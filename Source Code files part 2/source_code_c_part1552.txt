ine******************************\
* FLEX_STATE constructor
*
* Jul. 95 [marcfo]
*
\**************************************************************************/

FLEX_STATE::FLEX_STATE( STATE *pState )
{
    bTexture = pState->bTexture;
    Reset();
}

/**************************************************************************\
* Reset
*
* Reset a frame of normal pipes.
*
\**************************************************************************/

void 
FLEX_STATE::Reset( )
{
    // Choose a random scheme for each frame

    if( ss_iRand(2) )  // 50/50
        scheme = SC_EXTRUDED_XC;
    else
        scheme = SC_TURNOMANIA;
}

/**************************************************************************\
* OKToUseChase
*
* Determines if we can use chase mode for flex pipes
*
\**************************************************************************/

BOOL
FLEX_STATE::OKToUseChase( )
{
    return scheme != SC_TURNOMANIA;
}

/**************************************************************************\
* NewPipe
*
* Create a new pipe, based on current drawing scheme
*
\**************************************************************************/

PIPE*
FLEX_STATE::NewPipe( STATE *pState )
{
    if( scheme == SC_TURNOMANIA )
        return new TURNING_FLEX_PIPE( pState );
    else
        return new REGULAR_FLEX_PIPE( pState );
}

/**************************************************************************\
* GetMaxPipesPerFrame
*
\**************************************************************************/

int
FLEX_STATE::GetMaxPipesPerFrame( )
{
    if( scheme == SC_TURNOMANIA ) {
        return TURNOMANIA_PIPE_COUNT;
        if( bTexture )
            return TURNOMANIA_PIPE_COUNT / 2;
    } else {
        return bTexture ? NORMAL_TEX_PIPE_COUNT : NORMAL_PIPE_COUNT;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\fstate.h ===
/******************************Module*Header*******************************\
* Module Name: fstate.h
*
* FLEX_STATE
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#ifndef __fstate_h__
#define __fstate_h__

#include "sscommon.h"
#include "state.h"
#include "pipe.h"

class PIPE;
class STATE;

class FLEX_STATE {
public:
    int             scheme;         // current drawing scheme (right now this
                                    // is a per-frame thing)
    BOOL            bTexture;       // mf: repetition
    FLEX_STATE( STATE *pState );
    PIPE*           NewPipe( STATE *pState );
    void            Reset();
    BOOL            OKToUseChase();
    int             GetMaxPipesPerFrame();
};

#endif // __fstate_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\fpipe.h ===
/******************************Module*Header*******************************\
* Module Name: fpipe.h
*
* Flexy pipe stuff
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#ifndef __fpipe_h__
#define __fpipe_h__

#include "sscommon.h"
#include "sspipes.h"
#include "pipe.h"
#include "state.h"
#include "eval.h"
#include "xc.h"

// continuity types
enum {
    CONT_1 = 0,
    CONT_2
};

// cap types
enum {
    START_CAP = 0,
    END_CAP
};

#define CIRCUMFERENCE( r ) \
    ( 2.0f * PI * ((GLfloat) r) )

// drawing schemes
enum {
    SC_EXTRUDED_XC,
    SC_TURNOMANIA,
    SC_VARIABLE_XC,
    SC_COUNT
};

#define TURNOMANIA_PIPE_COUNT 10

/**************************************************************************\
*
* FLEX_PIPE class
*
* - Pipe has position and direction in node array
*
\**************************************************************************/

class FLEX_PIPE : public PIPE {
public:
    void        SetTexParams( TEXTURE *pTex, IPOINT2D *pTexRep );

protected:
    XC          *xcCur, *xcEnd;  // current xc, end xc
    EVAL        *pEval;
    GLfloat     zTrans;         // pos'n of pipe back along current dir,
                                // from current node
    FLEX_PIPE( STATE *state );
    ~FLEX_PIPE();
    void        ChooseXCProfile();
    void        DrawExtrudedXCObject( float length );
    void        DrawXCElbow( int newDir, float radius );
    void        DrawCap( int type );

private:
    int         nSlices;        // intended # of slices around an xc (based
                                // on tessLevel)
    int         tangent;        // current tangent at curXC (usually PLUS_Z)
    GLfloat     s_start, s_end;
    GLfloat     t_start, t_end;
    GLfloat     s_length;       // length in WC's of texture width
    GLfloat     evalDivSize;    // ~size in WC's of an eval division
    void        CalcEvalLengthParams( float length );
};

class REGULAR_FLEX_PIPE : public FLEX_PIPE {
public:
    float       turnFactorMin;  // describes degree of bend in an elbow
    float       turnFactorMax;  //  [0-1]

    REGULAR_FLEX_PIPE( STATE *state );
    void        Start();
    void        Draw();
};

class TURNING_FLEX_PIPE : public FLEX_PIPE {
public:
    TURNING_FLEX_PIPE( STATE *state );
    void        Start();
    void        Draw();
};

#endif // __fpipe_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\node.cxx ===
/******************************Module*Header*******************************\
* Module Name: node.cxx
*
* Pipes node array
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <sys/types.h>
#include <time.h>
#include <windows.h>

#include "sspipes.h"
#include "node.h"


/**************************************************************************\
*
* NODE_ARRAY constructor
*
\**************************************************************************/

NODE_ARRAY::NODE_ARRAY()
{
    nodes = NULL; // allocated on Resize

    numNodes.x = 0;
    numNodes.y = 0;
    numNodes.z = 0;
}

/**************************************************************************\
*
* NODE_ARRAY destructor
*
\**************************************************************************/

NODE_ARRAY::~NODE_ARRAY( )
{
    if( nodes )
        delete nodes;
}

/**************************************************************************\
*
* Resize
* 
\**************************************************************************/ 

void
NODE_ARRAY::Resize( IPOINT3D *pNewSize )
{
    if( (numNodes.x == pNewSize->x) &&
        (numNodes.y == pNewSize->y) &&
        (numNodes.z == pNewSize->z) )
        return;

    numNodes = *pNewSize;

    int elemCount = numNodes.x * numNodes.y * numNodes.z ;

    if( nodes )
        delete nodes;

    nodes = new Node[elemCount];

    SS_ASSERT( nodes, "NODE_ARRAY::Resize : can't alloc nodes\n" );

    // Reset the node states to empty

    int i;
    Node *pNode = nodes;
    for( i = 0; i < elemCount; i++, pNode++ )
        pNode->MarkAsEmpty();

    // precalculate direction offsets between nodes for speed
    nodeDirInc[PLUS_X] = 1;
    nodeDirInc[MINUS_X] = -1;
    nodeDirInc[PLUS_Y] = numNodes.x;
    nodeDirInc[MINUS_Y] = - nodeDirInc[PLUS_Y];
    nodeDirInc[PLUS_Z] = numNodes.x * numNodes.y;
    nodeDirInc[MINUS_Z] = - nodeDirInc[PLUS_Z];
}

/**************************************************************************\
*
* Reset
*
\**************************************************************************/

void
NODE_ARRAY::Reset( )
{
    int i;
    Node *pNode = nodes;

    // Reset the node states to empty
    for( i = 0; i < (numNodes.x)*(numNodes.y)*(numNodes.z); i++, pNode++ )
        pNode->MarkAsEmpty();
}

/**************************************************************************\
*
* GetNodeCount
*
\**************************************************************************/

void
NODE_ARRAY::GetNodeCount( IPOINT3D *count )
{
    *count = numNodes;
}

/**************************************************************************\
*
* ChooseRandomDirection
*
* Choose randomnly among the possible directions.  The likelyhood of going
* straight is controlled by weighting it.
*
\**************************************************************************/

int 
NODE_ARRAY::ChooseRandomDirection( IPOINT3D *pos, int dir, int weightStraight )
{
    Node *nNode[NUM_DIRS];
    int numEmpty, newDir;
    int choice;
    Node *straightNode = NULL;
    int emptyDirs[NUM_DIRS];

    SS_ASSERT( (dir >= 0) && (dir < NUM_DIRS), 
            "NODE_ARRAY::ChooseRandomDirection: invalid dir\n" );

    // Get the neigbouring nodes
    GetNeighbours( pos, nNode );

    // Get node in straight direction if necessary
    if( weightStraight && nNode[dir] && nNode[dir]->IsEmpty() ) {
        straightNode = nNode[dir];
        // if maximum weight, choose and return
        if( weightStraight == MAX_WEIGHT_STRAIGHT ) {
            straightNode->MarkAsTaken();
            return dir;
        }
    } else
        weightStraight = 0;

    // Get directions of possible turns
    numEmpty = GetEmptyTurnNeighbours( nNode, emptyDirs, dir );

    // Make a random choice
    if( (choice = (weightStraight + numEmpty)) == 0 )
        return DIR_NONE;
    choice = ss_iRand( choice );

    if( choice < weightStraight ) {
        straightNode->MarkAsTaken();
        return dir;
    } else {
        // choose one of the turns
        newDir = emptyDirs[choice - weightStraight];
        nNode[newDir]->MarkAsTaken();
        return newDir;
    }
}

/**************************************************************************\
*
* ChoosePreferredDirection
*
* Choose randomnly from one of the supplied preferred directions.  If none
* of these are available, then try and choose any empty direction
*
\**************************************************************************/

int 
NODE_ARRAY::ChoosePreferredDirection( IPOINT3D *pos, int dir, int *prefDirs,
                                      int nPrefDirs )
{
    Node *nNode[NUM_DIRS];
    int numEmpty, newDir;
    int emptyDirs[NUM_DIRS];
    int *pEmptyPrefDirs;
    int i, j;

    SS_ASSERT( (dir >= 0) && (dir < NUM_DIRS), 
            "NODE_ARRAY::ChoosePreferredDirection : invalid dir\n" );

    // Get the neigbouring nodes
    GetNeighbours( pos, nNode );

    // Create list of directions that are both preferred and empty

    pEmptyPrefDirs = emptyDirs;
    numEmpty = 0;

    for( i = 0, j = 0; (i < NUM_DIRS) && (j < nPrefDirs); i++ ) {
        if( i == *prefDirs ) {
            prefDirs++;
            j++;
            if( nNode[i] && nNode[i]->IsEmpty() ) {
                // add it to list
                *pEmptyPrefDirs++ = i;
                numEmpty++;
            }
        }
    }

    // if no empty preferred dirs, then any empty dirs become preferred
    
    if( !numEmpty ) {
        numEmpty = GetEmptyNeighbours( nNode, emptyDirs );
        if( numEmpty == 0 )
            return DIR_NONE;
    }
                
    // Pick a random dir from the empty set

    newDir = emptyDirs[ss_iRand( numEmpty )];
    nNode[newDir]->MarkAsTaken();
    return newDir;
}

/**************************************************************************\
*
* FindClearestDirection
*
* Finds the direction with the most empty nodes in a line 'searchRadius'
* long.  Does not mark any nodes as taken.
*
\**************************************************************************/

int 
NODE_ARRAY::FindClearestDirection( IPOINT3D *pos )
{
    static Node *neighbNode[NUM_DIRS];
    static int emptyDirs[NUM_DIRS];
    int nEmpty, newDir;
    int maxEmpty = 0;
    int searchRadius = 3;
    int count = 0;
    int i;

    // Get ptrs to neighbour nodes

    GetNeighbours( pos, neighbNode );

    // find empty nodes in each direction

    for( i = 0; i < NUM_DIRS; i ++ ) {
        if( neighbNode[i] && neighbNode[i]->IsEmpty() )
        {
            // find number of contiguous empty nodes along this direction
            nEmpty = GetEmptyNeighboursAlongDir( pos, i, searchRadius );
            if( nEmpty > maxEmpty ) {
                // we have a new winner
                count = 0;
                maxEmpty = nEmpty;
                emptyDirs[count++] = i;
            }
            else if( nEmpty == maxEmpty ) {
                // tied with current max
                emptyDirs[count++] = i;
            }
        }
    }

    if( count == 0 )
        return DIR_NONE;

    // randomnly choose a direction
    newDir = emptyDirs[ss_iRand( count )];

    return newDir;
}
/**************************************************************************\
*
* ChooseNewTurnDirection
*
* Choose a direction to turn
*
* This requires finding a pair of nodes to turn through.  The first node
* is in the direction of the turn from the current node, and the second node
* is at right angles to this at the end position.  The prim will not draw
* through the first node, but may sweep close to it, so we have to mark it
* as taken.
*
* - if next node is free, but there are no turns available, return
*   DIR_STRAIGHT, so the caller can decide what to do in this case
* - The turn possibilities are based on the orientation of the current xc, with
*   4 relative directions to seek turns in.
*
* History
*  Aug. 3, 95 : Marc Fortier [marcfo]
*    - Wrote it
*
\**************************************************************************/

int 
NODE_ARRAY::ChooseNewTurnDirection( IPOINT3D *pos, int dir )
{
    Node *nNode[NUM_DIRS];
    int turns[NUM_DIRS], nTurns;
    IPOINT3D nextPos;
    int numEmpty, newDir;
    Node *nextNode;

    SS_ASSERT( (dir >= 0) && (dir < NUM_DIRS), 
            "NODE_ARRAY::ChooseNewTurnDirection : invalid dir\n" );

    // First, check if next node along current dir is empty

    if( ! GetNextNodePos( pos, &nextPos, dir ) )
        return DIR_NONE; // node out of bounds or not empty

    // Ok, the next node is free - check the 4 possible turns from here

    nTurns = GetBestPossibleTurns( &nextPos, dir, turns );
    if( nTurns == 0 )
        return DIR_STRAIGHT; // nowhere to turn, but could go straight

    // randomnly choose one of the possible turns
    newDir = turns[ ss_iRand( nTurns ) ];

    SS_ASSERT( (newDir >= 0) && (newDir < NUM_DIRS), 
            "NODE_ARRAY::ChooseNewTurnDirection : invalid newDir\n" );


    // mark taken nodes

    nextNode = GetNode( &nextPos );
    nextNode->MarkAsTaken();

    nextNode = GetNextNode( &nextPos, newDir );

    nextNode->MarkAsTaken();

    return newDir;
}

/**************************************************************************\
*
* GetBestPossibleTurns
*
* From supplied direction and position, figure out which of 4 possible 
* directions are best to turn in.
*
* Turns that have the greatest number of empty nodes after the turn are the
* best, since a pipe is less likely to hit a dead end in this case.
* - We only check as far as 'searchRadius' nodes along each dir.
* - Return direction indices of best possible turns in turnDirs, and return 
*   count of these turns in fuction return value.
*
* History
*  Aug. 7, 95 : Marc Fortier [marcfo]
*    - Wrote it
*
\**************************************************************************/

int 
NODE_ARRAY::GetBestPossibleTurns( IPOINT3D *pos, int dir, int *turnDirs )
{
    Node *neighbNode[NUM_DIRS]; // ptrs to 6 neighbour nodes
    int i, count = 0;
    BOOL check[NUM_DIRS] = {TRUE, TRUE, TRUE, TRUE, TRUE, TRUE};
    int nEmpty, maxEmpty = 0;
    int searchRadius = 2;

    SS_ASSERT( (dir >= 0) && (dir < NUM_DIRS), 
            "NODE_ARRAY::GetBestPossibleTurns : invalid dir\n" );

    GetNeighbours( pos, neighbNode );

    switch( dir ) {
        case PLUS_X:    
        case MINUS_X:
            check[PLUS_X] = FALSE;
            check[MINUS_X] = FALSE;
            break;
        case PLUS_Y:    
        case MINUS_Y:
            check[PLUS_Y] = FALSE;
            check[MINUS_Y] = FALSE;
            break;
        case PLUS_Z:    
        case MINUS_Z:
            check[PLUS_Z] = FALSE;
            check[MINUS_Z] = FALSE;
            break;
    }

    // check approppriate directions
    for( i = 0; i < NUM_DIRS; i ++ ) {
        if( check[i] && neighbNode[i] && neighbNode[i]->IsEmpty() )
        {
            // find number of contiguous empty nodes along this direction
            nEmpty = GetEmptyNeighboursAlongDir( pos, i, searchRadius );
            if( nEmpty > maxEmpty ) {
                // we have a new winner
                count = 0;
                maxEmpty = nEmpty;
                turnDirs[count++] = i;
            }
            else if( nEmpty == maxEmpty ) {
                // tied with current max
                turnDirs[count++] = i;
            }
        }
    }

    return count;
}


/**************************************************************************\
*
* GetNeighbours
*
* Get neigbour nodes relative to supplied position
*
*       - get addresses of the neigbour nodes,
*         and put them in supplied matrix
*       - boundary hits are returned as NULL
*
\**************************************************************************/

void 
NODE_ARRAY::GetNeighbours( IPOINT3D *pos, Node **nNode )
{
    Node *centerNode = GetNode( pos );

    nNode[PLUS_X]  = pos->x == (numNodes.x - 1) ? NULL : 
                                            centerNode + nodeDirInc[PLUS_X];
    nNode[PLUS_Y]  = pos->y == (numNodes.y - 1) ? NULL :
                                            centerNode + nodeDirInc[PLUS_Y];
    nNode[PLUS_Z]  = pos->z == (numNodes.z - 1) ? NULL : 
                                            centerNode + nodeDirInc[PLUS_Z];

    nNode[MINUS_X] = pos->x == 0 ? NULL : centerNode + nodeDirInc[MINUS_X];
    nNode[MINUS_Y] = pos->y == 0 ? NULL : centerNode + nodeDirInc[MINUS_Y];
    nNode[MINUS_Z] = pos->z == 0 ? NULL : centerNode + nodeDirInc[MINUS_Z];
}


/**************************************************************************\
*
* NodeVisited
* 
* Mark the node as non-empty
* 
\**************************************************************************/

void 
NODE_ARRAY::NodeVisited( IPOINT3D *pos )
{
    (GetNode( pos ))->MarkAsTaken();
}

/**************************************************************************\
*
* GetNode
*
* Get ptr to node from position
*
\**************************************************************************/

Node *
NODE_ARRAY::GetNode( IPOINT3D *pos )
{
    return nodes +
           pos->x +
           pos->y * numNodes.x +
           pos->z * numNodes.x * numNodes.y;
}

/**************************************************************************\
*
* GetNextNode
*
* Get ptr to next node from pos and dir
*
\**************************************************************************/

Node *
NODE_ARRAY::GetNextNode( IPOINT3D *pos, int dir )
{
    Node *curNode = GetNode( pos );

    SS_ASSERT( (dir >= 0) && (dir < NUM_DIRS), 
            "NODE_ARRAY::GetNextNode : invalid dir\n" );

    switch( dir ) {
        case PLUS_X:
            return( pos->x == (numNodes.x - 1) ? NULL : 
                              curNode + nodeDirInc[PLUS_X]);
            break;
        case MINUS_X:
            return( pos->x == 0 ? NULL : 
                              curNode + nodeDirInc[MINUS_X]);
            break;
        case PLUS_Y:
            return( pos->y == (numNodes.y - 1) ? NULL : 
                              curNode + nodeDirInc[PLUS_Y]);
            break;
        case MINUS_Y:
            return( pos->y == 0 ? NULL : 
                              curNode + nodeDirInc[MINUS_Y]);
            break;
        case PLUS_Z:
            return( pos->z == (numNodes.z - 1) ? NULL : 
                              curNode + nodeDirInc[PLUS_Z]);
            break;
        case MINUS_Z:
            return( pos->z == 0 ? NULL : 
                              curNode + nodeDirInc[MINUS_Z]);
            break;
        default:
            return NULL;
    }
}


/**************************************************************************\
*
* GetNextNodePos
*
* Get position of next node from curPos and lastDir
*
* Returns FALSE if boundary hit or node empty
*
\**************************************************************************/

BOOL
NODE_ARRAY::GetNextNodePos( IPOINT3D *curPos, IPOINT3D *nextPos, int dir )
{
    static Node *neighbNode[NUM_DIRS]; // ptrs to 6 neighbour nodes

    SS_ASSERT( (dir >= 0) && (dir < NUM_DIRS), 
            "NODE_ARRAY::GetNextNodePos : invalid dir\n" );

//mf: don't need to get all neighbours, just one in next direction
    GetNeighbours( curPos, neighbNode );

    *nextPos = *curPos;

    // bail if boundary hit or node not empty
    if( (neighbNode[dir] == NULL) || !neighbNode[dir]->IsEmpty() )
        return FALSE;

    switch( dir ) {
        case PLUS_X:
            nextPos->x = curPos->x + 1;
            break;

        case MINUS_X:
            nextPos->x = curPos->x - 1;
            break;

        case PLUS_Y:
            nextPos->y = curPos->y + 1;
            break;

        case MINUS_Y:
            nextPos->y = curPos->y - 1;
            break;

        case PLUS_Z:
            nextPos->z = curPos->z + 1;
            break;

        case MINUS_Z:
            nextPos->z = curPos->z - 1;
            break;
    }

    return TRUE;
}


/**************************************************************************\
*             
*    GetEmptyNeighbours()
*       - get list of direction indices of empty node neighbours,
*         and put them in supplied matrix
*       - return number of empty node neighbours
*
\**************************************************************************/

int 
NODE_ARRAY::GetEmptyNeighbours( Node **nNode, int *nEmpty )
{
    int i, count = 0;

    for( i = 0; i < NUM_DIRS; i ++ ) {
        if( nNode[i] && nNode[i]->IsEmpty() )
            nEmpty[count++] = i;
    }
    return count;
}

/**************************************************************************\
*             
*    GetEmptyTurnNeighbours()
*       - get list of direction indices of empty node neighbours,
*         and put them in supplied matrix
*       - don't include going straight
*       - return number of empty node neighbours
*
\**************************************************************************/

int 
NODE_ARRAY::GetEmptyTurnNeighbours( Node **nNode, int *nEmpty, int lastDir )
{
    int i, count = 0;

    for( i = 0; i < NUM_DIRS; i ++ ) {
        if( nNode[i] && nNode[i]->IsEmpty() ) {
            if( i == lastDir )
                continue;
            nEmpty[count++] = i;
        }
    }
    return count;
}

/**************************************************************************\
* GetEmptyNeighboursAlongDir
*
* Sort of like above, but just gets one neigbour according to supplied dir
*
* Given a position and direction, find out how many contiguous empty nodes 
* there are in that direction.
* - Can limit search with searchRadius parameter
* - Return contiguous empty node count
*
* History
*  Aug. 12, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

int
NODE_ARRAY::GetEmptyNeighboursAlongDir( IPOINT3D *pos, int dir,
                            int searchRadius )
{
    Node *curNode = GetNode( pos );
    int nodeStride;
    int maxSearch;
    int count = 0;

    SS_ASSERT( (dir >= 0) && (dir < NUM_DIRS), 
            "NODE_ARRAY::GetEmptyNeighboursAlongDir : invalid dir\n" );

    nodeStride = nodeDirInc[dir];

    switch( dir ) {
        case PLUS_X:    
            maxSearch = numNodes.x - pos->x - 1;
            break;
        case MINUS_X:
            maxSearch = pos->x;
            break;
        case PLUS_Y:    
            maxSearch = numNodes.y - pos->y - 1;
            break;
        case MINUS_Y:
            maxSearch = pos->y;
            break;
        case PLUS_Z:    
            maxSearch = numNodes.z - pos->z - 1;
            break;
        case MINUS_Z:
            maxSearch = pos->z;
            break;
    }
    
    if( searchRadius > maxSearch )
        searchRadius = maxSearch;

    if( !searchRadius )
        return 0;

    while( searchRadius-- ) {
        curNode += nodeStride;
        if( ! curNode->IsEmpty() )
            return count;
        count++;
    }
    return count;
}

/**************************************************************************\
* FindRandomEmptyNode
*
* - Search for an empty node to start drawing
* - Return position of empty node in supplied pos ptr
* - Returns FALSE if couldn't find a node
* - Marks node as taken (mf: renam fn to ChooseEmptyNode ?
*
* History
*  July 19, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

// If random search takes longer than twice the total number
// of nodes, give up the random search.  There may not be any
// empty nodes.

#define INFINITE_LOOP   (2 * NUM_NODE * NUM_NODE * NUM_NODE)

BOOL
NODE_ARRAY::FindRandomEmptyNode( IPOINT3D *pos )
{
    int infLoopDetect = 0;

    while( TRUE ) {

        // Pick a random node.

        pos->x = ss_iRand( numNodes.x );
        pos->y = ss_iRand( numNodes.y );
        pos->z = ss_iRand( numNodes.z );

        // If its empty, we're done.

        if( GetNode(pos)->IsEmpty() ) {
            NodeVisited( pos );
            return TRUE;
        } else {
            // Watch out for infinite loops!  After trying for
            // awhile, give up on the random search and look
            // for the first empty node.

            if ( infLoopDetect++ > INFINITE_LOOP ) {

                // Search for first empty node.

                for ( pos->x = 0; pos->x < numNodes.x; pos->x++ )
                    for ( pos->y = 0; pos->y < numNodes.y; pos->y++ )
                        for ( pos->z = 0; pos->z < numNodes.z; pos->z++ )
                            if( GetNode(pos)->IsEmpty() ) {
                                NodeVisited( pos );
                                return TRUE;
                            }

                // There are no more empty nodes.
                // Reset the pipes and exit.

                return FALSE;
            }
        }
    }
}

/**************************************************************************\
* FindRandomEmptyNode2D
*
* - Like FindRandomEmptyNode, but limits search to a 2d plane of the supplied
*   box.
*
\**************************************************************************/

#define INFINITE_LOOP   (2 * NUM_NODE * NUM_NODE * NUM_NODE)
#define MIN_VAL 1
#define MAX_VAL 0

BOOL
NODE_ARRAY::FindRandomEmptyNode2D( IPOINT3D *pos, int plane, int *box )
{
    int *newx, *newy;
    int *xDim, *yDim;

    switch( plane ) {
        case PLUS_X:
        case MINUS_X:
            pos->x = box[plane];
            newx = &pos->z;
            newy = &pos->y;
            xDim = &box[PLUS_Z]; 
            yDim = &box[PLUS_Y]; 
            break;
        case PLUS_Y:
        case MINUS_Y:
            pos->y = box[plane];
            newx = &pos->x;
            newy = &pos->z;
            xDim = &box[PLUS_X]; 
            yDim = &box[PLUS_Z]; 
            break;
        case PLUS_Z:
        case MINUS_Z:
            newx = &pos->x;
            newy = &pos->y;
            pos->z = box[plane];
            xDim = &box[PLUS_X]; 
            yDim = &box[PLUS_Y]; 
            break;
    }

    int infLoop = 2 * (xDim[MAX_VAL] - xDim[MIN_VAL] + 1) *
                      (yDim[MAX_VAL] - yDim[MIN_VAL] + 1);
    int infLoopDetect = 0;

    while( TRUE ) {

        // Pick a random node.

        *newx = ss_iRand2( xDim[MIN_VAL], xDim[MAX_VAL] );
        *newy = ss_iRand2( yDim[MIN_VAL], yDim[MAX_VAL] );

        // If its empty, we're done.

        if( GetNode(pos)->IsEmpty() ) {
            NodeVisited( pos );
            return TRUE;
        } else {
            // Watch out for infinite loops!  After trying for
            // awhile, give up on the random search and look
            // for the first empty node.

            if ( ++infLoopDetect > infLoop ) {

                // Do linear search for first empty node.

                for ( *newx = xDim[MIN_VAL]; *newx <= xDim[MAX_VAL]; (*newx)++ )
                    for ( *newy = yDim[MIN_VAL]; *newy <= yDim[MAX_VAL]; (*newy)++ )
                        if( GetNode(pos)->IsEmpty() ) {
                            NodeVisited( pos );
                            return TRUE;
                        }

                // There are no empty nodes in this plane.
                return FALSE;
            }
        }
    }
}

/**************************************************************************\
* TakeClosestEmptyNode
*
* - Search for an empty node closest to supplied node position
* - Returns FALSE if couldn't find a node
* - Marks node as taken
* - mf: not completely opimized - if when dilating the box, a side gets
*   clamped against the node array, this side will continue to be searched
*
* History
*  Dec 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

static void
DilateBox( int *box, IPOINT3D *bounds );

BOOL
NODE_ARRAY::TakeClosestEmptyNode( IPOINT3D *newPos, IPOINT3D *pos )
{
    static int searchRadius = SS_MAX( numNodes.x, numNodes.y ) / 3;

    // easy out
    if( GetNode(pos)->IsEmpty() ) {
        NodeVisited( pos );
        *newPos = *pos;
        return TRUE;
    }

    int box[NUM_DIRS] = {pos->x, pos->x, pos->y, pos->y, pos->z, pos->z};
    int clip[NUM_DIRS] = {0};

    // do a random search on successively larger search boxes
    for( int i = 0; i < searchRadius; i++ ) {
        // Increase box size
        DilateBox( box, &numNodes );
        // start looking in random 2D face of the box
        int dir = ss_iRand( NUM_DIRS );
        for( int j = 0; j < NUM_DIRS; j++, dir = (++dir == NUM_DIRS) ? 0 : dir ) {
            if( FindRandomEmptyNode2D( newPos, dir, box ) )
                return TRUE;
        }
    }

    // nothing nearby - grab a random one
    return FindRandomEmptyNode( newPos );
}

/**************************************************************************\
* DilateBox
*
* - Increase box radius without exceeding bounds
*
\**************************************************************************/

static void
DilateBox( int *box, IPOINT3D *bounds )
{
    int *min = (int *) &box[MINUS_X];
    int *max = (int *) &box[PLUS_X];
    int *boundMax = (int *) bounds;
    // boundMin always 0

    for( int i = 0; i < 3; i ++, min+=2, max+=2, boundMax++ ) {
        if( *min > 0 )
            (*min)--;
        if( *max < (*boundMax - 1) )
            (*max)++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\node.h ===
/******************************Module*Header*******************************\
* Module Name: node.h
*
* Node stuff
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#ifndef __node_h__
#define __node_h__

#include "sscommon.h"
#include "sspipes.h"

#define NUM_NODE (NUM_DIV - 1)  // num nodes in longest dimension

// maximum weighting of going straight for direction choosing functions
#define MAX_WEIGHT_STRAIGHT 100

// Node class

class Node {
public:
    void        MarkAsTaken() { empty = FALSE; }
    void        MarkAsEmpty() { empty = TRUE; }
    BOOL        IsEmpty() { return empty; }
private:
    GLboolean   empty;
};

/**************************************************************************\
*
* Node array class
*
* - 3d array of nodes
* - Functions to access node neighbours, query if taken or not, etc. 
* - Not only is this the node array, but a set of methods that operates on it
*
\**************************************************************************/

class NODE_ARRAY {
public:
    NODE_ARRAY();
    ~NODE_ARRAY();
    void        Resize( IPOINT3D *pNewSize ); // new array size
    void        Reset();       // set all nodes to empty
    int         ChooseRandomDirection( IPOINT3D *pos, int dir, int weight );
    int         ChoosePreferredDirection( IPOINT3D *pos, int dir, int *prefDirs,
                                          int nPrefDirs );
    int         ChooseNewTurnDirection( IPOINT3D *pos, int dir );
    int         FindClearestDirection( IPOINT3D *pos );
    int         GetBestPossibleTurns( IPOINT3D *pos, int dir, int *turnDirs );
    BOOL        FindRandomEmptyNode( IPOINT3D *ip3dEmpty );
    BOOL        FindRandomEmptyNode2D( IPOINT3D *pos, int plane, int *box );
    BOOL        TakeClosestEmptyNode( IPOINT3D *newPos, IPOINT3D *pos );
    void        NodeVisited( IPOINT3D *pos );
    void        GetNodeCount( IPOINT3D *pos );
private:
    Node        *nodes;         // ptr to node array
    int         lock;          // semaphore lock for >1 drawing pipes
    IPOINT3D    numNodes;      // x,y,z dimensions of node array
    int         nodeDirInc[NUM_DIRS]; // array offset between nodes for each dir
    void        GetNeighbours( IPOINT3D *pos, Node **nNode );
    Node*       GetNode( IPOINT3D *pos );
    Node*       GetNextNode( IPOINT3D *pos, int dir );
    BOOL        GetNextNodePos( IPOINT3D *curPos, IPOINT3D *nextPos, int dir );
    int         GetEmptyNeighbours( Node **nNode, int *nEmpty ); 
    int         GetEmptyTurnNeighbours( Node **nNode, int *nEmpty, int lastDir ); 
    int         GetEmptyNeighboursAlongDir( IPOINT3D *pos, int dir,
                                    int searchRadius );
};

#endif // __node_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\npipe.h ===
/******************************Module*Header*******************************\
* Module Name: npipe.h
*
* Node stuff
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#ifndef __npipe_h__
#define __npipe_h__

#include "sscommon.h"
#include "state.h"
#include "pipe.h"

class NORMAL_STATE;

class NORMAL_PIPE: public PIPE {
private:
public:
    NORMAL_STATE      *pNState;

    NORMAL_PIPE( STATE *state );
    void        Start();
    GLint       ChooseElbow( int oldDir, int newDir);
    void        DrawJoint( int newDir );
    void        Draw( ); //mf: could take param to draw n sections
    void        DrawStartCap( int newDir );
    void        DrawEndCap();
};

#endif // __npipe_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\npipe.cxx ===
/******************************Module*Header*******************************\
* Module Name: npipe.cxx
*
* Normal pipes code
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <sys/types.h>
#include <sys/timeb.h>
#include <time.h>
#include <windows.h>

#include "sspipes.h"
#include "npipe.h"
#include "state.h"


static void align_notch( int newDir, int notch );
static void align_plusy( int oldDir, int newDir );

// defCylNotch shows where the notch for the default cylinder will be,
//  in absolute coords, once we do an align_plusz

static GLint defCylNotch[NUM_DIRS] = 
        { PLUS_Y, PLUS_Y, MINUS_Z, PLUS_Z, PLUS_Y, PLUS_Y };


/**************************************************************************\
* NORMAL_PIPE constructor
*
*
\**************************************************************************/

NORMAL_PIPE::NORMAL_PIPE( STATE *pState )
: PIPE( pState )
{
    int choice;

    type = TYPE_NORMAL;
    pNState = pState->pNState;

    // choose weighting of going straight
    if( ! ss_iRand( 20 ) )
        weightStraight = ss_iRand2( MAX_WEIGHT_STRAIGHT/4, MAX_WEIGHT_STRAIGHT );
    else
        weightStraight = 1 + ss_iRand( 4 );
}

/**************************************************************************\
* Start
*
* Start drawing a new normal pipe
*
* - Draw a start cap and short pipe in new direction
*
* History
*  July 27, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

void
NORMAL_PIPE::Start( )
{
    int newDir;

    // Set start position

    if( !SetStartPos() ) {
        status = PIPE_OUT_OF_NODES;
        return;
    }

    // set a material

    ChooseMaterial();

    // push matrix that has initial zTrans and rotation
    glPushMatrix();

    // Translate to current position
    TranslateToCurrentPosition();

    // Pick a random lastDir
    lastDir = ss_iRand( NUM_DIRS );

    newDir = ChooseNewDirection();

    if( newDir == DIR_NONE ) {
        // pipe is stuck at the start node, draw something
        status = PIPE_STUCK;
        DrawTeapot();
        glPopMatrix();
        return;
    } else
        status = PIPE_ACTIVE;

    // set initial notch vector
    notchVec = defCylNotch[newDir];

    DrawStartCap( newDir );

    // move ahead 1.0*r to draw pipe
    glTranslatef( 0.0f, 0.0f, radius );
            
    // draw short pipe
    align_notch( newDir, notchVec );
    pNState->shortPipe->Draw();

    glPopMatrix();

    UpdateCurrentPosition( newDir );

    lastDir = newDir;
}

/**************************************************************************\
* Draw
*
* - if turning, draws a joint and a short cylinder, otherwise
*   draws a long cylinder.
* - the 'current node' is set as the one we draw thru the NEXT
*   time around.
*
\**************************************************************************/

void
NORMAL_PIPE::Draw()
{
    int newDir;

    newDir = ChooseNewDirection();

    if( newDir == DIR_NONE ) {  // no empty nodes - nowhere to go
        DrawEndCap();
        status = PIPE_STUCK;
        return;
    }

    // push matrix that has initial zTrans and rotation
    glPushMatrix();

    // Translate to current position
    TranslateToCurrentPosition();

    // draw joint if necessary, and pipe

    if( newDir != lastDir ) { // turning! - we have to draw joint
        DrawJoint( newDir );

        // draw short pipe
        align_notch( newDir, notchVec );
        pNState->shortPipe->Draw();
    }
    else {  // no turn
        // draw long pipe, from point 1.0*r back
        align_plusz( newDir );
        align_notch( newDir, notchVec );
        glTranslatef( 0.0f, 0.0f, -radius );
        pNState->longPipe->Draw();
    }

    glPopMatrix();

    UpdateCurrentPosition( newDir );

    lastDir = newDir;
}

/**************************************************************************\
* DrawStartCap
*
* Cap the start of the pipe with a ball
*
* History
*  July 4, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

void 
NORMAL_PIPE::DrawStartCap( int newDir )
{
    if( bTexture ) {
        align_plusz( newDir );
        pNState->ballCap->Draw();
    }
    else {
        // draw big ball in default orientation
        pNState->bigBall->Draw();
        align_plusz( newDir );
    }
}

/**************************************************************************\
* DrawEndCap():
*
* - Draws a ball, used to cap end of a pipe
*
\**************************************************************************/

void 
NORMAL_PIPE::DrawEndCap( )
{
    glPushMatrix();

    // Translate to current position
    TranslateToCurrentPosition();

    if( bTexture ) {
        glPushMatrix();
        align_plusz( lastDir );
        align_notch( lastDir, notchVec );
        pNState->ballCap->Draw();
        glPopMatrix();
    }
    else
        pNState->bigBall->Draw();

    glPopMatrix();
}

/**************************************************************************\
* ChooseElbow
*
* - Decides which elbow to draw
* - The beginning of each elbow is aligned along +y, and we have
*   to choose the one with the notch in correct position
* - The 'primary' start notch (elbow[0]) is in same direction as
*   newDir, and successive elbows rotate this notch CCW around +y
*
\**************************************************************************/


// this array supplies the sequence of elbow notch vectors, given
//  oldDir and newDir  (0's are don't cares)
// it is also used to determine the ending notch of an elbow
static GLint notchElbDir[NUM_DIRS][NUM_DIRS][4] = {
// oldDir = +x
        iXX,            iXX,            iXX,            iXX,
        iXX,            iXX,            iXX,            iXX,
        PLUS_Y,         MINUS_Z,        MINUS_Y,        PLUS_Z,
        MINUS_Y,        PLUS_Z,         PLUS_Y,         MINUS_Z,
        PLUS_Z,         PLUS_Y,         MINUS_Z,        MINUS_Y,
        MINUS_Z,        MINUS_Y,        PLUS_Z,         PLUS_Y,
// oldDir = -x
        iXX,            iXX,            iXX,            iXX,
        iXX,            iXX,            iXX,            iXX,
        PLUS_Y,         PLUS_Z,         MINUS_Y,        MINUS_Z,
        MINUS_Y,        MINUS_Z,        PLUS_Y,         PLUS_Z,
        PLUS_Z,         MINUS_Y,        MINUS_Z,        PLUS_Y,
        MINUS_Z,        PLUS_Y,         PLUS_Z,         MINUS_Y,
// oldDir = +y
        PLUS_X,         PLUS_Z,         MINUS_X,        MINUS_Z,
        MINUS_X,        MINUS_Z,        PLUS_X,         PLUS_Z,
        iXX,            iXX,            iXX,            iXX,
        iXX,            iXX,            iXX,            iXX,
        PLUS_Z,         MINUS_X,        MINUS_Z,        PLUS_X,
        MINUS_Z,        PLUS_X,         PLUS_Z,         MINUS_X,
// oldDir = -y
        PLUS_X,         MINUS_Z,        MINUS_X,        PLUS_Z,
        MINUS_X,        PLUS_Z,         PLUS_X,         MINUS_Z,
        iXX,            iXX,            iXX,            iXX,
        iXX,            iXX,            iXX,            iXX,
        PLUS_Z,         PLUS_X,         MINUS_Z,        MINUS_X,
        MINUS_Z,        MINUS_X,        PLUS_Z,         PLUS_X,
// oldDir = +z
        PLUS_X,         MINUS_Y,        MINUS_X,        PLUS_Y,
        MINUS_X,        PLUS_Y,         PLUS_X,         MINUS_Y,
        PLUS_Y,         PLUS_X,         MINUS_Y,        MINUS_X,
        MINUS_Y,        MINUS_X,        PLUS_Y,         PLUS_X,
        iXX,            iXX,            iXX,            iXX,
        iXX,            iXX,            iXX,            iXX,
// oldDir = -z
        PLUS_X,         PLUS_Y,         MINUS_X,        MINUS_Y,
        MINUS_X,        MINUS_Y,        PLUS_X,         PLUS_Y,
        PLUS_Y,         MINUS_X,        MINUS_Y,        PLUS_X,
        MINUS_Y,        PLUS_X,         PLUS_Y,         MINUS_X,
        iXX,            iXX,            iXX,            iXX,
        iXX,            iXX,            iXX,            iXX
};

GLint 
NORMAL_PIPE::ChooseElbow( int oldDir, int newDir )
{
    int i;

    // precomputed table supplies correct elbow orientation
    for( i = 0; i < 4; i ++ ) {
        if( notchElbDir[oldDir][newDir][i] == notchVec )
            return i;
    }
    // we shouldn't arrive here
    return -1;
}

/**************************************************************************\
* DrawJoint
*
* Draw a joint between 2 pipes
*
* History
*  Apr. 28, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

void
NORMAL_PIPE::DrawJoint( int newDir )
{
    int jointType;
    int iBend;

    jointType = pNState->ChooseJointType();
#if PIPES_DEBUG
    if( newDir == oppositeDir[lastDir] )
        printf( "Warning: opposite dir chosen!\n" );
#endif
        
    switch( jointType ) {
      case BALL_JOINT:
            if( bTexture ) {
                // use special texture-friendly ballJoints

                align_plusz( newDir );
                glPushMatrix();

                align_plusy( lastDir, newDir );

                // translate forward 1.0*r along +z to get set for drawing elbow
                glTranslatef( 0.0f, 0.0f, radius );
                // decide which elbow orientation to use
                iBend = ChooseElbow( lastDir, newDir );
                pNState->ballJoints[iBend]->Draw();

                glPopMatrix();
            }
            else {
                // draw big ball in default orientation
                pNState->bigBall->Draw();
                align_plusz( newDir );
            }
            // move ahead 1.0*r to draw pipe
            glTranslatef( 0.0f, 0.0f, radius );
        break;

      case ELBOW_JOINT:
            align_plusz( newDir );

            // the align_plusy() here will mess up our notch calcs, so
            //  we push-pop

            glPushMatrix();

            align_plusy( lastDir, newDir );

            // translate forward 1.0*r along +z to get set for drawing elbow
            glTranslatef( 0.0f, 0.0f, radius );
            // decide which elbow orientation to use
            iBend = ChooseElbow( lastDir, newDir );
            if( iBend == -1 ) {
#if PIPES_DEBUG
                printf( "ChooseElbow() screwed up\n" );
#endif
                iBend = 0; // recover
            }
            pNState->elbows[iBend]->Draw();

            glPopMatrix();

            glTranslatef( 0.0f, 0.0f, radius );
        break;

      default:
            // Horrors! It's the teapot!
            DrawTeapot();
            align_plusz( newDir );
            // move ahead 1.0*r to draw pipe
            glTranslatef( 0.0f, 0.0f, radius );
        }
            
        // update the current notch vector
        notchVec = notchTurn[lastDir][newDir][notchVec];
#if PIPES_DEBUG
        if( notchVec == iXX )
            printf( "notchTurn gave bad value\n" );
#endif
}


/**************************************************************************\
* Geometry functions
\**************************************************************************/


static float RotZ[NUM_DIRS][NUM_DIRS] = {
          0.0f,   0.0f,  90.0f,  90.0f,  90.0f, -90.0f,
          0.0f,   0.0f, -90.0f, -90.0f, -90.0f,  90.0f,
        180.0f, 180.0f,   0.0f,   0.0f, 180.0f, 180.0f,
          0.0f,   0.0f,   0.0f,   0.0f,   0.0f,   0.0f,
        -90.0f,  90.0f,   0.0f, 180.0f,   0.0f,   0.0f,
         90.0f, -90.0f, 180.0f,   0.0f,   0.0f,   0.0f };

        
            
/*-----------------------------------------------------------------------
|                                                                       |
|    align_plusy( int lastDir, int newDir )                             |
|       - Assuming +z axis is already aligned with newDir, align        |
|         +y axis BACK along lastDir                                    |
|                                                                       |
-----------------------------------------------------------------------*/

static void 
align_plusy( int oldDir, int newDir )
{
    GLfloat rotz;

    rotz = RotZ[oldDir][newDir];
    glRotatef( rotz, 0.0f, 0.0f, 1.0f );
}

// given a dir, determine how much to rotate cylinder around z to match notches
// format is [newDir][notchVec]

static GLfloat alignNotchRot[NUM_DIRS][NUM_DIRS] = {
        fXX,    fXX,    0.0f,   180.0f,  90.0f, -90.0f,
        fXX,    fXX,    0.0f,   180.0f,  -90.0f, 90.0f,
        -90.0f, 90.0f,  fXX,    fXX,    180.0f, 0.0f,
        -90.0f, 90.0f,  fXX,    fXX,    0.0f,   180.0f,
        -90.0f, 90.0f,  0.0f,   180.0f, fXX,    fXX,
        90.0f,  -90.0f, 0.0f,   180.0f, fXX,    fXX
};
                
                
/*-----------------------------------------------------------------------
|                                                                       |
|    align_notch( int newDir )                                          |
|       - a cylinder is notched, and we have to line this up            |
|         with the previous primitive's notch which is maintained as    |
|         notchVec.                                                     |
|       - this adds a rotation around z to achieve this                 |
|                                                                       |
-----------------------------------------------------------------------*/

static void 
align_notch( int newDir, int notch )
{
    GLfloat rotz;
    GLint curNotch;

    // figure out where notch is presently after +z alignment
    curNotch = defCylNotch[newDir];
    // (don't need this now we have lut)

    // look up rotation value in table
    rotz = alignNotchRot[newDir][notch];
#if PIPES_DEBUG
    if( rotz == fXX ) {
        printf( "align_notch(): unexpected value\n" );
        return;
    }
#endif

    if( rotz != 0.0f )
        glRotatef( rotz, 0.0f, 0.0f, 1.0f );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\nstate.cxx ===
/******************************Module*Header*******************************\
* Module Name: nstate.cxx
*
* NORMAL_STATE
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <sys/types.h>
#include <sys/timeb.h>
#include <time.h>
#include <windows.h>

#include "sspipes.h"
#include "nstate.h"
#include "objects.h"
#include "dialog.h"

/******************************Public*Routine******************************\
* NORMAL_STATE constructor
*
* Jul. 95 [marcfo]
*
\**************************************************************************/

NORMAL_STATE::NORMAL_STATE( STATE *pState )
{
    // init joint types from dialog settings

    bCycleJointStyles = 0;

    switch( ulJointType ) {
        case JOINT_ELBOW:
            jointStyle = ELBOWS;
            break;
        case JOINT_BALL:
            jointStyle = BALLS;
            break;
        case JOINT_MIXED:
            jointStyle = EITHER;
            break;
        case JOINT_CYCLE:
            bCycleJointStyles = 1;
            jointStyle = EITHER;
            break;
        default:
            break;
    }

    // Build the objects

    BuildObjects( pState->radius, pState->view.divSize, pState->nSlices,
                  pState->bTexture, &pState->texRep[0] );
}

/******************************Public*Routine******************************\
* NORMAL_STATE destructor
*
* Some of the objects are always created, so don't have to check if they
* exist. Others may be NULL.
\**************************************************************************/

NORMAL_STATE::~NORMAL_STATE( )
{
    delete shortPipe;
    delete longPipe;
    delete ballCap;

    for( int i = 0; i < 4; i ++ ) {
        delete elbows[i];
        if( ballJoints[i] )
            delete ballJoints[i];
    }

    if( bigBall )
        delete bigBall;
}



/**************************************************************************\
* BuildObjects
*
* - Build all the pipe primitives
* - Different prims are built based on bTexture flag
*
\**************************************************************************/
void 
NORMAL_STATE::BuildObjects( float radius, float divSize, int nSlices, 
                            BOOL bTexture, IPOINT2D *texRep )
{
    OBJECT_BUILD_INFO *pBuildInfo = new OBJECT_BUILD_INFO;
    pBuildInfo->radius = radius;
    pBuildInfo->divSize = divSize;
    pBuildInfo->nSlices = nSlices;
    pBuildInfo->bTexture = bTexture;

    if( bTexture ) {
        pBuildInfo->texRep = texRep;
        
        // Calc s texture intersection values
        float s_max = (float) texRep->y;
        float s_trans =  s_max * 2.0f * radius / divSize;

        // Build short and long pipes
        shortPipe = new PIPE_OBJECT( pBuildInfo, divSize - 2*radius,
                                     s_trans, s_max );
        longPipe = new PIPE_OBJECT( pBuildInfo, divSize, 0.0f, s_max );

        // Build elbow and ball joints
        for( int i = 0; i < 4; i ++ ) {
            elbows[i] = new ELBOW_OBJECT( pBuildInfo, i, 0.0f, s_trans );
            ballJoints[i] = new BALLJOINT_OBJECT( pBuildInfo, i, 0.0f, s_trans );
        }

        bigBall = NULL;

        // Build end cap

        float s_start = - texRep->x * (ROOT_TWO - 1.0f) * radius / divSize;
        float s_end = texRep->x * (2.0f + (ROOT_TWO - 1.0f)) * radius / divSize;
        // calc compensation value, to prevent negative s coords
        float comp_s = (int) ( - s_start ) + 1.0f;
        s_start += comp_s;
        s_end += comp_s;
        ballCap = new SPHERE_OBJECT( pBuildInfo, ROOT_TWO*radius, s_start, s_end );

    } else {
        // Build pipes, elbows
        shortPipe = new PIPE_OBJECT( pBuildInfo, divSize - 2*radius );
        longPipe = new PIPE_OBJECT( pBuildInfo, divSize );
        for( int i = 0; i < 4; i ++ ) {
            elbows[i] = new ELBOW_OBJECT( pBuildInfo, i );
            ballJoints[i] = NULL;
        }

        // Build just one ball joint when not texturing.  It is slightly
        // larger than standard ball joint, to prevent any pipe edges from
        // 'sticking' out of the ball.
        bigBall = new SPHERE_OBJECT( pBuildInfo,  
                     ROOT_TWO*radius / ((float) cos(PI/nSlices)) );

        // build end cap
        ballCap = new SPHERE_OBJECT( pBuildInfo, ROOT_TWO*radius );
    }
}

/**************************************************************************\
* Reset
*
* Reset frame attributes for normal pipes.
*
\**************************************************************************/

void 
NORMAL_STATE::Reset( )
{
    // Set the joint style
    if( bCycleJointStyles ) {
        if( ++(jointStyle) >= NUM_JOINT_STYLES )
            jointStyle = 0;
    }
}

#if 0
/**************************************************************************\
* GetMaxPipesPerFrame
*
\**************************************************************************/

int
NORMAL_STATE::GetMaxPipesPerFrame( )
{
    if( bTexture )
        return NORMAL_TEX_PIPE_COUNT;
    else
        return NORMAL_PIPE_COUNT;
}
#endif

/*-----------------------------------------------------------------------
|                                                                       |
|    ChooseJointType                                                    |
|       - Decides which type of joint to draw                           |
|                                                                       |
-----------------------------------------------------------------------*/

#define BLUE_MOON 153

int 
NORMAL_STATE::ChooseJointType( )
{
    switch( jointStyle ) {
        case ELBOWS:
            return ELBOW_JOINT;
        case BALLS:
            return BALL_JOINT;
        case EITHER:
            // draw a teapot once in a blue moon
            if( ss_iRand(1000) == BLUE_MOON )
                return( TEAPOT );
        default:
            // otherwise an elbow or a ball (1/3 ball)
            if( !ss_iRand(3) )
                return BALL_JOINT;
            else
                return ELBOW_JOINT;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\nstate.h ===
/******************************Module*Header*******************************\
* Module Name: nstate.h
*
* NORMAL_STATE
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#ifndef __nstate_h__
#define __nstate_h__

#include "sscommon.h"
#include "objects.h"
#include "state.h"

#define NORMAL_PIPE_COUNT       5
#define NORMAL_TEX_PIPE_COUNT   3

#define NUM_JOINT_STYLES        3


// styles for pipe joints
enum {
    ELBOWS = 0,
    BALLS,
    EITHER
};

// joint types
enum {
    ELBOW_JOINT = 0,
    BALL_JOINT
};

// shchemes for choosing directions
enum {
    NORMAL_SCHEME_CHOOSE_DIR_RANDOM,
    NORMAL_SCHEME_CHOOSE_DIR_TURN,
    NORMAL_SCHEME_CHOOSE_DIR_STRAIGHT
};

// this used for traditional pipe drawing

class PIPE_OBJECT;
class ELBOW_OBJECT;
class SPHERE_OBJECT;
class BALLJOINT_OBJECT;

class STATE;

#if 0
struct _OBJECT_SET {
public:
    PIPE_OBJECT     *shortPipe;
    PIPE_OBJECT     *longPipe;
    ELBOW_OBJECT    *elbows[4];
    SPHERE_OBJECT   *ballCap;
    SPHERE_OBJECT   *bigBall;
    BALLJOINT_OBJECT  *ballJoints[4];
} OBJECT_SET;
#endif

class NORMAL_STATE {
public:
    int             jointStyle;
    int             bCycleJointStyles;
    
    PIPE_OBJECT     *shortPipe;
    PIPE_OBJECT     *longPipe;
    ELBOW_OBJECT    *elbows[4];
    SPHERE_OBJECT   *ballCap;
    SPHERE_OBJECT   *bigBall;
    BALLJOINT_OBJECT  *ballJoints[4];

    NORMAL_STATE( STATE *pState );
    ~NORMAL_STATE();
    void            Reset();
//    int             GetMaxPipesPerFrame();
    void            BuildObjects( float radius, float divSize, int nSlices,
                                  BOOL bTexture, IPOINT2D *pTexRep );  
    int             ChooseJointType();
};

#endif // __nstate_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\objects.cxx ===
/******************************Module*Header*******************************\
* Module Name: objects.cxx
*
* Creates command lists for pipe primitive objects
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <windows.h>
#include <GL/gl.h>
#include "sscommon.h"
#include "objects.h"
#include "sspipes.h"

#define ROOT_TWO 1.414213562373f

/**************************************************************************\
* OBJECT constructor
*
\**************************************************************************/
OBJECT::OBJECT( )
{
    listNum = glGenLists(1);
}

/**************************************************************************\
* OBJECT destructor
*
\**************************************************************************/
OBJECT::~OBJECT( )
{
    glDeleteLists( listNum, 1 );
}

/**************************************************************************\
* Draw
*
* - Draw the object by calling its display list
*
\**************************************************************************/
void
OBJECT::Draw( )
{
    glCallList( listNum );
}

/**************************************************************************\
* PIPE_OBJECT constructors
*
\**************************************************************************/
PIPE_OBJECT::PIPE_OBJECT( OBJECT_BUILD_INFO *pBuildInfo, float len )
{
    Build( pBuildInfo, len, 0.0f, 0.0f );
}

PIPE_OBJECT::PIPE_OBJECT( OBJECT_BUILD_INFO *pBuildInfo, float len, float s_start, float s_end )
{
    Build( pBuildInfo, len, s_start, s_end );
}

/**************************************************************************\
* ELBOW_OBJECT constructors
*
\**************************************************************************/
ELBOW_OBJECT::ELBOW_OBJECT( OBJECT_BUILD_INFO *pBuildInfo, int notch )
{
    Build( pBuildInfo, notch, 0.0f, 0.0f );
}

ELBOW_OBJECT::ELBOW_OBJECT( OBJECT_BUILD_INFO *pBuildInfo, int notch, float s_start, float s_end )
{
    Build( pBuildInfo, notch, s_start, s_end );
}

/**************************************************************************\
* BALLJOINT_OBJECT constructor
*
\**************************************************************************/
BALLJOINT_OBJECT::BALLJOINT_OBJECT( OBJECT_BUILD_INFO *pBuildInfo, int notch, float s_start, float s_end )
{
    Build( pBuildInfo, notch, s_start, s_end );
}

/**************************************************************************\
* SPHERE_OBJECT constructors
*
\**************************************************************************/
SPHERE_OBJECT::SPHERE_OBJECT( OBJECT_BUILD_INFO *pBuildInfo, float radius )
{
    Build( pBuildInfo, radius, 0.0f, 0.0f );
}

SPHERE_OBJECT::SPHERE_OBJECT( OBJECT_BUILD_INFO *pBuildInfo, float radius, float s_start, float s_end )
{
    Build( pBuildInfo, radius, s_start, s_end );
}


// rotate circle around x-axis, with edge attached to anchor

static void TransformCircle( 
    float angle, 
    POINT3D *inPoint, 
    POINT3D *outPoint, 
    GLint num,
    POINT3D *anchor )
{
    MATRIX matrix1, matrix2, matrix3;
    int i;

    // translate anchor point to origin
    ss_matrixIdent( &matrix1 );
    ss_matrixTranslate( &matrix1, -anchor->x, -anchor->y, -anchor->z );

    // rotate by angle, cw around x-axis
    ss_matrixIdent( &matrix2 );
    ss_matrixRotate( &matrix2, (double) -angle, 0.0, 0.0 );

    // concat these 2
    ss_matrixMult( &matrix3, &matrix2, &matrix1 );

    // translate back
    ss_matrixIdent( &matrix2 );
    ss_matrixTranslate( &matrix2,  anchor->x,  anchor->y,  anchor->z );

    // concat these 2
    ss_matrixMult( &matrix1, &matrix2, &matrix3 );

    // transform all the points, + center
    for( i = 0; i < num; i ++, outPoint++, inPoint++ ) {
        ss_xformPoint( outPoint, inPoint, &matrix1 );
    }
}

static void CalcNormals( POINT3D *p, POINT3D *n, POINT3D *center,
                         int num )
{
    POINT3D vec;
    int i;

    for( i = 0; i < num; i ++, n++, p++ ) {
        n->x = p->x - center->x;
        n->y = p->y - center->y;
        n->z = p->z - center->z;
        ss_normalizeNorm( n );
    }
}

/*----------------------------------------------------------------------\
|    MakeQuadStrip()                                                    |
|       - builds quadstrip between 2 rows of points. pA points to one   |
|         row of points, and pB to the next rotated row.  Because       |
|         the rotation has previously been defined CCW around the       |
|         x-axis, using an A-B sequence will result in CCW quads        |
|                                                                       |
\----------------------------------------------------------------------*/
static void MakeQuadStrip
(
    POINT3D *pA, 
    POINT3D *pB, 
    POINT3D *nA, 
    POINT3D *nB, 
    BOOL    bTexture,
    GLfloat *tex_s,
    GLfloat *tex_t,
    GLint slices
)
{
    GLint i;

    glBegin( GL_QUAD_STRIP );

    for( i = 0; i < slices; i ++ ) {
        glNormal3fv( (GLfloat *) nA++ );
        if( bTexture )
            glTexCoord2f( tex_s[0], *tex_t );
        glVertex3fv( (GLfloat *) pA++ );
        glNormal3fv( (GLfloat *) nB++ );
        if( bTexture )
            glTexCoord2f( tex_s[1], *tex_t++ );
        glVertex3fv( (GLfloat *) pB++ );
    }

    glEnd();
}

#define CACHE_SIZE      100     


/*----------------------------------------------------------------------\
|    BuildElbow()                                                      |
|       - builds elbows, by rotating a circle in the y=r plane          |
|         centered at (0,r,-r), CW around the x-axis at anchor pt.      |
|         (r = radius of the circle)                                    |
|       - rotation is 90.0 degrees, ending at circle in z=0 plane,      |
|         centered at origin.                                           |
|       - in order to 'mate' texture coords with the cylinders          |
|         generated with glu, we generate 4 elbows, each corresponding  |
|         to the 4 possible CW 90 degree orientations of the start point|
|         for each circle.                                              |
|       - We call this start point the 'notch'.  If we characterize     |
|         each notch by the axis it points down in the starting and     |
|         ending circles of the elbow, then we get the following axis   |
|         pairs for our 4 notches:                                      |
|               - +z,+y                                                 |
|               - +x,+x                                                 |
|               - -z,-y                                                 |
|               - -x,-x                                                 |
|         Since the start of the elbow always points down +y, the 4     |
|         start notches give all possible 90.0 degree orientations      |
|         around y-axis.                                                |
|       - We can keep track of the current 'notch' vector to provide    |
|         proper mating between primitives.                             |
|       - Each circle of points is described CW from the start point,   |
|         assuming looking down the +y axis(+y direction).              |
|       - texture 's' starts at 0.0, and goes to 2.0*r/divSize at       |
|         end of the elbow.  (Then a short pipe would start with this   |
|         's', and run it to 1.0).                                      |
|                                                                       |
\----------------------------------------------------------------------*/
void
ELBOW_OBJECT::Build( OBJECT_BUILD_INFO *pBuildInfo, int notch, float s_start, float s_end )
{
    GLint   stacks, slices;
    GLfloat angle, startAng, r;
    GLint numPoints;
    GLfloat s_delta;
    POINT3D pi[CACHE_SIZE]; // initial row of points + center
    POINT3D p0[CACHE_SIZE]; // 2 rows of points
    POINT3D p1[CACHE_SIZE];
    POINT3D n0[CACHE_SIZE]; // 2 rows of normals
    POINT3D n1[CACHE_SIZE];
    GLfloat tex_t[CACHE_SIZE];// 't' texture coords
    GLfloat tex_s[2];  // 's' texture coords
    POINT3D center;  // center of circle
    POINT3D anchor;  // where circle is anchored
    POINT3D *pA, *pB, *nA, *nB;
    int i, j;
    IPOINT2D *texRep = pBuildInfo->texRep;
    GLfloat radius = pBuildInfo->radius;
    BOOL    bTexture = pBuildInfo->bTexture;

    slices = pBuildInfo->nSlices;
    stacks = slices / 2;

    if (slices >= CACHE_SIZE) slices = CACHE_SIZE-1;
    if (stacks >= CACHE_SIZE) stacks = CACHE_SIZE-1;

    s_delta = s_end - s_start;
 
    if( bTexture ) {
        // calculate 't' texture coords
        for( i = 0; i <= slices; i ++ ) {
            tex_t[i] = (GLfloat) i * texRep->y / slices;
        }
    }

    numPoints = slices + 1;

        // starting angle increment 90.0 degrees each time
        startAng = notch * PI / 2;

        // calc initial circle of points for circle centered at 0,r,-r
        // points start at (0,r,0), and rotate circle CCW

        for( i = 0; i <= slices; i ++ ) {
            angle = startAng + (2 * PI * i / slices);
            pi[i].x = radius * (float) sin(angle);
            pi[i].y = radius;
            // translate z by -r, cuz these cos calcs are for circle at origin
            pi[i].z = radius * (float) cos(angle) - radius;
        }

        // center point, tacked onto end of circle of points
        pi[i].x =  0.0f;
        pi[i].y =  radius;
        pi[i].z = -radius;
        center = pi[i];
    
        // anchor point
        anchor.x = anchor.z = 0.0f;
        anchor.y = radius;

        // calculate initial normals
        CalcNormals( pi, n0, &center, numPoints );

        // initial 's' texture coordinate
        tex_s[0] = s_start;

        // setup pointers
        pA = pi;
        pB = p0;
        nA = n0;
        nB = n1;

        // now iterate throught the stacks

        glNewList(listNum, GL_COMPILE);

        for( i = 1; i <= stacks; i ++ ) {
            // ! this angle must be negative, for correct vertex orientation !
            angle = - 0.5f * PI * i / stacks;

            // transform to get next circle of points + center
            TransformCircle( angle, pi, pB, numPoints+1, &anchor );

            // calculate normals
            center = pB[numPoints];
            CalcNormals( pB, nB, &center, numPoints );

            // calculate next 's' texture coord
            tex_s[1] = (GLfloat) s_start + s_delta * i / stacks;

            // now we've got points and normals, ready to be quadstrip'd
            MakeQuadStrip( pA, pB, nA, nB, bTexture, tex_s, tex_t, numPoints );

            // reset pointers
            pA = pB;
            nA = nB;
            pB = (pB == p0) ? p1 : p0;
            nB = (nB == n0) ? n1 : n0;
            tex_s[0] = tex_s[1];
        }

        glEndList();
}

/*----------------------------------------------------------------------\
|    BuildBallJoint()                                                  |
|       - These are very similar to the elbows, in that the starting    |
|         and ending positions are almost identical.   The difference   |
|         here is that the circles in the sweep describe a sphere as    |
|         they are rotated.                                             |
|                                                                       |
\----------------------------------------------------------------------*/
void 
BALLJOINT_OBJECT::Build( OBJECT_BUILD_INFO *pBuildInfo, int notch, 
                         float s_start, float s_end )
{
    GLfloat ballRadius;
    GLfloat angle, delta_a, startAng, theta;
    GLint numPoints;
    GLfloat s_delta;
    POINT3D pi0[CACHE_SIZE]; // 2 circles of untransformed points
    POINT3D pi1[CACHE_SIZE];
    POINT3D p0[CACHE_SIZE]; // 2 rows of transformed points
    POINT3D p1[CACHE_SIZE];
    POINT3D n0[CACHE_SIZE]; // 2 rows of normals
    POINT3D n1[CACHE_SIZE];
    float   r[CACHE_SIZE];  // radii of the circles
    GLfloat tex_t[CACHE_SIZE];// 't' texture coords
    GLfloat tex_s[2];  // 's' texture coords
    POINT3D center;  // center of circle
    POINT3D anchor;  // where circle is anchored
    POINT3D *pA, *pB, *nA, *nB;
    int i, j, k;
    GLint   stacks, slices;
    IPOINT2D *texRep = pBuildInfo->texRep;
    GLfloat radius = pBuildInfo->radius;
    BOOL    bTexture = pBuildInfo->bTexture;

    slices = pBuildInfo->nSlices;
    stacks = slices;

    if (slices >= CACHE_SIZE) slices = CACHE_SIZE-1;
    if (stacks >= CACHE_SIZE) stacks = CACHE_SIZE-1;

    // calculate the radii for each circle in the sweep, where
    // r[i] = y = sin(angle)/r

    angle = PI / 4;  // first radius always at 45.0 degrees
    delta_a = (PI / 2.0f) / stacks;

    ballRadius = ROOT_TWO * radius;
    for( i = 0; i <= stacks; i ++, angle += delta_a ) {
        r[i] = (float) sin(angle) * ballRadius;
    }

    if( bTexture ) {
        // calculate 't' texture coords
        for( i = 0; i <= slices; i ++ ) {
            tex_t[i] = (GLfloat) i * texRep->y / slices;
        }
    }

    s_delta = s_end - s_start;
 
    numPoints = slices + 1;

    // unlike the elbow, the center for the ball joint is constant
    center.x = center.y = 0.0f;
    center.z = -radius;

        // starting angle along circle, increment 90.0 degrees each time
        startAng = notch * PI / 2;

        // calc initial circle of points for circle centered at 0,r,-r
        // points start at (0,r,0), and rotate circle CCW

        delta_a = 2 * PI / slices;
        for( i = 0, theta = startAng; i <= slices; i ++, theta += delta_a ) {
            pi0[i].x = r[0] * (float) sin(theta);
            pi0[i].y = radius;
            // translate z by -r, cuz these cos calcs are for circle at origin
            pi0[i].z = r[0] * (float) cos(theta) - r[0];
        }

        // anchor point
        anchor.x = anchor.z = 0.0f;
        anchor.y = radius;

        // calculate initial normals
        CalcNormals( pi0, n0, &center, numPoints );

        // initial 's' texture coordinate
        tex_s[0] = s_start;

        // setup pointers
        pA = pi0; // circles of transformed points
        pB = p0;
        nA = n0; // circles of transformed normals
        nB = n1;

        // now iterate throught the stacks

        glNewList(listNum, GL_COMPILE);

        for( i = 1; i <= stacks; i ++ ) {
            // ! this angle must be negative, for correct vertex orientation !
            angle = - 0.5f * PI * i / stacks;

            // calc the next circle of untransformed points into pi1[]

            for( k = 0, theta = startAng; k <= slices; k ++, theta+=delta_a ) {
                pi1[k].x = r[i] * (float) sin(theta);
                pi1[k].y = radius;
                // translate z by -r, cuz calcs are for circle at origin
                pi1[k].z = r[i] * (float) cos(theta) - r[i];
            }

            // rotate cirle of points to next position
            TransformCircle( angle, pi1, pB, numPoints, &anchor );

            // calculate normals
            CalcNormals( pB, nB, &center, numPoints );

            // calculate next 's' texture coord
            tex_s[1] = (GLfloat) s_start + s_delta * i / stacks;

            // now we've got points and normals, ready to be quadstrip'd
            MakeQuadStrip( pA, pB, nA, nB, bTexture, tex_s, tex_t, numPoints );

            // reset pointers
            pA = pB;
            nA = nB;
            pB = (pB == p0) ? p1 : p0;
            nB = (nB == n0) ? n1 : n0;
            tex_s[0] = tex_s[1];
        }

        glEndList();
}

// 'glu' routines

#ifdef _EXTENSIONS_
#define COS cosf
#define SIN sinf
#define SQRT sqrtf
#else
#define COS cos
#define SIN sin
#define SQRT sqrt
#endif


/**************************************************************************\
* BuildCylinder
*
\**************************************************************************/
void
PIPE_OBJECT::Build( OBJECT_BUILD_INFO *pBuildInfo, float length, float s_start, 
                            float s_end )
{
    GLint   stacks, slices;
    GLint   i,j,max;
    GLfloat sinCache[CACHE_SIZE];
    GLfloat cosCache[CACHE_SIZE];
    GLfloat sinCache2[CACHE_SIZE];
    GLfloat cosCache2[CACHE_SIZE];
    GLfloat angle;
    GLfloat x, y, zLow, zHigh;
    GLfloat sintemp, costemp;
    GLfloat zNormal;
    GLfloat s_delta;
    IPOINT2D *texRep = pBuildInfo->texRep;
    GLfloat radius = pBuildInfo->radius;
    BOOL    bTexture = pBuildInfo->bTexture;

    slices = pBuildInfo->nSlices;
    stacks = (int) SS_ROUND_UP( (length/pBuildInfo->divSize) * (float)slices) ;

    if (slices >= CACHE_SIZE) slices = CACHE_SIZE-1;
    if (stacks >= CACHE_SIZE) stacks = CACHE_SIZE-1;

    zNormal = 0.0f;

    s_delta = s_end - s_start;

    for (i = 0; i < slices; i++) {
        angle = 2 * PI * i / slices;
        sinCache2[i] = (float) SIN(angle);
        cosCache2[i] = (float) COS(angle);
        sinCache[i] = (float) SIN(angle);
        cosCache[i] = (float) COS(angle);
    }

    sinCache[slices] = sinCache[0];
    cosCache[slices] = cosCache[0];
    sinCache2[slices] = sinCache2[0];
    cosCache2[slices] = cosCache2[0];

    glNewList(listNum, GL_COMPILE);

        for (j = 0; j < stacks; j++) {
            zLow = j * length / stacks;
            zHigh = (j + 1) * length / stacks;

            glBegin(GL_QUAD_STRIP);
            for (i = 0; i <= slices; i++) {
                    glNormal3f(sinCache2[i], cosCache2[i], zNormal);
                    if (bTexture) {
                        glTexCoord2f( (float) s_start + s_delta * j / stacks,
                                      (float) i * texRep->y / slices );
                    }
                    glVertex3f(radius * sinCache[i], 
                            radius * cosCache[i], zLow);
                    if (bTexture) {
                        glTexCoord2f( (float) s_start + s_delta*(j+1) / stacks,
                                      (float) i * texRep->y / slices );
                    }
                    glVertex3f(radius * sinCache[i], 
                            radius * cosCache[i], zHigh);
            }
            glEnd();
        }

    glEndList();
}


/*----------------------------------------------------------------------\
|    pipeSphere()                                                       |
|                                                                       |
\----------------------------------------------------------------------*/
void 
SPHERE_OBJECT::Build( OBJECT_BUILD_INFO *pBuildInfo, GLfloat radius, 
                      GLfloat s_start, GLfloat s_end)
{
    GLint i,j,max;
    GLfloat sinCache1a[CACHE_SIZE];
    GLfloat cosCache1a[CACHE_SIZE];
    GLfloat sinCache2a[CACHE_SIZE];
    GLfloat cosCache2a[CACHE_SIZE];
    GLfloat sinCache1b[CACHE_SIZE];
    GLfloat cosCache1b[CACHE_SIZE];
    GLfloat sinCache2b[CACHE_SIZE];
    GLfloat cosCache2b[CACHE_SIZE];
    GLfloat angle;
    GLfloat x, y, zLow, zHigh;
    GLfloat sintemp1, sintemp2, sintemp3, sintemp4;
    GLfloat costemp1, costemp2, costemp3, costemp4;
    GLfloat zNormal;
    GLfloat s_delta;
    GLint start, finish;
    GLint   stacks, slices;
    BOOL    bTexture = pBuildInfo->bTexture;
    IPOINT2D *texRep = pBuildInfo->texRep;

    slices = pBuildInfo->nSlices;
    stacks = slices;
    if (slices >= CACHE_SIZE) slices = CACHE_SIZE-1;
    if (stacks >= CACHE_SIZE) stacks = CACHE_SIZE-1;

    // invert sense of s - it seems the glu sphere is not built similarly
    // to the glu cylinder
    // (this probably means stacks don't grow along +z - check it out)
    s_delta = s_start;
    s_start = s_end;
    s_end = s_delta; 

    s_delta = s_end - s_start;

    /* Cache is the vertex locations cache */
    /* Cache2 is the various normals at the vertices themselves */

    for (i = 0; i < slices; i++) {
        angle = 2 * PI * i / slices;
        sinCache1a[i] = (float) SIN(angle);
        cosCache1a[i] = (float) COS(angle);
            sinCache2a[i] = sinCache1a[i];
            cosCache2a[i] = cosCache1a[i];
    }

    for (j = 0; j <= stacks; j++) {
        angle = PI * j / stacks;
                sinCache2b[j] = (float) SIN(angle);
                cosCache2b[j] = (float) COS(angle);
        sinCache1b[j] = radius * (float) SIN(angle);
        cosCache1b[j] = radius * (float) COS(angle);
    }
    /* Make sure it comes to a point */
    sinCache1b[0] = 0.0f;
    sinCache1b[stacks] = 0.0f;

    sinCache1a[slices] = sinCache1a[0];
    cosCache1a[slices] = cosCache1a[0];
        sinCache2a[slices] = sinCache2a[0];
        cosCache2a[slices] = cosCache2a[0];

    glNewList(listNum, GL_COMPILE);

        /* Do ends of sphere as TRIANGLE_FAN's (if not bTexture)
        ** We don't do it when bTexture because we need to respecify the
        ** texture coordinates of the apex for every adjacent vertex (because
        ** it isn't a constant for that point)
        */
        if (!bTexture) {
            start = 1;
            finish = stacks - 1;

            /* Low end first (j == 0 iteration) */
            sintemp2 = sinCache1b[1];
            zHigh = cosCache1b[1];
                sintemp3 = sinCache2b[1];
                costemp3 = cosCache2b[1];
                glNormal3f(sinCache2a[0] * sinCache2b[0],
                        cosCache2a[0] * sinCache2b[0],
                        cosCache2b[0]);

            glBegin(GL_TRIANGLE_FAN);
            glVertex3f(0.0f, 0.0f, radius);

                for (i = slices; i >= 0; i--) {
                        glNormal3f(sinCache2a[i] * sintemp3,
                                cosCache2a[i] * sintemp3,
                                costemp3);
                    glVertex3f(sintemp2 * sinCache1a[i],
                            sintemp2 * cosCache1a[i], zHigh);
                }
            glEnd();

            /* High end next (j == stacks-1 iteration) */
            sintemp2 = sinCache1b[stacks-1];
            zHigh = cosCache1b[stacks-1];
                sintemp3 = sinCache2b[stacks-1];
                costemp3 = cosCache2b[stacks-1];
                glNormal3f(sinCache2a[stacks] * sinCache2b[stacks],
                        cosCache2a[stacks] * sinCache2b[stacks],
                        cosCache2b[stacks]);
            glBegin(GL_TRIANGLE_FAN);
            glVertex3f(0.0f, 0.0f, -radius);
                for (i = 0; i <= slices; i++) {
                        glNormal3f(sinCache2a[i] * sintemp3,
                                cosCache2a[i] * sintemp3,
                                costemp3);
                    glVertex3f(sintemp2 * sinCache1a[i],
                            sintemp2 * cosCache1a[i], zHigh);
                }
            glEnd();
        } else {
            start = 0;
            finish = stacks;
        }
        for (j = start; j < finish; j++) {
            zLow = cosCache1b[j];
            zHigh = cosCache1b[j+1];
            sintemp1 = sinCache1b[j];
            sintemp2 = sinCache1b[j+1];
                    sintemp3 = sinCache2b[j+1];
                    costemp3 = cosCache2b[j+1];
                    sintemp4 = sinCache2b[j];
                    costemp4 = cosCache2b[j];

            glBegin(GL_QUAD_STRIP);
            for (i = 0; i <= slices; i++) {
                    glNormal3f(sinCache2a[i] * sintemp3,
                            cosCache2a[i] * sintemp3,
                            costemp3);
                    if (bTexture) {
                        glTexCoord2f( (float) s_start + s_delta*(j+1) / stacks,
                                      (float) i * texRep->y / slices );
                    }
                    glVertex3f(sintemp2 * sinCache1a[i],
                            sintemp2 * cosCache1a[i], zHigh);
                    glNormal3f(sinCache2a[i] * sintemp4,
                            cosCache2a[i] * sintemp4,
                            costemp4);
                    if (bTexture) {
                        glTexCoord2f( (float) s_start + s_delta * j / stacks,
                                      (float) i * texRep->y / slices );
                    }
                    glVertex3f(sintemp1 * sinCache1a[i],
                            sintemp1 * cosCache1a[i], zLow);
            }
            glEnd();
        }

    glEndList();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\pipe.h ===
/******************************Module*Header*******************************\
* Module Name: pipe.h
*
* PIPE base class
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#ifndef __pipe_h__
#define __pipe_h__

#include "sscommon.h"
#include "state.h"

// pipe drawing status
enum {
    PIPE_ACTIVE,
    PIPE_STUCK,
    PIPE_OUT_OF_NODES
};

// pipe types
enum {
    TYPE_NORMAL,
    TYPE_FLEX_REGULAR,
    TYPE_FLEX_TURNING
};

// ways pipe choose directions
enum {
    CHOOSE_DIR_RANDOM_WEIGHTED,
    CHOOSE_DIR_CHASE // when chasing a lead pipe
};

// ways pipe choose start positions
enum {
    CHOOSE_STARTPOS_RANDOM,
    CHOOSE_STARTPOS_FURTHEST // furthest from last position
};
/**************************************************************************\
*
* PIPE class
*
* - Describes a pipe that draws thru the node array
* - Could have more than one pipe drawing in each array at same time
* - Pipe has position and direction in node array
*
\**************************************************************************/

class STATE;

class PIPE {
public:
    int         type;
    IPOINT3D    curPos;         // current node position of pipe

    STATE       *pState;        // for state value access

    void        SetChooseDirectionMethod( int method );
    void        SetChooseStartPosMethod( int method );
    int         ChooseNewDirection();
    BOOL        IsStuck();      // if pipe is stuck or not
    BOOL        NowhereToRun(){ return status == PIPE_OUT_OF_NODES; }
protected:
    BOOL        bTexture;
    float       radius;         // ideal radius (fluctuates for FPIPE)
    int         status;         // ACTIVE/STUCK/STOPPED, etc.
    int         lastDir;        // last direction taken by pipe
    int         notchVec;       // current notch vector
    PIPE( STATE *state );
    int         weightStraight; // current weighting of going straight
    BOOL        SetStartPos();  // starting node position
    void        ChooseMaterial();
    void        DrawTeapot();
    void        UpdateCurrentPosition( int dir );
    void        TranslateToCurrentPosition();
private:
    int         chooseDirMethod;
    int         chooseStartPosMethod;
    int         GetBestDirsForChase( int *bestDirs );
};

extern void align_plusz( int newDir );
extern GLint notchTurn[NUM_DIRS][NUM_DIRS][NUM_DIRS];

#endif // __pipe_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\objects.h ===
/******************************Module*Header*******************************\
* Module Name: objects.h
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#ifndef __objects_h__
#define __objects_h__

#include "sspipes.h"
#include "state.h"

class OBJECT_BUILD_INFO {
public:
    float radius;
    float divSize;
    int   nSlices;
    BOOL  bTexture;
    IPOINT2D *texRep;
};

/**************************************************************************\
*
* OBJECT classes
*
* - Display list objects
*
\**************************************************************************/

class OBJECT {
protected:
    int         listNum;
    int         nSlices;
public:
    void        Draw();

    OBJECT();
    ~OBJECT();
};

class PIPE_OBJECT : public OBJECT {
private:
    void Build( OBJECT_BUILD_INFO *state, float length, float start_s, float s_end );
public:
    PIPE_OBJECT( OBJECT_BUILD_INFO *state, float length );
    PIPE_OBJECT( OBJECT_BUILD_INFO *state, float length, float start_s, float end_s );
};

class ELBOW_OBJECT : public OBJECT {
private:
    void Build( OBJECT_BUILD_INFO *state, int notch, float start_s, float end_s );
public:
    ELBOW_OBJECT( OBJECT_BUILD_INFO *state, int notch );
    ELBOW_OBJECT( OBJECT_BUILD_INFO *state, int notch, float start_s, float end_s );
};

class BALLJOINT_OBJECT : public OBJECT {
private:
    void Build( OBJECT_BUILD_INFO *state, int notch, float start_s, float end_s );
public:
    // texturing version only
    BALLJOINT_OBJECT( OBJECT_BUILD_INFO *state, int notch, float start_s, float end_s );
};

class SPHERE_OBJECT : public OBJECT {
private:
    void Build( OBJECT_BUILD_INFO *state, float radius, float start_s, float end_s );
public:
    SPHERE_OBJECT( OBJECT_BUILD_INFO *state, float radius, float start_s, float end_s );
    SPHERE_OBJECT( OBJECT_BUILD_INFO *state, float radius );
};

#endif // __objects_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\sspipes.cxx ===
/******************************Module*Header*******************************\
* Module Name: sspipes.cxx
*
* Startup code
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <sys/types.h>
#include <sys/timeb.h>
#include <time.h>
#include <windows.h>

#include "sspipes.h"
#include "dialog.h"
#include "state.h"

#ifdef DO_TIMING
int pipeCount;
#endif

void InitPipes( void *data );

/******************************Public*Routine******************************\
* ss_Init
*
* Initialize - called on first entry into ss.
* Called BEFORE gl is initialized!
* Just do basic stuff here, like set up callbacks, verify dialog stuff, etc.
*
* Fills global SSContext structure with required data, and returns ptr
* to it.
*
\**************************************************************************/

static SSContext ssc;

SSContext *
ss_Init( void )
{
    // validate some initial dialog settings
    getIniSettings();  // also called on dialog init    

    if( ulSurfStyle == SURFSTYLE_TEX ) {
        // Texture verification has to go here, before gl is loaded, in case
        // error msgs are displayed.
        
        for( int i = 0; i < gnTextures; i ++ ) {
            if( !ss_VerifyTextureFile( &gTexFile[i]) ) {
                // user texture is invalid - substitute resource texture ?
                // If gnTextures > nRes
                // get rid of this one - move the others up
                gnTextures--;
                for( int j = i; j < gnTextures; j++ )
                    gTexFile[j] = gTexFile[j+1];
            }
        }
    }

    ss_InitFunc( InitPipes );

    // set configuration info to return
    ssc.bDoubleBuf = FALSE;
    ssc.depthType = SS_DEPTH16;
    ssc.bFloater = FALSE;

    return &ssc;
}

static void
Draw( void *data )
{
    // don't need data here, but I was hoping to be able to use the STATE
    // member functions directly as callbacks
    ((STATE *) data)->Draw(data);
}

static void
Reshape( int width, int height, void *data )
{
    ((STATE *) data)->Reshape( width, height, data );
}

static void
Repaint( LPRECT pRect, void *data )
{
    ((STATE *) data)->Repaint( pRect, data );
}

static void
Finish( void *data )
{
    ((STATE *) data)->Finish( data );
}

/******************************Public*Routine******************************\
* InitPipes
*
* - Called when GL window has been initialized
*
\**************************************************************************/
void 
InitPipes( void *data )
{
    // create world of pipes

    //mf: for now, bFlexMode used to choose between normal/flex

    STATE *pPipeWorld = new STATE( bFlexMode, bMultiPipes );

#if 0
    //mf: compiler doesn't like me using class member functions as callbacks
    ss_UpdateFunc( pState->Draw );
    ss_ReshapeFunc( pState->Reshape );
    ss_FinishFunc( pState->Finish );
#else
    // mf: use wrappers for now
    ss_UpdateFunc( Draw );
    ss_ReshapeFunc( Reshape );
    ss_RepaintFunc( Repaint );
    ss_FinishFunc( Finish );
#endif
    //mf: this should no longer be necessary
    ss_DataPtr( pPipeWorld ); 
}

#ifdef DO_TIMING
void CalcPipeRate( struct _timeb baseTime, int pipeCount ) {
    static struct _timeb thisTime;
    double elapsed, pipeRate;
    char buf[100];

    _ftime( &thisTime );
    elapsed = thisTime.time + thisTime.millitm/1000.0 -
       (baseTime.time + baseTime.millitm/1000.0);


    if( elapsed == 0.0 )
        pipeRate = 0.0;
    else
        pipeRate = pipeCount / elapsed;

    sprintf( buf, "Last frame's pipe rate = %4.1f pps", pipeRate );
#ifdef SS_DEBUG
    SendMessage(ss_GetHWND(), WM_SETTEXT, 0, (LPARAM)buf);
#endif
}

void Timer( int mode )
{
    static struct _timeb baseTime;

    switch( mode ) {
        case TIMER_START:
            pipeCount = 0;
 	        _ftime( &baseTime );
            break;
        case TIMER_STOP:
            CalcPipeRate( baseTime, pipeCount );
            break;
        case TIMER_TIMING:
            break;
        case TIMER_RESET:
        default:
            break;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sspipes.rc
//
#define IDI_ICON1                       103
#define IDC_RADIO1                      1014
#define IDC_RADIO2                      1015
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        104
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1017
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
#include "dialog.h"
#include "sscommon.rc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\pipe.cxx ===
/******************************Module*Header*******************************\
* Module Name: pipe.cxx
*
* - Pipe base class stuff
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <sys/types.h>
#include <sys/timeb.h>
#include <time.h>
#include <windows.h>

#include "sspipes.h"
#include "state.h"
#include "pipe.h"

/******************************Public*Routine******************************\
* PIPE constructor
*
* Nov. 95 [marcfo]
*
\**************************************************************************/

PIPE::PIPE( STATE *state )
{
    pState = state;
    bTexture = pState->bTexture;
    radius = pState->radius;
    // default direction choosing is random
    chooseDirMethod = CHOOSE_DIR_RANDOM_WEIGHTED;
    chooseStartPosMethod = CHOOSE_STARTPOS_RANDOM;
    weightStraight = 1;
}

/******************************Public*Routine******************************\
* ChooseMaterial
*
\**************************************************************************/

void 
PIPE::ChooseMaterial( )
{
    if( bTexture )
        ss_RandomTexMaterial( TRUE );
    else
        ss_RandomTeaMaterial( TRUE );
}

/**************************************************************************\
*
* DrawTeapot
*
\**************************************************************************/

extern void ResetEvaluator( BOOL bTexture );

void 
PIPE::DrawTeapot( )
{
    glFrontFace( GL_CW );
    glEnable( GL_NORMALIZE );
    auxSolidTeapot(2.5 * radius);
    glDisable( GL_NORMALIZE );
    glFrontFace( GL_CCW );
    if( type != TYPE_NORMAL ) {
        // Re-init flex's evaluator state (teapot uses evaluators as well,
        //  and messes up the state).
        ResetEvaluator( bTexture );
    }
}

/******************************Public*Routine******************************\
* SetChooseDirectionMethod
*
* Nov. 95 [marcfo]
*
\**************************************************************************/

void
PIPE::SetChooseDirectionMethod( int method )
{
    chooseDirMethod = method;
}


/**************************************************************************\
*
* ChooseNewDirection
*
* Call direction-finding function based on current method
* This is a generic entry point that is used by some pipe types
*
\**************************************************************************/

int 
PIPE::ChooseNewDirection()
{
    NODE_ARRAY *nodes = pState->nodes;
    int bestDirs[NUM_DIRS], nBestDirs;

    // figger out which fn to call
    switch( chooseDirMethod ) {
        case CHOOSE_DIR_CHASE:
            if( nBestDirs = GetBestDirsForChase( bestDirs ) )
                return nodes->ChoosePreferredDirection( &curPos, lastDir, 
                                                        bestDirs, nBestDirs );
            // else lead pipe must have died, so fall thru:
        case CHOOSE_DIR_RANDOM_WEIGHTED :
        default:
            return nodes->ChooseRandomDirection( &curPos, lastDir, weightStraight );
    }
}

/**************************************************************************\
*
* GetBestDirsForChase
*
* Find the best directions to take to close in on the lead pipe in chase mode.
*
\**************************************************************************/

//mf: ? but want to use similar scheme for turning flex pipes !!
// (later) 
int
PIPE::GetBestDirsForChase( int *bestDirs )
{
    // Figure out best dirs to close in on leadPos

    //mf: will have to 'protect' leadPos with GetLeadPos() for multi-threading
    IPOINT3D *leadPos = &pState->pLeadPipe->curPos;
    IPOINT3D delta;
    int numDirs = 0;

    delta.x = leadPos->x - curPos.x;
    delta.y = leadPos->y - curPos.y;
    delta.z = leadPos->z - curPos.z;

    if( delta.x ) {
        numDirs++;
        *bestDirs++ = delta.x > 0 ? PLUS_X : MINUS_X;
    }
    if( delta.y ) {
        numDirs++;
        *bestDirs++ = delta.y > 0 ? PLUS_Y : MINUS_Y;
    }
    if( delta.z ) {
        numDirs++;
        *bestDirs++ = delta.z > 0 ? PLUS_Z : MINUS_Z;
    }
    // It should be impossible for numDirs = 0 (all deltas = 0), as this
    // means curPos = leadPos
    return numDirs;
}

/******************************Public*Routine******************************\
* SetChooseStartPosMethod
*
* Nov. 95 [marcfo]
*
\**************************************************************************/

void
PIPE::SetChooseStartPosMethod( int method )
{
    chooseStartPosMethod = method;
}

/******************************Public*Routine******************************\
* PIPE::SetStartPos
*
* - Find an empty node to start the pipe on
*
\**************************************************************************/

BOOL
PIPE::SetStartPos()
{
    NODE_ARRAY *nodes = pState->nodes;

    switch( chooseStartPosMethod ) {

        case CHOOSE_STARTPOS_RANDOM:
        default:
            if( !nodes->FindRandomEmptyNode( &curPos ) ) {
                return FALSE;
            }
            return TRUE;
        
        case CHOOSE_STARTPOS_FURTHEST:
            // find node furthest away from curPos
            IPOINT3D refPos, numNodes;
            nodes->GetNodeCount( &numNodes );
            refPos.x = (curPos.x >= (numNodes.x / 2)) ? 0 : numNodes.x - 1;
            refPos.y = (curPos.y >= (numNodes.y / 2)) ? 0 : numNodes.y - 1;
            refPos.z = (curPos.z >= (numNodes.z / 2)) ? 0 : numNodes.z - 1;

            if( !nodes->TakeClosestEmptyNode( &curPos, &refPos ) ) {
                return FALSE;
            }
            return TRUE;
    }
}

/******************************Public*Routine******************************\
* PIPE::IsStuck
*
* Nov. 95 [marcfo]
*
\**************************************************************************/

BOOL
PIPE::IsStuck()
{
    return status == PIPE_STUCK;
}

/******************************Public*Routine******************************\
* PIPE::TranslateToCurrentPosition
*
\**************************************************************************/

void
PIPE::TranslateToCurrentPosition()
{
    IPOINT3D numNodes;

    float divSize = pState->view.divSize;
    // this requires knowing the size of the node array
    pState->nodes->GetNodeCount( &numNodes );
    glTranslatef( (curPos.x - (numNodes.x - 1)/2.0f )*divSize,
                  (curPos.y - (numNodes.y - 1)/2.0f )*divSize,
                  (curPos.z - (numNodes.z - 1)/2.0f )*divSize );
}

/**************************************************************************\
*
* UpdateCurrentPosition
* 
* Increment current position according to direction taken
\**************************************************************************/

void 
PIPE::UpdateCurrentPosition( int newDir )
{
    switch( newDir ) {
        case PLUS_X:
            curPos.x += 1;
            break;
        case MINUS_X:
            curPos.x -= 1;
            break;
        case PLUS_Y:
            curPos.y += 1;
            break;
        case MINUS_Y:
            curPos.y -= 1;
            break;
        case PLUS_Z:
            curPos.z += 1;
            break;
        case MINUS_Z:
            curPos.z -= 1;
            break;
    }
}

/******************************Public*Routine******************************\
* align_plusz
*
* - Aligns the z axis along specified direction
* - Used for all types of pipes
*
\**************************************************************************/


void align_plusz( int newDir )
{
    // align +z along new direction
    switch( newDir ) {
        case PLUS_X:
            glRotatef( 90.0f, 0.0f, 1.0f, 0.0f);
            break;
        case MINUS_X:
            glRotatef( -90.0f, 0.0f, 1.0f, 0.0f);
            break;
        case PLUS_Y:
            glRotatef( -90.0f, 1.0f, 0.0f, 0.0f);
            break;
        case MINUS_Y:
            glRotatef( 90.0f, 1.0f, 0.0f, 0.0f);
            break;
        case PLUS_Z:
            glRotatef( 0.0f, 0.0f, 1.0f, 0.0f);
            break;
        case MINUS_Z:
            glRotatef( 180.0f, 0.0f, 1.0f, 0.0f);
            break;
    }

}

/**************************************************************************\
* this array tells you which way the notch will be once you make
* a turn
* format: notchTurn[oldDir][newDir][notchVec] 
*
\**************************************************************************/

GLint notchTurn[NUM_DIRS][NUM_DIRS][NUM_DIRS] = {
// oldDir = +x
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    MINUS_X,PLUS_X, PLUS_Z, MINUS_Z,
        iXX,    iXX,    PLUS_X, MINUS_X,PLUS_Z, MINUS_Z,
        iXX,    iXX,    PLUS_Y, MINUS_Y,MINUS_X,PLUS_X,
        iXX,    iXX,    PLUS_Y, MINUS_Y,PLUS_X, MINUS_X,
// oldDir = -x
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    PLUS_X, MINUS_X,PLUS_Z, MINUS_Z,
        iXX,    iXX,    MINUS_X,PLUS_X, PLUS_Z, MINUS_Z,
        iXX,    iXX,    PLUS_Y, MINUS_Y,PLUS_X, MINUS_X,
        iXX,    iXX,    PLUS_Y, MINUS_Y,MINUS_X,PLUS_X,
// oldDir = +y
        MINUS_Y,PLUS_Y, iXX,    iXX,    PLUS_Z, MINUS_Z,
        PLUS_Y, MINUS_Y,iXX,    iXX,    PLUS_Z, MINUS_Z,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        PLUS_X, MINUS_X,iXX,    iXX,    MINUS_Y,PLUS_Y,
        PLUS_X, MINUS_X,iXX,    iXX,    PLUS_Y, MINUS_Y,
// oldDir = -y
        PLUS_Y, MINUS_Y,iXX,    iXX,    PLUS_Z, MINUS_Z,
        MINUS_Y,PLUS_Y, iXX,    iXX,    PLUS_Z, MINUS_Z,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        PLUS_X, MINUS_X,iXX,    iXX,    PLUS_Y, MINUS_Y,
        PLUS_X, MINUS_X,iXX,    iXX,    MINUS_Y,PLUS_Y,
// oldDir = +z
        MINUS_Z,PLUS_Z, PLUS_Y, MINUS_Y,iXX,    iXX,
        PLUS_Z, MINUS_Z,PLUS_Y, MINUS_Y,iXX,    iXX,
        PLUS_X, MINUS_X,MINUS_Z,PLUS_Z, iXX,    iXX,
        PLUS_X, MINUS_X,PLUS_Z, MINUS_Z,iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
// oldDir = -z
        PLUS_Z, MINUS_Z,PLUS_Y, MINUS_Y,iXX,    iXX,
        MINUS_Z,PLUS_Z, PLUS_Y, MINUS_Y,iXX,    iXX,
        PLUS_X, MINUS_X,PLUS_Z, MINUS_Z,iXX,    iXX,
        PLUS_X, MINUS_X,MINUS_Z,PLUS_Z, iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX,
        iXX,    iXX,    iXX,    iXX,    iXX,    iXX
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\state.h ===
/******************************Module*Header*******************************\
* Module Name: state.h
*
* STATE
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#ifndef __state_h__
#define __state_h__

#include "sscommon.hxx"
#include "pipe.h"
#include "node.h"
#include "view.h"
#include "nstate.h"
#include "fstate.h"

#define MAX_DRAW_THREADS    4

#define TEAPOT             66

#define MAX_TESS 3

// type(s) of pipes that are drawn
enum {
    DRAW_NORMAL,
    DRAW_FLEX,
    DRAW_BOTH  // not currently used
};

// Reset status

#define  RESET_STARTUP_BIT (1L << 0)
#define  RESET_NORMAL_BIT  (1L << 1)
#define  RESET_RESIZE_BIT  (1L << 2)
#define  RESET_REPAINT_BIT  (1L << 3)

// Frame draw schemes

enum {
    FRAME_SCHEME_RANDOM,  // pipes draw randomly
    FRAME_SCHEME_CHASE,   // pipes chase a lead pipe
};

class DRAW_THREAD {
private:
    HDC         hdc;
    HTEXTURE    htex;

public:
    HGLRC       hglrc;        // rc to draw with (public so STATE can delete)
    int         priority;

    DRAW_THREAD();
    ~DRAW_THREAD();
    PIPE        *pPipe;       // generic pipe ptr
    void        SetRCDC( HGLRC rc, HDC hdc );
    BOOL        HasRC();
    HGLRC       GetRC();
    void        MakeRCCurrent();
    void        SetTexture( HTEXTURE htex );
    void        SetPipe( PIPE *pipe );
    BOOL        StartPipe();
    void        DrawPipe();
    void        KillPipe();
};

// Program existence instance

class NORMAL_STATE;
class FLEX_STATE;

class STATE {
public:
    HGLRC       shareRC;        // RC that objects are shared from

    PIPE        *pLeadPipe;     // lead pipe for chase scenarios

    int         nSlices;      // reference # of slices around a pipe
    BOOL        bTexture;       // global texture enable
    int         nTextures;
    TEXTURE     texture[MAX_TEXTURES];
    IPOINT2D    texRep[MAX_TEXTURES];

    VIEW        view;           // viewing parameters
    float       radius;         // 'reference' pipe radius value
    NODE_ARRAY  *nodes;         // for keeping track of draw space
    NORMAL_STATE *pNState;
    FLEX_STATE  *pFState;

    STATE( BOOL bFlexMode, BOOL bMultiPipes );
    ~STATE();
    void        Reshape( int width, int height, void *data );
    void        Repaint( LPRECT pRect, void *data );
    void        Draw( void *data );
    void        Finish( void *data );

private:
    int         drawMode;       // drawing mode (flex or normal for now)
    int         drawScheme;     // random or chase

    int         maxPipesPerFrame; // max number of separate pipes/frame
    int         nPipesDrawn;    // number of pipes drawn or drawing in frame
    int         maxDrawThreads; // max number of concurrently drawing pipes
    int         nDrawThreads;   // number of live threads
    DRAW_THREAD drawThreads[MAX_DRAW_THREADS];

    int         resetStatus;

    SS_DIGITAL_DISSOLVE_CLEAR ddClear;
    int         bCalibrateClear;

    void        GLInit();
    void        DrawValidate();  // validation to do before each Draw
    void        ResetView();
    void        FrameReset();
    void        Clear();
    void        ChooseNewLeadPipe();
    void        CompactThreadList();
    BOOL        LoadTextureFiles();
    BOOL        LoadTextureFiles( TEXFILE *pTexFile, int nTexFiles, 
                                  TEX_RES *pTexRes );
    void        CalcTexRepFactors();
    int         CalcMaxPipesPerFrame();
};

#endif // __state_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\sspipes.h ===
/******************************Module*Header*******************************\
* Module Name: sspipes.h
*
* Global header for 3D Pipes screen saver.
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#ifndef __sspipes_h__
#define __sspipes_h__

#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glaux.h>

#include <commctrl.h>

#include "sscommon.h"

#define DO_TIMING 1
#ifdef DO_TIMING
enum {
    TIMER_START = 0,
    TIMER_STOP,
    TIMER_TIMING,
    TIMER_RESET
};
extern void Timer( int mode );
extern int pipeCount;
#endif


#define iXX -1
#define fXX -0.01f

// These are absolute directions, with origin in center of screen,
// looking down -z

enum {
    PLUS_X = 0,
    MINUS_X,
    PLUS_Y,
    MINUS_Y,
    PLUS_Z,
    MINUS_Z,
    NUM_DIRS,
    DIR_NONE,
    DIR_STRAIGHT
};

#define NUM_DIV 16              // divisions in window in longest dimension

#define MAX_TEXTURES 8

#endif // __sspipes_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\state.cxx ===
/******************************Module*Header*******************************\
* Module Name: state.cxx
*
* STATE
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <sys/types.h>
#include <sys/timeb.h>
#include <time.h>
#include <windows.h>

#include "sspipes.h"
#include "dialog.h"
#include "state.h"
#include "pipe.h"
#include "npipe.h"
#include "fpipe.h"
#include "eval.h"

// default texture resource(s)

#define DEF_TEX_COUNT 1
TEX_RES gTexRes[DEF_TEX_COUNT] = { 
    { TEX_BMP, IDB_DEFTEX }
};

static void InitTexParams();

/******************************Public*Routine******************************\
* STATE constructor
*
* - global state init
* - translates variables set from the dialog boxes
*
\**************************************************************************/

//mf: since pass bXXX params why not do same with ulSurfStyle, fTesselFact,
// ulTexQual

STATE::STATE( BOOL bFlexMode, BOOL bMultiPipes )
{
    // various state values
    resetStatus = RESET_STARTUP_BIT;

    // Put initial hglrc in drawThreads[0]
    // This RC is also used for dlists and texture objects that are shared
    // by other RC's

    shareRC = wglGetCurrentContext();
    drawThreads[0].SetRCDC( shareRC, wglGetCurrentDC() );

    bTexture = FALSE;
    if( ulSurfStyle == SURFSTYLE_TEX ) {
        if( LoadTextureFiles( gTexFile, gnTextures, &gTexRes[0] ) )
            bTexture = TRUE;
    }
    else if( ulSurfStyle == SURFSTYLE_WIREFRAME ) {
        glPolygonMode( GL_FRONT_AND_BACK, GL_LINE );
    }
   
    // Initialize GL state for the initial RC (sets texture state, so
    // (must come after LoadTextureFiles())

    GLInit();

    // set 'reference' radius value

    radius = 1.0f;

    // convert tesselation from fTesselFact(0.0-2.0) to tessLevel(0-MAX_TESS)

    int tessLevel = (int) (fTesselFact * (MAX_TESS+1) / 2.0001f);
    nSlices = (tessLevel+2) * 4;

    // Allocate basic NODE_ARRAY
    // NODE_ARRAY size is determined in Reshape (based on window size)
    nodes = new NODE_ARRAY;

    // Set drawing mode, and initialize accordingly.  For now, either all normal
    // or all flex pipes are drawn, but they could be combined later.
    // Can assume here that if there's any possibility that normal pipes
    // will be drawn, NORMAL_STATE will be initialized so that dlists are
    // built
    
    // Again, since have either NORMAL or FLEX, set maxPipesPerFrame,
    // maxDrawThreads
    if( bMultiPipes )
        maxDrawThreads = MAX_DRAW_THREADS;
    else
        maxDrawThreads = 1;
    nDrawThreads = 0; // no active threads yet
    nPipesDrawn = 0;
    // maxPipesPerFrame is set in Reset()

    if( bFlexMode ) {
        drawMode = DRAW_FLEX;
        pFState = new FLEX_STATE( this );
        pNState = NULL;
    } else {
        drawMode = DRAW_NORMAL;
        pNState = new NORMAL_STATE( this );
        pFState = NULL;
    }

    // initialize materials

    if( bTexture )
        ss_InitTexMaterials();
    else
        ss_InitTeaMaterials();

    // default draw scheme
    drawScheme = FRAME_SCHEME_RANDOM;
}

/******************************Public*Routine******************************\
* STATE destructor
*
\**************************************************************************/

STATE::~STATE( )
{
    if( pNState )
        delete pNState;
    if( pFState )
        delete pFState;
    if( nodes )
        delete nodes;
    if( bTexture ) {
        for( int i = 0; i < nTextures; i ++ ) {
            ss_DeleteTexture( &texture[i] );
        }
    }

    // Delete any RC's - should be done by ~THREAD, but since common lib
    // deletes shareRC, have to do it here

    DRAW_THREAD *pdt = &drawThreads[0];
    for( int i = 0; i < MAX_DRAW_THREADS; i ++, pdt++ ) {
        if( pdt->hglrc && (pdt->hglrc != shareRC) ) {
            wglDeleteContext( pdt->hglrc );
        }
    }
}

/******************************Public*Routine******************************\
* CalcTexRepFactors 
*
\**************************************************************************/

void
STATE::CalcTexRepFactors()
{
    ISIZE winSize;
    POINT2D texFact;

    ss_GetScreenSize( &winSize );

    // Figure out repetition factor of texture, based on bitmap size and
    // screen size.
    //
    // We arbitrarily decide to repeat textures that are smaller than
    // 1/8th of screen width or height.

    for( int i = 0; i < nTextures; i++ ) {
        texRep[i].x = texRep[i].y = 1;

        if( (texFact.x = winSize.width / texture[i].width / 8.0f) >= 1.0f)
            texRep[i].x = (int) (texFact.x+0.5f);

        if( (texFact.y = winSize.height / texture[i].height / 8.0f) >= 1.0f)
            texRep[i].y = (int) (texFact.y+0.5f);
    }
    
    // ! If display list based normal pipes, texture repetition is embedded
    // in the dlists and can't be changed. So use the smallest rep factors.
    // mf: Should change this so smaller textures are replicated close to
    // the largest texture, then same rep factor will work well for all
    
    if( pNState ) {
        //put smallest rep factors in texRep[0]; (mf:this is ok for now, as
        // flex pipes and normal pipes don't coexist)
    
        for( i = 1; i < nTextures; i++ ) {
            if( texRep[i].x < texRep[0].x )
                texRep[0].x = texRep[i].x;
            if( texRep[i].y < texRep[0].y )
                texRep[0].y = texRep[i].y;
        }
    } 
}

/******************************Public*Routine******************************\
* LoadTextureFiles
*
* - Load user texture files.  If texturing on but no user textures, or
*   problems loading them, load default texture resource
* mf: later, may want to have > 1 texture resource
*
\**************************************************************************/

BOOL
STATE::LoadTextureFiles( TEXFILE *pTexFile, int nTexFiles, TEX_RES *pTexRes )
{
    // Set pixel store state

    glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

    // Try to load the bmp or rgb file

    // i counts successfully loaded textures
    for( int i = 0; nTexFiles; nTexFiles-- ) {
        if( ss_LoadTextureFile( &pTexFile[i], &texture[i] ) )  {
            // If texture object extension, set tex params here for each object
            if( ss_TextureObjectsEnabled() )
                InitTexParams();
            i++; // count another valid texture
        }
    }

    // set number of valid textures in state
    nTextures = i;

    if( nTextures == 0 ) {
        // No user textures, or none loaded successfully
        // Load default resource texture(s)
        nTextures = DEF_TEX_COUNT;
        for( i = 0; i < nTextures; i++, pTexRes++ ) {
            if( !ss_LoadTextureResource( pTexRes, &texture[i] ) ) {
                // shouldn't happen
                return FALSE;
            }
        }
    }

    CalcTexRepFactors();

    return TRUE;
}

/******************************Public*Routine******************************\
* GLInit
*
* - Sets up GL state
* - Called once for every context (rc)
*
\**************************************************************************/

void 
STATE::GLInit()
{
    static float ambient[] = {0.1f, 0.1f, 0.1f, 1.0f};
    static float diffuse[] = {1.0f, 1.0f, 1.0f, 1.0f};
    static float position[] = {90.0f, 90.0f, 150.0f, 0.0f};
    static float lmodel_ambient[] = {1.0f, 1.0f, 1.0f, 1.0f};
    static float lmodel_ambientTex[] = {0.6f, 0.6f, 0.6f, 0.0f};
    static float back_mat_diffuse[] = {0.0f, 0.0f, 1.0f};

    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);

    glFrontFace(GL_CCW);

    glDepthFunc(GL_LEQUAL);
    glEnable(GL_DEPTH_TEST);

    glEnable( GL_AUTO_NORMAL ); // needed for GL_MAP2_VERTEX (tea)

    if( bTexture )
        glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambientTex);
    else
        glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse);
    glLightfv(GL_LIGHT0, GL_POSITION, position);
    glEnable(GL_LIGHT0);
    glEnable(GL_LIGHTING);

#if 1
    glCullFace(GL_BACK);
    glEnable(GL_CULL_FACE);
#else
// debug
// back material for debugging
    glMaterialfv(GL_BACK, GL_DIFFUSE, back_mat_diffuse);

    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_TRUE );
#endif
    
    // Set texture modes
    if( bTexture ) {
        glEnable(GL_TEXTURE_2D);
        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
        InitTexParams();
    }
}

/**************************************************************************\
* InitTexParams
*
* Set texture parameters, globally, or per object if texture object extension
*
\**************************************************************************/

static void
InitTexParams()
{
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);

    switch( ulTexQuality ) {
       case TEXQUAL_HIGH:
          glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
          glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
            break;
       case TEXQUAL_DEFAULT:
       default:
          glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);
          glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
            break;
    }
}


/**************************************************************************\
* Repaint
*
* This is called when a WM_PAINT msg has been sent to the window.   The paint
* will overwrite the frame buffer, screwing up the scene if pipes is in single
* buffer mode.  We set resetStatus accordingly to clear things up on next
* draw. 
*
\**************************************************************************/

void
STATE::Repaint( LPRECT pRect, void *data)
{
    resetStatus |= RESET_REPAINT_BIT;
}

/**************************************************************************\
* Reshape
*   - called on resize, expose
*   - always called on app startup
*   - set new window size for VIEW object, and set resetStatus for validation
*     at draw time
*
\**************************************************************************/

void
STATE::Reshape(int width, int height, void *data)
{
    if( view.SetWinSize( width, height ) )
        resetStatus |= RESET_RESIZE_BIT;
}

/**************************************************************************\
* ResetView
*
* Called on FrameReset resulting from change in viewing paramters (e.g. from
* a Resize event).
\**************************************************************************/

void
STATE::ResetView()
{
    IPOINT3D numNodes;

    // Have VIEW calculate the node array size based on view params
    view.CalcNodeArraySize( &numNodes );

    // Resize the node array
    nodes->Resize( &numNodes );

    // Set GL viewing parameters for each active RC

    DRAW_THREAD *pThread = drawThreads;

    for( int i = 0; i < MAX_DRAW_THREADS; i ++, pThread++ ) {
        if( pThread->HasRC() ) {
            pThread->MakeRCCurrent();
            view.SetGLView();
        }
    }
}

/**************************************************************************\
* FrameReset
*
* Start a new frame of pipes
*
* The resetStatus parameter indicates what triggered the Reset.
*
\**************************************************************************/

static int PickRandomTexture( int i, int nTextures );

void 
STATE::FrameReset()
{    
    int i;
    float xRot, zRot;
    PIPE *pNewPipe;

#ifdef DO_TIMING
    Timer( TIMER_STOP );
#endif

    SS_DBGINFO( "Pipes STATE::FrameReset:\n" );

    // Kill off any active pipes ! (so they can shut down ok)

    DRAW_THREAD *pThread = drawThreads;
    for( i = 0; i < nDrawThreads; i ++, pThread++ ) {
        pThread->KillPipe();
    }
    nDrawThreads = 0;
    
    // Clear the screen
    Clear();

    // Check for window resize status
    if( resetStatus & RESET_RESIZE_BIT ) {
        ResetView();
    }

    // Reset the node states to empty
    nodes->Reset();

    // Call any pipe-specific state resets, and get any recommended
    // pipesPerFrame counts

    if( pNState ) {
        pNState->Reset();
    }
    if( pFState ) {
        pFState->Reset();
        //mf: maybe should figure out min spherical view dist
        xRot = ss_fRand(-5.0f, 5.0f);
        zRot = ss_fRand(-5.0f, 5.0f);
    }
    maxPipesPerFrame = CalcMaxPipesPerFrame();

    // Set new number of drawing threads

    if( maxDrawThreads > 1 ) {
        // Set maximum # of pipes per frame
        maxPipesPerFrame = (int) (maxPipesPerFrame * 1.5);

        // Set # of draw threads
        nDrawThreads = SS_MIN( maxPipesPerFrame, ss_iRand2( 2, maxDrawThreads ) );
        // Set chase mode if applicable, every now and then
        BOOL bUseChase = pNState || (pFState && pFState->OKToUseChase());
        if( bUseChase && (!ss_iRand(5)) ) {
            drawScheme = FRAME_SCHEME_CHASE;
        }
    } else {
        nDrawThreads = 1;
    }
    nPipesDrawn = 0;

    // for now, either all NORMAL or all FLEX for each frame

    pThread = drawThreads;

    for( i = 0; i < nDrawThreads; i ++, pThread++ ) {

        // Create hglrc if necessary, and init it

        if( !pThread->HasRC() ) {
            HDC hdc = wglGetCurrentDC();
            pThread->SetRCDC( wglCreateContext( hdc ), hdc );
            // also need to init each RC
            pThread->MakeRCCurrent();
#if 0
//mf: should get this working
            wglCopyContext( drawThreads[0].GetRC(), pThread->GetRC(), 0xffff );
#endif
            // Do GL Init for this new RC
            GLInit();

            // Set viewing params
            view.SetGLView();
            
            // Give this rc access to any dlists
            wglShareLists( shareRC, pThread->GetRC() );
        }
        else
            pThread->MakeRCCurrent();
        
        // Set up the modeling view

        glLoadIdentity();
        glTranslatef(0.0f, 0.0f, view.zTrans);

        // Rotate Scene
        glRotatef( view.yRot, 0.0f, 1.0f, 0.0f );

        // create approppriate pipe for this thread slot

        switch( drawMode ) {
            case DRAW_NORMAL:
                pNewPipe = (PIPE *) new NORMAL_PIPE(this);
                break;
            case DRAW_FLEX:
                // There are several kinds of FLEX pipes - have FLEX_STATE
                // decide which one to create
                pNewPipe = pFState->NewPipe( this );
                // rotate a bit around x and z as well
                // mf: ! If combining NORMAL and FLEX, same rotations must be 
                // applied to both
                glRotatef( xRot, 1.0f, 0.0f, 0.0f );
                glRotatef( zRot, 0.0f, 0.0f, 1.0f ); 
                break;
        }
        pThread->SetPipe( pNewPipe );

        if( drawScheme == FRAME_SCHEME_CHASE ) {
            if( i == 0 ) {
                // this will be the lead pipe
                pLeadPipe = pNewPipe;
                pNewPipe->SetChooseDirectionMethod( CHOOSE_DIR_RANDOM_WEIGHTED );
            } else {
                pNewPipe->SetChooseDirectionMethod( CHOOSE_DIR_CHASE );
            }
        }

        // If texturing, pick a random texture for this thread

        if( bTexture ) {
            int index = PickRandomTexture( i, nTextures );
            pThread->SetTexture( &texture[index] );

            // Flex pipes need to be informed of the texture, so they 
            // can dynamically calculate various texture params
            if( pFState )
                ((FLEX_PIPE *) pNewPipe)->SetTexParams( &texture[index], 
                                                        &texRep[index] );
        }

        // Launch the pipe (assumed: always more nodes than pipes starting, so
        // StartPipe cannot fail)

        // ! All pipe setup needs to be done before we call StartPipe, as this
        // is where the pipe starts drawing

        pThread->StartPipe();

        // Kind of klugey, but if in chase mode, I set chooseStartPos here,
        // since first startPos used in StartPipe() should be random
        if( (i == 0) && (drawScheme == FRAME_SCHEME_CHASE) )
            pNewPipe->SetChooseStartPosMethod( CHOOSE_STARTPOS_FURTHEST );

        nPipesDrawn++;
    }

    // Increment scene rotation for normal reset case
    if( resetStatus & RESET_NORMAL_BIT )
        view.IncrementSceneRotation();

    // clear reset status
    resetStatus = 0;

#ifdef DO_TIMING
    Timer( TIMER_START );
#endif
}


/**************************************************************************\
* CalcMaxPipesPerFrame
*
\**************************************************************************/

int
STATE::CalcMaxPipesPerFrame()
{
    int nCount=0, fCount=0;

    if( pFState )
        fCount = pFState->GetMaxPipesPerFrame();
    if( pNState )
        nCount = bTexture ? NORMAL_TEX_PIPE_COUNT : NORMAL_PIPE_COUNT;
    return SS_MAX( nCount, fCount );
}

/**************************************************************************\
* PickRandomTexture
*
* Pick a random texture index from a list.  Remove entry from list as it
* is picked.  Once all have been picked, or starting a new frame, reset.
*
* ! Routine not reentrant, should only be called by the main thread
* dispatcher (FrameReset)
\**************************************************************************/

static int
PickRandomTexture( int iThread, int nTextures )
{
    if( nTextures == 0 )
        return 0;

    static int pickSet[MAX_TEXTURES] = {0};
    static int nPicked = 0;
    int i, index;

    if( iThread == 0 )
        // new frame - force reset
        nPicked = nTextures;

    // reset condition
    if( ++nPicked > nTextures ) {
        for( i = 0; i < nTextures; i ++ ) pickSet[i] = 0;
        nPicked = 1; // cuz
    }

    // Pick a random texture index
    index = ss_iRand( nTextures );
    while( pickSet[index] ) {
        // this index has alread been taken, try the next one
        if( ++index >= nTextures )
            index = 0;
    }
    // Hopefully, the above loop will exit :).  This means that we have
    // found a texIndex that is available
    pickSet[index] = 1; // mark as taken
    return index;
}

/**************************************************************************\
* Clear
*
* Clear the screen.  Depending on resetStatus, use normal clear or
* fancy transitional clear.
\**************************************************************************/

void 
STATE::Clear()
{
    // clear the screen - any rc will do

    glClear(GL_DEPTH_BUFFER_BIT);

    if( resetStatus & RESET_RESIZE_BIT ) {
        // new window size - recalibrate the transitional clear

        // Calibration is set after a window resize, so window is already black
        ddClear.CalibrateClear( view.winSize.width, view.winSize.height, 2.0f );
    } else if( resetStatus & RESET_NORMAL_BIT )
        // do the normal transitional clear
        ddClear.Clear( view.winSize.width, view.winSize.height );
    else {
        // do a fast one-shot clear
        glClear( GL_COLOR_BUFFER_BIT );
    }
}


/**************************************************************************\
* DrawValidate
*
* Validation done before every Draw
*
* For now, this just involves checking resetStatus
*
\**************************************************************************/

void 
STATE::DrawValidate()
{    
    if( ! resetStatus )
        return;

    FrameReset();
}

/**************************************************************************\
* Draw
*
* - Top-level pipe drawing routine
* - Each pipe thread keeps drawing new pipes until we reach maximum number
*   of pipes per frame - then each thread gets killed as soon as it gets
*   stuck.  Once number of drawing threads reaches 0, we start a new
*   frame
*
\**************************************************************************/

void 
STATE::Draw(void *data)
{
    int nKilledThreads = 0;
    BOOL bChooseNewLead = FALSE;

    // Validate the draw state

    DrawValidate();

    // Check each pipe's status

    DRAW_THREAD *pThread = drawThreads;

    for( int i = 0; i < nDrawThreads; i++, pThread++  ) {
        if( pThread->pPipe->IsStuck() ) {
            if( ++nPipesDrawn > maxPipesPerFrame ) {
                // Reaching pipe saturation - kill this pipe thread

                if( (drawScheme == FRAME_SCHEME_CHASE) &&
                    (pThread->pPipe == pLeadPipe) ) 
                    bChooseNewLead = TRUE;

                pThread->KillPipe();
                nKilledThreads++;

            } else {
                // Start up another pipe
                if( ! pThread->StartPipe() )
                    // we won't be able to draw any more pipes this frame
                    // (probably out of nodes)
                    maxPipesPerFrame = nPipesDrawn;
            }
        }
    }

    // Whenever one or more pipes are killed, compact the thread list
    if( nKilledThreads ) {
        CompactThreadList();
        nDrawThreads -= nKilledThreads;
    }

    if( nDrawThreads == 0 ) {
        // This frame is finished - mark for reset on next Draw
        resetStatus |= RESET_NORMAL_BIT;
        return;
    }

    if( bChooseNewLead ) {
        // We're in 'chase mode' and need to pick a new lead pipe
        ChooseNewLeadPipe();
    }

    // Draw each pipe

    for( i = 0, pThread = drawThreads; i < nDrawThreads; i++, pThread++ ) {
        pThread->DrawPipe();
#ifdef DO_TIMING
        pipeCount++;
#endif
    }

    glFlush();
}


/**************************************************************************\
*
* CompactThreadList
*
* - Compact the thread list according to number of pipe threads killed
* - The pipes have been killed, but the RC's in each slot are still valid
*   and reusable.  So we swap up entries with valid pipes. This means that
*   the ordering of the RC's in the thread list will change during the life
*   of the program.  This should be OK.
*
\**************************************************************************/

#define SWAP_SLOT( a, b ) \
    DRAW_THREAD pTemp; \
    pTemp = *(a); \
    *(a) = *(b); \
    *(b) = pTemp;
    
void
STATE::CompactThreadList()
{
    if( nDrawThreads <= 1 )
        // If only one active thread, it must be in slot 0 from previous
        // compactions - so nothing to do
        return;

    int iEmpty = 0;
    DRAW_THREAD *pThread = drawThreads;

    for( int i = 0; i < nDrawThreads; i ++, pThread++ ) {
        if( pThread->pPipe ) {
            if( iEmpty < i ) {
                // swap active pipe thread and empty slot
                SWAP_SLOT( &(drawThreads[iEmpty]), pThread );
            }
            iEmpty++;
        }
    }
}

/**************************************************************************\
*
* ChooseNewLeadPipe
*
* Choose a new lead pipe for chase mode.
*
\**************************************************************************/

void
STATE::ChooseNewLeadPipe()
{
    // Pick one of the active pipes at random to become the new lead

    int iLead = ss_iRand( nDrawThreads );
    pLeadPipe = drawThreads[iLead].pPipe;
    pLeadPipe->SetChooseStartPosMethod( CHOOSE_STARTPOS_FURTHEST );
    pLeadPipe->SetChooseDirectionMethod( CHOOSE_DIR_RANDOM_WEIGHTED );
}

/******************************Public*Routine******************************\
* Finish
*
* - Called when GL window being closed
*
\**************************************************************************/
void 
STATE::Finish( void *data )
{
    delete (STATE *) data;
}

/**************************************************************************\
* DRAW_THREAD constructor
*
\**************************************************************************/

DRAW_THREAD::DRAW_THREAD()
{
    hdc = 0;
    hglrc = 0;
    pPipe = NULL;
    htex = (HTEXTURE) -1;
}

/**************************************************************************\
* DRAW_THREAD destructor
*
* Delete any GL contexts
*
* - can't Delete shareRC, as this is done by common lib, so had to move
*   this up to ~STATE
*
\**************************************************************************/

DRAW_THREAD::~DRAW_THREAD()
{
#if 0
    wglDeleteContext( hglrc );
#endif
}

/**************************************************************************\
* MakeRCCurrent
*
\**************************************************************************/

void 
DRAW_THREAD::MakeRCCurrent()
{
    if( hglrc != wglGetCurrentContext() )
        wglMakeCurrent( hdc, hglrc );
}

/**************************************************************************\
* SetRCDC
*
\**************************************************************************/

void 
DRAW_THREAD::SetRCDC( HGLRC rc, HDC Hdc )
{
    hglrc = rc;
    hdc = Hdc;
}

/**************************************************************************\
* SetPipe
*
\**************************************************************************/

void 
DRAW_THREAD::SetPipe( PIPE *pipe )
{
    pPipe = pipe;
}

/**************************************************************************\
* HasRC
*
\**************************************************************************/

BOOL
DRAW_THREAD::HasRC()
{
    return( hglrc != 0 );
}

/**************************************************************************\
* GetRC
*
\**************************************************************************/

HGLRC
DRAW_THREAD::GetRC()
{
    return hglrc;
}

/**************************************************************************\
* SetTexture
*
* - Set a texture for a thread
* - Cache the texture index for performance
\**************************************************************************/

void 
DRAW_THREAD::SetTexture( HTEXTURE hnewtex )
{
    if( hnewtex != htex )
    {
        htex = hnewtex;
        ss_SetTexture( htex );
    }
}


/**************************************************************************\
* DrawPipe
*
* - Draw pipe in thread slot, according to its type
*
\**************************************************************************/

void 
DRAW_THREAD::DrawPipe()
{
    MakeRCCurrent();

    switch( pPipe->type ) {
        case TYPE_NORMAL:
            ( (NORMAL_PIPE *) pPipe )->Draw();
            break;
        case TYPE_FLEX_REGULAR:
            ( (REGULAR_FLEX_PIPE *) pPipe )->Draw();
            break;
        case TYPE_FLEX_TURNING:
            ( (TURNING_FLEX_PIPE *) pPipe )->Draw();
            break;
    }
    glFlush();
}
/**************************************************************************\
* StartPipe
*
* Starts up pipe of the approppriate type.  If can't find an empty node
* for the pipe to start on, returns FALSE;
*
\**************************************************************************/

BOOL
DRAW_THREAD::StartPipe()
{
    MakeRCCurrent();

    // call pipe-type specific Start function

    switch( pPipe->type ) {
        case TYPE_NORMAL:
            ( (NORMAL_PIPE *) pPipe )->Start();
            break;
        case TYPE_FLEX_REGULAR:
            ( (REGULAR_FLEX_PIPE *) pPipe )->Start();
            break;
        case TYPE_FLEX_TURNING:
            ( (TURNING_FLEX_PIPE *) pPipe )->Start();
            break;
    }
    glFlush();

    // check status
    if( pPipe->NowhereToRun() )
        return FALSE;
    else
        return TRUE;
}

/**************************************************************************\
* KillPipe
*
\**************************************************************************/

void 
DRAW_THREAD::KillPipe()
{
    switch( pPipe->type ) {
        case TYPE_NORMAL:
            delete (NORMAL_PIPE *) pPipe;
            break;
        case TYPE_FLEX_REGULAR:
            delete (REGULAR_FLEX_PIPE *) pPipe;
            break;
        case TYPE_FLEX_TURNING:
            delete (TURNING_FLEX_PIPE *) pPipe;
            break;
    }
    pPipe = NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\view.cxx ===
/******************************Module*Header*******************************\
* Module Name: view.cxx
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <sys/types.h>
#include <sys/timeb.h>
#include <time.h>
#include <windows.h>

#include "sspipes.h"
#include "view.h"

/******************************Public*Routine******************************\
* VIEW constructor
*
* Nov. 95 [marcfo]
*
\**************************************************************************/

VIEW::VIEW()
{
    bProjMode = GL_TRUE;

    // set some initial viewing and size params

//mf: these should be defines
    zTrans = -75.0f;
    viewDist = -zTrans;

    numDiv = NUM_DIV;
    SS_ASSERT( numDiv >= 2, "VIEW constructor: not enough divisions\n" );
    // Because number of nodes in a dimension is derived from (numDiv-1), and
    // can't be 0

    divSize = 7.0f;

    persp.viewAngle = 90.0f;
    persp.zNear = 1.0f;

    yRot = 0.0f;

    winSize.width = winSize.height = 0; 
}

/******************************Public*Routine******************************\
* SetProjMatrix
*
* Set GL view parameters
*
* Nov. 95 [marcfo]
*
\**************************************************************************/

void
VIEW::SetGLView()
{
    glViewport(0, 0, winSize.width, winSize.height );
    SetProjMatrix();
}

/******************************Public*Routine******************************\
* SetProjMatrix
*
* Set Projection matrix
*
* Nov. 95 [marcfo]
*
\**************************************************************************/

void
VIEW::SetProjMatrix()
{
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    persp.zFar = viewDist + world.z*2;
    if( bProjMode ) {
        gluPerspective( persp.viewAngle, 
                        aspectRatio, 
                        persp.zNear, persp.zFar );
    }
    else {
        glOrtho( -world.x/2, world.x/2, -world.y/2, world.y/2,
                          -world.z, world.z );
    }
    glMatrixMode(GL_MODELVIEW);
}

/******************************Public*Routine******************************\
* CalcNodeArraySize
*
* Based on the viewing width and height, and numDiv, calculate the x,y,z array
* node dimensions.
*
\**************************************************************************/

void
VIEW::CalcNodeArraySize( IPOINT3D *pNodeDim )
{
    // mf: !!! if aspect ratio deviates too much from 1, then nodes will get
    // clipped as view rotates

    if( winSize.width >= winSize.height ) {
        pNodeDim->x = numDiv - 1;
        pNodeDim->y = (int) (pNodeDim->x / aspectRatio) ;
        if( pNodeDim->y < 1 )
            pNodeDim->y = 1;
        pNodeDim->z = pNodeDim->x;
    }
    else {
        pNodeDim->y = numDiv - 1;
        pNodeDim->x = (int) (aspectRatio * pNodeDim->y);
        if( pNodeDim->x < 1 )
            pNodeDim->x = 1;
        pNodeDim->z = pNodeDim->y;
    }
}

/******************************Public*Routine******************************\
* SetWinSize
*
* Set the window size for the view, derive other view params.
*
* Return FALSE if new size same as old.
\**************************************************************************/

BOOL
VIEW::SetWinSize( int width, int height )
{
    if( (width == winSize.width) &&
        (height == winSize.height) )
        return FALSE;

    winSize.width = width;
    winSize.height = height;

    aspectRatio = winSize.height == 0 ? 1.0f : (float)winSize.width/winSize.height;

    if( winSize.width >= winSize.height ) {
        world.x = numDiv * divSize;
        world.y = world.x / aspectRatio;
        world.z = world.x;
    }
    else {
        world.y = numDiv * divSize;
        world.x = world.y * aspectRatio;
        world.z = world.y;
    }
    return TRUE;
}

/******************************Public*Routine******************************\
* SetSceneRotation 
*
\**************************************************************************/

void
VIEW::IncrementSceneRotation()
{
    yRot += 9.73156f;
    if( yRot >= 360.0f )
        // prevent overflow
        yRot -= 360.0f;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\view.h ===
/******************************Module*Header*******************************\
* Module Name: view.h
*
* Node stuff
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#ifndef __view_h__
#define __view_h__

#include "sscommon.h"

typedef struct {
    float viewAngle;            // field of view angle for height
    float zNear;                // near z clip value
    float zFar;                 // far z clip value
} Perspective;  // perspective view description

class VIEW {
public:
    float       zTrans;         // z translation
    float       yRot;           // current yRotation
    float       viewDist;       // viewing distance, usually -zTrans
    int         numDiv;         // # grid divisions in x,y,z
    float       divSize;        // distance between divisions
    ISIZE       winSize;        // window size in pixels

    VIEW();
    BOOL        SetWinSize( int width, int height );
    void        SetGLView();
    void        CalcNodeArraySize( IPOINT3D *pNodeDim );
    void        SetProjMatrix();
    void        IncrementSceneRotation();
private:
    BOOL        bProjMode;      // projection mode
    Perspective persp;          // perspective view description
    float       aspectRatio;    // x/y window aspect ratio
    POINT3D     world;          // view area in world space
};

#endif // __view_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\text3d\dialog.c ===
/******************************Module*Header*******************************\
* Module Name: dialog.c
*
* Dialog box functions for the OpenGL-based 3D Text screen saver.
*
* Created: 12-24-94 -by- Marc Fortier [marcfo]
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/

#include <windows.h>
#include <commdlg.h>
#include <scrnsave.h>
#include <GL\gl.h>
#include <math.h>
#include <memory.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <malloc.h>
#include <sys\timeb.h>
#include <time.h>
#include "sscommon.h"
#include "sstext3d.h"

// Global screen saver settings.

static int idsStyles[NUM_DEMOS] =
    {IDS_DEMO_STRING, IDS_DEMO_CLOCK};

static int idsRotStyles[NUM_ROTSTYLES] =
{    IDS_ROTSTYLE_NONE,
     IDS_ROTSTYLE_SEESAW,
     IDS_ROTSTYLE_WOBBLE,
     IDS_ROTSTYLE_RANDOM
};

// local funtions

LONG WndProc(HWND, UINT, WPARAM, LPARAM);
static void InitAttrContext( AttrContext *pac );
static void getFont( HWND hDlg);
static void updateDialogControls(HWND hDlg);


/******************************Public*Routine******************************\
* getIniSettings
*
* Get the screen saver configuration options from .INI file/registry.
*
* History:
*  Jan. 95 -by- Marc Fortier [marcfo]
*    - Wrote it.
*  Apr. 28, 95 : [marcfo]
*    - Call common function ss_GetDefaultBmp to get a default bmp file
*  Nov. 95 [marcfo]
*    - Use ss registry helper functions
*
\**************************************************************************/

void
getIniSettings()
{
    int    options;
    int    optMask = 1;
    TCHAR  szDefaultBitmap[MAX_PATH];
    int    iPos;
    TCHAR  szDefaultFont[256];
    TCHAR  szDefCharSet[16];
    int    iDefCharSet;

    // Initialize the global AttrContext

    InitAttrContext( &gac );

    // Load resources

    LoadString(hMainInstance, IDS_GENNAME, szScreenSaver,
               sizeof(szScreenSaver) / sizeof(TCHAR));
    if (LoadString(hMainInstance, IDS_DEFFONT, szDefaultFont,
                   sizeof(szDefaultFont) / sizeof(TCHAR)) == 0)
    {
#ifdef UNICODE
        wcscpy(szDefaultFont, TEXT("Tahoma"));
#else
        strcpy(szDefaultFont, TEXT("Tahoma"));
#endif
    }
    iDefCharSet = ANSI_CHARSET;
    if (LoadString(hMainInstance, IDS_DEFCHARSET, szDefCharSet,
                   sizeof(szDefCharSet) / sizeof(TCHAR)) != 0)
    {
#ifdef UNICODE
        iDefCharSet = _wtoi(szDefCharSet);
#else
        iDefCharSet = atoi(szDefCharSet);
#endif
    }

    // Get registry settings

    if( ss_RegistrySetup( hMainInstance, IDS_SAVERNAME, IDS_INIFILE ) )
    {
        // get demo type

        gac.demoType = ss_GetRegistryInt( IDS_DEMOTYPE, DEMO_STRING );
        SS_CLAMP_TO_RANGE2( gac.demoType, 0, MAX_DEMO);

        // get rotation style

        gac.rotStyle = ss_GetRegistryInt( IDS_ROTSTYLE, ROTSTYLE_RANDOM );
        SS_CLAMP_TO_RANGE2( gac.rotStyle, 0, NUM_ROTSTYLES-1 );

        // get tesselation

        iPos = ss_GetRegistryInt( IDS_TESSELATION, 10 );
        SS_CLAMP_TO_RANGE2( iPos, MIN_SLIDER, MAX_SLIDER );
        gac.fTesselFact  = (float)iPos / 100.0f;

        // get size

        gac.uSize = ss_GetRegistryInt( IDS_SIZE, 50 );
        if ( gac.uSize > MAX_SLIDER )
            gac.uSize = MAX_SLIDER;
        // MIN_SLIDER is 0 so the unsigned uSize cannot ever be less than MIN_SLIDER

        // get speed

        gac.iSpeed = ss_GetRegistryInt( IDS_SPEED, 50 );
        SS_CLAMP_TO_RANGE2( gac.iSpeed, MIN_SLIDER, MAX_SLIDER );

        // get surface style

        gac.surfStyle = ss_GetRegistryInt( IDS_SURFSTYLE, SURFSTYLE_SOLID );
        SS_CLAMP_TO_RANGE2(gac.surfStyle, 0, SURFSTYLE_TEX);

        // get font, attributes, and charset

        ss_GetRegistryString( IDS_FONT, szDefaultFont,
                              gac.szFontName, LF_FACESIZE );

        options = ss_GetRegistryInt( IDS_FONT_ATTRIBUTES, 0 );
        if( options >= 0 ) {
            optMask = 1;
            gac.bBold = ((options & optMask) != 0);
            optMask <<=1;
            gac.bItalic = ((options & optMask) != 0);
        }

        gac.charSet = (BYTE)ss_GetRegistryInt( IDS_CHARSET, iDefCharSet );

        // get display string

        ss_GetRegistryString( IDS_TEXT, TEXT("OpenGL"), gac.szText, TEXT_LIMIT+1);

        // Determine the default .bmp file

        ss_GetDefaultBmpFile( szDefaultBitmap );


        // Is there a texture specified in the registry that overrides the
        // default?

        ss_GetRegistryString( IDS_TEXTURE, szDefaultBitmap, gac.texFile.szPathName,
                              MAX_PATH);

        gac.texFile.nOffset = ss_GetRegistryInt( IDS_TEXTURE_FILE_OFFSET, 0 );
    }
}


/**************************************************************************\
* ConfigInit
*
\**************************************************************************/
BOOL
ss_ConfigInit( HWND hDlg )
{
    return TRUE;
}

/**************************************************************************\
* InitAttrContext
*
* Initialize some of the values in the attribute context
*
* History:
*  Jan. 95 -by- Marc Fortier [marcfo]
* Wrote it.
\**************************************************************************/
static void
InitAttrContext( AttrContext *pac )
{
    // set some default values

    pac->demoType = DEMO_STRING;
    pac->surfStyle = SURFSTYLE_SOLID;
    pac->fTesselFact = 1.0f;
    pac->uSize = 50;
    pac->iSpeed = 50;
    pac->texFile.szPathName[0] = '\0';
    pac->texFile.nOffset = 0;
}

/******************************Public*Routine******************************\
* saveIniSettings
*
* Save the screen saver configuration option to the .INI file/registry.
*
* History:
*  Jan. 95 -by- Marc Fortier [marcfo]
* Wrote it.
*  Nov. 95 [marcfo]
*    - Use ss registry helper functions
\**************************************************************************/

static void
saveIniSettings(HWND hDlg)
{
    int options;
    int optMask = 1;

    GetWindowText( GetDlgItem(hDlg, DLG_TEXT_ENTER), gac.szText, TEXT_LIMIT+1);

    if( ss_RegistrySetup( hMainInstance, IDS_SAVERNAME, IDS_INIFILE ) )
    {
        ss_WriteRegistryInt( IDS_DEMOTYPE, gac.demoType );
        ss_WriteRegistryInt( IDS_ROTSTYLE, gac.rotStyle );
        ss_WriteRegistryInt( IDS_TESSELATION,
                    ss_GetTrackbarPos(hDlg, DLG_SETUP_TESSEL) );
        ss_WriteRegistryInt( IDS_SIZE,
                    ss_GetTrackbarPos(hDlg, DLG_SETUP_SIZE) );
        ss_WriteRegistryInt( IDS_SPEED,
                    ss_GetTrackbarPos(hDlg, DLG_SETUP_SPEED) );
        ss_WriteRegistryInt( IDS_SURFSTYLE, gac.surfStyle );
        ss_WriteRegistryString( IDS_FONT, gac.szFontName );

        optMask = 1;
        options = gac.bBold ? optMask : 0;
        optMask <<= 1;
        options |= gac.bItalic ? optMask : 0;
        ss_WriteRegistryInt( IDS_FONT_ATTRIBUTES, options );

        ss_WriteRegistryInt( IDS_CHARSET, gac.charSet );
        ss_WriteRegistryString( IDS_TEXT, gac.szText );
        ss_WriteRegistryString( IDS_TEXTURE, gac.texFile.szPathName );
        ss_WriteRegistryInt( IDS_TEXTURE_FILE_OFFSET, gac.texFile.nOffset );
    }
}

/******************************Public*Routine******************************\
* setupDialogControls
*
* Do initial setup of dialog controls.
*
* History:
*  Jan. 95 -by- Marc Fortier [marcfo]
* Wrote it.
\**************************************************************************/

static void
setupDialogControls(HWND hDlg)
{
    int pos;

    InitCommonControls();

    // initialize sliders

    // tesselation slider

    pos = (int)(gac.fTesselFact * 100.0f);
    ss_SetupTrackbar( hDlg, DLG_SETUP_TESSEL, MIN_SLIDER, MAX_SLIDER, 1, 9,
                      pos );

    // size slider

    ss_SetupTrackbar( hDlg, DLG_SETUP_SIZE, MIN_SLIDER, MAX_SLIDER, 1, 9,
                      gac.uSize );

    // speed slider

    ss_SetupTrackbar( hDlg, DLG_SETUP_SPEED, MIN_SLIDER, MAX_SLIDER, 1, 9,
                      gac.iSpeed);

    // set state of other controls

    updateDialogControls(hDlg);
}

/******************************Public*Routine******************************\
* updateDialogControls
*
* Updates dialog controls according to current state
*
* History:
*  Jan. 95 -by- Marc Fortier [marcfo]
* Wrote it.
\**************************************************************************/

static void
updateDialogControls(HWND hDlg)
{
    int pos;
    BOOL bTexSurf;
    BOOL bText;

    bTexSurf = (gac.surfStyle == SURFSTYLE_TEX );

    CheckDlgButton(hDlg, IDC_RADIO_SOLID, !bTexSurf );
    CheckDlgButton(hDlg, IDC_RADIO_TEX  , bTexSurf );

    // set up demo-specific configure button

    bText = (gac.demoType == DEMO_STRING) ? TRUE : FALSE;
    EnableWindow(GetDlgItem(hDlg, DLG_TEXT_ENTER), bText );
    CheckDlgButton(hDlg, IDC_DEMO_STRING, bText );
    CheckDlgButton(hDlg, IDC_DEMO_CLOCK, !bText );

    // texture: only enable if surfStyle is texture

    EnableWindow(GetDlgItem(hDlg, DLG_SETUP_TEX), bTexSurf );
}

/******************************Public*Routine******************************\
* getFont
*
* Calls ChooseFont dialog
*
* History:
*  Jan. 95 -by- Marc Fortier [marcfo]
* Wrote it.
\**************************************************************************/

static void
getFont( HWND hDlg)
{
    CHOOSEFONT cf = {0};
    LOGFONT    lf = {0};
    HFONT      hfont, hfontOld;
    HDC   hdc;

    hdc = GetDC( hDlg );

    // Create and select a font.

    cf.lStructSize = sizeof(CHOOSEFONT);
    cf.hwndOwner = hDlg;
    cf.lpLogFont = &lf;
    cf.hInstance = hMainInstance;
    cf.lpTemplateName = (LPTSTR) MAKEINTRESOURCE(IDD_FONT);
    cf.Flags = CF_SCREENFONTS | CF_INITTOLOGFONTSTRUCT | CF_TTONLY |
               CF_ENABLETEMPLATE | CF_NOSIMULATIONS;

    // setup logfont with current settings

    lstrcpy(lf.lfFaceName, gac.szFontName);
    lf.lfWeight = (gac.bBold) ? FW_BOLD : FW_NORMAL;
    lf.lfItalic = (gac.bItalic) ? (BYTE) 1 : 0;
    lf.lfCharSet = gac.charSet;
    lf.lfHeight = -37;  // value ???

    if( ChooseFont(&cf) ) {
        // retrieve settings into gac
        lstrcpy( gac.szFontName, lf.lfFaceName );
        gac.bBold = (lf.lfWeight == FW_NORMAL) ? FALSE : TRUE;
        gac.bItalic = (lf.lfItalic) ? TRUE : FALSE;
        gac.charSet = lf.lfCharSet;
    }
}

BOOL WINAPI RegisterDialogClasses(HANDLE hinst)
{
    return TRUE;
}

/******************************Public*Routine******************************\
* ScreenSaverConfigureDialog
*
* Processes messages for the configuration dialog box.
*
* History:
*  Jan. 95 -by- Marc Fortier [marcfo]
*    - Wrote it.
*  Apr. 28, 95 : [marcfo]
*    - Call common function ss_GetTextureBitmap to load bmp texture
*
\**************************************************************************/

BOOL ScreenSaverConfigureDialog(HWND hDlg, UINT message,
                                WPARAM wParam, LPARAM lParam)
{
    int wTmp;
    TCHAR szStr[GEN_STRING_SIZE];
    HANDLE hInst;
    BOOL    bEnable;
    HWND    hText;

    switch (message) {
        case WM_INITDIALOG:
            getIniSettings();
            setupDialogControls(hDlg);

            // setup rotStyle combo box
            for (wTmp = 0; wTmp < NUM_ROTSTYLES; wTmp++) {
                LoadString(hMainInstance, idsRotStyles[wTmp], szStr,
                            GEN_STRING_SIZE);
                SendDlgItemMessage(hDlg, DLG_SETUP_ROTSTYLE, CB_ADDSTRING, 0,
                                   (LPARAM) szStr);
            }
            SendDlgItemMessage(hDlg, DLG_SETUP_ROTSTYLE, CB_SETCURSEL,
                               gac.rotStyle, 0);

            // display current string in box
            SendDlgItemMessage( hDlg, DLG_TEXT_ENTER, EM_LIMITTEXT, TEXT_LIMIT,0);
            SetWindowText( GetDlgItem(hDlg, DLG_TEXT_ENTER), gac.szText );

            return TRUE;

        case WM_COMMAND:
            switch (LOWORD(wParam)) {
                case DLG_SETUP_TYPES:
                    switch (HIWORD(wParam))
                    {
                        case CBN_EDITCHANGE:
                        case CBN_SELCHANGE:
                            gac.demoType =
                                (int)SendDlgItemMessage(hDlg, DLG_SETUP_TYPES,
                                                        CB_GETCURSEL, 0, 0);
                            updateDialogControls(hDlg);
                            break;
                        default:
                            break;
                    }
                    return FALSE;

                case DLG_SETUP_ROTSTYLE:
                    switch (HIWORD(wParam))
                    {
                        case CBN_EDITCHANGE:
                        case CBN_SELCHANGE:
                            gac.rotStyle =
                                (int)SendDlgItemMessage(hDlg, DLG_SETUP_ROTSTYLE,
                                                        CB_GETCURSEL, 0, 0);
                            updateDialogControls(hDlg);
                            break;
                        default:
                            break;
                    }
                    return FALSE;

                case DLG_SETUP_TEX:
                    // Run choose texture dialog
                    ss_SelectTextureFile( hDlg, &gac.texFile );
                    break;

                case DLG_SETUP_FONT:
                    getFont(hDlg);
                    break;

                case IDC_RADIO_SOLID:
                case IDC_RADIO_TEX:
                    gac.surfStyle = IDC_TO_SURFSTYLE( LOWORD(wParam) );
                    updateDialogControls(hDlg);
                    break;

                case IDC_DEMO_STRING:
                case IDC_DEMO_CLOCK:
                    gac.demoType = IDC_TO_DEMOTYPE( LOWORD(wParam) );
                    updateDialogControls(hDlg);
                    if( LOWORD(wParam) == IDC_DEMO_STRING ) {
                        // set selected text focus
                        SetFocus( GetDlgItem(hDlg, DLG_TEXT_ENTER) );
                        SendDlgItemMessage( hDlg, DLG_TEXT_ENTER,
                                            EM_SETSEL, 0, -1 );
                    }
                    break;

                case IDOK:
                    saveIniSettings(hDlg);
                    EndDialog(hDlg, TRUE);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, FALSE);
                    break;

                default:
                    break;
            }
            return TRUE;
            break;

        default:
            return 0;
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\xc.cxx ===
/******************************Module*Header*******************************\
* Module Name: xc.cxx
*
* Cross-section (xc) object stuff
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <sys/types.h>
#include <time.h>
#include <windows.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glaux.h>
#include <float.h>

#include "sscommon.h"
#include "sspipes.h"
#include "eval.h"
#include "xc.h"

/**************************************************************************\
* XC::CalcArcACValues90
*
* Calculate arc control points for a 90 degree rotation of an xc
*
* Arc is a quarter-circle
* - 90 degree is much easier, so we special case it
* - radius is distance from xc-origin to hinge of turn
*
* History
*  July 28, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

void
XC::CalcArcACValues90( int dir, float radius, float *acPts )
{
    int i;
    float sign;
    int offset;
    float *ppts = (float *) pts;

    // 1) calc 'r' values for each point (4 turn possibilities/point).  From
    //  this can determine ac, which is extrusion of point from xc face

    switch( dir ) {
        case PLUS_X:
            offset = 0;
            sign = -1.0f;
            break;
        case MINUS_X:
            offset = 0;
            sign =  1.0f;
            break;
        case PLUS_Y:
            offset = 1;
            sign = -1.0f;
            break;
        case MINUS_Y:
            offset = 1;
            sign =  1.0f;
            break;
    }

    for( i = 0; i < numPts; i++, ppts+=2, acPts++ ) {
        *acPts = EVAL_CIRC_ARC_CONTROL * (radius + (sign * ppts[offset]));
    }
    // replicate !
    *acPts = *(acPts - numPts);
}

/**************************************************************************\
* XC::CalcArcACValuesByDistance
*
* Use the distance of each xc point from the xc origin, as the radius for
* an arc control value.
*
* History
*  July 29, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

void
XC::CalcArcACValuesByDistance( float *acPts )
{
    int i;
    float r;
    POINT2D *ppts =  pts;

    for( i = 0; i < numPts; i++, ppts++ ) {
        r = (float) sqrt( ppts->x*ppts->x + ppts->y*ppts->y );
        *acPts++ = EVAL_CIRC_ARC_CONTROL * r;
    }
    // replicate !
    *acPts = *(acPts - numPts);
}

/**************************************************************************\
* ELLIPTICAL_XC::SetControlPoints
*
* Set the 12 control points for a circle at origin in z=0 plane
*
* Points go CCW from +x
*
* History
*  July 24, 95 : [marcfo]
*    - Wrote it
*  - 10/18/95 [marcfo] : Convert to C++
*
\**************************************************************************/

void 
ELLIPTICAL_XC::SetControlPoints( GLfloat r1, GLfloat r2 )
{
    GLfloat ac1, ac2; 

    ac1 = EVAL_CIRC_ARC_CONTROL * r2;
    ac2 = EVAL_CIRC_ARC_CONTROL * r1;

    // create 12-pt. set CCW from +x

    // last 2 points of right triplet
    pts[0].x = r1;
    pts[0].y = 0.0f;
    pts[1].x = r1;
    pts[1].y = ac1;

    // top triplet
    pts[2].x = ac2;
    pts[2].y = r2;
    pts[3].x = 0.0f;
    pts[3].y = r2;
    pts[4].x = -ac2;
    pts[4].y = r2;

    // left triplet
    pts[5].x = -r1;
    pts[5].y = ac1;
    pts[6].x = -r1;
    pts[6].y = 0.0f;
    pts[7].x = -r1;
    pts[7].y = -ac1;

    // bottom triplet
    pts[8].x = -ac2;
    pts[8].y = -r2;
    pts[9].x = 0.0f;
    pts[9].y = -r2;
    pts[10].x = ac2;
    pts[10].y = -r2;

    // first point of first triplet
    pts[11].x = r1;
    pts[11].y = -ac1;
}

/**************************************************************************\
* RANDOM4ARC_XC::SetControlPoints
*
* Set random control points for xc
* Points go CCW from +x
*
* History
*  July 30, 95 : [marcfo]
*    - Wrote it
*  - 10/18/95 [marcfo] : Convert to C++
*
\**************************************************************************/

void 
RANDOM4ARC_XC::SetControlPoints( float radius )
{
    int i;
    GLfloat r[4];
    float rMin = 0.5f * radius;
    float distx, disty;

    // figure the radius of each side first

    for( i = 0; i < 4; i ++ )
        r[i] = ss_fRand( rMin, radius );

    // The 4 r's now describe a box around the origin - this restricts stuff

    // Now need to select a point along each edge of the box as the joining
    // points for each arc (join points are at indices 0,3,6,9)

    pts[0].x = r[RIGHT];
    pts[3].y = r[TOP];
    pts[6].x = -r[LEFT];
    pts[9].y = -r[BOTTOM];

    // quarter of distance between edges
    disty = (r[TOP] - -r[BOTTOM]) / 4.0f;
    distx = (r[RIGHT] - -r[LEFT]) / 4.0f;
    
    // uh, put'em somwhere in the middle half of each side
    pts[0].y = ss_fRand( -r[BOTTOM] + disty, r[TOP] - disty );
    pts[6].y = ss_fRand( -r[BOTTOM] + disty, r[TOP] - disty );
    pts[3].x = ss_fRand( -r[LEFT] + distx, r[RIGHT] - distx );
    pts[9].x = ss_fRand( -r[LEFT] + distx, r[RIGHT] - distx );

    // now can calc ac's
    // easy part first:
    pts[1].x = pts[11].x = pts[0].x;
    pts[2].y = pts[4].y = pts[3].y;
    pts[5].x = pts[7].x = pts[6].x;
    pts[8].y = pts[10].y = pts[9].y;

    // right side ac's
    disty = (r[TOP] - pts[0].y) / 4.0f;
    pts[1].y = ss_fRand( pts[0].y + disty, r[TOP] );
    disty = (pts[0].y - -r[BOTTOM]) / 4.0f;
    pts[11].y = ss_fRand( -r[BOTTOM], pts[0].y - disty );

    // left side ac's
    disty = (r[TOP] - pts[6].y) / 4.0f;
    pts[5].y = ss_fRand( pts[6].y + disty, r[TOP]);
    disty = (pts[6].y - -r[BOTTOM]) / 4.0f;
    pts[7].y = ss_fRand( -r[BOTTOM], pts[6].y - disty );

    // top ac's
    distx = (r[RIGHT] - pts[3].x) / 4.0f;
    pts[2].x = ss_fRand( pts[3].x + distx, r[RIGHT] );
    distx = (pts[3].x - -r[LEFT]) / 4.0f;
    pts[4].x = ss_fRand( -r[LEFT],  pts[3].x - distx );

    // bottom ac's
    distx = (r[RIGHT] - pts[9].x) / 4.0f;
    pts[10].x = ss_fRand( pts[9].x + distx, r[RIGHT] );
    distx = (pts[9].x - -r[LEFT]) / 4.0f;
    pts[8].x = ss_fRand( -r[LEFT], pts[9].x - distx );
}


/**************************************************************************\
* ConvertPtsZ
*
* Convert the 2D pts in an xc, to 3D pts in point buffer, with z.
*
* Also replicate the last point.
*
*  July 28, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

void
XC::ConvertPtsZ( POINT3D *newpts, float z )
{
    int i;
    POINT2D *xcPts = pts;

    for( i = 0; i < numPts; i++, newpts++ ) {
        *( (POINT2D *) newpts ) = *xcPts++;
        newpts->z = z;
    }
    *newpts = *(newpts - numPts);
}

/**************************************************************************\
* XC::CalcBoundingBox
* 
* Calculate bounding box in x/y plane for xc
*
*  July 28, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/


void 
XC::CalcBoundingBox( )
{
    POINT2D *ppts = pts;
    int i;
    float xMin, xMax, yMax, yMin;

    // initialize to really insane numbers
    xMax = yMax = -FLT_MAX;
    xMin = yMin = FLT_MAX;

    // compare with rest of points
    for( i = 0; i < numPts; i ++, ppts++ ) {
        if( ppts->x < xMin )
            xMin = ppts->x;
        else if( ppts->x > xMax )
            xMax = ppts->x;
        if( ppts->y < yMin )
            yMin = ppts->y;
        else if( ppts->y > yMax )
            yMax = ppts->y;
    }
    xLeft = xMin;
    xRight = xMax;
    yBottom = yMin;
    yTop = yMax;
}

/**************************************************************************\
*
* MinTurnRadius
*
* Get minimum radius for the xc to turn in given direction. 
*
* If the turn radius is less than this minimum, then primitive will 'fold'
* over itself at the inside of the turn, creating ugliness.
*
* History
*  July 27, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

float
XC::MinTurnRadius( int relDir )
{
//mf: for now, assume xRight, yTop positive, xLeft, yBottom negative
// otherwise, might want to consider 'negative'radius
    switch( relDir ) {
        case PLUS_X:
            return( xRight );
        case MINUS_X:
            return( - xLeft );
        case PLUS_Y:
            return( yTop );
        case MINUS_Y:
            return( - yBottom );
        default:
            return(0.0f);
    }
}
/**************************************************************************\
*
* XC::MaxExtent
*
* Get maximum extent of the xc in x and y
*
* History
*  Aug. 1, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

float
XC::MaxExtent( )
{
    float max;

    max = xRight;

    if( yTop > max )
        max = yTop;
    if( -xLeft > max )
        max = -xLeft;
    if( -yBottom > max )
        max = -yBottom;

    return max;
}

/**************************************************************************\
* 
* XC::Scale
* 
* Scale an XC's points and extents by supplied scale value
*
\**************************************************************************/

void
XC::Scale( float scale )
{
    int i;
    POINT2D *ppts = pts;

    for( i = 0; i < numPts; i ++, ppts++ ) {
        ppts->x *= scale;
        ppts->y *= scale;
    }

    xLeft *= scale;
    xRight *= scale;
    yBottom *= scale;
    yTop *= scale;
}

/**************************************************************************\
* ~XC::XC
*
* Destructor
*
\**************************************************************************/

XC::~XC()
{
    if( pts )
        LocalFree( pts );
}

/**************************************************************************\
* XC::XC
*
* Constructor
*
* - Allocates point buffer for the xc
*
\**************************************************************************/

XC::XC( int nPts )
{
    numPts = nPts;
    pts = (POINT2D *)  LocalAlloc( LMEM_FIXED, numPts * sizeof(POINT2D) );
    SS_ASSERT( pts != 0, "XC constructor\n" );
}

#if 0
/**************************************************************************\
* XC::XC
*
* Constructor
*
* - Copies data from another XC
*
\**************************************************************************/

//mf: couldn't get calling this to work (compile time)
XC::XC( const XC& xc )
{
    numPts = xc.numPts;
    pts = (POINT2D *)  LocalAlloc( LMEM_FIXED, numPts * sizeof(POINT2D) );
    SS_ASSERT( pts != 0, "XC constructor\n" );
    RtlCopyMemory( pts, xc.pts, numPts * sizeof(POINT2D) );

    xLeft = xc.xLeft;
    xRight = xc.xRight;
    yBottom = xc.yBottom;
    yTop = xc.yTop;
}
#endif

XC::XC( XC *xc )
{
    numPts = xc->numPts;
    pts = (POINT2D *)  LocalAlloc( LMEM_FIXED, numPts * sizeof(POINT2D) );
    SS_ASSERT( pts != 0, "XC constructor\n" );
    RtlCopyMemory( pts, xc->pts, numPts * sizeof(POINT2D) );

    xLeft = xc->xLeft;
    xRight = xc->xRight;
    yBottom = xc->yBottom;
    yTop = xc->yTop;
}

/**************************************************************************\
*
* ELLIPTICAL_XC::ELLIPTICALXC
*
* Elliptical XC constructor

* These have 4 sections of 4 pts each, with pts shared between sections.
*
\**************************************************************************/

ELLIPTICAL_XC::ELLIPTICAL_XC( float r1, float r2 )
    // initialize base XC with numPts
    : XC( (int) EVAL_XC_CIRC_SECTION_COUNT * (EVAL_ARC_ORDER - 1))
{
    SetControlPoints( r1, r2 );
    CalcBoundingBox( );
}

/**************************************************************************\
*
* RANDOM4ARC_XC::RANDOM4ARC_XC
*
* Random 4-arc XC constructor

* The bounding box is 2*r each side
* These have 4 sections of 4 pts each, with pts shared between sections.
*
\**************************************************************************/
RANDOM4ARC_XC::RANDOM4ARC_XC( float r )
    // initialize base XC with numPts
    : XC( (int) EVAL_XC_CIRC_SECTION_COUNT * (EVAL_ARC_ORDER - 1))
{
    SetControlPoints( r );
    CalcBoundingBox( );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\pipes\xc.h ===
#ifndef __xc_h__
#define __xc_h__

#include "sscommon.h"


// useful for xc-coords
enum {
    RIGHT = 0,
    TOP,
    LEFT,
    BOTTOM
};

// Cross_section (xc) class

class XC {
public:
    GLfloat     xLeft, xRight;  // bounding box
    GLfloat     yTop, yBottom;
    int         numPts;
    POINT2D     *pts;        // CW points around the xc, from +x

    XC( int numPts );
    XC( const XC& xc );
    XC( XC *xc );
    ~XC();
    void        Scale( float scale );
    float       MaxExtent();
    float       MinTurnRadius( int relDir );
    void        CalcArcACValues90( int dir, float r, float *acPts );
    void        CalcArcACValuesByDistance(  float *acPts );
    void        ConvertPtsZ( POINT3D *pts, float z );
protected:
    void        CalcBoundingBox();
};

// Specific xc's derived from base xc class

class ELLIPTICAL_XC : public XC {
public:
    ELLIPTICAL_XC( float r1, float r2 );
    ~ELLIPTICAL_XC();
private:
    void SetControlPoints( float r1, float r2 );
};

class RANDOM4ARC_XC : public XC {
public:
    RANDOM4ARC_XC( float r );
    ~RANDOM4ARC_XC();
private:
    void SetControlPoints( float radius );
};

#endif __xc_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\text3d\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sstext3d.rc
//
#define IDI_ICON1                       103
#define IDD_DIALOG1                     104
#define IDC_BUTTON1                     1022
#define IDC_EDIT1                       1023
#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        106
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1042
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\text3d\font.c ===
/******************************Module*Header*******************************\
* Module Name: font.c
*
* Font and text handling for the OpenGL-based 3D Text screen saver.
*
* Created: 12-24-94 -by- Marc Fortier [marcfo]
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <commdlg.h>
#include <ptypes32.h>
#include <pwin32.h>
#include <stdio.h>
#include <stdlib.h>
#include <memory.h>
#include <float.h> // for FLT_MAX
#include <GL/gl.h>
#include "sscommon.h"
#include "sstext3d.h"

#ifndef UNICODE
// Support dbcs characters (this is a patch)
#define SS_DBCS_SUPPORT 1
#endif

static LISTENTRY* FindExtendedLUTEntry( TCHAR c, WglFontContext *pwfc );
static BOOL UpdateReducedFontList( TCHAR c, LISTENTRY *ple, 
                                   WglFontContext *pwfc );
#ifdef SS_DBCS_SUPPORT
static BOOL UpdateReducedFontListDBCS( DWORD c, LISTENTRY *ple, 
                                       WglFontContext *pwfc );
#endif
static void DeleteExtendedLUTTableEntries( WglFontContext *pwfc );
static void DeleteDirectLUTTableEntries( WglFontContext *pwfc );
static void DeleteLUTEntry( LISTENTRY *ple );

/******************************Public*Routine******************************\
* CreateWglFontContext
*
* Create a WglFontContext.
*
* Initializes the look-up-table memory for characters.
* The first half of this table is a direct look-up, using the char value.
* The second half is used for unicode chars that are >256, and must be
* searched sequentially.
*
\**************************************************************************/

WglFontContext *
CreateWglFontContext( HDC hdc, int type, float fExtrusion, 
                      float fChordalDeviation )
{
    WglFontContext *pwfc;

    pwfc = (WglFontContext *) LocalAlloc( LMEM_FIXED, sizeof(WglFontContext) );
    if( !pwfc ) {
        SS_ALLOC_FAILURE( "CreateWglFontContext" );
        return NULL;
    }

    pwfc->hdc = hdc;
    pwfc->type = type;
    pwfc->extrusion = fExtrusion;
    pwfc->chordalDeviation = fChordalDeviation;

    pwfc->listLUT = (LISTENTRY*) LocalAlloc( LMEM_FIXED | LMEM_ZEROINIT, 
                                      SIZE_LIST_LUT * sizeof(LISTENTRY) );

    if( !pwfc->listLUT ) {
        LocalFree( pwfc );
        SS_ALLOC_FAILURE( "CreateWglFontContext" );
        return NULL;
    }

    pwfc->LUTIndex = 0;

    return pwfc;
}

/******************************Public*Routine******************************\
* DeleteWglFontContext
*
* Delete a WglFontContext.
*
\**************************************************************************/

void
DeleteWglFontContext( WglFontContext *pwfc )
{
    if( !pwfc )
        return;

    // Delete the extended lut table entries
    DeleteExtendedLUTTableEntries( pwfc );

    // Delete the direct lut table entries
    DeleteDirectLUTTableEntries( pwfc );
    
    if( pwfc->listLUT )
        LocalFree( pwfc->listLUT );

    LocalFree( pwfc );
}


/******************************Public*Routine******************************\
* DeleteExtendedLUTTablEntries
*
\**************************************************************************/

static void
DeleteExtendedLUTTableEntries( WglFontContext *pwfc )
{
    int i;
    LISTENTRY *ple = pwfc->listLUT + MAX_DIRECT_LUT;

    for( i = 0; i < pwfc->LUTIndex; i ++, ple++ )
        DeleteLUTEntry( ple );

    pwfc->LUTIndex = 0;
}

/******************************Public*Routine******************************\
* DeleteDirectLUTTablEntries
*
\**************************************************************************/

static void
DeleteDirectLUTTableEntries( WglFontContext *pwfc )
{
    int i;
    LISTENTRY *ple = pwfc->listLUT;

    for( i = 0; i < MAX_DIRECT_LUT; i ++, ple++ )
        DeleteLUTEntry( ple );
}

/******************************Public*Routine******************************\
* DeleteLUTEntry
*
\**************************************************************************/

static void
DeleteLUTEntry( LISTENTRY *ple )
{
    if( ple->listNum ) {
        glDeleteLists( ple->listNum, 1 );
        ple->listNum = 0;
    }
    if( ple->lpgmf ) {
        LocalFree( ple->lpgmf );
        ple->lpgmf = NULL;
    }
    ple->glyph = 0;
}

/**************************************************************************\
* ConvertStringToList
*
* - Translate the string into display list numbers
* - If no entry in the list table, update the table
*
\**************************************************************************/
void
ConvertStringToList( LPTSTR pszSrc, USHORT *usDst, WglFontContext *pwfc )
{
    int strLen;
    LISTENTRY *ple;
    TCHAR c;
    TUCHAR cindex; // use unsigned TCHAR for table indexing
#ifdef SS_DBCS_SUPPORT
    BOOL bIsLeadByte;
#endif

    if( !pwfc )
        return;

    /* Go thru the string, making sure every char has a display list
     * Copy the display list # into usDst
     */

    strLen = lstrlen( pszSrc );
    if( strLen > TEXT_BUF_SIZE )
        strLen = TEXT_BUF_SIZE;

    /* Check for possible overflow with the extended LUT section, and
     * invalidate the extended LUT if so
     */
    if( pwfc->LUTIndex ) {
        int roomLeft; // spaces left in extended lut table

        roomLeft = SIZE_LIST_LUT - (pwfc->LUTIndex + MAX_DIRECT_LUT +1);
        if( roomLeft < strLen ) {
            /* If none of the characters in this string have entries in the
             * table, we'll run out of room.  Assume the worst, invalidate
             * the whole table, and start over again.
             */
            DeleteExtendedLUTTableEntries( pwfc );
        }
    }

    for( ; strLen; strLen--, pszSrc++ ) {
        c = *pszSrc;
        cindex = (TUCHAR) c;

        // see if char already has cmd list entry - if not, create it
#ifdef SS_DBCS_SUPPORT
        bIsLeadByte = IsDBCSLeadByte(cindex);
        if( !bIsLeadByte && (cindex < MAX_DIRECT_LUT) ) {  // direct LUT
#else
        if( cindex < MAX_DIRECT_LUT ) {  // direct LUT entry
#endif
            ple = &pwfc->listLUT[cindex];
            if( !ple->listNum ) {
                // have to create new cmd list for this glyph
                if( ! UpdateReducedFontList( c, ple, pwfc ) ) {
                    DeleteLUTEntry( ple );
                    continue;
                }
            }
        } else {  // extended LUT entry
#ifdef SS_DBCS_SUPPORT
            DWORD dwChar;
            if( bIsLeadByte ) {
                // Iterate over the lead byte
                pszSrc++;
                strLen--;
                c = *pszSrc;
                // Setup the double byte word so that :
                //   High byte is the lead byte
                //   Low byte is the next byte in the byte stream (this byte
                //   will be used to access the extended lut table)
                dwChar = (DWORD) ( (cindex << 8) | ((TUCHAR) c)  );
            } else
                dwChar = (DWORD) (TUCHAR) c;

            if( !(ple = FindExtendedLUTEntry( c, pwfc )) ) {
                ple = &pwfc->listLUT[pwfc->LUTIndex+MAX_DIRECT_LUT];
                if( ! UpdateReducedFontListDBCS( dwChar, ple, pwfc ) ) {
                    DeleteLUTEntry( ple );
                    continue;
                }
                ple->glyph = c;
                pwfc->LUTIndex++;
            }
#else
            if( !(ple = FindExtendedLUTEntry( c, pwfc )) ) {
                ple = &pwfc->listLUT[pwfc->LUTIndex+MAX_DIRECT_LUT];
                if( ! UpdateReducedFontList( c, ple, pwfc ) ) {
                    DeleteLUTEntry( ple );
                    continue;
                }
                ple->glyph = c;
                pwfc->LUTIndex++;
            }
#endif
        }
        *usDst++ = ple->listNum;
    }
    // zero terminate
    *usDst = 0;
}

/******************************Public*Routine******************************\
* UpdateReducedFontList
*
* Calls wglUseFontOutlines() to create a command list for the supplied
* character.
*
* Allocates memory for the characters glyphmetrics as well
*
\**************************************************************************/
static BOOL 
UpdateReducedFontList( TCHAR c, LISTENTRY *ple, WglFontContext *pwfc )
{
    ple->lpgmf = (LPGLYPHMETRICSFLOAT) LocalAlloc( LMEM_FIXED,
                                                sizeof( GLYPHMETRICSFLOAT ) );

    if( !ple->lpgmf ) {
        SS_ALLOC_FAILURE( "UpdateReducedFontList" );
        return FAILURE;
    }

    // get next list # for this glyph.
    ple->listNum = (USHORT) glGenLists( 1 );
    if( !ple->listNum ) {
        SS_WARNING( "glGenLists failed\n" );
        return FAILURE;
    }

    if( !wglUseFontOutlines(pwfc->hdc, (TUCHAR) c, 1, ple->listNum, 
               pwfc->chordalDeviation, 
               pwfc->extrusion, 
               pwfc->type, ple->lpgmf) ) {
        SS_WARNING( "wglUseFontOutlines failed\n" );
        return FAILURE;
    }
    return SUCCESS;
}

#ifdef SS_DBCS_SUPPORT

// Modified version of UpdateReducedFontList that handles dbcs characters.
// This is a *patch* (as is all the SS_DBCS_SUPPORT stuff) to handle dbcs
// characters without jeopardizing SUR release stability.  Later, the functions
// can be consolidated.

static BOOL 
UpdateReducedFontListDBCS( DWORD c, LISTENTRY *ple, WglFontContext *pwfc )
{
    ple->lpgmf = (LPGLYPHMETRICSFLOAT) LocalAlloc( LMEM_FIXED,
                                                sizeof( GLYPHMETRICSFLOAT ) );

    if( !ple->lpgmf ) {
        SS_ALLOC_FAILURE( "UpdateReducedFontList" );
        return FAILURE;
    }

    // get next list # for this glyph.
    ple->listNum = (USHORT) glGenLists( 1 );
    if( !ple->listNum ) {
        SS_WARNING( "glGenLists failed\n" );
        return FAILURE;
    }

    if( !wglUseFontOutlines(pwfc->hdc, c, 1, ple->listNum, 
               pwfc->chordalDeviation, 
               pwfc->extrusion, 
               pwfc->type, ple->lpgmf) ) {
        SS_WARNING( "wglUseFontOutlines failed\n" );
        return FAILURE;
    }
    return SUCCESS;
}
#endif

/******************************Public*Routine******************************\
* FindExtendedLUTEntry
*
* Searches through the extended character LUT, and returns ptr to the
* char's info if found, otherwise NULL.
*
\**************************************************************************/

static LISTENTRY*
FindExtendedLUTEntry( TCHAR c, WglFontContext *pwfc )
{
    int i;
    LISTENTRY *ple = pwfc->listLUT + MAX_DIRECT_LUT;

    for( i = 0; i < pwfc->LUTIndex; i ++, ple++ ) {
        if( ple->glyph == c )
            return ple;
    }
    return NULL;
}

/******************************Public*Routine******************************\
* DrawString
*
* Draws string by calling cmd list for each char.
*
\**************************************************************************/

void
DrawString(  USHORT           *string,
             int              strLen,
             WglFontContext   *pwfc )
{
    if( !pwfc )
        return;

    glCallLists(strLen, GL_UNSIGNED_SHORT, (GLushort *) string);
}

/******************************Public*Routine******************************\
* GetStringExtent
*
* Calculate a string's origin and extent in world coordinates.  
* 
* The origin is determined by the first character's location, and thereafter 
* each char's location is determined by adding the previous char's cellInc 
* values.
* 
* This will work for all string orientations.
*
\**************************************************************************/

int 
GetStringExtent(  LPTSTR          szString, 
                  POINTFLOAT      *extent,
                  POINTFLOAT      *origin,
                  WglFontContext  *pwfc )
{

    int len, strLen;
    TCHAR *c;
    TUCHAR cindex;
    LPGLYPHMETRICSFLOAT lpgmf;
    POINTFLOAT cellOrigin = {0.0f, 0.0f};
    POINTFLOAT extentOrigin = {FLT_MAX, -FLT_MAX};
    POINTFLOAT extentLowerRight = {-FLT_MAX, FLT_MAX};
    POINTFLOAT boxOrigin, boxLowerRight;
    LISTENTRY *listLUT, *ple;
#ifdef SS_DBCS_SUPPORT
    BOOL bIsLeadByte;
#endif

    if( !pwfc )
        return 0;

    listLUT = pwfc->listLUT;

    extent->x = extent->y = 0.0f;
    origin->x = origin->y = 0.0f;
    len = strLen = lstrlen( szString );
    if( !len )
        return 0;  // otherwise extents will be calc'd erroneously

    c = szString;

    for( ; strLen; strLen--, c++ ) {
        cindex = (TUCHAR) *c;
#ifdef SS_DBCS_SUPPORT
        if( bIsLeadByte = IsDBCSLeadByte(cindex) ) {
            // iterate over lead byte
            c++;
            strLen--;
            cindex = (TUCHAR) *c;
        }
        if( !bIsLeadByte && (cindex < MAX_DIRECT_LUT) )
#else
        if( cindex < MAX_DIRECT_LUT )
#endif
            ple = &listLUT[cindex];
        else
            ple = FindExtendedLUTEntry( *c, pwfc );

        lpgmf = ple->lpgmf;

        if( !lpgmf )
            // Memory must be running low, but keep going
            continue;

        // calc global position of this char's BlackBox (this is 
        //  'upper left')
        boxOrigin.x = cellOrigin.x + lpgmf->gmfptGlyphOrigin.x;
        boxOrigin.y = cellOrigin.y + lpgmf->gmfptGlyphOrigin.y;

        // calc lower right position
        boxLowerRight.x = boxOrigin.x + lpgmf->gmfBlackBoxX;
        boxLowerRight.y = boxOrigin.y - lpgmf->gmfBlackBoxY;

        // compare against the current bounding box

        if( boxOrigin.x < extentOrigin.x )
            extentOrigin.x = boxOrigin.x;
        if( boxOrigin.y > extentOrigin.y )
            extentOrigin.y = boxOrigin.y;
        if( boxLowerRight.x > extentLowerRight.x )
            extentLowerRight.x = boxLowerRight.x;
        if( boxLowerRight.y < extentLowerRight.y )
            extentLowerRight.y = boxLowerRight.y;

        // set global position of next cell
        cellOrigin.x = cellOrigin.x + lpgmf->gmfCellIncX;
        cellOrigin.y = cellOrigin.y + lpgmf->gmfCellIncY;
    }

    // Check for possible total lack of glyphmetric info
    if( extentOrigin.x == FLT_MAX ) {
        // Can assume if this value is still maxed out that all glyphmetric
        // info was NULL
        origin->x = origin->y = 0.0f;
        extent->x = extent->y = 0.0f;
        return 0;
    }

    *origin = extentOrigin;
    extent->x = extentLowerRight.x - extentOrigin.x;
    extent->y = extentOrigin.y - extentLowerRight.y;
    return len;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\text3d\sstext3d.h ===
/******************************Module*Header*******************************\
* Module Name: sstext3d.h
*
* Global header for text3D screen saver.
*
* Created: 12-24-94 -by- Marc Fortier [marcfo]
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#ifndef __sstext3d_h__
#define __sstext3d_h__

#include <commctrl.h>
#include "dlgs.h"
#include "sscommon.h"

#define PI_OVER_2 (PI/2.0f)
#define PI_OVER_4 (PI/4.0f)

#define TEXT_BUF_SIZE       100     // max length of display text buffer
                                    // (including NULL termination)
#define TEXT_LIMIT          16      // max length of user-inputted display text

#define MAX_IROT            100     // max integer rotation level (from slider)

#define MIN_SLIDER          0
#define MAX_SLIDER          100

// demo types
enum {
    DEMO_STRING = 0,    // static string
    DEMO_CLOCK,         // digital clock
    DEMO_VSTRING,       // variable string (actually a subset of DEMO_STRING)
};

#define MAX_DEMO  1             // max demo index
#define NUM_DEMOS (MAX_DEMO+1)

// surface styles
enum {
    SURFSTYLE_SOLID = 0,
    SURFSTYLE_TEX,
    SURFSTYLE_WIREFRAME
};

// rotation styles
enum {
    ROTSTYLE_NONE = 0,
    ROTSTYLE_SEESAW,
    ROTSTYLE_WOBBLE,
    ROTSTYLE_RANDOM,
    NUM_ROTSTYLES
};

enum {
    X_AXIS = 0,
    Y_AXIS,
    Z_AXIS,
    NUM_AXIS
};


#if defined(max)
#undef max
#endif
#define max( a, b ) ( a >= b ? a : b )

#if defined(clamp)
#undef clamp
#endif
#define clamp( a, lo, hi ) ( (a < lo) ? lo : ((a > hi) ? hi : a) )

#define deg_to_rad( a ) ( (a*PI) / 180.0f )
#define rad_to_deg( a ) ( (a*180.0f) / PI )

typedef struct {
    USHORT listNum;             // display list number
    TCHAR     glyph;            // glyph value (for extended LUT entries)
    LPGLYPHMETRICSFLOAT lpgmf;  // ptr to glyphmetrics
} LISTENTRY;

#define SIZE_LIST_LUT  512
#define MAX_DIRECT_LUT 256

typedef struct {
    HDC     hdc;
    int     nGlyphs;            // number of glyphs
    int     firstGlyph;
    FLOAT   chordalDeviation;
    FLOAT   extrusion;
    int     type;               // WGL_FONT_LINES or WGL_FONT_POLYGONS
    LISTENTRY *listLUT;             // LUT for cmd list # from glyph
    int     LUTIndex;           // current index for new indirect look-ups
} WglFontContext;

typedef struct {
    // registry or registry-derived attributes
    int     demoType;
    BOOL    bMaterialCycle;
    int     matType;    // material type from registry
    MATERIAL *pMat;     // ptr to current material
    int     surfStyle;
    int     rotStyle;   // rotation style
    int     texQual;
    float   fTesselFact;
    float   fDepth; // extrusion
    int     iSpeed; // rotation speed
    UINT    uSize;  // window size
    TEXFILE texFile;  // texture file
    TEXTURE texture;
    TCHAR   szFontName[LF_FACESIZE];       // font face name
    BOOL    bBold;
    BOOL    bItalic;
    BYTE    charSet;
    TCHAR   szText[TEXT_BUF_SIZE+1];  // display string
    USHORT  usText[TEXT_BUF_SIZE+1];    // display string converted to cmd lists

    // internal attributes
    BOOL            bTexture;
    BOOL            bRandomMat;
    WglFontContext  *pWglFontC;
    int             textLen;
    POINTFLOAT      pfTextExtent;
    POINTFLOAT      pfTextOrigin;       // upper left corner of extents
    POINT3D         p3dBoundingBox;     // bounding box, from spin angles
    FLOAT           fFovy;              // field of view in y-dir
    FLOAT           fAspect;            // aspect ratio of GL window
    FLOAT           fViewDist;          // dist to front of bounding box
    FLOAT           fZtrans;            // translation in z
    int             iRotStep;           // rotation step from slider
    int             iRotMinStep;        // min rotation step
    int             iRotMaxStep;        // max rotation step
    IPOINT3D        ip3dRotStep;        // xyz rot step, for random rotation
    IPOINT3D        ip3dRoti;           // current xyz rot step iteration
    POINT3D         p3dRotMin;          // min rotation amplitude
    POINT3D         p3dRotMax;          // max rotation amplitude
    POINT3D         p3dRotLimit;        // current rotation amplitude
    POINT3D         p3dRot;             // current rotation
    POINTFLOAT      *pTrig;             // current trig table
    SYSTEMTIME      stTime;
    BOOL            bXMajor;            // string either x-major or y-major

    SSContext       ssc;                // screen saver configuration
} AttrContext;

// Global attribute context
extern AttrContext gac;

extern WglFontContext* CreateWglFontContext ( 
    HDC     hdc, 
    int     type, 
    float   fExtrusion, 
    float   fChordalDeviation );

extern void DeleteWglFontContext( 
    WglFontContext *pwfc );

extern void DrawString ( 
    USHORT *string, 
    int     strLen, 
    WglFontContext *pwfc );

extern int GetStringExtent( 
    LPTSTR  pszString, 
    POINTFLOAT *extent, 
    POINTFLOAT *origin,
    WglFontContext *pwfc );

extern void ConvertStringToList( 
    LPTSTR pszSrc, 
    USHORT *usDst, 
    WglFontContext *pwfc );

extern void getIniSettings(void);


// Resource constants

#define IDS_SCREENSAVERTITLE    1020
#define IDS_SAVERNAME           1002
#define IDS_DEFFONT             1099
#define IDS_DEFCHARSET          1098

// registry attribute strings:
#define IDS_DEMOTYPE            1100
#define IDS_SURFSTYLE           1104
#define IDS_FONT                1109
#define IDS_FONT_ATTRIBUTES     1110
#define IDS_CHARSET             1111
#define IDS_TEXT                1115
#define IDS_SPEED               1120
#define IDS_ROTSTYLE            1124

// demo type strings
#define IDS_DEMO_STRING       1200
#define IDS_DEMO_CLOCK        1201

// rotation resource strings
#define IDS_ROTSTYLE_NONE            1400
#define IDS_ROTSTYLE_SEESAW          1401
#define IDS_ROTSTYLE_WOBBLE          1402
#define IDS_ROTSTYLE_RANDOM          1403

#define DLG_SETUP_HELP          2001
#define DLG_SETUP_TYPES         2002    // object type menu
#define DLG_SETUP_BITMAP        2003
#define DLG_SETUP_ABOUT         2010
#define DLG_SETUP_TESSEL        2012    // tesselation slider
#define DLG_SETUP_SIZE          2014    // size slider
#define DLG_SETUP_TEX           2016    // texture button
#define DLG_SETUP_FONT          2022    // select font button
#define DLG_SETUP_SPEED         2023    // speed slider

// surface styles
#define IDC_RADIO_SOLID         2030
#define IDC_RADIO_TEX           2031
#define IDC_RADIO_WIREFRAME     2032    // not presently used

#define IDC_TO_SURFSTYLE(n)         ( (n) - IDC_RADIO_SOLID )
// In order for the IDC_TO_SURFSTYLE conversion macro to work, the radio buttons
// for surface styles must be kept contiguous.

// rotation styles
#define DLG_SETUP_ROTSTYLE      4100


// demo type
#define IDC_DEMO_STRING         5000
#define IDC_DEMO_CLOCK          5001
#define IDC_TO_DEMOTYPE(n)      ( (n) - IDC_DEMO_STRING )

// sliders
#define IDC_STATIC_TESS         2051    // box around slider
#define IDC_STATIC_TESS_MIN     2052    // min label
#define IDC_STATIC_TESS_MAX     2053    // max label
#define IDC_STATIC_SIZE         2054
#define IDC_STATIC_SIZE_MIN     2055
#define IDC_STATIC_SIZE_MAX     2056

// rotation sliders
#define IDC_STATIC_ROTATION_GRP 5000

// configure text dialog box stuff
#define IDS_TEXT_TITLE          3001
#define DLG_TEXT_ENTER          3020
#define DLG_TEXT_SHOW           3021

// Choose font template
#define DLG_CF_TEMPLATE         6000
#define IDD_FONT                6001

// Default texture resource
#define IDB_DEFTEX              7000

#define SHELP_CONTENTS          01
#define SHELP_SHAPES            02
#define SHELP_PASSWORD          03
#define SHELP_COLOR             04
#define SHELP_MISC              05
#define SHELP_OVERVIEW          06

#endif // __sstext3d_h__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\scrsave\text3d\sstext3d.c ===
/******************************Module*Header*******************************\
* Module Name: sstext3d.c
*
* Core code for text3D screen saver
*
* Created: 12-24-94 -by- Marc Fortier [marcfo]
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <math.h>
#include <fcntl.h>
#include <io.h>
#include <sys/types.h>
#include <sys/timeb.h>
#include <time.h>
#include <windows.h>
#include <scrnsave.h>
#include <GL/gl.h>
#include <GL/glu.h>
#include <GL/glaux.h>

//#define SS_DEBUG 1

#include "sscommon.h"
#include "sstext3d.h"

#define FMAX_CHORDAL_DEVIATION   0.008f

#define FMIN_DEPTH           0.15f
#define FMAX_DEPTH           0.6f

#define FMIN_VIEW_ANGLE      90.0f
#define FMAX_VIEW_ANGLE     130.0f

#define FMIN_RANDOM_ANGLE    45.0f
#define FMAX_RANDOM_ANGLE    89.0f

#define FMIN_SEESAW_ANGLE    63.0f
#define FMAX_SEESAW_ANGLE    88.0f

#define FMIN_WOBBLE_ANGLE    30.0f
#define FMAX_WOBBLE_ANGLE    55.0f
#define FMIN_WOBBLE_ANGLE2   40.0f
#define FMAX_WOBBLE_ANGLE2   80.0f

#define MIN_ROT_STEP          1
#define MAX_ROT_STEP         20

#define FMAX_ZOOM             5.0f

// globals

static FLOAT gfMinCycleTime = 10.0f;
static POINTFLOAT gTrig[360];  // pre-calculated table of sines and cosines
static POINTFLOAT gSawTooth[360]; // sawtooth table
static POINTFLOAT gInvTrig[360];  // pseudo-inverse trig table
static POINT gTrigDif[360];   // table for converting trig->invtrig
static POINT gInvTrigDif[360];   // table for converting invtrig->trig

AttrContext gac;

// Default texture resource
TEX_RES gTexRes = { TEX_BMP, IDB_DEFTEX };

typedef struct _LIST *PLIST;
typedef struct _LIST {
    PLIST pnext;
    PLIST plistComplete;
    LPTSTR pszStr;
} LIST;

PLIST gplistComplete = NULL;
PLIST gplist = NULL;
static void DeleteNameList();

void text3d_Init( void *data  );
void text3d_Reset(void *data );
void text3d_Draw(void *data );
void text3d_Reshape(int width, int height, void *data );
void text3d_Finish( void *data );
static void CalcViewParams( AttrContext *pac );
static BOOL InitFont( AttrContext *pac );
static void InitLighting( AttrContext *pac );
static void InitTexture( AttrContext *pac );
static void InitMaterials( AttrContext *pac );
static void InitView( AttrContext *pac );
static FLOAT MapValue( FLOAT fInVal,
                       FLOAT fIn1, FLOAT fIn2,
                       FLOAT fOut1, FLOAT fOut2 );
static int  MapValueI( int inVal, int in1, int in2, int out1, int out2 );
static FLOAT CalcChordalDeviation( HDC hdc, AttrContext *pac );
static void (*BoundingBoxProc)( AttrContext *pac);
static void CalcBoundingBox( AttrContext *pac );
static void CalcBoundingBoxFromSphere( AttrContext *pac );
static void CalcBoundingBoxFromSpherePlus( AttrContext *pac, FLOAT zmax );
static void CalcBoundingBoxGeneric( AttrContext *pac );
static void CalcBoundingBoxFromExtents( AttrContext *pac, POINT3D *box );
static void CalcBoundingExtent( FLOAT rot, FLOAT x, FLOAT y,
                                POINTFLOAT *extent );
static void SortBoxes( POINT3D *box, FLOAT *boxvp, int numBox );
static void (*GetNextRotProc)( AttrContext *pac );
static void GetNextRotNone( AttrContext *pac );
static void GetNextRotRandom( AttrContext *pac );
static void GetNextRotWobble( AttrContext *pac );
static void InitTrigTable();
static void text3d_UpdateTime( AttrContext *pac, BOOL bCheckBounds );
static void text3d_UpdateString( AttrContext *pac, BOOL bCheckBounds );
static BOOL VerifyString( AttrContext *pac );
static BOOL CheckKeyStrings( LPTSTR testString, PSZ psz );
static void ConvertStringAsciiToUnicode( PSZ psz, PWSTR pwstr, int len );
static void InvertBitsA( char *s, int len );
static void ReadNameList();
static PSZ ReadStringFileA( char *file );
static void CreateRandomList();
static void ResetRotationLimits( AttrContext *pac, int *reset );
static int FrameCalibration( AttrContext *pac, struct _timeb *pBaseTime, int framesPerCycle,
                             int nCycle );
static void SetTransitionPoints( AttrContext *pac, int framesPerCycle,
                                int *trans1, int *trans2, FLOAT *zTrans );
static void
AdjustRotationStep( AttrContext *pac, int *reset, POINTFLOAT *oldTrig );

/******************************Public*Routine******************************\
* SetFloaterInfo
*
* Set the size and motion of the floating window
*
* ss_SetWindowAspectRatio may be called after this, to finely crop the
* window to the text being displayed.  But we can't call it here, since this
* function is called by common when creating the floating window, before the
* text string size has been determined.
\**************************************************************************/

static void
SetFloaterInfo( ISIZE *pParentSize, CHILD_INFO *pChild )
{
    float sizeFact;
    float sizeScale;
    int size;
    ISIZE *pChildSize = &pChild->size;
    MOTION_INFO *pMotion = &pChild->motionInfo;
    AttrContext *pac = &gac;

    sizeScale = (float)pac->uSize / 100.0f;  // range 0..1
    sizeFact = 0.25f + (0.5f * sizeScale);     // range 25-75%
    size = (int) (sizeFact * 
            ( ((float)(pParentSize->width + pParentSize->height)) / 2.0f ));
    SS_CLAMP_TO_RANGE2( size, 0, pParentSize->width );
    SS_CLAMP_TO_RANGE2( size, 0, pParentSize->height );

    pChildSize->width = pChildSize->height = size;
    pMotion->posInc.x = .01f * (float) size;
    if( pMotion->posInc.x < 1.0f )
        pMotion->posInc.x = 1.0f;
    pMotion->posInc.y = pMotion->posInc.x;
    pMotion->posIncVary.x = .4f * pMotion->posInc.x;
    pMotion->posIncVary.y = pMotion->posIncVary.x;
}

/******************************Public*Routine******************************\
* Init
*
* Initialize - called on first entry into ss.
* Called BEFORE gl is initialized!
* Just do basic stuff here, like set up callbacks, verify dialog stuff, etc.
*
* Fills global SSContext structure with required data, and returns ptr
* to it.
*
\**************************************************************************/

SSContext *
ss_Init( void )
{
    // validate some initial dialog settings
    getIniSettings();  // also called on dialog init

    // must verify textures here, before GL floater windows are created
    if( gac.surfStyle == SURFSTYLE_TEX ) {
        ss_DisableTextureErrorMsgs();
        ss_VerifyTextureFile( &gac.texFile );
    }

    // set Init callback
    ss_InitFunc( text3d_Init );

    // set data ptr to be sent with callbacks
    ss_DataPtr( &gac );

    // set configuration info to return

    gac.ssc.bFloater = TRUE;
    gac.ssc.floaterInfo.bMotion = TRUE;
    gac.ssc.floaterInfo.ChildSizeFunc = SetFloaterInfo;

    gac.ssc.bDoubleBuf = TRUE;
    gac.ssc.depthType = SS_DEPTH16;

    return &gac.ssc;
}

/******************************Public*Routine******************************\
* text3d_Init
*
* Initializes OpenGL state for text3d screen saver
*
\**************************************************************************/
void
text3d_Init( void *data )
{
    AttrContext *pac = (AttrContext *) data;

    // Set any callbacks that require GL
    ss_UpdateFunc( text3d_Draw );
    ss_ReshapeFunc( text3d_Reshape );
    ss_FinishFunc( text3d_Finish );

#ifdef SS_DEBUG
    glClearColor( 0.2f, 0.2f, 0.2f, 0.0f );
#else
    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
#endif

    glDepthFunc(GL_LEQUAL);
    glEnable(GL_DEPTH_TEST);

    // this sequence must be maintained

    InitLighting( pac );

    InitFont( pac );

    InitView( pac );

    InitTexture( pac );

    InitMaterials( pac );
}

/**************************************************************************\
* InitLighting
*
* Initialize lighting, and back face culling.
*
\**************************************************************************/
static void
InitLighting( AttrContext *pac )
{
    float ambient1[] = {0.2f, 0.2f, 0.2f, 1.0f};
    float ambient2[] = {0.1f, 0.1f, 0.1f, 1.0f};
    float diffuse1[] = {0.7f, 0.7f, 0.7f, 1.0f};
    float diffuse2[] = {0.7f, 0.7f, 0.7f, 1.0f};
    float position1[] = {0.0f, 50.0f, 150.0f, 0.0f};
    float position2[] = {25.0f, 150.0f, 50.0f, 0.0f};
    float lmodel_ambient[] = {1.0f, 1.0f, 1.0f, 1.0f};

    glLightfv(GL_LIGHT0, GL_AMBIENT, ambient1);
    glLightfv(GL_LIGHT0, GL_DIFFUSE, diffuse1);
    glLightfv(GL_LIGHT0, GL_POSITION, position1);
    glEnable(GL_LIGHT0);

    glLightfv(GL_LIGHT1, GL_AMBIENT, ambient2);
    glLightfv(GL_LIGHT1, GL_DIFFUSE, diffuse2);
    glLightfv(GL_LIGHT1, GL_POSITION, position2);
    glEnable(GL_LIGHT1);

    glLightModelfv(GL_LIGHT_MODEL_AMBIENT, lmodel_ambient);
    glLightModeli(GL_LIGHT_MODEL_TWO_SIDE, GL_FALSE);
    glCullFace( GL_BACK );
    glEnable(GL_CULL_FACE);
    glEnable(GL_LIGHTING);
}

/**************************************************************************\
* TestFont
*
* Test that GetOutlineTextMetrics works.  If not, wglUseFontOutlines will fail.
*
* If the font tests bad, delete it and select in the previous one.
*
\**************************************************************************/

static BOOL
TestFont( HFONT hfont )
{
    OUTLINETEXTMETRIC otm;
    HFONT hfontOld;
    HDC hdc = wglGetCurrentDC();

    hfontOld = SelectObject(hdc, hfont);

    if( GetOutlineTextMetrics( hdc, sizeof(otm), &otm) <= 0 ) {
        SS_DBGPRINT( "sstext3d Init: GetOutlineTextMetrics failure\n" );
        SelectObject(hdc, hfontOld);
        DeleteObject( hfont );
        return FALSE;
    }
    return TRUE;
}

/**************************************************************************\
* CreateFont
*
* Create a true type font and test it
*
\**************************************************************************/

static HFONT
text3d_CreateFont( LOGFONT *plf )
{
    HFONT hfont;

    // Create font from LOGFONT data
    hfont = CreateFontIndirect(plf);

    if( hfont ) {
        // Test the font
        if( ! TestFont( hfont ) )
            hfont = (HFONT) 0;
    }
    return hfont;
}

/**************************************************************************\
* InitFont
*
*
\**************************************************************************/
static BOOL
InitFont( AttrContext *pac )
{
    LOGFONT lf;
    HFONT hfont;
    int type;
    float fChordalDeviation;
    HDC hdc = wglGetCurrentDC();

    // Set up the LOGFONT structure

    memset(&lf, 0, sizeof(LOGFONT));
    lstrcpy( lf.lfFaceName, pac->szFontName );
    lf.lfWeight = (pac->bBold) ? FW_BOLD : FW_NORMAL;
    lf.lfItalic = (pac->bItalic) ? (BYTE) 1 : 0;

    lf.lfHeight = 0; // shouldn't matter
    lf.lfCharSet = pac->charSet;
    lf.lfOutPrecision = OUT_TT_ONLY_PRECIS;

    // Create the font

    if( ! (hfont = text3d_CreateFont( &lf )) ) {
        // Couldn't create a true type font with supplied data
        SS_DBGPRINT( "initial text3d_CreateFont failed: \n" );
    }

    if( !hfont && ss_fOnWin95() ) {
    // !!! Bug on win95: the font mapper didn't give us anything useful
    // For some reason GetOutlineTextMetrics fails for some fonts (Symbol)
    // when using lfHeight = 0 (default height value).
        lf.lfHeight = -10;
        if( ! (hfont = text3d_CreateFont( &lf )) ) {
            SS_DBGPRINT( "text3d_CreateFont with lfHeight != 0 failed: \n" );
        }
    }

    if( hfont == NULL ) {
        /* The requested font cannot be loaded.  Try to get the system to
         * load any TrueType font
         */
        hfont = CreateFont( 100, 100, 0, 0, lf.lfWeight, lf.lfItalic,
                             0, 0, 0, OUT_TT_ONLY_PRECIS, CLIP_DEFAULT_PRECIS,
                             DEFAULT_QUALITY, DEFAULT_PITCH, NULL );
        // If hfont is still null, nothing will be displayed.
        if( !hfont || !TestFont(hfont) ) {
            SS_DBGPRINT( "text3d_InitFont failure\n" );
            return FALSE;
        }
    }

    // We have a valid font

    SelectObject(hdc, hfont);

    // Set extrusion, chordal deviation, and font type

#ifdef _PPC_
    // !!! Work around for PPC compiler bug

    // calculate chordalDeviation from input attribute fTesselFact
    fChordalDeviation = CalcChordalDeviation( hdc, pac );

    pac->fDepth = ss_fRand( FMIN_DEPTH, FMAX_DEPTH );
#else
    pac->fDepth = ss_fRand( FMIN_DEPTH, FMAX_DEPTH );

    // calculate chordalDeviation from input attribute fTesselFact
    fChordalDeviation = CalcChordalDeviation( hdc, pac );
#endif

    type = pac->surfStyle == SURFSTYLE_WIREFRAME ? WGL_FONT_LINES :
                                                   WGL_FONT_POLYGONS;

    // Create a wgl font context

    if( !(pac->pWglFontC = 
            CreateWglFontContext( hdc, type, pac->fDepth, fChordalDeviation )) )
        return FALSE;

    // intialize the text that will be displayed

    if( pac->demoType == DEMO_CLOCK ) {
        text3d_UpdateTime( pac, FALSE );  // sets pac->textXXX params as well
    } else if( pac->demoType == DEMO_STRING ) {
        if( !VerifyString( pac ) ) {
            ConvertStringToList( pac->szText, pac->usText, pac->pWglFontC );
            pac->textLen = GetStringExtent( pac->szText, &pac->pfTextExtent,
                                         &pac->pfTextOrigin,
                                         pac->pWglFontC );
        }
    }
    return SUCCESS;
}


/**************************************************************************\
* InitView
*
*
\**************************************************************************/
static void
InitView( AttrContext *pac )
{
    int numRots=0, axis;
    FLOAT *p3dRotMax = (FLOAT *) &pac->p3dRotMax;
    FLOAT *p3dRotMin = (FLOAT *) &pac->p3dRotMin;
    int *ip3dRotStep = (int *) &pac->ip3dRotStep;
    POINT3D p3d_zero = {0.0f, 0.0f, 0.0f};
    int stepRange = 2; // default step range
    int reset[NUM_AXIS] = {1, 1, 1};

    // text is either xmajor or ymajor
    pac->bXMajor = pac->pfTextExtent.x >= pac->pfTextExtent.y ? TRUE : FALSE;


    /* At this point, the initial string extents will have been
     * calculated, and we can use this to determine rotational
     * characteristics
     */

    // default proc to get next rotation
    GetNextRotProc = GetNextRotRandom;

    /* convert the slider speed values to rotation steps, with
     * a steeper slope at the beginning of the scale
     */
    pac->iRotStep = MapValueI( pac->iSpeed,
                               MIN_SLIDER, MAX_SLIDER,  // slider range
                               MIN_ROT_STEP, MAX_ROT_STEP ); // step range

    // initialize rotation min/max to 0
    *( (POINT3D*)p3dRotMin ) = p3d_zero;
    *( (POINT3D*)p3dRotMax ) = p3d_zero;
    pac->p3dRot = p3d_zero;

    /* Set the MAXIMUM rotation limits.  This is required initially, in
     * order to set the bounding box
     */
    switch( pac->rotStyle ) {
        case ROTSTYLE_NONE:
            GetNextRotProc = GetNextRotNone;
            break;

        case ROTSTYLE_SEESAW:
            // rotate minor axis
            if( pac->demoType == DEMO_VSTRING )
                // always rotate around y-axis
                axis = Y_AXIS;
            else
                axis = pac->bXMajor ? Y_AXIS : X_AXIS;
            p3dRotMin[axis] = FMIN_SEESAW_ANGLE;
            p3dRotMax[axis] = FMAX_SEESAW_ANGLE;
            break;

        case ROTSTYLE_WOBBLE:
            GetNextRotProc = GetNextRotWobble;
            if( pac->demoType == DEMO_VSTRING ) {
                axis = Y_AXIS;
            }
            else {
                stepRange = 1;
                axis = pac->bXMajor ? Y_AXIS : X_AXIS;
            }
            p3dRotMin[Z_AXIS] = FMAX_WOBBLE_ANGLE;
            p3dRotMax[Z_AXIS] = FMAX_WOBBLE_ANGLE;
            p3dRotMin[axis] = FMIN_WOBBLE_ANGLE2;
            p3dRotMax[axis] = FMAX_WOBBLE_ANGLE2;
            break;

        case ROTSTYLE_RANDOM:
            // adjust stepRange based on speed
            stepRange = MapValueI( pac->iSpeed,
                               MIN_SLIDER, (MAX_SLIDER-MIN_SLIDER)/2,
                               2, 6 ); // step range
            for( axis = X_AXIS; axis < NUM_AXIS; axis++ ) {
                p3dRotMin[axis] = FMIN_RANDOM_ANGLE;
                p3dRotMax[axis] = FMAX_RANDOM_ANGLE;
            }
            break;
    }

    // set min and max steps
    pac->iRotMinStep = pac->iRotStep >= (MIN_ROT_STEP + stepRange) ?
              pac->iRotStep - stepRange : MIN_ROT_STEP;
    pac->iRotMaxStep = pac->iRotStep + stepRange; // don't limit upper end

    for( axis = X_AXIS; axis < NUM_AXIS; axis++ ) {
        ip3dRotStep[axis] = p3dRotMax[axis] != 0.0f ?
                ss_iRand2( pac->iRotMinStep, pac->iRotMaxStep ) : 0;
    }

    // initialize the step iteration
    pac->ip3dRoti.x = pac->ip3dRoti.y = pac->ip3dRoti.z = 0;

    // initialize the trig table, for fast rotation calculations
    InitTrigTable();

    // set the current rotation limits
    pac->p3dRotLimit = *( (POINT3D *)p3dRotMax );
    ResetRotationLimits( pac, reset );

    // set view angle
    pac->fFovy = ss_fRand( FMIN_VIEW_ANGLE, FMAX_VIEW_ANGLE );

    for( axis = X_AXIS; axis < NUM_AXIS; axis++ ) {
        if( p3dRotMax[axis] != 0.0f )
            numRots++;
    }

    // set BoundingBoxProc dependent on which axis are being rotated
    if( numRots <= 1 )
        BoundingBoxProc = CalcBoundingBox;
    else
        BoundingBoxProc = CalcBoundingBoxGeneric;

    (*BoundingBoxProc)( pac );
    if( pac->p3dBoundingBox.y == 0.0f )
        pac->p3dBoundingBox.y = 1.0f;
}

/**************************************************************************\
* InitMaterials
*
*
\**************************************************************************/
static void
InitMaterials( AttrContext *pac )
{
    if( pac->bTexture ) {
        ss_InitTexMaterials();
        pac->bMaterialCycle = FALSE;
        pac->pMat = ss_RandomTexMaterial( TRUE );
    } else {
        ss_InitTeaMaterials();
        pac->bMaterialCycle = TRUE;
        pac->pMat = ss_RandomTeaMaterial( TRUE );
    }
}

/**************************************************************************\
* InitTexture
*
* History
*  Apr. 28, 95 : [marcfo]
*    - Changed texture quality from default to high.
*
\**************************************************************************/
static void
InitTexture( AttrContext *pac )
{
    if( pac->surfStyle != SURFSTYLE_TEX )
        return;

    // No choice for texture quality in dialog - set to HIGH
    pac->texQual = TEXQUAL_HIGH;

    // Try to load the texture file or default texture resource

    if( ss_LoadTextureFile( &pac->texFile, &pac->texture ) ||
        ss_LoadTextureResource( &gTexRes, &pac->texture ) ) 
    {
        pac->bTexture = 1;

        glEnable(GL_TEXTURE_2D);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
        glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);

        ss_SetTexture( &pac->texture );

        // set auto texture coord generation
        ss_InitAutoTexture( NULL );
    }
    else {  // couldn't open .bmp file
        pac->bTexture = 0;
    }

}

/******************************Public*Routine******************************\
* text3d_Finish
*
* Handles any cleanup on program termination
*
\**************************************************************************/
void
text3d_Finish( void *data )
{
    AttrContext *pac = (AttrContext *) data;

    if( pac )
        DeleteWglFontContext( pac->pWglFontC );

    // delete any name list
    DeleteNameList();
}

/**************************************************************************\
* text3d_Reshape
*
*       - called on resize, expose
*       - always called on app startup
*
\**************************************************************************/

void
text3d_Reshape(int width, int height, void *data )
{
    AttrContext *pac = (AttrContext *) data;

//mf
#if 0
    glViewport( 0, 0, width, height );
#endif

    // calculate new aspect ratio
    pac->fAspect = height == 0 ? 1.0f : (FLOAT) width / (FLOAT) height;

    CalcViewParams( pac );
    ss_SetWindowAspectRatio( pac->p3dBoundingBox.x / pac->p3dBoundingBox.y );
}


/**************************************************************************\
* CalcViewParams
*
*   Calculate viewing parameters, based on window size, bounding box, etc.
*
\**************************************************************************/

static void
CalcViewParams( AttrContext *pac )
{
    GLdouble zNear, zFar;
    FLOAT aspectBound, viewDist;
    FLOAT vHeight;
    FLOAT fovy;

    // calculate viewing distance so that front of bounding box within view

    aspectBound = pac->p3dBoundingBox.x / pac->p3dBoundingBox.y;

    // this is distance to FRONT of bounding box:
    viewDist = pac->p3dBoundingBox.y /
               ( (FLOAT) tan( deg_to_rad(pac->fFovy/2.0f) ) );

    // NOTE: these are half-widths and heights
    if( aspectBound <= pac->fAspect ) {
        // we are bound by the window's height
        fovy = pac->fFovy;
    } else {
        // we are bound by window's width
        // adjust fovy, so fovx remains the same
        vHeight = pac->p3dBoundingBox.x / pac->fAspect;
        fovy = rad_to_deg( 2.0f * (FLOAT) atan( vHeight / viewDist ) );
    }

    /* Could just use rotation sphere dimensions here, but for now
     * set clipping planes 10% beyond bounding box.
     */

    zNear = 0.9f * viewDist;
    zFar = 1.1f * (viewDist + 2.0f*pac->p3dBoundingBox.z);

    if( pac->demoType == DEMO_VSTRING )
        zFar *= FMAX_ZOOM;

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    gluPerspective( fovy, pac->fAspect, zNear, zFar );

    // set viewing distance so that front of bounding box within view
    viewDist *= 1.01f; // pull back 1% further to be sure not off by a pixel..
    pac->fZtrans = -(viewDist + pac->p3dBoundingBox.z);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    glTranslatef( 0.0f, 0.0f, pac->fZtrans );

}


// number of calibration cycles
#define MAX_CALIBRATE 2

/**************************************************************************\
* text3d_Draw
*
* Draw a frame.
*
\**************************************************************************/
void
text3d_Draw( void *data )
{
    AttrContext *pac = (AttrContext *) data;
    POINT3D *rot = &pac->p3dRot;
    static BOOL bCalibrated = FALSE;
    static int nCycle = 0; // cycle count
    static int frameCount = 0, maxCount;
    static int matTransCount, matTransCount2 = 0;
    static MATERIAL transMat, transMatInc;
    static FLOAT zTrans, zTransInc;
    static MATERIAL *pNewMat;
    static struct _timeb baseTime;
    static BOOL bInit = FALSE;
    static int reset[NUM_AXIS] = {1,1,1};

    if( !bInit ) {

        // Do first time init stuff

        // Start the calibration timer
        _ftime( &baseTime );

        // set default transition points, until calibration done
        maxCount = 60;
        SetTransitionPoints( pac, maxCount, &matTransCount,
                             &matTransCount2, &zTrans );
        bInit = TRUE;
    }

    // take action based on frameCount

    if( frameCount >= matTransCount ) {

        // we are in the transition zone

        if( frameCount == matTransCount ) {

            // first transition point...

            // select new material
            if( pac->bTexture )
                pNewMat = ss_RandomTexMaterial( FALSE );
            else
                pNewMat = ss_RandomTeaMaterial( FALSE );

            // set material transition, zTrans transition
            if( pac->demoType == DEMO_VSTRING ) {
                // transition current material to black
                ss_CreateMaterialGradient( &transMatInc,
                                          pac->pMat,
                                          &ss_BlackMat,
                                          matTransCount2 - matTransCount );
                zTransInc = ((FMAX_ZOOM-1) * pac->fZtrans) /
                                        (matTransCount2 - matTransCount);
            } else {
                ss_CreateMaterialGradient( &transMatInc,
                                           pac->pMat,
                                           pNewMat,
                                           maxCount - matTransCount );
            }
            // initialize transition values to current settings
            zTrans = pac->fZtrans;
            transMat = *(pac->pMat);
            // begin transition on NEXT frame.

        } else {

            // past first transition...

            if( matTransCount2 && (frameCount == (matTransCount2+1)) ) {

                // optional second transition point...(only for vstrings)

                // transition from black to new material
                ss_CreateMaterialGradient( &transMatInc,
                                           &ss_BlackMat,
                                           pNewMat,
                                           maxCount - matTransCount2 );
                // init transition material to black
                transMat = ss_BlackMat;

                /* At this point, screen is black, so we can change strings
                 * and resize the floater without any problems.
                 */

                if( pac->demoType == DEMO_VSTRING )
                    text3d_UpdateString( pac, TRUE ); // can cause resize
                // set zTrans to furthest distance
                zTrans = (FMAX_ZOOM * pac->fZtrans);
                zTransInc = (pac->fZtrans - zTrans) /
                                            (maxCount - matTransCount2);
                // change this while string invisible
                ResetRotationLimits( pac, reset );
            }
            // set the transition material (updates transMat each time)

            ss_TransitionMaterial( &transMat, &transMatInc );
            zTrans += zTransInc;

            if( frameCount >= maxCount ) {

                // End of cycle
                nCycle++;  // 1-based

                // Calibrate on MAX_CALIBRATE cycles
                if( !bCalibrated && (nCycle >= MAX_CALIBRATE) ) {
                    maxCount = FrameCalibration( pac, &baseTime, maxCount, nCycle );

                    SetTransitionPoints( pac, maxCount, &matTransCount,
                                         &matTransCount2, &zTrans );
                    bCalibrated = TRUE;
                }

                // set, reset stuff
                pac->pMat = pNewMat;
                ss_SetMaterial( pNewMat );
                zTrans = pac->fZtrans;
                frameCount = 0;
            }
        }
    }

    if( pac->demoType == DEMO_CLOCK ) {
        // have to update the draw string with current time
        text3d_UpdateTime( pac, TRUE );
    }

    // ok, the string's setup - draw it

    glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();
    if( pac->demoType == DEMO_VSTRING )
        // use zooming zTrans
        glTranslatef( 0.0f, 0.0f, zTrans );
    else
        // use fixed zTrans
        glTranslatef( 0.0f, 0.0f, pac->fZtrans );

    /*
     * GetNextRotProc provides sinusoidal rotations
     */
    (*GetNextRotProc)( pac );  // sets pac->p3dRot, or rot

    if( pac->p3dRotMax.z != 0.0f ) {
        glRotatef( rot->z, 0.0f, 0.0f, 1.0f );
    }
    if( pac->p3dRotMax.y != 0.0f ) {
        glRotatef( rot->y, 0.0f, 1.0f, 0.0f );
    }
    if( pac->p3dRotMax.x != 0.0f ) {
        glRotatef( rot->x, 1.0f, 0.0f, 0.0f );
    }

    glTranslatef( -pac->pfTextOrigin.x - pac->pfTextExtent.x/2.0f,
                  -pac->pfTextOrigin.y + pac->pfTextExtent.y/2.0f,
                  pac->fDepth / 2.0f );

    DrawString( pac->usText, pac->textLen, pac->pWglFontC );

    glFlush();
    frameCount++;
}

/**************************************************************************\
* SetTransitionPoints
*
* Calculate draw transition points, as frame count values.
*
* If doing variable string (VSTRING), first transition point is where we
* start fading to black, and 2nd is from black to next material.  Also
* transition the z translation distance (zTrans).
* Note that trans2 indicates the frame number where the image should be
* black.  The actual transitioning may occur at trans2+1 (see text3d_draw
* above).
*
* For all other cases, set one transition point for fade to next material.
*
\**************************************************************************/
static void
SetTransitionPoints( AttrContext *pac, int framesPerCycle, int *trans1,
                     int *trans2, FLOAT *zTrans )
{
    *trans1 = (int) (0.5f * (FLOAT) framesPerCycle + 0.5f);

    if( pac->demoType == DEMO_VSTRING ) {
        *trans2 = *trans1 +
                  (int) (0.5f * (FLOAT) (framesPerCycle - *trans1) + 0.5f);
        *zTrans = pac->fZtrans;
    }
}

/**************************************************************************\
* text3d_UpdateTime
*
* Put new time string into the attribute context
*
\**************************************************************************/
static void
text3d_UpdateTime( AttrContext *pac, BOOL bCheckBounds )
{
    int oldLen;
    POINTFLOAT textExtent, textOrigin;
    POINTFLOAT textLowerRight, currentLowerRight;
    LPTSTR pszLastTime = pac->szText;
    static TCHAR szNewTime[TEXT_BUF_SIZE] = {0};

    GetLocalTime( &(pac->stTime) );
    GetTimeFormat( GetUserDefaultLCID(), // locale id
                    0,                      // flags
                    &(pac->stTime),         // time struct
                    NULL,                   // format string
                    szNewTime,               // buffer
                    TEXT_BUF_SIZE );        // buffer size

    // Compare new time string with last one

    if( !lstrcmp( pszLastTime, szNewTime ) )
        // time string has not changed, return
        return;

    // translate the new time string into display lists in pac->usText

    ConvertStringToList( szNewTime, pac->usText, pac->pWglFontC );
    lstrcpy( pac->szText, szNewTime );

    // Check extents of new string

    // save current values
    oldLen = pac->textLen;
    textExtent = pac->pfTextExtent;
    textOrigin = pac->pfTextOrigin;

    pac->textLen = GetStringExtent( pac->szText,
                                     &textExtent,
                                     &textOrigin,
                                     pac->pWglFontC );

    if( !bCheckBounds ) {
        // just set new extents and return
        pac->pfTextExtent = textExtent;
        pac->pfTextOrigin = textOrigin;
        return;
    }

    /* only update bounding box if new extents are larger, or the number
     * of chars changes
     */
    bCheckBounds = FALSE;

    if( pac->textLen != oldLen ) {

        // recalculate everything

        bCheckBounds = TRUE;
        pac->pfTextExtent = textExtent;
        pac->pfTextOrigin = textOrigin;
    }
    else {

        // accumulate maximum bounding box in pac

        // calc current lower right limits
        textLowerRight.x = textOrigin.x + textExtent.x;
        textLowerRight.y = textOrigin.y - textExtent.y;
        currentLowerRight.x = pac->pfTextOrigin.x + pac->pfTextExtent.x;
        currentLowerRight.y = pac->pfTextOrigin.y - pac->pfTextExtent.y;

        // if new text extents extend beyond current, update

        if( textOrigin.x < pac->pfTextOrigin.x ) {
            pac->pfTextOrigin.x = textOrigin.x;
            bCheckBounds = TRUE;
        }
        if( textOrigin.y > pac->pfTextOrigin.y ) {
            pac->pfTextOrigin.y = textOrigin.y;
            bCheckBounds = TRUE;
        }
        if( textLowerRight.x > currentLowerRight.x ) {
            pac->pfTextExtent.x = textLowerRight.x - pac->pfTextOrigin.x;
            bCheckBounds = TRUE;
        }
        if( textLowerRight.y < currentLowerRight.y ) {
            pac->pfTextExtent.y = pac->pfTextOrigin.y - textLowerRight.y;
            bCheckBounds = TRUE;
        }
    }
    if( bCheckBounds ) {
        // string size has changed - recalc box and view params
        (*BoundingBoxProc)( pac );
        CalcViewParams( pac );
    }
}

/**************************************************************************\
* text3d_UpdateString
*
* Select new string to display.
* If bCheckBounds, calculate new bounds as well.
*
\**************************************************************************/
static void
text3d_UpdateString( AttrContext *pac, BOOL bCheckBounds )
{
    static int index = 0;

    // get next string to display

    if( gplist == NULL )
        CreateRandomList();

    lstrcpy( pac->szText, gplist->pszStr );
    ConvertStringToList( pac->szText, pac->usText, pac->pWglFontC );
    gplist = gplist->pnext;

    // get new extents
    pac->textLen = GetStringExtent( pac->szText,
                                     &pac->pfTextExtent,
                                     &pac->pfTextOrigin,
                                     pac->pWglFontC );

    if( !bCheckBounds )
        return;

    // calculate bounding box
    (*BoundingBoxProc)( pac );
    if( pac->p3dBoundingBox.y == 0.0f )
        // avoid /0
        pac->p3dBoundingBox.y = 1.0f;

    // Make window's aspect ratio dependent on bounding box

    /* mf: could clear buffer here, so don't get incorrect results on
     *  synchronous resize, but not necessary since we're fading
     */
    ss_SetWindowAspectRatio( pac->p3dBoundingBox.x / pac->p3dBoundingBox.y );
    CalcViewParams( pac );

    // move window to new random position
    ss_RandomWindowPos();
}

/**************************************************************************\
* GetNextRotWobble
*
*   Calculate next rotation.
*   - 'step' controls amount of rotation
*   - rotation values are scaled from -1 to 1 (trig values), and  inscribe
*     circle with r=1 in the zy plane for the ends of the string
*   - steps for both minor and major rotation axis remain in sync
*
* History
*  Apr. 28, 95 : [marcfo]
*    - Call ResetRotationLimits() when axis rotation is 0
*
\**************************************************************************/
static void
GetNextRotWobble( AttrContext *pac )
{
    int *step = (int *) &pac->ip3dRoti;  // use step->x
    int *rotStep = (int *) &pac->ip3dRotStep.z;
    FLOAT *rotMax = (FLOAT *) &pac->p3dRotMax;
    POINTFLOAT *pTrig = pac->pTrig;
    static int resetPoint[NUM_AXIS] = {90,90,0}; // 0 amplitude points
    int reset[NUM_AXIS] = {0}; // which axis to be reset
    int axis;

    pac->p3dRot.z = pac->p3dRotLimit.z * pTrig[ *step ].y;  // sin
    pac->p3dRot.y = pac->p3dRotLimit.y * pTrig[ *step ].x;  // cos
    pac->p3dRot.x = pac->p3dRotLimit.x * pTrig[ *step ].x;  // cos

    // check for 0 amplitude point for non-vstrings
    for( axis = X_AXIS; axis < NUM_AXIS; axis++ ) {
        if( rotMax[axis] != 0.0f ) {
            if( (pac->demoType != DEMO_VSTRING) &&
                (*step == resetPoint[axis]) )
            {
                reset[axis] = 1;
                ResetRotationLimits( pac, reset );
                reset[axis] = 0;
            }
        }
    }

    // increment step
    if( (*step += *rotStep) >= 360 ) {
        // make the step variable
        *rotStep = ss_iRand2( pac->iRotMinStep, pac->iRotMaxStep );
        // start step at variable index
        *step = ss_iRand( *rotStep );
    }
}

/**************************************************************************\
* GetNextRotRandom
*
* Same as above, but steps for each axis are not kept in sync
*
* History :
*  Apr. 28, 95 : [marcfo]
*    - Call ResetRotationLimits() when axis rotation is 0
*
\**************************************************************************/
static void
GetNextRotRandom( AttrContext *pac )
{
    int *step = (int *) &pac->ip3dRoti;
    int *rotStep = (int *) &pac->ip3dRotStep;
    FLOAT *rotMax = (FLOAT *) &pac->p3dRotMax;
    POINTFLOAT *pTrig = pac->pTrig;
    static int resetPoint[NUM_AXIS] = {90,90,0}; // 0 amplitude points
    int reset[NUM_AXIS] = {0}; // which axis to be reset
    int axis;

    // set new rotation
    pac->p3dRot.z = pac->p3dRotLimit.z * pTrig[ step[Z_AXIS] ].y;  // sin
    pac->p3dRot.y = pac->p3dRotLimit.y * pTrig[ step[Y_AXIS] ].x;  // cos
    pac->p3dRot.x = pac->p3dRotLimit.x * pTrig[ step[X_AXIS] ].x;  // cos

    // for each rotation axis...

    for( axis = X_AXIS; axis < NUM_AXIS; axis++ ) {
        if( rotMax[axis] != 0.0f ) {
            // check for 0 amplitude point for non-vstrings
            if( (pac->demoType != DEMO_VSTRING) &&
                (step[axis] == resetPoint[axis]) ) {
                reset[axis] = 1;
                ResetRotationLimits( pac, reset );
                reset[axis] = 0;
            }

            // increment rotation step and check for end of cycle
            if( (step[axis] += rotStep[axis]) >= 360 ) {
                // make the step variable
                rotStep[axis] = ss_iRand2( pac->iRotMinStep, pac->iRotMaxStep );
                // start step at variable index
                step[axis] = ss_iRand( rotStep[axis] );
            }
        }
    }
}

/**************************************************************************\
* GetNextRotNone
*
* Null rot proc
*
\**************************************************************************/
static void
GetNextRotNone( AttrContext *pac )
{
}

/**************************************************************************\
* ResetRotationLimits
*
* Reset the maximum axis rotations.  So there won't be too much of a 'jump'
* when altering the rotation, this routine should only be called when the
* rotation of the specified axis is at zero amplitude.
*
* Also, change the rotation table if applicable.  This affects how the
* rotation 'steps' around the axis.
*
* History :
*  Apr. 28, 95 : [marcfo]
*    - Make rotation limits randomnly more extreme
*    - If trig table switched, call AdjustRotationStep(), to reset the steps
*      of non-zero axis rotations so that text string doesn't 'jump'
*
\**************************************************************************/

static void
ResetRotationLimits( AttrContext *pac, int *reset )
{
    FLOAT *p3dRot    =  (FLOAT *) &pac->p3dRot;       // current rotation
    FLOAT *p3dRotL   =  (FLOAT *) &pac->p3dRotLimit;  // new rot limit
    FLOAT *p3dRotMin =  (FLOAT *) &pac->p3dRotMin;    // max rotation
    FLOAT *p3dRotMax =  (FLOAT *) &pac->p3dRotMax;    // max rotation
    POINT3D p3dOldRotL = pac->p3dRotLimit; // save last rot limit
    POINTFLOAT *oldTrig;
    int i;

    // change rotation limits

    for( i = 0; i < NUM_AXIS; i++ ) {
        if( p3dRotMax[i] && reset[i] ) {
            p3dRotL[i] = ss_fRand( p3dRotMin[i], p3dRotMax[i] );
            // grossly modify amplitute sometimes for random
            if( pac->rotStyle == ROTSTYLE_RANDOM ) {
                if( ss_iRand(10) == 2 )
                    p3dRotL[i] = ss_fRand( 0.0f, 10.0f );
                else if( ss_iRand(10) == 2 )
                    p3dRotL[i] = ss_fRand( 90.0f, 135.0f );
            }
        }
    }

    // change rotation table

    // use i to set a frequency for choosing gInvTrig table
    i = 10;

    oldTrig = pac->pTrig;

    switch( pac->rotStyle ) {
        case ROTSTYLE_RANDOM:
            if( pac->demoType == DEMO_VSTRING )
                i = 7;
            // fall thru...
        case ROTSTYLE_SEESAW:
            // Use InvTrig table every now and then
            if( ss_iRand(i) == 2 ) {
                pac->pTrig = gInvTrig;
            }
            else
                pac->pTrig = gTrig;
            break;
        default:
            // Always use regular trig table
            pac->pTrig = gTrig;
    }

    // if trig table changed, need to adjust steps of non-zero axis rotations
    // (otherwise get 'twitch' in rotation)

    if( pac->pTrig != oldTrig ) {
        // only deal with axis which didn't have amplitudes modified
        for( i = 0; i < NUM_AXIS; i++ )
            reset[i] = ! reset[i];
        AdjustRotationStep( pac, reset, oldTrig );
    }
}

/**************************************************************************\
* AdjustRotationStep
*
* If trig table is changed in ResetRotationLimits, then axis with non-zero
* rotations will appear to jump.  This routine modifies the current step
* so this will not be apparent.
*
* History :
*  Apr. 28, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

static void
AdjustRotationStep( AttrContext *pac, int *reset, POINTFLOAT *oldTrig )
{
    int *step = (int *) &pac->ip3dRoti;
    FLOAT *p3dRotMax =  (FLOAT *) &pac->p3dRotMax;
    int axis;
    POINT *trigDif;

    if( pac->demoType == DEMO_VSTRING )
        // for now doesn't matter, string is invisible at this point
        return;

    // choose diff table to use for modifying step
    trigDif = (oldTrig == gTrig) ? gTrigDif : gInvTrigDif;

    for( axis = 0; axis < NUM_AXIS; axis++ ) {
        if( p3dRotMax[axis] && reset[axis] ) {
            if( axis != Z_AXIS )
                step[axis] += trigDif[ step[axis] ].x;
            else
                step[axis] += trigDif[ step[axis] ].y;

            // check for wrap or out of bounds
            if( (step[axis] >= 360) || (step[axis] < 0) )
                step[axis] = 0;
        }
    }
}

/**************************************************************************\
* FindInvStep
*
* Finds step in invTrig table with same value as trig table at i
*
* History :
*  Apr. 28, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

static int
FindInvStep( int i )
{
    FLOAT val, diff, minDiff;
    int invStep = i;

    val = gTrig[i].y;

    invStep = i;
    minDiff = val - gInvTrig[i].y;

    while( ++i <= 90 ) {
        diff = val - gInvTrig[i].y;
        if( (FLOAT) fabs(diff) < minDiff ) {
            minDiff = (FLOAT) fabs(diff);
            invStep = i;
        }
        if( diff < 0.0f )
            break;
    }

    return invStep;
}


/**************************************************************************\
* FindStep
*
* Finds step in trig table with same value as invTrig table at i
*
* History :
*  Apr. 28, 95 : [marcfo]
*    - Wrote it
*
\**************************************************************************/

static int
FindStep( int i )
{
    FLOAT val, diff, minDiff;
    int step = i;

    val = gInvTrig[i].y;

    step = i;
    minDiff = gTrig[i].y - val;

    while( --i >= 0 ) {
        diff = val - gTrig[i].y;
        if( (FLOAT) fabs(diff) < minDiff ) {
            minDiff = (FLOAT) fabs(diff);
            step = i;
        }
        if( diff > 0.0f )
            break;
    }

    return step;
}

/**************************************************************************\
* InitTrigTable
*
* Initialize trig look-up tables
*
* History :
*  Apr. 28, 95 : [marcfo]
*    - Calculate 'diff' tables for smooth transitions between trig and
*      invTrig tables
*
\**************************************************************************/
static void
InitTrigTable()
{
    int i;
    static int num = 360;
    FLOAT inc = (2.0f*PI)/((FLOAT)num);  // 360 degree range
    FLOAT angle = 0.0f;
    int newStep;

    // calc standard trig table

    for( i = 0; i < num; i ++ ) {
        gTrig[i].x = (FLOAT) cos(angle);
        gTrig[i].y = (FLOAT) sin(angle);
        angle += inc;
    }

    // Calc sawtooth and pseudo-inverse trig table, as well as a diff
    // table to convert between trig and invTrig.

    // do y, or sin values first

    for( i = 0; i <= 90; i ++ ) {
        gSawTooth[i].y = (int) i / 90.0f;
        gInvTrig[i].y = 2*gSawTooth[i].y - gTrig[i].y;
    }

    // Create tables to convert trig steps to invTrig steps, and vice-versa
    for( i = 0; i <= 90; i ++ ) {
        newStep = FindInvStep( i );
        gTrigDif[i].y = newStep - i;
        newStep = FindStep( i );
        gInvTrigDif[i].y = newStep - i; // -
    }

    // reflect 0-90 to get 90-180
    for( i = 1; i <= 90; i ++ ) {
        gSawTooth[90+i].y = gSawTooth[90-i].y;
        gInvTrig[90+i].y = gInvTrig[90-i].y;
        gTrigDif[90+i].y = -gTrigDif[90-i].y;
        gInvTrigDif[90+i].y = -gInvTrigDif[90-i].y;
    }
    // invert 0-180 to get 180-360
    for( i = 1; i < 180; i ++ ) {
        gSawTooth[180+i].y = -gSawTooth[i].y;
        gInvTrig[180+i].y = -gInvTrig[i].y;
        gTrigDif[180+i].y = gTrigDif[i].y;
        gInvTrigDif[180+i].y = gInvTrigDif[i].y;
    }

    // calc x, or cos, by phase-shifting y

    for( i = 0; i < 270; i ++ ) {
        gSawTooth[i].x = gSawTooth[i+90].y;
        gInvTrig[i].x = gInvTrig[i+90].y;
        gTrigDif[i].x = gTrigDif[i+90].y;
        gInvTrigDif[i].x = gInvTrigDif[i+90].y;
    }
    for( i = 0; i < 90; i ++ ) {
        gSawTooth[i+270].x = gSawTooth[i].y;
        gInvTrig[i+270].x = gInvTrig[i].y;
        gTrigDif[i+270].x = gTrigDif[i].y;
        gInvTrigDif[i+270].x = gInvTrigDif[i].y;
    }
}

/**************************************************************************\
* CalcChordalDeviation
*
*
\**************************************************************************/
static FLOAT
CalcChordalDeviation( HDC hdc, AttrContext *pac )
{
    OUTLINETEXTMETRIC otm;
    FLOAT       cd, mincd;  // chordal deviations

    // Query font metrics

    if( GetOutlineTextMetrics( hdc, sizeof(otm), &otm) <= 0 )
        // cmd failed, or buffer size=0
        return 1.0f;

    // minimum chordal deviation is limited by design space
    mincd = 1.0f / (FLOAT) otm.otmEMSquare;

    // now map fTesselFact to chordalDeviation
    cd = MapValue( pac->fTesselFact,
                   0.0f, 1.0f,  // fTesselFact range
                   FMAX_CHORDAL_DEVIATION, mincd );  // chordalDeviation range
    if( pac->fTesselFact == 0.0f )
        // make sure get lowest resolution
        cd = 1.0f;
    return cd;
}

/**************************************************************************\
* CalcBoundingBox
*
\**************************************************************************/
static void
CalcBoundingBox( AttrContext *pac )
{
    POINT3D box[3];  // for each axis rotation
    FLOAT viewAngle, critAngle, critAngleC, rectAngle;
    FLOAT r, rot, x, y, z, xmax, ymax, zCrit;
    FLOAT viewDist, viewDistO, xAngle[3], angle;
    FLOAT boxvpo[3];  // viewpoint to origin distance along z for the boxes
    int n = 0;
    POINTFLOAT extent;
    POINT3D pt;

    /* One thing to remember here is that box[n].z is constrained to be
     * the near clipping plane.  The boxe's x and y represent the frustum
     * cross-section at that point.
     */
    viewAngle = deg_to_rad( pac->fFovy )  / 2.0f;

    // x,y,z represent half-extents
    x = pac->pfTextExtent.x/2.0f;
    y = pac->pfTextExtent.y/2.0f;
    z = pac->fDepth/2.0f;
    // initialize box[0] with current extents
    box[0].x = x;
    box[0].y = y;
    box[0].z = z;
    boxvpo[0] = 0.0f;

    // handle rotation around x-axis

    if( pac->p3dRotMax.x != 0.0f ) {

        box[n].x = x;

        // need to determine y and z

        rot = deg_to_rad( pac->p3dRotMax.x );
        r = (FLOAT) sqrt( y*y + z*z );

        // calc incursion along z

        rectAngle = (z == 0.0f) ? PI_OVER_2 : (FLOAT) atan( y/z );
        if( rot >= rectAngle ) {
            // easy, use maximum possible extent
            box[n].z = r;
        } else {
            // rotate lower right corner of box by rot to get extent
            box[n].z = z * (FLOAT) cos( rot ) + y * (FLOAT) sin( rot );
        }

        /* figure out critical angle, where rotated rectangle would
         * be perpendicular to viewing frustum.  This indicates the max.
         * y-incursion into the frustum.
         */
        critAngle = PI_OVER_2 - viewAngle;
        ymax = r * (FLOAT) sin(critAngle);

        if( y > z ) {
            rectAngle = PI_OVER_2 - rectAngle;
            critAngleC = PI_OVER_2 - critAngle;
        } else
            critAngleC = critAngle;

        if( (rectAngle + rot) >= critAngleC ) {
            // no view reduction possible in y, use max view
            // need to calc y at box.z
            viewDistO = r / (FLOAT) cos( critAngle );
            boxvpo[n] = viewDistO;
            box[n].y = (viewDistO - box[n].z) *
                                        (FLOAT) tan( PI_OVER_2 - critAngle);
        } else {
            // we can sonic reduce it
            if( y > z )
                rot = -rot;
            // rotate front-top point by rot to get ymax, z
            ymax = z * (FLOAT) sin( rot ) + y * (FLOAT) cos( rot );
            zCrit = z * (FLOAT) cos( rot ) - y * (FLOAT) sin( rot );
            // not usin viewDistO properly here...
            viewDistO = ymax * (FLOAT) tan( viewAngle);
            boxvpo[n] = viewDistO + zCrit;
            viewDist = boxvpo[n] - box[n].z;
            box[n].y = viewDist * (FLOAT) tan( viewAngle );
        }
        n++;
    }

    if( pac->p3dRotMax.y != 0.0f ) {

        box[n].y = y;

        // need to determine x and z
        rot = deg_to_rad( pac->p3dRotMax.y );
        r = (FLOAT) sqrt( x*x + z*z );
        rectAngle = (z == 0.0f) ? PI_OVER_2 : (FLOAT) atan( x/z );

        // calc incursion along z

        if( rot >= rectAngle ) {
            // easy, use maximum possible extent
            box[n].z = r;
        } else {
            // rotate lower right corner of box by rot to get extent
            box[n].z = z * (FLOAT) cos( rot ) + x * (FLOAT) sin( rot );
        }

        // view distance to largest z
        viewDist = y / (FLOAT) tan(viewAngle);
        // make viewDist represent distance to origin
        viewDistO = viewDist + box[n].z;
        boxvpo[n] = viewDistO;

        // now minimize angle between viewpoint and rotated rect

        if( viewDistO > r ) {
            /* calc crit angle where view is maximized (line from viewpoint
             * tangent to rotation circle)
             * critAngle is between z-axis and radial line
             */
            critAngle = (FLOAT) acos( r / viewDistO );

            // critAngleC is for Comparing
            if( x > z ) {
                rectAngle = PI_OVER_2 - rectAngle;
                critAngleC = PI_OVER_2 - critAngle;
            } else
                critAngleC = critAngle;
        }

        if( (viewDistO > r) && // vp OUTSIDE circle
            ((rectAngle + rot) >= critAngleC) ) {

            /* no view reduction possible in x, use x along the max-view line
             */
            box[n].x = viewDist * (FLOAT) tan( PI_OVER_2 - critAngle );
        } else {
            // we can sonic reduce it
            if( x > z )
                rot = -rot;
            // rotate front-top point by rot to get x,z
            // pt.z not needed
            //pt.z = z * (FLOAT) cos( rot ) - x * (FLOAT) sin( rot );
            pt.x = z * (FLOAT) sin( rot ) + x * (FLOAT) cos( rot );
            box[n].x = pt.x;
        }
        n++;
    }

    if( pac->p3dRotMax.z != 0.0f ) {

        CalcBoundingExtent( deg_to_rad(pac->p3dRotMax.z),
                            x, y,
                            (POINTFLOAT *) &box[n] );
        box[n].z = z;
        // calc viewing distance from front of box
        viewDist = box[n].y / (FLOAT) tan(viewAngle);
        // calc view distance to origin;
        boxvpo[n] = box[n].z + viewDist;
        n++;
    }

    /* XXX!: this is currently only being used for case of one axis rotation
     * There were clipping problems using it for more axis'
     */

    /* Now we've got 3 rectangles in x-y plane at various depths, and
     * need to pick the shortest viewing distance that will encompass
     * all of them.  Or, don't actually have to pick the view distance
     * yet, since might want to wait for the viewport size in Reshape before
     * we do this - but in that case need to pick the rectangle that 'sticks
     * out the most', so it can be used as the bounding box.
     */
    /* The box with the furthest viewpoint will work for y.
     * But then have to check
     * this against the x's of the others.  If any stick out of the frustum,
     * then it will have to be made larger in x.  By making x larger, we
     * do not affect fovy
     */
    SortBoxes( box, boxvpo, n ); // put largest viewpoint box in box[0]

    // figure view dist to first box
    // (could maintain these as they are calculated)
    viewDist = boxvpo[0] - box[0].z;

    // compare x angles of boxes

    switch( n ) {
        FLOAT den;

        case 3:
            den = viewDist + (box[0].z - box[2].z);
            xAngle[2] = den == 0.0f ? PI_OVER_2 : (FLOAT)atan( box[2].x / den);
        case 2:
            den = viewDist + (box[0].z - box[1].z);
            xAngle[1] = den == 0.0f ? PI_OVER_2 : (FLOAT)atan( box[1].x / den);
        case 1:
            xAngle[0] = viewDist == 0.0f ? PI_OVER_2 :
                                            (FLOAT)atan( box[0].x / viewDist );
    }

    // here, just call Sort again, with list of xAngles
    SortBoxes( box, xAngle, n ); // put largest xangle box in box[0]

    // now box[0] should contain half extents of the Bounding box

    pac->p3dBoundingBox = box[0];
}

/**************************************************************************\
* CalcBoundingBoxFromSphere
*
* Calculates the bounding box from a sphere with r = diagonal of the box
*
\**************************************************************************/
static void
CalcBoundingBoxFromSphere( AttrContext *pac )
{
    FLOAT x, y, z, r;
    FLOAT viewAngle, viewDist, viewDistO;
    POINT3D box;

    // x,y,z represent half-extents
    x = pac->pfTextExtent.x/2.0f;
    y = pac->pfTextExtent.y/2.0f;
    z = pac->fDepth/2.0f;

    r = (FLOAT) sqrt( x*x + y*y +z*z );
    box.z = r;
    viewAngle = deg_to_rad( pac->fFovy )  / 2.0f;
    viewDistO = r / (FLOAT) sin( viewAngle );
    viewDist = viewDistO - r;
    box.y = viewDist * (FLOAT) tan( viewAngle );
    box.x = box.y;

    pac->p3dBoundingBox = box;
}

/**************************************************************************\
*
* CalcBoundingBoxFromSpherePlus
*
* Same as above, but tries to optimize for case when z exent is small
*
\**************************************************************************/
static void
CalcBoundingBoxFromSpherePlus( AttrContext *pac, FLOAT zmax )
{
    FLOAT x, y, z, r;
    FLOAT viewAngle, viewDist, viewDistO;
    POINT3D box;

    // x,y,z represent half-extents
    x = pac->pfTextExtent.x/2.0f;
    y = pac->pfTextExtent.y/2.0f;
    z = pac->fDepth/2.0f;

    r = (FLOAT) sqrt( x*x + y*y +z*z );
    viewAngle = deg_to_rad( pac->fFovy )  / 2.0f;

    if( zmax < r ) {
        // we can get closer !
        box.z = zmax;
        viewDistO = r / (FLOAT) sin( viewAngle );
        viewDist = viewDistO - zmax;

        // we want to move the clipping plane closer by (r-zmax)
        if( (r-zmax) > viewDist ) {
#ifdef SS_DEBUG
            glClearColor( 1.0f, 0.0f, 0.0f, 0.0f );
#endif
            // we are moving the vp inside the sphere
            box.y = (FLOAT) sqrt( r*r - box.z*box.z );
            box.x = box.y;
        } else {
            FLOAT zt; // z-point where view frustum tangent to sphere

            // vp outside sphere: can only optimize if zmax < ztangent
            zt = r * (FLOAT) cos( PI_OVER_2 - viewAngle);
            if( zmax < zt ) {
#ifdef SS_DEBUG
                // GREEN ZONE !!!
                glClearColor( 0.0f, 1.0f, 0.0f, 0.0f );
#endif
                box.y = (FLOAT) sqrt( r*r - zmax*zmax );
            } else
                // this is the same as below, but with better clipping
                box.y = (viewDist + (r-zmax)) * (FLOAT) tan( viewAngle );
            box.x = box.y;
        }
    } else {
        box.z = r;
        viewDistO = r / (FLOAT) sin( viewAngle );
        viewDist = viewDistO - r;
        box.y = viewDist * (FLOAT) tan( viewAngle );
        box.x = box.y;
    }
    pac->p3dBoundingBox = box;
}

/**************************************************************************\
* CalcBoundingBoxFromExtents
*
* Calculate bounding box for text, assuming text centered at origin, and
* using maximum possible spin angles.
*
* Rotation around any one axis will affect bounding areas in the other
* 2 directions (e.g. z-rotation affects x and y bounding values).
*
* We need to find the maxima of the rotated 2d area, while staying within
* the max spin angles.
*
\**************************************************************************/
static void
CalcBoundingBoxFromExtents( AttrContext *pac, POINT3D *box )
{
    POINTFLOAT extent;

    box->x = pac->pfTextExtent.x / 2.0f;
    box->y = pac->pfTextExtent.y / 2.0f;
    box->z = pac->fDepth / 2.0f;

    // split the 3d problem into 3 2d problems in 'x-y' plane

    if( pac->p3dRotMax.x != 0.0f ) {

        CalcBoundingExtent( deg_to_rad(pac->p3dRotMax.x),
                            box->z, box->y, &extent );
        box->z = max( box->z, extent.x );
        box->y = max( box->y, extent.y );
    }

    if( pac->p3dRotMax.y != 0.0f ) {

        CalcBoundingExtent( deg_to_rad(pac->p3dRotMax.y),
                            box->x, box->z, &extent );
        box->x = max( box->x, extent.x );
        box->z = max( box->z, extent.y );
    }

    if( pac->p3dRotMax.z != 0.0f ) {

        CalcBoundingExtent( deg_to_rad(pac->p3dRotMax.z),
                            box->x, box->y, &extent );
        box->x = max( box->x, extent.x );
        box->y = max( box->y, extent.y );
    }
}

/**************************************************************************\
* CalcBoundingBoxGeneric
*
* Combines the bounding sphere with the bounding extents
* Each of these alone will guarantee no clipping.  But we can
* optimize by combining them.
*
\**************************************************************************/
static void
CalcBoundingBoxGeneric( AttrContext *pac )
{
    POINT3D extentBox;
    FLOAT x, y, z, r, d, zt, fovx;
    FLOAT viewAngle, viewDist, viewDistO;
    BOOL xIn, yIn;

    // x,y,z represent half-extents
    x = pac->pfTextExtent.x/2.0f;
    y = pac->pfTextExtent.y/2.0f;
    z = pac->fDepth/2.0f;


    // get the max extent box

    /*!!! wait, this alone doesn't guarantee no clipping?  It only
     * checks each axis-rotation separately, without combining them. This
     * is no better than calling old CalcBoundingBox ... ??  Well, I
     * can't prove why theoretically, but it works
     */
    CalcBoundingBoxFromExtents( pac, &extentBox );

    // determine whether x and y extents inside/outside bounding sphere

    r = (FLOAT) sqrt( x*x + y*y +z*z );
    // check y
    d = (FLOAT) sqrt( extentBox.y*extentBox.y + extentBox.z*extentBox.z );
    yIn = d <= r ? TRUE : FALSE;
    // check x
    d = (FLOAT) sqrt( extentBox.x*extentBox.x + extentBox.z*extentBox.z );
    xIn = d <= r ? TRUE : FALSE;

    // handle easy cases

    if( yIn && xIn ) {
        pac->p3dBoundingBox = extentBox;
        return;
    }
    if( !yIn && !xIn ) {
        CalcBoundingBoxFromSpherePlus( pac, extentBox.z );
        return;
    }

    // harder cases

    viewAngle = deg_to_rad( pac->fFovy )  / 2.0f;

    if( yIn ) {
        // figure out x
        viewDist = extentBox.y / (FLOAT) tan(viewAngle);
        /* viewDist can be inside or outside of the sphere
         * If inside - no optimization possible
         * If outside, can draw line from viewpoint tangent to sphere,
         * and use this point for x
         */
        viewDistO = extentBox.z + viewDist;
        if( viewDistO <= r ) {
            // vp inside sphere
            // set x to the point where z intersects sphere
            // this becomes a Pythagorous theorem problem:
            extentBox.x = (FLOAT) sqrt( r*r - extentBox.z*extentBox.z );
        } else {
            // vp outside sphere
            /* - figure out zt, where line tangent to circle for viewAngle
             */
            fovx = (FLOAT) asin( r / viewDistO );
            zt = r * (FLOAT) acos( PI_OVER_2 - viewAngle);
            if( extentBox.z < zt ) {
                // use x where extentBox.z intersects sphere
                extentBox.x = (FLOAT) sqrt( r*r - extentBox.z*extentBox.z );
            } else {
                // use x at tangent point
                extentBox.x = (FLOAT) sqrt( r*r - zt*zt );
            }
        }
    } else {// y out, x in
        // XXX!
        // have to figure out whether vp inside/outside of sphere.
        /* !We can cheat a bit here.  It IS possible, with view angles > 90,
         * that the vp be inside sphere.  But since we always use 90 for
         * this app, it is safe to assume vp > r  (Fix later for general case)
         */
        // XXX: wait, if y out, isn't vp always outside sphere ?
        /* So we solve it this way:
         * - figure out line tangent to circle for viewAngle
         * - y will be where this line intersects the z=extentBox.z line
         */
        viewDistO = r / (FLOAT) sin( viewAngle );
        extentBox.y = (viewDistO - extentBox.z) * (FLOAT) tan( viewAngle );
        // I guess don't have to do anything with x ?
    }
    pac->p3dBoundingBox = extentBox;
}

/**************************************************************************\
*
* Calculate the extents in x and y from rotating a rectangle in a 2d plane
*
\**************************************************************************/
static void
CalcBoundingExtent( FLOAT rot, FLOAT x, FLOAT y, POINTFLOAT *extent )
{
    FLOAT r, angleCrit;

    r = (FLOAT) sqrt( x*x + y*y );
    angleCrit = (x == 0.0f) ? PI_OVER_2 : (FLOAT) atan( y/x );

    // calc incursion in x

    if( rot >= angleCrit ) {
        // easy, use maximum possible extent
        extent->x = r;
    } else {
        // rotate lower right corner of box by rot to get extent
        extent->x = x * (FLOAT) cos( rot ) + y * (FLOAT) sin( rot );
    }

    // calc incursion in y

    angleCrit = PI/2.0f - angleCrit;

    if( rot >= angleCrit ) {
        // easy, use maximum possible extent
        extent->y = r;
    } else {
        // rotate upper right corner of box by rot to get extent
        extent->y = x * (FLOAT) sin( rot ) + y * (FLOAT) cos( rot );
    }

}

/**************************************************************************\
*
* Sorts in descending order, based on values in val array (bubble sort)
*
\**************************************************************************/
static void
SortBoxes( POINT3D *box, FLOAT *val, int numBox )
{
    int i, j, t;
    POINT3D temp;

    j = numBox;
    while( j ) {
        t = 0;
        for( i = 0; i < j-1; i++ ) {
            if( val[i] < val[i+1] ) {
                // swap'em
                temp = box[i];
                box[i] = box[i+1];
                box[i+1] = temp;
                t = i;
            }
        }
        j = t;
    }
}

#define FILE_BUF_SIZE 180

/**************************************************************************\
* VerifyString
*
* Validate the string
*
* Has hard-coded ascii routines
*
\**************************************************************************/
static BOOL
VerifyString( AttrContext *pac )
{
    HMODULE ghmodule;
    HRSRC hr;
    HGLOBAL hg;
    PSZ psz, pszFile = NULL;
    CHAR szSectName[30], szFileName[FILE_BUF_SIZE], szFname[30];
    BOOL bMatch = FALSE;

    // Check for string file in registry
    if (LoadStringA(hMainInstance, IDS_SAVERNAME, szSectName, 30) &&
        LoadStringA(hMainInstance, IDS_INIFILE, szFname, 30))
    {
        if( GetPrivateProfileStringA(szSectName, "magic", NULL,
                                     szFileName, FILE_BUF_SIZE, szFname) )
            pszFile = ReadStringFileA( szFileName );
    }

    // Check for key strings
    if( pszFile )
        bMatch = CheckKeyStrings( pac->szText, pszFile );

    if( !bMatch ) {
        if( (ghmodule = GetModuleHandle(NULL)) &&
            (hr = FindResource(ghmodule, MAKEINTRESOURCE(1), 
                                                    MAKEINTRESOURCE(99))) &&
            (hg = LoadResource(ghmodule, hr)) &&
            (psz = (PSZ)LockResource(hg)) )
        bMatch = CheckKeyStrings( pac->szText, psz );
    }

    if( bMatch ) {
        // put first string in pac->szText
        pac->demoType = DEMO_VSTRING;
        // for now, initialize strings here
        text3d_UpdateString( pac, FALSE );

        // adjust cycle time based on rotStyle
        switch( pac->rotStyle ) {
            case ROTSTYLE_NONE:
                gfMinCycleTime = 4.0f;
                break;
            case ROTSTYLE_SEESAW:
                gfMinCycleTime = 8.0f;
                break;
            case ROTSTYLE_RANDOM:
                gfMinCycleTime = 10.0f;
                break;
            default:
                gfMinCycleTime = 9.0f;
        }
    }
    if( pszFile )
        free( pszFile );  // allocated by ReadStringFile
    return bMatch;
}

/**************************************************************************\
* CheckKeyStrings
*
* Test for match between string and any keystrings
* 'string' is user-inputted, and limited to TEXT_LIMIT chars.
*
\**************************************************************************/

static BOOL
CheckKeyStrings( LPTSTR string, PSZ psz )
{
    int i;
    TCHAR szKey[TEXT_LIMIT+1], testString[TEXT_LIMIT+1] = {0};
    BOOL bMatch = FALSE;
    int nMatch = 0;
    int len;

    // make copy of test string and convert to upper case
    lstrcpy( testString, string );
#ifdef UNICODE
    _wcsupr( testString );
#else
    _strupr( testString );
#endif

    while( psz[0] != '\n' ) { // iterate keyword/data sets
        while( psz[0] != '\n' ) {  // iterate keywords
            len = strlen( psz ); // ! could be > TEXT_LIMIT if from file
            // invert keyword bits and convert to uppercase
#ifdef UNICODE
            // convert ascii keyword to unicode in szKey (inverts at same time)
            ConvertStringAsciiToUnicode( psz, szKey,
                                         len > TEXT_LIMIT ? TEXT_LIMIT : len );
            _wcsupr( szKey );
#else
            // just copy keyword to szKey, without going over TEXT_LIMIT
            strncpy( szKey, psz, TEXT_LIMIT );
            InvertBitsA( szKey, len > TEXT_LIMIT ? TEXT_LIMIT : len );
            szKey[TEXT_LIMIT] = '\0';  // in case len > TEXT_LIMIT
            _strupr( szKey );
#endif

            if( !lstrcmp( szKey, testString ) ) {
                // keyword match !
                bMatch = TRUE;
                nMatch++;
            }
            psz += len + 1;  // skip over NULL as well
        }
        psz++;  // skip over '\n' at end of keywords
        if( bMatch )
            ReadNameList( psz );

        // skip over data to get to next keyword group
        while( *psz != '\n' )
            psz++;
        psz++;  // skip over '\n' at end of data
        bMatch = FALSE; // keep searching for keyword matches
    }
    return nMatch;
}

/**************************************************************************\
* Various functions to process vstrings
*
\**************************************************************************/

static void
InvertBitsA( char *s, int len )
{
    while( len-- ) {
        *s++ = ~(*s);
    }
}

static PSZ
ReadStringFileA( LPSTR szFile )
{
    char lineBuf[180];
    PSZ buf, pBuf;
    int size, length, fdi;
    char *ps;
    char ctrl_n = '\n';
    FILE *fIn;
    BOOL bKey;

    // create buffer to hold entire file
    // mf: ! must be better way of getting file length!
    fdi = _open(szFile, O_RDONLY | O_BINARY);
    if( fdi < 0 )
        return NULL;
    size = _filelength( fdi );
    _close(fdi);
    buf= (char *) malloc( size );
    if( !buf)
        return NULL;

    // open file for ascii text reading
    fIn = fopen( szFile, "r" );
    if( !fIn )
        return NULL;

    // Read in keyword/data sequences

    bKey = TRUE;  // so '\n' not appended to file when hit first keyword
    pBuf = buf;
    while( fgets( lineBuf, 180, fIn) ) {
        ps = lineBuf;
        if( *ps == '-' ) {
            // keyword
            if( !bKey ) {
                // first key in group, append '\n' to data
                *pBuf++ = ctrl_n;
            }
            bKey = TRUE;
            ps++; // skip '-'
        } else {
            // data
            if( bKey ) {
                // first data in group, append '\n' to keywords
                *pBuf++ = ctrl_n;
            }
            bKey = FALSE;
        }
        length = strlen( ps );
        InvertBitsA( ps, length );
        *(ps+length-1) = '\0'; // convert '\n' to null
        lstrcpyA( pBuf, ps );
        pBuf += length;
    }
    fclose( fIn );

    // put 2 '\n' at end, for end condition
    *pBuf++ = ctrl_n;
    *pBuf++ = ctrl_n;
    return( buf );
}

static void
CreateRandomList()
{
   PLIST plist = gplistComplete;
   PLIST *pplist;
   int i = 0;
   int n;

   while (plist != NULL) {
       n = ss_iRand( i+1 );
       pplist = &gplist;

       while (n > 0) {
           pplist = &((*pplist)->pnext);
           n--;
       }

       plist->pnext = *pplist;
       *pplist = plist;

       plist = plist->plistComplete;
       i++;
   }
}

static void
AddName(
    LPTSTR pszStr)
{
    PLIST plist = (PLIST)LocalAlloc(LPTR, sizeof(LIST));
    if( !plist )
        return;
    plist->pszStr = pszStr;
    plist->pnext = NULL;
    plist->plistComplete = gplistComplete;
    gplistComplete = plist;
}

static void
ReadNameList( PSZ psz )
{
    int length;
    int i;
    LPTSTR pszNew;

    while (psz[0] != '\n') {
        length = 0;
        while (psz[length] != 0) {
            length++;
        }
        length;
        pszNew = (LPTSTR)LocalAlloc( LPTR, (length + 1)*sizeof(TCHAR) );
        if( !pszNew )
            return;
#ifdef UNICODE
        ConvertStringAsciiToUnicode( psz, (PWSTR) pszNew, length );
#else
        strncpy( pszNew, psz, length );
        InvertBitsA( pszNew, length );
#endif
        AddName(pszNew);

        psz += length + 1;
    }
}

static void
DeleteNameList()
{
    PLIST plist = gplistComplete, plistLast;

    while( plist != NULL ) {
        LocalFree( plist->pszStr );
        plistLast = plist;
        plist = plist->plistComplete;
        LocalFree( plistLast );
    }
}

/**************************************************************************\
* ConvertStringAsciiToUnicorn
*
\**************************************************************************/
static void
ConvertStringAsciiToUnicode( PSZ psz, PWSTR pwstr, int len )
{
    while( len-- )
         *pwstr++ = ~(*psz++) & 0xFF;
    *pwstr = 0; // null terminate
}

/**************************************************************************\
* FrameCalibration
*
* Adjusts the number of frames in a cycle to conform to desired cycle time
*
\**************************************************************************/
static int
FrameCalibration( AttrContext *pac, struct _timeb *pBaseTime, int framesPerCycle, int nCycle )
{
    struct _timeb thisTime;
    FLOAT cycleTime;

    _ftime( &thisTime );
    cycleTime = thisTime.time - pBaseTime->time +
           (thisTime.millitm - pBaseTime->millitm)/1000.0f;
    cycleTime /= (FLOAT) nCycle;

    if( cycleTime < gfMinCycleTime ) {
        // need to add more frames to cycle
        if( cycleTime == 0.0f ) // very unlikely
            framesPerCycle = 800;
        else
            framesPerCycle = (int)( (FLOAT)framesPerCycle *
                            (gfMinCycleTime/cycleTime) );
    } else {
        // for vstrings, subtract frames from cycle
        if( pac->demoType == DEMO_VSTRING ) {
            framesPerCycle = (int)( (FLOAT)framesPerCycle *
                            (gfMinCycleTime/cycleTime) );
        }
    }
#define MIN_FRAMES 16
    // make sure it's not too small
    if( framesPerCycle < MIN_FRAMES )
        framesPerCycle = MIN_FRAMES;

    return framesPerCycle;
}

/**************************************************************************\
* MapValue
*
* Maps the value along an input range, to a proportional one along an
* output range.  Each range must be monotonically increasing or decreasing.
*
* NO boundary conditions checked - responsibility of caller.
*
\**************************************************************************/
FLOAT
MapValue( FLOAT fInVal,
          FLOAT fIn1, FLOAT fIn2,       // input range
          FLOAT fOut1, FLOAT fOut2 )    // output range
{
    FLOAT fDist, fOutVal;

    // how far along the input range is fInVal?, in %
    fDist = (fInVal - fIn1) / (fIn2 - fIn1);

    // use this distance to interpolate into output range
    fOutVal = fDist * (fOut2 - fOut1) + fOut1;

    return fOutVal;
}

/**************************************************************************\
* MapValueI
*
* Similar to above, but maps integer values
*
* Currently, only works for increasing ranges
*
* History
*  Apr. 28, 95 : [marcfo]
*    - Added early return for boundary conditions
*
\**************************************************************************/
int
MapValueI( int inVal,
          int in1, int in2,       // input range
          int out1, int out2 )    // output range
{
    int inDiv;
    int outVal;
    FLOAT fScale, fComp;

    if( inVal >= in2 )
        return out2;
    if( inVal <= in1 )
        return out1;

    inDiv = abs(in2 - in1) + 1;
    fScale = (FLOAT) (inDiv-1) / (FLOAT) inDiv;
    fComp = 1.0f + (1.0f / inDiv);

    outVal = (int) MapValue( (FLOAT) inVal * fComp,
                       (FLOAT) in1, (FLOAT) in2 + 0.999f,
                       (FLOAT) out1, (FLOAT) out2 + 0.999f );
    return outVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\alloc.c ===
/*
** Copyright 1991, 1992, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

#if DBG

// Set glRandomMallocFail to a positive value, say 40, to enable random
// allocation failures.  The failure will occur every glRandomMallocFail
// times.
long glRandomMallocFail = 0;
static long glRandomFailCount;

// glSize is the size of memory in use.
ULONG glSize = 0;
ULONG glHighWater = 0;
ULONG glReal = 0;

static void AdjustSizes(LONG delta, void *mem)
{
    ULONG nbytes;

#ifdef GL_REAL_SIZE
    nbytes = HeapSize(GetProcessHeap(), 0, mem);
#else
    nbytes = 0;
#endif
    
    if (delta < 0)
    {
        glSize -= (ULONG)(-delta);
        glReal -= nbytes;
        
        if ((int) glSize < 0)
        {
            DBGPRINT("glSize underflows\n");
        }
    }
    else if (delta > 0)
    {
        glSize += delta;
        glReal += nbytes;
        
        if ((int) glSize < 0)
        {
            DBGPRINT("glSize overflows\n");
        }
        
        if (glSize > glHighWater)
        {
#ifdef GL_SHOW_HIGH_WATER
            DbgPrint("glSize high %8d (%8d)\n", glSize, glReal);
#endif
            glHighWater = glSize;
        }
    }
}

typedef struct _MEM_HDR
{
    ULONG nbytes;
    ULONG signature[3];
} MEM_HDR;

// 'GLal' in byte order
#define MEM_ALLOC_SIG 0x6C614C47
// 'GLfr' in byte order
#define MEM_FREE_SIG 0x72664C47

#define MEM_HDR_SIZE sizeof(MEM_HDR)
#define MEM_HDR_PTR(mem) ((MEM_HDR *)((BYTE *)(mem)-MEM_HDR_SIZE))

// XXX We may want to protect these debug allocation functions with a
// critical section.
void * FASTCALL
dbgAlloc(UINT nbytes, DWORD flags)
{
    PVOID mem;

    // If random failure is enabled, fail this call randomly.

    if (glRandomMallocFail)
    {
        if (++glRandomFailCount >= glRandomMallocFail)
        {
            DBGPRINT("dbgAlloc random failing\n");
            glRandomFailCount = 0;
            return NULL;
        }
    }

    if (nbytes == 0)
    {
        DBGERROR("nbytes == 0\n");
        return NULL;
    }
    
    // Allocate extra bytes for debug house keeping.

    mem = HeapAlloc(GetProcessHeap(), flags, nbytes+MEM_HDR_SIZE);

    // Do house keeping and add allocation size so far.

    if (mem)
    {
        MEM_HDR *pmh = (MEM_HDR *)mem;

        pmh->nbytes = nbytes;
        pmh->signature[0] = MEM_ALLOC_SIG;
        pmh->signature[1] = MEM_ALLOC_SIG;
        pmh->signature[2] = MEM_ALLOC_SIG;
        AdjustSizes((LONG)nbytes, mem);
        mem = (PVOID) (pmh+1);
    }
    else
    {
        DBGLEVEL1(LEVEL_ERROR, "dbgAlloc could not allocate %u bytes\n",
                  nbytes);
    }

    DBGLEVEL2(LEVEL_ALLOC, "dbgAlloc of %u returned 0x%x\n", nbytes, mem);
    
    return mem;
}

void FASTCALL
dbgFree(void *mem)
{
    MEM_HDR *pmh;
    
    if (!mem)
    {
#ifdef FREE_OF_NULL_ERR
	// Freeing NULL happens currently so this error results
	// in a little too much spew.
        DBGERROR("mem is NULL\n");
#endif
        return;
    }

    // Verify that the signature is not corrupted.

    pmh = MEM_HDR_PTR(mem);
    if (pmh->signature[0] != MEM_ALLOC_SIG ||
        pmh->signature[1] != MEM_ALLOC_SIG ||
        pmh->signature[2] != MEM_ALLOC_SIG)
    {
        WARNING("Possible memory corruption\n");
    }

    // Make sure it is freed once only.

    pmh->signature[0] = MEM_FREE_SIG;
    pmh->signature[1] = MEM_FREE_SIG;
    pmh->signature[2] = MEM_FREE_SIG;

    // Subtract the allocation size.

    AdjustSizes(-(LONG)pmh->nbytes, pmh);

    HeapFree(GetProcessHeap(), 0, pmh);
    
    DBGLEVEL1(LEVEL_ALLOC, "dbgFree of 0x%x\n", mem);
}

void * FASTCALL
dbgRealloc(void *mem, UINT nbytes)
{
    PVOID memNew;
    MEM_HDR *pmh;

    // If random failure is enabled, fail this call randomly.

    if (glRandomMallocFail)
    {
        if (++glRandomFailCount >= glRandomMallocFail)
        {
            DBGPRINT("dbgRealloc random failing\n");
            glRandomFailCount = 0;
            return NULL;
        }
    }

    if (mem != NULL)
    {
	// Verify that the signature is not corrupted.
        
        pmh = MEM_HDR_PTR(mem);
        if (pmh->signature[0] != MEM_ALLOC_SIG ||
            pmh->signature[1] != MEM_ALLOC_SIG ||
            pmh->signature[2] != MEM_ALLOC_SIG)
        {
            WARNING("Possible memory corruption\n");
        }

        AdjustSizes(-(LONG)pmh->nbytes, pmh);
        
        // Reallocate nbytes+extra bytes.
        memNew = HeapReAlloc(GetProcessHeap(), 0, pmh, nbytes+MEM_HDR_SIZE);
    }
    else
    {
        // Old memory pointer is NULL, so allocate a new chunk.
        memNew = HeapAlloc(GetProcessHeap(), 0, nbytes+MEM_HDR_SIZE);

        // We've allocated new memory so initialize its signature.
        if (memNew != NULL)
        {
            pmh = (MEM_HDR *)memNew;
            pmh->signature[0] = MEM_ALLOC_SIG;
            pmh->signature[1] = MEM_ALLOC_SIG;
            pmh->signature[2] = MEM_ALLOC_SIG;
        }
    }

    if (memNew != NULL)
    {
        // Do house keeping and update allocation size so far.

        AdjustSizes(nbytes, memNew);
        pmh = (MEM_HDR *)memNew;
        pmh->nbytes = nbytes;
        memNew = (PVOID) (pmh+1);
    }
    else
    {
        if (mem != NULL)
        {
            AdjustSizes((LONG)pmh->nbytes, pmh);
        }
        
        DBGLEVEL1(LEVEL_ERROR, "dbgRealloc could not allocate %u bytes\n",
                  nbytes);
    }

    DBGLEVEL3(LEVEL_ALLOC, "dbgRealloc of 0x%X:%u returned 0x%x\n",
              mem, nbytes, memNew);

    return memNew;
}

int FASTCALL
dbgMemSize(void *mem)
{
    MEM_HDR *pmh;
    
    pmh = MEM_HDR_PTR(mem);
    
    if (pmh->signature[0] != MEM_ALLOC_SIG ||
        pmh->signature[1] != MEM_ALLOC_SIG ||
        pmh->signature[2] != MEM_ALLOC_SIG)
    {
        return -1;
    }
    
    return (int)pmh->nbytes;
}

#endif // DBG

ULONG APIENTRY glDebugEntry(int param, void *data)
{
#if DBG
    switch(param)
    {
    case 0:
	return glSize;
    case 1:
	return glHighWater;
    case 2:
	return glReal;
    case 3:
        return dbgMemSize(data);
    }
#endif
    return 0;
}

#define MEM_ALIGN 32

void * FASTCALL
AllocAlign32(UINT nbytes)
{
    void *mem;
    void **aligned;

    // We allocate enough extra memory for the alignment and our header
    // which just consists of a pointer:

    mem = ALLOC(nbytes + MEM_ALIGN + sizeof(void *));
    if (!mem)
    {
        DBGLEVEL1(LEVEL_ERROR, "AllocAlign32 could not allocate %u bytes\n",
                  nbytes);
        return NULL;
    }

    aligned = (void **)(((ULONG_PTR)mem + sizeof(void *) +
                         (MEM_ALIGN - 1)) & ~(MEM_ALIGN - 1));
    *(aligned-1) = mem;
    
    return aligned;
}

void FASTCALL
FreeAlign32(void *mem)
{
    if ( NULL == mem )
    {
        DBGERROR("NULL pointer passed to FreeAlign32\n");
        return;
    }

    FREE(*((void **)mem-1));
}

void * FASTCALL
gcAlloc( __GLcontext *gc, UINT nbytes, DWORD flags )
{
    void *mem;

#if DBG
    mem = dbgAlloc(nbytes, flags);
#else
    mem = HeapAlloc(GetProcessHeap(), flags, nbytes);
#endif
    if (NULL == mem)
    {
        ((__GLGENcontext *)gc)->errorcode = GLGEN_OUT_OF_MEMORY;
        __glSetErrorEarly(gc, GL_OUT_OF_MEMORY);
    }
    return mem;
}

void * FASTCALL
GCREALLOC( __GLcontext *gc, void *mem, UINT nbytes )
{
    void *newMem;

    // The Win32 realloc functions do not have free-on-zero behavior,
    // so fake it.
    if (nbytes == 0)
    {
	if (mem != NULL)
	{
	    FREE(mem);
	}
	return NULL;
    }

    // The Win32 realloc functions don't handle a NULL old pointer,
    // so explicitly turn such calls into allocs.
    if (mem == NULL)
    {
	newMem = ALLOC(nbytes);
    }
    else
    {
	newMem = REALLOC(mem, nbytes);
    }

    if (NULL == newMem)
    {
        ((__GLGENcontext *)gc)->errorcode = GLGEN_OUT_OF_MEMORY;
        __glSetErrorEarly(gc, GL_OUT_OF_MEMORY);
    }

    return newMem;
}

void * FASTCALL
GCALLOCALIGN32( __GLcontext *gc, UINT nbytes )
{
    void *mem;

    mem = AllocAlign32(nbytes);
    if (NULL == mem)
    {
        ((__GLGENcontext *)gc)->errorcode = GLGEN_OUT_OF_MEMORY;
        __glSetErrorEarly(gc, GL_OUT_OF_MEMORY);
    }
    return mem;
}

// Tunable parameters for temporary memory allocation

#define MAX_TEMP_BUFFERS    4
#define TEMP_BUFFER_SIZE    4096

struct MemHeaderRec
{
    LONG  inUse;
    ULONG nbytes;
    void  *mem;
};

typedef struct MemHeaderRec MemHeader;

MemHeader TempMemHeader[MAX_TEMP_BUFFERS];

// InitTempAlloc
//      Initializes the temporary memory allocation header and allocates the
//      temporary memory buffers.
//
// Synopsis:
//      BOOL InitTempAlloc()
//
// History:
//      02-DEC-93 Eddie Robinson [v-eddier] Wrote it.
//
BOOL FASTCALL
InitTempAlloc(void)
{
    int   i;
    PBYTE buffers;
    static LONG initCount = -1;
    
    if (initCount >= 0)
        return TRUE;

    if (InterlockedIncrement(&initCount) != 0)
        return TRUE;

// Allocate buffers for the first time.

    buffers = ALLOC(MAX_TEMP_BUFFERS*TEMP_BUFFER_SIZE);
    if (!buffers)
    {
        InterlockedDecrement(&initCount);           // try again later
        return FALSE;
    }

    for (i = 0; i < MAX_TEMP_BUFFERS; i++)
    {
        TempMemHeader[i].nbytes = TEMP_BUFFER_SIZE;
        TempMemHeader[i].mem = (void *) buffers;
        TempMemHeader[i].inUse = -1;      // must be last
        buffers += TEMP_BUFFER_SIZE;
    }
    
    return TRUE;
}                                  

// gcTempAlloc
//      Allocates temporary memory from a static array, if possible.  Otherwise
//      it calls ALLOC
//
// Synopsis:
//      void * gcTempAlloc(__GLcontext *gc, UINT nbytes)
//          gc      points to the OpenGL context structure
//          nbytes  specifies the number of bytes to allocate
//
// History:
//  02-DEC-93 Eddie Robinson [v-eddier] Wrote it.
//
void * FASTCALL
gcTempAlloc(__GLcontext *gc, UINT nbytes)
{
    int i;
    void *mem;

    if (nbytes == 0)
    {
        // Zero-byte allocations do occur so don't make this a warning
        // to avoid excessive debug spew.
        DBGLEVEL(LEVEL_ALLOC, "gcTempAlloc: failing zero byte alloc\n");
        return NULL;
    }
    
    for (i = 0; i < MAX_TEMP_BUFFERS; i++)
    {
        if (nbytes <= TempMemHeader[i].nbytes)
        {
            if (InterlockedIncrement(&TempMemHeader[i].inUse))
            {
                InterlockedDecrement(&TempMemHeader[i].inUse);
            }
            else
            {
                DBGLEVEL2(LEVEL_ALLOC, "gcTempAlloc of %u returned 0x%x\n",
                          nbytes, TempMemHeader[i].mem);
                GC_TEMP_BUFFER_ALLOC(gc, TempMemHeader[i].mem);
                return(TempMemHeader[i].mem);
            }
        }
    }
    
    mem = ALLOC(nbytes);
    if (!mem)
    {
        WARNING1("gcTempAlloc: memory allocation error size %d\n", nbytes);
        ((__GLGENcontext *)gc)->errorcode = GLGEN_OUT_OF_MEMORY;
        __glSetErrorEarly(gc, GL_OUT_OF_MEMORY);
    }
    
    DBGLEVEL2(LEVEL_ALLOC, "gcTempAlloc of %u returned 0x%x\n", nbytes, mem);
    GC_TEMP_BUFFER_ALLOC(gc, mem);
    
    return mem;
}

// gcTempFree
//      Marks allocated static buffer as unused or calls FREE.
//
// Synopsis:
//      void gcTempFree(__GLcontext *gc, void *mem)
//          mem    specifies the adress of the memory to free
//
// History:
//  02-DEC-93 Eddie Robinson [v-eddier] Wrote it.
//
void FASTCALL
gcTempFree(__GLcontext *gc, void *mem)
{
    int i;
    
    DBGLEVEL1(LEVEL_ALLOC, "gcTempFree of 0x%x\n", mem);

    GC_TEMP_BUFFER_FREE(gc, mem);
    for (i = 0; i < MAX_TEMP_BUFFERS; i++)
    {
        if (mem == TempMemHeader[i].mem)
        {
            InterlockedDecrement(&TempMemHeader[i].inUse);
            return;
        }
    }
    
    FREE( mem );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\ddirx.h ===
/*

Copyright (c) 1994, Microsoft Corporation

Module Name:

    ddirx.h

Abstract:

    Defines and types for Rendering/CAD DDI Extension Interface.

*/

#define DDIRXFUNCS        0x8000

typedef LONG LONGFIX;
typedef HANDLE DDIHANDLE;

/* Rendering-function header */

#define RX_CLIPINFO     0x0001

typedef struct _DDIRXHDR {
    ULONG flags;
    ULONG cCmd;
    DDIHANDLE hDDIrc;
    DDIHANDLE hMem;
    ULONG ulMemOffset;
} DDIRXHDR;

/* Rendering-function header */

typedef struct _DDIRXCMD {
    USHORT idFunc;
    USHORT flags;
    ULONG cData;
    ULONG buffer[1];
} DDIRXCMD;

typedef struct _DDIRXCLIPINFO {
    ULONG flags;
    ULONG idClip;
    ULONG cClip;
    RECT rclClient;
    RECT rclClip[1];    
} DDIRXCLIPINFO;

#define FRONT_BUFFER    0
#define BACK_BUFFER     1

#define RX_FLAT         0
#define RX_SMOOTH       1

#define RX_COLOR_INDEXED    0
#define RX_COLOR_RGBA       1

#define RX_DISABLE          0
#define RX_ENABLE_FASTEST   1
#define RX_ENABLE_NICEST    2

#define RX_LINEPAT          1
#define RX_FILLPAT          2
#define RX_ROP2             3
#define RX_GLCOMPAT         4
#define RX_WRITEBUFFER      5
#define RX_PLANEMASK        6
#define RX_ZMASK            7
#define RX_Z_ENABLE         8
#define RX_ALPHA_ENABLE     9
#define RX_LAST_PIXEL       10
#define RX_TEX_MAG          11
#define RX_TEX_MIN          12
#define RX_SRCBLEND         13
#define RX_DSTBLEND         14
#define RX_TEXBLEND         15
#define RX_COLORMODE        16
#define RX_PIXELMODE        17
#define RX_ZFUNC            18
#define RX_ALPHAREF         19
#define RX_ALPHAFUNC        20
#define RX_DITHER           21
#define RX_BLEND            22
#define RX_FILL             23
#define RX_TEXTURE          24
#define RX_FILLCOLOR        25
#define RX_FILLZ            26
#define RX_SOLIDCOLOR       27
#define RX_TRANSPCOLOR      28
#define RX_TRANSP_ENABLE    29
#define RX_FLOAT_ENABLE     30
#define RX_MASK_START       31
#define RX_AAPOINT_MODE     32
#define RX_AALINE_MODE      33
#define RX_AAPOLY_MODE      34
#define RX_SHADEMODE        35
#define RX_VERTEXTYPE       36
#define RX_SCANTYPE         37


typedef struct _COLORREFA {
    BYTE b;
    BYTE g;
    BYTE r;
    BYTE a;
} COLORREFA;

typedef struct _COLORREFAFIX {
    LONGFIX b;
    LONGFIX g;
    LONGFIX r;
    LONGFIX a;
} COLORREFAFIX;

typedef struct _PTFIX {
    LONGFIX x;
    LONGFIX y;
} PTFIX;

typedef struct _PTFIXZ {
    LONGFIX x;
    LONGFIX y;
    ULONG z;
} PTFIXZ;

typedef struct _PTFIXZTEX {
    LONGFIX x;
    LONGFIX y;
    ULONG z;
    LONGFIX s;
    LONGFIX t;
    FLOAT q;
    FLOAT w;
} PTFIXZTEX;

typedef struct _COLORPTFIXZTEX {
    LONGFIX b;
    LONGFIX g;
    LONGFIX r;
    LONGFIX a;
    LONGFIX x;
    LONGFIX y;
    LONG z;
    LONGFIX s;
    LONGFIX t;
    FLOAT q;
    FLOAT w;
} COLORPTFIXZTEX;

typedef struct _RXLINEPAT {
    USHORT repFactor;
    USHORT linePattern;
} RXLINEPAT;


typedef struct _RXFILLPAT {
    ULONG fillPattern[32];
} RXFILLPAT;

typedef struct _RXBITBLT {
    ULONG pixType;
    DDIHANDLE hSrc;
    DDIHANDLE hDest;
    ULONG xSrc;
    ULONG ySrc;
    ULONG xDest;
    ULONG yDest;
    ULONG width;
    ULONG height;
    ULONG srcWidth;
    ULONG srcHeight;
    ULONG destWidth;
    ULONG destHeight;
} RXBITBLT;

#define RX_COLOR_COMPONENT  1
#define RX_Z_COMPONENT      2

#define RX_FL_FILLCOLOR     0x0001
#define RX_FL_FILLZ         0x0002

// Comparison functions.  Test passes if new pixel value meets the
// specified condition with the current pixel value.

#define RX_CMP_NEVER        0x0001
#define RX_CMP_LESS         0x0002
#define RX_CMP_EQUAL        0x0004
#define RX_CMP_LEQUAL       0x0008
#define RX_CMP_GREATER      0x0010
#define RX_CMP_NOTEQUAL     00x020
#define RX_CMP_GEQUAL       0x0040
#define RX_CMP_ALWAYS       0x0080
#define RX_CMP_ALLGL        0x00ff

// Primitive-drawing capability flags

#define RX_SCANPRIM		0x0001
#define RX_LINEPRIM		0x0002
#define RX_FILLPRIM		0x0004
#define RX_BITBLT		0x0008

// Z-buffer resource flags

#define RX_Z_PER_WINDOW         0x0001
#define RX_Z_PER_SCREEN         0x0002

// Mask capability flags

#define RX_MASK_MSB             0x0001
#define RX_MASK_LSB             0x0002
#define RX_MASK_PLANES          0x0004

// Blending flags

#define RX_BLND_ZERO            0x0001
#define RX_BLND_ONE             0x0002
#define RX_BLND_SRC_COLOR       0x0004
#define RX_BLND_INV_SRC_COLOR   0x0008
#define RX_BLND_SRC_ALPHA       0x0010
#define RX_BLND_INV_SRC_ALPHA   0x0020
#define RX_BLND_DST_ALPHA       0x0040
#define RX_BLND_INV_DST_ALPHA   0x0080
#define RX_BLND_DST_COLOR       0x0100
#define RX_BLND_INV_DST_COLOR   0x0200
#define RX_BLND_SRC_ALPHA_SAT   0x0400
#define RX_BLND_ALLGL           0x07ff

// Texture-mapping flags

#define RX_TEX_NEAREST              0x0001
#define RX_TEX_LINEAR               0x0002
#define RX_TEX_MIP_NEAREST          0x0004
#define RX_TEX_MIP_LINEAR           0x0008
#define RX_TEX_LINEAR_MIP_NEAREST   0x0010
#define RX_TEX_LINEAR_MIP_LINEAR    0x0020
 
// Texture blending flags

#define RX_TEX_DECAL        0x0001
#define RX_TEX_MODULATE     0x0002

// Raster/color capability flags

#define RX_RASTER_DITHER          0x0001
#define RX_RASTER_ROP2            0x0002
#define RX_RASTER_LINEPAT         0x0004
#define RX_RASTER_FILLPAT         0x0008
#define RX_RASTER_TRANSPARENCY    0x0010

typedef struct _RXCAPS {
    ULONG verMajor;
    ULONG verMinor;
    ULONG maskCaps;
    ULONG rasterCaps;
    ULONG drawCaps;
    ULONG aaCaps;
    ULONG cCaps;
    ULONG zCaps;
    ULONG zCmpCaps;
    ULONG srcBlendCaps;
    ULONG dstBlendCaps;
    ULONG alphaCmpCaps;
    ULONG texCaps;        
    ULONG texFilterCaps;        
    ULONG texBlendCaps;        
    ULONG texMaxWidth;        
    ULONG texMaxHeight;        
    ULONG miscCaps;
} RXCAPS;

#define RX_DEV_BITMAP   1
#define RX_MEM_BITMAP   2

typedef struct _RXSURFACEINFO {
    USHORT surfType;
    UCHAR cBytesPerPixel;
    UCHAR rDepth;
    UCHAR gDepth;
    UCHAR bDepth;
    UCHAR aDepth;
    UCHAR rBitShift;
    UCHAR gBitShift;
    UCHAR bBitShift;
    UCHAR aBitShift;
    UCHAR zBytesPerPixel;
    UCHAR zDepth;
    UCHAR zBitShift;
    VOID *pZBits;
    LONG zScanDelta;
} RXSURFACEINFO;

typedef struct _RXSHAREMEM {
    HANDLE hSourceProcess;
    HANDLE hSource;
    DWORD dwOffset;
    DWORD dwSize;
} RXSHAREMEM;


#define RX_SCAN_PIX         0x0001
#define RX_SCAN_COLOR       0x0002
#define RX_SCAN_COLORZ      0x0003
#define RX_SCAN_COLORZTEX   0x0004

#define RX_SCAN_DELTA   0x0001
#define RX_SCAN_MASK    0x0002

typedef struct _RXSCAN {
    USHORT x;
    USHORT y;
    USHORT flags;
    USHORT count;
} RXSCAN;

#define FL_SCAN3D_DELTA     0x0001
#define FL_SCAN3D_PIX       0x0002
#define FL_SCAN3D_MASK      0x0004

typedef struct _RXSCANTEMPLATE {
    RXSCAN rxScan;
    COLORREFAFIX fixColor;
    PTFIXZTEX ptTex;
} RXSCANTEMPLATE;

#define RX_RESOURCE_TEX   1

#define RX_MEMCACHE       1
#define RX_MEMDEV         2
#define RX_MEMANY         3

typedef struct _RXTEXTURE {
    ULONG level;
    ULONG width;
    ULONG height;
    ULONG border;
} RXTEXTURE;

// Primitive types

#define RXPRIM_POINTS       1
#define RXPRIM_LINESTRIP    2
#define RXPRIM_TRISTRIP     3
#define RXPRIM_QUADSTRIP    4

#define RX_PTFIX            1
#define RX_PTFIXZ           2
#define RX_PTFIXZTEX        3

#define RX_INFO_CAPS            1
#define RX_INFO_SURFACE         2

#define DDIRX_GETINFO           1
#define DDIRX_CREATECONTEXT     2
#define DDIRX_DELETERESOURCE    3
#define DDIRX_MAPMEM            4
#define DDIRX_GETSURFACEHANDLE  5
#define DDIRX_SETSTATE          6
#define DDIRX_FILLRECT          7
#define DDIRX_BITBLT            8
#define DDIRX_POLYSCAN          9
#define DDIRX_ALLOCRESOURCE     10
#define DDIRX_LOADTEXTURE       11
#define DDIRX_PRIMSTRIP         12
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\debug.c ===
//+---------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1997.
//
// debug.c
//
// Debug build support routines.
//
// History:
//  Mon Jun 02 17:07:23 1997	-by-	Drew Bliss [drewb]
//   Created
//
//----------------------------------------------------------------------------

#include "precomp.h"
#pragma hdrstop

#include <imports.h>
#include <devlock.h>

#if DBG

static void printNormalFloat( float fval )
{
    int logi, logval_i, logval_f;
    float logval, logf;
    int negative=0;

    if( fval < (float) 0.0 )
	negative = 1;
    fval = __GL_ABSF(fval);

    logval = (float) (log( fval ) / log( 10 ));

    logi = (int) logval;
    logf = logval - logi;

    if( (logval <= (float) 0) && (logf != (float) 0.0) ) {
	logi -= 1;
	logf += (float) 1.0;
    }
    logval = (float) pow(10,logf);
    if( negative )
	DbgPrint( "-" );
#if 0
    DbgPrint( "%fE%d", logval, logi );
#else
    logval_i = (int) logval;
    logval_f = (int) ((logval - (float) logval_i) * (float) 10000.0 + (float) 0.5);
    DbgPrint( "%d.%dE%d", logval_i, logval_f, logi );
#endif
}

void printFloat( char *comment, void *mval, int printHex ) 
{
// IEEE single format: sign bits : 1
//		       exponent  : 7
//		       fraction  : 24
// Representation:	low word : Fraction low
//		       high word : 0-6: Fraction high
//				   7-14: Exponent
//				     15: Sign
    char *ploww, *phighw;
    short loww, highw;
    long lval = 0, fraction;
    int sign, exponent;
    float fval;

    ploww = (char *) mval;
    phighw = (char *) ((char *) mval) + 2;
    memcpy( &loww, ploww, 2 );
    memcpy( &highw, phighw, 2 );
    memcpy( &lval, mval, 4 );

    sign = (highw & 0x8000) >> 15;
    fraction = lval & 0x007fffff;
    exponent = (highw & 0x7f80) >> 7;

    DbgPrint( "%s", comment );
    if( printHex )
    	DbgPrint( "0x%x, ", lval );
    if( exponent == 255 ) {
	if( fraction == 0 ) {
	    if( sign )
		DbgPrint( "-" );
	    DbgPrint( "infinity" );
	}
	else
	    DbgPrint( "NaN" );
    }
    else if( exponent == 0 ) {
	if( fraction == 0 ) 
	    DbgPrint( "0.0" );
	else {
	    memcpy( &fval, mval, 4 );
	    printNormalFloat( fval );
	}
    }
    else {
	    memcpy( &fval, mval, 4 );
	    printNormalFloat( fval );
	}
}

/*****************************************************************************\
* DbgPrintFloat
*
* Prints floating point numbers from within server, in exponent notation with
* 4 significant digits (e.g 1.7392E-23).  Also prints string preceeding number.
* Checks for deviant cases, such as NaN's or infinity.
* 
\*****************************************************************************/

void DbgPrintFloat( char *comment, float fval ) 
{
    printFloat( comment, &fval, 0 );
}

/*****************************************************************************\
* DbgPrintFloatP
*
* Same as DbgPrintFloat, but takes a pointer to the float to print.  Also
* prints out the hex representation of the float.
* Used in cases where the float may not be a valid float.
* 
\*****************************************************************************/

void DbgPrintFloatP( char *comment, void *mval ) 
{
    printFloat( comment, mval, 1 );
}

#if defined(VERBOSE_DDSLOCK)

//
// Define DDGLOCK if you know the location of the DDraw global lock
// (DDRAW!CheapMutexCrossProcess) and want to see its counts.
//
typedef struct _DDRAW_GLOBAL_LOCK
{
    LONG LockCount;
    LONG RecursionCount;
    DWORD Tid;
    DWORD Pid;
} DDRAW_GLOBAL_LOCK;

// #define DDGLOCK ((DDRAW_GLOBAL_LOCK *)0x76959048)

/******************************Public*Routine******************************\
*
* DDSLOCK
*
* Tracks DirectDraw surface locks
*
* History:
*  Wed May 28 13:42:23 1997	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

HRESULT dbgDdsLock(LPDIRECTDRAWSURFACE pdds, DDSURFACEDESC *pddsd,
                   DWORD flags, char *file, int line)
{
    HRESULT hr;
#ifdef DDGLOCK
    volatile DDRAW_GLOBAL_LOCK *glock = DDGLOCK;
#endif

    DbgPrint("%2X:Lock %08lX %4d:%s\n",
             GetCurrentThreadId(), pdds, line, file);
    
#ifdef DDGLOCK
    DbgPrint("   %2d %2d %2X\n", glock->LockCount, glock->RecursionCount,
             glock->Tid);
#endif
    
    hr = pdds->lpVtbl->Lock(pdds, NULL, pddsd, flags, NULL);
    
#ifdef DDGLOCK
    DbgPrint("   %2d %2d %2X\n", glock->LockCount, glock->RecursionCount,
             glock->Tid);
#endif
    
    return hr;
}

/******************************Public*Routine******************************\
*
* DDSUNLOCK
*
* Tracks DirectDrawSurface unlocks
*
* History:
*  Wed May 28 13:42:39 1997	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

HRESULT dbgDdsUnlock(LPDIRECTDRAWSURFACE pdds, void *ptr,
                     char *file, int line)
{
    HRESULT hr;
#ifdef DDGLOCK
    volatile DDRAW_GLOBAL_LOCK *glock = DDGLOCK;
    LONG preLock;
#endif

    DbgPrint("%2X:Unlk %08lX %4d:%s\n",
             GetCurrentThreadId(), pdds, line, file);
    
#ifdef DDGLOCK
    DbgPrint("   %2d %2d %2X\n", glock->LockCount, glock->RecursionCount,
             glock->Tid);
    preLock = glock->LockCount;
#endif
    
    hr = pdds->lpVtbl->Unlock(pdds, ptr);
    
#ifdef DDGLOCK
    DbgPrint("   %2d %2d %2X\n", glock->LockCount, glock->RecursionCount,
             glock->Tid);
    if (preLock <= glock->LockCount)
    {
        DebugBreak();
    }
#endif
    
    return hr;
}

#endif // VERBOSE_DDSLOCK

#endif  // DBG

#ifdef _WIN95_
// Provide a DbgPrint implementation on Win95 since the system's doesn't
// do anything.
ULONG DbgPrint(PCH Format, ...)
{
    char achMsg[256];
    va_list vlArgs;

    va_start(vlArgs, Format);
    _vsnprintf(achMsg, sizeof(achMsg), Format, vlArgs);
    va_end(vlArgs);
    OutputDebugString(achMsg);
    return TRUE;
}
#endif // _WIN95_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\genaccel.c ===
/******************************Module*Header*******************************\
* Module Name: genaccel.c                                                  *
*                                                                          *
* This module provides support routines for acceleration functions.        *
*                                                                          *
* Created: 18-Feb-1994                                                     *
* Author: Otto Berkes [ottob]                                              *
*                                                                          *
* Copyright (c) 1994 Microsoft Corporation                                 *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "genline.h"

#ifdef GL_WIN_specular_fog
#define DO_NICEST_FOG(gc)\
         ((gc->state.hints.fog == GL_NICEST) && !(gc->polygon.shader.modeFlags & __GL_SHADE_SPEC_FOG))
#else //GL_WIN_specular_fog
#define DO_NICEST_FOG(gc)\
         (gc->state.hints.fog == GL_NICEST) 
#endif //GL_WIN_specular_fog

static ULONG internalSolidTexture[4] = {0xffffffff, 0xffffffff,
                                        0xffffffff, 0xffffffff};

GENTEXCACHE *GetGenTexCache(__GLcontext *gc, __GLtexture *tex)
{
    ULONG size;
    GENTEXCACHE *pGenTex;
    ULONG internalFormat;
    GLuint modeFlags = gc->polygon.shader.modeFlags;

    // Replace maps are only used for a subset of possible modes
    //   8 or 16bpp
    //   16-bit Z
    //
    //   No dithering.  Since dithering can turn on and off there
    //   are two cases:
    //     Dither off at TexImage time but on at texturing time -
    //       We create a map that's unused
    //     Dither on and then off - We won't create a map at
    //       TexImage time but it'll be created on the fly when
    //       dithering is turned on and everything is repicked
    //
    // Replace maps aren't created for DirectDraw textures because
    // the data isn't constant
    
    if (GENACCEL(gc).bpp < 8 ||
        GENACCEL(gc).bpp > 16 ||
        ((modeFlags & (__GL_SHADE_DEPTH_TEST | __GL_SHADE_DEPTH_ITER)) &&
         gc->modes.depthBits > 16) ||
        (modeFlags & __GL_SHADE_DITHER) ||
        gc->texture.ddtex.levels > 0)
    {
        return NULL;
    }

    internalFormat = tex->level[0].internalFormat;

    // We only support 8-bit palettes that are fully populated
    if (internalFormat == GL_COLOR_INDEX16_EXT ||
        (internalFormat == GL_COLOR_INDEX8_EXT &&
         tex->paletteSize != 256))
    {
        return NULL;
    }
    
    pGenTex = tex->pvUser;

    // Check and see whether the cached information can be reused
    // for the texture passed in
    if (pGenTex != NULL)
    {
        // gc's don't match so this must be a shared texture
        // Don't attempt to create a replace map for this gc
        if (gc != pGenTex->gc)
        {
            return NULL;
        }

        // Size and format must match to reuse the existing data area
        // If they don't, release the existing buffer.  A new one
        // will then be allocated
        if (internalFormat == GL_COLOR_INDEX8_EXT)
        {
            if (pGenTex->internalFormat != internalFormat ||
                pGenTex->width != tex->paletteTotalSize)
            {
                GCFREE(gc, pGenTex);
                tex->pvUser = NULL;
            }
        }
        else
        {
            if (pGenTex->internalFormat != internalFormat ||
                pGenTex->width != tex->level[0].width ||
                pGenTex->height != tex->level[0].height)
            {
                GCFREE(gc, pGenTex);
                tex->pvUser = NULL;
            }
        }
    }

    if (tex->pvUser == NULL)
    {
        if (internalFormat == GL_COLOR_INDEX8_EXT)
        {
            size = tex->paletteTotalSize * sizeof(DWORD);
        }
        else
        {
            size = tex->level[0].width * tex->level[0].height *
                GENACCEL(gc).xMultiplier;
        }

        pGenTex = (GENTEXCACHE *)GCALLOC(gc, size + sizeof(GENTEXCACHE));

        if (pGenTex != NULL)
        {
            tex->pvUser = pGenTex;
            pGenTex->gc = gc;
            pGenTex->paletteTimeStamp =
                ((__GLGENcontext *)gc)->PaletteTimestamp;
            if (internalFormat == GL_COLOR_INDEX8_EXT)
            {
                pGenTex->height = 0;
                pGenTex->width = tex->paletteTotalSize;
            }
            else
            {
            pGenTex->height = tex->level[0].height;
            pGenTex->width = tex->level[0].width;
            }
            pGenTex->internalFormat = internalFormat;
            pGenTex->texImageReplace = (UCHAR *)(pGenTex+1);
        }
    }

    return pGenTex;
}

BOOL FASTCALL __fastGenLoadTexImage(__GLcontext *gc, __GLtexture *tex)
{
    UCHAR *texBuffer;
    GLint internalFormat = tex->level[0].internalFormat;
    GENTEXCACHE *pGenTex;

    if (tex->level[0].buffer == NULL ||
	((internalFormat != GL_BGR_EXT) &&
         (internalFormat != GL_BGRA_EXT) &&
         (internalFormat != GL_COLOR_INDEX8_EXT)))
    {
        return FALSE;
    }

    // OK, the texture doesn't have a compressed replace-mode format, so
    // make one...

    if ((internalFormat == GL_BGR_EXT) ||
        (internalFormat == GL_BGRA_EXT)) {

        ULONG size;
        UCHAR *replaceBuffer;
        ULONG bytesPerPixel = GENACCEL(gc).xMultiplier;

        pGenTex = GetGenTexCache(gc, tex);
        if (pGenTex == NULL)
        {
            return FALSE;
        }

        texBuffer = (UCHAR *)tex->level[0].buffer;
        replaceBuffer = pGenTex->texImageReplace;

        {
            __GLcolorBuffer *cfb = gc->drawBuffer;
            ULONG rShift = cfb->redShift;
            ULONG gShift = cfb->greenShift;
            ULONG bShift = cfb->blueShift;
            ULONG rBits = ((__GLGENcontext *)gc)->gsurf.pfd.cRedBits;
            ULONG gBits = ((__GLGENcontext *)gc)->gsurf.pfd.cGreenBits;
            ULONG bBits = ((__GLGENcontext *)gc)->gsurf.pfd.cBlueBits;
            BYTE *pXlat = ((__GLGENcontext *)gc)->pajTranslateVector;
            ULONG i;

            size = tex->level[0].width * tex->level[0].height;
            for (i = 0; i < size; i++, texBuffer += 4) {
                ULONG color;

                color = ((((ULONG)texBuffer[2] << rBits) >> 8) << rShift) |
                    ((((ULONG)texBuffer[1] << gBits) >> 8) << gShift) |
                    ((((ULONG)texBuffer[0] << bBits) >> 8) << bShift);

                if (GENACCEL(gc).bpp == 8)
                    *replaceBuffer = pXlat[color & 0xff];
                else
                    *((USHORT *)replaceBuffer) = (USHORT)color;

                replaceBuffer += bytesPerPixel;
            }
        }
    } else {

        ULONG size;
        ULONG *replaceBuffer;

        // If we don't have palette data yet we can't create the
        // fast version.  It will be created when the ColorTable
        // call happens
        if (tex->paletteTotalData == NULL)
        {
            return FALSE;
        }

        pGenTex = GetGenTexCache(gc, tex);
        if (pGenTex == NULL)
        {
            return FALSE;
        }

        texBuffer = (UCHAR *)tex->paletteTotalData;
        replaceBuffer = (ULONG *)pGenTex->texImageReplace;
        size = tex->paletteTotalSize;

        {
            __GLcolorBuffer *cfb = gc->drawBuffer;
            ULONG rShift = cfb->redShift;
            ULONG gShift = cfb->greenShift;
            ULONG bShift = cfb->blueShift;
            ULONG rBits = ((__GLGENcontext *)gc)->gsurf.pfd.cRedBits;
            ULONG gBits = ((__GLGENcontext *)gc)->gsurf.pfd.cGreenBits;
            ULONG bBits = ((__GLGENcontext *)gc)->gsurf.pfd.cBlueBits;
            BYTE *pXlat = ((__GLGENcontext *)gc)->pajTranslateVector;
            ULONG i;

            for (i = 0; i < size; i++, texBuffer += 4) {
                ULONG color;

                color = ((((ULONG)texBuffer[2] << rBits) >> 8) << rShift) |
                    ((((ULONG)texBuffer[1] << gBits) >> 8) << gShift) |
                    ((((ULONG)texBuffer[0] << bBits) >> 8) << bShift);

                if (GENACCEL(gc).bpp == 8)
                    color = pXlat[color & 0xff];

                *replaceBuffer++ = (color | ((ULONG)texBuffer[3] << 24));
            }
        }
    }

    GENACCEL(gc).texImageReplace =
        ((GENTEXCACHE *)tex->pvUser)->texImageReplace;

    return TRUE;
}


/*
** Pick the fastest triangle rendering implementation available based on
** the current mode set.  Use any available accelerated resources if
** available, or use the generic routines for unsupported modes.
*/

void FASTCALL __fastGenCalcDeltas(__GLcontext *gc, __GLvertex *a, __GLvertex *b, __GLvertex *c);
void FASTCALL __fastGenCalcDeltasTexRGBA(__GLcontext *gc, __GLvertex *a, __GLvertex *b, __GLvertex *c);
void FASTCALL __fastGenDrvCalcDeltas(__GLcontext *gc, __GLvertex *a, __GLvertex *b, __GLvertex *c);

void __fastGenSetInitialParameters(__GLcontext *gc, const __GLvertex *a,
                                   __GLfloat dx, __GLfloat dy);
void __fastGenSetInitialParametersTexRGBA(__GLcontext *gc, const __GLvertex *a,
                                          __GLfloat dx, __GLfloat dy);

void __ZippyFT(
    __GLcontext *gc,
    __GLvertex *a,
    __GLvertex *b,
    __GLvertex *c,
    GLboolean ccw);

VOID FASTCALL InitAccelTextureValues(__GLcontext *gc, __GLtexture *tex)
{
    ULONG wLog2;
    ULONG hLog2;

    GENACCEL(gc).tex = tex;
    GENACCEL(gc).texImage = (ULONG *)tex->level[0].buffer;
    if (tex->level[0].internalFormat == GL_COLOR_INDEX8_EXT ||
        tex->level[0].internalFormat == GL_COLOR_INDEX16_EXT)
    {
        GENACCEL(gc).texPalette = (ULONG *)tex->paletteTotalData;
    }
    else
    {
        GENACCEL(gc).texPalette = NULL;
    }

    wLog2 = tex->level[0].widthLog2;
    hLog2 = tex->level[0].heightLog2;

    GENACCEL(gc).sMask = (~(~0 << wLog2)) << TEX_SCALESHIFT;
    GENACCEL(gc).tMask = (~(~0 << hLog2)) << TEX_SCALESHIFT;
    GENACCEL(gc).tShift = TEX_SCALESHIFT - (wLog2 + TEX_SHIFTPER4BPPTEXEL);
    GENACCEL(gc).tMaskSubDiv =
        (~(~0 << hLog2)) << (wLog2 + TEX_T_FRAC_BITS + TEX_SHIFTPER1BPPTEXEL);
    GENACCEL(gc).tShiftSubDiv =
        TEX_SCALESHIFT - (wLog2 + TEX_T_FRAC_BITS + TEX_SHIFTPER1BPPTEXEL);
    GENACCEL(gc).texXScale = (__GLfloat)tex->level[0].width * TEX_SCALEFACT;
    GENACCEL(gc).texYScale = (__GLfloat)tex->level[0].height * TEX_SCALEFACT;
}

BOOL FASTCALL bUseGenTriangles(__GLcontext *gc)
{
    GLuint modeFlags = gc->polygon.shader.modeFlags;
    GLuint enables = gc->state.enables.general;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    ULONG bpp = GENACCEL(gc).bpp;
    int iType;
    BOOL fZippy;
    BOOL bTryFastTexRGBA;
    PFNZIPPYSUB pfnZippySub;
    BOOL fUseFastGenSpan;
    GLboolean bMcdZ;
    ULONG internalFormat;
    ULONG textureMode;
    BOOL bRealTexture;
    BOOL bAccelDecal;

    if ((enables & (__GL_ALPHA_TEST_ENABLE |
                    __GL_STENCIL_TEST_ENABLE)) ||
        (modeFlags & (__GL_SHADE_STENCIL_TEST | __GL_SHADE_LOGICOP |
                      __GL_SHADE_ALPHA_TEST | __GL_SHADE_SLOW_FOG
#ifdef GL_WIN_specular_fog
                      | __GL_SHADE_SPEC_FOG
#endif //GL_WIN_specular_fog
                      )) ||
        !gc->state.raster.rMask ||
        !gc->state.raster.gMask ||
        !gc->state.raster.bMask ||
        (gc->drawBuffer->buf.flags & COLORMASK_ON) ||
        ALPHA_WRITE_ENABLED( gc->drawBuffer ) ||
        (gengc->gsurf.pfd.cColorBits < 8) ||
        ((modeFlags & __GL_SHADE_DEPTH_TEST) && (!gc->state.depth.writeEnable))
       )
        return FALSE;

    if (modeFlags & __GL_SHADE_TEXTURE) {
        internalFormat = gc->texture.currentTexture->level[0].internalFormat;
        textureMode = gc->state.texture.env[0].mode;
        bAccelDecal = (gc->texture.currentTexture->level[0].baseFormat !=
                       GL_RGBA);
        
        if (!((((textureMode == GL_DECAL) && bAccelDecal) ||
               (textureMode == GL_REPLACE) ||
               (textureMode == GL_MODULATE)) &&
              (gc->texture.currentTexture &&
               (gc->texture.currentTexture->params.minFilter == GL_NEAREST) &&
               (gc->texture.currentTexture->params.magFilter == GL_NEAREST) &&
               (gc->texture.currentTexture->params.sWrapMode == GL_REPEAT) &&
               (gc->texture.currentTexture->params.tWrapMode == GL_REPEAT) &&
               (gc->texture.currentTexture->level[0].border == 0) &&
               (internalFormat == GL_BGR_EXT ||
                internalFormat == GL_BGRA_EXT ||
                internalFormat == GL_COLOR_INDEX8_EXT))))
            return FALSE;

        InitAccelTextureValues(gc, gc->texture.currentTexture);
    }

    bMcdZ = ((((__GLGENcontext *)gc)->pMcdState != NULL) &&
             (((__GLGENcontext *)gc)->pMcdState->pDepthSpan != NULL) &&
             (((__GLGENcontext *)gc)->pMcdState->pMcdSurf != NULL) &&
             !(((__GLGENcontext *)gc)->pMcdState->McdBuffers.mcdDepthBuf.bufFlags & MCDBUF_ENABLED));

    bTryFastTexRGBA = ((gc->state.raster.drawBuffer != GL_FRONT_AND_BACK) &&
                       ((modeFlags & __GL_SHADE_DEPTH_TEST &&
                         modeFlags & __GL_SHADE_DEPTH_ITER)
                    || (!(modeFlags & __GL_SHADE_DEPTH_TEST) &&
                        !(modeFlags & __GL_SHADE_DEPTH_ITER))) &&
                       (modeFlags & __GL_SHADE_STIPPLE) == 0);

    fZippy = (bTryFastTexRGBA &&
              ((gc->drawBuffer->buf.flags & DIB_FORMAT) != 0) &&
              ((gc->drawBuffer->buf.flags & MEMORY_DC) != 0) &&
              gc->transform.reasonableViewport);

    GENACCEL(gc).flags &= ~(
            GEN_DITHER | GEN_RGBMODE | GEN_TEXTURE | GEN_SHADE |
            GEN_FASTZBUFFER | GEN_LESS | SURFACE_TYPE_DIB | GEN_TEXTURE_ORTHO
        );

    if ((enables & __GL_BLEND_ENABLE) ||
        (modeFlags & __GL_SHADE_TEXTURE)) {
        GENACCEL(gc).__fastCalcDeltaPtr = __fastGenCalcDeltasTexRGBA;
        GENACCEL(gc).__fastSetInitParamPtr = __fastGenSetInitialParametersTexRGBA;
    } else {
        GENACCEL(gc).__fastCalcDeltaPtr = __fastGenCalcDeltas;
        GENACCEL(gc).__fastSetInitParamPtr = __fastGenSetInitialParameters;
    }

#ifdef GL_WIN_phong_shading      
    if (modeFlags & __GL_SHADE_PHONG)
    {
        gc->procs.fillTriangle = __glFillPhongTriangle;
    }
    else
#endif //GL_WIN_phong_shading      
    {
#ifdef _MCD_
        // If MCD driver is being used, then we need to call the "floating
        // point state safe" version of fillTriangle.  This version will
        // not attempt to span floating point operations over a call that
        // may invoke the MCD driver (which will corrupt the FP state).

        if (gengc->pMcdState)
        {
            gc->procs.fillTriangle = __fastGenMcdFillTriangle;
        }
        else
        {
            gc->procs.fillTriangle = __fastGenFillTriangle;
        }
#else //_MCD_
        gc->procs.fillTriangle = __fastGenFillTriangle;
#endif //_MCD_
    }
    
    // If we're doing perspective-corrected texturing, we will support
    // the following combinations:
    //  z....... <, <=
    //  alpha... src, 1-src
    //  dither.. on/off
    //  bpp..... 332, 555, 565, 888

    // NOTE:  We will always try this path first for general texturing.

    if ((modeFlags & __GL_SHADE_TEXTURE) || (enables & __GL_BLEND_ENABLE)) {
        LONG pixType = -1;

        if (gc->state.hints.perspectiveCorrection != GL_NICEST)
            GENACCEL(gc).flags |= GEN_TEXTURE_ORTHO;

        if (!bTryFastTexRGBA)
            goto perspTexPathFail;

        if ((enables & __GL_BLEND_ENABLE) &&
            ((gc->state.raster.blendSrc != GL_SRC_ALPHA) ||
             (gc->state.raster.blendDst != GL_ONE_MINUS_SRC_ALPHA)))
            return FALSE;

        if (!(modeFlags & __GL_SHADE_TEXTURE)) {

            if (!(modeFlags & __GL_SHADE_RGB))
                goto perspTexPathFail;

            bRealTexture = FALSE;
            
            GENACCEL(gc).flags |= GEN_TEXTURE_ORTHO;
            GENACCEL(gc).texPalette = NULL;
            textureMode = GL_MODULATE;
            internalFormat = GL_BGRA_EXT;
            GENACCEL(gc).texImage =  (ULONG *)internalSolidTexture;
            GENACCEL(gc).sMask = 0;
            GENACCEL(gc).tMask = 0;
            GENACCEL(gc).tShift = 0;
            GENACCEL(gc).tMaskSubDiv = 0;
            GENACCEL(gc).tShiftSubDiv = 0;
        }
        else
        {
            bRealTexture = TRUE;
        }

        if (bpp == 8) {
            if ((gengc->gc.drawBuffer->redShift   == 0) &&
                (gengc->gc.drawBuffer->greenShift == 3) &&
                (gengc->gc.drawBuffer->blueShift  == 6))
                pixType = 0;
        } else if (bpp == 16) {
            if ((gengc->gc.drawBuffer->greenShift == 5) &&
                (gengc->gc.drawBuffer->blueShift  == 0)) {

                if (gengc->gc.drawBuffer->redShift == 10)
                    pixType = 1;
                else if (gengc->gc.drawBuffer->redShift == 11)
                    pixType = 2;
            }
        } else if ((bpp == 32) || (bpp == 24)) {
            if ((gengc->gc.drawBuffer->redShift == 16) &&
                (gengc->gc.drawBuffer->greenShift == 8) &&
                (gengc->gc.drawBuffer->blueShift  == 0))
                pixType = 3;
        }

        if (pixType < 0)
            goto perspTexPathFail;

        pixType *= 6;

        if (modeFlags & __GL_SHADE_DEPTH_ITER) {

            if (bMcdZ)
                goto perspTexPathFail;

            if (!((gc->state.depth.testFunc == GL_LESS) ||
                 (gc->state.depth.testFunc == GL_LEQUAL)))
                goto perspTexPathFail;

            if (gc->modes.depthBits > 16)
                goto perspTexPathFail;

            if (gc->state.depth.testFunc == GL_LEQUAL)
                pixType += 1;
            else
                pixType += 2;

            GENACCEL(gc).__fastFillSubTrianglePtr = __ZippyFSTZ;
        }

        if (enables & __GL_BLEND_ENABLE)
            pixType += 3;

        // Note:  For selecting the sub-triangle filling routine, assume
        // that we will use one of the "zippy" routines.  Then, check at the
        // end whether or not we can actually do this, or if we have to fall
        // back to a more generic (and slower) routine.

        if (internalFormat != GL_COLOR_INDEX8_EXT &&
            internalFormat != GL_COLOR_INDEX16_EXT) {

            //
            // Handle full RGB(A) textures
            //

            // Check if we can support the size...

            if (bRealTexture &&
                GENACCEL(gc).tex &&
                ((GENACCEL(gc).tex->level[0].widthLog2 > TEX_MAX_SIZE_LOG2) ||
                 (GENACCEL(gc).tex->level[0].heightLog2 > TEX_MAX_SIZE_LOG2)))
                goto perspTexPathFail;

            if ((textureMode == GL_DECAL) ||
                (textureMode == GL_REPLACE)) {

                // we don't handle the goofy alpha case for decal...

                if ((textureMode == GL_DECAL) &&
                    (enables & __GL_BLEND_ENABLE))
                    return FALSE;

                // If we're not dithering, we can go with the compressed
                // texture format.  Otherwise, we're forced to use flat-shading
                // procs to get the texture colors to dither properly.  Ouch...

                // We'd like to also go through this path if a DirectDraw
                // texture is used because replace maps can't be created,
                // but they only work with dithering
                if (modeFlags & __GL_SHADE_DITHER) {
                    GENACCEL(gc).__fastTexSpanFuncPtr =
                        __fastPerspTexFlatFuncs[pixType];
                } else {
                    if ((bpp >= 8 && bpp <= 16) &&
                        !(enables & __GL_BLEND_ENABLE)) {

                        // handle the case where we can use compressed textures
                        // for optimal performance.  We do this for bit depths
                        // <= 16 bits, no dithering, and no blending.

                        if (!GENACCEL(gc).tex->pvUser) {
                            if (!__fastGenLoadTexImage(gc, GENACCEL(gc).tex))
                                return FALSE;
                        } else {

                            // If the compressed texture image was created for
                            // another gc, revert to using the RGBA image.
                            // We do this by using the alpha paths.
                            //
                            // NOTE:  This logic depends on A being forced to
                            // 1 for all RGB textures.

                            if (gc != ((GENTEXCACHE *)GENACCEL(gc).tex->pvUser)->gc)
                            {
                                pixType += 3;
                            }
                            else
                            {
                                // Check that the cached data is the right size
                                ASSERTOPENGL(((GENTEXCACHE *)GENACCEL(gc).tex->pvUser)->width == GENACCEL(gc).tex->level[0].width &&
                                             ((GENTEXCACHE *)GENACCEL(gc).tex->pvUser)->height == GENACCEL(gc).tex->level[0].height,
                                             "Cached texture size mismatch\n");
                            }
                        }
                    }

                    GENACCEL(gc).__fastTexSpanFuncPtr =
                        __fastPerspTexReplaceFuncs[pixType];
                }

                if (!(modeFlags & __GL_SHADE_DEPTH_ITER))
                    GENACCEL(gc).__fastFillSubTrianglePtr = __ZippyFSTTex;

            } else if (textureMode == GL_MODULATE) {
                if (modeFlags & __GL_SHADE_SMOOTH) {
                    GENACCEL(gc).__fastTexSpanFuncPtr =
                        __fastPerspTexSmoothFuncs[pixType];
                    if (!(modeFlags & __GL_SHADE_DEPTH_ITER))
                        GENACCEL(gc).__fastFillSubTrianglePtr = __ZippyFSTRGBTex;
                } else {
                    GENACCEL(gc).__fastTexSpanFuncPtr =
                        __fastPerspTexFlatFuncs[pixType];
                    if (!(modeFlags & __GL_SHADE_DEPTH_ITER))
                        GENACCEL(gc).__fastFillSubTrianglePtr = __ZippyFSTTex;
                }
            }
        } else {
            //
            // Handle palettized textures
            //

            // Check if we can support the size...

            if (bRealTexture &&
                GENACCEL(gc).tex &&
                ((GENACCEL(gc).tex->level[0].widthLog2 > TEX_MAX_SIZE_LOG2) ||
                 (GENACCEL(gc).tex->level[0].heightLog2 > TEX_MAX_SIZE_LOG2)))
                return FALSE;

            if ((textureMode == GL_DECAL) ||
                (textureMode == GL_REPLACE)) {

                // we don't handle the goofy alpha case for decal...

                if ((textureMode == GL_DECAL) &&
                    (enables & __GL_BLEND_ENABLE))
                    return FALSE;

                // If we're not dithering, we can go with the compressed
                // texture format.  Otherwise, we're forced to use flat-shading
                // procs to get the texture colors to dither properly.  Ouch...

                // We'd like to also go through this path if a DirectDraw
                // texture is used because replace maps can't be created,
                // but they only work with dithering
                if (modeFlags & __GL_SHADE_DITHER) {
                    GENACCEL(gc).__fastTexSpanFuncPtr =
                        __fastPerspTexFlatFuncs[pixType];
                } else {

                    GENACCEL(gc).__fastTexSpanFuncPtr =
                        __fastPerspTexPalReplaceFuncs[pixType];

                    if (bpp >= 8 && bpp <= 16) {
                        // handle the case where we can use compressed paletted
                        // textures for optimal performance.  We do this for
                        // bit depths <= 16 bits with no dithering.

                        if (!GENACCEL(gc).tex->pvUser) {
                            if (!__fastGenLoadTexImage(gc, GENACCEL(gc).tex))
                                return FALSE;
                        } else {

        // If the compressed texture image was created for
        // another gc, we have no choice but to fall back to flat shading.
        // We should find a better solution for this...
                            if (gc != ((GENTEXCACHE *)GENACCEL(gc).tex->pvUser)->gc)
                            {
                                GENACCEL(gc).__fastTexSpanFuncPtr =
                                    __fastPerspTexFlatFuncs[pixType];
                            }
                            else
                            {
                                ASSERTOPENGL(((GENTEXCACHE *)GENACCEL(gc).tex->pvUser)->width == GENACCEL(gc).tex->paletteTotalSize,
                                             "Cached texture size mismatch\n");
                            }
                        }
                    }
                }

                if (!(modeFlags & __GL_SHADE_DEPTH_ITER))
                    GENACCEL(gc).__fastFillSubTrianglePtr = __ZippyFSTTex;

            } else if (textureMode == GL_MODULATE) {
                if (modeFlags & __GL_SHADE_SMOOTH) {
                    GENACCEL(gc).__fastTexSpanFuncPtr =
                        __fastPerspTexSmoothFuncs[pixType];
                    if (!(modeFlags & __GL_SHADE_DEPTH_ITER))
                        GENACCEL(gc).__fastFillSubTrianglePtr = __ZippyFSTRGBTex;
                } else {
                    GENACCEL(gc).__fastTexSpanFuncPtr =
                        __fastPerspTexFlatFuncs[pixType];
                    if (!(modeFlags & __GL_SHADE_DEPTH_ITER))
                        GENACCEL(gc).__fastFillSubTrianglePtr = __ZippyFSTTex;
                }
            }
        }

        if (!fZippy)
            GENACCEL(gc).__fastFillSubTrianglePtr = __fastGenFillSubTriangleTexRGBA;
        else
            GENACCEL(gc).flags |= SURFACE_TYPE_DIB;

        return TRUE;

    }

perspTexPathFail:

    // We don't support any alpha modes yet...

    if (enables & __GL_BLEND_ENABLE)
        return FALSE;

    fUseFastGenSpan = FALSE;

    if (bpp == 8) {
        iType = 2;
        if (
               (gengc->gc.drawBuffer->redShift   != 0)
            || (gengc->gc.drawBuffer->greenShift != 3)
            || (gengc->gc.drawBuffer->blueShift  != 6)
           ) {
            fUseFastGenSpan = TRUE;
        }
    } else if (bpp == 16) {
        if (
               (gengc->gc.drawBuffer->greenShift == 5)
            && (gengc->gc.drawBuffer->blueShift  == 0)
           ) {
            if (gengc->gc.drawBuffer->redShift == 10) {
                iType = 3;
            } else if (gengc->gc.drawBuffer->redShift == 11) {
                iType = 4;
            } else {
                iType = 3;
                fUseFastGenSpan = TRUE;
            }
        } else {
            iType = 3;
            fUseFastGenSpan = TRUE;
        }
    } else {
        if (bpp == 24) {
            iType = 0;
        } else {
            iType = 1;
        }
        if (
               (gengc->gc.drawBuffer->redShift   != 16)
            || (gengc->gc.drawBuffer->greenShift != 8)
            || (gengc->gc.drawBuffer->blueShift  != 0)
           ) {
            fUseFastGenSpan = TRUE;
        }
    }

    if (modeFlags & __GL_SHADE_DITHER) {
        if (   (bpp == 8)
            || (bpp == 16)
            || ((modeFlags & __GL_SHADE_DEPTH_ITER) == 0)
           ) {
            GENACCEL(gc).flags |= GEN_DITHER;
        }
        iType += 5;
    }

    // Use the accelerated span functions (with no inline z-buffering) if
    // we support the z-buffer function AND we're not using hardware
    // z-buffering:

    if (modeFlags & __GL_SHADE_DEPTH_ITER) {
        if (bMcdZ) {
            fUseFastGenSpan = TRUE;
        } else if (!fZippy) {
            fUseFastGenSpan = TRUE;
        } else if (gc->state.depth.testFunc == GL_LESS) {
            GENACCEL(gc).flags |= GEN_LESS;
        } else if (gc->state.depth.testFunc != GL_LEQUAL) {
            fUseFastGenSpan = TRUE;
        }
        iType += 10;
    }

    if (modeFlags & __GL_SHADE_RGB) {
        GENACCEL(gc).flags |= GEN_RGBMODE;
        pfnZippySub = __ZippyFSTRGB;

        if (modeFlags & __GL_SHADE_TEXTURE) {
            GENACCEL(gc).flags |= (GEN_TEXTURE | GEN_TEXTURE_ORTHO);

            if (gc->state.hints.perspectiveCorrection == GL_NICEST)
                return FALSE;

            if (internalFormat == GL_COLOR_INDEX8_EXT ||
                internalFormat == GL_COLOR_INDEX16_EXT)
                return FALSE;

            if (textureMode == GL_DECAL) {
                if (modeFlags & __GL_SHADE_DITHER)
                    GENACCEL(gc).__fastTexSpanFuncPtr =
                        __fastGenTexFuncs[iType];
                else
                    GENACCEL(gc).__fastTexSpanFuncPtr =
                        __fastGenTexDecalFuncs[iType];

                pfnZippySub = __ZippyFSTTex;
            } else {
                GENACCEL(gc).flags |= GEN_SHADE;
                pfnZippySub = __ZippyFSTRGBTex;
                GENACCEL(gc).__fastTexSpanFuncPtr =
                    __fastGenTexFuncs[iType];
            }

            if (GENACCEL(gc).__fastTexSpanFuncPtr == __fastGenSpan) {
                fUseFastGenSpan = TRUE;
            }
        } else {
            GENACCEL(gc).__fastSmoothSpanFuncPtr = __fastGenRGBFuncs[iType];
            GENACCEL(gc).__fastFlatSpanFuncPtr   = __fastGenRGBFlatFuncs[iType];

            if (GENACCEL(gc).__fastSmoothSpanFuncPtr == __fastGenSpan) {
                fUseFastGenSpan = TRUE;
            }
        }
    } else {
        pfnZippySub = __ZippyFSTCI;
        GENACCEL(gc).__fastSmoothSpanFuncPtr = __fastGenCIFuncs[iType];
        GENACCEL(gc).__fastFlatSpanFuncPtr = __fastGenCIFlatFuncs[iType];
    }

    if (modeFlags & __GL_SHADE_STIPPLE)
    {
        fUseFastGenSpan = TRUE;
    }
    
    if (fUseFastGenSpan) {
        GENACCEL(gc).__fastTexSpanFuncPtr          = __fastGenSpan;
        GENACCEL(gc).__fastSmoothSpanFuncPtr       = __fastGenSpan;
        GENACCEL(gc).__fastFlatSpanFuncPtr         = __fastGenSpan;
        GENACCEL(gc).__fastFillSubTrianglePtr      = __fastGenFillSubTriangle;
    } else {
        if (fZippy) {
            GENACCEL(gc).flags |= SURFACE_TYPE_DIB;

            if (   (iType == 2)
                && (
                    (modeFlags
                     & (__GL_SHADE_RGB | __GL_SHADE_SMOOTH)
                    ) == 0
                   )
               ) {
                GENACCEL(gc).__fastFillSubTrianglePtr = __ZippyFSTCI8Flat;
            } else if (iType >= 10) {
                GENACCEL(gc).__fastFillSubTrianglePtr = __ZippyFSTZ;
                GENACCEL(gc).flags |= GEN_FASTZBUFFER;
            } else {
                GENACCEL(gc).flags &= ~(HAVE_STIPPLE);
                GENACCEL(gc).__fastFillSubTrianglePtr = pfnZippySub;
            }
        } else {
            GENACCEL(gc).__fastFillSubTrianglePtr = __fastGenFillSubTriangle;
        }
    }

    return TRUE;
}

void FASTCALL __fastGenPickTriangleProcs(__GLcontext *gc)
{
    GLuint modeFlags = gc->polygon.shader.modeFlags;
    __GLGENcontext *genGc = (__GLGENcontext *)gc;

    CASTINT(gc->polygon.shader.rLittle) = 0;
    CASTINT(gc->polygon.shader.rBig) =    0;
    CASTINT(gc->polygon.shader.gLittle) = 0;
    CASTINT(gc->polygon.shader.gBig) =    0;
    CASTINT(gc->polygon.shader.bLittle) = 0;
    CASTINT(gc->polygon.shader.bBig) =    0;
    CASTINT(gc->polygon.shader.sLittle) = 0;
    CASTINT(gc->polygon.shader.sBig) =    0;
    CASTINT(gc->polygon.shader.tLittle) = 0;
    CASTINT(gc->polygon.shader.tBig) =    0;

    GENACCEL(gc).spanDelta.r = 0;
    GENACCEL(gc).spanDelta.g = 0;
    GENACCEL(gc).spanDelta.b = 0;
    GENACCEL(gc).spanDelta.a = 0;

    /*
    ** Setup cullFace so that a single test will do the cull check.
    */
    if (modeFlags & __GL_SHADE_CULL_FACE) {
        switch (gc->state.polygon.cull) {
          case GL_FRONT:
            gc->polygon.cullFace = __GL_CULL_FLAG_FRONT;
            break;
          case GL_BACK:
            gc->polygon.cullFace = __GL_CULL_FLAG_BACK;
            break;
          case GL_FRONT_AND_BACK:
            gc->procs.renderTriangle = __glDontRenderTriangle;
            gc->procs.fillTriangle = 0;         /* Done to find bugs */
            return;
        }
    } else {
        gc->polygon.cullFace = __GL_CULL_FLAG_DONT;
    }

    /* Build lookup table for face direction */
    switch (gc->state.polygon.frontFaceDirection) {
      case GL_CW:
        if (gc->constants.yInverted) {
            gc->polygon.face[__GL_CW] = __GL_BACKFACE;
            gc->polygon.face[__GL_CCW] = __GL_FRONTFACE;
        } else {
            gc->polygon.face[__GL_CW] = __GL_FRONTFACE;
            gc->polygon.face[__GL_CCW] = __GL_BACKFACE;
        }
        break;
      case GL_CCW:
        if (gc->constants.yInverted) {
            gc->polygon.face[__GL_CW] = __GL_FRONTFACE;
            gc->polygon.face[__GL_CCW] = __GL_BACKFACE;
        } else {
            gc->polygon.face[__GL_CW] = __GL_BACKFACE;
            gc->polygon.face[__GL_CCW] = __GL_FRONTFACE;
        }
        break;
    }

    /* Make polygon mode indexable and zero based */
    gc->polygon.mode[__GL_FRONTFACE] =
        (GLubyte) (gc->state.polygon.frontMode & 0xf);
    gc->polygon.mode[__GL_BACKFACE] =
        (GLubyte) (gc->state.polygon.backMode & 0xf);

    if (gc->renderMode == GL_FEEDBACK) {
        gc->procs.renderTriangle = __glFeedbackTriangle;
        gc->procs.fillTriangle = 0;             /* Done to find bugs */
        return;
    }
    if (gc->renderMode == GL_SELECT) {
        gc->procs.renderTriangle = __glSelectTriangle;
        gc->procs.fillTriangle = 0;             /* Done to find bugs */
        return;
    }

    if ((gc->state.polygon.frontMode == gc->state.polygon.backMode) &&
        (gc->state.polygon.frontMode == GL_FILL)) {
      if (modeFlags & __GL_SHADE_SMOOTH_LIGHT) {
          gc->procs.renderTriangle = __glRenderSmoothTriangle;
#ifdef GL_WIN_phong_shading
      } else if (modeFlags & __GL_SHADE_PHONG) {
          gc->procs.renderTriangle = __glRenderPhongTriangle;
#endif //GL_WIN_phong_shading
      } else {
          gc->procs.renderTriangle = __glRenderFlatTriangle;
      }
    } else {
        gc->procs.renderTriangle = __glRenderTriangle;
    }

    if (gc->state.enables.general & __GL_POLYGON_SMOOTH_ENABLE) {
#ifdef GL_WIN_phong_shading
        if (modeFlags & __GL_SHADE_PHONG)
            gc->procs.fillTriangle = __glFillAntiAliasedPhongTriangle;
        else
#endif //GL_WIN_phong_shading
            gc->procs.fillTriangle = __glFillAntiAliasedTriangle;
    } else {
        if ((gc->state.raster.drawBuffer == GL_NONE) ||
            !bUseGenTriangles(gc))
#ifdef GL_WIN_phong_shading
            if (modeFlags & __GL_SHADE_PHONG)
                gc->procs.fillTriangle = __glFillPhongTriangle;
            else
#endif //GL_WIN_phong_shading
                gc->procs.fillTriangle = __glFillTriangle;
    }

    if ((modeFlags & __GL_SHADE_CHEAP_FOG) && 
        !(modeFlags & __GL_SHADE_SMOOTH_LIGHT)) {
        gc->procs.fillTriangle2 = gc->procs.fillTriangle;
        gc->procs.fillTriangle = __glFillFlatFogTriangle;
    }
#ifdef GL_WIN_specular_fog
    /*
    ** The case where 1) Specular fog is enabled AND 2) flat-shaded
    */
    if ((modeFlags & (__GL_SHADE_SPEC_FOG | 
                      __GL_SHADE_SMOOTH_LIGHT |
                      __GL_SHADE_PHONG)) == __GL_SHADE_SPEC_FOG)
    {
        gc->procs.fillTriangle2 = gc->procs.fillTriangle;
        gc->procs.fillTriangle = __glFillFlatSpecFogTriangle;
    }
#endif //GL_WIN_specular_fog
}


void FASTCALL __fastGenPickSpanProcs(__GLcontext *gc)
{
    __GLGENcontext *genGc = (__GLGENcontext *)gc;
    GLuint enables = gc->state.enables.general;
    GLuint modeFlags = gc->polygon.shader.modeFlags;
    __GLcolorBuffer *cfb = gc->drawBuffer;
    __GLspanFunc *sp;
    __GLstippledSpanFunc *ssp;
    int spanCount;
    GLboolean replicateSpan;
    GLboolean bMcdZ = ((((__GLGENcontext *)gc)->pMcdState != NULL) &&
                       (((__GLGENcontext *)gc)->pMcdState->pDepthSpan != NULL) &&
                       (((__GLGENcontext *)gc)->pMcdState->pMcdSurf != NULL) &&
                       !(((__GLGENcontext *)gc)->pMcdState->McdBuffers.mcdDepthBuf.bufFlags & MCDBUF_ENABLED));

    // Always reset the color scale values at the beginning of the pick
    // procs.  Lines, triangles, and spans may all use these values...

    GENACCEL(gc).rAccelScale = (GLfloat)ACCEL_FIX_SCALE;
    GENACCEL(gc).gAccelScale = (GLfloat)ACCEL_FIX_SCALE;
    GENACCEL(gc).bAccelScale = (GLfloat)ACCEL_FIX_SCALE;

    // Note:  we need to scale between 0 and 255 to get proper alpha
    // blending.  The software-accelerated blending code assumes this
    // scaling for simplicity...

    GENACCEL(gc).aAccelScale = (GLfloat)(ACCEL_FIX_SCALE) *
                               (GLfloat)255.0 / gc->drawBuffer->alphaScale;

    replicateSpan = GL_FALSE;
    sp = gc->procs.span.spanFuncs;
    ssp = gc->procs.span.stippledSpanFuncs;

    /* Load phase one procs */
    if (!gc->transform.reasonableViewport) {
        *sp++ = __glClipSpan;
        *ssp++ = NULL;
    }

    if (modeFlags & __GL_SHADE_STIPPLE) {
        *sp++ = __glStippleSpan;
        *ssp++ = __glStippleStippledSpan;

        if (modeFlags & __GL_SHADE_DEPTH_TEST)
        {
            if (bMcdZ)
            {
                GENACCEL(gc).__fastStippleDepthTestSpan =
                    GenMcdStippleAnyDepthTestSpan;
            }
            else
            {
                if (gc->state.depth.testFunc == GL_LESS)
                {
                    if (gc->modes.depthBits == 32)
                    {
                        GENACCEL(gc).__fastStippleDepthTestSpan =
                            __fastGenStippleLt32Span;
                    }
                    else
                    {
                        GENACCEL(gc).__fastStippleDepthTestSpan =
                            __fastGenStippleLt16Span;
                    }
                }
                else
                {
                    GENACCEL(gc).__fastStippleDepthTestSpan =
                        __fastGenStippleAnyDepthTestSpan;
                }
            }
        }
        else
        {
            GENACCEL(gc).__fastStippleDepthTestSpan = __glStippleSpan;
        }
    }

    /* Load phase three procs */
    if (modeFlags & __GL_SHADE_RGB) {
        if (modeFlags & __GL_SHADE_SMOOTH) {
            *sp = __glShadeRGBASpan;
            *ssp = __glShadeRGBASpan;
#ifdef GL_WIN_phong_shading
        } else if (modeFlags & __GL_SHADE_PHONG) {
            *sp = __glPhongRGBASpan;
            *ssp = __glPhongRGBASpan;
        
#endif //GL_WIN_phong_shading
        } else {
            *sp = __glFlatRGBASpan;
            *ssp = __glFlatRGBASpan;
        }
    } else {
        if (modeFlags & __GL_SHADE_SMOOTH) {
            *sp = __glShadeCISpan;
            *ssp = __glShadeCISpan;
#ifdef GL_WIN_phong_shading
        } else if (modeFlags & __GL_SHADE_PHONG) {
            *sp = __glPhongCISpan;
            *ssp = __glPhongCISpan;
#endif //GL_WIN_phong_shading
        } else {
            *sp = __glFlatCISpan;
            *ssp = __glFlatCISpan;
        }
    }
    sp++;
    ssp++;

    if (modeFlags & __GL_SHADE_TEXTURE) {
        *sp++ = __glTextureSpan;
        *ssp++ = __glTextureStippledSpan;
    }

#ifdef GL_WIN_specular_fog
    if (modeFlags & (__GL_SHADE_SLOW_FOG | __GL_SHADE_SPEC_FOG))
#else //GL_WIN_specular_fog
    if (modeFlags & __GL_SHADE_SLOW_FOG)
#endif //GL_WIN_specular_fog
    {
        if (DO_NICEST_FOG (gc)) {
            *sp = __glFogSpanSlow;
            *ssp = __glFogStippledSpanSlow;
        } else {
            *sp = __glFogSpan;
            *ssp = __glFogStippledSpan;
        }
        sp++;
        ssp++;
    }

    if (modeFlags & __GL_SHADE_ALPHA_TEST) {
        *sp++ = __glAlphaTestSpan;
        *ssp++ = __glAlphaTestStippledSpan;
    }

    /* Load phase two procs */
    if (modeFlags & __GL_SHADE_STENCIL_TEST) {
        *sp++ = __glStencilTestSpan;
        *ssp++ = __glStencilTestStippledSpan;
        if (modeFlags & __GL_SHADE_DEPTH_TEST) {
            if (bMcdZ) {
                *sp = GenMcdDepthTestStencilSpan;
                *ssp = GenMcdDepthTestStencilStippledSpan;
            } else {
                *sp = __glDepthTestStencilSpan;
                *ssp = __glDepthTestStencilStippledSpan;
            }
        } else {
            *sp = __glDepthPassSpan;
            *ssp = __glDepthPassStippledSpan;
        }
        sp++;
        ssp++;
    } else {
        if (modeFlags & __GL_SHADE_DEPTH_TEST) {
            if (bMcdZ) {
                *sp++  =  GenMcdDepthTestSpan;
                *ssp++ = GenMcdDepthTestStippledSpan;
                if (gc->state.depth.writeEnable)
                    ((__GLGENcontext *)gc)->pMcdState->softZSpanFuncPtr =
                        __fastDepthFuncs[gc->state.depth.testFunc & 0x7];
                else
                    ((__GLGENcontext *)gc)->pMcdState->softZSpanFuncPtr =
                        (__GLspanFunc)NULL;

                GENACCEL(gc).__fastZSpanFuncPtr = GenMcdDepthTestSpan;
            } else {
                if (gc->state.depth.writeEnable) {
                    if( gc->modes.depthBits == 32 ) {
                        *sp++ = GENACCEL(gc).__fastZSpanFuncPtr =
                            __fastDepthFuncs[gc->state.depth.testFunc & 0x7];
                    } else {
                        *sp++ = GENACCEL(gc).__fastZSpanFuncPtr =
                            __fastDepth16Funcs[gc->state.depth.testFunc & 0x7];
                    }
                } else {
                    *sp++ = GENACCEL(gc).__fastZSpanFuncPtr =
                        __glDepthTestSpan;
                }

                *ssp++ = __glDepthTestStippledSpan;
            }
        }
    }

    if (gc->state.raster.drawBuffer == GL_FRONT_AND_BACK) {
        spanCount = (int)((ULONG_PTR)(sp - gc->procs.span.spanFuncs));
        gc->procs.span.n = spanCount;
        replicateSpan = GL_TRUE;
    }

    /* Span routines deal with masking, dithering, logicop, blending */
    *sp++ = cfb->storeSpan;
    *ssp++ = cfb->storeStippledSpan;

    spanCount = (int)((ULONG_PTR)(sp - gc->procs.span.spanFuncs));
    gc->procs.span.m = spanCount;
    if (replicateSpan) {
        gc->procs.span.processSpan = __glProcessReplicateSpan;
    } else {
        gc->procs.span.processSpan = __glProcessSpan;
        gc->procs.span.n = spanCount;
    }
}

// These are the bits in modeFlags that affect lines

#ifdef GL_WIN_specular_fog
#define __FAST_LINE_SPEC_FOG __GL_SHADE_SPEC_FOG
#else
#define __FAST_LINE_SPEC_FOG 0
#endif //GL_WIN_specular_fog

#ifdef GL_WIN_phong_shading
#define __FAST_LINE_PHONG __GL_SHADE_PHONG
#else
#define __FAST_LINE_PHONG 0
#endif //GL_WIN_phong_shading

#define __FAST_LINE_MODE_FLAGS \
    (__GL_SHADE_DEPTH_TEST | __GL_SHADE_SMOOTH | __GL_SHADE_TEXTURE | \
     __GL_SHADE_LINE_STIPPLE | __GL_SHADE_STENCIL_TEST | __GL_SHADE_LOGICOP | \
     __GL_SHADE_BLEND | __GL_SHADE_ALPHA_TEST | __GL_SHADE_MASK | \
     __GL_SHADE_SLOW_FOG | __GL_SHADE_CHEAP_FOG | __FAST_LINE_SPEC_FOG | \
     __FAST_LINE_PHONG)

/******************************Public*Routine******************************\
* __fastGenPickLineProcs
*
* Picks the line-rendering procedures.  Most of this function was copied from
* the soft code.  Some differences include:
*   1. The beginPrim function pointers are hooked by the accelerated code
*   2. If the attribute state is such that acceleration can be used,
*      __fastGenLineSetup is called to initialize the state machine.
*
* History:
*  22-Mar-1994 -by- Eddie Robinson [v-eddier]
* Wrote it.
\**************************************************************************/


void FASTCALL __fastGenPickLineProcs(__GLcontext *gc)
{
    __GLGENcontext *genGc = (__GLGENcontext *) gc;
    GENACCEL *genAccel;
    GLuint enables = gc->state.enables.general;
    GLuint modeFlags = gc->polygon.shader.modeFlags;
    __GLspanFunc *sp;
    __GLstippledSpanFunc *ssp;
    int spanCount;
    GLboolean wideLine;
    GLboolean replicateLine;
    GLuint aaline;
    GLboolean bMcdZ = ((genGc->pMcdState != NULL) &&
                       (genGc->pMcdState->pDepthSpan != NULL) &&
                       (genGc->pMcdState->pMcdSurf != NULL) &&
                       !(genGc->pMcdState->McdBuffers.mcdDepthBuf.bufFlags & MCDBUF_ENABLED));

    /*
    ** The fast line code replaces the line function pointers, so reset them
    ** to a good state
    */
    gc->procs.lineBegin  = __glNopLineBegin;
    gc->procs.lineEnd    = __glNopLineEnd;

    if (gc->renderMode == GL_FEEDBACK) {
        gc->procs.renderLine = __glFeedbackLine;
    } else if (gc->renderMode == GL_SELECT) {
        gc->procs.renderLine = __glSelectLine;
    } else {
        if (genAccel = (GENACCEL *) genGc->pPrivateArea) {
            if (!(modeFlags & __FAST_LINE_MODE_FLAGS & ~genAccel->flLineAccelModes) &&
                !(gc->state.enables.general & __GL_LINE_SMOOTH_ENABLE) &&
                !(gc->state.enables.general & __GL_SCISSOR_TEST_ENABLE) &&
                !(gc->state.raster.drawBuffer == GL_NONE) &&
                !gc->buffers.doubleStore &&
                !genGc->pMcdState &&
                (genGc->dwCurrentFlags & (GLSURF_HDC | GLSURF_METAFILE)) ==
                GLSURF_HDC)
            {
                __fastLineComputeOffsets(genGc);

#if NT_NO_BUFFER_INVARIANCE
                if (!(gc->drawBuffer->buf.flags & DIB_FORMAT)) {
                    if (genAccel->bFastLineDispAccel) {
                        if (__fastGenLineSetupDisplay(gc))
                            return;
                    }
                } else {
                    if (genAccel->bFastLineDIBAccel) {
                        if (__fastGenLineSetupDIB(gc))
                            return;
                    }
                }
#else
                if (genAccel->bFastLineDispAccel) {
                    if (__fastGenLineSetupDisplay(gc))
                        return;
                }
#endif
            }
        }

        if (__glGenSetupEitherLines(gc))
        {
            return;
        }

        replicateLine = wideLine = GL_FALSE;

        aaline = gc->state.enables.general & __GL_LINE_SMOOTH_ENABLE;
        if (aaline)
        {
            gc->procs.renderLine = __glRenderAntiAliasLine;
        }
        else
        {
            gc->procs.renderLine = __glRenderAliasLine;
        }
        
        sp = gc->procs.line.lineFuncs;
        ssp = gc->procs.line.stippledLineFuncs;

        if (!aaline && (modeFlags & __GL_SHADE_LINE_STIPPLE)) {
            *sp++ = __glStippleLine;
            *ssp++ = NULL;
        }

        if (!aaline && gc->state.line.aliasedWidth > 1) {
            wideLine = GL_TRUE;
        }
        spanCount = (int)((ULONG_PTR)(sp - gc->procs.line.lineFuncs));
        gc->procs.line.n = spanCount;

        *sp++ = __glScissorLine;
        *ssp++ = __glScissorStippledLine;

        if (!aaline) {
            if (modeFlags & __GL_SHADE_STENCIL_TEST) {
                *sp++ = __glStencilTestLine;
                *ssp++ = __glStencilTestStippledLine;
                if (modeFlags & __GL_SHADE_DEPTH_TEST) {
                    if (bMcdZ) {
                        *sp = GenMcdDepthTestStencilLine;
                        *ssp = GenMcdDepthTestStencilStippledLine;
                    } else if( gc->modes.depthBits == 32 ) {
                        *sp = __glDepthTestStencilLine;
                        *ssp = __glDepthTestStencilStippledLine;
                    }
                    else {
                        *sp = __glDepth16TestStencilLine;
                        *ssp = __glDepth16TestStencilStippledLine;
                    }
                } else {
                    *sp = __glDepthPassLine;
                    *ssp = __glDepthPassStippledLine;
                }
                sp++;
                ssp++;
            } else {
                if (modeFlags & __GL_SHADE_DEPTH_TEST) {
                    if (gc->state.depth.testFunc == GL_NEVER) {
                        /* Unexpected end of line routine picking! */
                        spanCount = (int)((ULONG_PTR)(sp - gc->procs.line.lineFuncs));
                        gc->procs.line.m = spanCount;
                        gc->procs.line.l = spanCount;
                        goto pickLineProcessor;
#ifdef __GL_USEASMCODE
                    } else {
                        unsigned long ix;

                        if (gc->state.depth.writeEnable) {
                            ix = 0;
                        } else {
                            ix = 8;
                        }
                        ix += gc->state.depth.testFunc & 0x7;

                        if (ix == (GL_LEQUAL & 0x7)) {
                            *sp++ = __glDepthTestLine_LEQ_asm;
                        } else {
                            *sp++ = __glDepthTestLine_asm;
                            gc->procs.line.depthTestPixel = LDepthTestPixel[ix];
                        }
#else
                    } else {
                        if (bMcdZ) {
                            *sp++ = GenMcdDepthTestLine;
                        } else {
                            if( gc->modes.depthBits == 32 )
                                *sp++ = __glDepthTestLine;
                            else
                                *sp++ = __glDepth16TestLine;
                        }
#endif
                    }
                    if (bMcdZ) {
                        *ssp++ = GenMcdDepthTestStippledLine;
                    } else {
                        if( gc->modes.depthBits == 32 )
                            *ssp++ = __glDepthTestStippledLine;
                        else
                            *ssp++ = __glDepth16TestStippledLine;
                    }
                }
            }
        }

        /* Load phase three procs */
        if (modeFlags & __GL_SHADE_RGB) {
            if (modeFlags & __GL_SHADE_SMOOTH) {
                *sp = __glShadeRGBASpan;
                *ssp = __glShadeRGBASpan;
#ifdef GL_WIN_phong_shading
            } else if (modeFlags & __GL_SHADE_PHONG) {
                *sp = __glPhongRGBASpan;
                *ssp = __glPhongRGBASpan;
#endif //GL_WIN_phong_shading
            } else {
                *sp = __glFlatRGBASpan;
                *ssp = __glFlatRGBASpan;
            }
        } else {
            if (modeFlags & __GL_SHADE_SMOOTH) {
                *sp = __glShadeCISpan;
                *ssp = __glShadeCISpan;
#ifdef GL_WIN_phong_shading
            } else if (modeFlags & __GL_SHADE_PHONG) {
                *sp = __glPhongCISpan;
                *ssp = __glPhongCISpan;
#endif //GL_WIN_phong_shading
            } else {
                *sp = __glFlatCISpan;
                *ssp = __glFlatCISpan;
            }
        }
        sp++;
        ssp++;
        if (modeFlags & __GL_SHADE_TEXTURE) {
            *sp++ = __glTextureSpan;
            *ssp++ = __glTextureStippledSpan;
        }
#ifdef GL_WIN_specular_fog
        if (modeFlags & (__GL_SHADE_SLOW_FOG | __GL_SHADE_SPEC_FOG))
#else //GL_WIN_specular_fog
        if (modeFlags & __GL_SHADE_SLOW_FOG)
#endif //GL_WIN_specular_fog
        {
            if (DO_NICEST_FOG (gc)) {
                *sp = __glFogSpanSlow;
                *ssp = __glFogStippledSpanSlow;
            } else {
                *sp = __glFogSpan;
                *ssp = __glFogStippledSpan;
            }
            sp++;
            ssp++;
        }

        if (aaline) {
            *sp++ = __glAntiAliasLine;
            *ssp++ = __glAntiAliasStippledLine;
        }

        if (aaline) {
            if (modeFlags & __GL_SHADE_STENCIL_TEST) {
                *sp++ = __glStencilTestLine;
                *ssp++ = __glStencilTestStippledLine;
                if (modeFlags & __GL_SHADE_DEPTH_TEST) {
                    if (bMcdZ) {
                        *sp = GenMcdDepthTestStencilLine;
                        *ssp = GenMcdDepthTestStencilStippledLine;
                    } else if( gc->modes.depthBits == 32 ) {
                        *sp = __glDepthTestStencilLine;
                        *ssp = __glDepthTestStencilStippledLine;
                    }
                    else {
                        *sp = __glDepth16TestStencilLine;
                        *ssp = __glDepth16TestStencilStippledLine;
                    }
                } else {
                    *sp = __glDepthPassLine;
                    *ssp = __glDepthPassStippledLine;
                }
                sp++;
                ssp++;
            } else {
                if (modeFlags & __GL_SHADE_DEPTH_TEST) {
                    if (gc->state.depth.testFunc == GL_NEVER) {
                        /* Unexpected end of line routine picking! */
                        spanCount = (int)((ULONG_PTR)(sp - gc->procs.line.lineFuncs));
                        gc->procs.line.m = spanCount;
                        gc->procs.line.l = spanCount;
                        goto pickLineProcessor;
#ifdef __GL_USEASMCODE
                    } else {
                        unsigned long ix;

                        if (gc->state.depth.writeEnable) {
                            ix = 0;
                        } else {
                            ix = 8;
                        }
                        ix += gc->state.depth.testFunc & 0x7;
                        *sp++ = __glDepthTestLine_asm;
                        gc->procs.line.depthTestPixel = LDepthTestPixel[ix];
#else
                    } else {
                        if (bMcdZ)
                            *sp++ = GenMcdDepthTestLine;
                        else if( gc->modes.depthBits == 32 )
                            *sp++ = __glDepthTestLine;
                        else
                            *sp++ = __glDepth16TestLine;
#endif
                    }
                    if (bMcdZ)
                        *ssp++ = GenMcdDepthTestStippledLine;
                    else if (gc->modes.depthBits == 32)
                        *ssp++ = __glDepthTestStippledLine;
                    else
                        *ssp++ = __glDepth16TestStippledLine;
                }
            }
        }

        if (modeFlags & __GL_SHADE_ALPHA_TEST) {
            *sp++ = __glAlphaTestSpan;
            *ssp++ = __glAlphaTestStippledSpan;
        }

        if (gc->buffers.doubleStore) {
            replicateLine = GL_TRUE;
        }
        spanCount = (int)((ULONG_PTR)(sp - gc->procs.line.lineFuncs));
        gc->procs.line.m = spanCount;

        *sp++ = __glStoreLine;
        *ssp++ = __glStoreStippledLine;

        spanCount = (int)((ULONG_PTR)(sp - gc->procs.line.lineFuncs));
        gc->procs.line.l = spanCount;

        sp = &gc->procs.line.wideLineRep;
        ssp = &gc->procs.line.wideStippledLineRep;
        if (wideLine) {
            *sp = __glWideLineRep;
            *ssp = __glWideStippleLineRep;
            sp = &gc->procs.line.drawLine;
            ssp = &gc->procs.line.drawStippledLine;
        }
        if (replicateLine) {
            *sp = __glDrawBothLine;
            *ssp = __glDrawBothStippledLine;
        } else {
            *sp = __glNopGCBOOL;
            *ssp = __glNopGCBOOL;
            gc->procs.line.m = gc->procs.line.l;
        }
        if (!wideLine) {
            gc->procs.line.n = gc->procs.line.m;
        }

pickLineProcessor:
        if (!wideLine && !replicateLine && spanCount == 3) {
            gc->procs.line.processLine = __glProcessLine3NW;
        } else {
            gc->procs.line.processLine = __glProcessLine;
        }
        if ((modeFlags & __GL_SHADE_CHEAP_FOG) &&
                !(modeFlags & __GL_SHADE_SMOOTH_LIGHT)) {
            gc->procs.renderLine2 = gc->procs.renderLine;
            gc->procs.renderLine = __glRenderFlatFogLine;
        }
    }
}

BOOL FASTCALL __glGenCreateAccelContext(__GLcontext *gc)
{
    __GLGENcontext *genGc = (__GLGENcontext *)gc;
    PIXELFORMATDESCRIPTOR *pfmt;
    ULONG bpp;

    pfmt = &genGc->gsurf.pfd;
    bpp = pfmt->cColorBits;

    genGc->pPrivateArea = (VOID *)(&genGc->genAccel);

    __glQueryLineAcceleration(gc);

    gc->procs.pickTriangleProcs = __fastGenPickTriangleProcs;
    gc->procs.pickSpanProcs     = __fastGenPickSpanProcs;

    // Set up constant-color values:

    GENACCEL(gc).constantR = ((1 << pfmt->cRedBits) - 1) << 16;
    GENACCEL(gc).constantG = ((1 << pfmt->cGreenBits) - 1) << 16;
    GENACCEL(gc).constantB = ((1 << pfmt->cBlueBits) - 1) << 16;
    if( pfmt->cAlphaBits )
        GENACCEL(gc).constantA = ((1 << pfmt->cAlphaBits) - 1) << 16;
    else
        GENACCEL(gc).constantA = 0xff << 16;

    GENACCEL(gc).bpp = bpp;
    GENACCEL(gc).xMultiplier = ((bpp + 7) / 8);

    if (gc->modes.depthBits == 16 )
        GENACCEL(gc).zScale = (__GLfloat)65536.0;
    else
        GENACCEL(gc).zScale = (__GLfloat)1.0;

    return TRUE;
}


MCDHANDLE FASTCALL __glGenLoadTexture(__GLcontext *gc, __GLtexture *tex,
                                      ULONG flags)
{
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    MCDHANDLE texHandle;
    DWORD texKey;

#ifdef _MCD_
    if (gengc->pMcdState) {
        texHandle = GenMcdCreateTexture(gengc, tex, flags);
        if (texHandle) {
            tex->textureKey = GenMcdTextureKey(gengc, texHandle);
            gc->textureKey = tex->textureKey;
        }
        return texHandle;
    } else
#endif
        return 0;
}


BOOL FASTCALL __glGenMakeTextureCurrent(__GLcontext *gc, __GLtexture *tex, MCDHANDLE loadKey)
{
    GLint internalFormat;

    if (!tex)
        return FALSE;

    InitAccelTextureValues(gc, tex);

    // Update the driver texture key in the context:

    if (((__GLGENcontext *)gc)->pMcdState && (gc->textureKey = tex->textureKey)) {
        GenMcdUpdateTextureState((__GLGENcontext *)gc, tex, loadKey);
    }

    // Previously we called bUseGenTriangles here to determine whether we were
    // doing 'fast' texturing, and if so, setup the texture cache pointers
    // below.  But this slowed down texture bind time, so for now we always
    // execute this next section of code (safe, since we check for valid ptrs).

    if (tex->level[0].internalFormat == GL_COLOR_INDEX8_EXT)
    {
        if (tex->pvUser)
            GENACCEL(gc).texImageReplace =
                ((GENTEXCACHE *)tex->pvUser)->texImageReplace;
    }
    else if (tex->level[0].internalFormat != GL_COLOR_INDEX16_EXT)
    {
        if (tex->pvUser)
            GENACCEL(gc).texImageReplace =
                ((GENTEXCACHE *)tex->pvUser)->texImageReplace;

        GENACCEL(gc).texPalette = NULL;
    }

    return TRUE;
}


BOOL FASTCALL __glGenUpdateTexture(__GLcontext *gc, __GLtexture *tex, MCDHANDLE loadKey)
{

//!! NOTE !!
//!! This should really be broken into separate load and update calls since
//!! loading and updating are different operations.  The texture texture
//!! data cache will never shrink with the current implementation.

    // Do not quit if the load fails because we want the repick to occur
    // in MakeTextureCurrent in both the success and failure cases
    __fastGenLoadTexImage(gc, tex);

    __glGenMakeTextureCurrent(gc, tex, loadKey);

    return TRUE;
}


void FASTCALL __glGenFreeTexture(__GLcontext *gc, __GLtexture *tex, MCDHANDLE loadKey)
{
    __GLGENcontext  *gengc = (__GLGENcontext *)gc;

    if (GENACCEL(gc).texImage)
        GENACCEL(gc).texImage = NULL;

    if (tex->pvUser) {
        GCFREE(gc, tex->pvUser);
        tex->pvUser = NULL;
    }

#ifdef _MCD_
    if (gengc->pMcdState && loadKey) {
        GenMcdDeleteTexture(gengc, loadKey);
    }
#endif
}

void FASTCALL __glGenUpdateTexturePalette(__GLcontext *gc, __GLtexture *tex,
                                          MCDHANDLE loadKey, ULONG start,
                                          ULONG count)
{
    UCHAR *texBuffer;
    GENTEXCACHE *pGenTex;
    __GLcolorBuffer *cfb = gc->drawBuffer;
    BYTE *pXlat = ((__GLGENcontext *)gc)->pajTranslateVector;
    ULONG rBits, gBits, bBits;
    ULONG rShift, gShift, bShift;
    ULONG i, end;
    ULONG *replaceBuffer;

    ASSERTOPENGL(tex->paletteTotalData != NULL,
                 "__GenUpdateTexturePalette: null texture data\n");

#ifdef _MCD_
    if (((__GLGENcontext *)gc)->pMcdState && loadKey) {
        GenMcdUpdateTexturePalette((__GLGENcontext *)gc, tex, loadKey, start, 
                                   count);
    }
#endif

    pGenTex = GetGenTexCache(gc, tex);
    if (!pGenTex)
        return;

    GENACCEL(gc).texImageReplace = pGenTex->texImageReplace;

    replaceBuffer = (ULONG *)(pGenTex->texImageReplace) + start;
    texBuffer = (UCHAR *)(tex->paletteTotalData + start);

    rShift = cfb->redShift;
    gShift = cfb->greenShift;
    bShift = cfb->blueShift;
    rBits = ((__GLGENcontext *)gc)->gsurf.pfd.cRedBits;
    gBits = ((__GLGENcontext *)gc)->gsurf.pfd.cGreenBits;
    bBits = ((__GLGENcontext *)gc)->gsurf.pfd.cBlueBits;

    end = start + count;

    for (i = start; i < end; i++, texBuffer += 4) {
        ULONG color;

        color = ((((ULONG)texBuffer[2] << rBits) >> 8) << rShift) |
                ((((ULONG)texBuffer[1] << gBits) >> 8) << gShift) |
                ((((ULONG)texBuffer[0] << bBits) >> 8) << bShift);

        if (GENACCEL(gc).bpp == 8)
            color = pXlat[color & 0xff];

        *replaceBuffer++ = (color | ((ULONG)texBuffer[3] << 24));
    }
}

#ifdef GL_EXT_flat_paletted_lighting
void FASTCALL __glGenSetPaletteOffset(__GLcontext *gc, __GLtexture *tex,
                                      GLint offset)
{
    GENTEXCACHE *pGenTex;

    if (GENACCEL(gc).texPalette == NULL)
    {
        return;
    }
    
    GENACCEL(gc).texPalette = (ULONG *)tex->paletteTotalData+offset;
    
    pGenTex = GetGenTexCache(gc, tex);
    if (pGenTex == NULL)
    {
        return;
    }

    // Replace map for paletted textures is a replace map of the
    // entire palette, so offset it
    if (GENACCEL(gc).texImageReplace != NULL)
    {
        GENACCEL(gc).texImageReplace = (UCHAR *)
            ((ULONG *)pGenTex->texImageReplace+offset);
    }
    
    // Consider - Call MCD
}
#endif

void FASTCALL __glGenDestroyAccelContext(__GLcontext *gc)
{
    __GLGENcontext *genGc = (__GLGENcontext *)gc;

    /* Free any platform-specific private data area */

    if (genGc->pPrivateArea) {

        if (GENACCEL(gc).pFastLineBuffer) {
            GCFREE(gc, GENACCEL(gc).pFastLineBuffer);
#ifndef _CLIENTSIDE_
            wglDeletePath(GENACCEL(gc).pFastLinePathobj);
#endif
        }

        genGc->pPrivateArea = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\genaline.c ===
/******************************Module*Header*******************************\
* Module Name: genaline.c                                                  *
*                                                                          *
* This module provides accelerated interpolated line support.              *
*                                                                          *
* Created: 8-Dec-1995                                                      *
* Author: Otto Berkes [ottob]                                              *
*                                                                          *
* 23-Jan-1996   Drew Bliss      [drewb]                                    *
*  Cut down antialiasing code to provide aliased versions                  *
*  Optimized line setup                                                    *
*                                                                          *
* Copyright (c) 1995-1996 Microsoft Corporation                            *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

// #define DO_CHECK_PIXELS

#ifdef _X86_
#include <gli386.h>
#endif

#include "genline.h"

#ifndef NO_COMPILER_BUG
#undef __GL_FLOAT_SIMPLE_BEGIN_DIVIDE
#undef __GL_FLOAT_SIMPLE_END_DIVIDE
#define __GL_FLOAT_SIMPLE_BEGIN_DIVIDE(a, b, c) \
    __GL_FLOAT_BEGIN_DIVIDE(a, b, &(c))
#define __GL_FLOAT_SIMPLE_END_DIVIDE(r) \
    __GL_FLOAT_END_DIVIDE(&(r))
#endif

// Also used by soft line code
BOOL FASTCALL __glInitLineData(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint start, end;
    __GLfloat x0,y0,x1,y1;
    __GLfloat minorStart;
    __GLfloat fdx, fdy;
    __GLfloat offset;
    __GLfloat slope;
    __GLlineState *ls = &gc->state.line;
    __GLfloat halfWidth;
    GLint x0frac, x1frac, y0frac, y1frac, totDist;
    GLint ix0, ix1, iy0, iy1, idx, idy;
    __GLcolorBuffer *cfb = gc->drawBuffer;

    ASSERT_CHOP_ROUND();
    
    gc->line.options.v0 = v0;
    gc->line.options.v1 = v1;
    gc->line.options.width = ls->aliasedWidth;

    x0 = v0->window.x;
    y0 = v0->window.y;
    x1 = v1->window.x;
    y1 = v1->window.y;

#ifdef DO_CHECK_PIXELS
    if (x0 < gc->transform.fminx || x0 >= gc->transform.fmaxx ||
        y0 < gc->transform.fminy || y0 >= gc->transform.fmaxy ||
        x1 < gc->transform.fminx || x1 >= gc->transform.fmaxx ||
        y1 < gc->transform.fminy || y1 >= gc->transform.fmaxy)
    {
        DbgPrint("Line coordinates out %.3lf,%.3lf - %.3lf,%.3lf%s\n",
                 x0, y0, x1, y1,
                 !gc->transform.reasonableViewport ? " (unreasonable)" : "");
    }
#endif
    
    fdx = x1-x0;
    fdy = y1-y0;

    halfWidth = (ls->aliasedWidth - 1) * __glHalf;

    ix0 = __GL_VERTEX_FLOAT_TO_INT(x0);
    x0frac = __GL_VERTEX_FLOAT_FRACTION(x0);
    iy0 = __GL_VERTEX_FLOAT_TO_INT(y0);
    y0frac = __GL_VERTEX_FLOAT_FRACTION(y0);
    ix1 = __GL_VERTEX_FLOAT_TO_INT(x1);
    x1frac = __GL_VERTEX_FLOAT_FRACTION(x1);
    iy1 = __GL_VERTEX_FLOAT_TO_INT(y1);
    y1frac = __GL_VERTEX_FLOAT_FRACTION(y1);

#if 0
    DbgPrint("Line %.3lf,%.3lf - %.3lf,%.3lf\n", x0, y0, x1, y1);
    DbgPrint("Line %d.%03d,%d.%03d - %d.%03d,%d.%03d\n",
             ix0, x0frac, iy0, y0frac, ix1, x1frac, iy1, y1frac);
#endif
    
    // An interesting property of window coordinates is that subtracting
    // two of them cancels the exponent so the result is the fixed-point
    // difference
    idx = CASTINT(x1)-CASTINT(x0);
    idy = CASTINT(y1)-CASTINT(y0);
    
    if (idx > 0) {
	if (idy > 0) {
	    if (idx > idy) {	/* dx > dy > 0 */
		gc->line.options.yBig = 1;
                gc->polygon.shader.sbufBig =
                    cfb->buf.outerWidth+GENACCEL(gc).xMultiplier;
                gc->polygon.shader.zbufBig = gc->depthBuffer.buf.outerWidth+1;

posxmajor:			/* dx > |dy| >= 0 */
		gc->line.options.yLittle = 0;
		gc->line.options.xBig = 1;
		gc->line.options.xLittle = 1;
                gc->polygon.shader.sbufLittle = GENACCEL(gc).xMultiplier;
                gc->polygon.shader.zbufLittle = 1;
                
		__GL_FLOAT_SIMPLE_BEGIN_DIVIDE(__glOne, fdx, slope);

		start = ix0;
		end = ix1;

		y0frac -= __GL_VERTEX_FRAC_HALF;
		if (y0frac < 0) y0frac = -y0frac;

		totDist = y0frac + x0frac - __GL_VERTEX_FRAC_ONE;
		if (totDist > 0) start++;

                y1frac -= __GL_VERTEX_FRAC_HALF;
                if (y1frac < 0) y1frac = -y1frac;

                totDist = y1frac + x1frac - __GL_VERTEX_FRAC_ONE;
                if (totDist > 0) end++;

		offset = start + __glHalf - x0;

		gc->line.options.length = fdx;
		gc->line.options.numPixels = end - start;

xmajorfinish:
		gc->line.options.axis = __GL_X_MAJOR;
		gc->line.options.xStart = start;
		gc->line.options.offset = offset;

		__GL_FLOAT_SIMPLE_END_DIVIDE(slope);
                gc->line.options.oneOverLength = slope;
                slope *= fdy;

		minorStart = y0 + offset*slope - halfWidth;
		gc->line.options.yStart = __GL_VERTEX_FLOAT_TO_INT(minorStart);
                if (gc->line.options.yStart < gc->transform.miny)
                {
                    gc->line.options.yStart = gc->transform.miny;
                    gc->line.options.fraction = 0;
                }
                else if (gc->line.options.yStart >= gc->transform.maxy)
                {
                    gc->line.options.yStart = gc->transform.maxy-1;
                    gc->line.options.fraction =
                        __GL_VERTEX_PROMOTE_FRACTION(
                                (1 << __GL_VERTEX_FRAC_BITS)-1);
                }
                else
                {
                    gc->line.options.fraction =
                        __GL_VERTEX_PROMOTED_FRACTION(minorStart);
                }
		gc->line.options.dfraction = FLT_FRACTION(slope);
	    } else {		/* dy >= dx > 0 */
		gc->line.options.xBig = 1;
                gc->polygon.shader.sbufBig =
                    cfb->buf.outerWidth+GENACCEL(gc).xMultiplier;
                gc->polygon.shader.zbufBig = gc->depthBuffer.buf.outerWidth+1;
                
posymajor:			/* dy >= |dx| >= 0, dy != 0 */
		gc->line.options.xLittle = 0;
		gc->line.options.yBig = 1;
		gc->line.options.yLittle = 1;
                gc->polygon.shader.sbufLittle = cfb->buf.outerWidth;
                gc->polygon.shader.zbufLittle = gc->depthBuffer.buf.outerWidth;
                
		__GL_FLOAT_SIMPLE_BEGIN_DIVIDE(__glOne, fdy, slope);
                    
		start = iy0;
		end = iy1;

		x0frac -= __GL_VERTEX_FRAC_HALF;
		if (x0frac < 0) x0frac = -x0frac;

		totDist = y0frac + x0frac - __GL_VERTEX_FRAC_ONE;
		if (totDist > 0) start++;

                x1frac -= __GL_VERTEX_FRAC_HALF;
                if (x1frac < 0) x1frac = -x1frac;

                totDist = y1frac + x1frac - __GL_VERTEX_FRAC_ONE;
                if (totDist > 0) end++;

		offset = start + __glHalf - y0;

		gc->line.options.length = fdy;
		gc->line.options.numPixels = end - start;

ymajorfinish:
		gc->line.options.axis = __GL_Y_MAJOR;
		gc->line.options.yStart = start;
		gc->line.options.offset = offset;

                __GL_FLOAT_SIMPLE_END_DIVIDE(slope);
                gc->line.options.oneOverLength = slope;
                slope *= fdx;
                
		minorStart = x0 + offset*slope - halfWidth;
		gc->line.options.xStart = __GL_VERTEX_FLOAT_TO_INT(minorStart);
                if (gc->line.options.xStart < gc->transform.minx)
                {
                    gc->line.options.xStart = gc->transform.minx;
                    gc->line.options.fraction = 0;
                }
                else if (gc->line.options.xStart >= gc->transform.maxx)
                {
                    gc->line.options.xStart = gc->transform.maxx-1;
                    gc->line.options.fraction =
                        __GL_VERTEX_PROMOTE_FRACTION(
                                (1 << __GL_VERTEX_FRAC_BITS)-1);
                }
                else
                {
                    gc->line.options.fraction =
                        __GL_VERTEX_PROMOTED_FRACTION(minorStart);
                }
		gc->line.options.dfraction = FLT_FRACTION(slope);
	    }
	} else {
	    if (idx > -idy) {	/* dx > -dy >= 0 */
		gc->line.options.yBig = -1;
                gc->polygon.shader.sbufBig =
                    GENACCEL(gc).xMultiplier-cfb->buf.outerWidth;
                gc->polygon.shader.zbufBig = 1-gc->depthBuffer.buf.outerWidth;
		goto posxmajor;
	    } else {		/* -dy >= dx >= 0, dy != 0 */
		gc->line.options.xBig = 1;
                gc->polygon.shader.sbufBig =
                    GENACCEL(gc).xMultiplier-cfb->buf.outerWidth;
                gc->polygon.shader.zbufBig = 1-gc->depthBuffer.buf.outerWidth;
negymajor:			/* -dy >= |dx| >= 0, dy != 0 */
		gc->line.options.xLittle = 0;
		gc->line.options.yBig = -1;
		gc->line.options.yLittle = -1;
                gc->polygon.shader.sbufLittle = -cfb->buf.outerWidth;
                gc->polygon.shader.zbufLittle = -gc->depthBuffer.buf.outerWidth;

                __GL_FLOAT_BEGIN_DIVIDE(__glOne, -fdy, &slope);

		start = iy0;
		end = iy1;

		x0frac -= __GL_VERTEX_FRAC_HALF;
		if (x0frac < 0) x0frac = -x0frac;

		totDist = x0frac - y0frac;
		if (totDist > 0) start--;

                x1frac -= __GL_VERTEX_FRAC_HALF;
                if (x1frac < 0) x1frac = -x1frac;

                totDist = x1frac - y1frac;
                if (totDist > 0) end--;

		offset = y0 - (start + __glHalf);

		gc->line.options.length = -fdy;
		gc->line.options.numPixels = start - end;
		goto ymajorfinish;
	    }
	}
    } else {
	if (idy > 0) {
	    if (-idx > idy) {	/* -dx > dy > 0 */
		gc->line.options.yBig = 1;
                gc->polygon.shader.sbufBig =
                    cfb->buf.outerWidth-GENACCEL(gc).xMultiplier;
                gc->polygon.shader.zbufBig = gc->depthBuffer.buf.outerWidth-1;
negxmajor:			/* -dx > |dy| >= 0 */
		gc->line.options.yLittle = 0;
		gc->line.options.xBig = -1;
		gc->line.options.xLittle = -1;
                gc->polygon.shader.sbufLittle = -GENACCEL(gc).xMultiplier;
                gc->polygon.shader.zbufLittle = -1;

                __GL_FLOAT_BEGIN_DIVIDE(__glOne, -fdx, &slope);

		start = ix0;
		end = ix1;

		y0frac -= __GL_VERTEX_FRAC_HALF;
		if (y0frac < 0) y0frac = -y0frac;

		totDist = y0frac - x0frac;
		if (totDist > 0) start--;

                y1frac -= __GL_VERTEX_FRAC_HALF;
                if (y1frac < 0) y1frac = -y1frac;

                totDist = y1frac - x1frac;
                if (totDist > 0) end--;

		offset = x0 - (start + __glHalf);

		gc->line.options.length = -fdx;
		gc->line.options.numPixels = start - end;

		goto xmajorfinish;
	    } else {		/* dy >= -dx >= 0, dy != 0 */
		gc->line.options.xBig = -1;
                gc->polygon.shader.sbufBig =
                    cfb->buf.outerWidth-GENACCEL(gc).xMultiplier;
                gc->polygon.shader.zbufBig = gc->depthBuffer.buf.outerWidth-1;
		goto posymajor;
	    }
	} else {
	    if (idx < idy) {	/* -dx > -dy >= 0 */
		gc->line.options.yBig = -1;
                gc->polygon.shader.sbufBig =
                    -GENACCEL(gc).xMultiplier-cfb->buf.outerWidth;
                gc->polygon.shader.zbufBig = -1-gc->depthBuffer.buf.outerWidth;
		goto negxmajor;
	    } else {		/* -dy >= -dx >= 0 */
		if ((idx | idy) == 0) {
		    gc->line.options.numPixels = 0;
		    return FALSE;
		}
		gc->line.options.xBig = -1;
                gc->polygon.shader.sbufBig =
                    -GENACCEL(gc).xMultiplier-cfb->buf.outerWidth;
                gc->polygon.shader.zbufBig = -1-gc->depthBuffer.buf.outerWidth;
		goto negymajor;
	    }
	}
    }

#ifdef DO_CHECK_PIXELS
    if (gc->line.options.numPixels > 0)
    {
        ix0 = gc->line.options.xStart;
        iy0 = gc->line.options.yStart;
        if (ix0 < gc->transform.minx || ix0 >= gc->transform.maxx ||
            iy0 < gc->transform.miny || iy0 >= gc->transform.maxy)
        {
            DbgPrint("Start out of bounds %d,%d (%d,%d - %d,%d) for %d,%d\n",
                     ix0, iy0,
                     gc->transform.minx, gc->transform.miny,
                     gc->transform.maxx, gc->transform.maxy,
                     idx, idy);
            DbgPrint("  Line %.3lf,%.3lf - %.3lf,%.3lf\n", x0, y0, x1, y1);
            DbgPrint("  Viewport %.3lf,%.3lf - %.3lf,%.3lf%s\n",
                     gc->state.viewport.xCenter, gc->state.viewport.yCenter,
                     gc->state.viewport.xScale, gc->state.viewport.yScale,
                     !gc->transform.reasonableViewport ?
                     " (unreasonable)" : "");
        }
    }
#endif
    
    return gc->line.options.numPixels > 0;
}

// Only used by fast single-pixel line code
// It differs from glInitLineData only in the removal of halfWidth
BOOL FASTCALL __glInitThinLineData(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint start, end;
    __GLfloat x0,y0,x1,y1;
    __GLfloat minorStart;
    __GLfloat fdx, fdy;
    __GLfloat offset;
    __GLfloat slope;
    GLint x0frac, x1frac, y0frac, y1frac, totDist;
    GLint ix0, ix1, iy0, iy1, idx, idy;
    __GLcolorBuffer *cfb = gc->drawBuffer;

    ASSERT_CHOP_ROUND();

    ASSERTOPENGL(gc->state.line.aliasedWidth == __glOne,
                 "ThinAlias setup for wrong line state\n");

    x0 = v0->window.x;
    y0 = v0->window.y;
    x1 = v1->window.x;
    y1 = v1->window.y;

#ifdef DO_CHECK_PIXELS
    gc->line.options.v0 = v0;
    gc->line.options.v1 = v1;

    if (x0 < gc->transform.fminx || x0 >= gc->transform.fmaxx ||
        y0 < gc->transform.fminy || y0 >= gc->transform.fmaxy ||
        x1 < gc->transform.fminx || x1 >= gc->transform.fmaxx ||
        y1 < gc->transform.fminy || y1 >= gc->transform.fmaxy)
    {
        DbgPrint("Line coordinates out %.3lf,%.3lf - %.3lf,%.3lf%s\n",
                 x0, y0, x1, y1,
                 !gc->transform.reasonableViewport ? " (unreasonable)" : "");
    }
#endif
    
    fdx = x1-x0;
    fdy = y1-y0;

    ix0 = __GL_VERTEX_FLOAT_TO_INT(x0);
    x0frac = __GL_VERTEX_FLOAT_FRACTION(x0);
    iy0 = __GL_VERTEX_FLOAT_TO_INT(y0);
    y0frac = __GL_VERTEX_FLOAT_FRACTION(y0);
    ix1 = __GL_VERTEX_FLOAT_TO_INT(x1);
    x1frac = __GL_VERTEX_FLOAT_FRACTION(x1);
    iy1 = __GL_VERTEX_FLOAT_TO_INT(y1);
    y1frac = __GL_VERTEX_FLOAT_FRACTION(y1);

#if 0
    DbgPrint("Line %.3lf,%.3lf - %.3lf,%.3lf\n", x0, y0, x1, y1);
    DbgPrint("Line %d.%03d,%d.%03d - %d.%03d,%d.%03d\n",
             ix0, x0frac, iy0, y0frac, ix1, x1frac, iy1, y1frac);
#endif
    
    // An interesting property of window coordinates is that subtracting
    // two of them cancels the exponent so the result is the fixed-point
    // difference
    idx = CASTINT(x1)-CASTINT(x0);
    idy = CASTINT(y1)-CASTINT(y0);
    
    if (idx > 0) {
	if (idy > 0) {
	    if (idx > idy) {	/* dx > dy > 0 */
		gc->line.options.yBig = 1;
                gc->polygon.shader.sbufBig =
                    cfb->buf.outerWidth+GENACCEL(gc).xMultiplier;
                gc->polygon.shader.zbufBig = gc->depthBuffer.buf.outerWidth+1;

posxmajor:			/* dx > |dy| >= 0 */
		gc->line.options.yLittle = 0;
		gc->line.options.xBig = 1;
		gc->line.options.xLittle = 1;
                gc->polygon.shader.sbufLittle = GENACCEL(gc).xMultiplier;
                gc->polygon.shader.zbufLittle = 1;
                
		__GL_FLOAT_SIMPLE_BEGIN_DIVIDE(__glOne, fdx, slope);

		start = ix0;
		end = ix1;

		y0frac -= __GL_VERTEX_FRAC_HALF;
		if (y0frac < 0) y0frac = -y0frac;

		totDist = y0frac + x0frac - __GL_VERTEX_FRAC_ONE;
		if (totDist > 0) start++;

                y1frac -= __GL_VERTEX_FRAC_HALF;
                if (y1frac < 0) y1frac = -y1frac;

                totDist = y1frac + x1frac - __GL_VERTEX_FRAC_ONE;
                if (totDist > 0) end++;

		offset = start + __glHalf - x0;

		gc->line.options.length = fdx;
		gc->line.options.numPixels = end - start;

xmajorfinish:
		gc->line.options.axis = __GL_X_MAJOR;
		gc->line.options.xStart = start;
		gc->line.options.offset = offset;

		__GL_FLOAT_SIMPLE_END_DIVIDE(slope);
                gc->line.options.oneOverLength = slope;
                slope *= fdy;

		minorStart = y0 + offset*slope;
		gc->line.options.yStart = __GL_VERTEX_FLOAT_TO_INT(minorStart);
                if (gc->line.options.yStart < gc->transform.miny)
                {
                    gc->line.options.yStart = gc->transform.miny;
                    gc->line.options.fraction = 0;
                }
                else if (gc->line.options.yStart >= gc->transform.maxy)
                {
                    gc->line.options.yStart = gc->transform.maxy-1;
                    gc->line.options.fraction =
                        __GL_VERTEX_PROMOTE_FRACTION(
                                (1 << __GL_VERTEX_FRAC_BITS)-1);
                }
                else
                {
                    gc->line.options.fraction =
                        __GL_VERTEX_PROMOTED_FRACTION(minorStart);
                }

		gc->line.options.dfraction = FLT_FRACTION(slope);
	    } else {		/* dy >= dx > 0 */
		gc->line.options.xBig = 1;
                gc->polygon.shader.sbufBig =
                    cfb->buf.outerWidth+GENACCEL(gc).xMultiplier;
                gc->polygon.shader.zbufBig = gc->depthBuffer.buf.outerWidth+1;
                
posymajor:			/* dy >= |dx| >= 0, dy != 0 */
		gc->line.options.xLittle = 0;
		gc->line.options.yBig = 1;
		gc->line.options.yLittle = 1;
                gc->polygon.shader.sbufLittle = cfb->buf.outerWidth;
                gc->polygon.shader.zbufLittle = gc->depthBuffer.buf.outerWidth;
                
		__GL_FLOAT_SIMPLE_BEGIN_DIVIDE(__glOne, fdy, slope);
                    
		start = iy0;
		end = iy1;

		x0frac -= __GL_VERTEX_FRAC_HALF;
		if (x0frac < 0) x0frac = -x0frac;

		totDist = y0frac + x0frac - __GL_VERTEX_FRAC_ONE;
		if (totDist > 0) start++;

                x1frac -= __GL_VERTEX_FRAC_HALF;
                if (x1frac < 0) x1frac = -x1frac;

                totDist = y1frac + x1frac - __GL_VERTEX_FRAC_ONE;
                if (totDist > 0) end++;

		offset = start + __glHalf - y0;

		gc->line.options.length = fdy;
		gc->line.options.numPixels = end - start;

ymajorfinish:
		gc->line.options.axis = __GL_Y_MAJOR;
		gc->line.options.yStart = start;
		gc->line.options.offset = offset;

                __GL_FLOAT_SIMPLE_END_DIVIDE(slope);
                gc->line.options.oneOverLength = slope;
                slope *= fdx;
                
		minorStart = x0 + offset*slope;
		gc->line.options.xStart = __GL_VERTEX_FLOAT_TO_INT(minorStart);
                if (gc->line.options.xStart < gc->transform.minx)
                {
                    gc->line.options.xStart = gc->transform.minx;
                    gc->line.options.fraction = 0;
                }
                else if (gc->line.options.xStart >= gc->transform.maxx)
                {
                    gc->line.options.xStart = gc->transform.maxx-1;
                    gc->line.options.fraction =
                        __GL_VERTEX_PROMOTE_FRACTION(
                                (1 << __GL_VERTEX_FRAC_BITS)-1);
                }
                else
                {
                    gc->line.options.fraction =
                        __GL_VERTEX_PROMOTED_FRACTION(minorStart);
                }
                
		gc->line.options.dfraction = FLT_FRACTION(slope);
	    }
	} else {
	    if (idx > -idy) {	/* dx > -dy >= 0 */
		gc->line.options.yBig = -1;
                gc->polygon.shader.sbufBig =
                    GENACCEL(gc).xMultiplier-cfb->buf.outerWidth;
                gc->polygon.shader.zbufBig = 1-gc->depthBuffer.buf.outerWidth;
		goto posxmajor;
	    } else {		/* -dy >= dx >= 0, dy != 0 */
		gc->line.options.xBig = 1;
                gc->polygon.shader.sbufBig =
                    GENACCEL(gc).xMultiplier-cfb->buf.outerWidth;
                gc->polygon.shader.zbufBig = 1-gc->depthBuffer.buf.outerWidth;
negymajor:			/* -dy >= |dx| >= 0, dy != 0 */
		gc->line.options.xLittle = 0;
		gc->line.options.yBig = -1;
		gc->line.options.yLittle = -1;
                gc->polygon.shader.sbufLittle = -cfb->buf.outerWidth;
                gc->polygon.shader.zbufLittle = -gc->depthBuffer.buf.outerWidth;

                __GL_FLOAT_BEGIN_DIVIDE(__glOne, -fdy, &slope);

		start = iy0;
		end = iy1;

		x0frac -= __GL_VERTEX_FRAC_HALF;
		if (x0frac < 0) x0frac = -x0frac;

		totDist = x0frac - y0frac;
		if (totDist > 0) start--;

                x1frac -= __GL_VERTEX_FRAC_HALF;
                if (x1frac < 0) x1frac = -x1frac;

                totDist = x1frac - y1frac;
                if (totDist > 0) end--;

		offset = y0 - (start + __glHalf);

		gc->line.options.length = -fdy;
		gc->line.options.numPixels = start - end;
		goto ymajorfinish;
	    }
	}
    } else {
	if (idy > 0) {
	    if (-idx > idy) {	/* -dx > dy > 0 */
		gc->line.options.yBig = 1;
                gc->polygon.shader.sbufBig =
                    cfb->buf.outerWidth-GENACCEL(gc).xMultiplier;
                gc->polygon.shader.zbufBig = gc->depthBuffer.buf.outerWidth-1;
negxmajor:			/* -dx > |dy| >= 0 */
		gc->line.options.yLittle = 0;
		gc->line.options.xBig = -1;
		gc->line.options.xLittle = -1;
                gc->polygon.shader.sbufLittle = -GENACCEL(gc).xMultiplier;
                gc->polygon.shader.zbufLittle = -1;

                __GL_FLOAT_BEGIN_DIVIDE(__glOne, -fdx, &slope);

		start = ix0;
		end = ix1;

		y0frac -= __GL_VERTEX_FRAC_HALF;
		if (y0frac < 0) y0frac = -y0frac;

		totDist = y0frac - x0frac;
		if (totDist > 0) start--;

                y1frac -= __GL_VERTEX_FRAC_HALF;
                if (y1frac < 0) y1frac = -y1frac;

                totDist = y1frac - x1frac;
                if (totDist > 0) end--;

		offset = x0 - (start + __glHalf);

		gc->line.options.length = -fdx;
		gc->line.options.numPixels = start - end;

		goto xmajorfinish;
	    } else {		/* dy >= -dx >= 0, dy != 0 */
		gc->line.options.xBig = -1;
                gc->polygon.shader.sbufBig =
                    cfb->buf.outerWidth-GENACCEL(gc).xMultiplier;
                gc->polygon.shader.zbufBig = gc->depthBuffer.buf.outerWidth-1;
		goto posymajor;
	    }
	} else {
	    if (idx < idy) {	/* -dx > -dy >= 0 */
		gc->line.options.yBig = -1;
                gc->polygon.shader.sbufBig =
                    -GENACCEL(gc).xMultiplier-cfb->buf.outerWidth;
                gc->polygon.shader.zbufBig = -1-gc->depthBuffer.buf.outerWidth;
		goto negxmajor;
	    } else {		/* -dy >= -dx >= 0 */
		if ((idx | idy) == 0) {
		    gc->line.options.numPixels = 0;
		    return FALSE;
		}
		gc->line.options.xBig = -1;
                gc->polygon.shader.sbufBig =
                    -GENACCEL(gc).xMultiplier-cfb->buf.outerWidth;
                gc->polygon.shader.zbufBig = -1-gc->depthBuffer.buf.outerWidth;
		goto negymajor;
	    }
	}
    }

#ifdef DO_CHECK_PIXELS
    if (gc->line.options.numPixels > 0)
    {
        ix0 = gc->line.options.xStart;
        iy0 = gc->line.options.yStart;
        if (ix0 < gc->transform.minx || ix0 >= gc->transform.maxx ||
            iy0 < gc->transform.miny || iy0 >= gc->transform.maxy)
        {
            DbgPrint("Start out of bounds %d,%d (%d,%d - %d,%d) for %d,%d\n",
                     ix0, iy0,
                     gc->transform.minx, gc->transform.miny,
                     gc->transform.maxx, gc->transform.maxy,
                     idx, idy);
            DbgPrint("  Line %.3lf,%.3lf - %.3lf,%.3lf\n", x0, y0, x1, y1);
            DbgPrint("  Viewport %.3lf,%.3lf - %.3lf,%.3lf%s\n",
                     gc->state.viewport.xCenter, gc->state.viewport.yCenter,
                     gc->state.viewport.xScale, gc->state.viewport.yScale,
                     !gc->transform.reasonableViewport ?
                     " (unreasonable)" : "");
        }
    }
#endif
    
    return gc->line.options.numPixels > 0;
}

// Called to render both anti-aliased and aliased lines
void FASTCALL __glGenRenderEitherLine(__GLcontext *gc, __GLvertex *v0, 
                                      __GLvertex *v1, GLuint flags)
{
    __GLfloat invDelta;
    GLuint modeFlags = gc->polygon.shader.modeFlags;

    CHOP_ROUND_ON();

    if (!(*GENACCEL(gc).__fastGenInitLineData)(gc, v0, v1))
    {
        CHOP_ROUND_OFF();
        return;
    }

    ASSERTOPENGL(GENACCEL(gc).rAccelScale == FIX_SCALEFACT,
                 "rAccelScale != FIX_SCALEFACT\n");
    ASSERTOPENGL(GENACCEL(gc).gAccelScale == FIX_SCALEFACT,
                 "gAccelScale != FIX_SCALEFACT\n");
    ASSERTOPENGL(GENACCEL(gc).bAccelScale == FIX_SCALEFACT,
                 "bAccelScale != FIX_SCALEFACT\n");
    // Alpha is always scaled between 0 and 255

    invDelta = gc->line.options.oneOverLength;
    
    /*
    ** Set up increments for any enabled line options.
    */

    if ((gc->drawBuffer->buf.flags & DIB_FORMAT) == 0)
    {
        // For non-DIBs we pick up the bytes from ColorsBits so
        // the pixel pointer doesn't move
        gc->polygon.shader.sbufLittle = 0;
        gc->polygon.shader.sbufBig = 0;
    }

    if (modeFlags & __GL_SHADE_SMOOTH)
    {
        __GLcolor *c0 = v0->color;
        __GLcolor *c1 = v1->color;

        /*
        ** Calculate red, green, blue and alpha value increments.
        */

        if (gc->modes.rgbMode)
        {
            __GLfloat dr, dg, db;
            
#ifdef _X86_
            __asm
            {
                ; Compute dr, dg and db
                mov eax, c0
                mov edx, c1
                fld DWORD PTR [eax+COLOR_r]
                fld DWORD PTR [eax+COLOR_g]
                fld DWORD PTR [eax+COLOR_b]
                fld DWORD PTR [edx+COLOR_r]
                fsub st(0), st(3)
                fld DWORD PTR [edx+COLOR_g]
                fsub st(0), st(3)
                fld DWORD PTR [edx+COLOR_b]
                fsub st(0), st(3)
                mov edx, gc
                fstp db
                fstp dg
                fstp dr
                
                FLT_STACK_RGB_TO_GC_FIXED(GC_SHADER_R,
                                          GC_SHADER_G,
                                          GC_SHADER_B)
            }
#else
            dr = c1->r - c0->r;
            CASTFIX(gc->polygon.shader.frag.color.r) =
                UNSAFE_FLT_TO_FIX(c0->r);
        
            dg = c1->g - c0->g;
            CASTFIX(gc->polygon.shader.frag.color.g) =
                UNSAFE_FLT_TO_FIX(c0->g);
            
            db = c1->b - c0->b;
            CASTFIX(gc->polygon.shader.frag.color.b) =
                UNSAFE_FLT_TO_FIX(c0->b);
#endif
            
            if ((CASTINT(dr) | CASTINT(dg) | CASTINT(db)) == 0)
            {
                CASTINT(gc->polygon.shader.drdx) = 0;
                CASTINT(gc->polygon.shader.dgdx) = 0;
                CASTINT(gc->polygon.shader.dbdx) = 0;
            }
            else
            {
#ifdef _X86_
                __asm
                {
                    fld dr
                    fld dg
                    fld db
                    fld invDelta
                    fmul __glVal65536
                    mov edx, gc
                    fmul st(3), st(0)
                    fmul st(2), st(0)
                    fmulp st(1), st(0)
                    fistp DWORD PTR [edx+GC_SHADE_dbdx]
                    fistp DWORD PTR [edx+GC_SHADE_dgdx]
                    fistp DWORD PTR [edx+GC_SHADE_drdx]
                }
#else
                CASTFIX(gc->polygon.shader.drdx) =
                    UNSAFE_FLT_TO_FIX(dr * invDelta);
                CASTFIX(gc->polygon.shader.dgdx) =
                    UNSAFE_FLT_TO_FIX(dg * invDelta);
                CASTFIX(gc->polygon.shader.dbdx) =
                    UNSAFE_FLT_TO_FIX(db * invDelta);
#endif
            }

            if (gc->state.enables.general & __GL_BLEND_ENABLE)
            {
                __GLfloat da;
                
                da = c1->a - c0->a;
                CASTFIX(gc->polygon.shader.frag.color.a) =
                    UNSAFE_FTOL(c0->a * GENACCEL(gc).aAccelScale);
                
                if (__GL_FLOAT_EQZ(da))
                {
                    CASTINT(gc->polygon.shader.dadx) = 0;
                }
                else
                {
                    CASTFIX(gc->polygon.shader.dadx) =
                        UNSAFE_FTOL(da * invDelta * GENACCEL(gc).aAccelScale);
                }
            }
        }
        else
        {
            __GLfloat dr;
            
            dr = c1->r - c0->r;
            CASTFIX(gc->polygon.shader.frag.color.r) =
                UNSAFE_FLT_TO_FIX(c0->r);

            if (__GL_FLOAT_EQZ(dr))
            {
                CASTINT(gc->polygon.shader.drdx) = 0;
            }
            else
            {
                CASTFIX(gc->polygon.shader.drdx) =
                    UNSAFE_FLT_TO_FIX(dr * invDelta);
            }
        }
    }
    else
    {
        __GLcolor *c1 = v0->color;

        if (gc->modes.rgbMode)
        {
#ifdef _X86_
            __asm
            {
                mov eax, c1
                fld DWORD PTR [eax+COLOR_r]
                fld DWORD PTR [eax+COLOR_g]
                fld DWORD PTR [eax+COLOR_b]
                mov edx, gc
                
                FLT_STACK_RGB_TO_GC_FIXED(GC_SHADER_R,
                                          GC_SHADER_G,
                                          GC_SHADER_B)
            }
#else
            CASTFIX(gc->polygon.shader.frag.color.r) =
                UNSAFE_FLT_TO_FIX(c1->r);
            CASTFIX(gc->polygon.shader.frag.color.g) =
                UNSAFE_FLT_TO_FIX(c1->g);
            CASTFIX(gc->polygon.shader.frag.color.b) =
                UNSAFE_FLT_TO_FIX(c1->b);
#endif

            if (gc->state.enables.general & __GL_BLEND_ENABLE)
            {
                CASTFIX(gc->polygon.shader.frag.color.a) =
                    UNSAFE_FTOL(c1->a * GENACCEL(gc).aAccelScale);
            }
        }
        else
        {
            CASTFIX(gc->polygon.shader.frag.color.r) =
                UNSAFE_FLT_TO_FIX(c1->r);
        }
    }
    
    if (modeFlags & __GL_SHADE_DEPTH_ITER)
    {
        // The increment is in USHORT units so it only needs to be
        // scaled in the 32-bit Z buffer case
        if (gc->depthBuffer.buf.elementSize == 4)
        {
            gc->polygon.shader.zbufLittle <<= 1;
            gc->polygon.shader.zbufBig <<= 1;
        }

        /*
        ** Calculate window z coordinate increment and starting position.
        */
        if(( gc->modes.depthBits == 16 ) &&
           ( gc->depthBuffer.scale <= (GLuint)0xffff ))
        {
            ASSERTOPENGL(Z16_SCALE == FIX_SCALEFACT,
                         "Z16 scaling different from fixed\n");
            
            gc->polygon.shader.dzdx =
                FLT_TO_Z16_SCALE((v1->window.z - v0->window.z) * invDelta);
            gc->polygon.shader.frag.z =
                FTOL(v0->window.z*Z16_SCALE + gc->polygon.shader.dzdx *
                     gc->line.options.offset);
        }
        else
        {
            gc->polygon.shader.dzdx =
                FTOL((v1->window.z - v0->window.z) * invDelta);
            gc->polygon.shader.frag.z =
                FTOL(v0->window.z + gc->polygon.shader.dzdx *
                     gc->line.options.offset);
        }
    } 

    (*GENACCEL(gc).__fastGenLineProc)(gc);

    CHOP_ROUND_OFF();
}

#define DITHER_PIXEL(pPix, x, y)\
{\
    ULONG r, g, b;\
    DWORD ditherVal;\
\
    ditherVal = ditherShade[((x) & 0x3) + \
                            (((y) & 0x3) << 3)];\
\
    r = ((rAccum + ditherVal) >> (16-RSHIFT)) & RMASK;\
    g = ((gAccum + ditherVal) >> (16-GSHIFT)) & GMASK;\
    b = ((bAccum + ditherVal) >> (16-BSHIFT)) & BMASK;\
\
    WRITE_PIX(pPix);\
}

#define BLEND_PIXEL(pPix, alpha, x, y)\
{\
    ULONG pix;\
    ULONG rDisplay, gDisplay, bDisplay, aDisplay;\
    ULONG r, g, b;\
    ULONG invAlpha;\
    DWORD ditherVal;\
\
    ditherVal = ditherShade[((x) & 0x3) + \
                            (((y) & 0x3) << 3)];\
\
    aDisplay = (gbMulTable[((aAccum >> 16) & 0xff) | (alpha)]) << 8;\
\
    pix = READ_PIX(pPix);\
\
    rDisplay = ((pix & RMASK) >> RSHIFT) << (8 - RBITS);\
    gDisplay = ((pix & GMASK) >> GSHIFT) << (8 - GBITS);\
    bDisplay = ((pix & BMASK) >> BSHIFT) << (8 - BBITS);\
\
    if (gc->state.raster.blendDst == GL_ONE) { \
\
        r = (gbMulTable[((rAccum >> (RBITS+8)) & 0xff) | aDisplay] + rDisplay)\
             + (ditherVal >> (RBITS + 8));\
        g = (gbMulTable[((gAccum >> (GBITS+8)) & 0xff) | aDisplay] + gDisplay)\
             + (ditherVal >> (GBITS + 8));\
        b = (gbMulTable[((bAccum >> (BBITS+8)) & 0xff) | aDisplay] + bDisplay)\
             + (ditherVal >> (BBITS + 8));\
        r = ((gbSatTable[r] << (RBITS+8)) \
             >> (16 - RSHIFT)) & RMASK;\
        g = ((gbSatTable[g] << (GBITS+8)) \
             >> (16 - GSHIFT)) & GMASK;\
        b = ((gbSatTable[b] << (BBITS+8)) \
             >> (16 - BSHIFT)) & BMASK;\
\
    } else { \
\
        invAlpha = 0xff00 - (ULONG)aDisplay;\
\
        rDisplay = gbMulTable[rDisplay | invAlpha];\
        gDisplay = gbMulTable[gDisplay | invAlpha];\
        bDisplay = gbMulTable[bDisplay | invAlpha];\
\
        r = ((((gbMulTable[((rAccum >> (RBITS+8)) & 0xff) | aDisplay] + rDisplay)\
             << (RBITS+8)) + ditherVal) >> (16 - RSHIFT)) & RMASK;\
\
        g = ((((gbMulTable[((gAccum >> (GBITS+8)) & 0xff) | aDisplay] + gDisplay)\
             << (GBITS+8)) + ditherVal) >> (16 - GSHIFT)) & GMASK;\
\
        b = ((((gbMulTable[((bAccum >> (BBITS+8)) & 0xff) | aDisplay] + bDisplay)\
             << (BBITS+8)) + ditherVal) >> (16 - BSHIFT)) & BMASK;\
    } \
\
    WRITE_PIX(pPix);\
}


#define WRITE_PIXEL_GEN(pPix, alpha, x, y)\
if (gc->state.enables.general & __GL_BLEND_ENABLE) {\
    ULONG pix;\
    ULONG rDisplay, gDisplay, bDisplay, aDisplay;\
    ULONG r, g, b;\
    ULONG invAlpha;\
    DWORD ditherVal;\
\
    if (modeFlags & __GL_SHADE_DITHER) {\
        ditherVal = ditherShade[((x) & 0x3) + \
                                (((y) & 0x3) << 3)];\
    } else\
        ditherVal = 0;\
\
    aDisplay = (gbMulTable[((aAccum >> 16) & 0xff) | (alpha)]) << 8;\
\
    switch (bytesPerPixel) {\
        case 1:\
            pix = ((__GLGENcontext *)gc)->pajInvTranslateVector[*((BYTE *)(pPix))];\
            rDisplay = ((pix & rMask) >> rShift) << (8 - rBits);\
            gDisplay = ((pix & gMask) >> gShift) << (8 - gBits);\
            bDisplay = ((pix & bMask) >> bShift) << (8 - bBits);\
            break;\
        case 2:\
            pix = *((USHORT *)(pPix));\
            rDisplay = ((pix & rMask) >> rShift) << (8 - rBits);\
            gDisplay = ((pix & gMask) >> gShift) << (8 - gBits);\
            bDisplay = ((pix & bMask) >> bShift) << (8 - bBits);\
            break;\
        case 3:\
        default:\
            if (rShift > bShift) {\
                rDisplay = pPix[2];\
                gDisplay = pPix[1];\
                bDisplay = pPix[0];\
            } else {\
                rDisplay = pPix[0];\
                gDisplay = pPix[1];\
                bDisplay = pPix[2];\
            }\
            break;\
    }\
\
    if (gc->state.raster.blendDst == GL_ONE) { \
\
        r = (gbMulTable[((rAccum >> (rBits+8)) & 0xff) | aDisplay] + rDisplay)\
             + (ditherVal >> (rBits + 8));\
        g = (gbMulTable[((gAccum >> (gBits+8)) & 0xff) | aDisplay] + gDisplay)\
             + (ditherVal >> (gBits + 8));\
        b = (gbMulTable[((bAccum >> (bBits+8)) & 0xff) | aDisplay] + bDisplay)\
             + (ditherVal >> (bBits + 8));\
        r = ((gbSatTable[r] << (rBits+8)) \
             >> (16 - rShift)) & rMask;\
        g = ((gbSatTable[g] << (gBits+8)) \
             >> (16 - gShift)) & gMask;\
        b = ((gbSatTable[b] << (bBits+8)) \
             >> (16 - bShift)) & bMask;\
\
    } else { \
\
        invAlpha = 0xff00 - (ULONG)aDisplay;\
\
        rDisplay = gbMulTable[rDisplay | invAlpha];\
        gDisplay = gbMulTable[gDisplay | invAlpha];\
        bDisplay = gbMulTable[bDisplay | invAlpha];\
\
        r = ((((gbMulTable[((rAccum >> (rBits+8)) & 0xff) | aDisplay] + rDisplay)\
             << (rBits+8)) + ditherVal) >> (16 - rShift)) & rMask;\
\
        g = ((((gbMulTable[((gAccum >> (gBits+8)) & 0xff) | aDisplay] + gDisplay)\
             << (gBits+8)) + ditherVal) >> (16 - gShift)) & gMask;\
\
        b = ((((gbMulTable[((bAccum >> (bBits+8)) & 0xff) | aDisplay] + bDisplay)\
             << (bBits+8)) + ditherVal) >> (16 - bShift)) & bMask;\
    } \
\
    switch (bytesPerPixel) {\
        case 1:\
            pPix[0] = ((__GLGENcontext *)gc)->xlatPalette[r | g | b];\
            break;\
        case 2:\
            *((USHORT *)pPix) = (USHORT)(r | g | b);\
            break;\
        case 3:\
            pix = r | g | b;\
            *((USHORT UNALIGNED *)pPix) = (USHORT)pix;\
            pPix[2] = (BYTE)(pix >> 16);\
            break;\
        default:\
            *((DWORD *)pPix) = (DWORD)(r | g | b);\
            break;\
    }\
} else {\
    ULONG r, g, b;\
    DWORD ditherVal;\
    ULONG pix;\
\
    if (modeFlags & __GL_SHADE_DITHER) {\
        ditherVal = ditherShade[((x) & 0x3) + (((y) & 0x3) << 3)];\
    } else\
        ditherVal = 0;\
\
    r = ((rAccum + ditherVal) >> (16-rShift)) & rMask;\
    g = ((gAccum + ditherVal) >> (16-gShift)) & gMask;\
    b = ((bAccum + ditherVal) >> (16-bShift)) & bMask;\
\
    switch (bytesPerPixel) {\
        case 1:\
            pPix[0] = ((__GLGENcontext *)gc)->xlatPalette[r | g | b];\
            break;\
        case 2:\
            *((USHORT *)pPix) = (USHORT)(r | g | b);\
            break;\
        case 3:\
            pix = r | g | b;\
            *((USHORT UNALIGNED *)pPix) = (USHORT)pix;\
            pPix[2] = (BYTE)(pix >> 16);\
            break;\
        default:\
            *((DWORD *)pPix) = (DWORD)(r | g | b);\
            break;\
    }\
}

#ifdef DO_CHECK_PIXELS
#define CHECK_PIXEL(gc, cfb, count, bx, by) \
{\
    GLint fbX, fbY;\
\
    fbX = __GL_UNBIAS_X(gc, bx);\
    fbY = __GL_UNBIAS_Y(gc, by);\
    if (!(fbX >= 0 && fbX < (cfb)->buf.width &&\
          fbY >= 0 && fbY < (cfb)->buf.height))\
    {\
        DbgPrint("Pixel out of bounds at %c %d of %d: %d,%d (%d,%d)\n",\
                 (gc)->line.options.axis == __GL_Y_MAJOR ? 'Y' : 'X',\
                 (gc)->line.options.numPixels-(count),\
                 (gc)->line.options.numPixels,\
                 fbX, fbY, (cfb)->buf.width, (cfb)->buf.height);\
        DbgPrint("  Line %.3lf,%.3lf - %.3lf,%.3lf\n",\
                 (gc)->line.options.v0->window.x,\
                 (gc)->line.options.v0->window.y,\
                 (gc)->line.options.v1->window.x,\
                 (gc)->line.options.v1->window.y);\
    }\
}
#else
#define CHECK_PIXEL(gc, cfb, w, x, y)
#endif
 
#define FAST_AA_LINE \
{\
    GLint xLittle, xBig, yLittle, yBig;\
    GLint fragX2, fragY2;\
    BYTE *pPix;\
    BYTE *pPix2;\
    USHORT *pZ;\
    USHORT *pZ2;\
    __GLfragment frag;\
    __GLcolorBuffer *cfb = gc->drawBuffer;\
    LONG rAccum, gAccum, bAccum, aAccum;\
    LONG pixAdjStep;\
    ULONG zAdjStep;\
    ULONG coverage, invCoverage;\
    LONG fragXinc;\
    LONG fragYinc;\
    LONG bytesPerPixel;\
    __GLzValue zAccum;\
    GLint clipX1 = gc->transform.clipX1;\
    GLint clipY1 = gc->transform.clipY1;\
\
    GLint fraction, dfraction;\
    GLint w;\
    GLuint modeFlags = gc->polygon.shader.modeFlags;\
\
    ASSERTOPENGL((cfb->buf.flags &\
                  (DIB_FORMAT | NO_CLIP)) == (DIB_FORMAT | NO_CLIP),\
                 "FAST_AA_LINE on clipping surface\n");\
\
    fraction = gc->line.options.fraction;\
    dfraction = gc->line.options.dfraction;\
\
    xBig = gc->line.options.xBig;\
    yBig = gc->line.options.yBig;\
    xLittle = gc->line.options.xLittle;\
    yLittle = gc->line.options.yLittle;\
\
    frag.x = gc->line.options.xStart;\
    frag.y = gc->line.options.yStart;\
\
    bytesPerPixel = GENACCEL(gc).xMultiplier;\
\
    if (gc->line.options.axis == __GL_Y_MAJOR) {\
        pixAdjStep = bytesPerPixel;\
        zAdjStep = 1;\
        fragXinc = 1;\
        fragYinc = 0;\
    } else {\
        pixAdjStep = cfb->buf.outerWidth;\
        zAdjStep = gc->depthBuffer.buf.outerWidth;\
        fragXinc = 0;\
        fragYinc = 1;\
    }\
\
    pPix = (BYTE *)((ULONG_PTR)cfb->buf.base +\
        (__GL_UNBIAS_Y(gc, frag.y) + cfb->buf.yOrigin) * cfb->buf.outerWidth +\
        (__GL_UNBIAS_X(gc, frag.x) + cfb->buf.xOrigin) * bytesPerPixel);\
\
    if (modeFlags & __GL_SHADE_DEPTH_TEST) {\
        zAccum = gc->polygon.shader.frag.z;\
\
	if( gc->modes.depthBits == 32 ) {\
	    pZ = (USHORT *)__GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),\
                                           frag.x, frag.y);\
\
            zAdjStep *= 2;\
	} else {\
	    pZ = (USHORT *)__GL_DEPTH_ADDR(&gc->depthBuffer,\
                                           (__GLz16Value*),\
                                           frag.x, frag.y);\
        }\
\
    }\
\
    rAccum = CASTFIX(gc->polygon.shader.frag.color.r);\
    gAccum = CASTFIX(gc->polygon.shader.frag.color.g);\
    bAccum = CASTFIX(gc->polygon.shader.frag.color.b);\
    aAccum = CASTFIX(gc->polygon.shader.frag.color.a);\
\
    w = gc->line.options.numPixels;\
    for (;;)\
    {\
        CHECK_PIXEL(gc, cfb, w, frag.x, frag.y);\
\
        invCoverage = ((fraction << 1) & 0xff000000) >> 16;\
	coverage = 0xff00 - invCoverage;\
\
        if (modeFlags & __GL_SHADE_DEPTH_TEST) {\
            if (!(*GENACCEL(gc).__fastGenZStore)(zAccum, (__GLzValue *)pZ ))\
                goto noWrite1;\
        }\
\
        BLEND_PIXEL(pPix, coverage, frag.x, frag.y);\
noWrite1:\
\
        fragX2 = frag.x + fragXinc;\
        fragY2 = frag.y + fragYinc;\
        if ((fragX2 >= clipX1) || (fragY2 >= clipY1)) {\
            goto noWrite2;\
        }\
\
        pZ2 = pZ+zAdjStep;\
        if (modeFlags & __GL_SHADE_DEPTH_TEST) {\
            if (!(*GENACCEL(gc).__fastGenZStore)(zAccum, (__GLzValue *)pZ2 ))\
                goto noWrite2;\
        }\
\
	pPix2 = pPix + pixAdjStep;\
        BLEND_PIXEL(pPix2, invCoverage, fragX2, fragY2);\
noWrite2:\
\
        if (--w <= 0)\
            return GL_TRUE;\
\
        fraction += dfraction;\
	if (fraction < 0) {\
	    fraction &= ~0x80000000;\
	    frag.x += xBig;\
	    frag.y += yBig;\
            pPix += gc->polygon.shader.sbufBig;\
            pZ += gc->polygon.shader.zbufBig;\
	} else {\
	    frag.x += xLittle;\
	    frag.y += yLittle;\
            pPix += gc->polygon.shader.sbufLittle;\
            pZ += gc->polygon.shader.zbufLittle;\
	}\
\
        if (modeFlags & __GL_SHADE_SMOOTH) {\
            rAccum += CASTFIX(gc->polygon.shader.drdx);\
            gAccum += CASTFIX(gc->polygon.shader.dgdx);\
            bAccum += CASTFIX(gc->polygon.shader.dbdx);\
            aAccum += CASTFIX(gc->polygon.shader.dadx);\
        }\
\
        if (modeFlags & __GL_SHADE_DEPTH_ITER) {\
	    zAccum += gc->polygon.shader.dzdx;\
        }\
    }\
\
    return GL_TRUE;\
}


/************************************************************************/


#undef BPP
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#undef RMASK
#undef GMASK
#undef BMASK
#undef READ_PIX
#undef WRITE_PIX
#define RSHIFT          0
#define GSHIFT          3
#define BSHIFT          6
#define RBITS		3
#define GBITS		3
#define BBITS		2
#define RMASK (((1 << RBITS) - 1) << RSHIFT)
#define GMASK (((1 << GBITS) - 1) << GSHIFT)
#define BMASK (((1 << BBITS) - 1) << BSHIFT)
#define BPP             8
#define READ_PIX(pPix) \
    ((__GLGENcontext *)gc)->pajInvTranslateVector[*((BYTE *)(pPix))]
#define WRITE_PIX(pPix) \
    pPix[0] = ((__GLGENcontext *)gc)->xlatPalette[r | g | b]

GLboolean FASTCALL __fastGenAntiAliasLine332(__GLcontext *gc)
FAST_AA_LINE


#undef BPP
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#undef RMASK
#undef GMASK
#undef BMASK
#undef READ_PIX
#undef WRITE_PIX
#define RSHIFT          10
#define GSHIFT          5
#define BSHIFT          0
#define RBITS		5
#define GBITS		5
#define BBITS		5
#define RMASK (((1 << RBITS) - 1) << RSHIFT)
#define GMASK (((1 << GBITS) - 1) << GSHIFT)
#define BMASK (((1 << BBITS) - 1) << BSHIFT)
#define BPP             16
#define READ_PIX(pPix) \
    *((USHORT *)(pPix))
#define WRITE_PIX(pPix) \
    *((USHORT *)pPix) = (USHORT)(r | g | b)

GLboolean FASTCALL __fastGenAntiAliasLine555(__GLcontext *gc)
FAST_AA_LINE


#undef BPP
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#undef RMASK
#undef GMASK
#undef BMASK
#undef READ_PIX
#undef WRITE_PIX
#define RSHIFT          11
#define GSHIFT          5
#define BSHIFT          0
#define RBITS		5
#define GBITS		6
#define BBITS		5
#define RMASK (((1 << RBITS) - 1) << RSHIFT)
#define GMASK (((1 << GBITS) - 1) << GSHIFT)
#define BMASK (((1 << BBITS) - 1) << BSHIFT)
#define BPP             16
#define READ_PIX(pPix) \
    *((USHORT *)(pPix))
#define WRITE_PIX(pPix) \
    *((USHORT *)pPix) = (USHORT)(r | g | b)

GLboolean FASTCALL __fastGenAntiAliasLine565(__GLcontext *gc)
FAST_AA_LINE

GLboolean FASTCALL __fastGenAntiAliasLine(__GLcontext *gc)
{
    GLint xLittle, xBig, yLittle, yBig;
    GLint fragX2, fragY2;
    BYTE *pPix;
    BYTE *pPix2;
    USHORT *pZ;
    USHORT *pZ2;
    __GLfragment frag;
    __GLcolorBuffer *cfb = gc->drawBuffer;
    LONG rAccum, gAccum, bAccum, aAccum;
    ULONG rMask, gMask, bMask;
    ULONG rShift, gShift, bShift;
    ULONG rBits, gBits, bBits;
    LONG bytesPerPixel;
    LONG pixAdjStep;
    ULONG zAdjStep;
    ULONG coverage, invCoverage;
    LONG fragXinc;
    LONG fragYinc;
    GLint cfbX, cfbY;
    int copyPix;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    __GLzValue zAccum;
    GLint clipX1 = gc->transform.clipX1;
    GLint clipY1 = gc->transform.clipY1;

    GLint fraction, dfraction;
    GLint w;
    GLuint modeFlags = gc->polygon.shader.modeFlags;

    w = gc->line.options.numPixels;

    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;

    frag.x = gc->line.options.xStart;
    frag.y = gc->line.options.yStart;

    bytesPerPixel = GENACCEL(gc).xMultiplier;

    if (gc->line.options.axis == __GL_Y_MAJOR) {
        pixAdjStep = bytesPerPixel;
        zAdjStep = 1;
        fragXinc = 1;
        fragYinc = 0;
        // For Y-major non-DIB lines we can copy both affected pixels
        // at once since they are adjacent in memory
        copyPix = 2;
    } else {
        if ((cfb->buf.flags & DIB_FORMAT) != 0)
        {
            pixAdjStep = cfb->buf.outerWidth;
        }
        else
        {
            pixAdjStep = 0;
        }
        zAdjStep = gc->depthBuffer.buf.outerWidth;
        fragXinc = 0;
        fragYinc = 1;
        copyPix = 1;
    }

    if ((cfb->buf.flags & DIB_FORMAT) != 0)
    {
        pPix = (BYTE *)((ULONG_PTR)cfb->buf.base +
            (__GL_UNBIAS_Y(gc, frag.y) + cfb->buf.yOrigin) * cfb->buf.outerWidth + 
            (__GL_UNBIAS_X(gc, frag.x) + cfb->buf.xOrigin) * bytesPerPixel);
    }
    else
    {
        pPix = gengc->ColorsBits;
    }

    if (modeFlags & __GL_SHADE_DEPTH_TEST) {
        zAccum = gc->polygon.shader.frag.z;

	if( gc->modes.depthBits == 32 ) {
	    pZ = (USHORT *)__GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                                           frag.x, frag.y);
            // Adjust for pZ being a USHORT * but traversing a 32-bit
            // depth buffer
            zAdjStep *= 2;
	} else {
	    pZ = (USHORT *)__GL_DEPTH_ADDR(&gc->depthBuffer,
                                           (__GLz16Value*),
                                           frag.x, frag.y);
        }
    }

    rShift = cfb->redShift;
    gShift = cfb->greenShift;
    bShift = cfb->blueShift;

    rMask = gc->modes.redMask;
    gMask = gc->modes.greenMask;
    bMask = gc->modes.blueMask;

    rBits = gc->modes.redBits;
    gBits = gc->modes.greenBits;
    bBits = gc->modes.blueBits;

    rAccum = CASTFIX(gc->polygon.shader.frag.color.r);
    gAccum = CASTFIX(gc->polygon.shader.frag.color.g);
    bAccum = CASTFIX(gc->polygon.shader.frag.color.b);
    aAccum = CASTFIX(gc->polygon.shader.frag.color.a);


    for (;;)
    {
        CHECK_PIXEL(gc, cfb, w, frag.x, frag.y);

        invCoverage = ((fraction << 1) & 0xff000000) >> 16;
	coverage = 0xff00 - invCoverage;

        if ((cfb->buf.flags & DIB_FORMAT) == 0)
        {
            cfbX = __GL_UNBIAS_X(gc, frag.x)+cfb->buf.xOrigin;
            cfbY = __GL_UNBIAS_Y(gc, frag.y)+cfb->buf.yOrigin;
            gengc->pfnCopyPixels(gengc, cfb, cfbX, cfbY, copyPix, FALSE);
        }

        if (modeFlags & __GL_SHADE_DEPTH_TEST) {
            if (!(*GENACCEL(gc).__fastGenZStore)(zAccum, (__GLzValue *)pZ ))
                goto noWrite1;
        }

        if ((cfb->buf.flags & (NO_CLIP | DIB_FORMAT)) == DIB_FORMAT)
        {
            cfbX = __GL_UNBIAS_X(gc, frag.x)+cfb->buf.xOrigin;
            cfbY = __GL_UNBIAS_Y(gc, frag.y)+cfb->buf.yOrigin;
            if (!wglPixelVisible(cfbX, cfbY))
            {
                goto noWrite1;
            }
        }
        
        WRITE_PIXEL_GEN(pPix, coverage, frag.x, frag.y);
        
        if ((cfb->buf.flags & DIB_FORMAT) == 0 && copyPix == 1)
        {
            gengc->pfnCopyPixels(gengc, cfb, cfbX, cfbY, copyPix, TRUE);
        }
        
noWrite1:

        fragX2 = frag.x + fragXinc;
        fragY2 = frag.y + fragYinc;
        if ((fragX2 >= clipX1) || (fragY2 >= clipY1)) {
            goto noWrite2;
        }

        pZ2 = pZ+zAdjStep;
        if (modeFlags & __GL_SHADE_DEPTH_TEST) {
            if (!(*GENACCEL(gc).__fastGenZStore)(zAccum, (__GLzValue *)pZ2 ))
                goto noWrite2;
        }

        if ((cfb->buf.flags & (NO_CLIP | DIB_FORMAT)) == DIB_FORMAT)
        {
            cfbX = __GL_UNBIAS_X(gc, fragX2)+cfb->buf.xOrigin;
            cfbY = __GL_UNBIAS_Y(gc, fragY2)+cfb->buf.yOrigin;
            if (!wglPixelVisible(cfbX, cfbY))
            {
                goto noWrite2;
            }
        }
        
	pPix2 = pPix + pixAdjStep;

        if ((cfb->buf.flags & DIB_FORMAT) == 0 && copyPix == 1)
        {
            cfbX += fragXinc;
            cfbY += fragYinc;
            gengc->pfnCopyPixels(gengc, cfb, cfbX, cfbY, copyPix, FALSE);
        }

        WRITE_PIXEL_GEN(pPix2, invCoverage, fragX2, fragY2);
        
noWrite2:

        if ((cfb->buf.flags & DIB_FORMAT) == 0)
        {
            gengc->pfnCopyPixels(gengc, cfb, cfbX, cfbY, copyPix, TRUE);
        }
        
        if (--w <= 0)
            return GL_TRUE;

        fraction += dfraction;
	if (fraction < 0) {
	    fraction &= ~0x80000000;
	    frag.x += xBig;
	    frag.y += yBig;
            pPix += gc->polygon.shader.sbufBig;
            pZ += gc->polygon.shader.zbufBig;
	} else {
	    frag.x += xLittle;
	    frag.y += yLittle;
            pPix += gc->polygon.shader.sbufLittle;
            pZ += gc->polygon.shader.zbufLittle;
	}

        if (modeFlags & __GL_SHADE_SMOOTH) {
            rAccum += CASTFIX(gc->polygon.shader.drdx);
            gAccum += CASTFIX(gc->polygon.shader.dgdx);
            bAccum += CASTFIX(gc->polygon.shader.dbdx);
            aAccum += CASTFIX(gc->polygon.shader.dadx);
        }

        if (modeFlags & __GL_SHADE_DEPTH_ITER) {
	    zAccum += gc->polygon.shader.dzdx;
        }
    }

    return GL_TRUE;
}

/************************************************************************/

#define FAST_A_LINE_BLEND \
{\
    GLint xLittle, xBig, yLittle, yBig;\
    BYTE *pPix;\
    USHORT *pZ;\
    __GLfragment frag;\
    __GLcolorBuffer *cfb = gc->drawBuffer;\
    LONG rAccum, gAccum, bAccum, aAccum;\
    LONG bytesPerPixel;\
    __GLzValue zAccum;\
    GLint fraction, dfraction;\
    GLint w;\
    GLuint modeFlags = gc->polygon.shader.modeFlags;\
    ULONG coverage = 0xff00;\
\
    ASSERTOPENGL((cfb->buf.flags &\
                  (DIB_FORMAT | NO_CLIP)) == (DIB_FORMAT | NO_CLIP),\
                 "FAST_A_LINE_BLEND on clipping surface\n");\
\
    fraction = gc->line.options.fraction;\
    dfraction = gc->line.options.dfraction;\
\
    xBig = gc->line.options.xBig;\
    yBig = gc->line.options.yBig;\
    xLittle = gc->line.options.xLittle;\
    yLittle = gc->line.options.yLittle;\
\
    frag.x = gc->line.options.xStart;\
    frag.y = gc->line.options.yStart;\
\
    bytesPerPixel = GENACCEL(gc).xMultiplier;\
\
    pPix = (BYTE *)((ULONG_PTR)cfb->buf.base +\
        (__GL_UNBIAS_Y(gc, frag.y) + cfb->buf.yOrigin) * cfb->buf.outerWidth +\
        (__GL_UNBIAS_X(gc, frag.x) + cfb->buf.xOrigin) * bytesPerPixel);\
\
    if (modeFlags & __GL_SHADE_DEPTH_TEST) {\
        zAccum = gc->polygon.shader.frag.z;\
\
	if( gc->modes.depthBits == 32 ) {\
	    pZ = (USHORT *)__GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),\
                                           frag.x, frag.y);\
\
	} else {\
	    pZ = (USHORT *)__GL_DEPTH_ADDR(&gc->depthBuffer,\
                                           (__GLz16Value*),\
                                           frag.x, frag.y);\
        }\
\
    }\
\
    rAccum = CASTFIX(gc->polygon.shader.frag.color.r);\
    gAccum = CASTFIX(gc->polygon.shader.frag.color.g);\
    bAccum = CASTFIX(gc->polygon.shader.frag.color.b);\
    aAccum = CASTFIX(gc->polygon.shader.frag.color.a);\
\
    w = gc->line.options.numPixels;\
    for (;;)\
    {\
        CHECK_PIXEL(gc, cfb, w, frag.x, frag.y);\
\
        if (modeFlags & __GL_SHADE_DEPTH_TEST) {\
            if (!(*GENACCEL(gc).__fastGenZStore)(zAccum, (__GLzValue *)pZ))\
                goto NoWrite;\
        }\
\
        BLEND_PIXEL(pPix, coverage, frag.x, frag.y);\
NoWrite:\
\
        if (--w <= 0)\
            return GL_TRUE;\
\
        fraction += dfraction;\
	if (fraction < 0) {\
	    fraction &= ~0x80000000;\
	    frag.x += xBig;\
	    frag.y += yBig;\
            pPix += gc->polygon.shader.sbufBig;\
            pZ += gc->polygon.shader.zbufBig;\
	} else {\
	    frag.x += xLittle;\
	    frag.y += yLittle;\
            pPix += gc->polygon.shader.sbufLittle;\
            pZ += gc->polygon.shader.zbufLittle;\
	}\
\
        if (modeFlags & __GL_SHADE_SMOOTH) {\
            rAccum += CASTFIX(gc->polygon.shader.drdx);\
            gAccum += CASTFIX(gc->polygon.shader.dgdx);\
            bAccum += CASTFIX(gc->polygon.shader.dbdx);\
            aAccum += CASTFIX(gc->polygon.shader.dadx);\
        }\
\
        if (modeFlags & __GL_SHADE_DEPTH_ITER) {\
	    zAccum += gc->polygon.shader.dzdx;\
        }\
    }\
\
    return GL_TRUE;\
}

#undef BPP
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#undef RMASK
#undef GMASK
#undef BMASK
#undef READ_PIX
#undef WRITE_PIX
#define RSHIFT          0
#define GSHIFT          3
#define BSHIFT          6
#define RBITS		3
#define GBITS		3
#define BBITS		2
#define RMASK (((1 << RBITS) - 1) << RSHIFT)
#define GMASK (((1 << GBITS) - 1) << GSHIFT)
#define BMASK (((1 << BBITS) - 1) << BSHIFT)
#define BPP             8
#define READ_PIX(pPix) \
    ((__GLGENcontext *)gc)->pajInvTranslateVector[*((BYTE *)(pPix))]
#define WRITE_PIX(pPix) \
    pPix[0] = ((__GLGENcontext *)gc)->xlatPalette[r | g | b]

GLboolean FASTCALL __fastGenBlendAliasLine332(__GLcontext *gc)
FAST_A_LINE_BLEND

#undef BPP
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#undef RMASK
#undef GMASK
#undef BMASK
#undef READ_PIX
#undef WRITE_PIX
#define RSHIFT         10
#define GSHIFT          5
#define BSHIFT          0
#define RBITS		5
#define GBITS		5
#define BBITS		5
#define RMASK (((1 << RBITS) - 1) << RSHIFT)
#define GMASK (((1 << GBITS) - 1) << GSHIFT)
#define BMASK (((1 << BBITS) - 1) << BSHIFT)
#define BPP             16
#define READ_PIX(pPix) \
    *((USHORT *)(pPix))
#define WRITE_PIX(pPix) \
    *((USHORT *)pPix) = (USHORT)(r | g | b)

GLboolean FASTCALL __fastGenBlendAliasLine555(__GLcontext *gc)
FAST_A_LINE_BLEND

#undef BPP
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#undef RMASK
#undef GMASK
#undef BMASK
#undef READ_PIX
#undef WRITE_PIX
#define RSHIFT         11
#define GSHIFT          5
#define BSHIFT          0
#define RBITS		5
#define GBITS		6
#define BBITS		5
#define RMASK (((1 << RBITS) - 1) << RSHIFT)
#define GMASK (((1 << GBITS) - 1) << GSHIFT)
#define BMASK (((1 << BBITS) - 1) << BSHIFT)
#define BPP             16
#define READ_PIX(pPix) \
    *((USHORT *)(pPix))
#define WRITE_PIX(pPix) \
    *((USHORT *)pPix) = (USHORT)(r | g | b)

GLboolean FASTCALL __fastGenBlendAliasLine565(__GLcontext *gc)
FAST_A_LINE_BLEND

/************************************************************************/

#define FAST_A_LINE_NO_BLEND \
{\
    GLint xLittle, xBig, yLittle, yBig;\
    BYTE *pPix;\
    USHORT *pZ;\
    __GLfragment frag;\
    __GLcolorBuffer *cfb = gc->drawBuffer;\
    LONG rAccum, gAccum, bAccum;\
    LONG bytesPerPixel;\
    __GLzValue zAccum;\
    GLint fraction, dfraction;\
    GLint w;\
    GLuint modeFlags = gc->polygon.shader.modeFlags;\
\
    ASSERTOPENGL((cfb->buf.flags &\
                  (DIB_FORMAT | NO_CLIP)) == (DIB_FORMAT | NO_CLIP),\
                 "FAST_A_LINE_NO_BLEND on clipping surface\n");\
\
    fraction = gc->line.options.fraction;\
    dfraction = gc->line.options.dfraction;\
\
    xBig = gc->line.options.xBig;\
    yBig = gc->line.options.yBig;\
    xLittle = gc->line.options.xLittle;\
    yLittle = gc->line.options.yLittle;\
\
    frag.x = gc->line.options.xStart;\
    frag.y = gc->line.options.yStart;\
\
    bytesPerPixel = GENACCEL(gc).xMultiplier;\
\
    pPix = (BYTE *)((ULONG_PTR)cfb->buf.base +\
        (__GL_UNBIAS_Y(gc, frag.y) + cfb->buf.yOrigin) * cfb->buf.outerWidth +\
        (__GL_UNBIAS_X(gc, frag.x) + cfb->buf.xOrigin) * bytesPerPixel);\
\
    if (modeFlags & __GL_SHADE_DEPTH_TEST) {\
        zAccum = gc->polygon.shader.frag.z;\
\
	if( gc->modes.depthBits == 32 ) {\
	    pZ = (USHORT *)__GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),\
                                           frag.x, frag.y);\
\
	} else {\
	    pZ = (USHORT *)__GL_DEPTH_ADDR(&gc->depthBuffer,\
                                           (__GLz16Value*),\
                                           frag.x, frag.y);\
        }\
\
    }\
\
    rAccum = CASTFIX(gc->polygon.shader.frag.color.r);\
    gAccum = CASTFIX(gc->polygon.shader.frag.color.g);\
    bAccum = CASTFIX(gc->polygon.shader.frag.color.b);\
\
    w = gc->line.options.numPixels;\
    for (;;)\
    {\
        CHECK_PIXEL(gc, cfb, w, frag.x, frag.y);\
\
        if (modeFlags & __GL_SHADE_DEPTH_TEST) {\
            if (!(*GENACCEL(gc).__fastGenZStore)(zAccum, (__GLzValue *)pZ))\
                goto NoWrite;\
        }\
\
        DITHER_PIXEL(pPix, frag.x, frag.y);\
NoWrite:\
\
        if (--w <= 0)\
            return GL_TRUE;\
\
        fraction += dfraction;\
	if (fraction < 0) {\
	    fraction &= ~0x80000000;\
	    frag.x += xBig;\
	    frag.y += yBig;\
            pPix += gc->polygon.shader.sbufBig;\
            pZ += gc->polygon.shader.zbufBig;\
	} else {\
	    frag.x += xLittle;\
	    frag.y += yLittle;\
            pPix += gc->polygon.shader.sbufLittle;\
            pZ += gc->polygon.shader.zbufLittle;\
	}\
\
        if (modeFlags & __GL_SHADE_SMOOTH) {\
            rAccum += CASTFIX(gc->polygon.shader.drdx);\
            gAccum += CASTFIX(gc->polygon.shader.dgdx);\
            bAccum += CASTFIX(gc->polygon.shader.dbdx);\
        }\
\
        if (modeFlags & __GL_SHADE_DEPTH_ITER) {\
	    zAccum += gc->polygon.shader.dzdx;\
        }\
    }\
\
    return GL_TRUE;\
}

#undef BPP
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#undef RMASK
#undef GMASK
#undef BMASK
#undef READ_PIX
#undef WRITE_PIX
#define RSHIFT          0
#define GSHIFT          3
#define BSHIFT          6
#define RBITS		3
#define GBITS		3
#define BBITS		2
#define RMASK (((1 << RBITS) - 1) << RSHIFT)
#define GMASK (((1 << GBITS) - 1) << GSHIFT)
#define BMASK (((1 << BBITS) - 1) << BSHIFT)
#define BPP             8
#define WRITE_PIX(pPix) \
    pPix[0] = ((__GLGENcontext *)gc)->xlatPalette[r | g | b]

GLboolean FASTCALL __fastGenNoBlendAliasLine332(__GLcontext *gc)
FAST_A_LINE_NO_BLEND

#undef BPP
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#undef RMASK
#undef GMASK
#undef BMASK
#undef READ_PIX
#undef WRITE_PIX
#define RSHIFT          10
#define GSHIFT          5
#define BSHIFT          0
#define RBITS		5
#define GBITS		5
#define BBITS		5
#define RMASK (((1 << RBITS) - 1) << RSHIFT)
#define GMASK (((1 << GBITS) - 1) << GSHIFT)
#define BMASK (((1 << BBITS) - 1) << BSHIFT)
#define BPP             16
#define WRITE_PIX(pPix) \
    *((USHORT *)pPix) = (USHORT)(r | g | b)

GLboolean FASTCALL __fastGenNoBlendAliasLine555(__GLcontext *gc)
FAST_A_LINE_NO_BLEND

#undef BPP
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#undef RMASK
#undef GMASK
#undef BMASK
#undef READ_PIX
#undef WRITE_PIX
#define RSHIFT          11
#define GSHIFT          5
#define BSHIFT          0
#define RBITS		5
#define GBITS		6
#define BBITS		5
#define RMASK (((1 << RBITS) - 1) << RSHIFT)
#define GMASK (((1 << GBITS) - 1) << GSHIFT)
#define BMASK (((1 << BBITS) - 1) << BSHIFT)
#define BPP             16
#define WRITE_PIX(pPix) \
    *((USHORT *)pPix) = (USHORT)(r | g | b)

GLboolean FASTCALL __fastGenNoBlendAliasLine565(__GLcontext *gc)
FAST_A_LINE_NO_BLEND

// WRITE_PIXEL_GEN handles both blending and no blending so this
// generic routine works for both of those cases
GLboolean FASTCALL __fastGenAliasLine(__GLcontext *gc)
{
    GLint xLittle, xBig, yLittle, yBig;
    BYTE *pPix;
    USHORT *pZ;
    __GLfragment frag;
    __GLcolorBuffer *cfb = gc->drawBuffer;
    LONG rAccum, gAccum, bAccum, aAccum;
    ULONG rMask, gMask, bMask;
    ULONG rShift, gShift, bShift;
    ULONG rBits, gBits, bBits;
    LONG bytesPerPixel;
    GLint cfbX, cfbY;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    __GLzValue zAccum;
    GLint fraction, dfraction;
    GLint w;
    GLuint modeFlags = gc->polygon.shader.modeFlags;
    
    // Only present for placeholder in WRITE_PIXEL_GEN macro
    ULONG coverage = 0xff00;

    w = gc->line.options.numPixels;

    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;

    frag.x = gc->line.options.xStart;
    frag.y = gc->line.options.yStart;

    bytesPerPixel = GENACCEL(gc).xMultiplier;

    if ((cfb->buf.flags & DIB_FORMAT) != 0)
    {
        pPix = (BYTE *)((ULONG_PTR)cfb->buf.base +
            (__GL_UNBIAS_Y(gc, frag.y) + cfb->buf.yOrigin) * cfb->buf.outerWidth + 
            (__GL_UNBIAS_X(gc, frag.x) + cfb->buf.xOrigin) * bytesPerPixel);
    }
    else
    {
        pPix = gengc->ColorsBits;
    }

    if (modeFlags & __GL_SHADE_DEPTH_TEST) {
        zAccum = gc->polygon.shader.frag.z;

	if( gc->modes.depthBits == 32 ) {
	    pZ = (USHORT *)__GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                                           frag.x, frag.y);
	} else {
	    pZ = (USHORT *)__GL_DEPTH_ADDR(&gc->depthBuffer,
                                           (__GLz16Value*),
                                           frag.x, frag.y);
        }
    }

    rShift = cfb->redShift;
    gShift = cfb->greenShift;
    bShift = cfb->blueShift;

    rMask = gc->modes.redMask;
    gMask = gc->modes.greenMask;
    bMask = gc->modes.blueMask;

    rBits = gc->modes.redBits;
    gBits = gc->modes.greenBits;
    bBits = gc->modes.blueBits;

    rAccum = CASTFIX(gc->polygon.shader.frag.color.r);
    gAccum = CASTFIX(gc->polygon.shader.frag.color.g);
    bAccum = CASTFIX(gc->polygon.shader.frag.color.b);
    aAccum = CASTFIX(gc->polygon.shader.frag.color.a);

    for (;;)
    {
        CHECK_PIXEL(gc, cfb, w, frag.x, frag.y);
        
        if (modeFlags & __GL_SHADE_DEPTH_TEST) {
            if (!(*GENACCEL(gc).__fastGenZStore)(zAccum, (__GLzValue *)pZ))
                goto NoWrite;
        }

        if ((cfb->buf.flags & (NO_CLIP | DIB_FORMAT)) == DIB_FORMAT)
        {
            cfbX = __GL_UNBIAS_X(gc, frag.x)+cfb->buf.xOrigin;
            cfbY = __GL_UNBIAS_Y(gc, frag.y)+cfb->buf.yOrigin;
            if (!wglPixelVisible(cfbX, cfbY))
            {
                goto NoWrite;
            }
        }
        
        if ((cfb->buf.flags & DIB_FORMAT) == 0)
        {
            cfbX = __GL_UNBIAS_X(gc, frag.x)+cfb->buf.xOrigin;
            cfbY = __GL_UNBIAS_Y(gc, frag.y)+cfb->buf.yOrigin;
            gengc->pfnCopyPixels(gengc, cfb, cfbX, cfbY, 1, FALSE);
        }

        WRITE_PIXEL_GEN(pPix, coverage, frag.x, frag.y);

        if ((cfb->buf.flags & DIB_FORMAT) == 0)
        {
            gengc->pfnCopyPixels(gengc, cfb, cfbX, cfbY, 1, TRUE);
        }

    NoWrite:
        
        if (--w <= 0)
            return GL_TRUE;
        
        fraction += dfraction;
	if (fraction < 0) {
	    fraction &= ~0x80000000;
	    frag.x += xBig;
	    frag.y += yBig;
            pPix += gc->polygon.shader.sbufBig;
            pZ += gc->polygon.shader.zbufBig;
	} else {
	    frag.x += xLittle;
	    frag.y += yLittle;
            pPix += gc->polygon.shader.sbufLittle;
            pZ += gc->polygon.shader.zbufLittle;
	}

        if (modeFlags & __GL_SHADE_SMOOTH) {
            rAccum += CASTFIX(gc->polygon.shader.drdx);
            gAccum += CASTFIX(gc->polygon.shader.dgdx);
            bAccum += CASTFIX(gc->polygon.shader.dbdx);
            aAccum += CASTFIX(gc->polygon.shader.dadx);
        }

        if (modeFlags & __GL_SHADE_DEPTH_ITER) {
	    zAccum += gc->polygon.shader.dzdx;
        }
    }

    return GL_TRUE;
}

/************************************************************************/

// Bits 0-1 are for pixel format
// Bit    2 is for GL_BLEND enable
// Bit    3 is for GL_LINE_SMOOTH_ENABLE
fastGenLineProc pfnFastGenLineProcs[] =
{
    __fastGenAliasLine,
    __fastGenNoBlendAliasLine332,
    __fastGenNoBlendAliasLine555,
    __fastGenNoBlendAliasLine565,
        
    __fastGenAliasLine,
    __fastGenBlendAliasLine332,
    __fastGenBlendAliasLine555,
    __fastGenBlendAliasLine565,
    
    __fastGenAntiAliasLine,
    __fastGenAntiAliasLine,
    __fastGenAntiAliasLine,
    __fastGenAntiAliasLine,
    
    __fastGenAntiAliasLine,
    __fastGenAntiAliasLine332,
    __fastGenAntiAliasLine555,
    __fastGenAntiAliasLine565
};

//
// Assumptions for accelerated lines:
//
// no blending, or (SRC, 1-SRC), or (SRC, 1)
// not both buffers
// not stippled
// not stenciled
// not textured
// not alpha-tested
// not masked, zmasked
// no logicOp
// not slow fog
// not color-indexed
// not wide

#define __SLOW_LINE_MODE_FLAGS \
    (__GL_SHADE_TEXTURE | __GL_SHADE_LINE_STIPPLE | \
     __GL_SHADE_STENCIL_TEST | __GL_SHADE_LOGICOP | \
     __GL_SHADE_ALPHA_TEST | __GL_SHADE_MASK | \
     __GL_SHADE_SLOW_FOG)

BOOL FASTCALL __glGenSetupEitherLines(__GLcontext *gc)
{
#ifdef _MCD_
    GENMCDSTATE *pMcdState = ((__GLGENcontext *) gc)->pMcdState;
#endif
    GLuint modeFlags = gc->polygon.shader.modeFlags;
    LONG bytesPerPixel;
    int fmt;
    BOOL bAccelerate =
        (((__GLGENcontext *)gc)->gsurf.pfd.cColorBits >= 8) &&
        (gc->state.raster.drawBuffer != GL_FRONT_AND_BACK) &&
        (gc->state.raster.drawBuffer != GL_NONE) &&
        ( ! ALPHA_WRITE_ENABLED( gc->drawBuffer ) ) &&
        (
         ((gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) &&
           (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_ITER) &&
           (gc->state.depth.writeEnable)) ||
          (!(gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) &&
           !(gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_ITER))
         ) &&
         (gc->transform.reasonableViewport) &&
         (gc->state.line.aliasedWidth == 1) &&
         (modeFlags & __GL_SHADE_RGB) &&
#ifdef GL_WIN_phong_shading
         !(modeFlags & __GL_SHADE_PHONG) &&
#endif //GL_WIN_phong_shading
#ifdef GL_WIN_specular_fog
         !(modeFlags & __GL_SHADE_SPEC_FOG) &&
#endif //GL_WIN_specular_fog
         (!(modeFlags & __SLOW_LINE_MODE_FLAGS)) &&
          (!(gc->state.enables.general & __GL_BLEND_ENABLE) ||
           ((gc->state.raster.blendSrc == GL_SRC_ALPHA) &&
            ((gc->state.raster.blendDst == GL_ONE_MINUS_SRC_ALPHA) ||
             (gc->state.raster.blendDst == GL_ONE)))
          );

#ifdef _MCD_
    bAccelerate &= (!pMcdState || (pMcdState->McdBuffers.mcdDepthBuf.bufFlags & MCDBUF_ENABLED));
#endif

    // Resort to soft code if we can't handle the line:

    if (!bAccelerate)
    {
        return FALSE;
    }
    else if (gc->state.enables.general & __GL_LINE_SMOOTH_ENABLE)
    {
        if (gc->state.hints.lineSmooth == GL_NICEST)
        {
            return FALSE;
        }
    }
    else if ((modeFlags & __GL_SHADE_CHEAP_FOG) &&
             (modeFlags & __GL_SHADE_SMOOTH_LIGHT) == 0)
    {
        // We only support cheap fog done by the front end, not
        // flat cheap fog done by the render procs
        return FALSE;
    }

    GENACCEL(gc).xMultiplier = bytesPerPixel = 
        (((__GLGENcontext *)gc)->gsurf.pfd.cColorBits + 7) >> 3;

    // Set up our local z-buffer procs:
    if (modeFlags & __GL_SHADE_DEPTH_ITER)
        __fastGenPickZStoreProc(gc);
    
    gc->procs.renderLine = __glGenRenderEitherLine;

    // Assume generic format
    fmt = 0;

    // For deep-color modes, we don't support most-significant-byte
    // formats...
    // For non-MSB deep-color modes, we only support generic rendering
    if (bytesPerPixel > 2)
    {
        if (((gc->drawBuffer->redShift > 16) ||
             (gc->drawBuffer->greenShift > 16) ||
             (gc->drawBuffer->blueShift > 16)))
        {
            return FALSE;
        }
        else
        {
            goto PickProc;
        }
    }

    // Just use generic acceleration if we're not 
    // dithering, since these are hardwired into the fastest routines...
    // We also only support unclipped surfaces in the fastest routines

    if (!(modeFlags & __GL_SHADE_DITHER) ||
        (gc->drawBuffer->buf.flags & (DIB_FORMAT | NO_CLIP)) !=
        (DIB_FORMAT | NO_CLIP))
    {
        goto PickProc;
    }

    // Now, check for supported color formats for fastest modes:

    if ((bytesPerPixel == 1) &&
        (gc->drawBuffer->redShift   == 0) &&
        (gc->drawBuffer->greenShift == 3) &&
        (gc->drawBuffer->blueShift  == 6))
    {
        fmt = 1;
    }
    else if (bytesPerPixel == 2)
    {
        if ((gc->drawBuffer->greenShift == 5) &&
            (gc->drawBuffer->blueShift  == 0))
        {
            if (gc->drawBuffer->redShift == 10)
            {
                fmt = 2;
            }
            else if (gc->drawBuffer->redShift == 11)
            {
                fmt = 3;
            }
        }
    }

 PickProc:
    if (gc->state.enables.general & __GL_BLEND_ENABLE)
    {
        fmt += 4;
    }
    if (gc->state.enables.general & __GL_LINE_SMOOTH_ENABLE)
    {
        fmt += 8;
    }
    
    GENACCEL(gc).__fastGenLineProc = pfnFastGenLineProcs[fmt];

    if (gc->state.line.aliasedWidth != 1)
    {
        GENACCEL(gc).__fastGenInitLineData = __glInitLineData;
    }
    else
    {
        GENACCEL(gc).__fastGenInitLineData = __glInitThinLineData;
    }
    
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\genci.h ===
#ifndef __GENCI_H__
#define __GENCI_H__

void FASTCALL __glGenInitCI(__GLcontext *gc, __GLcolorBuffer *cfb, GLenum type);
void FASTCALL __glGenFreeCI(__GLcontext *gc, __GLcolorBuffer *cfb);
GLuint FASTCALL ColorToIndex( __GLGENcontext *genGc, GLuint color );

#endif /* !__GENCI_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\genattri.c ===
#include "precomp.h"
#pragma hdrstop

void APIPRIVATE __glim_Enable(GLenum cap)
{
    __GL_SETUP_NOT_IN_BEGIN();

    switch (cap) {
      case GL_ALPHA_TEST:
        if (gc->state.enables.general & __GL_ALPHA_TEST_ENABLE) return;
        gc->state.enables.general |= __GL_ALPHA_TEST_ENABLE;
        break;
      case GL_BLEND:
        if (gc->state.enables.general & __GL_BLEND_ENABLE) return;
        gc->state.enables.general |= __GL_BLEND_ENABLE;
        break;
      case GL_COLOR_MATERIAL:
        if (gc->state.enables.general & __GL_COLOR_MATERIAL_ENABLE) return;
        gc->state.enables.general |= __GL_COLOR_MATERIAL_ENABLE;
        ComputeColorMaterialChange(gc);
        (*gc->procs.pickColorMaterialProcs)(gc);
        (*gc->procs.applyColor)(gc);
        break;
      case GL_CULL_FACE:
        if (gc->state.enables.general & __GL_CULL_FACE_ENABLE) return;
        gc->state.enables.general |= __GL_CULL_FACE_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POLYGON);
        
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, ENABLES);
#endif
        return;
      case GL_DEPTH_TEST:
        if (gc->state.enables.general & __GL_DEPTH_TEST_ENABLE) return;
        gc->state.enables.general |= __GL_DEPTH_TEST_ENABLE;
        if (gc->modes.depthBits) {
            if (!gc->modes.haveDepthBuffer)
                LazyAllocateDepth(gc);
                // XXX if this fails should we be setting the enable bit?
        } else {
            gc->state.depth.testFunc = GL_ALWAYS;
#ifdef _MCD_
            MCD_STATE_DIRTY(gc, DEPTHTEST);
#endif
        }
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_DEPTH);
        break;
      case GL_POLYGON_OFFSET_POINT:
        if (gc->state.enables.general & __GL_POLYGON_OFFSET_POINT_ENABLE) 
            return;
        gc->state.enables.general |= __GL_POLYGON_OFFSET_POINT_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POINT);
        break;
      case GL_POLYGON_OFFSET_LINE:
        if (gc->state.enables.general & __GL_POLYGON_OFFSET_LINE_ENABLE)
            return;
        gc->state.enables.general |= __GL_POLYGON_OFFSET_LINE_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LINE);
        break;
      case GL_POLYGON_OFFSET_FILL:
        if (gc->state.enables.general & __GL_POLYGON_OFFSET_FILL_ENABLE)
            return;
        gc->state.enables.general |= __GL_POLYGON_OFFSET_FILL_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POLYGON);
        break;
      case GL_DITHER:
        if (gc->state.enables.general & __GL_DITHER_ENABLE) return;
        gc->state.enables.general |= __GL_DITHER_ENABLE;
        break;
#ifdef GL_WIN_specular_fog
      case GL_FOG_SPECULAR_TEXTURE_WIN:
        if (gc->state.enables.general & __GL_FOG_SPEC_TEX_ENABLE) return;
        gc->state.enables.general |= __GL_FOG_SPEC_TEX_ENABLE;
        break;
#endif //GL_WIN_specular_fog
      case GL_FOG:
        if (gc->state.enables.general & __GL_FOG_ENABLE) return;
        gc->state.enables.general |= __GL_FOG_ENABLE;
        break;
      case GL_LIGHTING:
        if (gc->state.enables.general & __GL_LIGHTING_ENABLE) return;
        gc->state.enables.general |= __GL_LIGHTING_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LIGHTING);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, ENABLES);
#endif
#ifdef NT
        ComputeColorMaterialChange(gc);
#endif
        (*gc->procs.pickColorMaterialProcs)(gc);
        (*gc->procs.applyColor)(gc);
        return;
      case GL_LINE_SMOOTH:
        if (gc->state.enables.general & __GL_LINE_SMOOTH_ENABLE) return;
        gc->state.enables.general |= __GL_LINE_SMOOTH_ENABLE;
        break;
      case GL_LINE_STIPPLE:
        if (gc->state.enables.general & __GL_LINE_STIPPLE_ENABLE) return;
        gc->state.enables.general |= __GL_LINE_STIPPLE_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LINE);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, ENABLES);
#endif
        return;
      case GL_INDEX_LOGIC_OP:
        if (gc->state.enables.general & __GL_INDEX_LOGIC_OP_ENABLE) return;
        gc->state.enables.general |= __GL_INDEX_LOGIC_OP_ENABLE;
        break;
      case GL_COLOR_LOGIC_OP:
        if (gc->state.enables.general & __GL_COLOR_LOGIC_OP_ENABLE) return;
        gc->state.enables.general |= __GL_COLOR_LOGIC_OP_ENABLE;
        break;
      case GL_NORMALIZE:
        if (gc->state.enables.general & __GL_NORMALIZE_ENABLE) return;
        gc->state.enables.general |= __GL_NORMALIZE_ENABLE;
        break;
      case GL_POINT_SMOOTH:
        if (gc->state.enables.general & __GL_POINT_SMOOTH_ENABLE) return;
        gc->state.enables.general |= __GL_POINT_SMOOTH_ENABLE;
        break;
      case GL_POLYGON_SMOOTH:
        if (gc->state.enables.general & __GL_POLYGON_SMOOTH_ENABLE) return;
        gc->state.enables.general |= __GL_POLYGON_SMOOTH_ENABLE;
        break;
      case GL_POLYGON_STIPPLE:
        if (gc->state.enables.general & __GL_POLYGON_STIPPLE_ENABLE) return;
        gc->state.enables.general |= __GL_POLYGON_STIPPLE_ENABLE;
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_POLYGON);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, ENABLES);
#endif
        return;
      case GL_SCISSOR_TEST:
        if (gc->state.enables.general & __GL_SCISSOR_TEST_ENABLE) return;
        gc->state.enables.general |= __GL_SCISSOR_TEST_ENABLE;
#ifdef NT
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, SCISSOR);
#endif
        // applyViewport does both
        (*gc->procs.applyViewport)(gc);
#else
        (*gc->procs.computeClipBox)(gc);
        (*gc->procs.applyScissor)(gc);
#endif
        break;
      case GL_STENCIL_TEST:
        if (gc->state.enables.general & __GL_STENCIL_TEST_ENABLE) return;
        gc->state.enables.general |= __GL_STENCIL_TEST_ENABLE;

        if (!gc->modes.haveStencilBuffer && gc->modes.stencilBits) {
            LazyAllocateStencil(gc);
            // XXX if this fails should we be setting the enable bit?
        }
        break;
      case GL_TEXTURE_1D:
        if (gc->state.enables.general & __GL_TEXTURE_1D_ENABLE) return;
        gc->state.enables.general |= __GL_TEXTURE_1D_ENABLE;
        break;
      case GL_TEXTURE_2D:
        if (gc->state.enables.general & __GL_TEXTURE_2D_ENABLE) return;
        gc->state.enables.general |= __GL_TEXTURE_2D_ENABLE;
        break;
      case GL_AUTO_NORMAL:
        if (gc->state.enables.general & __GL_AUTO_NORMAL_ENABLE) return;
        gc->state.enables.general |= __GL_AUTO_NORMAL_ENABLE;
        break;
      case GL_TEXTURE_GEN_S:
        if (gc->state.enables.general & __GL_TEXTURE_GEN_S_ENABLE) return;
        gc->state.enables.general |= __GL_TEXTURE_GEN_S_ENABLE;
        break;
      case GL_TEXTURE_GEN_T:
        if (gc->state.enables.general & __GL_TEXTURE_GEN_T_ENABLE) return;
        gc->state.enables.general |= __GL_TEXTURE_GEN_T_ENABLE;
        break;
      case GL_TEXTURE_GEN_R:
        if (gc->state.enables.general & __GL_TEXTURE_GEN_R_ENABLE) return;
        gc->state.enables.general |= __GL_TEXTURE_GEN_R_ENABLE;
        break;
      case GL_TEXTURE_GEN_Q:
        if (gc->state.enables.general & __GL_TEXTURE_GEN_Q_ENABLE) return;
        gc->state.enables.general |= __GL_TEXTURE_GEN_Q_ENABLE;
        break;
#ifdef GL_WIN_multiple_textures
    case GL_TEXCOMBINE_CLAMP_WIN:
        if (gc->state.enables.general & __GL_TEXCOMBINE_CLAMP_ENABLE)
        {
            return;
        }
        gc->state.enables.general |= __GL_TEXCOMBINE_CLAMP_ENABLE;
        break;
#endif // GL_WIN_multiple_textures
#ifdef GL_EXT_flat_paletted_lighting
      case GL_PALETTED_LIGHTING_EXT:
        gc->state.enables.general |= __GL_PALETTED_LIGHTING_ENABLE;
        break;
#endif

      case GL_CLIP_PLANE0: case GL_CLIP_PLANE1:
      case GL_CLIP_PLANE2: case GL_CLIP_PLANE3:
      case GL_CLIP_PLANE4: case GL_CLIP_PLANE5:
        cap -= GL_CLIP_PLANE0;
        if (gc->state.enables.clipPlanes & (1 << cap)) return;
        gc->state.enables.clipPlanes |= (1 << cap);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, CLIPCTRL);
#endif
        break;
      case GL_LIGHT0: case GL_LIGHT1:
      case GL_LIGHT2: case GL_LIGHT3:
      case GL_LIGHT4: case GL_LIGHT5:
      case GL_LIGHT6: case GL_LIGHT7:
        cap -= GL_LIGHT0;
        if (gc->state.enables.lights & (1 << cap)) return;
        gc->state.enables.lights |= (1 << cap);
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_LIGHTING);
        MCD_STATE_DIRTY(gc, LIGHTS);
        return;
      case GL_MAP1_COLOR_4:
      case GL_MAP1_NORMAL:
      case GL_MAP1_INDEX:
      case GL_MAP1_TEXTURE_COORD_1: case GL_MAP1_TEXTURE_COORD_2:
      case GL_MAP1_TEXTURE_COORD_3: case GL_MAP1_TEXTURE_COORD_4:
      case GL_MAP1_VERTEX_3: case GL_MAP1_VERTEX_4:
        cap = __GL_EVAL1D_INDEX(cap);
        if (gc->state.enables.eval1 & (GLushort) (1 << cap)) return;
        gc->state.enables.eval1 |= (GLushort) (1 << cap);
        break;
      case GL_MAP2_COLOR_4:
      case GL_MAP2_NORMAL:
      case GL_MAP2_INDEX:
      case GL_MAP2_TEXTURE_COORD_1: case GL_MAP2_TEXTURE_COORD_2:
      case GL_MAP2_TEXTURE_COORD_3: case GL_MAP2_TEXTURE_COORD_4:
      case GL_MAP2_VERTEX_3: case GL_MAP2_VERTEX_4:
        cap = __GL_EVAL2D_INDEX(cap);
        if (gc->state.enables.eval2 & (GLushort) (1 << cap)) return;
        gc->state.enables.eval2 |= (GLushort) (1 << cap);
        break;

      default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }
    __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, ENABLES);
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\genci.c ===
#include "precomp.h"
#pragma hdrstop

#include "genclear.h"

// Null stores...

static void FASTCALL Store_NOT(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
}

static GLboolean FASTCALL StoreSpanNone(__GLcontext *gc)
{
    return GL_FALSE;
}


/* XXX! Current policy for >8-bit ColorIndex:

    - The index<->Color mapping will be kept in gengc->pajTranslateVector,
      viewed as an array of longs.  The first entry in the array will be
      the number of valid entries in the table.
    - gengc->pajTranslateVector will never be NULL, it is always allocated
      at MakeCurrent, and tracks any palette changes.
    - the minimum indexBits is 8 if the pixel format is > 8 bits deep
*/

/******************************Public*Routine******************************\
* dibSetPixelCI
*
* Special case version of GDI SetPixel API for use when the destination
* surface is a DIB and rendering in color index mode.
*
* This function *must* be used in lieu of gdiCopyPixels if we are
* accessing the screen directly as it is not safe to call GDI entry
* points with a screen lock
*
* History:
*  29-May-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void dibSetPixelCI(__GLGENcontext *gengc, __GLcolorBuffer *cfb,
                    GLint x, GLint y, DWORD dwColor)
{
    GLuint flags;

    flags = cfb->buf.flags;

    ASSERTOPENGL(flags & DIB_FORMAT,
                 "dibSetPixelCI called on non-DIB\n");
    
    if ( (flags & NO_CLIP) || wglPixelVisible(x, y) )
    {
        if ( gengc->gsurf.pfd.cColorBits > 4 )
        {
            VOID *pvDib;
            UINT cjPixel = gengc->gsurf.pfd.cColorBits >> 3;

            pvDib = (VOID *) (((BYTE *) gengc->gc.front->buf.base) +
                              gengc->gc.front->buf.outerWidth * y +
                              cjPixel * x);

            if ( gengc->gsurf.pfd.cColorBits == 8 )
                *((BYTE *) pvDib) = gengc->pajTranslateVector[dwColor];
            else
            {
                GLuint *pTrans = ((GLuint *) gengc->pajTranslateVector) + 1;

                dwColor &= cfb->redMax;

                switch (gengc->gsurf.pfd.cColorBits)
                {
                case 16:
                    *((WORD *) pvDib) = (WORD) pTrans[dwColor];
                    break;
                case 24:
                    Copy3Bytes(pvDib, &(pTrans[dwColor]));
                    break;
                case 32:
                    *((DWORD *) pvDib) = (DWORD) pTrans[dwColor];
                    break;
                default:
                    WARNING1("dibSetPixelCI: bad cColorBits = %ld\n",
                             gengc->gsurf.pfd.cColorBits);
                    break;
                }
            }
        }
        else
        {
            BYTE *puj = (BYTE *)((ULONG_PTR)cfb->buf.base +
                              (y*cfb->buf.outerWidth) + (x >> 1));

            dwColor = gengc->pajTranslateVector[dwColor & 0xf] & 0xf;
            if( x & 1 )
                *puj = (*puj & 0xf0) | (BYTE) dwColor;
            else
                *puj = (*puj & 0x0f) | (BYTE) (dwColor << 4);
        }
    }
}

/*
** No dither, no logicOp.
*/
static void FASTCALL Store(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    __GLcontext *gc      = cfb->buf.gc;
    __GLGENcontext *genGc = (__GLGENcontext *)gc;
    COLORREF Cr;
    DWORD index;

    DBGLEVEL(32, "Store(CI)\n");

    index = (DWORD) (frag->color.r + __glHalf);

    Cr = PALETTEINDEX(index);

    x = __GL_UNBIAS_X(gc, frag->x);
    y = __GL_UNBIAS_Y(gc, frag->y);

    if ( !(genGc->fsLocks & LOCKFLAG_FRONT_BUFFER) )
        SetPixel( CURRENT_DC, x, y, Cr );
    else
        dibSetPixelCI(genGc, cfb, x, y, index);

}
/* XXX! The Store_* routines do not handle double buffering.  Gilman
	has said that they will not be compatible with his 'cursor
	tear-down' strategy.  Therefore we probably won't use them.
	BUT, they are about 30% faster than their Display*Store
	counterparts, so we'll keep them around for further study
*/

/*
** Dither, no logicOp.
*/
static void FASTCALL Store_D(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    __GLcontext *gc      = cfb->buf.gc;
    __GLGENcontext *genGc = (__GLGENcontext *)gc;
    COLORREF Cr;
    DWORD index;


    DBGLEVEL(32, "Store_D\n");

    index = (DWORD) (frag->color.r + __glHalf);

    Cr = PALETTEINDEX(index);

    x = __GL_UNBIAS_X(gc, frag->x);
    y = __GL_UNBIAS_Y(gc, frag->y);

    if ( !(genGc->fsLocks & LOCKFLAG_FRONT_BUFFER) )
        SetPixel( CURRENT_DC, x, y, Cr );
    else
        dibSetPixelCI(genGc, cfb, x, y, index);
}

/*
** No dither, logicOp
*/
static void FASTCALL Store_L(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    __GLcontext *gc      = cfb->buf.gc;
    __GLGENcontext *genGc = (__GLGENcontext *)gc;
    COLORREF Cr;
    DWORD index;

    DBGLEVEL(32, "Store_L\n");

    index = (DWORD) (frag->color.r + __glHalf);

    Cr = PALETTEINDEX(index);

    x = __GL_UNBIAS_X(gc, frag->x);
    y = __GL_UNBIAS_Y(gc, frag->y);

    if ( !(genGc->fsLocks & LOCKFLAG_FRONT_BUFFER) )
        SetPixel( CURRENT_DC, x, y, Cr );
    else
        dibSetPixelCI(genGc, cfb, x, y, index);
}

/*
** Dither, logicOp
*/
static void FASTCALL Store_DL(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    __GLcontext *gc      = cfb->buf.gc;
    __GLGENcontext *genGc = (__GLGENcontext *)gc;
    COLORREF Cr;
    DWORD index;

    DBGLEVEL(32, "Store_DL\n");

    index = (DWORD) (frag->color.r + __glHalf);

    Cr = PALETTEINDEX(index);

    x = __GL_UNBIAS_X(gc, frag->x);
    y = __GL_UNBIAS_Y(gc, frag->y);

    if ( !(genGc->fsLocks & LOCKFLAG_FRONT_BUFFER) )
        SetPixel( CURRENT_DC, x, y, Cr );
    else
        dibSetPixelCI(genGc, cfb, x, y, index);
}

GLuint FASTCALL ColorToIndex( __GLGENcontext *genGc, GLuint color )
{
    int i, imax;
    GLuint *pTrans = (GLuint *) genGc->pajTranslateVector;

    color &= genGc->gc.modes.rgbMask;

    imax = *pTrans++;  // first element of pTrans is # entries

    for( i=0; i<imax; i++ ) {
	if( color == *pTrans++ )
	    return i;
    }
    return 0;
}

GLuint FASTCALL DoLogicOp( GLenum logicOp, GLuint SrcColor, GLuint DstColor )
{
    GLuint result;

    switch (logicOp) {
	case GL_CLEAR:         result = 0; break;
	case GL_AND:           result = SrcColor & DstColor; break;
	case GL_AND_REVERSE:   result = SrcColor & (~DstColor); break;
	case GL_COPY:          result = SrcColor; break;
	case GL_AND_INVERTED:  result = (~SrcColor) & DstColor; break;
	case GL_NOOP:          result = DstColor; break;
	case GL_XOR:           result = SrcColor ^ DstColor; break;
	case GL_OR:            result = SrcColor | DstColor; break;
	case GL_NOR:           result = ~(SrcColor | DstColor); break;
	case GL_EQUIV:         result = ~(SrcColor ^ DstColor); break;
	case GL_INVERT:        result = ~DstColor; break;
	case GL_OR_REVERSE:    result = SrcColor | (~DstColor); break;
	case GL_COPY_INVERTED: result = ~SrcColor; break;
	case GL_OR_INVERTED:   result = (~SrcColor) | DstColor; break;
	case GL_NAND:          result = ~(SrcColor & DstColor); break;
	case GL_SET:           result = (GLuint)~0; break;
    }
    return result;
}

/************************************************************************/

void FASTCALL DIBIndex4CIStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    GLubyte *puj;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    __GLfloat inc;
    GLuint enables = gc->state.enables.general;
    GLubyte index;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;

    inc = (enables & __GL_DITHER_ENABLE) ?
          fDitherIncTable[__GL_DITHER_INDEX(frag->x, frag->y)] : __glHalf;

    if ( (cfb->buf.flags & NO_CLIP) ||
            (*gengc->pfnPixelVisible)(x, y) ) {
    	index = (BYTE) (frag->color.r + inc);
        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x >> 1));

	if( cfb->buf.flags & NEED_FETCH ) {
	    GLubyte DstIndex;

            if (x & 1)
                DstIndex = gengc->pajInvTranslateVector[*puj & 0x0f];
            else
                DstIndex = gengc->pajInvTranslateVector[(*puj & 0xf0) >> 4];

    	    // apply logicop

    	    if (enables & __GL_INDEX_LOGIC_OP_ENABLE) {
                
	        index = (GLubyte) DoLogicOp( gc->state.raster.logicOp, 
					 (GLuint) index, (GLuint) DstIndex );
                index &= 0xf;
    	    }

    	    // apply indexmask

	    if( cfb->buf.flags & INDEXMASK_ON ) {
		index = (GLubyte)((index & cfb->sourceMask) | (DstIndex & cfb->destMask));
	    }
	}
	index = gengc->pajTranslateVector[index & 0xf] & 0xf;
	if( x & 1 )
	    *puj = (*puj & 0xf0) | index;
	else
	    *puj = (*puj & 0x0f) | (index << 4);
    }
}

// Put fragment into created DIB and call copybits for one pixel
void FASTCALL DisplayIndex4CIStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    GLubyte *puj;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    __GLfloat inc;
    GLuint enables = gc->state.enables.general;
    GLubyte index;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;

    inc = (enables & __GL_DITHER_ENABLE) ?
          fDitherIncTable[__GL_DITHER_INDEX(frag->x, frag->y)] : __glHalf;

    index = (BYTE) (frag->color.r + inc);
    puj = gengc->ColorsBits;

    if( cfb->buf.flags & NEED_FETCH ) {
        GLubyte DstIndex;

        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
        DstIndex = gengc->pajInvTranslateVector[(*puj & 0xf0) >> 4];

        // apply logicop

        if (enables & __GL_INDEX_LOGIC_OP_ENABLE) {

            index = (GLubyte) DoLogicOp( gc->state.raster.logicOp, 
					 (GLuint) index, (GLuint) DstIndex );
            index &= 0xf;
        }

        // apply indexmask

        if( cfb->buf.flags & INDEXMASK_ON ) {
            index = (GLubyte)((index & cfb->sourceMask) | (DstIndex & cfb->destMask));
        }
    }
    *puj = gengc->pajTranslateVector[index & 0xf] << 4;
    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, TRUE);
}

/************************************************************************/

void FASTCALL DIBIndex8CIStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    GLubyte *puj;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    __GLfloat inc;
    GLuint enables = gc->state.enables.general;
    GLubyte index;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;

    inc = (enables & __GL_DITHER_ENABLE) ?
          fDitherIncTable[__GL_DITHER_INDEX(frag->x, frag->y)] : __glHalf;

    if ( (cfb->buf.flags & NO_CLIP) ||
            (*gengc->pfnPixelVisible)(x, y) ) {
    	index = (BYTE) (frag->color.r + inc);
        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base + (y*cfb->buf.outerWidth) + x);

	if( cfb->buf.flags & NEED_FETCH ) {
	    GLubyte DstIndex = gengc->pajInvTranslateVector[*puj];

    	    // apply logicop

    	    if (enables & __GL_INDEX_LOGIC_OP_ENABLE) {

	        index = (GLubyte) DoLogicOp( gc->state.raster.logicOp, 
					 (GLuint) index, (GLuint) DstIndex );
    	    }

    	    // apply indexmask

	    if( cfb->buf.flags & INDEXMASK_ON ) {
                index = (GLubyte)((DstIndex & cfb->destMask) | (index & cfb->sourceMask));
	    }
	}

        *puj = gengc->pajTranslateVector[index];
    }
}

/************************************************************************/

void FASTCALL DisplayIndex8CIStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    GLubyte *puj;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    __GLfloat inc;
    GLuint enables = gc->state.enables.general;
    GLubyte index;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;

    inc = (enables & __GL_DITHER_ENABLE) ?
          fDitherIncTable[__GL_DITHER_INDEX(frag->x, frag->y)] : __glHalf;

    index = (BYTE) (frag->color.r + inc);
    puj = gengc->ColorsBits;

    if( cfb->buf.flags & NEED_FETCH ) {
        GLubyte DstIndex;

        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
        DstIndex = gengc->pajInvTranslateVector[*puj];

        // apply logicop

        if (enables & __GL_INDEX_LOGIC_OP_ENABLE) {
            index = (GLubyte) DoLogicOp( gc->state.raster.logicOp, 
					 (GLuint) index, (GLuint) DstIndex );
        }

        // apply indexmask

        if( cfb->buf.flags & INDEXMASK_ON ) {
            index = (GLubyte)((DstIndex & cfb->destMask) | (index & cfb->sourceMask));
        }
    }

    *puj = gengc->pajTranslateVector[index];
    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, TRUE);
}

/************************************************************************/

void FASTCALL DIBRGBCIStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    GLubyte *puj;
    GLuint index;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint enables = gc->state.enables.general;
    GLuint color, *pTrans;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;

    if ( (cfb->buf.flags & NO_CLIP) ||
            (*gengc->pfnPixelVisible)(x, y) ) {

    	index = (GLuint) (frag->color.r + __glHalf);
        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x * 3));
        pTrans = ((GLuint *) gengc->pajTranslateVector) + 1;

	if( cfb->buf.flags & NEED_FETCH ) {
    	    GLuint DstIndex; // represents both RGB and index

	    Copy3Bytes( &DstIndex, puj );
	    DstIndex = ColorToIndex( gengc, DstIndex );

    	    // apply logicop

    	    if (enables & __GL_INDEX_LOGIC_OP_ENABLE) {
	        index = (GLuint) DoLogicOp( gc->state.raster.logicOp, 
					 (GLuint) index, (GLuint) DstIndex);
    	    }

    	    // apply indexmask

	    if( cfb->buf.flags & INDEXMASK_ON ) {
                index = ((GLuint) DstIndex & cfb->destMask) |
		        (index & cfb->sourceMask);
	    }
	}
	index &= cfb->redMax;     // ceiling
	color = pTrans[index];  // guaranteed to be in range
	Copy3Bytes( puj, &color );
    }
}

/************************************************************************/

void FASTCALL DisplayRGBCIStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    GLubyte *puj;
    GLuint index, color, *pTrans;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint enables = gc->state.enables.general;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;

    index = (GLuint) (frag->color.r + __glHalf);
    puj = gengc->ColorsBits;
    pTrans = (GLuint *) gengc->pajTranslateVector;

    if( cfb->buf.flags & NEED_FETCH ) {
        GLuint DstIndex; // represents both RGB and index

        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
        Copy3Bytes( &DstIndex, puj );
        DstIndex = ColorToIndex( gengc, DstIndex );

        // apply logicop

        if (enables & __GL_INDEX_LOGIC_OP_ENABLE) {
            index = (GLuint) DoLogicOp( gc->state.raster.logicOp, 
                                        (GLuint) index, (GLuint) DstIndex );
        }

        // apply indexmask

        if( cfb->buf.flags & INDEXMASK_ON ) {
            index = ((GLuint) DstIndex & cfb->destMask) |
                (index & cfb->sourceMask);
        }
    }

    // Get RGB values that correspond to index

    index &= cfb->redMax; // ceiling
    color = pTrans[index+1];  // guaranteed to be in range
    Copy3Bytes( puj, &color );
    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, TRUE);
}

/************************************************************************/

void FASTCALL DIBBitfield16CIStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    GLushort index, *pus;
    GLuint *pTrans;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    __GLfloat inc;
    GLuint enables = gc->state.enables.general;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;

    inc = (enables & __GL_DITHER_ENABLE) ?
          fDitherIncTable[__GL_DITHER_INDEX(frag->x, frag->y)] : __glHalf;

    if ( (cfb->buf.flags & NO_CLIP) ||
            (*gengc->pfnPixelVisible)(x, y) ) {

    	index = (GLushort) (frag->color.r + inc);
        pus = (GLushort *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x << 1));
        pTrans = (GLuint *) gengc->pajTranslateVector;

	if( cfb->buf.flags & NEED_FETCH ) {
    	    GLushort DstIndex; // represents both RGB and index

            DstIndex = *pus;
	    DstIndex = (GLushort) ColorToIndex( gengc, (GLuint) DstIndex );

    	    // apply logicop

    	    if (enables & __GL_INDEX_LOGIC_OP_ENABLE) {
	        index = (GLushort) DoLogicOp( gc->state.raster.logicOp, 
					 (GLuint) index, (GLuint) DstIndex);
    	    }

    	    // apply indexmask

	    if( cfb->buf.flags & INDEXMASK_ON ) {
                index = (GLushort)((DstIndex & cfb->destMask) | (index & cfb->sourceMask));
	    }
	}
	index &= cfb->redMax;
	*pus = (GLushort) pTrans[index+1];
    }
}

// Put fragment into created DIB and call copybits for one pixel
void FASTCALL DisplayBitfield16CIStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    GLushort index, *pus;
    GLuint *pTrans;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    __GLfloat inc;
    GLuint enables = gc->state.enables.general;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;

    inc = (enables & __GL_DITHER_ENABLE) ?
          fDitherIncTable[__GL_DITHER_INDEX(frag->x, frag->y)] : __glHalf;

    index = (GLushort) (frag->color.r + inc);
    pus = gengc->ColorsBits;
    pTrans = (GLuint *) gengc->pajTranslateVector;

    if( cfb->buf.flags & NEED_FETCH ) {
        GLushort DstIndex; // represents both RGB and index

        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
        DstIndex = *pus;
        DstIndex = (GLushort) ColorToIndex( gengc, (GLuint) DstIndex );

        // apply logicop

        if (enables & __GL_INDEX_LOGIC_OP_ENABLE) {
            index = (GLushort) DoLogicOp( gc->state.raster.logicOp, 
                                          (GLuint) index, (GLuint) DstIndex);
        }

        // apply indexmask

        if( cfb->buf.flags & INDEXMASK_ON ) {
            index = (GLushort)((DstIndex & cfb->destMask) | (index & cfb->sourceMask));
        }
    }
    index &= cfb->redMax;
    *pus = (GLushort) pTrans[index+1];
    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, TRUE);
}

/************************************************************************/

void FASTCALL DIBBitfield32CIStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    GLuint index, *pul, *pTrans;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint enables = gc->state.enables.general;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;

    if ( (cfb->buf.flags & NO_CLIP) ||
            (*gengc->pfnPixelVisible)(x, y) ) {

    	index = (GLuint) (frag->color.r + __glHalf);
        pul = (GLuint *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x << 2));
        pTrans = ((GLuint *) gengc->pajTranslateVector) + 1;

	if( cfb->buf.flags & NEED_FETCH ) {
    	    GLuint DstIndex; // represents both RGB and index

            DstIndex = ColorToIndex( gengc, *pul );

    	    // apply logicop

    	    if (enables & __GL_INDEX_LOGIC_OP_ENABLE) {
	        index = (GLuint) DoLogicOp( gc->state.raster.logicOp, index,
						 DstIndex );
    	    }

    	    // apply indexmask

	    if( cfb->buf.flags & INDEXMASK_ON ) {
                index = (GLuint)((DstIndex & cfb->destMask) | (index & cfb->sourceMask));
	    }
	}
	index &= cfb->redMax;
	*pul = pTrans[index];
    }
}

// Put fragment into created DIB and call copybits for one pixel
void FASTCALL DisplayBitfield32CIStore(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
    GLint x, y;
    GLuint index, *pul, *pTrans;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint enables = gc->state.enables.general;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;

    index = (GLuint) (frag->color.r + __glHalf);
    pul = gengc->ColorsBits;
    pTrans = ((GLuint *) gengc->pajTranslateVector) + 1;

    if( cfb->buf.flags & NEED_FETCH ) {
        GLuint DstIndex; // represents both RGB and index

        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
        DstIndex = ColorToIndex( gengc, *pul );
 
        // apply logicop

        if (enables & __GL_INDEX_LOGIC_OP_ENABLE) {
            index = (GLuint) DoLogicOp( gc->state.raster.logicOp, index,
                                        DstIndex );
        }

        // apply indexmask

        if( cfb->buf.flags & INDEXMASK_ON ) {
            index = (DstIndex & cfb->destMask) | (index & cfb->sourceMask);
        }
    }
    index &= cfb->redMax;
    *pul = pTrans[index];
    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, TRUE);
}

/************************************************************************/

static GLboolean FASTCALL SlowStoreSpan(__GLcontext *gc)
{
    int x, x1;
    int i;
    __GLfragment frag;
    __GLcolor *cp;
    __GLcolorBuffer *cfb;
    GLint w;

    DBGENTRY("CI:StoreSpan\n");

    w = gc->polygon.shader.length;

    frag.y = gc->polygon.shader.frag.y;
    x = gc->polygon.shader.frag.x;
    x1 = gc->polygon.shader.frag.x + w;
    cp = gc->polygon.shader.colors;
    cfb = gc->polygon.shader.cfb;

    for (i = x; i < x1; i++) {
        frag.x = i;
        frag.color.r = cp->r;
        cp++;

        (*cfb->store)(cfb, &frag);
    }

    return GL_FALSE;
}


static GLboolean FASTCALL SlowStoreStippledSpan(__GLcontext *gc)
{
    int x;
    __GLfragment frag;
    __GLcolor *cp;
    __GLcolorBuffer *cfb;
    __GLstippleWord inMask, bit, *sp;
    GLint count;
    GLint w;

    DBGENTRY("CI:StoreStippledSpan\n");

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    frag.y = gc->polygon.shader.frag.y;
    x = gc->polygon.shader.frag.x;
    cp = gc->polygon.shader.colors;
    cfb = gc->polygon.shader.cfb;

    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        inMask = *sp++;
        bit = (GLuint) __GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (inMask & bit) {
                frag.x = x;
                frag.color.r = cp->r;

                (*cfb->store)(cfb, &frag);
            }
            x++;
            cp++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
    }

    return GL_FALSE;
}

void
CIFetchNone(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    result->r = 0.0F;
}

void
CIReadSpanNone(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *results,
                GLint w)
{
    GLint i;
    __GLcolor *pResults;

    for (i = 0, pResults = results; i < w; i++, pResults++)
    {
        pResults->r = 0.0F;
    }
}       
                    
void
DIBIndex4CIFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj, pixel;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x >> 1));

    pixel = *puj;
    if (!(x & 1))
        pixel >>= 4;

    result->r = (__GLfloat) gengc->pajInvTranslateVector[pixel & 0xf];
}

void
DIBIndex8CIFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    puj = (GLubyte *)((ULONG_PTR)cfb->buf.base + (y*cfb->buf.outerWidth) + x);

    result->r = (__GLfloat) gengc->pajInvTranslateVector[*puj];
}

void
DIBRGBCIFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;
    GLuint iColor;
    
    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                         (y*cfb->buf.outerWidth) + (x * 3));
    Copy3Bytes( &iColor, puj );
    result->r = (float) ColorToIndex( gengc, iColor );
}

void
DIBBitfield16CIFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLushort *pus;
    GLuint iColor;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    pus = (GLushort *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x << 1));
    iColor = (GLuint) *pus;
    result->r = (float) ColorToIndex( gengc, iColor );
}

void
DIBBitfield32CIFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint *pul;
    GLuint iColor;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    pul = (GLuint *)((ULONG_PTR)cfb->buf.base +
                        (y*cfb->buf.outerWidth) + (x << 2));
    iColor = *pul; // need to clamp to <= 24 bits ?
    result->r = (float) ColorToIndex( gengc, iColor );
}

void
DisplayIndex4CIFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj, pixel;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    puj = gengc->ColorsBits;
    pixel = *puj >> 4;
    result->r = (__GLfloat) gengc->pajInvTranslateVector[pixel];
}

void
DisplayIndex8CIFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    puj = gengc->ColorsBits;
    result->r = (__GLfloat) gengc->pajInvTranslateVector[*puj];
}

void
DisplayRGBCIFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;
    GLuint iColor;
    
    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    puj = gengc->ColorsBits;
    Copy3Bytes( &iColor, puj );
    result->r = (float) ColorToIndex( gengc, iColor );
}

void
DisplayBitfield16CIFetch(__GLcolorBuffer *cfb, GLint x, GLint y,
                         __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLushort *pus;
    GLuint iColor;
    
    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    pus = gengc->ColorsBits;
    iColor = (GLuint) *pus;
    result->r = (float) ColorToIndex( gengc, iColor );
}

void
DisplayBitfield32CIFetch(__GLcolorBuffer *cfb, GLint x, GLint y,
                         __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint *pul;
    GLuint iColor;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    pul = gengc->ColorsBits;
    iColor = *pul; // need to clamp to <= 24 bits ?
    result->r = (float) ColorToIndex( gengc, iColor );
}

void
Index4CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *results,
                 GLint w, GLboolean bDIB)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj, pixel;
    __GLcolor *pResults;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    if (bDIB)
    {
        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base + (y*cfb->buf.outerWidth) +
                          (x >> 1));
    }
    else
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, w, FALSE);
        puj = gengc->ColorsBits;
        x = 0;
    }
    pResults = results;
    if (x & 1)
    {
        pixel = *puj++;
        pResults->r = (__GLfloat) gengc->pajInvTranslateVector[pixel & 0xf];
        pResults++;
        w--;
    }
    while (w > 1)
    {
        pixel = *puj >> 4;
        pResults->r = (__GLfloat) gengc->pajInvTranslateVector[pixel];
        pResults++;
        pixel = *puj++;
        pResults->r = (__GLfloat) gengc->pajInvTranslateVector[pixel & 0xf];
        pResults++;
        w -= 2;
    }
    if (w > 0)
    {
        pixel = *puj >> 4;
        pResults->r = (__GLfloat) gengc->pajInvTranslateVector[pixel];
    }        
}

void
DIBIndex4CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *results,
                    GLint w)
{
    Index4CIReadSpan(cfb, x, y, results, w, TRUE);
}
    		 
void
DisplayIndex4CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                         __GLcolor *results, GLint w)
{
    Index4CIReadSpan(cfb, x, y, results, w, FALSE);
}

void
Index8CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *results,
                 GLint w, GLboolean bDIB)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;
    GLint i;
    __GLcolor *pResults;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    if (bDIB)
    {
        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base + (y*cfb->buf.outerWidth) + x);
    }
    else
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, w, FALSE);
        puj = gengc->ColorsBits;
    }
    for (i = 0, pResults = results; i < w; i++, pResults++)
    {
        pResults->r = (__GLfloat) gengc->pajInvTranslateVector[*puj++];
    }
}

void    
DIBIndex8CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *results,
                    GLint w)
{
    Index8CIReadSpan(cfb, x, y, results, w, TRUE);
}
  		     
void    
DisplayIndex8CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                        __GLcolor *results, GLint w)
{
    Index8CIReadSpan(cfb, x, y, results, w, FALSE);
}

void
RGBCIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *results,
              GLint w, GLboolean bDIB)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;
    GLint i;
    __GLcolor *pResults;
    GLuint iColor;
    
    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    if (bDIB)
    {
        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                         (y*cfb->buf.outerWidth) + (x * 3));
    }
    else
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, w, FALSE);
        puj = gengc->ColorsBits;
    }
    for (i = 0, pResults = results; i < w; i++, pResults++, puj += 3)
    {
	Copy3Bytes( &iColor, puj );
	pResults->r = (float) ColorToIndex( gengc, iColor );
    }
}

void    
DIBRGBCIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *results,
                 GLint w)
{
    RGBCIReadSpan(cfb, x, y, results, w, TRUE);
}
  		     
void    
DisplayRGBCIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *results,
                     GLint w)
{
    RGBCIReadSpan(cfb, x, y, results, w, FALSE);
}

void
Bitfield16CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                     __GLcolor *results, GLint w, GLboolean bDIB)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLushort *pus;
    GLint i;
    __GLcolor *pResults;
    GLuint iColor;
    
    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    if (bDIB)
    {
        pus = (GLushort *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x << 1));
    }
    else
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, w, FALSE);
        pus = gengc->ColorsBits;
    }
    for (i = 0, pResults = results; i < w; i++, pResults++)
    {
        iColor = *pus++;
        pResults->r = (__GLfloat) ColorToIndex( gengc, iColor );
    }
}

void    
DIBBitfield16CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                        __GLcolor *results, GLint w)
{
    Bitfield16CIReadSpan(cfb, x, y, results, w, TRUE);
}
  		     
void    
DisplayBitfield16CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                            __GLcolor *results, GLint w)
{
    Bitfield16CIReadSpan(cfb, x, y, results, w, FALSE);
}

void
Bitfield32CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                     __GLcolor *results, GLint w, GLboolean bDIB)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint *pul;
    GLint i;
    __GLcolor *pResults;
    GLuint iColor;
    
    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    if (bDIB)
    {
        pul = (GLuint *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x << 2));
    }
    else
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, w, FALSE);
        pul = gengc->ColorsBits;
    }
    for (i = 0, pResults = results; i < w; i++, pResults++)
    {
        iColor = *pul++;
        pResults->r = (__GLfloat) ColorToIndex( gengc, iColor );
    }
}

void    
DIBBitfield32CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                        __GLcolor *results, GLint w)
{
    Bitfield32CIReadSpan(cfb, x, y, results, w, TRUE);
}
  		     
void    
DisplayBitfield32CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                            __GLcolor *results, GLint w)
{
    Bitfield32CIReadSpan(cfb, x, y, results, w, FALSE);
}

/************************************************************************/

static void Resize(__GLGENbuffers *buffers, __GLcolorBuffer *cfb,
                   GLint w, GLint h)
{
    DBGENTRY("CI:Resize\n");

#ifdef __GL_LINT
    dp = dp;
#endif
    cfb->buf.width = w;
    cfb->buf.height = h;
}

/************************************************************************/

static void (FASTCALL *StoreProcs[4])(__GLcolorBuffer*, const __GLfragment*) = {
    Store,
    Store_D,
    Store_L,
    Store_DL,
};

void FASTCALL PickCI(__GLcontext *gc, __GLcolorBuffer *cfb)
{
    GLuint enables = gc->state.enables.general;
    GLint ix = 0;
    __GLGENcontext *gengc;
    PIXELFORMATDESCRIPTOR *pfmt;
    GLboolean needFetch = GL_FALSE;

    DBGENTRY("PickCI\n");

    /* predetermine if fetch required for Store procs: we'll assume 
       always need to if logicOp or indexMask (i.e: assume if needFetch
       not set, then no logicOp or indexMask used)
    */

    if( gc->state.raster.writeMask == cfb->redMax ) {
        cfb->buf.flags = cfb->buf.flags & ~INDEXMASK_ON;
    	cfb->sourceMask = cfb->redMax;  // mf: these 2 may not be needed
    	cfb->destMask = ~cfb->sourceMask;
    } else {
    	cfb->sourceMask = gc->state.raster.writeMask & cfb->redMax;
    	cfb->destMask = ~cfb->sourceMask & cfb->redMax;
        cfb->buf.flags = cfb->buf.flags | INDEXMASK_ON;
	needFetch = GL_TRUE;
    }
	
    if (enables & __GL_DITHER_ENABLE) {
        ix |= 1;
    }
    if (enables & __GL_INDEX_LOGIC_OP_ENABLE) {
        ix |= 2;
	needFetch = GL_TRUE; // don't need to fetch for some logicOps, but
			     // we'll deal with that later
    }
	
    if( needFetch )
    	cfb->buf.flags = cfb->buf.flags | NEED_FETCH;
    else
    	cfb->buf.flags = cfb->buf.flags & ~NEED_FETCH;

    cfb->store = StoreProcs[ix];

    // Figure out store and fetch routines
    if (gc->state.raster.drawBuffer == GL_NONE)
    {
        cfb->store = Store_NOT;
        cfb->fetch = CIFetchNone;
        cfb->readColor = CIFetchNone;
        cfb->readSpan = CIReadSpanNone;
        cfb->storeSpan = StoreSpanNone;
        cfb->storeStippledSpan = StoreSpanNone;
    }
    else
    {
        gengc = (__GLGENcontext *)gc;
        pfmt = &gengc->gsurf.pfd;
        if (cfb->buf.flags & DIB_FORMAT)
        {
            switch(pfmt->cColorBits) {

            case 4:
                cfb->fetch = DIBIndex4CIFetch;
                cfb->readColor = DIBIndex4CIFetch;
                cfb->readSpan = DIBIndex4CIReadSpan;
    		cfb->store = DIBIndex4CIStore;
		cfb->clear = Index4Clear;
                break;

            case 8:
                cfb->fetch = DIBIndex8CIFetch;
                cfb->readColor = DIBIndex8CIFetch;
                cfb->readSpan = DIBIndex8CIReadSpan;
    		cfb->store = DIBIndex8CIStore;
		cfb->clear = Index8Clear;
                break;

            case 16:
                cfb->fetch = DIBBitfield16CIFetch;
                cfb->readColor = DIBBitfield16CIFetch;
                cfb->readSpan = DIBBitfield16CIReadSpan;
    		cfb->store = DIBBitfield16CIStore;
		cfb->clear = Bitfield16Clear;
                break;

            case 24:
                cfb->readSpan = DIBRGBCIReadSpan;
                cfb->readColor = DIBRGBCIFetch;
                cfb->fetch = DIBRGBCIFetch;
		cfb->store = DIBRGBCIStore;
		cfb->clear = RGBClear;
                break;

            case 32:
                cfb->fetch = DIBBitfield32CIFetch;
                cfb->readColor = DIBBitfield32CIFetch;
                cfb->readSpan = DIBBitfield32CIReadSpan;
    		cfb->store = DIBBitfield32CIStore;
		cfb->clear = Bitfield32Clear;
                break;
            }
        }
        else
        {
            switch(pfmt->cColorBits) {

            case 4:
                cfb->fetch = DisplayIndex4CIFetch;
                cfb->readColor = DisplayIndex4CIFetch;
                cfb->readSpan = DisplayIndex4CIReadSpan;
    		cfb->store = DisplayIndex4CIStore;
		cfb->clear = Index4Clear;
                break;

            case 8:
                cfb->fetch = DisplayIndex8CIFetch;
                cfb->readColor = DisplayIndex8CIFetch;
                cfb->readSpan = DisplayIndex8CIReadSpan;
    		cfb->store = DisplayIndex8CIStore;
		cfb->clear = Index8Clear;
                break;
    
            case 16:
                cfb->fetch = DisplayBitfield16CIFetch;
                cfb->readColor = DisplayBitfield16CIFetch;
                cfb->readSpan = DisplayBitfield16CIReadSpan;
    		cfb->store = DisplayBitfield16CIStore;
		cfb->clear = Bitfield16Clear;
                break;

            case 24:
                cfb->readSpan = DisplayRGBCIReadSpan;
                cfb->fetch = DisplayRGBCIFetch;
                cfb->readColor = DisplayRGBCIFetch;
		cfb->store = DisplayRGBCIStore;
		cfb->clear = RGBClear;
                break;

            case 32:
                cfb->fetch = DisplayBitfield32CIFetch;
                cfb->readColor = DisplayBitfield32CIFetch;
                cfb->readSpan = DisplayBitfield32CIReadSpan;
    		cfb->store = DisplayBitfield32CIStore;
		cfb->clear = Bitfield32Clear;
                break;
            }
        }
    }
}

void FASTCALL __glGenInitCI(__GLcontext *gc, __GLcolorBuffer *cfb, GLenum type)
{
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    PIXELFORMATDESCRIPTOR *pfmt;

    DBGENTRY("__glGenInitCI\n");

    __glInitGenericCB(gc, cfb);

    cfb->pick       = PickCI;
    gc->redVertexScale   = cfb->redScale   = (__GLfloat)1.0;
    gc->greenVertexScale = cfb->greenScale = (__GLfloat)1.0;
    gc->blueVertexScale  = cfb->blueScale  = (__GLfloat)1.0;
    gc->alphaVertexScale = cfb->alphaScale = (__GLfloat)1.0;

    cfb->buf.elementSize   = sizeof(GLubyte);
    cfb->resize            = Resize;
    cfb->fetchSpan         = __glFetchSpan;
    cfb->fetchStippledSpan = __glFetchSpan;
    cfb->storeSpan         = SlowStoreSpan;
    cfb->storeStippledSpan = SlowStoreStippledSpan;

    pfmt = &gengc->gsurf.pfd;

/* XXX! redMax is used for index lighting in soft, and for setting 
    raster.writeMask
*/
    cfb->redMax = (1 << gc->modes.indexBits) - 1;
    cfb->redShift = pfmt->cRedShift;
    cfb->greenShift = pfmt->cGreenShift;
    cfb->blueShift = pfmt->cBlueShift;
    cfb->allShifts =
        (cfb->redShift << 0) |
        (cfb->greenShift << 8) |
        (cfb->blueShift << 16) |
        (cfb->alphaShift << 24);

    glGenInitCommon(gengc, cfb, type);

}

void FASTCALL __glGenFreeCI(__GLcontext *gc, __GLcolorBuffer *cfb)
{

    DBGENTRY("__glGenFreeCI\n");

#ifdef __GL_LINT
    gc = gc;
    cfb = cfb;
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\genaccum.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

#include "devlock.h"

void APIPRIVATE __glim_Accum(GLenum op, GLfloat value)
{
    __GLaccumBuffer *fb;
    __GL_SETUP();
    GLuint beginMode;
    void (*accumOp)(__GLaccumBuffer *fb, __GLfloat val);

    beginMode = gc->beginMode;
    if (beginMode != __GL_NOT_IN_BEGIN) {
	if (beginMode == __GL_NEED_VALIDATE) {
	    (*gc->procs.validate)(gc);
	    gc->beginMode = __GL_NOT_IN_BEGIN;
	    __glim_Accum(op,value);
	    return;
	} else {
	    __glSetError(GL_INVALID_OPERATION);
	    return;
	}
    }

    fb = &gc->accumBuffer;
    if (!gc->modes.accumBits || gc->modes.colorIndexMode) {
	__glSetError(GL_INVALID_OPERATION);
	return;
    }
    if (!gc->modes.haveAccumBuffer) {
        LazyAllocateAccum(gc);
        if (!gc->modes.haveAccumBuffer)	// LazyAllocate failed
            return;
    }
    switch (op) {
      case GL_ACCUM:
        accumOp = fb->accumulate;
	break;
      case GL_LOAD:
        accumOp = fb->load;
	break;
      case GL_RETURN:
        accumOp = fb->ret;
	break;
      case GL_MULT:
        accumOp = fb->mult;
	break;
      case GL_ADD:
        accumOp = fb->add;
	break;
      default:
	__glSetError(GL_INVALID_ENUM);
	return;
    }

    if (gc->renderMode == GL_RENDER) {
        BOOL bResetViewportAdj = FALSE;

        if (((__GLGENcontext *)gc)->pMcdState) {
            //
            // MCD does not hook glBitmap, so we go straight to the
            // simulations.  Therefore, if we are grabbing the device
            // lock lazily, we need to grab it now.
            //

	    if (!glsrvLazyGrabSurfaces((__GLGENcontext *)gc,
                                       COLOR_LOCK_FLAGS)) {
                __glSetError(GL_OUT_OF_MEMORY);
                return;
            }

            //
            // We may need to temporarily reset the viewport adjust values
            // before calling simulations.  If GenMcdResetViewportAdj returns
            // TRUE, the viewport is changed and we need restore later with
            // VP_NOBIAS.
            //

            bResetViewportAdj = GenMcdResetViewportAdj(gc, VP_FIXBIAS);
        }

        (*accumOp)(fb, value);

        //
        // Restore viewport values if needed.
        //

        if (bResetViewportAdj)
        {
            GenMcdResetViewportAdj(gc, VP_NOBIAS);
        }
    }
}


/************************************************************************/

static void FASTCALL Pick(__GLcontext *gc, __GLaccumBuffer *afb)
{
#ifdef __GL_LINT
    gc = gc;
    afb = afb;
#endif
}

static void Load32(__GLaccumBuffer* afb, __GLfloat val)
{
    __GLcontext *gc = afb->buf.gc;
    GLint x0 = gc->transform.clipX0;
    GLint y0 = gc->transform.clipY0;
    GLint x1 = gc->transform.clipX1;
    GLint y1 = gc->transform.clipY1;
    GLint w, w4, w1, ow, skip;
    GLint redShift, greenShift, blueShift;
    GLuint redMask, greenMask, blueMask;
    __GLfloat rval, gval, bval;
    GLuint *ac;
    __GLcolorBuffer *cfb;
    __GLcolor *cbuf;

    __GLuicolor *shift, *mask, *sign;
    __GLcolor cval, *cp;
    GLint i;

    shift = &afb->shift;
    mask  = &afb->mask;
    sign  = &afb->sign;
    cval.r = val * afb->redScale;
    cval.g = val * afb->greenScale;
    cval.b = val * afb->blueScale;
    cval.a = val * afb->alphaScale;
    
    w = x1 - x0;
    cbuf = (__GLcolor *) gcTempAlloc(gc, w * sizeof(__GLcolor));
    if (!cbuf)
        return;

    ac = __GL_ACCUM_ADDRESS(afb,(GLuint*),x0,y0);
    cfb = gc->readBuffer;
    ow = w;
    w4 = w >> 2;
    w1 = w & 3;
    skip = afb->buf.outerWidth - w;

    for (; y0 < y1; y0++, ac+= skip ) {
	__GLcolor *cp = &cbuf[0];
	(*cfb->readSpan)(cfb, x0, y0, &cbuf[0], w);

        if( ! gc->modes.alphaBits ) {
	    for( i = 0; i < w; i++, ac++, cp++ ) {
	        *ac = (((GLuint)(cp->r * cval.r) & mask->r) << shift->r) |
	                (((GLuint)(cp->g * cval.g) & mask->g) << shift->g) |
	                (((GLuint)(cp->b * cval.b) & mask->b) << shift->b);
	    }
        } else 
            // accum buffer has alpha component
	    for( i = 0; i < w; i++, ac++, cp++ ) {
	        *ac = (((GLuint)(cp->r * cval.r) & mask->r) << shift->r) |
	                (((GLuint)(cp->g * cval.g) & mask->g) << shift->g) |
	                (((GLuint)(cp->b * cval.b) & mask->b) << shift->b) |
	                (((GLuint)(cp->a * cval.a) & mask->a) << shift->a);
	    }
        }
    gcTempFree(gc, cbuf);
}

// Macros for accumulation operations on color components

#define ACCUM_ACCUM_MASKED_COLOR_COMPONENT( col, fbcol, shift, sign, mask, val) \
    col = (*ac >> shift) & mask; \
    if (col & sign) \
        col |= ~mask; \
    col += (GLint) (fbcol * val);

#define ACCUM_ADD_MASKED_COLOR_COMPONENT( col, shift, sign, mask, val) \
    col = (*ac >> shift) & mask; \
    if (col & sign) \
	col |= ~mask; \
    col = (GLint) (col + val);

#define ACCUM_MULT_MASKED_COLOR_COMPONENT( col, shift, sign, mask, val) \
    col = (*ac >> shift) & mask; \
    if (col & sign) \
        col |= ~mask; \
    col = (GLint) (col * val);

static void Accumulate32(__GLaccumBuffer* afb, __GLfloat val)
{
    __GLcontext *gc = afb->buf.gc;
    GLint x0 = gc->transform.clipX0;
    GLint y0 = gc->transform.clipY0;
    GLint x1 = gc->transform.clipX1;
    GLint y1 = gc->transform.clipY1;
    GLint w, ow, skip, w4, w1;
    GLint r, g, b;
    GLuint *ac, acVal;
    __GLfloat rval, gval, bval;
    __GLcolorBuffer *cfb;
    __GLcolor *cbuf;
    __GLuicolor *shift, *mask, *sign;
    __GLcolor cval, *cp;
    GLint a;

    shift = &afb->shift;
    mask  = &afb->mask;
    sign  = &afb->sign;
    cval.r = val * afb->redScale;
    cval.g = val * afb->greenScale;
    cval.b = val * afb->blueScale;
    cval.a = val * afb->alphaScale;

    w = x1 - x0;
    cbuf = (__GLcolor *) gcTempAlloc(gc, w * sizeof(__GLcolor));
    if (!cbuf)
        return;

    ac = __GL_ACCUM_ADDRESS(afb,(GLuint*),x0,y0);
    cfb = gc->readBuffer;
    ow = w;
    skip = afb->buf.outerWidth - w;

    for (; y0 < y1; y0++, ac+= skip ) {
	(*cfb->readSpan)(cfb, x0, y0, &cbuf[0], ow);

        cp = &cbuf[0];
        if( ! gc->modes.alphaBits ) {

	    for( w = ow; w; w--, ac++, cp++ ) {

                ACCUM_ACCUM_MASKED_COLOR_COMPONENT( r, cp->r, shift->r, sign->r, 
                                              mask->r, cval.r);
                ACCUM_ACCUM_MASKED_COLOR_COMPONENT( g, cp->g, shift->g, sign->g, 
                                              mask->g, cval.g);
                ACCUM_ACCUM_MASKED_COLOR_COMPONENT( b, cp->b, shift->b, sign->b, 
                                              mask->b, cval.b);

                *ac   = ((r & mask->r) << shift->r) |
                        ((g & mask->g) << shift->g) |
                        ((b & mask->b) << shift->b);
	    }

	} else {

	    for( w = ow; w; w--, ac++, cp++ ) {

                ACCUM_ACCUM_MASKED_COLOR_COMPONENT( r, cp->r, shift->r, sign->r, 
                                              mask->r, cval.r);
                ACCUM_ACCUM_MASKED_COLOR_COMPONENT( g, cp->g, shift->g, sign->g, 
                                              mask->g, cval.g);
                ACCUM_ACCUM_MASKED_COLOR_COMPONENT( b, cp->b, shift->b, sign->b, 
                                              mask->b, cval.b);
                ACCUM_ACCUM_MASKED_COLOR_COMPONENT( a, cp->a, shift->a, sign->a, 
                                              mask->a, cval.a);

                *ac   = ((r & mask->r) << shift->r) |
                        ((g & mask->g) << shift->g) |
                        ((b & mask->b) << shift->b) |
                        ((a & mask->a) << shift->a);
	    }

        }
    }
    gcTempFree(gc, cbuf);
}

static void Mult32(__GLaccumBuffer *afb, __GLfloat val)
{
    __GLcontext *gc = afb->buf.gc;
    GLint x0 = gc->transform.clipX0;
    GLint y0 = gc->transform.clipY0;
    GLint x1 = gc->transform.clipX1;
    GLint y1 = gc->transform.clipY1;
    GLint w, w4, w1, skip;
    GLuint acVal, *ac;
    GLint r, g, b;

    __GLuicolor *shift, *mask, *sign;
    GLint i;
    GLint a;

    shift = &afb->shift;
    mask  = &afb->mask;
    sign  = &afb->sign;
    
    ac = __GL_ACCUM_ADDRESS(afb,(GLuint*),x0,y0);
    w = x1 - x0;
    skip = afb->buf.outerWidth - w;

    if (val == __glZero) {
	/* Zero out the buffers contents */
	for (; y0 < y1; y0++) {
	    GLint ww = w;
	    while (ww > 0) {
		*ac++ = 0;
		ww--;
	    }
	    ac += skip;
	}
	return;
    }

    w4 = w >> 2;
    w1 = w & 3;
    for (; y0 < y1; y0++, ac+= skip) {
        if( ! gc->modes.alphaBits ) {

    	    for( i = 0; i < w; i++, ac++ ) {
                ACCUM_MULT_MASKED_COLOR_COMPONENT( r, shift->r, sign->r, 
                                              mask->r, val);
                ACCUM_MULT_MASKED_COLOR_COMPONENT( g, shift->g, sign->g, 
                                              mask->g, val);
                ACCUM_MULT_MASKED_COLOR_COMPONENT( b, shift->b, sign->b, 
                                              mask->b, val);

                *ac   = ((r & mask->r) << shift->r) |
                        ((g & mask->g) << shift->g) |
                        ((b & mask->b) << shift->b);
            }
        } else {
	    for( i = 0; i < w; i++, ac++ ) {
                ACCUM_MULT_MASKED_COLOR_COMPONENT( r, shift->r, sign->r, 
                                              mask->r, val);
                ACCUM_MULT_MASKED_COLOR_COMPONENT( g, shift->g, sign->g, 
                                              mask->g, val);
                ACCUM_MULT_MASKED_COLOR_COMPONENT( b, shift->b, sign->b, 
                                              mask->b, val);
                ACCUM_MULT_MASKED_COLOR_COMPONENT( a, shift->a, sign->a, 
                                              mask->a, val);

                *ac   = ((r & mask->r) << shift->r) |
                        ((g & mask->g) << shift->g) |
                        ((b & mask->b) << shift->b) |
                        ((a & mask->a) << shift->a);
            }
        }
    }
}

static void Add32(__GLaccumBuffer *afb, __GLfloat value)
{
    __GLcontext *gc = afb->buf.gc;
    GLint x0 = gc->transform.clipX0;
    GLint y0 = gc->transform.clipY0;
    GLint x1 = gc->transform.clipX1;
    GLint y1 = gc->transform.clipY1;
    GLint w, w4, w1, skip;
    GLint rval, gval, bval;
    GLuint acVal, *ac;
    GLint r, g, b;

    __GLuicolor *shift, *mask, *sign;
    __GLicolor cval;
    GLint i;
    GLint a;

    shift = &afb->shift;
    mask  = &afb->mask;
    sign  = &afb->sign;
    cval.r = (GLint)
	(value * gc->frontBuffer.redScale * afb->redScale + __glHalf);
    cval.g = (GLint)
	(value * gc->frontBuffer.greenScale * afb->greenScale + __glHalf);
    cval.b = (GLint)
	(value * gc->frontBuffer.blueScale * afb->blueScale + __glHalf);
    cval.a = (GLint)
	(value * gc->frontBuffer.alphaScale * afb->alphaScale + __glHalf);

    ac = __GL_ACCUM_ADDRESS(afb,(GLuint*),x0,y0);
    w = x1 - x0;
    w4 = w >> 2;
    w1 = w & 3;
    skip = afb->buf.outerWidth - w;

    for (; y0 < y1; y0++, ac+= skip) {
        if( ! gc->modes.alphaBits ) {

    	    for( i = 0; i < w; i++, ac++ ) {
                ACCUM_ADD_MASKED_COLOR_COMPONENT( r, shift->r, sign->r, 
                                              mask->r, cval.r);
                ACCUM_ADD_MASKED_COLOR_COMPONENT( g, shift->g, sign->g, 
                                              mask->g, cval.g);
                ACCUM_ADD_MASKED_COLOR_COMPONENT( b, shift->b, sign->b, 
                                              mask->b, cval.b);

                *ac   = ((r & mask->r) << shift->r) |
                        ((g & mask->g) << shift->g) |
                        ((b & mask->b) << shift->b);
            }
        } else {
	    for( i = 0; i < w; i++, ac++ ) {
                ACCUM_ADD_MASKED_COLOR_COMPONENT( r, shift->r, sign->r, 
                                              mask->r, cval.r);
                ACCUM_ADD_MASKED_COLOR_COMPONENT( g, shift->g, sign->g, 
                                              mask->g, cval.g);
                ACCUM_ADD_MASKED_COLOR_COMPONENT( b, shift->b, sign->b, 
                                              mask->b, cval.b);
                ACCUM_ADD_MASKED_COLOR_COMPONENT( a, shift->a, sign->a, 
                                              mask->a, cval.a);

                *ac   = ((r & mask->r) << shift->r) |
                        ((g & mask->g) << shift->g) |
                        ((b & mask->b) << shift->b) |
                        ((a & mask->a) << shift->a);
            }
        }
    }
}

static void Return32(__GLaccumBuffer* afb, __GLfloat val)
{
    __GLcontext *gc = afb->buf.gc;
    GLint x0 = gc->transform.clipX0;
    GLint y0 = gc->transform.clipY0;
    GLint x1 = gc->transform.clipX1;
    GLint y1 = gc->transform.clipY1;
    GLint w, next;
    GLuint *ac;
    __GLcolorBuffer *cfb;
    __GLcolorBuffer *cfb2;
    __GLfragment frag;
    __GLcolor *pAccumCol;
    // The returnspan routines use FTOL 
    FPU_SAVE_MODE();
    FPU_CHOP_ON_PREC_LOW();

    ac = __GL_ACCUM_ADDRESS(afb,(GLuint*),x0,y0);
    w = x1 - x0;
    next = afb->buf.outerWidth;
    frag.y = y0;

    // Preallocate a color buffer for the return span functions
    pAccumCol = (__GLcolor *) gcTempAlloc(gc, w * sizeof(__GLcolor));
    if( NULL == pAccumCol )
        return;
    afb->colors = pAccumCol;

    if (gc->buffers.doubleStore) {
	/* Store to both buffers */
	cfb = &gc->frontBuffer;
	cfb2 = &gc->backBuffer;
	for (; y0 < y1; y0++) {
	    (*cfb->returnSpan)(cfb, x0, y0, (__GLaccumCell *)ac, val, w);
	    (*cfb2->returnSpan)(cfb2, x0, y0, (__GLaccumCell *)ac, val, w);
	    ac += next;
	}
    } else {
	cfb = gc->drawBuffer;
	for (; y0 < y1; y0++) {
	    (*cfb->returnSpan)(cfb, x0, y0, (__GLaccumCell *)ac, val, w);
	    ac += next;
	}
    }
    FPU_RESTORE_MODE();
    gcTempFree( gc, pAccumCol );
}

static void FASTCALL Clear32(__GLaccumBuffer* afb)
{
    __GLcontext *gc = afb->buf.gc;
    GLint x0 = gc->transform.clipX0;
    GLint y0 = gc->transform.clipY0;
    GLint y1 = gc->transform.clipY1;
    GLint w, w4, w1, skip;
    GLuint *ac, acVal;
    GLint r, g, b;
    __GLcolorBuffer *cfb = &gc->frontBuffer;
    __GLcolor *val = &gc->state.accum.clear;
    GLint a;

    /*
    ** Convert abstract color into specific color value.
    */
    r = (GLint) (val->r * cfb->redScale * afb->redScale);
    g = (GLint) (val->g * cfb->greenScale * afb->greenScale);
    b = (GLint) (val->b * cfb->blueScale * afb->blueScale);
    a = (GLint) (val->a * cfb->alphaScale * afb->alphaScale);
    acVal = ((r & afb->mask.r) << afb->shift.r) |
            ((g & afb->mask.g) << afb->shift.g) |
            ((b & afb->mask.b) << afb->shift.b);
    if( gc->modes.alphaBits )
        acVal |= (a & afb->mask.a) << afb->shift.a;
            
    ac = __GL_ACCUM_ADDRESS(afb,(GLuint*),x0,y0);
    w = gc->transform.clipX1 - x0;
    w4 = w >> 2;
    w1 = w & 3;
    skip = afb->buf.outerWidth - w;
    for (; y0 < y1; y0++) {
	w = w4;
	while (--w >= 0) {
	    ac[0] = acVal;
	    ac[1] = acVal;
	    ac[2] = acVal;
	    ac[3] = acVal;
	    ac += 4;
	}
	w = w1;
	while (--w >= 0) {
	    *ac++ = acVal;
	}
	ac += skip;
    }
}

void FASTCALL __glInitAccum32(__GLcontext *gc, __GLaccumBuffer *afb)
{
    __GLGENcontext *gengc;
    PIXELFORMATDESCRIPTOR *pfmt;

    gengc = (__GLGENcontext *) gc;
    pfmt = &gengc->gsurf.pfd;
    afb->buf.elementSize = sizeof(GLuint);
    afb->buf.gc = gc;
    if (gc->modes.rgbMode) {
	__GLcolorBuffer *cfb;
	__GLfloat redScale, greenScale, blueScale;
	__GLfloat alphaScale;

	redScale = (__GLfloat) (1 << pfmt->cAccumRedBits)/2 - 1;
	greenScale = (__GLfloat) (1 << pfmt->cAccumGreenBits)/2 - 1;
	blueScale = (__GLfloat) (1 << pfmt->cAccumBlueBits)/2 - 1;

	cfb = &gc->frontBuffer;
	afb->redScale = redScale / (cfb->redScale);
	afb->greenScale = greenScale / (cfb->greenScale);
	afb->blueScale = blueScale / (cfb->blueScale);
        afb->alphaScale = (__GLfloat) 1.0;

	afb->oneOverRedScale = 1 / afb->redScale;
	afb->oneOverGreenScale = 1 / afb->greenScale;
	afb->oneOverBlueScale = 1 / afb->blueScale;
	afb->oneOverAlphaScale = 1 / afb->alphaScale;
        afb->shift.r = 0;
        afb->shift.g = pfmt->cAccumRedBits;
        afb->shift.b = afb->shift.g + pfmt->cAccumGreenBits;
        afb->mask.r = (1 << pfmt->cAccumRedBits) - 1;
        afb->mask.g = (1 << pfmt->cAccumGreenBits) - 1;
        afb->mask.b = (1 << pfmt->cAccumBlueBits) - 1;
        afb->sign.r = 1 << (pfmt->cAccumRedBits - 1);
        afb->sign.g = 1 << (pfmt->cAccumGreenBits - 1);
        afb->sign.b = 1 << (pfmt->cAccumBlueBits - 1);
        if( gc->modes.alphaBits ) {
            alphaScale = (__GLfloat) (1 << pfmt->cAccumAlphaBits)/2 - 1;
            afb->alphaScale = alphaScale / (cfb->alphaScale);
            afb->oneOverAlphaScale = 1 / afb->alphaScale;
            afb->shift.a = afb->shift.b + pfmt->cAccumBlueBits;
            afb->mask.a = (1 << pfmt->cAccumAlphaBits) - 1;
            afb->sign.a = 1 << (pfmt->cAccumAlphaBits - 1);
        }
    }
    afb->pick = Pick;
    afb->clear = Clear32;
    afb->accumulate = Accumulate32;
    afb->load = Load32;
    afb->ret = Return32;
    afb->mult = Mult32;
    afb->add = Add32;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\genclear.h ===
/******************************Module*Header*******************************\
* Module Name: genclear.h
*
* Created: 03-Dec-1993 00:33:51
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1992 Microsoft Corporation
*
\**************************************************************************/

void FASTCALL Index4Clear(__GLcolorBuffer *);
void FASTCALL Index8Clear(__GLcolorBuffer *);
void FASTCALL RGBClear(__GLcolorBuffer *);
void FASTCALL Bitfield16Clear(__GLcolorBuffer *);
void FASTCALL Bitfield32Clear(__GLcolorBuffer *);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\genclear.c ===
/******************************Module*Header*******************************\
* Module Name: genclear.c
*
* Clear functions.
*
* Created: 01-Dec-1993 16:11:17
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1992 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "genci.h"
#include "genrgb.h"
#include "devlock.h"

/******************************Public*Routine******************************\
* __glim_Clear
*
* Generic proc table entry point for glClear.  It allocates ancillary buffers
* the first time they are used
*
* History:
*  14-Dec-1993 -by- Eddie Robinson [v-eddier]
* Wrote it.
\**************************************************************************/

void APIPRIVATE __glim_Clear(GLbitfield mask)
{
    __GL_SETUP();
    GLuint beginMode;

    beginMode = gc->beginMode;
    if ( beginMode != __GL_NOT_IN_BEGIN )
    {
        if ( beginMode == __GL_NEED_VALIDATE )
        {
            (*gc->procs.validate)(gc);
            gc->beginMode = __GL_NOT_IN_BEGIN;
            __glim_Clear(mask);
            return;
        }
        else
        {
            __glSetError(GL_INVALID_OPERATION);
            return;
        }
    }

    if ( mask & ~(GL_COLOR_BUFFER_BIT | GL_ACCUM_BUFFER_BIT
                  | GL_STENCIL_BUFFER_BIT | GL_DEPTH_BUFFER_BIT) )
    {
        __glSetError(GL_INVALID_VALUE);
        return;
    }

    if ( gc->renderMode == GL_RENDER )
    {
        BOOL bResetViewportAdj = FALSE;

#ifdef _MCD_
    // Let MCD have first chance at clearing any of the MCD managed buffers.

        if ( ((__GLGENcontext *) (gc))->pMcdState &&
             (mask & (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT |
                      GL_STENCIL_BUFFER_BIT)) )
        {
        // Don't attempt to clear depth/stencil buffer if it does not exist.

            if ( !gc->modes.depthBits )
                mask &= ~GL_DEPTH_BUFFER_BIT;

            if ( !gc->modes.stencilBits )
                mask &= ~GL_STENCIL_BUFFER_BIT;

        // GenMcdClear will clear the mask bits of the buffers it
        // successfully cleared.

            GenMcdClear((__GLGENcontext *) gc, &mask);

        // If simulations are needed for any of the MCD buffers, now is
        // the time to grab the device lock.

            if (mask & (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT |
                        GL_STENCIL_BUFFER_BIT))
            {
            // Abandon the clear if we cannot acquire the lock.

                if (!glsrvLazyGrabSurfaces((__GLGENcontext *) gc,
                                           COLOR_LOCK_FLAGS |
                                           DEPTH_LOCK_FLAGS))
                    return;

            // We may need to temporarily reset the viewport adjust values
            // before calling simulations.  If GenMcdResetViewportAdj returns
            // TRUE, the viewport is changed and we need restore later with
            // VP_NOBIAS.

                bResetViewportAdj = GenMcdResetViewportAdj(gc, VP_FIXBIAS);
            }
        }
#endif

        if ( mask & GL_COLOR_BUFFER_BIT )
        {
            // Clear the software alpha buffer here too, as approppriate

            switch ( gc->state.raster.drawBuffer )
            {
              case GL_NONE:
                break;
              case GL_FRONT:
                (*gc->front->clear)(gc->front);
                if( ALPHA_BUFFER_WRITE( gc->front ) )
                    (*gc->front->alphaBuf.clear)(&gc->front->alphaBuf);
                break;

              case GL_FRONT_AND_BACK:
                (*gc->front->clear)(gc->front);
                if( ALPHA_BUFFER_WRITE( gc->front ) )
                    (*gc->front->alphaBuf.clear)(&gc->front->alphaBuf);
                // fall through...

              case GL_BACK:
                if ( gc->modes.doubleBufferMode ) {
                    (*gc->back->clear)(gc->back);
                    if( ALPHA_BUFFER_WRITE( gc->back ) )
                        (*gc->back->alphaBuf.clear)(&gc->back->alphaBuf);
                }
                break;
#if __GL_NUMBER_OF_AUX_BUFFERS > 0
              case GL_AUX0:
              case GL_AUX1:
              case GL_AUX2:
              case GL_AUX3:
                i = gc->state.raster.drawBuffer - GL_AUX0;
                if ( i < gc->modes.maxAuxBuffers )
                    (*gc->auxBuffer[i].clear)(&gc->auxBuffer[i]);
                break;
#endif
            }
        }

        if ( (mask & GL_DEPTH_BUFFER_BIT) && gc->modes.depthBits )
        {
            if ( !gc->modes.haveDepthBuffer )
                LazyAllocateDepth(gc);

//XXX Any reason we have to check base???
//XXX That doesn't really fit with 3d DDI model!  So check haveDepthBuffer
//XXX instead...
            if ( gc->modes.haveDepthBuffer )
                (*gc->depthBuffer.clear)(&gc->depthBuffer);
        }

        if ( (mask & GL_ACCUM_BUFFER_BIT) && gc->modes.accumBits )
        {
            if ( !gc->modes.haveAccumBuffer )
                LazyAllocateAccum(gc);

            if ( gc->accumBuffer.buf.base )
                (*gc->accumBuffer.clear)(&gc->accumBuffer);
        }

        if ( (mask & GL_STENCIL_BUFFER_BIT) && gc->modes.stencilBits )
        {
            if ( !gc->modes.haveStencilBuffer )
                LazyAllocateStencil(gc);

            if ( gc->stencilBuffer.buf.base )
                (*gc->stencilBuffer.clear)(&gc->stencilBuffer);
        }

    // Restore viewport values if needed.

        if (bResetViewportAdj)
        {
            GenMcdResetViewportAdj(gc, VP_NOBIAS);
        }
    }
}

/******************************Public*Routine******************************\
* InitClearRectangle
*
* If the wndobj is complex, need to start the enumeration
*
* History:
*  23-Jun-1994 Gilman Wong [gilmanw]
* Use cache of clip rectangles.
*
*  24-Jan-1994 -by- Scott Carr [v-scottc]
* Wrote it.
\**************************************************************************/

void FASTCALL InitClearRectangle(GLGENwindow *pwnd, GLint *pEnumState)
{
    __GLGENbuffers *buffers = pwnd->buffers;

    ASSERTOPENGL(pwnd->clipComplexity == CLC_COMPLEX,
                 "InitClearRectangle(): not CLC_COMPLEX\n");

#ifndef _CLIENTSIDE_
// Check the uniqueness signature.  Note that if the clip cache is
// uninitialized, the clip cache uniqueness is -1 (which is invalid).

    if (buffers->clip.WndUniq != buffers->WndUniq)
    {
        if (buffers->clip.prcl)
            (*private->free)(buffers->clip.prcl);

    // How many clip rectangles?

        buffers->clip.crcl = wglGetClipRects(pwnd, NULL);

    // Allocate a new clip cache.

        buffers->clip.prcl =
            (RECTL *) (*private->malloc)(buffers->clip.crcl * sizeof(RECTL));

        if (!buffers->clip.prcl)
        {
            buffers->clip.crcl = 0;
            return;
        }

    // Get the clip rectangles.

        buffers->clip.crcl = wglGetClipRects(pwnd, buffers->clip.prcl);
        buffers->clip.WndUniq = buffers->WndUniq;
    }
#else
    {
    // In the client-side case, we don't need to cache rectangles.  We already
    // have the rectangles cached for direct screen access.
    // Just grab a copy of the pointer and count from the
    // cached RGNDATA structure in the GLGENwindow.

        buffers->clip.crcl = pwnd->prgndat->rdh.nCount;
        buffers->clip.prcl = (RECTL *) pwnd->prgndat->Buffer;
        buffers->clip.WndUniq = buffers->WndUniq;
    }
#endif

    *pEnumState = 0;
}

/******************************Public*Routine******************************\
* GetClearSubRectangle
*
* Enumerate the rectangles (inclusive-exclusive) in screen coordinates that
* need to be cleared.  If the clipping region is complex, InitClearRectangle
* must be called prior to calling GetClearSubRectangle.
*
* Returns:
*   TRUE if there are more clip rectangles, FALSE if no more.
*
* History:
*  23-Jun-1994 Gilman Wong [gilmanw]
* Use cache of clip rectangles.
*
*  03-Dec-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

GLboolean
GetClearSubRectangle(
    __GLcolorBuffer *cfb,
    RECTL *prcl,
    GLGENwindow *pwnd,
    GLint *pEnumState)
{
    __GLcontext *gc = cfb->buf.gc;
    GLint x, y, x1, y1;
    GLboolean retval;
    RECTL *prcl2;

// Get the OpenGL clipping rectangle and convert to screen coordinates.

    //!!!XXX -- We want to return the clear rectangle as inclusive-exclusive.
    //!!!XXX    Does the gc->tranform.clip* coordinates represent
    //!!!XXX    inclusive-exclusive or inclusive-inclusive?

    x = gc->transform.clipX0;
    y = gc->transform.clipY0;
    x1 = gc->transform.clipX1;
    y1 = gc->transform.clipY1;
    if ((x1 - x == 0) || (y1 - y == 0)) {
        prcl->left = prcl->right = 0;
        prcl->top = prcl->bottom = 0;
        return GL_FALSE;
    }

    prcl->left = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    prcl->right = __GL_UNBIAS_X(gc, x1) + cfb->buf.xOrigin;
    prcl->bottom = __GL_UNBIAS_Y(gc, y1) + cfb->buf.yOrigin;
    prcl->top = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

// Now get the windowing system clipping.  There are three cases: CLC_TRIVIAL,
// CLC_COMPLEX, and CLC_RECTANGLE.

// CLC_TRIVIAL case -- no clipping, use rclClient.

    if (pwnd->clipComplexity == CLC_TRIVIAL)
    {
        prcl2 = &pwnd->rclClient;

        if ((pwnd->rclClient.left == 0) && (pwnd->rclClient.right == 0))
        {
            prcl->left = prcl->right = 0;
            return GL_FALSE;
        }

        retval = GL_FALSE;
    }

// CLC_COMPLEX case -- rectangles have already been enumerated and put into
// the clip cache.  The pEnumState parameter tracks current rectangle to be
// enumerated.

    else if (pwnd->clipComplexity == CLC_COMPLEX)
    {
        __GLGENbuffers *buffers = ((__GLGENcontext *)gc)->pwndLocked->buffers;

        ASSERTOPENGL(buffers->WndUniq == buffers->clip.WndUniq,
                     "GetClearSubRectangle(): clip cache is dirty\n");

        if (*pEnumState < buffers->clip.crcl)
        {
            prcl2 = &buffers->clip.prcl[*pEnumState];
            *pEnumState += 1;
            retval = (*pEnumState < buffers->clip.crcl);
        }
        else
        {
            RIP("GetClearSubRectangle(): no more rectangles!\n");
            prcl->left = prcl->right = 0;
            return GL_FALSE;
        }
    }

// CLC_RECT case -- only one rectangle, use rclBounds.

    else
    {
        ASSERTOPENGL(pwnd->clipComplexity == CLC_RECT,
                     "Unexpected clipComplexity\n");
        prcl2 = &pwnd->rclBounds;

        if ((pwnd->rclBounds.left == 0) && (pwnd->rclBounds.right == 0))
        {
            prcl->left = prcl->right = 0;
            return GL_FALSE;
        }

        retval = GL_FALSE;
    }

// Sanity check the rectangle.

    ASSERTOPENGL(
        (prcl2->right - prcl2->left) <= __GL_MAX_WINDOW_WIDTH
        && (prcl2->bottom - prcl2->top) <= __GL_MAX_WINDOW_HEIGHT,
        "GetClearSubRectangle(): bad visible rect size\n"
        );

// Need to take intersection of prcl & prcl2.

    if (prcl2->left > prcl->left)
        prcl->left = prcl2->left;
    if (prcl2->right < prcl->right)
        prcl->right = prcl2->right;
    if (prcl2->top > prcl->top)
        prcl->top = prcl2->top;
    if (prcl2->bottom < prcl->bottom)
        prcl->bottom = prcl2->bottom;

    if ((prcl->left >= prcl->right) || (prcl->top >= prcl->bottom))
        prcl->left = prcl->right = 0;   // empty inclusive-exclusive rect

    return retval;
}

/******************************Public*Routine******************************\
* ScrnRGBCIReadSpan
*
* Reads a span of RGB, and converts to ColorIndex
*
* History:
*  Feb-09-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void
ScrnRGBCIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y, GLuint *pResults,
              GLint w, GLboolean bDIB)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;
    GLint i;
    GLuint iColor;

    gengc = (__GLGENcontext *)gc;

    if (bDIB) {
        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                         (y*cfb->buf.outerWidth) + (x * 3));
    }
    else {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, w, FALSE);
        puj = gengc->ColorsBits;
    }
    for (i = 0; i < w; i++, puj += 3)
    {
        iColor = *( (GLuint *) puj) & 0xffffff;
        *pResults++ = ColorToIndex( gengc, iColor );
    }
}

/******************************Public*Routine******************************\
* ScrnBitfield16CIReadSpan
*
* Reads a span of Bitfield16, and converts to ColorIndex
*
* History:
*  Feb-09-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void
ScrnBitfield16CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                     GLuint *pResults, GLint w, GLboolean bDIB)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLushort *pus;
    GLint i;
    GLuint iColor;

    gengc = (__GLGENcontext *)gc;

    if (bDIB) {
        pus = (GLushort *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x << 1));
    }
    else {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, w, FALSE);
        pus = gengc->ColorsBits;
    }
    for (i = 0; i < w; i++)
    {
        iColor = *pus++;
        *pResults++ = ColorToIndex( gengc, iColor );
    }
}

/******************************Public*Routine******************************\
* ScrnBitfield32CIReadSpan
*
* Reads a span of Bitfield32, and converts to ColorIndex
*
* History:
*  Feb-09-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void
ScrnBitfield32CIReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                     GLuint *pResults, GLint w, GLboolean bDIB)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint *pul;
    GLint i;
    GLuint iColor;

    gengc = (__GLGENcontext *)gc;

    if (bDIB) {
        pul = (GLuint *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x << 2));
    }
    else {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, w, FALSE);
        pul = gengc->ColorsBits;
    }
    for (i = 0; i < w; i++)
    {
        iColor = *pul++;
        *pResults++ = ColorToIndex( gengc, iColor );
    }
}

/******************************Public*Routine******************************\
* CalcDitherMatrix
*
* Calculate the 16 element dither matrix, or return FALSE if dithering
* would have no effect.
*
* History:
*  Feb-03-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

GLboolean
CalcDitherMatrix( __GLcolorBuffer *cfb, GLboolean bRGBA, GLboolean bMasking,
                  GLboolean bBitfield16, GLubyte *mDither )
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    UINT    i, j;           // indices into the dither array
    GLushort result;         // dithered color value (in 332 RGB)
    __GLcolor *clear;
    GLfloat inc = DITHER_INC(15); // largest dither increment
    GLushort *msDither = (GLushort *) mDither;
    GLuint *pTrans = (GLuint *) (gengc->pajTranslateVector + 1);

    // see if we can ignore dithering altogether

    if( bRGBA ) {
        clear = &gc->state.raster.clear;

        if( ((BYTE)(clear->r*gc->frontBuffer.redScale) ==
             (BYTE)(clear->r*gc->frontBuffer.redScale + inc)) &&
            ((BYTE)(clear->g*gc->frontBuffer.greenScale) ==
             (BYTE)(clear->g*gc->frontBuffer.greenScale + inc)) &&
            ((BYTE)(clear->b*gc->frontBuffer.blueScale) ==
             (BYTE)(clear->b*gc->frontBuffer.blueScale + inc))  ) {

                return GL_FALSE;
        }
    }
    else {  // Color Index (cast to short so works for up to 16-bit)
        if( (GLushort) (gc->state.raster.clearIndex) ==
             (GLushort) (gc->state.raster.clearIndex + inc)) {
                return GL_FALSE;
        }
    }

//XXX -- could cache this in the gengc

    for (j = 0; j < 4; j++)
    {
        for (i = 0; i < 4; i++)
        {
            inc = fDitherIncTable[__GL_DITHER_INDEX(i, j)];

            if( bRGBA ) {
                result =
                    ((BYTE)(clear->r*gc->frontBuffer.redScale + inc) <<
                        cfb->redShift) |
                    ((BYTE)(clear->g*gc->frontBuffer.greenScale + inc) <<
                        cfb->greenShift) |
                    ((BYTE)(clear->b*gc->frontBuffer.blueScale + inc) <<
                        cfb->blueShift);
            }
            else {
                result = (BYTE) (gc->state.raster.clearIndex + inc);
                result &= cfb->redMax;
            }

            if( bBitfield16 ) {
                if( !bMasking ) {
                    if( bRGBA )
                        *msDither++ = result;
                    else
                        *msDither++ = (GLushort)pTrans[result];
                }
                else
                    *msDither++ = (GLushort)(result & cfb->sourceMask);
            }
            else {
                if( !bMasking )
                    *mDither++ = gengc->pajTranslateVector[(GLubyte)result];
                else
                    *mDither++ = (GLubyte)(result & cfb->sourceMask);
            }
        }
    }
    return TRUE;
}

/******************************Public*Routine******************************\
* Index4DitherClear
*
* Clear function for Display 4-bit pixel formats
*
* History:
*  Feb-03-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void
Index4DitherClear(__GLcolorBuffer *cfb, RECTL *rcl, GLubyte *mDither,
                    GLboolean bDIB )
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;

    UINT    cjSpan;             // length of span in bytes
    GLubyte *pDither;           // dithered color, relative to window origin
    UINT    i, j;               // indices into the dither array
    GLubyte *puj, *pujStart;    // pointer into span buffer
    GLint   ySpan;              // index to window row to clear
    GLushort pattern, *pus;     // replicatable 4-nibble dither pattern
    GLuint    lRightByte,       // right edge of span that is byte aligned
              lLeftByte;        // left edge of span that is byte aligned
    GLuint  cSpanWidth;         // span width in pixels
    GLuint   dithX, dithY;      // x,y offsets into dither matrix
    GLubyte dithQuad[4];        // dither repetion quad along a span

    lLeftByte = (rcl->left + 1) / 2;
    lRightByte = rcl->right / 2;
    cjSpan = lRightByte - lLeftByte;
    cSpanWidth = rcl->right - rcl->left;

    if( bDIB )
        pujStart = (GLubyte *)
                   ((ULONG_PTR)cfb->buf.base +
                    (rcl->top*cfb->buf.outerWidth) + lLeftByte);

    // calc dither offset in x,y
    dithX = (rcl->left - cfb->buf.xOrigin) & 3;
    dithY = (rcl->top  - cfb->buf.yOrigin) & 3;

    for (j = 0; (j < 4) && ((rcl->top + j) < (UINT)rcl->bottom); j++)
    {
        // Arrange the 4-pixel dither repetition pattern in x.  This
        // pattern is relative to rcl->left.

        pDither = mDither + ((dithY+j)&3)*4;
        for( i = 0; i < 4; i ++ ) {
            dithQuad[i] = pDither[(dithX+i)&3];
        }

        // Copy the clear pattern into the span buffer.

        puj = gengc->ColorsBits;
        pus = (GLushort *) puj;

        // For every line, we can replicate a 2-byte(4-nibble) pattern
        // into the span buffer.  This will allow us to quickly output
        // the byte aligned portion of the dithered span.
        //
        // If we are writing to a DIB and the first pixel does not fall
        // on a byte boundary, then the buffer will replicate (using
        // the dithQuad pattern) the dither pattern:
        //
        //  <dith 1> <dith 2> <dith 3> <dith 0>
        //
        // (The non-aligned first dither pixel will have to be handled
        // separately).
        //
        // Otherwise (if we are writing to a display managed surface or
        // the first pixel does fall on a byte boundary), then the buffer
        // will replicate the dither pattern:
        //
        //  <dith 0> <dith 1> <dith 2> <dith 3>
        //
        // Note -- for a VGA, the layout of the pixels in a ushort is:
        //
        //          | -------------- ushort --------------- |
        //          | ---- byte 1 ----- | ---- byte 0 ----- |
        //           <pixel 2> <pixel 3> <pixel 0> <pixel 1>

        if( bDIB && (rcl->left & 1) ) {  // not on byte boundary
            // dither: 1230  pattern: 3012
            pattern = (dithQuad[3] << 12) | (dithQuad[0] << 8) |
                      (dithQuad[1] << 4 ) | (dithQuad[2]);
        }
        else {                          // all other cases
            // dither: 0123  pattern: 2301
            pattern = (dithQuad[2] << 12) | (dithQuad[3] << 8) |
                      (dithQuad[0] << 4 ) | (dithQuad[1]);
        }

        // Replicate pattern into ColorsBits (round up to next short)

        for( i = (rcl->right - rcl->left + 3)/4; i; i-- ) {
            *pus++ = pattern;
        }

        // Copy the span to the display for every 4th row of the window.

        if( bDIB ) {
            for (ySpan = rcl->top + j, puj = pujStart;
                 ySpan < rcl->bottom;
                 ySpan+=4,
                 puj = (GLubyte *)((ULONG_PTR)puj + 4*cfb->buf.outerWidth) ) {

                RtlCopyMemory_UnalignedDst( puj, gengc->ColorsBits, cjSpan );
            }

            // Take care of non-byte aligned left edge.

            if( rcl->left & 1 ) {
                for (ySpan = rcl->top + j, puj = (pujStart-1);
                     ySpan < rcl->bottom;
                     ySpan+=4,
                     puj = (GLubyte *)((ULONG_PTR)puj + 4*cfb->buf.outerWidth) )

                *puj = (*puj & 0xf0) | (dithQuad[0] & 0x0f);
            }

            // Take care of non-byte aligned right edge.

            if( rcl->right & 1 ) {
                GLuint dindex = ((rcl->right - 1) - cfb->buf.xOrigin)&3;

                for (ySpan = rcl->top + j, puj = (pujStart + cjSpan);
                     ySpan < rcl->bottom;
                     ySpan+=4,
                     puj = (GLubyte *)((ULONG_PTR)puj + 4*cfb->buf.outerWidth) )

                *puj = (*puj & 0x0f) | (dithQuad[dindex] << 4);
            }

            pujStart += cfb->buf.outerWidth;
        }
        else {
            for (ySpan = rcl->top + j; ySpan < rcl->bottom; ySpan+=4)
            {
                (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                            ySpan, cSpanWidth, TRUE);
            }
        }
    }
}

/******************************Public*Routine******************************\
* Index4MaskedClear
*
* Clear function for Index4 Masked clears
*
* History:
*  Feb-09-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void
Index4MaskedClear(__GLcolorBuffer *cfb, RECTL *rcl, GLubyte index,
                  GLubyte *mDither)
{
    GLint cSpanWidth, ySpan, w;
    __GLGENcontext *gengc = (__GLGENcontext *) cfb->buf.gc;
    GLboolean bDIB;
    GLubyte *puj, *puj2;
    GLubyte result, pixel, src;
    GLubyte *pTrans, *pInvTrans, *clearDither;
    GLuint i,j;
    GLuint   dithX, dithY;      // x,y offsets into dither matrix

    cSpanWidth = rcl->right - rcl->left;
    bDIB  = cfb->buf.flags & DIB_FORMAT ? TRUE : FALSE;
    pTrans = (GLubyte *) gengc->pajTranslateVector;
    pInvTrans = (GLubyte *) gengc->pajInvTranslateVector;

    puj = bDIB ? (GLubyte *)((ULONG_PTR)cfb->buf.base +
                             (rcl->top*cfb->buf.outerWidth) + (rcl->left>>1))
                     : gengc->ColorsBits;

    if( mDither ) {
        // calc dither offset in x,y
        dithX = (rcl->left - cfb->buf.xOrigin) & 3;
        dithY = (rcl->top - cfb->buf.yOrigin) & 3;
    }

    for (ySpan = rcl->top, j=0; ySpan < rcl->bottom; ySpan++, j++) {

        i = 0;

        if( !bDIB ) {
            (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                        ySpan, cSpanWidth, FALSE);
        }

        if( mDither )
            clearDither = mDither + ((dithY + j)&3)*4;

        src = (GLubyte)(index & cfb->sourceMask);
        w = cSpanWidth;
        puj2 = puj;

        if ( rcl->left & 1 ) {
            result = (GLubyte)(pInvTrans[*puj2 & 0xf] & cfb->destMask);
            if( mDither ) {
                src = clearDither[dithX];
                i++;
            }
            result = pTrans[src | result];
            *puj2++ = (*puj2 & 0xf0) | result;
            w--;
        }

        while( w > 1 ) {
            pixel = (GLubyte)(pInvTrans[*puj2 >> 4] & cfb->destMask);
            pixel = pTrans[src | pixel];
            result = pixel << 4;
            pixel = (GLubyte)(pInvTrans[*puj2 & 0x0f] & cfb->destMask);
            if( mDither )
                src = clearDither[(dithX + i)&3];
            pixel = pTrans[src | pixel];
            *puj2++ = result | pixel;
            w -= 2;
            i++;
        }

        if( w ) {
            result = (GLubyte)(pInvTrans[*puj2 >> 4] & cfb->destMask);
            if( mDither )
                src = clearDither[(dithX + i)&3];
            result = pTrans[src | result];
            *puj2++ = (*puj2 & 0x0f) | (result << 4);
        }

        if( !bDIB )
            (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                        ySpan, cSpanWidth, TRUE);

        if( bDIB ) {
            puj += cfb->buf.outerWidth;
        }
    }
}

/******************************Public*Routine******************************\
* DIBIndex4Clear
*
* Clear function for DIB 4-bit pixel formats
*
* History:
*  Feb-03-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void FASTCALL DIBIndex4Clear(__GLcolorBuffer *cfb, RECTL *rcl, BYTE clearColor)
{
    UINT    cjSpan;             // length of span in bytes
    LONG    lRightByte,         // right edge of span that is byte aligned
            lLeftByte;          // left edge of span that is byte aligned
    GLubyte *puj, *pujEnd;      // pointers into DIB

    lLeftByte = (rcl->left + 1) / 2;
    lRightByte = rcl->right / 2;
    cjSpan = lRightByte - lLeftByte;

    // Copy the clear color into the DIB.

    puj = (GLubyte *)((ULONG_PTR)cfb->buf.base + (rcl->top*cfb->buf.outerWidth) + lLeftByte);
    pujEnd = (GLubyte *)((ULONG_PTR)puj + ((rcl->bottom-rcl->top)*cfb->buf.outerWidth));

    // Note: exit condition is (pul != pulEnd) rather than (pul < pulEnd)
    // because the DIB may be upside down which means that pul is moving
    // "backward" in memory rather than "forward".

    for ( ; puj != pujEnd; puj = (GLubyte *)((ULONG_PTR)puj + cfb->buf.outerWidth) )
    {
        RtlFillMemory((PVOID) puj, cjSpan, clearColor);
    }

    // Take care of possible 1 nibble overhang on the left.

    if ( rcl->left & 1 )
    {
    // Inclusive-exclusive, so on the left we want to turn on the pixel that
    // that is the "right" pixel in the byte.

        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base + (rcl->top*cfb->buf.outerWidth) + (rcl->left/2));
        pujEnd = (GLubyte *)((ULONG_PTR)puj + ((rcl->bottom-rcl->top)*cfb->buf.outerWidth));

        for ( ; puj != pujEnd; puj = (GLubyte *)((ULONG_PTR)puj + cfb->buf.outerWidth) )
            *puj = (*puj & 0xf0) | (clearColor & 0x0f);
    }

    // Take care of possible 1 nibble overhang on the right.

    if ( rcl->right & 1 )
    {
    // Inclusive-exclusive, so on the right we want to turn on the pixel that
    // that is the "left" pixel in the byte.

        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base + (rcl->top*cfb->buf.outerWidth) + (rcl->right/2));
        pujEnd = (GLubyte *)((ULONG_PTR)puj + ((rcl->bottom-rcl->top)*cfb->buf.outerWidth));

        for ( ; puj != pujEnd; puj = (GLubyte *)((ULONG_PTR)puj + cfb->buf.outerWidth) )
            *puj = (*puj & 0x0f) | (clearColor & 0xf0);
    }
}

/******************************Public*Routine******************************\
* Index4Clear
*
* Clear function for all 4-bit pixel formats
*
* History:
*  Feb-03-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void FASTCALL Index4Clear(__GLcolorBuffer *cfb)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    PIXELFORMATDESCRIPTOR *pfmt;
    GLubyte clearColor;         // clear color in 32BPP format
    RECTL   rcl;                // clear rectangle in screen coord.
    GLGENwindow *pwnd;
    GLboolean bMoreRects = GL_TRUE;
    GLboolean bDither = GL_FALSE;
    GLboolean bMasking = (cfb->buf.flags & COLORMASK_ON) != 0;
    GLboolean bDIB = (cfb->buf.flags & DIB_FORMAT) != 0;
    GLboolean bUseMcdSpans = gengc->pMcdState && !bDIB;
    GLboolean bRGBA;
    GLubyte ditherMatrix[4][4];
    GLint ClipEnumState;

    DBGENTRY("Index4Clear\n");

    pfmt = &gengc->gsurf.pfd;
    bRGBA = (pfmt->iPixelType == PFD_TYPE_RGBA);

    /* if dithering enabled, see if we can ignore it, and if not,
        precompute a dither matrix
    */
    if( gc->state.enables.general & __GL_DITHER_ENABLE ) {
        bDither = CalcDitherMatrix( cfb, bRGBA, bMasking, GL_FALSE,
                                    (GLubyte *)ditherMatrix );
    }

    // Convert the clear color to 4BPP format.

    if( pfmt->iPixelType == PFD_TYPE_RGBA ) {
        clearColor =
              ((BYTE)(gc->state.raster.clear.r*gc->frontBuffer.redScale +
                      __glHalf) << cfb->redShift) |
              ((BYTE)(gc->state.raster.clear.g*gc->frontBuffer.greenScale +
                     __glHalf) << cfb->greenShift) |
              ((BYTE)(gc->state.raster.clear.b*gc->frontBuffer.blueScale +
                      __glHalf) << cfb->blueShift);
    }
    else {
        clearColor = (BYTE) (gc->state.raster.clearIndex + 0.5F);
        clearColor &= cfb->redMax;
    }
    clearColor = gengc->pajTranslateVector[clearColor];
    clearColor = (clearColor << 4) | clearColor;

    // Get clear rectangle in screen coordinates.
    pwnd = cfb->bitmap->pwnd;
    if (pwnd->clipComplexity == CLC_COMPLEX) {
        InitClearRectangle(pwnd, &ClipEnumState);
#ifdef LATER
    } else if (   !bMasking
               && !bDither
               && bDIB
               && gengc->fDirtyRegionEnabled
               && !RECTLISTIsMax(&gengc->rlClear)
               && ((GLuint)clearColor == gengc->clearColor)
              ) {
        //
        // use dirty region rects
        //

        if (!RECTLISTIsEmpty(&gengc->rlClear)) {
            PYLIST pylist = gengc->rlClear.pylist;

            while (pylist != NULL) {
                PXLIST pxlist = pylist->pxlist;

                rcl.top = pylist->s;
                rcl.bottom = pylist->e;

                while (pxlist != NULL) {
                    rcl.left = pxlist->s;
                    rcl.right = pxlist->e;
                    DIBIndex4Clear( cfb, &rcl, clearColor );
                    pxlist = pxlist->pnext;
                }
                pylist = pylist->pnext;
            }

            //
            // Union the blt region with the Clear region
            // and set the clear region to empty
            //

            RECTLISTOrAndClear(&gengc->rlBlt, &gengc->rlClear);
        }

        return;
    }

    if (gengc->fDirtyRegionEnabled) {
        //
        // if we come through this path then for some reason we
        // are clearing the entire window
        //

        RECTLISTSetEmpty(&gengc->rlClear);
        RECTLISTSetMax(&gengc->rlBlt);

        //
        // remember the clear color
        //

        gengc->clearColor = (GLuint)clearColor;
#endif
    }

    while (bMoreRects)
    {
        // Must use MCD spans if buffer not accessible as DIB.  In such a
        // case, window offset has been removed (see GenMcdUpdateBufferInfo),
        // so a window relative rectangle is required for the clear.  Also,
        // because the driver handles clipping, we do not need to enumerate
        // rects.

        if (bUseMcdSpans) {
            rcl.left = __GL_UNBIAS_X(gc, gc->transform.clipX0);
            rcl.right = __GL_UNBIAS_X(gc, gc->transform.clipX1);
            rcl.bottom = __GL_UNBIAS_Y(gc, gc->transform.clipY1);
            rcl.top = __GL_UNBIAS_Y(gc, gc->transform.clipY0);
            bMoreRects = FALSE;
        } else
            bMoreRects = GetClearSubRectangle(cfb, &rcl, pwnd, &ClipEnumState);

        if (rcl.right == rcl.left)
            continue;

        // Case: no dithering, no masking

        if( !bMasking && !bDither ) {
            if (bDIB)
                DIBIndex4Clear( cfb, &rcl, clearColor );
            else if (bUseMcdSpans)
                Index4MaskedClear( cfb, &rcl, clearColor, NULL );
            else
                wglFillRect(gengc, pwnd, &rcl,
                            (ULONG) clearColor & 0x0000000F);
        }

        // Case: any masking

        else if( bMasking ) {
            Index4MaskedClear( cfb, &rcl, clearColor,
                               bDither ? (GLubyte *)ditherMatrix : NULL );
        }

        // Case: just dithering

        else {
            Index4DitherClear(cfb, &rcl, (GLubyte *)ditherMatrix, bDIB );
        }
    }
}

/******************************Public*Routine******************************\
* Index8DitherClear
*
* Clear device managed surface to the dithered clear color indicated
* in the __GLcolorBuffer.
*
* History:
*  06-Dec-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void
Index8DitherClear(__GLcolorBuffer *cfb, RECTL *rcl, GLubyte *mDither,
                         GLboolean bDIB)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;

    UINT    cjSpan;             // length of span in bytes
    GLubyte *pDither;       // dithered color, relative to window origin
    UINT    i, j;               // indices into the dither array
    GLubyte *puj, *pujStart;           // pointer into span buffer
    GLint   ySpan;          // index to window row to clear
    GLuint   dithX, dithY;      // x,y offsets into dither matrix
    GLubyte dithQuad[4];        // dither repetion quad along a span

    cjSpan = rcl->right - rcl->left;

    if( bDIB )
        pujStart = (GLubyte *)
                   ((ULONG_PTR)cfb->buf.base +
                    (rcl->top*cfb->buf.outerWidth) + rcl->left);

    // calc dither offset in x,y
    dithX = (rcl->left - cfb->buf.xOrigin) & 3;
    dithY = (rcl->top  - cfb->buf.yOrigin) & 3;

    for (j = 0; (j < 4) && ((rcl->top + j) < (UINT)rcl->bottom); j++)
    {
        // arrange the 4-pixel dither repetition pattern in x
        pDither = mDither + ((dithY+j)&3)*4;
        for( i = 0; i < 4; i ++ ) {
            dithQuad[i] = pDither[(dithX+i)&3];
        }

        // Copy the clear color into the span buffer.

        puj = gengc->ColorsBits;

        for (i = cjSpan / 4; i; i--)
        {
            *puj++ = dithQuad[0];
            *puj++ = dithQuad[1];
            *puj++ = dithQuad[2];
            *puj++ = dithQuad[3];
        }

        for (i = 0; i < (cjSpan & 3); i++)
        {
            *puj++ = dithQuad[i];
        }

    // Copy the span to the display for every 4th row of the window.

    //!!!XXX -- It may be worth writing a (*gengc->pfnCopyPixelsN) routine which
    //!!!XXX will do the loop in one call.  This will save not only call
    //!!!XXX overhead but also other engine locking overhead.  Something
    //!!!XXX like: (*gengc->pfnCopyPixelsN)(hdc, hbm, x, y, w, n, yDelta)

        if( bDIB ) {
            for (ySpan = rcl->top + j, puj = pujStart;
                 ySpan < rcl->bottom;
                 ySpan+=4,
                 puj = (GLubyte *)((ULONG_PTR)puj + 4*cfb->buf.outerWidth) ) {

                RtlCopyMemory_UnalignedDst( puj, gengc->ColorsBits, cjSpan );
            }
            pujStart += cfb->buf.outerWidth;
        }
        else {
            for (ySpan = rcl->top + j; ySpan < rcl->bottom; ySpan+=4)
            {
                (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                            ySpan, cjSpan, TRUE);
            }
        }
    }
}

/******************************Public*Routine******************************\
* Index8MaskedClear
*
* Clear function for Index8 Masked clears
* (Also handles dithering when masking on)
*
* History:
*  Feb-09-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void
Index8MaskedClear(__GLcolorBuffer *cfb, RECTL *rcl, GLubyte index,
                  GLubyte *mDither)
{
    GLint cSpanWidth, ySpan;
    __GLGENcontext *gengc = (__GLGENcontext *) cfb->buf.gc;
    GLboolean bDIB;
    GLubyte *puj, *puj2, *pujEnd;
    GLubyte result, src;
    GLubyte *pTrans, *pInvTrans, *clearDither;
    GLuint i,j;
    GLuint   dithX, dithY;      // x,y offsets into dither matrix

    cSpanWidth = rcl->right - rcl->left;
    bDIB  = cfb->buf.flags & DIB_FORMAT ? TRUE : FALSE;
    pTrans = (GLubyte *) gengc->pajTranslateVector;
    pInvTrans = (GLubyte *) gengc->pajInvTranslateVector;

    puj = bDIB ? (GLubyte *)((ULONG_PTR)cfb->buf.base +
                             (rcl->top*cfb->buf.outerWidth) + rcl->left)
                     : gengc->ColorsBits;
    pujEnd = puj + cSpanWidth;

    src = (GLubyte)(index & cfb->sourceMask);

    if( mDither ) {
        // calc dither offset in x,y
        dithX = (rcl->left - cfb->buf.xOrigin) & 3;
        dithY = (rcl->top - cfb->buf.yOrigin) & 3;
    }

    for (ySpan = rcl->top, j = 0; ySpan < rcl->bottom; ySpan++, j++) {

        if( !bDIB ) {
            (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                        ySpan, cSpanWidth, FALSE);
        }

        if( mDither ) {
            clearDither = mDither + ((dithY + j)&3)*4;
            for( puj2 = puj, i = 0; puj2 < pujEnd; puj2++, i++ ) {
                result = (GLubyte)(pInvTrans[*puj2] & cfb->destMask);
                src = clearDither[(dithX + i)&3];
                *puj2 = pTrans[result | src];
            }
        } else {
            for( puj2 = puj, i = 0; puj2 < pujEnd; puj2++, i++ ) {
                result = (GLubyte)(pInvTrans[*puj2] & cfb->destMask);
                *puj2 = pTrans[result | src];
            }
        }


        if( !bDIB )
            (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                        ySpan, cSpanWidth, TRUE);

        if( bDIB ) {
            puj += cfb->buf.outerWidth;
            pujEnd = puj + cSpanWidth;
        }
    }
}

/******************************Public*Routine******************************\
* DIBIndex8Clear
*
* Clear function for DIB 8-bit pixel formats
*
* History:
*  Feb-03-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void FASTCALL DIBIndex8Clear(__GLcolorBuffer *cfb, RECTL *rcl, BYTE index)
{
    int width = rcl->right - rcl->left;
    int height = (rcl->bottom - rcl->top);
    GLubyte *puj = (GLubyte *)((ULONG_PTR)cfb->buf.base + (rcl->top*cfb->buf.outerWidth) + rcl->left);
    GLubyte *pujEnd;

    if (cfb->buf.outerWidth > 0) {
        if (width == cfb->buf.outerWidth) {
            RtlFillMemory((PVOID) puj, width * height, index);
            return;
        }
    } else {
        if (width == -cfb->buf.outerWidth) {
            RtlFillMemory(
                (PVOID)((ULONG_PTR)puj - width * (height - 1)),
                width * height,
                index);
            return;
        }
    }

    pujEnd = (GLubyte *)((ULONG_PTR)puj + ((rcl->bottom-rcl->top)*cfb->buf.outerWidth));

    // Note: exit condition is (pul != pulEnd) rather than (pul < pulEnd)
    // because the DIB may be upside down which means that pul is moving
    // "backward" in memory rather than "forward".

    for ( ; puj != pujEnd; puj = (GLubyte *)((ULONG_PTR)puj + cfb->buf.outerWidth) ) {
        RtlFillMemory((PVOID) puj, width, index);
    }
}

/******************************Public*Routine******************************\
* Index8Clear
*
* Clear function for all 8-bit pixel formats
*
* History:
*  Feb-03-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
*  Oct-03-1995 -by- Marc Fortier [marcfo]
* Don't translate color if masking enabled
\**************************************************************************/

void FASTCALL Index8Clear(__GLcolorBuffer *cfb)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    PIXELFORMATDESCRIPTOR *pfmt;
    BYTE clearColor;
    RECTL  rcl;
    GLGENwindow *pwnd;
    GLboolean bMoreRects = GL_TRUE;
    GLboolean bDither = GL_FALSE;
    GLboolean bMasking = (cfb->buf.flags & COLORMASK_ON) != 0;
    GLboolean bDIB = (cfb->buf.flags & DIB_FORMAT) != 0;
    GLboolean bUseMcdSpans = gengc->pMcdState && !bDIB;
    GLboolean bRGBA;
    GLubyte ditherMatrix[4][4];
    GLint ClipEnumState;

    DBGENTRY("Index8Clear\n");

    pfmt = &gengc->gsurf.pfd;
    bRGBA = (pfmt->iPixelType == PFD_TYPE_RGBA);

    /* if dithering enabled, see if we can ignore it, and if not,
        precompute a dither matrix
    */

    if( gc->state.enables.general & __GL_DITHER_ENABLE ) {
        bDither = CalcDitherMatrix( cfb, bRGBA, bMasking, GL_FALSE,
                                    (GLubyte *)ditherMatrix );
    }

    // Convert clear value to index

    if( bRGBA ) {
        clearColor =
      ((BYTE)(gc->state.raster.clear.r*gc->frontBuffer.redScale + __glHalf) <<
                cfb->redShift) |
      ((BYTE)(gc->state.raster.clear.g*gc->frontBuffer.greenScale + __glHalf) <<
                cfb->greenShift) |
      ((BYTE)(gc->state.raster.clear.b*gc->frontBuffer.blueScale + __glHalf) <<
                cfb->blueShift);
    }
    else {
        clearColor = (BYTE) (gc->state.raster.clearIndex + __glHalf);
        clearColor &= cfb->redMax;
    }
    // translate color to index
    if( !bMasking )
        clearColor = gengc->pajTranslateVector[clearColor];

    // Get clear rectangle in screen coordinates.

    pwnd = cfb->bitmap->pwnd;
    if (pwnd->clipComplexity == CLC_COMPLEX) {
        InitClearRectangle(pwnd, &ClipEnumState);
#ifdef LATER
    } else if (   !bMasking
               && !bDither
               && bDIB
               && gengc->fDirtyRegionEnabled
               && !RECTLISTIsMax(&gengc->rlClear)
               && ((GLuint)clearColor == gengc->clearColor)
              ) {
        //
        // use dirty region rects
        //

        if (!RECTLISTIsEmpty(&gengc->rlClear)) {
            PYLIST pylist = gengc->rlClear.pylist;

            while (pylist != NULL) {
                PXLIST pxlist = pylist->pxlist;

                rcl.top = pylist->s;
                rcl.bottom = pylist->e;

                while (pxlist != NULL) {
                    rcl.left = pxlist->s;
                    rcl.right = pxlist->e;
                    DIBIndex8Clear( cfb, &rcl, clearColor );
                    pxlist = pxlist->pnext;
                }
                pylist = pylist->pnext;
            }

            //
            // Union the blt region with the Clear region
            // and set the clear region to empty
            //

            RECTLISTOrAndClear(&gengc->rlBlt, &gengc->rlClear);
        }

        return;
    }

    if (gengc->fDirtyRegionEnabled) {
        //
        // if we come through this path then for some reason we
        // are clearing the entire window
        //

        RECTLISTSetEmpty(&gengc->rlClear);
        RECTLISTSetMax(&gengc->rlBlt);

        //
        // remember the clear color
        //

        gengc->clearColor = (GLuint)clearColor;
#endif
    }

    while (bMoreRects)
    {
        // Must use MCD spans if buffer not accessible as DIB.  In such a
        // case, window offset has been removed (see GenMcdUpdateBufferInfo),
        // so a window relative rectangle is required for the clear.  Also,
        // because the driver handles clipping, we do not need to enumerate
        // rects.

        if (bUseMcdSpans) {
            rcl.left = __GL_UNBIAS_X(gc, gc->transform.clipX0);
            rcl.right = __GL_UNBIAS_X(gc, gc->transform.clipX1);
            rcl.bottom = __GL_UNBIAS_Y(gc, gc->transform.clipY1);
            rcl.top = __GL_UNBIAS_Y(gc, gc->transform.clipY0);
            bMoreRects = FALSE;
        } else
            bMoreRects = GetClearSubRectangle(cfb, &rcl, pwnd, &ClipEnumState);
        if (rcl.right == rcl.left)
            continue;

        // Case: no dithering, no masking

        if( !bMasking && !bDither ) {

            if( bDIB )
                DIBIndex8Clear( cfb, &rcl, clearColor );
            else if (bUseMcdSpans)
                Index8MaskedClear( cfb, &rcl, clearColor, NULL );
            else
                wglFillRect(gengc, pwnd, &rcl,
                            (ULONG) clearColor & 0x000000FF);
        }

        // Case: masking, maybe dithering

        else if( bMasking ) {
            Index8MaskedClear( cfb, &rcl, clearColor,
                               bDither ? (GLubyte *)ditherMatrix : NULL );
        }

        // Case: just dithering

        else {
            Index8DitherClear(cfb, &rcl, (GLubyte *)ditherMatrix, bDIB );
        }
    }
}

/******************************Public*Routine******************************\
* RGBMaskedClear
*
* Clear function for 24-bit (RGB/BGR) Masked clears
*
* History:
*  Feb-09-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void
RGBMaskedClear(__GLcolorBuffer *cfb, RECTL *rcl, GLuint color, GLuint index)
{
    GLint cSpanWidth, ySpan;
    __GLGENcontext *gengc = (__GLGENcontext *) cfb->buf.gc;
    __GLcontext *gc = (__GLcontext *) gengc;
    PIXELFORMATDESCRIPTOR *pfmt;
    GLboolean bDIB;
    GLuint *destColors, *cp;
    GLubyte *puj, *puj2, *pujEnd;
    GLuint result, src;
    GLuint *pTrans;

    pfmt = &gengc->gsurf.pfd;
    cSpanWidth = rcl->right - rcl->left;
    bDIB  = cfb->buf.flags & DIB_FORMAT ? TRUE : FALSE;
    if( pfmt->iPixelType != PFD_TYPE_RGBA ) {

        destColors = (GLuint *) gcTempAlloc(gc, cSpanWidth*sizeof(GLuint));
        if( NULL == destColors )
            return;

        pTrans = (GLuint *) gengc->pajTranslateVector + 1;
    }

    puj = bDIB ? (GLubyte *)((ULONG_PTR)cfb->buf.base +
                             (rcl->top*cfb->buf.outerWidth) + (rcl->left*3))
                     : gengc->ColorsBits;
    pujEnd = puj + 3*cSpanWidth;
    for (ySpan = rcl->top; ySpan < rcl->bottom; ySpan++) {

        if( pfmt->iPixelType == PFD_TYPE_RGBA ) {
            // fetch based on bDIB
            if( !bDIB ) {
                (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                        ySpan, cSpanWidth, FALSE);
            }
            src = color & cfb->sourceMask;
            for( puj2 = puj; puj2 < pujEnd; puj2+=3 ) {
                Copy3Bytes( &result, puj2 );  // get dst pixel
                result   = src | (result & cfb->destMask);
                Copy3Bytes( puj2, &result );
            }
        }
        else {  // Color Index
            ScrnRGBCIReadSpan( cfb, rcl->left, ySpan, destColors, cSpanWidth,
                                 bDIB );
            cp = destColors;
            src = index & cfb->sourceMask;
            for( puj2 = puj; puj2 < pujEnd; puj2+=3, cp++ ) {
                result = src | (*cp & cfb->destMask);
                result = pTrans[result];
                Copy3Bytes( puj2, &result );
            }
        }

        if( !bDIB )
            (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                        ySpan, cSpanWidth, TRUE);

        if( bDIB ) {
            puj += cfb->buf.outerWidth;
            pujEnd = puj + 3*cSpanWidth;
        }
    }
    if( pfmt->iPixelType != PFD_TYPE_RGBA )
        gcTempFree(gc, destColors);
}

/******************************Public*Routine******************************\
* DIBRGBClear
*
* Clear function for 24-bit (RGB/BGR) DIB pixel formats
*
* History:
*  Feb-03-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void FASTCALL DIBRGBClear(__GLcolorBuffer *cfb, RECTL *rcl, GLubyte *color)
{
    __GLcontext *gc = cfb->buf.gc;
    GLint width = (rcl->right - rcl->left) * 3;
    GLuint *pul = (GLuint *) (((ULONG_PTR)cfb->buf.base +
                              rcl->top*cfb->buf.outerWidth) + (rcl->left*3));
    GLuint *pulEnd;
    GLubyte clear0, clear1, clear2;
    BYTE *ScanLineBuf;

    ScanLineBuf = (BYTE *) gcTempAlloc (gc, width);

    if (ScanLineBuf)  {

        // Alloc succeeds

        clear0 = color[0]; clear1 = color[1]; clear2 = color[2];
        RtlFillMemory24((PVOID)ScanLineBuf, width, clear0, clear1, clear2);
        pulEnd = (GLuint *)((ULONG_PTR)pul + 
                            ((rcl->bottom-rcl->top)*cfb->buf.outerWidth));
        // Note: exit condition is (pul != pulEnd) rather than (pul < pulEnd)
        // because the DIB may be upside down which means that pul is moving
        // "backward" in memory rather than "forward".

        for ( ; pul != pulEnd; 
                pul = (GLuint *)((ULONG_PTR)pul + cfb->buf.outerWidth))
             memcpy((PVOID) pul, ScanLineBuf, width);

        gcTempFree(gc, ScanLineBuf); 

    }
}

/******************************Public*Routine******************************\
* RGBClear
*
* Clear function for all 24-bit (RGB/BGR) pixel formats
*
* History:
*  Feb-03-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void FASTCALL RGBClear(__GLcolorBuffer *cfb)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    PIXELFORMATDESCRIPTOR *pfmt;
    RECTL  rcl;
    GLuint clearColor;
    GLGENwindow *pwnd;
    GLboolean bMoreRects = GL_TRUE;
    DWORD index;
    GLint ClipEnumState;
    GLboolean bMasking = (cfb->buf.flags & COLORMASK_ON) != 0;
    GLboolean bDIB = (cfb->buf.flags & DIB_FORMAT) != 0;
    GLboolean bUseMcdSpans = gengc->pMcdState && !bDIB;

    DBGENTRY("RGBClear\n");

    // Convert the clear color to individual RGB components.

    pfmt = &gengc->gsurf.pfd;
    if( pfmt->iPixelType == PFD_TYPE_RGBA ) {
        GLubyte clearR, clearG, clearB;
        GLubyte *pClearColor;

        clearR = (GLubyte)(gc->state.raster.clear.r*gc->frontBuffer.redScale);
        clearG = (GLubyte)(gc->state.raster.clear.g*gc->frontBuffer.greenScale);
        clearB = (GLubyte)(gc->state.raster.clear.b*gc->frontBuffer.blueScale);

        pClearColor = (GLubyte *) &clearColor;
        if( cfb->redShift == 16 ) {
            // BGR mode
            *pClearColor++ = clearB;
            *pClearColor++ = clearG;
            *pClearColor = clearR;
        }
        else {
            // RGB mode
            *pClearColor++ = clearR;
            *pClearColor++ = clearG;
            *pClearColor = clearB;
        }
    }
    else {
        GLuint *pTrans;

        index = (DWORD) (gc->state.raster.clearIndex + 0.5F);
        index &= cfb->redMax;
        pTrans = (GLuint *) gengc->pajTranslateVector;
        clearColor = pTrans[index+1];
    }

    // Get clear rectangle in screen coordinates.
    pwnd = cfb->bitmap->pwnd;
    if (pwnd->clipComplexity == CLC_COMPLEX) {
        InitClearRectangle(pwnd, &ClipEnumState);
#ifdef LATER
    } else if (   !bMasking
               && bDIB
               && gengc->fDirtyRegionEnabled
               && !RECTLISTIsMax(&gengc->rlClear)
               && ((GLuint)clearColor == gengc->clearColor)
              ) {
        //
        // use dirty region rects
        //

        if (!RECTLISTIsEmpty(&gengc->rlClear)) {
            PYLIST pylist = gengc->rlClear.pylist;

            while (pylist != NULL) {
                PXLIST pxlist = pylist->pxlist;

                rcl.top = pylist->s;
                rcl.bottom = pylist->e;

                while (pxlist != NULL) {
                    rcl.left = pxlist->s;
                    rcl.right = pxlist->e;
                    DIBRGBClear( cfb, &rcl, (GLubyte *) &clearColor);
                    pxlist = pxlist->pnext;
                }
                pylist = pylist->pnext;
            }

            //
            // Union the blt region with the Clear region
            // and set the clear region to empty
            //

            RECTLISTOrAndClear(&gengc->rlBlt, &gengc->rlClear);
        }

        return;
    }

    if (gengc->fDirtyRegionEnabled) {
        //
        // if we come through this path then for some reason we
        // are clearing the entire window
        //

        RECTLISTSetEmpty(&gengc->rlClear);
        RECTLISTSetMax(&gengc->rlBlt);

        //
        // remember the clear color
        //

        gengc->clearColor = (GLuint)clearColor;
#endif
    }

    while (bMoreRects)
    {
        // Must use MCD spans if buffer not accessible as DIB.  In such a
        // case, window offset has been removed (see GenMcdUpdateBufferInfo),
        // so a window relative rectangle is required for the clear.  Also,
        // because the driver handles clipping, we do not need to enumerate
        // rects.

        if (bUseMcdSpans) {
            rcl.left = __GL_UNBIAS_X(gc, gc->transform.clipX0);
            rcl.right = __GL_UNBIAS_X(gc, gc->transform.clipX1);
            rcl.bottom = __GL_UNBIAS_Y(gc, gc->transform.clipY1);
            rcl.top = __GL_UNBIAS_Y(gc, gc->transform.clipY0);
            bMoreRects = FALSE;
        } else
            bMoreRects = GetClearSubRectangle(cfb, &rcl, pwnd, &ClipEnumState);
        if (rcl.right == rcl.left)
            continue;

        // Call aproppriate clear function

        if (bMasking || bUseMcdSpans) { // or INDEXMASK_ON
            RGBMaskedClear( cfb, &rcl, clearColor, index );
        }
        else {
            if (bDIB)
                DIBRGBClear( cfb, &rcl, (GLubyte *) &clearColor);
            else
                wglFillRect(gengc, pwnd, &rcl,
                            (ULONG) clearColor & 0x00FFFFFF);
        }
    }
}

/******************************Public*Routine******************************\
* Bitfield16DitherClear
*
* Clear device managed surface to the dithered clear color indicated
* in the __GLcolorBuffer.
*
* History:
*  06-Dec-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void
Bitfield16DitherClear(__GLcolorBuffer *cfb, RECTL *rcl, GLushort *mDither,
                         GLboolean bDIB)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;

    GLushort *pDither;              // dithered color, relative to window origin
    UINT     i, j;
    GLushort *pus, *pusStart;           // pointer into span buffer
    GLint   ySpan;                      // index to window row to clear
    GLuint  cSpanWidth, cSpanWidth2;
    GLint   outerWidth4;
    GLuint   dithX, dithY;      // x,y offsets into dither matrix
    GLushort dithQuad[4];       // dither repetion quad along a span

    cSpanWidth = rcl->right - rcl->left;

    if( bDIB )
    {
        pusStart = (GLushort *)
                   ((ULONG_PTR)cfb->buf.base +
                    (rcl->top*cfb->buf.outerWidth) + (rcl->left << 1));

        /*
         *  Dither patterns repeat themselves every four rows
         */

        outerWidth4 = cfb->buf.outerWidth << 2;

        /*
         *  cSpanWidth is in pixels, convert it to bytes
         */

        cSpanWidth2 = cSpanWidth << 1;
    }

    // calc dither offset in x,y
    dithX = (rcl->left - cfb->buf.xOrigin) & 3;
    dithY = (rcl->top  - cfb->buf.yOrigin) & 3;

    for (j = 0; (j < 4) && ((rcl->top + j) < (UINT)rcl->bottom); j++)
    {
        // arrange the 4-pixel dither repetition pattern in x
        pDither = mDither + ((dithY+j)&3)*4;
        for( i = 0; i < 4; i ++ ) {
            dithQuad[i] = pDither[(dithX+i)&3];
        }

        // Copy the clear color into the span buffer.

        pus = gengc->ColorsBits;

        for (i = cSpanWidth / 4; i; i--)
        {
            *pus++ = dithQuad[0];
            *pus++ = dithQuad[1];
            *pus++ = dithQuad[2];
            *pus++ = dithQuad[3];
        }

        for (i = 0; i < (cSpanWidth & 3); i++)
        {
            *pus++ = dithQuad[i];
        }

        // Copy the span to the display for every 4th row of the window.

        if( bDIB ) {

            for (ySpan = rcl->top + j, pus = pusStart;
                 ySpan < rcl->bottom;
                 ySpan+=4,
                 pus = (GLushort *)((ULONG_PTR)pus + outerWidth4) ) {

                 RtlCopyMemory_UnalignedDst( pus, gengc->ColorsBits, cSpanWidth2 );
            }
            pusStart = (GLushort *)((ULONG_PTR)pusStart + cfb->buf.outerWidth);
        }
        else {
            for (ySpan = rcl->top + j; ySpan < rcl->bottom; ySpan+=4)
            {
                (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                            ySpan, cSpanWidth, TRUE);
            }
        }
    }
}

/******************************Public*Routine******************************\
* Bitfield16MaskedClear
*
* Clear function for Bitfield16 Masked clears
*
* History:
*  Feb-09-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void
Bitfield16MaskedClear(__GLcolorBuffer *cfb, RECTL *rcl, GLushort color,
                      GLuint index, GLushort *mDither)
{
    GLint cSpanWidth, ySpan;
    __GLGENcontext *gengc = (__GLGENcontext *) cfb->buf.gc;
    __GLcontext *gc = (__GLcontext *) gengc;
    PIXELFORMATDESCRIPTOR *pfmt;
    GLboolean bDIB;
    GLuint *destColors, *cp;
    GLushort *pus, *pus2, *pusEnd, *clearDither;
    GLushort result, src;
    GLuint *pTrans, i, j;
    GLuint   dithX, dithY;      // x,y offsets into dither matrix

    pfmt = &gengc->gsurf.pfd;
    cSpanWidth = rcl->right - rcl->left;
    bDIB  = cfb->buf.flags & DIB_FORMAT ? TRUE : FALSE;
    if( pfmt->iPixelType != PFD_TYPE_RGBA ) {
        destColors = (GLuint *) gcTempAlloc(gc, cSpanWidth*sizeof(GLuint));
        if( NULL == destColors )
            return;
        pTrans = (GLuint *) gengc->pajTranslateVector + 1;
    }

    pus = bDIB ? (GLushort *)((ULONG_PTR)cfb->buf.base +
                             (rcl->top*cfb->buf.outerWidth) + (rcl->left<<1))
                     : gengc->ColorsBits;
    pusEnd = pus + cSpanWidth;

    if( mDither ) {
        // calc dither offset in x,y
        dithX = (rcl->left - cfb->buf.xOrigin) & 3;
        dithY = (rcl->top - cfb->buf.yOrigin) & 3;
    }

    for (ySpan = rcl->top, j = 0; ySpan < rcl->bottom; ySpan++, j++) {

        if( mDither )
            clearDither = mDither + ((dithY + j)&3)*4;

        if( pfmt->iPixelType == PFD_TYPE_RGBA ) {
            // fetch based on bDIB
            if( !bDIB ) {
                (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                        ySpan, cSpanWidth, FALSE);
            }
            src = (GLushort)(color & cfb->sourceMask);
            for( pus2 = pus, i = 0; pus2 < pusEnd; pus2++, i++ ) {
                if( mDither )
                    src = clearDither[(dithX + i)&3];
                *pus2 = (GLushort)(src | (*pus2 & cfb->destMask));
            }
        }
        else {  // Color Index
            ScrnBitfield16CIReadSpan( cfb, rcl->left, ySpan, destColors,
                                        cSpanWidth, bDIB );
            cp = destColors;
            src = (GLushort)(index & cfb->sourceMask);
            for( pus2 = pus, i = 0; pus2 < pusEnd; pus2++, cp++, i++ ) {
                if( mDither )
                    src = clearDither[(dithX + i)&3];
                result = (GLushort)(src | (*cp & cfb->destMask));
                result = (GLushort)pTrans[result];
                *pus2 = result;
            }
        }

        if( !bDIB )
            (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                        ySpan, cSpanWidth, TRUE);

        if( bDIB ) {
            pus = (GLushort *)((ULONG_PTR)pus + cfb->buf.outerWidth);
            pusEnd = pus + cSpanWidth;
        }
    }
    if( pfmt->iPixelType != PFD_TYPE_RGBA )
        gcTempFree(gc, destColors);
}

/******************************Public*Routine******************************\
* DIBBitfield16Clear
*
* Clear function for 16-bit DIB pixel formats
*
* History:
*  Feb-03-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void FASTCALL DIBBitfield16Clear(__GLcolorBuffer *cfb, RECTL *rcl, GLushort clearColor)
{
    GLint    cSpanWidth;        // span width to clear
    GLushort *pus, *pusEnd;     // pointers into DIB

    cSpanWidth = rcl->right - rcl->left;

    pus = (GLushort *)((ULONG_PTR)cfb->buf.base + (rcl->top*cfb->buf.outerWidth) + (rcl->left<<1));
    pusEnd = (GLushort *)((ULONG_PTR)pus + ((rcl->bottom-rcl->top)*cfb->buf.outerWidth));

    // Note: exit condition is (pul != pulEnd) rather than (pul < pulEnd)
    // because the DIB may be upside down which means that pul is moving
    // "backward" in memory rather than "forward".

    for ( ; pus != pusEnd; pus = (GLushort *)((ULONG_PTR)pus + cfb->buf.outerWidth) )
    {
        RtlFillMemoryUshort(pus, cSpanWidth * sizeof(GLushort), clearColor);
    }
}

//!!!XXX -- don't need yet, but let's keep it around just in case
#if 0
/******************************Public*Routine******************************\
* DisplayBitfield16Clear
*
* Clear device managed surface to the clear color indicated
* in the __GLcolorBuffer.
*
* History:
*  16-Feb-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void
DisplayBitfield16Clear(__GLcolorBuffer *cfb, RECTL *rcl,
                         GLushort clearColor)
{
    __GLGENcontext *gengc = (__GLGENcontext *) cfb->buf.gc;
    GLushort *pus, *pusEnd;
    GLint cSpanWidth;        // in pixels
    GLint ySpan;

    cSpanWidth = rcl->right - rcl->left;

    pus = (GLushort *) gengc->ColorsBits;
    pusEnd = pus + cSpanWidth;

// Initialize a span buffer to clear color.

    LocalRtlFillMemoryUshort(pus, cSpanWidth*sizeof(GLushort), clearColor);

    for ( ySpan = rcl->top; ySpan < rcl->bottom; ySpan++ )
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                    ySpan, cSpanWidth, TRUE);
    }
}
#endif

/******************************Public*Routine******************************\
* Bitfield16Clear
*
* Clear function for all 16-bit pixel formats
*
* History:
*  Feb-03-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void FASTCALL Bitfield16Clear(__GLcolorBuffer *cfb)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    PIXELFORMATDESCRIPTOR *pfmt;
    GLushort clearColor;
    RECTL  rcl;
    GLGENwindow *pwnd;
    GLboolean bMoreRects = GL_TRUE;
    GLboolean bDither = GL_FALSE;
    GLboolean bMasking = (cfb->buf.flags & COLORMASK_ON) != 0;
    GLboolean bDIB = (cfb->buf.flags & DIB_FORMAT) != 0;
    GLboolean bUseMcdSpans = gengc->pMcdState && !bDIB;
    GLboolean bRGBA;
    GLushort ditherMatrix[4][4];
    DWORD index;
    GLint ClipEnumState;

    DBGENTRY("Bitfield16Clear\n");

    pfmt = &gengc->gsurf.pfd;
    bRGBA = (pfmt->iPixelType == PFD_TYPE_RGBA);

    /* if dithering enabled, see if we can ignore it, and if not,
        precompute a dither matrix
    */

    if( gc->state.enables.general & __GL_DITHER_ENABLE ) {
        bDither = CalcDitherMatrix( cfb, bRGBA, bMasking, GL_TRUE,
                                    (GLubyte *)ditherMatrix );
    }

    // Convert clear value

    if( bRGBA ) {
        clearColor =
      ((BYTE)(gc->state.raster.clear.r*gc->frontBuffer.redScale + __glHalf) <<
                cfb->redShift) |
      ((BYTE)(gc->state.raster.clear.g*gc->frontBuffer.greenScale + __glHalf) <<
                cfb->greenShift) |
      ((BYTE)(gc->state.raster.clear.b*gc->frontBuffer.blueScale + __glHalf) <<
                cfb->blueShift);
        if( ALPHA_IN_PIXEL( cfb ) )
            clearColor |= 
      ((BYTE)(gc->state.raster.clear.a*gc->frontBuffer.alphaScale + __glHalf) <<
                cfb->alphaShift);
    }
    else {
        GLuint *pTrans;

        index = (DWORD) (gc->state.raster.clearIndex + 0.5F);
        index &= cfb->redMax;
        pTrans = (GLuint *) gengc->pajTranslateVector;
        clearColor = (GLushort) pTrans[index+1];
    }

    // Get clear rectangle in screen coordinates.
    pwnd = cfb->bitmap->pwnd;
    if (pwnd->clipComplexity == CLC_COMPLEX) {
        InitClearRectangle(pwnd, &ClipEnumState);
#ifdef LATER
    } else if (   !bMasking
               && !bDither
               && bDIB
               && gengc->fDirtyRegionEnabled
               && !RECTLISTIsMax(&gengc->rlClear)
               && ((GLuint)clearColor == gengc->clearColor)
              ) {
        //
        // use dirty region rects
        //

        if (!RECTLISTIsEmpty(&gengc->rlClear)) {
            PYLIST pylist = gengc->rlClear.pylist;

            while (pylist != NULL) {
                PXLIST pxlist = pylist->pxlist;

                rcl.top = pylist->s;
                rcl.bottom = pylist->e;

                while (pxlist != NULL) {
                    rcl.left = pxlist->s;
                    rcl.right = pxlist->e;
                    DIBBitfield16Clear( cfb, &rcl, clearColor );
                    pxlist = pxlist->pnext;
                }
                pylist = pylist->pnext;
            }

            //
            // Union the blt region with the Clear region
            // and set the clear region to empty
            //

            RECTLISTOrAndClear(&gengc->rlBlt, &gengc->rlClear);
        }

        return;
    }

    if (gengc->fDirtyRegionEnabled) {
        //
        // if we come through this path then for some reason we
        // are clearing the entire window
        //

        RECTLISTSetEmpty(&gengc->rlClear);
        RECTLISTSetMax(&gengc->rlBlt);

        //
        // remember the clear color
        //

        gengc->clearColor = (GLuint)clearColor;
#endif
    }

    while (bMoreRects)
    {
        // Must use MCD spans if buffer not accessible as DIB.  In such a
        // case, window offset has been removed (see GenMcdUpdateBufferInfo),
        // so a window relative rectangle is required for the clear.  Also,
        // because the driver handles clipping, we do not need to enumerate
        // rects.

        if (bUseMcdSpans) {
            rcl.left = __GL_UNBIAS_X(gc, gc->transform.clipX0);
            rcl.right = __GL_UNBIAS_X(gc, gc->transform.clipX1);
            rcl.bottom = __GL_UNBIAS_Y(gc, gc->transform.clipY1);
            rcl.top = __GL_UNBIAS_Y(gc, gc->transform.clipY0);
            bMoreRects = FALSE;
        } else
            bMoreRects = GetClearSubRectangle(cfb, &rcl, pwnd, &ClipEnumState);
        if (rcl.right == rcl.left)
            continue;

        // Case: no dithering, no masking

        if( !bMasking && !bDither) {
            if (bDIB)
                DIBBitfield16Clear( cfb, &rcl, clearColor );
            else if (bUseMcdSpans)
                Bitfield16MaskedClear( cfb, &rcl, clearColor, index, NULL );
            else
                wglFillRect(gengc, pwnd, &rcl,
                            (ULONG) clearColor & 0x0000FFFF);

        }

        // Case: masking, maybe dithering

        else if( bMasking ) {
            Bitfield16MaskedClear( cfb, &rcl, clearColor, index,
                                   bDither ? (GLushort *)ditherMatrix : NULL );
        }

        // Case: just dithering

        else {
            Bitfield16DitherClear(cfb, &rcl, (GLushort *)ditherMatrix, bDIB );
        }
    }

}

/******************************Public*Routine******************************\
* Bitfield32MaskedClear
*
* Clear function for Bitfield16 Masked clears
*
* History:
*  Feb-09-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void
Bitfield32MaskedClear(__GLcolorBuffer *cfb, RECTL *rcl, GLuint color, GLuint index)
{
    GLint cSpanWidth, ySpan;
    __GLGENcontext *gengc = (__GLGENcontext *) cfb->buf.gc;
    __GLcontext *gc = (__GLcontext *) gengc;
    PIXELFORMATDESCRIPTOR *pfmt;
    GLboolean bDIB;
    GLuint *destColors, *cp;
    GLuint *pul, *pul2, *pulEnd;
    GLuint result, src;
    GLuint *pTrans;

    pfmt = &gengc->gsurf.pfd;
    cSpanWidth = rcl->right - rcl->left;
    bDIB  = cfb->buf.flags & DIB_FORMAT ? TRUE : FALSE;
    if( pfmt->iPixelType != PFD_TYPE_RGBA ) {
        destColors = (GLuint *) gcTempAlloc(gc, cSpanWidth*sizeof(GLuint));
        if( NULL == destColors )
            return;
        pTrans = (GLuint *) gengc->pajTranslateVector + 1;
    }

    pul = bDIB ? (GLuint *)((ULONG_PTR)cfb->buf.base +
                             (rcl->top*cfb->buf.outerWidth) + (rcl->left<<2))
                     : gengc->ColorsBits;
    pulEnd = pul + cSpanWidth;
    for (ySpan = rcl->top; ySpan < rcl->bottom; ySpan++) {

        if( pfmt->iPixelType == PFD_TYPE_RGBA ) {
            // fetch based on bDIB
            if( !bDIB ) {
                (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                        ySpan, cSpanWidth, FALSE);
            }
            src = color & cfb->sourceMask;
            for( pul2 = pul; pul2 < pulEnd; pul2++) {
                *pul2 = src | (*pul2 & cfb->destMask);
            }
        }
        else {  // Color Index
            ScrnBitfield32CIReadSpan( cfb, rcl->left, ySpan, destColors,
                                        cSpanWidth, bDIB );
            cp = destColors;
            src = index & cfb->sourceMask;
            for( pul2 = pul; pul2 < pulEnd; pul2++, cp++ ) {
                result = src | (*cp & cfb->destMask);
                result = pTrans[result];
                *pul2 = result;
            }
        }

        if( !bDIB )
            (*gengc->pfnCopyPixels)(gengc, cfb, rcl->left,
                        ySpan, cSpanWidth, TRUE);

        if( bDIB ) {
            pul = (GLuint *)((ULONG_PTR)pul + cfb->buf.outerWidth);
            pulEnd = pul + cSpanWidth;
        }
    }
    if( pfmt->iPixelType != PFD_TYPE_RGBA )
        gcTempFree(gc, destColors);
}

/******************************Public*Routine******************************\
* DIBBitfield32Clear
*
* Clear function for 32-bit DIB pixel formats
*
* History:
*  Feb-03-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void FASTCALL DIBBitfield32Clear(__GLcolorBuffer *cfb, RECTL *rcl, GLuint clearColor)
{
    GLint width = (rcl->right - rcl->left) * sizeof(ULONG);
    GLint height = (rcl->bottom - rcl->top);
    GLuint *pul = (GLuint *)((ULONG_PTR)cfb->buf.base + (rcl->top*cfb->buf.outerWidth) + (rcl->left<<2));
    GLuint *pulEnd;

    if (cfb->buf.outerWidth > 0) {
        if (width == cfb->buf.outerWidth) {
            RtlFillMemoryUlong((PVOID) pul, width * height, clearColor);
            return;
        }
    } else {
        if (width == -cfb->buf.outerWidth) {
            RtlFillMemoryUlong(
                (PVOID)((ULONG_PTR)pul - width * (height - 1)),
                width * height,
                clearColor);
            return;
        }
    }

    pulEnd = (GLuint *)((ULONG_PTR)pul + ((rcl->bottom-rcl->top)*cfb->buf.outerWidth));

    // Note: exit condition is (pul != pulEnd) rather than (pul < pulEnd)
    // because the DIB may be upside down which means that pul is moving
    // "backward" in memory rather than "forward".

    for ( ; pul != pulEnd; pul = (GLuint *)((ULONG_PTR)pul + cfb->buf.outerWidth))
    {
        RtlFillMemoryUlong((PVOID) pul, width, clearColor);
    }
}

/******************************Public*Routine******************************\
* Bitfield32Clear
*
* Clear function for all 32-bit pixel formats
*
* History:
*  Feb-03-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

void FASTCALL Bitfield32Clear(__GLcolorBuffer *cfb)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    PIXELFORMATDESCRIPTOR *pfmt;
    GLuint clearColor;
    RECTL  rcl;
    DWORD  index;
    GLGENwindow *pwnd;
    GLboolean bMoreRects = GL_TRUE;
    GLint ClipEnumState;
    GLboolean bMasking = (cfb->buf.flags & COLORMASK_ON) != 0;
    GLboolean bDIB = (cfb->buf.flags & DIB_FORMAT) != 0;
    GLboolean bUseMcdSpans = gengc->pMcdState && !bDIB;

    DBGENTRY("Bitfield32Clear\n");

    // Convert clear value

    pfmt = &gengc->gsurf.pfd;
    if( pfmt->iPixelType == PFD_TYPE_RGBA ) {
        clearColor =
      ((BYTE)(gc->state.raster.clear.r*gc->frontBuffer.redScale + __glHalf) <<
                cfb->redShift) |
      ((BYTE)(gc->state.raster.clear.g*gc->frontBuffer.greenScale + __glHalf) <<
                cfb->greenShift) |
      ((BYTE)(gc->state.raster.clear.b*gc->frontBuffer.blueScale + __glHalf) <<
                cfb->blueShift);
        if( ALPHA_IN_PIXEL( cfb ) )
            clearColor |= 
      ((BYTE)(gc->state.raster.clear.a*gc->frontBuffer.alphaScale + __glHalf) <<
                cfb->alphaShift);
    }
    else {
        GLuint *pTrans;

        index = (DWORD) (gc->state.raster.clearIndex + 0.5F);
        index &= cfb->redMax;
        pTrans = (GLuint *) gengc->pajTranslateVector;
        clearColor = pTrans[index+1];
    }

    // Get clear rectangle in screen coordinates.
    pwnd = cfb->bitmap->pwnd;
    if (pwnd->clipComplexity == CLC_COMPLEX) {
        InitClearRectangle(pwnd, &ClipEnumState);
#ifdef LATER
    } else if (   !bMasking
               && bDIB
               && gengc->fDirtyRegionEnabled
               && !RECTLISTIsMax(&gengc->rlClear)
               && ((GLuint)clearColor == gengc->clearColor)
              ) {
        //
        // use dirty region rects
        //

        if (!RECTLISTIsEmpty(&gengc->rlClear)) {
            PYLIST pylist = gengc->rlClear.pylist;

            while (pylist != NULL) {
                PXLIST pxlist = pylist->pxlist;

                rcl.top = pylist->s;
                rcl.bottom = pylist->e;

                while (pxlist != NULL) {
                    rcl.left = pxlist->s;
                    rcl.right = pxlist->e;
                    DIBBitfield32Clear( cfb, &rcl, clearColor );
                    pxlist = pxlist->pnext;
                }
                pylist = pylist->pnext;
            }

            //
            // Union the blt region with the Clear region
            // and set the clear region to empty
            //

            RECTLISTOrAndClear(&gengc->rlBlt, &gengc->rlClear);
        }

        return;
    }

    if (gengc->fDirtyRegionEnabled) {
        //
        // if we come through this path then for some reason we
        // are clearing the entire window
        //

        RECTLISTSetEmpty(&gengc->rlClear);
        RECTLISTSetMax(&gengc->rlBlt);

        //
        // remember the clear color
        //

        gengc->clearColor = (GLuint)clearColor;
#endif
    }

    while (bMoreRects)
    {
        // Must use MCD spans if buffer not accessible as DIB.  In such a
        // case, window offset has been removed (see GenMcdUpdateBufferInfo),
        // so a window relative rectangle is required for the clear.  Also,
        // because the driver handles clipping, we do not need to enumerate
        // rects.

        if (bUseMcdSpans) {
            rcl.left = __GL_UNBIAS_X(gc, gc->transform.clipX0);
            rcl.right = __GL_UNBIAS_X(gc, gc->transform.clipX1);
            rcl.bottom = __GL_UNBIAS_Y(gc, gc->transform.clipY1);
            rcl.top = __GL_UNBIAS_Y(gc, gc->transform.clipY0);
            bMoreRects = FALSE;
        } else
            bMoreRects = GetClearSubRectangle(cfb, &rcl, pwnd, &ClipEnumState);
        if (rcl.right == rcl.left)
            continue;

        // Call aproppriate clear function

        if (bMasking || bUseMcdSpans) { // or INDEXMASK_ON
            Bitfield32MaskedClear( cfb, &rcl, clearColor, index );
        }
        else {
            if (bDIB)
                DIBBitfield32Clear( cfb, &rcl, clearColor );
            else
                wglFillRect(gengc, pwnd, &rcl, (ULONG) clearColor);
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\gendirty.c ===
/****************************************************************************\
*
* Dirty region calculation
*
* 14-Feb-1995 mikeke    Created
*
* Copyright (c) 1994 Microsoft Corporation
\****************************************************************************/

#include "precomp.h"
#pragma hdrstop

/****************************************************************************/

PXLIST XLISTAlloc(
    __GLGENbuffers *buffers)
{
    PXLIST pxlist;

    if (buffers->pxlist != NULL) {
        pxlist = buffers->pxlist;
        buffers->pxlist = pxlist->pnext;
    } else {
        pxlist = (PXLIST)ALLOC(sizeof(XLIST));
        if (pxlist == NULL) return NULL;
    }

    pxlist->pnext = NULL;
    return pxlist;
}

/****************************************************************************/

void XLISTFree(
    __GLGENbuffers *buffers,
    PXLIST pxlist)
{
    pxlist->pnext = buffers->pxlist;
    buffers->pxlist = pxlist;
}

/****************************************************************************/

PXLIST XLISTCopy(
    __GLGENbuffers *buffers,
    PXLIST pxlist)
{
    PXLIST pxlistNew = XLISTAlloc(buffers);

    if (pxlistNew != NULL) {
        pxlistNew->s = pxlist->s;
        pxlistNew->e = pxlist->e;
    }

    return pxlistNew;
}

/****************************************************************************/

BOOL YLISTAddSpan(
    __GLGENbuffers *buffers,
    PYLIST pylist,
    int xs,
    int xe)
{
    PXLIST *ppxlist = &(pylist->pxlist);
    PXLIST pxlist = XLISTAlloc(buffers);

    if (pxlist == NULL) return FALSE;

    //
    // Create new x span
    //

    pxlist->s = xs;
    pxlist->e = xe;

    //
    // Insert it in sorted order
    //

    while (
              ((*ppxlist) != NULL)
           && ((*ppxlist)->s < xs)
          ) {
        ppxlist = &((*ppxlist)->pnext);
    }
    pxlist->pnext = *ppxlist;
    *ppxlist = pxlist;

    //
    // Combine any overlapping spans
    //

    pxlist = pylist->pxlist;
    while (TRUE) {
        PXLIST pxlistNext = pxlist->pnext;

        if (pxlistNext == NULL) return TRUE;

        if (pxlist->e >= pxlistNext->s) {
            if (pxlistNext->e > pxlist->e) {
                pxlist->e = pxlistNext->e;
            }
            pxlist->pnext = pxlistNext->pnext;
            XLISTFree(buffers, pxlistNext);
        } else {
            pxlist = pxlist->pnext;
        }
    }

    return TRUE;
}

/****************************************************************************/

PYLIST YLISTAlloc(
    __GLGENbuffers *buffers)
{
    PYLIST pylist;

    if (buffers->pylist != NULL) {
        pylist = buffers->pylist;
        buffers->pylist = pylist->pnext;
    } else {
        pylist = (PYLIST)ALLOC(sizeof(YLIST));
        if (pylist == NULL) return NULL;
    }

    pylist->pxlist = NULL;
    pylist->pnext = NULL;
    return pylist;
}

/****************************************************************************/

void YLISTFree(
    __GLGENbuffers *buffers,
    PYLIST pylist)
{
    PXLIST pxlist = pylist->pxlist;
    PXLIST pxlistKill;

    while (pxlist != NULL) {
        pxlistKill = pxlist;
        pxlist = pxlist->pnext;
        XLISTFree(buffers, pxlistKill);
    }

    pylist->pnext = buffers->pylist;
    buffers->pylist = pylist;
}

/****************************************************************************/

PYLIST YLISTCopy(
    __GLGENbuffers *buffers,
    PYLIST pylist)
{
    PXLIST pxlist = pylist->pxlist;
    PXLIST *ppxlist;
    PYLIST pylistNew = YLISTAlloc(buffers);

    if (pylistNew != NULL) {
        pylistNew->s = pylist->s;
        pylistNew->e = pylist->e;

        ppxlist = &(pylistNew->pxlist);
        while (pxlist != NULL) {
            *ppxlist = XLISTCopy(buffers, pxlist);
            if (*ppxlist == NULL) {
                YLISTFree(buffers, pylistNew);
                return NULL;
            }
            ppxlist = &((*ppxlist)->pnext);
            pxlist = pxlist->pnext;
        }
        *ppxlist = NULL;
    }

    return pylistNew;
}

/****************************************************************************/

void RECTLISTAddRect(
    PRECTLIST prl,
    int xs,
    int ys,
    int xe,
    int ye)
{
    __GLGENbuffers *buffers = (__GLGENbuffers *)(prl->buffers);
    PYLIST* ppylist;
    PYLIST pylistNew;

    ppylist = &(prl->pylist);
    while ((*ppylist) != NULL) {
        if (ys < (*ppylist)->e) break;
        ppylist  = &((*ppylist)->pnext);
    }

    while ((*ppylist) != NULL) {
        if (ys < (*ppylist)->s) {
            PYLIST pylistNew = YLISTAlloc(buffers);
            if (pylistNew == NULL) {
              OutOfMemory:
                RECTLISTSetEmpty(prl);
                return;
            }

            pylistNew->s = ys;
            pylistNew->e = ye;
            if (!YLISTAddSpan(buffers, pylistNew, xs, xe)) {
                goto OutOfMemory;
            }

            pylistNew->pnext = *ppylist;
            *ppylist = pylistNew;
            ppylist = &((*ppylist)->pnext);

            if (ye <= (*ppylist)->s) {
                return;
            }

            pylistNew->e = (*ppylist)->s;
            ys = (*ppylist)->s;
        } else if (ys == (*ppylist)->s) {
            if (ye >= (*ppylist)->e) {
                if (!YLISTAddSpan(buffers, *ppylist, xs, xe)) {
                    goto OutOfMemory;
                }

                ys = (*ppylist)->e;
                if (ys == ye) return;
                ppylist = &((*ppylist)->pnext);
            } else {
                PYLIST pylistNew = YLISTCopy(buffers, *ppylist);
                if (pylistNew == NULL) {
                    goto OutOfMemory;
                }

                pylistNew->e = ye;
                if (!YLISTAddSpan(buffers, pylistNew, xs, xe)) {
                    goto OutOfMemory;
                }

                (*ppylist)->s = ye;

                pylistNew->pnext = *ppylist;
                *ppylist = pylistNew;

                return;
            }
        } else {
            PYLIST pylistNew = YLISTCopy(buffers, *ppylist);
            if (pylistNew == NULL) {
                goto OutOfMemory;
            }

            pylistNew->e = ys;
            (*ppylist)->s = ys;

            pylistNew->pnext = *ppylist;
            *ppylist = pylistNew;
            ppylist = &((*ppylist)->pnext);
        }
    }

    pylistNew = YLISTAlloc(buffers);
    if (pylistNew == NULL) {
        goto OutOfMemory;
    }

    pylistNew->s = ys;
    pylistNew->e = ye;
    if (!YLISTAddSpan(buffers, pylistNew, xs, xe)) {
        goto OutOfMemory;
    }

    pylistNew->pnext = *ppylist;
    *ppylist = pylistNew;
}

/****************************************************************************/

#ifdef LATER
// these functions are not required in the server implementation

#define MAXRECTS 1024

HRGN RECTLISTCreateRegion(
    PRECTLIST prl)
{
    __GLGENbuffers *buffers = (__GLGENbuffers *)(prl->buffers);
    PYLIST pylist = prl->pylist;
    int irect = 0;
    PRGNDATA prgndata;
    PRECT prc;
    HRGN hrgn;

    prgndata = (PRGNDATA)ALLOC(sizeof(RGNDATAHEADER) + MAXRECTS * sizeof(RECT));
    if (prgndata == NULL) return NULL;

    prc = (PRECT)(prgndata->Buffer);

    while (pylist != NULL) {
        PXLIST pxlist = pylist->pxlist;
        while (pxlist != NULL) {
            prc->left   = pxlist->s;
            prc->right  = pxlist->e;
            prc->top    = pylist->s;
            prc->bottom = pylist->e;
            prc++;
            irect++;
            if (irect == MAXRECTS) {
                //Error("maxrect");
                goto done;
            }

            pxlist = pxlist->pnext;
        }
        pylist = pylist->pnext;
    }

  done:
    prgndata->rdh.dwSize = sizeof(RGNDATAHEADER);
    prgndata->rdh.iType = RDH_RECTANGLES;
    prgndata->rdh.nCount = irect;
    prgndata->rdh.nRgnSize = 0;
    prgndata->rdh.rcBound.left = 0;
    prgndata->rdh.rcBound.right = 4096;
    prgndata->rdh.rcBound.top = 0;
    prgndata->rdh.rcBound.bottom = 4096;

    hrgn = GreExtCreateRegion(NULL, irect * sizeof(RECT) + sizeof(RGNDATAHEADER), prgndata);

    #ifdef LATER
    if (hrgn == NULL) {
        Error1("ExtCreateRegion() Error %d\n", GetLastError());
        Error1("%d rects\n", irect);
        prc = (PRECT)(prgndata->Buffer);
        for (;irect>0; irect--) {
            //printf("(%5d, %5d, %5d, %5d)\n", prc->left, prc->right, prc->top, prc->bottom);
            prc++;
        }
    }
    #endif

    FREE(prgndata);

    return hrgn;
}

/****************************************************************************/

//
// !!! make this do everything in one pass
//

void RECTLISTOr(
    PRECTLIST prl1,
    PRECTLIST prl2)
{
    __GLGENbuffers *buffers = (__GLGENbuffers *)(prl1->buffers);
    PYLIST pylist = prl2->pylist;

    while (pylist != NULL) {
        PXLIST pxlist = pylist->pxlist;

        while (pxlist != NULL) {
            RECTLISTAddRect(prl1, pxlist->s, pylist->s, pxlist->e, pylist->e);
            pxlist = pxlist->pnext;
        }
        pylist = pylist->pnext;
    }
}


/****************************************************************************/

void RECTLISTOrAndClear(
    PRECTLIST prl1,
    PRECTLIST prl2)
{
    __GLGENbuffers *buffers = (__GLGENbuffers *)(prl1->buffers);

    if (RECTLISTIsMax(prl2)) {
        RECTLISTSetMax(prl1);
        RECTLISTSetEmpty(prl2);
    } else {
        if (RECTLISTIsEmpty(prl1)) {
            //
            // If the clear region is empty just swap them
            //
            RECTLISTSwap(prl1, prl2);
        } else {
            //
            // The clear region isn't empty so maximize it.
            //
            RECTLISTSetMax(prl1);
            RECTLISTSetEmpty(prl2);
        }
    }
}

/****************************************************************************/

void RECTLISTSwap(
    PRECTLIST prl1,
    PRECTLIST prl2)
{
    __GLGENbuffers *buffers = (__GLGENbuffers *)(prl1->buffers);
    RECTLIST rlTemp = *prl1;

    *prl1 = *prl2;
    *prl2 = rlTemp;
}
#endif

/****************************************************************************/

void RECTLISTSetEmpty(
    PRECTLIST prl)
{
    __GLGENbuffers *buffers = (__GLGENbuffers *)(prl->buffers);
    PYLIST pylist = prl->pylist;
    PYLIST pylistKill;

    while (pylist != NULL) {
        pylistKill = pylist;
        pylist = pylist->pnext;
        YLISTFree(buffers, pylistKill);
    }

    prl->pylist = NULL;
}

/****************************************************************************/

BOOL RECTLISTIsEmpty(
    PRECTLIST prl)
{
    return (prl->pylist == NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\genpick.c ===
/*
** Copyright 1991,1992,1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

#ifdef __GL_USEASMCODE
static void (*SDepthTestPixel[16])(void) = {
    NULL,
    __glDTS_LESS,
    __glDTS_EQUAL,
    __glDTS_LEQUAL,
    __glDTS_GREATER,
    __glDTS_NOTEQUAL,
    __glDTS_GEQUAL,
    __glDTS_ALWAYS,
    NULL,
    __glDTS_LESS_M,
    __glDTS_EQUAL_M,
    __glDTS_LEQUAL_M,
    __glDTS_GREATER_M,
    __glDTS_NOTEQUAL_M,
    __glDTS_GEQUAL_M,
    __glDTS_ALWAYS_M,
};
#endif

typedef void (FASTCALL *StoreProc)(__GLcolorBuffer *cfb, const __GLfragment *frag);

static StoreProc storeProcs[8] = {
    &__glDoStore,
    &__glDoStore_A,
    &__glDoStore_S,
    &__glDoStore_AS,
    &__glDoStore_D,
    &__glDoStore_AD,
    &__glDoStore_SD,
    &__glDoStore_ASD,
};

void FASTCALL __glGenPickStoreProcs(__GLcontext *gc)
{
    GLint ix = 0;
    GLuint enables = gc->state.enables.general;

    if ((enables & __GL_ALPHA_TEST_ENABLE) && gc->modes.rgbMode) {
	ix |= 1;
    }
    if (enables & __GL_STENCIL_TEST_ENABLE) {
	ix |= 2;
    }
    if (enables & __GL_DEPTH_TEST_ENABLE) {
	ix |= 4;
    }
    switch (gc->state.raster.drawBuffer) {
      case GL_NONE:
        gc->procs.store = storeProcs[ix];
	gc->procs.cfbStore = __glDoNullStore;
	break;
      case GL_FRONT_AND_BACK:
	if (gc->buffers.doubleStore) {
            gc->procs.store = storeProcs[ix];
	    gc->procs.cfbStore = __glDoDoubleStore;
	    break;
	}
	/*
	** Note that there is an intentional drop through here.  If double
	** store is not set, then storing to this buffer is no different
	** that storing to the front buffer.
	*/
      case GL_FRONT:
      case GL_BACK:
      case GL_AUX0:
      case GL_AUX1:
      case GL_AUX2:
      case GL_AUX3:
	/*
	** This code knows that gc->drawBuffer will point to the
	** current buffer as chosen by glDrawBuffer
	*/
	gc->procs.store = storeProcs[ix];
	gc->procs.cfbStore = gc->drawBuffer->store;
	break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\genpoly.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

#ifdef _X86_

#define SHADER  __GLcontext.polygon.shader
#define GENGCACCEL __GLGENcontext.genAccel
#define SPANDELTA __GLGENcontext.genAccel.spanDelta
#define SPANVALUE __GLGENcontext.genAccel.spanValue

#endif

#define ENABLE_ASM  1

#if DBG
//#define FORCE_NPX_DEBUG 1
#endif

/**************************************************************************\
\**************************************************************************/

/* This routine sets gc->polygon.shader.cfb to gc->drawBuffer */

void FASTCALL __fastGenFillSubTriangle(__GLcontext *gc, GLint iyBottom, GLint iyTop)
{
    GLint ixLeft, ixRight;
    GLint ixLeftFrac, ixRightFrac;
    GLint spanWidth, clipY0, clipY1;
    ULONG ulSpanVisibility;
    GLint cWalls;
    GLint *Walls;
#ifdef NT
    __GLstippleWord stackWords[__GL_MAX_STACK_STIPPLE_WORDS];
    __GLstippleWord *words;
    GLuint maxWidth;
#else
    __GLstippleWord words[__GL_MAX_STIPPLE_WORDS];
#endif
    BOOL bSurfaceDIB;
    BOOL bClipped;
    GLint xScr, yScr;
    GLint zFails;
    __GLzValue *zbuf, z;
    GLint r, g, b, s, t;
    __GLGENcontext  *gengc = (__GLGENcontext *)gc;
    __genSpanFunc cSpanFunc = GENACCEL(gc).__fastSpanFuncPtr;
    __GLspanFunc zSpanFunc = GENACCEL(gc).__fastZSpanFuncPtr;
    int scansize;

#ifdef NT
    maxWidth = (gc->transform.clipX1 - gc->transform.clipX0) + 31;
    if (maxWidth > __GL_MAX_STACK_STIPPLE_BITS)
    {
        words = gcTempAlloc(gc, (maxWidth+__GL_STIPPLE_BITS-1)/8);
        if (words == NULL)
        {
            return;
        }
    }
    else
    {
        words = stackWords;
    }
#endif

    gc->polygon.shader.stipplePat = words;
    scansize = gc->polygon.shader.cfb->buf.outerWidth;

    bSurfaceDIB = (gc->polygon.shader.cfb->buf.flags & DIB_FORMAT) != 0;
    bClipped = (!(gc->drawBuffer->buf.flags & NO_CLIP)) &&
                 bSurfaceDIB;

    if (bSurfaceDIB)
        GENACCEL(gc).flags |= SURFACE_TYPE_DIB;
    else
        GENACCEL(gc).flags &= ~(SURFACE_TYPE_DIB);

    ixLeft = gc->polygon.shader.ixLeft;
    ixLeftFrac = gc->polygon.shader.ixLeftFrac;
    ixRight = gc->polygon.shader.ixRight;
    ixRightFrac = gc->polygon.shader.ixRightFrac;
    clipY0 = gc->transform.clipY0;
    clipY1 = gc->transform.clipY1;

    r = GENACCEL(gc).spanValue.r;
    g = GENACCEL(gc).spanValue.g;
    b = GENACCEL(gc).spanValue.b;
    s = GENACCEL(gc).spanValue.s;
    t = GENACCEL(gc).spanValue.t;

    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) {
        z = gc->polygon.shader.frag.z;

	if( gc->modes.depthBits == 32 )
	    zbuf = __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                                   ixLeft, iyBottom);
	else
	    zbuf = (__GLzValue *)__GL_DEPTH_ADDR(&gc->depthBuffer,
                                                 (__GLz16Value*),
                                                 ixLeft, iyBottom);
    } else if ((gc->polygon.shader.modeFlags & __GL_SHADE_STIPPLE) == 0) {
        GLuint w;

        if (w = ((gc->transform.clipX1 - gc->transform.clipX0) + 31) >> 3)
            RtlFillMemoryUlong(words, w, ~((ULONG)0));
        GENACCEL(gc).flags &= ~(HAVE_STIPPLE);
    }

    //
    // render the spans
    //

    while (iyBottom < iyTop) {
	spanWidth = ixRight - ixLeft;
	/*
	** Only render spans that have non-zero width and which are
	** not scissored out vertically.
	*/
	if ((spanWidth > 0) && (iyBottom >= clipY0) && (iyBottom < clipY1)) {
	    gc->polygon.shader.frag.x = ixLeft;
	    gc->polygon.shader.frag.y = iyBottom;
            gc->polygon.shader.zbuf = zbuf;
            gc->polygon.shader.frag.z = z;

            GENACCEL(gc).spanValue.r = r;
            GENACCEL(gc).spanValue.g = g;
            GENACCEL(gc).spanValue.b = b;
            GENACCEL(gc).spanValue.s = s;
            GENACCEL(gc).spanValue.t = t;

            // take care of horizontal scissoring

            if (!gc->transform.reasonableViewport) {
                GLint clipX0 = gc->transform.clipX0;
                GLint clipX1 = gc->transform.clipX1;

                // see if we skip entire span

                if ((ixRight <= clipX0) || (ixLeft >= clipX1))
                    goto advance;

                // now clip right and left

                if (ixRight > clipX1)
                    spanWidth = (clipX1 - ixLeft);

                if (ixLeft < clipX0) {
              	    GLuint delta;

                    delta = clipX0 - ixLeft;
                    spanWidth -= delta;

                    if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
                        GENACCEL(gc).spanValue.r += delta * GENACCEL(gc).spanDelta.r;
                        if (gc->polygon.shader.modeFlags & __GL_SHADE_RGB) {
                            GENACCEL(gc).spanValue.g += delta * GENACCEL(gc).spanDelta.g;
                            GENACCEL(gc).spanValue.b += delta * GENACCEL(gc).spanDelta.b;
                        }
                    }
                    if (gc->polygon.shader.modeFlags & __GL_SHADE_TEXTURE) {
                        GENACCEL(gc).spanValue.s += delta * GENACCEL(gc).spanDelta.s;
                        GENACCEL(gc).spanValue.t += delta * GENACCEL(gc).spanDelta.t;
                    }

            	    gc->polygon.shader.frag.x = clipX0;

                    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_ITER) {
                        if( gc->modes.depthBits == 32 )
                            gc->polygon.shader.zbuf += delta;
                        else
                            (__GLz16Value *)gc->polygon.shader.zbuf += delta;

                        gc->polygon.shader.frag.z +=
                            (gc->polygon.shader.dzdx * delta);

                    }
                }
            }

            // now have span length

	    gc->polygon.shader.length = spanWidth;

            // If a stipple is active, process it first
            if (gc->polygon.shader.modeFlags & __GL_SHADE_STIPPLE)
            {
                // If no pixels are left after stippling and depth
                // testing then we can skip the span
                // Note that this function handles the no-depth-
                // testing case also
                gc->polygon.shader.done = GL_FALSE;
                if (!(*GENACCEL(gc).__fastStippleDepthTestSpan)(gc) ||
                    gc->polygon.shader.done)
                {
                    goto advance;
                }

                GENACCEL(gc).flags |= HAVE_STIPPLE;
            }

            // Do z-buffering if needed, and short-circuit rest of span
            // operations if nothing will be drawn.

            else if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_ITER) {
                // initially assume no stippling

                GENACCEL(gc).flags &= ~(HAVE_STIPPLE);
                if ((zFails = (*zSpanFunc)(gc)) == 1)
                    goto advance;
                else if (zFails)
                    GENACCEL(gc).flags |= HAVE_STIPPLE;
            }

            if (gc->state.raster.drawBuffer == GL_FRONT_AND_BACK) {

                gc->polygon.shader.cfb = &gc->frontBuffer;

                xScr = __GL_UNBIAS_X(gc, gc->polygon.shader.frag.x) +
                       gc->frontBuffer.buf.xOrigin;
                yScr = __GL_UNBIAS_Y(gc, iyBottom) +
                       gc->frontBuffer.buf.yOrigin;

                // If the front buffer is a DIB, we're drawing straight to
                // the screen, so we must check clipping.

                if ((gc->frontBuffer.buf.flags &
                    (DIB_FORMAT | NO_CLIP)) == DIB_FORMAT) {

                    ulSpanVisibility = wglSpanVisible(xScr, yScr, spanWidth,
                                                      &cWalls, &Walls);

                    // If the span is completely visible, we can treat the
                    // screen as a DIB.

                    if (ulSpanVisibility == WGL_SPAN_ALL) {
                        GENACCEL(gc).flags |= SURFACE_TYPE_DIB;
                        (*cSpanFunc)(gengc);
                    } else if (ulSpanVisibility == WGL_SPAN_PARTIAL) {
                        GENACCEL(gc).flags &= ~(SURFACE_TYPE_DIB);
                        if (GENACCEL(gc).flags & HAVE_STIPPLE)
                            (*gengc->pfnCopyPixels)(gengc,
                                                    gc->polygon.shader.cfb,
                                                    xScr, yScr, spanWidth,
                                                    FALSE);
                        GENACCEL(gc).flags &= ~(SURFACE_TYPE_DIB);
                        (*cSpanFunc)(gengc);
                        (*gengc->pfnCopyPixels)(gengc,
                                                gc->polygon.shader.cfb,
                                                xScr, yScr, spanWidth,
                                                TRUE);
                    }

                } else {
                    GENACCEL(gc).flags &= ~(SURFACE_TYPE_DIB);
                    if (GENACCEL(gc).flags & HAVE_STIPPLE)
                        (*gengc->pfnCopyPixels)(gengc,
                                                gc->polygon.shader.cfb,
                                                xScr, yScr, spanWidth,
                                                FALSE);
                    GENACCEL(gc).flags &= ~(SURFACE_TYPE_DIB);
                    (*cSpanFunc)(gengc);
                    (*gengc->pfnCopyPixels)(gengc,
                                            gc->polygon.shader.cfb,
                                            xScr, yScr, spanWidth,
                                            TRUE);
                }

                // The back buffer is always DIB-compatible

                gc->polygon.shader.cfb = &gc->backBuffer;
                GENACCEL(gc).flags |= SURFACE_TYPE_DIB;
                (*cSpanFunc)(gengc);
            } else {
                if (bClipped) {
                    xScr = __GL_UNBIAS_X(gc, gc->polygon.shader.frag.x) +
                           gc->drawBuffer->buf.xOrigin;
                    yScr = __GL_UNBIAS_Y(gc, iyBottom) +
                           gc->drawBuffer->buf.yOrigin;

                    ulSpanVisibility = wglSpanVisible(xScr, yScr, spanWidth,
                                                      &cWalls, &Walls);

                    if (ulSpanVisibility == WGL_SPAN_ALL) {
                        GENACCEL(gc).flags |= SURFACE_TYPE_DIB;
                        (*cSpanFunc)(gengc);
                    } else if (ulSpanVisibility == WGL_SPAN_PARTIAL) {
                        GENACCEL(gc).flags &= ~(SURFACE_TYPE_DIB);
                        if (GENACCEL(gc).flags & HAVE_STIPPLE)
                            (*gengc->pfnCopyPixels)(gengc,
                                                    gc->polygon.shader.cfb,
                                                    xScr, yScr, spanWidth,
                                                    FALSE);
                        GENACCEL(gc).flags &= ~(SURFACE_TYPE_DIB);
                        (*cSpanFunc)(gengc);
                        (*gengc->pfnCopyPixels)(gengc,
                                                gc->polygon.shader.cfb,
                                                xScr, yScr, spanWidth,
                                                TRUE);
                    }

                } else if (bSurfaceDIB) {
                    (*cSpanFunc)(gengc);
                } else {
                    xScr = __GL_UNBIAS_X(gc, gc->polygon.shader.frag.x) +
                           gc->drawBuffer->buf.xOrigin;
                    yScr = __GL_UNBIAS_Y(gc, iyBottom) +
                           gc->drawBuffer->buf.yOrigin;

                    GENACCEL(gc).flags &= ~(SURFACE_TYPE_DIB);
                    if (GENACCEL(gc).flags & HAVE_STIPPLE)
                        (*gengc->pfnCopyPixels)(gengc,
                                                gc->polygon.shader.cfb,
                                                xScr, yScr, spanWidth,
                                                FALSE);
                    (*cSpanFunc)(gengc);
                    if (!bSurfaceDIB)
                        (*gengc->pfnCopyPixels)(gengc,
                                                gc->polygon.shader.cfb,
                                                xScr, yScr, spanWidth,
                                                TRUE);
                }
            }
	}

advance:

        GENACCEL(gc).pPix += scansize;

	/* Advance right edge fixed point, adjusting for carry */
	ixRightFrac += gc->polygon.shader.dxRightFrac;
	if (ixRightFrac < 0) {
	    /* Carry/Borrow'd. Use large step */
	    ixRight += gc->polygon.shader.dxRightBig;
	    ixRightFrac &= ~0x80000000;
	} else {
	    ixRight += gc->polygon.shader.dxRightLittle;
	}

	iyBottom++;
	ixLeftFrac += gc->polygon.shader.dxLeftFrac;
	if (ixLeftFrac < 0) {
	    /* Carry/Borrow'd.  Use large step */
	    ixLeft += gc->polygon.shader.dxLeftBig;
	    ixLeftFrac &= ~0x80000000;

	    if (gc->polygon.shader.modeFlags & __GL_SHADE_RGB) {
		if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
		    r += *((GLint *)&gc->polygon.shader.rBig);
		    g += *((GLint *)&gc->polygon.shader.gBig);
		    b += *((GLint *)&gc->polygon.shader.bBig);
		}
                if (gc->polygon.shader.modeFlags & __GL_SHADE_TEXTURE) {
		    s += *((GLint *)&gc->polygon.shader.sBig);
		    t += *((GLint *)&gc->polygon.shader.tBig);
                }
	    } else {
		if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
		    r += *((GLint *)&gc->polygon.shader.rBig);
		}
	    }

	    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) {
		z += gc->polygon.shader.zBig;
		/* The implicit multiply is taken out of the loop */
		zbuf = (__GLzValue*)((GLubyte*)zbuf +
                       gc->polygon.shader.zbufBig);
	    }
	} else {
	    /* Use small step */
	    ixLeft += gc->polygon.shader.dxLeftLittle;
	    if (gc->polygon.shader.modeFlags & __GL_SHADE_RGB) {
		if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
		    r += *((GLint *)&gc->polygon.shader.rLittle);
		    g += *((GLint *)&gc->polygon.shader.gLittle);
		    b += *((GLint *)&gc->polygon.shader.bLittle);
		}
                if (gc->polygon.shader.modeFlags & __GL_SHADE_TEXTURE) {
		    s += *((GLint *)&gc->polygon.shader.sLittle);
		    t += *((GLint *)&gc->polygon.shader.tLittle);
                }
	    } else {
		if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
		    r += *((GLint *)&gc->polygon.shader.rLittle);
		}
            }
	    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) {
		z += gc->polygon.shader.zLittle;
		/* The implicit multiply is taken out of the loop */
		zbuf = (__GLzValue*)((GLubyte*)zbuf +
		        gc->polygon.shader.zbufLittle);
	    }
	}
    }

    gc->polygon.shader.ixLeft = ixLeft;
    gc->polygon.shader.ixLeftFrac = ixLeftFrac;
    gc->polygon.shader.ixRight = ixRight;
    gc->polygon.shader.ixRightFrac = ixRightFrac;
    gc->polygon.shader.frag.z = z;
    GENACCEL(gc).spanValue.r = r;
    GENACCEL(gc).spanValue.g = g;
    GENACCEL(gc).spanValue.b = b;
    GENACCEL(gc).spanValue.s = s;
    GENACCEL(gc).spanValue.t = t;

#ifdef NT
    if (maxWidth > __GL_MAX_STACK_STIPPLE_BITS)
    {
        gcTempFree(gc, words);
    }
#endif
}


void FASTCALL __fastGenFillSubTriangleTexRGBA(__GLcontext *gc, GLint iyBottom, GLint iyTop)
{
    GLint ixLeft, ixRight;
    GLint ixLeftFrac, ixRightFrac;
    GLint spanWidth, clipY0, clipY1;
    ULONG ulSpanVisibility;
    GLint cWalls;
    GLint *Walls;
    BOOL bSurfaceDIB;
    BOOL bClipped;
    GLint xScr, yScr;
    __GLzValue *zbuf, z;
    GLint r, g, b, a, s, t;
    __GLfloat qw;
    __GLGENcontext  *gengc = (__GLGENcontext *)gc;
    __genSpanFunc cSpanFunc = GENACCEL(gc).__fastSpanFuncPtr;
    int scansize;
    BOOL bReadPixels = (gc->state.enables.general & __GL_BLEND_ENABLE) ||
                       (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST);
#ifdef _MCD_
    GLboolean bMcdZ = ((gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) &&
                       (gengc->pMcdState != NULL) &&
                       (gengc->pMcdState->pDepthSpan != NULL) &&
                       (gengc->pMcdState->pMcdSurf != NULL) &&
                       !(gengc->pMcdState->McdBuffers.mcdDepthBuf.bufFlags & MCDBUF_ENABLED));
#endif


    scansize = gc->polygon.shader.cfb->buf.outerWidth;

    bSurfaceDIB = (gc->polygon.shader.cfb->buf.flags & DIB_FORMAT) != 0;
    bClipped = (!(gc->drawBuffer->buf.flags & NO_CLIP)) &&
                 bSurfaceDIB;

    if (bSurfaceDIB)
        GENACCEL(gc).flags |= SURFACE_TYPE_DIB;
    else
        GENACCEL(gc).flags &= ~(SURFACE_TYPE_DIB);

    ixLeft = gc->polygon.shader.ixLeft;
    ixLeftFrac = gc->polygon.shader.ixLeftFrac;
    ixRight = gc->polygon.shader.ixRight;
    ixRightFrac = gc->polygon.shader.ixRightFrac;
    clipY0 = gc->transform.clipY0;
    clipY1 = gc->transform.clipY1;

    r = GENACCEL(gc).spanValue.r;
    g = GENACCEL(gc).spanValue.g;
    b = GENACCEL(gc).spanValue.b;
    a = GENACCEL(gc).spanValue.a;
    s = GENACCEL(gc).spanValue.s;
    t = GENACCEL(gc).spanValue.t;
    qw = gc->polygon.shader.frag.qw;

    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) {
        z = gc->polygon.shader.frag.z;

#ifdef _MCD_
        if (bMcdZ)
        {
            zbuf = (__GLzValue *)gengc->pMcdState->pMcdSurf->McdDepthBuf.pv;
        }
        else
#endif
        {
            if( gc->modes.depthBits == 32 )
                zbuf = __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                                       ixLeft, iyBottom);
            else
                zbuf = (__GLzValue *)__GL_DEPTH_ADDR(&gc->depthBuffer,
                                                     (__GLz16Value*),
                                                     ixLeft, iyBottom);
        }
    }

    //
    // render the spans
    //

    while (iyBottom < iyTop) {
	spanWidth = ixRight - ixLeft;
	/*
	** Only render spans that have non-zero width and which are
	** not scissored out vertically.
	*/
	if ((spanWidth > 0) && (iyBottom >= clipY0) && (iyBottom < clipY1)) {
	    gc->polygon.shader.frag.x = ixLeft;
	    gc->polygon.shader.frag.y = iyBottom;
            gc->polygon.shader.zbuf = zbuf;
            gc->polygon.shader.frag.z = z;

            GENACCEL(gc).spanValue.r = r;
            GENACCEL(gc).spanValue.g = g;
            GENACCEL(gc).spanValue.b = b;
            GENACCEL(gc).spanValue.a = a;
            GENACCEL(gc).spanValue.s = s;
            GENACCEL(gc).spanValue.t = t;
            gc->polygon.shader.frag.qw = qw;

            // take care of horizontal scissoring

            if (!gc->transform.reasonableViewport) {
                GLint clipX0 = gc->transform.clipX0;
                GLint clipX1 = gc->transform.clipX1;

                // see if we skip entire span

                if ((ixRight <= clipX0) || (ixLeft >= clipX1))
                    goto advance;

                // now clip right and left

                if (ixRight > clipX1)
                    spanWidth = (clipX1 - ixLeft);

                if (ixLeft < clipX0) {
              	    GLuint delta;

                    delta = clipX0 - ixLeft;
                    spanWidth -= delta;

                    if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
                        GENACCEL(gc).spanValue.r += delta * GENACCEL(gc).spanDelta.r;
                        GENACCEL(gc).spanValue.g += delta * GENACCEL(gc).spanDelta.g;
                        GENACCEL(gc).spanValue.b += delta * GENACCEL(gc).spanDelta.b;
                        GENACCEL(gc).spanValue.a += delta * GENACCEL(gc).spanDelta.a;
                    }
                    if (gc->polygon.shader.modeFlags & __GL_SHADE_TEXTURE) {
                        GENACCEL(gc).spanValue.s += delta * GENACCEL(gc).spanDelta.s;
                        GENACCEL(gc).spanValue.t += delta * GENACCEL(gc).spanDelta.t;
        	        gc->polygon.shader.frag.qw += delta * gc->polygon.shader.dqwdx;
                    }

            	    gc->polygon.shader.frag.x = clipX0;

                    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_ITER) {
                        if( gc->modes.depthBits == 32 )
                            gc->polygon.shader.zbuf += delta;
                        else
                            (__GLz16Value *)gc->polygon.shader.zbuf += delta;

                        gc->polygon.shader.frag.z +=
                            (gc->polygon.shader.dzdx * delta);
                    }
                }
            }


            // now have span length

	    gc->polygon.shader.length = spanWidth;

#ifdef _MCD_
            // read from driver z buffer into z span buffer

            if (bMcdZ) {
                GenMcdReadZRawSpan(&gc->depthBuffer, gc->polygon.shader.frag.x,
                                   iyBottom, spanWidth);
            }
#endif

            if (bClipped) {
                xScr = __GL_UNBIAS_X(gc, gc->polygon.shader.frag.x) +
                       gc->drawBuffer->buf.xOrigin;
                yScr = __GL_UNBIAS_Y(gc, iyBottom) +
                       gc->drawBuffer->buf.yOrigin;

                ulSpanVisibility = wglSpanVisible(xScr, yScr, spanWidth,
                                                  &cWalls, &Walls);

                if (ulSpanVisibility == WGL_SPAN_ALL) {
                    GENACCEL(gc).flags |= SURFACE_TYPE_DIB;
                    (*cSpanFunc)(gengc);
                } else if (ulSpanVisibility == WGL_SPAN_PARTIAL) {
                    GENACCEL(gc).flags &= ~(SURFACE_TYPE_DIB);
                    if (bReadPixels)
                        (*gengc->pfnCopyPixels)(gengc,
                                                gc->polygon.shader.cfb,
                                                xScr, yScr, spanWidth,
                                                FALSE);
                    (*cSpanFunc)(gengc);
                    (*gengc->pfnCopyPixels)(gengc,
                                            gc->polygon.shader.cfb,
                                            xScr, yScr, spanWidth,
                                            TRUE);
                }

            } else if (bSurfaceDIB) {
                (*cSpanFunc)(gengc);
            } else {
                xScr = __GL_UNBIAS_X(gc, gc->polygon.shader.frag.x) +
                       gc->drawBuffer->buf.xOrigin;
                yScr = __GL_UNBIAS_Y(gc, iyBottom) +
                       gc->drawBuffer->buf.yOrigin;

                GENACCEL(gc).flags &= ~(SURFACE_TYPE_DIB);
                if (bReadPixels)
                    (*gengc->pfnCopyPixels)(gengc,
                                            gc->polygon.shader.cfb,
                                            xScr, yScr, spanWidth,
                                            FALSE);
                (*cSpanFunc)(gengc);
                if (!bSurfaceDIB)
                    (*gengc->pfnCopyPixels)(gengc,
                                            gc->polygon.shader.cfb,
                                            xScr, yScr, spanWidth,
                                            TRUE);
            }

#ifdef _MCD_
            // write z span buffer back to driver z buffer

            if (bMcdZ) {
                GenMcdWriteZRawSpan(&gc->depthBuffer,
                                    gc->polygon.shader.frag.x,
                                    iyBottom, spanWidth);
            }
#endif

        }

advance:

        GENACCEL(gc).pPix += scansize;

	/* Advance right edge fixed point, adjusting for carry */
	ixRightFrac += gc->polygon.shader.dxRightFrac;
	if (ixRightFrac < 0) {
	    /* Carry/Borrow'd. Use large step */
	    ixRight += gc->polygon.shader.dxRightBig;
	    ixRightFrac &= ~0x80000000;
	} else {
	    ixRight += gc->polygon.shader.dxRightLittle;
	}

	iyBottom++;
	ixLeftFrac += gc->polygon.shader.dxLeftFrac;
	if (ixLeftFrac < 0) {
	    /* Carry/Borrow'd.  Use large step */
	    ixLeft += gc->polygon.shader.dxLeftBig;
	    ixLeftFrac &= ~0x80000000;

            if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
	        r += *((GLint *)&gc->polygon.shader.rBig);
	        g += *((GLint *)&gc->polygon.shader.gBig);
	        b += *((GLint *)&gc->polygon.shader.bBig);
	        a += *((GLint *)&gc->polygon.shader.aBig);
	    }
            if (gc->polygon.shader.modeFlags & __GL_SHADE_TEXTURE) {
	        s += *((GLint *)&gc->polygon.shader.sBig);
	        t += *((GLint *)&gc->polygon.shader.tBig);
                qw += gc->polygon.shader.qwBig;
            }

	    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) {
		z += gc->polygon.shader.zBig;
                /* The implicit multiply is taken out of the loop */
#ifdef _MCD_
                if (!bMcdZ)
#endif
                {
                    zbuf = (__GLzValue*)((GLubyte*)zbuf +
                           gc->polygon.shader.zbufBig);
                }
	    }
	} else {
	    /* Use small step */
	    ixLeft += gc->polygon.shader.dxLeftLittle;
            if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
	        r += *((GLint *)&gc->polygon.shader.rLittle);
	        g += *((GLint *)&gc->polygon.shader.gLittle);
	        b += *((GLint *)&gc->polygon.shader.bLittle);
	        a += *((GLint *)&gc->polygon.shader.aLittle);
	    }
            if (gc->polygon.shader.modeFlags & __GL_SHADE_TEXTURE) {
                s += *((GLint *)&gc->polygon.shader.sLittle);
	        t += *((GLint *)&gc->polygon.shader.tLittle);
                qw += gc->polygon.shader.qwLittle;
            }

	    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) {
		z += gc->polygon.shader.zLittle;
		/* The implicit multiply is taken out of the loop */
#ifdef _MCD_
                if (!bMcdZ)
#endif
                {
                    zbuf = (__GLzValue*)((GLubyte*)zbuf +
                            gc->polygon.shader.zbufLittle);
                }
	    }
	}
    }

    gc->polygon.shader.ixLeft = ixLeft;
    gc->polygon.shader.ixLeftFrac = ixLeftFrac;
    gc->polygon.shader.ixRight = ixRight;
    gc->polygon.shader.ixRightFrac = ixRightFrac;
    gc->polygon.shader.frag.z = z;
    gc->polygon.shader.zbuf = zbuf;
    GENACCEL(gc).spanValue.r = r;
    GENACCEL(gc).spanValue.g = g;
    GENACCEL(gc).spanValue.b = b;
    GENACCEL(gc).spanValue.a = a;
    GENACCEL(gc).spanValue.s = s;
    GENACCEL(gc).spanValue.t = t;
    gc->polygon.shader.frag.qw = qw;
}

/**************************************************************************\
\**************************************************************************/

void FASTCALL GenDrvFillSubTriangle(__GLcontext *gc, GLint iyBottom, GLint iyTop)
{
    GLint ixLeft, ixRight;
    GLint ixLeftFrac, ixRightFrac;
    GLint spanWidth, clipY0, clipY1;
#ifdef NT
    __GLstippleWord stackWords[__GL_MAX_STACK_STIPPLE_WORDS];
    __GLstippleWord *words;
    GLuint maxWidth;
#else
    __GLstippleWord words[__GL_MAX_STIPPLE_WORDS];
#endif
    GLint zFails;
    __GLzValue *zbuf = NULL, z;
    GLint r, g, b, a, s, t;
    __GLGENcontext  *gengc = (__GLGENcontext *)gc;
    __genSpanFunc cSpanFunc = GENACCEL(gc).__fastSpanFuncPtr;
    __GLspanFunc zSpanFunc = GENACCEL(gc).__fastZSpanFuncPtr;

#ifdef NT
    maxWidth = (gc->transform.clipX1 - gc->transform.clipX0) + 31;
    if (maxWidth > __GL_MAX_STACK_STIPPLE_BITS)
    {
        words = gcTempAlloc(gc, (maxWidth+__GL_STIPPLE_BITS-1)/8);
        if (words == NULL)
        {
            return;
        }
    }
    else
    {
        words = stackWords;
    }
#endif

    gc->polygon.shader.stipplePat = words;
    gc->polygon.shader.cfb = gc->drawBuffer;

    ixLeft = gc->polygon.shader.ixLeft;
    ixLeftFrac = gc->polygon.shader.ixLeftFrac;
    ixRight = gc->polygon.shader.ixRight;
    ixRightFrac = gc->polygon.shader.ixRightFrac;
    clipY0 = gc->transform.clipY0;
    clipY1 = gc->transform.clipY1;

    r = GENACCEL(gc).spanValue.r;
    g = GENACCEL(gc).spanValue.g;
    b = GENACCEL(gc).spanValue.b;
    a = GENACCEL(gc).spanValue.a;
    s = GENACCEL(gc).spanValue.s;
    t = GENACCEL(gc).spanValue.t;

    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) {
        z = gc->polygon.shader.frag.z;

	if( gc->modes.depthBits == 32 )
	    zbuf = __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                                   ixLeft, iyBottom);
	else
	    zbuf = (__GLzValue *)__GL_DEPTH_ADDR(&gc->depthBuffer,
                                                 (__GLz16Value*),
                                                 ixLeft, iyBottom);
    } else {
        GLuint w;

        if (w = ((gc->transform.clipX1 - gc->transform.clipX0) + 31) >> 3)
            RtlFillMemoryUlong(words, w, ~((ULONG)0));
        GENACCEL(gc).flags &= ~(HAVE_STIPPLE);
    }

    while (iyBottom < iyTop) {
	spanWidth = ixRight - ixLeft;
	/*
	** Only render spans that have non-zero width and which are
	** not scissored out vertically.
	*/
	if ((spanWidth > 0) && (iyBottom >= clipY0) && (iyBottom < clipY1)) {
	    gc->polygon.shader.frag.x = ixLeft;
	    gc->polygon.shader.frag.y = iyBottom;
            gc->polygon.shader.zbuf = zbuf;
            gc->polygon.shader.frag.z = z;

            GENACCEL(gc).spanValue.r = r;
            GENACCEL(gc).spanValue.g = g;
            GENACCEL(gc).spanValue.b = b;
            GENACCEL(gc).spanValue.a = a;
            GENACCEL(gc).spanValue.s = s;
            GENACCEL(gc).spanValue.t = t;

            // take care of horizontal scissoring

            if (!gc->transform.reasonableViewport) {
                GLint clipX0 = gc->transform.clipX0;
                GLint clipX1 = gc->transform.clipX1;

                // see if we skip entire span

                if ((ixRight <= clipX0) || (ixLeft >= clipX1))
                    goto advance;

                // now clip right and left

                if (ixRight > clipX1)
                    spanWidth = (clipX1 - ixLeft);

                if (ixLeft < clipX0) {
              	    GLuint delta;

                    delta = clipX0 - ixLeft;
                    spanWidth -= delta;

                    if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
                        GENACCEL(gc).spanValue.r += delta * GENACCEL(gc).spanDelta.r;
                        if (gc->polygon.shader.modeFlags & __GL_SHADE_RGB) {
                            GENACCEL(gc).spanValue.g += delta * GENACCEL(gc).spanDelta.g;
                            GENACCEL(gc).spanValue.b += delta * GENACCEL(gc).spanDelta.b;
                        }
                    }
                    if (gc->polygon.shader.modeFlags & __GL_SHADE_TEXTURE) {
                        GENACCEL(gc).spanValue.s += delta * GENACCEL(gc).spanDelta.s;
                        GENACCEL(gc).spanValue.t += delta * GENACCEL(gc).spanDelta.t;
                    }

            	    gc->polygon.shader.frag.x = clipX0;

                    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_ITER) {
                        if( gc->modes.depthBits == 32 )
                            gc->polygon.shader.zbuf += delta;
                        else
                            (__GLz16Value *)gc->polygon.shader.zbuf += delta;

                        gc->polygon.shader.frag.z +=
                            (gc->polygon.shader.dzdx * delta);
                    }
                }
            }

            // now have span length

	    gc->polygon.shader.length = spanWidth;

            // Do z-buffering if needed, and short-circuit rest of span
            // operations if nothing will be drawn.

            if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_ITER) {
                // initially assume no stippling

                GENACCEL(gc).flags &= ~(HAVE_STIPPLE);
                if ((zFails = (*zSpanFunc)(gc)) == 1)
                    goto advance;
                else if (zFails)
                    GENACCEL(gc).flags |= HAVE_STIPPLE;
            }

            (*cSpanFunc)(gengc);
        }

advance:

	/* Advance right edge fixed point, adjusting for carry */
	ixRightFrac += gc->polygon.shader.dxRightFrac;
	if (ixRightFrac < 0) {
	    /* Carry/Borrow'd. Use large step */
	    ixRight += gc->polygon.shader.dxRightBig;
	    ixRightFrac &= ~0x80000000;
	} else {
	    ixRight += gc->polygon.shader.dxRightLittle;
	}

	iyBottom++;
	ixLeftFrac += gc->polygon.shader.dxLeftFrac;
	if (ixLeftFrac < 0) {
	    /* Carry/Borrow'd.  Use large step */
	    ixLeft += gc->polygon.shader.dxLeftBig;
	    ixLeftFrac &= ~0x80000000;

	    if (gc->polygon.shader.modeFlags & __GL_SHADE_RGB) {
		if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
		    r += *((GLint *)&gc->polygon.shader.rBig);
		    g += *((GLint *)&gc->polygon.shader.gBig);
		    b += *((GLint *)&gc->polygon.shader.bBig);
		    a += *((GLint *)&gc->polygon.shader.aBig);
		}
                if (gc->polygon.shader.modeFlags & __GL_SHADE_TEXTURE) {
		    s += *((GLint *)&gc->polygon.shader.sBig);
		    t += *((GLint *)&gc->polygon.shader.tBig);
                }
	    } else {
		if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
		    r += *((GLint *)&gc->polygon.shader.rBig);
		}
	    }

	    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) {
		z += gc->polygon.shader.zBig;
		/* The implicit multiply is taken out of the loop */
		zbuf = (__GLzValue*)((GLubyte*)zbuf +
                       gc->polygon.shader.zbufBig);
	    }
	} else {
	    /* Use small step */
	    ixLeft += gc->polygon.shader.dxLeftLittle;
	    if (gc->polygon.shader.modeFlags & __GL_SHADE_RGB) {
		if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
		    r += *((GLint *)&gc->polygon.shader.rLittle);
		    g += *((GLint *)&gc->polygon.shader.gLittle);
		    b += *((GLint *)&gc->polygon.shader.bLittle);
		    a += *((GLint *)&gc->polygon.shader.aLittle);
		}
                if (gc->polygon.shader.modeFlags & __GL_SHADE_TEXTURE) {
		    s += *((GLint *)&gc->polygon.shader.sLittle);
		    t += *((GLint *)&gc->polygon.shader.tLittle);
                }
	    } else {
		if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
		    r += *((GLint *)&gc->polygon.shader.rLittle);
		}
            }
	    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) {
		z += gc->polygon.shader.zLittle;
		/* The implicit multiply is taken out of the loop */
		zbuf = (__GLzValue*)((GLubyte*)zbuf +
		        gc->polygon.shader.zbufLittle);
	    }
	}
    }
    gc->polygon.shader.ixLeft = ixLeft;
    gc->polygon.shader.ixLeftFrac = ixLeftFrac;
    gc->polygon.shader.ixRight = ixRight;
    gc->polygon.shader.ixRightFrac = ixRightFrac;
    gc->polygon.shader.frag.z = z;
    GENACCEL(gc).spanValue.r = r;
    GENACCEL(gc).spanValue.g = g;
    GENACCEL(gc).spanValue.b = b;
    GENACCEL(gc).spanValue.a = a;
    GENACCEL(gc).spanValue.s = s;
    GENACCEL(gc).spanValue.t = t;

#ifdef NT
    if (maxWidth > __GL_MAX_STACK_STIPPLE_BITS)
    {
        gcTempFree(gc, words);
    }
#endif
}

/**************************************************************************\
\**************************************************************************/

void GenSnapXLeft(__GLcontext *gc, __GLfloat xLeft, __GLfloat dxdyLeft)
{
    GLint ixLeft, ixLeftFrac;

    ixLeft = __GL_VERTEX_FLOAT_TO_INT(xLeft);
    ixLeftFrac = __GL_VERTEX_PROMOTED_FRACTION(xLeft) + 0x40000000;

    gc->polygon.shader.ixLeftFrac = ixLeftFrac & ~0x80000000;
    gc->polygon.shader.ixLeft = ixLeft + (((GLuint) ixLeftFrac) >> 31);

    /* Compute big and little steps */
    gc->polygon.shader.dxLeftLittle = FTOL(dxdyLeft);
    gc->polygon.shader.dxLeftFrac =
        FLT_FRACTION(dxdyLeft - gc->polygon.shader.dxLeftLittle);

    if (gc->polygon.shader.dxLeftFrac < 0) {
	gc->polygon.shader.dxLeftBig = gc->polygon.shader.dxLeftLittle - 1;
    } else {
	gc->polygon.shader.dxLeftBig = gc->polygon.shader.dxLeftLittle + 1;
    }

    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) {
	/*
	** Compute the big and little depth buffer steps.  We walk the
	** memory pointers for the depth buffer along the edge of the
	** triangle as we walk the edge.  This way we don't have to
	** recompute the buffer address as we go.
	*/
        if (gc->depthBuffer.buf.elementSize == 2) {
            gc->polygon.shader.zbufLittle =
                (gc->depthBuffer.buf.outerWidth +
                 gc->polygon.shader.dxLeftLittle) << 1;
	    gc->polygon.shader.zbufBig =
                (gc->depthBuffer.buf.outerWidth +
                 gc->polygon.shader.dxLeftBig) << 1;
        } else {
            gc->polygon.shader.zbufLittle =
                (gc->depthBuffer.buf.outerWidth +
                 gc->polygon.shader.dxLeftLittle) << 2;
	    gc->polygon.shader.zbufBig =
                (gc->depthBuffer.buf.outerWidth +
                 gc->polygon.shader.dxLeftBig) << 2;
        }
    }
}

/**************************************************************************\
\**************************************************************************/

void GenSnapXRight(__GLcontext *gc, __GLfloat xRight, __GLfloat dxdyRight)
{
    GLint ixRight, ixRightFrac;

    ixRight = __GL_VERTEX_FLOAT_TO_INT(xRight);
    ixRightFrac = __GL_VERTEX_PROMOTED_FRACTION(xRight) + 0x40000000;

    gc->polygon.shader.ixRightFrac = ixRightFrac & ~0x80000000;
    gc->polygon.shader.ixRight = ixRight + (((GLuint) ixRightFrac) >> 31);

    /* Compute big and little steps */
    gc->polygon.shader.dxRightLittle = FTOL(dxdyRight);
    gc->polygon.shader.dxRightFrac =
        FLT_FRACTION(dxdyRight - gc->polygon.shader.dxRightLittle);

    if (gc->polygon.shader.dxRightFrac < 0) {
	gc->polygon.shader.dxRightBig = gc->polygon.shader.dxRightLittle - 1;
    } else {
	gc->polygon.shader.dxRightBig = gc->polygon.shader.dxRightLittle + 1;
    }
}

/**************************************************************************\
\**************************************************************************/


void __fastGenSetInitialParameters(
    __GLcontext *gc,
    const __GLvertex *a,
    __GLfloat fdx,
    __GLfloat fdy)
{

#define sh gc->polygon.shader
#define bPolygonOffset \
        (gc->state.enables.general & __GL_POLYGON_OFFSET_FILL_ENABLE)

    __GLfloat zOffset;
    __GLfloat dxLeftLittle;

#if _X86_ && ENABLE_ASM

    LARGE_INTEGER temp;

    _asm{

    mov     edx, gc
    fild    DWORD PTR [OFFSET(SHADER.dxLeftLittle)][edx]
    mov     edi, [OFFSET(SHADER.modeFlags)][edx]
    test    edi, __GL_SHADE_DEPTH_ITER
    fstp    dxLeftLittle
    je      noZ
    }

        _asm{

        mov     ebx, [OFFSET(__GLcontext.state.enables.general)][edx]
        mov     ecx, __glZero
        test    ebx, __GL_POLYGON_OFFSET_FILL_ENABLE
        mov     zOffset, ecx

        je      noPolyOffset
        }

        zOffset = __glPolygonOffsetZ(gc);
        _asm{
        mov     edx, gc
        mov     edi, [OFFSET(SHADER.modeFlags)][edx]
        }

noPolyOffset:

        _asm{

        mov     eax, a
        fld     fdx
        fmul    DWORD PTR [OFFSET(SHADER.dzdxf)][edx]
        fld     fdy
        fmul    DWORD PTR [OFFSET(SHADER.dzdyf)][edx]
                            // zy zx
        fxch    ST(1)
                            // zx zy
        fadd    DWORD PTR [OFFSET(__GLvertex.window.z)][eax]

        fld     dxLeftLittle
        fmul    DWORD PTR [OFFSET(SHADER.dzdxf)][edx]
                            // zl zy zx
        fxch    ST(1)       // zy zl zx
        fadd    zOffset
        fxch    ST(1)       // zl zy zx
        fadd    DWORD PTR [OFFSET(SHADER.dzdyf)][edx]
                            // zl zy zx (+1)
        fxch    ST(1)       // zy zl zx
        faddp   ST(2), ST   // zl z
        fmul    DWORD PTR [OFFSET(GENGCACCEL.zScale)][edx]
                            // ZL z (+1)
        fxch    ST(1)       // z ZL
        fmul    DWORD PTR [OFFSET(GENGCACCEL.zScale)][edx]
                            // Z ZL
        fxch    ST(1)       // ZL Z
        fistp   temp
        mov     eax, DWORD PTR temp
        mov     DWORD PTR [OFFSET(SHADER.zLittle)][edx], eax
        fistp   temp
        mov     eax, DWORD PTR temp
        mov     DWORD PTR [OFFSET(SHADER.frag.z)][edx], eax
        }


        #if FORCE_NPX_DEBUG
        {
        ULONG fragZ = FTOL((a->window.z + fdx*sh.dzdxf +
                         (fdy*sh.dzdyf + zOffset)) * GENACCEL(gc).zScale);
        __GLfloat zLittle = ((sh.dzdyf + sh.dxLeftLittle * sh.dzdxf)) * GENACCEL(gc).zScale;
        LONG shZLittle = FTOL(zLittle);

        if (sh.frag.z != fragZ)
            DbgPrint("fragZ %x %x\n", fragZ, sh.frag.z);
        if (sh.zLittle != shZLittle)
            DbgPrint("sh.zLittle %x %x\n", shZLittle, sh.zLittle);
        }
        _asm {
        mov     edx, gc
        mov     edi, [OFFSET(SHADER.modeFlags)][edx]
        }
        #endif // FORCE_NPX_DEBUG

noZ:
    _asm{
    test    edi, __GL_SHADE_SMOOTH
    je      done
    test    edi, __GL_SHADE_RGB
    jne     rgbShade
    }

// ciShade:

        {
            CASTFIX(sh.rLittle) =
                FLT_TO_FIX(gc->polygon.shader.drdy +
                           dxLeftLittle * gc->polygon.shader.drdx);
            GENACCEL(gc).spanValue.r =
                FLT_TO_FIX(a->color->r + fdx * sh.drdx + fdy * sh.drdy);
        }
        _asm{
        mov     edx, gc
        mov     edi, [OFFSET(SHADER.modeFlags)][edx]
        jmp     done
        }

rgbShade:

        _asm
        {
        mov     eax, a

        fld     dxLeftLittle
        fmul    DWORD PTR [OFFSET(SHADER.drdx)][edx]
        fld     dxLeftLittle
        fmul    DWORD PTR [OFFSET(SHADER.dgdx)][edx]    // g r
        fxch    ST(1)                                   // r g
        fadd    DWORD PTR [OFFSET(SHADER.drdy)][edx]    // R g
        fld     dxLeftLittle
        fmul    DWORD PTR [OFFSET(SHADER.dbdx)][edx]    // b R g
        fxch    ST(2)                                   // g R b
        fadd    DWORD PTR [OFFSET(SHADER.dgdy)][edx]    // G R b
        fxch    ST(2)                                   // b R G
        fadd    DWORD PTR [OFFSET(SHADER.dbdy)][edx]    // B R G
        fxch    ST(1)                                   // R B G
        fmul    __glVal65536                            // sR B  G
        fxch    ST(2)                                   // G  B  sR
        fmul    __glVal65536                            // sG B  sR
        fxch    ST(1)                                   // B  sG sR
        fmul    __glVal65536                            // sB sG sR
        fxch    ST(2)                                   // sR sG sB
        fistp   DWORD PTR [OFFSET(SHADER.rLittle)][edx]
        fistp   DWORD PTR [OFFSET(SHADER.gLittle)][edx]
        fistp   DWORD PTR [OFFSET(SHADER.bLittle)][edx]

        fld     DWORD PTR [OFFSET(SHADER.drdx)][edx]
        mov     eax, [OFFSET(__GLvertex.color)][eax]
        fmul    fdx
        fld     DWORD PTR [OFFSET(SHADER.drdy)][edx]
        fmul    fdy                                     // r r
        fxch    ST(1)                                   // r r
        fadd    DWORD PTR [OFFSET(__GLcolor.r)][eax]

        fld     DWORD PTR [OFFSET(SHADER.dgdx)][edx]
        fmul    fdx
        fld     DWORD PTR [OFFSET(SHADER.dgdy)][edx]
        fmul    fdy                                     // g g r r
        fxch    ST(1)                                   // g g r r
        fadd    DWORD PTR [OFFSET(__GLcolor.g)][eax]

        fld     DWORD PTR [OFFSET(SHADER.dbdx)][edx]
        fmul    fdx
        fld     DWORD PTR [OFFSET(SHADER.dbdy)][edx]
        fmul    fdy                                     // b b g g r r
        fxch    ST(1)                                   // b b g g r r
        fadd    DWORD PTR [OFFSET(__GLcolor.b)][eax]

        fxch    ST(4)                                   // r b g g b r
        faddp   ST(5), ST                               // b g g b r
        fxch    ST(2)                                   // g g b b r
        faddp   ST(1), ST                               // g b b r
        fxch    ST(2)                                   // b b g r
        faddp   ST(1), ST                               // b g r
        fxch    ST(2)                                   // r g b
        fmul    __glVal65536                            // R g b
        fxch    ST(1)                                   // g R b
        fmul    __glVal65536                            // G R b
        fxch    ST(2)                                   // b R G
        fmul    __glVal65536                            // B R G
        fxch    ST(1)                                   // R B G
        fadd    __glVal128                              // R B G
        fxch    ST(2)                                   // G B R
        fadd    __glVal128                              // G B R
        fxch    ST(1)                                   // B G R
        fadd    __glVal128                              // B G R
        fxch    ST(2)                                   // R G B
        fistp   DWORD PTR [OFFSET(GENGCACCEL.spanValue.r)][edx]
        fistp   DWORD PTR [OFFSET(GENGCACCEL.spanValue.g)][edx]
        fistp   DWORD PTR [OFFSET(GENGCACCEL.spanValue.b)][edx]

        }

        #if FORCE_NPX_DEBUG
        {
        LONG rLittle = FLT_TO_FIX(gc->polygon.shader.drdy +
                                  (__GLfloat)sh.dxLeftLittle * gc->polygon.shader.drdx);
        LONG gLittle = FLT_TO_FIX(gc->polygon.shader.dgdy +
                                  (__GLfloat)sh.dxLeftLittle * gc->polygon.shader.dgdx);
        LONG bLittle = FLT_TO_FIX(gc->polygon.shader.dbdy +
                                  (__GLfloat)sh.dxLeftLittle * gc->polygon.shader.dbdx);
        LONG spanR = FLT_TO_FIX(a->color->r + fdx * sh.drdx + fdy * sh.drdy)+0x0080;
        LONG spanG = FLT_TO_FIX(a->color->g + fdx * sh.dgdx + fdy * sh.dgdy)+0x0080;
        LONG spanB = FLT_TO_FIX(a->color->b + fdx * sh.dbdx + fdy * sh.dbdy)+0x0080;

        if (CASTFIX(sh.rLittle) != rLittle)
            DbgPrint("rLittle: %x %x\n", rLittle, sh.rLittle);
        if (CASTFIX(sh.gLittle) != gLittle)
            DbgPrint("gLittle: %x %x\n", gLittle, sh.gLittle);
        if (CASTFIX(sh.bLittle) != bLittle)
            DbgPrint("bLittle: %x %x\n", bLittle, sh.bLittle);

        if (spanR != GENACCEL(gc).spanValue.r)
            DbgPrint("spanR: %x %x\n", spanR, GENACCEL(gc).spanValue.r);
        if (spanG != GENACCEL(gc).spanValue.g)
            DbgPrint("spanG: %x %x\n", spanG, GENACCEL(gc).spanValue.g);
        if (spanB != GENACCEL(gc).spanValue.b)
            DbgPrint("spanB: %x %x\n", spanB, GENACCEL(gc).spanValue.b);

        }
        _asm {
        mov     edx, gc
        mov     edi, [OFFSET(SHADER.modeFlags)][edx]
        }
        #endif // FORCE_NPX_DEBUG

done:

    _asm {

        mov     eax, [OFFSET(SHADER.dxLeftBig)][edx]
        mov     ecx, [OFFSET(SHADER.dxLeftLittle)][edx]

        cmp     eax, ecx
        jle     littleGreater

	test	edi, __GL_SHADE_SMOOTH
        je      bigNoSmooth

        mov     eax, [OFFSET(SHADER.rLittle)][edx]
        mov     ecx, [OFFSET(SPANDELTA.r)][edx]
        mov     esi, [OFFSET(SHADER.gLittle)][edx]
        mov     ebx, [OFFSET(SPANDELTA.g)][edx]
        add     eax, ecx
        add     esi, ebx
        mov     [OFFSET(SHADER.rBig)][edx], eax
        mov     [OFFSET(SHADER.gBig)][edx], esi

        mov     eax, [OFFSET(SHADER.bLittle)][edx]
        mov     ecx, [OFFSET(SPANDELTA.b)][edx]
        mov     esi, [OFFSET(SHADER.zLittle)][edx]
        mov     ebx, [OFFSET(SHADER.dzdx)][edx]
        add     eax, ecx
        add     esi, ebx
        mov     [OFFSET(SHADER.bBig)][edx], eax
        mov     [OFFSET(SHADER.zBig)][edx], esi

    bigNoSmooth:
	test	edi, __GL_SHADE_DEPTH_ITER
        je      done2

        mov     eax, [OFFSET(SHADER.zLittle)][edx]
        mov     ecx, [OFFSET(SHADER.dzdx)][edx]
        add     eax, ecx
        mov     [OFFSET(SHADER.zBig)][edx], eax

        jmp     done2

littleGreater:

	test	edi, __GL_SHADE_SMOOTH
        je      smallNoSmooth

        mov     eax, [OFFSET(SHADER.rLittle)][edx]
        mov     ecx, [OFFSET(SPANDELTA.r)][edx]
        mov     esi, [OFFSET(SHADER.gLittle)][edx]
        mov     ebx, [OFFSET(SPANDELTA.g)][edx]
        sub     eax, ecx
        sub     esi, ebx
        mov     [OFFSET(SHADER.rBig)][edx], eax
        mov     [OFFSET(SHADER.gBig)][edx], esi

        mov     eax, [OFFSET(SHADER.bLittle)][edx]
        mov     ecx, [OFFSET(SPANDELTA.b)][edx]
        mov     esi, [OFFSET(SHADER.zLittle)][edx]
        mov     ebx, [OFFSET(SHADER.dzdx)][edx]
        sub     eax, ecx
        sub     esi, ebx
        mov     [OFFSET(SHADER.bBig)][edx], eax
        mov     [OFFSET(SHADER.zBig)][edx], esi

    smallNoSmooth:
	test	edi, __GL_SHADE_DEPTH_ITER
        je      done2

        mov     eax, [OFFSET(SHADER.zLittle)][edx]
        mov     ecx, [OFFSET(SHADER.dzdx)][edx]
        sub     eax, ecx
        mov     [OFFSET(SHADER.zBig)][edx], eax
done2:
    }

#else _X86_

    __GLfloat zLittle;

    dxLeftLittle = (__GLfloat)sh.dxLeftLittle;

    if (sh.modeFlags & __GL_SHADE_SMOOTH) {
        if (sh.modeFlags & __GL_SHADE_RGB) {

            CASTFIX(sh.rLittle) =
                FLT_TO_FIX(gc->polygon.shader.drdy +
                           dxLeftLittle * gc->polygon.shader.drdx);
            CASTFIX(sh.gLittle) =
                FLT_TO_FIX(gc->polygon.shader.dgdy +
                           dxLeftLittle * gc->polygon.shader.dgdx);
            CASTFIX(sh.bLittle) =
                FLT_TO_FIX(gc->polygon.shader.dbdy +
                           dxLeftLittle * gc->polygon.shader.dbdx);

            GENACCEL(gc).spanValue.r =
                FLT_TO_FIX(a->color->r + fdx * sh.drdx + fdy * sh.drdy);
            GENACCEL(gc).spanValue.g =
                FLT_TO_FIX(a->color->g + fdx * sh.dgdx + fdy * sh.dgdy);
            GENACCEL(gc).spanValue.b =
                FLT_TO_FIX(a->color->b + fdx * sh.dbdx + fdy * sh.dbdy);
        } else {
            CASTFIX(sh.rLittle) =
                FLT_TO_FIX(gc->polygon.shader.drdy +
                           dxLeftLittle * gc->polygon.shader.drdx);
            GENACCEL(gc).spanValue.r =
                FLT_TO_FIX(a->color->r + fdx * sh.drdx + fdy * sh.drdy);
        }
    }

    if (sh.modeFlags & __GL_SHADE_DEPTH_ITER) {
        zOffset = bPolygonOffset ? __glPolygonOffsetZ(gc) : 0.0f;
        sh.frag.z = FTOL((a->window.z + fdx*sh.dzdxf +
                         (fdy*sh.dzdyf + zOffset)) * GENACCEL(gc).zScale);
        zLittle = ((sh.dzdyf + sh.dxLeftLittle * sh.dzdxf)) * GENACCEL(gc).zScale;
        sh.zLittle = FTOL(zLittle);
    }

    if (sh.dxLeftBig > sh.dxLeftLittle) {

	if (sh.modeFlags & __GL_SHADE_SMOOTH) {
            CASTFIX(sh.rBig) = CASTFIX(sh.rLittle) + GENACCEL(gc).spanDelta.r;
            CASTFIX(sh.gBig) = CASTFIX(sh.gLittle) + GENACCEL(gc).spanDelta.g;
            CASTFIX(sh.bBig) = CASTFIX(sh.bLittle) + GENACCEL(gc).spanDelta.b;
        }

	if (sh.modeFlags & __GL_SHADE_DEPTH_ITER) {
            sh.zBig = sh.zLittle + sh.dzdx;
	}
    } else {	

	if (sh.modeFlags & __GL_SHADE_SMOOTH) {
            CASTFIX(sh.rBig) = CASTFIX(sh.rLittle) - GENACCEL(gc).spanDelta.r;
            CASTFIX(sh.gBig) = CASTFIX(sh.gLittle) - GENACCEL(gc).spanDelta.g;
            CASTFIX(sh.bBig) = CASTFIX(sh.bLittle) - GENACCEL(gc).spanDelta.b;
        }

	if (sh.modeFlags & __GL_SHADE_DEPTH_ITER) {
            sh.zBig = sh.zLittle - sh.dzdx;
	}
    }
#endif
}


void __fastGenSetInitialParametersTexRGBA(
    __GLcontext *gc,
    const __GLvertex *a,
    __GLfloat fdx,
    __GLfloat fdy)
{
#define sh gc->polygon.shader

    __GLfloat zOffset;
    __GLfloat dxLeftLittle;

#if _X86_ && ENABLE_ASM

    LARGE_INTEGER temp;

    _asm{

    mov     edx, gc
    mov     edi, [OFFSET(SHADER.modeFlags)][edx]
    fild    DWORD PTR [OFFSET(SHADER.dxLeftLittle)][edx]
    test    edi, __GL_SHADE_TEXTURE
    mov     eax, [OFFSET(__GLcontext.state.texture.env)][edx]
    je      notTexture
    mov     ebx, [OFFSET(__GLtextureEnvState.mode)][eax]
    cmp     ebx, GL_REPLACE
    je      fastReplace
    cmp     ebx, GL_DECAL
    jne     notTexture
fastReplace:
    fstp    dxLeftLittle
    jmp     colorDone

notTexture:

    test    edi, __GL_SHADE_SMOOTH
    fstp    dxLeftLittle
    je      colorDone

    }
        _asm
        {
        mov     eax, a
        fld     dxLeftLittle
        fmul    DWORD PTR [OFFSET(SHADER.drdx)][edx]
        fld     dxLeftLittle
        fmul    DWORD PTR [OFFSET(SHADER.dgdx)][edx]    // g r
        fxch    ST(1)                                   // r g
        fadd    DWORD PTR [OFFSET(SHADER.drdy)][edx]    // R g
        fld     dxLeftLittle
        fmul    DWORD PTR [OFFSET(SHADER.dbdx)][edx]    // b R g
        fxch    ST(2)                                   // g R b
        fadd    DWORD PTR [OFFSET(SHADER.dgdy)][edx]    // G R b
        fxch    ST(2)                                   // b R G
        fadd    DWORD PTR [OFFSET(SHADER.dbdy)][edx]    // B R G
        fxch    ST(1)                                   // R B G
        fmul    __glVal65536                            // sR B  G
        fxch    ST(2)                                   // G  B  sR
        fmul    __glVal65536                            // sG B  sR
        fxch    ST(1)                                   // B  sG sR
        fmul    __glVal65536                            // sB sG sR
        fxch    ST(2)                                   // sR sG sB
        fistp   DWORD PTR [OFFSET(SHADER.rLittle)][edx]
        mov     eax, [OFFSET(__GLvertex.color)][eax]
        fistp   DWORD PTR [OFFSET(SHADER.gLittle)][edx]
        fistp   DWORD PTR [OFFSET(SHADER.bLittle)][edx]


        fld     DWORD PTR [OFFSET(SHADER.drdx)][edx]
        fmul    fdx
        fld     DWORD PTR [OFFSET(SHADER.drdy)][edx]
        fmul    fdy                                     // r r
        fxch    ST(1)                                   // r r
        fadd    DWORD PTR [OFFSET(__GLcolor.r)][eax]

        fld     DWORD PTR [OFFSET(SHADER.dgdx)][edx]
        fmul    fdx
        fld     DWORD PTR [OFFSET(SHADER.dgdy)][edx]
        fmul    fdy                                     // g g r r
        fxch    ST(1)                                   // g g r r
        fadd    DWORD PTR [OFFSET(__GLcolor.g)][eax]

        fld     DWORD PTR [OFFSET(SHADER.dbdx)][edx]
        fmul    fdx
        fld     DWORD PTR [OFFSET(SHADER.dbdy)][edx]
        fmul    fdy                                     // b b g g r r
        fxch    ST(1)                                   // b b g g r r
        fadd    DWORD PTR [OFFSET(__GLcolor.b)][eax]

        fxch    ST(4)                                   // r b g g b r
        faddp   ST(5), ST                               // b g g b r
        fxch    ST(2)                                   // g g b b r
        faddp   ST(1), ST                               // g b b r
        fxch    ST(2)                                   // b b g r
        faddp   ST(1), ST                               // b g r
        fxch    ST(2)                                   // r g b
        fmul    __glVal65536                            // R g b
        fxch    ST(1)                                   // g R b
        fmul    __glVal65536                            // G R b
        fxch    ST(2)                                   // b R G
        fmul    __glVal65536                            // B R G
        fxch    ST(1)                                   // R B G
        fadd    __glVal128                              // R B G
        fxch    ST(2)                                   // G B R
        fadd    __glVal128                              // G B R
        fxch    ST(1)                                   // B G R
        fadd    __glVal128                              // B G R
        fxch    ST(2)                                   // R G B
        fistp   DWORD PTR [OFFSET(GENGCACCEL.spanValue.r)][edx]
        fistp   DWORD PTR [OFFSET(GENGCACCEL.spanValue.g)][edx]
        mov     ebx, [OFFSET(__GLcontext.state.enables.general)][edx]
        fistp   DWORD PTR [OFFSET(GENGCACCEL.spanValue.b)][edx]

        }

        _asm{
        test    ebx, __GL_BLEND_ENABLE
        je      noBlend

        }
            _asm{
            mov     eax, a

            fld     DWORD PTR [OFFSET(SHADER.dadx)][edx]
            mov     eax, DWORD PTR [OFFSET(__GLvertex.color)][eax]
            fmul    fdx
            fld     DWORD PTR [OFFSET(SHADER.dady)][edx]
            fmul    fdy                                     // a a
            fxch    ST(1)
            fadd    DWORD PTR [OFFSET(__GLcolor.a)][eax]    // a a

            fld     dxLeftLittle
            fmul    DWORD PTR [OFFSET(SHADER.dadx)][edx]    // al a a
            fxch    ST(1)                                   // a al a
            faddp   ST(2), ST                               // al a
            fadd    DWORD PTR [OFFSET(SHADER.dady)][edx]    // al a (+1)
            fxch    ST(1)                                   // a al
            fmul    DWORD PTR [OFFSET(GENGCACCEL.aAccelScale)][edx]
                                                            // A al
            fxch    ST(1)                                   // al A
            fmul    DWORD PTR [OFFSET(GENGCACCEL.aAccelScale)][edx]
                                                            // AL A (+1)
            fxch    ST(1)                                   // A AL
            fadd    __glVal128                              // A AL (+1)
            fxch    ST(1)                                   // AL A
            fistp   DWORD PTR [OFFSET(SHADER.aLittle)][edx]
            fistp   DWORD PTR [OFFSET(GENGCACCEL.spanValue.a)][edx]

            }

            #if FORCE_NPX_DEBUG
            {
            LONG aLittle = FTOL((gc->polygon.shader.dady +
                                (__GLfloat)sh.dxLeftLittle * gc->polygon.shader.dadx) *
                                GENACCEL(gc).aAccelScale);

            LONG spanA = FTOL((a->color->a + fdx * sh.dadx + fdy * sh.dady) *
                              GENACCEL(gc).aAccelScale)+0x0080;

            if (aLittle != CASTFIX(sh.aLittle))
                DbgPrint("sh.aLittle %x %x\n", aLittle, CASTFIX(sh.aLittle));
            if (spanA != GENACCEL(gc).spanValue.a)
                DbgPrint("spanValue.a %x %x\n", spanA, GENACCEL(gc).spanValue.a);
            }
            _asm {
            mov     edx, gc
            mov     edi, [OFFSET(SHADER.modeFlags)][edx]
            }
            #endif // FORCE_NPX_DEBUG

noBlend:

        #if FORCE_NPX_DEBUG
        {
        LONG rLittle = FLT_TO_FIX(gc->polygon.shader.drdy +
                                  (__GLfloat)sh.dxLeftLittle * gc->polygon.shader.drdx);
        LONG gLittle = FLT_TO_FIX(gc->polygon.shader.dgdy +
                                  (__GLfloat)sh.dxLeftLittle * gc->polygon.shader.dgdx);
        LONG bLittle = FLT_TO_FIX(gc->polygon.shader.dbdy +
                                  (__GLfloat)sh.dxLeftLittle * gc->polygon.shader.dbdx);
        LONG spanR = FLT_TO_FIX(a->color->r + fdx * sh.drdx + fdy * sh.drdy)+0x0080;
        LONG spanG = FLT_TO_FIX(a->color->g + fdx * sh.dgdx + fdy * sh.dgdy)+0x0080;
        LONG spanB = FLT_TO_FIX(a->color->b + fdx * sh.dbdx + fdy * sh.dbdy)+0x0080;

        if (CASTFIX(sh.rLittle) != rLittle)
            DbgPrint("rLittle: %x %x\n", rLittle, sh.rLittle);
        if (CASTFIX(sh.gLittle) != gLittle)
            DbgPrint("gLittle: %x %x\n", gLittle, sh.gLittle);
        if (CASTFIX(sh.bLittle) != bLittle)
            DbgPrint("bLittle: %x %x\n", bLittle, sh.bLittle);

        if (spanR != GENACCEL(gc).spanValue.r)
            DbgPrint("spanR: %x %x\n", spanR, GENACCEL(gc).spanValue.r);
        if (spanG != GENACCEL(gc).spanValue.g)
            DbgPrint("spanG: %x %x\n", spanG, GENACCEL(gc).spanValue.g);
        if (spanB != GENACCEL(gc).spanValue.b)
            DbgPrint("spanB: %x %x\n", spanB, GENACCEL(gc).spanValue.b);
        }
        _asm {
        mov     edx, gc
        mov     edi, [OFFSET(SHADER.modeFlags)][edx]
        }

        #endif // FORCE_NPX_DEBUG

colorDone:

    _asm{
    test    edi, __GL_SHADE_TEXTURE
    je      doneTexture

        mov     ebx, [OFFSET(__GLcontext.state.hints.perspectiveCorrection)][edx]
        cmp     ebx, GL_NICEST
        je      nicestTex
    }

            _asm{
            mov     eax, a

            fld     dxLeftLittle
            fmul    DWORD PTR [OFFSET(SHADER.dsdx)][edx]
            fld     dxLeftLittle
            fmul    DWORD PTR [OFFSET(SHADER.dtdx)][edx]
                                            // dt ds
            fld     fdx
            fmul    DWORD PTR [OFFSET(SHADER.dsdx)][edx]
            fld     fdy
            fmul    DWORD PTR [OFFSET(SHADER.dsdy)][edx]
            fxch    ST(1)                   // s  s dt ds
            fadd    DWORD PTR [OFFSET(__GLvertex.texture.x)][eax]

            fxch    ST(3)                   // ds s dt s
            fadd    DWORD PTR [OFFSET(SHADER.dsdy)][edx]

            fld     fdx
            fmul    DWORD PTR [OFFSET(SHADER.dtdx)][edx]
            fld     fdy
            fmul    DWORD PTR [OFFSET(SHADER.dtdy)][edx]
            fxch    ST(1)                   // t t ds s dt s
            fadd    DWORD PTR [OFFSET(__GLvertex.texture.y)][eax]

            fxch    ST(4)                   // dt t ds s t s
            fadd    DWORD PTR [OFFSET(SHADER.dtdy)][edx]

            fxch    ST(5)                   // s t ds s t dt
            faddp   ST(3), ST               // t ds s t dt
            faddp   ST(3), ST               // ds s t dt
            fmul    DWORD PTR [OFFSET(GENGCACCEL.texXScale)][edx]
                                            // DS s t dt
            fxch    ST(3)                   // dt s t DS
            fmul    DWORD PTR [OFFSET(GENGCACCEL.texYScale)][edx]
                                            // DT s t DS
            fxch    ST(1)                   // s DT t DS
            fmul    DWORD PTR [OFFSET(GENGCACCEL.texXScale)][edx]
                                            // S DT t DS
            fxch    ST(2)                   // t DT S DS
            fmul    DWORD PTR [OFFSET(GENGCACCEL.texYScale)][edx]
                                            // T DT S DS
            fxch    ST(3)                   // DS DT S T

            fistp   DWORD PTR [OFFSET(SHADER.sLittle)][edx]
            fistp   DWORD PTR [OFFSET(SHADER.tLittle)][edx]
            fistp   DWORD PTR [OFFSET(GENGCACCEL.spanValue.s)][edx]
            fistp   DWORD PTR [OFFSET(GENGCACCEL.spanValue.t)][edx]

            #if !FORCE_NPX_DEBUG
            jmp     doneTexture
            #endif
            }

            #if FORCE_NPX_DEBUG
            {
            LONG sLittle = FTOL((gc->polygon.shader.dsdy + (__GLfloat)sh.dxLeftLittle *
                           gc->polygon.shader.dsdx) * GENACCEL(gc).texXScale);
            LONG tLittle = FTOL((gc->polygon.shader.dtdy + (__GLfloat)sh.dxLeftLittle *
                           gc->polygon.shader.dtdx) * GENACCEL(gc).texYScale);
            LONG spanS = FTOL((a->texture.x +
                         (fdx * sh.dsdx) + (fdy * sh.dsdy)) * GENACCEL(gc).texXScale);
            LONG spanT = FTOL((a->texture.y +
                         (fdx * sh.dtdx) + (fdy * sh.dtdy)) * GENACCEL(gc).texYScale);

            if (sLittle != CASTFIX(sh.sLittle))
                DbgPrint("sLittle %x %x\n", sLittle, CASTFIX(sh.sLittle));
            if (tLittle != CASTFIX(sh.tLittle))
                DbgPrint("tLittle %x %x\n", tLittle, CASTFIX(sh.tLittle));

            if (GENACCEL(gc).spanValue.s != spanS)
                DbgPrint("spanValue.s %x %x\n", spanS, GENACCEL(gc).spanValue.s);
            if (GENACCEL(gc).spanValue.t != spanT)
                DbgPrint("spanValue.t %x %x\n", spanT, GENACCEL(gc).spanValue.t);
            }
            _asm {
            mov     edx, gc
            mov     edi, [OFFSET(SHADER.modeFlags)][edx]
            jmp     doneTexture;
            }
            #endif // FORCE_NPX_DEBUG

nicestTex:

            _asm{
            mov     eax, a

            fld     dxLeftLittle
            fmul    DWORD PTR [OFFSET(SHADER.dsdx)][edx]
            fld     dxLeftLittle
            fmul    DWORD PTR [OFFSET(SHADER.dtdx)][edx]
                                            // dt ds

            fld     DWORD PTR fdx
            fmul    DWORD PTR [OFFSET(SHADER.dqwdx)][edx]
                                            // qwx dt ds
            fxch    ST(2)
                                            // ds dt qwx
            fadd    DWORD PTR [OFFSET(SHADER.dsdy)][edx]
            fxch    ST(1)                   // dt ds qwx
            fadd    DWORD PTR [OFFSET(SHADER.dtdy)][edx]
            fxch    ST(2)                   // qwx ds dt

            fld     DWORD PTR fdy
            fmul    DWORD PTR [OFFSET(SHADER.dqwdy)][edx]
                                            // qwy qwx ds dt
            fxch    ST(2)                   // ds qwx qwy dt
            fmul    DWORD PTR [OFFSET(GENGCACCEL.texXScale)][edx]
            fxch    ST(3)                   // dt qwx qwy ds
            fmul    DWORD PTR [OFFSET(GENGCACCEL.texYScale)][edx]
            fxch    ST(2)                   // qwy qwx dt ds

            fld     DWORD PTR [OFFSET(__GLvertex.texture.w)][eax]
            fmul    DWORD PTR [OFFSET(__GLvertex.window.w)][eax]
                                            // qww qwy qwx dt ds

            fxch    ST(4)                   // ds qwy qwx dt qww
            fistp   DWORD PTR [OFFSET(SHADER.sLittle)][edx]
                                            // qwy qwx dt qww

            faddp   ST(1), ST               // qw dt qww
            fxch    ST(1)                   // dt qw qww
            fistp   DWORD PTR [OFFSET(SHADER.tLittle)][edx]
                                            // qw qww

            fld     DWORD PTR [OFFSET(SHADER.dqwdx)][edx]
            fmul    dxLeftLittle            // lt qw qww
            fxch    ST(1)                   // qw lt qww
            faddp   ST(2), ST               // lt qw

            fld     DWORD PTR [OFFSET(__GLvertex.texture.x)][eax]
            fmul    DWORD PTR [OFFSET(__GLvertex.window.w)][eax]
                                            // s  lt qw
            fxch    ST(1)                   // lt s  qw
            fadd    DWORD PTR [OFFSET(SHADER.dqwdy)][edx]
            fxch    ST(1)                   // s  lt qw
            fld     fdx
            fmul    DWORD PTR [OFFSET(SHADER.dsdx)][edx]
            fld     fdy
            fmul    DWORD PTR [OFFSET(SHADER.dsdy)][edx]
            fxch    ST(1)                   // s  s  s  lt qw
            faddp   ST(2), ST               // s  s  lt qw

            fld     DWORD PTR [OFFSET(__GLvertex.texture.y)][eax]
            fmul    DWORD PTR [OFFSET(__GLvertex.window.w)][eax]
            fld     fdx
            fmul    DWORD PTR [OFFSET(SHADER.dtdx)][edx]

                                            // t  t  s  s  lt qw
            fxch    ST(2)                   // s  t  t  s  lt qw
            faddp   ST(3), ST               // t  t  s  lt qw
            fld     fdy
            fmul    DWORD PTR [OFFSET(SHADER.dtdy)][edx]

            fxch    ST(1)                   // t  t  t  s  lt qw
            faddp   ST(2), ST               // t  t  s  lt qw
            fxch    ST(2)                   // s  t  t  lt qw

            fmul    DWORD PTR [OFFSET(GENGCACCEL.texXScale)][edx]
                                            // S  t  t  lt qw

            fxch    ST(4)                   // qw t  t  lt S
            fstp    DWORD PTR [OFFSET(SHADER.frag.qw)][edx]

            faddp   ST(1), ST               // t  lt S
            fxch    ST(1)                   // lt t  S
            fstp    DWORD PTR [OFFSET(SHADER.qwLittle)][edx]
                                            // t  S
            fmul    DWORD PTR [OFFSET(GENGCACCEL.texYScale)][edx]   // (+1)
                                            // T S
            fxch    ST(1)                   // S T
            fistp   DWORD PTR [OFFSET(GENGCACCEL.spanValue.s)][edx]
            fistp   DWORD PTR [OFFSET(GENGCACCEL.spanValue.t)][edx]

            }

            #if FORCE_NPX_DEBUG
            {
            LONG sLittle = FTOL((gc->polygon.shader.dsdy + dxLeftLittle *
                           gc->polygon.shader.dsdx) * GENACCEL(gc).texXScale);
            LONG tLittle = FTOL((gc->polygon.shader.dtdy + dxLeftLittle *
                           gc->polygon.shader.dtdx) * GENACCEL(gc).texYScale);
            __GLfloat qw = (a->texture.w * a->window.w) + (fdx * sh.dqwdx) +
                           (fdy * sh.dqwdy);
            __GLfloat qwLittle = sh.dqwdy + dxLeftLittle * sh.dqwdx;
            LONG spanS = FTOL(((a->texture.x * a->window.w) +
                         (fdx * sh.dsdx) + (fdy * sh.dsdy)) * GENACCEL(gc).texXScale);
            LONG spanT = FTOL(((a->texture.y * a->window.w) +
                         (fdx * sh.dtdx) + (fdy * sh.dtdy)) * GENACCEL(gc).texYScale);

            if (sLittle != CASTFIX(sh.sLittle))
                DbgPrint("sLittle %x %x\n", sLittle, CASTFIX(sh.sLittle));
            if (tLittle != CASTFIX(sh.tLittle))
                DbgPrint("tLittle %x %x\n", tLittle, CASTFIX(sh.tLittle));

            if (qw != sh.frag.qw)
                DbgPrint("qw %f %f\n", qw, sh.frag.qw);
            if (qwLittle != sh.qwLittle)
                DbgPrint("qw %f %f\n", qwLittle, sh.qwLittle);

            if (GENACCEL(gc).spanValue.s != spanS)
                DbgPrint("spanValue.s %x %x\n", spanS, GENACCEL(gc).spanValue.s);
            if (GENACCEL(gc).spanValue.t != spanT)
                DbgPrint("spanValue.t %x %x\n", spanT, GENACCEL(gc).spanValue.t);
            }
            _asm {
            mov     edx, gc
            mov     edi, [OFFSET(SHADER.modeFlags)][edx]
            }
            #endif // FORCE_NPX_DEBUG

doneTexture:

    _asm{
    test    edi, __GL_SHADE_DEPTH_ITER
    je      noZ
    }

        _asm{

        mov     ebx, [OFFSET(__GLcontext.state.enables.general)][edx]
        mov     ecx, __glZero
        test    ebx, __GL_POLYGON_OFFSET_FILL_ENABLE
        mov     zOffset, ecx

        je      noPolyOffset
        }

        zOffset = __glPolygonOffsetZ(gc);

        _asm{
        mov     edx, gc
        mov     edi, [OFFSET(SHADER.modeFlags)][edx]
        }

noPolyOffset:

        _asm{

        mov     eax, a
        fld     fdx
        fmul    DWORD PTR [OFFSET(SHADER.dzdxf)][edx]
        fld     fdy
        fmul    DWORD PTR [OFFSET(SHADER.dzdyf)][edx]
                            // zy zx
        fxch    ST(1)
                            // zx zy
        fadd    DWORD PTR [OFFSET(__GLvertex.window.z)][eax]

        fld     dxLeftLittle
        fmul    DWORD PTR [OFFSET(SHADER.dzdxf)][edx]
                            // zl zy zx
        fxch    ST(1)       // zy zl zx
        fadd    zOffset
        fxch    ST(1)       // zl zy zx
        fadd    DWORD PTR [OFFSET(SHADER.dzdyf)][edx]
                            // zl zy zx (+1)
        fxch    ST(1)       // zy zl zx
        faddp   ST(2), ST   // zl z
        fmul    DWORD PTR [OFFSET(GENGCACCEL.zScale)][edx]
                            // ZL z (+1)
        fxch    ST(1)       // z ZL
        fmul    DWORD PTR [OFFSET(GENGCACCEL.zScale)][edx]
                            // Z ZL
        fxch    ST(1)       // ZL Z
        fistp   temp
        mov     eax, DWORD PTR temp
        mov     DWORD PTR [OFFSET(SHADER.zLittle)][edx], eax
        fistp   temp
        mov     eax, DWORD PTR temp
        mov     DWORD PTR [OFFSET(SHADER.frag.z)][edx], eax
        }


        #if FORCE_NPX_DEBUG
        {
        ULONG fragZ = FTOL((a->window.z + fdx*sh.dzdxf +
                         (fdy*sh.dzdyf + zOffset)) * GENACCEL(gc).zScale);
        __GLfloat zLittle = ((sh.dzdyf + sh.dxLeftLittle * sh.dzdxf)) * GENACCEL(gc).zScale;
        LONG shZLittle = FTOL(zLittle);

        if (sh.frag.z != fragZ)
            DbgPrint("fragZ %x %x\n", fragZ, sh.frag.z);
        if (sh.zLittle != shZLittle)
            DbgPrint("sh.zLittle %x %x\n", shZLittle, sh.zLittle);
        }
        _asm {
        mov     edx, gc
        mov     edi, [OFFSET(SHADER.modeFlags)][edx]
        }
        #endif // FORCE_NPX_DEBUG

noZ:

    _asm {

        mov     eax, [OFFSET(SHADER.dxLeftBig)][edx]
        mov     ecx, [OFFSET(SHADER.dxLeftLittle)][edx]

        cmp     eax, ecx
        jle     littleGreater

	test	edi, __GL_SHADE_SMOOTH
        je      bigNoSmooth

        mov     eax, [OFFSET(SHADER.rLittle)][edx]
        mov     ecx, [OFFSET(SPANDELTA.r)][edx]
        mov     esi, [OFFSET(SHADER.gLittle)][edx]
        mov     ebx, [OFFSET(SPANDELTA.g)][edx]
        add     eax, ecx
        add     esi, ebx
        mov     [OFFSET(SHADER.rBig)][edx], eax
        mov     [OFFSET(SHADER.gBig)][edx], esi

        mov     eax, [OFFSET(SHADER.bLittle)][edx]
        mov     ecx, [OFFSET(SPANDELTA.b)][edx]
        mov     esi, [OFFSET(SHADER.aLittle)][edx]
        mov     ebx, [OFFSET(SPANDELTA.a)][edx]
        add     eax, ecx
        add     esi, ebx
        mov     [OFFSET(SHADER.bBig)][edx], eax
        mov     [OFFSET(SHADER.aBig)][edx], esi

    bigNoSmooth:
	test	edi, __GL_SHADE_TEXTURE
        je      bigNoTexture


        fld     DWORD PTR [OFFSET(SHADER.qwLittle)][edx]
        mov     eax, [OFFSET(SHADER.sLittle)][edx]
        fadd    DWORD PTR [OFFSET(SHADER.dqwdx)][edx]
        mov     ecx, [OFFSET(SPANDELTA.s)][edx]
        mov     esi, [OFFSET(SHADER.tLittle)][edx]
        mov     ebx, [OFFSET(SPANDELTA.t)][edx]
        add     eax, ecx
        add     esi, ebx
        mov     [OFFSET(SHADER.sBig)][edx], eax
        mov     [OFFSET(SHADER.tBig)][edx], esi
        fstp    DWORD PTR [OFFSET(SHADER.qwBig)][edx]

    bigNoTexture:
	test	edi, __GL_SHADE_DEPTH_ITER
        je      done

        mov     eax, [OFFSET(SHADER.zLittle)][edx]
        mov     ecx, [OFFSET(SHADER.dzdx)][edx]
        add     eax, ecx
        mov     [OFFSET(SHADER.zBig)][edx], eax

        jmp     done

littleGreater:

	test	edi, __GL_SHADE_SMOOTH
        je      smallNoSmooth

        mov     eax, [OFFSET(SHADER.rLittle)][edx]
        mov     ecx, [OFFSET(SPANDELTA.r)][edx]
        mov     esi, [OFFSET(SHADER.gLittle)][edx]
        mov     ebx, [OFFSET(SPANDELTA.g)][edx]
        sub     eax, ecx
        sub     esi, ebx
        mov     [OFFSET(SHADER.rBig)][edx], eax
        mov     [OFFSET(SHADER.gBig)][edx], esi

        mov     eax, [OFFSET(SHADER.bLittle)][edx]
        mov     ecx, [OFFSET(SPANDELTA.b)][edx]
        mov     esi, [OFFSET(SHADER.aLittle)][edx]
        mov     ebx, [OFFSET(SPANDELTA.a)][edx]
        sub     eax, ecx
        sub     esi, ebx
        mov     [OFFSET(SHADER.bBig)][edx], eax
        mov     [OFFSET(SHADER.aBig)][edx], esi


    smallNoSmooth:
	test	edi, __GL_SHADE_TEXTURE
        je      smallNoTexture


        fld     DWORD PTR [OFFSET(SHADER.qwLittle)][edx]
        mov     eax, [OFFSET(SHADER.sLittle)][edx]
        fsub    DWORD PTR [OFFSET(SHADER.dqwdx)][edx]
        mov     ecx, [OFFSET(SPANDELTA.s)][edx]
        mov     esi, [OFFSET(SHADER.tLittle)][edx]
        mov     ebx, [OFFSET(SPANDELTA.t)][edx]
        sub     eax, ecx
        sub     esi, ebx
        mov     [OFFSET(SHADER.sBig)][edx], eax
        mov     [OFFSET(SHADER.tBig)][edx], esi
        fstp    DWORD PTR [OFFSET(SHADER.qwBig)][edx]

    smallNoTexture:
	test	edi, __GL_SHADE_DEPTH_ITER
        je      done

        mov     eax, [OFFSET(SHADER.zLittle)][edx]
        mov     ecx, [OFFSET(SHADER.dzdx)][edx]
        sub     eax, ecx
        mov     [OFFSET(SHADER.zBig)][edx], eax
done:
    }

#else

    __GLfloat zLittle;
    __GLfloat tmp1, tmp2;

    dxLeftLittle = (float)sh.dxLeftLittle;

    // Don't bother with the color deltas if we're decaling or replacing
    // with textures.

    if ((gc->polygon.shader.modeFlags & __GL_SHADE_TEXTURE) &&
        ((gc->state.texture.env[0].mode == GL_REPLACE) ||
         (gc->state.texture.env[0].mode == GL_DECAL))) {
        ;
    } else if (sh.modeFlags & __GL_SHADE_SMOOTH) {

        CASTFIX(sh.rLittle) =
            FLT_TO_FIX(gc->polygon.shader.drdy +
                       dxLeftLittle * gc->polygon.shader.drdx);
        CASTFIX(sh.gLittle) =
            FLT_TO_FIX(gc->polygon.shader.dgdy +
                       dxLeftLittle * gc->polygon.shader.dgdx);
        CASTFIX(sh.bLittle) =
            FLT_TO_FIX(gc->polygon.shader.dbdy +
                       dxLeftLittle * gc->polygon.shader.dbdx);

        GENACCEL(gc).spanValue.r =
            FLT_TO_FIX(a->color->r + fdx * sh.drdx + fdy * sh.drdy)+0x0080;
        GENACCEL(gc).spanValue.g =
            FLT_TO_FIX(a->color->g + fdx * sh.dgdx + fdy * sh.dgdy)+0x0080;
        GENACCEL(gc).spanValue.b =
            FLT_TO_FIX(a->color->b + fdx * sh.dbdx + fdy * sh.dbdy)+0x0080;

        if (gc->state.enables.general & __GL_BLEND_ENABLE) {

            CASTFIX(sh.aLittle) =
                FTOL((gc->polygon.shader.dady +
                      dxLeftLittle * gc->polygon.shader.dadx) *
                     GENACCEL(gc).aAccelScale);

            GENACCEL(gc).spanValue.a =
                FTOL((a->color->a + fdx * sh.dadx + fdy * sh.dady) *
                     GENACCEL(gc).aAccelScale)+0x0080;
        }
    }

    if (sh.modeFlags & __GL_SHADE_TEXTURE) {

        if (gc->state.hints.perspectiveCorrection != GL_NICEST) {

            tmp1 = (gc->polygon.shader.dsdy + dxLeftLittle *
                    gc->polygon.shader.dsdx) * GENACCEL(gc).texXScale;
            tmp2 = (gc->polygon.shader.dtdy + dxLeftLittle *
                    gc->polygon.shader.dtdx) * GENACCEL(gc).texYScale;

            CASTFIX(sh.sLittle) = FTOL(tmp1);
            CASTFIX(sh.tLittle) = FTOL(tmp2);

            tmp1 = (a->texture.x +
                    (fdx * sh.dsdx) + (fdy * sh.dsdy)) * GENACCEL(gc).texXScale;

            tmp2 = (a->texture.y +
                    (fdx * sh.dtdx) + (fdy * sh.dtdy)) * GENACCEL(gc).texYScale;

            GENACCEL(gc).spanValue.s = FTOL(tmp1);
            GENACCEL(gc).spanValue.t = FTOL(tmp2);

        } else {

            tmp1 = (gc->polygon.shader.dsdy + dxLeftLittle *
                    gc->polygon.shader.dsdx) * GENACCEL(gc).texXScale;
            tmp2 = (gc->polygon.shader.dtdy + dxLeftLittle *
                    gc->polygon.shader.dtdx) * GENACCEL(gc).texYScale;

            CASTFIX(sh.sLittle) = FTOL(tmp1);
            CASTFIX(sh.tLittle) = FTOL(tmp2);

            sh.frag.qw = (a->texture.w * a->window.w) + (fdx * sh.dqwdx) +
                         (fdy * sh.dqwdy);

            sh.qwLittle = sh.dqwdy + dxLeftLittle * sh.dqwdx;

            tmp1 = ((a->texture.x * a->window.w) +
                    (fdx * sh.dsdx) + (fdy * sh.dsdy)) * GENACCEL(gc).texXScale;

            tmp2 = ((a->texture.y * a->window.w) +
                    (fdx * sh.dtdx) + (fdy * sh.dtdy)) * GENACCEL(gc).texYScale;

            GENACCEL(gc).spanValue.s = FTOL(tmp1);
            GENACCEL(gc).spanValue.t = FTOL(tmp2);
        }
    }


    if (sh.modeFlags & __GL_SHADE_DEPTH_ITER) {
        zOffset = bPolygonOffset ? __glPolygonOffsetZ(gc) : 0.0f;
        sh.frag.z = FTOL((a->window.z + fdx*sh.dzdxf +
                         (fdy*sh.dzdyf + zOffset)) * GENACCEL(gc).zScale);
        zLittle = ((sh.dzdyf + sh.dxLeftLittle * sh.dzdxf)) * GENACCEL(gc).zScale;
        sh.zLittle = FTOL(zLittle);
    }

    if (sh.dxLeftBig > sh.dxLeftLittle) {

	if (sh.modeFlags & __GL_SHADE_SMOOTH) {
            CASTFIX(sh.rBig) = CASTFIX(sh.rLittle) + GENACCEL(gc).spanDelta.r;
            CASTFIX(sh.gBig) = CASTFIX(sh.gLittle) + GENACCEL(gc).spanDelta.g;
            CASTFIX(sh.bBig) = CASTFIX(sh.bLittle) + GENACCEL(gc).spanDelta.b;
            if (gc->state.enables.general & __GL_BLEND_ENABLE)
                CASTFIX(sh.aBig) = CASTFIX(sh.aLittle) + GENACCEL(gc).spanDelta.a;
        }

        if (sh.modeFlags & __GL_SHADE_TEXTURE) {
            CASTFIX(sh.sBig) = CASTFIX(sh.sLittle) + GENACCEL(gc).spanDelta.s;
            CASTFIX(sh.tBig) = CASTFIX(sh.tLittle) + GENACCEL(gc).spanDelta.t;
            sh.qwBig = sh.qwLittle + sh.dqwdx;
        }

	if (sh.modeFlags & __GL_SHADE_DEPTH_ITER) {
            sh.zBig = sh.zLittle + sh.dzdx;
	}
    } else {	

	if (sh.modeFlags & __GL_SHADE_SMOOTH) {
            CASTFIX(sh.rBig) = CASTFIX(sh.rLittle) - GENACCEL(gc).spanDelta.r;
            CASTFIX(sh.gBig) = CASTFIX(sh.gLittle) - GENACCEL(gc).spanDelta.g;
            CASTFIX(sh.bBig) = CASTFIX(sh.bLittle) - GENACCEL(gc).spanDelta.b;
            if (gc->state.enables.general & __GL_BLEND_ENABLE)
                CASTFIX(sh.aBig) = CASTFIX(sh.aLittle) - GENACCEL(gc).spanDelta.a;
        }

        if (sh.modeFlags & __GL_SHADE_TEXTURE) {
            CASTFIX(sh.sBig) = CASTFIX(sh.sLittle) - GENACCEL(gc).spanDelta.s;
            CASTFIX(sh.tBig) = CASTFIX(sh.tLittle) - GENACCEL(gc).spanDelta.t;
            sh.qwBig = sh.qwLittle - sh.dqwdx;
        }

	if (sh.modeFlags & __GL_SHADE_DEPTH_ITER) {
            sh.zBig = sh.zLittle - sh.dzdx;
	}
    }
#endif
}

/**************************************************************************\
\**************************************************************************/


void FASTCALL __fastGenCalcDeltas(
    __GLcontext *gc,
    __GLvertex *a,
    __GLvertex *b,
    __GLvertex *c)
{
    __GLfloat oneOverArea, t1, t2, t3, t4;

#if _X86_ && ENABLE_ASM

    LARGE_INTEGER temp;

    _asm{

    mov     edx, gc
    fld     __glOne
    fdiv    DWORD PTR [OFFSET(SHADER.area)][edx]
    mov     edi, [OFFSET(SHADER.modeFlags)][edx]
    test    edi, __GL_SHADE_RGB
    je      notRGB
        test    edi, __GL_SHADE_SMOOTH
        je      notSmoothRGB
    }

            _asm{

            mov     eax, a
            mov     ebx, b
            mov     ecx, c

            fstp    oneOverArea                         // finish divide

            fld     DWORD PTR [OFFSET(SHADER.dyAC)][edx]
            mov     eax, [OFFSET(__GLvertex.color)][eax]
            fmul    oneOverArea
            fld     DWORD PTR [OFFSET(SHADER.dyBC)][edx]
            mov     ebx, [OFFSET(__GLvertex.color)][ebx]
            fmul    oneOverArea                         // dyBC dyAC
            fld     DWORD PTR [OFFSET(SHADER.dxAC)][edx]
            mov     ecx, [OFFSET(__GLvertex.color)][ecx]
            fmul    oneOverArea                         // dxAC dyBC dyAC
            fxch    ST(1)                               // dyBC dxAC dyAC
            fld     DWORD PTR [OFFSET(SHADER.dxBC)][edx]
            fmul    oneOverArea                         // dxBC dyBC dxAC dyAC
            fxch    ST(3)                               // dyAC dyBC dxAC dxBC
            fstp    t1
            fstp    t2
            fstp    t3
            fstp    t4

            // Now, calculate deltas:

                // Red

            fld     DWORD PTR [OFFSET(__GLcolor.r)][eax]
            fsub    DWORD PTR [OFFSET(__GLcolor.r)][ecx]
            fld     DWORD PTR [OFFSET(__GLcolor.r)][ebx]
            fsub    DWORD PTR [OFFSET(__GLcolor.r)][ecx]
                            // drBC drAC
            fld     ST(1)       // drAC drBC drAC
            fmul    t2          // drACt2 drBC drAC
            fld     ST(1)       // drBC drACt2 drBC drAC
            fmul    t1          // drBCt1 drACt2 drBC drAC
            fxch    ST(2)       // drBC drACt2 drBCt1 drAC
            fmul    t3          // drBCt3 drACt2 drBCt1 drAC
            fxch    ST(3)       // drAC drACt2 drBCt1 drBCt3
            fmul    t4          // drACt4 drACt2 drBCt1 drBCt3
            fxch    ST(2)       // drBCt1 drACt2 drACt4 drBCt3
            fsubp   ST(1), ST   // drACBC drACt4 drBCt3

            fld     DWORD PTR [OFFSET(__GLcolor.g)][ebx]
            fsub    DWORD PTR [OFFSET(__GLcolor.g)][ecx]
                            // dgBC drACBC drACt4 drBCt3
            fxch    ST(2)       // drACt4 drACBC dgBC drBCt3
            fsubp   ST(3), ST   // drACBC dgBC drBCAC
            fst     DWORD PTR [OFFSET(SHADER.drdx)][edx]
            fmul    __glVal65536
                            // DRACBC dgBC drBCAC
            fxch    ST(2)       // drBCAC dgBC DRACBC
            fstp    DWORD PTR [OFFSET(SHADER.drdy)][edx]
                            // dgBC DRACBC
            fld     DWORD PTR [OFFSET(__GLcolor.g)][eax]
            fsub    DWORD PTR [OFFSET(__GLcolor.g)][ecx]
                            // dgAC dgBC DRACBC
            fxch    ST(2)       // DRACBC dgBC dgAC
            fistp   DWORD PTR [OFFSET(SPANDELTA.r)][edx]

                // Green
                                // dgBC dgAC
            fld     ST(1)       // dgAC dgBC dgAC
            fmul    t2          // dgACt2 dgBC dgAC
            fld     ST(1)       // dgBC dgACt2 dgBC dgAC
            fmul    t1          // dgBCt1 dgACt2 dgBC dgAC
            fxch    ST(2)       // dgBC dgACt2 dgBCt1 dgAC
            fmul    t3          // dgBCt3 dgACt2 dgBCt1 dgAC
            fxch    ST(3)       // dgAC dgACt2 dgBCt1 dgBCt3
            fmul    t4          // dgACt4 dgACt2 dgBCt1 dgBCt3
            fxch    ST(2)       // dgBCt1 dgACt2 dgACt4 dgBCt3
            fsubp   ST(1), ST   // dgACBC dgACt4 dgBCt3

            fld     DWORD PTR [OFFSET(__GLcolor.b)][ebx]
            fsub    DWORD PTR [OFFSET(__GLcolor.b)][ecx]
                                // dbBC dgACBC dgACt4 dgBCt3
            fxch    ST(2)       // dgACt4 dgACBC dbBC dgBCt3
            fsubp   ST(3), ST   // dgACBC dbBC dgBCAC
            fst     DWORD PTR [OFFSET(SHADER.dgdx)][edx]
            fmul    __glVal65536
                                // DGACBC dbBC dgBCAC
            fxch    ST(2)       // dgBCAC dbBC DGACBC
            fstp    DWORD PTR [OFFSET(SHADER.dgdy)][edx]
                                // dbBC DGACBC
            fld     DWORD PTR [OFFSET(__GLcolor.b)][eax]
            fsub    DWORD PTR [OFFSET(__GLcolor.b)][ecx]
                                // dbAC dbBC DGACBC
            fxch    ST(2)       // DGACBC dbBC dbAC
            fistp   DWORD PTR [OFFSET(SPANDELTA.g)][edx]

                // Blue
                                // dbBC dbAC
            fld     ST(1)       // dbAC dbBC dbAC
            fmul    t2          // dbACt2 dbBC dbAC
            fld     ST(1)       // dbBC dbACt2 dbBC dbAC
            fmul    t1          // dbBCt1 dbACt2 dbBC dbAC
            fxch    ST(2)       // dbBC dbACt2 dbBCt1 dbAC
            fmul    t3          // dbBCt3 dbACt2 dbBCt1 dbAC
            fxch    ST(3)       // dbAC dbACt2 dbBCt1 dbBCt3
            fmul    t4          // dbACt4 dbACt2 dbBCt1 dbBCt3
            fxch    ST(2)       // dbBCt1 dbACt2 dbACt4 dbBCt3
            fsubp   ST(1), ST   // dbACBC dbACt4 dbBCt3
            fxch    ST(1)       // dbACt4 dbACBC dbBCt3
            fsubp   ST(2), ST   // dbACBC dbBCAC (+1)
            fst     DWORD PTR [OFFSET(SHADER.dbdx)][edx]
            fmul    __glVal65536
                                // DBACBC dbBCAC
            fxch    ST(1)       // dbBCAC DBACBC
            fstp    DWORD PTR [OFFSET(SHADER.dbdy)][edx]
            fistp   DWORD PTR [OFFSET(SPANDELTA.b)][edx]

            mov     ebx, [OFFSET(GENGCACCEL.__fastSmoothSpanFuncPtr)][edx]
            mov     [OFFSET(GENGCACCEL.__fastSpanFuncPtr)][edx], ebx

            mov     eax, [OFFSET(SPANDELTA.r)][edx]
            mov     ebx, [OFFSET(SPANDELTA.g)][edx]
            mov     ecx, [OFFSET(SPANDELTA.b)][edx]
            or      eax, ebx
            or      eax, ecx
            jne     notZeroDelta

            mov     eax, [OFFSET(GENGCACCEL.flags)][edx]
            test    eax, GEN_FASTZBUFFER
            jne     notZeroDelta

            mov     ebx, [OFFSET(GENGCACCEL.__fastFlatSpanFuncPtr)][edx]
            mov     [OFFSET(GENGCACCEL.__fastSpanFuncPtr)][edx], ebx

notZeroDelta:

            #if !FORCE_NPX_DEBUG
            jmp     colorDone
            #endif

            }

            #if FORCE_NPX_DEBUG
            {
	    __GLfloat drAC, dgAC, dbAC, daAC;
	    __GLfloat drBC, dgBC, dbBC, daBC;
	    __GLcolor *ac, *bc, *cc;
            __GLfloat ft1 = gc->polygon.shader.dyAC * oneOverArea;
            __GLfloat ft2 = gc->polygon.shader.dyBC * oneOverArea;
            __GLfloat ft3 = gc->polygon.shader.dxAC * oneOverArea;
            __GLfloat ft4 = gc->polygon.shader.dxBC * oneOverArea;
            __GLfloat drdx;
            __GLfloat drdy;
            __GLfloat dgdx;
            __GLfloat dgdy;
            __GLfloat dbdx;
            __GLfloat dbdy;
            LONG spanR, spanG, spanB;

            ac = a->color;
            bc = b->color;
            cc = c->color;

            drAC = ac->r - cc->r;
            drBC = bc->r - cc->r;
            dgAC = ac->g - cc->g;
            dgBC = bc->g - cc->g;
            dbAC = ac->b - cc->b;
            dbBC = bc->b - cc->b;

            drdx = drAC * t2 - drBC * t1;
            drdy = drBC * t3 - drAC * t4;
            dgdx = dgAC * t2 - dgBC * t1;
            dgdy = dgBC * t3 - dgAC * t4;
            dbdx = dbAC * t2 - dbBC * t1;
            dbdy = dbBC * t3 - dbAC * t4;

            spanR = FLT_TO_FIX(drdx);
            spanG = FLT_TO_FIX(dgdx);
            spanB = FLT_TO_FIX(dbdx);

            if (ft1 != t1)
                DbgPrint("t1 %f %f\n", t1, ft1);
            if (ft2 != t2)
                DbgPrint("t2 %f %f\n", t2, ft2);
            if (ft3 != t3)
                DbgPrint("t3 %f %f\n", t3, ft3);
            if (ft4 != t4)
                DbgPrint("t4 %f %f\n", t4, ft4);

            if (drdx != gc->polygon.shader.drdx)
                DbgPrint("drdx %f %f\n", drdx, gc->polygon.shader.drdx);
            if (drdy != gc->polygon.shader.drdy)
                DbgPrint("drdy %f %f\n", drdy, gc->polygon.shader.drdy);
            if (dgdx != gc->polygon.shader.dgdx)
                DbgPrint("dgdx %f %f\n", dgdx, gc->polygon.shader.dgdx);
            if (dgdy != gc->polygon.shader.dgdy)
                DbgPrint("dgdy %f %f\n", dgdy, gc->polygon.shader.dgdy);
            if (dbdx != gc->polygon.shader.dbdx)
                DbgPrint("dbdx %f %f\n", dbdx, gc->polygon.shader.dbdx);
            if (dbdy != gc->polygon.shader.dbdy)
                DbgPrint("dbdy %f %f\n", dbdy, gc->polygon.shader.dbdy);

            if (spanR != GENACCEL(gc).spanDelta.r)
                DbgPrint("spanDelta.r %x %x\n", spanR, GENACCEL(gc).spanDelta.r);
            if (spanG!= GENACCEL(gc).spanDelta.g)
                DbgPrint("spanDelta.g %x %x\n", spanG, GENACCEL(gc).spanDelta.g);
            if (spanB != GENACCEL(gc).spanDelta.b)
                DbgPrint("spanDelta.b %x %x\n", spanB, GENACCEL(gc).spanDelta.b);
            }
            _asm{
            mov     edx, gc
            mov     edi, [OFFSET(SHADER.modeFlags)][edx]
            jmp     colorDone
            }
            #endif // FORCE_NPX_DEBUG


notSmoothRGB:

            _asm{

            mov     eax, [OFFSET(__GLcontext.vertex.provoking)][edx]

            fld     __glVal65536
            mov     eax, [OFFSET(__GLvertex.color)][eax]
            fmul    DWORD PTR [OFFSET(__GLcolor.r)][eax]
            fld     __glVal65536
            fmul    DWORD PTR [OFFSET(__GLcolor.g)][eax]
            fld     __glVal65536
            fmul    DWORD PTR [OFFSET(__GLcolor.b)][eax]
                                                          // B G R
            fxch    ST(2)                                 // R G B
            fistp   DWORD PTR [OFFSET(SPANVALUE.r)][edx]  // G B
            fistp   DWORD PTR [OFFSET(SPANVALUE.g)][edx]
            fistp   DWORD PTR [OFFSET(SPANVALUE.b)][edx]

            mov     ebx, [OFFSET(GENGCACCEL.__fastFlatSpanFuncPtr)][edx]
            mov     [OFFSET(GENGCACCEL.__fastSpanFuncPtr)][edx], ebx

            jmp     colorDone

            }

notRGB:

	if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH)
        {
	    __GLfloat drAC;
	    __GLfloat drBC;
	    __GLcolor *ac, *bc, *cc;

            ac = a->color;
            bc = b->color;
	    cc = c->color;
	    drAC = ac->r - cc->r;
	    drBC = bc->r - cc->r;

            __GL_FLOAT_SIMPLE_END_DIVIDE(oneOverArea);
            t1 = gc->polygon.shader.dyAC * oneOverArea;
            t2 = gc->polygon.shader.dyBC * oneOverArea;
            t3 = gc->polygon.shader.dxAC * oneOverArea;
            t4 = gc->polygon.shader.dxBC * oneOverArea;

	    gc->polygon.shader.drdx = drAC * t2 - drBC * t1;
	    gc->polygon.shader.drdy = drBC * t3 - drAC * t4;

            GENACCEL(gc).spanDelta.r =
                FLT_TO_FIX(gc->polygon.shader.drdx);

            if (GENACCEL(gc).spanDelta.r == 0)
            {
                GENACCEL(gc).__fastSpanFuncPtr =
                    GENACCEL(gc).__fastFlatSpanFuncPtr;
            }
            else
            {
                GENACCEL(gc).__fastSpanFuncPtr =
                    GENACCEL(gc).__fastSmoothSpanFuncPtr;
            }
	}
        else
        {
            GENACCEL(gc).spanValue.r =
                FLT_TO_FIX(gc->vertex.provoking->color->r);

            GENACCEL(gc).__fastSpanFuncPtr =
                GENACCEL(gc).__fastFlatSpanFuncPtr;
	}

        _asm{
        mov     edx, gc
        mov     edi, [OFFSET(SHADER.modeFlags)][edx]
        }


colorDone:

    _asm{
    test    edi, __GL_SHADE_DEPTH_ITER
    je      noZ

        test    edi, __GL_SHADE_SMOOTH
        jne     areaOK
    }

            _asm{

            fstp    oneOverArea                         // finish divide

            fld     DWORD PTR [OFFSET(SHADER.dyAC)][edx]
            fmul    oneOverArea
            fld     DWORD PTR [OFFSET(SHADER.dyBC)][edx]
            fmul    oneOverArea                         // dyBC dyAC
            fld     DWORD PTR [OFFSET(SHADER.dxAC)][edx]
            fmul    oneOverArea                         // dxAC dyBC dyAC
            fxch    ST(1)                               // dyBC dxAC dyAC
            fld     DWORD PTR [OFFSET(SHADER.dxBC)][edx]
            fmul    oneOverArea                         // dxBC dyBC dxAC dyAC
            fxch    ST(3)                               // dyAC dyBC dxAC dxBC
            fstp    t1
            fstp    t2
            fstp    t3
            fstp    t4
            }

            #if FORCE_NPX_DEBUG
            {
            __GLfloat ft1 = gc->polygon.shader.dyAC * oneOverArea;
            __GLfloat ft2 = gc->polygon.shader.dyBC * oneOverArea;
            __GLfloat ft3 = gc->polygon.shader.dxAC * oneOverArea;
            __GLfloat ft4 = gc->polygon.shader.dxBC * oneOverArea;

            if (ft1 != t1)
                DbgPrint("zt1 %f %f\n", t1, ft1);
            if (ft2 != t2)
                DbgPrint("zt2 %f %f\n", t2, ft2);
            if (ft3 != t3)
                DbgPrint("zt3 %f %f\n", t3, ft3);
            if (ft4 != t4)
                DbgPrint("zt4 %f %f\n", t4, ft4);
            }
            _asm{
            mov     edx, gc
            mov     edi, [OFFSET(SHADER.modeFlags)][edx]
            }
            #endif // FORCE_NPX_DEBUG
areaOK:

        _asm{

        mov     ecx, c
        mov     eax, a
        mov     ebx, b

        fld     DWORD PTR [OFFSET(__GLvertex.window.z)][eax]
        fsub    DWORD PTR [OFFSET(__GLvertex.window.z)][ecx]
        fld     DWORD PTR [OFFSET(__GLvertex.window.z)][ebx]
        fsub    DWORD PTR [OFFSET(__GLvertex.window.z)][ecx]
                                                        // dzBC dzAC
        fld     ST(1)                                   // dzAC dzBC dzAC
        fmul    t2                                      // ACt2 dzBC dzAC
        fld     ST(1)                                   // dzBC ACt2 dzBC dzAC
        fmul    t1                                      // BCt1 ACt2 dzBC dzAC
        fxch    ST(3)                                   // dzAC ACt2 dzBC BCt1
        fmul    t4                                      // ACt4 ACt2 dzBC BCt1
        fxch    ST(2)                                   // dzBC ACt2 ACt4 BCt1
        fmul    t3                                      // BCt3 ACt2 ACt4 BCt1
        fsubrp  ST(2),ST                                // ACt2 BCAC BCt1
        fsubrp  ST(2),ST                                // BCAC ACBC
        fxch    ST(1)                                   // ACBC BCAC
                                                        // dzdx dzdy
        fld     ST(0)                                   // dzdx dzdx dzdy
        fmul    DWORD PTR [OFFSET(GENGCACCEL.zScale)][edx]
                                                        // dzdxS dzdx dzdy
        fxch    ST(2)                                   // dzdy dzdx dzdxS
        fstp    DWORD PTR [OFFSET(SHADER.dzdyf)][edx]
        fstp    DWORD PTR [OFFSET(SHADER.dzdxf)][edx]
        fistp   temp
        mov     ebx, DWORD PTR temp
        mov     DWORD PTR [OFFSET(SHADER.dzdx)][edx], ebx
        mov     DWORD PTR [OFFSET(SPANDELTA.z)][edx], ebx
        #if !FORCE_NPX_DEBUG
        jmp     deltaDone
        #endif
        }

        #if FORCE_NPX_DEBUG
        {
        __GLfloat dzdxf;
        __GLfloat dzdyf;
        __GLfloat dzAC, dzBC;
        ULONG spanDeltaZ;

        dzAC = a->window.z - c->window.z;
        dzBC = b->window.z - c->window.z;

        dzdxf = dzAC * t2 - dzBC * t1;
        dzdyf = dzBC * t3 - dzAC * t4;
        spanDeltaZ = FTOL(dzdxf * GENACCEL(gc).zScale);

        if (dzdxf != gc->polygon.shader.dzdxf)
            DbgPrint("dzdxf %f %f\n", dzdxf, gc->polygon.shader.dzdxf);
        if (dzdyf != gc->polygon.shader.dzdyf)
            DbgPrint("dzdyf %f %f\n", dzdyf, gc->polygon.shader.dzdyf);

        if (spanDeltaZ != GENACCEL(gc).spanDelta.z)
            DbgPrint("spanDeltaZ %x %x\n", spanDeltaZ, GENACCEL(gc).spanDelta.z);
        goto deltaDone;
        }
        #endif // FORCE_NPX_DEBUG
noZ:

    _asm{
    test    edi, __GL_SHADE_SMOOTH
    jne     deltaDone
    fstp    ST(0)
    }

deltaDone:
    return;

#else // _X86_

    /* Pre-compute one over polygon area */

    __GL_FLOAT_BEGIN_DIVIDE(__glOne, gc->polygon.shader.area, &oneOverArea);

    /*
    ** t1-4 are delta values for unit changes in x or y for each
    ** parameter.
    */

    if (gc->polygon.shader.modeFlags & __GL_SHADE_RGB)
    {
	if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH)
        {

	    __GLfloat drAC, dgAC, dbAC, daAC;
	    __GLfloat drBC, dgBC, dbBC, daBC;
	    __GLcolor *ac, *bc, *cc;

            ac = a->color;
            bc = b->color;
	    cc = c->color;

	    drAC = ac->r - cc->r;
	    drBC = bc->r - cc->r;
	    dgAC = ac->g - cc->g;
	    dgBC = bc->g - cc->g;
	    dbAC = ac->b - cc->b;
	    dbBC = bc->b - cc->b;

            __GL_FLOAT_SIMPLE_END_DIVIDE(oneOverArea);
            t1 = gc->polygon.shader.dyAC * oneOverArea;
            t2 = gc->polygon.shader.dyBC * oneOverArea;
            t3 = gc->polygon.shader.dxAC * oneOverArea;
            t4 = gc->polygon.shader.dxBC * oneOverArea;

	    gc->polygon.shader.drdx = drAC * t2 - drBC * t1;
	    gc->polygon.shader.drdy = drBC * t3 - drAC * t4;
	    gc->polygon.shader.dgdx = dgAC * t2 - dgBC * t1;
	    gc->polygon.shader.dgdy = dgBC * t3 - dgAC * t4;
	    gc->polygon.shader.dbdx = dbAC * t2 - dbBC * t1;
	    gc->polygon.shader.dbdy = dbBC * t3 - dbAC * t4;

            GENACCEL(gc).spanDelta.r = FLT_TO_FIX(gc->polygon.shader.drdx);
            GENACCEL(gc).spanDelta.g = FLT_TO_FIX(gc->polygon.shader.dgdx);
            GENACCEL(gc).spanDelta.b = FLT_TO_FIX(gc->polygon.shader.dbdx);

            if (   ((GENACCEL(gc).spanDelta.r | GENACCEL(gc).spanDelta.g |
                     GENACCEL(gc).spanDelta.b) == 0)
                && ((GENACCEL(gc).flags & GEN_FASTZBUFFER) == 0))
            {
                GENACCEL(gc).__fastSpanFuncPtr =
                    GENACCEL(gc).__fastFlatSpanFuncPtr;
            }
            else
            {
                GENACCEL(gc).__fastSpanFuncPtr =
                    GENACCEL(gc).__fastSmoothSpanFuncPtr;
            }
	}
        else
        {
            __GLcolor *flatColor = gc->vertex.provoking->color;

            GENACCEL(gc).spanValue.r = FLT_TO_FIX(flatColor->r);
            GENACCEL(gc).spanValue.g = FLT_TO_FIX(flatColor->g);
            GENACCEL(gc).spanValue.b = FLT_TO_FIX(flatColor->b);

            GENACCEL(gc).__fastSpanFuncPtr =
                GENACCEL(gc).__fastFlatSpanFuncPtr;
	}
    }
    else
    {
	if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH)
        {
	    __GLfloat drAC;
	    __GLfloat drBC;
	    __GLcolor *ac, *bc, *cc;

            ac = a->color;
            bc = b->color;
	    cc = c->color;
	    drAC = ac->r - cc->r;
	    drBC = bc->r - cc->r;

            __GL_FLOAT_SIMPLE_END_DIVIDE(oneOverArea);
            t1 = gc->polygon.shader.dyAC * oneOverArea;
            t2 = gc->polygon.shader.dyBC * oneOverArea;
            t3 = gc->polygon.shader.dxAC * oneOverArea;
            t4 = gc->polygon.shader.dxBC * oneOverArea;

	    gc->polygon.shader.drdx = drAC * t2 - drBC * t1;
	    gc->polygon.shader.drdy = drBC * t3 - drAC * t4;

            GENACCEL(gc).spanDelta.r =
                FLT_TO_FIX(gc->polygon.shader.drdx);

            if (GENACCEL(gc).spanDelta.r == 0)
            {
                GENACCEL(gc).__fastSpanFuncPtr =
                    GENACCEL(gc).__fastFlatSpanFuncPtr;
            }
            else
            {
                GENACCEL(gc).__fastSpanFuncPtr =
                    GENACCEL(gc).__fastSmoothSpanFuncPtr;
            }
	}
        else
        {
            GENACCEL(gc).spanValue.r =
                FLT_TO_FIX(gc->vertex.provoking->color->r);

            GENACCEL(gc).__fastSpanFuncPtr =
                GENACCEL(gc).__fastFlatSpanFuncPtr;
	}
    }

    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_ITER)
    {
	__GLfloat dzAC, dzBC;

        if ((gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) == 0)
        {
            __GL_FLOAT_SIMPLE_END_DIVIDE(oneOverArea);
            t1 = gc->polygon.shader.dyAC * oneOverArea;
            t2 = gc->polygon.shader.dyBC * oneOverArea;
            t3 = gc->polygon.shader.dxAC * oneOverArea;
            t4 = gc->polygon.shader.dxBC * oneOverArea;
        }

	dzAC = a->window.z - c->window.z;
	dzBC = b->window.z - c->window.z;
	gc->polygon.shader.dzdxf = dzAC * t2 - dzBC * t1;
	gc->polygon.shader.dzdyf = dzBC * t3 - dzAC * t4;
        GENACCEL(gc).spanDelta.z = gc->polygon.shader.dzdx =
            FTOL(gc->polygon.shader.dzdxf * GENACCEL(gc).zScale);
    }
    else if ((gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) == 0)
    {
        // In this case the divide hasn't been terminated yet so
        // we need to complete it even though we don't use the result
        __GL_FLOAT_SIMPLE_END_DIVIDE(oneOverArea);
    }
#endif // _X86_
}


void FASTCALL __fastGenCalcDeltasTexRGBA(
    __GLcontext *gc,
    __GLvertex *a,
    __GLvertex *b,
    __GLvertex *c)
{
    __GLfloat oneOverArea, t1, t2, t3, t4;
    GLboolean oneOverAreaDone;

#if _X86_ && ENABLE_ASM

    LARGE_INTEGER temp;

    _asm{

    mov     edx, gc
    xor     eax, eax
    mov     oneOverAreaDone, al
    mov     edi, [OFFSET(SHADER.modeFlags)][edx]
    fld     __glOne
    fdiv    DWORD PTR [OFFSET(SHADER.area)][edx]
    mov     ebx, [OFFSET(GENGCACCEL.__fastTexSpanFuncPtr)][edx]
    test    edi, __GL_SHADE_TEXTURE
    mov     [OFFSET(GENGCACCEL.__fastSpanFuncPtr)][edx], ebx
    mov     eax, [OFFSET(__GLcontext.state.texture.env)][edx]
    je      notReplace
    mov     ebx, [OFFSET(__GLtextureEnvState.mode)][eax]
    cmp     ebx, GL_REPLACE
    je      fastReplace
    cmp     ebx, GL_DECAL
    jne     notReplace
    }

fastReplace:

        _asm{
        mov     eax, [OFFSET(GENGCACCEL.constantR)][edx]
        mov     ebx, [OFFSET(GENGCACCEL.constantG)][edx]
        mov     [OFFSET(SPANVALUE.r)][edx], eax
        mov     [OFFSET(SPANVALUE.g)][edx], ebx
        mov     eax, [OFFSET(GENGCACCEL.constantB)][edx]
        mov     ebx, [OFFSET(GENGCACCEL.constantA)][edx]
        mov     [OFFSET(SPANVALUE.b)][edx], eax
        mov     [OFFSET(SPANVALUE.a)][edx], ebx
        jmp     colorDone
        }

notReplace:

    _asm{
    test    edi, __GL_SHADE_SMOOTH
    je      doFlat
    mov     al, 1
    mov     oneOverAreaDone, al
    }

// smooth:

        _asm{

        mov     eax, a
        mov     ebx, b
        mov     ecx, c

        fstp    oneOverArea                         // finish divide

        fld     DWORD PTR [OFFSET(SHADER.dyAC)][edx]
        mov     eax, [OFFSET(__GLvertex.color)][eax]
        fmul    oneOverArea
        fld     DWORD PTR [OFFSET(SHADER.dyBC)][edx]
        mov     ebx, [OFFSET(__GLvertex.color)][ebx]
        fmul    oneOverArea                         // dyBC dyAC
        fld     DWORD PTR [OFFSET(SHADER.dxAC)][edx]
        mov     ecx, [OFFSET(__GLvertex.color)][ecx]
        fmul    oneOverArea                         // dxAC dyBC dyAC
        fxch    ST(1)                               // dyBC dxAC dyAC
        fld     DWORD PTR [OFFSET(SHADER.dxBC)][edx]
        fmul    oneOverArea                         // dxBC dyBC dxAC dyAC
        fxch    ST(3)                               // dyAC dyBC dxAC dxBC
        fstp    t1
        fstp    t2
        fstp    t3
        fstp    t4

        // Now, calculate deltas:

            // Red

        fld     DWORD PTR [OFFSET(__GLcolor.r)][eax]
        fsub    DWORD PTR [OFFSET(__GLcolor.r)][ecx]
        fld     DWORD PTR [OFFSET(__GLcolor.r)][ebx]
        fsub    DWORD PTR [OFFSET(__GLcolor.r)][ecx]
                            // drBC drAC
        fld     ST(1)       // drAC drBC drAC
        fmul    t2          // drACt2 drBC drAC
        fld     ST(1)       // drBC drACt2 drBC drAC
        fmul    t1          // drBCt1 drACt2 drBC drAC
        fxch    ST(2)       // drBC drACt2 drBCt1 drAC
        fmul    t3          // drBCt3 drACt2 drBCt1 drAC
        fxch    ST(3)       // drAC drACt2 drBCt1 drBCt3
        fmul    t4          // drACt4 drACt2 drBCt1 drBCt3
        fxch    ST(2)       // drBCt1 drACt2 drACt4 drBCt3
        fsubp   ST(1), ST   // drACBC drACt4 drBCt3

        fld     DWORD PTR [OFFSET(__GLcolor.g)][ebx]
        fsub    DWORD PTR [OFFSET(__GLcolor.g)][ecx]
                            // dgBC drACBC drACt4 drBCt3
        fxch    ST(2)       // drACt4 drACBC dgBC drBCt3
        fsubp   ST(3), ST   // drACBC dgBC drBCAC
        fst     DWORD PTR [OFFSET(SHADER.drdx)][edx]
        fmul    __glVal65536
                            // DRACBC dgBC drBCAC
        fxch    ST(2)       // drBCAC dgBC DRACBC
        fstp    DWORD PTR [OFFSET(SHADER.drdy)][edx]
                            // dgBC DRACBC
        fld     DWORD PTR [OFFSET(__GLcolor.g)][eax]
        fsub    DWORD PTR [OFFSET(__GLcolor.g)][ecx]
                            // dgAC dgBC DRACBC
        fxch    ST(2)       // DRACBC dgBC dgAC
        fistp   DWORD PTR [OFFSET(SPANDELTA.r)][edx]

            // Green
                            // dgBC dgAC
        fld     ST(1)       // dgAC dgBC dgAC
        fmul    t2          // dgACt2 dgBC dgAC
        fld     ST(1)       // dgBC dgACt2 dgBC dgAC
        fmul    t1          // dgBCt1 dgACt2 dgBC dgAC
        fxch    ST(2)       // dgBC dgACt2 dgBCt1 dgAC
        fmul    t3          // dgBCt3 dgACt2 dgBCt1 dgAC
        fxch    ST(3)       // dgAC dgACt2 dgBCt1 dgBCt3
        fmul    t4          // dgACt4 dgACt2 dgBCt1 dgBCt3
        fxch    ST(2)       // dgBCt1 dgACt2 dgACt4 dgBCt3
        fsubp   ST(1), ST   // dgACBC dgACt4 dgBCt3

        fld     DWORD PTR [OFFSET(__GLcolor.b)][ebx]
        fsub    DWORD PTR [OFFSET(__GLcolor.b)][ecx]
                            // dbBC dgACBC dgACt4 dgBCt3
        fxch    ST(2)       // dgACt4 dgACBC dbBC dgBCt3
        fsubp   ST(3), ST   // dgACBC dbBC dgBCAC
        fst     DWORD PTR [OFFSET(SHADER.dgdx)][edx]
        fmul    __glVal65536
                            // DGACBC dbBC dgBCAC
        fxch    ST(2)       // dgBCAC dbBC DGACBC
        fstp    DWORD PTR [OFFSET(SHADER.dgdy)][edx]
                            // dbBC DGACBC
        fld     DWORD PTR [OFFSET(__GLcolor.b)][eax]
        fsub    DWORD PTR [OFFSET(__GLcolor.b)][ecx]
                            // dbAC dbBC DGACBC
        fxch    ST(2)       // DGACBC dbBC dbAC
        fistp   DWORD PTR [OFFSET(SPANDELTA.g)][edx]

            // Blue
                            // dbBC dbAC
        fld     ST(1)       // dbAC dbBC dbAC
        fmul    t2          // dbACt2 dbBC dbAC
        fld     ST(1)       // dbBC dbACt2 dbBC dbAC
        fmul    t1          // dbBCt1 dbACt2 dbBC dbAC
        fxch    ST(2)       // dbBC dbACt2 dbBCt1 dbAC
        fmul    t3          // dbBCt3 dbACt2 dbBCt1 dbAC
        fxch    ST(3)       // dbAC dbACt2 dbBCt1 dbBCt3
        fmul    t4          // dbACt4 dbACt2 dbBCt1 dbBCt3
        fxch    ST(2)       // dbBCt1 dbACt2 dbACt4 dbBCt3
        fsubp   ST(1), ST   // dbACBC dbACt4 dbBCt3
        fxch    ST(1)       // dbACt4 dbACBC dbBCt3
        fsubp   ST(2), ST   // dbACBC dbBCAC (+1)
        fst     DWORD PTR [OFFSET(SHADER.dbdx)][edx]
        fmul    __glVal65536
                            // DBACBC dbBCAC
        fxch    ST(1)       // dbBCAC DBACBC
        fstp    DWORD PTR [OFFSET(SHADER.dbdy)][edx]
        test    [OFFSET(__GLcontext.state.enables.general)][edx], __GL_BLEND_ENABLE
        fistp   DWORD PTR [OFFSET(SPANDELTA.b)][edx]

        je      colorDone

            fld     DWORD PTR [OFFSET(__GLcolor.a)][eax]
            fsub    DWORD PTR [OFFSET(__GLcolor.a)][ecx]
                                        // daAC
            fld     DWORD PTR [OFFSET(__GLcolor.a)][ebx]
            fsub    DWORD PTR [OFFSET(__GLcolor.a)][ecx]
                                        // daBC daAC
            fld     ST(1)               // daAC daBC daAC
            fmul    t2                  // daACt2 daBC daAC
            fld     ST(1)               // daBC daACt2 daBC daAC
            fmul    t1                  // daBCt1 daACt2 daBC daAC
            fxch    ST(3)               // daAC daACt2 daBC daBCt1
            fmul    t4                  // daACt4 daACt2 daBC daBCt1
            fxch    ST(2)               // daBC daACt2 daACt4 daBCt1
            fmul    t3                  // daBCt3 daACt2 daACt4 daBCt1

            fxch    ST(3)               // daBCt1 daACt2 daACt4 daBCt3
            fsubp   ST(1), ST           // daACBC daACt4 daBCt3
            fxch    ST(1)               // daACt4 daACBC daBCt3
            fsubp   ST(2), ST           // daACBC daBCAC (+1)
            fst     DWORD PTR [OFFSET(SHADER.dadx)][edx]
            fmul    DWORD PTR [OFFSET(GENGCACCEL.aAccelScale)][edx]
            fxch    ST(1)
            fstp    DWORD PTR [OFFSET(SHADER.dady)][edx]
            fistp   DWORD PTR [OFFSET(SPANDELTA.a)][edx] // (+1)
            #if !FORCE_NPX_DEBUG
            jmp     colorDone
            #endif
        }

        #if FORCE_NPX_DEBUG
        {
        __GLfloat drAC, dgAC, dbAC, daAC;
        __GLfloat drBC, dgBC, dbBC, daBC;
        __GLcolor *ac, *bc, *cc;
        __GLfloat ft1 = gc->polygon.shader.dyAC * oneOverArea;
        __GLfloat ft2 = gc->polygon.shader.dyBC * oneOverArea;
        __GLfloat ft3 = gc->polygon.shader.dxAC * oneOverArea;
        __GLfloat ft4 = gc->polygon.shader.dxBC * oneOverArea;
        __GLfloat drdx;
        __GLfloat drdy;
        __GLfloat dgdx;
        __GLfloat dgdy;
        __GLfloat dbdx;
        __GLfloat dbdy;
        LONG spanR, spanG, spanB;

        ac = a->color;
        bc = b->color;
        cc = c->color;

        drAC = ac->r - cc->r;
        drBC = bc->r - cc->r;
        dgAC = ac->g - cc->g;
        dgBC = bc->g - cc->g;
        dbAC = ac->b - cc->b;
        dbBC = bc->b - cc->b;

        drdx = drAC * t2 - drBC * t1;
        drdy = drBC * t3 - drAC * t4;
        dgdx = dgAC * t2 - dgBC * t1;
        dgdy = dgBC * t3 - dgAC * t4;
        dbdx = dbAC * t2 - dbBC * t1;
        dbdy = dbBC * t3 - dbAC * t4;

        spanR = FLT_TO_FIX(drdx);
        spanG = FLT_TO_FIX(dgdx);
        spanB = FLT_TO_FIX(dbdx);

        if (ft1 != t1)
            DbgPrint("t1 %f %f\n", t1, ft1);
        if (ft2 != t2)
            DbgPrint("t2 %f %f\n", t2, ft2);
        if (ft3 != t3)
            DbgPrint("t3 %f %f\n", t3, ft3);
        if (ft4 != t4)
            DbgPrint("t4 %f %f\n", t4, ft4);

        if (drdx != gc->polygon.shader.drdx)
            DbgPrint("drdx %f %f\n", drdx, gc->polygon.shader.drdx);
        if (drdy != gc->polygon.shader.drdy)
            DbgPrint("drdy %f %f\n", drdy, gc->polygon.shader.drdy);
        if (dgdx != gc->polygon.shader.dgdx)
            DbgPrint("dgdx %f %f\n", dgdx, gc->polygon.shader.dgdx);
        if (dgdy != gc->polygon.shader.dgdy)
            DbgPrint("dgdy %f %f\n", dgdy, gc->polygon.shader.dgdy);
        if (dbdx != gc->polygon.shader.dbdx)
            DbgPrint("dbdx %f %f\n", dbdx, gc->polygon.shader.dbdx);
        if (dbdy != gc->polygon.shader.dbdy)
            DbgPrint("dbdy %f %f\n", dbdy, gc->polygon.shader.dbdy);

        if (spanR != GENACCEL(gc).spanDelta.r)
            DbgPrint("spanDelta.r %x %x\n", spanR, GENACCEL(gc).spanDelta.r);
        if (spanG!= GENACCEL(gc).spanDelta.g)
            DbgPrint("spanDelta.g %x %x\n", spanG, GENACCEL(gc).spanDelta.g);
        if (spanB != GENACCEL(gc).spanDelta.b)
            DbgPrint("spanDelta.b %x %x\n", spanB, GENACCEL(gc).spanDelta.b);

        if (gc->state.enables.general & __GL_BLEND_ENABLE) {
            __GLfloat dadx;
            __GLfloat dady;
            LONG a;

            daAC = ac->a - cc->a;
            daBC = bc->a - cc->a;
            dadx = daAC * t2 - daBC * t1;
            dady = daBC * t3 - daAC * t4;

            a = FTOL(gc->polygon.shader.dadx * GENACCEL(gc).aAccelScale);

            if (dadx != gc->polygon.shader.dadx)
                DbgPrint("dadx %f %f\n", dadx, gc->polygon.shader.dadx);
            if (dady != gc->polygon.shader.dady)
                DbgPrint("dady %f %f\n", dady, gc->polygon.shader.dady);
            if (a != GENACCEL(gc).spanDelta.a)
                DbgPrint("spanDelta.a %x %x\n", a, GENACCEL(gc).spanDelta.a);
            }
        }
        _asm {
        mov     edx, gc
        mov     edi, [OFFSET(SHADER.modeFlags)][edx]
        jmp     colorDone
        }
        #endif // FORCE_NPX_DEBUG

doFlat:
	_asm{

        mov     eax, [OFFSET(__GLcontext.vertex.provoking)][edx]

        fld     __glVal65536
        mov     eax, [OFFSET(__GLvertex.color)][eax]
        fmul    DWORD PTR [OFFSET(__GLcolor.r)][eax]
        fld     __glVal65536
        fmul    DWORD PTR [OFFSET(__GLcolor.g)][eax]
        mov     ebx, [OFFSET(__GLcontext.state.enables.general)][edx]
        fld     __glVal65536
        test    ebx, __GL_BLEND_ENABLE
        fmul    DWORD PTR [OFFSET(__GLcolor.b)][eax]

        je      noFlatBlend

        fld     DWORD PTR [OFFSET(GENGCACCEL.aAccelScale)][edx]
        fmul    DWORD PTR [OFFSET(__GLcolor.a)][eax]
                                                          // A B G R
        fxch    ST(3)                                     // R B G A
        fistp   DWORD PTR [OFFSET(SPANVALUE.r)][edx]
        fistp   DWORD PTR [OFFSET(SPANVALUE.b)][edx]
        fistp   DWORD PTR [OFFSET(SPANVALUE.g)][edx]
        fistp   DWORD PTR [OFFSET(SPANVALUE.a)][edx]
        jmp     short flatDone

noFlatBlend:
                                                          // B G R
        fxch    ST(2)                                     // R G B
        fistp   DWORD PTR [OFFSET(SPANVALUE.r)][edx]      // G B
        fistp   DWORD PTR [OFFSET(SPANVALUE.g)][edx]
        fistp   DWORD PTR [OFFSET(SPANVALUE.b)][edx]

flatDone:

        }

colorDone:

    _asm{
    test    edi, __GL_SHADE_TEXTURE
    mov     eax, [OFFSET(GENGCACCEL.texImage)][edx]
    je      texDone
    test    eax, eax
    je      texDone
    }

        _asm{
        mov     al, oneOverAreaDone
        mov     ebx, [OFFSET(__GLcontext.state.hints.perspectiveCorrection)][edx]
        test    al, al
        jne     areaDoneAlready
        }
            _asm{

            fstp    oneOverArea                         // finish divide

            fld     DWORD PTR [OFFSET(SHADER.dyAC)][edx]
            fmul    oneOverArea
            fld     DWORD PTR [OFFSET(SHADER.dyBC)][edx]
            fmul    oneOverArea                         // dyBC dyAC
            fld     DWORD PTR [OFFSET(SHADER.dxAC)][edx]
            fmul    oneOverArea                         // dxAC dyBC dyAC
            fxch    ST(1)                               // dyBC dxAC dyAC
            fld     DWORD PTR [OFFSET(SHADER.dxBC)][edx]
            fmul    oneOverArea                         // dxBC dyBC dxAC dyAC
            fxch    ST(3)                               // dyAC dyBC dxAC dxBC
            fstp    t1
            inc     eax
            fstp    t2
            mov     oneOverAreaDone, al
            fstp    t3
            fstp    t4
            }

areaDoneAlready:

        _asm{
        cmp     ebx, GL_NICEST
        je      doNicest
        }
            _asm{
            mov     eax, a
            mov     ecx, c
            mov     ebx, b

            fld     DWORD PTR [OFFSET(__GLvertex.texture.x)][eax]
            fsub    DWORD PTR [OFFSET(__GLvertex.texture.x)][ecx]
                                    // dsAC
            fld     DWORD PTR [OFFSET(__GLvertex.texture.x)][ebx]
            fsub    DWORD PTR [OFFSET(__GLvertex.texture.x)][ecx]
                                    // dsBC dsAC

            fld     ST(1)           // dsAC dsBC dsAC
            fmul    t2
            fxch    ST(2)           // dsAC dsBC dsACt2
            fmul    t4              // dsACt4 dsBC dsACt2
            fld     ST(1)           // dsBC dsACt4 dsBC dsACt2
            fmul    t1              // dsBCt1 dsACt4 dsBC dsACt2
            fxch    ST(2)           // dsBC dsACt4 dsBCt1 dsACt2
            fmul    t3              // dsBCt3 dsACt4 dsBCt1 dsACt2
            fxch    ST(2)           // dsBCt1 dsACt4 dsBCt3 dsACt2
            fsubp   ST(3), ST       // dsACt4 dsBCt3 dsACBC

            fld     DWORD PTR [OFFSET(__GLvertex.texture.y)][ebx]
            fsub    DWORD PTR [OFFSET(__GLvertex.texture.y)][ecx]
                                    // dtBC dsACt4 dsBCt3 dsACBC
            fxch    ST(1)           // dsACt4 dtBC dsBCt3 dsACBC
            fsubp   ST(2), ST       // dtBC dsBCAC dsACBC
            fxch    ST(2)           // dsACBC dsBCAC dtBC
            fst     DWORD PTR [OFFSET(SHADER.dsdx)][edx]
                                    // dsdx dsBCAC dtBC

            fld     DWORD PTR [OFFSET(__GLvertex.texture.y)][eax]
            fsub    DWORD PTR [OFFSET(__GLvertex.texture.y)][ecx]
                                    // dtAC dsdx dsBCAC dtBC
            fxch    ST(2)           // dsBCAC dsdx dtAC dtBC
            fstp    DWORD PTR [OFFSET(SHADER.dsdy)][edx]
                                    // dsdx dtAC dtBC

            fmul    DWORD PTR [OFFSET(GENGCACCEL.texXScale)][edx]

                                    // deltaS dtAC dtBC
            fxch    ST(2)           // dtBC dtAC deltaS
            fld     ST(1)           // dtAC dtBC dtAC deltaS
            fmul    t2              // dtACt2 dtBC dtAC deltaS
            fxch    ST(2)           // dtAC dtBC dtACt2 deltaS
            fmul    t4              // dtACt4 dtBC dtACt2 deltaS
            fld     ST(1)           // dtBC dtACt4 dtBC dtACt2 deltaS
            fmul    t1              // dtBCt1 dtACt4 dtBC dtACt2 deltaS
            fxch    ST(2)           // dtBC dtACt4 dtBCt1 dtACt2 deltaS
            fmul    t3              // dtBCt3 dtACt4 dtBCt1 dtACt2 deltaS
            fxch    ST(2)           // dtBCt1 dtACt4 dtBCt3 dtACt2 deltaS
            fsubp   ST(3), ST       // dtACt4 dtBCt3 dtACBC deltaS

            fxch    ST(3)           // deltaS dtBCt3 dtACBC dtACt4
            fistp   DWORD PTR [OFFSET(SPANDELTA.s)][edx]
                                    // dtBCt3 dtACBC dtACt4

            fsubrp  ST(2), ST       // dtACBC dtBCAC
            fst     DWORD PTR [OFFSET(SHADER.dtdx)][edx]
            fmul    DWORD PTR [OFFSET(GENGCACCEL.texYScale)][edx]
            fxch    ST(1)           // dtBCAC deltaT
            fstp    DWORD PTR [OFFSET(SHADER.dtdy)][edx]
            mov     eax, [OFFSET(SPANDELTA.s)][edx]
            fistp   DWORD PTR [OFFSET(SPANDELTA.t)][edx]

            shl     eax, TEX_SUBDIV_LOG2
            mov     ebx, [OFFSET(SPANDELTA.t)][edx]
            shl     ebx, TEX_SUBDIV_LOG2
            mov     [OFFSET(GENGCACCEL.sStepX)][edx], eax
            mov     [OFFSET(GENGCACCEL.tStepX)][edx], ebx


            #if !FORCE_NPX_DEBUG
            jmp     texDone
            #endif
            }

            #if FORCE_NPX_DEBUG
            {
            __GLfloat awinv, bwinv, cwinv, scwinv, tcwinv, qwcwinv;
            __GLfloat dsAC, dsBC, dtAC, dtBC, dqwAC, dqwBC;
            __GLfloat dsdx, dsdy;
            __GLfloat dtdx, dtdy;
            LONG spanDeltaS, spanDeltaT;

            dsAC = a->texture.x - c->texture.x;
            dsBC = b->texture.x - c->texture.x;
            dsdx = dsAC * t2 - dsBC * t1;
            dsdy = dsBC * t3 - dsAC * t4;
            dtAC = a->texture.y - c->texture.y;
            dtBC = b->texture.y - c->texture.y;
            dtdx = dtAC * t2 - dtBC * t1;
            dtdy = dtBC * t3 - dtAC * t4;

            spanDeltaS = FTOL(dsdx * GENACCEL(gc).texXScale);
            spanDeltaT = FTOL(dtdx * GENACCEL(gc).texYScale);

            if (gc->polygon.shader.dsdx != dsdx)
                DbgPrint("dsdx %f %f\n", dsdx, gc->polygon.shader.dsdx);
            if (gc->polygon.shader.dsdy != dsdy)
                DbgPrint("dsdy %f %f\n", dsdy, gc->polygon.shader.dsdy);

            if (gc->polygon.shader.dtdx != dtdx)
                DbgPrint("dtdx %f %f\n", dtdx, gc->polygon.shader.dtdx);
            if (gc->polygon.shader.dtdy != dtdy)
                DbgPrint("dtdy %f %f\n", dtdy, gc->polygon.shader.dtdy);

            if (spanDeltaS != GENACCEL(gc).spanDelta.s)
                DbgPrint("spanDelta.s %x %x\n", spanDeltaS, GENACCEL(gc).spanDelta.s);
            if (spanDeltaT != GENACCEL(gc).spanDelta.t)
                DbgPrint("spanDelta.t %x %x\n", spanDeltaT, GENACCEL(gc).spanDelta.t);

            }
            _asm {
            mov     edx, gc
            mov     edi, [OFFSET(SHADER.modeFlags)][edx]
            jmp     texDone
            }
            #endif // FORCE_NPX_DEBUG

doNicest:

// LATER - remove store/read of dsdx, dydx

            _asm{
            mov     ecx, c
            mov     ebx, b
            mov     eax, a

            fld     DWORD PTR [OFFSET(__GLvertex.texture.x)][ecx]   // sc
            fmul    DWORD PTR [OFFSET(__GLvertex.window.w)][ecx]
            fld     DWORD PTR [OFFSET(__GLvertex.texture.x)][eax]
            fmul    DWORD PTR [OFFSET(__GLvertex.window.w)][eax]    // dsA sc
            fld     DWORD PTR [OFFSET(__GLvertex.texture.x)][ebx]
            fmul    DWORD PTR [OFFSET(__GLvertex.window.w)][ebx]
                                    // dsB dsA sc
            fxch    ST(2)           // sc dsA dsB

            fsub    ST(1), ST       // sc dsAC dsB

            fld     DWORD PTR [OFFSET(__GLvertex.texture.y)][ecx]   // tcwinv
            fmul    DWORD PTR [OFFSET(__GLvertex.window.w)][ecx]
                                    // tc sc dsAC dsB

            fxch    ST(1)           // sc tc dsAC dsB
            fsubp   ST(3), ST       // tc dsAC dsBC
            fxch    ST(2)           // dsBC dsAC tc

            fld     ST(1)           // dsAC dsBC dsAC tc
            fmul    t2
            fxch    ST(2)           // dsAC dsBC dsACt2 tc
            fmul    t4              // dsACt4 dsBC dsACt2 tc
            fld     ST(1)           // dsBC dsACt4 dsBC dsACt2 tc
            fmul    t1              // dsBCt1 dsACt4 dsBC dsACt2 tc
            fxch    ST(2)           // dsBC dsACt4 dsBCt1 dsACt2 tc
            fmul    t3              // dsBCt3 dsACt4 dsBCt1 dsACt2 tc
            fxch    ST(2)           // dsBCt1 dsACt4 dsBCt3 dsACt2 tc
            fsubp   ST(3), ST       // dsACt4 dsBCt3 dsACBC tc

            fld     DWORD PTR [OFFSET(__GLvertex.texture.y)][eax]
            fmul    DWORD PTR [OFFSET(__GLvertex.window.w)][eax]
                                    // dtA dsACt4 dsBCt3 dsACBC tc
            fxch    ST(1)           // dsACt4 dtA dsBCt3 dsACBC tc
            fsubp   ST(2), ST       // dtA dsBCAC dsACBC tc
            fxch    ST(2)           // dsACBC dsBCAC dtA tc
            fstp    DWORD PTR [OFFSET(SHADER.dsdx)][edx]
                                    // dsBCAC dtA tc

            fld     DWORD PTR [OFFSET(__GLvertex.texture.y)][ebx]
            fmul    DWORD PTR [OFFSET(__GLvertex.window.w)][ebx]
                                    // dtB dsBCAC dtA tc
            fxch    ST(1)           // dsBCAC dtB dtA tc
            fstp    DWORD PTR [OFFSET(SHADER.dsdy)][edx]
                                    // dtB dtA tc

            fxch    ST(2)           // tc dtA dtB
            fsub    ST(1), ST       // tc dtAC dtB
            fsubp   ST(2), ST       // dtAC dtBC

            fld     DWORD PTR [OFFSET(__GLvertex.texture.w)][ecx]
            fmul    DWORD PTR [OFFSET(__GLvertex.window.w)][ecx]
                                    // qw dtAC dtBC
            fxch    ST(2)           // dtBC dtAC qw
            fld     ST(1)           // dtAC dtBC dtAC qw
            fmul    t2              // dtACt2 dtBC dtAC qw
            fxch    ST(2)           // dtAC dtBC dtACt2 qw
            fmul    t4              // dtACt4 dtBC dtACt2 qw
            fld     ST(1)           // dtBC dtACt4 dtBC dtACt2 qw
            fmul    t1              // dtBCt1 dtACt4 dtBC dtACt2 qw
            fxch    ST(2)           // dtBC dtACt4 dtBCt1 dtACt2 qw
            fmul    t3              // dtBCt3 dtACt4 dtBCt1 dtACt2 qw
            fxch    ST(2)           // dtBCt1 dtACt4 dtBCt3 dtACt2 qw
            fsubp   ST(3), ST       // dtACt4 dtBCt3 dtACBC qw

            fld     DWORD PTR [OFFSET(__GLvertex.texture.w)][eax]
            fmul    DWORD PTR [OFFSET(__GLvertex.window.w)][eax]
                                    // dqA dtACt4 dtBCt3 dtACBC qw

            fxch    ST(1)           // dtACt4 dqA dtBCt3 dtACBC qw
            fsubp   ST(2), ST       // dqA dtBCAC dtACBC qw
            fxch    ST(2)           // dtACBC dtBCAC dqA qw
            fstp    DWORD PTR [OFFSET(SHADER.dtdx)][edx]
                                    // dsBCAC dqA qw
            fld     DWORD PTR [OFFSET(__GLvertex.texture.w)][ebx]
            fmul    DWORD PTR [OFFSET(__GLvertex.window.w)][ebx]
                                    // dqB dsBCAC dqA qw

            fxch    ST(3)           // qw dsBCAC dqA dqB
            fsub    ST(2), ST       // qw dsBCAC dqAC dqB
            fxch    ST(1)           // dsBCAC qw dqAC dqB
            fstp    DWORD PTR [OFFSET(SHADER.dtdy)][edx]
                                    // qw dqAC dqB
            fsubp   ST(2), ST       // dqAC dqBC
            fxch    ST(1)           // dqBC dqAC

            fld     ST(1)           // dqAC dqBC dqAC
            fmul    t2              // dqACt2 dqBC dqAC
            fxch    ST(2)           // dqAC dqBC dqACt2
            fmul    t4              // dqACt4 dqBC dqACt2
            fld     ST(1)           // dqBC dqACt4 dqBC dqACt2
            fmul    t1              // dqBCt1 dqACt4 dqBC dqACt2
            fxch    ST(2)           // dqBC dqACt4 dqBCt1 dqACt2
            fmul    t3              // dqBCt3 dqACt4 dqBCt1 dqACt2
            fxch    ST(2)           // dqBCt1 dqACt4 dqBCt3 dqACt2
            fsubp   ST(3), ST       // dqACt4 dqBCt3 dqACBC
            fxch    ST(2)           // dqACBC dqBCt3 dqACt4

            fld     DWORD PTR [OFFSET(SHADER.dsdx)][edx]
            fmul    DWORD PTR [OFFSET(GENGCACCEL.texXScale)][edx]
                                    // deltaS dqACBC dqBCt3 dqACt4

            fxch    ST(3)           // dqACt4 dqACBC dqBCt3 deltaS
            fsubp   ST(2), ST       // dqACBC dqBCAC deltaS

            fld     DWORD PTR [OFFSET(SHADER.dtdx)][edx]
            fmul    DWORD PTR [OFFSET(GENGCACCEL.texYScale)][edx]
                                    // deltaT dqACBC dqBCAC deltaS
            fld     __glTexSubDiv
            fmul    ST, ST(2)
                                    // qwStep deltaT dqACBC dqBCAC deltaS
            fxch    ST(4)           // deltaS deltaT dqACBC dqBCAC qwStep
            fistp   DWORD PTR [OFFSET(SPANDELTA.s)][edx]
            fistp   DWORD PTR [OFFSET(SPANDELTA.t)][edx]
                                    // dqACBC dqBCAC qwStep
            fstp    DWORD PTR [OFFSET(SHADER.dqwdx)][edx]
            fstp    DWORD PTR [OFFSET(SHADER.dqwdy)][edx]
            mov     eax, [OFFSET(SPANDELTA.s)][edx]
            fstp    DWORD PTR [OFFSET(GENGCACCEL.qwStepX)][edx]

            shl     eax, TEX_SUBDIV_LOG2
            mov     ebx, [OFFSET(SPANDELTA.t)][edx]
            shl     ebx, TEX_SUBDIV_LOG2
            mov     [OFFSET(GENGCACCEL.sStepX)][edx], eax
            mov     [OFFSET(GENGCACCEL.tStepX)][edx], ebx

            }

            #if FORCE_NPX_DEBUG
            {
            __GLfloat awinv, bwinv, cwinv, scwinv, tcwinv, qwcwinv;
            __GLfloat dsAC, dsBC, dtAC, dtBC, dqwAC, dqwBC;
            __GLfloat dsdx, dsdy;
            __GLfloat dtdx, dtdy;
            __GLfloat dqwdx, dqwdy;
            __GLfloat qwStepX;
            LONG spanDeltaS, spanDeltaT;

            awinv = a->window.w;
            bwinv = b->window.w;
            cwinv = c->window.w;
            scwinv = c->texture.x * cwinv;
            tcwinv = c->texture.y * cwinv;
            qwcwinv = c->texture.w * cwinv;

            dsAC = a->texture.x * awinv - scwinv;
            dsBC = b->texture.x * bwinv - scwinv;
            dsdx = dsAC * t2 - dsBC * t1;
            dsdy = dsBC * t3 - dsAC * t4;

            dtAC = a->texture.y * awinv - tcwinv;
            dtBC = b->texture.y * bwinv - tcwinv;
            dtdx = dtAC * t2 - dtBC * t1;
            dtdy = dtBC * t3 - dtAC * t4;

            dqwAC = a->texture.w * awinv - qwcwinv;
            dqwBC = b->texture.w * bwinv - qwcwinv;
            dqwdx = dqwAC * t2 - dqwBC * t1;
            dqwdy = dqwBC * t3 - dqwAC * t4;

            spanDeltaS = FTOL(dsdx * GENACCEL(gc).texXScale);
            spanDeltaT = FTOL(dtdx * GENACCEL(gc).texYScale);

            qwStepX = (gc->polygon.shader.dqwdx * (__GLfloat)TEX_SUBDIV);

            if (gc->polygon.shader.dsdx != dsdx)
                DbgPrint("dsdx %f %f\n", dsdx, gc->polygon.shader.dsdx);
            if (gc->polygon.shader.dsdy != dsdy)
                DbgPrint("dsdy %f %f\n", dsdy, gc->polygon.shader.dsdy);

            if (gc->polygon.shader.dtdx != dtdx)
                DbgPrint("dtdx %f %f\n", dtdx, gc->polygon.shader.dtdx);
            if (gc->polygon.shader.dtdy != dtdy)
                DbgPrint("dtdy %f %f\n", dtdy, gc->polygon.shader.dtdy);

            if (gc->polygon.shader.dqwdx != dqwdx)
                DbgPrint("dqdx %f %f\n", dqwdx, gc->polygon.shader.dqwdx);
            if (gc->polygon.shader.dqwdy != dqwdy)
                DbgPrint("dqdy %f %f\n", dqwdy, gc->polygon.shader.dqwdy);

            if (spanDeltaS != GENACCEL(gc).spanDelta.s)
                DbgPrint("spanDelta.s %x %x\n", spanDeltaS, GENACCEL(gc).spanDelta.s);
            if (spanDeltaT != GENACCEL(gc).spanDelta.t)
                DbgPrint("spanDelta.t %x %x\n", spanDeltaT, GENACCEL(gc).spanDelta.t);

            if (qwStepX != GENACCEL(gc).qwStepX)
                DbgPrint("qwStepX %f %f\n", qwStepX, GENACCEL(gc).qwStepX);
            }
            _asm {
            mov     edx, gc
            mov     edi, [OFFSET(SHADER.modeFlags)][edx]
            }
            #endif // FORCE_NPX_DEBUG
texDone:

    _asm{
    test    edi, __GL_SHADE_DEPTH_ITER
    je      noZ
    mov     al, oneOverAreaDone
    test    al, al
    jne     areaDoneAlready2
    }

        _asm{

        fstp    oneOverArea                         // finish divide

        fld     DWORD PTR [OFFSET(SHADER.dyAC)][edx]
        fmul    oneOverArea
        fld     DWORD PTR [OFFSET(SHADER.dyBC)][edx]
        fmul    oneOverArea                         // dyBC dyAC
        fld     DWORD PTR [OFFSET(SHADER.dxAC)][edx]
        fmul    oneOverArea                         // dxAC dyBC dyAC
        fxch    ST(1)                               // dyBC dxAC dyAC
        fld     DWORD PTR [OFFSET(SHADER.dxBC)][edx]
        fmul    oneOverArea                         // dxBC dyBC dxAC dyAC
        fxch    ST(3)                               // dyAC dyBC dxAC dxBC
        fstp    t1
        inc     eax
        fstp    t2
        mov     oneOverAreaDone, al
        fstp    t3
        fstp    t4
        }

areaDoneAlready2:

        _asm{

        mov     ecx, c
        mov     eax, a
        mov     ebx, b

        fld     DWORD PTR [OFFSET(__GLvertex.window.z)][eax]
        fsub    DWORD PTR [OFFSET(__GLvertex.window.z)][ecx]
        fld     DWORD PTR [OFFSET(__GLvertex.window.z)][ebx]
        fsub    DWORD PTR [OFFSET(__GLvertex.window.z)][ecx]
                                                        // dzBC dzAC
        fld     ST(1)                                   // dzAC dzBC dzAC
        fmul    t2                                      // ACt2 dzBC dzAC
        fld     ST(1)                                   // dzBC ACt2 dzBC dzAC
        fmul    t1                                      // BCt1 ACt2 dzBC dzAC
        fxch    ST(3)                                   // dzAC ACt2 dzBC BCt1
        fmul    t4                                      // ACt4 ACt2 dzBC BCt1
        fxch    ST(2)                                   // dzBC ACt2 ACt4 BCt1
        fmul    t3                                      // BCt3 ACt2 ACt4 BCt1
        fsubrp  ST(2),ST                                // ACt2 BCAC BCt1
        fsubrp  ST(2),ST                                // BCAC ACBC
        fxch    ST(1)                                   // ACBC BCAC
                                                        // dzdx dzdy
        fld     ST(0)                                   // dzdx dzdx dzdy
        fmul    DWORD PTR [OFFSET(GENGCACCEL.zScale)][edx]
                                                        // dzdxS dzdx dzdy
        fxch    ST(2)                                   // dzdy dzdx dzdxS
        fstp    DWORD PTR [OFFSET(SHADER.dzdyf)][edx]
        fstp    DWORD PTR [OFFSET(SHADER.dzdxf)][edx]
        fistp   temp
        mov     ebx, DWORD PTR temp
        mov     DWORD PTR [OFFSET(SHADER.dzdx)][edx], ebx
        mov     DWORD PTR [OFFSET(SPANDELTA.z)][edx], ebx
        #if !FORCE_NPX_DEBUG
        jmp     deltaDone
        #endif
        }

        #if FORCE_NPX_DEBUG
        {
	__GLfloat dzAC, dzBC;
        __GLfloat dzdxf;
        __GLfloat dzdyf;
        ULONG spanDeltaZ;

        dzAC = a->window.z - c->window.z;
        dzBC = b->window.z - c->window.z;

        dzdxf = dzAC * t2 - dzBC * t1;
        dzdyf = dzBC * t3 - dzAC * t4;
        spanDeltaZ = FTOL(dzdxf * GENACCEL(gc).zScale);

        if (dzdxf != gc->polygon.shader.dzdxf)
            DbgPrint("dzdxf %f %f\n", dzdxf, gc->polygon.shader.dzdxf);
        if (dzdyf != gc->polygon.shader.dzdyf)
            DbgPrint("dzdyf %f %f\n", dzdyf, gc->polygon.shader.dzdyf);

        if (spanDeltaZ != GENACCEL(gc).spanDelta.z)
            DbgPrint("spanDeltaZ %x %x\n", spanDeltaZ, GENACCEL(gc).spanDelta.z);
        }
        #endif // FORCE_NPX_DEBUG

noZ:

    _asm{
    mov     al, oneOverAreaDone
    test    al, al
    jne     deltaDone
    fstp    ST(0)
    }

deltaDone:
    return;

#else

    /* Pre-compute one over polygon area */

    __GL_FLOAT_BEGIN_DIVIDE(__glOne, gc->polygon.shader.area, &oneOverArea);
    oneOverAreaDone = GL_FALSE;

    /*
    ** Compute delta values for unit changes in x or y for each
    ** parameter.
    */

    GENACCEL(gc).__fastSpanFuncPtr = GENACCEL(gc).__fastTexSpanFuncPtr;

    if ((gc->polygon.shader.modeFlags & __GL_SHADE_TEXTURE) &&
        ((gc->state.texture.env[0].mode == GL_REPLACE) ||
         (gc->state.texture.env[0].mode == GL_DECAL))) {

        GENACCEL(gc).spanValue.r = GENACCEL(gc).constantR;
        GENACCEL(gc).spanValue.g = GENACCEL(gc).constantG;
        GENACCEL(gc).spanValue.b = GENACCEL(gc).constantB;
        GENACCEL(gc).spanValue.a = GENACCEL(gc).constantA;

    } else if (gc->polygon.shader.modeFlags & __GL_SHADE_SMOOTH) {
        __GLfloat drAC, dgAC, dbAC, daAC;
        __GLfloat drBC, dgBC, dbBC, daBC;
        __GLcolor *ac, *bc, *cc;

        oneOverAreaDone = GL_TRUE;

        ac = a->color;
        bc = b->color;
        cc = c->color;

        drAC = ac->r - cc->r;
        drBC = bc->r - cc->r;
        dgAC = ac->g - cc->g;
        dgBC = bc->g - cc->g;
        dbAC = ac->b - cc->b;
        dbBC = bc->b - cc->b;

        __GL_FLOAT_SIMPLE_END_DIVIDE(oneOverArea);
        t1 = gc->polygon.shader.dyAC * oneOverArea;
        t2 = gc->polygon.shader.dyBC * oneOverArea;
        t3 = gc->polygon.shader.dxAC * oneOverArea;
        t4 = gc->polygon.shader.dxBC * oneOverArea;

        gc->polygon.shader.drdx = drAC * t2 - drBC * t1;
        gc->polygon.shader.drdy = drBC * t3 - drAC * t4;
        gc->polygon.shader.dgdx = dgAC * t2 - dgBC * t1;
        gc->polygon.shader.dgdy = dgBC * t3 - dgAC * t4;
        gc->polygon.shader.dbdx = dbAC * t2 - dbBC * t1;
        gc->polygon.shader.dbdy = dbBC * t3 - dbAC * t4;

        GENACCEL(gc).spanDelta.r = FLT_TO_FIX(gc->polygon.shader.drdx);
        GENACCEL(gc).spanDelta.g = FLT_TO_FIX(gc->polygon.shader.dgdx);
        GENACCEL(gc).spanDelta.b = FLT_TO_FIX(gc->polygon.shader.dbdx);

        if (gc->state.enables.general & __GL_BLEND_ENABLE) {
            daAC = ac->a - cc->a;
	    daBC = bc->a - cc->a;
	    gc->polygon.shader.dadx = daAC * t2 - daBC * t1;
	    gc->polygon.shader.dady = daBC * t3 - daAC * t4;
            GENACCEL(gc).spanDelta.a =
                FTOL(gc->polygon.shader.dadx * GENACCEL(gc).aAccelScale);
        }

#ifdef GENERIC_CAN_BLEND
//!! Note: this is not enabled in the assembly code above

        if (   ((GENACCEL(gc).spanDelta.r | GENACCEL(gc).spanDelta.g | GENACCEL(gc).spanDelta.b) == 0)
            && ((GENACCEL(gc).flags & GEN_FASTZBUFFER) == 0)
           ) {
            GENACCEL(gc).__fastSpanFuncPtr = GENACCEL(gc).__fastFlatSpanFuncPtr;
        } else {
            GENACCEL(gc).__fastSpanFuncPtr = GENACCEL(gc).__fastSmoothSpanFuncPtr;
        }
#endif
    } else {

        __GLcolor *flatColor = gc->vertex.provoking->color;

        GENACCEL(gc).spanValue.r = FLT_TO_FIX(flatColor->r);
        GENACCEL(gc).spanValue.g = FLT_TO_FIX(flatColor->g);
        GENACCEL(gc).spanValue.b = FLT_TO_FIX(flatColor->b);
        if (gc->state.enables.general & __GL_BLEND_ENABLE)
            GENACCEL(gc).spanValue.a = FTOL(flatColor->a * GENACCEL(gc).aAccelScale);
#ifdef GENERIC_CAN_BLEND
//!! Note: this is not enabled in the assembly code above
        GENACCEL(gc).__fastSpanFuncPtr = GENACCEL(gc).__fastFlatSpanFuncPtr;
#endif
    }

    if ((gc->polygon.shader.modeFlags & __GL_SHADE_TEXTURE) && (GENACCEL(gc).texImage)) {
        __GLfloat awinv, bwinv, cwinv, scwinv, tcwinv, qwcwinv;
        __GLfloat dsAC, dsBC, dtAC, dtBC, dqwAC, dqwBC;

#ifdef GENERIC_CAN_BLEND
        GENACCEL(gc).__fastSpanFuncPtr = GENACCEL(gc).__fastTexSpanFuncPtr;
#endif

        if (!oneOverAreaDone)
        {
            oneOverAreaDone = GL_TRUE;
            __GL_FLOAT_SIMPLE_END_DIVIDE(oneOverArea);
            t1 = gc->polygon.shader.dyAC * oneOverArea;
            t2 = gc->polygon.shader.dyBC * oneOverArea;
            t3 = gc->polygon.shader.dxAC * oneOverArea;
            t4 = gc->polygon.shader.dxBC * oneOverArea;
        }

        if (gc->state.hints.perspectiveCorrection != GL_NICEST) {
            dsAC = a->texture.x - c->texture.x;
            dsBC = b->texture.x - c->texture.x;
            gc->polygon.shader.dsdx = dsAC * t2 - dsBC * t1;
            gc->polygon.shader.dsdy = dsBC * t3 - dsAC * t4;
            dtAC = a->texture.y - c->texture.y;
            dtBC = b->texture.y - c->texture.y;
            gc->polygon.shader.dtdx = dtAC * t2 - dtBC * t1;
            gc->polygon.shader.dtdy = dtBC * t3 - dtAC * t4;

            GENACCEL(gc).spanDelta.s =
                FTOL(gc->polygon.shader.dsdx * GENACCEL(gc).texXScale);

            GENACCEL(gc).spanDelta.t =
                FTOL(gc->polygon.shader.dtdx * GENACCEL(gc).texYScale);
            GENACCEL(gc).sStepX = (GENACCEL(gc).spanDelta.s * TEX_SUBDIV);
            GENACCEL(gc).tStepX = (GENACCEL(gc).spanDelta.t * TEX_SUBDIV);

        } else {
            awinv = a->window.w;
            bwinv = b->window.w;
            cwinv = c->window.w;
            scwinv = c->texture.x * cwinv;
            tcwinv = c->texture.y * cwinv;
            qwcwinv = c->texture.w * cwinv;

            dsAC = a->texture.x * awinv - scwinv;
            dsBC = b->texture.x * bwinv - scwinv;
            gc->polygon.shader.dsdx = dsAC * t2 - dsBC * t1;
            gc->polygon.shader.dsdy = dsBC * t3 - dsAC * t4;

            dtAC = a->texture.y * awinv - tcwinv;
            dtBC = b->texture.y * bwinv - tcwinv;
            gc->polygon.shader.dtdx = dtAC * t2 - dtBC * t1;
            gc->polygon.shader.dtdy = dtBC * t3 - dtAC * t4;

            dqwAC = a->texture.w * awinv - qwcwinv;
            dqwBC = b->texture.w * bwinv - qwcwinv;
            gc->polygon.shader.dqwdx = dqwAC * t2 - dqwBC * t1;
            gc->polygon.shader.dqwdy = dqwBC * t3 - dqwAC * t4;

            GENACCEL(gc).spanDelta.s = FTOL(gc->polygon.shader.dsdx * GENACCEL(gc).texXScale);
            GENACCEL(gc).spanDelta.t = FTOL(gc->polygon.shader.dtdx * GENACCEL(gc).texYScale);

            GENACCEL(gc).qwStepX = (gc->polygon.shader.dqwdx * (__GLfloat)TEX_SUBDIV);
            GENACCEL(gc).sStepX = (GENACCEL(gc).spanDelta.s * TEX_SUBDIV);
            GENACCEL(gc).tStepX = (GENACCEL(gc).spanDelta.t * TEX_SUBDIV);
        }
    }

    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_ITER) {
	__GLfloat dzAC, dzBC;

        if (!oneOverAreaDone) {
            oneOverAreaDone = GL_TRUE;

            __GL_FLOAT_SIMPLE_END_DIVIDE(oneOverArea);
            t1 = gc->polygon.shader.dyAC * oneOverArea;
            t2 = gc->polygon.shader.dyBC * oneOverArea;
            t3 = gc->polygon.shader.dxAC * oneOverArea;
            t4 = gc->polygon.shader.dxBC * oneOverArea;
        }

	dzAC = a->window.z - c->window.z;
	dzBC = b->window.z - c->window.z;
	gc->polygon.shader.dzdxf = dzAC * t2 - dzBC * t1;
	gc->polygon.shader.dzdyf = dzBC * t3 - dzAC * t4;
        GENACCEL(gc).spanDelta.z = gc->polygon.shader.dzdx =
            FTOL(gc->polygon.shader.dzdxf * GENACCEL(gc).zScale);
    }

    if (!oneOverAreaDone)
    {
        // In this case the divide hasn't been terminated yet so
        // we need to complete it even though we don't use the result
        __GL_FLOAT_SIMPLE_END_DIVIDE(oneOverArea);
    }
#endif // _X86_
}


/**************************************************************************\
\**************************************************************************/

void FASTCALL __fastGenFillTriangle(
    __GLcontext *gc,
    __GLvertex *a,
    __GLvertex *b,
    __GLvertex *c,
    GLboolean ccw)
{
    GLint aIY, bIY, cIY;
    __GLfloat dxdyAC, dxdyBC, dxdyBA;
    __GLfloat dx, dy;
    __GLfloat invDyAB, invDyBC, invDyAC;

    #if DBG && CHECK_FPU
    {
        USHORT cw;

        __asm {
            _asm fnstcw   cw
            _asm mov     ax, cw
            _asm and     ah, (~0x3f)
            _asm mov     cw,ax
            _asm fldcw   cw
        }
    }
    #endif

    //
    // Snap each y coordinate to its pixel center
    //

    aIY = __GL_VERTEX_FIXED_TO_INT(__GL_VERTEX_FLOAT_TO_FIXED(a->window.y)+
                                   __GL_VERTEX_FRAC_HALF);
    cIY = __GL_VERTEX_FIXED_TO_INT(__GL_VERTEX_FLOAT_TO_FIXED(c->window.y)+
                                   __GL_VERTEX_FRAC_HALF);

    if (aIY == cIY) {
        return;
    }

    bIY = __GL_VERTEX_FIXED_TO_INT(__GL_VERTEX_FLOAT_TO_FIXED(b->window.y)+
                                   __GL_VERTEX_FRAC_HALF);

    if (cIY - aIY > __GL_MAX_INV_TABLE)
        goto bigTriangle;

    gc->polygon.shader.cfb = gc->drawBuffer;

    CASTFIX(invDyAB) = CASTFIX(invTable[CASTFIX(b->window.y) - CASTFIX(a->window.y)]) | 0x80000000;
    CASTFIX(invDyBC) = CASTFIX(invTable[CASTFIX(c->window.y) - CASTFIX(b->window.y)]) | 0x80000000;
    CASTFIX(invDyAC) = CASTFIX(invTable[CASTFIX(c->window.y) - CASTFIX(a->window.y)]) | 0x80000000;

    //
    // Calculate delta values for unit changes in x or y
    //

    GENACCEL(gc).__fastCalcDeltaPtr(gc, a, b, c);

    //
    // calculate the destination address
    //

    GENACCEL(gc).pPix =
          (BYTE *)gc->polygon.shader.cfb->buf.base
        + (  gc->polygon.shader.cfb->buf.outerWidth
           * (
                aIY
              - gc->constants.viewportYAdjust
              + gc->polygon.shader.cfb->buf.yOrigin
             )
          )
        + (  GENACCEL(gc).xMultiplier
           * (
              - gc->constants.viewportXAdjust
              + gc->polygon.shader.cfb->buf.xOrigin
             )
          );

    // Calculate destination Z
    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST)
    {
        if ( gc->modes.depthBits == 32 )
        {
            gc->polygon.shader.zbuf =
                __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                                0, aIY);
        }
        else
        {
            gc->polygon.shader.zbuf = (__GLzValue *)
                __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLz16Value*),
                                0, aIY);
        }
    }

    /*
    ** This algorithm always fills from bottom to top, left to right.
    ** Because of this, ccw triangles are inherently faster because
    ** the parameter values need not be recomputed.
    */

    if (ccw)
    {
	dy = (aIY + __glHalf) - a->window.y;

        dxdyAC = gc->polygon.shader.dxAC * invDyAC;

	GenSnapXLeft(gc, a->window.x + dy*dxdyAC, dxdyAC);

	dx = (gc->polygon.shader.ixLeft + __glHalf) - a->window.x;

	GENACCEL(gc).__fastSetInitParamPtr(gc, a, dx, dy);

	if (aIY != bIY)
        {
	    dxdyBA = (a->window.x - b->window.x) * invDyAB;

	    GenSnapXRight(gc, a->window.x + dy*dxdyBA, dxdyBA);

            if (bIY == cIY)
                gc->polygon.shader.modeFlags |= __GL_SHADE_LAST_SUBTRI;

            GENACCEL(gc).__fastFillSubTrianglePtr(gc, aIY, bIY);

            if (bIY != cIY)
            {
                if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST)
                {
                    if ( gc->modes.depthBits == 32 )
                    {
                        gc->polygon.shader.zbuf = (__GLzValue *)
                            ((GLubyte *)gc->polygon.shader.zbuf-
                             (gc->polygon.shader.ixLeft << 2));
                    }
                    else
                    {
                        gc->polygon.shader.zbuf = (__GLzValue *)
                            ((GLubyte *)gc->polygon.shader.zbuf-
                             (gc->polygon.shader.ixLeft << 1));
                    }
                }
            }
	}

        if (bIY != cIY)
        {

	    dy = (bIY + __glHalf) - b->window.y;

	    dxdyBC = (b->window.x - c->window.x) * invDyBC;

	    GenSnapXRight(gc, b->window.x + dy*dxdyBC, dxdyBC);

            gc->polygon.shader.modeFlags |= __GL_SHADE_LAST_SUBTRI;

            GENACCEL(gc).__fastFillSubTrianglePtr(gc, bIY, cIY);
	}
    }
    else
    {

	dy = (aIY + __glHalf) - a->window.y;

        dxdyAC = gc->polygon.shader.dxAC * invDyAC;

	GenSnapXRight(gc, a->window.x + dy*dxdyAC, dxdyAC);

	if (aIY != bIY)
        {
	    dxdyBA = (a->window.x - b->window.x) * invDyAB;

	    GenSnapXLeft(gc, a->window.x + dy*dxdyBA, dxdyBA);
	    dx = (gc->polygon.shader.ixLeft + __glHalf) - a->window.x;
            GENACCEL(gc).__fastSetInitParamPtr(gc, a, dx, dy);

            if (bIY == cIY)
                gc->polygon.shader.modeFlags |= __GL_SHADE_LAST_SUBTRI;

            GENACCEL(gc).__fastFillSubTrianglePtr(gc, aIY, bIY);

            if (bIY != cIY)
            {
                if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST)
                {
                    if ( gc->modes.depthBits == 32 )
                    {
                        gc->polygon.shader.zbuf = (__GLzValue *)
                            ((GLubyte *)gc->polygon.shader.zbuf-
                             (gc->polygon.shader.ixLeft << 2));
                    }
                    else
                    {
                        gc->polygon.shader.zbuf = (__GLzValue *)
                            ((GLubyte *)gc->polygon.shader.zbuf-
                             (gc->polygon.shader.ixLeft << 1));
                    }
                }
            }
	}

	if (bIY != cIY)
        {
	    dy = (bIY + __glHalf) - b->window.y;

            dxdyBC = gc->polygon.shader.dxBC * invDyBC;

	    GenSnapXLeft(gc, b->window.x + dy*dxdyBC, dxdyBC);
	    dx = (gc->polygon.shader.ixLeft + __glHalf) - b->window.x;
            GENACCEL(gc).__fastSetInitParamPtr(gc, b, dx, dy);

            gc->polygon.shader.modeFlags |= __GL_SHADE_LAST_SUBTRI;

            GENACCEL(gc).__fastFillSubTrianglePtr(gc, bIY, cIY);
	}
    }

    gc->polygon.shader.modeFlags &= ~(__GL_SHADE_LAST_SUBTRI);

    return;

bigTriangle:

    __GL_FLOAT_BEGIN_DIVIDE(gc->polygon.shader.dxAC,
                            gc->polygon.shader.dyAC,
                            &dxdyAC);

    gc->polygon.shader.cfb = gc->drawBuffer;

    //
    // Calculate delta values for unit changes in x or y
    //

    GENACCEL(gc).__fastCalcDeltaPtr(gc, a, b, c);

    //
    // calculate the destination address
    //

    GENACCEL(gc).pPix =
          (BYTE *)gc->polygon.shader.cfb->buf.base
        + (  gc->polygon.shader.cfb->buf.outerWidth
           * (
                aIY
              - gc->constants.viewportYAdjust
              + gc->polygon.shader.cfb->buf.yOrigin
             )
          )
        + (  GENACCEL(gc).xMultiplier
           * (
              - gc->constants.viewportXAdjust
              + gc->polygon.shader.cfb->buf.xOrigin
             )
          );

    // Calculate destination Z
    if ((gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) &&
        aIY != bIY)
    {
        if ( gc->modes.depthBits == 32 )
        {
            gc->polygon.shader.zbuf =
                __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                                0, aIY);
        }
        else
        {
            gc->polygon.shader.zbuf = (__GLzValue *)
                __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLz16Value*),
                                0, aIY);
        }
    }

    /*
    ** This algorithm always fills from bottom to top, left to right.
    ** Because of this, ccw triangles are inherently faster because
    ** the parameter values need not be recomputed.
    */

    if (ccw)
    {
	dy = (aIY + __glHalf) - a->window.y;

        __GL_FLOAT_SIMPLE_END_DIVIDE(dxdyAC);

	GenSnapXLeft(gc, a->window.x + dy*dxdyAC, dxdyAC);

	dx = (gc->polygon.shader.ixLeft + __glHalf) - a->window.x;
	GENACCEL(gc).__fastSetInitParamPtr(gc, a, dx, dy);

	if (aIY != bIY)
        {
	    dxdyBA = (a->window.x - b->window.x) /
                (a->window.y - b->window.y);
	    GenSnapXRight(gc, a->window.x + dy*dxdyBA, dxdyBA);

            if (bIY != cIY)
            {
                GENACCEL(gc).__fastFillSubTrianglePtr(gc, aIY, bIY);

                __GL_FLOAT_BEGIN_DIVIDE(gc->polygon.shader.dxBC,
                                        gc->polygon.shader.dyBC,
                                        &dxdyBC);

                if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST)
                {
                    if ( gc->modes.depthBits == 32 )
                    {
                        gc->polygon.shader.zbuf = (__GLzValue *)
                            ((GLubyte *)gc->polygon.shader.zbuf-
                             (gc->polygon.shader.ixLeft << 2));
                    }
                    else
                    {
                        gc->polygon.shader.zbuf = (__GLzValue *)
                            ((GLubyte *)gc->polygon.shader.zbuf-
                             (gc->polygon.shader.ixLeft << 1));
                    }
                }
            }
            else
            {
                GENACCEL(gc).__fastFillSubTrianglePtr(gc, aIY, bIY);
            }
	}
        else if (bIY != cIY)
        {
            if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST)
            {
                if ( gc->modes.depthBits == 32 )
                {
                    gc->polygon.shader.zbuf =
                        __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                                        0, bIY);
                }
                else
                {
                    gc->polygon.shader.zbuf = (__GLzValue *)
                        __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLz16Value*),
                                        0, bIY);
                }
            }

            __GL_FLOAT_BEGIN_DIVIDE(gc->polygon.shader.dxBC,
                                    gc->polygon.shader.dyBC,
                                    &dxdyBC);
        }

	if (bIY != cIY)
        {
	    dy = (bIY + __glHalf) - b->window.y;

            __GL_FLOAT_SIMPLE_END_DIVIDE(dxdyBC);

	    GenSnapXRight(gc, b->window.x + dy*dxdyBC, dxdyBC);
	    GENACCEL(gc).__fastFillSubTrianglePtr(gc, bIY, cIY);
	}
    }
    else
    {
	dy = (aIY + __glHalf) - a->window.y;

        __GL_FLOAT_SIMPLE_END_DIVIDE(dxdyAC);

	GenSnapXRight(gc, a->window.x + dy*dxdyAC, dxdyAC);

	if (aIY != bIY)
        {
	    dxdyBA = (a->window.x - b->window.x) /
                (a->window.y - b->window.y);
	    GenSnapXLeft(gc, a->window.x + dy*dxdyBA, dxdyBA);
	    dx = (gc->polygon.shader.ixLeft + __glHalf) - a->window.x;
            GENACCEL(gc).__fastSetInitParamPtr(gc, a, dx, dy);

            if (bIY != cIY)
            {
                __GL_FLOAT_BEGIN_DIVIDE(gc->polygon.shader.dxBC,
                                        gc->polygon.shader.dyBC,
                                        &dxdyBC);

                GENACCEL(gc).__fastFillSubTrianglePtr(gc, aIY, bIY);

                if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST)
                {
                    if ( gc->modes.depthBits == 32 )
                    {
                        gc->polygon.shader.zbuf = (__GLzValue *)
                            ((GLubyte *)gc->polygon.shader.zbuf-
                             (gc->polygon.shader.ixLeft << 2));
                    }
                    else
                    {
                        gc->polygon.shader.zbuf = (__GLzValue *)
                            ((GLubyte *)gc->polygon.shader.zbuf-
                             (gc->polygon.shader.ixLeft << 1));
                    }
                }
            }
            else
            {
                GENACCEL(gc).__fastFillSubTrianglePtr(gc, aIY, bIY);
            }
	}
        else if (bIY != cIY)
        {
            if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST)
            {
                if ( gc->modes.depthBits == 32 )
                {
                    gc->polygon.shader.zbuf =
                        __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                                        0, bIY);
                }
                else
                {
                    gc->polygon.shader.zbuf = (__GLzValue *)
                        __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLz16Value*),
                                        0, bIY);
                }
            }

            __GL_FLOAT_BEGIN_DIVIDE(gc->polygon.shader.dxBC,
                                    gc->polygon.shader.dyBC,
                                    &dxdyBC);
        }

	if (bIY != cIY)
        {
	    dy = (bIY + __glHalf) - b->window.y;

            __GL_FLOAT_SIMPLE_END_DIVIDE(dxdyBC);

	    GenSnapXLeft(gc, b->window.x + dy*dxdyBC, dxdyBC);
	    dx = (gc->polygon.shader.ixLeft + __glHalf) - b->window.x;
            GENACCEL(gc).__fastSetInitParamPtr(gc, b, dx, dy);
	    GENACCEL(gc).__fastFillSubTrianglePtr(gc, bIY, cIY);
	}
    }

    CHOP_ROUND_OFF();
}

/**************************************************************************\
* __fastGenMcdFillTriangle
*
* Just like __fastGenFillTriangle, except that the floating point macros
* __GL_FLOAT_BEGIN_DIVIDE and __GL_FLOAT_SIMPLE_END_DIVIDE are not allowed
* to straddle a function call to the driver (i.e., __fastFillSubTrianglePtr
* calls the display driver span functions if direct frame buffer access is
* not available.
\**************************************************************************/

void FASTCALL __fastGenMcdFillTriangle(
    __GLcontext *gc,
    __GLvertex *a,
    __GLvertex *b,
    __GLvertex *c,
    GLboolean ccw)
{
    GLint aIY, bIY, cIY;
    __GLfloat dxdyAC, dxdyBC, dxdyBA;
    __GLfloat dx, dy;

    CHOP_ROUND_ON();

    //
    // Calculate delta values for unit changes in x or y
    //

    GENACCEL(gc).__fastCalcDeltaPtr(gc, a, b, c);

    __GL_FLOAT_BEGIN_DIVIDE(gc->polygon.shader.dxAC,
                            gc->polygon.shader.dyAC,
                            &dxdyAC);

    //
    // can this be moved up even farther?
    //

    gc->polygon.shader.cfb = gc->drawBuffer;

    //
    // Snap each y coordinate to its pixel center
    //

    aIY = __GL_VERTEX_FIXED_TO_INT(__GL_VERTEX_FLOAT_TO_FIXED(a->window.y)+
                                   __GL_VERTEX_FRAC_HALF);
    bIY = __GL_VERTEX_FIXED_TO_INT(__GL_VERTEX_FLOAT_TO_FIXED(b->window.y)+
                                   __GL_VERTEX_FRAC_HALF);
    cIY = __GL_VERTEX_FIXED_TO_INT(__GL_VERTEX_FLOAT_TO_FIXED(c->window.y)+
                                   __GL_VERTEX_FRAC_HALF);

    //
    // calculate the destination address
    //

    GENACCEL(gc).pPix =
          (BYTE *)gc->polygon.shader.cfb->buf.base
        + (  gc->polygon.shader.cfb->buf.outerWidth
           * (
                aIY
              - gc->constants.viewportYAdjust
              + gc->polygon.shader.cfb->buf.yOrigin
             )
          )
        + (  GENACCEL(gc).xMultiplier
           * (
              - gc->constants.viewportXAdjust
              + gc->polygon.shader.cfb->buf.xOrigin
             )
          );

    // Calculate destination Z
    if ((gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) &&
        aIY != bIY)
    {
        if ( gc->modes.depthBits == 32 )
        {
            gc->polygon.shader.zbuf =
                __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                                0, aIY);
        }
        else
        {
            gc->polygon.shader.zbuf = (__GLzValue *)
                __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLz16Value*),
                                0, aIY);
        }
    }

    /*
    ** This algorithm always fills from bottom to top, left to right.
    ** Because of this, ccw triangles are inherently faster because
    ** the parameter values need not be recomputed.
    */

    if (ccw)
    {
	dy = (aIY + __glHalf) - a->window.y;

        __GL_FLOAT_SIMPLE_END_DIVIDE(dxdyAC);

	GenSnapXLeft(gc, a->window.x + dy*dxdyAC, dxdyAC);

	dx = (gc->polygon.shader.ixLeft + __glHalf) - a->window.x;
	GENACCEL(gc).__fastSetInitParamPtr(gc, a, dx, dy);

	if (aIY != bIY)
        {
	    dxdyBA = (a->window.x - b->window.x) /
                (a->window.y - b->window.y);
	    GenSnapXRight(gc, a->window.x + dy*dxdyBA, dxdyBA);

            if (bIY != cIY)
            {
                GENACCEL(gc).__fastFillSubTrianglePtr(gc, aIY, bIY);

                __GL_FLOAT_BEGIN_DIVIDE(gc->polygon.shader.dxBC,
                                        gc->polygon.shader.dyBC,
                                        &dxdyBC);

                if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST)
                {
                    if ( gc->modes.depthBits == 32 )
                    {
                        gc->polygon.shader.zbuf = (__GLzValue *)
                            ((GLubyte *)gc->polygon.shader.zbuf-
                             (gc->polygon.shader.ixLeft << 2));
                    }
                    else
                    {
                        gc->polygon.shader.zbuf = (__GLzValue *)
                            ((GLubyte *)gc->polygon.shader.zbuf-
                             (gc->polygon.shader.ixLeft << 1));
                    }
                }
            }
            else
            {
                GENACCEL(gc).__fastFillSubTrianglePtr(gc, aIY, bIY);
            }
	}
        else if (bIY != cIY)
        {
            if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST)
            {
                if ( gc->modes.depthBits == 32 )
                {
                    gc->polygon.shader.zbuf =
                        __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                                        0, bIY);
                }
                else
                {
                    gc->polygon.shader.zbuf = (__GLzValue *)
                        __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLz16Value*),
                                        0, bIY);
                }
            }

            __GL_FLOAT_BEGIN_DIVIDE(gc->polygon.shader.dxBC,
                                    gc->polygon.shader.dyBC,
                                    &dxdyBC);
        }

	if (bIY != cIY)
        {
	    dy = (bIY + __glHalf) - b->window.y;

            __GL_FLOAT_SIMPLE_END_DIVIDE(dxdyBC);

	    GenSnapXRight(gc, b->window.x + dy*dxdyBC, dxdyBC);
	    GENACCEL(gc).__fastFillSubTrianglePtr(gc, bIY, cIY);
	}
    }
    else
    {
	dy = (aIY + __glHalf) - a->window.y;

        __GL_FLOAT_SIMPLE_END_DIVIDE(dxdyAC);

	GenSnapXRight(gc, a->window.x + dy*dxdyAC, dxdyAC);

	if (aIY != bIY)
        {
	    dxdyBA = (a->window.x - b->window.x) /
                (a->window.y - b->window.y);
	    GenSnapXLeft(gc, a->window.x + dy*dxdyBA, dxdyBA);
	    dx = (gc->polygon.shader.ixLeft + __glHalf) - a->window.x;
            GENACCEL(gc).__fastSetInitParamPtr(gc, a, dx, dy);

            if (bIY != cIY)
            {
                GENACCEL(gc).__fastFillSubTrianglePtr(gc, aIY, bIY);

                __GL_FLOAT_BEGIN_DIVIDE(gc->polygon.shader.dxBC,
                                        gc->polygon.shader.dyBC,
                                        &dxdyBC);

                if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST)
                {
                    if ( gc->modes.depthBits == 32 )
                    {
                        gc->polygon.shader.zbuf = (__GLzValue *)
                            ((GLubyte *)gc->polygon.shader.zbuf-
                             (gc->polygon.shader.ixLeft << 2));
                    }
                    else
                    {
                        gc->polygon.shader.zbuf = (__GLzValue *)
                            ((GLubyte *)gc->polygon.shader.zbuf-
                             (gc->polygon.shader.ixLeft << 1));
                    }
                }
            }
            else
            {
                GENACCEL(gc).__fastFillSubTrianglePtr(gc, aIY, bIY);
            }
	}
        else if (bIY != cIY)
        {
            if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST)
            {
                if ( gc->modes.depthBits == 32 )
                {
                    gc->polygon.shader.zbuf =
                        __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
                                        0, bIY);
                }
                else
                {
                    gc->polygon.shader.zbuf = (__GLzValue *)
                        __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLz16Value*),
                                        0, bIY);
                }
            }

            __GL_FLOAT_BEGIN_DIVIDE(gc->polygon.shader.dxBC,
                                    gc->polygon.shader.dyBC,
                                    &dxdyBC);
        }

	if (bIY != cIY)
        {
	    dy = (bIY + __glHalf) - b->window.y;

            __GL_FLOAT_SIMPLE_END_DIVIDE(dxdyBC);

	    GenSnapXLeft(gc, b->window.x + dy*dxdyBC, dxdyBC);
	    dx = (gc->polygon.shader.ixLeft + __glHalf) - b->window.x;
            GENACCEL(gc).__fastSetInitParamPtr(gc, b, dx, dy);
	    GENACCEL(gc).__fastFillSubTrianglePtr(gc, bIY, cIY);
	}
    }

    CHOP_ROUND_OFF();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\gencx.c ===
#include "precomp.h"
#pragma hdrstop

#include <imfuncs.h>
#include "genci.h"
#include "genrgb.h"
#include "devlock.h"
#include "imports.h"

//
// CJ_ALIGNDWORD computes the minimum size (in bytes) of a DWORD array that
// contains at least cj bytes.
//
#define CJ_ALIGNDWORD(cj)   ( ((cj) + (sizeof(DWORD)-1)) & (-((signed)sizeof(DWORD))) )

//
// BITS_ALIGNDWORD computes the minimum size (in bits) of a DWORD array that
// contains at least c bits.
//
// We assume that there will always be 8 bits in a byte and that sizeof()
// always returns size in bytes.  The rest is independent of the definition
// of DWORD.
//
#define BITS_ALIGNDWORD(c)  ( ((c) + ((sizeof(DWORD)*8)-1)) & (-((signed)(sizeof(DWORD)*8))) )

// change to "static" after debugging
#define STATIC

#if DBG
// not multithreaded safe, but only for testing
#define RANDOMDISABLE                           \
    {                                           \
        long saveRandom = glRandomMallocFail;   \
        glRandomMallocFail = 0;

#define RANDOMREENABLE                          \
        if (saveRandom)                         \
            glRandomMallocFail = saveRandom;    \
    }
#else
#define RANDOMDISABLE
#define RANDOMREENABLE
#endif /* DBG */

#define INITIAL_TIMESTAMP   ((ULONG)-1)

/*
 *  Function Prototypes
 */

BOOL APIENTRY ValidateLayerIndex(int iLayer, PIXELFORMATDESCRIPTOR *ppfd);


/*
 *  Private functions
 */

void FASTCALL GetContextModes(__GLGENcontext *gengc);
STATIC void FASTCALL ApplyViewport(__GLcontext *gc);
GLboolean ResizeAncillaryBuffer(__GLGENbuffers *, __GLbuffer *, GLint, GLint);
GLboolean ResizeHardwareBackBuffer(__GLGENbuffers *, __GLcolorBuffer *, GLint, GLint);
GLboolean ResizeUnownedDepthBuffer(__GLGENbuffers *, __GLbuffer *, GLint, GLint);

/******************************Public*Routine******************************\
*
* EmptyFillStrokeCache
*
* Cleans up any objects in the fill and stroke cache
*
* History:
*  Tue Aug 15 15:37:30 1995     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void FASTCALL EmptyFillStrokeCache(__GLGENcontext *gengc)
{
    if (gengc->hbrFill != NULL)
    {
        DeleteObject(gengc->hbrFill);
        gengc->hbrFill = NULL;
        gengc->crFill = COLORREF_UNUSED;
        gengc->hdcFill = NULL;
    }
#if DBG
    else
    {
        ASSERTOPENGL(gengc->crFill == COLORREF_UNUSED,
                     "crFill inconsistent\n");
    }
#endif
    if (gengc->hpenStroke != NULL)
    {
        // Deselect the pen before deletion if necessary
        if (gengc->hdcStroke != NULL)
        {
            SelectObject(gengc->hdcStroke, GetStockObject(BLACK_PEN));
            gengc->hdcStroke = NULL;
        }

        DeleteObject(gengc->hpenStroke);
        gengc->hpenStroke = NULL;
        gengc->cStroke.r = -1.0f;
        gengc->fStrokeInvalid = TRUE;
    }
#if DBG
    else
    {
        ASSERTOPENGL(gengc->cStroke.r < 0.0f &&
                     gengc->fStrokeInvalid,
                     "rStroke inconsistent\n");
    }
#endif
}

/******************************Public*Routine******************************\
* glsrvDeleteContext
*
* Deletes the generic context.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
\**************************************************************************/

BOOL APIENTRY glsrvDeleteContext(__GLcontext *gc)
{
    __GLGENcontext *gengc;

    gengc = (__GLGENcontext *)gc;

    /* Free ancillary buffer related data.  Note that these calls do
    ** *not* free software ancillary buffers, just any related data
    ** stored in them.  The ancillary buffers are freed on window destruction
    */
    if (gc->modes.accumBits) {
        DBGLEVEL(LEVEL_ALLOC,
                "DestroyContext: Freeing accumulation buffer related data\n");
        __glFreeAccum64(gc, &gc->accumBuffer);
    }

    if (gc->modes.depthBits) {
        DBGLEVEL(LEVEL_ALLOC,
                "DestroyContext: Freeing depth buffer related data\n");
        __glFreeDepth32(gc, &gc->depthBuffer);
    }
    if (gc->modes.stencilBits) {
        DBGLEVEL(LEVEL_ALLOC,
                "DestroyContext: Freeing stencil buffer related data\n");
        __glFreeStencil8(gc, &gc->stencilBuffer);
    }

    /* Free Translate & Inverse Translate vectors */
    if ((gengc->pajTranslateVector != NULL) &&
        (gengc->pajTranslateVector != gengc->xlatPalette))
        GCFREE(gc, gengc->pajTranslateVector);

    if (gengc->pajInvTranslateVector != NULL)
        GCFREE(gc, gengc->pajInvTranslateVector);

    // Make sure that any cached GDI objects are freed
    // This is normally done in LoseCurrent but a context may be
    // left current and then cleaned up
    EmptyFillStrokeCache(gengc);

    /*
    /* Free the span dibs and storage.
    */

#ifndef _CLIENTSIDE_
    if (gengc->StippleBitmap)
        EngDeleteSurface((HSURF)gengc->StippleBitmap);
#endif

    wglDeleteScanlineBuffers(gengc);

    if (gengc->StippleBits)
        GCFREE(gc, gengc->StippleBits);

    // Free __GLGENbitmap front-buffer structure

    if (gc->frontBuffer.bitmap)
        GCFREE(gc, gc->frontBuffer.bitmap);

#ifndef _CLIENTSIDE_
    /*
     *  Free the buffers that may have been allocated by feedback
     *  or selection
     */

    if ( NULL != gengc->RenderState.SrvSelectBuffer )
    {
#ifdef NT
        // match the allocation function
        FREE(gengc->RenderState.SrvSelectBuffer);
#else
        GCFREE(gc, gengc->RenderState.SrvSelectBuffer);
#endif
    }

    if ( NULL != gengc->RenderState.SrvFeedbackBuffer)
    {
#ifdef NT
        // match the allocation function
        FREE(gengc->RenderState.SrvFeedbackBuffer);
#else
        GCFREE(gc, gengc->RenderState.SrvFeedbackBuffer);
#endif
    }
#endif  //_CLIENTSIDE_

#ifdef _CLIENTSIDE_
    /*
     * Cleanup logical palette copy if it exists.
     */
    if ( gengc->ppalBuf )
        FREE(gengc->ppalBuf);
#endif

    /* Destroy acceleration-specific context information */

    __glGenDestroyAccelContext(gc);
    
#ifdef _MCD_
    /* Free the MCD state structure and associated resources. */

    if (gengc->_pMcdState) {
        GenMcdDeleteContext(gengc->_pMcdState);
    }
#endif

    /* Free any temporay buffers in abnormal process exit */
    GC_TEMP_BUFFER_EXIT_CLEANUP(gc);

    // Release references to DirectDraw surfaces
    if (gengc->gsurf.dwFlags & GLSURF_DIRECTDRAW)
    {
        GLWINDOWID gwid;
        GLGENwindow *pwnd;
        
        // Destroy window created for this context
        gwid.iType = GLWID_DDRAW;
        gwid.pdds = gengc->gsurf.dd.gddsFront.pdds;
        gwid.hdc = gengc->gsurf.hdc;
        gwid.hwnd = NULL;
        pwnd = pwndGetFromID(&gwid);
        ASSERTOPENGL(pwnd != NULL,
                     "Destroying DDraw context without window\n");
        pwndCleanup(pwnd);

        gengc->gsurf.dd.gddsFront.pdds->lpVtbl->
            Release(gengc->gsurf.dd.gddsFront.pdds);
        if (gengc->gsurf.dd.gddsZ.pdds != NULL)
        {
            gengc->gsurf.dd.gddsZ.pdds->lpVtbl->
                Release(gengc->gsurf.dd.gddsZ.pdds);
        }

    }
    
    /* Destroy rest of software context (in soft code) */
    __glDestroyContext(gc);

    return TRUE;
}

/******************************Public*Routine******************************\
* glsrvLoseCurrent
*
* Releases the current context (makes it not current).
*
\**************************************************************************/

VOID APIENTRY glsrvLoseCurrent(__GLcontext *gc)
{
    __GLGENcontext *gengc;

    gengc = (__GLGENcontext *)gc;

    DBGENTRY("LoseCurrent\n");
    ASSERTOPENGL(gc == GLTEB_SRVCONTEXT(), "LoseCurrent not current!");

    /*
    ** Release lock if still held.
    */
    if (gengc->fsLocks != 0)
    {
        glsrvReleaseLock(gengc);
    }

    /*
    ** Unscale derived state that depends upon the color scales.  This
    ** is needed so that if this context is rebound to a memdc, it can
    ** then rescale all of those colors using the memdc color scales.
    */
    __glContextUnsetColorScales(gc);
    memset(&gengc->gwidCurrent, 0, sizeof(gengc->gwidCurrent));

    /*
    ** Clean up HDC-specific GDI objects
    */
    EmptyFillStrokeCache(gengc);

    /*
    ** Free up fake window for IC's
    */
    if ((gengc->dwCurrentFlags & GLSURF_METAFILE) && gengc->ipfdCurrent == 0)
    {
        GLGENwindow *pwnd;

        pwnd = gengc->pwndMakeCur;
        ASSERTOPENGL(pwnd != NULL,
                     "IC with no pixel format but no fake window\n");

        if (pwnd->buffers != NULL)
        {
            __glGenFreeBuffers(pwnd->buffers);
        }

        DeleteCriticalSection(&pwnd->sem);
        FREE(pwnd);
    }

    gengc->pwndMakeCur = NULL;
    
#ifdef _MCD_
    /*
    ** Disconnect MCD state.
    */
    gengc->pMcdState = (GENMCDSTATE *) NULL;
#endif

    gc->constants.width = 0;
    gc->constants.height = 0;

    // Set paTeb to NULL for debugging.
    gc->paTeb = NULL;
    GLTEB_SET_SRVCONTEXT(0);
}

/******************************Public*Routine******************************\
* glsrvSwapBuffers
*
* This uses the software implementation of double buffering.  An engine
* allocated bitmap is allocated for use as the back buffer.  The SwapBuffer
* routine copies the back buffer to the front buffer surface (which may
* be another DIB, a device surface in DIB format, or a device managed
* surface (with a device specific format).
*
* The SwapBuffer routine does not disturb the contents of the back buffer,
* though the defined behavior for now is undefined.
*
* Note: the caller should be holding the per-window semaphore.
*
* History:
*  19-Nov-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY glsrvSwapBuffers(HDC hdc, GLGENwindow *pwnd)
{
    DBGENTRY("glsrvSwapBuffers\n");

    if ( pwnd->buffers ) {
        __GLGENbuffers *buffers;
        __GLGENbitmap *genBm;

        buffers = pwnd->buffers;

        if (buffers->pMcdSurf) {
            return GenMcdSwapBuffers(hdc, pwnd);
        }

        genBm = &buffers->backBitmap;

        // Make sure the backbuffer exists

        if (genBm->hbm) {
            if (!RECTLISTIsEmpty(&buffers->rl) && !buffers->fMax) {
                wglCopyBufRECTLIST(
                    hdc,
                    genBm->hdc,
                    0,
                    0,
                    buffers->backBuffer.width,
                    buffers->backBuffer.height,
                    &buffers->rl
                    );
            } else {
                buffers->fMax = FALSE;
                wglCopyBuf(
                    hdc,
                    genBm->hdc,
                    0,
                    0,
                    buffers->backBuffer.width,
                    buffers->backBuffer.height
                    );
            }
            RECTLISTSetEmpty(&buffers->rl);
        }
        if( buffers->alphaBits 
            && buffers->alphaBackBuffer
            && buffers->alphaFrontBuffer) {

            ASSERTOPENGL(buffers->alphaFrontBuffer->size ==
                         buffers->alphaBackBuffer->size,
                         "Destination alpha buffer size mismatch\n");
            
            // Destination alpha values are kept in separate buffers.
            // If this buffer set has destination alpha buffers,
            // copy the back alpha values into the front alpha buffer.
            RtlCopyMemory(buffers->alphaFrontBuffer->base,
                          buffers->alphaBackBuffer->base,
                          buffers->alphaBackBuffer->size);
        }
        return TRUE;
    }

    return FALSE;
}

/******************************Public*Routine******************************\
* gdiCopyPixels
*
* Copy span [(x, y), (x + cx, y)) (inclusive-exclusive) to/from specified
* color buffer cfb from/to the scanline buffer.
*
* If bIn is TRUE, the copy is from the scanline buffer to the buffer.
* If bIn is FALSE, the copy is from the buffer to the scanline buffer.
*
\**************************************************************************/

void gdiCopyPixels(__GLGENcontext *gengc, __GLcolorBuffer *cfb,
                   GLint x, GLint y, GLint cx, BOOL bIn)
{
    wglCopyBits(gengc, gengc->pwndLocked, gengc->ColorsBitmap, x, y, cx, bIn);
}

/******************************Public*Routine******************************\
* dibCopyPixels
*
* Special case version of gdiCopyPixels that is used when cfb is a DIB,
* either a real DIB or a device surface which has a DIB format.
*
* This function *must* be used in lieu of gdiCopyPixels if we are
* directly accessing the screen as it is not safe to call GDI entry
* points with the screen locked
*
* History:
*  24-May-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void dibCopyPixels(__GLGENcontext *gengc, __GLcolorBuffer *cfb,
                      GLint x, GLint y, GLint cx, BOOL bIn)
{
    VOID *pvDib;
    UINT cjPixel = gengc->gsurf.pfd.cColorBits >> 3;
    ULONG ulSpanVisibility;
    GLint cWalls;
    GLint *pWalls;

// Don't handle VGA DIBs.
//
// We are not supposed to call GDI if directly accessing the screen.  However,
// we should be able to assume that 4bpp devices do not support
// direct access making it OK for us to punt this call to the GDI version.
// This is true for Win95 and, according to AndrewGo, will be
// true for WinNT SUR.

    if (gengc->gsurf.pfd.cColorBits <= 4)
    {
        ASSERTOPENGL(
                !((cfb->buf.flags & DIB_FORMAT) &&
                  !(cfb->buf.flags & MEMORY_DC)),
                "dibCopyPixels: unexpected 4bpp direct surface\n"
                );

        gdiCopyPixels(gengc, cfb, x, y, cx, bIn);
        return;
    }

// Find out clipping info.

    if ((cfb->buf.flags & (NO_CLIP | DIB_FORMAT)) ==
        (NO_CLIP | DIB_FORMAT))
    {
        ulSpanVisibility = WGL_SPAN_ALL;
    }
    else
    {
        ulSpanVisibility = wglSpanVisible(x, y, cx, &cWalls, &pWalls);
    }

// Completely clipped, nothing to do.

    if (ulSpanVisibility == WGL_SPAN_NONE)
        return;

// Completely visible.
//
// Actually, if bIn == FALSE (i.e., copy from screen to scanline buffer)
// we can cheat a little and ignore the clipping.

    else if ( (ulSpanVisibility == WGL_SPAN_ALL) || !bIn )
    {
    // Get pointer into DIB at position (x, y).

        pvDib = (VOID *) (((BYTE *) gengc->gc.front->buf.base) +
                          gengc->gc.front->buf.outerWidth * y +
                          cjPixel * x);

    // If bIn == TRUE, copy from scanline buffer to DIB.
    // Otherwise,  copy from DIB to scanline buffer.

        if (bIn)
            RtlCopyMemory_UnalignedDst(pvDib, gengc->ColorsBits, cjPixel * cx);
        else
            RtlCopyMemory_UnalignedSrc(gengc->ColorsBits, pvDib, cjPixel * cx);
    }

// Partially visible.

    else
    {
        GLint xEnd = x + cx;    // end of the span
        UINT cjSpan;          // size of the current portion of span to copy
        VOID *pvBits;           // current copy position in the scanline buf
        BYTE *pjScan;           // address of scan line in DIB

        ASSERTOPENGL( cWalls && pWalls, "dibCopyPixels(): bad wall array\n");

    // The walls are walked until either the end of the array is reached
    // or the walls exceed the end of the span.  The do..while loop
    // construct was choosen because the first iteration will always
    // copy something and after the first iteration we are guaranteed
    // to be in the "cWalls is even" case.  This makes the testing the
    // walls against the span end easier.
    //
    // If cWalls is even, clip the span to each pair of walls in pWalls.
    // If cWalls is odd, form the first pair with (x, pWalls[0]) and then
    // pair the remaining walls starting with pWalls[1].

        pjScan = (VOID *) (((BYTE *) gengc->gc.front->buf.base) +
                           gengc->gc.front->buf.outerWidth * y);

        do
        {
            //!!!XXX -- Make faster by pulling the odd case out of the loop

            if (cWalls & 0x1)
            {
                pvDib = (VOID *) (pjScan + (cjPixel * x));

                pvBits = gengc->ColorsBits;

                if ( pWalls[0] <= xEnd )
                    cjSpan = cjPixel * (pWalls[0] - x);
                else
                    cjSpan = cjPixel * cx;

                pWalls++;
                cWalls--;   // Now cWalls is even!
            }
            else
            {
                pvDib = (VOID *) (pjScan + (cjPixel * pWalls[0]));

                pvBits = (VOID *) (((BYTE *) gengc->ColorsBits) +
                                   cjPixel * (pWalls[0] - x));

                if ( pWalls[1] <= xEnd )
                    cjSpan = cjPixel * (pWalls[1] - pWalls[0]);
                else
                    cjSpan = cjPixel * (xEnd - pWalls[0]);

                pWalls += 2;
                cWalls -= 2;
            }

            // We are going to cheat and ignore clipping when copying from
            // the dib to the scanline buffer (i.e., we are going to handle
            // the !bIn case as if it were WGL_SPAN_ALL).  Thus, we can assume
            // that bIn == TRUE if we get to here.
            //
            // If clipping is needed to read the DIB, its trivial to turn it
            // back on.
            //
            // RtlCopyMemory(bIn ? pvDib : pvBits,
            //               bIn ? pvBits : pvDib,
            //               cjSpan);

        //!!!dbug -- Possible COMPILER BUG (compiler should check for
        //!!!dbug    alignment before doing the "rep movsd").  Keep around
        //!!!dbug    as a test case.
        #if 1
            RtlCopyMemory_UnalignedDst(pvDib, pvBits, cjSpan);
        #else
            RtlCopyMemory(pvDib, pvBits, cjSpan);
        #endif

        } while ( cWalls && (pWalls[0] < xEnd) );
    }
}

/******************************Public*Routine******************************\
* MaskFromBits
*
* Support routine for GetContextModes.  Computes a color mask given that
* colors bit count and shift position.
*
\**************************************************************************/

#define MaskFromBits(shift, count) \
    ((0xffffffff >> (32-(count))) << (shift))

/******************************Public*Routine******************************\
* GetContextModes
*
* Convert the information from Gdi into OpenGL format after checking that
* the formats are compatible and that the surface is compatible with the
* format.
*
* Called during a glsrvMakeCurrent().
*
\**************************************************************************/

void FASTCALL GetContextModes(__GLGENcontext *gengc)
{
    PIXELFORMATDESCRIPTOR *pfmt;
    __GLcontextModes *Modes;

    DBGENTRY("GetContextModes\n");

    Modes = &((__GLcontext *)gengc)->modes;

    pfmt = &gengc->gsurf.pfd;

    if (pfmt->iPixelType == PFD_TYPE_RGBA)
        Modes->rgbMode              = GL_TRUE;
    else
        Modes->rgbMode              = GL_FALSE;

    Modes->colorIndexMode       = !Modes->rgbMode;

    if (pfmt->dwFlags & PFD_DOUBLEBUFFER)
        Modes->doubleBufferMode     = GL_TRUE;
    else
        Modes->doubleBufferMode     = GL_FALSE;

    if (pfmt->dwFlags & PFD_STEREO)
        Modes->stereoMode           = GL_TRUE;
    else
        Modes->stereoMode           = GL_FALSE;

    Modes->accumBits        = pfmt->cAccumBits;
    Modes->haveAccumBuffer  = GL_FALSE;

    Modes->auxBits          = NULL;     // This is a pointer

    Modes->depthBits        = pfmt->cDepthBits;
    Modes->haveDepthBuffer  = GL_FALSE;

    Modes->stencilBits      = pfmt->cStencilBits;
    Modes->haveStencilBuffer= GL_FALSE;

    if (pfmt->cColorBits > 8)
        Modes->indexBits    = 8;
    else
        Modes->indexBits    = pfmt->cColorBits;

    Modes->indexFractionBits= 0;

    // The Modes->{Red,Green,Blue}Bits are used in soft
    Modes->redBits          = pfmt->cRedBits;
    Modes->greenBits        = pfmt->cGreenBits;
    Modes->blueBits         = pfmt->cBlueBits;
    Modes->alphaBits        = pfmt->cAlphaBits;
    Modes->redMask          = MaskFromBits(pfmt->cRedShift, pfmt->cRedBits);
    Modes->greenMask        = MaskFromBits(pfmt->cGreenShift, pfmt->cGreenBits);
    Modes->blueMask         = MaskFromBits(pfmt->cBlueShift, pfmt->cBlueBits);
    Modes->alphaMask        = MaskFromBits(pfmt->cAlphaShift, pfmt->cAlphaBits);
    Modes->rgbMask          = Modes->redMask | Modes->greenMask |
                              Modes->blueMask;
    Modes->allMask          = Modes->redMask | Modes->greenMask |
                              Modes->blueMask | Modes->alphaMask;
    Modes->maxAuxBuffers    = 0;

    Modes->isDirect         = GL_FALSE;
    Modes->level            = 0;

    #if DBG
    DBGBEGIN(LEVEL_INFO)
        DbgPrint("GL generic server get modes: rgbmode %d, cimode %d, index bits %d\n", Modes->rgbMode, Modes->colorIndexMode);
        DbgPrint("    redmask 0x%x, greenmask 0x%x, bluemask 0x%x\n", Modes->redMask, Modes->greenMask, Modes->blueMask);
        DbgPrint("    redbits %d, greenbits %d, bluebits %d\n", Modes->redBits, Modes->greenBits, Modes->blueBits);
        DbgPrint("GetContext Modes flags %X\n", gengc->gsurf.dwFlags);
    DBGEND
    #endif   /* DBG */
}

/******************************Public*Routine******************************\
* wglGetSurfacePalette
*
* Initialize the array of RGBQUADs to match the color table or palette
* of the DC's surface.
*
* Note:
*   Should be called only for 8bpp or lesser surfaces.
*
* History:
*  12-Jun-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL
wglGetSurfacePalette( __GLGENcontext *gengc, RGBQUAD *prgbq,
                      BOOL bTranslateDdb )
{
    int nColors;
    BOOL bRet;
    BOOL bConvert;
    PALETTEENTRY ppe[256];
    int i;
    
    ASSERTOPENGL(gengc->gsurf.pfd.cColorBits <= 8,
                 "wglGetSurfacePalette called for deep surface\n");
    ASSERTOPENGL((gengc->dwCurrentFlags & GLSURF_METAFILE) == 0,
                 "wglGetSurfacePalette called for metafile\n");

    nColors = 1 << gengc->gsurf.pfd.cColorBits;
    
    if (gengc->dwCurrentFlags & GLSURF_DIRECTDRAW)
    {
        LPDIRECTDRAWPALETTE pddp;
        HRESULT hr;
        
        // Retrieve DirectDraw palette from surface
        if (gengc->gsurf.dd.gddsFront.pdds->lpVtbl->
            GetPalette(gengc->gsurf.dd.gddsFront.pdds, &pddp) != DD_OK ||
            pddp == NULL)
        {
            return FALSE;
        }
        
        hr = pddp->lpVtbl->GetEntries(pddp, 0, 0, nColors, ppe);

        pddp->lpVtbl->Release(pddp);

        bRet = hr == DD_OK;
        bConvert = TRUE;
    }
    else if (GLSURF_IS_DIRECTDC(gengc->dwCurrentFlags))
    {
        // Direct DC, so get the RGB values from the system palette.
        bRet = wglGetSystemPaletteEntries(gengc->gwidCurrent.hdc,
                                          0, nColors, ppe);
        bConvert = TRUE;
    }
    else if (gengc->dwCurrentFlags & GLSURF_DIRECT_ACCESS)
    {
        // DIB section, so copy the color table.
        bRet = GetDIBColorTable(gengc->gwidCurrent.hdc, 0, nColors, prgbq);
        bConvert = FALSE;
    }
    else
    {
        // DDB surface, so use the logical palette.
        bRet = GetPaletteEntries(GetCurrentObject(gengc->gwidCurrent.hdc,
                                                  OBJ_PAL),
                                 0, nColors, ppe);

        // For certain DDB surfaces we need the palette to be permuted
        // by the forward translation vector before use.
        if (bRet && bTranslateDdb)
        {
            BYTE *pjTrans;
            
            bConvert = FALSE;
            
            // Convert to RGBQUAD with forward translation permutation.
            pjTrans = gengc->pajTranslateVector;
            for (i = 0; i < nColors; i++)
            {
                prgbq[pjTrans[i]].rgbRed      = ppe[i].peRed;
                prgbq[pjTrans[i]].rgbGreen    = ppe[i].peGreen;
                prgbq[pjTrans[i]].rgbBlue     = ppe[i].peBlue;
                prgbq[pjTrans[i]].rgbReserved = 0;
            }
        }
        else
        {
            bConvert = TRUE;
        }
    }

    if (bRet && bConvert)
    {
        // Convert to RGBQUAD.
        for (i = 0; i < nColors; i++)
        {
            prgbq[i].rgbRed      = ppe[i].peRed;
            prgbq[i].rgbGreen    = ppe[i].peGreen;
            prgbq[i].rgbBlue     = ppe[i].peBlue;
            prgbq[i].rgbReserved = 0;
        }
    }
    
    return bRet;
}

/******************************Public*Routine******************************\
* SyncDibColorTables
*
* Setup the color table in each DIB associated with the specified
* GLGENcontext to match the system palette.
*
* Called only for <= 8bpp surfaces.
*
* History:
*  24-Oct-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void
SyncDibColorTables(__GLGENcontext *gengc)
{
    __GLGENbuffers *buffers = gengc->pwndLocked->buffers;

    ASSERTOPENGL(gengc->gsurf.pfd.cColorBits <= 8,
                 "SyncDibColorTables(): bad surface type");

    if (gengc->ColorsBitmap || buffers->backBitmap.hbm)
    {
        RGBQUAD rgbq[256];
        
        if (wglGetSurfacePalette(gengc, rgbq, TRUE))
        {
            int nColors;
            
        // If color table was obtained, setup the DIBs.

            nColors = 1 << gengc->gsurf.pfd.cColorBits;
            
        // Scan-line DIB.
            if (gengc->ColorsBitmap)
                SetDIBColorTable(gengc->ColorsMemDC, 0, nColors, rgbq);

        // Back buffer
            if (buffers->backBitmap.hbm)
                SetDIBColorTable(buffers->backBitmap.hdc, 0, nColors, rgbq);
        }
        else
        {
            WARNING("SyncDibColorTables: Unable to get surface palette\n");
        }
    }
}

static BYTE vubSystemToRGB8[20] = {
    0x00,
    0x04,
    0x20,
    0x24,
    0x80,
    0x84,
    0xa0,
    0xf6,
    0xf6,
    0xf5,
    0xff,
    0xad,
    0xa4,
    0x07,
    0x38,
    0x3f,
    0xc0,
    0xc7,
    0xf8,
    0xff
};

// ComputeInverseTranslationVector
//      Computes the inverse translation vector for 4-bit and 8-bit.
//
// Synopsis:
//      void ComputeInverseTranslation(
//          __GLGENcontext *gengc   specifies the generic RC
//          int cColorEntries       specifies the number of color entries
//          BYTE iPixeltype         specifies the pixel format type
//
// Assumtions:
//      The inverse translation vector has been allocated and initialized with
//      zeros.
//
// History:
// 23-NOV-93 Eddie Robinson [v-eddier] Wrote it.
//
void FASTCALL ComputeInverseTranslationVector(__GLGENcontext *gengc,
                                              int cColorEntries,
                                              int iPixelType)
{
    BYTE *pXlate, *pInvXlate;
    int i, j;

    pInvXlate = gengc->pajInvTranslateVector;
    pXlate = gengc->pajTranslateVector;
    for (i = 0; i < cColorEntries; i++)
    {
        if (pXlate[i] == i) {       // Look for trivial mapping first
            pInvXlate[i] = (BYTE)i;
        }
        else
        {
            for (j = 0; j < cColorEntries; j++)
            {
                if (pXlate[j] == i) // Look for exact match
                {
                    pInvXlate[i] = (BYTE)j;
                    goto match_found;
                }
            }

            //
            // If we reach here, there is no exact match, so we should find the
            // closest fit.  These indices should match the system colors
            // for 8-bit devices.
            //
            // Note that these pixel values cannot be generated by OpenGL
            // drawing with the current foreground translation vector.
            //

            if (cColorEntries == 256)
            {
                if (i <= 9)
                {
                    if (iPixelType == PFD_TYPE_RGBA)
                        pInvXlate[i] = vubSystemToRGB8[i];
                    else
                        pInvXlate[i] = (BYTE)i;
                }
                else if (i >= 246)
                {
                    if (iPixelType == PFD_TYPE_RGBA)
                        pInvXlate[i] = vubSystemToRGB8[i-236];
                    else
                        pInvXlate[i] = i-236;
                }
            }
        }
match_found:;
    }
}

// er: similar to function in so_textu.c, but rounds up the result

/*
** Return the log based 2 of a number
**
** logTab1 returns (int)ceil(log2(index))
** logTab2 returns (int)log2(index)+1
*/


static GLubyte logTab1[256] = { 0, 0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4,
                                4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                                5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
                                6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
                                6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                                7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                                7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                                7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8
};

static GLubyte logTab2[256] = { 1, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4,
                                5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,
                                6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
                                6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6,
                                7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                                7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                                7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                                7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8,
                                8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8
};

static GLint FASTCALL Log2RoundUp(GLint i)
{
    if (i & 0xffff0000) {
        if (i & 0xff000000) {
            if (i & 0x00ffffff)
                return(logTab2[i >> 24] + 24);
            else
                return(logTab1[i >> 24] + 24);
        } else {
            if (i & 0x0000ffff)
                return(logTab2[i >> 16] + 16);
            else
                return(logTab1[i >> 16] + 16);
        }
    } else {
        if (i & 0xff00) {
            if (i & 0x00ff)
                return (logTab2[i >> 8] + 8);
            else
                return (logTab1[i >> 8] + 8);
        } else {
            return (logTab1[i]);
        }
    }
}

// default translation vector for 4-bit RGB

static GLubyte vujRGBtoVGA[16] = {
    0x0, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf,
    0x0, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf
};

// SetColorTranslationVector
//      Sets up the translation vector, which may take 2 forms:
//      - In all 8,4-bit surfaces, get the translation vector with
//        wglCopyTranslateVector(), with 2**numBits byte entries.
//      - For 16,24,32 ColorIndex, get the mapping from index to RGB
//        value with wglGetPalette().  All entries in the table are unsigned
//        longs, with the first entry being the number of entries. This table
//        always has (2**n) <= 4096 entries, because gl assumes n bits are
//        used for color index.
//
// Synopsis:
//      void SetColorTranslationVector
//          __GLGENcontext *gengc   generic RC
//          int cColorEntries       number of color entries
//          int cColorBits          number of color bits
//          int iPixelType          specifies RGB or ColorIndex
//
// History:
// Feb. 02 Eddie Robinson [v-eddier] Added support for 4-bit and 8-bit
// Jan. 29 Marc Fortier [v-marcf] Wrote it.
void
SetColorTranslationVector(__GLGENcontext *gengc, int cColorEntries,
                          int cColorBits, int iPixelType)
{
    int numEntries, numBits;
    __GLcontextModes *Modes;
    BYTE ajBGRtoRGB[256];
    BYTE ajTmp[256];

    Modes = &((__GLcontext *)gengc)->modes;

// Handle formats with a hardware palette (i.e., 4bpp and 8bpp).

    if ( cColorBits <= 8 )
    {
        int i;
        BYTE *pXlate;

    // Compute logical to system palette forward translation vector.

        if (!wglCopyTranslateVector(gengc, gengc->pajTranslateVector,
                                    cColorEntries))
        {
        // if foreground translation vector doesn't exist, build one

            pXlate = gengc->pajTranslateVector;

            if (cColorBits == 4)
            {
            // for RGB, map 1-1-1 to VGA colors.  For CI, just map 1 to 1
                if (iPixelType == PFD_TYPE_COLORINDEX)
                {
                    for (i = 0; i < 16; i++)
                        pXlate[i] = (BYTE)i;
                }
                else
                {
                    for (i = 0; i < 16; i++)
                        pXlate[i] = vujRGBtoVGA[i];
                }
            }
            else
            {
            // for RGB, map 1 to 1.  For CI display, 1 - 20 to system colors
            // for CI DIB, just map 1 to 1
                if ((iPixelType == PFD_TYPE_COLORINDEX) &&
                    GLSURF_IS_DIRECTDC(gengc->dwCurrentFlags))
                {
                    for (i = 0; i < 10; i++)
                        pXlate[i] = (BYTE)i;

                    for (i = 10; i < 20; i++)
                        pXlate[i] = i + 236;
                }
                else
                {
                    for (i = 0; i < cColorEntries; i++)
                        pXlate[i] = (BYTE)i;
                }
            }
        }

    // Some MCD pixelformats specify a 233BGR (i.e., 2-bits blue in least
    // significant bits, etc.) bit ordering.  Unfortunately, this is the
    // slow path for simulations.  For those formats, we force the ordering
    // to RGB internally and reorder the pajTranslateVector to convert it
    // back to BGR before writing to the surface.

        if (gengc->flags & GENGC_MCD_BGR_INTO_RGB)
        {
            pXlate = gengc->pajTranslateVector;

        // Compute a 233BGR to 332RGB translation vector.

            for (i = 0; i < 256; i++)
            {
                ajBGRtoRGB[i] = (((i & 0x03) << 6) |    // blue
                                 ((i & 0x1c) << 1) |    // green
                                 ((i & 0xe0) >> 5))     // red
                                & 0xff;
            }

        // Remap the tranlation vector to 332RGB.

            RtlCopyMemory(ajTmp, pXlate, 256);

            for (i = 0; i < 256; i++)
            {
                pXlate[ajBGRtoRGB[i]] = ajTmp[i];
            }
        }

//!!!XXX -- I think the code below to fixup 4bpp is no longer needed.
//!!!XXX    There is now special case code in wglCopyTranslateVector
#if 0
        // wglCopyTranslateVector = TRUE, and 4-bit: need some fixing up
        // For now, zero out upper nibble of returned xlate vector
        else if( cColorBits == 4 ) {
            pXlate = gengc->pajTranslateVector;
            for( i = 0; i < 16; i ++ )
                pXlate[i] &= 0xf;
        }
#endif
        ComputeInverseTranslationVector( gengc, cColorEntries, iPixelType );

#ifdef _CLIENTSIDE_
        SyncDibColorTables( gengc );
#endif
    }

// Handle formats w/o a hardware format (i.e., 16bpp, 24bpp, 32bpp).

    else
    {
        if( cColorEntries <= 256 ) {
            numEntries = 256;
            numBits = 8;
        }
        else
        {
            numBits = Log2RoundUp( cColorEntries );
            numEntries = 1 << numBits;
        }

        // We will always allocate 4096 entries for CI mode with > 8 bits
        // of color.  This enables us to use a constant (0xfff) mask for
        // color-index clamping.

        ASSERTOPENGL(numEntries <= MAXPALENTRIES,
                     "Maximum color-index size exceeded");

        if( (numBits == Modes->indexBits) &&
            (gengc->pajTranslateVector != NULL) )
        {
            // New palette same size as previous
            ULONG *pTrans;
            int i;

            // zero out some entries
            pTrans = (ULONG *)gengc->pajTranslateVector + cColorEntries + 1;
            for( i = cColorEntries + 1; i < MAXPALENTRIES; i ++ )
                *pTrans++ = 0;
        }
        else
        {
            __GLcontext *gc = (__GLcontext *) gengc;
            __GLcolorBuffer *cfb;

            // New palette has different size
            if( gengc->pajTranslateVector != NULL &&
                (gengc->pajTranslateVector != gengc->xlatPalette) )
                GCFREE(gc, gengc->pajTranslateVector );

            gengc->pajTranslateVector =
                GCALLOCZ(gc, (MAXPALENTRIES+1)*sizeof(ULONG));

            // Change indexBits
            Modes->indexBits = numBits;

            // For depths greater than 8 bits, cfb->redMax must change if the
            // number of entries in the palette changes.
            // Also, change the writemask so that if the palette grows, the
            // new planes will be enabled by default.

            if (cfb = gc->front)
            {
                GLint oldRedMax;

                oldRedMax = cfb->redMax;
                cfb->redMax = (1 << gc->modes.indexBits) - 1;
                gc->state.raster.writeMask |= ~oldRedMax;
                gc->state.raster.writeMask &= cfb->redMax;
            }
            if (cfb = gc->back)
            {
                GLint oldRedMax;

                oldRedMax = cfb->redMax;
                cfb->redMax = (1 << gc->modes.indexBits) - 1;
                gc->state.raster.writeMask |= ~oldRedMax;
                gc->state.raster.writeMask &= cfb->redMax;
            }

            // store procs may need to be picked based on the change in
            // palette size

            __GL_DELAY_VALIDATE(gc);
#ifdef _MCD_
            MCD_STATE_DIRTY(gc, FBUFCTRL);
#endif
        }

        // Compute index-to-color table from current palette information

        wglComputeIndexedColors( gengc,
                                 (unsigned long *) gengc->pajTranslateVector,
                                 MAXPALENTRIES );
    }
}

// HandlePaletteChanges
//      Check if palette has changed, update translation vectors
//      XXX add support for malloc failures at attention time
// Synopsis:
//      void HandlePaletteChanges(
//          __GLGENcontext *gengc   specifies the generic RC
//
// Assumtions:
//   x   wglPaletteChanged() will always return 0 when no palette is set
//      by the client.  This has proved to be not always true.
//
// History:
// Feb. 25 Fixed by rightful owner
// Feb. ?? Mutilated by others
// Jan. 29 Marc Fortier [v-marcf] Wrote it.
void HandlePaletteChanges( __GLGENcontext *gengc, GLGENwindow *pwnd )
{
    ULONG Timestamp;
    GLuint paletteSize;
    PIXELFORMATDESCRIPTOR *pfmt;

    // No palettes for IC's
    if (gengc->dwCurrentFlags & GLSURF_METAFILE)
    {
        return;
    }

    Timestamp = wglPaletteChanged(gengc, pwnd);
    if (Timestamp != gengc->PaletteTimestamp)
    {
        pfmt = &gengc->gsurf.pfd;

        if (pfmt->iPixelType == PFD_TYPE_COLORINDEX)
        {
            if (pfmt->cColorBits <= 8)
            {
                paletteSize = 1 << pfmt->cColorBits;
            }
            else
            {
                paletteSize = min(wglPaletteSize(gengc), MAXPALENTRIES);
            }
        }
        else
        {
#ifndef _CLIENTSIDE_
            /* Only update RGB at makecurrent time */
            if( (gengc->PaletteTimestamp == INITIAL_TIMESTAMP) &&
                    (pfmt->cColorBits <= 8) )
#else
            if (pfmt->cColorBits <= 8)
#endif
            {
                paletteSize = 1 << pfmt->cColorBits;
            }
            else
            {
                paletteSize = 0;
            }
        }

        if (paletteSize)
        {
            SetColorTranslationVector( gengc, paletteSize,
                                       pfmt->cColorBits, pfmt->iPixelType );
        }

        EmptyFillStrokeCache(gengc);

        gengc->PaletteTimestamp = Timestamp;
    }
}

#ifdef _CLIENTSIDE_

/******************************Public*Routine******************************\
* wglFillBitfields
*
* Return the Red, Green, and Blue color masks based on the DC surface
* format.  The masks are returned in the pdwColorFields array in the
* order: red mask, green mask, blue mask.
*
* Note:
*   Should be called only for 16bpp or greater surfaces.
*
* History:
*  12-Jun-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void
wglFillBitfields(PIXELFORMATDESCRIPTOR *ppfd, DWORD *pdwColorFields)
{
    *pdwColorFields++ = MaskFromBits(ppfd->cRedShift,   ppfd->cRedBits  );
    *pdwColorFields++ = MaskFromBits(ppfd->cGreenShift, ppfd->cGreenBits);
    *pdwColorFields++ = MaskFromBits(ppfd->cBlueShift,  ppfd->cBlueBits );
}

/******************************Public*Routine******************************\
* wglCreateBitmap
*
* Create a DIB section and color table that matches the specified format.
*
* Returns:
*   A valid bitmap handle if sucessful, NULL otherwise.
*
* History:
*  20-Sep-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

HBITMAP
wglCreateBitmap( __GLGENcontext *gengc, SIZEL sizl, PVOID *ppvBits )
{
    BITMAPINFO *pbmi;
    HBITMAP    hbmRet = (HBITMAP) NULL;
    size_t     cjbmi;
    DWORD      dwCompression;
    DWORD      cjImage = 0;
    WORD       wBitCount;
    int        cColors = 0;

    *ppvBits = (PVOID) NULL;

// Figure out what kind of DIB needs to be created based on the
// DC format.

    switch ( gengc->gsurf.pfd.cColorBits )
    {
    case 4:
        cjbmi = sizeof(BITMAPINFO) + 16*sizeof(RGBQUAD);
        dwCompression = BI_RGB;
        wBitCount = 4;
        cColors = 16;
        break;
    case 8:
        cjbmi = sizeof(BITMAPINFO) + 256*sizeof(RGBQUAD);
        dwCompression = BI_RGB;
        wBitCount = 8;
        cColors = 256;
        break;
    case 16:
        cjbmi = sizeof(BITMAPINFO) + 3*sizeof(RGBQUAD);
        dwCompression = BI_BITFIELDS;
        cjImage = sizl.cx * sizl.cy * 2;
        wBitCount = 16;
        break;
    case 24:
        cjbmi = sizeof(BITMAPINFO);
        dwCompression = BI_RGB;
        wBitCount = 24;
        break;
    case 32:
        cjbmi = sizeof(BITMAPINFO) + 3*sizeof(RGBQUAD);
        dwCompression = BI_BITFIELDS;
        cjImage = sizl.cx * sizl.cy * 4;
        wBitCount = 32;
        break;
    default:
        WARNING1("wglCreateBitmap: unknown format 0x%lx\n",
                 gengc->gsurf.pfd.cColorBits);
        return (HBITMAP) NULL;
    }

// Allocate the BITMAPINFO structure and color table.

    pbmi = ALLOC(cjbmi);
    if (pbmi)
    {
        pbmi->bmiHeader.biSize          = sizeof(BITMAPINFOHEADER);
        pbmi->bmiHeader.biWidth         = sizl.cx;
        pbmi->bmiHeader.biHeight        = sizl.cy;
        pbmi->bmiHeader.biPlanes        = 1;
        pbmi->bmiHeader.biBitCount      = wBitCount;
        pbmi->bmiHeader.biCompression   = dwCompression;
        pbmi->bmiHeader.biSizeImage     = cjImage;
        pbmi->bmiHeader.biXPelsPerMeter = 0;
        pbmi->bmiHeader.biYPelsPerMeter = 0;
        pbmi->bmiHeader.biClrUsed       = 0;
        pbmi->bmiHeader.biClrImportant  = 0;

    // Initialize DIB color table.

        switch (gengc->gsurf.pfd.cColorBits)
        {
        case 4:
        case 8:
            if (!wglGetSurfacePalette(gengc, &pbmi->bmiColors[0], FALSE))
            {
                return NULL;
            }
            break;

        case 16:
        case 32:
            wglFillBitfields(&gengc->gsurf.pfd, (DWORD *) &pbmi->bmiColors[0]);
            break;

        case 24:
            // Color table is assumed to be BGR for 24BPP DIBs.  Nothing to do.
            break;
        }

    // Create DIB section.

        hbmRet = CreateDIBSection(gengc->gwidCurrent.hdc, pbmi, DIB_RGB_COLORS,
                                  ppvBits, NULL, 0);

        #if DBG
        if ( hbmRet == (HBITMAP) NULL )
            WARNING("wglCreateBitmap(): DIB section creation failed\n");
        #endif

        FREE(pbmi);
    }
    else
    {
        WARNING("wglCreateBitmap(): memory allocation error\n");
    }

    return hbmRet;
}
#endif

/******************************Public*Routine******************************\
* wglCreateScanlineBuffers
*
* Allocate the scanline buffers.  The scanline buffers are used by the
* generic implementation to write data to the target (display or bitmap)
* a span at a time when the target surface is not directly accessible.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  17-Apr-1996 -by- Gilman Wong [gilmanw]
* Taken from CreateGDIObjects and made into function.
\**************************************************************************/

BOOL FASTCALL wglCreateScanlineBuffers(__GLGENcontext *gengc)
{
    BOOL bRet = FALSE;
    PIXELFORMATDESCRIPTOR *pfmt;
    UINT cBits;
    UINT cBytes;
    SIZEL size;
    int cColorEntries;
    __GLcontext *gc;

    gc = (__GLcontext *)gengc;
    pfmt = &gengc->gsurf.pfd;

    //
    // Bitmap must have DWORD sized scanlines.
    //

    cBits = BITS_ALIGNDWORD(__GL_MAX_WINDOW_WIDTH * pfmt->cColorBits);
    cBytes = cBits / 8;

    //
    // Create color scanline DIB buffer.
    //

    size.cx = cBits / pfmt->cColorBits;
    size.cy = 1;
    gengc->ColorsMemDC = CreateCompatibleDC(gengc->gwidCurrent.hdc);
    gengc->ColorsBitmap = wglCreateBitmap(gengc, size,
                                          &gengc->ColorsBits);

    if ( (NULL == gengc->ColorsMemDC) ||
         (NULL == gengc->ColorsBitmap) ||
         (NULL == gengc->ColorsBits) ||
         !SelectObject(gengc->ColorsMemDC, gengc->ColorsBitmap) )
    {
        #if DBG
        if (!gengc->ColorsMemDC)
            WARNING("wglCreateScanlineBuffers: dc creation failed, ColorsMemDC\n");
        if (!gengc->ColorsBitmap)
            WARNING("wglCreateScanlineBuffers: bitmap creation failed, ColorsBitmap\n");
        if (!gengc->ColorsBits)
            WARNING("wglCreateScanlineBuffers: bitmap creation failed, ColorsBits\n");
        #endif

        goto wglCreateScanlineBuffers_exit;
    }

    //
    // Screen to DIB BitBlt performance on Win95 is very poor.
    // By doing the BitBlt via an intermediate DDB, we can avoid
    // a lot of unnecessary overhead.  So create an intermediate
    // scanline DDB to match ColorsBitmap.
    //

    if ((gengc->dwCurrentFlags & GLSURF_DIRECTDRAW) == 0)
    {
        gengc->ColorsDdbDc = CreateCompatibleDC(gengc->gwidCurrent.hdc);
        gengc->ColorsDdb = CreateCompatibleBitmap(gengc->gwidCurrent.hdc,
                                                  size.cx, size.cy);

        //!!!Viper fix -- Diamond Viper (Weitek 9000) fails
        //!!!             CreateCompatibleBitmap for some (currently unknown)
        //!!!             reason

        if ( !gengc->ColorsDdb )
        {
            WARNING("wglCreateScanlineBuffers: "
                    "CreateCompatibleBitmap failed\n");
            if (gengc->ColorsDdbDc)
                DeleteDC(gengc->ColorsDdbDc);
            gengc->ColorsDdbDc = (HDC) NULL;
        }
        else
        {
            if ( (NULL == gengc->ColorsDdbDc) ||
                 !SelectObject(gengc->ColorsDdbDc, gengc->ColorsDdb) )
            {
#if DBG
                if (!gengc->ColorsDdbDc)
                    WARNING("wglCreateScanlineBuffers: "
                            "dc creation failed, ColorsDdbDc\n");
                if (!gengc->ColorsDdb)
                    WARNING("wglCreateScanlineBuffers: "
                            "bitmap creation failed, ColorsDdb\n");
#endif

                goto wglCreateScanlineBuffers_exit;
            }
        }
    }

    //
    // Success.
    //

    bRet = TRUE;

wglCreateScanlineBuffers_exit:

    if (!bRet)
    {
        //
        // Error case.  Delete whatever may have been allocated.
        //

        wglDeleteScanlineBuffers(gengc);
    }

    return bRet;
}

/******************************Public*Routine******************************\
* wglDeleteScanlineBuffers
*
* Delete the scanline buffers.  The scanline buffers are used by the
* generic implementation to write data to the target (display or bitmap)
* a span at a time when the target surface is not directly accessible.
*
* History:
*  17-Apr-1996 -by- Gilman Wong [gilmanw]
* Taken from CreateGDIObjects and made into function.
\**************************************************************************/

VOID FASTCALL wglDeleteScanlineBuffers(__GLGENcontext *gengc)
{
    __GLcontext *gc = (__GLcontext *)gengc;

    //
    // Delete color scanline DIB buffer.
    //

    if (gengc->ColorsMemDC)
    {
        DeleteDC(gengc->ColorsMemDC);
        gengc->ColorsMemDC = NULL;
    }

    if (gengc->ColorsBitmap)
    {
        if (!DeleteObject(gengc->ColorsBitmap))
            ASSERTOPENGL(FALSE, "wglDeleteScanlineBuffers: DeleteObject failed");
        gengc->ColorsBitmap = NULL;
        gengc->ColorsBits = NULL;   // deleted for us when DIB section dies
    }

    //
    // Delete intermediate color scanline DDB buffer.
    //

    if (gengc->ColorsDdbDc)
    {
        if (!DeleteDC(gengc->ColorsDdbDc))
        {
            ASSERTOPENGL(FALSE, "wglDeleteScanlineBuffers: DDB DeleteDC failed");
        }
        gengc->ColorsDdbDc = NULL;
    }

    if (gengc->ColorsDdb)
    {
        if (!DeleteObject(gengc->ColorsDdb))
        {
            ASSERTOPENGL(FALSE, "wglDeleteScanlineBuffers: DDB DeleteObject failed");
        }
        gengc->ColorsDdb = NULL;
    }
}

/******************************Public*Routine******************************\
* wglInitializeColorBuffers
*
* Initialize the color buffer (front and/or back) information.
*
* History:
*  17-Apr-1996 -by- Gilman Wong [gilmanw]
* Taken out of glsrvCreateContext and made into function.
\**************************************************************************/

VOID FASTCALL wglInitializeColorBuffers(__GLGENcontext *gengc)
{
    __GLcontext *gc = &gengc->gc;

    gc->front = &gc->frontBuffer;

    if ( gc->modes.doubleBufferMode)
    {
        gc->back = &gc->backBuffer;

        if (gc->modes.colorIndexMode)
        {
            __glGenInitCI(gc, gc->front, GL_FRONT);
            __glGenInitCI(gc, gc->back, GL_BACK);
        }
        else
        {
            __glGenInitRGB(gc, gc->front, GL_FRONT);
            __glGenInitRGB(gc, gc->back, GL_BACK);
        }
    }
    else
    {
        if (gc->modes.colorIndexMode)
        {
            __glGenInitCI(gc, gc->front, GL_FRONT);
        }
        else
        {
            __glGenInitRGB(gc, gc->front, GL_FRONT);
        }
    }
}

/******************************Public*Routine******************************\
* wglInitializeDepthBuffer
*
* Initialize the depth buffer information.
*
* History:
*  17-Apr-1996 -by- Gilman Wong [gilmanw]
* Taken out of glsrvCreateContext and made into function.
\**************************************************************************/

VOID FASTCALL wglInitializeDepthBuffer(__GLGENcontext *gengc)
{
    __GLcontext *gc = &gengc->gc;

    if (gc->modes.depthBits)
    {
        if (gengc->_pMcdState) {
            // This is not the final initialization of the MCD depth buffer.
            // This is being done now so that the validate proc can be done
            // in glsrvCreateContext.  The real initialization will occur
            // during glsrvMakeCurrent.

            GenMcdInitDepth(gc, &gc->depthBuffer);
            gc->depthBuffer.scale = gengc->_pMcdState->McdRcInfo.depthBufferMax;
        } else if (gc->modes.depthBits == 16) {
            DBGINFO("CALLING: __glInitDepth16\n");
            __glInitDepth16(gc, &gc->depthBuffer);
            gc->depthBuffer.scale = 0x7fff;
        } else {
            DBGINFO("CALLING: __glInitDepth32\n");
            __glInitDepth32(gc, &gc->depthBuffer);
            gc->depthBuffer.scale = 0x7fffffff;
        }
        /*
         *  Note: scale factor does not use the high bit (this avoids
         *  floating point exceptions).
         */
        // XXX (mf) I changed 16 bit depth buffer to use high bit, since
        // there is no possibility of overflow on conversion to float.  For
        // 32-bit, (float) 0xffffffff overflows to 0.  I was able to avoid
        // overflow in this case by using a scale factor of 0xffffff7f, but
        // this is a weird number, and 31 bits is enough resolution anyways.
        // !! Note asserts in px_fast.c that have hardcoded depth scales.
    }
#ifdef _MCD_
    else
    {
        // This is not the final initialization of the MCD depth buffer.
        // This is being done now so that the validate proc can be done
        // in glsrvCreateContext.  The real initialization will occur
        // during glsrvMakeCurrent.

        GenMcdInitDepth(gc, &gc->depthBuffer);
        gc->depthBuffer.scale = 0x7fffffff;
    }
#endif
}

/******************************Public*Routine******************************\
* wglInitializePixelCopyFuncs
*
* Set the appropriate CopyPixels and PixelVisible functions in the context.
*
* History:
*  18-Apr-1996 -by- Gilman Wong [gilmanw]
* Taken out of glsrvCreateContext and made into function.
\**************************************************************************/

VOID FASTCALL wglInitializePixelCopyFuncs(__GLGENcontext *gengc)
{
    __GLcontext *gc = &gengc->gc;

    if ( gc->front->buf.flags & DIB_FORMAT )
        gengc->pfnCopyPixels = dibCopyPixels;
    else {
        if (gengc->pMcdState) {
            gengc->ColorsBits = gengc->pMcdState->pMcdSurf->McdColorBuf.pv;
            gengc->pfnCopyPixels = GenMcdCopyPixels;
        }
        else
            gengc->pfnCopyPixels = gdiCopyPixels;
    }
    gengc->pfnPixelVisible = wglPixelVisible;
}

/******************************Public*Routine******************************\
* CreateGDIObjects
*
* Create various buffers, and GDI objects that we will always need.
*
* Called from glsrvCreateContext().
*
* Returns:
*   TRUE if sucessful, FALSE if error.
*
\**************************************************************************/

BOOL FASTCALL CreateGDIObjects(__GLGENcontext *gengc)
{
    PIXELFORMATDESCRIPTOR *pfmt;
    UINT  cBytes;
    SIZEL size;
    int cColorEntries;
    __GLcontext *gc;

    gc = (__GLcontext *)gengc;
    pfmt = &gengc->gsurf.pfd;

    //
    // Palette translation vectors.
    //
    // If not a true color surface, need space for the foreground xlation
    //

    if (pfmt->cColorBits <= 8)
    {
        cColorEntries = 1 << pfmt->cColorBits;

        ASSERTOPENGL(NULL == gengc->pajTranslateVector, "have a xlate vector");

        //
        // Just set the translation vector to the cache space in the gc:
        //

        gengc->pajTranslateVector = gengc->xlatPalette;

        //
        // Allocate the inverse translation vector.
        //

        ASSERTOPENGL(NULL == gengc->pajInvTranslateVector, "have an inv xlate vector");
        gengc->pajInvTranslateVector = GCALLOCZ(gc, cColorEntries);
        if (NULL == gengc->pajInvTranslateVector)
        {
            WARNING("CreateGDIObjects: memory allocation failed, pajInvTrans\n");
            goto ERROR_EXIT;
        }
    }

    //
    // Scanline buffers.
    //
    // Always create engine bitmaps to provide a generic means of performing
    // pixel transfers using the ColorsBits and StippleBits buffers.
    //

    if (NULL == gengc->ColorsBits)
    {
        //
        // Color scanline buffer
        //

#ifdef _MCD_
        //
        // If MCD the ColorBits will be set when the MCD surface is
        // created, so nothing to do.
        //
        // Otherwise, create the generic scanline buffer.
        //
        //

        if (!gengc->_pMcdState)
#endif
        {
            //
            // Generic case.
            //

            if (!wglCreateScanlineBuffers(gengc))
            {
                WARNING("CreateGDIObjects: wglCreateScanlineBuffers failed\n");
                goto ERROR_EXIT;
            }
        }

        //
        // Stipple scanline buffer.
        //

        // Bitmap must have DWORD sized scanlines.  Note that stipple only
        // requires a 1 bit per pel bitmap.

        ASSERTOPENGL(NULL == gengc->StippleBits, "StippleBits not null");
        size.cx = BITS_ALIGNDWORD(__GL_MAX_WINDOW_WIDTH);
        cBytes = size.cx / 8;
        gengc->StippleBits = GCALLOCZ(gc, cBytes);
        if (NULL == gengc->StippleBits)
        {
            WARNING("CreateGDIObjects: memory allocation failed, StippleBits\n");
            goto ERROR_EXIT;
        }

        ASSERTOPENGL(NULL == gengc->StippleBitmap, "StippleBitmap not null");
#ifndef _CLIENTSIDE_
//!!!XXX -- why are we even bothering to make the stipple an engine bitmap?
//!!!XXX    It is never used as such (at least not yet).
        gengc->StippleBitmap = EngCreateBitmap(
                                size,
                                cBytes,
                                BMF_1BPP,
                                0,
                                gengc->StippleBits);
        if (NULL == gengc->StippleBitmap)
        {
            WARNING("CreateGDIObjects: memory allocation failed, StippleBitmap\n");
            goto ERROR_EXIT;
        }
#else
        gengc->StippleBitmap = (HBITMAP) NULL;
#endif
    }

    return TRUE;

ERROR_EXIT:

//
// Error cleanup --
// Destroy everything we might have created, return false so makecurrent fails.
//

    if (gengc->pajTranslateVector &&
        (gengc->pajTranslateVector != gengc->xlatPalette))
    {
        GCFREE(gc,gengc->pajTranslateVector);
        gengc->pajTranslateVector = NULL;
    }

    if (gengc->pajInvTranslateVector)
    {
        GCFREE(gc,gengc->pajInvTranslateVector);
        gengc->pajInvTranslateVector = NULL;
    }

    wglDeleteScanlineBuffers(gengc);

    if (gengc->StippleBits)
    {
        GCFREE(gc,gengc->StippleBits);
        gengc->StippleBits = NULL;
    }

#ifndef _CLIENTSIDE_
    if (gengc->StippleBitmap)
    {
        if (!EngDeleteSurface((HSURF)gengc->StippleBitmap))
            ASSERTOPENGL(FALSE, "EngDeleteSurface failed");
        gengc->StippleBitmap = NULL;
    }
#endif

    return FALSE;
}

/******************************Public*Routine******************************\
* ApplyViewport
*
* Recompute viewport state and clipbox.  May also be called via the
* applyViewport function pointer in the gc's proc table.
*
\**************************************************************************/

// This routine can be called because of a user vieport command, or because
// of a change in the size of the window

static void FASTCALL ApplyViewport(__GLcontext *gc)
{
    GLint xlow, ylow, xhigh, yhigh;
    GLint llx, lly, urx, ury;
    GLboolean lastReasonable;
    GLGENwindow *pwnd;
    GLint clipLeft, clipRight, clipTop, clipBottom;
    __GLGENcontext *gengc = (__GLGENcontext *) gc;

    DBGENTRY("ApplyViewport\n");

    ASSERTOPENGL(gengc->pwndLocked != NULL,
                 "ApplyViewport called without lock\n");
    
    pwnd = gengc->pwndLocked;
    if (pwnd)
    {
        gengc->visibleWidth = pwnd->rclBounds.right - pwnd->rclBounds.left;
        gengc->visibleHeight = pwnd->rclBounds.bottom - pwnd->rclBounds.top;
    }
    else
    {
        gengc->visibleWidth = 0;
        gengc->visibleHeight = 0;
    }

    // Sanity check the info from window.
    ASSERTOPENGL(
        gengc->visibleWidth <= __GL_MAX_WINDOW_WIDTH && gengc->visibleHeight <= __GL_MAX_WINDOW_HEIGHT,
        "ApplyViewport(): bad visible rect size\n"
        );

    /* If this viewport is fully contained in the window, we note this fact,
    ** and this can save us on scissoring tests.
    */
    if (gc->state.enables.general & __GL_SCISSOR_TEST_ENABLE)
    {
        xlow  = gc->state.scissor.scissorX;
        xhigh = xlow + gc->state.scissor.scissorWidth;
        ylow  = gc->state.scissor.scissorY;
        yhigh = ylow + gc->state.scissor.scissorHeight;
    }
    else
    {
        xlow = 0;
        ylow = 0;
        xhigh = gc->constants.width;
        yhigh = gc->constants.height;
    }

    /*
    ** convert visible region to GL coords and intersect with scissor
    */
    if (pwnd)
    {
        clipLeft   = pwnd->rclBounds.left - pwnd->rclClient.left;
        clipRight  = pwnd->rclBounds.right - pwnd->rclClient.left;
        clipTop    = gc->constants.height -
                     (pwnd->rclBounds.top - pwnd->rclClient.top);
        clipBottom = gc->constants.height -
                     (pwnd->rclBounds.bottom - pwnd->rclClient.top);
    }
    else
    {
        clipLeft   = 0;
        clipRight  = 0;
        clipTop    = 0;
        clipBottom = 0;
    }

    if (xlow  < clipLeft)   xlow  = clipLeft;
    if (xhigh > clipRight)  xhigh = clipRight;
    if (ylow  < clipBottom) ylow  = clipBottom;
    if (yhigh > clipTop)    yhigh = clipTop;

// ComputeClipBox

    {
        if (xlow >= xhigh || ylow >= yhigh)
        {
            gc->transform.clipX0 = gc->constants.viewportXAdjust;
            gc->transform.clipX1 = gc->constants.viewportXAdjust;
            gc->transform.clipY0 = gc->constants.viewportYAdjust;
            gc->transform.clipY1 = gc->constants.viewportYAdjust;
        }
        else
        {
            gc->transform.clipX0 = xlow + gc->constants.viewportXAdjust;
            gc->transform.clipX1 = xhigh + gc->constants.viewportXAdjust;

            if (gc->constants.yInverted) {
                gc->transform.clipY0 = (gc->constants.height - yhigh) +
                    gc->constants.viewportYAdjust;
                gc->transform.clipY1 = (gc->constants.height - ylow) +
                    gc->constants.viewportYAdjust;
            } else {
                gc->transform.clipY0 = ylow + gc->constants.viewportYAdjust;
                gc->transform.clipY1 = yhigh + gc->constants.viewportYAdjust;
            }
        }
    }

    llx    = (GLint)gc->state.viewport.x;
    lly    = (GLint)gc->state.viewport.y;

    urx    = llx + (GLint)gc->state.viewport.width;
    ury    = lly + (GLint)gc->state.viewport.height;

#ifdef NT
    gc->transform.miny = (gc->constants.height - ury) +
            gc->constants.viewportYAdjust;
    gc->transform.maxy = gc->transform.miny + (GLint)gc->state.viewport.height;
    gc->transform.fminy = (__GLfloat)gc->transform.miny;
    gc->transform.fmaxy = (__GLfloat)gc->transform.maxy;

// The viewport xScale, xCenter, yScale and yCenter values are computed in
// first MakeCurrent and subsequent glViewport calls.  When the window is
// resized (i.e. gc->constatns.height changes), however, we need to recompute
// yCenter if yInverted is TRUE.

    if (gc->constants.yInverted)
    {
        __GLfloat hh, h2;

        h2 = gc->state.viewport.height * __glHalf;
        hh = h2 - gc->constants.viewportEpsilon;
        gc->state.viewport.yCenter =
            gc->constants.height - (gc->state.viewport.y + h2) +
            gc->constants.fviewportYAdjust;

#if 0
        DbgPrint("AV ys %.3lf, yc %.3lf (%.3lf)\n",
                 -hh, gc->state.viewport.yCenter,
                 gc->constants.height - (gc->state.viewport.y + h2));
#endif
    }
#else
    ww     = gc->state.viewport.width * __glHalf;
    hh     = gc->state.viewport.height * __glHalf;

    gc->state.viewport.xScale = ww;
    gc->state.viewport.xCenter = gc->state.viewport.x + ww +
        gc->constants.fviewportXAdjust;

    if (gc->constants.yInverted) {
        gc->state.viewport.yScale = -hh;
        gc->state.viewport.yCenter =
            (gc->constants.height - gc->constants.viewportEpsilon) -
            (gc->state.viewport.y + hh) +
            gc->constants.fviewportYAdjust;
    } else {
        gc->state.viewport.yScale = hh;
        gc->state.viewport.yCenter = gc->state.viewport.y + hh +
            gc->constants.fviewportYAdjust;
    }
#endif

    // Remember the current reasonableViewport.  If it changes, we may
    // need to change the pick procs.

    lastReasonable = gc->transform.reasonableViewport;

    // Is viewport entirely within the visible bounding rectangle (which
    // includes scissoring if it is turned on)?  reasonableViewport is
    // TRUE if so, FALSE otherwise.
    // The viewport must also have a non-zero size to be reasonable

    if (llx >= xlow && lly >= ylow && urx <= xhigh && ury <= yhigh &&
        urx-llx >= 1 && ury-lly >= 1)
    {
        gc->transform.reasonableViewport = GL_TRUE;
    } else {
        gc->transform.reasonableViewport = GL_FALSE;
    }

#if 0
    DbgPrint("%3X:Clipbox %4d,%4d - %4d,%4d, reasonable %d, g %p, w %p\n",
             GetCurrentThreadId(),
             gc->transform.clipX0, gc->transform.clipY0,
             gc->transform.clipX1, gc->transform.clipY1,
             gc->transform.reasonableViewport,
             gc, ((__GLGENcontext *)gc)->pwndLocked);
#endif

#ifdef NT
// To be safe than sorry.  The new poly array does not break up Begin/End pair.

    if (lastReasonable != gc->transform.reasonableViewport)
        __GL_DELAY_VALIDATE(gc);

#ifdef _MCD_
    MCD_STATE_DIRTY(gc, VIEWPORT);
#endif

#else
    // Old code use to use __GL_DELAY_VALIDATE() macro, this would
    // blow up if resize/position changed and a flush occured between
    // a glBegin/End pair.  Only need to pick span, line, & triangle procs
    // since that is safe

    if (lastReasonable != gc->transform.reasonableViewport) {
        (*gc->procs.pickSpanProcs)(gc);
        (*gc->procs.pickTriangleProcs)(gc);
        (*gc->procs.pickLineProcs)(gc);
    }
#endif
}

/******************************Public*Routine******************************\
* __glGenFreeBuffers
*
* Free the __GLGENbuffers structure and its associated ancillary and
* back buffers.
*
\**************************************************************************/

void FASTCALL __glGenFreeBuffers(__GLGENbuffers *buffers)
{
    if (buffers == NULL)
    {
        return;
    }
    
#if DBG
    DBGBEGIN(LEVEL_INFO)
        DbgPrint("glGenFreeBuffers 0x%x, 0x%x, 0x%x, 0x%x\n",
                 buffers->accumBuffer.base,
                 buffers->stencilBuffer.base,
                 buffers->depthBuffer.base,
                 buffers);
    DBGEND;
#endif
        
    //
    // Free ancillary buffers
    //

    if (buffers->accumBuffer.base) {
        DBGLEVEL(LEVEL_ALLOC, "__glGenFreeBuffers: Freeing accumulation buffer\n");
        FREE(buffers->accumBuffer.base);
    }
    if (buffers->stencilBuffer.base) {
        DBGLEVEL(LEVEL_ALLOC, "__glGenFreeBuffers: Freeing stencil buffer\n");
        FREE(buffers->stencilBuffer.base);
    }

    //
    // Free alpha buffers
    //
    if (buffers->alphaBuffer0.base) {
        DBGLEVEL(LEVEL_ALLOC, "__glGenFreeBuffers: Freeing alpha buffer 0\n");
        FREE(buffers->alphaBuffer0.base);
    }
    if (buffers->alphaBuffer1.base) {
        DBGLEVEL(LEVEL_ALLOC, "__glGenFreeBuffers: Freeing alpha buffer 1\n");
        FREE(buffers->alphaBuffer1.base);
    }

    //
    // If its not an MCD managed depth buffer, free the depth
    // buffer.
    //

    if (buffers->resizeDepth != ResizeUnownedDepthBuffer)
    {
        if (buffers->depthBuffer.base)
        {
            DBGLEVEL(LEVEL_ALLOC,
                     "__glGenFreeBuffers: Freeing depth buffer\n");
            FREE(buffers->depthBuffer.base);
        }
    }

    //
    // Free back buffer if we allocated one
    //

    if (buffers->backBitmap.pvBits) {
        // Note: the DIB section deletion will delete
        //       buffers->backBitmap.pvBits for us
        
        if (!DeleteDC(buffers->backBitmap.hdc))
            WARNING("__glGenFreeBuffers: DeleteDC failed\n");
        DeleteObject(buffers->backBitmap.hbm);
    }

#ifdef _MCD_
    //
    // Free MCD surface.
    //

    if (buffers->pMcdSurf) {
        GenMcdDeleteSurface(buffers->pMcdSurf);
    }
#endif

    //
    // free up swap hint region
    //

    {
        PYLIST pylist;
        PXLIST pxlist;

        RECTLISTSetEmpty(&buffers->rl);

        //
        // Free up the free lists
        //

        pylist = buffers->pylist;
        while (pylist) {
            PYLIST pylistKill = pylist;
            pylist = pylist->pnext;
            FREE(pylistKill);
        }
        buffers->pylist = NULL;

        pxlist = buffers->pxlist;
        while (pxlist) {
            PXLIST pxlistKill = pxlist;
            pxlist = pxlist->pnext;
            FREE(pxlistKill);
        }
        buffers->pxlist = NULL;
    }

    //
    // Free the private structure
    //
    
    FREE(buffers);
}

/******************************Public*Routine******************************\
* __glGenAllocAndInitPrivateBufferStruct
*
* Allocates and initializes a __GLGENbuffers structure and saves it as
* the drawable private data.
*
* The __GLGENbuffers structure contains the shared ancillary and back
* buffers, as well as the cache of clip rectangles enumerated from the
* CLIPOBJ.
*
* The __GLGENbuffers structure and its data is freed by calling
* __glGenFreeBuffers.
*
* Returns:
*   NULL if error.
*
\**************************************************************************/

static __GLGENbuffers *
__glGenAllocAndInitPrivateBufferStruct(__GLcontext *gc)
{
    __GLGENbuffers *buffers;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    PIXELFORMATDESCRIPTOR *ppfd = &gengc->gsurf.pfd;

    /* No private structure, no ancillary buffers */
    DBGLEVEL(LEVEL_ALLOC, "glsrvMakeCurrent: No private struct existed\n");

    buffers = (__GLGENbuffers *)ALLOCZ(sizeof(__GLGENbuffers));
    if (NULL == buffers)
        return(NULL);

    buffers->resize = ResizeAncillaryBuffer;
    buffers->resizeDepth = ResizeAncillaryBuffer;

    buffers->accumBuffer.elementSize = gc->accumBuffer.buf.elementSize;
    buffers->depthBuffer.elementSize = gc->depthBuffer.buf.elementSize;
    buffers->stencilBuffer.elementSize = gc->stencilBuffer.buf.elementSize;

    buffers->stencilBits = ppfd->cStencilBits;
    buffers->depthBits   = ppfd->cDepthBits;
    buffers->accumBits   = ppfd->cAccumBits;
    buffers->colorBits   = ppfd->cColorBits;
    buffers->alphaBits   = ppfd->cAlphaBits;

    if (gc->modes.accumBits) {
        gc->accumBuffer.buf.base = 0;
        gc->accumBuffer.buf.size = 0;
        gc->accumBuffer.buf.outerWidth = 0;
    }
    buffers->alphaFrontBuffer = buffers->alphaBackBuffer = NULL;
    // These base values must *always* be set to 0, regardless of alphaBits,
    //  since base will be free'd if non-zero on buffer deletion
    buffers->alphaBuffer0.base = 0;
    buffers->alphaBuffer1.base = 0;
    if (gc->modes.alphaBits) {
        buffers->alphaBuffer0.size = 0;
        buffers->alphaBuffer0.outerWidth = 0;
        buffers->alphaFrontBuffer = &buffers->alphaBuffer0;
        if (gc->modes.doubleBufferMode) {
            buffers->alphaBuffer1.size = 0;
            buffers->alphaBuffer1.outerWidth = 0;
            buffers->alphaBackBuffer = &buffers->alphaBuffer1;
        }
    }
    if (gc->modes.depthBits) {
        gc->depthBuffer.buf.base = 0;
        gc->depthBuffer.buf.size = 0;
        gc->depthBuffer.buf.outerWidth = 0;
    }
    if (gc->modes.stencilBits) {
        gc->stencilBuffer.buf.base = 0;
        gc->stencilBuffer.buf.size = 0;
        gc->stencilBuffer.buf.outerWidth = 0;
    }

    // If double-buffered, initialize the fake window for the back buffer
    if (gc->modes.doubleBufferMode)
    {
        buffers->backBitmap.pwnd = &buffers->backBitmap.wnd;
        buffers->backBitmap.wnd.clipComplexity = DC_TRIVIAL;
        buffers->backBitmap.wnd.rclBounds.left = 0;
        buffers->backBitmap.wnd.rclBounds.top = 0;
        buffers->backBitmap.wnd.rclBounds.right = 0;
        buffers->backBitmap.wnd.rclBounds.bottom = 0;
        buffers->backBitmap.wnd.rclClient =
            buffers->backBitmap.wnd.rclBounds;
    }

#ifdef _MCD_
    if (gengc->_pMcdState &&
        !(gengc->flags & GLGEN_MCD_CONVERTED_TO_GENERIC)) {
        if (bInitMcdSurface(gengc, gengc->pwndLocked, buffers)) {
            if (gengc->pMcdState->pDepthSpan) {
                gc->depthBuffer.buf.base = gengc->pMcdState->pDepthSpan;
                buffers->depthBuffer.base = gengc->pMcdState->pDepthSpan;
                buffers->resizeDepth = ResizeUnownedDepthBuffer;
            }
        } else {
            WARNING("__glGenAllocAndInitPrivateBufferStruct: bInitMcdSurface failed\n");
            FREE(buffers);
            return NULL;
        }
    }
    else
#endif

    if (gengc->dwCurrentFlags & GLSURF_DIRECTDRAW)
    {
        // DDraw surfaces provide their own depth buffers
        buffers->resizeDepth = ResizeUnownedDepthBuffer;
    }
    
    buffers->clip.WndUniq = -1;

   //
   // init swap hint region
   //

   buffers->pxlist = NULL;
   buffers->pylist = NULL;

   buffers->rl.buffers = buffers;
   buffers->rl.pylist  = NULL;

   buffers->fMax = FALSE;

   return buffers;
}

/******************************Public*Routine******************************\
* __glGenCheckBufferStruct
*
* Check if context and buffer struct are compatible.
*
* To satisfy this requirement, the attributes of the shared buffers
* (back, depth, stencil, and accum) must match.  Otherwise, the context
* cannot be used with the given set of buffers.
*
* Returns:
*   TRUE if compatible, FALSE otherwise.
*
* History:
*  17-Jul-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

GLboolean __glGenCheckBufferStruct(__GLcontext *gc, __GLGENbuffers *buffers)
{
    BOOL bRet = FALSE;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    PIXELFORMATDESCRIPTOR *ppfd = &gengc->gsurf.pfd;

    if ((buffers->stencilBits == ppfd->cStencilBits) &&
        (buffers->depthBits   == ppfd->cDepthBits  ) &&
        (buffers->accumBits   == ppfd->cAccumBits  ) &&
        (buffers->colorBits   == ppfd->cColorBits  ) &&
        (buffers->alphaBits   == ppfd->cAlphaBits  ))
    {
        bRet = TRUE;
    }

    return (GLboolean)bRet;
}

/******************************Public*Routine******************************\
* glsrvMakeCurrent
*
* Make generic context current to this thread with specified DC.
*
* Returns:
*   TRUE if sucessful.
*
\**************************************************************************/

// Upper level code should make sure that this context is not current to
// any other thread, that we "lose" the old context first
// Called with DEVLOCK held, free to modify window
//
// FALSE will be returned if we cannot create the objects we need
// rcobj.cxx will set the error code to show we are out of memory

BOOL APIENTRY glsrvMakeCurrent(GLWINDOWID *pgwid, __GLcontext *gc,
                               GLGENwindow *pwnd)
{
    __GLGENcontext *gengc;
    __GLGENbuffers *buffers;
    GLint width, height;
    BOOL bFreePwnd = FALSE;
    BOOL bUninitSem = FALSE;

    DBGENTRY("Generic MakeCurrent\n");
    
    // Common initialization
    gengc = (__GLGENcontext *)gc;
    
    ASSERTOPENGL(GLTEB_SRVCONTEXT() == 0, "current context in makecurrent!");
    ASSERTOPENGL(gengc->pwndMakeCur == NULL &&
                 gengc->pwndLocked == NULL,
                 "Non-current context has window pointers\n");
    
    gengc->gwidCurrent = *pgwid;
    if (pwnd == NULL)
    {
        ASSERTOPENGL((gengc->gsurf.dwFlags & GLSURF_METAFILE),
                     "Non-metafile surface without a window\n");

        // Drawing on an IC, create a fake window with no visible area
        pwnd = (GLGENwindow *)ALLOC(sizeof(GLGENwindow));
        if (pwnd == NULL)
        {
            WARNING("glsrvMakeCurrent: memory allocation failure "
                    "(IC, window)\n");
            goto ERROR_EXIT;
        }
        bFreePwnd = TRUE;

        RtlZeroMemory(pwnd, sizeof(GLGENwindow));
        pwnd->clipComplexity = DC_TRIVIAL;

        // This window data is private so technically there'll never
        // be another thread accessing it so this critsec is unnecessary.
        // However, having it eliminates special cases where
        // window locks are taken or checked for ownership.
        __try
        {
            InitializeCriticalSection(&pwnd->sem);
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
            goto ERROR_EXIT;
        }
        bUninitSem = TRUE;

        // Set this so CreateGDIObjects doesn't attempt to create
        // zero-size objects
        gengc->ColorsBits = (void *)1;

        gengc->dwCurrentFlags = gengc->gsurf.dwFlags;
    }
    else if (pgwid->iType == GLWID_DDRAW)
    {
        gengc->dwCurrentFlags = gengc->gsurf.dwFlags;
    }
    else
    {
        GLSURF gsurf;

        if (!InitDeviceSurface(pgwid->hdc, pwnd->ipfd, gengc->gsurf.iLayer,
                               wglObjectType(pgwid->hdc), FALSE, &gsurf))
        {
            goto ERROR_EXIT;
        }

        gengc->dwCurrentFlags = gsurf.dwFlags;
    }
    
    if (gengc->dwCurrentFlags & GLSURF_DIRECTDRAW)
    {
        gengc->pgddsFront = &gengc->gsurf.dd.gddsFront;
    }
    else if (GLDIRECTSCREEN && GLSURF_IS_SCREENDC(gengc->dwCurrentFlags))
    {
        gengc->pgddsFront = &GLSCREENINFO->gdds;
    }
    else
    {
        gengc->pgddsFront = NULL;
    }

    // We need this field to tell whether we're using a fake window
    // or a real one.
    gengc->ipfdCurrent = pwnd->ipfd;

    gengc->pwndMakeCur = pwnd;
    ENTER_WINCRIT_GC(pwnd, gengc);

    width = pwnd->rclClient.right - pwnd->rclClient.left;
    height = pwnd->rclClient.bottom - pwnd->rclClient.top;
    gengc->errorcode = 0;

    // Sanity check the info from window.
    ASSERTOPENGL(
        width <= __GL_MAX_WINDOW_WIDTH && height <= __GL_MAX_WINDOW_HEIGHT,
        "glsrvMakeCurrrent(): bad window client size\n"
        );

    // Make our context current in the TEB.
    // If failures after this point, make sure to reset TEB entry
    // Set up this thread's paTeb pointer.
    gc->paTeb = GLTEB_CLTPOLYARRAY();
    GLTEB_SET_SRVCONTEXT(gc);

    buffers = pwnd->buffers;

    /* We inherit any drawable state */
    if (buffers)
    {
        gc->constants.width = buffers->width;
        gc->constants.height = buffers->height;

        if (!__glGenCheckBufferStruct(gc, buffers))
        {
            WARNING("glsrvMakeCurrent: __glGenCheckBufferStruct failed\n");
            goto ERROR_EXIT;
        }

#ifdef _MCD_
        if (GLSURF_IS_DIRECTDC(gengc->dwCurrentFlags))
        {
            if (!(gengc->flags & GLGEN_MCD_CONVERTED_TO_GENERIC) &&
                !(buffers->flags & GLGENBUF_MCD_LOST))
            {
                gengc->pMcdState = gengc->_pMcdState;

            // Reset MCD scaling values since we're now using
            // MCD hardware acceleration:

                GenMcdSetScaling(gengc);

                if (gengc->pMcdState)
                {
                    gengc->pMcdState->pMcdSurf = buffers->pMcdSurf;
                    if (buffers->pMcdSurf)
                    {
                        gengc->pMcdState->pDepthSpan = buffers->pMcdSurf->pDepthSpan;
                    }
                    else
                    {
                        WARNING("glsrvMakeCurrent: MCD context, generic surface\n");
                        goto ERROR_EXIT;
                    }
                }
                else
                {
                // Generic context.  If the surface is an MCD surface, we
                // cannot continue.  The context is generic but the pixelfmt
                // is MCD, so what must have happened is that we  attempted
                // to create an MCD context, but failed, so we reverted
                // to generic.

                    if (buffers->pMcdSurf)
                    {
                        WARNING("glsrvMakeCurrent: generic context, MCD surface\n");
                        goto ERROR_EXIT;
                    }
                }
            }
            else
            {
                gengc->pMcdState = (GENMCDSTATE *)NULL;

            // Reset MCD scaling values since we've fallen back to
            // software:

                GenMcdSetScaling(gengc);

            // If MCD context (or former context), either surface or context
            // needs conversion.
            //
            // The only other way to get here is if this is a generic context
            // an a converted surface, which is perfectly OK and requires no
            // further conversion.

                //!!!SP1 -- should be able to skip this section if no conversion
                //!!!SP1    needed, but we miss out on the forced repick, which
                //!!!SP!    could be risky for NT4.0
                //if (gengc->_pMcdState &&
                //    (!(gengc->flags & GLGEN_MCD_CONVERTED_TO_GENERIC) ||
                //     !(buffers->flags & GLGENBUF_MCD_LOST)))
                if (gengc->_pMcdState)
                {
                    BOOL bConverted;

                // Do conversion.  We must have color scales set to do the
                // conversion, but we must restore color scales afterwards.

                    __glContextSetColorScales(gc);
                    bConverted = GenMcdConvertContext(gengc, buffers);
                    __glContextUnsetColorScales(gc);

                // Fail makecurrent if conversion failed.

                    if (!bConverted)
                    {
                        WARNING("glsrvMakeCurrent: GenMcdConvertContext failed\n");
                        goto ERROR_EXIT;
                    }
                }
            }
        }
        else
            gengc->pMcdState = (GENMCDSTATE *)NULL;

#endif

        if (buffers->accumBuffer.base && gc->modes.accumBits)
        {
            DBGLEVEL(LEVEL_ALLOC, "glsrvMakeCurrent: Accumulation buffer existed\n");
            gc->accumBuffer.buf.base = buffers->accumBuffer.base;
            gc->accumBuffer.buf.size = buffers->accumBuffer.size;
            gc->accumBuffer.buf.outerWidth = buffers->width;
            gc->modes.haveAccumBuffer = GL_TRUE;
        }
        else
        {
            /* No Accum buffer at this point in time */
            DBGLEVEL(LEVEL_ALLOC, "glsrvMakeCurrent: Accum buffer doesn't exist\n");
            gc->accumBuffer.buf.base = 0;
            gc->accumBuffer.buf.size = 0;
            gc->accumBuffer.buf.outerWidth = 0;
        }
        if (buffers->depthBuffer.base && gc->modes.depthBits)
        {
            DBGLEVEL(LEVEL_ALLOC, "glsrvMakeCurrent: Depth buffer existed\n");
            gc->depthBuffer.buf.base = buffers->depthBuffer.base;
            gc->depthBuffer.buf.size = buffers->depthBuffer.size;
            gc->depthBuffer.buf.outerWidth = buffers->width;
            gc->modes.haveDepthBuffer = GL_TRUE;
        }
        else
        {
            /* No Depth buffer at this point in time */
            DBGLEVEL(LEVEL_ALLOC, "glsrvMakeCurrent: Depth buffer doesn't exist\n");
            gc->depthBuffer.buf.base = 0;
            gc->depthBuffer.buf.size = 0;
            gc->depthBuffer.buf.outerWidth = 0;
        }
        if (buffers->stencilBuffer.base && gc->modes.stencilBits)
        {
            DBGLEVEL(LEVEL_ALLOC, "glsrvMakeCurrent: Stencil buffer existed\n");
            gc->stencilBuffer.buf.base = buffers->stencilBuffer.base;
            gc->stencilBuffer.buf.size = buffers->stencilBuffer.size;
            gc->stencilBuffer.buf.outerWidth = buffers->width;
            gc->modes.haveStencilBuffer = GL_TRUE;
        }
        else
        {
            /* No Stencil buffer at this point in time */
            DBGLEVEL(LEVEL_ALLOC, "glsrvMakeCurrent:Stencil buffer doesn't exist\n");
            gc->stencilBuffer.buf.base = 0;
            gc->stencilBuffer.buf.size = 0;
            gc->stencilBuffer.buf.outerWidth = 0;
        }
    }
    else
    {
        gc->modes.haveStencilBuffer = GL_FALSE;
        gc->modes.haveDepthBuffer   = GL_FALSE;
        gc->modes.haveAccumBuffer   = GL_FALSE;
    }
    
    /*
    ** Allocate and initialize ancillary buffers structures if none were
    ** inherited.  This will happen if an RC has previously been current
    ** and is made current to a new window.
    */
    if (!buffers)
    {
        buffers = __glGenAllocAndInitPrivateBufferStruct(gc);
        if (NULL == buffers)
        {
            WARNING("glsrvMakeCurrent: __glGenAllocAndInitPrivateBufferStruct failed\n");
            goto ERROR_EXIT;
        }

        pwnd->buffers = buffers;
    }

    // Setup pointer to generic back buffer
    if ( gc->modes.doubleBufferMode)
    {
        gc->backBuffer.bitmap = &buffers->backBitmap;
        UpdateSharedBuffer(&gc->backBuffer.buf, &buffers->backBuffer);
    }

    // Setup alpha buffer pointers
    
    if ( buffers->alphaBits )
    {
        UpdateSharedBuffer( &gc->frontBuffer.alphaBuf.buf, 
                            buffers->alphaFrontBuffer );
        buffers->alphaFrontBuffer->elementSize = 
                                gc->frontBuffer.alphaBuf.buf.elementSize;
        if ( gc->modes.doubleBufferMode)
        {
            UpdateSharedBuffer( &gc->backBuffer.alphaBuf.buf, 
                                buffers->alphaBackBuffer );
            buffers->alphaBackBuffer->elementSize = 
                                gc->backBuffer.alphaBuf.buf.elementSize;
        }
    }

    if (gc->gcSig != GC_SIGNATURE)
    {
        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_ALL);
#ifdef _MCD_
        MCD_STATE_DIRTY(gc, ALL);
#endif

        // After initializing all of the individual buffer structures, make
        // sure we copy the element size back into the shared buffer.
        // This is a little clumsy,

        buffers->accumBuffer.elementSize = gc->accumBuffer.buf.elementSize;
        buffers->depthBuffer.elementSize = gc->depthBuffer.buf.elementSize;
        buffers->stencilBuffer.elementSize = gc->stencilBuffer.buf.elementSize;

        // We always need to initialize the MCD-related scaling values:

        GenMcdSetScaling(gengc);

        /*
        ** Need some stuff to exist before doing viewport stuff.
        */
        (*gc->procs.validate)(gc);

        /*
        ** The first time a context is made current the spec requires that
        ** the viewport be initialized.  The code below does it.
        ** The ApplyViewport() routine will be called inside Viewport()
        */

        __glim_Viewport(0, 0, width, height);
        __glim_Scissor(0, 0, width, height);

        /*
        ** Now that viewport is set, need to revalidate (initializes all
        ** the proc pointers).
        */
        (*gc->procs.validate)(gc);

        gc->gcSig = GC_SIGNATURE;
    }
    else        /* Not the first makecurrent for this RC */
    {
        /* This will check the window size, and recompute relevant state */
        ApplyViewport(gc);
    }

#ifdef _MCD_

    if (gengc->pMcdState)
    {
        // Now that we are assured that the mcd state is fully initialized,
        // configure the depth buffer.

        GenMcdInitDepth(gc, &gc->depthBuffer);
        if (gc->modes.depthBits)
        {
            gc->depthBuffer.scale =
                gengc->pMcdState->McdRcInfo.depthBufferMax;
        }
        else
        {
            gc->depthBuffer.scale = 0x7fffffff;
        }

        // Bind MCD context to window.

        if (!GenMcdMakeCurrent(gengc, pwnd))
        {
            goto ERROR_EXIT;
        }

        gengc->pMcdState->mcdFlags |=
            (MCD_STATE_FORCEPICK | MCD_STATE_FORCERESIZE);

        __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_ALL);
        MCD_STATE_DIRTY(gc, ALL);
    }

#endif

    // Common initialization

    // Select correct pixel-copy function

    wglInitializePixelCopyFuncs(gengc);

    // Set front-buffer HDC, window to current HDC, window
    gc->front->bitmap->hdc = pgwid->hdc;
    ASSERT_WINCRIT(pwnd);
    gc->front->bitmap->pwnd = pwnd;

    // Make sure our GDI object cache is empty
    // It should always be empty at MakeCurrent time since
    // the objects in the cache are HDC-specific and so
    // they cannot be cached between MakeCurrents since the
    // HDC could change
    //
    // This should be done before HandlePaletteChanges since the
    // cache is used there
    ASSERTOPENGL(gengc->crFill == COLORREF_UNUSED &&
                 gengc->hbrFill == NULL &&
                 gengc->hdcFill == NULL,
                 "Fill cache inconsistent at MakeCurrent\n");
    ASSERTOPENGL(gengc->cStroke.r < 0.0f &&
                 gengc->hpenStroke == NULL &&
                 gengc->hdcStroke == NULL &&
                 gengc->fStrokeInvalid,
                 "Stroke cache inconsistent at MakeCurrent\n");

    // Get current xlation
    gengc->PaletteTimestamp = INITIAL_TIMESTAMP;
    HandlePaletteChanges(gengc, pwnd);

    // Force attention code to check if resize is needed
    gengc->WndUniq = -1;
    gengc->WndSizeUniq = -1;

    // Check for allocation failures during MakeCurrent
    if (gengc->errorcode)
    {
        WARNING1("glsrvMakeCurrent: errorcode 0x%lx\n", gengc->errorcode);
        goto ERROR_EXIT;
    }

    /*
    ** Default value for rasterPos needs to be yInverted.  The
    ** defaults are filled in during SoftResetContext
    ** we do the adjusting here.
    */

    if (gc->constants.yInverted) {
        gc->state.current.rasterPos.window.y = height +
        gc->constants.fviewportYAdjust - gc->constants.viewportEpsilon;
    }

    /*
    ** Scale all state that depends upon the color scales.
    */
    __glContextSetColorScales(gc);

    LEAVE_WINCRIT_GC(pwnd, gengc);
    
    return TRUE;

ERROR_EXIT:
    memset(&gengc->gwidCurrent, 0, sizeof(gengc->gwidCurrent));
    
    // Set paTeb to NULL for debugging.
    gc->paTeb = NULL;
    
    GLTEB_SET_SRVCONTEXT(0);

    // Remove window pointers.
    if (gengc->pwndLocked != NULL)
    {
        LEAVE_WINCRIT_GC(pwnd, gengc);
    }

    if (bFreePwnd)
    {
        if (bUninitSem)
        {
            DeleteCriticalSection(&pwnd->sem);
        }
        FREE(pwnd);
    }
    
    gengc->pwndMakeCur = NULL;
    
    return FALSE;
}

/******************************Public*Routine******************************\
* AddSwapHintRectWIN()
*
* 17-Feb-1995 mikeke    Created
\**************************************************************************/

void APIPRIVATE __glim_AddSwapHintRectWIN(
    GLint xs,
    GLint ys,
    GLint xe,
    GLint ye)
{
    __GLGENbuffers *buffers;

    __GL_SETUP();

    buffers = ((__GLGENcontext *)gc)->pwndLocked->buffers;

    if (xs < 0)                          xs = 0;
    if (xe > buffers->backBuffer.width)  xe = buffers->backBuffer.width;
    if (ys < 0)                          ys = 0;
    if (ye > buffers->backBuffer.height) ye = buffers->backBuffer.height;

    if (xs < xe && ys < ye) {
        if (gc->constants.yInverted) {
            RECTLISTAddRect(&buffers->rl,
                xs, buffers->backBuffer.height - ye,
                xe, buffers->backBuffer.height - ys);
        } else {
            RECTLISTAddRect(&buffers->rl, xs, ys, xe, ye);
        }
    }
}

/******************************Public*Routine******************************\
* wglFixupPixelFormat
*
* Fixes up certain MCD pixel format cases
*
* History:
*  21-Apr-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID FASTCALL wglFixupPixelFormat(__GLGENcontext *gengc,
                                  PIXELFORMATDESCRIPTOR *ppfd)
{
// Some MCD pixelformats specify a 233BGR (i.e., 2-bits blue in least
// significant bits, etc.) bit ordering.  Unfortunately, this is the
// slow path for simulations.  For those formats, we force the ordering
// to RGB internally and reorder the pajTranslateVector to convert it
// back to BGR before writing to the surface.

    if (((ppfd->dwFlags & (PFD_NEED_SYSTEM_PALETTE | PFD_GENERIC_ACCELERATED))
         == (PFD_NEED_SYSTEM_PALETTE | PFD_GENERIC_ACCELERATED)) &&
        (ppfd->cRedBits   == 3) && (ppfd->cRedShift   == 5) &&
        (ppfd->cGreenBits == 3) && (ppfd->cGreenShift == 2) &&
        (ppfd->cBlueBits  == 2) && (ppfd->cBlueShift  == 0))
    {
        ppfd->cRedShift   = 0;
        ppfd->cGreenShift = 3;
        ppfd->cBlueShift  = 6;

        gengc->flags |= GENGC_MCD_BGR_INTO_RGB;
    }
    else
    {
        gengc->flags &= ~GENGC_MCD_BGR_INTO_RGB;
    }
}

/******************************Public*Routine******************************\
* glsrvCreateContext
*
* Create a generic context.
*
* Returns:
*   NULL for failure.
*
\**************************************************************************/

// hdc is the dc used to create the context,  hrc is how the server
// identifies the GL context,  the GLcontext pointer that is return is how
// the generic code identifies the context.  The server will pass that pointer
// in all calls.

PVOID APIENTRY glsrvCreateContext(GLWINDOWID *pgwid, GLSURF *pgsurf)
{
    __GLGENcontext *gengc;
    __GLcontext *gc;

    RANDOMDISABLE;

    DBGENTRY("__glsrvCreateContext\n");

    // Initialize the temporary memory allocation table
    if (!InitTempAlloc())
    {
        return NULL;
    }

    gengc = ALLOCZ(sizeof(*gengc));
    if (gengc == NULL)
    {
        WARNING("bad alloc\n");
        return NULL;
    }

    gengc->hrc = NULL;
    gc = (__GLcontext *)gengc;

    // Initialize cached objects to nothing
    gengc->crFill = COLORREF_UNUSED;
    gengc->hbrFill = NULL;
    gengc->hdcFill = NULL;
    gengc->cStroke.r = -1.0f;
    gengc->fStrokeInvalid = TRUE;
    gengc->hpenStroke = NULL;
    gengc->hdcStroke = NULL;

    gc->gcSig = 0;

    /*
     *  Add a bunch of constants to the context
     */

    gc->constants.maxViewportWidth        = __GL_MAX_WINDOW_WIDTH;
    gc->constants.maxViewportHeight       = __GL_MAX_WINDOW_HEIGHT;

    gc->constants.viewportXAdjust         = __GL_VERTEX_X_BIAS+
        __GL_VERTEX_X_FIX;
    gc->constants.viewportYAdjust         = __GL_VERTEX_Y_BIAS+
        __GL_VERTEX_Y_FIX;

    gc->constants.subpixelBits            = __GL_WGL_SUBPIXEL_BITS;

    gc->constants.numberOfLights          = __GL_WGL_NUMBER_OF_LIGHTS;
    gc->constants.numberOfClipPlanes      = __GL_WGL_NUMBER_OF_CLIP_PLANES;
    gc->constants.numberOfTextures        = __GL_WGL_NUMBER_OF_TEXTURES;
    gc->constants.numberOfTextureEnvs     = __GL_WGL_NUMBER_OF_TEXTURE_ENVS;
    gc->constants.maxTextureSize          = __GL_WGL_MAX_MIPMAP_LEVEL;/*XXX*/
    gc->constants.maxMipMapLevel          = __GL_WGL_MAX_MIPMAP_LEVEL;
    gc->constants.maxListNesting          = __GL_WGL_MAX_LIST_NESTING;
    gc->constants.maxEvalOrder            = __GL_WGL_MAX_EVAL_ORDER;
    gc->constants.maxPixelMapTable        = __GL_WGL_MAX_PIXEL_MAP_TABLE;
    gc->constants.maxAttribStackDepth     = __GL_WGL_MAX_ATTRIB_STACK_DEPTH;
    gc->constants.maxClientAttribStackDepth = __GL_WGL_MAX_CLIENT_ATTRIB_STACK_DEPTH;
    gc->constants.maxNameStackDepth       = __GL_WGL_MAX_NAME_STACK_DEPTH;

    gc->constants.pointSizeMinimum        =
                                (__GLfloat)__GL_WGL_POINT_SIZE_MINIMUM;
    gc->constants.pointSizeMaximum        =
                                (__GLfloat)__GL_WGL_POINT_SIZE_MAXIMUM;
    gc->constants.pointSizeGranularity    =
                                (__GLfloat)__GL_WGL_POINT_SIZE_GRANULARITY;
    gc->constants.lineWidthMinimum        =
                                (__GLfloat)__GL_WGL_LINE_WIDTH_MINIMUM;
    gc->constants.lineWidthMaximum        =
                                (__GLfloat)__GL_WGL_LINE_WIDTH_MAXIMUM;
    gc->constants.lineWidthGranularity    =
                                (__GLfloat)__GL_WGL_LINE_WIDTH_GRANULARITY;

#ifndef NT
    gc->dlist.optimizer = __glDlistOptimizer;
    gc->dlist.checkOp = __glNopGCListOp;
    gc->dlist.listExec = __gl_GenericDlOps;
    gc->dlist.baseListExec = __glListExecTable;
#endif
    gc->dlist.initState = __glNopGC;

    __glEarlyInitContext( gc );

    if (gengc->errorcode)
    {
        WARNING1("Context error is %d\n", gengc->errorcode);
        glsrvDeleteContext(gc);
        return NULL;
    }

    RANDOMREENABLE;

    // Many routines depend on a current surface so set it temporarily
    gengc->gwidCurrent = *pgwid;
    gengc->dwCurrentFlags = pgsurf->dwFlags;

    // Get copy of current pixelformat
    if (pgsurf->iLayer == 0 &&
        (pgsurf->pfd.dwFlags &
         (PFD_GENERIC_FORMAT | PFD_GENERIC_ACCELERATED)) ==
        (PFD_GENERIC_FORMAT | PFD_GENERIC_ACCELERATED))
    {
        wglFixupPixelFormat(gengc, &pgsurf->pfd);
    }
    gengc->gsurf = *pgsurf;

#ifdef _MCD_
    // Is the pixelformat compatible with the generic code, or is it some
    // weird h/w (MCD) format generic cannot handle?
    if (GenMcdGenericCompatibleFormat(gengc))
        gengc->flags |= GENGC_GENERIC_COMPATIBLE_FORMAT;
#endif

    // Extract information from pixel format to set up modes
    GetContextModes(gengc);

    ASSERTOPENGL(GLSURF_IS_MEMDC(gengc->dwCurrentFlags) ?
        !gc->modes.doubleBufferMode : 1, "Double buffered memdc!");

    // XXX! Reset buffer dimensions to force Bitmap resize call
    // We should eventually handle the Bitmap as we do ancilliary buffers
    gc->constants.width = 0;
    gc->constants.height = 0;

    __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_ALL);
#ifdef _MCD_
    MCD_STATE_DIRTY(gc, ALL);
#endif

    gc->constants.yInverted = GL_TRUE;
    gc->constants.ySign = -1;

    // Allocate GDI objects that we will need
    if (!CreateGDIObjects(gengc))
    {
        goto ERROR_EXIT;
    }

    // Allocate __GLGENbitmap front-buffer structure

    if (!(gc->frontBuffer.bitmap = GCALLOCZ(gc, sizeof(__GLGENbitmap))))
    {
        goto ERROR_EXIT;
    }

    // Create MCD rendering context, if MCD is available.

    if (gengc->gsurf.dwFlags & GLSURF_VIDEO_MEMORY)
    {
        GLGENwindow *pwnd;
        BOOL bMcdContext;

        // Validate layer index
        if (pgsurf->iLayer &&
            !ValidateLayerIndex(pgsurf->iLayer, &pgsurf->pfd))
        {
            WARNING("glsrvCreateContext: bad iLayer\n");
            goto ERROR_EXIT;
        }

        pwnd = pwndGetFromID(pgwid);
        if (pwnd == NULL)
        {
            goto ERROR_EXIT;
        }

        // If this fails, _pMcdState is NULL and we fall back on
        // the software-only implementation.
        //
        // Unless we were trying to create a layer context.  Generic
        // does not support layers, so fail if we cannot create an
        // MCD context.

        bMcdContext = bInitMcdContext(gengc, pwnd);

        if (!(gengc->flags & GENGC_GENERIC_COMPATIBLE_FORMAT) && !bMcdContext)
        {
            goto ERROR_EXIT;
        }

        pwndRelease(pwnd);
    }

    /*
     *  Initialize front/back color buffer(s)
     */

    wglInitializeColorBuffers(gengc);

    /*
     *  Initialize any other ancillary buffers
     */

    // Init accum buffer.
    if (gc->modes.accumBits)
    {
        switch (gc->modes.accumBits)
        {
        case 16:
        // We will now internally use a 32-bit accum for accumBits=16
        case 32:
            __glInitAccum32(gc, &gc->accumBuffer);
            break;
        case 64:
        default:
            __glInitAccum64(gc, &gc->accumBuffer);
            break;
        }
    }

    // Initialize depth buffer.
    wglInitializeDepthBuffer(gengc);

    // Init stencil buffer.
    if (gc->modes.stencilBits)
    {
        __glInitStencil8( gc, &gc->stencilBuffer);
    }

    // Look at REX code for procs to make CPU specific
    gc->procs.bitmap                      = __glDrawBitmap;
    gc->procs.clipPolygon                 = __glClipPolygon;
    gc->procs.validate                    = __glGenericValidate;

    gc->procs.pickAllProcs                = __glGenericPickAllProcs;
    gc->procs.pickBlendProcs              = __glGenericPickBlendProcs;
    gc->procs.pickFogProcs                = __glGenericPickFogProcs;
    gc->procs.pickParameterClipProcs      = __glGenericPickParameterClipProcs;
    gc->procs.pickStoreProcs              = __glGenPickStoreProcs;
    gc->procs.pickTextureProcs            = __glGenericPickTextureProcs;

    gc->procs.copyImage                   = __glGenericPickCopyImage;

    gc->procs.pixel.spanReadCI            = __glSpanReadCI;
    gc->procs.pixel.spanReadCI2           = __glSpanReadCI2;
    gc->procs.pixel.spanReadRGBA          = __glSpanReadRGBA;
    gc->procs.pixel.spanReadRGBA2         = __glSpanReadRGBA2;
    gc->procs.pixel.spanReadDepth         = __glSpanReadDepth;
    gc->procs.pixel.spanReadDepth2        = __glSpanReadDepth2;
    gc->procs.pixel.spanReadStencil       = __glSpanReadStencil;
    gc->procs.pixel.spanReadStencil2      = __glSpanReadStencil2;
    gc->procs.pixel.spanRenderCI          = __glSpanRenderCI;
    gc->procs.pixel.spanRenderCI2         = __glSpanRenderCI2;
    gc->procs.pixel.spanRenderRGBA        = __glSpanRenderRGBA;
    gc->procs.pixel.spanRenderRGBA2       = __glSpanRenderRGBA2;
    gc->procs.pixel.spanRenderDepth       = __glSpanRenderDepth;
    gc->procs.pixel.spanRenderDepth2      = __glSpanRenderDepth2;
    gc->procs.pixel.spanRenderStencil     = __glSpanRenderStencil;
    gc->procs.pixel.spanRenderStencil2    = __glSpanRenderStencil2;

    gc->procs.applyViewport               = ApplyViewport;

    gc->procs.pickBufferProcs             = __glGenericPickBufferProcs;
    gc->procs.pickColorMaterialProcs      = __glGenericPickColorMaterialProcs;
    gc->procs.pickPixelProcs              = __glGenericPickPixelProcs;

    gc->procs.pickClipProcs               = __glGenericPickClipProcs;
    gc->procs.pickLineProcs               = __fastGenPickLineProcs;
    gc->procs.pickSpanProcs               = __fastGenPickSpanProcs;
    gc->procs.pickTriangleProcs           = __fastGenPickTriangleProcs;
    gc->procs.pickRenderBitmapProcs       = __glGenericPickRenderBitmapProcs;
    gc->procs.pickPointProcs              = __glGenericPickPointProcs;
    gc->procs.pickVertexProcs             = __glGenericPickVertexProcs;
    gc->procs.pickDepthProcs              = __glGenericPickDepthProcs;
    gc->procs.convertPolygonStipple       = __glConvertStipple;

    /* Now reset the context to its default state */

    RANDOMDISABLE;

    __glSoftResetContext(gc);
    // Check for allocation failures during SoftResetContext
    if (gengc->errorcode)
    {
        goto ERROR_EXIT;
    }

    /* Create acceleration-specific context information */

    if (!__glGenCreateAccelContext(gc))
    {
        goto ERROR_EXIT;
    }
    
    /*
    ** Now that we have a context, we can initialize
    ** all the proc pointers.
    */
    (*gc->procs.validate)(gc);

    /*
    ** NOTE: now that context is initialized reset to use the global
    ** table.
    */

    RANDOMREENABLE;

    // We won't be fully initialized until the first MakeCurrent
    // so set the signature to uninitialized
    gc->gcSig = 0;

    memset(&gengc->gwidCurrent, 0, sizeof(gengc->gwidCurrent));
    gengc->dwCurrentFlags = 0;

    /*
     *  End stuff that may belong in the hardware context
     */

    return (PVOID)gc;

 ERROR_EXIT:
    memset(&gengc->gwidCurrent, 0, sizeof(gengc->gwidCurrent));
    gengc->dwCurrentFlags = 0;
    glsrvDeleteContext(gc);
    return NULL;
}

/******************************Public*Routine******************************\
* UpdateSharedBuffer
*
* Make the context buffer state consistent with the shared buffer state.
* This is called separately for each of the shared buffers.
*
\**************************************************************************/

void UpdateSharedBuffer(__GLbuffer *to, __GLbuffer *from)
{
    to->width       = from->width;
    to->height      = from->height;
    to->base        = from->base;
    to->outerWidth  = from->outerWidth;
}

/******************************Public*Routine******************************\
* ResizeUnownedDepthBuffer
*
* Resizes a general-purpose hardware depth buffer.  Just updates structure.
*
* Returns:
*   TRUE always.
*
\**************************************************************************/

GLboolean ResizeUnownedDepthBuffer(__GLGENbuffers *buffers,
                                   __GLbuffer *fb, GLint w, GLint h)
{
    fb->width = w;
    fb->height = h;
    return TRUE;
}


/******************************Public*Routine******************************\
* ResizeHardwareBackBuffer
*
* Resizes a general-purpose hardware color buffer.  Just updates structure.
*
* Returns:
*   TRUE always.
*
\**************************************************************************/

GLboolean ResizeHardwareBackBuffer(__GLGENbuffers *buffers,
                                   __GLcolorBuffer *cfb, GLint w, GLint h)
{
    __GLGENbitmap *genBm = cfb->bitmap;
    __GLGENcontext *gengc = (__GLGENcontext *) cfb->buf.gc;

    // Fake up some of the __GLGENbitmap information.  The window is required
    // for clipping of the hardware back buffer.  The hdc is required to
    // retrieve drawing data from GDI.

    ASSERT_WINCRIT(gengc->pwndLocked);
    genBm->pwnd = gengc->pwndLocked;
    genBm->hdc = gengc->gwidCurrent.hdc;

    buffers->backBuffer.width = w;
    buffers->backBuffer.height = h;
    UpdateSharedBuffer(&cfb->buf, &buffers->backBuffer);
    return TRUE;
}

/******************************Public*Routine******************************\
* ResizeAncillaryBuffer
*
* Resizes the indicated shared buffer via a realloc (to preserve as much of
* the existing data as possible).
*
* This is currently used for each of ancillary shared buffers except for
* the back buffer.
*
* Returns:
*   TRUE if successful, FALSE if error.
*
\**************************************************************************/

GLboolean ResizeAncillaryBuffer(__GLGENbuffers *buffers, __GLbuffer *fb,
                                GLint w, GLint h)
{
    size_t newSize = (size_t) (w * h * fb->elementSize);
    __GLbuffer oldbuf, *ofb;
    GLboolean result;
    GLint i, imax, rowsize;
    void *to, *from;

    ofb = &oldbuf;
    oldbuf = *fb;

    if (newSize > 0)
    {
        fb->base = ALLOC(newSize);
    }
    else
    {
        // Buffer has no size.  If we tried to allocate zero the debug alloc
        // would complain, so skip directly to the underlying allocator
        fb->base = HeapAlloc(GetProcessHeap(), 0, 0);
    }
    ASSERTOPENGL((ULONG_PTR)fb->base % 4 == 0, "base not aligned");
    fb->size = newSize;
    fb->width = w;
    fb->height = h;
    fb->outerWidth = w; // element size
    if (fb->base) {
        result = GL_TRUE;
        if (ofb->base) {
            if (ofb->width > fb->width)
                rowsize = fb->width * fb->elementSize;
            else
                rowsize = ofb->width * fb->elementSize;

            if (ofb->height > fb->height)
                imax = fb->height;
            else
                imax = ofb->height;

            from = ofb->base;
            to = fb->base;
            for (i = 0; i < imax; i++) {
                __GL_MEMCOPY(to, from, rowsize);
                (ULONG_PTR)from += (ofb->width * ofb->elementSize);
                (ULONG_PTR)to += (fb->width * fb->elementSize);
            }
        }
    } else {
        result = GL_FALSE;
    }
    if (ofb->base)
    {
        FREE(ofb->base);
    }
    return result;
}

/******************************Private*Routine******************************\
* ResizeBitmapBuffer
*
* Used to resize the backbuffer that is implemented as a bitmap.  Cannot
* use same code as ResizeAncillaryBuffer() because each scanline must be
* dword aligned.  We also have to create engine objects for the bitmap.
*
* This code handles the case of a bitmap that has never been initialized.
*
* History:
*  18-Nov-1993 -by- Gilman Wong [gilmanw]
*  Wrote it.
\**************************************************************************/

void
ResizeBitmapBuffer(__GLGENbuffers *buffers, __GLcolorBuffer *cfb,
                   GLint w, GLint h)
{
    __GLGENcontext *gengc = (__GLGENcontext *) cfb->buf.gc;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENbitmap *genBm;
    UINT    cBytes;         // size of the bitmap in bytes
    LONG    cBytesPerScan;  // size of a scanline (DWORD aligned)
    SIZEL   size;           // dimensions of the bitmap
    PIXELFORMATDESCRIPTOR *pfmt = &gengc->gsurf.pfd;
    GLint cBitsPerScan;
#ifndef _CLIENTSIDE_
    void *newbits;
#endif

    DBGENTRY("Entering ResizeBitmapBuffer\n");

    genBm = cfb->bitmap;

    ASSERTOPENGL(
        &gc->backBuffer == cfb,
        "ResizeBitmapBuffer(): not back buffer!\n"
        );

    ASSERTOPENGL(
        genBm == &buffers->backBitmap,
        "ResizeBitmapBuffer(): bad __GLGENbitmap * in cfb\n"
        );

    // Compute the size of the bitmap.
    // The engine bitmap must have scanlines that are DWORD aligned.

    cBitsPerScan = BITS_ALIGNDWORD(w * pfmt->cColorBits);
    cBytesPerScan = cBitsPerScan / 8;
    cBytes = h * cBytesPerScan;

    // Setup size structure with dimensions of the bitmap.

    size.cx = cBitsPerScan / pfmt->cColorBits;
    size.cy = h;

#ifndef _CLIENTSIDE_
    // Malloc new buffer
    if ( (!cBytes) ||
         (NULL == (newbits = GCALLOC(gc, cBytes))) )
    {
        gengc->errorcode = GLGEN_OUT_OF_MEMORY;
        goto ERROR_EXIT_ResizeBitmapBuffer;
    }

    // If old buffer existed:
    if ( genBm->pvBits )
    {
        GLint i, imax, rowsize;
        void *to, *from;

        // Transfer old contents to new buffer
        rowsize = min(-cfb->buf.outerWidth, cBytesPerScan);
        imax    = min(cfb->buf.height, h);

        from = genBm->pvBits;
        to = newbits;

        for (i = 0; i < imax; i++)
        {
            __GL_MEMCOPY(to, from, rowsize);
            (GLint) from -= cfb->buf.outerWidth;
            (GLint) to += cBytesPerScan;
        }

        // Free old bitmap and delete old surface
        EngDeleteSurface((HSURF) genBm->hbm);
        GCFREE(gc, genBm->pvBits);
    }
    genBm->pvBits = newbits;

    // Create new surface
    if ( (genBm->hbm = EngCreateBitmap(size,
                                   cBytesPerScan,
                                   gengc->iFormatDC,
                                   0,
                                   genBm->pvBits))
         == (HBITMAP) 0 )
    {
        gengc->errorcode = GLGEN_GRE_FAILURE;
        GCFREE(gc, genBm->pvBits);
        genBm->pvBits = (PVOID) NULL;
        goto ERROR_EXIT_ResizeBitmapBuffer;
    }

#else
    // Zero sized bitmap.  The error case will set the dimensions to
    // zero, thereby preventing drawing operations.

    if ( !cBytes )
        goto ERROR_EXIT_ResizeBitmapBuffer;

    // Delete old back buffer.

    if ( genBm->hbm )
    {
        if (!DeleteDC(genBm->hdc))
            WARNING("ResizeBitmapBuffer: DeleteDC failed\n");
        genBm->hdc = (HDC) NULL;
        if (!DeleteObject(genBm->hbm))
            WARNING("ResizeBitmapBuffer: DeleteBitmap failed");
        genBm->hbm = (HBITMAP) NULL;
        genBm->pvBits = (PVOID) NULL;   // DIBsect deletion freed pvBits
    }

    if ( (genBm->hdc = CreateCompatibleDC(gengc->gwidCurrent.hdc)) == (HDC) 0 )
    {
        gengc->errorcode = GLGEN_GRE_FAILURE;
        genBm->pvBits = (PVOID) NULL;
        goto ERROR_EXIT_ResizeBitmapBuffer;
    }

    // Create new surface
    if ( (genBm->hbm = wglCreateBitmap(gengc, size, &genBm->pvBits))
         == (HBITMAP) 0 )
    {
        gengc->errorcode = GLGEN_GRE_FAILURE;
        genBm->pvBits = (PVOID) NULL;   // DIBsect deletion freed pvBits
        DeleteDC(genBm->hdc);
        genBm->hdc = (HDC) NULL;
        goto ERROR_EXIT_ResizeBitmapBuffer;
    }

    if ( !SelectObject(genBm->hdc, genBm->hbm) )
    {
        gengc->errorcode = GLGEN_GRE_FAILURE;
        DeleteDC(genBm->hdc);
        genBm->hdc = (HDC) NULL;
        DeleteObject(genBm->hbm);
        genBm->hbm = (HBITMAP) NULL;
        genBm->pvBits = (PVOID) NULL;   // DIBsect deletion freed pvBits
        goto ERROR_EXIT_ResizeBitmapBuffer;
    }
#endif

    // Update buffer data structure
    // Setup the buffer to point to the DIB.  A DIB is "upside down"
    // from our perspective, so we will set buf.base to point to the
    // last scan of the buffer and set buf.outerWidth to be negative
    // (causing us to move "up" through the DIB with increasing y).

    buffers->backBuffer.outerWidth = -(cBytesPerScan);
    buffers->backBuffer.base =
            (PVOID) (((BYTE *)genBm->pvBits) + (cBytesPerScan * (h - 1)));


    buffers->backBuffer.xOrigin = 0;
    buffers->backBuffer.yOrigin = 0;
    buffers->backBuffer.width = w;
    buffers->backBuffer.height = h;
    buffers->backBuffer.size = cBytes;

    UpdateSharedBuffer(&cfb->buf, &buffers->backBuffer);

    // Update the dummy window for the back buffer
    ASSERTOPENGL(genBm->wnd.clipComplexity == DC_TRIVIAL,
                 "Back buffer complexity non-trivial\n");
    genBm->wnd.rclBounds.right  = w;
    genBm->wnd.rclBounds.bottom = h;
    genBm->wnd.rclClient = genBm->wnd.rclBounds;

    return;

ERROR_EXIT_ResizeBitmapBuffer:

// If we get to here, memory allocation or bitmap creation failed.

    #if DBG
    switch (gengc->errorcode)
    {
        case 0:
            break;

        case GLGEN_GRE_FAILURE:
            WARNING("ResizeBitmapBuffer(): object creation failed\n");
            break;

        case GLGEN_OUT_OF_MEMORY:
            if ( w && h )
                WARNING("ResizeBitmapBuffer(): mem alloc failed\n");
            break;

        default:
            WARNING1("ResizeBitmapBuffer(): errorcode = 0x%lx\n", gengc->errorcode);
            break;
    }
    #endif

// If we've blown away the bitmap, we need to set the back buffer info
// to a consistent state.

    if (!genBm->pvBits)
    {
        buffers->backBuffer.width  = 0;
        buffers->backBuffer.height = 0;
        buffers->backBuffer.base   = (PVOID) NULL;
    }

    cfb->buf.width      = 0;    // error state: empty buffer
    cfb->buf.height     = 0;
    cfb->buf.outerWidth = 0;

}

/* Lazy allocation of ancillary buffers */
void FASTCALL LazyAllocateDepth(__GLcontext *gc)
{
    GLint w = gc->constants.width;
    GLint h = gc->constants.height;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    __GLGENbuffers *buffers;
    GLint depthIndex = gc->state.depth.testFunc;

    ASSERTOPENGL(gc->modes.depthBits, "LazyAllocateDepth: zero depthBits\n");

    buffers = gengc->pwndLocked->buffers;
    buffers->createdDepthBuffer = GL_TRUE;

    // If we're using the DDI, we've already allocated depth buffers
    // on the device, so at this point we may simply assume that
    // our depth buffer is available.

#ifdef _MCD_
    // If we're using MCD, we allocated the depth buffer when we created
    // the MCD context.

    if ((gengc->pMcdState) && (gengc->pMcdState->pDepthSpan))
    {
        gc->modes.haveDepthBuffer = GL_TRUE;
        return;
    }
#endif

    // Depth buffer should never be touched because
    // no output should be generated
    if (gengc->dwCurrentFlags & GLSURF_METAFILE)
    {
        gc->modes.haveDepthBuffer = GL_TRUE;
        return;
    }

    if (buffers->depthBuffer.base) {
        /* buffer already allocated by another RC */
        UpdateSharedBuffer(&gc->depthBuffer.buf, &buffers->depthBuffer);
    } else {

        DBGLEVEL(LEVEL_ALLOC, "Depth buffer must be allocated\n");
        (*buffers->resize)(buffers, &buffers->depthBuffer, w, h);
        UpdateSharedBuffer(&gc->depthBuffer.buf, &buffers->depthBuffer);
    }

    if (gc->depthBuffer.buf.base) {
        gc->modes.haveDepthBuffer = GL_TRUE;
    } else {
        gc->modes.haveDepthBuffer = GL_FALSE;
        __glSetError(GL_OUT_OF_MEMORY);
    }
    __GL_DELAY_VALIDATE_MASK(gc, __GL_DIRTY_DEPTH);

    // Note similar code in so_pick.c
    // Don't need to handle (depthBits == 0) case because LazyAllocateDepth
    // is not called unless depthBits is non-zero.
    depthIndex -= GL_NEVER;
    if( gc->state.depth.writeEnable == GL_FALSE ) {
        depthIndex += 8;
    }
    if( gc->depthBuffer.buf.elementSize == 2 )
        depthIndex += 16;
    (*gc->depthBuffer.pick)(gc, &gc->depthBuffer, depthIndex);
}

void FASTCALL LazyAllocateStencil(__GLcontext *gc)
{
    GLint w = gc->constants.width;
    GLint h = gc->constants.height;
    __GLGENbuffers *buffers;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;

    ASSERTOPENGL(gc->modes.stencilBits, "LazyAllocateStencil: zero stencilBits\n");

    buffers = gengc->pwndLocked->buffers;
    buffers->createdStencilBuffer = GL_TRUE;

    // Depth buffer should never be touched because
    // no output should be generated
    if (gengc->dwCurrentFlags & GLSURF_METAFILE)
    {
        gc->modes.haveStencilBuffer = GL_TRUE;
        return;
    }

    if (buffers->stencilBuffer.base) {
        /* buffer already allocated by another RC */
        UpdateSharedBuffer(&gc->stencilBuffer.buf, &buffers->stencilBuffer);
    } else {

        DBGLEVEL(LEVEL_ALLOC, "stencil buffer must be allocated\n");
        (*buffers->resize)(buffers, &buffers->stencilBuffer, w, h);
        UpdateSharedBuffer(&gc->stencilBuffer.buf, &buffers->stencilBuffer);
    }

    if (gc->stencilBuffer.buf.base) {
        gc->modes.haveStencilBuffer = GL_TRUE;
    } else {
        gc->modes.haveStencilBuffer = GL_FALSE;
        __glSetError(GL_OUT_OF_MEMORY);
    }
    __GL_DELAY_VALIDATE(gc);
    gc->validateMask |= (__GL_VALIDATE_STENCIL_FUNC | __GL_VALIDATE_STENCIL_OP);
    (*gc->stencilBuffer.pick)(gc, &gc->stencilBuffer);
}


void FASTCALL LazyAllocateAccum(__GLcontext *gc)
{
    GLint w = gc->constants.width;
    GLint h = gc->constants.height;
    __GLGENbuffers *buffers;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;

    ASSERTOPENGL(gc->modes.accumBits, "LazyAllocateAccum: zero accumBits\n");

    buffers = gengc->pwndLocked->buffers;
    buffers->createdAccumBuffer = GL_TRUE;

    // Depth buffer should never be touched because
    // no output should be generated
    if (gengc->dwCurrentFlags & GLSURF_METAFILE)
    {
        gc->modes.haveAccumBuffer = GL_TRUE;
        return;
    }

    if (buffers->accumBuffer.base) {
        /* buffer already allocated by another RC */
        UpdateSharedBuffer(&gc->accumBuffer.buf, &buffers->accumBuffer);
    } else {

        DBGLEVEL(LEVEL_ALLOC, "Accum buffer must be allocated\n");
        (*buffers->resize)(buffers, &buffers->accumBuffer, w, h);
        UpdateSharedBuffer(&gc->accumBuffer.buf, &buffers->accumBuffer);
    }

    if (gc->accumBuffer.buf.base) {
        gc->modes.haveAccumBuffer = GL_TRUE;
    } else {
        gc->modes.haveAccumBuffer = GL_FALSE;
        __glSetError(GL_OUT_OF_MEMORY);
    }
    __GL_DELAY_VALIDATE(gc);
    (*gc->accumBuffer.pick)(gc, &gc->accumBuffer);
}

/******************************Public*Routine******************************\
* glGenInitCommon
*
* Called from __glGenInitRGB and __glGenInitCI to handle the shared
* initialization chores.
*
\**************************************************************************/

void FASTCALL glGenInitCommon(__GLGENcontext *gengc, __GLcolorBuffer *cfb, GLenum type)
{
    __GLbuffer *bp;

    bp = &cfb->buf;

// If front buffer, we need to setup the buffer if we think its DIB format.

    if (type == GL_FRONT)
    {
#ifdef _MCD_
        if (gengc->_pMcdState)
        {
        // Assume that MCD surface is not accessible.  Accessibility
        // must be determined on a per-batch basis by calling
        // GenMcdUpdateBufferInfo.

            bp->flags &= ~(DIB_FORMAT | MEMORY_DC | NO_CLIP);
        }
#endif
        {
            if (gengc->dwCurrentFlags & GLSURF_DIRECT_ACCESS)
            {
                // These fields will be updated at attention time
                bp->base = NULL;
                bp->outerWidth = 0;
                cfb->buf.flags = DIB_FORMAT;
            }

            if (GLSURF_IS_MEMDC(gengc->dwCurrentFlags))
            {
                bp->flags = bp->flags | (MEMORY_DC | NO_CLIP);
            }
            else if (gengc->gsurf.dwFlags & GLSURF_DIRECTDRAW)
            {
                LPDIRECTDRAWCLIPPER pddc;
                HRESULT hr;
                
                hr = gengc->gsurf.dd.gddsFront.pdds->lpVtbl->
                    GetClipper(gengc->gsurf.dd.gddsFront.pdds, &pddc);
                if (hr == DDERR_NOCLIPPERATTACHED)
                {
                    bp->flags = bp->flags | NO_CLIP;
                }
            }
        }
    }

// If back buffer, we assume its a DIB, or a hardware backbuffer.
// In the case of a DIB, the bitmap memory will be allocated via
// ResizeBitmapBuffer().

    else
    {
#ifdef _MCD_
        if (gengc->_pMcdState)
        {
        // Assume that MCD surface is not accessible.  Accessibility
        // must be determined on a per-batch basis by calling
        // GenMcdUpdateBufferInfo.

            cfb->resize = ResizeHardwareBackBuffer;
            bp->flags &= ~(DIB_FORMAT | MEMORY_DC | NO_CLIP);
        }
        else
#endif
        {
            cfb->resize = ResizeBitmapBuffer;
            bp->flags = DIB_FORMAT | MEMORY_DC | NO_CLIP;
        }
    }
}


/******************************Public*Routine******************************\
* glsrvCleanupWindow
*
* Called from wglCleanupWindow to remove the pwnd reference from the
* context.
*
* History:
*  05-Jul-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID APIENTRY glsrvCleanupWindow(__GLcontext *gc, GLGENwindow *pwnd)
{
    __GLGENcontext *gengc = (__GLGENcontext *) gc;

// The window in gengc should be consistent with the one in the rc object.
// wglCleanupWindow should have already checked to see if the pwnd in the
// rc is one we need to remove, so we can just assert here.

    ASSERTOPENGL(gengc->pwndMakeCur == pwnd,
                 "glsrvCleanupWindow(): bad pwnd\n");

    gengc->pwndLocked = NULL;
    gengc->pwndMakeCur = NULL;
}


/*
** Fetch the data for a query in its internal type, then convert it to the
** type that the user asked for.
**
** This only handles the NT generic driver specific values (so far just the
** GL_ACCUM_*_BITS values).  All others fall back to the soft code function,
** __glDoGet().
*/

// These types are stolen from ..\soft\so_get.c.  To minimize changes to
// the soft code, we will pull them into here rather than moving them to
// a header file and changing so_get.c to use the header file.

#define __GL_FLOAT      0       /* __GLfloat */
#define __GL_FLOAT32    1       /* api 32 bit float */
#define __GL_FLOAT64    2       /* api 64 bit float */
#define __GL_INT32      3       /* api 32 bit int */
#define __GL_BOOLEAN    4       /* api 8 bit boolean */
#define __GL_COLOR      5       /* unscaled color in __GLfloat */
#define __GL_SCOLOR     6       /* scaled color in __GLfloat */

extern void __glDoGet(GLenum, void *, GLint, const char *);
extern void __glConvertResult(__GLcontext *, GLint, const void *, GLint,
                              void *, GLint);

void FASTCALL __glGenDoGet(GLenum sq, void *result, GLint type, const char *procName)
{
    GLint iVal;
    __GLGENcontext *gengc;
    __GL_SETUP_NOT_IN_BEGIN();

    gengc = (__GLGENcontext *) gc;

    switch (sq) {
      case GL_ACCUM_RED_BITS:
        iVal = gengc->gsurf.pfd.cAccumRedBits;
        break;
      case GL_ACCUM_GREEN_BITS:
        iVal = gengc->gsurf.pfd.cAccumGreenBits;
        break;
      case GL_ACCUM_BLUE_BITS:
        iVal = gengc->gsurf.pfd.cAccumBlueBits;
        break;
      case GL_ACCUM_ALPHA_BITS:
        iVal = gengc->gsurf.pfd.cAccumAlphaBits;
        break;
      default:
        __glDoGet(sq, result, type, procName);
        return;
    }

    __glConvertResult(gc, __GL_INT32, &iVal, type, result, 1);
}

/******************************Public*Routine******************************\
*
* glsrvCopyContext
*
* Copies state from one context to another
*
* History:
*  Mon Jun 05 16:53:42 1995     -by-    Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL APIENTRY glsrvCopyContext(__GLcontext *gcSource, __GLcontext *gcDest,
                               GLuint mask)
{
    return (BOOL)__glCopyContext(gcDest, gcSource, mask);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\genline.h ===
/*
** Macros and externs used by genline.c
*/

extern ULONG FASTCALL __fastLineComputeColorRGB4(__GLcontext *gc, __GLcolor *color);
extern ULONG FASTCALL __fastLineComputeColorRGB8(__GLcontext *gc, __GLcolor *color);
extern ULONG FASTCALL __fastLineComputeColorRGB(__GLcontext *gc, __GLcolor *color);
extern ULONG FASTCALL __fastLineComputeColorCI4and8(__GLcontext *gc, __GLcolor *color);
extern ULONG FASTCALL __fastLineComputeColorCI(__GLcontext *gc, __GLcolor *color);

extern void FASTCALL __fastGenLineBegin(__GLcontext *gc);
extern void FASTCALL __fastGenLineEnd(__GLcontext *gc);
extern void FASTCALL __fastGenLine(__GLcontext *gc, __GLvertex *v0,
                                   __GLvertex *v1, GLuint flags);
extern void FASTCALL __fastGenLineWide(__GLcontext *gc, __GLvertex *v0,
                                       __GLvertex *v1, GLuint flags);

BOOL FASTCALL __fastGenLineSetupDisplay(__GLcontext *gc);
void FASTCALL __glQueryLineAcceleration(__GLcontext *gc);

BOOL FASTCALL __glGenSetupEitherLines(__GLcontext *gc);

/*
** float-to-fix macro converts floats to 28.4
*/
#define __FAST_LINE_FLTTOFIX(x) ((long)((x) * 16.0f))

// Converts a floating-point coordinate to an appropriate device coordinate
#ifdef _CLIENTSIDE_
#define __FAST_LINE_FLTTODEV(x) ((long)(x))
#define __FAST_LINE_UNIT_VALUE  1
#else
#define __FAST_LINE_FLTTODEV(x) __FAST_LINE_FLTTOFIX(x)
#define __FAST_LINE_UNIT_VALUE  16
#endif
    
/*
** line-stroking macros for DIB surfaces
*/

#ifdef NT_NO_BUFFER_INVARIANCE

BOOL FASTCALL __fastGenLineSetupDIB(__GLcontext *gc);

/*
** __FAST_LINE_STROKE_DIB
**
** Strokes a thin solid line into a DIB surface.  Performs scissoring.
** Works for 8, 16, and 32 BPP
**
*/
#define __FAST_LINE_STROKE_DIB                                          \
{                                                                       \
    len = gc->line.options.numPixels;                                   \
    fraction = gc->line.options.fraction;                               \
    dfraction = gc->line.options.dfraction;                             \
                                                                        \
    if (!gc->transform.reasonableViewport) {                            \
        GLint clipX0, clipX1, clipY0, clipY1;                           \
        GLint xStart, yStart, xEnd, yEnd;                               \
        GLint xLittle, yLittle, xBig, yBig;                             \
        GLint highWord, lowWord, bigs, littles;                         \
                                                                        \
        clipX0 = gc->transform.clipX0;                                  \
        clipX1 = gc->transform.clipX1;                                  \
        clipY0 = gc->transform.clipY0;                                  \
        clipY1 = gc->transform.clipY1;                                  \
                                                                        \
        xBig = gc->line.options.xBig;                                   \
        yBig = gc->line.options.yBig;                                   \
                                                                        \
        xStart = gc->line.options.xStart;                               \
        yStart = gc->line.options.yStart;                               \
                                                                        \
        /* If the start point is in the scissor region, we attempt to   \
        ** trivially accept the line.                                   \
        */                                                              \
        if (xStart >= clipX0 && xStart < clipX1 &&                      \
	    yStart >= clipY0 && yStart < clipY1) {                      \
                                                                        \
	    len--;	/* Makes our math simpler */                    \
	    /* Trivial accept attempt */                                \
	    xEnd = xStart + xBig * len;                                 \
	    yEnd = yStart + yBig * len;                                 \
	    if (xEnd >= clipX0 && xEnd < clipX1 &&                      \
		yEnd >= clipY0 && yEnd < clipY1) {                      \
		len++;                                                  \
	        goto no_scissor;                                        \
	    }                                                           \
                                                                        \
	    xLittle = gc->line.options.xLittle;                         \
	    yLittle = gc->line.options.yLittle;                         \
                                                                        \
	    /*                                                          \
            ** Invert negative minor slopes so we can assume            \
            ** dfraction > 0                                            \
            */                                                          \
	    if (dfraction < 0) {                                        \
	        dfraction = -dfraction;                                 \
	        fraction = 0x7fffffff - fraction;                       \
	    }                                                           \
                                                                        \
	    /* Now we compute number of littles and bigs in this line */\
                                                                        \
	    /* We perform a 16 by 32 bit multiply.  Ugh. */             \
	    highWord = (((GLuint) dfraction) >> 16) * len +             \
		       (((GLuint) fraction) >> 16);                     \
	    lowWord = (dfraction & 0xffff) * len + (fraction & 0xffff); \
	    highWord += (((GLuint) lowWord) >> 16);                     \
	    bigs = ((GLuint) highWord) >> 15;                           \
	    littles = len - bigs;                                       \
                                                                        \
	    /* Second trivial accept attempt */                         \
	    xEnd = xStart + xBig*bigs + xLittle*littles;                \
	    yEnd = yStart + yBig*bigs + yLittle*littles;                \
	    if (xEnd >= clipX0 && xEnd < clipX1 &&                      \
		yEnd >= clipY0 && yEnd < clipY1) {                      \
		len++;                                                  \
	        goto no_scissor;                                        \
	    }                                                           \
            len++;	/* Restore len */                               \
        } else {                                                        \
	    xLittle = gc->line.options.xLittle;                         \
	    yLittle = gc->line.options.yLittle;                         \
        }                                                               \
                                                                        \
        /*                                                              \
        ** The line needs to be scissored.                              \
        ** Well, it should only happen rarely, so we can afford         \
        ** to make it slow.  We achieve this by tediously stippling the \
        ** line.  (rather than clipping it, of course, which would be   \
        ** faster but harder).                                          \
        */                                                              \
                                                                        \
        if (!((GLuint)cfb->buf.other & NO_CLIP)) {                      \
            RECTL rcl;                                                  \
                                                                        \
            xEnd = x + xBig * (len - 1);                                \
            yEnd = y + yBig * (len - 1);                                \
                                                                        \
            if (x < xEnd) {                                             \
                rcl.left  = x;                                          \
                rcl.right = xEnd + 1;                                   \
            } else {                                                    \
                rcl.left  = xEnd;                                       \
                rcl.right = x + 1;                                      \
            }                                                           \
            if (y < yEnd) {                                             \
                rcl.top    = y;                                         \
                rcl.bottom = yEnd + 1;                                  \
            } else {                                                    \
                rcl.top    = yEnd;                                      \
                rcl.bottom = y + 1;                                     \
            }                                                           \
            switch (wglRectVisible(&rcl)) {                             \
              case WGL_RECT_ALL:                                        \
                goto scissor_no_complex;                                \
                break;                                                  \
              case WGL_RECT_NONE:                                       \
                goto no_draw;                                           \
                break;                                                  \
            }                                                           \
                                                                        \
            /* Line is partially visible, check each pixel */           \
                                                                        \
            while (--len >= 0) {                                        \
	        if (wglPixelVisible(x, y) &&                            \
                    xStart >= clipX0 && xStart < clipX1 &&              \
		    yStart >= clipY0 && yStart < clipY1) {              \
		    *addr = pixel;                                      \
	        }                                                       \
	        fraction += dfraction;                                  \
	        if (fraction < 0) {                                     \
		    fraction &= ~0x80000000;                            \
		    x      += xBig;                                     \
		    y      += yBig;                                     \
		    xStart += xBig;                                     \
		    yStart += yBig;                                     \
		    addr   += addrBig;                                  \
	        } else {                                                \
		    x      += xLittle;                                  \
		    y      += yLittle;                                  \
		    xStart += xLittle;                                  \
		    yStart += yLittle;                                  \
		    addr   += addrLittle;                               \
	        }                                                       \
	    }                                                           \
        } else {                                                        \
scissor_no_complex:                                                     \
            while (--len >= 0) {                                        \
	        if (xStart >= clipX0 && xStart < clipX1 &&              \
		    yStart >= clipY0 && yStart < clipY1) {              \
		    *addr = pixel;                                      \
	        }                                                       \
	        fraction += dfraction;                                  \
	        if (fraction < 0) {                                     \
		    fraction &= ~0x80000000;                            \
		    xStart += xBig;                                     \
		    yStart += yBig;                                     \
		    addr   += addrBig;                                  \
	        } else {                                                \
		    xStart += xLittle;                                  \
		    yStart += yLittle;                                  \
		    addr   += addrLittle;                               \
	        }                                                       \
	    }                                                           \
	}                                                               \
    } else {                                                            \
no_scissor:                                                             \
        if (!((GLuint)cfb->buf.other & NO_CLIP)) {                    \
            RECTL rcl;                                                  \
            GLint xEnd, yEnd, xBig, yBig, xLittle, yLittle;             \
                                                                        \
            xBig    = gc->line.options.xBig;                            \
            yBig    = gc->line.options.yBig;                            \
            xLittle = gc->line.options.xLittle;                         \
            yLittle = gc->line.options.yLittle;                         \
                                                                        \
            xEnd = x + xBig * (len - 1);                                \
            yEnd = y + yBig * (len - 1);                                \
                                                                        \
            if (x < xEnd) {                                             \
                rcl.left  = x;                                          \
                rcl.right = xEnd + 1;                                   \
            } else {                                                    \
                rcl.left  = xEnd;                                       \
                rcl.right = x + 1;                                      \
            }                                                           \
            if (y < yEnd) {                                             \
                rcl.top    = y;                                         \
                rcl.bottom = yEnd + 1;                                  \
            } else {                                                    \
                rcl.top    = yEnd;                                      \
                rcl.bottom = y + 1;                                     \
            }                                                           \
            switch (wglRectVisible(&rcl)) {                             \
              case WGL_RECT_ALL:                                        \
                goto no_complex;                                        \
                break;                                                  \
              case WGL_RECT_NONE:                                       \
                goto no_draw;                                           \
                break;                                                  \
            }                                                           \
                                                                        \
            /* Line is partially visible, check each pixel */           \
                                                                        \
            while (--len >= 0) {                                        \
                if (wglPixelVisible(x, y))                              \
                    *addr = pixel;                                      \
                                                                        \
    	        fraction += dfraction;                                  \
	        if (fraction < 0) {                                     \
	            fraction &= ~0x80000000;                            \
	            x    += xBig;                                       \
	            y    += yBig;                                       \
	            addr += addrBig;                                    \
	        } else {                                                \
	            x    += xLittle;                                    \
	            y    += yLittle;                                    \
	            addr += addrLittle;                                 \
	        }                                                       \
            }                                                           \
        } else {                                                        \
no_complex:                                                             \
            while (--len >= 0) {                                        \
                *addr = pixel;                                          \
                                                                        \
    	        fraction += dfraction;                                  \
	        if (fraction < 0) {                                     \
	            fraction &= ~0x80000000;                            \
	            addr += addrBig;                                    \
	        } else {                                                \
	            addr += addrLittle;                                 \
	        }                                                       \
            }                                                           \
        }                                                               \
    }                                                                   \
no_draw:;                                                               \
}


/*
** __FAST_LINE_STROKE_DIB24
**
** Strokes a thin solid line into a DIB surface.  Performs scissoring.
** Works for 24 BPP
**
*/
#define __FAST_LINE_STROKE_DIB24                                        \
{                                                                       \
    len = gc->line.options.numPixels;                                   \
    fraction = gc->line.options.fraction;                               \
    dfraction = gc->line.options.dfraction;                             \
                                                                        \
    if (!gc->transform.reasonableViewport) {                            \
        GLint clipX0, clipX1, clipY0, clipY1;                           \
        GLint xStart, yStart, xEnd, yEnd;                               \
        GLint xLittle, yLittle, xBig, yBig;                             \
        GLint highWord, lowWord, bigs, littles;                         \
                                                                        \
        clipX0 = gc->transform.clipX0;                                  \
        clipX1 = gc->transform.clipX1;                                  \
        clipY0 = gc->transform.clipY0;                                  \
        clipY1 = gc->transform.clipY1;                                  \
                                                                        \
        xBig = gc->line.options.xBig;                                   \
        yBig = gc->line.options.yBig;                                   \
                                                                        \
        xStart = gc->line.options.xStart;                               \
        yStart = gc->line.options.yStart;                               \
                                                                        \
        /* If the start point is in the scissor region, we attempt to   \
        ** trivially accept the line.                                   \
        */                                                              \
        if (xStart >= clipX0 && xStart < clipX1 &&                      \
	    yStart >= clipY0 && yStart < clipY1) {                      \
                                                                        \
	    len--;	/* Makes our math simpler */                    \
	    /* Trivial accept attempt */                                \
	    xEnd = xStart + xBig * len;                                 \
	    yEnd = yStart + yBig * len;                                 \
	    if (xEnd >= clipX0 && xEnd < clipX1 &&                      \
		yEnd >= clipY0 && yEnd < clipY1) {                      \
		len++;                                                  \
	        goto no_scissor;                                        \
	    }                                                           \
                                                                        \
	    xLittle = gc->line.options.xLittle;                         \
	    yLittle = gc->line.options.yLittle;                         \
                                                                        \
	    /*                                                          \
            ** Invert negative minor slopes so we can assume            \
            ** dfraction > 0                                            \
            */                                                          \
	    if (dfraction < 0) {                                        \
	        dfraction = -dfraction;                                 \
	        fraction = 0x7fffffff - fraction;                       \
	    }                                                           \
                                                                        \
	    /* Now we compute number of littles and bigs in this line */\
                                                                        \
	    /* We perform a 16 by 32 bit multiply.  Ugh. */             \
	    highWord = (((GLuint) dfraction) >> 16) * len +             \
		       (((GLuint) fraction) >> 16);                     \
	    lowWord = (dfraction & 0xffff) * len + (fraction & 0xffff); \
	    highWord += (((GLuint) lowWord) >> 16);                     \
	    bigs = ((GLuint) highWord) >> 15;                           \
	    littles = len - bigs;                                       \
                                                                        \
	    /* Second trivial accept attempt */                         \
	    xEnd = xStart + xBig*bigs + xLittle*littles;                \
	    yEnd = yStart + yBig*bigs + yLittle*littles;                \
	    if (xEnd >= clipX0 && xEnd < clipX1 &&                      \
		yEnd >= clipY0 && yEnd < clipY1) {                      \
		len++;                                                  \
	        goto no_scissor;                                        \
	    }                                                           \
            len++;	/* Restore len */                               \
        } else {                                                        \
	    xLittle = gc->line.options.xLittle;                         \
	    yLittle = gc->line.options.yLittle;                         \
        }                                                               \
                                                                        \
        /*                                                              \
        ** The line needs to be scissored.                              \
        ** Well, it should only happen rarely, so we can afford         \
        ** to make it slow.  We achieve this by tediously stippling the \
        ** line.  (rather than clipping it, of course, which would be   \
        ** faster but harder).                                          \
        */                                                              \
                                                                        \
        if (!((GLuint)cfb->buf.other & NO_CLIP)) {                    \
            RECTL rcl;                                                  \
                                                                        \
            xEnd = x + xBig * (len - 1);                                \
            yEnd = y + yBig * (len - 1);                                \
                                                                        \
            if (x < xEnd) {                                             \
                rcl.left  = x;                                          \
                rcl.right = xEnd + 1;                                   \
            } else {                                                    \
                rcl.left  = xEnd;                                       \
                rcl.right = x + 1;                                      \
            }                                                           \
            if (y < yEnd) {                                             \
                rcl.top    = y;                                         \
                rcl.bottom = yEnd + 1;                                  \
            } else {                                                    \
                rcl.top    = yEnd;                                      \
                rcl.bottom = y + 1;                                     \
            }                                                           \
            switch (wglRectVisible(&rcl)) {                             \
              case WGL_RECT_ALL:                                        \
                goto scissor_no_complex;                                \
                break;                                                  \
              case WGL_RECT_NONE:                                       \
                goto no_draw;                                           \
                break;                                                  \
            }                                                           \
                                                                        \
            /* Line is partially visible, check each pixel */           \
                                                                        \
            while (--len >= 0) {                                        \
	        if (wglPixelVisible(x, y) &&                            \
                    xStart >= clipX0 && xStart < clipX1 &&              \
		    yStart >= clipY0 && yStart < clipY1) {              \
		    addr[0] = ir;                                       \
		    addr[1] = ig;                                       \
		    addr[2] = ib;                                       \
	        }                                                       \
	        fraction += dfraction;                                  \
	        if (fraction < 0) {                                     \
		    fraction &= ~0x80000000;                            \
		    x      += xBig;                                     \
		    y      += yBig;                                     \
		    xStart += xBig;                                     \
		    yStart += yBig;                                     \
		    addr   += addrBig;                                  \
	        } else {                                                \
		    x      += xLittle;                                  \
		    y      += yLittle;                                  \
		    xStart += xLittle;                                  \
		    yStart += yLittle;                                  \
		    addr   += addrLittle;                               \
	        }                                                       \
	    }                                                           \
        } else {                                                        \
scissor_no_complex:                                                     \
            while (--len >= 0) {                                        \
	        if (xStart >= clipX0 && xStart < clipX1 &&              \
		    yStart >= clipY0 && yStart < clipY1) {              \
		    addr[0] = ir;                                       \
		    addr[1] = ig;                                       \
		    addr[2] = ib;                                       \
	        }                                                       \
	        fraction += dfraction;                                  \
	        if (fraction < 0) {                                     \
		    fraction &= ~0x80000000;                            \
		    xStart += xBig;                                     \
		    yStart += yBig;                                     \
		    addr   += addrBig;                                  \
	        } else {                                                \
		    xStart += xLittle;                                  \
		    yStart += yLittle;                                  \
		    addr   += addrLittle;                               \
	        }                                                       \
	    }                                                           \
        }                                                               \
    } else {                                                            \
no_scissor:                                                             \
        if (!((GLuint)cfb->buf.other & NO_CLIP)) {                    \
            RECTL rcl;                                                  \
            GLint xEnd, yEnd, xBig, yBig, xLittle, yLittle;             \
                                                                        \
            xBig    = gc->line.options.xBig;                            \
            yBig    = gc->line.options.yBig;                            \
            xLittle = gc->line.options.xLittle;                         \
            yLittle = gc->line.options.yLittle;                         \
                                                                        \
            xEnd = x + xBig * (len - 1);                                \
            yEnd = y + yBig * (len - 1);                                \
                                                                        \
            if (x < xEnd) {                                             \
                rcl.left  = x;                                          \
                rcl.right = xEnd + 1;                                   \
            } else {                                                    \
                rcl.left  = xEnd;                                       \
                rcl.right = x + 1;                                      \
            }                                                           \
            if (y < yEnd) {                                             \
                rcl.top    = y;                                         \
                rcl.bottom = yEnd + 1;                                  \
            } else {                                                    \
                rcl.top    = yEnd;                                      \
                rcl.bottom = y + 1;                                     \
            }                                                           \
            switch (wglRectVisible(&rcl)) {                             \
              case WGL_RECT_ALL:                                        \
                goto no_complex;                                        \
                break;                                                  \
              case WGL_RECT_NONE:                                       \
                goto no_draw;                                           \
                break;                                                  \
            }                                                           \
                                                                        \
            /* Line is partially visible, check each pixel */           \
                                                                        \
            while (--len >= 0) {                                        \
                if (wglPixelVisible(x, y)) {                            \
                    addr[0] = ir;                                       \
                    addr[1] = ig;                                       \
                    addr[2] = ib;                                       \
                }                                                       \
    	        fraction += dfraction;                                  \
	        if (fraction < 0) {                                     \
	            fraction &= ~0x80000000;                            \
	            addr += addrBig;                                    \
	        } else {                                                \
	            addr += addrLittle;                                 \
	        }                                                       \
            }                                                           \
	} else {                                                        \
no_complex:                                                             \
            while (--len >= 0) {                                        \
                addr[0] = ir;                                           \
                addr[1] = ig;                                           \
                addr[2] = ib;                                           \
    	        fraction += dfraction;                                  \
	        if (fraction < 0) {                                     \
	            fraction &= ~0x80000000;                            \
	            addr += addrBig;                                    \
	        } else {                                                \
	            addr += addrLittle;                                 \
	        }                                                       \
            }                                                           \
        }                                                               \
    }                                                                   \
no_draw:;                                                               \
}


/*
** __FAST_LINE_STROKE_DIB_WIDE
**
** Strokes a wide solid line into a DIB surface.  Performs scissoring.
** Works for 8, 16, and 32 BPP
**
*/
#define __FAST_LINE_STROKE_DIB_WIDE                                     \
{                                                                       \
    len = gc->line.options.numPixels;                                   \
    fraction = gc->line.options.fraction;                               \
    dfraction = gc->line.options.dfraction;                             \
                                                                        \
    /*                                                                  \
    ** Since one or more of the strokes of a wide line may lie outside  \
    ** the viewport, wide lines always go through the scissoring checks \
    */                                                                  \
    {                                                                   \
        GLint clipX0, clipX1, clipY0, clipY1;                           \
        GLint xStart, yStart, xEnd, yEnd;                               \
        GLint xLittle, yLittle, xBig, yBig;                             \
        GLint highWord, lowWord, bigs, littles;                         \
                                                                        \
        clipX0 = gc->transform.clipX0;                                  \
        clipX1 = gc->transform.clipX1;                                  \
        clipY0 = gc->transform.clipY0;                                  \
        clipY1 = gc->transform.clipY1;                                  \
                                                                        \
        xBig = gc->line.options.xBig;                                   \
        yBig = gc->line.options.yBig;                                   \
                                                                        \
        xStart = gc->line.options.xStart;                               \
        yStart = gc->line.options.yStart;                               \
                                                                        \
        /* If the start point is in the scissor region, we attempt to   \
        ** trivially accept the line.                                   \
        */                                                              \
        if (xStart >= clipX0 && xStart < clipX1 &&                      \
	    yStart >= clipY0 && yStart < clipY1) {                      \
                                                                        \
	    len--;	/* Makes our math simpler */                    \
	    width--;                                                    \
	    /* Trivial accept attempt */                                \
	    xEnd = xStart + xBig * len;                                 \
	    yEnd = yStart + yBig * len;                                 \
	    if (xEnd >= clipX0 && xEnd < clipX1 &&                      \
		yEnd >= clipY0 && yEnd < clipY1) {                      \
		                                                        \
                if (gc->line.options.axis == __GL_X_MAJOR) {            \
                    if (((yStart + width) >= clipY0) &&                 \
                        ((yStart + width) <  clipY1) &&                 \
                        ((yEnd + width)   >= clipY0) &&                 \
                        ((yEnd + width)   <  clipY1)) {                 \
                                                                        \
		        len++;                                          \
		        width++;                                        \
	                goto no_scissor;                                \
	            }                                                   \
	        } else {                                                \
                    if (((xStart + width) >= clipX0) &&                 \
                        ((xStart + width) <  clipX1) &&                 \
                        ((xEnd + width)   >= clipX0) &&                 \
                        ((xEnd + width)   <  clipX1)) {                 \
                                                                        \
		        len++;                                          \
		        width++;                                        \
	                goto no_scissor;                                \
	            }                                                   \
	        }                                                       \
	    }                                                           \
                                                                        \
	    xLittle = gc->line.options.xLittle;                         \
	    yLittle = gc->line.options.yLittle;                         \
                                                                        \
	    /*                                                          \
            ** Invert negative minor slopes so we can assume            \
            ** dfraction > 0                                            \
            */                                                          \
	    if (dfraction < 0) {                                        \
	        dfraction = -dfraction;                                 \
	        fraction = 0x7fffffff - fraction;                       \
	    }                                                           \
                                                                        \
	    /* Now we compute number of littles and bigs in this line */\
                                                                        \
	    /* We perform a 16 by 32 bit multiply.  Ugh. */             \
	    highWord = (((GLuint) dfraction) >> 16) * len +             \
		       (((GLuint) fraction) >> 16);                     \
	    lowWord = (dfraction & 0xffff) * len + (fraction & 0xffff); \
	    highWord += (((GLuint) lowWord) >> 16);                     \
	    bigs = ((GLuint) highWord) >> 15;                           \
	    littles = len - bigs;                                       \
                                                                        \
	    /* Second trivial accept attempt */                         \
	    xEnd = xStart + xBig*bigs + xLittle*littles;                \
	    yEnd = yStart + yBig*bigs + yLittle*littles;                \
	    if (xEnd >= clipX0 && xEnd < clipX1 &&                      \
		yEnd >= clipY0 && yEnd < clipY1) {                      \
                                                                        \
                if (gc->line.options.axis == __GL_X_MAJOR) {            \
                    if (((yStart + width) >= clipY0) &&                 \
                        ((yStart + width) <  clipY1) &&                 \
                        ((yEnd + width)   >= clipY0) &&                 \
                        ((yEnd + width)   <  clipY1)) {                 \
                                                                        \
		        len++;                                          \
		        width++;                                        \
	                goto no_scissor;                                \
	            }                                                   \
	        } else {                                                \
                    if (((xStart + width) >= clipX0) &&                 \
                        ((xStart + width) <  clipX1) &&                 \
                        ((xEnd + width)   >= clipX0) &&                 \
                        ((xEnd + width)   <  clipX1)) {                 \
                                                                        \
		        len++;                                          \
		        width++;                                        \
	                goto no_scissor;                                \
	            }                                                   \
	        }                                                       \
	    }                                                           \
            len++;	/* Restore len and width */                     \
	    width++;                                                    \
        } else {                                                        \
	    xLittle = gc->line.options.xLittle;                         \
	    yLittle = gc->line.options.yLittle;                         \
        }                                                               \
                                                                        \
        /*                                                              \
        ** The line needs to be scissored.                              \
        ** Well, it should only happen rarely, so we can afford         \
        ** to make it slow.  We achieve this by tediously stippling the \
        ** line.  (rather than clipping it, of course, which would be   \
        ** faster but harder).                                          \
        */                                                              \
                                                                        \
        if (gc->line.options.axis == __GL_X_MAJOR) {                    \
            GLint yTmp0;                                                \
                                                                        \
            if (!((GLuint)cfb->buf.other & NO_CLIP)) {                \
                RECTL rcl;                                              \
                GLint yTmp1;                                            \
                                                                        \
                xEnd = x + xBig * (len - 1);                            \
                yEnd = y + yBig * (len - 1);                            \
                                                                        \
                if (x < xEnd) {                                         \
                    rcl.left  = x;                                      \
                    rcl.right = xEnd + 1;                               \
                } else {                                                \
                    rcl.left  = xEnd;                                   \
                    rcl.right = x + 1;                                  \
                }                                                       \
                if (y < yEnd) {                                         \
                    rcl.top    = y;                                     \
                    rcl.bottom = yEnd + width;                          \
                } else {                                                \
                    rcl.top    = yEnd;                                  \
                    rcl.bottom = y + width;                             \
                }                                                       \
                switch (wglRectVisible(&rcl)) {                         \
                  case WGL_RECT_ALL:                                    \
                    goto scissor_x_no_complex;                          \
                    break;                                              \
                  case WGL_RECT_NONE:                                   \
                    goto no_draw;                                       \
                    break;                                              \
                }                                                       \
                                                                        \
                /* Line is partially visible, check each pixel */       \
                                                                        \
                while (--len >= 0) {                                    \
    	            if (xStart >= clipX0 && xStart < clipX1) {          \
                        yTmp0 = yStart;                                 \
                        yTmp1 = y;                                      \
                        w = width;                                      \
                        while (--w >= 0) {                              \
		            if (wglPixelVisible(x, yTmp1) &&            \
                                yTmp0 >= clipY0 && yTmp0 < clipY1) {    \
    		                *addr = pixel;                          \
                            }                                           \
                            addr += addrMinor;                          \
                            yTmp0++;                                    \
                            yTmp1++;                                    \
		        }                                               \
	            } else {                                            \
	                addr += addrMinor * width;                      \
	            }                                                   \
	            fraction += dfraction;                              \
	            if (fraction < 0) {                                 \
		        fraction &= ~0x80000000;                        \
		        x      += xBig;                                 \
		        y      += yBig;                                 \
		        xStart += xBig;                                 \
		        yStart += yBig;                                 \
		        addr   += addrBig;                              \
	            } else {                                            \
		        x      += xLittle;                              \
		        y      += yLittle;                              \
		        xStart += xLittle;                              \
		        yStart += yLittle;                              \
		        addr   += addrLittle;                           \
	            }                                                   \
	        }                                                       \
	    } else {                                                    \
scissor_x_no_complex:                                                   \
                while (--len >= 0) {                                    \
    	            if (xStart >= clipX0 && xStart < clipX1) {          \
                        yTmp0 = yStart;                                 \
                        w = width;                                      \
                        while (--w >= 0) {                              \
		            if (yTmp0 >= clipY0 && yTmp0 < clipY1) {    \
    		                *addr = pixel;                          \
                            }                                           \
                            addr += addrMinor;                          \
                            yTmp0++;                                    \
		        }                                               \
	            } else {                                            \
	                addr += addrMinor * width;                      \
	            }                                                   \
	            fraction += dfraction;                              \
	            if (fraction < 0) {                                 \
		        fraction &= ~0x80000000;                        \
		        xStart += xBig;                                 \
		        yStart += yBig;                                 \
		        addr   += addrBig;                              \
	            } else {                                            \
		        xStart += xLittle;                              \
		        yStart += yLittle;                              \
		        addr   += addrLittle;                           \
	            }                                                   \
	        }                                                       \
	    }                                                           \
	} else {                                                        \
            GLint xTmp0;                                                \
                                                                        \
            if (!((GLuint)cfb->buf.other & NO_CLIP)) {                \
                RECTL rcl;                                              \
                GLint xTmp1;                                            \
                                                                        \
                xEnd = x + xBig * (len - 1);                            \
                yEnd = y + yBig * (len - 1);                            \
                                                                        \
                if (x < xEnd) {                                         \
                    rcl.left  = x;                                      \
                    rcl.right = xEnd + width;                           \
                } else {                                                \
                    rcl.left  = xEnd;                                   \
                    rcl.right = x + width;                              \
                }                                                       \
                if (y < yEnd) {                                         \
                    rcl.top    = y;                                     \
                    rcl.bottom = yEnd + 1;                              \
                } else {                                                \
                    rcl.top    = yEnd;                                  \
                    rcl.bottom = y + 1;                                 \
                }                                                       \
                switch (wglRectVisible(&rcl)) {                         \
                  case WGL_RECT_ALL:                                    \
                    goto scissor_y_no_complex;                          \
                    break;                                              \
                  case WGL_RECT_NONE:                                   \
                    goto no_draw;                                       \
                    break;                                              \
                }                                                       \
                                                                        \
                /* Line is partially visible, check each pixel */       \
                                                                        \
                while (--len >= 0) {                                    \
    	            if (yStart >= clipY0 && yStart < clipY1) {          \
                        xTmp0 = xStart;                                 \
                        xTmp1 = x;                                      \
                        w = width;                                      \
                        while (--w >= 0) {                              \
		            if (wglPixelVisible(xTmp1, y) &&            \
                                xTmp0 >= clipX0 && xTmp0 < clipX1) {    \
    		                *addr = pixel;                          \
                            }                                           \
                            addr += addrMinor;                          \
                            xTmp0++;                                    \
                            xTmp1++;                                    \
		        }                                               \
	            } else {                                            \
	                addr += addrMinor * width;                      \
	            }                                                   \
	            fraction += dfraction;                              \
	            if (fraction < 0) {                                 \
		        fraction &= ~0x80000000;                        \
		        x      += xBig;                                 \
		        y      += yBig;                                 \
		        xStart += xBig;                                 \
		        yStart += yBig;                                 \
		        addr   += addrBig;                              \
	            } else {                                            \
		        x      += xLittle;                              \
		        y      += yLittle;                              \
		        xStart += xLittle;                              \
		        yStart += yLittle;                              \
		        addr   += addrLittle;                           \
	            }                                                   \
	        }                                                       \
	    } else {                                                    \
scissor_y_no_complex:                                                   \
                while (--len >= 0) {                                    \
    	            if (yStart >= clipY0 && yStart < clipY1) {          \
                        xTmp0 = xStart;                                 \
                        w = width;                                      \
                        while (--w >= 0) {                              \
		            if (xTmp0 >= clipX0 && xTmp0 < clipX1) {    \
    		                *addr = pixel;                          \
                            }                                           \
                            addr += addrMinor;                          \
                            xTmp0++;                                    \
		        }                                               \
	            } else {                                            \
	                addr += addrMinor * width;                      \
	            }                                                   \
	            fraction += dfraction;                              \
	            if (fraction < 0) {                                 \
		        fraction &= ~0x80000000;                        \
		        xStart += xBig;                                 \
		        yStart += yBig;                                 \
		        addr   += addrBig;                              \
	            } else {                                            \
		        xStart += xLittle;                              \
		        yStart += yLittle;                              \
		        addr   += addrLittle;                           \
	            }                                                   \
	        }                                                       \
	    }                                                           \
	}                                                               \
        goto no_draw;                                                   \
no_scissor:                                                             \
        if (!((GLuint)cfb->buf.other & NO_CLIP)) {                    \
            RECTL rcl;                                                  \
                                                                        \
            xEnd = x + xBig * (len - 1);                                \
            yEnd = y + yBig * (len - 1);                                \
                                                                        \
            xLittle = gc->line.options.xLittle;                         \
            yLittle = gc->line.options.yLittle;                         \
                                                                        \
            if (gc->line.options.axis == __GL_X_MAJOR) {                \
                GLint yTmp;                                             \
                                                                        \
                if (x < xEnd) {                                         \
                    rcl.left  = x;                                      \
                    rcl.right = xEnd + 1;                               \
                } else {                                                \
                    rcl.left  = xEnd;                                   \
                    rcl.right = x + 1;                                  \
                }                                                       \
                if (y < yEnd) {                                         \
                    rcl.top    = y;                                     \
                    rcl.bottom = yEnd + width;                          \
                } else {                                                \
                    rcl.top    = yEnd;                                  \
                    rcl.bottom = y + width;                             \
                }                                                       \
                switch (wglRectVisible(&rcl)) {                         \
                  case WGL_RECT_ALL:                                    \
                    goto no_scissor_no_complex;                         \
                    break;                                              \
                  case WGL_RECT_NONE:                                   \
                    goto no_draw;                                       \
                    break;                                              \
                }                                                       \
                                                                        \
                /* Line is partially visible, check each pixel */       \
                                                                        \
                while (--len >= 0) {                                    \
                    yTmp = y;                                           \
                    w = width;                                          \
                    while (--w >= 0) {                                  \
                        if (wglPixelVisible(x, yTmp)) {                 \
    		            *addr = pixel;                              \
                        }                                               \
                        addr += addrMinor;                              \
                        yTmp++;                                         \
	            }                                                   \
	            fraction += dfraction;                              \
	            if (fraction < 0) {                                 \
		        fraction &= ~0x80000000;                        \
		        x      += xBig;                                 \
		        y      += yBig;                                 \
		        addr   += addrBig;                              \
	            } else {                                            \
		        x      += xLittle;                              \
		        y      += yLittle;                              \
		        addr   += addrLittle;                           \
	            }                                                   \
	        }                                                       \
	    } else {                                                    \
                GLint xTmp;                                             \
                                                                        \
                if (x < xEnd) {                                         \
                    rcl.left  = x;                                      \
                    rcl.right = xEnd + width;                           \
                } else {                                                \
                    rcl.left  = xEnd;                                   \
                    rcl.right = x + width;                              \
                }                                                       \
                if (y < yEnd) {                                         \
                    rcl.top    = y;                                     \
                    rcl.bottom = yEnd + 1;                              \
                } else {                                                \
                    rcl.top    = yEnd;                                  \
                    rcl.bottom = y + 1;                                 \
                }                                                       \
                switch (wglRectVisible(&rcl)) {                         \
                  case WGL_RECT_ALL:                                    \
                    goto no_scissor_no_complex;                         \
                    break;                                              \
                  case WGL_RECT_NONE:                                   \
                    goto no_draw;                                       \
                    break;                                              \
                }                                                       \
                                                                        \
                /* Line is partially visible, check each pixel */       \
                                                                        \
                while (--len >= 0) {                                    \
                    xTmp = x;                                           \
                    w = width;                                          \
                    while (--w >= 0) {                                  \
                        if (wglPixelVisible(xTmp, y)) {                 \
    		            *addr = pixel;                              \
                        }                                               \
                        addr += addrMinor;                              \
                        xTmp++;                                         \
	            }                                                   \
	            fraction += dfraction;                              \
	            if (fraction < 0) {                                 \
		        fraction &= ~0x80000000;                        \
		        x      += xBig;                                 \
		        y      += yBig;                                 \
		        addr   += addrBig;                              \
	            } else {                                            \
		        x      += xLittle;                              \
		        y      += yLittle;                              \
		        addr   += addrLittle;                           \
	            }                                                   \
	        }                                                       \
	    }                                                           \
	} else {                                                        \
no_scissor_no_complex:                                                  \
            while (--len >= 0) {                                        \
                w = width;                                              \
                while (--w >= 0) {                                      \
                    *addr = pixel;                                      \
                    addr += addrMinor;                                  \
                }                                                       \
  	        fraction += dfraction;                                  \
	        if (fraction < 0) {                                     \
	            fraction &= ~0x80000000;                            \
	            addr += addrBig;                                    \
	        } else {                                                \
	            addr += addrLittle;                                 \
	        }                                                       \
	    }                                                           \
	}                                                               \
    }                                                                   \
no_draw:;                                                               \
}


/*
** __FAST_LINE_STROKE_DIB24_WIDE
**
** Strokes a wide solid line into a DIB surface.  Performs scissoring.
** Works for 24 BPP
**
*/
#define __FAST_LINE_STROKE_DIB24_WIDE                                   \
{                                                                       \
    len = gc->line.options.numPixels;                                   \
    fraction = gc->line.options.fraction;                               \
    dfraction = gc->line.options.dfraction;                             \
                                                                        \
    /*                                                                  \
    ** Since one or more of the strokes of a wide line may lie outside  \
    ** the viewport, wide lines always go through the scissoring checks \
    */                                                                  \
    {                                                                   \
        GLint clipX0, clipX1, clipY0, clipY1;                           \
        GLint xStart, yStart, xEnd, yEnd;                               \
        GLint xLittle, yLittle, xBig, yBig;                             \
        GLint highWord, lowWord, bigs, littles;                         \
                                                                        \
        clipX0 = gc->transform.clipX0;                                  \
        clipX1 = gc->transform.clipX1;                                  \
        clipY0 = gc->transform.clipY0;                                  \
        clipY1 = gc->transform.clipY1;                                  \
                                                                        \
        xBig = gc->line.options.xBig;                                   \
        yBig = gc->line.options.yBig;                                   \
                                                                        \
        xStart = gc->line.options.xStart;                               \
        yStart = gc->line.options.yStart;                               \
                                                                        \
        /* If the start point is in the scissor region, we attempt to   \
        ** trivially accept the line.                                   \
        */                                                              \
        if (xStart >= clipX0 && xStart < clipX1 &&                      \
	    yStart >= clipY0 && yStart < clipY1) {                      \
                                                                        \
	    len--;	/* Makes our math simpler */                    \
	    width--;                                                    \
	    /* Trivial accept attempt */                                \
	    xEnd = xStart + xBig * len;                                 \
	    yEnd = yStart + yBig * len;                                 \
	    if (xEnd >= clipX0 && xEnd < clipX1 &&                      \
		yEnd >= clipY0 && yEnd < clipY1) {                      \
		                                                        \
                if (gc->line.options.axis == __GL_X_MAJOR) {            \
                    if (((yStart + width) >= clipY0) &&                 \
                        ((yStart + width) <  clipY1) &&                 \
                        ((yEnd + width)   >= clipY0) &&                 \
                        ((yEnd + width)   <  clipY1)) {                 \
                                                                        \
		        len++;                                          \
		        width++;                                        \
	                goto no_scissor;                                \
	            }                                                   \
	        } else {                                                \
                    if (((xStart + width) >= clipX0) &&                 \
                        ((xStart + width) <  clipX1) &&                 \
                        ((xEnd + width)   >= clipX0) &&                 \
                        ((xEnd + width)   <  clipX1)) {                 \
                                                                        \
		        len++;                                          \
		        width++;                                        \
	                goto no_scissor;                                \
	            }                                                   \
	        }                                                       \
	    }                                                           \
                                                                        \
	    xLittle = gc->line.options.xLittle;                         \
	    yLittle = gc->line.options.yLittle;                         \
                                                                        \
	    /*                                                          \
            ** Invert negative minor slopes so we can assume            \
            ** dfraction > 0                                            \
            */                                                          \
	    if (dfraction < 0) {                                        \
	        dfraction = -dfraction;                                 \
	        fraction = 0x7fffffff - fraction;                       \
	    }                                                           \
                                                                        \
	    /* Now we compute number of littles and bigs in this line */\
                                                                        \
	    /* We perform a 16 by 32 bit multiply.  Ugh. */             \
	    highWord = (((GLuint) dfraction) >> 16) * len +             \
		       (((GLuint) fraction) >> 16);                     \
	    lowWord = (dfraction & 0xffff) * len + (fraction & 0xffff); \
	    highWord += (((GLuint) lowWord) >> 16);                     \
	    bigs = ((GLuint) highWord) >> 15;                           \
	    littles = len - bigs;                                       \
                                                                        \
	    /* Second trivial accept attempt */                         \
	    xEnd = xStart + xBig*bigs + xLittle*littles;                \
	    yEnd = yStart + yBig*bigs + yLittle*littles;                \
	    if (xEnd >= clipX0 && xEnd < clipX1 &&                      \
		yEnd >= clipY0 && yEnd < clipY1) {                      \
                                                                        \
                if (gc->line.options.axis == __GL_X_MAJOR) {            \
                    if (((yStart + width) >= clipY0) &&                 \
                        ((yStart + width) <  clipY1) &&                 \
                        ((yEnd + width)   >= clipY0) &&                 \
                        ((yEnd + width)   <  clipY1)) {                 \
                                                                        \
		        len++;                                          \
		        width++;                                        \
	                goto no_scissor;                                \
	            }                                                   \
	        } else {                                                \
                    if (((xStart + width) >= clipX0) &&                 \
                        ((xStart + width) <  clipX1) &&                 \
                        ((xEnd + width)   >= clipX0) &&                 \
                        ((xEnd + width)   <  clipX1)) {                 \
                                                                        \
		        len++;                                          \
		        width++;                                        \
	                goto no_scissor;                                \
	            }                                                   \
	        }                                                       \
	    }                                                           \
            len++;	/* Restore len and width */                     \
	    width++;                                                    \
        } else {                                                        \
	    xLittle = gc->line.options.xLittle;                         \
	    yLittle = gc->line.options.yLittle;                         \
        }                                                               \
                                                                        \
        /*                                                              \
        ** The line needs to be scissored.                              \
        ** Well, it should only happen rarely, so we can afford         \
        ** to make it slow.  We achieve this by tediously stippling the \
        ** line.  (rather than clipping it, of course, which would be   \
        ** faster but harder).                                          \
        */                                                              \
                                                                        \
        if (gc->line.options.axis == __GL_X_MAJOR) {                    \
            GLint yTmp0;                                                \
                                                                        \
            if (!((GLuint)cfb->buf.other & NO_CLIP)) {                \
                RECTL rcl;                                              \
                GLint yTmp1;                                            \
                                                                        \
                xEnd = x + xBig * (len - 1);                            \
                yEnd = y + yBig * (len - 1);                            \
                                                                        \
                if (x < xEnd) {                                         \
                    rcl.left  = x;                                      \
                    rcl.right = xEnd + 1;                               \
                } else {                                                \
                    rcl.left  = xEnd;                                   \
                    rcl.right = x + 1;                                  \
                }                                                       \
                if (y < yEnd) {                                         \
                    rcl.top    = y;                                     \
                    rcl.bottom = yEnd + width;                          \
                } else {                                                \
                    rcl.top    = yEnd;                                  \
                    rcl.bottom = y + width;                             \
                }                                                       \
                switch (wglRectVisible(&rcl)) {                         \
                  case WGL_RECT_ALL:                                    \
                    goto scissor_x_no_complex;                          \
                    break;                                              \
                  case WGL_RECT_NONE:                                   \
                    goto no_draw;                                       \
                    break;                                              \
                }                                                       \
                                                                        \
                /* Line is partially visible, check each pixel */       \
                                                                        \
                while (--len >= 0) {                                    \
    	            if (xStart >= clipX0 && xStart < clipX1) {          \
                        yTmp0 = yStart;                                 \
                        yTmp1 = y;                                      \
                        w = width;                                      \
                        while (--w >= 0) {                              \
		            if (wglPixelVisible(x, yTmp1) &&            \
                                yTmp0 >= clipY0 && yTmp0 < clipY1) {    \
    		                addr[0] = ir;                           \
    		                addr[1] = ig;                           \
    		                addr[2] = ib;                           \
                            }                                           \
                            addr += addrMinor;                          \
                            yTmp0++;                                    \
                            yTmp1++;                                    \
		        }                                               \
	            } else {                                            \
	                addr += addrMinor * width;                      \
	            }                                                   \
	            fraction += dfraction;                              \
	            if (fraction < 0) {                                 \
		        fraction &= ~0x80000000;                        \
		        x      += xBig;                                 \
		        y      += yBig;                                 \
		        xStart += xBig;                                 \
		        yStart += yBig;                                 \
		        addr   += addrBig;                              \
	            } else {                                            \
		        x      += xLittle;                              \
		        y      += yLittle;                              \
		        xStart += xLittle;                              \
		        yStart += yLittle;                              \
		        addr   += addrLittle;                           \
	            }                                                   \
	        }                                                       \
	    } else {                                                    \
scissor_x_no_complex:                                                   \
                while (--len >= 0) {                                    \
    	            if (xStart >= clipX0 && xStart < clipX1) {          \
                        yTmp0 = yStart;                                 \
                        w = width;                                      \
                        while (--w >= 0) {                              \
		            if (yTmp0 >= clipY0 && yTmp0 < clipY1) {    \
    		                addr[0] = ir;                           \
    		                addr[1] = ig;                           \
    		                addr[2] = ib;                           \
                            }                                           \
                            addr += addrMinor;                          \
                            yTmp0++;                                    \
		        }                                               \
	            } else {                                            \
	                addr += addrMinor * width;                      \
	            }                                                   \
	            fraction += dfraction;                              \
	            if (fraction < 0) {                                 \
		        fraction &= ~0x80000000;                        \
		        xStart += xBig;                                 \
		        yStart += yBig;                                 \
		        addr   += addrBig;                              \
	            } else {                                            \
		        xStart += xLittle;                              \
		        yStart += yLittle;                              \
		        addr   += addrLittle;                           \
	            }                                                   \
	        }                                                       \
	    }                                                           \
	} else {                                                        \
            GLint xTmp0;                                                \
                                                                        \
            if (!((GLuint)cfb->buf.other & NO_CLIP)) {                \
                RECTL rcl;                                              \
                GLint xTmp1;                                            \
                                                                        \
                xEnd = x + xBig * (len - 1);                            \
                yEnd = y + yBig * (len - 1);                            \
                                                                        \
                if (x < xEnd) {                                         \
                    rcl.left  = x;                                      \
                    rcl.right = xEnd + width;                           \
                } else {                                                \
                    rcl.left  = xEnd;                                   \
                    rcl.right = x + width;                              \
                }                                                       \
                if (y < yEnd) {                                         \
                    rcl.top    = y;                                     \
                    rcl.bottom = yEnd + 1;                              \
                } else {                                                \
                    rcl.top    = yEnd;                                  \
                    rcl.bottom = y + 1;                                 \
                }                                                       \
                switch (wglRectVisible(&rcl)) {                         \
                  case WGL_RECT_ALL:                                    \
                    goto scissor_y_no_complex;                          \
                    break;                                              \
                  case WGL_RECT_NONE:                                   \
                    goto no_draw;                                       \
                    break;                                              \
                }                                                       \
                                                                        \
                /* Line is partially visible, check each pixel */       \
                                                                        \
                while (--len >= 0) {                                    \
    	            if (yStart >= clipY0 && yStart < clipY1) {          \
                        xTmp0 = xStart;                                 \
                        xTmp1 = x;                                      \
                        w = width;                                      \
                        while (--w >= 0) {                              \
		            if (wglPixelVisible(xTmp1, y) &&            \
                                xTmp0 >= clipX0 && xTmp0 < clipX1) {    \
    		                addr[0] = ir;                           \
    		                addr[1] = ig;                           \
    		                addr[2] = ib;                           \
                            }                                           \
                            addr += addrMinor;                          \
                            xTmp0++;                                    \
                            xTmp1++;                                    \
		        }                                               \
	            } else {                                            \
	                addr += addrMinor * width;                      \
	            }                                                   \
	            fraction += dfraction;                              \
	            if (fraction < 0) {                                 \
		        fraction &= ~0x80000000;                        \
		        x      += xBig;                                 \
		        y      += yBig;                                 \
		        xStart += xBig;                                 \
		        yStart += yBig;                                 \
		        addr   += addrBig;                              \
	            } else {                                            \
		        x      += xLittle;                              \
		        y      += yLittle;                              \
		        xStart += xLittle;                              \
		        yStart += yLittle;                              \
		        addr   += addrLittle;                           \
	            }                                                   \
	        }                                                       \
	    } else {                                                    \
scissor_y_no_complex:                                                   \
                while (--len >= 0) {                                    \
    	            if (yStart >= clipY0 && yStart < clipY1) {          \
                        xTmp0 = xStart;                                 \
                        w = width;                                      \
                        while (--w >= 0) {                              \
		            if (xTmp0 >= clipX0 && xTmp0 < clipX1) {    \
    		                addr[0] = ir;                           \
    		                addr[1] = ig;                           \
    		                addr[2] = ib;                           \
                            }                                           \
                            addr += addrMinor;                          \
                            xTmp0++;                                    \
		        }                                               \
	            } else {                                            \
	                addr += addrMinor * width;                      \
	            }                                                   \
	            fraction += dfraction;                              \
	            if (fraction < 0) {                                 \
		        fraction &= ~0x80000000;                        \
		        xStart += xBig;                                 \
		        yStart += yBig;                                 \
		        addr   += addrBig;                              \
	            } else {                                            \
		        xStart += xLittle;                              \
		        yStart += yLittle;                              \
		        addr   += addrLittle;                           \
	            }                                                   \
	        }                                                       \
	    }                                                           \
	}                                                               \
        goto no_draw;                                                   \
no_scissor:                                                             \
        if (!((GLuint)cfb->buf.other & NO_CLIP)) {                    \
            RECTL rcl;                                                  \
                                                                        \
            xLittle = gc->line.options.xLittle;                         \
            yLittle = gc->line.options.yLittle;                         \
                                                                        \
            if (gc->line.options.axis == __GL_X_MAJOR) {                \
                GLint yTmp;                                             \
                                                                        \
                if (x < xEnd) {                                         \
                    rcl.left  = x;                                      \
                    rcl.right = xEnd + 1;                               \
                } else {                                                \
                    rcl.left  = xEnd;                                   \
                    rcl.right = x + 1;                                  \
                }                                                       \
                if (y < yEnd) {                                         \
                    rcl.top    = y;                                     \
                    rcl.bottom = yEnd + width;                          \
                } else {                                                \
                    rcl.top    = yEnd;                                  \
                    rcl.bottom = y + width;                             \
                }                                                       \
                switch (wglRectVisible(&rcl)) {                         \
                  case WGL_RECT_ALL:                                    \
                    goto no_scissor_no_complex;                         \
                    break;                                              \
                  case WGL_RECT_NONE:                                   \
                    goto no_draw;                                       \
                    break;                                              \
                }                                                       \
                                                                        \
                /* Line is partially visible, check each pixel */       \
                                                                        \
                while (--len >= 0) {                                    \
                    yTmp = y;                                           \
                    w = width;                                          \
                    while (--w >= 0) {                                  \
                        if (wglPixelVisible(x, yTmp)) {                 \
    		            addr[0] = ir;                               \
    		            addr[1] = ig;                               \
    		            addr[2] = ib;                               \
                        }                                               \
                        addr += addrMinor;                              \
                        yTmp++;                                         \
	            }                                                   \
	            fraction += dfraction;                              \
	            if (fraction < 0) {                                 \
		        fraction &= ~0x80000000;                        \
		        x      += xBig;                                 \
		        y      += yBig;                                 \
		        addr   += addrBig;                              \
	            } else {                                            \
		        x      += xLittle;                              \
		        y      += yLittle;                              \
		        addr   += addrLittle;                           \
	            }                                                   \
	        }                                                       \
	    } else {                                                    \
                GLint xTmp;                                             \
                                                                        \
                if (x < xEnd) {                                         \
                    rcl.left  = x;                                      \
                    rcl.right = xEnd + width;                           \
                } else {                                                \
                    rcl.left  = xEnd;                                   \
                    rcl.right = x + width;                              \
                }                                                       \
                if (y < yEnd) {                                         \
                    rcl.top    = y;                                     \
                    rcl.bottom = yEnd + 1;                              \
                } else {                                                \
                    rcl.top    = yEnd;                                  \
                    rcl.bottom = y + 1;                                 \
                }                                                       \
                switch (wglRectVisible(&rcl)) {                         \
                  case WGL_RECT_ALL:                                    \
                    goto no_scissor_no_complex;                         \
                    break;                                              \
                  case WGL_RECT_NONE:                                   \
                    goto no_draw;                                       \
                    break;                                              \
                }                                                       \
                                                                        \
                /* Line is partially visible, check each pixel */       \
                                                                        \
                while (--len >= 0) {                                    \
                    xTmp = x;                                           \
                    w = width;                                          \
                    while (--w >= 0) {                                  \
                        if (wglPixelVisible(xTmp, y)) {                 \
    		            addr[0] = ir;                               \
    		            addr[1] = ig;                               \
    		            addr[2] = ib;                               \
                        }                                               \
                        addr += addrMinor;                              \
                        xTmp++;                                         \
	            }                                                   \
	            fraction += dfraction;                              \
	            if (fraction < 0) {                                 \
		        fraction &= ~0x80000000;                        \
		        x      += xBig;                                 \
		        y      += yBig;                                 \
		        addr   += addrBig;                              \
	            } else {                                            \
		        x      += xLittle;                              \
		        y      += yLittle;                              \
		        addr   += addrLittle;                           \
	            }                                                   \
	        }                                                       \
	    }                                                           \
	} else {                                                        \
no_scissor_no_complex:                                                  \
            while (--len >= 0) {                                        \
                w = width;                                              \
                while (--w >= 0) {                                      \
    		    addr[0] = ir;                                       \
    		    addr[1] = ig;                                       \
    		    addr[2] = ib;                                       \
                    addr += addrMinor;                                  \
                }                                                       \
  	        fraction += dfraction;                                  \
	        if (fraction < 0) {                                     \
	            fraction &= ~0x80000000;                            \
	            addr += addrBig;                                    \
	        } else {                                                \
	            addr += addrLittle;                                 \
	        }                                                       \
	    }                                                           \
	}                                                               \
    }                                                                   \
no_draw:;                                                               \
}

#endif // NT_NO_BUFFER_INVARIANCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\genline.c ===
/*
** Copyright 1991,1992,1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "precomp.h"
#pragma hdrstop

#include "genline.h"
#include "devlock.h"

/******************************Public*Routine******************************\
* __fastGenLineSetupDisplay
*
* Initializes the accelerated line-rendering state machine for display surfaces.
* There are basically 4 levels in the state machine:
*   1. lineBegin
*           This function initializes the initial states of the lower levels.
*
*   2. lineVertex
*           This function adds vertices to the path
* 
*   3. lineEnd
*           This function calls the routine to stroke the path.
*
* History:
*  09-Jan-1996 -by- Drew Bliss [drewb]
*   Totally rewrote fast line support
*  29-Mar-1994 [v-eddier]
*   Changed name when __fastGenLineSetupDIB was added.
*  22-Mar-1994 -by- Eddie Robinson [v-eddier]
*   Wrote it.
\**************************************************************************/

BOOL FASTCALL __fastGenLineSetupDisplay(__GLcontext *gc)
{
    __GLGENcontext *gengc = (__GLGENcontext *) gc;
    GENACCEL *genAccel = (GENACCEL *) gengc->pPrivateArea;
    GLuint modeFlags = gc->polygon.shader.modeFlags;

    // allocate line buffer
    
    if (!genAccel->pFastLineBuffer) {
        if (!(genAccel->pFastLineBuffer =
              (BYTE *) GCALLOC(gc, __FAST_LINE_BUFFER_SIZE)))
            return FALSE;
    }
    
    // Set the line rasterization function pointers
    gc->procs.lineBegin = __fastGenLineBegin;
    gc->procs.lineEnd = __fastGenLineEnd;
    
    if (gc->state.line.aliasedWidth > 1)
    {
        gc->procs.renderLine = __fastGenLineWide;
    }
    else
    {
        gc->procs.renderLine = __fastGenLine;
    }
    
    return TRUE;
}

/******************************Public*Routine******************************\
*
* __fastLineComputeOffsets
*
* Precomputes static offsets for fast line drawing
*
* History:
*  Tue Aug 15 18:10:29 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void FASTCALL __fastLineComputeOffsets(__GLGENcontext *gengc)
{
    GENACCEL *genAccel;

    genAccel = (GENACCEL *)gengc->pPrivateArea;
    ASSERTOPENGL(genAccel != NULL,
                 "ComputeFastLineOffsets with no genaccel\n");
    
// If acceleration is wired-in, set the offsets for line drawing.
// These offsets include the following:
//      subtraction of the viewport bias
//      addition of the client window origin
//      subtraction of .5 to align GL pixel centers with GDI's pixel centers
//      addition of 1/32 to round the value which will be converted to
//          28.4 fixed point

#ifdef _CLIENTSIDE_
    // Window-relative coordinates
    genAccel->fastLineOffsetX = 0 -
        gengc->gc.constants.viewportXAdjust - (__GLfloat) (0.5 - 0.03125);

    genAccel->fastLineOffsetY = 0 -
        gengc->gc.constants.viewportYAdjust - (__GLfloat) (0.5 - 0.03125);
#else
    // Screen-relative coordinates
    genAccel->fastLineOffsetX = gengc->gc.drawBuffer->buf.xOrigin - 
        gengc->gc.constants.viewportXAdjust - (__GLfloat) (0.5 - 0.03125);

    genAccel->fastLineOffsetY = gengc->gc.drawBuffer->buf.yOrigin - 
        gengc->gc.constants.viewportYAdjust - (__GLfloat) (0.5 - 0.03125);
#endif
}

/******************************Public*Routine******************************\
* __fastLineComputeColor*
*
* Computes the color index to use for line drawing.  These functions are
* called through a function pointer whenever the vertex color changes.
*
* History:
*  22-Mar-1994 -by- Eddie Robinson [v-eddier]
* Wrote it.
\**************************************************************************/

GLubyte vujRGBtoVGA[8] = {
    0x0, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf
};

ULONG FASTCALL __fastLineComputeColorRGB4(__GLcontext *gc, __GLcolor *color)
{
    __GLGENcontext *gengc = (__GLGENcontext *) gc;
    PIXELFORMATDESCRIPTOR *pfmt = &gengc->gsurf.pfd;
    int ir, ig, ib;

    ir = (int) color->r;
    ig = (int) color->g;
    ib = (int) color->b;
    return (ULONG) vujRGBtoVGA[(ir << pfmt->cRedShift) |
                               (ig << pfmt->cGreenShift) |
                               (ib << pfmt->cBlueShift)];
}

ULONG FASTCALL __fastLineComputeColorRGB8(__GLcontext *gc, __GLcolor *color)
{
    __GLGENcontext *gengc = (__GLGENcontext *) gc;
    PIXELFORMATDESCRIPTOR *pfmt = &gengc->gsurf.pfd;
    int ir, ig, ib;

    ir = (int) color->r;
    ig = (int) color->g;
    ib = (int) color->b;
    return (ULONG) gengc->pajTranslateVector[(ir << pfmt->cRedShift) |
                                             (ig << pfmt->cGreenShift) |
                                             (ib << pfmt->cBlueShift)];
}

ULONG FASTCALL __fastLineComputeColorRGB(__GLcontext *gc, __GLcolor *color)
{
    __GLGENcontext *gengc = (__GLGENcontext *) gc;
    PIXELFORMATDESCRIPTOR *pfmt = &gengc->gsurf.pfd;
    int ir, ig, ib;

    ir = (int) color->r;
    ig = (int) color->g;
    ib = (int) color->b;
    return (ULONG) ((ir << pfmt->cRedShift) |
                    (ig << pfmt->cGreenShift) |
                    (ib << pfmt->cBlueShift));
}

ULONG FASTCALL __fastLineComputeColorCI4and8(__GLcontext *gc, __GLcolor *color)
{
    __GLGENcontext *gengc = (__GLGENcontext *) gc;

    return (ULONG) gengc->pajTranslateVector[(int)color->r];
}

ULONG FASTCALL __fastLineComputeColorCI(__GLcontext *gc, __GLcolor *color)
{
    __GLGENcontext *gengc = (__GLGENcontext *) gc;
    GLuint *pTrans = (GLuint *) gengc->pajTranslateVector;
    
    return (ULONG) pTrans[(int)(color->r)+1];
}

/******************************Public*Routine******************************\
* __glQueryLineAcceleration
*
* Determines if lines are accelerated through the DDI and performs some
* initialization.  Currently, this routine only checks for acceleration via
* the standard DDI.  Eventually, it could support checking for acceleration
* via the extended DDI.
*
* History:
*  22-Mar-1994 -by- Eddie Robinson [v-eddier]
* Wrote it.
\**************************************************************************/

void FASTCALL __glQueryLineAcceleration(__GLcontext *gc)
{
    __GLGENcontext *gengc = (__GLGENcontext *) gc;
    GENACCEL *genAccel = (GENACCEL *) gengc->pPrivateArea;
    PIXELFORMATDESCRIPTOR *pfmt;

    pfmt = &gengc->gsurf.pfd;

    // On the client side we can draw into any surface with GDI
    // and (presumably) get the best possible plain 2D line drawing
    // performance
    genAccel->bFastLineDIBAccel = TRUE;

    //XXX eventually, check rxcaps and set appropriate mode bits

    genAccel->bFastLineDispAccel = TRUE;
    
    // set modes supported by hardware.  These are equivalent to the
    // gc->polygon.shader.modeFlags checked in the pick function
    
    genAccel->flLineAccelModes = 0;

    // Set the color computation function

    if (pfmt->iPixelType == PFD_TYPE_RGBA) {
        switch (pfmt->cColorBits) {
          case 4:
            genAccel->fastLineComputeColor = __fastLineComputeColorRGB4;
            break;
          case 8:
            genAccel->fastLineComputeColor = __fastLineComputeColorRGB8;
            break;
          case 16:
          case 24:
          case 32:
            genAccel->fastLineComputeColor = __fastLineComputeColorRGB;
            break;
          default:
            genAccel->bFastLineDispAccel = FALSE;
            return;
        }
    } else {
        switch (pfmt->cColorBits) {
          case 4:
          case 8:
            genAccel->fastLineComputeColor = __fastLineComputeColorCI4and8;
            break;
          case 16:
          case 24:
          case 32:
            genAccel->fastLineComputeColor = __fastLineComputeColorCI;
            break;
          default:
            genAccel->bFastLineDispAccel = FALSE;
            return;
        }
    }
}    

/**************************************************************************/

// Macros to hide how the single pFastLineBuffer is divided into two
// sections, one for points and one for counts
#define FAST_LINE_FIRST_POINT(genAccel) \
    ((POINT *)(genAccel)->pFastLineBuffer)

#define FAST_LINE_FIRST_COUNT(genAccel) \
    ((DWORD *)((genAccel)->pFastLineBuffer+__FAST_LINE_BUFFER_SIZE)- \
     __FAST_LINE_BUFFER_COUNTS)
    
#define FAST_LINE_LAST_POINT(genAccel) \
    ((POINT *)FAST_LINE_FIRST_COUNT(genAccel)-1)
    
#define FAST_LINE_LAST_COUNT(genAccel) \
    ((DWORD *)((genAccel)->pFastLineBuffer+__FAST_LINE_BUFFER_SIZE)-1)

/******************************Public*Routine******************************\
*
* __fastGenLineBegin
*
* Initializes fast line state
*
* History:
*  Mon Jan 08 19:22:32 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void FASTCALL __fastGenLineBegin(__GLcontext *gc)
{
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    GENACCEL *genAccel = &gengc->genAccel;

    genAccel->pFastLinePoint = FAST_LINE_FIRST_POINT(genAccel)-1;
    genAccel->pFastLineCount = FAST_LINE_FIRST_COUNT(genAccel)-1;
    genAccel->fastLineCounts = 0;
}

/******************************Public*Routine******************************\
*
* __fastGenLineEnd
*
* Renders any current lines in the fast line buffer and
* then resets the fast line state
*
* History:
*  Mon Jan 08 19:22:52 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void FASTCALL __fastGenLineEnd(__GLcontext *gc)
{
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    GENACCEL *genAccel = &gengc->genAccel;
    ULONG ulSolidColor;
    HDC hdc;
    HPEN hpen;

    if (genAccel->fastLineCounts == 0)
    {
        return;
    }
    
    // If there is no lock, we must have failed to reacquire the lock
    // from the previous call to wglStrokePath.  This is an error condition
    // and we should not continue.

    if (gengc->fsLocks == 0)
    {
	WARNING("fastGenLineEnd: no lock\n");
	return;
    }

    // We need to sychronize with GDI before making GDI calls
    glsrvSynchronizeWithGdi(gengc, gengc->pwndLocked,
                            COLOR_LOCK_FLAGS | DEPTH_LOCK_FLAGS);

    // If this color is the same as the one we've cached, use the
    // cached information
    hdc = CURRENT_DC_GC(gc);
    if (!gengc->fStrokeInvalid && hdc == gengc->hdcStroke)
    {
        hpen = gengc->hpenStroke;
        ASSERTOPENGL(hpen != NULL, "Cached stroke pen is null\n");
    }
    else
    {
        if (gengc->hpenStroke != NULL)
        {
            // Deselect the object before deletion
            if (gengc->hdcStroke != NULL)
            {
                SelectObject(gengc->hdcStroke, GetStockObject(BLACK_PEN));
                gengc->hdcStroke = NULL;
            }
            
            DeleteObject(gengc->hpenStroke);
        }

        ulSolidColor = wglTranslateColor(gengc->crStroke, hdc,
                                         gengc, &gengc->gsurf.pfd);
        hpen = CreatePen(PS_SOLID, 0, ulSolidColor);
        gengc->hpenStroke = hpen;
        
        if (hpen == NULL ||
            SelectObject(hdc, hpen) == NULL)
        {
            if (hpen != NULL)
            {
                DeleteObject(hpen);
                gengc->hpenStroke = NULL;
            }
            
            gengc->cStroke.r = -1.0f;
            gengc->fStrokeInvalid = TRUE;
            goto Exit;
        }

        gengc->hdcStroke = hdc;
        gengc->fStrokeInvalid = FALSE;
    }

#ifdef DBG_VERBOSE
    {
        DWORD i;
        DWORD *count;
        POINT *pt;

        count = FAST_LINE_FIRST_COUNT(genAccel);
        pt = FAST_LINE_FIRST_POINT(genAccel);
        for (i = 0; i < genAccel->fastLineCounts; i++)
        {
            DbgPrint("Polyline with %d points at %d\n",
                     *count, pt-FAST_LINE_FIRST_POINT(genAccel));
            pt += *count;
            count++;
        }
    }
#endif
    
    PolyPolyline(hdc,
                 FAST_LINE_FIRST_POINT(genAccel),
                 FAST_LINE_FIRST_COUNT(genAccel),
                 genAccel->fastLineCounts);

 Exit:
    // No more need for GDI operations
    glsrvDecoupleFromGdi(gengc, gengc->pwndLocked,
                         COLOR_LOCK_FLAGS | DEPTH_LOCK_FLAGS);
    
    // Reset
    __fastGenLineBegin(gc);
}

/******************************Public*Routine******************************\
*
* __fastGenLineSetStrokeColor
*
* Updates cached pen with current color if necessary
*
* History:
*  Wed Jan 17 20:37:15 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL __fastGenLineSetStrokeColor(__GLGENcontext *gengc, __GLcolor *color)
{
    if (__GL_FLOAT_NE(color->r, gengc->cStroke.r) ||
	(gengc->gsurf.pfd.iPixelType == PFD_TYPE_RGBA
	 && (__GL_FLOAT_NE(color->g, gengc->cStroke.g) ||
	     __GL_FLOAT_NE(color->b, gengc->cStroke.b))))
    {
        ASSERTOPENGL(color->r >= 0.0f, "Invalid color\n");
        
#ifdef DBG_VERBOSE
        if (gengc->cStroke.r >= 0.0f)
        {
            DbgPrint("Color change\n");
        }
#endif
        
        // Flush whatever we have so far
        __fastGenLineEnd(&gengc->gc);

        // Set current color
	if (gengc->gsurf.pfd.iPixelType == PFD_TYPE_RGBA)
	    gengc->cStroke = *color;
	else
	    gengc->cStroke.r = color->r;
        gengc->crStroke =
            gengc->genAccel.fastLineComputeColor((__GLcontext *)gengc,
                                                 &gengc->cStroke);
        // Invalidate cached pen
        gengc->fStrokeInvalid = TRUE;

        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

/******************************Public*Routine******************************\
*
* __fastGenLine
*
* Accumulates incoming vertices in the fast line buffer
* Thin line version
*
* History:
*  Mon Jan 08 19:23:19 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void FASTCALL __fastGenLine(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1,
                            GLuint flags)
{
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    GENACCEL *genAccel = &gengc->genAccel;
    POINT pt;

#ifdef DBG_VERBOSE
    DbgPrint("Counts %d, count %d, flags %X\n",
             genAccel->fastLineCounts,
             genAccel->pFastLineCount >= FAST_LINE_FIRST_COUNT(genAccel) ?
             *genAccel->pFastLineCount : -1,
             flags);
#endif
    
    // Check for flushing conditions.  We flush if:
    //  The provoking vertex's color is different from the current color
    //  This is the first vertex of a line and we don't have space for
    //   a new count and two vertices
    //  This is not the first vertex of a line and we don't have space for
    //   a new vertex
    //
    // According to spec we have to use color form a second vertex for flat
    // shaded case
    //
    if (__fastGenLineSetStrokeColor(gengc, v1->color))
    {
        // Since we flushed, the current vertex is now the beginning
        // of a polyline
        flags |= __GL_LVERT_FIRST;
    }

    if (((flags & __GL_LVERT_FIRST) != 0 &&
         (genAccel->pFastLinePoint+1 >= FAST_LINE_LAST_POINT(genAccel) ||
          genAccel->pFastLineCount >= FAST_LINE_LAST_COUNT(genAccel))) ||
        ((flags & __GL_LVERT_FIRST) == 0 &&
         genAccel->pFastLinePoint >= FAST_LINE_LAST_POINT(genAccel)))
    {
#ifdef DBG_VERBOSE
        DbgPrint("Overflow\n");
#endif
        
        __fastGenLineEnd(gc);

        // Since we flushed, the current vertex is now the beginning
        // of a polyline
        flags |= __GL_LVERT_FIRST;
    }

    // If we're starting a polyline, update the counts and add
    // the vertex data
    if (flags & __GL_LVERT_FIRST)
    {
#ifdef DBG_VERBOSE
        if (genAccel->pFastLineCount >= FAST_LINE_FIRST_COUNT(genAccel))
        {
            DbgPrint("First ended polyline with %d points\n",
                     *genAccel->pFastLineCount);
        }
#endif
        // Check to make sure we don't ever create segments with only
        // one vertex
        ASSERTOPENGL(genAccel->pFastLineCount <
                     FAST_LINE_FIRST_COUNT(genAccel) ||
                     *genAccel->pFastLineCount > 1,
                     "Line segment with only one vertex\n");

        genAccel->fastLineCounts++;
        genAccel->pFastLineCount++;
        *genAccel->pFastLineCount = 1;
        
        // Compute device coordinates
        pt.x = __FAST_LINE_FLTTODEV(v0->window.x + genAccel->fastLineOffsetX);
        pt.y = __FAST_LINE_FLTTODEV(v0->window.y + genAccel->fastLineOffsetY);
        *(++genAccel->pFastLinePoint) = pt;
    }
    
    ASSERTOPENGL(genAccel->pFastLineCount >=
                 FAST_LINE_FIRST_COUNT(genAccel) &&
                 *genAccel->pFastLineCount > 0,
                 "Added fast point without count\n");
    
    // Compute device coordinates
    pt.x = __FAST_LINE_FLTTODEV(v1->window.x + genAccel->fastLineOffsetX);
    pt.y = __FAST_LINE_FLTTODEV(v1->window.y + genAccel->fastLineOffsetY);
    (*genAccel->pFastLineCount)++;
    *(++genAccel->pFastLinePoint) = pt;
    
    // Check on counts also
    ASSERTOPENGL(genAccel->pFastLineCount <= FAST_LINE_LAST_COUNT(genAccel),
                 "Fast line count buffer overflow\n");
    ASSERTOPENGL(genAccel->pFastLinePoint <= FAST_LINE_LAST_POINT(genAccel),
                 "Fast line point buffer overflow\n");
    
    // Make sure the current color is being maintained properly
    ASSERTOPENGL((v1->color->r == gengc->cStroke.r) &&
		 (gengc->gsurf.pfd.iPixelType == PFD_TYPE_COLORINDEX ||
                     (v1->color->g == gengc->cStroke.g &&
		      v1->color->b == gengc->cStroke.b)),
                 "Fast line color mismatch\n");
}

/******************************Public*Routine******************************\
*
* __fastGenLineWide
*
* Accumulates incoming vertices in the fast line buffer
* Wide line version
* For wide lines we can't maintain connectivity because of the
* way OpenGL wide lines are defined.  Instead, each segment
* of a wide line is decomposed into aliasedWidth unconnected
* line segments
*
* History:
*  Tue Jan 09 11:32:10 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void FASTCALL __fastGenLineWide(__GLcontext *gc, __GLvertex *v0,
                                __GLvertex *v1, GLuint flags)
{
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    GENACCEL *genAccel = &gengc->genAccel;
    POINT pt1, pt2;
    GLint width;
    long adjust;
    GLfloat dx, dy;

    // Set the current pen color
    // According to spec we have to use color form a second vertex for flat
    // shaded case
    //
    __fastGenLineSetStrokeColor(gengc, v1->color);
    
    // We have a wide line segment from v0 to v1
    // Compute its width and add an appropriate number of
    // side-by-side thin segments to create the wide form

    // Compute device coordinates
    pt1.x = __FAST_LINE_FLTTODEV(v0->window.x +
                                 genAccel->fastLineOffsetX);
    pt1.y = __FAST_LINE_FLTTODEV(v0->window.y +
                                 genAccel->fastLineOffsetY);
    pt2.x = __FAST_LINE_FLTTODEV(v1->window.x +
                                 genAccel->fastLineOffsetX);
    pt2.y = __FAST_LINE_FLTTODEV(v1->window.y +
                                 genAccel->fastLineOffsetY);
    
    width = gc->state.line.aliasedWidth;

    /*
    ** Compute the minor-axis adjustment for the first line segment
    ** this can be a fixed point value with 4 fractional bits
    */
    adjust = ((width - 1) * __FAST_LINE_UNIT_VALUE) / 2;
        
    // Determine the major axis
    dx = v0->window.x - v1->window.x;
    if (dx < 0.0)
    {
        dx = -dx;
    }
    dy = v0->window.y - v1->window.y;
    if (dy < 0.0)
    {
        dy = -dy;
    }

    if (dx > dy)
    {
        pt1.y -= adjust;
        pt2.y -= adjust;

        while (width-- > 0)
        {
            // Make sure we have room for another count and two more
            // vertices
            if (genAccel->pFastLinePoint+1 >= FAST_LINE_LAST_POINT(genAccel) ||
                genAccel->pFastLineCount >= FAST_LINE_LAST_COUNT(genAccel))
            {
                __fastGenLineEnd(gc);
            }
            
            genAccel->fastLineCounts++;
            genAccel->pFastLineCount++;
            *genAccel->pFastLineCount = 2;
            *(++genAccel->pFastLinePoint) = pt1;
            *(++genAccel->pFastLinePoint) = pt2;

            pt1.y++;
            pt2.y++;
        }
    }
    else
    {
        pt1.x -= adjust;
        pt2.x -= adjust;

        while (width-- > 0)
        {
            // Make sure we have room for another count and two more
            // vertices
            if (genAccel->pFastLinePoint+1 >= FAST_LINE_LAST_POINT(genAccel) ||
                genAccel->pFastLineCount >= FAST_LINE_LAST_COUNT(genAccel))
            {
                __fastGenLineEnd(gc);
            }
            
            genAccel->fastLineCounts++;
            genAccel->pFastLineCount++;
            *genAccel->pFastLineCount = 2;
            *(++genAccel->pFastLinePoint) = pt1;
            *(++genAccel->pFastLinePoint) = pt2;

            pt1.x++;
            pt2.x++;
        }
    }
}

#if NT_NO_BUFFER_INVARIANCE

PFN_RENDER_LINE __fastGenRenderLineDIBFuncs[32] = {
    __fastGenRenderLineDIBCI8,
    __fastGenRenderLineDIBCI16,
    __fastGenRenderLineDIBCIRGB,
    __fastGenRenderLineDIBCIBGR,
    __fastGenRenderLineDIBCI32,
    NULL,
    NULL,
    NULL,
    __fastGenRenderLineDIBRGB8,
    __fastGenRenderLineDIBRGB16,
    __fastGenRenderLineDIBRGB,
    __fastGenRenderLineDIBBGR,
    __fastGenRenderLineDIBRGB32,
    NULL,
    NULL,
    NULL,
    __fastGenRenderLineWideDIBCI8,
    __fastGenRenderLineWideDIBCI16,
    __fastGenRenderLineWideDIBCIRGB,
    __fastGenRenderLineWideDIBCIBGR,
    __fastGenRenderLineWideDIBCI32,
    NULL,
    NULL,
    NULL,
    __fastGenRenderLineWideDIBRGB8,
    __fastGenRenderLineWideDIBRGB16,
    __fastGenRenderLineWideDIBRGB,
    __fastGenRenderLineWideDIBBGR,
    __fastGenRenderLineWideDIBRGB32,
    NULL,
    NULL,
    NULL
};

/******************************Public*Routine******************************\
* __fastGenLineSetupDIB
*
* Initializes the accelerated line-rendering function pointer for bitmap
* surfaces.  All accelerated lines drawn to bitmaps are drawn by the
* gc->procs.renderLine funtion pointer.
*
* History:
*  29-Mar-1994 -by- Eddie Robinson [v-eddier]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL __fastGenLineSetupDIB(__GLcontext *gc)
{
    __GLGENcontext *gengc = (__GLGENcontext *) gc;
    PIXELFORMATDESCRIPTOR *pfmt = &gengc->gsurf.pfd;
    GLint index;

    switch (pfmt->cColorBits) {
      case 8:
        index = 0;
        break;
      case 16:
        index = 1;
        break;
      case 24:
        if (pfmt->cRedShift == 0)
            index = 2;
        else
            index = 3;
        break;
      case 32:
        index = 4;
        break;
    }
    if (gc->polygon.shader.modeFlags & __GL_SHADE_RGB)
        index |= 0x08;
        
    if (gc->state.line.aliasedWidth > 1)
        index |= 0x10;

    gc->procs.renderLine = __fastGenRenderLineDIBFuncs[index];
    return TRUE;
}

void FASTCALL __fastGenRenderLineDIBRGB8(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle;
    unsigned char *addr, pixel;
    GLint x, y;

    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    pixel = (unsigned char) __fastLineComputeColorRGB8(gc, v1->color);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr       = (unsigned char *) ((GLint)cfb->buf.base + x +
                                    (y * cfb->buf.outerWidth));

    addrLittle = gc->line.options.xLittle +
                 (gc->line.options.yLittle * cfb->buf.outerWidth);

    addrBig    = gc->line.options.xBig +
                 (gc->line.options.yBig * cfb->buf.outerWidth);
           
    __FAST_LINE_STROKE_DIB
}

void FASTCALL __fastGenRenderLineDIBRGB16(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle;
    unsigned short *addr, pixel;
    GLint x, y, outerWidth_2;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    pixel = (unsigned short) __fastLineComputeColorRGB(gc, v1->color);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr       = (unsigned short *) ((GLint)cfb->buf.base + (x << 1) +
                                     (y * cfb->buf.outerWidth));

    outerWidth_2 = cfb->buf.outerWidth >> 1;

    addrLittle = gc->line.options.xLittle +
                 (gc->line.options.yLittle * outerWidth_2);

    addrBig    = gc->line.options.xBig +
                 (gc->line.options.yBig * outerWidth_2);
           
    __FAST_LINE_STROKE_DIB
}

void FASTCALL __fastGenRenderLineDIBRGB(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction;
    __GLcolor *cp;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle;
    unsigned char *addr, ir, ig, ib;
    GLint x, y;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    cp = v1->color;
    ir = (unsigned char) cp->r;
    ig = (unsigned char) cp->g;
    ib = (unsigned char) cp->b;
    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr       = (unsigned char *) ((GLint)cfb->buf.base + (x * 3) +
                                    (y * cfb->buf.outerWidth));
                                    
    addrLittle = (gc->line.options.xLittle * 3) +
                 (gc->line.options.yLittle * cfb->buf.outerWidth);

    addrBig    = (gc->line.options.xBig * 3) +
                 (gc->line.options.yBig * cfb->buf.outerWidth);
           
    __FAST_LINE_STROKE_DIB24
}

void FASTCALL __fastGenRenderLineDIBBGR(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction;
    __GLcolor *cp;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle;
    unsigned char *addr, ir, ig, ib;
    GLint x, y;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    cp = v1->color;
    ir = (unsigned char) cp->b;
    ig = (unsigned char) cp->g;
    ib = (unsigned char) cp->r;
    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr       = (unsigned char *) ((GLint)cfb->buf.base + (x * 3) +
                                    (y * cfb->buf.outerWidth));

    addrLittle = (gc->line.options.xLittle * 3) +
                 (gc->line.options.yLittle * cfb->buf.outerWidth);

    addrBig    = (gc->line.options.xBig * 3) +
                 (gc->line.options.yBig * cfb->buf.outerWidth);
           
    __FAST_LINE_STROKE_DIB24
}

void FASTCALL __fastGenRenderLineDIBRGB32(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle;
    unsigned long *addr, pixel;
    GLint x, y, outerWidth_4;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    pixel = __fastLineComputeColorRGB(gc, v1->color);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr = (unsigned long *) ((GLint)cfb->buf.base + (x << 2) +
                              (y * cfb->buf.outerWidth));

    outerWidth_4 = cfb->buf.outerWidth >> 2;
    
    addrLittle = gc->line.options.xLittle +
                 (gc->line.options.yLittle * outerWidth_4);

    addrBig    = gc->line.options.xBig +
                 (gc->line.options.yBig * outerWidth_4);
           
    __FAST_LINE_STROKE_DIB
}

void FASTCALL __fastGenRenderLineDIBCI8(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle;
    unsigned char *addr, pixel;
    GLint x, y;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    pixel = (unsigned char) __fastLineComputeColorCI4and8(gc, v1->color);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr       = (unsigned char *) ((GLint)cfb->buf.base + x +
                                    (y * cfb->buf.outerWidth));

    addrLittle = gc->line.options.xLittle +
                 (gc->line.options.yLittle * cfb->buf.outerWidth);

    addrBig    = gc->line.options.xBig +
                 (gc->line.options.yBig * cfb->buf.outerWidth);
           
    __FAST_LINE_STROKE_DIB
}

void FASTCALL __fastGenRenderLineDIBCI16(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle;
    unsigned short *addr, pixel;
    GLint x, y, outerWidth_2;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    pixel = (unsigned short) __fastLineComputeColorCI(gc, v1->color);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr = (unsigned short *) ((GLint)cfb->buf.base + (x << 1) +
                               (y * cfb->buf.outerWidth));

    outerWidth_2 = cfb->buf.outerWidth >> 1;
    
    addrLittle = gc->line.options.xLittle +
                 (gc->line.options.yLittle * outerWidth_2);

    addrBig    = gc->line.options.xBig +
                 (gc->line.options.yBig * outerWidth_2);
           
    __FAST_LINE_STROKE_DIB
}

/*
** XXX GRE swabs bytes in palette, DIBCIRGB & DIBCIBGR are identical now
*/
void FASTCALL __fastGenRenderLineDIBCIRGB(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle;
    unsigned char *addr, ir, ig, ib;
    unsigned long pixel;
    GLint x, y;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    // Red is lsb of pixel
    pixel = __fastLineComputeColorCI(gc, v1->color);
    ir = (unsigned char) (pixel & 0xff);
    ig = (unsigned char) ((pixel >> 8) & 0xff);
    ib = (unsigned char) ((pixel >> 16) & 0xff);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr       = (unsigned char *) ((GLint)cfb->buf.base + (x * 3) +
                                    (y * cfb->buf.outerWidth));

    addrLittle = (gc->line.options.xLittle * 3) +
                 (gc->line.options.yLittle * cfb->buf.outerWidth);

    addrBig    = (gc->line.options.xBig * 3) +
                 (gc->line.options.yBig * cfb->buf.outerWidth);
           
    __FAST_LINE_STROKE_DIB24
}

void FASTCALL __fastGenRenderLineDIBCIBGR(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle;
    unsigned char *addr, ir, ig, ib;
    unsigned long pixel;
    GLint x, y;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    // Blue is lsb of pixel
    pixel = __fastLineComputeColorCI(gc, v1->color);
    // Swap blue and red
    ir = (unsigned char) (pixel & 0xff);
    ig = (unsigned char) ((pixel >> 8) & 0xff);
    ib = (unsigned char) ((pixel >> 16) & 0xff);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr       = (unsigned char *) ((GLint)cfb->buf.base + (x * 3) +
                                    (y * cfb->buf.outerWidth));

    addrLittle = (gc->line.options.xLittle * 3) +
                 (gc->line.options.yLittle * cfb->buf.outerWidth);

    addrBig    = (gc->line.options.xBig * 3) +
                 (gc->line.options.yBig * cfb->buf.outerWidth);
           
    __FAST_LINE_STROKE_DIB24
}

void FASTCALL __fastGenRenderLineDIBCI32(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle;
    unsigned long *addr, pixel;
    GLint x, y, outerWidth_4;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    pixel = __fastLineComputeColorCI(gc, v1->color);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr = (unsigned long *) ((GLint)cfb->buf.base + (x << 2) +
                              (y * cfb->buf.outerWidth));

    outerWidth_4 = cfb->buf.outerWidth >> 2;
    
    addrLittle = gc->line.options.xLittle +
                 (gc->line.options.yLittle * outerWidth_4);

    addrBig    = gc->line.options.xBig +
                 (gc->line.options.yBig * outerWidth_4);
           
    __FAST_LINE_STROKE_DIB
}

void FASTCALL __fastGenRenderLineWideDIBRGB8(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction, width, w;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle, addrMinor;
    unsigned char *addr, pixel;
    GLint x, y;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    pixel = (unsigned char) __fastLineComputeColorRGB8(gc, v1->color);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr = (unsigned char *) ((GLint)cfb->buf.base + x +
                              (y * cfb->buf.outerWidth));

    width = gc->line.options.width;
    if (gc->line.options.axis == __GL_X_MAJOR) {
        addrMinor  = cfb->buf.outerWidth;

        addrLittle = gc->line.options.xLittle +
                     ((gc->line.options.yLittle - width) * cfb->buf.outerWidth);

        addrBig    = gc->line.options.xBig +
                     ((gc->line.options.yBig - width) * cfb->buf.outerWidth);
    } else {
        addrMinor  = 1;

        addrLittle = gc->line.options.xLittle - width +
                     (gc->line.options.yLittle * cfb->buf.outerWidth);

        addrBig    = gc->line.options.xBig - width +
                     (gc->line.options.yBig * cfb->buf.outerWidth);
    }           
    __FAST_LINE_STROKE_DIB_WIDE
}

void FASTCALL __fastGenRenderLineWideDIBRGB16(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction, width, w;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle, addrMinor;
    unsigned short *addr, pixel;
    GLint x, y, outerWidth_2;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    pixel = (unsigned short) __fastLineComputeColorRGB(gc, v1->color);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr = (unsigned short *) ((GLint)cfb->buf.base + (x << 1) +
                               (y * cfb->buf.outerWidth));

    width = gc->line.options.width;
    outerWidth_2 = cfb->buf.outerWidth >> 1;

    if (gc->line.options.axis == __GL_X_MAJOR) {
        addrMinor  = outerWidth_2;

        addrLittle = gc->line.options.xLittle +
                     ((gc->line.options.yLittle - width) * outerWidth_2);

        addrBig    = gc->line.options.xBig +
                     ((gc->line.options.yBig - width) * outerWidth_2);
    } else {
        addrMinor  = 1;

        addrLittle = gc->line.options.xLittle - width +
                     (gc->line.options.yLittle * outerWidth_2);

        addrBig    = gc->line.options.xBig - width +
                     (gc->line.options.yBig * outerWidth_2);
    }           
    __FAST_LINE_STROKE_DIB_WIDE
}

void FASTCALL __fastGenRenderLineWideDIBRGB(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction, width, w;
    __GLcolor *cp;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle, addrMinor;
    unsigned char *addr, ir, ig, ib;
    GLint x, y;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    cp = v1->color;
    ir = (unsigned char) cp->r;
    ig = (unsigned char) cp->g;
    ib = (unsigned char) cp->b;
    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr = (unsigned char *) ((GLint)cfb->buf.base + (x * 3) +
                              (y * cfb->buf.outerWidth));

    width = gc->line.options.width;
    if (gc->line.options.axis == __GL_X_MAJOR) {
        addrMinor  = cfb->buf.outerWidth;

        addrLittle = (gc->line.options.xLittle * 3) +
                     ((gc->line.options.yLittle - width) * cfb->buf.outerWidth);

        addrBig    = (gc->line.options.xBig * 3) +
                     ((gc->line.options.yBig - width) * cfb->buf.outerWidth);
    } else {
        addrMinor  = 3;

        addrLittle = ((gc->line.options.xLittle - width) * 3) +
                     (gc->line.options.yLittle * cfb->buf.outerWidth);

        addrBig    = ((gc->line.options.xBig - width) * 3) +
                     (gc->line.options.yBig * cfb->buf.outerWidth);
    }           
    __FAST_LINE_STROKE_DIB24_WIDE
}

void FASTCALL __fastGenRenderLineWideDIBBGR(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction, width, w;
    __GLcolor *cp;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle, addrMinor;
    unsigned char *addr, ir, ig, ib;
    GLint x, y;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    cp = v1->color;
    ir = (unsigned char) cp->b;
    ig = (unsigned char) cp->g;
    ib = (unsigned char) cp->r;
    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr = (unsigned char *) ((GLint)cfb->buf.base + (x * 3) +
                              (y * cfb->buf.outerWidth));

    width = gc->line.options.width;
    if (gc->line.options.axis == __GL_X_MAJOR) {
        addrMinor  = cfb->buf.outerWidth;

        addrLittle = (gc->line.options.xLittle * 3) +
                     ((gc->line.options.yLittle - width) * cfb->buf.outerWidth);

        addrBig    = (gc->line.options.xBig * 3) +
                     ((gc->line.options.yBig - width) * cfb->buf.outerWidth);
    } else {
        addrMinor  = 3;

        addrLittle = ((gc->line.options.xLittle - width) * 3) +
                     (gc->line.options.yLittle * cfb->buf.outerWidth);

        addrBig    = ((gc->line.options.xBig - width) * 3) +
                     (gc->line.options.yBig * cfb->buf.outerWidth);
    }           
    __FAST_LINE_STROKE_DIB24_WIDE
}

void FASTCALL __fastGenRenderLineWideDIBRGB32(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction, width, w;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle, addrMinor;
    unsigned long *addr, pixel;
    GLint x, y, outerWidth_4;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    pixel = __fastLineComputeColorRGB(gc, v1->color);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr = (unsigned long *) ((GLint)cfb->buf.base + (x << 2) +
                              (y * cfb->buf.outerWidth));

    width = gc->line.options.width;
    outerWidth_4 = cfb->buf.outerWidth >> 2;

    if (gc->line.options.axis == __GL_X_MAJOR) {
        addrMinor  = outerWidth_4;

        addrLittle = gc->line.options.xLittle +
                     ((gc->line.options.yLittle - width) * outerWidth_4);

        addrBig    = gc->line.options.xBig +
                     ((gc->line.options.yBig - width) * outerWidth_4);
    } else {
        addrMinor  = 1;

        addrLittle = gc->line.options.xLittle - width +
                     (gc->line.options.yLittle * outerWidth_4);

        addrBig    = gc->line.options.xBig - width +
                     (gc->line.options.yBig * outerWidth_4);
    }           
    __FAST_LINE_STROKE_DIB_WIDE
}

void FASTCALL __fastGenRenderLineWideDIBCI8(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction, width, w;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle, addrMinor;
    unsigned char *addr, pixel;
    GLint x, y;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    pixel = (unsigned char) __fastLineComputeColorCI4and8(gc, v1->color);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr = (unsigned char *) ((GLint)cfb->buf.base + x +
                              (y * cfb->buf.outerWidth));

    width = gc->line.options.width;
    if (gc->line.options.axis == __GL_X_MAJOR) {
        addrMinor  = cfb->buf.outerWidth;

        addrLittle = gc->line.options.xLittle +
                     ((gc->line.options.yLittle - width) * cfb->buf.outerWidth);

        addrBig    = gc->line.options.xBig +
                     ((gc->line.options.yBig - width) * cfb->buf.outerWidth);
    } else {
        addrMinor  = 1;

        addrLittle = gc->line.options.xLittle - width +
                     (gc->line.options.yLittle * cfb->buf.outerWidth);

        addrBig    = gc->line.options.xBig - width +
                     (gc->line.options.yBig * cfb->buf.outerWidth);
    }           
    __FAST_LINE_STROKE_DIB_WIDE
}

void FASTCALL __fastGenRenderLineWideDIBCI16(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction, width, w;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle, addrMinor;
    unsigned short *addr, pixel;
    GLint x, y, outerWidth_2;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    pixel = (unsigned short) __fastLineComputeColorCI(gc, v1->color);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr = (unsigned short *) ((GLint)cfb->buf.base + (x << 1) +
                               (y * cfb->buf.outerWidth));

    width = gc->line.options.width;
    outerWidth_2 = cfb->buf.outerWidth >> 1;

    if (gc->line.options.axis == __GL_X_MAJOR) {
        addrMinor  = outerWidth_2;

        addrLittle = gc->line.options.xLittle +
                     ((gc->line.options.yLittle - width) * outerWidth_2);

        addrBig    = gc->line.options.xBig +
                     ((gc->line.options.yBig - width) * outerWidth_2);
    } else {
        addrMinor  = 1;

        addrLittle = gc->line.options.xLittle - width +
                     (gc->line.options.yLittle * outerWidth_2);

        addrBig    = gc->line.options.xBig - width +
                     (gc->line.options.yBig * outerWidth_2);
    }           
    __FAST_LINE_STROKE_DIB_WIDE
}

void FASTCALL __fastGenRenderLineWideDIBCIRGB(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction, width, w;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle, addrMinor;
    unsigned char *addr, ir, ig, ib;
    unsigned long pixel;
    GLint x, y;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    // Red is lsb of pixel
    pixel = __fastLineComputeColorCI(gc, v1->color);
    ir = (unsigned char) (pixel & 0xff);
    ig = (unsigned char) ((pixel >> 8) & 0xff);
    ib = (unsigned char) ((pixel >> 16) & 0xff);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr = (unsigned char *) ((GLint)cfb->buf.base + (x * 3) +
                              (y * cfb->buf.outerWidth));

    width = gc->line.options.width;
    if (gc->line.options.axis == __GL_X_MAJOR) {
        addrMinor  = cfb->buf.outerWidth;

        addrLittle = (gc->line.options.xLittle * 3) +
                     ((gc->line.options.yLittle - width) * cfb->buf.outerWidth);

        addrBig    = (gc->line.options.xBig * 3) +
                     ((gc->line.options.yBig - width) * cfb->buf.outerWidth);
    } else {
        addrMinor  = 3;

        addrLittle = ((gc->line.options.xLittle - width) * 3) +
                     (gc->line.options.yLittle * cfb->buf.outerWidth);

        addrBig    = ((gc->line.options.xBig - width) * 3) +
                     (gc->line.options.yBig * cfb->buf.outerWidth);
    }           
    __FAST_LINE_STROKE_DIB24_WIDE
}

void FASTCALL __fastGenRenderLineWideDIBCIBGR(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction, width, w;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle, addrMinor;
    unsigned char *addr, ir, ig, ib;
    unsigned long pixel;
    GLint x, y;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    // Blue is lsb of pixel
    pixel = __fastLineComputeColorCI(gc, v1->color);
    // Swap blue and red
    ir = (unsigned char) (pixel & 0xff);
    ig = (unsigned char) ((pixel >> 8) & 0xff);
    ib = (unsigned char) ((pixel >> 16) & 0xff);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr = (unsigned char *) ((GLint)cfb->buf.base + (x * 3) +
                              (y * cfb->buf.outerWidth));

    width = gc->line.options.width;
    if (gc->line.options.axis == __GL_X_MAJOR) {
        addrMinor  = cfb->buf.outerWidth;

        addrLittle = (gc->line.options.xLittle * 3) +
                     ((gc->line.options.yLittle - width) * cfb->buf.outerWidth);

        addrBig    = (gc->line.options.xBig * 3) +
                     ((gc->line.options.yBig - width) * cfb->buf.outerWidth);
    } else {
        addrMinor  = 3;

        addrLittle = ((gc->line.options.xLittle - width) * 3) +
                     (gc->line.options.yLittle * cfb->buf.outerWidth);

        addrBig    = ((gc->line.options.xBig - width) * 3) +
                     (gc->line.options.yBig * cfb->buf.outerWidth);
    }           
    __FAST_LINE_STROKE_DIB24_WIDE
}

void FASTCALL __fastGenRenderLineWideDIBCI32(__GLcontext *gc, __GLvertex *v0, __GLvertex *v1)
{
    GLint len, fraction, dfraction, width, w;
    __GLcolorBuffer *cfb;
    GLint addrBig, addrLittle, addrMinor;
    unsigned long *addr, pixel;
    GLint x, y, outerWidth_4;
    
    GLboolean init;
    CHOP_ROUND_ON();
    init = __glInitLineData(gc, v0, v1);
    CHOP_ROUND_OFF();
    if (!init) return;

    pixel = __fastLineComputeColorCI(gc, v1->color);

    cfb = gc->drawBuffer;
    x = __GL_UNBIAS_X(gc, gc->line.options.xStart) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, gc->line.options.yStart) + cfb->buf.yOrigin;
    addr = (unsigned long *) ((GLint)cfb->buf.base + (x << 2) +
                              (y * cfb->buf.outerWidth));

    width = gc->line.options.width;
    outerWidth_4 = cfb->buf.outerWidth >> 2;

    if (gc->line.options.axis == __GL_X_MAJOR) {
        addrMinor  = outerWidth_4;

        addrLittle = gc->line.options.xLittle +
                     ((gc->line.options.yLittle - width) * outerWidth_4);

        addrBig    = gc->line.options.xBig +
                     ((gc->line.options.yBig - width) * outerWidth_4);
    } else {
        addrMinor  = 1;

        addrLittle = gc->line.options.xLittle - width +
                     (gc->line.options.yLittle * outerWidth_4);

        addrBig    = gc->line.options.xBig - width +
                     (gc->line.options.yBig * outerWidth_4);
    }           
    __FAST_LINE_STROKE_DIB_WIDE
}

#endif //NT_NO_BUFFER_INVARIANCE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\genrgb.h ===
/******************************Module*Header*******************************\
* Module Name: genrgb.h
*
* Copyright (c) 1992 Microsoft Corporation
*
\**************************************************************************/

#ifndef __GENRGB_H__
#define __GENRGB_H__

extern void FASTCALL __glGenInitRGB(__GLcontext *glGc, __GLcolorBuffer *Cfb , GLenum type );
extern void FASTCALL __glGenFreeRGB(__GLcontext *glGc, __GLcolorBuffer *Cfb );

#define DITHER_INC(i) (((__GLfloat) (((i) << 1) + 1)) / (__GLfloat) (2 * __GL_DITHER_PRECISION))

extern __GLfloat fDitherIncTable[];

#endif /* !__GENRGB_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\genpxapi.c ===
#include "precomp.h"
#pragma hdrstop

#include "devlock.h"

GLboolean __glGenCheckDrawPixelArgs(__GLcontext *gc,
        GLsizei width, GLsizei height, GLenum format, GLenum type)
{
    GLboolean index;

    if ((width < 0) || (height < 0)) {
        __glSetError(GL_INVALID_VALUE);
        return GL_FALSE;
    }
    switch (format) {
      case GL_STENCIL_INDEX:
        if (!gc->modes.stencilBits) {
            __glSetError(GL_INVALID_OPERATION);
            return GL_FALSE;
        }
        if (!gc->modes.haveStencilBuffer) {
            LazyAllocateStencil(gc);
            if (!gc->stencilBuffer.buf.base) {
                return GL_FALSE;
            }
        }
        index = GL_TRUE;
        break;
      case GL_COLOR_INDEX:
        index = GL_TRUE;
        break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
        if (gc->modes.colorIndexMode) {
            /* Can't convert RGB to color index */
            __glSetError(GL_INVALID_OPERATION);
            return GL_FALSE;
        }
        index = GL_FALSE;
        break;
      case GL_DEPTH_COMPONENT:
        if (!gc->modes.depthBits) {
            __glSetError(GL_INVALID_OPERATION);
            return GL_FALSE;
        }
        if (!gc->modes.haveDepthBuffer) {
            LazyAllocateDepth(gc);
            if (!gc->depthBuffer.buf.base) {
                return GL_FALSE;
            }
        }
        index = GL_FALSE;
        break;
      default:
        __glSetError(GL_INVALID_ENUM);
        return GL_FALSE;
    }
    switch (type) {
      case GL_BITMAP:
        if (!index) {
            __glSetError(GL_INVALID_ENUM);
            return GL_FALSE;
        }
        break;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
        break;
      default:
        __glSetError(GL_INVALID_ENUM);
        return GL_FALSE;
    }
    return GL_TRUE;
}

GLboolean __glGenCheckReadPixelArgs(__GLcontext *gc,
        GLsizei width, GLsizei height, GLenum format, GLenum type)
{
    if ((width < 0) || (height < 0)) {
        __glSetError(GL_INVALID_VALUE);
        return GL_FALSE;
    }
    switch (format) {
      case GL_STENCIL_INDEX:
        if (!gc->modes.stencilBits) {
            __glSetError(GL_INVALID_OPERATION);
            return GL_FALSE;
        }
        if (!gc->modes.haveStencilBuffer) {
            LazyAllocateStencil(gc);
            if (!gc->stencilBuffer.buf.base) {
                return GL_FALSE;
            }
        }
        break;
      case GL_COLOR_INDEX:
        if (gc->modes.rgbMode) {
            /* Can't convert RGB to color index */
            __glSetError(GL_INVALID_OPERATION);
            return GL_FALSE;
        }
        break;
      case GL_DEPTH_COMPONENT:
        if (!gc->modes.depthBits) {
            __glSetError(GL_INVALID_OPERATION);
            return GL_FALSE;
        }
        if (!gc->modes.haveDepthBuffer) {
            LazyAllocateDepth(gc);
            if (!gc->depthBuffer.buf.base) {
                return GL_FALSE;
            }
        }
        break;
      case GL_RED:
      case GL_GREEN:
      case GL_BLUE:
      case GL_ALPHA:
      case GL_RGB:
      case GL_RGBA:
      case GL_LUMINANCE:
      case GL_LUMINANCE_ALPHA:
#ifdef GL_EXT_bgra
      case GL_BGRA_EXT:
      case GL_BGR_EXT:
#endif
        break;
      default:
        __glSetError(GL_INVALID_ENUM);
        return GL_FALSE;
    }
    switch (type) {
      case GL_BITMAP:
        if (format != GL_STENCIL_INDEX && format != GL_COLOR_INDEX) {
            __glSetError(GL_INVALID_OPERATION);
            return GL_FALSE;
        }
        break;
      case GL_BYTE:
      case GL_UNSIGNED_BYTE:
      case GL_SHORT:
      case GL_UNSIGNED_SHORT:
      case GL_INT:
      case GL_UNSIGNED_INT:
      case GL_FLOAT:
        break;
      default:
        __glSetError(GL_INVALID_ENUM);
        return GL_FALSE;
    }
    return GL_TRUE;
}

#ifdef NT
void APIPRIVATE __glim_DrawPixels(GLsizei width, GLsizei height, GLenum format,
                       GLenum type, const GLvoid *pixels, GLboolean _IsDlist)
#else
void APIPRIVATE __glim_DrawPixels(GLsizei width, GLsizei height, GLenum format,
                       GLenum type, const GLvoid *pixels)
#endif
{
    __GL_SETUP();
    GLuint beginMode;
    BOOL bResetViewportAdj = FALSE;

    beginMode = gc->beginMode;
    if (beginMode != __GL_NOT_IN_BEGIN) {
        if (beginMode == __GL_NEED_VALIDATE) {
            (*gc->procs.validate)(gc);
            gc->beginMode = __GL_NOT_IN_BEGIN;
            __glim_DrawPixels(width, height, format,
                type, pixels, _IsDlist);
            return;
        } else {
            __glSetError(GL_INVALID_OPERATION);
            return;
        }
    }

    if (!__glGenCheckDrawPixelArgs(gc, width, height, format, type)) return;
    if (!gc->state.current.validRasterPos) {
        return;
    }

    if (gc->renderMode == GL_FEEDBACK) {
        __glFeedbackDrawPixels(gc, &gc->state.current.rasterPos);
        return;
    }

    if (gc->renderMode != GL_RENDER)
        return;

#ifdef _MCD_
    // If MCD context, give driver first crack at call.  If it succeeds,
    // return.  Otherwise, continue on with the generic version.

    {
        __GLGENcontext *gengc = (__GLGENcontext *) gc;

        if (gengc->pMcdState) {
            if (GenMcdDrawPix(gengc, width, height, format, type,
                              (VOID *) pixels, _IsDlist))
                return;

        // If MCD kicked back, now is the time to grab the device lock if
        // needed.  If we can't, abandon the call.

            if (!glsrvLazyGrabSurfaces(gengc, RENDER_LOCK_FLAGS))
                return;

        // We may need to temporarily reset the viewport adjust values
        // before calling simulations.  If GenMcdResetViewportAdj returns
        // TRUE, the viewport is changed and we need restore later with
        // VP_NOBIAS.

            bResetViewportAdj = GenMcdResetViewportAdj(gc, VP_FIXBIAS);
        }
    }
#endif

#ifdef NT
    if (_IsDlist)
    {
        (*gc->procs.drawPixels)(gc, width, height, format, type, pixels, GL_TRUE);
    }
    else
    {
#endif
        (*gc->procs.drawPixels)(gc, width, height, format, type, pixels, GL_FALSE);
#ifdef NT
    }
#endif

// Restore viewport values if needed.

    if (bResetViewportAdj)
    {
        GenMcdResetViewportAdj(gc, VP_NOBIAS);
    }
}

void APIPRIVATE __glim_ReadPixels(GLint x, GLint y, GLsizei width, GLsizei height,
                       GLenum format, GLenum type, GLvoid *buf)
{
    __GL_SETUP();
    GLuint beginMode;
    BOOL bResetViewportAdj = FALSE;

    beginMode = gc->beginMode;
    if (beginMode != __GL_NOT_IN_BEGIN) {
        if (beginMode == __GL_NEED_VALIDATE) {
            (*gc->procs.validate)(gc);
            gc->beginMode = __GL_NOT_IN_BEGIN;
            __glim_ReadPixels(x,y,width,height,
                    format,type,buf);
            return;
        } else {
            __glSetError(GL_INVALID_OPERATION);
            return;
        }
    }

    if (!__glGenCheckReadPixelArgs(gc, width, height, format, type))
        return;

#ifdef _MCD_
    // If MCD context, give driver first crack at call.  If it succeeds,
    // return.  Otherwise, continue on with the generic version.

    {
        __GLGENcontext *gengc = (__GLGENcontext *) gc;

        if (gengc->pMcdState) {
            if (GenMcdReadPix(gengc, x, y, width, height, format, type, buf))
                return;

        // If MCD kicked back, now is the time to grab the device lock if
        // needed.  If we can't, abandon the call.

            if (!glsrvLazyGrabSurfaces(gengc, 
				       COLOR_LOCK_FLAGS | DEPTH_LOCK_FLAGS))
                return;

        // We may need to temporarily reset the viewport adjust values
        // before calling simulations.  If GenMcdResetViewportAdj returns
        // TRUE, the viewport is changed and we need restore later with
        // VP_NOBIAS.

            bResetViewportAdj = GenMcdResetViewportAdj(gc, VP_FIXBIAS);
        }
    }
#endif

    (*gc->procs.readPixels)(gc, x, y, width, height, format, type, buf);

// Restore viewport values if needed.

    if (bResetViewportAdj)
    {
        GenMcdResetViewportAdj(gc, VP_NOBIAS);
    }
}

void APIPRIVATE __glim_CopyPixels(GLint x, GLint y, GLsizei width, GLsizei height,
                       GLenum type)
{
    GLenum format;
    __GL_SETUP();
    GLuint beginMode;
    BOOL bResetViewportAdj = FALSE;

    beginMode = gc->beginMode;
    if (beginMode != __GL_NOT_IN_BEGIN) {
        if (beginMode == __GL_NEED_VALIDATE) {
            (*gc->procs.validate)(gc);
            gc->beginMode = __GL_NOT_IN_BEGIN;
            __glim_CopyPixels(x,y,width,height,type);
            return;
        } else {
            __glSetError(GL_INVALID_OPERATION);
            return;
        }
    }

    if ((width < 0) || (height < 0)) {
        __glSetError(GL_INVALID_VALUE);
        return;
    }
    switch (type) {
      case GL_STENCIL:
        if (!gc->modes.stencilBits) {
            __glSetError(GL_INVALID_OPERATION);
            return;
        }
        if (!gc->modes.haveStencilBuffer) {
            LazyAllocateStencil(gc);
            if (!gc->stencilBuffer.buf.base) {
                return;
            }
        }
        format = GL_STENCIL_INDEX;
        break;
      case GL_COLOR:
        if (gc->modes.rgbMode) {
            format = GL_RGBA;
        } else {
            format = GL_COLOR_INDEX;
        }
        break;
      case GL_DEPTH:
        if (!gc->modes.depthBits) {
            __glSetError(GL_INVALID_OPERATION);
            return;
        }
        if (!gc->modes.haveDepthBuffer) {
            LazyAllocateDepth(gc);
            if (!gc->depthBuffer.buf.base) {
                return;
            }
        }
        format = GL_DEPTH_COMPONENT;
        break;
      default:
        __glSetError(GL_INVALID_ENUM);
        return;
    }

    if (!gc->state.current.validRasterPos) {
        return;
    }

    if (gc->renderMode == GL_FEEDBACK) {
        __glFeedbackCopyPixels(gc, &gc->state.current.rasterPos);
        return;
    }

    if (gc->renderMode != GL_RENDER)
        return;

#ifdef _MCD_
    // If MCD context, give driver first crack at call.  If it succeeds,
    // return.  Otherwise, continue on with the generic version.

    {
        __GLGENcontext *gengc = (__GLGENcontext *) gc;

        if (gengc->pMcdState) {
            if (GenMcdCopyPix(gengc, x, y, width, height, type))
                return;

        // If MCD kicked back, now is the time to grab the device lock if
        // needed.  If we can't, abandon the call.

            if (!glsrvLazyGrabSurfaces(gengc, RENDER_LOCK_FLAGS))
                return;

        // We may need to temporarily reset the viewport adjust values
        // before calling simulations.  If GenMcdResetViewportAdj returns
        // TRUE, the viewport is changed and we need restore later with
        // VP_NOBIAS.

            bResetViewportAdj = GenMcdResetViewportAdj(gc, VP_FIXBIAS);
        }
    }
#endif

    (*gc->procs.copyPixels)(gc, x, y, width, height, format);

// Restore viewport values if needed.

    if (bResetViewportAdj)
    {
        GenMcdResetViewportAdj(gc, VP_NOBIAS);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\genspan.c ===
/******************************Module*Header*******************************\
* Module Name: genspan.c                                                   *
*                                                                          *
* This module accelerates common spans.                                    *
*                                                                          *
* Created: 24-Feb-1994                                                     *
* Author: Otto Berkes [ottob]                                              *
*                                                                          *
* Copyright (c) 1994 Microsoft Corporation                                 *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

/*******************************************************/

void FASTCALL __fastGenDeltaSpan(__GLcontext *gc, SPANREC *spanDelta)
{
    GLuint modeflags = gc->polygon.shader.modeFlags;
    GENACCEL *pGenAccel = (GENACCEL *)(((__GLGENcontext *)gc)->pPrivateArea);

    if (modeflags & __GL_SHADE_RGB) {
        if ((modeflags & __GL_SHADE_TEXTURE) && (pGenAccel->texImage)) {
            if (modeflags & __GL_SHADE_SMOOTH) {
                pGenAccel->spanDelta.r = spanDelta->r;
                pGenAccel->spanDelta.g = spanDelta->g;
                pGenAccel->spanDelta.b = spanDelta->b;
            } else {
                pGenAccel->spanDelta.r = 0;
                pGenAccel->spanDelta.g = 0;
                pGenAccel->spanDelta.b = 0;
            }
            pGenAccel->spanDelta.s = spanDelta->s;
            pGenAccel->spanDelta.t = spanDelta->t;

            pGenAccel->__fastSpanFuncPtr = pGenAccel->__fastTexSpanFuncPtr;

        } else if (modeflags & __GL_SHADE_SMOOTH) {
            if (   ((spanDelta->r | spanDelta->g | spanDelta->b) == 0)
                && ((pGenAccel->flags & GEN_FASTZBUFFER) == 0)
               ) {
                pGenAccel->spanDelta.r = 0;
                pGenAccel->spanDelta.g = 0;
                pGenAccel->spanDelta.b = 0;
                pGenAccel->__fastSpanFuncPtr = 
                    pGenAccel->__fastFlatSpanFuncPtr;
            } else {
                pGenAccel->spanDelta.r = spanDelta->r;
                pGenAccel->spanDelta.g = spanDelta->g;
                pGenAccel->spanDelta.b = spanDelta->b;
                pGenAccel->__fastSpanFuncPtr = 
                    pGenAccel->__fastSmoothSpanFuncPtr;
            }                
        } else {
            pGenAccel->__fastSpanFuncPtr = pGenAccel->__fastFlatSpanFuncPtr;
        } 
    } else {
        if (modeflags & __GL_SHADE_SMOOTH) {
            if (spanDelta->r == 0) {
                pGenAccel->spanDelta.r = 0;
                pGenAccel->__fastSpanFuncPtr = 
                    pGenAccel->__fastFlatSpanFuncPtr;
            } else {
                pGenAccel->spanDelta.r = spanDelta->r;
                pGenAccel->__fastSpanFuncPtr = 
                    pGenAccel->__fastSmoothSpanFuncPtr;
            }                
        } else {
            pGenAccel->__fastSpanFuncPtr = pGenAccel->__fastFlatSpanFuncPtr;
        } 
    }

#ifdef LATER
    pGenAccel->spanDelta.r = spanDelta->r;
    pGenAccel->spanDelta.g = spanDelta->g;
    pGenAccel->spanDelta.b = spanDelta->b;
    pGenAccel->spanDelta.s = spanDelta->s;
    pGenAccel->spanDelta.t = spanDelta->t;
    if (  modeflags & (__GL_SHADE_RGB | __GL_SHADE_TEXTURE | __GL_SHADE_SMOOTH) ==
          __GL_SHADE_RGB | __GL_SHADE_TEXTURE
       ) {
        pGenAccel->spanDelta.r = 0;
        pGenAccel->spanDelta.g = 0;
        pGenAccel->spanDelta.b = 0;
    } else
    if (  modeflags & (__GL_SHADE_RGB | __GL_SHADE_TEXTURE | __GL_SHADE_SMOOTH) ==
          __GL_SHADE_RGB | __GL_SHADE_SMOOTH
       ) {
        if ((spanDelta->r | spanDelta->g | spanDelta->b) == 0) {
            pGenAccel->__fastSpanFuncPtr =
                pGenAccel->__fastFlatSpanFuncPtr;
        } else {
            pGenAccel->__fastSpanFuncPtr =
                pGenAccel->__fastSmoothSpanFuncPtr;
        }
    }
#endif
}

/*******************************************************/

#define ZBUF_PROC(type, pass_cond) \
GLboolean FASTCALL __fastGenDepthTestSpan##type(__GLcontext *gc)\
{\
    register GLuint zAccum = gc->polygon.shader.frag.z;\
    register GLint zDelta = gc->polygon.shader.dzdx;\
    register GLuint *zbuf = gc->polygon.shader.zbuf;\
    register GLuint *pStipple = gc->polygon.shader.stipplePat;\
    register GLint cTotalPix = gc->polygon.shader.length;\
    register GLuint mask;\
    register GLint cPix;\
    register GLint zPasses = 0;\
    register GLuint maskBit;\
\
    for (;cTotalPix > 0; cTotalPix-=32) {\
        mask = 0;\
        maskBit = 0x80000000;\
        cPix = cTotalPix;\
        if (cPix > 32)\
            cPix = 32;\
\
        for (;cPix > 0; cPix --) {\
            if ((zAccum) pass_cond (*zbuf)) {\
                *zbuf = zAccum;\
                zPasses++;\
                mask |= maskBit;\
            }\
            *zbuf++;\
            zAccum += zDelta;\
            maskBit >>= 1;\
        }\
\
        *pStipple++ = mask;\
    }\
\
    if (zPasses == 0) {\
        gc->polygon.shader.done = TRUE;\
        return 1;\
    } else if (zPasses == gc->polygon.shader.length) {\
        return 0;\
    } else {\
        return 2;\
    }\
}

#define ZBUF16_PROC(type, pass_cond) \
GLboolean FASTCALL __fastGenDepth16TestSpan##type(__GLcontext *gc)\
{\
    register GLuint zAccum = gc->polygon.shader.frag.z;\
    register __GLz16Value z16Accum = (__GLz16Value) (zAccum >> Z16_SHIFT); \
    register GLint zDelta = gc->polygon.shader.dzdx;\
    register __GLz16Value *zbuf = (__GLz16Value *) (gc->polygon.shader.zbuf);\
    register GLuint *pStipple = gc->polygon.shader.stipplePat;\
    register GLint cTotalPix = gc->polygon.shader.length;\
    register GLuint mask;\
    register GLint cPix;\
    register GLint zPasses = 0;\
    register GLuint maskBit;\
\
    for (;cTotalPix > 0; cTotalPix-=32) {\
        mask = 0;\
        maskBit = 0x80000000;\
        cPix = cTotalPix;\
        if (cPix > 32)\
            cPix = 32;\
        \
        for (;cPix > 0; cPix --) {\
            if (((__GLz16Value)(zAccum >> Z16_SHIFT)) pass_cond (*zbuf)) {\
                *zbuf = ((__GLz16Value)(zAccum >> Z16_SHIFT));\
                zPasses++;\
                mask |= maskBit;\
            }\
            *zbuf++;\
            zAccum += zDelta;\
            maskBit >>= 1;\
        }\
\
        *pStipple++ = mask;\
    }\
\
    if (zPasses == 0) {\
        gc->polygon.shader.done = TRUE;\
        return 1;\
    } else if (zPasses == gc->polygon.shader.length) {\
        return 0;\
    } else {\
        return 2;\
    }\
}


ZBUF_PROC(LT, <);

ZBUF_PROC(EQ, ==);

ZBUF_PROC(LE, <=);

ZBUF_PROC(GT, >);

ZBUF_PROC(NE, !=);

ZBUF_PROC(GE, >=);

ZBUF_PROC(ALWAYS, || TRUE ||);

GLboolean FASTCALL __fastGenDepthTestSpanNEVER(__GLcontext *gc)
{
    return FALSE;
}

ZBUF16_PROC(LT, <);

ZBUF16_PROC(EQ, ==);

ZBUF16_PROC(LE, <=);

ZBUF16_PROC(GT, >);

ZBUF16_PROC(NE, !=);

ZBUF16_PROC(GE, >=);

ZBUF16_PROC(ALWAYS, || TRUE ||);

/*******************************************************/

__GLspanFunc __fastDepthFuncs[] =
    {__fastGenDepthTestSpanNEVER,
     __fastGenDepthTestSpanLT,
     __fastGenDepthTestSpanEQ,
     __fastGenDepthTestSpanLE,
     __fastGenDepthTestSpanGT,
     __fastGenDepthTestSpanNE,
     __fastGenDepthTestSpanGE,
     __fastGenDepthTestSpanALWAYS
    };

__GLspanFunc __fastDepth16Funcs[] =
    {__fastGenDepthTestSpanNEVER,
     __fastGenDepth16TestSpanLT,
     __fastGenDepth16TestSpanEQ,
     __fastGenDepth16TestSpanLE,
     __fastGenDepth16TestSpanGT,
     __fastGenDepth16TestSpanNE,
     __fastGenDepth16TestSpanGE,
     __fastGenDepth16TestSpanALWAYS
    };

/*******************************************************/

DWORD ditherShade[32] = {
    0x0800,
    0x8800,
    0x2800,
    0xa800,
    0x0800,
    0x8800,
    0x2800,
    0xa800,

    0xc800,
    0x4800,
    0xe800,
    0x6800,
    0xc800,
    0x4800,
    0xe800,
    0x6800,

    0x3800,
    0xb800,
    0x1800,
    0x9800,
    0x3800,
    0xb800,
    0x1800,
    0x9800,

    0xf800,
    0x7800,
    0xd800,
    0x5800,
    0xf800,
    0x7800,
    0xd800,
    0x5800,
};

DWORD ditherTexture[32] = {
    0x08,
    0x88,
    0x28,
    0xa8,
    0x08,
    0x88,
    0x28,
    0xa8,

    0xc8,
    0x48,
    0xe8,
    0x68,
    0xc8,
    0x48,
    0xe8,
    0x68,

    0x38,
    0xb8,
    0x18,
    0x98,
    0x38,
    0xb8,
    0x18,
    0x98,

    0xf8,
    0x78,
    0xd8,
    0x58,
    0xf8,
    0x78,
    0xd8,
    0x58,
};

static ULONG Dither_4x4[4] = {0xa8288808, 0x68e848c8, 0x9818b838, 0x58d878f8};

/*******************************************************/

#define STRCAT4R(s1, s2, s3, s4) s1 ## s2 ## s3 ## s4
#define STRCAT4(s1, s2, s3, s4) STRCAT4R(s1, s2, s3, s4)

#define STRCAT3R(s1, s2, s3) s1 ## s2 ## s3
#define STRCAT3(s1, s2, s3) STRCAT3R(s1, s2, s3)

#define STRCAT2R(s1, s2) s1 ## s2
#define STRCAT2(s1, s2) STRCAT2R(s1, s2)

/*******************************************************/

//
// create the generic span routine
//

#define GENERIC 1
#define ZBUFFER 1
#define RGBMODE 1
#define SHADE   1
#define DITHER  1
#define TEXTURE 1
#define BPP bpp

#include "span.h"

#undef GENERIC
#define GENERIC 0

/*******************************************************/

//
// now create the special case span routines
//

//
// first modes that are dithered
//

#undef DITHER
#define DITHER 1

/*******************************************************/

#undef COLORFORMAT
#define COLORFORMAT     332
#undef BPP
#define BPP		8

#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#define RSHIFT          0
#define GSHIFT          3
#define BSHIFT          6
#define RBITS		3
#define GBITS		3
#define BBITS		2

#include "spanset.h"

/*******************************************************/

#undef COLORFORMAT
#define COLORFORMAT     555
#undef BPP
#define BPP		16

#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#define RSHIFT          10
#define GSHIFT          5
#define BSHIFT          0
#define RBITS		5
#define GBITS		5
#define BBITS		5

#include "spanset.h"

/*******************************************************/

#undef COLORFORMAT
#define COLORFORMAT     565
#undef BPP
#define BPP		16

#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#define RSHIFT          11
#define GSHIFT          5
#define BSHIFT          0
#define RBITS		5
#define GBITS		6
#define BBITS		5

#include "spanset.h"

/*******************************************************/

//
// undithered modes
//

#undef  DITHER
#define DITHER 0

/*******************************************************/

#undef COLORFORMAT
#define COLORFORMAT     24
#undef BPP
#define BPP		24

#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#define RSHIFT          16
#define GSHIFT          8
#define BSHIFT          0
#define RBITS		8
#define GBITS		8
#define BBITS		8


#include "spanset.h"

/*******************************************************/

#undef COLORFORMAT
#define COLORFORMAT     32
#undef BPP
#define BPP		32

#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#define RSHIFT          16
#define GSHIFT          8
#define BSHIFT          0
#define RBITS		8
#define GBITS		8
#define BBITS		8

#include "spanset.h"

/*******************************************************/

#ifndef _X86_

//
// Create span routines for perspective-corrected textures
//

#undef BPP
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#define RSHIFT          0
#define GSHIFT          3
#define BSHIFT          6
#define RBITS		3
#define GBITS		3
#define BBITS		2
#define BPP             8

#define FAST_REPLACE 1
#include "texspans.h"
#undef FAST_REPLACE

#define SKIP_FAST_REPLACE 1
#define REPLACE 1
#include "texspans.h"
#undef REPLACE
#undef SKIP_FAST_REPLACE

#define FAST_REPLACE 1
#define PALETTE_ONLY 1
#include "texspans.h"
#undef FAST_REPLACE
#undef PALETTE_ONLY

#define PALETTE_ENABLED 1

#define FLAT_SHADING 1
#include "texspans.h"
#undef FLAT_SHADING

#define SMOOTH_SHADING 1
#include "texspans.h"
#undef SMOOTH_SHADING

#undef PALETTE_ENABLED


#undef BPP
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#define RSHIFT          10
#define GSHIFT          5
#define BSHIFT          0
#define RBITS		5
#define GBITS		5
#define BBITS		5
#define BPP             16

#define SKIP_FAST_REPLACE 1
#define REPLACE 1
#include "texspans.h"
#undef REPLACE
#undef SKIP_FAST_REPLACE

#define SKIP_FAST_REPLACE 1     // only need routines for alpha modes, since
#define FAST_REPLACE 1          // replace is identical otherwise with 565
#define PALETTE_ONLY 1
#include "texspans.h"
#undef FAST_REPLACE
#undef PALETTE_ONLY
#undef SKIP_FAST_REPLACE

#define PALETTE_ENABLED 1

#define FLAT_SHADING 1
#include "texspans.h"
#undef FLAT_SHADING

#define SMOOTH_SHADING 1
#include "texspans.h"
#undef SMOOTH_SHADING

#undef PALETTE_ENABLED


#undef BPP
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#define RSHIFT          11
#define GSHIFT          5
#define BSHIFT          0
#define RBITS		5
#define GBITS		6
#define BBITS		5
#define BPP             16

#define FAST_REPLACE 1
#include "texspans.h"
#undef FAST_REPLACE

#define SKIP_FAST_REPLACE 1
#define REPLACE 1
#include "texspans.h"
#undef REPLACE
#undef SKIP_FAST_REPLACE

#define FAST_REPLACE 1
#define PALETTE_ONLY 1
#include "texspans.h"
#undef FAST_REPLACE
#undef PALETTE_ONLY

#define PALETTE_ENABLED 1

#define FLAT_SHADING 1
#include "texspans.h"
#undef FLAT_SHADING

#define SMOOTH_SHADING 1
#include "texspans.h"
#undef SMOOTH_SHADING

#undef PALETTE_ENABLED

#undef BPP
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT
#undef RBITS
#undef GBITS
#undef BBITS
#define RSHIFT          16
#define GSHIFT          8
#define BSHIFT          0
#define RBITS		8
#define GBITS		8
#define BBITS		8
#define BPP             32

#define REPLACE 1
#include "texspans.h"
#undef REPLACE

#define REPLACE 1
#define PALETTE_ONLY 1
#include "texspans.h"
#undef REPLACE
#undef PALETTE_ONLY


#define PALETTE_ENABLED 1

#define FLAT_SHADING 1
#include "texspans.h"
#undef FLAT_SHADING

#define SMOOTH_SHADING 1
#include "texspans.h"
#undef SMOOTH_SHADING

#undef PALETTE_ENABLED

#endif  // _X86_


/*******************************************************/

//
// finally color index and flat spans
//

#undef TEXTURE
#undef SHADE
#undef RSHIFT
#undef GSHIFT
#undef BSHIFT

/*******************************************************/

#undef COLORFORMAT
#define COLORFORMAT     8
#undef BPP
#define BPP		8

#include "spanci.h"

/*******************************************************/

#undef COLORFORMAT
#define COLORFORMAT     16
#undef BPP
#define BPP		16

#include "spanci.h"

/*******************************************************/

#undef COLORFORMAT
#define COLORFORMAT     24
#undef BPP
#define BPP		24

#include "spanci.h"

/*******************************************************/

#undef COLORFORMAT
#define COLORFORMAT     32
#undef BPP
#define BPP		32

#include "spanci.h"

/*******************************************************/

__genSpanFunc __fastGenRGBFlatFuncs[] =
    {
     __fastGenRGB24FlatSpan,
     __fastGenRGB32FlatSpan,
     __fastGenRGB8FlatSpan,
     __fastGenRGB16FlatSpan,
     __fastGenRGB16FlatSpan,

     __fastGenRGB24FlatSpan,
     __fastGenRGB32FlatSpan,
     __fastGenRGB8DithFlatSpan,
     __fastGenRGB16DithFlatSpan,
     __fastGenRGB16DithFlatSpan,

     __fastGenMaskRGB24FlatSpan,
     __fastGenMaskRGB32FlatSpan,
     __fastGenMaskRGB8FlatSpan,
     __fastGenMaskRGB16FlatSpan,
     __fastGenMaskRGB16FlatSpan,

     __fastGenMaskRGB24FlatSpan,
     __fastGenMaskRGB32FlatSpan,
     __fastGenMaskRGB8DithFlatSpan,
     __fastGenMaskRGB16DithFlatSpan,
     __fastGenMaskRGB16DithFlatSpan,
    };

__genSpanFunc __fastGenCIFlatFuncs[] =
    {
     __fastGenCI24FlatSpan,
     __fastGenCI32FlatSpan,
     __fastGenCI8FlatSpan,
     __fastGenCI16FlatSpan,
     __fastGenCI16FlatSpan,

     __fastGenCI24DithFlatSpan,
     __fastGenCI32DithFlatSpan,
     __fastGenCI8DithFlatSpan,
     __fastGenCI16DithFlatSpan,
     __fastGenCI16DithFlatSpan,

     __fastGenMaskCI24FlatSpan,
     __fastGenMaskCI32FlatSpan,
     __fastGenMaskCI8FlatSpan,
     __fastGenMaskCI16FlatSpan,
     __fastGenMaskCI16FlatSpan,

     __fastGenMaskCI24DithFlatSpan,
     __fastGenMaskCI32DithFlatSpan,
     __fastGenMaskCI8DithFlatSpan,
     __fastGenMaskCI16DithFlatSpan,
     __fastGenMaskCI16DithFlatSpan,
    };


__genSpanFunc __fastGenCIFuncs[] =
    {
     __fastGenCI24Span,
     __fastGenCI32Span,
     __fastGenCI8Span,
     __fastGenCI16Span,
     __fastGenCI16Span,

     __fastGenCI24DithSpan,
     __fastGenCI32DithSpan,
     __fastGenCI8DithSpan,
     __fastGenCI16DithSpan,
     __fastGenCI16DithSpan,

     __fastGenMaskCI24Span,
     __fastGenMaskCI32Span,
     __fastGenMaskCI8Span,
     __fastGenMaskCI16Span,
     __fastGenMaskCI16Span,

     __fastGenMaskCI24DithSpan,
     __fastGenMaskCI32DithSpan,
     __fastGenMaskCI8DithSpan,
     __fastGenMaskCI16DithSpan,
     __fastGenMaskCI16DithSpan,
    };

__genSpanFunc __fastGenRGBFuncs[] =
    {
     __fastGenRGB24Span,
     __fastGenRGB32Span,
     __fastGenSpan,
     __fastGenSpan,
     __fastGenSpan,

     __fastGenRGB24Span,
     __fastGenRGB32Span,
     __fastGenRGB332DithSpan,
     __fastGenRGB555DithSpan,
     __fastGenRGB565DithSpan,

     __fastGenMaskRGB24Span,
     __fastGenMaskRGB32Span,
     __fastGenSpan,
     __fastGenSpan,
     __fastGenSpan,

     __fastGenMaskRGB24Span,
     __fastGenMaskRGB32Span,
     __fastGenMaskRGB332DithSpan,
     __fastGenMaskRGB555DithSpan,
     __fastGenMaskRGB565DithSpan,
    };

__genSpanFunc __fastGenTexDecalFuncs[] =
    {
     __fastGenTexDecal24Span,
     __fastGenTexDecal32Span,
     __fastGenSpan,
     __fastGenSpan,
     __fastGenSpan,

     __fastGenTexDecal24Span,
     __fastGenTexDecal32Span,
     __fastGenTexDecal332DithSpan,
     __fastGenTexDecal555DithSpan,
     __fastGenTexDecal565DithSpan,

     __fastGenMaskTexDecal24Span,
     __fastGenMaskTexDecal32Span,
     __fastGenSpan,
     __fastGenSpan,
     __fastGenSpan,

     __fastGenMaskTexDecal24Span,
     __fastGenMaskTexDecal32Span,
     __fastGenMaskTexDecal332DithSpan,
     __fastGenMaskTexDecal555DithSpan,
     __fastGenMaskTexDecal565DithSpan,
    };

__genSpanFunc __fastGenTexFuncs[] =
    {
     __fastGenTex24Span,
     __fastGenTex32Span,
     __fastGenSpan,
     __fastGenSpan,
     __fastGenSpan,

     __fastGenTex24Span,
     __fastGenTex32Span,
     __fastGenTex332DithSpan,
     __fastGenTex555DithSpan,
     __fastGenTex565DithSpan,

     __fastGenMaskTex24Span,
     __fastGenMaskTex32Span,
     __fastGenSpan,
     __fastGenSpan,
     __fastGenSpan,

     __fastGenMaskTex24Span,
     __fastGenMaskTex32Span,
     __fastGenMaskTex332DithSpan,
     __fastGenMaskTex555DithSpan,
     __fastGenMaskTex565DithSpan,
    };


void FASTCALL __fastFastPerspReplace332(__GLGENcontext *gc);
void FASTCALL __fastFastPerspReplaceZle332(__GLGENcontext *gc);
void FASTCALL __fastFastPerspReplaceZlt332(__GLGENcontext *gc);

// Note the the compressed 555 and 565 formats are equivalent, so
// we'll just use the 565 version:

void FASTCALL __fastFastPerspReplace565(__GLGENcontext *gc);
void FASTCALL __fastFastPerspReplaceZle565(__GLGENcontext *gc);
void FASTCALL __fastFastPerspReplaceZlt565(__GLGENcontext *gc);

//----------------------------------------------------------------------

void FASTCALL __fastPerspReplace332(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceZle332(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceZlt332(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceAlpha332(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceAlphaZle332(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceAlphaZlt332(__GLGENcontext *gc);

void FASTCALL __fastPerspReplace555(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceZle555(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceZlt555(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceAlpha555(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceAlphaZle555(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceAlphaZlt555(__GLGENcontext *gc);

void FASTCALL __fastPerspReplace565(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceZle565(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceZlt565(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceAlpha565(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceAlphaZle565(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceAlphaZlt565(__GLGENcontext *gc);

void FASTCALL __fastPerspReplace888(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceZle888(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceZlt888(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceAlpha888(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceAlphaZle888(__GLGENcontext *gc);
void FASTCALL __fastPerspReplaceAlphaZlt888(__GLGENcontext *gc);

//----------------------------------------------------------------------

void FASTCALL __fastFastPerspPalReplace332(__GLGENcontext *gc);
void FASTCALL __fastFastPerspPalReplaceZle332(__GLGENcontext *gc);
void FASTCALL __fastFastPerspPalReplaceZlt332(__GLGENcontext *gc);
void FASTCALL __fastFastPerspPalReplaceAlpha332(__GLGENcontext *gc);
void FASTCALL __fastFastPerspPalReplaceAlphaZle332(__GLGENcontext *gc);
void FASTCALL __fastFastPerspPalReplaceAlphaZlt332(__GLGENcontext *gc);

// Note the the compressed 555 and 565 formats are equivalent, so
// we'll just use the 565 version:

void FASTCALL __fastFastPerspPalReplace565(__GLGENcontext *gc);
void FASTCALL __fastFastPerspPalReplaceZle565(__GLGENcontext *gc);
void FASTCALL __fastFastPerspPalReplaceZlt565(__GLGENcontext *gc);

// With alpha, we have to provode pixel-format-specific code for 555 and
// 565, since there is a potential read-modify-write for which we will
// have to deal with the pixel format...

void FASTCALL __fastFastPerspPalReplaceAlpha555(__GLGENcontext *gc);
void FASTCALL __fastFastPerspPalReplaceAlphaZle555(__GLGENcontext *gc);
void FASTCALL __fastFastPerspPalReplaceAlphaZlt555(__GLGENcontext *gc);
void FASTCALL __fastFastPerspPalReplaceAlpha565(__GLGENcontext *gc);
void FASTCALL __fastFastPerspPalReplaceAlphaZle565(__GLGENcontext *gc);
void FASTCALL __fastFastPerspPalReplaceAlphaZlt565(__GLGENcontext *gc);


void FASTCALL __fastPerspPalReplace332(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceZle332(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceZlt332(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceAlpha332(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceAlphaZle332(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceAlphaZlt332(__GLGENcontext *gc);

void FASTCALL __fastPerspPalReplace555(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceZle555(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceZlt555(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceAlpha555(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceAlphaZle555(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceAlphaZlt555(__GLGENcontext *gc);

void FASTCALL __fastPerspPalReplace565(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceZle565(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceZlt565(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceAlpha565(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceAlphaZle565(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceAlphaZlt565(__GLGENcontext *gc);

void FASTCALL __fastPerspPalReplace888(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceZle888(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceZlt888(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceAlpha888(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceAlphaZle888(__GLGENcontext *gc);
void FASTCALL __fastPerspPalReplaceAlphaZlt888(__GLGENcontext *gc);

//----------------------------------------------------------------------

void FASTCALL __fastPerspFlat332(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatZle332(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatZlt332(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatAlpha332(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatAlphaZle332(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatAlphaZlt332(__GLGENcontext *gc);

void FASTCALL __fastPerspFlat555(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatZle555(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatZlt555(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatAlpha555(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatAlphaZle555(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatAlphaZlt555(__GLGENcontext *gc);

void FASTCALL __fastPerspFlat565(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatZle565(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatZlt565(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatAlpha565(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatAlphaZle565(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatAlphaZlt565(__GLGENcontext *gc);

void FASTCALL __fastPerspFlat888(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatZle888(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatZlt888(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatAlpha888(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatAlphaZle888(__GLGENcontext *gc);
void FASTCALL __fastPerspFlatAlphaZlt888(__GLGENcontext *gc);

//----------------------------------------------------------------------

void FASTCALL __fastPerspSmooth332(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothZle332(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothZlt332(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothAlpha332(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothAlphaZle332(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothAlphaZlt332(__GLGENcontext *gc);

void FASTCALL __fastPerspSmooth555(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothZle555(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothZlt555(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothAlpha555(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothAlphaZle555(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothAlphaZlt555(__GLGENcontext *gc);

void FASTCALL __fastPerspSmooth565(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothZle565(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothZlt565(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothAlpha565(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothAlphaZle565(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothAlphaZlt565(__GLGENcontext *gc);

void FASTCALL __fastPerspSmooth888(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothZle888(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothZlt888(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothAlpha888(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothAlphaZle888(__GLGENcontext *gc);
void FASTCALL __fastPerspSmoothAlphaZlt888(__GLGENcontext *gc);


__genSpanFunc __fastPerspTexReplaceFuncs[] = {

    __fastFastPerspReplace332,
    __fastFastPerspReplaceZle332,
    __fastFastPerspReplaceZlt332,
    __fastPerspReplaceAlpha332,
    __fastPerspReplaceAlphaZle332,
    __fastPerspReplaceAlphaZlt332,

    __fastFastPerspReplace565,
    __fastFastPerspReplaceZle565,
    __fastFastPerspReplaceZlt565,
    __fastPerspReplaceAlpha555,
    __fastPerspReplaceAlphaZle555,
    __fastPerspReplaceAlphaZlt555,

    __fastFastPerspReplace565,
    __fastFastPerspReplaceZle565,
    __fastFastPerspReplaceZlt565,
    __fastPerspReplaceAlpha565,
    __fastPerspReplaceAlphaZle565,
    __fastPerspReplaceAlphaZlt565,

    __fastPerspReplace888,
    __fastPerspReplaceZle888,
    __fastPerspReplaceZlt888,
    __fastPerspReplaceAlpha888,
    __fastPerspReplaceAlphaZle888,
    __fastPerspReplaceAlphaZlt888,
   
};

__genSpanFunc __fastPerspTexPalReplaceFuncs[] = {

    __fastFastPerspPalReplace332,
    __fastFastPerspPalReplaceZle332,
    __fastFastPerspPalReplaceZlt332,
    __fastFastPerspPalReplaceAlpha332,
    __fastFastPerspPalReplaceAlphaZle332,
    __fastFastPerspPalReplaceAlphaZlt332,

    __fastFastPerspPalReplace565,
    __fastFastPerspPalReplaceZle565,
    __fastFastPerspPalReplaceZlt565,
    __fastFastPerspPalReplaceAlpha555,
    __fastFastPerspPalReplaceAlphaZle555,
    __fastFastPerspPalReplaceAlphaZlt555,

    __fastFastPerspPalReplace565,
    __fastFastPerspPalReplaceZle565,
    __fastFastPerspPalReplaceZlt565,
    __fastFastPerspPalReplaceAlpha565,
    __fastFastPerspPalReplaceAlphaZle565,
    __fastFastPerspPalReplaceAlphaZlt565,

    __fastPerspPalReplace888,
    __fastPerspPalReplaceZle888,
    __fastPerspPalReplaceZlt888,
    __fastPerspPalReplaceAlpha888,
    __fastPerspPalReplaceAlphaZle888,
    __fastPerspPalReplaceAlphaZlt888,
   
};

__genSpanFunc __fastPerspTexFlatFuncs[] = {

    __fastPerspFlat332,
    __fastPerspFlatZle332,
    __fastPerspFlatZlt332,
    __fastPerspFlatAlpha332,
    __fastPerspFlatAlphaZle332,
    __fastPerspFlatAlphaZlt332,

    __fastPerspFlat555,
    __fastPerspFlatZle555,
    __fastPerspFlatZlt555,
    __fastPerspFlatAlpha555,
    __fastPerspFlatAlphaZle555,
    __fastPerspFlatAlphaZlt555,

    __fastPerspFlat565,
    __fastPerspFlatZle565,
    __fastPerspFlatZlt565,
    __fastPerspFlatAlpha565,
    __fastPerspFlatAlphaZle565,
    __fastPerspFlatAlphaZlt565,

    __fastPerspFlat888,
    __fastPerspFlatZle888,
    __fastPerspFlatZlt888,
    __fastPerspFlatAlpha888,
    __fastPerspFlatAlphaZle888,
    __fastPerspFlatAlphaZlt888,
   
};

__genSpanFunc __fastPerspTexSmoothFuncs[] = {

    __fastPerspSmooth332,
    __fastPerspSmoothZle332,
    __fastPerspSmoothZlt332,
    __fastPerspSmoothAlpha332,
    __fastPerspSmoothAlphaZle332,
    __fastPerspSmoothAlphaZlt332,

    __fastPerspSmooth555,
    __fastPerspSmoothZle555,
    __fastPerspSmoothZlt555,
    __fastPerspSmoothAlpha555,
    __fastPerspSmoothAlphaZle555,
    __fastPerspSmoothAlphaZlt555,

    __fastPerspSmooth565,
    __fastPerspSmoothZle565,
    __fastPerspSmoothZlt565,
    __fastPerspSmoothAlpha565,
    __fastPerspSmoothAlphaZle565,
    __fastPerspSmoothAlphaZlt565,

    __fastPerspSmooth888,
    __fastPerspSmoothZle888,
    __fastPerspSmoothZlt888,
    __fastPerspSmoothAlpha888,
    __fastPerspSmoothAlphaZle888,
    __fastPerspSmoothAlphaZlt888,
};

/*******************************************************/

GLboolean FASTCALL __fastGenStippleLt32Span(__GLcontext *gc)
{
    register GLuint zAccum = gc->polygon.shader.frag.z;
    register GLint zDelta = gc->polygon.shader.dzdx;
    register GLuint *zbuf = gc->polygon.shader.zbuf;
    register GLuint *pStipple = gc->polygon.shader.stipplePat;
    register GLint cTotalPix = gc->polygon.shader.length;
    register GLuint mask;
    register GLint cPix;
    register GLint zPasses = 0;
    register GLuint maskBit;
    __GLstippleWord stipple;
    GLint count;
    GLint shift;

    if (gc->constants.yInverted) {
	stipple = gc->polygon.stipple[(gc->constants.height - 
		(gc->polygon.shader.frag.y - gc->constants.viewportYAdjust)-1) 
		& (__GL_STIPPLE_BITS-1)];
    } else {
	stipple = gc->polygon.stipple[gc->polygon.shader.frag.y & 
		(__GL_STIPPLE_BITS-1)];
    }
    shift = gc->polygon.shader.frag.x & (__GL_STIPPLE_BITS - 1);
#ifdef __GL_STIPPLE_MSB
    stipple = (stipple << shift) | (stipple >> (__GL_STIPPLE_BITS - shift));
#else
    stipple = (stipple >> shift) | (stipple << (__GL_STIPPLE_BITS - shift));
#endif
    if (stipple == 0) {
	/* No point in continuing */
	return GL_FALSE;
    }
    
    for (;cTotalPix > 0; cTotalPix-=32) {
        mask = stipple;
        maskBit = 0x80000000;
        cPix = cTotalPix;
        if (cPix > 32)
            cPix = 32;

        for (;cPix > 0; cPix --)
        {
            if (mask & maskBit)
            {
                if ((zAccum) < (*zbuf))
                {
                    *zbuf = zAccum;
                    zPasses++;
                }
                else
                {
                    mask &= ~maskBit;
                }
            }
            zbuf++;
            zAccum += zDelta;
            maskBit >>= 1;
        }

        *pStipple++ = mask;
    }

    if (zPasses == 0) {
        return GL_FALSE;
    } else {
        return GL_TRUE;
    }
}

GLboolean FASTCALL __fastGenStippleLt16Span(__GLcontext *gc)
{
    register GLuint zAccum = gc->polygon.shader.frag.z;
    register __GLz16Value z16Accum = (__GLz16Value) (zAccum >> Z16_SHIFT);
    register GLint zDelta = gc->polygon.shader.dzdx;
    register __GLz16Value *zbuf = (__GLz16Value *) (gc->polygon.shader.zbuf);
    register GLuint *pStipple = gc->polygon.shader.stipplePat;
    register GLint cTotalPix = gc->polygon.shader.length;
    register GLuint mask;
    register GLint cPix;
    register GLint zPasses = 0;
    register GLuint maskBit;
    __GLstippleWord stipple;
    GLint count;
    GLint shift;

    if (gc->constants.yInverted) {
	stipple = gc->polygon.stipple[(gc->constants.height - 
		(gc->polygon.shader.frag.y - gc->constants.viewportYAdjust)-1) 
		& (__GL_STIPPLE_BITS-1)];
    } else {
	stipple = gc->polygon.stipple[gc->polygon.shader.frag.y & 
		(__GL_STIPPLE_BITS-1)];
    }
    shift = gc->polygon.shader.frag.x & (__GL_STIPPLE_BITS - 1);
#ifdef __GL_STIPPLE_MSB
    stipple = (stipple << shift) | (stipple >> (__GL_STIPPLE_BITS - shift));
#else
    stipple = (stipple >> shift) | (stipple << (__GL_STIPPLE_BITS - shift));
#endif
    if (stipple == 0) {
	/* No point in continuing */
	return GL_FALSE;
    }
    
    for (;cTotalPix > 0; cTotalPix-=32) {
        mask = stipple;
        maskBit = 0x80000000;
        cPix = cTotalPix;
        if (cPix > 32)
            cPix = 32;

        for (;cPix > 0; cPix --)
        {
            if (mask & maskBit)
            {
                if (((__GLz16Value)(zAccum >> Z16_SHIFT)) < (*zbuf))
                {
                    *zbuf = ((__GLz16Value)(zAccum >> Z16_SHIFT));
                    zPasses++;
                }
                else
                {
                    mask &= ~maskBit;
                }
            }
            zbuf++;
            zAccum += zDelta;
            maskBit >>= 1;
        }

        *pStipple++ = mask;
    }

    if (zPasses == 0) {
        return GL_FALSE;
    } else {
        return GL_TRUE;
    }
}

GLboolean FASTCALL __fastGenStippleAnyDepthTestSpan(__GLcontext *gc)
{
    // If the shader is done after this routine then
    // the stipple pattern is all zeroes so we can
    // skip the span
    __glStippleSpan(gc);
    if (gc->polygon.shader.done)
    {
        return GL_FALSE;
    }
                
    // If this returns true then all bits are off so
    // we can skip the span
    return !__glDepthTestStippledSpan(gc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\genrgb.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

#include "genrgb.h"
#include "genclear.h"

#define STATIC

__GLfloat fDitherIncTable[16] = {
    DITHER_INC(0),  DITHER_INC(8),  DITHER_INC(2),  DITHER_INC(10),
    DITHER_INC(12), DITHER_INC(4),  DITHER_INC(14), DITHER_INC(6),
    DITHER_INC(3),  DITHER_INC(11), DITHER_INC(1),  DITHER_INC(9),
    DITHER_INC(15), DITHER_INC(7),  DITHER_INC(13), DITHER_INC(5)
};

/* No Dither,  No blend, No Write, No Nothing */
STATIC void FASTCALL Store_NOT(__GLcolorBuffer *cfb, const __GLfragment *frag)
{
}

STATIC GLboolean FASTCALL StoreSpanNone(__GLcontext *gc)
{
    return GL_FALSE;
}

//
// Special case normal alpha blending (source alpha*src + dst*(1-sa))
// This case is used in antialiasing and actually jumping through
// the fetch and blend procs takes up a large amount of time.  Moving
// the code into the store proc removes this overhead
//
// The macro requires a standard store proc setup, with gc, cfb, frag,
// blendColor and so on.  It requires a dst_pix variable which
// will hold a pixel in the destination format.
// It also takes as an argument a statement which will set dst_pix.
// The reason it doesn't take the pixel itself is because only the special case
// actually needs the value.  In all the flags cases the pixel
// retrieval would be wasted.
//

extern void __glDoBlend_SA_MSA(__GLcontext *gc, const __GLcolor *source,
                               const __GLcolor *dest, __GLcolor *result);

#define SPECIAL_ALPHA_BLEND(dst_pix_gen)                                      \
    color = &blendColor;                                                      \
    if( (gc->procs.blendColor == __glDoBlend_SA_MSA) &&			      \
        !( ALPHA_WRITE_ENABLED( cfb )) ) \
    {									      \
        __GLfloat a, msa;						      \
                							      \
        a = frag->color.a * gc->frontBuffer.oneOverAlphaScale;		      \
        msa = __glOne - a;						      \
									      \
        dst_pix_gen;					                      \
        blendColor.r = frag->color.r*a + msa*(__GLfloat)		      \
            ((dst_pix & gc->modes.redMask) >> cfb->redShift);		      \
        blendColor.g = frag->color.g*a + msa*(__GLfloat)		      \
            ((dst_pix & gc->modes.greenMask) >> cfb->greenShift);	      \
        blendColor.b = frag->color.b*a + msa*(__GLfloat)		      \
            ((dst_pix & gc->modes.blueMask) >> cfb->blueShift);		      \
    }									      \
    else								      \
    {									      \
        (*gc->procs.blend)( gc, cfb, frag, &blendColor );		      \
    }

#define SPECIAL_ALPHA_BLEND_SPAN(dst_pix_gen)				      \
    if( (gc->procs.blendColor == __glDoBlend_SA_MSA) &&			      \
        !( ALPHA_WRITE_ENABLED( cfb )) ) \
    {									      \
        __GLcolor *color = gc->polygon.shader.colors;   \
                                                         \
        for ( i = 0; i < w; i++, color++ )			      \
        {								      \
            __GLfloat a, msa;						      \
									      \
            a = color->a * gc->frontBuffer.oneOverAlphaScale;		      \
            msa = __glOne - a;						      \
									      \
            dst_pix_gen;						      \
            color->r = color->r*a + msa*(__GLfloat)			      \
                ((dst_pix & gc->modes.redMask) >> cfb->redShift);	      \
            color->g = color->g*a + msa*(__GLfloat)			      \
                ((dst_pix & gc->modes.greenMask) >> cfb->greenShift);	      \
            color->b = color->b*a + msa*(__GLfloat)			      \
                ((dst_pix & gc->modes.blueMask) >> cfb->blueShift);	      \
        }								      \
    }									      \
    else								      \
    {									      \
        (*gc->procs.blendSpan)( gc );         \
    }

#define DitheredRGBColorToBuffer(col, incr, cfb, dest, type) \
    ((dest) = (type)(( FTOL((col)->r+(incr)) << (cfb)->redShift) | \
                     ( FTOL((col)->g+(incr)) << (cfb)->greenShift) | \
                     ( FTOL((col)->b+(incr)) << (cfb)->blueShift)))
#define UnditheredRGBColorToBuffer(col, cfb, dest, type) \
    ((dest) = (type)(( FTOL((col)->r) << (cfb)->redShift) | \
                     ( FTOL((col)->g) << (cfb)->greenShift) | \
                     ( FTOL((col)->b) << (cfb)->blueShift)))
#define DitheredRGBAColorToBuffer(col, incr, cfb, dest, type) \
    ((dest) = (type)(( FTOL((col)->r+(incr)) << (cfb)->redShift) | \
                     ( FTOL((col)->g+(incr)) << (cfb)->greenShift) | \
                     ( FTOL((col)->b+(incr)) << (cfb)->blueShift) | \
                     ( FTOL((col)->a+(incr)) << (cfb)->alphaShift)))
#define UnditheredRGBAColorToBuffer(col, cfb, dest, type) \
    ((dest) = (type)(( FTOL((col)->r) << (cfb)->redShift) | \
                     ( FTOL((col)->g) << (cfb)->greenShift) | \
                     ( FTOL((col)->b) << (cfb)->blueShift) | \
                     ( FTOL((col)->a) << (cfb)->alphaShift)))

#define DitheredColorToBuffer(col, incr, cfb, dest, type) \
    if( ALPHA_PIXEL_WRITE( cfb ) ) \
        DitheredRGBAColorToBuffer(col, incr, cfb, dest, type); \
    else \
        DitheredRGBColorToBuffer(col, incr, cfb, dest, type);

#define UnditheredColorToBuffer(col, cfb, dest, type) \
    if( ALPHA_PIXEL_WRITE( cfb ) ) \
        UnditheredRGBAColorToBuffer(col, cfb, dest, type); \
    else \
        UnditheredRGBColorToBuffer(col, cfb, dest, type);

#define StoreColorAsRGB(col, dst) \
    (*(dst)++ = (BYTE) FTOL((col)->r), \
     *(dst)++ = (BYTE) FTOL((col)->g), \
     *(dst)++ = (BYTE) FTOL((col)->b) )
#define StoreColorAsBGR(col, dst) \
    (*(dst)++ = (BYTE) FTOL((col)->b), \
     *(dst)++ = (BYTE) FTOL((col)->g), \
     *(dst)++ = (BYTE) FTOL((col)->r) )

// Macro to read RGBA bitfield span, where alpha component has 3 possibilities:
// 1) No alpha buffer, so use constant alpha
// 2) Alpha is part of the pixel
// 3) Alpha is in the software alpha buffer
// Note, currently this is only used for 16 and 32bpp.

#define READ_RGBA_BITFIELD_SPAN(src_pix_gen)				      \
    if( !gc->modes.alphaBits ) { \
        for( ; w; w--, pResults++ ) \
        { \
            src_pix_gen; \
            pResults->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift); \
            pResults->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift); \
            pResults->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift); \
            pResults->a = cfb->alphaScale; \
        } \
    } \
    else if( ALPHA_IN_PIXEL( cfb ) ) { \
        for( ; w; w--, pResults++ ) \
        { \
            src_pix_gen; \
            pResults->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift); \
            pResults->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift); \
            pResults->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift); \
            pResults->a = (__GLfloat) ((pixel & gc->modes.alphaMask) >> cfb->alphaShift); \
        } \
    } else { \
        (*cfb->alphaBuf.readSpan)(&cfb->alphaBuf, x, y, w, pResults); \
        for( ; w; w--, pResults++ ) \
        { \
            src_pix_gen; \
            pResults->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift); \
            pResults->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift); \
            pResults->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift); \
        } \
    }

/*
 *  write all
 */
STATIC void FASTCALL DIBIndex4Store(__GLcolorBuffer *cfb,
                                    const __GLfragment *frag)
{
    GLint x, y;
    GLubyte result, *puj;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    __GLfloat incr;
    GLuint enables = gc->state.enables.general;
    __GLcolor blendColor;
    const __GLcolor *color;
    GLubyte dst_pix;

    ASSERT_CHOP_ROUND();

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;
    // x & y are screen coords now

    if ( (cfb->buf.flags & NO_CLIP) ||
         (*gengc->pfnPixelVisible)(x, y) )
    {
        incr = (enables & __GL_DITHER_ENABLE) ?
            fDitherIncTable[__GL_DITHER_INDEX(frag->x, frag->y)] : __glHalf;

        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x >> 1));

        if( enables & __GL_BLEND_ENABLE )
        {
            SPECIAL_ALPHA_BLEND((dst_pix = gengc->pajInvTranslateVector
                                 [(x & 1) ? (*puj & 0xf) : (*puj >> 4)]));
        }
        else
        {
            color = &(frag->color);
        }

        DitheredRGBColorToBuffer(color, incr, cfb, result, GLubyte);

        if (cfb->buf.flags & NEED_FETCH)
        {
            if( x & 1 )
            {
                dst_pix = (*puj & 0x0f);
            }
            else
            {
                dst_pix = (*puj & 0xf0) >> 4;
            }
            dst_pix = gengc->pajInvTranslateVector[dst_pix];

            if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
            {
                result = (GLubyte)
                    (DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                     gc->modes.allMask);
            }

            if (cfb->buf.flags & COLORMASK_ON)
            {
                result = (GLubyte)
                    ((dst_pix & cfb->destMask) | (result & cfb->sourceMask));
            }
        }

        // now put it in
        result = gengc->pajTranslateVector[result];
        if (x & 1)
        {
            *puj = (*puj & 0xf0) | result;
        }
        else
        {
            result <<= 4;
            *puj = (*puj & 0x0f) | result;
        }
        if( ALPHA_WRITE_ENABLED( cfb ) )
            (*cfb->alphaBuf.store)(&cfb->alphaBuf, frag->x, frag->y, color);
    }
}


STATIC void FASTCALL DIBIndex8Store(__GLcolorBuffer *cfb,
                                    const __GLfragment *frag)
{
    GLint x, y;
    GLubyte result, *puj;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    __GLfloat incr;
    GLuint enables = gc->state.enables.general;
    __GLcolor blendColor;
    const __GLcolor *color;
    GLubyte dst_pix;

    ASSERT_CHOP_ROUND();

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;
    // x & y are screen coords now

    if ( (cfb->buf.flags & NO_CLIP) ||
         (*gengc->pfnPixelVisible)(x, y) )
    {
        incr = (enables & __GL_DITHER_ENABLE) ?
            fDitherIncTable[__GL_DITHER_INDEX(frag->x, frag->y)] : __glHalf;

        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + x);

        if( enables & __GL_BLEND_ENABLE )
        {
            SPECIAL_ALPHA_BLEND((dst_pix =
                                 gengc->pajInvTranslateVector[*puj]));
        }
        else
        {
            color = &(frag->color);
        }

        DitheredRGBColorToBuffer(color, incr, cfb, result, GLubyte);

        if (cfb->buf.flags & NEED_FETCH)
        {
            dst_pix = gengc->pajInvTranslateVector[*puj];

            if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
            {
                result = (GLubyte)
                    (DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                     gc->modes.allMask);
            }

            if (cfb->buf.flags & COLORMASK_ON)
            {
                result = (GLubyte)
                    ((dst_pix & cfb->destMask) | (result & cfb->sourceMask));
            }
        }

        *puj = gengc->pajTranslateVector[result];

        if( ALPHA_WRITE_ENABLED( cfb ) )
            (*cfb->alphaBuf.store)(&cfb->alphaBuf, frag->x, frag->y, color);
    }
}

// BMF_24BPP in BGR format
STATIC void FASTCALL DIBBGRStore(__GLcolorBuffer *cfb,
                                 const __GLfragment *frag)
{
    GLint x, y;
    GLubyte *puj;
    GLuint result;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint enables = gc->state.enables.general;
    __GLcolor blendColor;
    const __GLcolor *color;
    GLuint dst_pix;

    ASSERT_CHOP_ROUND();

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;
    // x & y are screen coords now

    if ( (cfb->buf.flags & NO_CLIP) ||
         (*gengc->pfnPixelVisible)(x, y) )
    {
        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x * 3));

        if( enables & __GL_BLEND_ENABLE )
        {
            SPECIAL_ALPHA_BLEND(Copy3Bytes(&dst_pix, puj));
        }
        else
        {
            color = &(frag->color);
        }

        if (cfb->buf.flags & NEED_FETCH)
        {
            Copy3Bytes( &dst_pix, puj );

            UnditheredRGBColorToBuffer(color, cfb, result, GLuint);

            if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
            {
                result = DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                    gc->modes.allMask;
            }

            if (cfb->buf.flags & COLORMASK_ON)
            {
                result =
                    (result & cfb->sourceMask) | (dst_pix & cfb->destMask);
            }

            Copy3Bytes( puj, &result );
        }
        else
        {
            StoreColorAsBGR(color, puj);
        }
        if( ALPHA_WRITE_ENABLED( cfb ) )
            (*cfb->alphaBuf.store)(&cfb->alphaBuf, frag->x, frag->y, color);
    }
}

// BMF_24BPP in RGB format
STATIC void FASTCALL DIBRGBAStore(__GLcolorBuffer *cfb,
                                 const __GLfragment *frag)
{
    GLint x, y;
    GLubyte *puj;
    GLuint result;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint enables = gc->state.enables.general;
    __GLcolor blendColor;
    const __GLcolor *color;
    GLuint dst_pix;

    ASSERT_CHOP_ROUND();

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;
    // x & y are screen coords now

    if ( (cfb->buf.flags & NO_CLIP) ||
         (*gengc->pfnPixelVisible)(x, y) )
    {
        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x * 3));

        if( enables & __GL_BLEND_ENABLE )
        {
            SPECIAL_ALPHA_BLEND(Copy3Bytes(&dst_pix, puj));
        }
        else
        {
            color = &(frag->color);
        }

        if (cfb->buf.flags & NEED_FETCH)
        {
            Copy3Bytes( &dst_pix, puj );
            UnditheredRGBColorToBuffer(color, cfb, result, GLuint);

            if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
            {
                result = DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                    gc->modes.allMask;
            }

            if (cfb->buf.flags & COLORMASK_ON)
            {
                result =
                    (result & cfb->sourceMask) | (dst_pix & cfb->destMask);
            }

            Copy3Bytes( puj, &result );
        }
        else
        {
            StoreColorAsRGB(color, puj);
        }
        if( ALPHA_WRITE_ENABLED( cfb ) )
            (*cfb->alphaBuf.store)(&cfb->alphaBuf, frag->x, frag->y, color);
    }
}

// BMF_16BPP
STATIC void FASTCALL DIBBitfield16Store(__GLcolorBuffer *cfb,
                                        const __GLfragment *frag)
{
    GLint x, y;
    GLushort result, *pus;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    __GLfloat incr;
    GLuint enables = gc->state.enables.general;
    __GLcolor blendColor;
    const __GLcolor *color;
    GLushort dst_pix;

    ASSERT_CHOP_ROUND();

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;
    // x & y are screen coords now

    if ( (cfb->buf.flags & NO_CLIP) ||
         (*gengc->pfnPixelVisible)(x, y) )
    {
        incr = (enables & __GL_DITHER_ENABLE) ?
            fDitherIncTable[__GL_DITHER_INDEX(frag->x, frag->y)] : __glHalf;

        pus = (GLushort *)((ULONG_PTR)cfb->buf.base +
                           (y*cfb->buf.outerWidth) + (x << 1));

        if( enables & __GL_BLEND_ENABLE )
        {
            SPECIAL_ALPHA_BLEND((dst_pix = *pus));
        }
        else
        {
            color = &(frag->color);
        }

        DitheredColorToBuffer(color, incr, cfb, result, GLushort);

        if (cfb->buf.flags & NEED_FETCH)
        {
            dst_pix = *pus;

            if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
            {
                result = (GLushort)
                    (DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                     gc->modes.allMask);
            }

            if (cfb->buf.flags & COLORMASK_ON)
            {
                result = (GLushort)((dst_pix & cfb->destMask) |
                              (result & cfb->sourceMask));
            }
        }
        *pus = result;

        if( ALPHA_BUFFER_WRITE( cfb ) )
            (*cfb->alphaBuf.store)(&cfb->alphaBuf, frag->x, frag->y, color);
    }
}

// BMF_32BPP store
// each component is 8 bits or less
// XXX could special case if shifting by 8 or use the 24 bit RGB code
STATIC void FASTCALL DIBBitfield32Store(__GLcolorBuffer *cfb,
                                        const __GLfragment *frag)
{
    GLint x, y;
    GLuint result, *pul;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint enables = gc->state.enables.general;
    __GLcolor blendColor;
    const __GLcolor *color;
    GLuint dst_pix;

    ASSERT_CHOP_ROUND();

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;
    // x & y are screen coords now

    if ( (cfb->buf.flags & NO_CLIP) ||
         (*gengc->pfnPixelVisible)(x, y) )
    {
        pul = (GLuint *)((ULONG_PTR)cfb->buf.base +
                          (y*cfb->buf.outerWidth) + (x << 2));

        if( enables & __GL_BLEND_ENABLE )
        {
            SPECIAL_ALPHA_BLEND((dst_pix = *pul));
        }
        else
        {
            color = &(frag->color);
        }

        UnditheredColorToBuffer(color, cfb, result, GLuint);

        if (cfb->buf.flags & NEED_FETCH)
        {
            dst_pix = *pul;

            if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
            {
                result =
                    DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                    gc->modes.allMask;
            }

            if (cfb->buf.flags & COLORMASK_ON)
            {
                result = (dst_pix & cfb->destMask) | (result & cfb->sourceMask);
            }
        }
        *pul = result;

        if( ALPHA_BUFFER_WRITE( cfb ) )
            (*cfb->alphaBuf.store)(&cfb->alphaBuf, frag->x, frag->y, color);
    }
}

static GLubyte vubRGBtoVGA[8] = {
    0x00,
    0x90,
    0xa0,
    0xb0,
    0xc0,
    0xd0,
    0xe0,
    0xf0
};

STATIC void FASTCALL DisplayIndex4Store(__GLcolorBuffer *cfb,
                                        const __GLfragment *frag)
{
    GLint x, y;
    GLubyte result, *puj;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    __GLfloat incr;
    GLuint enables = gc->state.enables.general;
    __GLcolor blendColor;
    const __GLcolor *color;
    GLubyte dst_pix;

    ASSERT_CHOP_ROUND();

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;
    // x & y are screen coords now

    incr = (enables & __GL_DITHER_ENABLE) ?
        fDitherIncTable[__GL_DITHER_INDEX(frag->x, frag->y)] : __glHalf;

    puj = gengc->ColorsBits;

    if( enables & __GL_BLEND_ENABLE )
    {
        color = &blendColor;
        (*gc->procs.blend)( gc, cfb, frag, &blendColor );
    }
    else
    {
        color = &(frag->color);
    }

    DitheredRGBColorToBuffer(color, incr, cfb, result, GLubyte);

    if (cfb->buf.flags & NEED_FETCH)
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
        dst_pix = *puj >> 4;

        if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
        {
            result = (GLubyte)
                (DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                 gc->modes.allMask);
        }

        if (cfb->buf.flags & COLORMASK_ON)
        {
            result = (GLubyte)((dst_pix & cfb->destMask) |
                               (result & cfb->sourceMask));
        }
    }

    *puj = vubRGBtoVGA[result];
    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, TRUE);

    if( ALPHA_WRITE_ENABLED( cfb ) )
        (*cfb->alphaBuf.store)(&cfb->alphaBuf, frag->x, frag->y, color);
}

// Put fragment into created DIB and call copybits for one pixel
STATIC void FASTCALL DisplayIndex8Store(__GLcolorBuffer *cfb,
                                        const __GLfragment *frag)
{
    GLint x, y;
    GLubyte result, *puj;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    __GLfloat incr;
    GLuint enables = gc->state.enables.general;
    __GLcolor blendColor;
    const __GLcolor *color;
    GLubyte dst_pix;

    ASSERT_CHOP_ROUND();

    gengc = (__GLGENcontext *)gc;

    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;
    // x & y are screen coords now

    incr = (enables & __GL_DITHER_ENABLE) ?
        fDitherIncTable[__GL_DITHER_INDEX(frag->x, frag->y)] : __glHalf;

    puj = gengc->ColorsBits;

    if( enables & __GL_BLEND_ENABLE )
    {
        color = &blendColor;
        (*gc->procs.blend)( gc, cfb, frag, &blendColor );
    }
    else
    {
        color = &(frag->color);
    }

    DitheredRGBColorToBuffer(color, incr, cfb, result, GLubyte);

    if (cfb->buf.flags & NEED_FETCH)
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
        dst_pix = gengc->pajInvTranslateVector[*puj];

        if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
        {
            result = (GLubyte)
                (DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                 gc->modes.allMask);
        }

        if (cfb->buf.flags & COLORMASK_ON)
        {
            result = (GLubyte)((dst_pix & cfb->destMask) |
                               (result & cfb->sourceMask));
        }
    }

    *puj = gengc->pajTranslateVector[result];
    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, TRUE);

    if( ALPHA_WRITE_ENABLED( cfb ) )
        (*cfb->alphaBuf.store)(&cfb->alphaBuf, frag->x, frag->y, color);
}

STATIC void FASTCALL DisplayBGRStore(__GLcolorBuffer *cfb,
                                     const __GLfragment *frag)
{
    GLint x, y;
    GLubyte *puj;
    GLuint result;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint enables = gc->state.enables.general;
    __GLcolor blendColor;
    const __GLcolor *color;
    GLuint dst_pix;

    ASSERT_CHOP_ROUND();

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;
    // x & y are screen coords now

    puj = gengc->ColorsBits;

    if( enables & __GL_BLEND_ENABLE )
    {
        color = &blendColor;
        (*gc->procs.blend)( gc, cfb, frag, &blendColor );
    }
    else
    {
        color = &(frag->color);
    }

    if (cfb->buf.flags & NEED_FETCH)
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
        dst_pix = *(GLuint *)puj;
        UnditheredRGBColorToBuffer(color, cfb, result, GLuint);

        if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
        {
            result =
                DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                gc->modes.allMask;
        }

        if (cfb->buf.flags & COLORMASK_ON)
        {
            result = (dst_pix & cfb->destMask) |
                (result & cfb->sourceMask);
        }

        Copy3Bytes( puj, &result );
    }
    else
    {
        StoreColorAsBGR(color, puj);
    }
    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, TRUE);

    if( ALPHA_WRITE_ENABLED( cfb ) )
        (*cfb->alphaBuf.store)(&cfb->alphaBuf, frag->x, frag->y, color);
}

STATIC void FASTCALL DisplayRGBStore(__GLcolorBuffer *cfb,
                                     const __GLfragment *frag)
{
    GLint x, y;
    GLubyte *puj;
    GLuint result;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint enables = gc->state.enables.general;
    __GLcolor blendColor;
    const __GLcolor *color;
    GLuint dst_pix;

    ASSERT_CHOP_ROUND();

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;
    // x & y are screen coords now

    puj = gengc->ColorsBits;

    if( enables & __GL_BLEND_ENABLE )
    {
        color = &blendColor;
        (*gc->procs.blend)( gc, cfb, frag, &blendColor );
    }
    else
    {
        color = &(frag->color);
    }

    if (cfb->buf.flags & NEED_FETCH)
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
        dst_pix = *(GLuint *)puj;
        UnditheredRGBColorToBuffer(color, cfb, result, GLuint);

        if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
        {
            result =
                DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                gc->modes.allMask;
        }

        if (cfb->buf.flags & COLORMASK_ON)
        {
            result = (dst_pix & cfb->destMask) |
                (result & cfb->sourceMask);
        }

        Copy3Bytes( puj, &result );
    }
    else
    {
        StoreColorAsRGB(color, puj);
    }
    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, TRUE);

    if( ALPHA_WRITE_ENABLED( cfb ) )
        (*cfb->alphaBuf.store)(&cfb->alphaBuf, frag->x, frag->y, color);
}

STATIC void FASTCALL DisplayBitfield16Store(__GLcolorBuffer *cfb,
                                            const __GLfragment *frag)
{
    GLint x, y;
    GLushort result, *pus;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    __GLfloat incr;
    GLuint enables = gc->state.enables.general;
    __GLcolor blendColor;
    const __GLcolor *color;
    GLushort dst_pix;

    ASSERT_CHOP_ROUND();

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;
    // x & y are screen coords now

    incr = (enables & __GL_DITHER_ENABLE) ?
        fDitherIncTable[__GL_DITHER_INDEX(frag->x, frag->y)] : __glHalf;

    pus = gengc->ColorsBits;

    if( enables & __GL_BLEND_ENABLE )
    {
        color = &blendColor;
        (*gc->procs.blend)( gc, cfb, frag, &blendColor );
    }
    else
    {
        color = &(frag->color);
    }

    DitheredColorToBuffer(color, incr, cfb, result, GLushort);

    if (cfb->buf.flags & NEED_FETCH)
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
        dst_pix = *pus;

        if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
        {
            result = (GLushort)
                (DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                 gc->modes.allMask);
        }

        if (cfb->buf.flags & COLORMASK_ON)
        {
            result = (GLushort)((dst_pix & cfb->destMask) |
                                (result & cfb->sourceMask));
        }
    }

    *pus = result;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, TRUE);

    if( ALPHA_BUFFER_WRITE( cfb ) )
        (*cfb->alphaBuf.store)(&cfb->alphaBuf, frag->x, frag->y, color);
}

STATIC void FASTCALL DisplayBitfield32Store(__GLcolorBuffer *cfb,
                                            const __GLfragment *frag)
{
    GLint x, y;
    GLuint result, *pul;
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint enables = gc->state.enables.general;
    __GLcolor blendColor;
    const __GLcolor *color;
    GLuint dst_pix;

    ASSERT_CHOP_ROUND();

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, frag->x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, frag->y) + cfb->buf.yOrigin;
    // x & y are screen coords now

    pul = gengc->ColorsBits;

    if( enables & __GL_BLEND_ENABLE )
    {
        color = &blendColor;
        (*gc->procs.blend)( gc, cfb, frag, &blendColor );
    }
    else
    {
        color = &(frag->color);
    }

    UnditheredColorToBuffer(color, cfb, result, GLuint);

    if (cfb->buf.flags & NEED_FETCH)
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
        dst_pix = *pul;

        if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
        {
            result =
                DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                gc->modes.allMask;
        }

        if (cfb->buf.flags & COLORMASK_ON)
        {
            result = (dst_pix & cfb->destMask) |
                (result & cfb->sourceMask);
        }
    }

    *pul = result;
    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, TRUE);

    if( ALPHA_BUFFER_WRITE( cfb ) )
        (*cfb->alphaBuf.store)(&cfb->alphaBuf, frag->x, frag->y, color);
}

STATIC void FASTCALL AlphaStore(__GLcolorBuffer *cfb,
                                    const __GLfragment *frag)
{
    (*cfb->alphaBuf.store)(&cfb->alphaBuf, frag->x, frag->y, &(frag->color) );
}

/******************************Public*Routine******************************\
* Index8StoreSpan
*
* Copies the current span in the renderer into a bitmap.  If bDIB is TRUE,
* then the bitmap is the display in DIB format (or a memory DC).  If bDIB
* is FALSE, then the bitmap is an offscreen scanline buffer and it will be
* output to the buffer by (*gengc->pfnCopyPixels)().
*
* This handles 8-bit CI mode.  Blending and dithering are supported.
*
* Returns:
*   GL_FALSE always.  Soft code ignores return value.
*
* History:
*  15-Nov-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

//XXX The returnSpan routine follows this routine very closely.  Any changes
//XXX to this routine should also be reflected in the returnSpan routine

STATIC GLboolean FASTCALL Index8StoreSpan( __GLcontext *gc )
{
    GLint xFrag, yFrag;             // current fragment coordinates
    __GLcolor *cp;                  // current fragment color
    __GLcolorBuffer *cfb;           // color frame buffer

    GLint xScr, yScr;               // current screen (pixel) coordinates
    GLubyte result, *puj;           // current pixel color, current pixel ptr
    GLubyte *pujEnd;                // end of scan line
    __GLfloat incr;                 // current dither adj.

    GLint w;                        // span width
    ULONG ulSpanVisibility;         // span visibility mode
    GLint cWalls;
    GLint *Walls;

    __GLGENcontext *gengc;          // generic graphics context
    GLuint enables;                 // modes enabled in graphics context
    GLuint flags;
    GLboolean bDIB;
    GLubyte dst_pix;

    ASSERT_CHOP_ROUND();

// Get span position and length.

    w = gc->polygon.shader.length;
    xFrag = gc->polygon.shader.frag.x;
    yFrag = gc->polygon.shader.frag.y;

    gengc = (__GLGENcontext *)gc;
    cfb = gc->drawBuffer;

    xScr = __GL_UNBIAS_X(gc, xFrag) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, yFrag) + cfb->buf.yOrigin;
    enables = gc->state.enables.general;
    flags = cfb->buf.flags;
    bDIB = flags & DIB_FORMAT;

    if( !bDIB || (flags & NO_CLIP) )
    {
    // Device managed or unclipped surface
        ulSpanVisibility = WGL_SPAN_ALL;
    }
    else
    {
    // Device in BITMAP format
        ulSpanVisibility = wglSpanVisible(xScr, yScr, w, &cWalls, &Walls);
    }

// Proceed as long as the span is (partially or fully) visible.
    if (ulSpanVisibility  != WGL_SPAN_NONE)
    {
        GLboolean bCheckWalls = GL_FALSE;
        GLboolean bDraw;
        GLint NextWall;

        if (ulSpanVisibility == WGL_SPAN_PARTIAL)
        {
            bCheckWalls = GL_TRUE;
            if (cWalls & 0x01)
            {
                bDraw = GL_TRUE;
            }
            else
            {
                bDraw = GL_FALSE;
            }
            NextWall = *Walls++;
            cWalls--;
        }
    // Get pointers to fragment colors array and frame buffer.

        cp = gc->polygon.shader.colors;
        cfb = gc->polygon.shader.cfb;

    // Get pointer to bitmap.

        puj = bDIB ? (GLubyte *)((ULONG_PTR)cfb->buf.base + (yScr*cfb->buf.outerWidth) + xScr)
                     : gengc->ColorsBits;
        pujEnd = puj + w;

    // Case: no dithering, no masking, no blending
    //
    // Check for the common case (which we'll do the fastest).

        if ( !(enables & (__GL_DITHER_ENABLE)) &&
             !(cfb->buf.flags & NEED_FETCH) &&
             !(enables & __GL_BLEND_ENABLE ) )
        {
            //!!!XXX -- we can also opt. by unrolling the loops

            incr = __glHalf;
            for (; puj < pujEnd; puj++, cp++)
            {
                if (bCheckWalls)
                {
                    if (xScr++ >= NextWall)
                    {
                        if (bDraw)
                            bDraw = GL_FALSE;
                        else
                            bDraw = GL_TRUE;
                        if (cWalls <= 0)
                        {
                            NextWall = gc->constants.maxViewportWidth;
                        }
                        else
                        {
                            NextWall = *Walls++;
                            cWalls--;
                        }
                    }
                    if (bDraw == GL_FALSE)
                        continue;
                }

                DitheredRGBColorToBuffer(cp, incr, cfb, result, GLubyte);
                *puj = gengc->pajTranslateVector[result];
            }
        }

    // Case: dithering, no masking, no blending
    //
    // Dithering is pretty common for 8-bit displays, so its probably
    // worth special case also.

        else if ( !(cfb->buf.flags & NEED_FETCH) &&
                  !(enables & __GL_BLEND_ENABLE) )
        {
            for (; puj < pujEnd; puj++, cp++, xFrag++)
            {
                if (bCheckWalls)
                {
                    if (xScr++ >= NextWall)
                    {
                        if (bDraw)
                            bDraw = GL_FALSE;
                        else
                            bDraw = GL_TRUE;
                        if (cWalls <= 0)
                        {
                            NextWall = gc->constants.maxViewportWidth;
                        }
                        else
                        {
                            NextWall = *Walls++;
                            cWalls--;
                        }
                    }
                    if (bDraw == GL_FALSE)
                        continue;
                }
                incr = fDitherIncTable[__GL_DITHER_INDEX(xFrag, yFrag)];

                DitheredRGBColorToBuffer(cp, incr, cfb, result, GLubyte);
                *puj = gengc->pajTranslateVector[result];
            }
        }

    // Case: general
    //
    // Otherwise, we'll do it slower.

        else
        {
            // Fetch pixels we will modify:

            if( (!bDIB) && (cfb->buf.flags & NEED_FETCH) )
                (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, FALSE );

            // Blend.
            if (enables & __GL_BLEND_ENABLE)
            {
                int i;

                // this overwrites fragment colors array with blended values
                SPECIAL_ALPHA_BLEND_SPAN(
                        (dst_pix =
                         gengc->pajInvTranslateVector[*(puj+i)]));
            }

            for (; puj < pujEnd; puj++, cp++)
            {
                if (bCheckWalls)
                {
                    if (xScr++ >= NextWall)
                    {
                        if (bDraw)
                            bDraw = GL_FALSE;
                        else
                            bDraw = GL_TRUE;
                        if (cWalls <= 0)
                        {
                            NextWall = gc->constants.maxViewportWidth;
                        }
                        else
                        {
                            NextWall = *Walls++;
                            cWalls--;
                        }
                    }
                    if (bDraw == GL_FALSE)
                        continue;
                }
            // Dither.

                if (enables & __GL_DITHER_ENABLE)
                {
                    incr = fDitherIncTable[__GL_DITHER_INDEX(xFrag, yFrag)];
                    xFrag++;
                }
                else
                {
                    incr = __glHalf;
                }

            // Convert the RGB color to color index.

                DitheredRGBColorToBuffer(cp, incr, cfb, result, GLubyte);

            // Color mask

                if (cfb->buf.flags & NEED_FETCH)
                {
                    dst_pix = gengc->pajInvTranslateVector[*puj];

                    if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
                    {
                        result = (GLubyte)
                            (DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                             gc->modes.allMask);
                    }

                    if (cfb->buf.flags & COLORMASK_ON)
                    {
                        result = (GLubyte)((dst_pix & cfb->destMask) |
                                           (result & cfb->sourceMask));
                    }
                }

                *puj = gengc->pajTranslateVector[result];
            }
        }

    // Output the offscreen scanline buffer to the device.  The function
    // (*gengc->pfnCopyPixels) should handle clipping.

        if (!bDIB)
            (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, TRUE);

        // Note that we ignore walls here for simplicity...
        if( ALPHA_WRITE_ENABLED( cfb ) )
            (*cfb->alphaBuf.storeSpan)( &cfb->alphaBuf );
    }

    return GL_FALSE;
}

/******************************Public*Routine******************************\
* Bitfield16StoreSpan
*
* Copies the current span in the renderer into a bitmap.  If bDIB is TRUE,
* then the bitmap is the display in DIB format (or a memory DC).  If bDIB
* is FALSE, then the bitmap is an offscreen scanline buffer and it will be
* output to the buffer by (*gengc->pfnCopyPixels)().
*
* This handles general 16-bit BITFIELDS mode.  Blending is supported.  There
* is dithering.
*
* Returns:
*   GL_FALSE always.  Soft code ignores return value.
*
* History:
*  08-Dec-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

//XXX The returnSpan routine follows this routine very closely.  Any changes
//XXX to this routine should also be reflected in the returnSpan routine

STATIC GLboolean FASTCALL 
Bitfield16StoreSpanPartial(__GLcontext *gc, GLboolean bDIB, GLint cWalls, GLint *Walls )
{
    GLint xFrag, yFrag;             // current fragment coordinates
    __GLcolor *cp;                  // current fragment color
    __GLcolorBuffer *cfb;           // color frame buffer

    GLint xScr, yScr;               // current screen (pixel) coordinates
    GLushort result, *pus;          // current pixel color, current pixel ptr
    GLushort *pusEnd;               // end of scan line
    __GLfloat incr;                 // current dither adj.

    GLint w;                        // span width
    GLboolean bDraw;
    GLint NextWall;

    __GLGENcontext *gengc;          // generic graphics context
    GLuint enables;                 // modes enabled in graphics context
    GLuint flags;
    GLushort dst_pix;

// Get span position and length.

    w = gc->polygon.shader.length;
    xFrag = gc->polygon.shader.frag.x;
    yFrag = gc->polygon.shader.frag.y;

    gengc = (__GLGENcontext *)gc;
    cfb = gc->drawBuffer;

    xScr = __GL_UNBIAS_X(gc, xFrag) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, yFrag) + cfb->buf.yOrigin;
    enables = gc->state.enables.general;
    flags = cfb->buf.flags;


    if (cWalls & 0x01)
    {
        bDraw = GL_TRUE;
    }
    else
    {
        bDraw = GL_FALSE;
    }
    NextWall = *Walls++;
    cWalls--;

    // Get pointers to fragment colors array and frame buffer.

    cp = gc->polygon.shader.colors;
    cfb = gc->polygon.shader.cfb;

    // Get pointer to bitmap.

    pus = bDIB ? (GLushort *)((ULONG_PTR)cfb->buf.base + (yScr*cfb->buf.outerWidth) + (xScr<<1))
                 : gengc->ColorsBits;
    pusEnd = pus + w;

    // Case: no masking, no dithering, no blending

    if ( !(enables & (__GL_DITHER_ENABLE)) &&
         !(cfb->buf.flags & NEED_FETCH) &&
         !(enables & __GL_BLEND_ENABLE) )
    {
        incr = __glHalf;
        for (; pus < pusEnd; pus++, cp++)
        {
            if (xScr++ >= NextWall)
            {
                if (bDraw)
                    bDraw = GL_FALSE;
                else
                    bDraw = GL_TRUE;
                if (cWalls <= 0)
                {
                    NextWall = gc->constants.maxViewportWidth;
                }
                else
                {
                    NextWall = *Walls++;
                    cWalls--;
                }
            }
            if (bDraw == GL_FALSE)
                continue;
            DitheredColorToBuffer(cp, incr, cfb, result, GLushort);
            *pus = result;
        }
    }

    // Case: dithering, no masking, no blending

    else if ( !(cfb->buf.flags & NEED_FETCH) &&
              !(enables & __GL_BLEND_ENABLE) )
    {
        for (; pus < pusEnd; pus++, cp++, xFrag++)
        {
            if (xScr++ >= NextWall)
            {
                if (bDraw)
                    bDraw = GL_FALSE;
                else
                    bDraw = GL_TRUE;
                if (cWalls <= 0)
                {
                    NextWall = gc->constants.maxViewportWidth;
                }
                else
                {
                    NextWall = *Walls++;
                    cWalls--;
                }
            }
            if (bDraw == GL_FALSE)
                continue;
            incr = fDitherIncTable[__GL_DITHER_INDEX(xFrag, yFrag)];

            DitheredColorToBuffer(cp, incr, cfb, result, GLushort);
            *pus = result;
        }
    }

    // All other cases

    else
    {
        if( (!bDIB) && (cfb->buf.flags & NEED_FETCH) )
            (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, FALSE);

        if ( enables & __GL_BLEND_ENABLE )
        {
            int i;

            // this overwrites fragment colors array with blended values
            // XXX is the +i handled properly by the optimizer ?
            SPECIAL_ALPHA_BLEND_SPAN((dst_pix = *(pus+i)));
        }

        for (; pus < pusEnd; pus++, cp++)
        {
            if (xScr++ >= NextWall)
            {
                if (bDraw)
                    bDraw = GL_FALSE;
                else
                    bDraw = GL_TRUE;
                if (cWalls <= 0)
                {
                    NextWall = gc->constants.maxViewportWidth;
                }
                else
                {
                    NextWall = *Walls++;
                    cWalls--;
                }
            }
            if (bDraw == GL_FALSE)
                continue;
            // Dither.

            if ( enables & __GL_DITHER_ENABLE )
            {
                incr = fDitherIncTable[__GL_DITHER_INDEX(xFrag, yFrag)];
                xFrag++;
            }
            else
            {
                incr = __glHalf;
            }

            // Convert color to 16BPP format.

            DitheredColorToBuffer(cp, incr, cfb, result, GLushort);

            // Store result with optional masking.

            if (cfb->buf.flags & NEED_FETCH)
            {
                dst_pix = *pus;

                if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
                {
                    result = (GLushort)
                        (DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                         gc->modes.allMask);
                }

                if ( cfb->buf.flags & COLORMASK_ON )
                {
                    result = (GLushort)((dst_pix & cfb->destMask) |
                                      (result & cfb->sourceMask));
                }
            }
            *pus = result;
        }
    }

    // Output the offscreen scanline buffer to the device.  The function
    // (*gengc->pfnCopyPixels) should handle clipping.

    if (!bDIB)
        (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, TRUE);

    if( ALPHA_BUFFER_WRITE( cfb ) )
        (*cfb->alphaBuf.storeSpan)( &cfb->alphaBuf );

    return GL_FALSE;
}

STATIC GLboolean FASTCALL Bitfield16StoreSpan(__GLcontext *gc)
{
    GLint xFrag, yFrag;             // current fragment coordinates
    __GLcolor *cp;                  // current fragment color
    __GLcolorBuffer *cfb;           // color frame buffer
    GLboolean   bDIB;

    GLint xScr, yScr;               // current screen (pixel) coordinates
    GLushort result, *pus;          // current pixel color, current pixel ptr
    GLushort *pusEnd;               // end of scan line
    __GLfloat incr;                 // current dither adj.

    GLint w;                        // span width
    GLint cWalls;
    GLint *Walls;

    __GLGENcontext *gengc;          // generic graphics context
    GLuint enables;                 // modes enabled in graphics context
    GLuint flags;
    GLushort dst_pix;

    ASSERT_CHOP_ROUND();

// Get span position and length.

    w = gc->polygon.shader.length;
    xFrag = gc->polygon.shader.frag.x;
    yFrag = gc->polygon.shader.frag.y;

    gengc = (__GLGENcontext *)gc;
    cfb = gc->drawBuffer;

    xScr = __GL_UNBIAS_X(gc, xFrag) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, yFrag) + cfb->buf.yOrigin;
    enables = gc->state.enables.general;
    flags = cfb->buf.flags;
    bDIB = flags & DIB_FORMAT;

    // Check span visibility 
    if( bDIB && !(flags & NO_CLIP) )
    {
        // Device in BITMAP format
        ULONG ulSpanVisibility;         // span visibility mode

        ulSpanVisibility = wglSpanVisible(xScr, yScr, w, &cWalls, &Walls);

        if (ulSpanVisibility  == WGL_SPAN_NONE)
            return GL_FALSE;
        else if (ulSpanVisibility == WGL_SPAN_PARTIAL)
            return Bitfield16StoreSpanPartial( gc, bDIB, cWalls, Walls );
        // else span fully visible
    }

    // Get pointers to fragment colors array and frame buffer.

    cp = gc->polygon.shader.colors;
    cfb = gc->polygon.shader.cfb;

    // Get pointer to bitmap.

    pus = bDIB ? (GLushort *)((ULONG_PTR)cfb->buf.base + (yScr*cfb->buf.outerWidth) + (xScr<<1))
                 : gengc->ColorsBits;
    pusEnd = pus + w;

    // Case: no masking, no dithering, no blending

    if ( !(enables & (__GL_DITHER_ENABLE)) &&
         !(cfb->buf.flags & NEED_FETCH) &&
         !(enables & __GL_BLEND_ENABLE) )
    {
        incr = __glHalf;
        if( ALPHA_PIXEL_WRITE( cfb ) ) {
            for (; pus < pusEnd; pus++, cp++)
                DitheredRGBAColorToBuffer(cp, incr, cfb, *pus, GLushort);
        } else {
            for (; pus < pusEnd; pus++, cp++)
                DitheredRGBColorToBuffer(cp, incr, cfb, *pus, GLushort);
        }
    
    }

    // Case: dithering, no masking, no blending

    else if ( !(cfb->buf.flags & NEED_FETCH) &&
              !(enables & __GL_BLEND_ENABLE) )
    {
        if( ALPHA_PIXEL_WRITE( cfb ) ) {
            for (; pus < pusEnd; pus++, cp++, xFrag++)
            {
                incr = fDitherIncTable[__GL_DITHER_INDEX(xFrag, yFrag)];

                DitheredRGBAColorToBuffer(cp, incr, cfb, *pus, GLushort);
            }
        } else {
            for (; pus < pusEnd; pus++, cp++, xFrag++)
            {
                incr = fDitherIncTable[__GL_DITHER_INDEX(xFrag, yFrag)];

                DitheredRGBColorToBuffer(cp, incr, cfb, *pus, GLushort);
            }
        }
    }

    // All other cases

    else
    {
        if( (!bDIB) && (cfb->buf.flags & NEED_FETCH) )
            (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, FALSE);

        if ( enables & __GL_BLEND_ENABLE )
        {
            int i;

            // this overwrites fragment colors array with blended values
            SPECIAL_ALPHA_BLEND_SPAN((dst_pix = *(pus+i)));
        }

        for (; pus < pusEnd; pus++, cp++)
        {
            // Dither.

            if ( enables & __GL_DITHER_ENABLE )
            {
                incr = fDitherIncTable[__GL_DITHER_INDEX(xFrag, yFrag)];
                xFrag++;
            }
            else
            {
                incr = __glHalf;
            }

            // Convert color to 16BPP format.

            DitheredColorToBuffer(cp, incr, cfb, result, GLushort);

            // Store result with optional masking.

            if (cfb->buf.flags & NEED_FETCH)
            {
                dst_pix = *pus;

                if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
                {
                    result = (GLushort)
                        (DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                         gc->modes.allMask);
                }

                if ( cfb->buf.flags & COLORMASK_ON )
                {
                    result = (GLushort)((dst_pix & cfb->destMask) |
                                      (result & cfb->sourceMask));
                }
            }
            *pus = result;
        }
    }

    // Output the offscreen scanline buffer to the device.  The function
    // (*gengc->pfnCopyPixels) should handle clipping.

    if (!bDIB)
        (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, TRUE);

    if( ALPHA_BUFFER_WRITE( cfb ) )
        (*cfb->alphaBuf.storeSpan)( &cfb->alphaBuf );
    return GL_FALSE;
}

/******************************Public*Routine******************************\
* BGRStoreSpan
*
* Copies the current span in the renderer into a bitmap.  If bDIB is TRUE,
* then the bitmap is the display in DIB format (or a memory DC).  If bDIB
* is FALSE, then the bitmap is an offscreen scanline buffer and it will be
* output to the buffer by (*gengc->pfnCopyPixels)().
*
* This handles GBR 24-bit mode.  Blending is supported.  There
* is no dithering.
*
* Returns:
*   GL_FALSE always.  Soft code ignores return value.
*
* History:
*  10-Jan-1994 -by- Marc Fortier [v-marcf]
* Wrote it.
\**************************************************************************/

//XXX The returnSpan routine follows this routine very closely.  Any changes
//XXX to this routine should also be reflected in the returnSpan routine

STATIC GLboolean FASTCALL BGRStoreSpan(__GLcontext *gc )
{
    __GLcolor *cp;                  // current fragment color
    __GLcolorBuffer *cfb;           // color frame buffer

    GLint xScr, yScr;               // current screen (pixel) coordinates
    GLubyte *puj;                   // current pixel ptr
    GLuint *pul;                    // current pixel ptr
    GLuint result;                  // current pixel color
    GLubyte *pujEnd;                 // end of scan line

    GLint w;                        // span width
    ULONG ulSpanVisibility;         // span visibility mode
    GLint cWalls;
    GLint *Walls;

    __GLGENcontext *gengc;          // generic graphics context
    GLuint enables;                 // modes enabled in graphics context
    GLuint flags;
    GLboolean   bDIB;
    GLuint dst_pix;

    ASSERT_CHOP_ROUND();

// Get span position and length.

    w = gc->polygon.shader.length;

    gengc = (__GLGENcontext *)gc;
    cfb = gc->drawBuffer;

    xScr = __GL_UNBIAS_X(gc, gc->polygon.shader.frag.x) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, gc->polygon.shader.frag.y) + cfb->buf.yOrigin;
    enables = gc->state.enables.general;

    flags = cfb->buf.flags;
    bDIB = flags & DIB_FORMAT;

    if( !bDIB || (flags & NO_CLIP) )
    {
// Device managed or unclipped surface
        ulSpanVisibility = WGL_SPAN_ALL;
    }
    else
    {
// Device in BITMAP format
        ulSpanVisibility = wglSpanVisible(xScr, yScr, w, &cWalls, &Walls);
    }

// Proceed as long as the span is (partially or fully) visible.
    if (ulSpanVisibility  != WGL_SPAN_NONE)
    {
        GLboolean bCheckWalls = GL_FALSE;
        GLboolean bDraw;
        GLint NextWall;

        if (ulSpanVisibility == WGL_SPAN_PARTIAL)
        {
            bCheckWalls = GL_TRUE;
            if (cWalls & 0x01)
            {
                bDraw = GL_TRUE;
            }
            else
            {
                bDraw = GL_FALSE;
            }
            NextWall = *Walls++;
            cWalls--;
        }
    // Get pointers to fragment colors array and frame buffer.

        cp = gc->polygon.shader.colors;
        cfb = gc->polygon.shader.cfb;

    // Get pointer to bitmap.

        puj = bDIB ? (GLubyte *)((ULONG_PTR)cfb->buf.base + (yScr*cfb->buf.outerWidth) + (xScr*3))
                     : gengc->ColorsBits;
        pujEnd = puj + 3*w;

    // Case: no masking, no blending

        //!!!XXX -- do extra opt. for RGB and BGR cases

        //!!!XXX -- we can also opt. by unrolling the loops

        if ( !(cfb->buf.flags & NEED_FETCH) &&
             !(enables & __GL_BLEND_ENABLE) )
        {
            for (; puj < pujEnd; cp++)
            {
                if (bCheckWalls)
                {
                    if (xScr++ >= NextWall)
                    {
                        if (bDraw)
                            bDraw = GL_FALSE;
                        else
                            bDraw = GL_TRUE;
                        if (cWalls <= 0)
                        {
                            NextWall = gc->constants.maxViewportWidth;
                        }
                        else
                        {
                            NextWall = *Walls++;
                            cWalls--;
                        }
                    }
                    if (bDraw == GL_FALSE) {
                        puj += 3;
                        continue;
                    }
                }
                StoreColorAsBGR(cp, puj);
            }
        }

    // All other cases

        else
        {
            if( (!bDIB) && (cfb->buf.flags & NEED_FETCH) )
                (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, FALSE);

            if (enables & __GL_BLEND_ENABLE)
            {
                // this overwrites fragment colors array with blended values
                (*gc->procs.blendSpan)( gc );
            }

            for (; puj < pujEnd; cp++)
            {
                if (bCheckWalls)
                {
                    if (xScr++ >= NextWall)
                    {
                        if (bDraw)
                            bDraw = GL_FALSE;
                        else
                            bDraw = GL_TRUE;
                        if (cWalls <= 0)
                        {
                            NextWall = gc->constants.maxViewportWidth;
                        }
                        else
                        {
                            NextWall = *Walls++;
                            cWalls--;
                        }
                    }
                    if (bDraw == GL_FALSE) {
                        puj += 3;
                        continue;
                    }
                }

                if (cfb->buf.flags & NEED_FETCH)
                {
                    Copy3Bytes(&dst_pix, puj);
                    UnditheredRGBColorToBuffer(cp, cfb, result, GLuint);

                    if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
                    {
                        result =
                            DoLogicOp(gc->state.raster.logicOp, result,
                                      dst_pix) & gc->modes.allMask;
                    }

                    if (cfb->buf.flags & COLORMASK_ON)
                    {
                        result = (result & cfb->sourceMask) |
                            (dst_pix & cfb->destMask);
                    }

                    Copy3Bytes( puj, &result );
                    puj += 3;
                }
                else
                {
                    StoreColorAsBGR(cp, puj);
                }
            }
        }

    // Output the offscreen scanline buffer to the device.  The function
    // (*gengc->pfnCopyPixels) should handle clipping.

        if (!bDIB)
            (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, TRUE);

        if( ALPHA_WRITE_ENABLED( cfb ) )
            (*cfb->alphaBuf.storeSpan)( &cfb->alphaBuf );
    }

    return GL_FALSE;
}

/******************************Public*Routine******************************\
* Bitfield32StoreSpan
*
* Copies the current span in the renderer into a bitmap.  If bDIB is TRUE,
* then the bitmap is the display in DIB format (or a memory DC).  If bDIB
* is FALSE, then the bitmap is an offscreen scanline buffer and it will be
* output to the buffer by (*gengc->pfnCopyPixels)().
*
* This handles general 32-bit BITFIELDS mode.  Blending is supported.  There
* is no dithering.
*
* Returns:
*   GL_FALSE always.  Soft code ignores return value.
*
* History:
*  15-Nov-1993 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

//XXX The returnSpan routine follows this routine very closely.  Any changes
//XXX to this routine should also be reflected in the returnSpan routine

STATIC GLboolean FASTCALL 
Bitfield32StoreSpanPartial(__GLcontext *gc, GLboolean bDIB, GLint cWalls, GLint *Walls )
{
    __GLcolor *cp;                  // current fragment color
    __GLcolorBuffer *cfb;           // color frame buffer

    GLint xScr, yScr;               // current screen (pixel) coordinates
    GLuint result, *pul;            // current pixel color, current pixel ptr
    GLuint *pulEnd;                 // end of scan line

    GLint w;                        // span width

    GLboolean bDraw;
    GLint NextWall;

    __GLGENcontext *gengc;          // generic graphics context
    GLuint enables;                 // modes enabled in graphics context
    GLuint flags;
    GLuint dst_pix;

// Get span position and length.

    w = gc->polygon.shader.length;

    gengc = (__GLGENcontext *)gc;
    cfb = gc->drawBuffer;

    xScr = __GL_UNBIAS_X(gc, gc->polygon.shader.frag.x) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, gc->polygon.shader.frag.y) + cfb->buf.yOrigin;
    enables = gc->state.enables.general;

    flags = cfb->buf.flags;

    if (cWalls & 0x01)
    {
        bDraw = GL_TRUE;
    }
    else
    {
        bDraw = GL_FALSE;
    }
    NextWall = *Walls++;
    cWalls--;
    
    // Get pointers to fragment colors array and frame buffer.

    cp = gc->polygon.shader.colors;
    cfb = gc->polygon.shader.cfb;

    // Get pointer to bitmap.

    pul = bDIB ? (GLuint *)((ULONG_PTR)cfb->buf.base + (yScr*cfb->buf.outerWidth) + (xScr<<2))
                 : gengc->ColorsBits;
    pulEnd = pul + w;

    // Case: no masking, no blending

    //!!!XXX -- do extra opt. for RGB and BGR cases

    //!!!XXX -- we can also opt. by unrolling the loops

    if ( !(cfb->buf.flags & NEED_FETCH) &&
         !(enables & __GL_BLEND_ENABLE) )
    {
        for (; pul < pulEnd; pul++, cp++)
        {
            if (xScr++ >= NextWall)
            {
                if (bDraw)
                    bDraw = GL_FALSE;
                else
                    bDraw = GL_TRUE;
                if (cWalls <= 0)
                {
                    NextWall = gc->constants.maxViewportWidth;
                }
                else
                {
                    NextWall = *Walls++;
                    cWalls--;
                }
            }
            if (bDraw == GL_FALSE)
                continue;
            UnditheredColorToBuffer(cp, cfb, result, GLuint);
            *pul = result;
        }
    }

    // All other cases

    else
    {
        if( (!bDIB) && (cfb->buf.flags & NEED_FETCH) )
            (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, FALSE);

        if (enables & __GL_BLEND_ENABLE)
        {
            int i;

            SPECIAL_ALPHA_BLEND_SPAN((dst_pix = *(pul+i)));
        }

        for (; pul < pulEnd; pul++, cp++)
        {
            if (xScr++ >= NextWall)
            {
                if (bDraw)
                    bDraw = GL_FALSE;
                else
                    bDraw = GL_TRUE;
                if (cWalls <= 0)
                {
                    NextWall = gc->constants.maxViewportWidth;
                }
                else
                {
                    NextWall = *Walls++;
                    cWalls--;
                }
            }
            if (bDraw == GL_FALSE)
                continue;

            UnditheredColorToBuffer(cp, cfb, result, GLuint);

            //!!!XXX again, opt. by unrolling loop

            if (cfb->buf.flags & NEED_FETCH)
            {
                dst_pix = *pul;

                if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
                {
                    result =
                        DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                        gc->modes.allMask;
                }

                if (cfb->buf.flags & COLORMASK_ON)
                {
                    result = (dst_pix & cfb->destMask) |
                        (result & cfb->sourceMask);
                }
            }
            *pul = result;
        }
    }

    // Output the offscreen scanline buffer to the device.  The function
    // (*gengc->pfnCopyPixels) should handle clipping.

    if (!bDIB)
        (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, TRUE);

    if( ALPHA_BUFFER_WRITE( cfb ) )
        (*cfb->alphaBuf.storeSpan)( &cfb->alphaBuf );

    return GL_FALSE;
}

STATIC GLboolean FASTCALL Bitfield32StoreSpan( __GLcontext *gc )
{
    __GLcolor *cp;                  // current fragment color
    __GLcolorBuffer *cfb;           // color frame buffer
    GLboolean   bDIB;

    GLint xScr, yScr;               // current screen (pixel) coordinates
    GLuint result, *pul;            // current pixel color, current pixel ptr
    GLuint *pulEnd;                 // end of scan line

    GLint w;                        // span width
    ULONG ulSpanVisibility;         // span visibility mode
    GLint cWalls;
    GLint *Walls;

    __GLGENcontext *gengc;          // generic graphics context
    GLuint enables;                 // modes enabled in graphics context
    GLuint flags;
    GLuint dst_pix;

    ASSERT_CHOP_ROUND();

    // Get span position and length.

    w = gc->polygon.shader.length;

    gengc = (__GLGENcontext *)gc;
    cfb = gc->drawBuffer;

    xScr = __GL_UNBIAS_X(gc, gc->polygon.shader.frag.x) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, gc->polygon.shader.frag.y) + cfb->buf.yOrigin;
    enables = gc->state.enables.general;
    flags = cfb->buf.flags;
    bDIB = flags & DIB_FORMAT;

    // Check span visibility 
    if( bDIB && !(flags & NO_CLIP) )
    {
        // Device in BITMAP format
        ULONG ulSpanVisibility;         // span visibility mode

        ulSpanVisibility = wglSpanVisible(xScr, yScr, w, &cWalls, &Walls);

        if (ulSpanVisibility  == WGL_SPAN_NONE)
            return GL_FALSE;
        else if (ulSpanVisibility == WGL_SPAN_PARTIAL)
            return Bitfield32StoreSpanPartial( gc, bDIB, cWalls, Walls );
        // else span fully visible
    }

    // Get pointers to fragment colors array and frame buffer.

    cp = gc->polygon.shader.colors;
    cfb = gc->polygon.shader.cfb;

    // Get pointer to bitmap.

    pul = bDIB ? (GLuint *)((ULONG_PTR)cfb->buf.base + (yScr*cfb->buf.outerWidth) + (xScr<<2))
                 : gengc->ColorsBits;
    pulEnd = pul + w;

    // Case: no masking, no blending

    //!!!XXX -- do extra opt. for RGB and BGR cases

    //!!!XXX -- we can also opt. by unrolling the loops

    if ( !(cfb->buf.flags & NEED_FETCH) &&
         !(enables & __GL_BLEND_ENABLE) )
    {
        if( ALPHA_PIXEL_WRITE( cfb ) ) {
            for (; pul < pulEnd; pul++, cp++)
            {
                UnditheredRGBAColorToBuffer(cp, cfb, result, GLuint);
                *pul = result;
            }
        } else {
            for (; pul < pulEnd; pul++, cp++)
            {
                UnditheredRGBColorToBuffer(cp, cfb, result, GLuint);
                *pul = result;
            }
        }
    }

    // All other cases

    else
    {
        if( (!bDIB) && (cfb->buf.flags & NEED_FETCH) )
            (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, FALSE);

        if (enables & __GL_BLEND_ENABLE)
        {
            int i;

            SPECIAL_ALPHA_BLEND_SPAN((dst_pix = *(pul+i)));
        }

        for (; pul < pulEnd; pul++, cp++)
        {
            UnditheredColorToBuffer(cp, cfb, result, GLuint);

            //!!!XXX again, opt. by unrolling loop

            if (cfb->buf.flags & NEED_FETCH)
            {
                dst_pix = *pul;

                if (enables & __GL_COLOR_LOGIC_OP_ENABLE)
                {
                    result =
                        DoLogicOp(gc->state.raster.logicOp, result, dst_pix) &
                        gc->modes.allMask;
                }

                if (cfb->buf.flags & COLORMASK_ON)
                {
                    result = (dst_pix & cfb->destMask) |
                        (result & cfb->sourceMask);
                }
            }
            *pul = result;
        }
    }

    // Output the offscreen scanline buffer to the device.  The function
    // (*gengc->pfnCopyPixels) should handle clipping.

    if (!bDIB)
        (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, TRUE);

    if( ALPHA_BUFFER_WRITE( cfb ) )
        (*cfb->alphaBuf.storeSpan)( &cfb->alphaBuf );

    return GL_FALSE;
}

STATIC GLboolean FASTCALL AlphaStoreSpan(__GLcontext *gc)
{
    __GLcolorBuffer *cfb = gc->drawBuffer;

    ASSERT_CHOP_ROUND();

    (*cfb->alphaBuf.storeSpan)( &cfb->alphaBuf );
    return GL_FALSE;
}

STATIC GLboolean FASTCALL StoreMaskedSpan(__GLcontext *gc, GLboolean masked)
{
#ifdef REWRITE
    GLint x, y, len;
    int i;
    __GLcolor *cp;
    DWORD *pul;
    WORD *pus;
    BYTE *puj;
    __GLGENcontext *gengc = (__GLGENcontext *)gc;

    len = gc->polygon.shader.length;
    x = __GL_UNBIAS_X(gc, gc->polygon.shader.frag.x);
    y = __GL_UNBIAS_Y(gc, gc->polygon.shader.frag.y);

    cp = gc->polygon.shader.colors;

    switch (gengc->iFormatDC)
    {

    case BMF_8BPP:
        break;

    case BMF_16BPP:
        pus = gengc->ColorsBits;
        for (i = 0; i < len; i++) {
            *pus++ = __GL_COLOR_TO_BMF_16BPP(cp);
            cp++;
        }
        break;

    case BMF_24BPP:
        puj = gengc->ColorsBits;
        for (i = 0; i < len; i++) {
            *puj++ = (BYTE)cp->b;               // XXX check order
            *puj++ = (BYTE)cp->g;
            *puj++ = (BYTE)cp->r;
            cp++;
        }
        break;

    case BMF_32BPP:
        pul = gengc->ColorsBits;
        for (i = 0; i < len; i++) {
            *pul++ = __GL_COLOR_TO_BMF_32BPP(cp);
            cp++;
        }
        break;

    default:
        break;
    }
    if (masked == GL_TRUE)              // XXX mask is BigEndian!!!
    {
        unsigned long *pulstipple;
        unsigned long stip;
        GLint count;

        pul = gengc->StippleBits;
        pulstipple = gc->polygon.shader.stipplePat;
        count = (len+31)/32;
        for (i = 0; i < count; i++) {
            stip = *pulstipple++;
            *pul++ = (stip&0xff)<<24 | (stip&0xff00)<<8 | (stip&0xff0000)>>8 |
                (stip&0xff000000)>>24;
        }
        wglSpanBlt(CURRENT_DC, gengc->ColorsBitmap, gengc->StippleBitmap,
                   x, y, len);
    }
    else
    {
        wglSpanBlt(CURRENT_DC, gengc->ColorsBitmap, (HBITMAP)NULL,
                   x, y, len);
    }
#endif

    return GL_FALSE;
}

#ifdef TESTSTIPPLE
STATIC void FASTCALL MessUpStippledSpan(__GLcontext *gc)
{
    __GLcolor *cp;
    __GLcolorBuffer *cfb;
    __GLstippleWord inMask, bit, *sp;
    GLint count;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    cp = gc->polygon.shader.colors;
    cfb = gc->polygon.shader.cfb;

    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        inMask = *sp++;
        bit = __GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (!(inMask & bit)) {
                cp->r = cfb->redMax;
                cp->g = cfb->greenMax;
                cp->b = cfb->blueMax;
            }

            cp++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
    }
}
#endif

// From the PIXMAP code, calls store for each fragment
STATIC GLboolean FASTCALL SlowStoreSpan(__GLcontext *gc)
{
    int x, x1;
    int i;
    __GLfragment frag;
    __GLcolor *cp;
    __GLcolorBuffer *cfb;
    GLint w;

    w = gc->polygon.shader.length;

    frag.y = gc->polygon.shader.frag.y;
    x = gc->polygon.shader.frag.x;
    x1 = gc->polygon.shader.frag.x + w;
    cp = gc->polygon.shader.colors;
    cfb = gc->polygon.shader.cfb;

    for (i = x; i < x1; i++) {
        frag.x = i;
        frag.color = *cp++;

        (*cfb->store)(cfb, &frag);
    }

    return GL_FALSE;
}

// From the PIXMAP code, calls store for each fragment with mask test
STATIC GLboolean FASTCALL SlowStoreStippledSpan(__GLcontext *gc)
{
    int x;
    __GLfragment frag;
    __GLcolor *cp;
    __GLcolorBuffer *cfb;
    __GLstippleWord inMask, bit, *sp;
    GLint count;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    frag.y = gc->polygon.shader.frag.y;
    x = gc->polygon.shader.frag.x;
    cp = gc->polygon.shader.colors;
    cfb = gc->polygon.shader.cfb;

    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        inMask = *sp++;
        bit = __GL_STIPPLE_SHIFT((__GLstippleWord)0);
        while (--count >= 0) {
            if (inMask & bit) {
                frag.x = x;
                frag.color = *cp;

                (*cfb->store)(cfb, &frag);
            }
            x++;
            cp++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
    }

    return GL_FALSE;
}

//
//  Tables to convert 4-bit index to RGB component
//  These tables assume the VGA fixed palette
//  History:
//      22-NOV-93   Eddie Robinson [v-eddier] Wrote it.
//
#ifdef __GL_DOUBLE

static __GLfloat vfVGAtoR[16] = {
    0.0,    // black
    0.5,    // dim red
    0.0,    // dim green
    0.5,    // dim yellow
    0.0,    // dim blue
    0.5,    // dim magenta
    0.0,    // dim cyan
    0.5,    // dim grey
    0.75,   // medium grey
    1.0,    // bright red
    0.0,    // bright green
    1.0,    // bright yellow
    0.0,    // bright blue
    1.0,    // bright magenta
    0.0,    // bright cyan
    1.0     // white
};

static __GLfloat vfVGAtoG[16] = {
    0.0,    // black
    0.0,    // dim red
    0.5,    // dim green
    0.5,    // dim yellow
    0.0,    // dim blue
    0.0,    // dim magenta
    0.5,    // dim cyan
    0.5,    // dim grey
    0.75,   // medium grey
    0.0,    // bright red
    1.0,    // bright green
    1.0,    // bright yellow
    0.0,    // bright blue
    0.0,    // bright magenta
    1.0,    // bright cyan
    1.0     // white
};

static __GLfloat vfVGAtoB[16] = {
    0.0,    // black
    0.0,    // dim red
    0.0,    // dim green
    0.0,    // dim yellow
    0.5,    // dim blue
    0.5,    // dim magenta
    0.5,    // dim cyan
    0.5,    // dim grey
    0.75,   // medium grey
    0.0,    // bright red
    0.0,    // bright green
    0.0,    // bright yellow
    1.0,    // bright blue
    1.0,    // bright magenta
    1.0,    // bright cyan
    1.0     // white
};

#else

static __GLfloat vfVGAtoR[16] = {
    0.0F,   // black
    0.5F,   // dim red
    0.0F,   // dim green
    0.5F,   // dim yellow
    0.0F,   // dim blue
    0.5F,   // dim magenta
    0.0F,   // dim cyan
    0.5F,   // dim grey
    0.75F,  // medium grey
    1.0F,   // bright red
    0.0F,   // bright green
    1.0F,   // bright yellow
    0.0F,   // bright blue
    1.0F,   // bright magenta
    0.0F,   // bright cyan
    1.0F    // white
};

static __GLfloat vfVGAtoG[16] = {
    0.0F,   // black
    0.0F,   // dim red
    0.5F,   // dim green
    0.5F,   // dim yellow
    0.0F,   // dim blue
    0.0F,   // dim magenta
    0.5F,   // dim cyan
    0.5F,   // dim grey
    0.75F,  // medium grey
    0.0F,   // bright red
    1.0F,   // bright green
    1.0F,   // bright yellow
    0.0F,   // bright blue
    0.0F,   // bright magenta
    1.0F,   // bright cyan
    1.0F    // white
};

static __GLfloat vfVGAtoB[16] = {
    0.0F,   // black
    0.0F,   // dim red
    0.0F,   // dim green
    0.0F,   // dim yellow
    0.5F,   // dim blue
    0.5F,   // dim magenta
    0.5F,   // dim cyan
    0.5F,   // dim grey
    0.75F,  // medium grey
    0.0F,   // bright red
    0.0F,   // bright green
    0.0F,   // bright yellow
    1.0F,   // bright blue
    1.0F,   // bright magenta
    1.0F,   // bright cyan
    1.0F    // white
};

#endif


void
RGBFetchNone(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    result->r = 0.0F;
    result->g = 0.0F;
    result->b = 0.0F;
    if( cfb->buf.gc->modes.alphaBits )
        result->a = 0.0F;
    else
        result->a = cfb->alphaScale;
}

void
RGBReadSpanNone(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *results,
                GLint w)
{
    GLint i;
    __GLcolor *pResults;
    __GLfloat alphaVal;

    if( cfb->buf.gc->modes.alphaBits )
        alphaVal = 0.0F;
    else
        alphaVal = cfb->alphaScale;

    for (i = 0, pResults = results; i < w; i++, pResults++)
    {
        pResults->r = 0.0F;
        pResults->g = 0.0F;
        pResults->b = 0.0F;
        pResults->a = alphaVal;
    }
}

void
DIBIndex4RGBAFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj, pixel;

    // Do alpha first, before x,y unbiased
    if( gc->modes.alphaBits ) {
        (*cfb->alphaBuf.fetch)(&cfb->alphaBuf, x, y, result);
    } else
        result->a = cfb->alphaScale;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                      (y*cfb->buf.outerWidth) + (x >> 1));

    pixel = *puj;
    if (!(x & 1))
        pixel >>= 4;

    pixel = gengc->pajInvTranslateVector[pixel&0xf];
    result->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
    result->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
    result->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
}

void
DIBIndex8RGBFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj, pixel;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    puj = (GLubyte *)((ULONG_PTR)cfb->buf.base + (y*cfb->buf.outerWidth) + x);

    pixel = gengc->pajInvTranslateVector[*puj];
    result->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
    result->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
    result->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
    result->a = cfb->alphaScale;
}

void
DIBIndex8RGBAFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj, pixel;

    (*cfb->alphaBuf.fetch)(&cfb->alphaBuf, x, y, result);

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    puj = (GLubyte *)((ULONG_PTR)cfb->buf.base + (y*cfb->buf.outerWidth) + x);

    pixel = gengc->pajInvTranslateVector[*puj];
    result->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
    result->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
    result->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
}

void
DIBBGRFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                     (y*cfb->buf.outerWidth) + (x * 3));

    result->b = (__GLfloat) *puj++;
    result->g = (__GLfloat) *puj++;
    result->r = (__GLfloat) *puj;
    result->a = cfb->alphaScale;
}

void
DIBBGRAFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;

    (*cfb->alphaBuf.fetch)(&cfb->alphaBuf, x, y, result);

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                     (y*cfb->buf.outerWidth) + (x * 3));

    result->b = (__GLfloat) *puj++;
    result->g = (__GLfloat) *puj++;
    result->r = (__GLfloat) *puj;
}

void
DIBRGBFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                     (y*cfb->buf.outerWidth) + (x * 3));

    result->r = (__GLfloat) *puj++;
    result->g = (__GLfloat) *puj++;
    result->b = (__GLfloat) *puj;
    result->a = cfb->alphaScale;
}

void
DIBRGBAFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;

    (*cfb->alphaBuf.fetch)(&cfb->alphaBuf, x, y, result);

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                     (y*cfb->buf.outerWidth) + (x * 3));

    result->r = (__GLfloat) *puj++;
    result->g = (__GLfloat) *puj++;
    result->b = (__GLfloat) *puj;
}

void
DIBBitfield16RGBFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLushort *pus, pixel;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    pus = (GLushort *)((ULONG_PTR)cfb->buf.base +
                      (y*cfb->buf.outerWidth) + (x << 1));
    pixel = *pus;
    result->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
    result->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
    result->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
    result->a = cfb->alphaScale;
}

void
DIBBitfield16RGBAFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLushort *pus, pixel;
    GLint xScr, yScr;               // current screen (pixel) coordinates

    gengc = (__GLGENcontext *)gc;
    xScr = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    pus = (GLushort *)((ULONG_PTR)cfb->buf.base +
                      (yScr*cfb->buf.outerWidth) + (xScr << 1));
    pixel = *pus;
    result->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
    result->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
    result->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
    if( ALPHA_IN_PIXEL( cfb ) )
        result->a = (__GLfloat) ((pixel & gc->modes.alphaMask) >> cfb->alphaShift);
    else
        (*cfb->alphaBuf.fetch)(&cfb->alphaBuf, x, y, result);
}

void
DIBBitfield32RGBFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint *pul, pixel;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    pul = (GLuint *)((ULONG_PTR)cfb->buf.base +
                    (y*cfb->buf.outerWidth) + (x << 2));
    pixel = *pul;
    result->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
    result->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
    result->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
    result->a = cfb->alphaScale;
}

void
DIBBitfield32RGBAFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint *pul, pixel;
    GLint xScr, yScr;

    gengc = (__GLGENcontext *)gc;
    xScr = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    pul = (GLuint *)((ULONG_PTR)cfb->buf.base +
                    (yScr*cfb->buf.outerWidth) + (xScr << 2));
    pixel = *pul;
    result->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
    result->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
    result->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
    if( ALPHA_IN_PIXEL( cfb ) )
        result->a = (__GLfloat) ((pixel & gc->modes.alphaMask) >> cfb->alphaShift);
    else
        (*cfb->alphaBuf.fetch)(&cfb->alphaBuf, x, y, result);
}

void
DisplayIndex4RGBAFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj, pixel;

    if( gc->modes.alphaBits ) {
        (*cfb->alphaBuf.fetch)(&cfb->alphaBuf, x, y, result);
    } else
        result->a = cfb->alphaScale;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    puj = gengc->ColorsBits;
    pixel = *puj >> 4;
    result->r = vfVGAtoR[pixel];
    result->g = vfVGAtoG[pixel];
    result->b = vfVGAtoB[pixel];
}

void
DisplayIndex8RGBFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj, pixel;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    puj = gengc->ColorsBits;
    pixel = gengc->pajInvTranslateVector[*puj];
    result->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
    result->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
    result->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
    result->a = cfb->alphaScale;
}

void
DisplayIndex8RGBAFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj, pixel;

    (*cfb->alphaBuf.fetch)(&cfb->alphaBuf, x, y, result);

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    puj = gengc->ColorsBits;
    pixel = gengc->pajInvTranslateVector[*puj];
    result->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
    result->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
    result->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
}

void
DisplayBGRFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    puj = gengc->ColorsBits;
    result->b = (__GLfloat) *puj++;
    result->g = (__GLfloat) *puj++;
    result->r = (__GLfloat) *puj;
    result->a = cfb->alphaScale;
}

void
DisplayBGRAFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;

    (*cfb->alphaBuf.fetch)(&cfb->alphaBuf, x, y, result);

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    puj = gengc->ColorsBits;
    result->b = (__GLfloat) *puj++;
    result->g = (__GLfloat) *puj++;
    result->r = (__GLfloat) *puj;
}

void
DisplayRGBFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    puj = gengc->ColorsBits;
    result->r = (__GLfloat) *puj++;
    result->g = (__GLfloat) *puj++;
    result->b = (__GLfloat) *puj;
    result->a = cfb->alphaScale;
}

void
DisplayRGBAFetch(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;

    (*cfb->alphaBuf.fetch)(&cfb->alphaBuf, x, y, result);

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    puj = gengc->ColorsBits;
    result->r = (__GLfloat) *puj++;
    result->g = (__GLfloat) *puj++;
    result->b = (__GLfloat) *puj;
}

void
DisplayBitfield16RGBFetch(__GLcolorBuffer *cfb, GLint x, GLint y,
                          __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLushort *pus, pixel;

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    pus = gengc->ColorsBits;
    pixel = *pus;
    result->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
    result->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
    result->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
    result->a = cfb->alphaScale;
}

void
DisplayBitfield16RGBAFetch(__GLcolorBuffer *cfb, GLint x, GLint y,
                          __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLushort *pus, pixel;
    GLint xScr, yScr;               // current screen (pixel) coordinates

    gengc = (__GLGENcontext *)gc;
    xScr = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    pus = gengc->ColorsBits;
    pixel = *pus;
    result->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
    result->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
    result->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
    if( ALPHA_IN_PIXEL( cfb ) )
        result->a = (__GLfloat) ((pixel & gc->modes.alphaMask) >> cfb->alphaShift);
    else
        (*cfb->alphaBuf.fetch)(&cfb->alphaBuf, x, y, result);
}

void
DisplayBitfield32RGBFetch(__GLcolorBuffer *cfb, GLint x, GLint y,
                          __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint *pul, pixel;

    gengc = (__GLGENcontext *)gc;

    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, 1, FALSE);
    pul = gengc->ColorsBits;
    pixel = *pul;
    result->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
    result->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
    result->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
    result->a = cfb->alphaScale;
}

void
DisplayBitfield32RGBAFetch(__GLcolorBuffer *cfb, GLint x, GLint y,
                          __GLcolor *result)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint *pul, pixel;
    GLint xScr, yScr;

    gengc = (__GLGENcontext *)gc;

    xScr = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, 1, FALSE);
    pul = gengc->ColorsBits;
    pixel = *pul;
    result->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
    result->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
    result->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
    if( ALPHA_IN_PIXEL( cfb ) )
        result->a = (__GLfloat) ((pixel & gc->modes.alphaMask) >> cfb->alphaShift);
    else
        (*cfb->alphaBuf.fetch)(&cfb->alphaBuf, x, y, result);
}

static void
ReadAlphaSpan( __GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *pResults, 
               GLint w )
{
    __GLcontext *gc = cfb->buf.gc;

    if( gc->modes.alphaBits )
        (*cfb->alphaBuf.readSpan)(&cfb->alphaBuf, x, y, w, pResults);
    else {
        for( ; w ; w--, pResults++ )
            pResults->a = cfb->alphaScale;
    }
}

void
DIBIndex4RGBAReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *results,
                     GLint w)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj, pixel;
    __GLcolor *pResults;

    ReadAlphaSpan( cfb, x, y, results, w );

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    puj = (GLubyte *)((ULONG_PTR)cfb->buf.base + (y*cfb->buf.outerWidth) +
                      (x >> 1));

    pResults = results;
    if (x & 1)
    {
        pixel = *puj++;
        pixel = gengc->pajInvTranslateVector[pixel & 0xf];
        pResults->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
        pResults->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
        pResults->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
        pResults++;
        w--;
    }
    while (w > 1)
    {
        pixel = *puj >> 4;
        pixel = gengc->pajInvTranslateVector[pixel];
        pResults->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
        pResults->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
        pResults->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
        pResults++;
        pixel = *puj++;
        pixel = gengc->pajInvTranslateVector[pixel & 0xf];
        pResults->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
        pResults->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
        pResults->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
        pResults++;
        w -= 2;
    }
    if (w > 0)
    {
        pixel = *puj >> 4;
        pixel = gengc->pajInvTranslateVector[pixel];
        pResults->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
        pResults->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
        pResults->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
    }
}

void
DisplayIndex4RGBAReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                         __GLcolor *results, GLint w)
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj, pixel;
    __GLcolor *pResults;

    ReadAlphaSpan( cfb, x, y, results, w );

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    (*gengc->pfnCopyPixels)(gengc, cfb, x, y, w, FALSE);
    puj = gengc->ColorsBits;
    pResults = results;
    while (w > 1)
    {
        pixel = *puj >> 4;
        pResults->r = vfVGAtoR[pixel];
        pResults->g = vfVGAtoG[pixel];
        pResults->b = vfVGAtoB[pixel];
        pResults++;
        pixel = *puj++ & 0xf;
        pResults->r = vfVGAtoR[pixel];
        pResults->g = vfVGAtoG[pixel];
        pResults->b = vfVGAtoB[pixel];
        pResults++;
        w -= 2;
    }
    if (w > 0)
    {
        pixel = *puj >> 4;
        pResults->r = vfVGAtoR[pixel];
        pResults->g = vfVGAtoG[pixel];
        pResults->b = vfVGAtoB[pixel];
    }
}

void
Index8RGBAReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *pResults,
                  GLint w )
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj, pixel;

    ReadAlphaSpan( cfb, x, y, pResults, w );

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    if( cfb->buf.flags & DIB_FORMAT )
    {
        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base + (y*cfb->buf.outerWidth) + x);
    }
    else
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, w, FALSE);
        puj = gengc->ColorsBits;
    }
    for ( ; w; w--, pResults++)
    {
        pixel = gengc->pajInvTranslateVector[*puj++];
        pResults->r = (__GLfloat) ((pixel & gc->modes.redMask) >> cfb->redShift);
        pResults->g = (__GLfloat) ((pixel & gc->modes.greenMask) >> cfb->greenShift);
        pResults->b = (__GLfloat) ((pixel & gc->modes.blueMask) >> cfb->blueShift);
    }
}

void
BGRAReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *pResults, GLint w )
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;

    ReadAlphaSpan( cfb, x, y, pResults, w );

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    if( cfb->buf.flags & DIB_FORMAT )
    {
        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                         (y*cfb->buf.outerWidth) + (x * 3));
    }
    else
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, w, FALSE);
        puj = gengc->ColorsBits;
    }

    for ( ; w; w--, pResults++)
    {
        pResults->b = (__GLfloat) *puj++;
        pResults->g = (__GLfloat) *puj++;
        pResults->r = (__GLfloat) *puj++;
    }
}

void
RGBAReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y, __GLcolor *pResults, GLint w )

{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLubyte *puj;


    ReadAlphaSpan( cfb, x, y, pResults, w );

    gengc = (__GLGENcontext *)gc;
    x = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    y = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    if( cfb->buf.flags & DIB_FORMAT )
    {
        puj = (GLubyte *)((ULONG_PTR)cfb->buf.base +
                         (y*cfb->buf.outerWidth) + (x * 3));
    }
    else
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, x, y, w, FALSE);
        puj = gengc->ColorsBits;
    }

    for ( ; w; w--, pResults++)
    {
        pResults->r = (__GLfloat) *puj++;
        pResults->g = (__GLfloat) *puj++;
        pResults->b = (__GLfloat) *puj++;
    }
}

void
Bitfield16RGBAReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                      __GLcolor *pResults, GLint w )
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLushort *pus, pixel;
    GLint xScr, yScr;

    gengc = (__GLGENcontext *)gc;
    xScr = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    if( cfb->buf.flags & DIB_FORMAT )
    {
        pus = (GLushort *)((ULONG_PTR)cfb->buf.base +
                          (yScr*cfb->buf.outerWidth) + (xScr << 1));
    }
    else
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, FALSE);
        pus = gengc->ColorsBits;
    }
    READ_RGBA_BITFIELD_SPAN( (pixel = *pus++) );
}

void
Bitfield32RGBAReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                      __GLcolor *pResults, GLint w )
{
    __GLcontext *gc = cfb->buf.gc;
    __GLGENcontext *gengc;
    GLuint *pul, pixel;
    GLint xScr, yScr;

    gengc = (__GLGENcontext *)gc;
    xScr = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;

    if( cfb->buf.flags & DIB_FORMAT )
    {
        pul = (GLuint *)((ULONG_PTR)cfb->buf.base +
                          (yScr*cfb->buf.outerWidth) + (xScr << 2));
    }
    else
    {
        (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, FALSE);
        pul = gengc->ColorsBits;
    }

    READ_RGBA_BITFIELD_SPAN( (pixel = *pul++) );
}

/************************************************************************/

// Used in accumulation

// Accumulation helper macros and functions 

// Clamp a color component between 0 and max
#define ACCUM_CLAMP_COLOR_COMPONENT( col, max ) \
    if ((col) < (__GLfloat) 0.0) \
        (col) = (__GLfloat) 0.0; \
    else if ((col) > max ) \
        (col) = max;

// Extract an accumulation buffer color component by shifting and masking, then
// multiply it by scale (Requires ap and icol defined).
#define ACCUM_SCALE_SIGNED_COLOR_COMPONENT( col, shift, sign, mask, scale ) \
        icol = (*ap >> shift) & mask; \
        if (icol & sign) \
            icol |= ~mask; \
        (col) = (icol * scale);

// Fetch and scale a span of rgba values from a 32-bit accumulation buffer
void GetClampedRGBAccum32Values( 
    __GLcolorBuffer *cfb,  GLuint *pac, __GLcolor *cDest, GLint width,
    __GLfloat scale )
{
    GLint w, i;
    GLint icol;
    __GLfloat rval, gval, bval, aval;
    __GLuicolor *shift, *mask, *sign;
    GLuint *ap;
    __GLcolor *cp;
    __GLcontext *gc = cfb->buf.gc;
    __GLaccumBuffer *afb = &gc->accumBuffer;

    rval = scale * afb->oneOverRedScale;
    gval = scale * afb->oneOverGreenScale;
    bval = scale * afb->oneOverBlueScale;
    shift = &afb->shift;
    mask  = &afb->mask;
    sign  = &afb->sign;

    for ( w = width, cp = cDest, ap = pac; w; w--, cp++, ap++ ) {
        ACCUM_SCALE_SIGNED_COLOR_COMPONENT( cp->r, shift->r, sign->r, mask->r, rval );
        ACCUM_CLAMP_COLOR_COMPONENT( cp->r, cfb->redScale );

        ACCUM_SCALE_SIGNED_COLOR_COMPONENT( cp->g, shift->g, sign->g, mask->g, gval );
        ACCUM_CLAMP_COLOR_COMPONENT( cp->g, cfb->greenScale );

        ACCUM_SCALE_SIGNED_COLOR_COMPONENT( cp->b, shift->b, sign->b, mask->b, bval );
        ACCUM_CLAMP_COLOR_COMPONENT( cp->b, cfb->blueScale );
    }

    if( ! ALPHA_WRITE_ENABLED( cfb ) )
        return;

    aval = scale * afb->oneOverAlphaScale;

    for ( w = width, cp = cDest, ap = pac; w; w--, cp++, ap++ ) {
        ACCUM_SCALE_SIGNED_COLOR_COMPONENT( cp->a, shift->a, sign->a, mask->a, aval );
        ACCUM_CLAMP_COLOR_COMPONENT( cp->a, cfb->alphaScale );
    }
}

// Fetch and scale a span of rgba values from a 64-bit accumulation buffer
void GetClampedRGBAccum64Values( 
    __GLcolorBuffer *cfb,  GLshort *pac, __GLcolor *cDest, GLint width,
    __GLfloat scale )
{
    GLint w;
    __GLcontext *gc = cfb->buf.gc;
    __GLaccumBuffer *afb = &gc->accumBuffer;
    __GLfloat rval, gval, bval, aval;
    __GLcolor *cp;
    GLshort *ap;

    rval = scale * afb->oneOverRedScale;
    gval = scale * afb->oneOverGreenScale;
    bval = scale * afb->oneOverBlueScale;

    for ( w = width, cp = cDest, ap = pac; w; w--, cp++, ap+=4 ) {
        cp->r = (ap[0] * rval);
        ACCUM_CLAMP_COLOR_COMPONENT( cp->r, cfb->redScale );
        cp->g = (ap[1] * gval);
        ACCUM_CLAMP_COLOR_COMPONENT( cp->g, cfb->greenScale );
        cp->b = (ap[2] * bval);
        ACCUM_CLAMP_COLOR_COMPONENT( cp->b, cfb->blueScale );
    }

    if( ! ALPHA_WRITE_ENABLED( cfb ) )
        return;

    aval = scale * afb->oneOverAlphaScale;

    // Offset the accumulation pointer to the alpha value:
    ap = pac + 3;

    for ( w = width, cp = cDest; w; w--, cp++, ap+=4 ) {
        cp->a = (*ap * rval);
        ACCUM_CLAMP_COLOR_COMPONENT( cp->a, cfb->alphaScale );
    }
}

/******************************Public*Routine******************************\
* Index4ReturnSpan
*   Reads from a 16-bit accumulation buffer and writes the span to a device or
*   a DIB.  Only dithering and color mask are applied.  Blend is ignored.
*   Since accumulation of 4-bit RGB isn't very useful, this routine is very
*   general and calls through the store function pointers.
*
* History:
*   10-DEC-93 Eddie Robinson [v-eddier] Wrote it.
\**************************************************************************/

//XXX This routine follows the store span routine very closely.  Any changes
//XXX to the store span routine should also be reflected here

void Index4ReturnSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                      const __GLaccumCell *ac, __GLfloat scale, GLint w)
{
    __GLcontext *gc = cfb->buf.gc;
    GLuint *ap;                     // current accum entry
    __GLGENcontext *gengc;          // generic graphics context
    GLuint saveEnables;             // modes enabled in graphics context
    __GLaccumBuffer *afb;
    __GLfragment frag;
    __GLcolor *pAccumCol, *pac;

    afb = &gc->accumBuffer;
    ap = (GLuint *)ac;
    saveEnables = gc->state.enables.general;            // save current enables
    gc->state.enables.general &= ~__GL_BLEND_ENABLE;    // disable blend for store procs
    frag.x = x;
    frag.y = y;

    // Pre-fetch/clamp/scale the accum buffer values
    afb = &gc->accumBuffer;
    pAccumCol = afb->colors;
    GetClampedRGBAccum32Values( cfb, ap, pAccumCol, w, scale );

    for( pac = pAccumCol ; w; w--, pac++ )
    {
        frag.color = *pac;
        (*cfb->store)(cfb, &frag);
        frag.x++;
    }

    gc->state.enables.general = saveEnables;    // restore current enables
}

/******************************Public*Routine******************************\
* Index8ReturnSpan
*   Reads from a 32-bit accumulation buffer and writes the span to a device or
*   a DIB.  Only dithering and color mask are applied.  Blend is ignored.
*
* History:
*   10-DEC-93 Eddie Robinson [v-eddier] Wrote it.
\**************************************************************************/

//XXX This routine follows the store span routine very closely.  Any changes
//XXX to the store span routine should also be reflected here

void Index8ReturnSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                      const __GLaccumCell *ac, __GLfloat scale, GLint w )
{
    __GLcontext *gc = cfb->buf.gc;
    GLuint *ap;                     // current accum entry

    GLint xFrag, yFrag;             // current window (pixel) coordinates
    GLint xScr, yScr;               // current screen (pixel) coordinates
    GLubyte result, *puj;           // current pixel color, current pixel ptr
    GLubyte *pujEnd;                // end of scan line
    __GLfloat inc;                  // current dither adj.
    __GLGENcontext *gengc;          // generic graphics context
    GLuint enables;                 // modes enabled in graphics context
    GLboolean bDIB;
    __GLaccumBuffer *afb;
    GLubyte dst_pix;
    __GLcolor *pAccumCol, *pac;
    ASSERT_CHOP_ROUND();

    gengc = (__GLGENcontext *)gc;

    ap = (GLuint *)ac;
    xFrag = x;
    yFrag = y;
    xScr = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;
    enables = gc->state.enables.general;
    bDIB = cfb->buf.flags & DIB_FORMAT;

// Use to call wglSpanVisible,  if window level security is added reimplement

    // Get pointer to bitmap.

    puj = bDIB ? (GLubyte *)((ULONG_PTR)cfb->buf.base + (yScr*cfb->buf.outerWidth) + xScr)
                 : gengc->ColorsBits;
    pujEnd = puj + w;

    afb = &gc->accumBuffer;
    pAccumCol = afb->colors;
    GetClampedRGBAccum32Values( cfb, ap, pAccumCol, w, scale );
    pac = pAccumCol;

    // Case: no dithering, no masking
    //
    // Check for the common case (which we'll do the fastest).

    if ( !(enables & (__GL_DITHER_ENABLE)) &&
         !(cfb->buf.flags & COLORMASK_ON) )
    {
        //!!!XXX -- we can also opt. by unrolling the loops

        for ( ; puj < pujEnd; puj++, pac++ )
        {
            result = ((BYTE) FTOL(pac->r + __glHalf) << cfb->redShift) |
                     ((BYTE) FTOL(pac->g + __glHalf) << cfb->greenShift) |
                     ((BYTE) FTOL(pac->b + __glHalf) << cfb->blueShift);
            *puj = gengc->pajTranslateVector[result];
        }
    }

    // Case: dithering, no masking, no blending
    //
    // Dithering is pretty common for 8-bit displays, so its probably
    // worth special case also.

    else if ( !(cfb->buf.flags & COLORMASK_ON) )
    {
        for ( ; puj < pujEnd; puj++, pac++, xFrag++)
        {
            inc = fDitherIncTable[__GL_DITHER_INDEX(xFrag, yFrag)];

            result = ((BYTE) FTOL(pac->r + inc) << cfb->redShift) |
                     ((BYTE) FTOL(pac->g + inc) << cfb->greenShift) |
                     ((BYTE) FTOL(pac->b + inc) << cfb->blueShift);
            *puj = gengc->pajTranslateVector[result];
        }
    }

    // Case: general
    //
    // Otherwise, we'll do it slower.

    else
    {
        // Color mask pre-fetch
        if ((cfb->buf.flags & COLORMASK_ON) && !bDIB) {
                (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, FALSE );
        }

        for ( ; puj < pujEnd; puj++, pac++ )
        {
            if (enables & __GL_DITHER_ENABLE)
            {
                inc = fDitherIncTable[__GL_DITHER_INDEX(xFrag, yFrag)];
                xFrag++;
            }
            else
            {
                inc = __glHalf;
            }
            result = ((BYTE)FTOL(pac->r + inc) << cfb->redShift) |
                     ((BYTE)FTOL(pac->g + inc) << cfb->greenShift) |
                     ((BYTE)FTOL(pac->b + inc) << cfb->blueShift);

            // Color mask
            if (cfb->buf.flags & COLORMASK_ON)
            {
                dst_pix = gengc->pajInvTranslateVector[*puj];
                result = (GLubyte)((dst_pix & cfb->destMask) |
                                   (result & cfb->sourceMask));
            }
            *puj = gengc->pajTranslateVector[result];

        }
    }

    // Output the offscreen scanline buffer to the device.  The function
    // (*gengc->pfnCopyPixels) should handle clipping.

    if (!bDIB)
        (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, TRUE);

    // Store alpha values
    if( ALPHA_WRITE_ENABLED( cfb ) )
        (*cfb->alphaBuf.storeSpan2)( &cfb->alphaBuf, x, y, w, pAccumCol );
}

/******************************Public*Routine******************************\
* RGBReturnSpan
*   Reads from a 64-bit accumulation buffer and writes the span to a device or
*   a DIB.  Only dithering and color mask are applied.  Blend is ignored.
*
* History:
*   10-DEC-93 Eddie Robinson [v-eddier] Wrote it.
\**************************************************************************/

//XXX This routine follows the store span routine very closely.  Any changes
//XXX to the store span routine should also be reflected here

void RGBReturnSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                   const __GLaccumCell *ac, __GLfloat scale, GLint w )
{
    __GLcontext *gc = cfb->buf.gc;
    GLshort *ap;                    // current accum entry

    GLint xScr, yScr;               // current screen (pixel) coordinates
    GLubyte *puj;                   // current pixel color, current pixel ptr
    GLubyte *pujEnd;                // end of scan line
    __GLGENcontext *gengc;          // generic graphics context
    GLuint enables;                 // modes enabled in graphics context
    GLboolean bDIB;
    __GLaccumBuffer *afb;
    __GLcolor *pAccumCol, *pac;

    ASSERT_CHOP_ROUND();

    afb = &gc->accumBuffer;
    gengc = (__GLGENcontext *)gc;

    ap = (GLshort *)ac;
    xScr = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;
    enables = gc->state.enables.general;
    bDIB = cfb->buf.flags & DIB_FORMAT;

// Use to call wglSpanVisible,  if window level security is added reimplement

    // Get pointer to bitmap.

    puj = bDIB ? (GLuint *)((ULONG_PTR)cfb->buf.base + (yScr*cfb->buf.outerWidth) + (xScr*3))
                 : gengc->ColorsBits;
    pujEnd = puj + w*3;

    // Pre-fetch/clamp/scale the accum buffer values
    afb = &gc->accumBuffer;
    pAccumCol = afb->colors;
    GetClampedRGBAccum64Values( cfb, ap, pAccumCol, w, scale );
    pac = pAccumCol;

    // Case: no masking

    if ( !(cfb->buf.flags & COLORMASK_ON) )
    {
        for ( ; puj < pujEnd; puj += 3, pac ++ )
        {
            puj[0] = (GLubyte) FTOL(pac->r);
            puj[1] = (GLubyte) FTOL(pac->g);
            puj[2] = (GLubyte) FTOL(pac->b);
        }
    }

    // All other cases
    else
    {
        GLboolean bRedMask, bGreenMask, bBlueMask;
        GLubyte *pujStart = puj;

        // Color mask pre-fetch
    	if (!bDIB)
            (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, FALSE);

        if( gc->state.raster.rMask ) {
            for ( puj = pujStart, pac = pAccumCol; puj < pujEnd; puj += 3, pac++ )
                *puj = (GLubyte) FTOL(pac->r);
        }
        pujStart++; pujEnd++;
        if( gc->state.raster.gMask ) {
            for ( puj = pujStart, pac = pAccumCol; puj < pujEnd; puj += 3, pac++ )
                *puj = (GLubyte) FTOL(pac->g);
        }
        pujStart++; pujEnd++;
        if( gc->state.raster.bMask ) {
            for ( puj = pujStart, pac = pAccumCol; puj < pujEnd; puj += 3, pac++ )
                *puj = (GLubyte) FTOL(pac->b);
        }
    }

    // Output the offscreen scanline buffer to the device.  The function
    // (*gengc->pfnCopyPixels) should handle clipping.

    if (!bDIB)
        (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, TRUE);

    // Store alpha values
    if( ALPHA_WRITE_ENABLED( cfb ) )
        (*cfb->alphaBuf.storeSpan2)( &cfb->alphaBuf, x, y, w, pAccumCol );
}

/******************************Public*Routine******************************\
* BGRReturnSpan
*   Reads from a 64-bit accumulation buffer and writes the span to a device or
*   a DIB.  Only dithering and color mask are applied.  Blend is ignored.
*
* History:
*   10-DEC-93 Eddie Robinson [v-eddier] Wrote it.
\**************************************************************************/

//XXX This routine follows the store span routine very closely.  Any changes
//XXX to the store span routine should also be reflected here

void BGRReturnSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                   const __GLaccumCell *ac, __GLfloat scale, GLint w )
{
    __GLcontext *gc = cfb->buf.gc;
    GLshort *ap;                    // current accum entry
    __GLcolor *pAccumCol, *pac;

    GLint xScr, yScr;               // current screen (pixel) coordinates
    GLubyte *puj;                   // current pixel color, current pixel ptr
    GLubyte *pujEnd;                // end of scan line
    __GLGENcontext *gengc;          // generic graphics context
    GLuint enables;                 // modes enabled in graphics context
    GLboolean bDIB;

    __GLfloat r, g, b;
    __GLfloat rval, gval, bval;
    __GLaccumBuffer *afb;

    ASSERT_CHOP_ROUND();

    afb = &gc->accumBuffer;
    rval = scale * afb->oneOverRedScale;
    gval = scale * afb->oneOverGreenScale;
    bval = scale * afb->oneOverBlueScale;
    gengc = (__GLGENcontext *)gc;

    ap = (GLshort *)ac;
    xScr = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;
    enables = gc->state.enables.general;
    bDIB = cfb->buf.flags & DIB_FORMAT;

// Use to call wglSpanVisible,  if window level security is added reimplement

    // Get pointer to bitmap.

    puj = bDIB ? (GLuint *)((ULONG_PTR)cfb->buf.base + (yScr*cfb->buf.outerWidth) + (xScr*3))
                 : gengc->ColorsBits;
    pujEnd = puj + w*3;

    // Pre-fetch/clamp/scale the accum buffer values
    afb = &gc->accumBuffer;
    pAccumCol = afb->colors;
    GetClampedRGBAccum64Values( cfb, ap, pAccumCol, w, scale );
    pac = pAccumCol;

    // Case: no masking

    if ( !(cfb->buf.flags & COLORMASK_ON) )
    {
        for ( ; puj < pujEnd; puj += 3, pac ++ )
        {
            puj[0] = (GLubyte) FTOL(pac->b);
            puj[1] = (GLubyte) FTOL(pac->g);
            puj[2] = (GLubyte) FTOL(pac->r);
        }
    }

    // All other cases

    else
    {
        GLboolean bRedMask, bGreenMask, bBlueMask;
        GLubyte *pujStart = puj;

        // Color mask pre-fetch
    	if (!bDIB)
            (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, FALSE);

        if( gc->state.raster.bMask ) {
            for ( puj = pujStart, pac = pAccumCol; puj < pujEnd; puj += 3, pac++ )
                *puj = (GLubyte) FTOL(pac->b);
        }
        pujStart++; pujEnd++;
        if( gc->state.raster.gMask ) {
            for ( puj = pujStart, pac = pAccumCol; puj < pujEnd; puj += 3, pac++ )
                *puj = (GLubyte) FTOL(pac->g);
        }
        pujStart++; pujEnd++;
        if( gc->state.raster.rMask ) {
            for ( puj = pujStart, pac = pAccumCol; puj < pujEnd; puj += 3, pac++ )
                *puj = (GLubyte) FTOL(pac->r);
        }
    }

    // Output the offscreen scanline buffer to the device.  The function
    // (*gengc->pfnCopyPixels) should handle clipping.

    if (!bDIB)
        (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, TRUE);

    // Store alpha values
    if( ALPHA_WRITE_ENABLED( cfb ) )
        (*cfb->alphaBuf.storeSpan2)( &cfb->alphaBuf, x, y, w, pAccumCol );
}

/******************************Public*Routine******************************\
* Bitfield16ReturnSpan
*   Reads from a 32-bit accumulation buffer and writes the span to a device or
*   a DIB.  Only dithering and color mask are applied.  Blend is ignored.
*
* History:
*   10-DEC-93 Eddie Robinson [v-eddier] Wrote it.
\**************************************************************************/

//XXX This routine follows the store span routine very closely.  Any changes
//XXX to the store span routine should also be reflected here

void Bitfield16ReturnSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                          const __GLaccumCell *ac, __GLfloat scale, GLint w )
{
    __GLcontext *gc = cfb->buf.gc;
    GLuint *ap;                     // current accum entry

    GLint xFrag, yFrag;             // current fragment coordinates
    GLint xScr, yScr;               // current screen (pixel) coordinates
    GLushort result, *pus;          // current pixel color, current pixel ptr
    GLushort *pusEnd;               // end of scan line
    __GLfloat inc;                  // current dither adj.
    __GLGENcontext *gengc;          // generic graphics context
    GLuint enables;                 // modes enabled in graphics context
    GLboolean bDIB;
    __GLcolor *pAccumCol, *pac;
    __GLaccumBuffer *afb;

    ASSERT_CHOP_ROUND();

    afb = &gc->accumBuffer;
    gengc = (__GLGENcontext *)gc;

    ap = (GLuint *)ac;
    xFrag = x;
    yFrag = y;
    xScr = __GL_UNBIAS_X(gc, xFrag) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, yFrag) + cfb->buf.yOrigin;
    enables = gc->state.enables.general;
    bDIB = cfb->buf.flags & DIB_FORMAT;

// Use to call wglSpanVisible,  if window level security is added reimplement

    // Get pointer to bitmap.

    pus = bDIB ? (GLushort *)((ULONG_PTR)cfb->buf.base + (yScr*cfb->buf.outerWidth) + (xScr<<1))
                 : gengc->ColorsBits;
    pusEnd = pus + w;

    // Pre-fetch/clamp/scale the accum buffer values
    afb = &gc->accumBuffer;
    pAccumCol = afb->colors;
    GetClampedRGBAccum32Values( cfb, ap, pAccumCol, w, scale );
    pac = pAccumCol;

    // Case: no masking, no dithering

    if ( !(enables & (__GL_DITHER_ENABLE)) &&
         !(cfb->buf.flags & COLORMASK_ON) )
    {
        if( ALPHA_PIXEL_WRITE( cfb ) ) {
            for ( ; pus < pusEnd; pus++, pac++ )
            {
                *pus = ((BYTE) FTOL(pac->r + __glHalf) << cfb->redShift) |
                       ((BYTE) FTOL(pac->g + __glHalf) << cfb->greenShift) |
                       ((BYTE) FTOL(pac->b + __glHalf) << cfb->blueShift) |
                       ((BYTE) FTOL(pac->a + __glHalf) << cfb->alphaShift);
            }
        } else {
            for ( ; pus < pusEnd; pus++, pac++ )
            {
                *pus = ((BYTE) FTOL(pac->r + __glHalf) << cfb->redShift) |
                       ((BYTE) FTOL(pac->g + __glHalf) << cfb->greenShift) |
                       ((BYTE) FTOL(pac->b + __glHalf) << cfb->blueShift);
            }
        }
    }

    // Case: dithering, no masking

    else if ( !(cfb->buf.flags & COLORMASK_ON) )
    {
        if( ALPHA_PIXEL_WRITE( cfb ) ) {
            for ( ; pus < pusEnd; pus++, pac++, xFrag++ )
            {
                inc = fDitherIncTable[__GL_DITHER_INDEX(xFrag, yFrag)];
    
                *pus   = ((BYTE) FTOL(pac->r + inc) << cfb->redShift) |
                         ((BYTE) FTOL(pac->g + inc) << cfb->greenShift) |
                         ((BYTE) FTOL(pac->b + inc) << cfb->blueShift) |
                         ((BYTE) FTOL(pac->a + inc) << cfb->alphaShift);
            }
        } else {
            for ( ; pus < pusEnd; pus++, pac++, xFrag++ )
            {
                inc = fDitherIncTable[__GL_DITHER_INDEX(xFrag, yFrag)];
    
                *pus   = ((BYTE) FTOL(pac->r + inc) << cfb->redShift) |
                         ((BYTE) FTOL(pac->g + inc) << cfb->greenShift) |
                         ((BYTE) FTOL(pac->b + inc) << cfb->blueShift);
            }
        }
    }

    // All other cases

    else
    {
        // Color mask pre-fetch
        if (!bDIB)
            (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, FALSE);

        for ( ; pus < pusEnd; pus++, pac++ )
        {
            inc = fDitherIncTable[__GL_DITHER_INDEX(xFrag, yFrag)];

        // Dither.

            if ( enables & __GL_DITHER_ENABLE )
            {
                inc = fDitherIncTable[__GL_DITHER_INDEX(xFrag, yFrag)];
                xFrag++;
            }
            else
            {
                inc = __glHalf;
            }

        // Convert color to 16BPP format.

            result = ((BYTE) FTOL(pac->r + inc) << cfb->redShift) |
                     ((BYTE) FTOL(pac->g + inc) << cfb->greenShift) |
                     ((BYTE) FTOL(pac->b + inc) << cfb->blueShift);
            if( ALPHA_PIXEL_WRITE( cfb ) )
                result |= ((BYTE) FTOL(pac->a + inc) << cfb->alphaShift);

        // Store result with optional masking.

            *pus = (GLushort)((*pus & cfb->destMask) | (result & cfb->sourceMask));
        }
    }

    // Output the offscreen scanline buffer to the device.  The function
    // (*gengc->pfnCopyPixels) should handle clipping.

    if (!bDIB)
        (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, TRUE);

    if( ALPHA_BUFFER_WRITE( cfb ) )
        (*cfb->alphaBuf.storeSpan2)( &cfb->alphaBuf, x, y, w, pAccumCol );

}

/******************************Public*Routine******************************\
* Bitfield32ReturnSpan
*   Reads from a 64-bit accumulation buffer and writes the span to a device or
*   a DIB.  Only dithering and color mask are applied.  Blend is ignored.
*
* History:
*   10-DEC-93 Eddie Robinson [v-eddier] Wrote it.
\**************************************************************************/

//XXX This routine follows the store span routine very closely.  Any changes
//XXX to the store span routine should also be reflected here

void Bitfield32ReturnSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
                          const __GLaccumCell *ac, __GLfloat scale, GLint w )
{
    __GLcontext *gc = cfb->buf.gc;
    GLshort *ap;                    // current accum entry

    GLint xScr, yScr;               // current screen (pixel) coordinates
    GLuint result, *pul;            // current pixel color, current pixel ptr
    GLuint *pulEnd;                 // end of scan line

    __GLGENcontext *gengc;          // generic graphics context
    GLuint enables;                 // modes enabled in graphics context
    GLboolean bDIB;

    __GLfloat r, g, b;
    __GLfloat rval, gval, bval;
    __GLaccumBuffer *afb;
    __GLcolor *pAccumCol, *pac;
    ASSERT_CHOP_ROUND();

    afb = &gc->accumBuffer;
    rval = scale * afb->oneOverRedScale;
    gval = scale * afb->oneOverGreenScale;
    bval = scale * afb->oneOverBlueScale;
    gengc = (__GLGENcontext *)gc;

    ap = (GLshort *)ac;
    xScr = __GL_UNBIAS_X(gc, x) + cfb->buf.xOrigin;
    yScr = __GL_UNBIAS_Y(gc, y) + cfb->buf.yOrigin;
    enables = gc->state.enables.general;
    bDIB = cfb->buf.flags & DIB_FORMAT;

// Use to call wglSpanVisible,  if window level security is added reimplement

    // Get pointer to bitmap.

    pul = bDIB ? (GLuint *)((ULONG_PTR)cfb->buf.base + (yScr*cfb->buf.outerWidth) + (xScr<<2))
                 : gengc->ColorsBits;
    pulEnd = pul + w;

    // Pre-fetch/clamp/scale the accum buffer values
    afb = &gc->accumBuffer;
    pAccumCol = afb->colors;
    GetClampedRGBAccum64Values( cfb, ap, pAccumCol, w, scale );
    pac = pAccumCol;

    // Case: no masking

    if ( !(cfb->buf.flags & COLORMASK_ON) )
    {
        if( ALPHA_PIXEL_WRITE( cfb ) ) {
            for ( ; pul < pulEnd; pul++, pac++ )
            {
                *pul   = ((BYTE) FTOL(pac->r) << cfb->redShift) |
                         ((BYTE) FTOL(pac->g) << cfb->greenShift) |
                         ((BYTE) FTOL(pac->b) << cfb->blueShift) |
                         ((BYTE) FTOL(pac->a) << cfb->alphaShift);
            }
        } else {
            for ( ; pul < pulEnd; pul++, pac++ )
            {
                *pul   = ((BYTE) FTOL(pac->r) << cfb->redShift) |
                         ((BYTE) FTOL(pac->g) << cfb->greenShift) |
                         ((BYTE) FTOL(pac->b) << cfb->blueShift);
            }
        }
    }

    // All other cases

    else
    {
        // Color mask pre-fetch
        if( !bDIB )
            (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, FALSE);

        for ( ; pul < pulEnd; pul++, pac++ )
        {
            result   = ((BYTE) FTOL(pac->r) << cfb->redShift) |
                     ((BYTE) FTOL(pac->g) << cfb->greenShift) |
                     ((BYTE) FTOL(pac->b) << cfb->blueShift);

            if( ALPHA_PIXEL_WRITE( cfb ) )
                result |= ((BYTE) FTOL(pac->a) << cfb->alphaShift);

            //!!!XXX again, opt. by unrolling loop
            *pul = (*pul & cfb->destMask) | (result & cfb->sourceMask);
        }
    }

    // Output the offscreen scanline buffer to the device.  The function
    // (*gengc->pfnCopyPixels) should handle clipping.

    if (!bDIB)
        (*gengc->pfnCopyPixels)(gengc, cfb, xScr, yScr, w, TRUE);

    if( ALPHA_BUFFER_WRITE( cfb ) )
        (*cfb->alphaBuf.storeSpan2)( &cfb->alphaBuf, x, y, w, pAccumCol );
}

STATIC void __glSetDrawBuffer(__GLcolorBuffer *cfb)
{

    DBGENTRY("__glSetDrawBuffer\n");
}

STATIC void setReadBuffer(__GLcolorBuffer *cfb)
{
    DBGENTRY("setReadBuffer\n");
}


/************************************************************************/

STATIC void Resize(__GLGENbuffers *buffers, __GLcolorBuffer *cfb,
                   GLint w, GLint h)
{

    DBGENTRY("Resize\n");

    cfb->buf.width = w;
    cfb->buf.height = h;
}

#define DBG_PICK    LEVEL_ENTRY

// Called at each validate (lots of times, whenever states change)
STATIC void FASTCALL PickRGB(__GLcontext *gc, __GLcolorBuffer *cfb)
{
    __GLGENcontext *gengc;
    GLuint totalMask, sourceMask;
    GLboolean colormask;
    PIXELFORMATDESCRIPTOR *pfmt;
    GLuint enables = gc->state.enables.general;

    sourceMask = 0;
    colormask = GL_FALSE;
    if (gc->state.raster.rMask) {
        sourceMask |= gc->modes.redMask;
    }
    if (gc->state.raster.gMask) {
        sourceMask |= gc->modes.greenMask;
    }
    if (gc->state.raster.bMask) {
        sourceMask |= gc->modes.blueMask;
    }

    totalMask = gc->modes.redMask | gc->modes.greenMask | gc->modes.blueMask;

    gengc = (__GLGENcontext *)gc;

    // If we have alpha bits, need to determine where they belong : for a 
    // generic pixel format, they live in the software alpha buffer, but for
    // an mcd type context they will be on the mcd device (or ALPHA_IN_PIXEL ).
    // This is used by all the 'slow' store/fetch procs.

    if( gc->modes.alphaBits && gengc->pMcdState ) {
        // Set bit in buf.flags indicating alpha is in the pixel
        cfb->buf.flags = cfb->buf.flags | ALPHA_IN_PIXEL_BIT;
    } else {
        // Alpha is not in the pixel, or there is no alpha
        cfb->buf.flags = cfb->buf.flags & ~ALPHA_IN_PIXEL_BIT;
    }

    if( ALPHA_IN_PIXEL( cfb ) ) {
        // There are alpha bits in the pixels, so need to include alpha in mask
        if (gc->state.raster.aMask) {
            sourceMask |= gc->modes.alphaMask;
        }
        totalMask |= gc->modes.alphaMask;
    }

    if (sourceMask == totalMask) {
        cfb->buf.flags = cfb->buf.flags & ~COLORMASK_ON;
    } else {
        cfb->buf.flags = cfb->buf.flags | COLORMASK_ON;
    }
    cfb->sourceMask = sourceMask;
    cfb->destMask = totalMask & ~sourceMask;

    // Determine whether writing alpha values is required
    if( gc->modes.alphaBits && gc->state.raster.aMask )
        cfb->buf.flags = cfb->buf.flags | ALPHA_ON;
    else
        cfb->buf.flags = cfb->buf.flags & ~ALPHA_ON;

    // If we're doing a logic op or there is a color mask we'll need
    // to fetch the destination value before we write
    if ((enables & __GL_COLOR_LOGIC_OP_ENABLE) ||
        (cfb->buf.flags & COLORMASK_ON))
    {
        cfb->buf.flags = cfb->buf.flags | NEED_FETCH;
    }
    else
        cfb->buf.flags = cfb->buf.flags & ~NEED_FETCH;

    // Figure out store routines
    if (gc->state.raster.drawBuffer == GL_NONE) {
        cfb->store = Store_NOT;
        cfb->fetch = RGBFetchNone;
        cfb->readSpan = RGBReadSpanNone;
        cfb->storeSpan = StoreSpanNone;
        cfb->storeStippledSpan = StoreSpanNone;
    } else {
        pfmt = &gengc->gsurf.pfd;

        // Pick functions that work for both DIB and Display formats

        switch(pfmt->cColorBits) {
        case 4:
            cfb->clear = Index4Clear;
            cfb->returnSpan = Index4ReturnSpan;
            break;
        case 8:
            cfb->storeSpan = Index8StoreSpan;
            cfb->readSpan = Index8RGBAReadSpan;
            cfb->returnSpan = Index8ReturnSpan;
            cfb->clear = Index8Clear;
            break;
        case 16:
            cfb->storeSpan = Bitfield16StoreSpan;
            cfb->readSpan = Bitfield16RGBAReadSpan;
            cfb->returnSpan = Bitfield16ReturnSpan;
            cfb->clear = Bitfield16Clear;
            break;
        case 24:
            if (cfb->redShift == 16)
            {
                cfb->storeSpan = BGRStoreSpan;
                cfb->readSpan = BGRAReadSpan;
                cfb->returnSpan = BGRReturnSpan;
            } else {
                // XXX why no RGBStoreSpan ?
                cfb->readSpan = RGBAReadSpan;
                cfb->returnSpan = RGBReturnSpan;
            }
            cfb->clear = RGBClear;
            break;
        case 32:
            cfb->storeSpan = Bitfield32StoreSpan;
            cfb->readSpan = Bitfield32RGBAReadSpan;
            cfb->returnSpan = Bitfield32ReturnSpan;
            cfb->clear = Bitfield32Clear;
            break;
        }

        // Pick specific functions for DIB or Display formats

        if (cfb->buf.flags & DIB_FORMAT) {

            switch(pfmt->cColorBits) {

            case 4:
                DBGLEVEL(DBG_PICK, "DIBIndex4Store\n");
                cfb->store = DIBIndex4Store;
                cfb->fetch = DIBIndex4RGBAFetch;
                cfb->readSpan = DIBIndex4RGBAReadSpan;
                break;

            case 8:
                DBGLEVEL(DBG_PICK, "DIBIndex8Store, "
                                   "Index8StoreSpan\n");
                cfb->store = DIBIndex8Store;
                if( gc->modes.alphaBits )
                    cfb->fetch = DIBIndex8RGBAFetch;
                else
                    cfb->fetch = DIBIndex8RGBFetch;
                break;

            case 16:
                DBGLEVEL(DBG_PICK, "DIBBitfield16Store\n");
                cfb->store = DIBBitfield16Store;
                if( gc->modes.alphaBits )
                    cfb->fetch = DIBBitfield16RGBAFetch;
                else
                    cfb->fetch = DIBBitfield16RGBFetch;
                break;

            case 24:
                if (cfb->redShift == 16)
                {
                    DBGLEVEL(DBG_PICK, "DIBBGRStore\n");
                    cfb->store = DIBBGRStore;
                    if( gc->modes.alphaBits )
                        cfb->fetch = DIBBGRAFetch;
                    else
                        cfb->fetch = DIBBGRFetch;
                }
                else
                {
                    DBGLEVEL(DBG_PICK, "DIBRGBStore\n");
                    cfb->store = DIBRGBAStore;
                    if( gc->modes.alphaBits )
                        cfb->fetch = DIBRGBAFetch;
                    else
                        cfb->fetch = DIBRGBFetch;
                }
                break;

            case 32:
                DBGLEVEL(DBG_PICK, "DIBBitfield32Store, "
                                   "Bitfield32StoreSpan\n");
                cfb->store = DIBBitfield32Store;
                if( gc->modes.alphaBits )
                    cfb->fetch = DIBBitfield32RGBAFetch;
                else
                    cfb->fetch = DIBBitfield32RGBFetch;
                break;

            }
        } else {
            switch(pfmt->cColorBits) {

            case 4:
                DBGLEVEL(DBG_PICK, "DisplayIndex4Store\n");
                cfb->store = DisplayIndex4Store;
                cfb->fetch = DisplayIndex4RGBAFetch;
                cfb->readSpan = DisplayIndex4RGBAReadSpan;
                break;

            case 8:
                DBGLEVEL(DBG_PICK, "DisplayIndex8Store, "
                                   "Index8StoreSpan\n");
                cfb->store = DisplayIndex8Store;
                if( gc->modes.alphaBits )
                    cfb->fetch = DisplayIndex8RGBAFetch;
                else
                    cfb->fetch = DisplayIndex8RGBFetch;
                break;

            case 16:
                DBGLEVEL(DBG_PICK, "DisplayBitfield16Store\n");
                cfb->store = DisplayBitfield16Store;
                if( gc->modes.alphaBits )
                    cfb->fetch = DisplayBitfield16RGBAFetch;
                else
                    cfb->fetch = DisplayBitfield16RGBFetch;
                break;

            case 24:
                // Must be RGB or BGR
                if (cfb->redShift == 16)
                {
                    DBGLEVEL(DBG_PICK, "DisplayBGRStore\n");
                    cfb->store = DisplayBGRStore;
                    if( gc->modes.alphaBits )
                        cfb->fetch = DisplayBGRAFetch;
                    else
                        cfb->fetch = DisplayBGRFetch;
                }
                else
                {
                    DBGLEVEL(DBG_PICK, "DisplayRGBStore\n");
                    cfb->store = DisplayRGBStore;
                    if( gc->modes.alphaBits )
                        cfb->fetch = DisplayRGBAFetch;
                    else
                        cfb->fetch = DisplayRGBFetch;
                }
                break;

            case 32:
                DBGLEVEL(DBG_PICK, "DisplayBitfield32Store, "
                                   "Bitfield32StoreSpan\n");
                cfb->store = DisplayBitfield32Store;
                if( gc->modes.alphaBits )
                    cfb->fetch = DisplayBitfield32RGBAFetch;
                else
                    cfb->fetch = DisplayBitfield32RGBFetch;
                break;
            }
        }
        // cfb->readColor is the same as cfb->fetch (so why do we need it ?)
        cfb->readColor = cfb->fetch;

        // If we are only writing alpha (rgb all masked), can further optimize:
        // Don't bother if logicOp or blending are enabled, and only if we
        // have a software alpha buffer
        if( gc->modes.alphaBits && 
            ! ALPHA_IN_PIXEL( cfb ) && 
            (sourceMask == 0) && 
            gc->state.raster.aMask &&
            !(enables & __GL_COLOR_LOGIC_OP_ENABLE) &&
            ! (enables & __GL_BLEND_ENABLE) ) 
        {
            cfb->store = AlphaStore;
            cfb->storeSpan = AlphaStoreSpan;
        }
    }
}

/************************************************************************/

void FASTCALL __glGenFreeRGB(__GLcontext *gc, __GLcolorBuffer *cfb)
{
    DBGENTRY("__glGenFreeRGB\n");
}

/************************************************************************/

// Note: this used to be defined in generic\genrgb.h
#define __GL_GENRGB_COMPONENT_SCALE_ALPHA       255

// called at makecurrent time
// need to get info out of pixel format structure
void FASTCALL __glGenInitRGB(__GLcontext *gc, __GLcolorBuffer *cfb, GLenum type)
{
    __GLGENcontext *gengc = (__GLGENcontext *)gc;
    PIXELFORMATDESCRIPTOR *pfmt;

    __glInitGenericCB(gc, cfb);

    cfb->redMax      = (1 << gc->modes.redBits) - 1;
    cfb->greenMax    = (1 << gc->modes.greenBits) - 1;
    cfb->blueMax     = (1 << gc->modes.blueBits) - 1;

    gc->redVertexScale   = cfb->redScale    = (__GLfloat)cfb->redMax;
    gc->greenVertexScale = cfb->greenScale  = (__GLfloat)cfb->greenMax;
    gc->blueVertexScale  = cfb->blueScale   = (__GLfloat)cfb->blueMax;

    cfb->iRedScale   = cfb->redMax;
    cfb->iGreenScale = cfb->greenMax;
    cfb->iBlueScale  = cfb->blueMax;

    // Do any initialization related to alpha
    if( gc->modes.alphaBits ) {
        cfb->alphaMax        = (1 << gc->modes.alphaBits) - 1;
        cfb->iAlphaScale     = cfb->alphaMax;
        gc->alphaVertexScale = cfb->alphaScale  = (__GLfloat)cfb->alphaMax;
        // Initialize the software alpha buffer.  Actually, we may not need to
        // do this, since if an mcd pixel format supports alpha, we don't need
        // the software alpha buffer.  But this is the most convenient place to
        // do it, and no memory will be allocated anyways. just function ptrs
        // initialized.
        __glInitAlpha( gc, cfb ); 
    } else {
        cfb->alphaMax    = __GL_GENRGB_COMPONENT_SCALE_ALPHA;
        cfb->iAlphaScale = __GL_GENRGB_COMPONENT_SCALE_ALPHA;
        gc->alphaVertexScale = cfb->alphaScale  = (__GLfloat)cfb->redMax;
    }

    cfb->buf.elementSize = sizeof(GLubyte);     // XXX needed?

    cfb->pick              = PickRGB;           // called at each validate
    cfb->resize            = Resize;
    cfb->fetchSpan         = __glFetchSpan;
    cfb->fetchStippledSpan = __glFetchSpan;
    cfb->storeSpan         = SlowStoreSpan;
    cfb->storeStippledSpan = SlowStoreStippledSpan;

    pfmt = &gengc->gsurf.pfd;

    cfb->redShift = pfmt->cRedShift;
    cfb->greenShift = pfmt->cGreenShift;
    cfb->blueShift = pfmt->cBlueShift;
    cfb->alphaShift = pfmt->cAlphaShift;

    glGenInitCommon(gengc, cfb, type);

    DBGLEVEL3(LEVEL_INFO,"GeninitRGB: redMax %d, greenMax %d, blueMax %d\n",
        cfb->redMax, cfb->greenMax, cfb->blueMax);
    DBGLEVEL3(LEVEL_INFO,"    redShift %d, greenShift %d, blueShift %d\n",
        cfb->redShift, cfb->greenShift, cfb->blueShift);
    DBGLEVEL2(LEVEL_INFO,"    dwFlags %X, cColorBits %d\n",
        gengc->dwCurrentFlags, pfmt->cColorBits);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\makefile.inc ===
#
# If BUILDMSG is not defined, the define it as the empty string to make
# the conditionals easier to write.
#

PUBLICINCS= $(SDK_INC_PATH)\gl\gl.h

PRIVATEINCS= ..\inc\types.h     \
             ..\inc\render.h    \
             ..\inc\buffers.h   \
             ..\inc\context.h   \
             ..\inc\attrib.h    \
             ..\inc\vertex.h    \
             ..\inc\xform.h     \
             ..\inc\procs.h     \
             ..\inc\pixel.h     \
             ..\inc\texture.h   \
             ..\inc\lighting.h  \
             ..\..\inc\parray.h \
             ..\inc\gencx.h

GLTGT = $(NTTARGETFILE0)

!if $(AMD64) || $(IA64)

#
# For AMD64 and IA64  use the M4 method of include file generation.
#

$(TARGET_DIRECTORY)\glconst.c: $(TARGET_DIRECTORY)\glconst.m4
    m4 -DBASE_INC_PATH=$(BASE_INC_PATH) < $** > $@

$(GLTGT):                                               \
                $(TARGET_DIRECTORY)\glconst.c           \
		$(PUBLICINCS)                           \
		$(PRIVATEINCS)                          \
		$(BASE_INC_PATH)\genxx.h
    set PASS0ONLY=
    -md $(_OBJ_DIR)\$(TARGET_DIRECTORY)
    nmake $(_OBJ_DIR)\$(TARGET_DIRECTORY)\glconst.obj USE_MSVCRT=1 NTNOPCH=1 NTDEBUG=ntsdnodbg FORCENATIVEOBJECT=1
    genxx $(_OBJ_DIR)\$(TARGET_DIRECTORY)\glconst.obj -s$(ASM_INCLUDE_SUFFIX) -o$@

!else

$(GLTGT):                                                          \
               $(TARGET_DIRECTORY)\gl$(TARGET_DIRECTORY).c         \
               $(PUBLICINCS)                                       \
               $(PRIVATEINCS)
    set PASS0ONLY=
    nmake $(_OBJ_DIR)\$(TARGET_DIRECTORY)\gl$(TARGET_DIRECTORY).obj USE_MSVCRT=1 NTNOPCH=1 $(HOST_TARGET_DEFINES) $(HOST_TOOLS) NTDEBUG=ntsdnodbg
    -link -out:$(_OBJ_DIR)\$(TARGET_DIRECTORY)\gl$(TARGET_DIRECTORY).exe @<<
-machine:$(HOST_TARGETCPU)
-base:@$(COFFBASE_TXT_FILE),usermode
-subsystem:console
-entry:mainCRTStartup
-nodefaultlib
-ignore:4078
-force
$(_OBJ_DIR)\$(TARGET_DIRECTORY)\gl$(TARGET_DIRECTORY).obj
$(SDK_LIB_DEST)\$(HOST_TARGETCPU)\msvcrt.lib
$(SDK_LIB_DEST)\$(HOST_TARGETCPU)\kernel32.lib
$(PERFLIBS)
<<
    -$(_OBJ_DIR)\$(TARGET_DIRECTORY)\gl$(TARGET_DIRECTORY).exe $@
    -erase $(_OBJ_DIR)\$(TARGET_DIRECTORY)\gl$(TARGET_DIRECTORY).obj
    -erase $(_OBJ_DIR)\$(TARGET_DIRECTORY)\gl$(TARGET_DIRECTORY).exe

!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\mcddepth.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

#ifdef _MCD_

void FASTCALL GenMcdClearDepthNOP(__GLdepthBuffer *dfb);

/******************************Public*Routine******************************\
* GenMcdReadZSpan
*
* Read specified span (starting from (x,y) and cx pels wide) of the depth
* buffer.  The read span is in the pMcdSurf->pDepthSpan buffer.
*
* Returns:
*   First depth value in the span.
*
* History:
*  15-Feb-1996 -by- Gilman Wong [gilmanw]
* Adpated from gendepth.c (3dddi).
\**************************************************************************/

__GLzValue GenMcdReadZSpan(__GLdepthBuffer *fb, GLint x, GLint y, GLint cx)
{
    GENMCDSTATE *pMcdState;
    GENMCDSURFACE *pMcdSurf;
    LONG i;
    ULONG *pDest;
    ULONG shiftVal;
    ULONG maskVal;

    pMcdState = ((__GLGENcontext *)fb->buf.gc)->pMcdState;
    ASSERTOPENGL(pMcdState, "GenMcdReadZSpan: null pMcdState\n");

    pMcdSurf = pMcdState->pMcdSurf;
    ASSERTOPENGL(pMcdSurf, "GenMcdReadZSpan: null pMcdSurf\n");

// Read MCD depth span.

    if ( !(gpMcdTable->pMCDReadSpan)(&pMcdState->McdContext,
                                     pMcdSurf->McdDepthBuf.pv,
                                      __GL_UNBIAS_X(fb->buf.gc, x),
                                      __GL_UNBIAS_Y(fb->buf.gc, y),
                                     cx, MCDSPAN_DEPTH) )
    {
        WARNING("GenMcdReadZSpan: MCDReadSpan failed\n");
    }

// Shift and mask depth values so that they are in the most significant
// bits of the __GLzValue.
//
// If MCD has a 16-bit depth buffer, then we utilize a separate translation
// buffer (pDepthSpan).  If MCD has a 32-bit depth buffer (implying that
// pDepthSpan == McdDepthBuf.pv), then we do this in place.

    pDest = (ULONG *) pMcdState->pDepthSpan;
    shiftVal = pMcdState->McdPixelFmt.cDepthShift;
    maskVal = pMcdSurf->depthBitMask;

    if ( pDest == (ULONG *) pMcdSurf->McdDepthBuf.pv )
    {
        for (i = cx; i; i--, pDest++)
            *pDest = (*pDest << shiftVal) & maskVal;
    }
    else
    {
        USHORT *pSrc = (USHORT *) pMcdSurf->McdDepthBuf.pv;

        for (i = cx; i; i--)
            *pDest++ = ((ULONG)*pSrc++ << shiftVal) & maskVal;
    }

    return (*((__GLzValue *)pMcdState->pDepthSpan));
}

/******************************Public*Routine******************************\
* GenMcdWriteZSpan
*
* Write depth span buffer to the specificed span (starting from (x,y) and
* cx pels wide) of the MCD depth buffer.  The span to be written is in
* pMcdSurf->pDepthSpan.
*
* History:
*  15-Feb-1996 -by- Gilman Wong [gilmanw]
* Adpated from gendepth.c (3dddi).
\**************************************************************************/

void GenMcdWriteZSpan(__GLdepthBuffer *fb, GLint x, GLint y, GLint cx)
{
    GENMCDSTATE *pMcdState;
    GENMCDSURFACE *pMcdSurf;
    LONG i;
    ULONG *pSrc;
    ULONG shiftVal;

    pMcdState = ((__GLGENcontext *)fb->buf.gc)->pMcdState;
    ASSERTOPENGL(pMcdState, "GenMcdWriteZSpan: null pMcdState\n");

    pMcdSurf = pMcdState->pMcdSurf;
    ASSERTOPENGL(pMcdSurf, "GenMcdWriteZSpan: null pMcdSurf\n");

// Depth span buffer values are shifted into the most significant portion
// of the __GLzValue.  We need to shift these values back into position.
//
// Furthermore, the depth span buffer is always 32-bit.  If the MCD depth
// buffer is also 32-bit (implying that pDepthSpan == McdDepthBuf.pv),
// then we can shift in place.

    pSrc = (ULONG *) pMcdState->pDepthSpan;
    shiftVal = pMcdState->McdPixelFmt.cDepthShift;

    if ( pSrc == (ULONG *) pMcdSurf->McdDepthBuf.pv )
    {
        for (i = cx; i; i--, pSrc++)
            *pSrc >>= shiftVal;
    }
    else
    {
        USHORT *pDest = (USHORT *) pMcdSurf->McdDepthBuf.pv;

        for (i = cx; i; i--)
            *pDest++ = (USHORT)(*pSrc++ >> shiftVal);
    }

// Write MCD depth span.

    if ( !(gpMcdTable->pMCDWriteSpan)(&pMcdState->McdContext,
                                      pMcdSurf->McdDepthBuf.pv,
                                      __GL_UNBIAS_X(fb->buf.gc, x),
                                      __GL_UNBIAS_Y(fb->buf.gc, y),
                                      cx, MCDSPAN_DEPTH) )
    {
        WARNING("GenMcdWriteZSpan: MCDWriteSpan failed\n");
    }
}

/******************************Public*Routine******************************\
* GenMcdWriteZ
*
* Write a single depth value to the specificed location.
*
* History:
*  15-Feb-1996 -by- Gilman Wong [gilmanw]
* Adpated from gendepth.c (3dddi).
\**************************************************************************/

void GenMcdWriteZ(__GLdepthBuffer *fb, GLint x, GLint y, __GLzValue z)
{
    GENMCDSTATE *pMcdState;
    GENMCDSURFACE *pMcdSurf;

    pMcdState = ((__GLGENcontext *)fb->buf.gc)->pMcdState;
    ASSERTOPENGL(pMcdState, "GenMcdWriteZ: null pMcdState\n");

    pMcdSurf = pMcdState->pMcdSurf;
    ASSERTOPENGL(pMcdSurf, "GenMcdWriteZ: null pMcdSurf\n");

// If (pmcd->pDepthSpan == pmcd->McdDepthBuf.pv) then MCD has a 32-bit
// depth buffer; otherwise, 16-bit.

    if ( pMcdSurf->McdDepthBuf.pv == (PVOID) pMcdState->pDepthSpan )
        *((ULONG *)pMcdSurf->McdDepthBuf.pv)  = (ULONG)z >> pMcdState->McdPixelFmt.cDepthShift;
    else
        *((USHORT *)pMcdSurf->McdDepthBuf.pv) = (USHORT)(z >> pMcdState->McdPixelFmt.cDepthShift);

// Write depth value to MCD.

    if ( !(gpMcdTable->pMCDWriteSpan)(&pMcdState->McdContext,
                                      pMcdSurf->McdDepthBuf.pv,
                                      __GL_UNBIAS_X(fb->buf.gc, x),
                                      __GL_UNBIAS_Y(fb->buf.gc, y),
                                      1, MCDSPAN_DEPTH) )
    {
        WARNING("GenMcdWriteZ: MCDWriteSpan failed\n");
    }
}

/******************************Public*Routine******************************\
* GenMcdReadZRawSpan
*
* Unlike GenMcdReadZSpan, which reads the span from the MCD drivers into
* the 32-bit z span buffer, GenMcdReadZRawSpan reads the span in its
* native format and leaves it in the pMcdSurf->McdDepthBuf.pv buffer.
*
* History:
*  14-Mar-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

PVOID FASTCALL
GenMcdReadZRawSpan(__GLdepthBuffer *fb, GLint x, GLint y, GLint cx)
{
    GENMCDSTATE *pMcdState;
    GENMCDSURFACE *pMcdSurf;

#if DBG
    if (cx > fb->buf.gc->constants.width)
        WARNING2("GenMcdReadZRawSpan: cx (%ld) bigger than window width (%ld)\n", cx, fb->buf.gc->constants.width);
    ASSERTOPENGL(cx <= MCD_MAX_SCANLINE, "GenMcdReadZRawSpan: cx exceeds buffer width\n");
#endif

    pMcdState = ((__GLGENcontext *)fb->buf.gc)->pMcdState;
    pMcdSurf = pMcdState->pMcdSurf;

// Read MCD depth span.

    if ( !(gpMcdTable->pMCDReadSpan)(&pMcdState->McdContext,
                                     pMcdSurf->McdDepthBuf.pv,
                                      __GL_UNBIAS_X(fb->buf.gc, x),
                                      __GL_UNBIAS_Y(fb->buf.gc, y),
                                     cx, MCDSPAN_DEPTH) )
    {
        WARNING("GenMcdReadZRawSpan: MCDReadSpan failed\n");
    }

    return (pMcdSurf->McdDepthBuf.pv);
}

/******************************Public*Routine******************************\
* GenMcdWriteZRawSpan
*
* Unlike GenMcdWriteZSpan, which writes the span in the 32-bit z span
* buffer to the MCD driver, GenMcdWriteZRawSpan writes the native format
* span in the pMcdSurf->McdDepthBuf.pv buffer to the driver.
*
* History:
*  14-Mar-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL
GenMcdWriteZRawSpan(__GLdepthBuffer *fb, GLint x, GLint y, GLint cx)
{
    GENMCDSTATE *pMcdState;
    GENMCDSURFACE *pMcdSurf;

#if DBG
    if (cx > fb->buf.gc->constants.width)
        WARNING2("GenMcdWriteZRawSpan: cx (%ld) bigger than window width (%ld)\n", cx, fb->buf.gc->constants.width);
    ASSERTOPENGL(cx <= MCD_MAX_SCANLINE, "GenMcdWriteZRawSpan: cx exceeds buffer width\n");
#endif

    pMcdState = ((__GLGENcontext *)fb->buf.gc)->pMcdState;
    pMcdSurf = pMcdState->pMcdSurf;

// Write MCD depth span.

    if ( !(gpMcdTable->pMCDWriteSpan)(&pMcdState->McdContext,
                                      pMcdSurf->McdDepthBuf.pv,
                                      __GL_UNBIAS_X(fb->buf.gc, x),
                                      __GL_UNBIAS_Y(fb->buf.gc, y),
                                      cx, MCDSPAN_DEPTH) )
    {
        WARNING("GenMcdWriteZRawSpan: MCDWriteSpan failed\n");
    }
}


/************************************************************************/
/* Fetch routines                                                       */

__GLzValue FASTCALL McdFetch(__GLdepthBuffer *fb, GLint x, GLint y)
{
    return GenMcdReadZSpan(fb, x, y, 1);
}

__GLzValue FASTCALL McdFetch16(__GLdepthBuffer *fb, GLint x, GLint y)
{
    return (GenMcdReadZSpan(fb, x, y, 1) >> 16);
}

__GLzValue FASTCALL McdFetchNEVER(__GLdepthBuffer *fb, GLint x, GLint y)
{
    return (__GLzValue) 0;
}


/************************************************************************/
/* 32-bit depth buffer store routines, depth write is enabled.          */
/*                                                                      */
/* Note: McdStoreNEVER is usable for 16- and 32-bit, write enabled or   */
/*       not.                                                           */

GLboolean McdStoreNEVER(__GLdepthBuffer *fb,
                            GLint x, GLint y, __GLzValue z)
{
    return GL_FALSE;
}

GLboolean McdStoreLESS(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    if ((z & fb->writeMask) < GenMcdReadZSpan(fb, x, y, 1)) {
        GenMcdWriteZ(fb, x, y, z);
        return GL_TRUE;
    }
    return GL_FALSE;
}

GLboolean McdStoreEQUAL(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    if ((z & fb->writeMask) == GenMcdReadZSpan(fb, x, y, 1)) {
        GenMcdWriteZ(fb, x, y, z);
        return GL_TRUE;
    }
    return GL_FALSE;
}

GLboolean McdStoreLEQUAL(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    if ((z & fb->writeMask) <= GenMcdReadZSpan(fb, x, y, 1)) {
        GenMcdWriteZ(fb, x, y, z);
        return GL_TRUE;
    }
    return GL_FALSE;
}

GLboolean McdStoreGREATER(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    if ((z & fb->writeMask) > GenMcdReadZSpan(fb, x, y, 1)) {
        GenMcdWriteZ(fb, x, y, z);
        return GL_TRUE;
    }
    return GL_FALSE;
}

GLboolean McdStoreNOTEQUAL(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    if ((z & fb->writeMask) != GenMcdReadZSpan(fb, x, y, 1)) {
        GenMcdWriteZ(fb, x, y, z);
        return GL_TRUE;
    }
    return GL_FALSE;
}

GLboolean McdStoreGEQUAL(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    if ((z & fb->writeMask) >= GenMcdReadZSpan(fb, x, y, 1)) {
        GenMcdWriteZ(fb, x, y, z);
        return GL_TRUE;
    }
    return GL_FALSE;
}

GLboolean McdStoreALWAYS(__GLdepthBuffer *fb,
                             GLint x, GLint y, __GLzValue z)
{
    GenMcdWriteZ(fb, x, y, z);
    return GL_TRUE;
}


/************************************************************************/
/* 32-bit depth buffer store routines, depth write not enabled.         */
/*                                                                      */
/* Note: McdStoreALWAYS_W usable for both 16- and 32-bit.               */

GLboolean McdStoreLESS_W(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    return (z & fb->writeMask) < GenMcdReadZSpan(fb, x, y, 1);
}

GLboolean McdStoreEQUAL_W(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    return (z & fb->writeMask) == GenMcdReadZSpan(fb, x, y, 1);
}

GLboolean McdStoreLEQUAL_W(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    return (z & fb->writeMask) <= GenMcdReadZSpan(fb, x, y, 1);
}

GLboolean McdStoreGREATER_W(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    return (z & fb->writeMask) > GenMcdReadZSpan(fb, x, y, 1);
}

GLboolean McdStoreNOTEQUAL_W(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    return (z & fb->writeMask) != GenMcdReadZSpan(fb, x, y, 1);
}

GLboolean McdStoreGEQUAL_W(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    return (z & fb->writeMask) >= GenMcdReadZSpan(fb, x, y, 1);
}

GLboolean McdStoreALWAYS_W(__GLdepthBuffer *fb,
                             GLint x, GLint y, __GLzValue z)
{
    return GL_TRUE;
}


/************************************************************************/
/* 16-bit depth buffer store routines, depth write enabled.             */

GLboolean McdStore16LESS(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    z <<= 16;
    if ((z & fb->writeMask) < GenMcdReadZSpan(fb, x, y, 1)) {
        GenMcdWriteZ(fb, x, y, z);
        return GL_TRUE;
    }
    return GL_FALSE;
}

GLboolean McdStore16EQUAL(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    z <<= 16;
    if ((z & fb->writeMask) == GenMcdReadZSpan(fb, x, y, 1)) {
        GenMcdWriteZ(fb, x, y, z);
        return GL_TRUE;
    }
    return GL_FALSE;
}

GLboolean McdStore16LEQUAL(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    z <<= 16;
    if ((z & fb->writeMask) <= GenMcdReadZSpan(fb, x, y, 1)) {
        GenMcdWriteZ(fb, x, y, z);
        return GL_TRUE;
    }
    return GL_FALSE;
}

GLboolean McdStore16GREATER(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    z <<= 16;
    if ((z & fb->writeMask) > GenMcdReadZSpan(fb, x, y, 1)) {
        GenMcdWriteZ(fb, x, y, z);
        return GL_TRUE;
    }
    return GL_FALSE;
}

GLboolean McdStore16NOTEQUAL(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    z <<= 16;
    if ((z & fb->writeMask) != GenMcdReadZSpan(fb, x, y, 1)) {
        GenMcdWriteZ(fb, x, y, z);
        return GL_TRUE;
    }
    return GL_FALSE;
}

GLboolean McdStore16GEQUAL(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    z <<= 16;
    if ((z & fb->writeMask) >= GenMcdReadZSpan(fb, x, y, 1)) {
        GenMcdWriteZ(fb, x, y, z);
        return GL_TRUE;
    }
    return GL_FALSE;
}

GLboolean McdStore16ALWAYS(__GLdepthBuffer *fb,
                             GLint x, GLint y, __GLzValue z)
{
    z <<= 16;
    GenMcdWriteZ(fb, x, y, z);
    return GL_TRUE;
}


/************************************************************************/
/* 16-bit depth buffer store routines, depth write not enabled.         */

GLboolean McdStore16LESS_W(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    z <<= 16;
    return (z & fb->writeMask) < GenMcdReadZSpan(fb, x, y, 1);
}

GLboolean McdStore16EQUAL_W(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    z <<= 16;
    return (z & fb->writeMask) == GenMcdReadZSpan(fb, x, y, 1);
}

GLboolean McdStore16LEQUAL_W(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    z <<= 16;
    return (z & fb->writeMask) <= GenMcdReadZSpan(fb, x, y, 1);
}

GLboolean McdStore16GREATER_W(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    z <<= 16;
    return (z & fb->writeMask) > GenMcdReadZSpan(fb, x, y, 1);
}

GLboolean McdStore16NOTEQUAL_W(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    z <<= 16;
    return (z & fb->writeMask) != GenMcdReadZSpan(fb, x, y, 1);
}

GLboolean McdStore16GEQUAL_W(__GLdepthBuffer *fb,
                           GLint x, GLint y, __GLzValue z)
{
    z <<= 16;
    return (z & fb->writeMask) >= GenMcdReadZSpan(fb, x, y, 1);
}


/************************************************************************/
/* Store proc table                                                     */
/*                                                                      */
/* Functions are indexed by the depth function index (with offset of    */
/* GL_NEVER removed).  If depth write is not enabled, an additional     */
/* offset of 8 must be added.  If 16-bit depth, rather than 32-bit,     */
/* an additional offset of 16 must be added.                            */

GLboolean (*McdStoreProcs[32])(__GLdepthBuffer*, GLint, GLint, __GLzValue)
 = {
    McdStoreNEVER,      // 32-bit depth, write enabled
    McdStoreLESS,
    McdStoreEQUAL,
    McdStoreLEQUAL,
    McdStoreGREATER,
    McdStoreNOTEQUAL,
    McdStoreGEQUAL,
    McdStoreALWAYS,
    McdStoreNEVER,      // 32-bit depth, write disabled
    McdStoreLESS_W,
    McdStoreEQUAL_W,
    McdStoreLEQUAL_W,
    McdStoreGREATER_W,
    McdStoreNOTEQUAL_W,
    McdStoreGEQUAL_W,
    McdStoreALWAYS_W,
    McdStoreNEVER,      // 16-bit depth, write enabled
    McdStore16LESS,
    McdStore16EQUAL,
    McdStore16LEQUAL,
    McdStore16GREATER,
    McdStore16NOTEQUAL,
    McdStore16GEQUAL,
    McdStore16ALWAYS,
    McdStoreNEVER,      // 16-bit depth, write disabled
    McdStore16LESS_W,
    McdStore16EQUAL_W,
    McdStore16LEQUAL_W,
    McdStore16GREATER_W,
    McdStore16NOTEQUAL_W,
    McdStore16GEQUAL_W,
    McdStoreALWAYS_W
};

/******************************Public*Routine******************************\
* Pick
*
* Choose appropriate store proc for the MCD managed depth buffer.
*
* History:
*  15-Feb-1996 -by- Gilman Wong [gilmanw]
* Adpated from gendepth.c (3dddi).
\**************************************************************************/

// Note: depthIndex param not used - for compatibility with Pick in so_depth.c
void FASTCALL GenMcdPickDepth(__GLcontext *gc, __GLdepthBuffer *fb,
                                     GLint depthIndex)
{
    GLint ix;

    ix = gc->state.depth.testFunc - GL_NEVER;

    if (gc->modes.depthBits) {
        if (!gc->state.depth.writeEnable) {
            ix += 8;
        }
        if (gc->depthBuffer.buf.elementSize == 2) {
            ix += 16;
        }
    } else {

    // No depthBits so force McdStoreALWAYS_W.

        ix = (GL_ALWAYS - GL_NEVER) + 8;
    }

    fb->store = McdStoreProcs[ix];

    if (ix < 16)
        fb->storeRaw = McdStoreProcs[ix];
    else
        fb->storeRaw = McdStoreProcs[ix-16];
}

/******************************Public*Routine******************************\
* __fastGenPickZStoreProc
*
\**************************************************************************/

void FASTCALL __fastGenPickZStoreProc(__GLcontext *gc)
{
    int index;

    index = gc->state.depth.testFunc - GL_NEVER;

    if (gc->modes.depthBits) {
        if (gc->state.depth.writeEnable == GL_FALSE)
            index += 8;

        if (gc->depthBuffer.buf.elementSize == 2)
            index += 16;
    } else {
        index = (GL_ALWAYS - GL_NEVER) + 8;
    }

#if DBG
    {
        GENMCDSTATE *pMcdState = ((__GLGENcontext *)gc)->pMcdState;
        ASSERTOPENGL(!pMcdState || (pMcdState->McdBuffers.mcdDepthBuf.bufFlags & MCDBUF_ENABLED),
                     "__fastGenPickZStoreProc: bad state\n");
    }
#endif

    GENACCEL(gc).__fastGenZStore =  __glCDTPixel[index];
}

/******************************Public*Routine******************************\
* GenMcdInitDepth
*
* Initialize __GLdepthBuffer for MCD.
*
* History:
*  15-Feb-1996 -by- Gilman Wong [gilmanw]
* Adpated from gendepth.c (3dddi).
\**************************************************************************/

void FASTCALL GenMcdInitDepth(__GLcontext *gc, __GLdepthBuffer *fb)
{
    GENMCDSTATE *pMcdState;
    ULONG zDepth;

    pMcdState = ((__GLGENcontext *)gc)->pMcdState;

    fb->buf.gc = gc;
    fb->scale = (__GLzValue) ~0;
    if (pMcdState)
        fb->writeMask = ((__GLzValue)~0) << (32 - pMcdState->McdPixelFmt.cDepthBits);
    else
        fb->writeMask = 0;
    fb->pick = GenMcdPickDepth;

    if (gc->modes.depthBits) {
        if (gc->modes.depthBits > 16)
        {
            fb->buf.elementSize = sizeof(__GLzValue);
            fb->clear = GenMcdClearDepth32;
            fb->store2 = McdStoreALWAYS;
            fb->fetch = McdFetch;
        } else {
            fb->buf.elementSize = sizeof(__GLz16Value);
            fb->clear = GenMcdClearDepth16;
            fb->store2 = McdStore16ALWAYS;
            fb->fetch = McdFetch16;
        }
    } else {
    // If no depth buffer, depth test always passes (according to spec).
    // However, writes must be masked.  Also, I don't want to leave the
    // clear function pointer unitialized (even though it should never
    // be called) so use the NOP clear

        fb->clear = GenMcdClearDepthNOP;
        fb->store = McdStoreALWAYS_W;
        fb->store2 = McdStoreALWAYS_W;
        fb->fetch = McdFetchNEVER;
    }
}

/******************************Public*Routine******************************\
* GenMcdFreeDepth
*
* Nothing to do.  MCD driver manages its own resources.
\**************************************************************************/

void FASTCALL GenMcdFreeDepth(__GLcontext *gc, __GLdepthBuffer *fb)
{
}

/******************************Public*Routine******************************\
* GenMcdClearDepthNOP
*
* Nothing to do.  This is used in the depthBits == 0 case.
\**************************************************************************/

void FASTCALL GenMcdClearDepthNOP(__GLdepthBuffer *dfb)
{
}

/******************************Public*Routine******************************\
* GenMcdClearDepth16
*
* MCD 16-bit depth buffer clear.
*
* History:
*  15-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL GenMcdClearDepth16(__GLdepthBuffer *dfb)
{
    __GLGENcontext *gengc = (__GLGENcontext *) dfb->buf.gc;
    GENMCDSTATE *pMcdState;
    RECTL rcl;
    GLint cWidthBytes;
    USHORT usFillZ;

    if (!gengc || !(pMcdState = gengc->pMcdState))
        return;

// No clipping to handle.  If MCDBUF_ENABLED is set there is
// no clipping to handle (see GenMcdUpdateBufferInfo in mcdcx.c).
// If MCDBUF_ENABLE is not set, then we use the MCD span call which
// will handle clipping for us.
//
// Therefore, the client rectangle from the WNDOBJ is the clear
// rectangle.

    rcl = gengc->pwndLocked->rclClient;
    cWidthBytes = (rcl.right - rcl.left) * sizeof(USHORT);

// Compute 16-bit z clear value.

    usFillZ = (USHORT)(gengc->gc.state.depth.clear * gengc->genAccel.zDevScale);

// If MCDBUF_ENABLED, write directly into frame buffer memory.

    if (pMcdState->McdBuffers.mcdDepthBuf.bufFlags & MCDBUF_ENABLED)
    {
        USHORT *pus, *pusEnd;

    // Note: dfb->buf.base has a buffer origin offset of (0, 0).

        pus = (USHORT *) dfb->buf.base;
        pusEnd = pus + ((rcl.bottom - rcl.top) * dfb->buf.outerWidth);

        ASSERTOPENGL((((ULONG_PTR)pus) & 0x01) == 0,
                     "GenMcdClearDepth16: depth buffer not WORD aligned\n");

        for ( ; pus != pusEnd; pus += dfb->buf.outerWidth)
        {
            RtlFillMemoryUshort(pus, cWidthBytes, usFillZ);
        }
    }

// Otherwise, fill in one span's worth and write to MCD driver via
// MCDWriteSpan.

    else
    {
        GLint y;
        GLint cWidth = rcl.right - rcl.left;
        GENMCDSURFACE *pMcdSurf;

        pMcdSurf = pMcdState->pMcdSurf;
        ASSERTOPENGL(pMcdSurf, "GenMcdClearDepth16: no MCD surface\n");

    // Fill in one span into the shared memory buffer.

        ASSERTOPENGL((((ULONG_PTR)pMcdSurf->McdDepthBuf.pv) & 0x01) == 0,
                     "GenMcdClearDepth16: depth span buffer not WORD aligned\n");

        RtlFillMemoryUshort(pMcdSurf->McdDepthBuf.pv, cWidthBytes, usFillZ);

    // Write the span for each span in the clear rectangle.

        for (y = 0; y < (rcl.bottom - rcl.top); y++)
        {
            if ( !(gpMcdTable->pMCDWriteSpan)(&pMcdState->McdContext,
                                              pMcdSurf->McdDepthBuf.pv,
                                              //__GL_UNBIAS_X(dfb->buf.gc, 0),
                                              //__GL_UNBIAS_Y(dfb->buf.gc, y),
                                              0, y,
                                              cWidth, MCDSPAN_DEPTH) )
            {
                WARNING("GenMcdClearDepth32: MCDWriteSpan failed\n");
            }
        }
    }
}

/******************************Public*Routine******************************\
* GenMcdClearDepth32
*
* MCD 16-bit depth buffer clear.
*
* History:
*  15-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL GenMcdClearDepth32(__GLdepthBuffer *dfb)
{
    __GLGENcontext *gengc = (__GLGENcontext *) dfb->buf.gc;
    GENMCDSTATE *pMcdState;
    RECTL rcl;
    GLint cWidthBytes;
    ULONG ulFillZ;

    if (!gengc || !(pMcdState = gengc->pMcdState))
        return;

// No clipping to handle.  If MCDBUF_ENABLED is set there is
// no clipping to handle (see GenMcdUpdateBufferInfo in mcdcx.c).
// If MCDBUF_ENABLE is not set, then we use the MCD span call which
// will handle clipping for us.
//
// Therefore, the client rectangle from the WNDOBJ is the clear
// rectangle.

    rcl = gengc->pwndLocked->rclClient;
    cWidthBytes = (rcl.right - rcl.left) * sizeof(ULONG);

// Compute 32-bit z clear value.

    ulFillZ = (ULONG)(gengc->gc.state.depth.clear * gengc->genAccel.zDevScale);

// If MCDBUF_ENABLED, write directly into frame buffer memory.

    if (pMcdState->McdBuffers.mcdDepthBuf.bufFlags & MCDBUF_ENABLED)
    {
        ULONG *pul, *pulEnd;

    // Note: dfb->buf.base has a buffer origin offset of (0, 0).

        pul = (ULONG *) dfb->buf.base;
        pulEnd = pul + ((rcl.bottom - rcl.top) * dfb->buf.outerWidth);

        ASSERTOPENGL((((ULONG_PTR)pul) & 0x03) == 0,
                     "GenMcdClearDepth32: depth buffer not DWORD aligned\n");

        for ( ; pul != pulEnd; pul += dfb->buf.outerWidth)
        {
            RtlFillMemoryUlong(pul, cWidthBytes, ulFillZ);
        }
    }

// Otherwise, fill in one span's worth and write to MCD driver via
// MCDWriteSpan.

    else
    {
        GLint y;
        GLint cWidth = rcl.right - rcl.left;
        GENMCDSURFACE *pMcdSurf;

        pMcdSurf = pMcdState->pMcdSurf;
        ASSERTOPENGL(pMcdSurf, "GenMcdClearDepth32: no MCD surface\n");

    // Fill in one span into the shared memory buffer.

        ASSERTOPENGL((((ULONG_PTR)pMcdSurf->McdDepthBuf.pv) & 0x03) == 0,
                     "GenMcdClearDepth32: depth span buffer not DWORD aligned\n");

        RtlFillMemoryUlong(pMcdSurf->McdDepthBuf.pv, cWidthBytes, ulFillZ);

    // Write the span for each span in the clear rectangle.

        for (y = 0; y < (rcl.bottom - rcl.top); y++)
        {
            if ( !(gpMcdTable->pMCDWriteSpan)(&pMcdState->McdContext,
                                              pMcdSurf->McdDepthBuf.pv,
                                              0, y,
                                              cWidth, MCDSPAN_DEPTH) )
            {
                WARNING("GenMcdClearDepth32: MCDWriteSpan failed\n");
            }
        }
    }
}


/************************************************************************/

GLboolean FASTCALL GenMcdDepthTestLine(__GLcontext *gc)
{
    __GLzValue z, dzdx;
    GLint xLittle, xBig, yLittle, yBig;
    GLint xStart, yStart;
    GLint fraction, dfraction;
    GLint failed, count;
    __GLstippleWord bit, outMask, *osp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    xStart = gc->line.options.xStart;
    yStart = gc->line.options.yStart;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        outMask = (__GLstippleWord)~0;
        bit = (__GLstippleWord)__GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (!(*gc->depthBuffer.storeRaw)(&gc->depthBuffer, xStart, yStart, z)) {
                outMask &= ~bit;
                failed++;
            }
            z += dzdx;

            fraction += dfraction;
            if (fraction < 0) {
                fraction &= ~0x80000000;
                xStart += xBig;
                yStart += yBig;
            } else {
                xStart += xLittle;
                yStart += yLittle;
            }
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *osp++ = outMask;
    }

    if (failed == 0) {
        /* Call next span proc */
        return GL_FALSE;
    } else {
        if (failed != gc->polygon.shader.length) {
            /* Call next stippled span proc */
            return GL_TRUE;
        }
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}


GLboolean FASTCALL GenMcdDepthTestStippledLine(__GLcontext *gc)
{
    __GLzValue z, dzdx;
    GLint xLittle, xBig, yLittle, yBig;
    GLint xStart, yStart;
    GLint fraction, dfraction;
    GLint failed, count;
    __GLstippleWord bit, inMask, outMask, *sp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;
    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    xStart = gc->line.options.xStart;
    yStart = gc->line.options.yStart;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        inMask = *sp;
        outMask = (__GLstippleWord)~0;
        bit = (__GLstippleWord)__GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (inMask & bit) {
                if (!(*gc->depthBuffer.storeRaw)(&gc->depthBuffer, xStart, yStart, z)) {
                    outMask &= ~bit;
                    failed++;
                }
            } else failed++;
            z += dzdx;

            fraction += dfraction;
            if (fraction < 0) {
                fraction &= ~0x80000000;
                fraction &= ~0x80000000;
                xStart += xBig;
                yStart += yBig;
            } else {
                xStart += xLittle;
                yStart += yLittle;
            }
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *sp++ = outMask & inMask;
    }

    if (failed != gc->polygon.shader.length) {
        /* Call next proc */
        return GL_FALSE;
    }
    return GL_TRUE;
}

GLboolean FASTCALL GenMcdDepthTestStencilLine(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp, *zFailOp;
    GLint xLittle, xBig, yLittle, yBig;
    GLint xStart, yStart;
    GLint fraction, dfraction;
    GLint dspLittle, dspBig;
    __GLzValue z, dzdx;
    GLint failed, count;
    __GLstippleWord bit, outMask, *osp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    xStart = gc->line.options.xStart;
    yStart = gc->line.options.yStart;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    sfb = __GL_STENCIL_ADDR(&gc->stencilBuffer, (__GLstencilCell*),
            gc->line.options.xStart, gc->line.options.yStart);
    dspLittle = xLittle + yLittle * gc->stencilBuffer.buf.outerWidth;
    dspBig = xBig + yBig * gc->stencilBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    zFailOp = gc->stencilBuffer.depthFailOpTable;
    zPassOp = gc->stencilBuffer.depthPassOpTable;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        outMask = (__GLstippleWord)~0;
        bit = (__GLstippleWord)__GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (!(*gc->depthBuffer.storeRaw)(&gc->depthBuffer, xStart, yStart, z)) {
                sfb[0] = zFailOp[sfb[0]];
                outMask &= ~bit;
                failed++;
            } else {
                sfb[0] = zPassOp[sfb[0]];
            }

            z += dzdx;
            fraction += dfraction;

            if (fraction < 0) {
                fraction &= ~0x80000000;
                sfb += dspBig;
                xStart += xBig;
                yStart += yBig;
            } else {
                sfb += dspLittle;
                xStart += xLittle;
                yStart += yLittle;
            }
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *osp++ = outMask;
    }

    if (failed == 0) {
        /* Call next span proc */
        return GL_FALSE;
    } else {
        if (failed != gc->polygon.shader.length) {
            /* Call next stippled span proc */
            return GL_TRUE;
        }
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

GLboolean FASTCALL GenMcdDepthTestStencilStippledLine(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp, *zFailOp;
    GLint xLittle, xBig, yLittle, yBig;
    GLint xStart, yStart;
    GLint fraction, dfraction;
    GLint dspLittle, dspBig;
    __GLzValue z, dzdx;
    GLint failed, count;
    __GLstippleWord bit, inMask, outMask, *sp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    xBig = gc->line.options.xBig;
    yBig = gc->line.options.yBig;
    xLittle = gc->line.options.xLittle;
    yLittle = gc->line.options.yLittle;
    xStart = gc->line.options.xStart;
    yStart = gc->line.options.yStart;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    sfb = __GL_STENCIL_ADDR(&gc->stencilBuffer, (__GLstencilCell*),
            gc->line.options.xStart, gc->line.options.yStart);
    dspLittle = xLittle + yLittle * gc->stencilBuffer.buf.outerWidth;
    dspBig = xBig + yBig * gc->stencilBuffer.buf.outerWidth;
    fraction = gc->line.options.fraction;
    dfraction = gc->line.options.dfraction;

    zFailOp = gc->stencilBuffer.depthFailOpTable;
    zPassOp = gc->stencilBuffer.depthPassOpTable;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        inMask = *sp;
        outMask = (__GLstippleWord)~0;
        bit = (__GLstippleWord)__GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (inMask & bit) {
                if (!(*gc->depthBuffer.storeRaw)(&gc->depthBuffer, xStart, yStart, z)) {
                    sfb[0] = zFailOp[sfb[0]];
                    outMask &= ~bit;
                    failed++;
                } else {
                    sfb[0] = zPassOp[sfb[0]];
                }
            } else failed++;
            z += dzdx;

            fraction += dfraction;
            if (fraction < 0) {
                fraction &= ~0x80000000;
                sfb += dspBig;
                xStart += xBig;
                yStart += yBig;
            } else {
                sfb += dspLittle;
                xStart += xLittle;
                yStart += yLittle;
            }
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *sp++ = outMask & inMask;
    }

    if (failed != gc->polygon.shader.length) {
        /* Call next proc */
        return GL_FALSE;
    }

    return GL_TRUE;
}


/************************************************************************/

/*
** Depth test a span, when stenciling is disabled.
*/
GLboolean FASTCALL GenMcdDepthTestSpan(__GLcontext *gc)
{
    __GLzValue z, dzdx, *zfb;
    GLint failed, count, testFunc;
    __GLstippleWord bit, outMask, *osp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;

    GenMcdReadZSpan(&gc->depthBuffer, gc->polygon.shader.frag.x,
                    gc->polygon.shader.frag.y, w);

    if (((__GLGENcontext *)gc)->pMcdState->softZSpanFuncPtr) {
        GLboolean retVal;

        gc->polygon.shader.zbuf = (__GLzValue *)((__GLGENcontext *)gc)->pMcdState->pDepthSpan;

        retVal =
            (*(__GLspanFunc)((__GLGENcontext *)gc)->pMcdState->softZSpanFuncPtr)(gc);

        if (gc->state.depth.writeEnable)
            GenMcdWriteZSpan(&gc->depthBuffer, gc->polygon.shader.frag.x,
                             gc->polygon.shader.frag.y,
                             gc->polygon.shader.length);

        return retVal;
    }

    testFunc = gc->state.depth.testFunc & 0x7;
    zfb = (__GLzValue *)((__GLGENcontext *)gc)->pMcdState->pDepthSpan;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        outMask = (__GLstippleWord)~0;
        bit = (__GLstippleWord)__GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            switch (testFunc) {
              case (GL_NEVER & 0x7):    passed = GL_FALSE; break;
              case (GL_LESS & 0x7):     passed = z < zfb[0]; break;
              case (GL_EQUAL & 0x7):    passed = z == zfb[0]; break;
              case (GL_LEQUAL & 0x7):   passed = z <= zfb[0]; break;
              case (GL_GREATER & 0x7):  passed = z > zfb[0]; break;
              case (GL_NOTEQUAL & 0x7): passed = z != zfb[0]; break;
              case (GL_GEQUAL & 0x7):   passed = z >= zfb[0]; break;
              case (GL_ALWAYS & 0x7):   passed = GL_TRUE; break;
            }
            if (passed) {
                if (writeEnabled) {
                    zfb[0] = z;
                }
            } else {
                outMask &= ~bit;
                failed++;
            }
            z += dzdx;
            zfb++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *osp++ = outMask;
    }

    if (writeEnabled)
        GenMcdWriteZSpan(&gc->depthBuffer, gc->polygon.shader.frag.x,
                         gc->polygon.shader.frag.y,
                         gc->polygon.shader.length);


    if (failed == 0) {
        /* Call next span proc */
        return GL_FALSE;
    } else {
        if (failed != gc->polygon.shader.length) {
            /* Call next stippled span proc */
            return GL_TRUE;
        }
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

/*
** Stippled form of depth test span, when stenciling is disabled.
*/
GLboolean FASTCALL GenMcdDepthTestStippledSpan(__GLcontext *gc)
{
    __GLzValue z, dzdx, *zfb;
    GLint failed, count, testFunc;
    __GLstippleWord bit, inMask, outMask, *sp;
    GLboolean writeEnabled, passed;
    GLint w;

    sp = gc->polygon.shader.stipplePat;
    w = gc->polygon.shader.length;

    GenMcdReadZSpan(&gc->depthBuffer, gc->polygon.shader.frag.x,
                    gc->polygon.shader.frag.y, w);

    testFunc = gc->state.depth.testFunc & 0x7;
    zfb = (__GLzValue *)((__GLGENcontext *)gc)->pMcdState->pDepthSpan;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        inMask = *sp;
        outMask = (__GLstippleWord)~0;
        bit = (__GLstippleWord)__GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (inMask & bit) {
                switch (testFunc) {
                  case (GL_NEVER & 0x7):    passed = GL_FALSE; break;
                  case (GL_LESS & 0x7):     passed = z < zfb[0]; break;
                  case (GL_EQUAL & 0x7):    passed = z == zfb[0]; break;
                  case (GL_LEQUAL & 0x7):   passed = z <= zfb[0]; break;
                  case (GL_GREATER & 0x7):  passed = z > zfb[0]; break;
                  case (GL_NOTEQUAL & 0x7): passed = z != zfb[0]; break;
                  case (GL_GEQUAL & 0x7):   passed = z >= zfb[0]; break;
                  case (GL_ALWAYS & 0x7):   passed = GL_TRUE; break;
                }
                if (passed) {
                    if (writeEnabled) {
                        zfb[0] = z;
                    }
                } else {
                    outMask &= ~bit;
                    failed++;
                }
            } else failed++;
            z += dzdx;
            zfb++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *sp++ = outMask & inMask;
    }

    if (writeEnabled)
        GenMcdWriteZSpan(&gc->depthBuffer, gc->polygon.shader.frag.x,
                         gc->polygon.shader.frag.y,
                         gc->polygon.shader.length);

    if (failed != gc->polygon.shader.length) {
        /* Call next proc */
        return GL_FALSE;
    }
    return GL_TRUE;
}

/*
** Depth test a span when stenciling is enabled.
*/
GLboolean FASTCALL GenMcdDepthTestStencilSpan(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp, *zFailOp;
    __GLzValue z, dzdx, *zfb;
    GLint failed, count, testFunc;
    __GLstippleWord bit, outMask, *osp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;

    GenMcdReadZSpan(&gc->depthBuffer, gc->polygon.shader.frag.x,
                    gc->polygon.shader.frag.y, w);

    testFunc = gc->state.depth.testFunc & 0x7;
    zfb = (__GLzValue *)((__GLGENcontext *)gc)->pMcdState->pDepthSpan;
    sfb = gc->polygon.shader.sbuf;
    zFailOp = gc->stencilBuffer.depthFailOpTable;
    zPassOp = gc->stencilBuffer.depthPassOpTable;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    osp = gc->polygon.shader.stipplePat;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        outMask = (__GLstippleWord)~0;
        bit = (__GLstippleWord)__GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            switch (testFunc) {
              case (GL_NEVER & 0x7):    passed = GL_FALSE; break;
              case (GL_LESS & 0x7):     passed = z < zfb[0]; break;
              case (GL_EQUAL & 0x7):    passed = z == zfb[0]; break;
              case (GL_LEQUAL & 0x7):   passed = z <= zfb[0]; break;
              case (GL_GREATER & 0x7):  passed = z > zfb[0]; break;
              case (GL_NOTEQUAL & 0x7): passed = z != zfb[0]; break;
              case (GL_GEQUAL & 0x7):   passed = z >= zfb[0]; break;
              case (GL_ALWAYS & 0x7):   passed = GL_TRUE; break;
            }
            if (passed) {
                sfb[0] = zPassOp[sfb[0]];
                if (writeEnabled) {
                    zfb[0] = z;
                }
            } else {
                sfb[0] = zFailOp[sfb[0]];
                outMask &= ~bit;
                failed++;
            }
            z += dzdx;
            zfb++;
            sfb++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *osp++ = outMask;
    }

    if (writeEnabled)
        GenMcdWriteZSpan(&gc->depthBuffer, gc->polygon.shader.frag.x,
                         gc->polygon.shader.frag.y,
                         gc->polygon.shader.length);

    if (failed == 0) {
        /* Call next span proc */
        return GL_FALSE;
    } else {
        if (failed != gc->polygon.shader.length) {
            /* Call next stippled span proc */
            return GL_TRUE;
        }
    }
    gc->polygon.shader.done = GL_TRUE;
    return GL_TRUE;
}

/*
** Stippled form of depth test span, when stenciling is enabled.
*/
GLboolean FASTCALL GenMcdDepthTestStencilStippledSpan(__GLcontext *gc)
{
    __GLstencilCell *sfb, *zPassOp, *zFailOp;
    __GLzValue z, dzdx, *zfb;
    GLint failed, count, testFunc;
    __GLstippleWord bit, inMask, outMask, *sp;
    GLboolean writeEnabled, passed;
    GLint w;

    w = gc->polygon.shader.length;
    sp = gc->polygon.shader.stipplePat;

    GenMcdReadZSpan(&gc->depthBuffer, gc->polygon.shader.frag.x,
                    gc->polygon.shader.frag.y, w);

    testFunc = gc->state.depth.testFunc & 0x7;
    zfb = (__GLzValue *)((__GLGENcontext *)gc)->pMcdState->pDepthSpan;
    sfb = gc->polygon.shader.sbuf;
    zFailOp = gc->stencilBuffer.depthFailOpTable;
    zPassOp = gc->stencilBuffer.depthPassOpTable;
    z = gc->polygon.shader.frag.z;
    dzdx = gc->polygon.shader.dzdx;
    writeEnabled = gc->state.depth.writeEnable;
    failed = 0;
    while (w) {
        count = w;
        if (count > __GL_STIPPLE_BITS) {
            count = __GL_STIPPLE_BITS;
        }
        w -= count;

        inMask = *sp;
        outMask = (__GLstippleWord)~0;
        bit = (__GLstippleWord)__GL_STIPPLE_SHIFT(0);
        while (--count >= 0) {
            if (inMask & bit) {
                switch (testFunc) {
                  case (GL_NEVER & 0x7):    passed = GL_FALSE; break;
                  case (GL_LESS & 0x7):     passed = z < zfb[0]; break;
                  case (GL_EQUAL & 0x7):    passed = z == zfb[0]; break;
                  case (GL_LEQUAL & 0x7):   passed = z <= zfb[0]; break;
                  case (GL_GREATER & 0x7):  passed = z > zfb[0]; break;
                  case (GL_NOTEQUAL & 0x7): passed = z != zfb[0]; break;
                  case (GL_GEQUAL & 0x7):   passed = z >= zfb[0]; break;
                  case (GL_ALWAYS & 0x7):   passed = GL_TRUE; break;
                }
                if (passed) {
                    sfb[0] = zPassOp[sfb[0]];
                    if (writeEnabled) {
                        zfb[0] = z;
                    }
                } else {
                    sfb[0] = zFailOp[sfb[0]];
                    outMask &= ~bit;
                    failed++;
                }
            } else failed++;
            z += dzdx;
            zfb++;
            sfb++;
#ifdef __GL_STIPPLE_MSB
            bit >>= 1;
#else
            bit <<= 1;
#endif
        }
        *sp++ = outMask & inMask;
    }

    if (writeEnabled)
        GenMcdWriteZSpan(&gc->depthBuffer, gc->polygon.shader.frag.x,
                         gc->polygon.shader.frag.y,
                         gc->polygon.shader.length);

    if (failed != gc->polygon.shader.length) {
        /* Call next proc */
        return GL_FALSE;
    }

    return GL_TRUE;
}

/*
** MCD version of __fastGenStippleAnyDepthTestSpan.  See __fastGenPickSpanProcs
** in genaccel.c and __fastGenStippleAnyDepthTestSpan in genspan.c.
*/
GLboolean FASTCALL GenMcdStippleAnyDepthTestSpan(__GLcontext *gc)
{
    // If the shader is done after this routine then
    // the stipple pattern is all zeroes so we can
    // skip the span
    __glStippleSpan(gc);
    if (gc->polygon.shader.done)
    {
        return GL_FALSE;
    }

    // If this returns true then all bits are off so
    // we can skip the span
    return !GenMcdDepthTestStippledSpan(gc);
}

#ifdef NT_DEADCODE_GENMCDSTIPPLESPAN
//
// The code below works (it must be enabled in the __fastGenPickSpanProcs
// function), but it doesn't seem worth turning it on and increasing the
// DLL size to slightly speed up a rarely used MCD kickback case.
//
// Here are the prototypes for mcdcx.h if the code is turned on:
//
//  GLboolean FASTCALL GenMcdStippleLt32Span(__GLcontext *);
//  GLboolean FASTCALL GenMcdStippleLt16Span(__GLcontext *);
//

/*
** MCD version of __fastGenStippleLt32Span, a special case of
** GenMcdStippleAnyDepthTestSpan for 32-bit depth buffers and GL_LESS
** depth test.
**
** See __fastGenPickSpanProcs in genaccel.c and __fastGenStippleLt32Span in
** genspan.c.
*/
GLboolean FASTCALL GenMcdStippleLt32Span(__GLcontext *gc)
{
    register GLuint zAccum = gc->polygon.shader.frag.z;
    register GLint zDelta = gc->polygon.shader.dzdx;
    register GLuint *zbuf = (GLuint *)
                            ((__GLGENcontext *)gc)->pMcdState->pMcdSurf->McdDepthBuf.pv;
    register GLuint *pStipple = gc->polygon.shader.stipplePat;
    register GLint cTotalPix = gc->polygon.shader.length;
    register GLuint mask;
    register GLint cPix;
    register GLint zPasses = 0;
    register GLuint maskBit;
    __GLstippleWord stipple;
    GLint count;
    GLint shift;

    GenMcdReadZRawSpan(&gc->depthBuffer, gc->polygon.shader.frag.x,
                       gc->polygon.shader.frag.y, gc->polygon.shader.length);

    if (gc->constants.yInverted) {
        stipple = gc->polygon.stipple[(gc->constants.height -
                (gc->polygon.shader.frag.y - gc->constants.viewportYAdjust)-1)
                & (__GL_STIPPLE_BITS-1)];
    } else {
        stipple = gc->polygon.stipple[gc->polygon.shader.frag.y &
                (__GL_STIPPLE_BITS-1)];
    }
    shift = gc->polygon.shader.frag.x & (__GL_STIPPLE_BITS - 1);
#ifdef __GL_STIPPLE_MSB
    stipple = (stipple << shift) | (stipple >> (__GL_STIPPLE_BITS - shift));
#else
    stipple = (stipple >> shift) | (stipple << (__GL_STIPPLE_BITS - shift));
#endif
    if (stipple == 0) {
        /* No point in continuing */
        return GL_FALSE;
    }

    for (;cTotalPix > 0; cTotalPix-=32) {
        mask = stipple;
        maskBit = 0x80000000;
        cPix = cTotalPix;
        if (cPix > 32)
            cPix = 32;

        for (;cPix > 0; cPix --)
        {
            if (mask & maskBit)
            {
                if ((zAccum) < (*zbuf))
                {
                    *zbuf = zAccum;
                    zPasses++;
                }
                else
                {
                    mask &= ~maskBit;
                }
            }
            zbuf++;
            zAccum += zDelta;
            maskBit >>= 1;
        }

        *pStipple++ = mask;
    }

    if (gc->state.depth.writeEnable)
        GenMcdWriteZRawSpan(&gc->depthBuffer,
                            gc->polygon.shader.frag.x,
                            gc->polygon.shader.frag.y,
                            gc->polygon.shader.length);

    if (zPasses == 0) {
        return GL_FALSE;
    } else {
        return GL_TRUE;
    }
}

/*
** MCD version of __fastGenStippleLt16Span, a special case of
** GenMcdStippleAnyDepthTestSpan for 16-bit depth buffers and GL_LESS
** depth test.
**
** See __fastGenPickSpanProcs in genaccel.c and __fastGenStippleLt16Span in
** genspan.c.
*/
GLboolean FASTCALL GenMcdStippleLt16Span(__GLcontext *gc)
{
    register GLuint zAccum = gc->polygon.shader.frag.z;
    register GLint zDelta = gc->polygon.shader.dzdx;
    register __GLz16Value *zbuf = (__GLz16Value *)
                                  ((__GLGENcontext *)gc)->pMcdState->pMcdSurf->McdDepthBuf.pv;
    register GLuint *pStipple = gc->polygon.shader.stipplePat;
    register GLint cTotalPix = gc->polygon.shader.length;
    register GLuint mask;
    register GLint cPix;
    register GLint zPasses = 0;
    register GLuint maskBit;
    __GLstippleWord stipple;
    GLint count;
    GLint shift;

    GenMcdReadZRawSpan(&gc->depthBuffer, gc->polygon.shader.frag.x,
                       gc->polygon.shader.frag.y, gc->polygon.shader.length);

    if (gc->constants.yInverted) {
        stipple = gc->polygon.stipple[(gc->constants.height -
                (gc->polygon.shader.frag.y - gc->constants.viewportYAdjust)-1)
                & (__GL_STIPPLE_BITS-1)];
    } else {
        stipple = gc->polygon.stipple[gc->polygon.shader.frag.y &
                (__GL_STIPPLE_BITS-1)];
    }
    shift = gc->polygon.shader.frag.x & (__GL_STIPPLE_BITS - 1);
#ifdef __GL_STIPPLE_MSB
    stipple = (stipple << shift) | (stipple >> (__GL_STIPPLE_BITS - shift));
#else
    stipple = (stipple >> shift) | (stipple << (__GL_STIPPLE_BITS - shift));
#endif
    if (stipple == 0) {
        /* No point in continuing */
        return GL_FALSE;
    }

    for (;cTotalPix > 0; cTotalPix-=32) {
        mask = stipple;
        maskBit = 0x80000000;
        cPix = cTotalPix;
        if (cPix > 32)
            cPix = 32;

        for (;cPix > 0; cPix --)
        {
            if (mask & maskBit)
            {
                if (((__GLz16Value)(zAccum >> Z16_SHIFT)) < (*zbuf))
                {
                    *zbuf = ((__GLz16Value)(zAccum >> Z16_SHIFT));
                    zPasses++;
                }
                else
                {
                    mask &= ~maskBit;
                }
            }
            zbuf++;
            zAccum += zDelta;
            maskBit >>= 1;
        }

        *pStipple++ = mask;
    }

    if (gc->state.depth.writeEnable)
        GenMcdWriteZRawSpan(&gc->depthBuffer,
                            gc->polygon.shader.frag.x,
                            gc->polygon.shader.frag.y,
                            gc->polygon.shader.length);

    if (zPasses == 0) {
        return GL_FALSE;
    } else {
        return GL_TRUE;
    }
}
#endif

#endif //_MCD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\genzippy.c ===
/******************************Module*Header*******************************\
* Module Name: zippy.c
*
* Triangle drawing fast path.
*
* 28-Oct-1994 mikeke    Created
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/

/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include "precomp.h"
#pragma hdrstop

/**************************************************************************\
*
* Subtriangle functions
*
\**************************************************************************/

#define TEXTURE 1
    #define SHADE 1
    #define ZBUFFER 1
    #include "zippy.h"

    #undef ZBUFFER
    #define ZBUFFER 0
    #include "zippy.h"

    #undef SHADE
    #define SHADE 0
    #include "zippy.h"

#undef TEXTURE
#define TEXTURE 0
    #undef SHADE
    #define SHADE 1
    #include "zippy.h"

    #undef SHADE
    #define SHADE 0
    #include "zippy.h"


/**************************************************************************\
*
* Flat subtriangle function
*
\**************************************************************************/

void FASTCALL
__ZippyFSTCI8Flat
(__GLcontext *gc, GLint iyBottom, GLint iyTop)
{
    __GLGENcontext  *gengc = (__GLGENcontext *)gc; 
    GENACCEL *pGenAccel = (GENACCEL *)(gengc->pPrivateArea);
    int scansize;
    ULONG color1;

    //
    // this function assumes all this stuff
    //
    ASSERTOPENGL((gc->drawBuffer->buf.flags & DIB_FORMAT) != 0,
		 "Zippy target must have DIB format\n");
    ASSERTOPENGL((gc->drawBuffer->buf.flags & NO_CLIP) != 0,
                 "Zippy doesn't support per-pixel clipping\n");
    ASSERTOPENGL(gc->state.raster.drawBuffer != GL_FRONT_AND_BACK,
                 "Zippy only handles one draw buffer\n");
    ASSERTOPENGL(gc->transform.reasonableViewport,
                 "Zippy requires reasonableViewport\n");
    ASSERTOPENGL(gc->transform.clipY0 <= iyBottom,
                 "Zippy requires unclipped area\n");
    ASSERTOPENGL(iyTop <= gc->transform.clipY1,
                 "Zippy requires unclipped area\n");

    //
    // calculate the color
    //

    color1 = gengc->pajTranslateVector[
        ((pGenAccel->spanValue.r + 0x0800) >> 16) & 0xff
    ];

    //
    // render the spans
    //

    scansize = gc->polygon.shader.cfb->buf.outerWidth;
    gc->polygon.shader.frag.x = gc->polygon.shader.ixLeft;
    for (gc->polygon.shader.frag.y = iyBottom;
         gc->polygon.shader.frag.y != iyTop;
         gc->polygon.shader.frag.y++
        ) {
	GLint spanWidth = gc->polygon.shader.ixRight - gc->polygon.shader.frag.x;

	if (spanWidth > 0) {
            RtlFillMemory(
                pGenAccel->pPix + gengc->gc.polygon.shader.frag.x,
                spanWidth,
                color1);
	}

        pGenAccel->pPix += scansize;

	gc->polygon.shader.ixRightFrac += gc->polygon.shader.dxRightFrac;
	if (gc->polygon.shader.ixRightFrac < 0) {
	    /*
             * Carry/Borrow'd. Use large step
             */
	    gc->polygon.shader.ixRight += gc->polygon.shader.dxRightBig;
	    gc->polygon.shader.ixRightFrac &= ~0x80000000;
	} else {
	    gc->polygon.shader.ixRight += gc->polygon.shader.dxRightLittle;
	}

	gc->polygon.shader.ixLeftFrac += gc->polygon.shader.dxLeftFrac;
	if (gc->polygon.shader.ixLeftFrac < 0) {
	    /*
             * Carry/Borrow'd.  Use large step
             */
	    gc->polygon.shader.frag.x += gc->polygon.shader.dxLeftBig;
	    gc->polygon.shader.ixLeftFrac &= ~0x80000000;
	} else {
	    /*
             * Use small step
             */
	    gc->polygon.shader.frag.x += gc->polygon.shader.dxLeftLittle;
	}
    }
    gc->polygon.shader.ixLeft = gc->polygon.shader.frag.x;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\i386\profile.inc ===
IFNDEF __PROFILE_INC__
__PROFILE_INC EQU 1

IF PROFILE
EXTRN __penter:NEAR
	
PROF_ENTRY MACRO
	call __penter
	ENDM
ELSE
PROF_ENTRY MACRO
	ENDM
ENDIF
	
ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\mcdcx.c ===
/******************************Module*Header*******************************\
* Module Name: mcdcx.c
*
* GenMcdXXX layer between generic software implementation and MCD functions.
*
* Created: 05-Feb-1996 21:37:33
* Author: Gilman Wong [gilmanw]
*
* Copyright (c) 1995 Microsoft Corporation
*
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#ifdef _MCD_

/******************************Public*Routine******************************\
* bInitMcd
*
* Load MCD32.DLL and initialize the MCD api function table.
*
* History:
*  11-Mar-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

MCDTABLE *gpMcdTable = (MCDTABLE *) NULL;
MCDTABLE McdTable;
MCDDRIVERINFOI McdDriverInfo;

// Checks MCD version to see if the driver can accept direct buffer
// access.  Direct access was introduced in 1.1.
#define SUPPORTS_DIRECT() \
    (McdDriverInfo.mcdDriverInfo.verMinor >= 0x10 || \
     McdDriverInfo.mcdDriverInfo.verMajor > 1)

// Checks MCD version for 2.0 or greater
#define SUPPORTS_20() \
    (McdDriverInfo.mcdDriverInfo.verMajor >= 2)

static char *pszMcdEntryPoints[] = {
    "MCDGetDriverInfo",
    "MCDDescribeMcdPixelFormat",
    "MCDDescribePixelFormat",
    "MCDCreateContext",
    "MCDDeleteContext",
    "MCDAlloc",
    "MCDFree",
    "MCDBeginState",
    "MCDFlushState",
    "MCDAddState",
    "MCDAddStateStruct",
    "MCDSetViewport",
    "MCDSetScissorRect",
    "MCDQueryMemStatus",
    "MCDProcessBatch",
    "MCDReadSpan",
    "MCDWriteSpan",
    "MCDClear",
    "MCDSwap",
    "MCDGetBuffers",
    "MCDAllocBuffers",
    "MCDLock",
    "MCDUnlock",
    "MCDBindContext",
    "MCDSync",
    "MCDCreateTexture",
    "MCDDeleteTexture",
    "MCDUpdateSubTexture",
    "MCDUpdateTexturePalette",
    "MCDUpdateTexturePriority",
    "MCDUpdateTextureState",
    "MCDTextureStatus",
    "MCDTextureKey",
    "MCDDescribeMcdLayerPlane",
    "MCDDescribeLayerPlane",
    "MCDSetLayerPalette",
    "MCDDrawPixels",
    "MCDReadPixels",
    "MCDCopyPixels",
    "MCDPixelMap",
    "MCDDestroyWindow",
    "MCDGetTextureFormats",
    "MCDSwapMultiple",
    "MCDProcessBatch2"
};
#define NUM_MCD_ENTRY_POINTS    (sizeof(pszMcdEntryPoints)/sizeof(char *))

#define STR_MCD32_DLL   "MCD32.DLL"

BOOL FASTCALL bInitMcd(HDC hdc)
{
    static BOOL bFirstTime = TRUE;

    ASSERTOPENGL(NUM_MCD_ENTRY_POINTS == sizeof(MCDTABLE)/sizeof(void *),
                 "MCD entry points mismatch\n");
    //
    // Note on multi-threaded initialization.
    //
    // Since the table memory exists in global memory and the pointer to
    // the table is always set to point to this, it doesn't matter if multiple
    // thread attempt to run the initialization routine.  The worse that
    // could happen is that we set the table multiple times.
    //

    if (bFirstTime && (gpMcdTable == (MCDTABLE *) NULL))
    {
        HMODULE hmod;
        PROC *ppfn;

        //
        // Attempt the load once and once only.  Otherwise application
        // initialization time could be significantly slowed if MCD32.DLL
        // does not exist.
        //
        // We could have attempted this in the DLL entry point in responce
        // to PROCESS_ATTACH, but then we might end up wasting working set
        // if MCD is never used.
        //
        // So instead we control the load attempt with this static flag.
        //

        bFirstTime = FALSE;

        hmod = LoadLibraryA(STR_MCD32_DLL);

        if (hmod)
        {
            MCDTABLE McdTableLocal;
            BOOL bLoadFailed = FALSE;
            BOOL bDriverValid = FALSE;
            int i;

            //
            // Get address for each of the MCD entry points.
            //
            // To be multi-thread safe, we store the pointers in a local
            // table.  Only after the *entire* table is successfully
            // initialized can we copy it to the global table.
            //

            ppfn = (PROC *) &McdTableLocal.pMCDGetDriverInfo;
            for (i = 0; i < NUM_MCD_ENTRY_POINTS; i++, ppfn++)
            {
                *ppfn = GetProcAddress(hmod, pszMcdEntryPoints[i]);

                if (!*ppfn)
                {
                    WARNING1("bInitMcd: missing entry point %s\n", pszMcdEntryPoints[i]);
                    bLoadFailed = TRUE;
                }
            }

            //
            // If all entry points successfully loaded, validate driver
            // by checking the MCDDRIVERINFO.
            //

            if (!bLoadFailed)
            {
                if ((McdTableLocal.pMCDGetDriverInfo)(hdc, &McdDriverInfo))
                {
                    //
                    // Validate MCD driver version, etc.
                    //

                    //!!!mcd -- what other types of validation can we do?
#ifdef ALLOW_NEW_MCD
                    if ((McdDriverInfo.mcdDriverInfo.verMajor == 1 &&
                         (McdDriverInfo.mcdDriverInfo.verMinor == 0 ||
                          McdDriverInfo.mcdDriverInfo.verMinor == 0x10)) ||
                        (McdDriverInfo.mcdDriverInfo.verMajor == 2 &&
                         McdDriverInfo.mcdDriverInfo.verMinor == 0))
#else
                    if (McdDriverInfo.mcdDriverInfo.verMajor == 1 &&
                        McdDriverInfo.mcdDriverInfo.verMinor == 0)
#endif
                    {
                        bDriverValid = TRUE;
                    }
                    else
                    {
                        WARNING("bInitMcd: bad version\n");
                    }
                }
            }

            //
            // It is now safe to call MCD entry points via the table.  Copy
            // local copy to the global table and set the global pointer.
            //

            if (bDriverValid)
            {
                McdTable   = McdTableLocal;
                gpMcdTable = &McdTable;
            }
            else
            {
                WARNING1("bInitMcd: unloading %s\n", STR_MCD32_DLL);
                FreeLibrary(hmod);
            }
        }
    }

    return (gpMcdTable != (MCDTABLE *) NULL);
}

/******************************Public*Routine******************************\
* vFlushDirtyState
*
* GENMCDSTATE maintains a set of dirty flags to track state changes.
* This function updates the MCD driver state that is marked dirty.
* The dirty flags are consequently cleared.
*
* History:
*  07-Mar-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID FASTCALL vFlushDirtyState(__GLGENcontext *gengc)
{
    if (gengc->pMcdState)
    {
        //
        // Viewport, scissor, and texture each have separate update
        // functions/structures.  Check the dirty flags and update
        // these first.
        //

        if (MCD_STATE_DIRTYTEST(gengc, VIEWPORT))
        {
            GenMcdViewport(gengc);
            MCD_STATE_CLEAR(gengc, VIEWPORT);
        }

        if (MCD_STATE_DIRTYTEST(gengc, SCISSOR))
        {
            GenMcdScissor(gengc);

            //
            // DO NOT CLEAR.  Scissor is passed in two forms: a direct call
            // that affects clipping in MCDSRV32.DLL and a state call that
            // the MCD driver can optionally use for high performance h/w.
            // We need to leave the flag set so that the state call will
            // also be processed.
            //
            //MCD_STATE_CLEAR(gengc, SCISSOR);
        }

        if (MCD_STATE_DIRTYTEST(gengc, TEXTURE))
        {
            if (gengc->gc.texture.currentTexture)
            {
                __GLtextureObject *texobj;

                if (gengc->gc.state.enables.general & __GL_TEXTURE_2D_ENABLE)
                    texobj = __glLookUpTextureObject(&gengc->gc, GL_TEXTURE_2D);
                else if (gengc->gc.state.enables.general & __GL_TEXTURE_1D_ENABLE)
                    texobj = __glLookUpTextureObject(&gengc->gc, GL_TEXTURE_1D);
                else
                    texobj = (__GLtextureObject *) NULL;

                if (texobj && texobj->loadKey)
                {
                    ASSERTOPENGL(&texobj->texture.map == gengc->gc.texture.currentTexture,
                                 "vFlushDirtyState: texobj not current texture\n");

                    GenMcdUpdateTextureState(gengc,
                                             &texobj->texture.map,
                                             texobj->loadKey);
                    MCD_STATE_CLEAR(gengc, TEXTURE);
                }
            }
        }

        //
        // Take care of the other state.
        //

        if (MCD_STATE_DIRTYTEST(gengc, ALL))
        {
            //
            // Setup state command.
            //

            (gpMcdTable->pMCDBeginState)(&gengc->pMcdState->McdContext,
                                         gengc->pMcdState->McdCmdBatch.pv);

            //
            // Add MCDPIXELSTATE structure to state command if needed.
            //

            if (MCD_STATE_DIRTYTEST(gengc, PIXELSTATE))
            {
                GenMcdUpdatePixelState(gengc);
            }

            if (gengc->pMcdState->McdRcInfo.requestFlags &
                MCDRCINFO_FINE_GRAINED_STATE)
            {
                // Add front-end and rendering states.
                GenMcdUpdateFineState(gengc);
            }
            else
            {
                //
                // Add MCDRENDERSTATE structure to state command if needed.
                //

                if (MCD_STATE_DIRTYTEST(gengc, RENDERSTATE))
                {
                    GenMcdUpdateRenderState(gengc);
                }
            }

            //
            // Add MCDSCISSORSTATE structure to state command if needed.
            //

            if (MCD_STATE_DIRTYTEST(gengc, SCISSOR))
            {
                GenMcdUpdateScissorState(gengc);
            }

            //
            // Add MCDTEXENVSTATE structure to state command if needed.
            //

            if (MCD_STATE_DIRTYTEST(gengc, TEXENV))
            {
                GenMcdUpdateTexEnvState(gengc);
            }

            //
            // Send state command to MCD driver.
            //

            (gpMcdTable->pMCDFlushState)(gengc->pMcdState->McdCmdBatch.pv);

            //
            // Clear dirty flags.
            //

            MCD_STATE_RESET(gengc);
        }
    }
}

/******************************Public*Routine******************************\
* vInitPolyArrayBuffer
*
* Initialize the POLYARRAY/POLYDATA buffer pointed to by pdBuf.
*
* History:
*  12-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID FASTCALL vInitPolyArrayBuffer(__GLcontext *gc, POLYDATA *pdBuf,
                                   UINT pdBufSizeBytes, UINT pdBufSize)
{
    UINT i;
    POLYDATA *pdBufSAVE;
    GLuint   pdBufSizeBytesSAVE;
    GLuint   pdBufSizeSAVE;

    //
    // Save current polyarray buffer.  We are going to temporarily
    // replace the current one with the new one for the purposes
    // of initializing the buffer.  However, it is too early to
    // replace the current polyarray.  The higher level code will
    // figure that out later.
    //

    pdBufSAVE          = gc->vertex.pdBuf;
    pdBufSizeBytesSAVE = gc->vertex.pdBufSizeBytes;
    pdBufSizeSAVE      = gc->vertex.pdBufSize;

    //
    // Set polyarray buffer to memory allocated by MCD.
    //

    gc->vertex.pdBuf          = pdBuf;
    gc->vertex.pdBufSizeBytes = pdBufSizeBytes;
    gc->vertex.pdBufSize      = pdBufSize;

    //
    // Initialize the vertex buffer.
    //

    PolyArrayResetBuffer(gc);

    //
    // Restore the polyarray buffer.
    //

    gc->vertex.pdBuf          = pdBufSAVE;
    gc->vertex.pdBufSizeBytes = pdBufSizeBytesSAVE;
    gc->vertex.pdBufSize      = pdBufSizeSAVE;
}

/******************************Public*Routine******************************\
* GenMcdSetScaling
*
* Set up the various scale values needed for MCD or generic operation.
*
* This should be called when toggling between accelerated/non-accelerated
* operation.
*
* Returns:
*   None.
*
* History:
*  03-May-1996 -by- Otto Berkes [ottob]
* Wrote it.
\**************************************************************************/

VOID FASTCALL GenMcdSetScaling(__GLGENcontext *gengc)
{
    __GLcontext *gc = (__GLcontext *)gengc;
    GENMCDSTATE *pMcdState = gengc->pMcdState;
    __GLviewport *vp = &gc->state.viewport;
    double scale;

    //
    // If we're using MCD, set up the desired scale value:
    //

    if (pMcdState) {
        if (pMcdState->McdRcInfo.requestFlags & MCDRCINFO_DEVZSCALE)
            gengc->genAccel.zDevScale = pMcdState->McdRcInfo.zScale;
        else
            gengc->genAccel.zDevScale = pMcdState->McdRcInfo.depthBufferMax;
    } else if (gengc->_pMcdState)
        gengc->genAccel.zDevScale = gengc->_pMcdState->McdRcInfo.depthBufferMax;
        
    if (pMcdState)
        scale = gengc->genAccel.zDevScale * __glHalf;
    else
        scale = gc->depthBuffer.scale * __glHalf;
    gc->state.viewport.zScale = (__GLfloat)((vp->zFar - vp->zNear) * scale);
    gc->state.viewport.zCenter = (__GLfloat)((vp->zFar + vp->zNear) * scale);

    if (pMcdState && pMcdState->McdRcInfo.requestFlags & MCDRCINFO_NOVIEWPORTADJUST) {
        gc->constants.viewportXAdjust = 0;
        gc->constants.viewportYAdjust = 0;
        gc->constants.fviewportXAdjust = (__GLfloat)0.0;
        gc->constants.fviewportYAdjust = (__GLfloat)0.0;
    } else {
        gc->constants.viewportXAdjust = __GL_VERTEX_X_BIAS + __GL_VERTEX_X_FIX;
        gc->constants.viewportYAdjust = __GL_VERTEX_Y_BIAS + __GL_VERTEX_Y_FIX;
        gc->constants.fviewportXAdjust = (__GLfloat)gc->constants.viewportXAdjust;
        gc->constants.fviewportYAdjust = (__GLfloat)gc->constants.viewportYAdjust;
    }

    //
    // The inverses for these are set in __glContextSetColorScales which is
    // called on each MakeCurrent:
    //

    if (pMcdState && pMcdState->McdRcInfo.requestFlags & MCDRCINFO_DEVCOLORSCALE) {
        gc->redVertexScale   = pMcdState->McdRcInfo.redScale;
        gc->greenVertexScale = pMcdState->McdRcInfo.greenScale;
        gc->blueVertexScale  = pMcdState->McdRcInfo.blueScale;
        gc->alphaVertexScale = pMcdState->McdRcInfo.alphaScale;
    } else {
        if (gc->modes.colorIndexMode) {
            gc->redVertexScale   = (MCDFLOAT)1.0;
            gc->greenVertexScale = (MCDFLOAT)1.0;
            gc->blueVertexScale  = (MCDFLOAT)1.0;
            gc->alphaVertexScale = (MCDFLOAT)1.0;
        } else {
            gc->redVertexScale   = (MCDFLOAT)((1 << gc->modes.redBits) - 1);
            gc->greenVertexScale = (MCDFLOAT)((1 << gc->modes.greenBits) - 1);
            gc->blueVertexScale  = (MCDFLOAT)((1 << gc->modes.blueBits) - 1);
            if( gc->modes.alphaBits )
                gc->alphaVertexScale = (MCDFLOAT)((1 << gc->modes.alphaBits) - 1);
            else
                gc->alphaVertexScale = (MCDFLOAT)((1 << gc->modes.redBits) - 1);
        }
    }

    gc->redClampTable[1] = gc->redVertexScale;
    gc->redClampTable[2] = (__GLfloat)0.0;
    gc->redClampTable[3] = (__GLfloat)0.0;
    gc->greenClampTable[1] = gc->greenVertexScale;
    gc->greenClampTable[2] = (__GLfloat)0.0;
    gc->greenClampTable[3] = (__GLfloat)0.0;
    gc->blueClampTable[1] = gc->blueVertexScale;
    gc->blueClampTable[2] = (__GLfloat)0.0;
    gc->blueClampTable[3] = (__GLfloat)0.0;
    gc->alphaClampTable[1] = gc->alphaVertexScale;
    gc->alphaClampTable[2] = (__GLfloat)0.0;
    gc->alphaClampTable[3] = (__GLfloat)0.0;

    if (pMcdState && pMcdState->McdRcInfo.requestFlags & MCDRCINFO_Y_LOWER_LEFT) {
        gc->constants.yInverted = GL_FALSE;
        gc->constants.ySign = 1;
    } else {
        gc->constants.yInverted = GL_TRUE;
        gc->constants.ySign = -1;
    }

}

/******************************Public*Routine******************************\
*
* McdPixelFormatFromPfd
*
* Fills out an MCDPIXELFORMAT from a PIXELFORMATDESCRIPTOR
*
* History:
*  Mon Sep 16 14:51:42 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

VOID FASTCALL McdPixelFormatFromPfd(PIXELFORMATDESCRIPTOR *pfd,
                                    MCDPIXELFORMAT *mpf)
{
    mpf->nSize = sizeof(MCDPIXELFORMAT);
    mpf->dwFlags = pfd->dwFlags & (PFD_DOUBLEBUFFER |
                                   PFD_NEED_PALETTE |
                                   PFD_NEED_SYSTEM_PALETTE |
                                   PFD_SWAP_EXCHANGE |
                                   PFD_SWAP_COPY |
                                   PFD_SWAP_LAYER_BUFFERS);
    mpf->iPixelType = pfd->iPixelType;
    mpf->cColorBits = pfd->cColorBits;
    mpf->cRedBits = pfd->cRedBits;
    mpf->cRedShift = pfd->cRedShift;
    mpf->cGreenBits = pfd->cGreenBits;
    mpf->cGreenShift = pfd->cGreenShift;
    mpf->cBlueBits = pfd->cBlueBits;
    mpf->cBlueShift = pfd->cBlueShift;
    mpf->cAlphaBits = pfd->cAlphaBits;
    mpf->cAlphaShift = pfd->cAlphaShift;
    mpf->cDepthBits = pfd->cDepthBits;
    mpf->cDepthShift = 0;
    mpf->cDepthBufferBits = pfd->cDepthBits;
    mpf->cStencilBits = pfd->cStencilBits;
    mpf->cOverlayPlanes = pfd->bReserved & 0xf;
    mpf->cUnderlayPlanes = pfd->bReserved >> 4;
    mpf->dwTransparentColor = pfd->dwVisibleMask;
}

/******************************Public*Routine******************************\
* GenMcdResetViewportAdj
*
* If an MCD driver that specifies MCDRCINFO_NOVIEWPORTADJUST kicks back
* for simulations, we need to change the viewport adjust values from
* 0, 0 back to the default values in order to run the software
* implementation.
*
* If biasType is VP_FIXBIAS, this function will set the viewport adjust
* values to their software default.
*
* If biasType is VP_NOBIAS, this function will set the viewport adjust
* values to zero.
*
* Returns:
*   TRUE is viewport is set, FALSE otherwise.
*
* Note:
*   The main reason for returning a BOOL is so that caller can check if
*   VP_FIXBIAS succeeds.  If it does, it needs to reset values back to
*   VP_NOBIAS.
*
*   Also note that it is safe for non-MCD and MCD that does not set
*   MCDRCINFO_NOVIEWPORTADJUST to call this function.  This function
*   will do nothing in these situations and will return FALSE.
*
* History:
*  22-May-1997 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdResetViewportAdj(__GLcontext *gc, VP_BIAS_TYPE biasType)
{
    __GLGENcontext *gengc = (__GLGENcontext *) gc;
    BOOL bRet = FALSE;

    if (gengc->pMcdState &&
        (gengc->pMcdState->McdRcInfo.requestFlags & MCDRCINFO_NOVIEWPORTADJUST))
    {
        switch (biasType)
        {
            case VP_FIXBIAS:
                if (gc->constants.viewportXAdjust == 0)
                {
                    //
                    // The state of viewportYAdjust should match
                    // viewportXAdjust.  If not, the test should be
                    // changed (perhaps state flag in the context to
                    // track biasing).
                    //

                    ASSERTOPENGL((gc->constants.viewportYAdjust == 0),
                                 "GenMcdResetViewportAdj: "
                                 "viewportYAdjust not zero\n");

                    gc->constants.viewportXAdjust = __GL_VERTEX_X_BIAS +
                                                    __GL_VERTEX_X_FIX;
                    gc->constants.viewportYAdjust = __GL_VERTEX_Y_BIAS +
                                                    __GL_VERTEX_Y_FIX;
                    gc->constants.fviewportXAdjust = (__GLfloat)gc->constants.viewportXAdjust;
                    gc->constants.fviewportYAdjust = (__GLfloat)gc->constants.viewportYAdjust;

                    //
                    // Apply new bias to the rasterPos.
                    //

                    gc->state.current.rasterPos.window.x += gc->constants.fviewportXAdjust;
                    gc->state.current.rasterPos.window.y += gc->constants.fviewportYAdjust;
                }
                bRet = TRUE;
                break;

            case VP_NOBIAS:
                if (gc->constants.viewportXAdjust != 0)
                {
                    //
                    // The state of viewportYAdjust should match
                    // viewportXAdjust.  If not, the test should be
                    // changed (perhaps state flag in the context to
                    // track biasing).
                    //

                    ASSERTOPENGL((gc->constants.viewportYAdjust != 0),
                                 "GenMcdResetViewportAdj: "
                                 "viewportYAdjust zero\n");

                    //
                    // Remove bias from the rasterPos before resetting.
                    //

                    gc->state.current.rasterPos.window.x -= gc->constants.fviewportXAdjust;
                    gc->state.current.rasterPos.window.y -= gc->constants.fviewportYAdjust;

                    gc->constants.viewportXAdjust = 0;
                    gc->constants.viewportYAdjust = 0;
                    gc->constants.fviewportXAdjust = (__GLfloat)0.0;
                    gc->constants.fviewportYAdjust = (__GLfloat)0.0;
                }
                bRet = TRUE;
                break;

            default:
                DBGPRINT("GenMcdResetViewportAdj: unknown type\n");
                break;
        }

        if (bRet)
        {
            __GLbeginMode beginMode = gc->beginMode;

            //
            // Why save/restore beginMode?
            //
            // Because we are playing around with the viewport values,
            // ApplyViewport may inadvertently set beginMode to
            // __GL_NEED_VALIDATE even though we will later restore the
            // original viewport values.  This can confuse glim_DrawPolyArray
            // which plays around with the beginMode settings.
            //

            __glUpdateViewport(gc);
            (gc->procs.applyViewport)(gc);
            __glUpdateViewportDependents(gc);

            gc->beginMode = beginMode;
        }
    }

    return bRet;
}

/******************************Public*Routine******************************\
* bInitMcdContext
*
* Allocate and initialize the GENMCDSTATE structure.  Create MCD context
* and shared memory buffers used to pass vertex arrays, commands, and state.
*
* This state exists per-context.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*   In addition, the gengc->pMcdState is valid IFF successful.
*
* History:
*  05-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL bInitMcdContext(__GLGENcontext *gengc, GLGENwindow *pwnd)
{
    BOOL bRet = FALSE;
    __GLcontext *gc = &gengc->gc;
    GENMCDSTATE *pMcdState = (GENMCDSTATE *) NULL;
    ULONG ulBytes;
    UINT  nVertices;
    UINT  pdBufSize;
    POLYDATA *pd;
    DWORD dwFlags;
    MCDRCINFOPRIV mriPriv;

    //
    // This functions cannot assume MCD entry point table is already
    // initialized.
    //

    if (!bInitMcd(gengc->gsurf.hdc))
    {
        goto bInitMcdContext_exit;
    }

    //
    // Fail if not an MCD pixelformat.
    //

    if (!(gengc->gsurf.pfd.dwFlags & PFD_GENERIC_ACCELERATED))
    {
        goto bInitMcdContext_exit;
    }

    //
    // Allocate memory for our MCD state.
    //

    pMcdState = (GENMCDSTATE *)ALLOCZ(sizeof(*gengc->pMcdState));

    if (pMcdState)
    {
        //
        // Create an MCD context.
        //

        //
        // Pickup viewportXAdjust and viewportYAdjust from the constants section
        // of the gc.
        //

        pMcdState->McdRcInfo.viewportXAdjust = gengc->gc.constants.viewportXAdjust;
        pMcdState->McdRcInfo.viewportYAdjust = gengc->gc.constants.viewportYAdjust;

        if (!gengc->gsurf.pfd.cDepthBits || (gengc->gsurf.pfd.cDepthBits >= 32))
            pMcdState->McdRcInfo.depthBufferMax = ~((ULONG)0);
        else
            pMcdState->McdRcInfo.depthBufferMax = (1 << gengc->gsurf.pfd.cDepthBits) - 1;

        //!!!
        //!!! This is broken since we can't use the full z-buffer range!
        //!!!

        pMcdState->McdRcInfo.depthBufferMax >>= 1;

        pMcdState->McdRcInfo.zScale = (MCDDOUBLE)pMcdState->McdRcInfo.depthBufferMax;

        //
        // This is also computed by initCi/initRGB, but this function
        // is called before the color buffers are initialized:
        //

        if (gc->modes.colorIndexMode)
        {
            pMcdState->McdRcInfo.redScale   = (MCDFLOAT)1.0;
            pMcdState->McdRcInfo.greenScale = (MCDFLOAT)1.0;
            pMcdState->McdRcInfo.blueScale  = (MCDFLOAT)1.0;
            pMcdState->McdRcInfo.alphaScale = (MCDFLOAT)1.0;
        }
        else
        {
            pMcdState->McdRcInfo.redScale   = (MCDFLOAT)((1 << gc->modes.redBits) - 1);
            pMcdState->McdRcInfo.greenScale = (MCDFLOAT)((1 << gc->modes.greenBits) - 1);
            pMcdState->McdRcInfo.blueScale  = (MCDFLOAT)((1 << gc->modes.blueBits) - 1);
            pMcdState->McdRcInfo.alphaScale = (MCDFLOAT)((1 << gc->modes.redBits) - 1);
        }

        dwFlags = 0;
            
        // Consider - Extract clipper-associated hwnds?  Whole clipping
	// scheme is broken until clipper data can be accessed in kernel.
        if ((gengc->gsurf.dwFlags & GLSURF_DIRECTDRAW) == 0)
        {
            dwFlags |= MCDSURFACE_HWND;
        }
        else
        {
            // Cache kernel-mode surface handles for DirectDraw
            // This must occur before the call to MCDCreateContext
            pMcdState->hDdColor = (HANDLE)
                ((LPDDRAWI_DDRAWSURFACE_INT)gengc->gsurf.dd.gddsFront.pdds)->
                lpLcl->hDDSurface;
            if (gengc->gsurf.dd.gddsZ.pdds != NULL)
            {
                pMcdState->hDdDepth = (HANDLE)
                    ((LPDDRAWI_DDRAWSURFACE_INT)gengc->gsurf.dd.gddsZ.pdds)->
                    lpLcl->hDDSurface;
            }
        }

        if (SUPPORTS_DIRECT())
        {
            dwFlags |= MCDSURFACE_DIRECT;
        }
        
        mriPriv.mri = pMcdState->McdRcInfo;
        if (!(gpMcdTable->pMCDCreateContext)(&pMcdState->McdContext,
                                             &mriPriv,
                                             &gengc->gsurf,
                                             pwnd->ipfd - pwnd->ipfdDevMax,
                                             dwFlags))
        {
            WARNING("bInitMcdContext: MCDCreateContext failed\n");
            goto bInitMcdContext_exit;
        }

        pMcdState->McdRcInfo = mriPriv.mri;
        
        //
        // Get MCDPIXELFORMAT and cache in GENMCDSTATE.
        //

        if (gengc->gsurf.dwFlags & GLSURF_DIRECTDRAW)
        {
            McdPixelFormatFromPfd(&gengc->gsurf.pfd, &pMcdState->McdPixelFmt);
        }
        else if (!(gpMcdTable->pMCDDescribeMcdPixelFormat)
                 (gengc->gsurf.hdc,
                  pwnd->ipfd - pwnd->ipfdDevMax,
                  &pMcdState->McdPixelFmt))
        {
            WARNING("bInitMcdContext: MCDDescribeMcdPixelFormat failed\n");
            goto bInitMcdContext_exit;
        }

        //
        // Allocate cmd/state buffer.
        //

        //!!!mcd -- How much memory should be allocated for cmd buffer?
        //!!!mcd    Use a page (4K) for now...
        ulBytes = 4096;
        pMcdState->McdCmdBatch.size = ulBytes;
        pMcdState->McdCmdBatch.pv =
            (gpMcdTable->pMCDAlloc)(&pMcdState->McdContext, ulBytes,
                                    &pMcdState->McdCmdBatch.hmem, 0);

        if (!pMcdState->McdCmdBatch.pv)
        {
            WARNING("bInitMcdContext: state buf MCDAlloc failed\n");
            goto bInitMcdContext_exit;
        }

        //
        // Determine size of vertex buffer we should use with MCD driver.
        // This is calculated by taking the size the MCD driver requests
        // and computing the number of POLYDATA structure that will fit.
        // If the result is less than the minimum size required by the
        // generic software implementation, bump it up to the minimum.
        //

        ulBytes = McdDriverInfo.mcdDriverInfo.drvBatchMemSizeMax;
        nVertices = ulBytes / sizeof(POLYDATA);

        if (nVertices < MINIMUM_POLYDATA_BUFFER_SIZE)
        {
            ulBytes = MINIMUM_POLYDATA_BUFFER_SIZE * sizeof(POLYDATA);
            nVertices = MINIMUM_POLYDATA_BUFFER_SIZE;
        }

        //
        // Only n-1 vertices are used for the buffer.  The "extra" is
        // reserved for use by the polyarray code (see PolyArrayAllocBuf
        // in so_prim.c).
        //

        pdBufSize = nVertices - 1;

        //
        // Allocate vertex buffers.
        //

        if (McdDriverInfo.mcdDriverInfo.drvMemFlags & MCDRV_MEM_DMA)
        {
            pMcdState->McdBuf2.size = ulBytes;
            pMcdState->McdBuf2.pv =
                (gpMcdTable->pMCDAlloc)(&pMcdState->McdContext, ulBytes,
                                        &pMcdState->McdBuf2.hmem, 0);

            if (pMcdState->McdBuf2.pv)
            {
                //
                // Configure memory buffer as a POLYDATA buffer.
                //

                vInitPolyArrayBuffer(gc, (POLYDATA *) pMcdState->McdBuf2.pv,
                                     ulBytes, pdBufSize);
            }
            else
            {
                WARNING("bInitMcdContext: 2nd MCDAlloc failed\n");
                goto bInitMcdContext_exit;
            }
        }

        pMcdState->McdBuf1.size = ulBytes;
        pMcdState->McdBuf1.pv =
            (gpMcdTable->pMCDAlloc)(&pMcdState->McdContext, ulBytes,
                                    &pMcdState->McdBuf1.hmem, 0);

        if (pMcdState->McdBuf1.pv)
        {
            pMcdState->pMcdPrimBatch = &pMcdState->McdBuf1;

            //
            // Configure memory buffer as a POLYDATA buffer.
            //

            vInitPolyArrayBuffer(gc, (POLYDATA *) pMcdState->McdBuf1.pv,
                                 ulBytes, pdBufSize);

            //
            // Free current poly array buffer.
            //
            // If we fail after this, we must call PolyArrayAllocBuffer to
            // restore the poly array buffer.  Luckily, at this point we
            // are guaranteed not fail.
            //

            PolyArrayFreeBuffer(gc);

            //
            // Set poly array buffer to memory allocated by MCD.
            //

            gc->vertex.pdBuf = (POLYDATA *) pMcdState->pMcdPrimBatch->pv;
            gc->vertex.pdBufSizeBytes = ulBytes;
            gc->vertex.pdBufSize = pdBufSize;
        }
        else
        {
            WARNING("bInitMcdContext: MCDAlloc failed\n");
            goto bInitMcdContext_exit;
        }

        if (pwnd->dwMcdWindow == 0)
        {
            //
            // Save MCD server-side window handle in the GENwindow
            //

            pwnd->dwMcdWindow = mriPriv.dwMcdWindow;
        }
        else
        {
            ASSERTOPENGL(pwnd->dwMcdWindow == mriPriv.dwMcdWindow,
                         "dwMcdWindow mismatch\n");
        }

        //
        // Finally, success.
        //

        bRet = TRUE;
    }

bInitMcdContext_exit:

    //
    // If function failed, cleanup allocated resources.
    //

    if (!bRet)
    {
        if (pMcdState)
        {
            if (pMcdState->McdBuf1.pv)
            {
                (gpMcdTable->pMCDFree)(&pMcdState->McdContext, pMcdState->McdBuf1.pv);
            }

            if (pMcdState->McdBuf2.pv)
            {
                (gpMcdTable->pMCDFree)(&pMcdState->McdContext, pMcdState->McdBuf2.pv);
            }

            if (pMcdState->McdCmdBatch.pv)
            {
                (gpMcdTable->pMCDFree)(&pMcdState->McdContext, pMcdState->McdCmdBatch.pv);
            }

            if (pMcdState->McdContext.hMCDContext)
            {
                (gpMcdTable->pMCDDeleteContext)(&pMcdState->McdContext);
            }

            FREE(pMcdState);
        }
        gengc->_pMcdState = (GENMCDSTATE *) NULL;
    }
    else
    {
        gengc->_pMcdState = pMcdState;

        //
        // For generic formats, the depth resolution (i.e., number of
        // active depth bits) and the depth "pixel stride" are the same.
        // So GetContextModes, which sets modes.depthBits, can use the
        // PIXELFORMATDESCRIPTOR.cDepthBits for generic pixel formats.
        //
        // However, these two quantities can differ for MCD, so we need
        // to set it to cDepthBufferBits once we know that this is an
        // MCD context.
        //

        if (gengc->_pMcdState)
            gengc->gc.modes.depthBits = gengc->_pMcdState->McdPixelFmt.cDepthBufferBits;
    }

    gengc->pMcdState = (GENMCDSTATE *) NULL;

    return bRet;
}

/******************************Public*Routine******************************\
* bInitMcdSurface
*
* Allocate and initialize the GENMCDSURFACE structure.  This includes
* creating shared span buffers to read/write the MCD front, back and depth
* buffers.
*
* The MCDBUFFERS structure, which describes the location of the MCD buffers
* (if directly accessible), is left zero-initialized.  The contents of this
* structure are only valid when the screen lock is held and must be reset each
* time direct screen access is started.
*
* This function, if successful, will also bind the MCD context to the MCD
* surface.
*
* This state exists per-window.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*   In addition, the gengc->pMcdState is valid IFF successful.
*
* History:
*  05-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL bInitMcdSurface(__GLGENcontext *gengc, GLGENwindow *pwnd,
                              __GLGENbuffers *buffers)
{
    BOOL bRet = FALSE;
    __GLcontext *gc = &gengc->gc;
    GENMCDSTATE *pMcdState;
    GENMCDSURFACE *pMcdSurf = (GENMCDSURFACE *) NULL;
    ULONG ulBytes;
    UINT  nVertices;
    POLYDATA *pd;

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "bInitMcdSurface: mcd32.dll not initialized\n");

    //
    // Fail if no MCD context.
    //

    if (!(pMcdState = gengc->_pMcdState))
    {
        goto bInitMcdSurface_exit;
    }

    //
    // Allocate memory for our MCD surface.
    //

    pMcdSurf = (GENMCDSURFACE *)ALLOCZ(sizeof(*buffers->pMcdSurf));

    if (pMcdSurf)
    {
        //
        // Remember the window this surface is bound to.
        //

        pMcdSurf->pwnd = pwnd;

        //
        // Allocate scanline depth buffer.  Used to read/write depth buffer
        // spans.
        //

        if (pMcdState->McdPixelFmt.cDepthBits)
        {
            pMcdSurf->McdDepthBuf.size =
                MCD_MAX_SCANLINE * ((pMcdState->McdPixelFmt.cDepthBufferBits + 7) >> 3);
            pMcdSurf->McdDepthBuf.pv =
                (gpMcdTable->pMCDAlloc)(&pMcdState->McdContext,
                                        pMcdSurf->McdDepthBuf.size,
                                        &pMcdSurf->McdDepthBuf.hmem, 0);

            if (!pMcdSurf->McdDepthBuf.pv)
            {
                WARNING("bInitMcdSurface: MCDAlloc depth buf failed\n");
                goto bInitMcdSurface_exit;
            }

            //
            // A 32-bit depth span is required by generic implementation for
            // simulations.  If cDepthBufferBits < 32, then we need to allocate
            // a separate buffer to do the conversion.
            //

            if (pMcdState->McdPixelFmt.cDepthBufferBits < 32)
            {
                pMcdSurf->pDepthSpan =
                    (__GLzValue *)ALLOC(sizeof(__GLzValue) * MCD_MAX_SCANLINE);

                if (!pMcdSurf->pDepthSpan)
                {
                    WARNING("bInitMcdSurface: malloc depth buf failed\n");
                    goto bInitMcdSurface_exit;
                }
            }
            else
            {
                pMcdSurf->pDepthSpan = (__GLzValue *) pMcdSurf->McdDepthBuf.pv;
            }
        }
        else
        {
            pMcdSurf->McdDepthBuf.pv = (PVOID) NULL;
            pMcdSurf->pDepthSpan = (PVOID) NULL;
        }

        pMcdSurf->depthBitMask = (~0) << (32 - pMcdState->McdPixelFmt.cDepthBits);

        //
        // Allocate scanline color buffer.  Used to read/write front/back
        // buffer spans.
        //

        pMcdSurf->McdColorBuf.size =
            MCD_MAX_SCANLINE * ((pMcdState->McdPixelFmt.cColorBits + 7) >> 3);
        pMcdSurf->McdColorBuf.pv =
            (gpMcdTable->pMCDAlloc)(&pMcdState->McdContext,
                                    pMcdSurf->McdColorBuf.size,
                                    &pMcdSurf->McdColorBuf.hmem, 0);

        if (!pMcdSurf->McdColorBuf.pv)
        {
            WARNING("bInitMcdSurface: MCDAlloc color buf failed\n");
            goto bInitMcdSurface_exit;
        }

        //
        // Finally, success.
        //

        bRet = TRUE;
    }

bInitMcdSurface_exit:

    //
    // If function failed, cleanup allocated resources.
    //

    if (!bRet)
    {
        if (pMcdSurf)
        {
            if (pMcdSurf->McdColorBuf.pv)
            {
                (gpMcdTable->pMCDFree)(&pMcdState->McdContext, pMcdSurf->McdColorBuf.pv);
            }

            if (pMcdSurf->pDepthSpan != pMcdSurf->McdDepthBuf.pv)
            {
                FREE(pMcdSurf->pDepthSpan);
            }

            if (pMcdSurf->McdDepthBuf.pv)
            {
                (gpMcdTable->pMCDFree)(&pMcdState->McdContext, pMcdSurf->McdDepthBuf.pv);
            }

            FREE(pMcdSurf);
            buffers->pMcdSurf = (GENMCDSURFACE *) NULL;
            pMcdState->pMcdSurf = (GENMCDSURFACE *) NULL;
        }
    }
    else
    {
        //
        // Surface created.  Save it in the __GLGENbuffers.
        //

        buffers->pMcdSurf = pMcdSurf;

        //
        // Bind the context to the surface.
        // Sounds fancy, but it really just means save a copy of pointer
        // (and a copy of the pDepthSpan for convenience).
        //

        pMcdState->pMcdSurf = pMcdSurf;
        pMcdState->pDepthSpan = pMcdSurf->pDepthSpan;

        //
        // MCD state is now fully created and bound to a surface.
        // OK to connect pMcdState to the _pMcdState.
        //

        gengc->pMcdState = gengc->_pMcdState;
        gengc->pMcdState->mcdFlags |= (MCD_STATE_FORCEPICK | MCD_STATE_FORCERESIZE);
    }

    return bRet;
}

/******************************Public*Routine******************************\
* GenMcdDeleteContext
*
* Delete the resources belonging to the MCD context (including the context).
*
* History:
*  16-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL GenMcdDeleteContext(GENMCDSTATE *pMcdState)
{
    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdDeleteContext: mcd32.dll not initialized\n");

    if (pMcdState)
    {
        if (pMcdState->McdBuf1.pv)
        {
            (gpMcdTable->pMCDFree)(&pMcdState->McdContext, pMcdState->McdBuf1.pv);
        }

        if (pMcdState->McdBuf2.pv)
        {
            (gpMcdTable->pMCDFree)(&pMcdState->McdContext, pMcdState->McdBuf2.pv);
        }

        if (pMcdState->McdCmdBatch.pv)
        {
            (gpMcdTable->pMCDFree)(&pMcdState->McdContext, pMcdState->McdCmdBatch.pv);
        }

        if (pMcdState->McdContext.hMCDContext)
        {
            (gpMcdTable->pMCDDeleteContext)(&pMcdState->McdContext);
        }

        FREE(pMcdState);
    }
}

/******************************Public*Routine******************************\
* GenMcdDeleteSurface
*
* Delete the resources belonging to the MCD surface.
*
* History:
*  16-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL GenMcdDeleteSurface(GENMCDSURFACE *pMcdSurf)
{
    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdDeleteSurface: mcd32.dll not initialized\n");

    if (pMcdSurf)
    {
        MCDCONTEXT McdContext;

    //
    // If a separate depth interchange buffer was allocated, delete it.
    //

        if (pMcdSurf->pDepthSpan != pMcdSurf->McdDepthBuf.pv)
        {
            FREE(pMcdSurf->pDepthSpan);
        }

    //
    // A valid McdContext is not guaranteed to exist at the time this function
    // is called.  Therefore, need to fake up an McdContext with which to call
    // MCDFree.  Currently, the only thing in the McdContext that needs to be
    // valid in order to call MCDFree is the hdc field.
    //

        memset(&McdContext, 0, sizeof(McdContext));

        if (pMcdSurf->pwnd->gwid.iType == GLWID_DDRAW)
        {
            McdContext.hdc = pMcdSurf->pwnd->gwid.hdc;
        }
        else
        {
            McdContext.hdc = GetDC(pMcdSurf->pwnd->gwid.hwnd);
        }
        if (McdContext.hdc)
        {
            if (pMcdSurf->McdColorBuf.pv)
            {
                (gpMcdTable->pMCDFree)(&McdContext, pMcdSurf->McdColorBuf.pv);
            }

            if (pMcdSurf->McdDepthBuf.pv)
            {
                (gpMcdTable->pMCDFree)(&McdContext, pMcdSurf->McdDepthBuf.pv);
            }

            if (pMcdSurf->pwnd->gwid.iType != GLWID_DDRAW)
            {
                ReleaseDC(pMcdSurf->pwnd->gwid.hwnd, McdContext.hdc);
            }
        }

    //
    // Delete the GENMCDSURFACE structure.
    //

        FREE(pMcdSurf);
    }
}

/******************************Public*Routine******************************\
* GenMcdMakeCurrent
*
* Call MCD driver to bind specified context to window.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  03-Apr-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdMakeCurrent(__GLGENcontext *gengc, GLGENwindow *pwnd)
{
    BOOL bRet;
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdMakeCurrent: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdMakeCurrent: mcd32.dll not initialized\n");

    bRet = (gpMcdTable->pMCDBindContext)(&pMcdState->McdContext,
                                         gengc->gwidCurrent.hdc, pwnd);

    //
    // Fake up some of the __GLGENbitmap information.  The WNDOBJ is required
    // for clipping of the hardware back buffer.  The hdc is required to
    // retrieve drawing data from GDI.
    //

    if (gengc->gc.modes.doubleBufferMode)
    {
        __GLGENbitmap *genBm = gengc->gc.back->bitmap;

        ASSERT_WINCRIT(gengc->pwndLocked);
        genBm->pwnd = gengc->pwndLocked;
        genBm->hdc = gengc->gwidCurrent.hdc;
    }

#if DBG
    if (!bRet)
    {
        WARNING2("GenMcdMakeCurrent: MCDBindContext failed\n"
                 "\tpMcdCx = 0x%08lx, pwnd = 0x%08lx\n",
                 &pMcdState->McdContext, pwnd);
    }
#endif

    return bRet;
}

/******************************Public*Routine******************************\
* GenMcdClear
*
* Call MCD driver to clear specified buffers.  The buffers are specified by
* the masked pointed to by pClearMask.
*
* There is no function return value, but the function will clear the mask
* bits of the buffers it successfully cleared.
*
* History:
*  06-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL GenMcdClear(__GLGENcontext *gengc, ULONG *pClearMask)
{
    RECTL rcl;
    ULONG mask;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdClear: null pMcdState\n");

    //
    // If MCD format supports stencil, include GL_STENCIL_BUFFER_BIT in
    // the mask.
    //

    if (gengc->pMcdState->McdPixelFmt.cStencilBits)
    {
        mask = *pClearMask & (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT |
                              GL_STENCIL_BUFFER_BIT);
    }
    else
    {
        mask = *pClearMask & (GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdClear: mcd32.dll not initialized\n");

    if ( mask )
    {
        GLGENwindow *pwnd = gengc->pwndLocked;

        //
        // Determine the clear rectangle.  If there is any window clipping
        // or scissoring, the driver will have to handle it.
        //

        rcl.left   = 0;
        rcl.top    = 0;
        rcl.right  = pwnd->rclClient.right - pwnd->rclClient.left;
        rcl.bottom = pwnd->rclClient.bottom - pwnd->rclClient.top;

        if ((rcl.left != rcl.right) && (rcl.top != rcl.bottom))
        {
            //
            // Before calling MCD to draw, flush state.
            //

            vFlushDirtyState(gengc);

            if ( (gpMcdTable->pMCDClear)(&gengc->pMcdState->McdContext, rcl,
                                         mask) )
            {
                //
                // Successful, so clear the bits of the buffers we
                // handled.
                //

                *pClearMask &= ~(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

                //
                // Stencil buffer is supplied by generic if MCD does not
                // support it.  Therefore, clear this bit if and only if
                // supported by MCD.
                //

                if (gengc->pMcdState->McdPixelFmt.cStencilBits)
                    *pClearMask &= ~GL_STENCIL_BUFFER_BIT;
            }
        }
    }
}

/******************************Public*Routine******************************\
* GenMcdCopyPixels
*
* Copy span scanline buffer to/from display.  Direction is determined by
* the flag bIn (if bIn is TRUE, copy from color span buffer to display;
* otherwise, copy from display to color span buffer).
*
* History:
*  14-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void GenMcdCopyPixels(__GLGENcontext *gengc, __GLcolorBuffer *cfb,
                      GLint x, GLint y, GLint cx, BOOL bIn)
{
    GENMCDSTATE *pMcdState;
    GENMCDSURFACE *pMcdSurf;
    ULONG ulType;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdCopyPixels: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdCopyPixels: mcd32.dll not initialized\n");

    pMcdState = gengc->pMcdState;
    pMcdSurf = pMcdState->pMcdSurf;

    //
    // Clip the length of the span to the scanline buffer size.
    //

    //!!!mcd -- should we just enforce the buffer limit?
    //cx = min(cx, MCD_MAX_SCANLINE);
#if DBG
    if (cx > gengc->gc.constants.width)
        WARNING2("GenMcdCopyPixels: cx (%ld) bigger than window width (%ld)\n", cx, gengc->gc.constants.width);
    ASSERTOPENGL(cx <= MCD_MAX_SCANLINE, "GenMcdCopyPixels: cx exceeds buffer width\n");
#endif

    //
    // Convert screen coordinates to window coordinates.
    //

    if (cfb == gengc->gc.front)
    {
        ulType = MCDSPAN_FRONT;
        x -= gengc->gc.frontBuffer.buf.xOrigin;
        y -= gengc->gc.frontBuffer.buf.yOrigin;
    }
    else
    {
        ulType = MCDSPAN_BACK;
        x -= gengc->gc.backBuffer.buf.xOrigin;
        y -= gengc->gc.backBuffer.buf.yOrigin;
    }

    //
    // If bIn, copy from the scanline buffer to the MCD buffer.
    // Otherwise, copy from the MCD buffer into the scanline buffer.
    //

    if ( bIn )
    {
        if ( !(gpMcdTable->pMCDWriteSpan)(&pMcdState->McdContext,
                                          pMcdSurf->McdColorBuf.pv,
                                          x, y, cx, ulType) )
        {
            WARNING3("GenMcdCopyPixels: MCDWriteSpan failed (%ld, %ld) %ld\n", x, y, cx);
        }
    }
    else
    {
        if ( !(gpMcdTable->pMCDReadSpan)(&pMcdState->McdContext,
                                         pMcdSurf->McdColorBuf.pv,
                                         x, y, cx, ulType) )
        {
            WARNING3("GenMcdCopyPixels: MCDReadSpan failed (%ld, %ld) %ld\n", x, y, cx);
        }
    }
}

/******************************Public*Routine******************************\
* GenMcdUpdateRenderState
*
* Update MCD render state from the OpenGL state.
*
* This call only adds a state structure to the current state command.
* It is assumed that the caller has already called MCDBeginState and
* will call MCDFlushState.
*
* History:
*  08-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL GenMcdUpdateRenderState(__GLGENcontext *gengc)
{
    __GLcontext *gc = &gengc->gc;
    GENMCDSTATE *pMcdState = gengc->pMcdState;
    MCDRENDERSTATE McdRenderState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdUpdateRenderState: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdUpdateRenderState: mcd32.dll not initialized\n");

    //
    // Compute MCD state from the current OpenGL context state.
    //

    //
    // -=<< State Enables >>=-
    //

    McdRenderState.enables = gc->state.enables.general;

    //
    // -=<< Texture State >>=-
    //

    McdRenderState.textureEnabled = gc->texture.textureEnabled;

    //
    // -=<< Fog State >>=-
    //

    *((__GLcolor *) &McdRenderState.fogColor) = gc->state.fog.color;
    McdRenderState.fogIndex   = gc->state.fog.index;
    McdRenderState.fogDensity = gc->state.fog.density;
    McdRenderState.fogStart   = gc->state.fog.start;
    McdRenderState.fogEnd     = gc->state.fog.end;
    McdRenderState.fogMode    = gc->state.fog.mode;

    //
    // -=<< Shading Model State >>=-
    //

    McdRenderState.shadeModel = gc->state.light.shadingModel;

    //
    // -=<< Point Drawing State >>=-
    //

    McdRenderState.pointSize         = gc->state.point.requestedSize;

    //
    // -=<< Line Drawing State >>=-
    //

    McdRenderState.lineWidth          = gc->state.line.requestedWidth;
    McdRenderState.lineStipplePattern = gc->state.line.stipple;
    McdRenderState.lineStippleRepeat  = gc->state.line.stippleRepeat;

    //
    // -=<< Polygon Drawing State >>=-
    //

    McdRenderState.cullFaceMode         = gc->state.polygon.cull;
    McdRenderState.frontFace            = gc->state.polygon.frontFaceDirection;
    McdRenderState.polygonModeFront     = gc->state.polygon.frontMode;
    McdRenderState.polygonModeBack      = gc->state.polygon.backMode;
    memcpy(&McdRenderState.polygonStipple, &gc->state.polygonStipple.stipple,
           sizeof(McdRenderState.polygonStipple));
    McdRenderState.zOffsetFactor        = gc->state.polygon.factor;
    McdRenderState.zOffsetUnits         = gc->state.polygon.units;

    //
    // -=<< Stencil Test State >>=-
    //

    McdRenderState.stencilTestFunc  = gc->state.stencil.testFunc;
    McdRenderState.stencilMask      = (USHORT) gc->state.stencil.mask;
    McdRenderState.stencilRef       = (USHORT) gc->state.stencil.reference;
    McdRenderState.stencilFail      = gc->state.stencil.fail;
    McdRenderState.stencilDepthFail = gc->state.stencil.depthFail;
    McdRenderState.stencilDepthPass = gc->state.stencil.depthPass;

    //
    // -=<< Alpha Test State >>=-
    //

    McdRenderState.alphaTestFunc   = gc->state.raster.alphaFunction;
    McdRenderState.alphaTestRef    = gc->state.raster.alphaReference;

    //
    // -=<< Depth Test State >>=-
    //

    McdRenderState.depthTestFunc   = gc->state.depth.testFunc;

    //
    // -=<< Blend State >>=-
    //

    McdRenderState.blendSrc    = gc->state.raster.blendSrc;
    McdRenderState.blendDst    = gc->state.raster.blendDst;

    //
    // -=<< Logic Op State >>=-
    //

    McdRenderState.logicOpMode        = gc->state.raster.logicOp;

    //
    // -=<< Frame Buffer Control State >>=-
    //

    McdRenderState.drawBuffer         = gc->state.raster.drawBuffer;
    McdRenderState.indexWritemask     = gc->state.raster.writeMask;
    McdRenderState.colorWritemask[0]  = gc->state.raster.rMask;
    McdRenderState.colorWritemask[1]  = gc->state.raster.gMask;
    McdRenderState.colorWritemask[2]  = gc->state.raster.bMask;
    McdRenderState.colorWritemask[3]  = gc->state.raster.aMask;
    McdRenderState.depthWritemask     = gc->state.depth.writeEnable;

    // To be consistent, we will scale the clear color to whatever
    // the MCD driver specified:

    McdRenderState.colorClearValue.r = gc->state.raster.clear.r * gc->redVertexScale;
    McdRenderState.colorClearValue.g = gc->state.raster.clear.g * gc->greenVertexScale;
    McdRenderState.colorClearValue.b = gc->state.raster.clear.b * gc->blueVertexScale;
    McdRenderState.colorClearValue.a = gc->state.raster.clear.a * gc->alphaVertexScale;

    McdRenderState.indexClearValue    = gc->state.raster.clearIndex;
    McdRenderState.stencilClearValue  = (USHORT) gc->state.stencil.clear;

    McdRenderState.depthClearValue   = (MCDDOUBLE) (gc->state.depth.clear *
                                                 gengc->genAccel.zDevScale);

    //
    // -=<< Lighting >>=-
    //

    McdRenderState.twoSided = gc->state.light.model.twoSided;

    //
    // -=<< Clipping Control >>=-
    //

    memset(McdRenderState.userClipPlanes, 0, sizeof(McdRenderState.userClipPlanes));
    {
        ULONG i, mask, numClipPlanes;

        //
        // Number of user defined clip planes should match.  However,
        // rather than assume this, let's take the min and be robust.
        //

        ASSERTOPENGL(sizeof(__GLcoord) == sizeof(MCDCOORD),
            "GenMcdUpdateRenderState: coord struct mismatch\n");

        ASSERTOPENGL(MCD_MAX_USER_CLIP_PLANES == gc->constants.numberOfClipPlanes,
            "GenMcdUpdateRenderState: num clip planes mismatch\n");

        numClipPlanes = min(MCD_MAX_USER_CLIP_PLANES, gc->constants.numberOfClipPlanes);

        for (i = 0, mask = 1; i < numClipPlanes; i++, mask <<= 1)
        {
            if (mask & gc->state.enables.clipPlanes)
            {
                McdRenderState.userClipPlanes[i] =
                    *(MCDCOORD *)&gc->state.transform.eyeClipPlanes[i];
            }
        }
    }

    //
    // -=<< Hints >>=-
    //

    McdRenderState.perspectiveCorrectionHint = gc->state.hints.perspectiveCorrection;
    McdRenderState.pointSmoothHint           = gc->state.hints.pointSmooth;
    McdRenderState.lineSmoothHint            = gc->state.hints.lineSmooth;
    McdRenderState.polygonSmoothHint         = gc->state.hints.polygonSmooth;
    McdRenderState.fogHint                   = gc->state.hints.fog;

    //
    // Now that the complete MCD state is computed, add it to the state cmd.
    //

    (gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                     MCD_RENDER_STATE,
                                     &McdRenderState,
                                     sizeof(McdRenderState));
}

/******************************Public*Routine******************************\
* GenMcdViewport
*
* Set the viewport from the OpenGL state.
*
* History:
*  09-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL GenMcdViewport(__GLGENcontext *gengc)
{
    MCDVIEWPORT mcdVP;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdViewport: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdViewport: mcd32.dll not initialized\n");

    //
    // We can copy directly from &viewport.xScale to a MCDVIEWPORT because the
    // structures are the same.  To be safe, assert the structure ordering.
    //

    ASSERTOPENGL(
           offsetof(MCDVIEWPORT, xCenter) ==
           (offsetof(__GLviewport, xCenter) - offsetof(__GLviewport, xScale))
        && offsetof(MCDVIEWPORT, yCenter) ==
           (offsetof(__GLviewport, yCenter) - offsetof(__GLviewport, xScale))
        && offsetof(MCDVIEWPORT, zCenter) ==
           (offsetof(__GLviewport, zCenter) - offsetof(__GLviewport, xScale))
        && offsetof(MCDVIEWPORT, yScale)  ==
           (offsetof(__GLviewport, yScale) - offsetof(__GLviewport, xScale))
        && offsetof(MCDVIEWPORT, zScale)  ==
           (offsetof(__GLviewport, zScale) - offsetof(__GLviewport, xScale)),
        "GenMcdViewport: structure mismatch\n");

    memcpy(&mcdVP.xScale, &gengc->gc.state.viewport.xScale,
           sizeof(MCDVIEWPORT));

    (gpMcdTable->pMCDSetViewport)(&gengc->pMcdState->McdContext,
                                  gengc->pMcdState->McdCmdBatch.pv, &mcdVP);
}

/******************************Public*Routine******************************\
* GenMcdScissor
*
* Set the scissor rectangle from the OpenGL state.
*
* History:
*  06-Mar-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static void FASTCALL vGetScissor(__GLGENcontext *gengc, RECTL *prcl)
{
    prcl->left  = gengc->gc.state.scissor.scissorX;
    prcl->right = gengc->gc.state.scissor.scissorX + gengc->gc.state.scissor.scissorWidth;

    if (gengc->gc.constants.yInverted)
    {
        prcl->bottom = gengc->gc.constants.height -
                       gengc->gc.state.scissor.scissorY;
        prcl->top    = gengc->gc.constants.height -
                       (gengc->gc.state.scissor.scissorY + gengc->gc.state.scissor.scissorHeight);
    }
    else
    {
        prcl->top    = gengc->gc.state.scissor.scissorY;
        prcl->bottom = gengc->gc.state.scissor.scissorY + gengc->gc.state.scissor.scissorHeight;
    }
}

void FASTCALL GenMcdScissor(__GLGENcontext *gengc)
{
    BOOL bEnabled;
    RECTL rcl;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdScissor: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdScissor: mcd32.dll not initialized\n");

    vGetScissor(gengc, &rcl);

    bEnabled = (gengc->gc.state.enables.general & __GL_SCISSOR_TEST_ENABLE)
               ? TRUE : FALSE;

    (gpMcdTable->pMCDSetScissorRect)(&gengc->pMcdState->McdContext, &rcl,
                                     bEnabled);
}

/******************************Public*Routine******************************\
* GenMcdUpdateScissorState
*
* Update MCD scissor state from the OpenGL state.
*
* This call only adds a state structure to the current state command.
* It is assumed that the caller has already called MCDBeginState and
* will call MCDFlushState.
*
* This is similar to but not quite the same as GenMcdScissor.  The
* GenMcdScissor only sets the scissor rect in the MCDSRV32.DLL to
* compute the scissored clip list it maintains.  This call is used
* to update the scissor rectangle state in the (MCD) display driver.
*
* History:
*  27-May-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL GenMcdUpdateScissorState(__GLGENcontext *gengc)
{
    __GLcontext *gc = &gengc->gc;
    GENMCDSTATE *pMcdState = gengc->pMcdState;
    RECTL rcl;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdUpdateScissorState: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdUpdateScissorState: mcd32.dll not initialized\n");

    //
    // Get the scissor rect.
    //

    vGetScissor(gengc, &rcl);

    //
    // Add MCDPIXELSTATE to the state cmd.
    //

    (gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                     MCD_SCISSOR_RECT_STATE,
                                     &rcl,
                                     sizeof(rcl));
}

/******************************Public*Routine******************************\
* GenMcdUpdateTexEnvState
*
* Update MCD texture environment state from the OpenGL state.
*
* This call only adds a state structure to the current state command.
* It is assumed that the caller has already called MCDBeginState and
* will call MCDFlushState.
*
* History:
*  21-Oct-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL GenMcdUpdateTexEnvState(__GLGENcontext *gengc)
{
    __GLcontext *gc = &gengc->gc;
    GENMCDSTATE *pMcdState = gengc->pMcdState;
    MCDTEXENVSTATE McdTexEnvState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdUpdateTexEnvState: "
                                   "null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdUpdateTexEnvState: "
                             "mcd32.dll not initialized\n");

    //
    // The texture environment array should have been initialized in
    // __glEarlyInitTextureState, but it does not have an error return
    // so it is possible that the array is NULL.
    //

    if (!gengc->gc.state.texture.env)
    {
        WARNING("GenMcdUpdateTexEnvState: null texture environment\n");
        return;
    }

    //
    // There is only one texture environment per-context.
    //
    // If multiple textures are added to a future version of OpenGL,
    // then we can define a new state structure for each new texture.
    // Or we can add a separate MCDTEXENVSTATE structure to the state
    // batch for each supported texture environment.  The first structure
    // is for the first environment, the second structure is for the
    // second environment, etc.  The driver can ignore any structures
    // over the number of texture environments it supports.  Of course,
    // these are just suggestions.  Depending on how multiple textures
    // are spec'd, we might have to do something totally different.
    //

    McdTexEnvState.texEnvMode = gengc->gc.state.texture.env[0].mode;
    *((__GLcolor *) &McdTexEnvState.texEnvColor) = gengc->gc.state.texture.env[0].color;

    //
    // Add MCDPIXELSTATE to the state cmd.
    //

    (gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                     MCD_TEXENV_STATE,
                                     &McdTexEnvState,
                                     sizeof(McdTexEnvState));
}

/******************************Public*Routine******************************\
* GenMcdDrawPrim
*
* Draw the primitives in the POLYARRAY/POLYDATA array pointed to by pa.
* The primitives are chained together as a linked list terminated by a
* NULL.  The return value is a pointer to the first unhandled primitive
* (NULL if the entire chain is successfully processed).
*
* Returns:
*   NULL if entire batch is processed; otherwise, return value is a pointer
*   to the unhandled portion of the chain.
*
* History:
*  09-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

POLYARRAY * FASTCALL GenMcdDrawPrim(__GLGENcontext *gengc, POLYARRAY *pa)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;
    int levels;
    LPDIRECTDRAWSURFACE *pdds;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdDrawPrim: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdDrawPrim: mcd32.dll not initialized\n");

#if DBG
    {
        LONG lOffset;

        lOffset = (LONG) ((BYTE *) pa - (BYTE *) pMcdState->pMcdPrimBatch->pv);

        ASSERTOPENGL(
            (lOffset >= 0) &&
            (lOffset < (LONG) pMcdState->pMcdPrimBatch->size),
            "GenMcdDrawPrim: pa not in shared mem window\n");
    }
#endif

    //
    // Before calling MCD to draw, flush state.
    //

    vFlushDirtyState(gengc);

#ifdef AUTOMATIC_SURF_LOCK
    levels = gengc->gc.texture.ddtex.levels;
    if (levels > 0 &&
        gengc->gc.texture.ddtex.texobj.loadKey != 0)
    {
        pdds = gengc->gc.texture.ddtex.pdds;
    }
    else
#endif
    {
        levels = 0;
        pdds = NULL;
    }
    
    return (POLYARRAY *)
           (gpMcdTable->pMCDProcessBatch)(&pMcdState->McdContext,
                                          pMcdState->pMcdPrimBatch->pv,
                                          pMcdState->pMcdPrimBatch->size,
                                          (PVOID) pa,
                                          levels, pdds);
}

/******************************Public*Routine******************************\
* GenMcdSwapBatch
*
* If the MCD driver uses DMA, then as part of context creation TWO vertex
* buffers we allocated so that we could ping-pong or double buffer between
* the two buffers (i.e., while the MCD driver is busy processing the
* data in one vertex buffer, OpenGL can start filling the other vertex
* buffer).
*
* This function switches the MCD state and OpenGL context to the other
* buffer.  If the new buffer is still being processed by the MCD driver,
* we will periodically poll the status of the buffer until it becomes
* available.
*
* History:
*  08-Mar-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL GenMcdSwapBatch(__GLGENcontext *gengc)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;
    GENMCDBUF *pNewBuf;
    ULONG ulMemStatus;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdSwapBatch: null pMcdState\n");

    ASSERTOPENGL(McdDriverInfo.mcdDriverInfo.drvMemFlags & MCDRV_MEM_DMA,
                 "GenMcdSwapBatch: error -- not using DMA\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdSwapBatch: mcd32.dll not initialized\n");

    //
    // Determine which of McdBuf1 and McdBuf2 is the current buffer and
    // which is the new buffer.
    //

    if (pMcdState->pMcdPrimBatch == &pMcdState->McdBuf1)
        pNewBuf = &pMcdState->McdBuf2;
    else
        pNewBuf = &pMcdState->McdBuf1;

    //
    // Poll memory status of the new buffer until it is available.
    //

    do
    {
        ulMemStatus = (gpMcdTable->pMCDQueryMemStatus)(pNewBuf->pv);

        //
        // If status of the new buffer is MCD_MEM_READY, set it as the
        // current vertex buffer (both in the pMcdState and in the gengc.
        //

        if (ulMemStatus == MCD_MEM_READY)
        {
            pMcdState->pMcdPrimBatch = pNewBuf;
            gengc->gc.vertex.pdBuf = (POLYDATA *) pMcdState->pMcdPrimBatch->pv;
        }
        else if (ulMemStatus == MCD_MEM_INVALID)
        {
            //
            // This should not be possible, but to be robust let's handle
            // the case in which the new buffer has somehow become invalid
            // (in other words, "Beware of bad drivers!").
            //
            // We handle this by abandoning double buffering and simply
            // wait for the current buffer to become available again.
            // Not very efficient, but at least we recover gracefully.
            //

            RIP("GenMcdSwapBatch: vertex buffer invalid!\n");

            do
            {
                ulMemStatus = (gpMcdTable->pMCDQueryMemStatus)(pMcdState->pMcdPrimBatch->pv);

                //
                // The current buffer definitely should not become invalid!
                //

                ASSERTOPENGL(ulMemStatus != MCD_MEM_INVALID,
                             "GenMcdSwapBatch: current vertex buffer invalid!\n");

            } while (ulMemStatus == MCD_MEM_BUSY);
        }

    } while (ulMemStatus == MCD_MEM_BUSY);
}

/******************************Public*Routine******************************\
* GenMcdSwapBuffers
*
* Invoke the MCD swap buffers command.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  19-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdSwapBuffers(HDC hdc, GLGENwindow *pwnd)
{
    BOOL bRet = FALSE;
    MCDCONTEXT McdContextTmp;

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdSwapBuffers: mcd32.dll not initialized\n");

    McdContextTmp.hdc = hdc;
    McdContextTmp.hMCDContext = NULL;
    McdContextTmp.dwMcdWindow = pwnd->dwMcdWindow;

    bRet = (gpMcdTable->pMCDSwap)(&McdContextTmp, 0);

    return bRet;
}

/******************************Public*Routine******************************\
* GenMcdResizeBuffers
*
* Resize the buffers (front, back, and depth) associated with the MCD
* context bound to the specified GL context.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* Note:  If this functions fails, then MCD drawing for the MCD context
*        will fail.  Other MCD contexts are unaffected.
*
* History:
*  20-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdResizeBuffers(__GLGENcontext *gengc)
{
    BOOL bRet = FALSE;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdResizeBuffers: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdResizeBuffers: mcd32.dll not initialized\n");

    bRet = (gpMcdTable->pMCDAllocBuffers)(&gengc->pMcdState->McdContext,
                                          &gengc->pwndLocked->rclClient);

    return bRet;
}

/******************************Public*Routine******************************\
* GenMcdUpdateBufferInfo
*
* This function must be called on every screen access start to synchronize
* the GENMCDSURFACE to the current framebuffer pointer and stride.
*
* If we have direct access to any of the MCD buffers (front, back, depth),
* then setup pointers to the buffer and set flags indicating that they are
* accessible.
*
* Otherwise, mark them as inaccessible (which will force us to use
* MCDReadSpan or MCDWriteSpan to access the buffers).
*
* History:
*  20-Feb-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdUpdateBufferInfo(__GLGENcontext *gengc)
{
    BOOL bRet = FALSE;
    __GLcontext *gc = (__GLcontext *) gengc;
    __GLGENbuffers *buffers = gengc->pwndLocked->buffers;
    GENMCDSTATE *pMcdState = gengc->pMcdState;
    MCDRECTBUFFERS McdBuffers;
    BOOL bForceValidate = FALSE;
    
    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdUpdateBufferInfo: mcd32.dll not initialized\n");

    //
    // Does the flag in pMcdState indicate that a pick should be forced?
    // This is required, for example, for the first batch after an MCD
    // context has been made current.
    //

    if (pMcdState->mcdFlags & MCD_STATE_FORCEPICK)
    {
        bForceValidate = TRUE;
        pMcdState->mcdFlags &= ~MCD_STATE_FORCEPICK;
    }

    //
    // This is the currently active context.  Set the pointer in the
    // shared surface info.
    //

    buffers->pMcdState = pMcdState;

#ifdef MCD95
    //
    // Set the request flags.
    //

    McdBuffers.mcdRequestFlags = MCDBUF_REQ_MCDBUFINFO;
#endif

    if (gengc->dwCurrentFlags & GLSURF_DIRECTDRAW)
    {
        // Nothing to do
    }
    else if ((gengc->fsLocks & LOCKFLAG_FRONT_BUFFER)
        && (gpMcdTable->pMCDGetBuffers)(&pMcdState->McdContext, &McdBuffers))
    {
        BYTE *pbVideoBase;

        // If we're in this code block it shouldn't be possible
        // to have the DD_DEPTH lock since that should only
        // occur if the current surface is a DDraw surface.
        ASSERTOPENGL((gengc->fsLocks & LOCKFLAG_DD_DEPTH) == 0,
                     "DD_DEPTH lock unexpected\n");
        
#ifdef MCD95
        pbVideoBase = (BYTE *) McdBuffers.pvFrameBuf;
#else
        //
        // In order to compute the buffer pointers from the offsets returned by
        // MCDGetBuffers, we need to know the frame buffer pointer.
        // This implies direct screen access must be enabled.
        //

        if (gengc->pgddsFront != NULL)
        {
            pbVideoBase = (BYTE *)GLSCREENINFO->gdds.ddsd.lpSurface;
        }
#endif
    
        //
        // Front buffer.
        //

        if (McdBuffers.mcdFrontBuf.bufFlags & MCDBUF_ENABLED)
        {
            gc->frontBuffer.buf.xOrigin = gengc->pwndLocked->rclClient.left;
            gc->frontBuffer.buf.yOrigin = gengc->pwndLocked->rclClient.top;

            //
            // Since clipping is in screen coordinates, offset buffer pointer
            // by the buffer origin.
            //
            gc->frontBuffer.buf.base =
                (PVOID) (pbVideoBase + McdBuffers.mcdFrontBuf.bufOffset
                         - (McdBuffers.mcdFrontBuf.bufStride * gc->frontBuffer.buf.yOrigin)
                         - (gc->frontBuffer.buf.xOrigin * ((gengc->gsurf.pfd.cColorBits + 7) >> 3)));
            gc->frontBuffer.buf.outerWidth = McdBuffers.mcdFrontBuf.bufStride;
            gc->frontBuffer.buf.flags |= DIB_FORMAT;
        }
        else
        {
            gc->frontBuffer.buf.xOrigin = 0;
            gc->frontBuffer.buf.yOrigin = 0;

            gc->frontBuffer.buf.base = NULL;
            gc->frontBuffer.buf.flags &= ~DIB_FORMAT;
        }

        //
        // Back buffer.
        //

        if (McdBuffers.mcdBackBuf.bufFlags & MCDBUF_ENABLED)
        {
            gc->backBuffer.buf.xOrigin = gengc->pwndLocked->rclClient.left;
            gc->backBuffer.buf.yOrigin = gengc->pwndLocked->rclClient.top;

            //
            // Since clipping is in screen coordinates, offset buffer pointer
            // by the buffer origin.
            //
            gc->backBuffer.buf.base =
                (PVOID) (pbVideoBase + McdBuffers.mcdBackBuf.bufOffset
                         - (McdBuffers.mcdBackBuf.bufStride * gc->backBuffer.buf.yOrigin)
                         - (gc->backBuffer.buf.xOrigin * ((gengc->gsurf.pfd.cColorBits + 7) >> 3)));
            gc->backBuffer.buf.outerWidth = McdBuffers.mcdBackBuf.bufStride;
            gc->backBuffer.buf.flags |= DIB_FORMAT;
        }
        else
        {
            gc->backBuffer.buf.xOrigin = 0;
            gc->backBuffer.buf.yOrigin = 0;

            gc->backBuffer.buf.base = (PVOID) NULL;
            gc->backBuffer.buf.flags &= ~DIB_FORMAT;
        }
        if (McdBuffers.mcdBackBuf.bufFlags & MCDBUF_NOCLIP)
            gc->backBuffer.buf.flags |= NO_CLIP;
        else
            gc->backBuffer.buf.flags &= ~NO_CLIP;

        UpdateSharedBuffer(&buffers->backBuffer , &gc->backBuffer.buf);

        //
        // Depth buffer.
        //

        //!!!mcd -- No depth buffer clipping code, so if we have to clip
        //!!!mcd    depth buffer we need to revert back to span code.

        if ((McdBuffers.mcdDepthBuf.bufFlags & MCDBUF_ENABLED) &&
            (McdBuffers.mcdDepthBuf.bufFlags & MCDBUF_NOCLIP))
        {
            gc->depthBuffer.buf.xOrigin = 0;
            gc->depthBuffer.buf.yOrigin = 0;

            gc->depthBuffer.buf.base =
                (PVOID) (pbVideoBase + McdBuffers.mcdDepthBuf.bufOffset);

            //
            // Depth code expects stride as a pixel count, not a byte count.
            //

            gc->depthBuffer.buf.outerWidth =
                McdBuffers.mcdDepthBuf.bufStride /
                ((pMcdState->McdPixelFmt.cDepthBufferBits + 7) >> 3);

            //!!!mcd dbug -- span code sets element size to 32bit.  should we
            //!!!mcd dbug    set according to cDepthBits when direct access is used?!?
        }
        else
        {
            //
            // If we ended up here because clipping is required, buffer
            // could still be marked as accessible.  We want the state change
            // detection code to treat this as an inaccessible buffer case,
            // so force the flags to 0.
            //

            McdBuffers.mcdDepthBuf.bufFlags = 0;

            gc->depthBuffer.buf.xOrigin = 0;
            gc->depthBuffer.buf.yOrigin = 0;

            gc->depthBuffer.buf.base = (PVOID) pMcdState->pDepthSpan;

            //!!!mcd dbug -- always force pick procs if no zbuf access
            //bForceValidate = TRUE;
        }

        UpdateSharedBuffer(&buffers->depthBuffer , &gc->depthBuffer.buf);

        bRet = TRUE;
    }
    else
    {
        //
        // MCDGetBuffers normally shouldn't fail.  However, let's gracefully
        // handle this odd case by falling back to the span buffer code.
        //

        gc->frontBuffer.buf.xOrigin = 0;
        gc->frontBuffer.buf.yOrigin = 0;
        gc->frontBuffer.buf.base = (PVOID) NULL;
        gc->frontBuffer.buf.flags &= ~DIB_FORMAT;

        gc->backBuffer.buf.xOrigin = 0;
        gc->backBuffer.buf.yOrigin = 0;
        gc->backBuffer.buf.base = (PVOID) NULL;
        gc->backBuffer.buf.flags &= ~DIB_FORMAT;

        gc->depthBuffer.buf.xOrigin = 0;
        gc->depthBuffer.buf.yOrigin = 0;
        gc->depthBuffer.buf.base = (PVOID) pMcdState->pDepthSpan;

        //
        // Extra paranoid code.  Zero out structure in case MCD driver
        // partially initialized McdBuffers.
        //

        memset(&McdBuffers, 0, sizeof(McdBuffers));
    }

    //
    // If state changed (i.e., access to any of the buffers gained or lost),
    // need to force pick procs.
    //

    if (   (pMcdState->McdBuffers.mcdFrontBuf.bufFlags !=
            McdBuffers.mcdFrontBuf.bufFlags)
        || (pMcdState->McdBuffers.mcdBackBuf.bufFlags !=
            McdBuffers.mcdBackBuf.bufFlags)
        || (pMcdState->McdBuffers.mcdDepthBuf.bufFlags !=
            McdBuffers.mcdDepthBuf.bufFlags) )
    {
        bForceValidate = TRUE;
    }

    //
    // Save a copy of current MCD buffers.
    //

    pMcdState->McdBuffers = McdBuffers;

    //
    // If needed, do pick procs.
    //

    if (bForceValidate)
    {
        gc->dirtyMask |= __GL_DIRTY_ALL;
        (*gc->procs.validate)(gc);
    }

    return bRet;
}

/******************************Public*Routine******************************\
* GenMcdSynchronize
*
* This function synchronizes to the MCD driver; i.e., it waits until the
* hardware is ready for direct access to the framebuffer and/or more
* hardware-accelerated operations.  This is needed because some (most?) 2D
* and 3D accelerator chips do not support simultaneous hardware operations
* and framebuffer access.
*
* This function must be called by any GL API that potentially touches any
* of the MCD buffers (front, back, or depth) without giving MCD first crack.
* For example, clears always go to MCDClear before the software clear is
* given a chance; therefore, glClear does not need to call GenMcdSychronize.
* On the other hand, glReadPixels does not have an equivalent MCD function
* so it immediately goes to the software implementation; therefore,
* glReadPixels does need to call GenMcdSynchronize.
*
* History:
*  20-Mar-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL GenMcdSynchronize(__GLGENcontext *gengc)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdSynchronize: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdSynchronize: mcd32.dll not initialized\n");

    //
    // Note: MCDSync returns a BOOL indicating success or failure.  This
    // is actually for future expansion.  Currently, the function is defined
    // to WAIT until the hardware is ready and then return success.  The
    // specification of the function behavior allows us to ignore the return
    // value for now.
    //
    // In the future, we may change this to a query function.  In which case
    // we should call this in a while loop.  I'd rather not do this at this
    // time though, as it leaves us vulnerable to an infinitely loop problem
    // if we have a bad MCD driver.
    //

    (gpMcdTable->pMCDSync)(&pMcdState->McdContext);
}


/******************************Public*Routine******************************\
* GenMcdConvertContext
*
* Convert the context from an MCD-based one to a generic one.
*
* This requires creating the buffers, etc. that are required for a generic
* context and releasing the MCD resources.
*
* IMPORTANT NOTE:
*   Because we modify the buffers struct, the WNDOBJ semaphore
*   should be held while calling this function.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* Side effects:
*   If successful, the MCD surface is freed and the context will use
*   only generic code.  However, the gengc->_pMcdState will still point to
*   a valid (but quiescent as gengc->pMcdState is disconnected) GENMCDSTATE
*   structure that needs to be deleted when the GLGENcontext is deleted.
*
*   If it fails, then the MCD resources are left allocated meaning that
*   we can try to realloc the MCD buffers later.  However, for the current
*   batch, drawing may not be possible (presumedly we were called because
*   GenMcdResizeBuffers failed).
*
* History:
*  18-Apr-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdConvertContext(__GLGENcontext *gengc,
                                   __GLGENbuffers *buffers)
{
    BOOL bRet = FALSE;
    __GLcontext *gc = &gengc->gc;
    GENMCDSTATE   *pMcdStateSAVE;
    GENMCDSTATE   *_pMcdStateSAVE;
    GENMCDSTATE   *buffers_pMcdStateSAVE;
    GENMCDSURFACE *pMcdSurfSAVE;
    BOOL bConvertContext, bConvertSurface;

    ASSERTOPENGL(gengc->_pMcdState,
                 "GenMcdConvertContext: not an MCD context\n");

    //
    // Do not support conversion if not compatible with generic code.
    //

    if (!(gengc->flags & GENGC_GENERIC_COMPATIBLE_FORMAT))
        return FALSE;

    //
    // Determine if context needs conversion.  Do not need to create
    // scanline buffers if already converted.
    //

    if (gengc->flags & GLGEN_MCD_CONVERTED_TO_GENERIC)
        bConvertContext = FALSE;
    else
        bConvertContext = TRUE;

    //
    // Determine if surface needs conversion.  Do not need to create
    // the generic shared buffers or destroy MCD surface if already
    // converted.
    //

    if (buffers->flags & GLGENBUF_MCD_LOST)
        bConvertSurface = FALSE;
    else
        bConvertSurface = TRUE;

    //
    // Early out if neither context or surface needs conversion.
    //

    //!!!SP1 -- should be able to early out, but risky for NT4.0
    //if (!bConvertContext && !bConvertSurface)
    //{
    //    return TRUE;
    //}

    //
    // Save current MCD context and surface info.
    //
    // Note that we grab the surface info from the buffers struct.
    // The copy in gengc->pMcdState->pMcdSurf is potentially stale
    // (i.e., may point to a surface already deleted by an earlier
    // call to GenMcdConvertContext for a context that shares the
    // same buffers struct).
    //
    // This allows us to use pMcdSurfSAVE as a flag.  If it is
    // NULL, we know that the MCD surface has already been deleted.
    //

    pMcdSurfSAVE          = buffers->pMcdSurf;
    buffers_pMcdStateSAVE = buffers->pMcdState;

    pMcdStateSAVE  = gengc->pMcdState;
    _pMcdStateSAVE = gengc->_pMcdState;

    //
    // First, remove the MCD information from the context and buffers structs.
    //

    buffers->pMcdSurf  = NULL;
    buffers->pMcdState = NULL;

    gengc->pMcdState  = NULL;
    gengc->_pMcdState = NULL;

    //
    // Create required buffers; initialize buffer info structs.
    //

    if (bConvertContext)
    {
        if (!wglCreateScanlineBuffers(gengc))
        {
            WARNING("GenMcdConvertContext: wglCreateScanlineBuffers failed\n");
            goto GenMcdConvertContext_exit;
        }
        wglInitializeColorBuffers(gengc);
        wglInitializeDepthBuffer(gengc);
        wglInitializePixelCopyFuncs(gengc);
    }

    //
    // *******************************************************************
    // None of the subsequent operations have failure cases, so at this
    // point success is guaranteed.  We no longer need to worry about
    // saving current values so that they can be restored in the failure
    // case.
    //
    // If code is added that may fail, it must be added before this point.
    // Otherwise, it is acceptable to add the code afterwards.
    // *******************************************************************
    //

    bRet = TRUE;

    //
    // Invalidate the context's depth buffer.
    //

    if (bConvertContext)
    {
        gc->modes.haveDepthBuffer = GL_FALSE;
        gc->depthBuffer.buf.base = 0;
        gc->depthBuffer.buf.size = 0;
        gc->depthBuffer.buf.outerWidth = 0;
    }

    //
    // Generic backbuffer doesn't care about the WNDOBJ, so connect the
    // backbuffer to the dummy backbuffer WNDOBJ rather than the real one.
    //

    if (gc->modes.doubleBufferMode)
    {
        gc->backBuffer.bitmap = &buffers->backBitmap;
        buffers->backBitmap.pwnd = &buffers->backBitmap.wnd;
    }

    //
    // Generic back buffers have origin of (0,0).
    //

    gc->backBuffer.buf.xOrigin = 0;
    gc->backBuffer.buf.yOrigin = 0;
    buffers->backBuffer.xOrigin = 0;
    buffers->backBuffer.yOrigin = 0;

GenMcdConvertContext_exit:

    if (bRet)
    {
        //
        // Delete MCD surface.
        //

        if (bConvertSurface && pMcdSurfSAVE)
        {
            GenMcdDeleteSurface(pMcdSurfSAVE);

            //
            // Invalidate the shared depth buffer.
            // Set depth resize routine to the generic version.
            //

            buffers->depthBuffer.base = 0;
            buffers->depthBuffer.size = 0;
            buffers->depthBuffer.outerWidth = 0;
            buffers->resizeDepth = ResizeAncillaryBuffer;

            //
            // Since we deleted MCD surface, we get to create the generic
            // buffers to replace it.
            //

            wglResizeBuffers(gengc, buffers->width, buffers->height);
        }
        else
        {
            //
            // Didn't need to create generic buffers, but we do need to
            // update the buffer info in the context.
            //

            wglUpdateBuffers(gengc, buffers);
        }

        //
        // Reconnect _pMcdState; it and the MCD context resources
        // will be deleted when the GLGENcontext is deleted
        // (but note that pMcdState remains NULL!).
        //
        // We need to keep it around because we are going to continue
        // to use the MCD allocated POLYARRAY buffer.
        //

        gengc->_pMcdState = _pMcdStateSAVE;
        gengc->_pMcdState->pMcdSurf   = (GENMCDSURFACE *) NULL;
        gengc->_pMcdState->pDepthSpan = (__GLzValue *) NULL;

        //
        // Mark buffers struct so that other contexts will know that the
        // MCD resources are gone.
        //

        buffers->flags |= GLGENBUF_MCD_LOST;

        //
        // Mark context as converted so we don't do it again.
        //

        gengc->flags |= GLGEN_MCD_CONVERTED_TO_GENERIC;
    }
    else
    {
        //
        // Delete generic resources if neccessary.
        //

        wglDeleteScanlineBuffers(gengc);

        //
        // Restore the MCD information.
        //

        buffers->pMcdSurf  = pMcdSurfSAVE;
        buffers->pMcdState = buffers_pMcdStateSAVE;

        gengc->pMcdState  = pMcdStateSAVE;
        gengc->_pMcdState = _pMcdStateSAVE;

        //
        // Resetting the MCD information requires that we
        // reinitialization the color, depth, and pixel copy
        // funcs.
        //

        wglInitializeColorBuffers(gengc);
        wglInitializeDepthBuffer(gengc);
        wglInitializePixelCopyFuncs(gengc);

        if (gengc->pMcdState && gengc->pMcdState->pDepthSpan)
        {
            gc->depthBuffer.buf.base = gengc->pMcdState->pDepthSpan;
            buffers->depthBuffer.base = gengc->pMcdState->pDepthSpan;
            buffers->resizeDepth = ResizeUnownedDepthBuffer;
        }

        __glSetErrorEarly(gc, GL_OUT_OF_MEMORY);
    }

    //
    // Success or failure, we've messed around with enough data to
    // require revalidation.
    //

    (*gc->procs.applyViewport)(gc);
    //!!!SP1 -- GL_INVALIDATE (which only sets the __GL_DIRTY_GENERIC bit)
    //!!!SP1    should suffice now that __glGenericPickAllProcs has been
    //!!!SP1    modified to repick depth procs if GL_DIRTY_GENERIC is set.
    //!!!SP1    However, we are too close to ship to get good stress coverage,
    //!!!SP1    so leave it as is until after NT4.0 ships.
    //__GL_INVALIDATE(gc);
    gc->dirtyMask |= __GL_DIRTY_ALL;
    gc->validateMask |= (__GL_VALIDATE_STENCIL_FUNC |
                         __GL_VALIDATE_STENCIL_OP);
    (*gc->procs.validate)(gc);

    return bRet;
}


/******************************Public*Routine******************************\
* GenMcdCreateTexture
*
* Invoke the MCD texture creation command.
*
* Returns:
*   A non-NULL MCD handle if successful, NULL otherwise.
*
* History:
*  29-April-1996 -by- Otto Berkes [ottob]
* Wrote it.
\**************************************************************************/

MCDHANDLE FASTCALL GenMcdCreateTexture(__GLGENcontext *gengc, __GLtexture *tex,
                                       ULONG flags)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdCreateTexture: null pMcdState\n");
    ASSERTOPENGL(tex, "GenMcdCreateTexture: null texture pointer\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdCreateTexture: mcd32.dll not initialized\n");

    if ((flags & MCDTEXTURE_DIRECTDRAW_SURFACES) &&
        !SUPPORTS_DIRECT())
    {
        // Don't pass DirectDraw texture surfaces to the driver if it
        // doesn't support them.
        return 0;
    }
    
    return (gpMcdTable->pMCDCreateTexture)(&pMcdState->McdContext,
                                          (MCDTEXTUREDATA *)&tex->params,
                                          flags, NULL);
}


/******************************Public*Routine******************************\
* GenMcdDeleteTexture
*
* Invoke the MCD texture deletion command.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  29-April-1996 -by- Otto Berkes [ottob]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdDeleteTexture(__GLGENcontext *gengc, MCDHANDLE texHandle)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdDeleteTexture: null pMcdState\n");
    ASSERTOPENGL(texHandle, "GenMcdDeleteTexture: null texture handle\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdDeleteTexture: mcd32.dll not initialized\n");

    return (BOOL)(gpMcdTable->pMCDDeleteTexture)(&pMcdState->McdContext,
                                                 (MCDHANDLE)texHandle);
}


/******************************Public*Routine******************************\
* GenMcdUpdateSubTexture
*
* Invoke the MCD subtexture update command.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  29-April-1996 -by- Otto Berkes [ottob]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdUpdateSubTexture(__GLGENcontext *gengc, __GLtexture *tex,
                                     MCDHANDLE texHandle, GLint lod, 
                                     GLint xoffset, GLint yoffset, 
                                     GLsizei w, GLsizei h)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;
    RECTL rect;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdUpdateSubTexture: null pMcdState\n");

    ASSERTOPENGL(texHandle, "GenMcdUpdateSubTexture: null texture handle\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdUpdateSubTexture: mcd32.dll not initialized\n");

    rect.left = xoffset;
    rect.top = yoffset;
    rect.right = xoffset + w;
    rect.bottom = yoffset + h;

    return (BOOL)(gpMcdTable->pMCDUpdateSubTexture)(&pMcdState->McdContext,
                (MCDTEXTUREDATA *)&tex->params, (MCDHANDLE)texHandle,
                (ULONG)lod, &rect);
}


/******************************Public*Routine******************************\
* GenMcdUpdateTexturePalette
*
* Invoke the MCD texture palette update command.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  29-April-1996 -by- Otto Berkes [ottob]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdUpdateTexturePalette(__GLGENcontext *gengc, __GLtexture *tex,
                                         MCDHANDLE texHandle, GLsizei start,
                                         GLsizei count)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdUpdateTexturePalette: null pMcdState\n");
    ASSERTOPENGL(texHandle, "GenMcdUpdateTexturePalette: null texture handle\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdUpdateTexturePalette: mcd32.dll not initialized\n");

    return (BOOL)(gpMcdTable->pMCDUpdateTexturePalette)(&pMcdState->McdContext,
                (MCDTEXTUREDATA *)&tex->params, (MCDHANDLE)texHandle,
                (ULONG)start, (ULONG)count);
}


/******************************Public*Routine******************************\
* GenMcdUpdateTexturePriority
*
* Invoke the MCD texture priority command.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  29-April-1996 -by- Otto Berkes [ottob]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdUpdateTexturePriority(__GLGENcontext *gengc, __GLtexture *tex,
                                          MCDHANDLE texHandle)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdUpdateTexturePriority: null pMcdState\n");
    ASSERTOPENGL(texHandle, "GenMcdUpdateTexturePriority: null texture handle\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdUpdateTexturePriority: mcd32.dll not initialized\n");

    return (BOOL)(gpMcdTable->pMCDUpdateTexturePriority)(&pMcdState->McdContext,
                (MCDTEXTUREDATA *)&tex->params, (MCDHANDLE)texHandle);
}


/******************************Public*Routine******************************\
* GenMcdTextureStatus
*
* Invoke the MCD texture status command.
*
* Returns:
*   The status for the specified texture.
*
* History:
*  29-April-1996 -by- Otto Berkes [ottob]
* Wrote it.
\**************************************************************************/

DWORD FASTCALL GenMcdTextureStatus(__GLGENcontext *gengc, MCDHANDLE texHandle)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdTextureStatus: null pMcdState\n");
    ASSERTOPENGL(texHandle, "GenMcdTextureStatus: null texture handle\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdTextureStatus: mcd32.dll not initialized\n");

    return (DWORD)(gpMcdTable->pMCDTextureStatus)(&pMcdState->McdContext,
                                                  (MCDHANDLE)texHandle);
}


/******************************Public*Routine******************************\
* GenMcdUpdateTextureState
*
* Invoke the MCD texture state update command.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  29-April-1996 -by- Otto Berkes [ottob]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdUpdateTextureState(__GLGENcontext *gengc, __GLtexture *tex,
                                       MCDHANDLE texHandle)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdUpdateTextureState: null pMcdState\n");
    ASSERTOPENGL(texHandle, "GenMcdUpdateTextureState: null texture handle\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdTextureStatus: mcd32.dll not initialized\n");

    return (BOOL)(gpMcdTable->pMCDUpdateTextureState)(&pMcdState->McdContext,
                (MCDTEXTUREDATA *)&tex->params, (MCDHANDLE)texHandle);
}


/******************************Public*Routine******************************\
* GenMcdTextureKey
*
* Invoke the MCD texture key command.  Note that this call does not go to
* the display driver, but gets handled in the mcd server.
*
* Returns:
*   The driver-owned key for the specified texture.
*
* History:
*  29-April-1996 -by- Otto Berkes [ottob]
* Wrote it.
\**************************************************************************/

DWORD FASTCALL GenMcdTextureKey(__GLGENcontext *gengc, MCDHANDLE texHandle)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdTextureKey: null pMcdState\n");
    ASSERTOPENGL(texHandle, "GenMcdTextureKey: null texture handle\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdTextureKey: mcd32.dll not initialized\n");

    return (DWORD)(gpMcdTable->pMCDTextureKey)(&pMcdState->McdContext,
                                               (MCDHANDLE)texHandle);
}

/******************************Public*Routine******************************\
* GenMcdDescribeLayerPlane
*
* Call the MCD driver to return information about the specified layer plane.
*
* History:
*  16-May-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdDescribeLayerPlane(HDC hdc, int iPixelFormat,
                                       int iLayerPlane, UINT nBytes,
                                       LPLAYERPLANEDESCRIPTOR plpd)
{
    BOOL bRet = FALSE;

    //
    // Cannot assume that MCD is intialized.
    //

    if (gpMcdTable || bInitMcd(hdc))
    {
        //
        // Caller (wglDescribeLayerPlane in client\layer.c) validates
        // size.
        //

        ASSERTOPENGL(nBytes >= sizeof(LAYERPLANEDESCRIPTOR),
                     "GenMcdDescribeLayerPlane: bad size\n");

        bRet = (gpMcdTable->pMCDDescribeLayerPlane)(hdc, iPixelFormat,
                                                    iLayerPlane, plpd);
    }

    return bRet;
}

/******************************Public*Routine******************************\
* GenMcdSetLayerPaletteEntries
*
* Set the logical palette for the specified layer plane.
*
* The logical palette is cached in the GLGENwindow structure and is flushed
* to the driver when GenMcdRealizeLayerPalette is called.
*
* History:
*  16-May-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int FASTCALL GenMcdSetLayerPaletteEntries(HDC hdc, int iLayerPlane,
                                          int iStart, int cEntries,
                                          CONST COLORREF *pcr)
{
    int iRet = 0;
    GLGENwindow *pwnd;
    GLWINDOWID gwid;

    if (!pcr)
        return iRet;

    //
    // Need to find the window that has the layer palettes.
    //

    WindowIdFromHdc(hdc, &gwid);
    pwnd = pwndGetFromID(&gwid);
    if (pwnd)
    {
        GLGENlayerInfo *plyri;

        ENTER_WINCRIT(pwnd);

        //
        // Get the layer plane information.
        //

        plyri = plyriGet(pwnd, hdc, iLayerPlane);
        if (plyri)
        {
            //
            // Set the palette information in the layer plane structure.
            //

            iRet = min(plyri->cPalEntries - iStart, cEntries);
            memcpy(&plyri->pPalEntries[iStart], pcr, iRet * sizeof(COLORREF));
        }

        pwndUnlock(pwnd, NULL);
    }

    return iRet;
}

/******************************Public*Routine******************************\
* GenMcdGetLayerPaletteEntries
*
* Get the logical palette from the specified layer plane.
*
* The logical palette is cached in the GLGENwindow structure and is flushed
* to the driver when GenMcdRealizeLayerPalette is called.
*
* History:
*  16-May-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int FASTCALL GenMcdGetLayerPaletteEntries(HDC hdc, int iLayerPlane,
                                          int iStart, int cEntries,
                                          COLORREF *pcr)
{
    int iRet = 0;
    GLGENwindow *pwnd;
    GLWINDOWID gwid;

    if (!pcr)
        return iRet;

    //
    // Need to find the window.
    //

    WindowIdFromHdc(hdc, &gwid);
    pwnd = pwndGetFromID(&gwid);
    if (pwnd)
    {
        GLGENlayerInfo *plyri;

        ENTER_WINCRIT(pwnd);

        //
        // Get the layer plane information.
        //

        plyri = plyriGet(pwnd, hdc, iLayerPlane);
        if (plyri)
        {
            //
            // Get the palette information from the layer plane structure.
            //

            iRet = min(plyri->cPalEntries - iStart, cEntries);
            memcpy(pcr, &plyri->pPalEntries[iStart], iRet * sizeof(COLORREF));
        }

        pwndUnlock(pwnd, NULL);
    }

    return iRet;
}

/******************************Public*Routine******************************\
* GenMcdRealizeLayerPalette
*
* Send the logical palette of the specified layer plane to the MCD driver.
* If the bRealize flag is TRUE, the palette is mapped into the physical
* palette of the specified layer plane.  Otherwise, this is a signal to the
* driver that the physical palette is no longer needed.
*
* History:
*  16-May-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int FASTCALL GenMcdRealizeLayerPalette(HDC hdc, int iLayerPlane,
                                        BOOL bRealize)
{
    int iRet = 0;
    GLWINDOWID gwid;

    //
    // Cannot assume that MCD is intialized.
    //

    if (gpMcdTable || bInitMcd(hdc))
    {
        GLGENwindow *pwnd;

        //
        // Need to find the window.
        //

        WindowIdFromHdc(hdc, &gwid);
        pwnd = pwndGetFromID(&gwid);
        if (pwnd)
        {
            GLGENlayerInfo *plyri;

            ENTER_WINCRIT(pwnd);

            //
            // Get the layer plane information.
            //

            plyri = plyriGet(pwnd, hdc, iLayerPlane);
            if (plyri)
            {
                //
                // Set the palette from the logical palette stored
                // in the layer plane structure.
                //

                iRet = (gpMcdTable->pMCDSetLayerPalette)
                            (hdc, iLayerPlane, bRealize,
                             plyri->cPalEntries,
                             &plyri->pPalEntries[0]);
            }

            pwndUnlock(pwnd, NULL);
        }
    }

    return iRet;
}

/******************************Public*Routine******************************\
* GenMcdSwapLayerBuffers
*
* Swap the individual layer planes specified in fuFlags.
*
* History:
*  16-May-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdSwapLayerBuffers(HDC hdc, UINT fuFlags)
{
    BOOL bRet = FALSE;
    GLGENwindow *pwnd;
    GLWINDOWID gwid;

    //
    // Need the window.
    //

    WindowIdFromHdc(hdc, &gwid);
    pwnd = pwndGetFromID(&gwid);
    if (pwnd)
    {
        MCDCONTEXT McdContextTmp;

        ENTER_WINCRIT(pwnd);

        //
        // From the window, we can get the buffers struct.
        //

        if (pwnd->buffers != NULL)
        {
            __GLGENbuffers *buffers = pwnd->buffers;

            //
            // Call MCDSwap if we can (MCD context is required).
            //

            if (buffers->pMcdSurf)
            {
                ASSERTOPENGL(gpMcdTable,
                             "GenMcdSwapLayerBuffers: "
                             "mcd32.dll not initialized\n");

                McdContextTmp.hdc = hdc;

                bRet = (gpMcdTable->pMCDSwap)(&McdContextTmp, fuFlags);
            }
        }

        //
        // Release the window.
        //

        pwndUnlock(pwnd, NULL);
    }

    return bRet;
}

/******************************Public*Routine******************************\
* GenMcdUpdatePixelState
*
* Update MCD pixel state from the OpenGL state.
*
* This call only adds a state structure to the current state command.
* It is assumed that the caller has already called MCDBeginState and
* will call MCDFlushState.
*
* Note: pixel maps (glPixelMap) are not updated by this function.  Because
* they are not used often, they are delayed but rather flushed to the driver
* immediately.
*
* History:
*  27-May-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void FASTCALL GenMcdUpdatePixelState(__GLGENcontext *gengc)
{
    __GLcontext *gc = &gengc->gc;
    GENMCDSTATE *pMcdState = gengc->pMcdState;
    MCDPIXELSTATE McdPixelState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdUpdatePixelState: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdUpdatePixelState: mcd32.dll not initialized\n");

    //
    // Compute MCD pixel state from the current OpenGL context state.
    //

    //
    // Pixel transfer modes.
    //
    // MCDPIXELTRANSFER and __GLpixelTransferMode structures are the same.
    //

    McdPixelState.pixelTransferModes
        = *((MCDPIXELTRANSFER *) &gengc->gc.state.pixel.transferMode);

    //
    // Pixel pack modes.
    //
    // MCDPIXELPACK and __GLpixelPackMode structures are the same.
    //

    McdPixelState.pixelPackModes
        = *((MCDPIXELPACK *) &gengc->gc.state.pixel.packModes);

    //
    // Pixel unpack modes.
    //
    // MCDPIXELUNPACK and __GLpixelUnpackMode structures are the same.
    //

    McdPixelState.pixelUnpackModes
        = *((MCDPIXELUNPACK *) &gengc->gc.state.pixel.unpackModes);

    //
    // Read buffer.
    //

    McdPixelState.readBuffer = gengc->gc.state.pixel.readBuffer;

    //
    // Current raster position.
    //

    McdPixelState.rasterPos = *((MCDCOORD *) &gengc->gc.state.current.rasterPos.window);

    //
    // Send MCDPIXELSTATE to the state cmd.
    //

    (gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                     MCD_PIXEL_STATE,
                                     &McdPixelState,
                                     sizeof(McdPixelState));
}

/******************************Public*Routine******************************\
* GenMcdUpdateFineState
*
* Update fine-grained MCD state from the OpenGL state.
*
* This call only adds state structures to the current state command.
* It is assumed that the caller has already called MCDBeginState and
* will call MCDFlushState.
*
* History:
*  13-Mar-1997 -by- Drew Bliss [drewb]
* Created.
\**************************************************************************/

void FASTCALL GenMcdUpdateFineState(__GLGENcontext *gengc)
{
    __GLcontext *gc = &gengc->gc;
    GENMCDSTATE *pMcdState = gengc->pMcdState;
    MCDPIXELSTATE McdPixelState;

    ASSERTOPENGL(pMcdState, "GenMcdUpdateFineState: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdUpdateFineState: "
                 "mcd32.dll not initialized\n");

    //
    // Compute MCD state from the current OpenGL context state.
    //

    if (MCD_STATE_DIRTYTEST(gengc, ENABLES))
    {
        MCDENABLESTATE state;

        state.enables = gc->state.enables.general;
        (gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                         MCD_ENABLE_STATE,
                                         &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, TEXTURE))
    {
        MCDTEXTUREENABLESTATE state;

        state.textureEnabled = gc->texture.textureEnabled;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_TEXTURE_ENABLE_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, FOG))
    {
        MCDFOGSTATE state;

        *((__GLcolor *) &state.fogColor) = gc->state.fog.color;
        state.fogIndex   = gc->state.fog.index;
        state.fogDensity = gc->state.fog.density;
        state.fogStart   = gc->state.fog.start;
        state.fogEnd     = gc->state.fog.end;
        state.fogMode    = gc->state.fog.mode;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_FOG_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, SHADEMODEL))
    {
        MCDSHADEMODELSTATE state;

        state.shadeModel = gc->state.light.shadingModel;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_SHADEMODEL_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, POINTDRAW))
    {
        MCDPOINTDRAWSTATE state;

        state.pointSize = gc->state.point.requestedSize;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_POINTDRAW_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, LINEDRAW))
    {
        MCDLINEDRAWSTATE state;

        state.lineWidth          = gc->state.line.requestedWidth;
        state.lineStipplePattern = gc->state.line.stipple;
        state.lineStippleRepeat  = gc->state.line.stippleRepeat;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_LINEDRAW_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, POLYDRAW))
    {
        MCDPOLYDRAWSTATE state;

        state.cullFaceMode     = gc->state.polygon.cull;
        state.frontFace        = gc->state.polygon.frontFaceDirection;
        state.polygonModeFront = gc->state.polygon.frontMode;
        state.polygonModeBack  = gc->state.polygon.backMode;
        memcpy(&state.polygonStipple, &gc->state.polygonStipple.stipple,
               sizeof(state.polygonStipple));
        state.zOffsetFactor    = gc->state.polygon.factor;
        state.zOffsetUnits     = gc->state.polygon.units;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_POLYDRAW_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, ALPHATEST))
    {
        MCDALPHATESTSTATE state;

        state.alphaTestFunc = gc->state.raster.alphaFunction;
        state.alphaTestRef  = gc->state.raster.alphaReference;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_ALPHATEST_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, DEPTHTEST))
    {
        MCDDEPTHTESTSTATE state;

        state.depthTestFunc = gc->state.depth.testFunc;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_DEPTHTEST_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, BLEND))
    {
        MCDBLENDSTATE state;

        state.blendSrc = gc->state.raster.blendSrc;
        state.blendDst = gc->state.raster.blendDst;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_BLEND_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, LOGICOP))
    {
        MCDLOGICOPSTATE state;

        state.logicOpMode = gc->state.raster.logicOp;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_LOGICOP_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, FBUFCTRL))
    {
        MCDFRAMEBUFSTATE state;

        state.drawBuffer        = gc->state.raster.drawBuffer;
        state.indexWritemask    = gc->state.raster.writeMask;
        state.colorWritemask[0] = gc->state.raster.rMask;
        state.colorWritemask[1] = gc->state.raster.gMask;
        state.colorWritemask[2] = gc->state.raster.bMask;
        state.colorWritemask[3] = gc->state.raster.aMask;
        state.depthWritemask    = gc->state.depth.writeEnable;

        // To be consistent, we will scale the clear color to whatever
        // the MCD driver specified:

        state.colorClearValue.r =
            gc->state.raster.clear.r * gc->redVertexScale;
        state.colorClearValue.g =
            gc->state.raster.clear.g * gc->greenVertexScale;
        state.colorClearValue.b =
            gc->state.raster.clear.b * gc->blueVertexScale;
        state.colorClearValue.a =
            gc->state.raster.clear.a * gc->alphaVertexScale;

        state.indexClearValue   = gc->state.raster.clearIndex;
        state.stencilClearValue = (USHORT) gc->state.stencil.clear;

        state.depthClearValue   = (MCDDOUBLE) (gc->state.depth.clear *
                                               gengc->genAccel.zDevScale);
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_FRAMEBUF_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, LIGHTMODEL))
    {
        MCDLIGHTMODELSTATE state;

        *((__GLcolor *)&state.ambient) = gc->state.light.model.ambient;
        state.localViewer = gc->state.light.model.localViewer;
        state.twoSided = gc->state.light.model.twoSided;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_LIGHT_MODEL_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, HINTS))
    {
        MCDHINTSTATE state;

        state.perspectiveCorrectionHint =
            gc->state.hints.perspectiveCorrection;
        state.pointSmoothHint           = gc->state.hints.pointSmooth;
        state.lineSmoothHint            = gc->state.hints.lineSmooth;
        state.polygonSmoothHint         = gc->state.hints.polygonSmooth;
        state.fogHint                   = gc->state.hints.fog;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_HINT_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, CLIPCTRL))
    {
        MCDCLIPSTATE state;
        ULONG i, mask, numClipPlanes;

        memset(state.userClipPlanes, 0, sizeof(state.userClipPlanes));
        memset(state.userClipPlanesInv, 0, sizeof(state.userClipPlanesInv));

        //
        // Number of user defined clip planes should match.  However,
        // rather than assume this, let's take the min and be robust.
        //

        ASSERTOPENGL(sizeof(__GLcoord) == sizeof(MCDCOORD),
                     "GenMcdUpdateFineState: coord struct mismatch\n");

        ASSERTOPENGL(MCD_MAX_USER_CLIP_PLANES ==
                     gc->constants.numberOfClipPlanes,
                     "GenMcdUpdateFineState: num clip planes mismatch\n");

        numClipPlanes = min(MCD_MAX_USER_CLIP_PLANES,
                            gc->constants.numberOfClipPlanes);

        state.userClipEnables = gc->state.enables.clipPlanes;
        
        for (i = 0, mask = 1; i < numClipPlanes; i++, mask <<= 1)
        {
            if (mask & gc->state.enables.clipPlanes)
            {
                state.userClipPlanes[i] =
                    *(MCDCOORD *)&gc->state.transform.eyeClipPlanesSet[i];
                state.userClipPlanesInv[i] =
                    *(MCDCOORD *)&gc->state.transform.eyeClipPlanes[i];
            }
        }

        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_CLIP_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, STENCILTEST))
    {
        MCDSTENCILTESTSTATE state;

        state.stencilTestFunc  = gc->state.stencil.testFunc;
        state.stencilMask      = (USHORT) gc->state.stencil.mask;
        state.stencilRef       = (USHORT) gc->state.stencil.reference;
        state.stencilFail      = gc->state.stencil.fail;
        state.stencilDepthFail = gc->state.stencil.depthFail;
        state.stencilDepthPass = gc->state.stencil.depthPass;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_STENCILTEST_STATE,
                                          &state, sizeof(state));
    }

    //
    // The rest of the state is only interesting to a 2.0 driver,
    // so only send it to a 2.0 driver.
    //

    if (!SUPPORTS_20())
    {
        return;
    }
    
    if (MCD_STATE_DIRTYTEST(gengc, TEXTRANSFORM))
    {
        MCDTEXTURETRANSFORMSTATE state;

        ASSERTOPENGL(sizeof(gc->transform.texture->matrix) ==
                     sizeof(MCDMATRIX),
                     "Matrix size mismatch\n");
        
	memcpy(&state.transform, &gc->transform.texture->matrix,
               sizeof(state.transform));
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_TEXTURE_TRANSFORM_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, TEXGEN))
    {
        MCDTEXTUREGENERATIONSTATE state;

        ASSERTOPENGL(sizeof(__GLtextureCoordState) ==
                     sizeof(MCDTEXTURECOORDGENERATION),
                     "MCDTEXTURECOORDGENERATION mismatch\n");
        
        *(__GLtextureCoordState *)&state.s = gc->state.texture.s;
        *(__GLtextureCoordState *)&state.t = gc->state.texture.t;
        *(__GLtextureCoordState *)&state.r = gc->state.texture.r;
        *(__GLtextureCoordState *)&state.q = gc->state.texture.q;
        
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_TEXTURE_GENERATION_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, MATERIAL))
    {
        MCDMATERIALSTATE state;

        ASSERTOPENGL(sizeof(MCDMATERIAL) == sizeof(__GLmaterialState),
                     "Material size mismatch\n");
        
        *(__GLmaterialState *)&state.materials[MCDVERTEX_FRONTFACE] =
            gc->state.light.front;
        *(__GLmaterialState *)&state.materials[MCDVERTEX_BACKFACE] =
            gc->state.light.back;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_MATERIAL_STATE,
                                          &state, sizeof(state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, LIGHTS))
    {
        // Extra light is to hold the MCDLIGHTSTATE
        MCDLIGHT lights[MCD_MAX_LIGHTS+1];
        MCDLIGHT *light;
        MCDLIGHTSOURCESTATE *state;
        __GLlightSourceState *lss;
        ULONG bit;

        ASSERTOPENGL(sizeof(MCDLIGHTSOURCESTATE) <= sizeof(MCDLIGHT),
                     "MCDLIGHTSTATE too large\n");
        ASSERTOPENGL(gc->constants.numberOfLights <= MCD_MAX_LIGHTS,
                     "Too many lights\n");
        ASSERTOPENGL(sizeof(__GLlightSourceState) >= sizeof(MCDLIGHT),
                     "__GLlightSourceState too small\n");
        
        // We attempt to optimize this state request by only
        // sending down the lights that have changed.

        light = &lights[1];
        state = (MCDLIGHTSOURCESTATE *)
            ((BYTE *)light - sizeof(MCDLIGHTSOURCESTATE));
        
        state->enables = gc->state.enables.lights;
        state->changed = gc->state.light.dirtyLights;
        gc->state.light.dirtyLights = 0;

        bit = 1;
        lss = gc->state.light.source;
        while (bit < (1UL << gc->constants.numberOfLights))
        {
            if (state->changed & bit)
            {
                // MCDLIGHT is a subset of __GLlightSourceState.
                memcpy(light, lss, sizeof(MCDLIGHT));
                light++;
            }

            bit <<= 1;
            lss++;
        }
        
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_LIGHT_SOURCE_STATE,
                                          state, (ULONG)((BYTE *)light-(BYTE *)state));
    }

    if (MCD_STATE_DIRTYTEST(gengc, COLORMATERIAL))
    {
        MCDCOLORMATERIALSTATE state;

        state.face = gc->state.light.colorMaterialFace;
        state.mode = gc->state.light.colorMaterialParam;
        (*gpMcdTable->pMCDAddStateStruct)(pMcdState->McdCmdBatch.pv,
                                          MCD_COLOR_MATERIAL_STATE,
                                          &state, sizeof(state));
    }
}

/******************************Public*Routine******************************\
* GenMcdDrawPix
*
* Stub to call MCDDrawPixels.
*
* History:
*  27-May-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ULONG FASTCALL GenMcdDrawPix(__GLGENcontext *gengc, ULONG width,
                             ULONG height, ULONG format, ULONG type,
                             VOID *pPixels, BOOL packed)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdDrawPix: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdDrawPix: mcd32.dll not initialized\n");

    //
    // Before calling MCD to draw, flush state.
    //

    vFlushDirtyState(gengc);

    return (gpMcdTable->pMCDDrawPixels)(&gengc->pMcdState->McdContext,
                                        width, height, format, type,
                                        pPixels, packed);
}

/******************************Public*Routine******************************\
* GenMcdReadPix
*
* Stub to call MCDReadPixels.
*
* History:
*  27-May-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ULONG FASTCALL GenMcdReadPix(__GLGENcontext *gengc, LONG x, LONG y,
                             ULONG width, ULONG height, ULONG format,
                             ULONG type, VOID *pPixels)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdReadPix: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdReadPix: mcd32.dll not initialized\n");

    //
    // Before calling MCD to draw, flush state.
    //

    vFlushDirtyState(gengc);

    return (gpMcdTable->pMCDReadPixels)(&gengc->pMcdState->McdContext,
                                        x, y, width, height, format, type,
                                        pPixels);
}

/******************************Public*Routine******************************\
* GenMcdCopyPix
*
* Stub to call MCDCopyPixels.
*
* History:
*  27-May-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ULONG FASTCALL GenMcdCopyPix(__GLGENcontext *gengc, LONG x, LONG y,
                             ULONG width, ULONG height, ULONG type)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdCopyPix: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdCopyPix: mcd32.dll not initialized\n");

    //
    // Before calling MCD to draw, flush state.
    //

    vFlushDirtyState(gengc);

    return (gpMcdTable->pMCDCopyPixels)(&gengc->pMcdState->McdContext,
                                        x, y, width, height, type);
}

/******************************Public*Routine******************************\
* GenMcdPixelMap
*
* Stub to call MCDPixelMap.
*
* History:
*  27-May-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ULONG FASTCALL GenMcdPixelMap(__GLGENcontext *gengc, ULONG mapType,
                              ULONG mapSize, VOID *pMap)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState, "GenMcdPixelMap: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdPixelMap: mcd32.dll not initialized\n");

    return (gpMcdTable->pMCDPixelMap)(&gengc->pMcdState->McdContext,
                                      mapType, mapSize, pMap);
}

/******************************Public*Routine******************************\
*
* GenMcdDestroyWindow
*
* Passes on GLGENwindow cleanup notifications
*
* History:
*  Thu Sep 19 12:01:40 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void FASTCALL GenMcdDestroyWindow(GLGENwindow *pwnd)
{
    HDC hdc;
    
    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdDestroyWindow: "
                 "mcd32.dll not initialized\n");

    // The HDC stored in the pwnd may no longer be valid, so if there's
    // a window associated with the pwnd get a fresh DC.
    if (pwnd->gwid.iType == GLWID_DDRAW ||
        pwnd->gwid.hwnd == NULL)
    {
        hdc = pwnd->gwid.hdc;
    }
    else
    {
        hdc = GetDC(pwnd->gwid.hwnd);
        if (hdc == NULL)
        {
            WARNING("GenMcdDestroyWindow unable to GetDC\n");
            return;
        }
    }
        
    (gpMcdTable->pMCDDestroyWindow)(hdc, pwnd->dwMcdWindow);

    if (pwnd->gwid.iType != GLWID_DDRAW &&
        pwnd->gwid.hwnd != NULL)
    {
        ReleaseDC(pwnd->gwid.hwnd, hdc);
    }
}

/******************************Public*Routine******************************\
*
* GenMcdGetTextureFormats
*
* History:
*  Thu Sep 26 18:34:49 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

int FASTCALL GenMcdGetTextureFormats(__GLGENcontext *gengc, int nFmts,
                                     struct _DDSURFACEDESC *pddsd)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;

    ASSERTOPENGL(gengc->pMcdState,
                 "GenMcdGetMcdTextureFormats: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable,
                 "GenMcdGetMcdTextureFormats: mcd32.dll not initialized\n");

    return (gpMcdTable->pMCDGetTextureFormats)(&gengc->pMcdState->McdContext,
                                               nFmts, pddsd);
}

/******************************Public*Routine******************************\
*
* GenMcdSwapMultiple
*
* History:
*  Tue Oct 15 12:51:09 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DWORD FASTCALL GenMcdSwapMultiple(UINT cBuffers, GENMCDSWAP *pgms)
{
    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable, "GenMcdSwapMultiple: "
                 "mcd32.dll not initialized\n");

    return (gpMcdTable->pMCDSwapMultiple)(pgms[0].pwswap->hdc, cBuffers, pgms);
}

/******************************Public*Routine******************************\
* GenMcdProcessPrim
*
* Process the primitives in the POLYARRAY/POLYDATA array pointed to by pa.
* The primitives are chained together as a linked list terminated by a
* NULL.  The return value is a pointer to the first unhandled primitive
* (NULL if the entire chain is successfully processed).
*
* This routine differs from GenMcdProcessPrim in that it is the MCD 2.0
* entry point for front-end processors and so calls MCDrvProcess rather
* than MCDrvDraw.
*
* Returns:
*   NULL if entire batch is processed; otherwise, return value is a pointer
*   to the unhandled portion of the chain.
*
* History:
*  13-Mar-1997 -by- Drew Bliss [drewb]
* Created from GenMcdDrawPrim.
\**************************************************************************/

POLYARRAY * FASTCALL GenMcdProcessPrim(__GLGENcontext *gengc, POLYARRAY *pa,
                                       ULONG cmdFlagsAll, ULONG primFlags,
                                       MCDTRANSFORM *pMCDTransform,
                                       MCDMATERIALCHANGES *pMCDMatChanges)
{
    GENMCDSTATE *pMcdState = gengc->pMcdState;
    int levels;
    LPDIRECTDRAWSURFACE *pdds;

    if (!SUPPORTS_20())
    {
        return pa;
    }
    
    ASSERTOPENGL(gengc->pMcdState, "GenMcdProcessPrim: null pMcdState\n");

    //
    // This function can assume that MCD entry point table is already
    // initialized as we cannot get here without MCD already having been
    // called.
    //

    ASSERTOPENGL(gpMcdTable,
                 "GenMcdProcessPrim: mcd32.dll not initialized\n");

#if DBG
    {
        LONG lOffset;

        lOffset = (LONG) ((BYTE *) pa - (BYTE *) pMcdState->pMcdPrimBatch->pv);

        ASSERTOPENGL(
            (lOffset >= 0) &&
            (lOffset < (LONG) pMcdState->pMcdPrimBatch->size),
            "GenMcdProcessPrim: pa not in shared mem window\n");
    }
#endif

    //
    // Before calling MCD to draw, flush state.
    //

    vFlushDirtyState(gengc);

#ifdef AUTOMATIC_SURF_LOCK
    levels = gengc->gc.texture.ddtex.levels;
    if (levels > 0 &&
        gengc->gc.texture.ddtex.texobj.loadKey != 0)
    {
        pdds = gengc->gc.texture.ddtex.pdds;
    }
    else
#endif
    {
        levels = 0;
        pdds = NULL;
    }
    
    return (POLYARRAY *)
           (gpMcdTable->pMCDProcessBatch2)(&pMcdState->McdContext,
                                           pMcdState->McdCmdBatch.pv,
                                           pMcdState->pMcdPrimBatch->pv,
                                           (PVOID) pa, levels, pdds,
                                           cmdFlagsAll, primFlags,
                                           pMCDTransform, pMCDMatChanges);
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\precomp.h ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>

#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

#include <ddrawp.h>
#include <ddrawi.h>

#include <wingdip.h>
#define _NO_DDRAWINT_NO_COM
#include <winddi.h>

#include <glp.h>
#include <gencx.h>
#include <global.h>
#include <fixed.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\wglsup.c ===
/******************************Module*Header*******************************\
* Module Name: wglsup.c                                                    *
*                                                                          *
* WGL support routines.                                                    *
*                                                                          *
* Created: 15-Dec-1994                                                     *
* Author: Gilman Wong [gilmanw]                                            *
*                                                                          *
* Copyright (c) 1994 Microsoft Corporation                                 *
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

#include "devlock.h"

#define DONTUSE(x)  ( (x) = (x) )

//!!!XXX -- Patrick says is necessary, but so far we seem OK.  I think
//          it is really the apps responsibility.
//!!!dbug
#if 1
#define REALIZEPALETTE(hdc) RealizePalette((hdc))
#else
#define REALIZEPALETTE(hdc)
#endif

//!!!XXX -- BitBlt's involving DIB sections are batched.
//          A GdiFlush is required, but perhaps can be taken out when
//          GDI goes to kernel-mode.  Can probably take out for Win95.
//#ifdef _OPENGL_NT_
#if 1
#define GDIFLUSH    GdiFlush()
#else
#define GDIFLUSH
#endif

/******************************Public*Routine******************************\
* wglPixelVisible
*
* Determines if the pixel (x, y) is visible in the window associated with
* the given DC.  The determination is made by checking the coordinate
* against the visible region data cached in the GLGENwindow structure for
* this winodw.
*
* Returns:
*   TRUE if pixel (x, y) is visible, FALSE if clipped out.
*
\**************************************************************************/

BOOL APIENTRY wglPixelVisible(LONG x, LONG y)
{
    BOOL bRet = FALSE;
    __GLGENcontext *gengc = (__GLGENcontext *) GLTEB_SRVCONTEXT();
    GLGENwindow *pwnd = gengc->pwndLocked;

    // If direct screen access isn't active we shouldn't call this function
    // since there's no need to do any visibility clipping ourselves
    ASSERTOPENGL(GLDIRECTSCREEN,
                 "wglPixelVisible called without direct access\n");

// Quick test against bounds.

    if (
            pwnd->prgndat && pwnd->pscandat &&
            x >= pwnd->prgndat->rdh.rcBound.left   &&
            x <  pwnd->prgndat->rdh.rcBound.right  &&
            y >= pwnd->prgndat->rdh.rcBound.top    &&
            y <  pwnd->prgndat->rdh.rcBound.bottom
       )
    {
        ULONG cScans = pwnd->pscandat->cScans;
        GLGENscan *pscan = pwnd->pscandat->aScans;

    // Find right scan.

        for ( ; cScans; cScans--, pscan = pscan->pNext )
        {
        // Check if point is above scan.

            if ( pscan->top > y )
            {
            // Since scans are ordered top-down, we can conclude that
            // point is also above subsequent scans.  Therefore intersection
            // must be NULL and we can terminate search.

                break;
            }

        // Check if point is within scan.

            else if ( pscan->bottom > y )
            {
                LONG *plWalls = pscan->alWalls;
                LONG *plWallsEnd = plWalls + pscan->cWalls;

            // Check x against each pair of walls.

                for ( ; plWalls < plWallsEnd; plWalls+=2 )
                {
                // Each pair of walls (inclusive-exclusive) defines
                // a non-NULL interval in the span that is visible.

                    ASSERTOPENGL(
                        plWalls[0] < plWalls[1],
                        "wglPixelVisible(): bad walls in span\n"
                        );

                // Check if x is within current interval.

                    if ( x >= plWalls[0] && x < plWalls[1] )
                    {
                        bRet = TRUE;
                        break;
                    }
                }

                break;
            }

        // Point is below current scan. Try next scan.
        }
    }

    return bRet;
}

/******************************Public*Routine******************************\
* wglSpanVisible
*
* Determines the visibility of the span [(x, y), (x+w, y)) (test is
* inclusive-exclusive) in the current window.  The span is either
* completely visible, partially visible (clipped), or completely
* clipped out (WGL_SPAN_ALL, WGL_SPAN_PARTIAL, and WGL_SPAN_NONE,
* respectively).
*
* WGL_SPAN_ALL
* ------------
* The entire span is visible.  *pcWalls and *ppWalls are not set.
*
* WGL_SPAN_NONE
* -------------
* The span is completely obscured (clipped out).  *pcWalls and *ppWalls
* are not set.
*
* WGL_SPAN_PARTIAL
* ----------------
* If the span is WGL_SPAN_PARTIAL, the function also returns a pointer
* to the wall array (starting with the first wall actually intersected
* by the span) and a count of the walls at this pointer.
*
* If the wall count is even, then the span starts outside the visible
* region and the first wall is where the span enters a visible portion.
*
* If the wall count is odd, then the span starts inside the visible
* region and the first wall is where the span exits a visible portion.
*
* The span may or may not cross all the walls in the array, but definitely
* does cross the first wall.
*
* Return:
*   Returns WGL_SPAN_ALL, WGL_SPAN_NONE, or WGL_SPAN_PARTIAL.  In
*   addition, if return is WGL_SPAN_PARTIAL, pcWalls and ppWalls will
*   be set (see above).
*
* History:
*  06-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

ULONG APIENTRY
wglSpanVisible(LONG x, LONG y, ULONG w, LONG *pcWalls, LONG **ppWalls)
{
    ULONG ulRet = WGL_SPAN_NONE;
    __GLGENcontext *gengc = (__GLGENcontext *) GLTEB_SRVCONTEXT();
    GLGENwindow *pwnd = gengc->pwndLocked;
    LONG xRight = x + w;        // Right edge of span (exclusive)

    // If direct access is not active we shouldn't call this function since
    // there's no need to do any visibility clipping ourselves
    ASSERTOPENGL(GLDIRECTSCREEN,
                 "wglSpanVisible called without direct access\n");

// Quick test against bounds.

    if (
            pwnd->prgndat && pwnd->pscandat &&
            (x      <  pwnd->prgndat->rdh.rcBound.right ) &&
            (xRight >  pwnd->prgndat->rdh.rcBound.left  ) &&
            (y      >= pwnd->prgndat->rdh.rcBound.top   ) &&
            (y      <  pwnd->prgndat->rdh.rcBound.bottom)
       )
    {
        ULONG cScans = pwnd->pscandat->cScans;
        GLGENscan *pscan = pwnd->pscandat->aScans;

    // Find right scan.

        for ( ; cScans; cScans--, pscan = pscan->pNext )
        {
        // Check if span is above scan.

            if ( pscan->top > y )           // Scans have gone past span
            {
            // Since scans are ordered top-down, we can conclude that
            // span will aslo be above subsequent scans.  Therefore
            // intersection must be NULL and we can terminate search.

                goto wglSpanVisible_exit;
            }

        // Span is below top of scan.  If span is also above bottom,
        // span vertically intersects this scan and only this scan.

            else if ( pscan->bottom > y )
            {
                LONG *plWalls = pscan->alWalls;
                ULONG cWalls = pscan->cWalls;

                ASSERTOPENGL(
                    (cWalls & 0x1) == 0,
                    "wglSpanVisible(): wall count must be even!\n"
                    );

            // Check span against each pair of walls.  Walls are walked
            // from left to right.
            //
            // Possible intersections where "[" is inclusive
            // and ")" is exclusive:
            //                         left wall        right wall
            //                             [                )
            //      case 1a     [-----)    [                )
            //           1b          [-----)                )
            //                             [                )
            //      case 2a             [-----)             )       return
            //           2b             [-------------------)       left wall
            //                             [                )
            //      case 3a                [-----)          )
            //           3b                [    [-----)     )
            //           3c                [          [-----)
            //           3d                [----------------)
            //                             [                )
            //      case 4a                [             [-----)    return
            //           4b                [-------------------)    right wall
            //                             [                )
            //      case 5a                [                [-----)
            //           5b                [                )    [-----)
            //                             [                )
            //      case 6              [----------------------)    return
            //                             [                )       left wall

                for ( ; cWalls; cWalls-=2, plWalls+=2 )
                {
                // Each pair of walls (inclusive-exclusive) defines
                // a non-NULL interval in the span that is visible.

                    ASSERTOPENGL(
                        plWalls[0] < plWalls[1],
                        "wglSpanVisible(): bad walls in span\n"
                        );

                // Checking right end against left wall will partition the
                // set into case 1 vs. case 2 thru 6.

                    if ( plWalls[0] >= xRight )
                    {
                    // Case 1 -- span outside interval on the left.
                    //
                    // The walls are ordered from left to right (i.e., low
                    // to high).  So if span is left of this interval, it
                    // must also be left of all subsequent intervals and
                    // we can terminate the search.

                        goto wglSpanVisible_exit;
                    }

                // Cases 2 thru 6.
                //
                // Checking left end against right wall will partition subset
                // into case 5 vs. cases 2, 3, 4, 6.

                    else if ( plWalls[1] > x )
                    {
                    // Cases 2, 3, 4, and 6.
                    //
                    // Checking left end against left wall will partition
                    // subset into cases 2, 6 vs. cases 3, 4.

                        if ( plWalls[0] <= x )
                        {
                        // Cases 3 and 4.
                        //
                        // Checking right end against right wall will
                        // distinguish between the two cases.

                            if ( plWalls[1] >= xRight )
                            {
                            // Case 3 -- completely visible.

                                ulRet = WGL_SPAN_ALL;
                            }
                            else
                            {
                            // Case 4 -- partially visible, straddling the
                            // right wall.

                                ulRet = WGL_SPAN_PARTIAL;

                                *ppWalls = &plWalls[1];
                                *pcWalls = cWalls - 1;
                            }
                        }
                        else
                        {
                        // Cases 2 and 6 -- in either case its a partial
                        // intersection where the first intersection is with
                        // the left wall.

                            ulRet = WGL_SPAN_PARTIAL;

                            *ppWalls = &plWalls[0];
                            *pcWalls = cWalls;
                        }

                        goto wglSpanVisible_exit;
                    }

                // Case 5 -- span outside interval to the right. Try
                // next pair of walls.
                }

            // A span can intersect only one scan.  We don't need to check
            // any other scans.

                goto wglSpanVisible_exit;
            }

        // Span is below current scan.  Try next scan.
        }
    }

wglSpanVisible_exit:

    return ulRet;
}

/******************************Public*Routine******************************\
* bComputeLogicalToSurfaceMap
*
* Copy logical palette to surface palette translation vector to the buffer
* pointed to by pajVector.  The logical palette is specified by hpal.  The
* surface is specified by hdc.
*
* Note: The hdc may identify either a direct (display) dc or a DIB memory dc.
* If hdc is a display dc, then the surface palette is the system palette.
* If hdc is a memory dc, then the surface palette is the DIB color table.
*
* History:
*  27-Jan-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL bComputeLogicalToSurfaceMap(HPALETTE hpal, HDC hdc, BYTE *pajVector)
{
    BOOL bRet = FALSE;
    HPALETTE hpalSurf;
    ULONG cEntries, cSysEntries;
    DWORD dwDcType = wglObjectType(hdc);
    LPPALETTEENTRY lppeTmp, lppeEnd;

    BYTE aj[sizeof(LOGPALETTE) + (sizeof(PALETTEENTRY) * 512) + (sizeof(RGBQUAD) * 256)];
    LOGPALETTE *ppal = (LOGPALETTE *) aj;
    LPPALETTEENTRY lppeSurf = &ppal->palPalEntry[0];
    LPPALETTEENTRY lppe = lppeSurf + 256;
    RGBQUAD *prgb = (RGBQUAD *) (lppe + 256);

// Determine number of colors in each palette.

    cEntries = GetPaletteEntries(hpal, 0, 1, NULL);
    if (dwDcType == OBJ_DC)
        cSysEntries = wglGetSystemPaletteEntries(hdc, 0, 1, NULL);
    else
        cSysEntries = 256;

// Dynamic color depth changing can cause this.

    if ((cSysEntries > 256) || (cEntries > 256))
    {
        WARNING("wglCopyTranslationVector(): palette on > 8BPP device\n");

    // Drawing will have corrupted colors, but at least we should not crash.

        cSysEntries = min(cSysEntries, 256);
        cEntries = min(cEntries, 256);
    }

// Get the logical palette entries.

    cEntries = GetPaletteEntries(hpal, 0, cEntries, lppe);

// Get the surface palette entries.

    if (dwDcType == OBJ_DC)
    {
        cSysEntries = wglGetSystemPaletteEntries(hdc, 0, cSysEntries, lppeSurf);

        lppeTmp = lppeSurf;
        lppeEnd = lppeSurf + cSysEntries;

        for (; lppeTmp < lppeEnd; lppeTmp++)
            lppeTmp->peFlags = 0;
    }
    else
    {
        RGBQUAD *prgbTmp;

    // First get RGBQUADs from DIB color table...

        cSysEntries = GetDIBColorTable(hdc, 0, cSysEntries, prgb);

    // ...then convert RGBQUADs into PALETTEENTRIES.

        prgbTmp = prgb;
        lppeTmp = lppeSurf;
        lppeEnd = lppeSurf + cSysEntries;

        while (lppeTmp < lppeEnd)
        {
            lppeTmp->peRed   = prgbTmp->rgbRed;
            lppeTmp->peGreen = prgbTmp->rgbGreen;
            lppeTmp->peBlue  = prgbTmp->rgbBlue;
            lppeTmp->peFlags = 0;

            lppeTmp++;
            prgbTmp++;

        }
    }

// Construct a translation vector by using GetNearestPaletteIndex to
// map each entry in the logical palette to the surface palette.

    if (cEntries && cSysEntries)
    {
    // Create a temporary logical palette that matches the surface
    // palette retrieved above.

        ppal->palVersion = 0x300;
        ppal->palNumEntries = (USHORT) cSysEntries;

        if ( hpalSurf = CreatePalette(ppal) )
        {
        // Translate each logical palette entry into a surface palette index.

            lppeTmp = lppe;
            lppeEnd = lppe + cEntries;

            for ( ; lppeTmp < lppeEnd; lppeTmp++, pajVector++)
            {
                *pajVector = (BYTE) GetNearestPaletteIndex(
                                        hpalSurf,
                                        RGB(lppeTmp->peRed,
                                            lppeTmp->peGreen,
                                            lppeTmp->peBlue)
                                        );

                ASSERTOPENGL(
                    *pajVector != CLR_INVALID,
                    "bComputeLogicalToSurfaceMap: GetNearestPaletteIndex failed\n"
                    );
            }

            bRet = TRUE;

            DeleteObject(hpalSurf);
        }
        else
        {
            WARNING("bComputeLogicalToSurfaceMap: CreatePalette failed\n");
        }
    }
    else
    {
        WARNING("bComputeLogicalToSurfaceMap: failed to get pal info\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* wglCopyTranslateVector
*
* Create a logical palette index to system palette index translation
* vector.
*
* This is done by first reading both the logical palette and system palette
* entries.  A temporary palette is created from the read system palette
* entries.  This will be passed to GetNearestPaletteIndex to translate
* each logical palette entry into the desired system palette entry.
*
* Note: when GetNearestColor was called instead, very unstable results
* were obtained.  GetNearestPaletteIndex is definitely the right way to go.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  25-Oct-1994 -by- Gilman Wong [gilmanw]
* Ported from gdi\gre\wglsup.cxx.
\**************************************************************************/

static GLubyte vubRGBtoVGA[8] = {
    0x0,
    0x9,
    0xa,
    0xb,
    0xc,
    0xd,
    0xe,
    0xf
};

BOOL APIENTRY wglCopyTranslateVector(__GLGENcontext *gengc, BYTE *pajVector,
                                     ULONG cEntries)
{
    BOOL bRet = FALSE;
    ULONG i;
    HDC hdc;

    CHECKSCREENLOCKOUT();

    if (gengc->dwCurrentFlags & GLSURF_DIRECTDRAW)
    {
        // DirectDraw palettes are set directly into the hardware so
        // the translation vector is always identity
        for (i = 0; i < cEntries; i++)
        {
            *pajVector++ = (BYTE)i;
        }

        return TRUE;
    }

    hdc = gengc->gwidCurrent.hdc;
    
    if (GLSURF_IS_MEMDC(gengc->dwCurrentFlags))
    {
        HBITMAP hbm, hbmSave;
        
        // Technically this assert is invalid
        // because we can't be sure that cEntries will be one
        // of these two cases.  To fix this we'd have to add
        // another parameter to this function indicating the
        // bit depth desired and go by that.
        ASSERTOPENGL(cEntries == 16 || cEntries == 256,
                     "wglCopyTranslateVector: Unknown cEntries\n");

        if (gengc->dwCurrentFlags & GLSURF_DIRECT_ACCESS)
        {
            // For compatibility, do not do this if the stock palette is
            // selected.  The old behavior assumed that the logical palette
            // can be ignored because the bitmap will have a color table
            // that exactly corresponds to the format specified by the
            // pixelformat.  Thus, if no palette is selected into the memdc,
            // OpenGL would still render properly since it assumed 1-to-1.
            //
            // However, to enable using optimized DIB sections (i.e., DIBs
            // whose color tables match the system palette exactly), we need
            // to be able to specify the logical palette in the memdc.
            //
            // Therefore the hack is to assume 1-to-1 iff the stock
            // palette is selected into the memdc.  Otherwise, we will
            // compute the logical to surface mapping.

            if ( gengc->gc.modes.rgbMode &&
                 (GetCurrentObject(hdc, OBJ_PAL) !=
                  GetStockObject(DEFAULT_PALETTE)) )
            {
                // If an RGB DIB section, compute a mapping from logical
                // palette to surface (DIB color table).

                bRet = bComputeLogicalToSurfaceMap(
                        GetCurrentObject(hdc, OBJ_PAL),
                        hdc,
                        pajVector
                        );
            }

            return bRet;
        }

        // 4bpp has a fixed color table so we can just copy the standard
        // translation into the output vector.

        if (cEntries == 16)
        {
            // For RGB mode, 4bpp uses a 1-1-1 format.  We want to utilize
            // bright versions which exist in the upper 8 entries.

            if ( gengc->gc.modes.rgbMode )
            {
                memcpy(pajVector, vubRGBtoVGA, 8);

                // Set the other mappings to white to make problems show up
                memset(pajVector+8, 15, 8);

                bRet = TRUE;
            }

            // For CI mode, just return FALSE and use the trivial vector.

            return bRet;
        }
        
        // For bitmaps, we can determine the forward translation vector by
        // filling a compatible bitmap with palette index specifiers from
        // 1 to 255 and reading the bits back with GetBitmapBits.
        
        hbm = CreateCompatibleBitmap(hdc, cEntries, 1);
        if (hbm)
        {
            LONG cBytes;
            
            hbmSave = SelectObject(hdc, hbm);
            RealizePalette(hdc);
            
            for (i = 0; i < cEntries; i++)
                SetPixel(hdc, i, 0, PALETTEINDEX(i));
            
            cBytes = 256;
            
            if ( GetBitmapBits(hbm, cBytes, (LPVOID) pajVector) >= cBytes )
                bRet = TRUE;
#if DBG
            else
                WARNING("wglCopyTranslateVector: GetBitmapBits failed\n");
#endif
            
            SelectObject(hdc, hbmSave);
            DeleteObject(hbm);
            RealizePalette(hdc);
        }
        
        return bRet;
    }

// Determine number of colors in logical and system palettes, respectively.

    cEntries = min(GetPaletteEntries(GetCurrentObject(hdc, OBJ_PAL),
                                     0, cEntries, NULL),
                   cEntries);

    if (cEntries == 16)
    {
        // For 16-color displays we are using RGB 1-1-1 since the
        // full 16-color palette doesn't make for very good mappings
        // Since we're only using the first eight of the colors we
        // want to map them to the bright colors in the VGA palette
        // rather than having them map to the dark colors as they would
        // if we ran the loop below

        if ( gengc->gc.modes.rgbMode )
        {
            memcpy(pajVector, vubRGBtoVGA, 8);

            // Set the other mappings to white to make problems show up
            memset(pajVector+8, 15, 8);

            bRet = TRUE;
        }

        // For CI mode, return FALSE and use the trivial translation vector.

        return bRet;
    }

// Compute logical to surface palette mapping.

    bRet = bComputeLogicalToSurfaceMap(GetCurrentObject(hdc, OBJ_PAL), hdc,
                                       pajVector);

    return bRet;
}

/******************************Public*Routine******************************\
* wglCopyBits
*
* Calls DrvCopyBits to copy scanline bits into or out of the driver surface.
*
\**************************************************************************/

VOID APIENTRY wglCopyBits(
    __GLGENcontext *gengc,
    GLGENwindow *pwnd,
    HBITMAP hbm,            // ignore
    LONG x,                 // screen coordinate of scan
    LONG y,
    ULONG cx,               // width of scan
    BOOL bIn)               // if TRUE, copy from bm to dev; otherwise, dev to bm
{
    CHECKSCREENLOCKOUT();

// Convert screen coordinates to window coordinates.

    x -= pwnd->rclClient.left;
    y -= pwnd->rclClient.top;

// this shouldn't happen, but better safe than sorry

    if (y < 0)
        return;

    //!!!XXX
    REALIZEPALETTE(gengc->gwidCurrent.hdc);

// Copy from bitmap to device.

    if (bIn)
    {
        LONG xSrc, x0Dst, x1Dst;
        if (x < 0)
        {
            xSrc  = -x;
            x0Dst = 0;
            x1Dst = x + (LONG)cx;
        }
        else
        {
            xSrc  = 0;
            x0Dst = x;
            x1Dst = x + (LONG)cx;
        }
        if (x1Dst <= x0Dst)
            return;

        BitBlt(gengc->gwidCurrent.hdc, x0Dst, y, cx, 1,
               gengc->ColorsMemDC, xSrc, 0, SRCCOPY);
    }

// Copy from device to bitmap.

    else
    {
        LONG xSrc, x0Dst, x1Dst;

        if (x < 0)
        {
            xSrc  = 0;
            x0Dst = -x;
            x1Dst = (LONG)cx;
        }
        else
        {
            xSrc  = x;
            x0Dst = 0;
            x1Dst = (LONG)cx;
        }
        if (x1Dst <= x0Dst)
            return;

        if (dwPlatformId == VER_PLATFORM_WIN32_NT ||
            GLSURF_IS_MEMDC(gengc->dwCurrentFlags))
        {
            BitBlt(gengc->ColorsMemDC, x0Dst, 0, cx, 1,
                   gengc->gwidCurrent.hdc, xSrc, y, SRCCOPY);
        }
        else
        {
            /* If we're copying from the screen,
               copy through a DDB to avoid some layers of unnecessary
               code in Win95 that deals with translating between
               different bitmap layouts */
            if (gengc->ColorsDdbDc)
            {
                BitBlt(gengc->ColorsDdbDc, 0, 0, cx, 1,
                       gengc->gwidCurrent.hdc, xSrc, y, SRCCOPY);

                BitBlt(gengc->ColorsMemDC, x0Dst, 0, cx, 1,
                       gengc->ColorsDdbDc, 0, 0, SRCCOPY);
            }
            else
            {
                //!!!Viper fix -- Diamond Viper (Weitek 9000) fails
                //!!!             CreateCompatibleBitmap for some
                //!!!             (currently unknown) reason.  Thus,
                //!!!             the DDB does not exist and we will
                //!!!             have to incur the perf. hit.

                BitBlt(gengc->ColorsMemDC, x0Dst, 0, cx, 1,
                       gengc->gwidCurrent.hdc, xSrc, y, SRCCOPY);
            }
        }
    }

    GDIFLUSH;
}

/******************************Public*Routine******************************\
* wglCopyBits2
*
* Calls DrvCopyBits to copy scanline bits into or out of the driver surface.
*
\**************************************************************************/

VOID APIENTRY wglCopyBits2(
    HDC hdc,        // dst/src device
    GLGENwindow *pwnd,   // clipping
    __GLGENcontext *gengc,
    LONG x,         // screen coordinate of scan
    LONG y,
    ULONG cx,       // width of scan
    BOOL bIn)       // if TRUE, copy from bm to dev; otherwise, dev to bm
{
    CHECKSCREENLOCKOUT();

// Convert screen coordinates to window coordinates.

    x -= pwnd->rclClient.left;
    y -= pwnd->rclClient.top;

// this shouldn't happen, but better safe than sorry

    if (y < 0)
        return;

    //!!!XXX
    REALIZEPALETTE(hdc);

// Copy from bitmap to device.

    if (bIn)
    {
        LONG xSrc, x0Dst, x1Dst;
        if (x < 0)
        {
            xSrc  = -x;
            x0Dst = 0;
            x1Dst = x + (LONG)cx;
        }
        else
        {
            xSrc  = 0;
            x0Dst = x;
            x1Dst = x + (LONG)cx;
        }
        if (x1Dst <= x0Dst)
            return;

        BitBlt(hdc, x0Dst, y, cx, 1,
               gengc->ColorsMemDC, xSrc, 0, SRCCOPY);
    }

// Copy from device to bitmap.

    else
    {
        LONG xSrc, x0Dst, x1Dst;

        if (x < 0)
        {
            xSrc  = 0;
            x0Dst = -x;
            x1Dst = (LONG)cx;
        }
        else
        {
            xSrc  = x;
            x0Dst = 0;
            x1Dst = (LONG)cx;
        }
        if (x1Dst <= x0Dst)
            return;

        if (dwPlatformId == VER_PLATFORM_WIN32_NT ||
            GLSURF_IS_MEMDC(gengc->dwCurrentFlags))
        {
            BitBlt(gengc->ColorsMemDC, x0Dst, 0, cx, 1,
                   hdc, xSrc, y, SRCCOPY);
        }
        else
        {
            /* If we're copying from the screen,
               copy through a DDB to avoid some layers of unnecessary
               code in Win95 that deals with translating between
               different bitmap layouts */
            if (gengc->ColorsDdbDc)
            {
                BitBlt(gengc->ColorsDdbDc, 0, 0, cx, 1,
                       hdc, xSrc, y, SRCCOPY);
                BitBlt(gengc->ColorsMemDC, x0Dst, 0, cx, 1,
                       gengc->ColorsDdbDc, 0, 0, SRCCOPY);
            }
            else
            {
                //!!!Viper fix -- Diamond Viper (Weitek 9000) fails
                //!!!             CreateCompatibleBitmap for some
                //!!!             (currently unknown) reason.  Thus,
                //!!!             the DDB does not exist and we will
                //!!!             have to incur the perf. hit.

                BitBlt(gengc->ColorsMemDC, x0Dst, 0, cx, 1,
                       hdc, xSrc, y, SRCCOPY);
            }
        }
    }

    GDIFLUSH;
}

/******************************Public*Routine******************************\
*
* wglTranslateColor
*
* Transforms a GL logical color into a Windows COLORREF
*
* Note: This is relatively expensive so it should be avoided if possible
*
* History:
*  Tue Aug 15 15:23:29 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

COLORREF wglTranslateColor(COLORREF crColor,
                           HDC hdc,
                           __GLGENcontext *gengc,
                           PIXELFORMATDESCRIPTOR *ppfd)
{
    //!!!XXX
    REALIZEPALETTE(hdc);

// If palette managed, then crColor is actually a palette index.

    if ( ppfd->cColorBits <= 8 )
    {
        PALETTEENTRY peTmp;

        ASSERTOPENGL(
            crColor < (COLORREF) (1 << ppfd->cColorBits),
            "TranslateColor(): bad color\n"
            );

    // If rendering to a bitmap, we need to do different things depending
    // on whether it's a DIB or DDB

        if ( gengc->gc.drawBuffer->buf.flags & MEMORY_DC )
        {
            DIBSECTION ds;
            
            // Check whether we're drawing to a DIB or a DDB
            if (GetObject(GetCurrentObject(hdc, OBJ_BITMAP),
                          sizeof(ds), &ds) == sizeof(ds) && ds.dsBm.bmBits)
            {
                RGBQUAD rgbq;
                
                // Drawing to a DIB so retrieve the color from the
                // DIB color table
                if (GetDIBColorTable(hdc, crColor, 1, &rgbq))
                {
                    crColor = RGB(rgbq.rgbRed, rgbq.rgbGreen,
                                  rgbq.rgbBlue);
                }
                else
                {
                    WARNING("TranslateColor(): GetDIBColorTable failed\n");
                    crColor = RGB(0, 0, 0);
                }
            }
            else
            {
                // Reverse the forward translation so that we get back
                // to a normal palette index
                crColor = gengc->pajInvTranslateVector[crColor];

                // Drawing to a DDB so we can just use the palette
                // index directly since going through the inverse
                // translation table has given us an index into
                // the logical palette
                crColor = PALETTEINDEX((WORD) crColor);
            }
        }

    // Otherwise...

        else
        {
        // I hate to have to confess this, but I don't really understand
        // why this needs to be this way.  Either way should work regardless
        // of the bit depth.
        //
        // The reality is that 4bpp we *have* to go into the system palette
        // and fetch an RGB value.  At 8bpp on the MGA driver (and possibly
        // others), we *have* to specify PALETTEINDEX.

            if ( ppfd->cColorBits == 4 )
            {
                if ( wglGetSystemPaletteEntries(hdc, crColor, 1, &peTmp) )
                {
                    crColor = RGB(peTmp.peRed, peTmp.peGreen, peTmp.peBlue);
                }
                else
                {
                    WARNING("TranslateColor(): wglGetSystemPaletteEntries failed\n");
                    crColor = RGB(0, 0, 0);
                }
            }
            else
            {
                if (!(gengc->flags & GENGC_MCD_BGR_INTO_RGB))
                    crColor = gengc->pajInvTranslateVector[crColor];
                crColor = PALETTEINDEX((WORD) crColor);
            }
        }
    }

// If 24BPP DIB section, BGR ordering is implied.

    else if ( ppfd->cColorBits == 24 )
    {
        crColor = RGB((crColor & 0xff0000) >> 16,
                      (crColor & 0x00ff00) >> 8,
                      (crColor & 0x0000ff));
    }

// Win95 and 16 BPP case.
//
// On Win95, additional munging is necessary to get a COLORREF value
// that will result in a non-dithered brush.

    else if ( (dwPlatformId == VER_PLATFORM_WIN32_WINDOWS) &&
         (ppfd->cColorBits == 16) )
    {
        HBITMAP hbmTmp;
        HDC hdcTmp;

        if (hdcTmp = CreateCompatibleDC(hdc))
        {
            if (hbmTmp = CreateCompatibleBitmap(hdc, 1, 1))
            {
                HBITMAP hbmOld;

                hbmOld = SelectObject(hdcTmp, hbmTmp);

                if (SetBitmapBits(hbmTmp, 2, (VOID *) &crColor))
                {
                    crColor = GetPixel(hdcTmp, 0, 0);
                }
                else
                {
                    WARNING("TranslateColor(): SetBitmapBits failed\n");
                }

                SelectObject(hdcTmp, hbmOld);
                DeleteObject(hbmTmp);
            }
            else
            {
                WARNING("TranslateColor(): CreateCompatibleBitmap failed\n");
            }
            
            DeleteDC(hdcTmp);
        }
        else
        {
            WARNING("TranslateColor(): CreateCompatibleDC failed\n");
        }
    }

// Bitfield format (16BPP or 32BPP).

    else
    {
        // Shift right to position bits at zero and then scale into
        // an 8-bit quantity

        //!!!XXX -- use rounding?!?
        crColor =
            RGB(((crColor & gengc->gc.modes.redMask) >> ppfd->cRedShift) *
                255 / ((1 << ppfd->cRedBits) - 1),
                ((crColor & gengc->gc.modes.greenMask) >> ppfd->cGreenShift) *
                255 / ((1 << ppfd->cGreenBits) - 1),
                ((crColor & gengc->gc.modes.blueMask) >> ppfd->cBlueShift) *
                255 / ((1 << ppfd->cBlueBits) - 1));

    }

    return crColor;
}

/******************************Public*Routine******************************\
* wglFillRect
*
* Calls DrvBitBlt to fill a rectangle area of a driver surface with a
* given color.
*
\**************************************************************************/

VOID APIENTRY wglFillRect(
    __GLGENcontext *gengc,
    GLGENwindow *pwnd,
    PRECTL prcl,        // screen coordinate of the rectangle area
    COLORREF crColor)   // color to set
{
    HBRUSH hbr;
    PIXELFORMATDESCRIPTOR *ppfd = &gengc->gsurf.pfd;

    CHECKSCREENLOCKOUT();

// If the rectangle is empty, return.

    if ( (prcl->left >= prcl->right) || (prcl->top >= prcl->bottom) )
    {
        WARNING("wglFillRect(): bad or empty rectangle\n");
        return;
    }

// Convert from screen to window coordinates.

    prcl->left   -= pwnd->rclClient.left;
    prcl->right  -= pwnd->rclClient.left;
    prcl->top    -= pwnd->rclClient.top;
    prcl->bottom -= pwnd->rclClient.top;

// Make a solid color brush and fill the rectangle.

    // If the fill color is the same as the last one, we can reuse
    // the cached brush rather than creating a new one
    if (crColor == gengc->crFill &&
        gengc->gwidCurrent.hdc == gengc->hdcFill)
    {
        hbr = gengc->hbrFill;
        ASSERTOPENGL(hbr != NULL, "Cached fill brush is null\n");
    }
    else
    {
        if (gengc->hbrFill != NULL)
        {
            DeleteObject(gengc->hbrFill);
        }
        
        gengc->crFill = crColor;
        
        crColor = wglTranslateColor(crColor, gengc->gwidCurrent.hdc, gengc, ppfd);
        hbr = CreateSolidBrush(crColor);
        gengc->hbrFill = hbr;
        
        if (hbr == NULL)
        {
            gengc->crFill = COLORREF_UNUSED;
            return;
        }

        gengc->hdcFill = gengc->gwidCurrent.hdc;
    }
    
    FillRect(gengc->gwidCurrent.hdc, (RECT *) prcl, hbr);
    GDIFLUSH;
}

/******************************Public*Routine******************************\
* wglCopyBuf
*
* Calls DrvCopyBits to copy a bitmap into the driver surface.
*
\**************************************************************************/

//!!!XXX -- change to a macro

VOID APIENTRY wglCopyBuf(
    HDC hdc,            // dst/src DCOBJ
    HDC hdcBmp,         // scr/dst bitmap
    LONG x,             // dst rect (UL corner) in window coord.
    LONG y,
    ULONG cx,           // width of dest rect
    ULONG cy            // height of dest rect
    )
{
    CHECKSCREENLOCKOUT();

    //!!!XXX
    REALIZEPALETTE(hdc);

    if (!BitBlt(hdc, x, y, cx, cy, hdcBmp, 0, 0, SRCCOPY))
    {
        WARNING1("wglCopyBuf BitBlt failed %d\n", GetLastError());
    }

    GDIFLUSH;
}

/******************************Public*Routine******************************\
* wglCopyBufRECTLIST
*
* Calls DrvCopyBits to copy a bitmap into the driver surface.
*
\**************************************************************************/

VOID APIENTRY wglCopyBufRECTLIST(
    HDC hdc,            // dst/src DCOBJ
    HDC hdcBmp,         // scr/dst bitmap
    LONG x,             // dst rect (UL corner) in window coord.
    LONG y,
    ULONG cx,           // width of dest rect
    ULONG cy,           // height of dest rect
    PRECTLIST prl
    )
{
    PYLIST pylist;

    CHECKSCREENLOCKOUT();

    //!!!XXX
    REALIZEPALETTE(hdc);

    for (pylist = prl->pylist; pylist != NULL; pylist = pylist->pnext)
    {
        PXLIST pxlist;
        
        for (pxlist = pylist->pxlist; pxlist != NULL; pxlist = pxlist->pnext)
        {
            int xx  = pxlist->s;
            int cxx = pxlist->e - pxlist->s;
            int yy  = pylist->s;
            int cyy = pylist->e - pylist->s;

            if (!BitBlt(hdc, xx, yy, cxx, cyy, hdcBmp, xx, yy, SRCCOPY))
            {
                WARNING1("wglCopyBufRL BitBlt failed %d\n", GetLastError());
            }
        }
    }

    GDIFLUSH;
}

/******************************Public*Routine******************************\
* wglPaletteChanged
*
* Check if the palette changed.
*
*    If the surface for the DC is palette managed we care about the
*    foreground realization, so, return iUniq
*
*    If the surface is not palette managed, return ulTime
*
\**************************************************************************/

ULONG APIENTRY wglPaletteChanged(__GLGENcontext *gengc,
                                 GLGENwindow *pwnd)
{
    ULONG ulRet = 0;
    HDC hdc;

    // Palette must stay fixed for DirectDraw after initialization
    if (gengc->dwCurrentFlags & GLSURF_DIRECTDRAW)
    {
        if (gengc->PaletteTimestamp == 0xffffffff)
        {
            return 0;
        }
        else
        {
            return gengc->PaletteTimestamp;
        }
    }

    hdc = gengc->gwidCurrent.hdc;
    
    // Technically we shouldn't be making these GDI calls while we
    // have a screen lock but currently it would be very difficult
    // to fix because we're actually invoking this routine in
    // glsrvGrabLock in order to ensure that we have stable information
    // while we have the lock
    // We don't seem to be having too many problems so for the moment
    // this will be commented out
    // CHECKSCREENLOCKOUT();

    if (pwnd)
    {
        PIXELFORMATDESCRIPTOR *ppfd = &gengc->gsurf.pfd;
        BYTE cBitsThreshold;

        // WM_PALETTECHANGED messages are sent for 8bpp on Win95 when the
        // palette is realized.  This allows us to update the palette time.
        //
        // When running WinNT on >= 8bpp or running Win95 on >= 16bpp,
        // WM_PALETTECHANGED is not sent so we need to manually examine
        // the contents of the logical palette and compare it with a previously
        // cached copy to look for a palette change.

        cBitsThreshold = ( dwPlatformId == VER_PLATFORM_WIN32_NT ) ? 8 : 16;

        if (((ppfd->cColorBits >= cBitsThreshold) &&
             (ppfd->iPixelType == PFD_TYPE_COLORINDEX)) )
        {
            if ( !gengc->ppalBuf )
            {
                UINT cjPal, cjRgb;

                // Allocate buffer space for *two* copies of the palette.
                // That way we don't need to dynamically allocate space
                // for temp storage of the palette.  Also,we don't need
                // to copy the current palette to the save buffer if we
                // keep two pointers (one for the temp storage and one for
                // the saved copy) and swap them.

                cjRgb = 0;
                cjPal = sizeof(LOGPALETTE) +
                    (MAXPALENTRIES * sizeof(PALETTEENTRY));

                gengc->ppalBuf = (LOGPALETTE *)
                    ALLOC((cjPal + cjRgb) * 2);

                if ( gengc->ppalBuf )
                {
                    // Setup the logical palette buffers.
                    
                    gengc->ppalSave = gengc->ppalBuf;
                    gengc->ppalTemp = (LOGPALETTE *)
                        (((BYTE *) gengc->ppalBuf) + cjPal);
                    gengc->ppalSave->palVersion = 0x300;
                    gengc->ppalTemp->palVersion = 0x300;

                    // How many palette entries?  Note that only the first
                    // MAXPALENTRIES are significant to generic OpenGL.  The
                    // rest are ignored.

                    gengc->ppalSave->palNumEntries =
                        (WORD) GetPaletteEntries(
                                GetCurrentObject(hdc, OBJ_PAL),
                                0, 0, (LPPALETTEENTRY) NULL
                                );
                    gengc->ppalSave->palNumEntries =
                        min(gengc->ppalSave->palNumEntries, MAXPALENTRIES);

                    gengc->ppalSave->palNumEntries =
                        (WORD) GetPaletteEntries(
                                GetCurrentObject(hdc, OBJ_PAL),
                                0, gengc->ppalSave->palNumEntries,
                                gengc->ppalSave->palPalEntry
                                );

                    // Since we had to allocate buffer, this must be the
                    // first time wglPaletteChanged was called for this
                    // context.

                    pwnd->ulPaletteUniq++;
                }
            }
            else
            {
                BOOL bNewPal = FALSE;   // TRUE if log palette is different

                // How many palette entries?  Note that only the first
                // MAXPALENTRIES are significant to generic OpenGL.  The
                // rest are ignored.
                
                gengc->ppalTemp->palNumEntries =
                    (WORD) GetPaletteEntries(
                            GetCurrentObject(hdc, OBJ_PAL),
                            0, 0, (LPPALETTEENTRY) NULL
                            );
                gengc->ppalTemp->palNumEntries =
                    min(gengc->ppalTemp->palNumEntries, MAXPALENTRIES);
                
                gengc->ppalTemp->palNumEntries =
                    (WORD) GetPaletteEntries(
                            GetCurrentObject(hdc, OBJ_PAL),
                            0, gengc->ppalTemp->palNumEntries,
                            gengc->ppalTemp->palPalEntry
                            );
                
                // If number of entries differ, know the palette has changed.
                // Otherwise, need to do the hard word of comparing each entry.
                
                ASSERTOPENGL(
                        sizeof(PALETTEENTRY) == sizeof(ULONG),
                        "wglPaletteChanged(): PALETTEENTRY should be 4 bytes\n"
                        );
                
                // If color table comparison already detected a change, no
                // need to do logpal comparison.
                //
                // However, we will still go ahead and swap logpal pointers
                // below because we want the palette cache to stay current.
                
                if ( !bNewPal )
                {
                    bNewPal = (gengc->ppalSave->palNumEntries != gengc->ppalTemp->palNumEntries);
                    if ( !bNewPal )
                    {
                        bNewPal = !LocalCompareUlongMemory(
                                gengc->ppalSave->palPalEntry,
                                gengc->ppalTemp->palPalEntry,
                                gengc->ppalSave->palNumEntries * sizeof(PALETTEENTRY)
                                );
                    }
                }
                
                // So, if palette is different, increment uniqueness and
                // update the saved copy.
                
                if ( bNewPal )
                {
                    LOGPALETTE *ppal;
                    
                    pwnd->ulPaletteUniq++;
                    
                    // Update saved palette by swapping pointers.
                    
                    ppal = gengc->ppalSave;
                    gengc->ppalSave = gengc->ppalTemp;
                    gengc->ppalTemp = ppal;
                }
            }
        }
    
        ulRet = pwnd->ulPaletteUniq;
    }

    return ulRet;
}

/******************************Public*Routine******************************\
* wglPaletteSize
*
* Return the size of the current palette
*
\**************************************************************************/

//!!!XXX -- make into a macro?
ULONG APIENTRY wglPaletteSize(__GLGENcontext *gengc)
{
    CHECKSCREENLOCKOUT();

    if (gengc->dwCurrentFlags & GLSURF_DIRECTDRAW)
    {
        DWORD dwCaps;
        LPDIRECTDRAWPALETTE pddp = NULL;
        HRESULT hr;
        
        if (gengc->gsurf.dd.gddsFront.pdds->lpVtbl->
            GetPalette(gengc->gsurf.dd.gddsFront.pdds, &pddp) != DD_OK ||
            pddp == NULL)
        {
            return 0;
        }

        hr = pddp->lpVtbl->GetCaps(pddp, &dwCaps);

        pddp->lpVtbl->Release(pddp);

        if (hr != DD_OK)
        {
            return 0;
        }

        if (dwCaps & DDPCAPS_1BIT)
        {
            return 1;
        }
        else if (dwCaps & DDPCAPS_2BIT)
        {
            return 4;
        }
        else if (dwCaps & DDPCAPS_4BIT)
        {
            return 16;
        }
        else if (dwCaps & DDPCAPS_8BIT)
        {
            return 256;
        }
        else
            return 0;
    }
    else
    {
        return GetPaletteEntries(GetCurrentObject(gengc->gwidCurrent.hdc,
                                                  OBJ_PAL), 0, 0, NULL);
    }
}

/******************************Public*Routine******************************\
* wglComputeIndexedColors
*
* Copy current index-to-color table to the supplied array.  Colors are
* formatted as specified in the current pixelformat and are put into the
* table as DWORDs (i.e., DWORD alignment) starting at the second DWORD.
* The first DWORD in the table is the number of colors in the table.
*
* History:
*  15-Dec-1994 -by- Gilman Wong [gilmanw]
* Ported from gdi\gre\wglsup.cxx.
\**************************************************************************/

BOOL APIENTRY wglComputeIndexedColors(__GLGENcontext *gengc, ULONG *rgbTable,
                                      ULONG cEntries)
{
    UINT cColors = 0;
    LPPALETTEENTRY lppe, lppeTable;
    UINT i;
    LPDIRECTDRAWPALETTE pddp = NULL;

    CHECKSCREENLOCKOUT();

    // first element in table is number of entries
    rgbTable[0] = min(wglPaletteSize(gengc), cEntries);

    lppeTable = (LPPALETTEENTRY)
                ALLOC(sizeof(PALETTEENTRY) * rgbTable[0]);

    if (lppeTable)
    {
        int rScale, gScale, bScale;
        int rShift, gShift, bShift;

        rScale = (1 << gengc->gsurf.pfd.cRedBits  ) - 1;
        gScale = (1 << gengc->gsurf.pfd.cGreenBits) - 1;
        bScale = (1 << gengc->gsurf.pfd.cBlueBits ) - 1;
        rShift = gengc->gsurf.pfd.cRedShift  ;
        gShift = gengc->gsurf.pfd.cGreenShift;
        bShift = gengc->gsurf.pfd.cBlueShift ;

        if (gengc->dwCurrentFlags & GLSURF_DIRECTDRAW)
        {
            if (gengc->gsurf.dd.gddsFront.pdds->lpVtbl->
                GetPalette(gengc->gsurf.dd.gddsFront.pdds, &pddp) != DD_OK ||
                pddp == NULL)
            {
                return 0;
            }
            
            if (pddp->lpVtbl->GetEntries(pddp, 0, 0,
                                         rgbTable[0], lppeTable) != DD_OK)
            {
                cColors = 0;
            }
            else
            {
                cColors = rgbTable[0];
            }
        }
        else
        {
            cColors = GetPaletteEntries(GetCurrentObject(gengc->gwidCurrent.hdc,
                                                         OBJ_PAL),
                                        0, rgbTable[0], lppeTable);
        }

        for (i = 1, lppe = lppeTable; i <= cColors; i++, lppe++)
        {
        // Whack the PALETTEENTRY color into proper color format.  Store as
        // ULONG.

            //!!!XXX -- use rounding?!?
            rgbTable[i] = (((ULONG)lppe->peRed   * rScale / 255) << rShift) |
                          (((ULONG)lppe->peGreen * gScale / 255) << gShift) |
                          (((ULONG)lppe->peBlue  * bScale / 255) << bShift);
        }

        FREE(lppeTable);
    }

    if (pddp != NULL)
    {
        pddp->lpVtbl->Release(pddp);
    }
           
    return(cColors != 0);
}

/******************************Public*Routine******************************\
* wglValidPixelFormat
*
* Determines if a pixelformat is usable with the DC specified.
*
\**************************************************************************/

BOOL APIENTRY wglValidPixelFormat(HDC hdc, int ipfd, DWORD dwObjectType,
                                  LPDIRECTDRAWSURFACE pdds,
                                  DDSURFACEDESC *pddsd)
{
    BOOL bRet = FALSE;
    PIXELFORMATDESCRIPTOR pfd, pfdDC;

    if ( wglDescribePixelFormat(hdc, ipfd, sizeof(pfd), &pfd) )
    {
        if ( dwObjectType == OBJ_DC )
        {
        // We have a display DC; make sure the pixelformat allows drawing
        // to the window.

            bRet = ( (pfd.dwFlags & PFD_DRAW_TO_WINDOW) != 0 );
            if (!bRet)
            {
                SetLastError(ERROR_INVALID_FLAGS);
            }
        }
        else if ( dwObjectType == OBJ_MEMDC )
        {
            // We have a memory DC.  Make sure pixelformat allows drawing
            // to a bitmap.

            if ( pfd.dwFlags & PFD_DRAW_TO_BITMAP )
            {
                // Make sure that the bitmap and pixelformat have the same
                // color depth.

                HBITMAP hbm;
                BITMAP bm;
                ULONG cBitmapColorBits;

                hbm = CreateCompatibleBitmap(hdc, 1, 1);
                if ( hbm )
                {
                    if ( GetObject(hbm, sizeof(bm), &bm) )
                    {
                        cBitmapColorBits = bm.bmPlanes * bm.bmBitsPixel;
                        
                        bRet = ( cBitmapColorBits == pfd.cColorBits );
                        if (!bRet)
                        {
                            SetLastError(ERROR_INVALID_FUNCTION);
                        }
                    }
                    else
                    {
                        WARNING("wglValidPixelFormat: GetObject failed\n");
                    }
                    
                    DeleteObject(hbm);
                }
                else
                {
                    WARNING("wglValidPixelFormat: Unable to create cbm\n");
                }
            }
        }
        else if (dwObjectType == OBJ_ENHMETADC)
        {
            // We don't know anything about what surfaces this
            // metafile will be played back on so allow any kind
            // of pixel format
            bRet = TRUE;
        }
        else if (dwObjectType == OBJ_DDRAW)
        {
            DDSCAPS ddscaps;
            LPDIRECTDRAWSURFACE pddsZ;
            DDSURFACEDESC ddsdZ;
            
            // We have a DDraw surface.

            // Check that DDraw is supported and that double buffering
            // is not defined.
            if ((pfd.dwFlags & PFD_SUPPORT_DIRECTDRAW) == 0 ||
                (pfd.dwFlags & PFD_DOUBLEBUFFER))
            {
                WARNING1("DDSurf pfd has bad flags 0x%08lX\n", pfd.dwFlags);
                SetLastError(ERROR_INVALID_FLAGS);
                return FALSE;
            }
            
            // We only understand 4 and 8bpp paletted formats plus RGB
            // We don't support alpha-only or Z-only surfaces
            if ((pddsd->ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED4 |
                                                   DDPF_PALETTEINDEXED8 |
                                                   DDPF_RGB)) == 0 ||
                (pddsd->ddpfPixelFormat.dwFlags & (DDPF_ALPHA |
                                                   DDPF_ZBUFFER)) != 0)
            {
                WARNING1("DDSurf ddpf has bad flags, 0x%08lX\n",
                         pddsd->ddpfPixelFormat.dwFlags);
                SetLastError(ERROR_INVALID_PIXEL_FORMAT);
                return FALSE;
            }

            if (DdPixelDepth(pddsd) != pfd.cColorBits)
            {
                WARNING2("DDSurf pfd cColorBits %d "
                         "doesn't match ddsd depth %d\n",
                         pfd.cColorBits, DdPixelDepth(pddsd));
                SetLastError(ERROR_INVALID_PIXEL_FORMAT);
                return FALSE;
            }

            // Check for alpha
            if (pfd.cAlphaBits > 0)
            {
                // Interleaved destination alpha is not supported.
                if (pddsd->ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS)
                {
                    WARNING("DDSurf has alpha pixels\n");
                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
                    return FALSE;
                }
            }

            // Check for an attached Z buffer
            memset(&ddscaps, 0, sizeof(ddscaps));
            ddscaps.dwCaps = DDSCAPS_ZBUFFER;
            if (pdds->lpVtbl->
                GetAttachedSurface(pdds, &ddscaps, &pddsZ) == DD_OK)
            {
                HRESULT hr;
                
                memset(&ddsdZ, 0, sizeof(ddsdZ));
                ddsdZ.dwSize = sizeof(ddsdZ);
                
                hr = pddsZ->lpVtbl->GetSurfaceDesc(pddsZ, &ddsdZ);
                
                pddsZ->lpVtbl->Release(pddsZ);

                if (hr != DD_OK)
                {
                    WARNING("Unable to get Z ddsd\n");
                    return FALSE;
                }

                // Ensure that the Z surface depth is the same as the
                // one in the pixel format
                if (pfd.cDepthBits !=
                    (BYTE)DdPixDepthToCount(ddsdZ.ddpfPixelFormat.
                                            dwZBufferBitDepth))
                {
                    WARNING2("DDSurf pfd cDepthBits %d doesn't match "
                             "Z ddsd depth %d\n", pfd.cDepthBits,
                             DdPixDepthToCount(ddsdZ.ddpfPixelFormat.
                                               dwZBufferBitDepth));
                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
                    return FALSE;
                }
            }
            else
            {
                // No Z so make sure the pfd doesn't ask for it
                if (pfd.cDepthBits > 0)
                {
                    WARNING("DDSurf pfd wants depth with no Z attached\n");
                    SetLastError(ERROR_INVALID_PIXEL_FORMAT);
                    return FALSE;
                }
            }

            bRet = TRUE;
        }
        else
        {
            WARNING("wglValidPixelFormat: not a valid DC!\n");
        }
    }
    else
    {
        WARNING("wglValidPixelFormat: wglDescribePixelFormat failed\n");
    }

    return bRet;
}

/******************************Public*Routine******************************\
* wglMakeScans
*
* Converts the visible rectangle list in the provided GLGENwindow to a
* scan-based data structure.  The scan-data is put into the GLGENwindow
* structure.
*
* Note: this function assumes that the rectangles are already organized
* top-down, left-right in scans.  This is true for Windows NT 3.5 and
* Windows 95.  This is because the internal representation of regions
* in both systems is already a scan-based structure.  When the APIs
* (such as GetRegionData) convert the scans to rectangles, the rectangles
* automatically have this property.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*   Note: if failure, clipping info is invalid.
*
* History:
*  05-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY wglMakeScans(GLGENwindow *pwnd)
{
    RECT *prc, *prcEnd;
    LONG lPrevScanTop;
    ULONG cScans = 0;
    UINT cjNeed;
    GLGENscan *pscan;
    LONG *plWalls;

    ASSERTOPENGL(
        pwnd->prgndat,
        "wglMakeScans(): NULL region data\n"
        );

    ASSERTOPENGL(
        pwnd->prgndat->rdh.iType == RDH_RECTANGLES,
        "wglMakeScans(): not RDH_RECTANGLES!\n"
        );

// Bail out if no rectangles.

    if (pwnd->prgndat->rdh.nCount == 0)
        return TRUE;

// First pass: determine the number of scans.

    lPrevScanTop = -(LONG) 0x7FFFFFFF;
    prc = (RECT *) pwnd->prgndat->Buffer;
    prcEnd = prc + pwnd->prgndat->rdh.nCount;

    for ( ; prc < prcEnd; prc++)
    {
        if (prc->top != lPrevScanTop)
        {
            lPrevScanTop = prc->top;
            cScans++;
        }
    }

// Determine the size needed: 1 GLGENscanData PLUS a GLGENscan per scan PLUS
// two walls per rectangle.

    cjNeed = offsetof(GLGENscanData, aScans) +
             cScans * offsetof(GLGENscan, alWalls) +
             pwnd->prgndat->rdh.nCount * sizeof(LONG) * 2;

// Allocate the scan structure.

    if ( cjNeed > pwnd->cjscandat || !pwnd->pscandat )
    {
        if ( pwnd->pscandat )
            FREE(pwnd->pscandat);

        pwnd->pscandat = ALLOC(pwnd->cjscandat = cjNeed);
        if ( !pwnd->pscandat )
        {
            WARNING("wglMakeScans(): memory failure\n");
            pwnd->cjscandat = 0;
            return FALSE;
        }
    }

// Second pass: fill the scan structure.

    pwnd->pscandat->cScans = cScans;

    lPrevScanTop = -(LONG) 0x7FFFFFFF;
    prc = (RECT *) pwnd->prgndat->Buffer;    // need to reset prc but prcEnd OK
    plWalls = (LONG *) pwnd->pscandat->aScans;
    pscan = (GLGENscan *) NULL;

    for ( ; prc < prcEnd; prc++ )
    {
    // Do we need to start a new scan?

        if ( prc->top != lPrevScanTop )
        {
        // Scan we just finished needs pointer to the next scan.  Next
        // will start just after this scan (which, conveniently enough,
        // plWalls is pointing at).

            if ( pscan )
                pscan->pNext = (GLGENscan *) plWalls;

            lPrevScanTop = prc->top;

        // Start the new span.

            pscan = (GLGENscan *) plWalls;
            pscan->cWalls = 0;
            pscan->top = prc->top;
            pscan->bottom = prc->bottom;
            plWalls = pscan->alWalls;
        }

        pscan->cWalls+=2;
        *plWalls++ = prc->left;
        *plWalls++ = prc->right;
    }

    if ( pscan )
        pscan->pNext = (GLGENscan *) NULL;  // don't leave ptr unitialized in
                                            // the last scan

#if DBG
    DBGLEVEL1(LEVEL_INFO, "\n-----\nwglMakeScans(): cScans = %ld\n", pwnd->pscandat->cScans);

    cScans = pwnd->pscandat->cScans;
    pscan = pwnd->pscandat->aScans;

    for ( ; cScans; cScans--, pscan = pscan->pNext )
    {
        LONG *plWalls = pscan->alWalls;
        LONG *plWallsEnd = plWalls + pscan->cWalls;

        DBGLEVEL3(LEVEL_INFO, "Scan: top = %ld, bottom = %ld, walls = %ld\n", pscan->top, pscan->bottom, pscan->cWalls);

        for ( ; plWalls < plWallsEnd; plWalls+=2 )
        {
            DBGLEVEL2(LEVEL_INFO, "\t%ld, %ld\n", plWalls[0], plWalls[1]);
        }
    }
#endif

    return TRUE;
}

/******************************Public*Routine******************************\
* wglGetClipList
*
* Gets the visible region in the form of a list of rectangles,
* for the window associated with the given window.  The data is placed
* in the GLGENwindow structure.
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  01-Dec-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY wglGetClipList(GLGENwindow *pwnd)
{
    UINT cj;
    RECT rc;

// Set clipping to empty.  If an error occurs getting clip information,
// all drawing will be clipped.

    pwnd->clipComplexity = CLC_RECT;
    pwnd->rclBounds.left   = 0;
    pwnd->rclBounds.top    = 0;
    pwnd->rclBounds.right  = 0;
    pwnd->rclBounds.bottom = 0;

// Make sure we have enough memory to cache the clip list.

    if (pwnd->pddClip->lpVtbl->
        GetClipList(pwnd->pddClip, NULL, NULL, &cj) == DD_OK)
    {
        if ( cj > pwnd->cjrgndat || !pwnd->prgndat )
        {
            if ( pwnd->prgndat )
                FREE(pwnd->prgndat);

            pwnd->prgndat = ALLOC(pwnd->cjrgndat = cj);
            if ( !pwnd->prgndat )
            {
                WARNING("wglGetClipList(): memory failure\n");
                pwnd->cjrgndat = 0;
                return FALSE;
            }
        }
    }
    else
    {
        WARNING("wglGetClipList(): clipper failed to return size\n");
        return FALSE;
    }

// Get the clip list (RGNDATA format).

    if ( pwnd->pddClip->lpVtbl->
         GetClipList(pwnd->pddClip, NULL, pwnd->prgndat, &cj) == DD_OK )
    {
    // Compose the scan version of the clip list.

        if (!wglMakeScans(pwnd))
        {
            WARNING("wglGetClipList(): scan conversion failed\n");
            return FALSE;
        }
    }
    else
    {
        WARNING("wglGetClipList(): clipper failed\n");
        return FALSE;
    }

// Fixup the protected portions of the window.

    ASSERT_WINCRIT(pwnd);
    
    {
        __GLGENbuffers *buffers;

    // Update rclBounds to match RGNDATA bounds.

        pwnd->rclBounds = *(RECTL *) &pwnd->prgndat->rdh.rcBound;

    // Update rclClient to match client area.  We cannot do this from the
    // information in RGNDATA as the bounds may be smaller than the window
    // client area.  We will have to call GetClientRect().

        GetClientRect(pwnd->gwid.hwnd, (LPRECT) &pwnd->rclClient);
        ClientToScreen(pwnd->gwid.hwnd, (LPPOINT) &pwnd->rclClient);
        pwnd->rclClient.right += pwnd->rclClient.left;
        pwnd->rclClient.bottom += pwnd->rclClient.top;

    //
    // Setup window clip complexity
    //
        if ( pwnd->prgndat->rdh.nCount > 1 )
        {
	    // Clip list will be used for clipping.
            pwnd->clipComplexity = CLC_COMPLEX;
        }
        else if ( pwnd->prgndat->rdh.nCount == 1 )
        {
            RECT *prc = (RECT *) pwnd->prgndat->Buffer;

        // Recently, DirectDraw has been occasionally returning rclBounds
        // set to the screen dimensions.  This is being investigated as a
        // bug on DDraw's part, but let us protect ourselves in any case.
        //
        // When there is only a single clip rectangle, it should be
        // the same as the bounds.

            pwnd->rclBounds = *((RECTL *) prc);

        // If bounds rectangle is smaller than client area, we need to
        // clip to the bounds rectangle.  Otherwise, clip to the window
        // client area.

            if ( (pwnd->rclBounds.left   <= pwnd->rclClient.left  ) &&
                 (pwnd->rclBounds.right  >= pwnd->rclClient.right ) &&
                 (pwnd->rclBounds.top    <= pwnd->rclClient.top   ) &&
                 (pwnd->rclBounds.bottom >= pwnd->rclClient.bottom) )
                pwnd->clipComplexity = CLC_TRIVIAL;
            else
                pwnd->clipComplexity = CLC_RECT;
        }
        else
        {
        // Clip count is zero.  Bounds should be an empty rectangle.

            pwnd->clipComplexity = CLC_RECT;

            pwnd->rclBounds.left   = 0;
            pwnd->rclBounds.top    = 0;
            pwnd->rclBounds.right  = 0;
            pwnd->rclBounds.bottom = 0;
        }

    // Finally, the window has changed, so change the uniqueness number.

        if ((buffers = pwnd->buffers))
        {
            buffers->WndUniq++;

        // Don't let it hit -1.  -1 is special and is used by
        // MakeCurrent to signal that an update is required

            if (buffers->WndUniq == -1)
                buffers->WndUniq = 0;
        }
    }

    return TRUE;
}

/******************************Public*Routine******************************\
* wglCleanupWindow
*
* Removes references to the specified window from
* all contexts by running through the list of RCs in the handle manager
* table.
*
* History:
*  05-Jul-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID APIENTRY wglCleanupWindow(GLGENwindow *pwnd)
{
    if (pwnd)
    {
    //!!!XXX -- For now remove reference from current context.  Need to
    //!!!XXX    scrub all contexts for multi-threaded cleanup to work.
    //!!!XXX    We need to implement a gengc tracking mechanism.

        __GLGENcontext *gengc = (__GLGENcontext *) GLTEB_SRVCONTEXT();

        if ( gengc && (gengc->pwndMakeCur == pwnd) )
        {
        // Found a victim.  Must NULL out the pointer both in the RC
        // and in the generic context.

            glsrvCleanupWindow(gengc, pwnd);
        }
    }
}

/******************************Public*Routine******************************\
* wglGetSystemPaletteEntries
*
* Internal version of GetSystemPaletteEntries.
*
* GetSystemPaletteEntries fails on some 4bpp devices.  This wgl version
* will detect the 4bpp case and supply the hardcoded 16-color VGA palette.
* Otherwise, it will pass the call on to GDI's GetSystemPaletteEntries.
*
* It is expected that this call will only be called in the 4bpp and 8bpp
* cases as it is not necessary for OpenGL to query the system palette
* for > 8bpp devices.
*
* History:
*  17-Aug-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

static PALETTEENTRY gapeVgaPalette[16] =
{
    { 0,   0,   0,    0 },
    { 0x80,0,   0,    0 },
    { 0,   0x80,0,    0 },
    { 0x80,0x80,0,    0 },
    { 0,   0,   0x80, 0 },
    { 0x80,0,   0x80, 0 },
    { 0,   0x80,0x80, 0 },
    { 0x80,0x80,0x80, 0 },
    { 0xC0,0xC0,0xC0, 0 },
    { 0xFF,0,   0,    0 },
    { 0,   0xFF,0,    0 },
    { 0xFF,0xFF,0,    0 },
    { 0,   0,   0xFF, 0 },
    { 0xFF,0,   0xFF, 0 },
    { 0,   0xFF,0xFF, 0 },
    { 0xFF,0xFF,0xFF, 0 }
};

UINT APIENTRY wglGetSystemPaletteEntries(
    HDC hdc,
    UINT iStartIndex,
    UINT nEntries,
    LPPALETTEENTRY lppe)
{
    int nDeviceBits;

    nDeviceBits = GetDeviceCaps(hdc, BITSPIXEL) * GetDeviceCaps(hdc, PLANES);

    if ( nDeviceBits == 4 )
    {
        if ( lppe )
        {
            nEntries = min(nEntries, (16 - iStartIndex));

            memcpy(lppe, &gapeVgaPalette[iStartIndex],
                   nEntries * sizeof(PALETTEENTRY));
        }
        else
            nEntries = 16;

        return nEntries;
    }
    else
    {
        return GetSystemPaletteEntries(hdc, iStartIndex, nEntries, lppe);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\pixelfmt.c ===
/******************************Module*Header*******************************\
* Module Name: pixelfmt.c
*
* This contains the pixel format functions.
*
* Created: 15-Dec-1994 00:28:39
* Author: Gilman Wong [gilmanw]   --   ported from gdi\gre\pixelfmt.cxx
*
* Copyright (c) 1994 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

//#define DBG_WINDOW
//#define DBG_REFCOUNTS

#ifdef _CLIENTSIDE_
// Need for glsbAttention declaration
#include "glsbcltu.h"
#include "glscreen.h"
#endif

#ifdef _MCD_
#include "mcd.h"
#endif

#define SAVE_ERROR_CODE(x)  SetLastError((x))

// Number of generic pixel formats.  There are 5 pixel depths (4,8,16,24,32).
// This is to convert BMF constants into # bits per pel

#define BMF_COUNT (BMF_32BPP+1)

ULONG gaulConvert[BMF_COUNT] =
{
    0,
    1,
    4,
    8,
    16,
    24,
    32
};

#define MIN_GENERIC_PFD  1
#define MAX_GENERIC_PFD  36

LRESULT CALLBACK
wglWndProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam);

#define PALETTE_WATCHER_CLASS __TEXT("Palette Watcher")
static ATOM aPaletteWatcherClass = 0;

DWORD tidPaletteWatcherThread = 0;
ULONG ulPaletteWatcherCount = 0;
HANDLE hPaletteWatcherThread = 0;
HWND hwndPaletteWatcher = 0;
LONG lPaletteWatcherUsers = 0;

/******************************Public*Routine******************************\
* pwndNew
*
* Allocate a new GLGENwindow, initialize it (from input structure), and
* insert it into the global linked list.
*
* Returns:
*   Pointer to structure if successful, NULL otherwise.
*
* History:
*  01-Nov-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

GLGENwindow * APIENTRY pwndNew(GLGENwindow *pwndInit)
{
    GLGENwindow *pwndRet = (GLGENwindow *) NULL;
    BOOL bDirectScreen = GLDIRECTSCREEN && pwndInit->gwid.hwnd;
    LPDIRECTDRAWCLIPPER pddClip = (LPDIRECTDRAWCLIPPER) NULL;

// If using direct access, retrieve or create a clipper object to track
// vis rgn changes.

    if (pwndInit->gwid.iType == GLWID_DDRAW)
    {
        HRESULT hr;
        
        hr = pwndInit->gwid.pdds->lpVtbl->
            GetClipper(pwndInit->gwid.pdds, &pddClip);
        if (hr != DD_OK && hr != DDERR_NOCLIPPERATTACHED)
        {
            return NULL;
        }
    }
        
    if ( !bDirectScreen ||
         pwndInit->gwid.iType == GLWID_DDRAW ||
         (GLSCREENINFO->pdd->lpVtbl->
          CreateClipper(GLSCREENINFO->pdd, 0, &pddClip, NULL) == DD_OK &&
          pddClip->lpVtbl->SetHWnd(pddClip, 0, pwndInit->gwid.hwnd) == DD_OK) )
    {
        pwndInit->pddClip = pddClip;
        
    // Allocate a new GLGENwindow.

        pwndRet = (GLGENwindow *)ALLOC(sizeof(GLGENwindow));
        if (pwndRet)
        {
            // Initialize from input structure.
            *pwndRet = *pwndInit;

            // Initialize per-window semaphore.
            __try
            {
                InitializeCriticalSection(&pwndRet->sem);
            }
            __except(EXCEPTION_EXECUTE_HANDLER)
            {
                FREE(pwndRet);
                pwndRet = NULL;
            }

            if (pwndRet)
            {
                // Set initial usage count to one
                pwndRet->lUsers = 1;

                // Insert into linked list.
                EnterCriticalSection(&gwndHeader.sem);
                {
                    pwndRet->pNext = gwndHeader.pNext;
                    gwndHeader.pNext = pwndRet;
                }
                LeaveCriticalSection(&gwndHeader.sem);
            }
        }
    }
    else
    {
       WARNING("pwndNew: Clipper setup failed\n");

       if (pddClip != NULL)
       {
           pddClip->lpVtbl->Release(pddClip);
       }
    }

#ifdef DBG_WINDOW
    if (pwndRet != NULL)
    {
        DbgPrint("Alloc window %p, type %d, hdc %p, hwnd %p, pdds %p\n",
                 pwndRet, pwndRet->gwid.iType, pwndRet->gwid.hdc,
                 pwndRet->gwid.hwnd, pwndRet->gwid.pdds);
    }
#endif
    
    return pwndRet;
}

/******************************Public*Routine******************************\
*
* pwndUnsubclass
*
* Removes OpenGL's subclassing set when windows are created
*
* History:
*  Mon May 20 14:05:23 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void pwndUnsubclass(GLGENwindow *pwnd, BOOL bProcessExit)
{
    WNDPROC wpCur;
        
    // We only restore the original WNDPROC if the current WNDPROC
    // is one of ours.  This prevents us from stomping on the WNDPROC
    // pointer if somebody else has changed it.

    if ((pwnd->ulFlags & GLGENWIN_OTHERPROCESS) == 0)
    {
        wpCur = (WNDPROC)GetWindowLongPtr(pwnd->gwid.hwnd, GWLP_WNDPROC);
        if (wpCur == wglWndProc)
        {
            SetWindowLongPtr(pwnd->gwid.hwnd, GWLP_WNDPROC,
                          (LONG_PTR) pwnd->pfnOldWndProc);
        }
    }
    else
    {
        // Clean up the palette watcher window if this is the last user.
        EnterCriticalSection(&gcsPaletteWatcher);

        ASSERTOPENGL(lPaletteWatcherUsers > 0,
                     "lPaletteWatcherUsers too low\n");
        
        if (--lPaletteWatcherUsers == 0)
        {
            if( PostMessage(hwndPaletteWatcher, WM_CLOSE, 0, 0) == FALSE)
            {
                DbgPrint( "PostMessage to hwnd: %08x failed with error: %08x\n",
                          hwndPaletteWatcher, GetLastError() );

                // Check if the thread is still alive
                
                if( WaitForSingleObject( hPaletteWatcherThread, 100 ) !=
                    WAIT_OBJECT_0 )
                {
                    // This means that the thread is still alive and 
                    // somehow the window is invalid.
                    // Kill this thread or else GL will keep waiting.
                    TerminateThread( hPaletteWatcherThread, 0 );
                }
                
                // Should be safe to do. If the thread is alive, it 
                // was killed above else, someone else killed it
                tidPaletteWatcherThread = 0;
            }
            CloseHandle( hPaletteWatcherThread );
            
            // We don't want to zero the palette watcher's thread ID
            // at process exit because we use it to wait for the
            // thread to die.
            if (!bProcessExit)
            {
                tidPaletteWatcherThread = 0;
            }
        }
        
        LeaveCriticalSection(&gcsPaletteWatcher);
    }
}

/******************************Public*Routine******************************\
* pwndFree
*
* Frees the specified GLGENwindow.
*
* Returns:
*   NULL if successful, pointer to structure otherwise
*
* History:
*  07-Nov-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

GLGENwindow * APIENTRY pwndFree(GLGENwindow *pwndVictim, BOOL bProcessExit)
{
    BOOL bDirectScreen = GLDIRECTSCREEN && pwndVictim->gwid.hwnd;

#ifdef DBG_WINDOW
    DbgPrint("Free  window %p\n", pwndVictim);
#endif

    // Check for a stray screen lock and release if necessary.

    if (pwndVictim->ulFlags & GLGENWIN_DIRECTSCREEN)
        EndDirectScreenAccess(pwndVictim);

    // Free clipper object.

    if (bDirectScreen)
    {
        pwndVictim->pddClip->lpVtbl->Release(pwndVictim->pddClip);
    }

    // Cleanup visible region caches if they exist.

    if ( pwndVictim->prgndat )
        FREE(pwndVictim->prgndat);

    if ( pwndVictim->pscandat )
        FREE(pwndVictim->pscandat);
    
    // Restore original WNDPROC in window.
    if (pwndVictim->gwid.hwnd != NULL)
        pwndUnsubclass(pwndVictim, bProcessExit);

    // Cleanup GLGENlayers.

    if (pwndVictim->plyr)
    {
        int i;

        for (i = 0; i < 15; i++)
        {
            if (pwndVictim->plyr->overlayInfo[i])
                FREE(pwndVictim->plyr->overlayInfo[i]);

            if (pwndVictim->plyr->underlayInfo[i])
                FREE(pwndVictim->plyr->underlayInfo[i]);
        }

        FREE(pwndVictim->plyr);
    }

    // Notify MCD that this window has gone away
    if (pwndVictim->dwMcdWindow != 0)
    {
        GenMcdDestroyWindow(pwndVictim);
    }
        
    // Delete victim.

    DeleteCriticalSection(&pwndVictim->sem);
    FREE(pwndVictim);

    return NULL;
}

/******************************Public*Routine******************************\
*
* pwndCleanup
*
* Does all cleanup necessary for window destruction
*
* History:
*  Mon Mar 18 17:30:49 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void APIENTRY pwndCleanup(GLGENwindow *pwndVictim)
{
    GLGENwindow *pwnd, *pwndPrev;
#if DBG
    ULONG ulLoops;
#endif

#ifdef DBG_WINDOW
    DbgPrint("Clean window %p\n", pwndVictim);
#endif
    
    EnterCriticalSection(&gwndHeader.sem);

    // Search for victim.  Maintain a prev pointer so we can do
    // removal from linked list.

    for (
         pwndPrev = &gwndHeader, pwnd = pwndPrev->pNext;
         pwnd != &gwndHeader;
         pwndPrev = pwnd, pwnd = pwndPrev->pNext
         )
    {
        if (pwnd == pwndVictim)
            break;
    }

    // If victim was found, take it out.

    if (pwnd == pwndVictim)
    {
        // Excise victim from linked list.
        
        pwndPrev->pNext = pwnd->pNext;
    }
    
    LeaveCriticalSection(&gwndHeader.sem);

    if (pwnd == NULL)
    {
        WARNING("pwndFree: pwndVictim not found in list\n");
        return;
    }

    // If victim was found, it's out of the list so nobody
    // new can get access to it.
            
    // Wait for all current accessors to go away before cleaning up
    // the window

#if DBG
    ulLoops = 0;
#endif
    
    for (;;)
    {
        if (pwndVictim->lUsers == 1)
        {
            break;
        }

#if DBG
        if (++ulLoops == 1000)
        {
            DbgPrint("Spinning on window %p\n", pwndVictim);
#ifdef DBG_WINDOW
            DebugBreak();
#endif
        }
#endif
        
        // Wait on the critical section as a delay
        // Acquiring it doesn't guarantee that we're the last
        // accessor, but it does kill time in the case where
        // another accessor is already holding it
        EnterCriticalSection(&pwndVictim->sem);
        LeaveCriticalSection(&pwndVictim->sem);

        // Allow other threads time to run so we don't starve
        // anybody while we're waiting
        Sleep(0);
    }

    if (pwndVictim->buffers != NULL)
    {
        __glGenFreeBuffers(pwndVictim->buffers);
        wglCleanupWindow(pwndVictim);
    }
    
    if (pwndFree(pwndVictim, FALSE))
        WARNING("window deletion failed\n");
}

/******************************Public*Routine******************************\
* vCleanupWnd
*
* Removes and deletes all GLGENwindow structures from the linked list.
* Must *ONLY* be called from process detach (GLUnInitializeProcess).
*
* History:
*  25-Jul-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID APIENTRY vCleanupWnd()
{
    GLGENwindow *pwndNext;
    
    EnterCriticalSection(&gwndHeader.sem);

    while ( gwndHeader.pNext != &gwndHeader )
    {
        pwndNext = gwndHeader.pNext->pNext;
        pwndFree(gwndHeader.pNext, TRUE);
        gwndHeader.pNext = pwndNext;
    }

    LeaveCriticalSection(&gwndHeader.sem);

    // Wait for the palette watcher thread to die.  This ensures
    // that the palette watcher critical section can be deleted
    // safely in process detach.
    // We don't use a critical section at this point because of
    // the special critsec rules during DLL detach processing.
    while (tidPaletteWatcherThread != 0)
    {
        Sleep(50);
    }
    // Give the palette watcher thread some time to exit after
    // clearing the thread ID.
    Sleep(50);
}

/******************************Public*Routine******************************\
* pwndGetFromHWND
*
* Finds the corresponding GLGENwindow for the given window handle.
*
* Returns:
*   Pointer to GLGENwindow if sucessful; NULL otherwise.
*
* History:
*  19-Oct-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

GLGENwindow * APIENTRY pwndGetFromHWND(HWND hwnd)
{
    GLGENwindow *pwndRet = (GLGENwindow *) NULL;
    GLGENwindow *pwnd = (GLGENwindow *) NULL;

    EnterCriticalSection(&gwndHeader.sem);
    {
        for (pwnd = gwndHeader.pNext; pwnd != &gwndHeader; pwnd = pwnd->pNext)
            if (pwnd->gwid.hwnd == hwnd)
            {
                pwndRet = pwnd;
                InterlockedIncrement(&pwnd->lUsers);
                break;
            }
    }
    LeaveCriticalSection(&gwndHeader.sem);

#ifdef DBG_REFCOUNTS
    if (pwndRet != 0)
    {
        DbgPrint("GetHWND %p to %d\n", pwndRet, pwndRet->lUsers);
    }
#endif
    
    return pwndRet;
}

/******************************Public*Routine******************************\
* pwndGetFromMemDC
*
* Finds the corresponding GLGENwindow for the given mem DC handle.
*
* Returns:
*   Pointer to GLGENwindow if sucessful; NULL otherwise.
*
* History:
*  21-Jan-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

GLGENwindow * APIENTRY pwndGetFromMemDC(HDC hdcMem)
{
    GLGENwindow *pwndRet = (GLGENwindow *) NULL;
    GLGENwindow *pwnd = (GLGENwindow *) NULL;

    EnterCriticalSection(&gwndHeader.sem);
    {
        for (pwnd = gwndHeader.pNext; pwnd != &gwndHeader; pwnd = pwnd->pNext)
        {
            // If the pwnd has an HWND then the DC used at its
            // creation was associated with a window.  If we're
            // in this routine, though, that means hdcMem is
            // not associated with a window, so there's been
            // a reuse of the HDC handle and even though
            // we match DCs we can't return the pwnd.
            
            if (pwnd->gwid.hdc == hdcMem && pwnd->gwid.hwnd == NULL)
            {
                pwndRet = pwnd;
                InterlockedIncrement(&pwndRet->lUsers);
                break;
            }
        }
    }
    LeaveCriticalSection(&gwndHeader.sem);

#ifdef DBG_REFCOUNTS
    if (pwndRet != 0)
    {
        DbgPrint("GetDC   %p to %d\n", pwndRet, pwndRet->lUsers);
    }
#endif
    
    return pwndRet;
}

/******************************Public*Routine******************************\
*
* pwndGetFromDdraw
*
* Looks up a window by its DirectDraw surface
*
* History:
*  Wed Aug 28 18:15:40 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

GLGENwindow *pwndGetFromDdraw(LPDIRECTDRAWSURFACE pdds)
{
    GLGENwindow *pwndRet = (GLGENwindow *) NULL;
    GLGENwindow *pwnd = (GLGENwindow *) NULL;

    EnterCriticalSection(&gwndHeader.sem);
    {
        for (pwnd = gwndHeader.pNext; pwnd != &gwndHeader; pwnd = pwnd->pNext)
            if (pwnd->gwid.pdds == pdds)
            {
                pwndRet = pwnd;
                InterlockedIncrement(&pwndRet->lUsers);
                break;
            }
    }
    LeaveCriticalSection(&gwndHeader.sem);

#ifdef DBG_REFCOUNTS
    if (pwndRet != 0)
    {
        DbgPrint("GetDD   %p to %d\n", pwndRet, pwndRet->lUsers);
    }
#endif
    
    return pwndRet;
}

/******************************Public*Routine******************************\
* pwndGetFromID
*
* Finds the corresponding GLGENwindow for the given window ID.
*
* Returns:
*   Pointer to GLGENwindow if sucessful; NULL otherwise.
*
* History:
*  19-Oct-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

GLGENwindow * APIENTRY pwndGetFromID(GLWINDOWID *pgwid)
{
    GLGENwindow *pwndRet = (GLGENwindow *) NULL;

    switch (pgwid->iType)
    {
    case GLWID_HWND:
        pwndRet = pwndGetFromHWND(pgwid->hwnd);
        break;
    case GLWID_HDC:
        pwndRet = pwndGetFromMemDC(pgwid->hdc);
        break;
    case GLWID_DDRAW:
        pwndRet = pwndGetFromDdraw(pgwid->pdds);
        break;
    }

    return pwndRet;
}

/******************************Public*Routine******************************\
*
* pwndRelease
*
* Decrements the user count of a window
*
* History:
*  Mon Mar 18 19:35:28 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#if DBG
void APIENTRY pwndRelease(GLGENwindow *pwnd)
{
    ASSERTOPENGL(pwnd->lUsers > 0, "Decrement lUsers below zero\n");
    
    InterlockedDecrement(&pwnd->lUsers);
    
#ifdef DBG_REFCOUNTS
    DbgPrint("Release %p to %d\n", pwnd, pwnd->lUsers);
#endif
}
#endif

/******************************Public*Routine******************************\
*
* pwndUnlock
*
* Releases an owner of a window
*
* History:
*  Mon Mar 18 17:25:56 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void APIENTRY pwndUnlock(GLGENwindow *pwnd, __GLGENcontext *gengc)
{
    ASSERTOPENGL(pwnd != NULL, "Unlocking NULL window\n");

    LEAVE_WINCRIT_GC(pwnd, gengc);
    pwndRelease(pwnd);
}


/******************************Public*Routine******************************\
*
* ENTER_WINCRIT_GC
* LEAVE_WINCRIT_GC
*
* Window lock tracking routines.  The pwnd and gengc are validated
* and updated to reflect current locks.
*
* If the gengc is non-NULL then recursion is not allowed.  This is
* to prevent difficulties with maintaining gengc->pwndLocked correctly
* during recursion.  Recursing with gengc == NULL is not a problem.
*
* No ASSERTOPENGL usage so these can be enabled on free builds.
*
* History:
*  Wed Jul 02 12:57:26 1997	-by-	Drew Bliss [drewb]
*
\**************************************************************************/

void ENTER_WINCRIT_GC(GLGENwindow *pwnd, __GLGENcontext *gengc)
{
    EnterCriticalSection(&pwnd->sem);

    if (pwnd->owningThread == 0)
    {
#if DBG || defined(TRACK_WINCRIT)
        if (pwnd->lockRecursion != 0)
        {
            DbgPrint("Unowned window 0x%08lX has recursion count %d\n",
                     pwnd, pwnd->lockRecursion);
            DebugBreak();
        }
        if (pwnd->gengc != NULL)
        {
            DbgPrint("Unowned window 0x%08lX has gengc 0x%08lX\n",
                     pwnd, pwnd->gengc);
            DebugBreak();
        }
        if (gengc != NULL && gengc->pwndLocked != NULL)
        {
            DbgPrint("gengc 0x%08lX has pwnd 0x%08lX while locking 0x%08lX\n",
                     gengc, gengc->pwndLocked, pwnd);
            DebugBreak();
        }
#endif

        pwnd->owningThread = GetCurrentThreadId();
        if (gengc != NULL)
        {
            gengc->pwndLocked = pwnd;
            pwnd->gengc = gengc;
        }
    }
    else
    {
        // Make sure this thread is really the one holding the lock.
        ASSERT_WINCRIT(pwnd);
        
#if DBG || defined(TRACK_WINCRIT)
        // Recursion is only allowed with gengc == NULL.
        if (gengc != NULL)
        {
            DbgPrint("Window 0x%08lX recursing with gengc 0x%08lX\n",
                     pwnd, gengc);
            DebugBreak();
        }
#endif
    }

    pwnd->lockRecursion++;
}

void LEAVE_WINCRIT_GC(GLGENwindow *pwnd, __GLGENcontext *gengc)
{
    ASSERT_WINCRIT(pwnd);
    
#if 0
// Currently turned off because of difference in RTL_CRITICAL_SECTION
// RecursionCount between x86 and Alpha
#if !defined(_WIN95_) && (DBG || defined(TRACK_WINCRIT))
    // Check and make sure that our tracking information is following
    // what the system thinks.
    if (pwnd->sem.OwningThread != (HANDLE)pwnd->owningThread ||
        (DWORD)pwnd->sem.RecursionCount != pwnd->lockRecursion)
    {
        DbgPrint("pwnd 0x%08lX critsec information mismatch\n", pwnd);
        DebugBreak();
    }
#endif
#endif

#if DBG || defined(TRACK_WINCRIT)
    if (gengc != NULL)
    {
        if (pwnd->gengc != gengc || gengc->pwndLocked != pwnd)
        {
            DbgPrint("pwnd 0x%08lX:%08lX mismatch with gengc 0x%08lX:%08lX\n",
                     pwnd, pwnd->gengc, gengc, gengc->pwndLocked);
            DebugBreak();
        }
        if (pwnd->lockRecursion != 1)
        {
            DbgPrint("gengc 0x%08lX leaving window 0x%08lX with "
                     "recursion count of %d\n",
                     gengc, pwnd, pwnd->lockRecursion);
            DebugBreak();
        }
    }
#endif
    
    if (--pwnd->lockRecursion == 0)
    {
        if (gengc != NULL)
        {
            gengc->pwndLocked = NULL;
        }

        pwnd->gengc = NULL;
        pwnd->owningThread = 0;
    }
    
    LeaveCriticalSection(&pwnd->sem);
}

/******************************Public*Routine******************************\
*
* wglValidateWindows
*
* Walks the window list and prunes away any DC-based windows with
* invalid DCs.  This is necessary because, unlike window-based
* windows, we usually aren't notified when a memory DC goes away
* so if it has a window it just hangs around
*
* History:
*  Thu May 02 17:44:23 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void APIENTRY wglValidateWindows(void)
{
    GLGENwindow *pwnd, *pwndNext;
    BOOL bValid;

    EnterCriticalSection(&gwndHeader.sem);
    for (pwnd = gwndHeader.pNext; pwnd != &gwndHeader; pwnd = pwndNext)
    {
        pwndNext = pwnd->pNext;

        switch(pwnd->gwid.iType)
        {
        case GLWID_HDC:
            bValid = GetObjectType(pwnd->gwid.hdc) != 0;
            break;
            
        case GLWID_DDRAW:
            // Better validation?  Not really necessary since properly
            // behaved apps will have the genwin cleaned up on
            // context destruction.
            bValid = !IsBadReadPtr(pwnd->gwid.pdds, sizeof(void *)) &&
                *(void **)pwnd->gwid.pdds == pwnd->pvSurfaceVtbl;
            break;
            
        default:
            // No validation for HWNDs necessary
            bValid = TRUE;
            break;
        }

        if (!bValid)
        {
            // Increment so users count is one
            InterlockedIncrement(&pwnd->lUsers);
            pwndCleanup(pwnd);
        }
    }
    LeaveCriticalSection(&gwndHeader.sem);
}

/******************************Public*Routine******************************\
* plyriGet
*
* Returns the GLGENlayerInfo for the specified layer plane from the pwnd.
* If it doesn't yet exist, the GLGENlayer and/or GLGENlayerInfo structure(s)
* are allocated.
*
* Returns:
*   A non-NULL pointer if successful; NULL otherwise.
*
* History:
*  16-May-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

GLGENlayerInfo * APIENTRY plyriGet(GLGENwindow *pwnd, HDC hdc, int iLayer)
{
    GLGENlayerInfo *plyriRet = (GLGENlayerInfo * ) NULL;
    GLGENlayerInfo **pplyri;

    ASSERTOPENGL(pwnd, "plyriGet: bad pwnd\n");

// Allocate plyr if needed.

    if (!pwnd->plyr)
    {
        pwnd->plyr = (GLGENlayers *) ALLOCZ(sizeof(GLGENlayers));

        if (!pwnd->plyr)
        {
            WARNING("plyriGet: alloc failed (GLGENlayers)\n");
            goto plyriGet_exit;
        }
    }

// Get info for the specified layer (positive values are overlay planes,
// negative values are underlay planes).

    if (iLayer > 0)
        pplyri = &pwnd->plyr->overlayInfo[iLayer - 1];
    else if (iLayer < 1)
        pplyri = &pwnd->plyr->underlayInfo[(-iLayer) - 1];
    else
    {
        WARNING("plyriGet: no layer plane info for main plane!\n");
        goto plyriGet_exit;
    }

// Allocate plyri if needed.

    if (!(*pplyri))
    {
        LAYERPLANEDESCRIPTOR lpd;

        if (!wglDescribeLayerPlane(hdc, pwnd->ipfd, iLayer, sizeof(lpd), &lpd))
        {
            WARNING("plyriGet: wglDescribeLayerPlane failed\n");
            goto plyriGet_exit;
        }

        *pplyri = (GLGENlayerInfo *)
            ALLOC((sizeof(COLORREF) * (1 << lpd.cColorBits))
                       + sizeof(GLGENlayerInfo));


        if (*pplyri)
        {
            int i;

        // Initialize the new GLGENlayerInfo.
        // Note that the palette is initialized with all white colors.

            (*pplyri)->cPalEntries = 1 << lpd.cColorBits;
            for (i = 0; i < (*pplyri)->cPalEntries; i++)
                (*pplyri)->pPalEntries[i] = RGB(255, 255, 255);
        }
        else
        {
            WARNING("plyriGet: alloc failed (GLGENlayerInfo)\n");
            goto plyriGet_exit;
        }
    }

// Success.

    plyriRet = *pplyri;

plyriGet_exit:

    return plyriRet;
}

/******************************Public*Routine******************************\
* GetScreenRect
*
* Get the screen rectangle by accessing the virtual screen metrics. 
*
* If the system does not understand multimon, such as old Win95 or NT,
* just use the device caps.  This code technically isn't necessary but
* it's useful.
*
\**************************************************************************/

static void GetScreenRect( HDC hdc, LPRECTL pRect )
{
    // If SM_CMONITORS is not understood the system returns zero,
    // so this if test works for both old and new systems.
    if (GetSystemMetrics(SM_CMONITORS) > 1)
    {
        pRect->left   = GetSystemMetrics( SM_XVIRTUALSCREEN );
        pRect->top    = GetSystemMetrics( SM_YVIRTUALSCREEN );
        pRect->right  = pRect->left + GetSystemMetrics( SM_CXVIRTUALSCREEN );
        pRect->bottom = pRect->top  + GetSystemMetrics( SM_CYVIRTUALSCREEN );
    }
    else
    {
        pRect->left   = 0;
        pRect->top    = 0;
        pRect->right  = GetDeviceCaps(hdc, HORZRES);
        pRect->bottom = GetDeviceCaps(hdc, VERTRES);
    }
}

/******************************Public*Routine******************************\
* bClipToScreen(prclDst, prclSrc)
*
* Clip source rectangle to screen bounds and store in destination rectangle.
*
* Returns:
*   TRUE if resultant prclDst == prclSrc; FALSE otherwise.
*
\**************************************************************************/

BOOL bClipToScreen(RECTL *prclDst, RECTL *prclSrc)
{
    BOOL bRet;
    HDC hdc;

    if (hdc = GetDC(NULL))
    {
        RECTL rclScreen;

        GetScreenRect( hdc, &rclScreen );

        prclDst->left   = max(prclSrc->left  , rclScreen.left  );
        prclDst->top    = max(prclSrc->top   , rclScreen.top   );
        prclDst->right  = min(prclSrc->right , rclScreen.right );
        prclDst->bottom = min(prclSrc->bottom, rclScreen.bottom);

        if ((prclDst->left >= prclDst->right) ||
            (prclDst->top >= prclDst->bottom))
        {
            prclDst->left   = 0;
            prclDst->top    = 0;
            prclDst->right  = 0;
            prclDst->bottom = 0;
        }

        ReleaseDC(NULL, hdc);
    }
    else
    {
        prclDst->left   = 0;
        prclDst->top    = 0;
        prclDst->right  = 0;
        prclDst->bottom = 0;
    }

    if ((prclDst->left   == prclSrc->left  ) &&
        (prclDst->top    == prclSrc->top   ) &&
        (prclDst->right  == prclSrc->right ) &&
        (prclDst->bottom == prclSrc->bottom))
        bRet = TRUE;
    else
        bRet = FALSE;

    return bRet;
}

/******************************Public*Routine******************************\
*
* PaletteWatcherProc
*
* Window proc for the palette watcher
*
* History:
*  Mon Oct 14 15:29:10 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

LRESULT WINAPI PaletteWatcherProc(HWND hwnd, UINT uiMsg,
                                  WPARAM wpm, LPARAM lpm)
{
    switch(uiMsg)
    {
    case WM_PALETTECHANGED:
        InterlockedIncrement((LONG *)&ulPaletteWatcherCount);
        return 0;
        
    default:
        return DefWindowProc(hwnd, uiMsg, wpm, lpm);
    }
}

/******************************Public*Routine******************************\
*
* PaletteWatcher
*
* Thread routine for the palette change monitor.  Creates a hidden
* top level window and looks for WM_PALETTECHANGED.
*
* History:
*  Mon Oct 14 15:16:02 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

DWORD WINAPI PaletteWatcher(LPVOID pvArg)
{
    HWND hwnd;

    hwnd = CreateWindow(PALETTE_WATCHER_CLASS,
                        PALETTE_WATCHER_CLASS,
                        WS_OVERLAPPED,
                        0, 0, 1, 1,
                        NULL,
                        NULL,
                        (HINSTANCE)GetModuleHandle(NULL),
                        NULL);
    if (hwnd != NULL)
    {
        HDC hdc;
        HPALETTE hpal;

        // Select a palette into the window DC.  This is necessary
        // to get around an optimization introduced into NT5 where
        // WM_PALETTECHANGED is only sent to windows that have selected
        // a palette.
        
        hpal = NULL;
        
        hdc = GetDC(hwnd);
        if (hdc != NULL)
        {
            hpal = SelectPalette(hdc, GetStockObject(DEFAULT_PALETTE), FALSE);
            ReleaseDC(hwnd, hdc);
        }

        if (hpal == NULL)
        {
            goto EH_Exit;
        }
            
        hwndPaletteWatcher = hwnd;
        
        for (;;)
        {
            MSG msg;

            if (GetMessage(&msg, hwnd, 0, 0) > 0)
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
            else
            {
                break;
            }
        }

    EH_Exit:
        DestroyWindow(hwnd);
        hwndPaletteWatcher = 0;
    }

    EnterCriticalSection(&gcsPaletteWatcher);
        
    // Some kind of problem occurred or this thread is dying.
    // Indicate that this thread is going away and that a
    // new watcher needs to be created.
    if (tidPaletteWatcherThread == GetCurrentThreadId())
    {
        tidPaletteWatcherThread = 0;
    }
        
    LeaveCriticalSection(&gcsPaletteWatcher);
    
    return 0;
}

/******************************Public*Routine******************************\
*
* StartPaletteWatcher
*
* Spins up a thread to watch for palette change events
*
* History:
*  Mon Oct 14 15:11:35 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

BOOL StartPaletteWatcher(void)
{
    BOOL bRet;
    
    EnterCriticalSection(&gcsPaletteWatcher);

    bRet = FALSE;
    if (tidPaletteWatcherThread == 0)
    {
        HANDLE h;

        if (aPaletteWatcherClass == 0)
        {
            WNDCLASS wc;

            wc.style = 0;
            wc.lpfnWndProc = PaletteWatcherProc;
            wc.cbClsExtra = 0;
            wc.cbWndExtra = 0;
            wc.hInstance = (HINSTANCE)GetModuleHandle(NULL);
            wc.hIcon = NULL;
            wc.hCursor = NULL;
            wc.hbrBackground = NULL;
            wc.lpszMenuName = NULL;
            wc.lpszClassName = PALETTE_WATCHER_CLASS;

            aPaletteWatcherClass = RegisterClass(&wc);
        }
        
        if (aPaletteWatcherClass != 0)
        {
            h = CreateThread(NULL, 4096, PaletteWatcher,
                             NULL, 0, &tidPaletteWatcherThread);
            if (h != NULL)
            {
                hPaletteWatcherThread = h;
                bRet = TRUE;
            }
        }
    }
    else
    {
        bRet = TRUE;
    }

    if (bRet)
    {
        lPaletteWatcherUsers++;
    }
    
    LeaveCriticalSection(&gcsPaletteWatcher);
    
    // Make sure that the Palette watcher window is created.
    // Dont need to be in the CritSec for this.
    while( (hwndPaletteWatcher == 0) && 
           (tidPaletteWatcherThread != 0) ) Sleep( 100 );

    return bRet;
}

/******************************Public*Routine******************************\
* wglWndProc
*
* Handle window events for keeping GLGENwindows current
*
* History:
*  19-Oct-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

LRESULT CALLBACK
wglWndProc(HWND hwnd, UINT uiMsg, WPARAM wParam, LPARAM lParam)
{
    GLGENwindow *pwnd;
    LRESULT lRet = 0;
    WORD width, height;
    __GLGENcontext *gengc;

    pwnd = pwndGetFromHWND(hwnd);

    if (pwnd)
    {
        __GLGENbuffers *buffers = (__GLGENbuffers *) NULL;
        // Cache old WNDPROC because we may delete pwnd
        WNDPROC pfnWndProc = pwnd->pfnOldWndProc;

        // If WM_NCDESTROY, do OpenGL housekeeping after
        // calling original WndProc.
        // NOTE - We shouldn't really need this special case.
        // It's present in order to allow apps to do things like
        // wglDeleteContext in NCDESTROY which wouldn't work if
        // we cleaned up the window before we passed on the message
        // This used to be done in WM_DESTROY where apps do work,
        // but now that it's on NCDESTROY it's much less likely that
        // an app is doing anything.  We preserved the old behavior
        // for safety, though.

        if (uiMsg == WM_NCDESTROY)
        {
            // Subclassing is supposed to be removed during NCDESTROY
            // processing and order is important.  Remove our
            // subclassing before passing on the message.
            pwndUnsubclass(pwnd, FALSE);

            if (pfnWndProc)
            {
                lRet = CallWindowProc(pfnWndProc, hwnd,
                                      uiMsg, wParam, lParam);
            }
        }

    // OpenGL housekeeping in response to windowing system messages.

        switch (uiMsg)
        {
            case WM_SIZE:
                width  = LOWORD(lParam);
                height = HIWORD(lParam);
                gengc = (__GLGENcontext *)GLTEB_SRVCONTEXT();

                // Use the non-gc enter to allow recursion.
                ENTER_WINCRIT(pwnd);
                {
                    POINT pt;
                    
                    // Convert client coordinates to screen coordinates
                    // as genwin information is always in screen coordinates.
                    // The given lParam information may be parent-relative
                    // for child windows so it can't be used directly.
                    pt.x = 0;
                    pt.y = 0;
                    ClientToScreen(hwnd, &pt);

                    pwnd->rclClient.left   = pt.x;
                    pwnd->rclClient.right  = pt.x + width;
                    pwnd->rclClient.top    = pt.y;
                    pwnd->rclClient.bottom = pt.y + height;

#if 0
                    DbgPrint("size %d,%d - %d,%d\n",
                             pwnd->rclClient.left,
                             pwnd->rclClient.top,
                             pwnd->rclClient.right,
                             pwnd->rclClient.bottom);
#endif
                    
                    // At least clip to screen.

                    if (bClipToScreen(&pwnd->rclBounds,
                                      &pwnd->rclClient))
                        pwnd->clipComplexity = CLC_TRIVIAL;
                    else
                        pwnd->clipComplexity = CLC_RECT;

                    buffers = pwnd->buffers;
                    if (buffers)
                    {
                        buffers->WndUniq++;

                        buffers->WndSizeUniq++;

                    // Don't let it hit -1.  -1 is special and is used by
                    // MakeCurrent to signal that an update is required

                        if (buffers->WndUniq == -1)
                            buffers->WndUniq = 0;

                        if (buffers->WndSizeUniq == -1)
                            buffers->WndSizeUniq = 0;

                        if ((gengc != NULL) && (pwnd == gengc->pwndLocked))
                            UpdateWindowInfo(gengc);
                    }
                }
                LEAVE_WINCRIT(pwnd);

                break;

            case WM_MOVE:
                gengc = (__GLGENcontext *)GLTEB_SRVCONTEXT();
                
                // Use the non-gc enter to allow recursion.
                ENTER_WINCRIT(pwnd);
                {
                    POINT pt;
                    
                    // Convert client coordinates to screen coordinates
                    // as genwin information is always in screen coordinates.
                    // The given lParam information may be parent-relative
                    // for child windows so it can't be used directly.
                    pt.x = 0;
                    pt.y = 0;
                    ClientToScreen(hwnd, &pt);

                    width  = (WORD) (pwnd->rclClient.right -
                                     pwnd->rclClient.left);
                    height = (WORD) (pwnd->rclClient.bottom -
                                     pwnd->rclClient.top);

                    ASSERTOPENGL(
                        (pwnd->rclClient.right -
                         pwnd->rclClient.left) <= 0x0FFFF &&
                        (pwnd->rclClient.bottom -
                         pwnd->rclClient.top) <= 0x0FFFF,
                        "wglWndProc(): WM_MOVE - width/height overflow\n"
                        );

                    pwnd->rclClient.left   = pt.x;
                    pwnd->rclClient.right  = pt.x + width;
                    pwnd->rclClient.top    = pt.y;
                    pwnd->rclClient.bottom = pt.y + height;

#if 0
                    DbgPrint("move %d,%d - %d,%d\n",
                             pwnd->rclClient.left,
                             pwnd->rclClient.top,
                             pwnd->rclClient.right,
                             pwnd->rclClient.bottom);
#endif
                    
                    // At least clip to screen.

                    if (bClipToScreen(&pwnd->rclBounds,
                                      &pwnd->rclClient))
                        pwnd->clipComplexity = CLC_TRIVIAL;
                    else
                        pwnd->clipComplexity = CLC_RECT;

                    buffers = pwnd->buffers;
                    if (buffers)
                    {
                        buffers->WndUniq++;

                    // Don't let it hit -1.  -1 is special and is used by
                    // MakeCurrent to signal that an update is required

                        if (buffers->WndUniq == -1)
                            buffers->WndUniq = 0;

                        if ((gengc != NULL) && (pwnd == gengc->pwndLocked))
                            UpdateWindowInfo(gengc);
                    }
                }
                LEAVE_WINCRIT(pwnd);

                break;

            case WM_PALETTECHANGED:
                gengc = (__GLGENcontext *)GLTEB_SRVCONTEXT();
                
                // Use the non-gc enter to allow recursion.
                ENTER_WINCRIT(pwnd);
                {
                    pwnd->ulPaletteUniq++;
                    if ((gengc != NULL) && (pwnd == gengc->pwndLocked))
                        HandlePaletteChanges(gengc, pwnd);
                }
                LEAVE_WINCRIT(pwnd);

                break;

            case WM_NCDESTROY:
                pwndCleanup(pwnd);

            // WM_NCDESTROY (and WM_DESTROY) are sent after the window has
            // been removed from the screen.  The window area is invalid
            // but there is no API that allows us to dertermine that. This
            // allows multithreaded drawing to draw on the screen area
            // formerly occupied by the window.  On Win95, DirectDraw does
            // not force a repaint of the system when a window is destroyed.
            // Therefore, if we are running multiple threads on Win95,
            // we force a repaint of the desktop.  Note that multithreaded
            // does not mean that we are doing multithreaded drawing, but
            // its a reasonable approximation.

                if (WIN95_PLATFORM && (lThreadsAttached > 1))
                {
                    InvalidateRect(NULL, NULL, FALSE);
                }

                return lRet;

            default:
                break;
        }

    // If !WM_NCDESTROY, do OpenGL housekeeping before calling original
    // WndProc.

        ASSERTOPENGL(uiMsg != WM_NCDESTROY,
                     "WM_NCDESTROY processing didn't terminate\n");

        pwndRelease(pwnd);

        if (pfnWndProc)
            lRet = CallWindowProc(pfnWndProc, hwnd,
                                  uiMsg, wParam, lParam);
    }

    return lRet;
}

/******************************Public*Routine******************************\
*
* CreatePwnd
*
* Creates a window for the given surface
*
* History:
*  Thu Aug 29 10:33:59 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

GLGENwindow * APIENTRY CreatePwnd(GLWINDOWID *pgwid, int ipfd, int ipfdDevMax,
                                  DWORD dwObjectType, RECTL *prcl, BOOL *pbNew)
{
    GLGENwindow *pwnd;
    GLGENwindow wndInit;
    
    pwnd = pwndGetFromID(pgwid);

    if ( !pwnd )
    {
        memset(&wndInit, 0, sizeof(wndInit));

        wndInit.gwid = *pgwid;
        wndInit.ipfd = ipfd;
        wndInit.ipfdDevMax = ipfdDevMax;

        //!!!client driver
        //!!!dbug -- Move SetWindowLong call to pwndNew?!? Maybe move
        //!!!dbug    everything from this if.. clause to pwndNew?!?
        if ( wndInit.gwid.hwnd )
        {
            DWORD dwPid;

            if (GetWindowThreadProcessId(wndInit.gwid.hwnd,
                                         &dwPid) == 0xffffffff)
            {
                return NULL;
            }

            if (dwPid == GetCurrentProcessId())
            {
                wndInit.pfnOldWndProc =
                    (WNDPROC) SetWindowLongPtr(wndInit.gwid.hwnd,
                                            GWLP_WNDPROC, (LONG_PTR) wglWndProc);
            }
            else
            {
                wndInit.ulFlags |= GLGENWIN_OTHERPROCESS;

                // Start a thread to watch for palette changes
                if (!StartPaletteWatcher())
                {
                    return NULL;
                }
            }
            
            // Get *SCREEN* coordinates of client rectangle.

            GetClientRect(wndInit.gwid.hwnd, (LPRECT) &wndInit.rclClient);
            ClientToScreen(wndInit.gwid.hwnd, (LPPOINT) &wndInit.rclClient);
            wndInit.rclClient.right += wndInit.rclClient.left;
            wndInit.rclClient.bottom += wndInit.rclClient.top;
        }
        else if (dwObjectType == OBJ_DC)
        {
            // A direct DC without a window is treated like a DFB
            GetScreenRect( pgwid->hdc, &wndInit.rclClient );
        }
        else if (dwObjectType == OBJ_MEMDC)
        {
            DIBSECTION bmi;

        // Get bitmap dimensions.

            if ( !GetObject(GetCurrentObject(pgwid->hdc, OBJ_BITMAP),
                            sizeof(DIBSECTION), (LPVOID) &bmi) )
            {
                WARNING("wglSetPixelFormat(): GetObject failed\n");
                return NULL;
            }

            wndInit.rclClient.left   = 0;
            wndInit.rclClient.top    = 0;
            wndInit.rclClient.right  = bmi.dsBm.bmWidth;
            wndInit.rclClient.bottom = abs(bmi.dsBm.bmHeight);
        }
        else if (dwObjectType == OBJ_DDRAW)
        {
            // DirectDraw surface, use passed in rectangle
            ASSERTOPENGL(prcl != NULL, "NULL rect for DDraw surface\n");
            wndInit.rclClient = *prcl;

            // Record the surface vtbl pointer for later validation
            wndInit.pvSurfaceVtbl = *(void **)pgwid->pdds;
        }
        else
        {
            ASSERTOPENGL(dwObjectType == OBJ_ENHMETADC,
                         "Bad dwType in SetPixelFormat\n");
            
            // Initialize metafile DC's to have no size so all output
            // is clipped.  This is good because there's no surface
            // to draw on
            wndInit.rclClient.left   = 0;
            wndInit.rclClient.top    = 0;
            wndInit.rclClient.right  = 0;
            wndInit.rclClient.bottom = 0;
        }

        if (wndInit.gwid.hwnd)
        {
            // To be safe, at least clip bounds to screen.

            if (bClipToScreen(&wndInit.rclBounds,
                              &wndInit.rclClient))
                wndInit.clipComplexity = CLC_TRIVIAL;
            else
                wndInit.clipComplexity = CLC_RECT;
        }
        else
        {
            // Make bounds the same as client.
            wndInit.rclBounds = wndInit.rclClient;
            wndInit.clipComplexity = CLC_TRIVIAL;
        }

        pwnd = pwndNew(&wndInit);
        if (pwnd == NULL)
        {
            WARNING("wglSetPixelFormat: Unable to allocate new window\n");

            if ( wndInit.gwid.hwnd )
            {
                pwndUnsubclass(&wndInit, FALSE);
            }
        }

        *pbNew = TRUE;
    }
    else
    {
    // If the given pixel format is the same as the previous one, return
    // success.  Otherwise, as the pixel format can be set only once,
    // return error.

        if ( pwnd->ipfd != ipfd )
        {
            WARNING("wglSetPixelFormat: Attempt to set pixel format twice\n");
            SAVE_ERROR_CODE(ERROR_INVALID_PIXEL_FORMAT);
            pwndRelease(pwnd);
            pwnd = NULL;
        }

        *pbNew = FALSE;
    }

    return pwnd;
}

/******************************Public*Routine******************************\
* wglGetPixelFormat
*
* Get the pixel format for the window or surface associated with the given
* DC.
*
* Returns:
*   0 if error or no pixel format was previously set in the window or
*   surface; current pixel format index otherwise
*
* History:
*  19-Oct-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

int WINAPI wglGetPixelFormat(HDC hdc)
{
    GLGENwindow *pwnd;
    int iRet = 0;
    GLWINDOWID gwid;

    WindowIdFromHdc(hdc, &gwid);
    pwnd = pwndGetFromID(&gwid);

    if (pwnd)
    {
        iRet = pwnd->ipfd;
        pwndRelease(pwnd);
    }
    else
    {
#if 0
	// Too noisy for normal operation
        WARNING("wglGetPixelFormat: No window for DC\n");
#endif
        SAVE_ERROR_CODE(ERROR_INVALID_PIXEL_FORMAT);
    }

    return iRet;
}

/*****************************Private*Routine******************************\
*
* EnterPixelFormatSection
*
* Enters pixel format exclusive code
*
* NOTE - Pixel format information is maintained in the client process
* so it is not synchronized between processes.  This means that two
* processes could successfully set the pixel format for a window.
* If the list becomes global, this synchronization code should also become
* cross-process aware.
*
* History:
*  Mon Jun 26 17:49:04 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#define EnterPixelFormatSection() \
    (EnterCriticalSection(&gcsPixelFormat), TRUE)

/*****************************Private*Routine******************************\
*
* LeavePixelFormatSection
*
* Leaves pixel format exclusive code
*
* History:
*  Mon Jun 26 17:55:20 1995	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

#define LeavePixelFormatSection() \
    LeaveCriticalSection(&gcsPixelFormat)

/******************************Public*Routine******************************\
* wglNumHardwareFormats
*
* Returns the number of hardware formats (ICD and MCD), supported on the
* specified hdc.
*
* History:
*  17-Apr-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID APIENTRY wglNumHardwareFormats(HDC hdc, DWORD dwType,
                                    int *piMcd, int *piIcd)
{
// It is assumed that the caller has already validated the DC.

    ASSERTOPENGL((dwType == OBJ_DC) ||
                 (dwType == OBJ_MEMDC) ||
                 (dwType == OBJ_ENHMETADC) ||
                 (dwType == OBJ_DDRAW),
                 "wglNumHardwareFormats: bad hdc\n");

// Do not call MCD or ICD for enhanced metafile DCs.  In such a
// case, the code in ntgdi\client\output.c will return a non-zero value
// even if there are no ICD or MCD pixelformats.
#if _WIN32_WINNT >= 0x0501
    {
        BOOL wow64Process;

        if (IsWow64Process(GetCurrentProcess(), &wow64Process) && wow64Process)
            dwType = OBJ_ENHMETADC;
    }
#endif

    if ( dwType == OBJ_ENHMETADC )
    {
    // It's a metafile DC.  Therefore it cannot support MCD or ICD
    // (current OpenGL metafiling support would have to be modified
    // to allow this).

        *piIcd = 0;
        *piMcd = 0;
    }
    else
    {
    // Get ICD pixelformat count.

        *piIcd = __DrvDescribePixelFormat(hdc, 1, 0, NULL);

    // Get MCD pixelformat count.

#ifdef _MCD_
        if ( gpMcdTable || bInitMcd(hdc) )
            *piMcd = (gpMcdTable->pMCDDescribePixelFormat)(hdc, 1, NULL);
        else
            *piMcd = 0;
#else
        *piMcd = 0;
#endif
    }
}

/******************************Public*Routine******************************\
*
* GetCompatibleDevice
*
* Returns an HDC appropriate for making escape calls on.
* In the memdc case it returns a DC for the screen.
*
* History:
*  Wed Nov 20 17:48:57 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

HDC GetCompatibleDevice(HDC hdc, DWORD dwObjectType)
{
    HDC hdcDriver;
    int iTech;
    
    hdcDriver = hdc;
    iTech = GetDeviceCaps(hdc, TECHNOLOGY);
    if ((dwObjectType == OBJ_MEMDC) && (iTech != DT_PLOTTER) &&
        (iTech != DT_RASPRINTER))
    {
        hdcDriver = GetDC(NULL);
    }

    return hdcDriver;
}

/******************************Public*Routine******************************\
* wglSetPixelFormat
*
* Set the pixel format for the window or surface associated with the given
* DC.
*
* Note:
* Since the pixel format is per-window data (per-DC for non-display DCs), a
* side effect of this call is to create a GLGENwindow structure.
*
* Note:
* For an installable client driver, a GLGENwindow structure is still created
* to track the pixel format and the driver structure (GLDRIVER).
*
* History:
*  19-Oct-1994 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL WINAPI wglSetPixelFormat(HDC hdc, int ipfd,
                              CONST PIXELFORMATDESCRIPTOR *ppfd)
{
    GLGENwindow *pwnd = NULL;
    int   ipfdDevMax, ipfdMcdMax;
    DWORD dwObjectType;
    BOOL  bRet = FALSE;
    GLWINDOWID gwid;
    BOOL  bNew;
    HDC hdcDriver;
    LPDIRECTDRAWSURFACE pdds;
    RECTL rcl, *prcl;
    DDSURFACEDESC ddsd;
        
//DBGPRINT1("wglSetPixelFormat: ipfd = %ld\n", ipfd);

// Validate DC.

    switch (dwObjectType = wglObjectType(hdc))
    {
    case OBJ_DC:
    case OBJ_MEMDC:
    case OBJ_ENHMETADC:
        break;
    default:
        WARNING1("wglSetPixelFormat: Attempt to set format of %d type DC\n",
                 dwObjectType);
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

// Take the pixel format mutex

    if (!EnterPixelFormatSection())
    {
        WARNING("wglSetPixelFormat: Unable to take pixel format mutex\n");
        return FALSE;
    }

// Get the number of hardware supported formats.

    if (pfnGetSurfaceFromDC != NULL &&
        pfnGetSurfaceFromDC(hdc, &pdds, &hdcDriver) == DD_OK)
    {
        // Get the surface dimensions
        memset(&ddsd, 0, sizeof(ddsd));
        ddsd.dwSize = sizeof(ddsd);
        if (pdds->lpVtbl->GetSurfaceDesc(pdds, &ddsd) != DD_OK)
        {
            goto LeaveSection;
        }

        rcl.left = 0;
        rcl.top = 0;
        rcl.right = ddsd.dwWidth;
        rcl.bottom = ddsd.dwHeight;
        prcl = &rcl;

        // Switch object type to identify this as a DirectDraw surface
        dwObjectType = OBJ_DDRAW;
    }
    else
    {
        pdds = NULL;
        prcl = NULL;
        
        hdcDriver = GetCompatibleDevice(hdc, dwObjectType);
        if (hdcDriver == NULL)
        {
            goto LeaveSection;
        }
    }
        
    wglNumHardwareFormats(hdcDriver, dwObjectType,
                          &ipfdMcdMax, &ipfdDevMax);

// Filter out invalid (out of range) pixel format indices.

    if ( (ipfd < 1) || (ipfd > (ipfdDevMax + ipfdMcdMax + MAX_GENERIC_PFD)) )
    {
        WARNING1("wglSetPixelFormat: ipfd %d out of range\n", ipfd);
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        goto LeaveSection;
    }

// If it exists, grab pwnd.  Otherwise, create one.

    WindowIdFromHdc(hdc, &gwid);
    pwnd = CreatePwnd(&gwid, ipfd, ipfdDevMax, dwObjectType, prcl, &bNew);
    if (pwnd == NULL)
    {
        goto LeaveSection;
    }

    if (bNew)
    {
// Dispatch driver formats.
// Driver is responsible for doing its own validation of the pixelformat.
// For generic formats, we call wglValidPixelFormat to validate.
// We do not send DirectDraw pixel format calls to the driver
// so that we avoid having new pixel format calls.

        if (dwObjectType != OBJ_DDRAW && ipfd <= ipfdDevMax)
        {
            bRet = __DrvSetPixelFormat(hdc, ipfd, (PVOID) pwnd);
#if DBG
            if (!bRet)
            {
                WARNING("__DrvSetPixelFormat failed\n");
            }
#endif
        }
        else
        {
            bRet = wglValidPixelFormat(hdc, ipfd, dwObjectType,
                                       pdds, &ddsd);
#if DBG
            if (!bRet)
            {
                WARNING("wglValidPixelFormat failed\n");
            }
#endif
        }

// If the pixel format is not valid or could not be set in the driver,
// cleanup and return error.

        if (!bRet)
        {
            goto FreeWnd;
        }
    }
    else
    {
        bRet = TRUE;
    }

    pwndRelease(pwnd);
    
LeaveSection:
    LeavePixelFormatSection();

    if (pdds != NULL)
    {
        pdds->lpVtbl->Release(pdds);
    }
    else if (hdcDriver != hdc)
    {
        ReleaseDC((HWND) NULL, hdcDriver);
    }
    
    return bRet;

FreeWnd:
    pwndCleanup(pwnd);
    goto LeaveSection;
}

/******************************Public*Routine******************************\
* wglChoosePixelFormat
*
* Choose the pixel format.
*
* Returns: 0 if error; best matching pixel format index otherwise
*
* History:
*
*  Sat Feb 10 11:55:22 1996     -by-    Hock San Lee    [hockl]
* Chose generic 16-bit depth buffer over 32-bit depth buffer.
* Added PFD_DEPTH_DONTCARE flag.
*
*  19-Oct-1994 Gilman Wong [gilmanw]
* Taken from GreChoosePixelFormat (gdi\gre\pixelfmt.cxx).
*
* History for gdi\gre\pixelfmt.cxx:
*  Tue Sep 21 14:25:04 1993     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

// Reserve some PFD_SUPPORT flags for other potential graphics systems
// such as PEX, HOOPS, Renderman etc.

#define PFD_SUPPORT_OTHER1         0x01000000
#define PFD_SUPPORT_OTHER2         0x02000000
#define PFD_SUPPORT_OTHER3         0x04000000
#define PFD_SUPPORT_OTHER4         0x08000000

// Scores for matching pixel formats

#define PFD_DRAW_TO_WINDOW_SCORE   0x10000    /* must match */
#define PFD_DRAW_TO_BITMAP_SCORE   0x01000
#define PFD_PIXEL_TYPE_SCORE       0x01000
#define PFD_SUPPORT_SCORE          0x01000
#define PFD_DOUBLEBUFFER_SCORE1    0x01000
#define PFD_DOUBLEBUFFER_SCORE2    0x00001
#define PFD_STEREO_SCORE1          0x01000
#define PFD_STEREO_SCORE2          0x00001
#define PFD_BUFFER_SCORE1          0x01010
#define PFD_BUFFER_SCORE2          0x01001
#define PFD_BUFFER_SCORE3          0x01000
// #define PFD_LAYER_TYPE_SCORE    0x01000
#define PFD_DEVICE_FORMAT_SCORE    0x00100
#define PFD_ACCEL_FORMAT_SCORE     0x00010
#define PFD_SUPPORT_DDRAW_SCORE    0x10000    /* must match */

//!!! Add code to choose overlays?

int WINAPI wglChoosePixelFormat(HDC hdc, CONST PIXELFORMATDESCRIPTOR *ppfd)
{
    PIXELFORMATDESCRIPTOR pfdIn = *ppfd;
    PIXELFORMATDESCRIPTOR pfdCurrent;

// Enumerate and find the best match.

    int ipfdBest = 1;           // assume the default is the best
    int iScoreBest = -1;
    int ipfdMax;
    int ipfd = 1;

    do
    {
        int iScore = 0;

        ipfdMax = wglDescribePixelFormat(hdc,ipfd,sizeof(PIXELFORMATDESCRIPTOR),&pfdCurrent);

        if (ipfdMax == 0)
            return(0);          // something went wrong

        if (pfdIn.iPixelType == pfdCurrent.iPixelType)
            iScore += PFD_PIXEL_TYPE_SCORE;

        if ((pfdIn.cColorBits == 0)
         || (pfdIn.cColorBits == pfdCurrent.cColorBits))
            iScore += PFD_BUFFER_SCORE1;
        else if (pfdIn.cColorBits < pfdCurrent.cColorBits)
            iScore += PFD_BUFFER_SCORE2;
        else if (pfdCurrent.cColorBits != 0)
            iScore += PFD_BUFFER_SCORE3;

        if (!(pfdIn.dwFlags & PFD_DRAW_TO_WINDOW)
         || (pfdCurrent.dwFlags & PFD_DRAW_TO_WINDOW))
            iScore += PFD_DRAW_TO_WINDOW_SCORE;

        if (!(pfdIn.dwFlags & PFD_DRAW_TO_BITMAP)
         || (pfdCurrent.dwFlags & PFD_DRAW_TO_BITMAP))
            iScore += PFD_DRAW_TO_BITMAP_SCORE;

        if (!(pfdIn.dwFlags & PFD_SUPPORT_GDI)
         || (pfdCurrent.dwFlags & PFD_SUPPORT_GDI))
            iScore += PFD_SUPPORT_SCORE;

        if (!(pfdIn.dwFlags & PFD_SUPPORT_OPENGL)
         || (pfdCurrent.dwFlags & PFD_SUPPORT_OPENGL))
            iScore += PFD_SUPPORT_SCORE;

        if ((pfdIn.dwFlags & PFD_SUPPORT_DIRECTDRAW) == 0 ||
            (pfdCurrent.dwFlags & PFD_SUPPORT_DIRECTDRAW))
        {
            iScore += PFD_SUPPORT_DDRAW_SCORE;
        }
        
        if (!(pfdIn.dwFlags & PFD_SUPPORT_OTHER1)
         || (pfdCurrent.dwFlags & PFD_SUPPORT_OTHER1))
            iScore += PFD_SUPPORT_SCORE;

        if (!(pfdIn.dwFlags & PFD_SUPPORT_OTHER2)
         || (pfdCurrent.dwFlags & PFD_SUPPORT_OTHER2))
            iScore += PFD_SUPPORT_SCORE;

        if (!(pfdIn.dwFlags & PFD_SUPPORT_OTHER3)
         || (pfdCurrent.dwFlags & PFD_SUPPORT_OTHER3))
            iScore += PFD_SUPPORT_SCORE;

        if (!(pfdIn.dwFlags & PFD_SUPPORT_OTHER4)
         || (pfdCurrent.dwFlags & PFD_SUPPORT_OTHER4))
            iScore += PFD_SUPPORT_SCORE;

        if (pfdCurrent.dwFlags & PFD_GENERIC_ACCELERATED)
            iScore += PFD_ACCEL_FORMAT_SCORE;
        else if (!(pfdCurrent.dwFlags & PFD_GENERIC_FORMAT))
            iScore += PFD_DEVICE_FORMAT_SCORE;

        if ((pfdIn.dwFlags & PFD_DOUBLEBUFFER_DONTCARE)
         || ((pfdIn.dwFlags & PFD_DOUBLEBUFFER)
          == (pfdCurrent.dwFlags & PFD_DOUBLEBUFFER)))
            iScore += PFD_DOUBLEBUFFER_SCORE1;
        else if (pfdCurrent.dwFlags & PFD_DOUBLEBUFFER)
            iScore += PFD_DOUBLEBUFFER_SCORE2;

        if ((pfdIn.dwFlags & PFD_STEREO_DONTCARE)
         || ((pfdIn.dwFlags & PFD_STEREO)
          == (pfdCurrent.dwFlags & PFD_STEREO)))
            iScore += PFD_STEREO_SCORE1;
        else if (pfdCurrent.dwFlags & PFD_STEREO)
            iScore += PFD_STEREO_SCORE2;

        if ((pfdIn.cAlphaBits == 0)
         || (pfdIn.cAlphaBits == pfdCurrent.cAlphaBits))
            iScore += PFD_BUFFER_SCORE1;
        else if (pfdIn.cAlphaBits < pfdCurrent.cAlphaBits)
            iScore += PFD_BUFFER_SCORE2;
        else if (pfdCurrent.cAlphaBits != 0)
            iScore += PFD_BUFFER_SCORE3;

        if ((pfdIn.cAccumBits == 0)
         || (pfdIn.cAccumBits == pfdCurrent.cAccumBits))
            iScore += PFD_BUFFER_SCORE1;
        else if (pfdIn.cAccumBits < pfdCurrent.cAccumBits)
            iScore += PFD_BUFFER_SCORE2;
        else if (pfdCurrent.cAccumBits != 0)
            iScore += PFD_BUFFER_SCORE3;

// Some applications (e.g. GLview browser) specifies a 0-bit depth buffer
// but expect this function to return a pixel format with a depth buffer.
// This works in NT 3.51 since all pixel formats have a depth buffer.
// When pixel formats with no depth buffer were added in NT 4.0, these
// applications stopped working.  The flag PFD_DEPTH_DONTCARE is added to
// indicate that no depth buffer is required.  If this flags is not given,
// this function will attempt to select a pixel format with a depth buffer.

	if (pfdIn.dwFlags & PFD_DEPTH_DONTCARE)
	{
	    if (pfdCurrent.cDepthBits == 0)
		iScore += PFD_BUFFER_SCORE1;
	    else
		iScore += PFD_BUFFER_SCORE2;
	}
	else if (pfdCurrent.cDepthBits != 0)
	{
	    if ((pfdIn.cDepthBits == 0)
	     || (pfdIn.cDepthBits == pfdCurrent.cDepthBits))
		iScore += PFD_BUFFER_SCORE1;
	    else if (pfdIn.cDepthBits < pfdCurrent.cDepthBits)
		iScore += PFD_BUFFER_SCORE2;
	    else if (pfdCurrent.cDepthBits != 0)
		iScore += PFD_BUFFER_SCORE3;
	}

        if ((pfdIn.cStencilBits == 0)
         || (pfdIn.cStencilBits == pfdCurrent.cStencilBits))
            iScore += PFD_BUFFER_SCORE1;
        else if (pfdIn.cStencilBits < pfdCurrent.cStencilBits)
            iScore += PFD_BUFFER_SCORE2;
        else if (pfdCurrent.cStencilBits != 0)
            iScore += PFD_BUFFER_SCORE3;

        if ((pfdIn.cAuxBuffers == 0)
         || (pfdIn.cAuxBuffers == pfdCurrent.cAuxBuffers))
            iScore += PFD_BUFFER_SCORE1;
        else if (pfdIn.cAuxBuffers < pfdCurrent.cAuxBuffers)
            iScore += PFD_BUFFER_SCORE2;
        else if (pfdCurrent.cAuxBuffers != 0)
            iScore += PFD_BUFFER_SCORE3;

#if 0
        DbgPrint("%2d: score is %8X, best %8X (%2d)\n",
                 ipfd, iScore, iScoreBest, ipfdBest);
#endif
        
        if (iScore > iScoreBest)
        {
            iScoreBest = iScore;
            ipfdBest = ipfd;
        }
        else if (iScore == iScoreBest)
        {
// When everything is equal, we should choose the pixel format with a
// smaller depth size for better performance, provided that the smaller
// depth buffer satisfies the request.  The best way to do this is to
// order pixel formats such that one with smaller depth buffer comes
// first.  In NT 3.51, however, the generic pixel format was not ordered
// this way.  As a result, pixel formats with 32-bit depth buffer are
// choosen by default.  To maintain compatibility, we modify the selection
// here without reordering generic pixel formats.

            if ((pfdCurrent.dwFlags & PFD_GENERIC_FORMAT) &&
#ifdef _MCD_
                !(pfdCurrent.dwFlags & PFD_GENERIC_ACCELERATED) &&
#endif
                (pfdIn.cDepthBits < 16 || pfdIn.dwFlags & PFD_DEPTH_DONTCARE) &&
                (pfdCurrent.cDepthBits == 16) &&
                (ipfd == ipfdBest + 1))
            {
                ipfdBest = ipfd;
            }
        }

        ipfd++;
    } while (ipfd <= ipfdMax);

    return(ipfdBest);
}

/******************************Public*Routine******************************\
*
* MaskToBitsAndShift
*
* Counts bits in a mask and determines shift
* Set bits must be contiguous
*
* History:
*  Mon Aug 26 14:16:28 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

void APIENTRY MaskToBitsAndShift(DWORD dwMask, BYTE *pbBits, BYTE *pbShift)
{
    DWORD dwBit;

    *pbBits = 0;
    *pbShift = 0;
    
    /* Determine first set bit and accumulate shift count */
    dwBit = 0x1;
    while ((dwMask & dwBit) == 0)
    {
        dwBit <<= 1;
        (*pbShift)++;
    }

    /* Count set bits */
    while ((dwMask & dwBit) != 0)
    {
        dwBit <<= 1;
        (*pbBits)++;
    }

    /* No other bits in the mask can be set */
    ASSERTOPENGL(((*pbBits+*pbShift) == (sizeof(dwMask)*8)) ||
                 ((dwMask >> (*pbBits+*pbShift)) == 0),
                 "Invalid mask\n");
}

/*****************************Private*Routine******************************\
*
* ComputeBitsFromMasks
*
* Determines the values for c*Bits and c*Shift from BI_BITFIELD
* channel masks
*
* History:
*  Tue Feb 14 10:50:10 1995     -by-    Drew Bliss [drewb]
*   Created by pulling out duplicated code
*
\**************************************************************************/

static void ComputeBitsFromMasks(PIXELFORMATDESCRIPTOR *ppfd,
                                 DWORD dwRedMask, DWORD dwGreenMask,
                                 DWORD dwBlueMask)
{
    /* Masks can't be zero and they can't overlap */
    ASSERTOPENGL(dwRedMask != 0 &&
                 dwGreenMask != 0 &&
                 dwBlueMask != 0,
                 "Bitfield mask is zero");
    ASSERTOPENGL((dwRedMask & dwGreenMask) == 0 &&
                 (dwRedMask & dwBlueMask) == 0 &&
                 (dwGreenMask & dwBlueMask) == 0,
                 "Bitfield masks overlap");

    MaskToBitsAndShift(dwRedMask, &ppfd->cRedBits, &ppfd->cRedShift);
    MaskToBitsAndShift(dwGreenMask, &ppfd->cGreenBits, &ppfd->cGreenShift);
    MaskToBitsAndShift(dwBlueMask, &ppfd->cBlueBits, &ppfd->cBlueShift);
}

/******************************Public*Routine******************************\
* __wglGetDdFormat
*
* Special case of __wglGetBitfieldColorFormat to support DirectDraw
* surfaces.  Fills in the cRedBits, cRedShift, cGreenBits, etc. fields
* of the PIXELFORMATDESCRIPTOR for 16, 24, and 32bpp direct surfaces.
*
* This is done by interpreting the given surface information
*
* History:
*  07-Jun-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

void __wglGetDdFormat(DDSURFACEDESC *pddsd,
                      PIXELFORMATDESCRIPTOR *ppfd)
{
    // This routine should only be called for bitfield formats, but
    // random mode changes in the middle of certain calls could cause
    // it to be called with non-bitfield formats.
    //
    // When such a mode change occurs OpenGL should not crash but
    // does not necessarily have to produce correct output
    
    if ((pddsd->ddpfPixelFormat.dwFlags & DDPF_RGB) == 0 ||
        (pddsd->ddpfPixelFormat.dwFlags & (DDPF_PALETTEINDEXED1 |
                                           DDPF_PALETTEINDEXED2 |
                                           DDPF_PALETTEINDEXED4 |
                                           DDPF_PALETTEINDEXED8)))
    {
        WARNING1("__wglGetDdFormat called with 0x%08lX ddpf flags\n",
                 pddsd->ddpfPixelFormat.dwFlags);
        
        ppfd->cRedBits = 8;
        ppfd->cRedShift = 0;
        ppfd->cGreenBits = 8;
        ppfd->cGreenShift = 0;
        ppfd->cBlueBits = 8;
        ppfd->cBlueShift = 0;
    }
    else
    {
        ComputeBitsFromMasks(ppfd,
                             pddsd->ddpfPixelFormat.dwRBitMask,
                             pddsd->ddpfPixelFormat.dwGBitMask,
                             pddsd->ddpfPixelFormat.dwBBitMask);
    }
}

/******************************Public*Routine******************************\
* __wglGetBitfieldColorFormat
*
* Fills in the cRedBits, cRedShift, cGreenBits, etc. fields of the
* PIXELFORMATDESCRIPTOR for 16, 24, and 32bpp surfaces (either device
* or bitmap surfaces).
*
* This is done by creating a compatible bitmap and calling GetDIBits
* to return the color masks.  This is done with two calls.  The first
* call passes in biBitCount = 0 to GetDIBits which will fill in the
* base BITMAPINFOHEADER data.  The second call to GetDIBits (passing
* in the BITMAPINFO filled in by the first call) will return the color
* table or bitmasks, as appropriate.
*
* This function is used to describe the color format for both the underlying
* surface and for the device.  This is the same thing if the DC is a
* display DC.  However, for a memory DC, the surface and the device may have
* different formats.  The bDescribeSurf flag indicates whether the caller
* wants the decription of the device (FALSE) or the surface (TRUE).
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  07-Jun-1995 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL APIENTRY
__wglGetBitfieldColorFormat(HDC hdc, UINT cColorBits, PIXELFORMATDESCRIPTOR *ppfd,
                            BOOL bDescribeSurf)
{
    HBITMAP hbm = (HBITMAP) NULL;
    BOOL    bRet = FALSE;
    HDC hdcDriver;

#if DBG
// Dynamic color depth changes can cause this.  It will not cause us to crash,
// but drawing (color) may be incorrect.

    if ((GetObjectType(hdc) == OBJ_DC) &&
        (GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE))
    {
        WARNING("Palette managed device that is greater than 8 bits\n");
    }

    if (cColorBits < 16)
    {
        WARNING("__wglGetBitfieldColorFormat with cColorBits < 16\n");
    }
#endif

// Handle direct case.

    if ( GLDIRECTSCREEN && wglIsDirectDevice(hdc) )
    {
        __wglGetDdFormat(&GLSCREENINFO->gdds.ddsd, ppfd);
        return TRUE;
    }

// Create a dummy bitmap from which we can query color format info.
//
// If we want a device format AND its a MEM_DC AND NOT a printer or plotter,
// then we need to create a compatible bitmap from a display DC (not the mem
// DC passed into this function).
//
// Otherwise, the format of the surface (whether bitmap or device) associated
// with the DC passed in will suffice.
//
// WinNT does not care, but the Win95 GetDIBits call might
// fail if we use a memory DC.  Specifically, if the memory
// DC contains a surface that does not match the display
// (remember, the new bitmap is compatible with the display)
// the Win95 GetDIBits call will fail.
//
// So use the display DC.  It works on both platforms.

    if (!bDescribeSurf)
    {
        hdcDriver = GetCompatibleDevice(hdc, GetObjectType(hdc));
        if (hdcDriver == NULL)
        {
            return FALSE;
        }
    }
    else
    {
        hdcDriver = hdc;
    }
    
    hbm = CreateCompatibleBitmap(hdcDriver, 1, 1);
    if ( !hbm )
    {
        WARNING("__wglGetBitfieldColorFormat: "
                "CreateCompatibleBitmap failed\n");
    }

// Get the color format by calling GetDIBits.

    else
    {
        BYTE ajBitmapInfo[sizeof(BITMAPINFO) + 3*sizeof(DWORD)];
        BITMAPINFO *pbmi = (BITMAPINFO *) ajBitmapInfo;
        int iRet;

        //!!!dbug -- Init masks to zero so we can
        // tell if they are set by GetDIBits.
        memset(pbmi, 0, sizeof(ajBitmapInfo));
        pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);

        // Call first time to fill in BITMAPINFO header.
        iRet = GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS);

#if DBG
        if (pbmi->bmiHeader.biBitCount != cColorBits)
            WARNING2("__wglGetBitfieldColorFormat: bit count != BITSPIXEL "
                     " (%ld, %ld)\n", pbmi->bmiHeader.biBitCount, cColorBits);
#endif

        switch ( pbmi->bmiHeader.biCompression )
        {
        case BI_RGB:

#if DBG
        // Dynamic color depth changes can cause this.  It will not cause
        // us to crash, but drawing (color) may be incorrect.

            if (pbmi->bmiHeader.biBitCount != cColorBits)
            {
                WARNING("__wglGetBitfieldColorFormat(): bit count mismatch\n");
            }
#endif

        // Default DIB format.  Color masks are implicit for each bit depth.

            switch ( pbmi->bmiHeader.biBitCount )
            {
            case 16:
                // 16bpp default is 555 BGR-ordering
                ppfd->cRedBits   = 5; ppfd->cRedShift   = 10;
                ppfd->cGreenBits = 5; ppfd->cGreenShift =  5;
                ppfd->cBlueBits  = 5; ppfd->cBlueShift  =  0;
                bRet = TRUE;
                break;

            case 24:
            case 32:
                // 24 and 32bpp default is 888 BGR-ordering
                ppfd->cRedBits   = 8; ppfd->cRedShift   = 16;
                ppfd->cGreenBits = 8; ppfd->cGreenShift =  8;
                ppfd->cBlueBits  = 8; ppfd->cBlueShift  =  0;
                bRet = TRUE;
                break;

            default:
                break;
            }

            break;

        case BI_BITFIELDS:

        // Some drivers seem to return bitfields for everything that's
        // not paletted.  They return correct BGR bitfields so we
        // operate correctly, so remove this assert
#ifdef STRICT_BITFIELD_CHECK
            ASSERTOPENGL(
                    cColorBits == 16 || cColorBits == 32,
                    "__wglGetBitfieldColorFormat(): "
                    "BI_BITFIELDS surface not 16 or 32bpp\n"
                );
#endif

            // Call a second time to get the color masks.
            // It's a GetDIBits Win32 "feature".
            iRet = GetDIBits(hdc, hbm, 0, pbmi->bmiHeader.biHeight, NULL,
                             pbmi, DIB_RGB_COLORS);

            ComputeBitsFromMasks(ppfd,
                                 *(DWORD *)&pbmi->bmiColors[0],
                                 *(DWORD *)&pbmi->bmiColors[1],
                                 *(DWORD *)&pbmi->bmiColors[2]);

            bRet = TRUE;
            break;

        default:
            RIP("__wglGetBitfieldColorFormat(): bad biCompression\n");
            break;
        }

        DeleteObject(hbm);
    }

    if ( hdcDriver != hdc )
    {
        ReleaseDC((HWND) NULL, hdcDriver);
    }

    return bRet;
}

/******************************Public*Routine******************************\
*
* wglGetDeviceDepth
*
* Returns the depth of the given HDC
* Primarily used to workaround potential problems with printers
* that lie about their depth in GetDeviceCaps
*
* History:
*  Tue Apr 09 16:52:47 1996	-by-	Drew Bliss [drewb]
*   Created
*
\**************************************************************************/

int wglGetDeviceDepth(HDC hdc)
{
    int iTech;

    // If this is an enhanced metafile it should return the technology
    // of the reference device
    iTech = GetDeviceCaps(hdc, TECHNOLOGY);
    if (iTech == DT_PLOTTER || iTech == DT_RASPRINTER)
    {
        HBITMAP hbm;
        BYTE ajBitmapInfo[sizeof(BITMAPINFO) + 3*sizeof(DWORD)];
        BITMAPINFO *pbmi = (BITMAPINFO *) ajBitmapInfo;
        int iRet;
        
        // We're dealing with a printer or a metafile that has a printer
        // as a reference device
        // Find out the true depth by creating a compatible
        // bitmap and querying its format
        if ( (hbm = CreateCompatibleBitmap(hdc, 1, 1)) != NULL )
        {
            memset(pbmi, 0, sizeof(ajBitmapInfo));
            pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
            iRet = GetDIBits(hdc, hbm, 0, 0, NULL, pbmi, DIB_RGB_COLORS);
            
            DeleteObject(hbm);
            
            return iRet != 0 ? pbmi->bmiHeader.biBitCount : -1;
        }

        // Failure
        return -1;
    }
    else
    {
        // We're dealing with a well-behaved DC so just return
        // the normal depth
        return GetDeviceCaps(hdc, BITSPIXEL)*GetDeviceCaps(hdc, PLANES);
    }
}

/******************************Public*Routine******************************\
* wglDescribePixelFormat
*
* Describe the pixel format.
* If cjpfd is 0, just return the maximum pixel format index.
*
* Returns: 0 if error; maximum pixel format index otherwise
*
* History:
*  19-Oct-1994 Gilman Wong [gilmanw]
* Adapted from GreDescribePixelFormat (gdi\gre\pixelfmt.cxx).
*
* History for gdi\gre\pixelfmt.cxx:
*  Mon Apr 25 15:34:32 1994     -by-    Hock San Lee    [hockl]
* Added 16-bit Z buffer formats and removed double buffered formats for bitmaps.
*  Tue Sep 21 14:25:04 1993     -by-    Hock San Lee    [hockl]
* Wrote it.
\**************************************************************************/

// Here are the generic formats that we enumerate.  ChoosePixelFormat code
// assumes that generic pixel formats with z32 comes before z16 as given below:
//
// I. Native formats:
//
//   1. rgb.sb.z32.a0
//   2. rgb.sb.z16.a0
//   3. rgb.db.z32.a0
//   4. rgb.db.z16.a0
//   5. rgb.sb.z32.a8
//   6. rgb.sb.z16.a8
//   7. rgb.db.z32.a8
//   8. rgb.db.z16.a8
//   9.  ci.sb.z32
//   10. ci.sb.z16
//   11. ci.db.z32
//   12. ci.db.z16
//
// II. Other formats:
//
//   1. rgb.sb.z32.a0
//   2. rgb.sb.z16.a0
//   3. rgb.sb.z32.a8
//   4. rgb.sb.z16.a8
//   5.  ci.sb.z32
//   6.  ci.sb.z16
//
// We always enumerate the native formats first followed by other formats
// in the BPP order {24, 32, 16, 8, 4} for a total of 1 * 12 + 4 * 6 = 36
// pixel formats.

// Highest native format generic pixel format index.
#define MAX_NATIVE_GENERIC_PFD 12
// Number of non-native formats in a non-native group.
#define NON_NATIVE_PFD_GROUP 6

static BYTE aabPixelBits[BMF_COUNT][4] =
{
    {24, 32, 16, 8},    // error
    {24, 32, 16, 8},    // 1 bpp
    {24, 32, 16, 8},    // 4 bpp
    {24, 32, 16, 4},    // 8 bpp
    {24, 32,  8, 4},    // 16 bpp
    {32, 16,  8, 4},    // 24 bpp
    {24, 16,  8, 4}     // 32 bpp
};

static BYTE abPixelType[MAX_GENERIC_PFD] =
{
    PFD_TYPE_RGBA, PFD_TYPE_RGBA, PFD_TYPE_RGBA, PFD_TYPE_RGBA,
    PFD_TYPE_RGBA, PFD_TYPE_RGBA, PFD_TYPE_RGBA, PFD_TYPE_RGBA,
    PFD_TYPE_COLORINDEX,PFD_TYPE_COLORINDEX, PFD_TYPE_COLORINDEX,PFD_TYPE_COLORINDEX,
    PFD_TYPE_RGBA, PFD_TYPE_RGBA, PFD_TYPE_RGBA, PFD_TYPE_RGBA,
    PFD_TYPE_COLORINDEX, PFD_TYPE_COLORINDEX,
    PFD_TYPE_RGBA, PFD_TYPE_RGBA, PFD_TYPE_RGBA, PFD_TYPE_RGBA,
    PFD_TYPE_COLORINDEX, PFD_TYPE_COLORINDEX,
    PFD_TYPE_RGBA, PFD_TYPE_RGBA, PFD_TYPE_RGBA, PFD_TYPE_RGBA,
    PFD_TYPE_COLORINDEX, PFD_TYPE_COLORINDEX,
    PFD_TYPE_RGBA, PFD_TYPE_RGBA, PFD_TYPE_RGBA, PFD_TYPE_RGBA,
    PFD_TYPE_COLORINDEX, PFD_TYPE_COLORINDEX
};

int WINAPI InternalDescribePixelFormat(HDC hdc, HDC hdcDriver,
                                       int ipfd, UINT cjpfd,
                                       LPPIXELFORMATDESCRIPTOR ppfd,
                                       int ipfdDevMax, int ipfdMcdMax,
                                       LPDIRECTDRAWSURFACE pdds,
                                       DDSURFACEDESC *pddsd)
{
    int iRet = 0;
    int ipfdGen;
    UINT iDitherFormat;
    BYTE cColorBitsNative;
    
// If cjpfd is 0, just return the maximum pixel format index.

    if (cjpfd == 0 || ppfd == NULL)
    {
        iRet = MAX_GENERIC_PFD + ipfdDevMax + ipfdMcdMax;
        goto wglDescribePixelFormat_cleanup;
    }

// Validate the size of the pixel format descriptor.

    if (cjpfd < sizeof(PIXELFORMATDESCRIPTOR))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        goto wglDescribePixelFormat_cleanup;
    }

// Validate pixel format index.
// If a driver support device pixel formats 1..ipfdDevMax, the generic
// pixel formats will be (ipfdDevMax+1)..(ipfdDevMax+MAX_GENERIC_PFD).
// Otherwise, ipfdDevMax is 0 and the generic pixel formats are
// 1..MAX_GENERIC_PFD.

    if ((ipfd < 1) || (ipfd > ipfdDevMax + ipfdMcdMax + MAX_GENERIC_PFD))
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        goto wglDescribePixelFormat_cleanup;
    }

// Dispatch ICD driver formats.

    if (ipfd <= ipfdDevMax)
    {
        int iDrvRet = __DrvDescribePixelFormat(hdcDriver,ipfd,cjpfd,ppfd);
        if (iDrvRet)
        {
            ASSERTOPENGL(iDrvRet == ipfdDevMax,
                         "wglDescribePixelFornat: Bad ipfdDevMax");
            iRet = MAX_GENERIC_PFD + ipfdDevMax + ipfdMcdMax;
        }

        goto wglDescribePixelFormat_cleanup;
    }

#ifdef _MCD_
// Dispatch MCD driver formats.

    ipfdGen = ipfd - ipfdDevMax;
    if (ipfdGen <= ipfdMcdMax)
    {
        int iMcdRet;

    // Note: don't need to check if gpMcdTable is valid because we can't get
    // here unless ipfdDevMax is non-zero and that can't happen unless the
    // the table is valid.

        ASSERTOPENGL(gpMcdTable, "wglDescribePixelFormat: bad MCD table\n");

        iMcdRet = (gpMcdTable->pMCDDescribePixelFormat)(hdcDriver, ipfdGen,
                                                        ppfd);
        if (iMcdRet)
        {
            ASSERTOPENGL(iMcdRet == ipfdMcdMax,
                         "wglDescribePixelFornat: Bad ipfdMcdMax");
            iRet = MAX_GENERIC_PFD + ipfdDevMax + ipfdMcdMax;
        }

        goto wglDescribePixelFormat_cleanup;
    }

// Generic implementation.
// Normalize the generic pixel format index to 0..(MAX_GENERIC_PFD-1).

    ipfdGen = ipfdGen - ipfdMcdMax - 1;
#else
// Generic implementation.
// Normalize the generic pixel format index to 0..(MAX_GENERIC_PFD-1).

    ipfdGen = ipfd - ipfdDevMax - 1;
#endif

// Get the native BPP format.

    if (pdds != NULL)
    {
        cColorBitsNative = DdPixelDepth(pddsd);
    }
    else
    {
        cColorBitsNative = (BYTE)wglGetDeviceDepth(hdc);
    }
    
    if (cColorBitsNative < 1)
    {
        SAVE_ERROR_CODE(ERROR_INVALID_PARAMETER);
        goto wglDescribePixelFormat_cleanup;
    }

    if (cColorBitsNative <= 1)
    {
        cColorBitsNative = 1;
        iDitherFormat = BMF_1BPP;
    }
    else if (cColorBitsNative <= 4)
    {
        cColorBitsNative = 4;
        iDitherFormat = BMF_4BPP;
    }
    else if (cColorBitsNative <= 8)
    {
        cColorBitsNative = 8;
        iDitherFormat = BMF_8BPP;
    }
    else if (cColorBitsNative <= 16)
    {
        cColorBitsNative = 16;
        iDitherFormat = BMF_16BPP;
    }
    else if (cColorBitsNative <= 24)
    {
        cColorBitsNative = 24;
        iDitherFormat = BMF_24BPP;
    }
    else
    {
        cColorBitsNative = 32;
        iDitherFormat = BMF_32BPP;
    }

// Fill in the pixel format descriptor.

    ppfd->nSize      = sizeof(PIXELFORMATDESCRIPTOR);
    ppfd->nVersion   = 1;
    ppfd->iPixelType = abPixelType[ipfdGen];

    if (ipfdGen < MAX_NATIVE_GENERIC_PFD)
    {
        ppfd->cColorBits = max(cColorBitsNative, 4);    // 1 bpp not supported
    }
    else
    {
        ppfd->cColorBits = aabPixelBits[iDitherFormat]
            [(ipfdGen - MAX_NATIVE_GENERIC_PFD) / NON_NATIVE_PFD_GROUP];
    }

// If the color format is compatible to that of the device and the
// color bits is 16 or greater, use the device description.
// Otherwise, use the generic format.

    if (ipfdGen < MAX_NATIVE_GENERIC_PFD && cColorBitsNative >= 16)
    {
// Handle compatible formats that are greater than 16-bits.

        if (pdds != NULL)
        {
            __wglGetDdFormat(pddsd, ppfd);
        }
        else if ( !__wglGetBitfieldColorFormat(hdc, cColorBitsNative,
                                               ppfd, FALSE) )
        {
        // Don't know how to deal with this device!

            WARNING("Unknown device format");
            SAVE_ERROR_CODE(ERROR_NOT_SUPPORTED);
            goto wglDescribePixelFormat_cleanup;
        }
    }
    else
    {
// Handle generic formats.

        switch (ppfd->cColorBits)
        {
        case 4:
            ppfd->cRedBits   = 1; ppfd->cRedShift   = 0;
            ppfd->cGreenBits = 1; ppfd->cGreenShift = 1;
            ppfd->cBlueBits  = 1; ppfd->cBlueShift  = 2;
            break;
        case 8:
            ppfd->cRedBits   = 3; ppfd->cRedShift   = 0;
            ppfd->cGreenBits = 3; ppfd->cGreenShift = 3;
            ppfd->cBlueBits  = 2; ppfd->cBlueShift  = 6;
            break;
        case 16:
            /*
            ** Even though Win95 allows arbitrary bitfield definitions
            ** for 16bpp DIBs, only 555BGR is usable by Win95's GDI.
            */
            ppfd->cRedBits   = 5; ppfd->cRedShift   = 10;   // 555BGR
            ppfd->cGreenBits = 5; ppfd->cGreenShift =  5;
            ppfd->cBlueBits  = 5; ppfd->cBlueShift  =  0;
            break;
        case 24:
        case 32:
            /*
            ** Even though Win95 allows arbitrary bitfield definitions
            ** for 32bpp, only 888BGR is usable by Win95's GDI.  Similarly,
            ** NT has the concept of a RGB 24bpp DIB, but Win95 does not.
            */
            ppfd->cRedBits   = 8; ppfd->cRedShift   = 16;   // 888BGR
            ppfd->cGreenBits = 8; ppfd->cGreenShift =  8;
            ppfd->cBlueBits  = 8; ppfd->cBlueShift  =  0;
            break;
        default:
            ASSERTOPENGL(FALSE, "wglDescribePixelFornat: Unknown format");
            break;
        }
    }

    ppfd->cAlphaBits    = 0;
    ppfd->cAlphaShift   = 0;
    if ( ipfdGen < MAX_NATIVE_GENERIC_PFD)
    {
        // Only report alpha bits if the DirectDraw surface has them.
        if (pdds != NULL)
        {
            if (pddsd->ddpfPixelFormat.dwFlags & DDPF_ALPHAPIXELS)
            {
                ASSERTOPENGL(pddsd->dwFlags & DDSD_ALPHABITDEPTH,
                             "Surface with alpha but no bit depth set\n");
                
                ppfd->cAlphaBits = (BYTE)pddsd->dwAlphaBitDepth;
            }
        }
        else if ( (ipfdGen > 3) && (ipfdGen < 8) )
        {
            ppfd->cAlphaBits = 8;
        }
    }
    else
    {
        int ipfd = (ipfdGen - MAX_NATIVE_GENERIC_PFD) % NON_NATIVE_PFD_GROUP;
        if ( (ipfd == 2) || (ipfd == 3) )
        {
            ppfd->cAlphaBits = 8;
        }
    }

    if (ppfd->iPixelType == PFD_TYPE_RGBA)
    {
        if (ppfd->cColorBits <= 16)
        {
            if (ppfd->cColorBits < 8)
            {
                // !!! Internally now, we will actually be using a 32-bit accum
                // buffer, but the user will think it's 16 (This is for 
                // backwards compatibility).
                ppfd->cAccumBits = 16;
                if( ppfd->cAlphaBits )
                {
                    ppfd->cAccumRedBits   = 4;
                    ppfd->cAccumGreenBits = 4;
                    ppfd->cAccumBlueBits  = 4;
                    ppfd->cAccumAlphaBits = 4;
                }
                else
                {
                    ppfd->cAccumRedBits   = 5;
                    ppfd->cAccumGreenBits = 6;
                    ppfd->cAccumBlueBits  = 5;
                    ppfd->cAccumAlphaBits = 0;
                }
            }
            else 
            {
                ppfd->cAccumBits = 32;
                if( ppfd->cAlphaBits )
                {
                    ppfd->cAccumRedBits   = 8;
                    ppfd->cAccumGreenBits = 8;
                    ppfd->cAccumBlueBits  = 8;
                    ppfd->cAccumAlphaBits = 8;
                }
                else
                {
                    ppfd->cAccumRedBits   = 11;
                    ppfd->cAccumGreenBits = 11;
                    ppfd->cAccumBlueBits  = 10;
                    ppfd->cAccumAlphaBits = 0;
                }
            }
        }
        else
        {
            ppfd->cAccumBits = 64;

            if( ppfd->cAlphaBits )
            {
                ppfd->cAccumRedBits   = 16;
                ppfd->cAccumGreenBits = 16;
                ppfd->cAccumBlueBits  = 16;
                ppfd->cAccumAlphaBits = 16;
            }
            else
            {
                ppfd->cAccumRedBits   = 16;
                ppfd->cAccumGreenBits = 16;
                ppfd->cAccumBlueBits  = 16;
                ppfd->cAccumAlphaBits = 0;
            }
        }
    }
    else
    {
        ppfd->cAccumBits      = 0;
        ppfd->cAccumRedBits   = 0;
        ppfd->cAccumGreenBits = 0;
        ppfd->cAccumBlueBits  = 0;
        ppfd->cAccumAlphaBits = 0;
    }

// Generic formats alternate between 16- and 32-bit depth buffer.  Evens
// are 32-bit, odds are 16-bit.
// DirectDraw surfaces always report the depth of the attached Z buffer
// for the native format indices.

    if (pdds != NULL && ipfdGen < MAX_NATIVE_GENERIC_PFD)
    {
        DDSCAPS ddscaps;
        LPDIRECTDRAWSURFACE pddsZ;
        
        // DDraw surfaces may not have attached Z buffers, in which case
        // we should not report depth bits.  If one is attached, its
        // depth should be reported.
        // We only do this processing for native pixel formats.
        
        memset(&ddscaps, 0, sizeof(ddscaps));
        ddscaps.dwCaps = DDSCAPS_ZBUFFER;
        if (pdds->lpVtbl->
            GetAttachedSurface(pdds, &ddscaps, &pddsZ) == DD_OK)
        {
            HRESULT hr;
            DDSURFACEDESC ddsdZ;
                
            memset(&ddsdZ, 0, sizeof(ddsdZ));
            ddsdZ.dwSize = sizeof(ddsdZ);
                
            hr = pddsZ->lpVtbl->GetSurfaceDesc(pddsZ, &ddsdZ);
            
            pddsZ->lpVtbl->Release(pddsZ);

            if (hr != DD_OK)
            {
                goto wglDescribePixelFormat_cleanup;
            }

            ppfd->cDepthBits =
                (BYTE)DdPixDepthToCount(ddsdZ.ddpfPixelFormat.
                                        dwZBufferBitDepth);
        }
        else
        {
            ppfd->cDepthBits = 0;
        }
    }
    else if (ipfdGen & 0x1)
    {
        ppfd->cDepthBits = 16;
    }
    else
    {
        ppfd->cDepthBits = 32;
    }
    
    ppfd->cStencilBits  = 8;
    ppfd->cAuxBuffers   = 0;
    ppfd->iLayerType    = PFD_MAIN_PLANE;
    ppfd->bReserved     = 0;
    ppfd->dwLayerMask   = 0;
    ppfd->dwVisibleMask = 0;
    ppfd->dwDamageMask  = 0;

// Compute the buffer flags.
// Support OpenGL in all generic formats.

    ppfd->dwFlags = PFD_SUPPORT_OPENGL | PFD_GENERIC_FORMAT;

    // Indicate DirectDraw support on native pixel formats for DD surfaces.
    if (pdds != NULL && ipfdGen < MAX_NATIVE_GENERIC_PFD)
    {
        ppfd->dwFlags |= PFD_SUPPORT_DIRECTDRAW;
    }
    
// Bitmaps and GDI drawing are available in single buffered mode only.

    if (pdds == NULL &&
        (ipfdGen == 2 || ipfdGen == 3 || ipfdGen == 6 || ipfdGen == 7 ||
         ipfdGen == 10 || ipfdGen == 11))
    {
        ppfd->dwFlags |= PFD_DOUBLEBUFFER | PFD_SWAP_COPY;
    }
    else
    {
        ppfd->dwFlags |= PFD_DRAW_TO_BITMAP | PFD_SUPPORT_GDI;
    }

// Draw to window or device surface only if the format is compatible.

    if (ipfdGen < MAX_NATIVE_GENERIC_PFD)
    {
        ppfd->dwFlags |= PFD_DRAW_TO_WINDOW;

// Need a palette if it is a RGBA pixel type on a palette managed device.

        if (ppfd->cColorBits == 8 && ppfd->iPixelType == PFD_TYPE_RGBA)
        {
            ppfd->dwFlags |= PFD_NEED_PALETTE;
        }
    }

// If this is a 1 bpp surface, we don't support drawing to window and
// double buffered mode.  Re-set the buffer flags.

    if (cColorBitsNative < 4)
    {
#ifndef GL_METAFILE
        ASSERTOPENGL(ppfd->cColorBits == 4,
            "wglDescribePixelFormat: bad cColorBits for 1 bpp surface\n");
#endif

        ppfd->dwFlags = PFD_DRAW_TO_BITMAP | PFD_SUPPORT_GDI |
            PFD_SUPPORT_OPENGL | PFD_GENERIC_FORMAT;
    }

// To support other potential graphics systems, we reserve the following
// flags in the pixel format descriptor.  For example, PEX may use
// PFD_SUPPORT_OTHER1 on the system that supports PEX.  Since we don't
// support these other systems in the generic implementation, they belong
// to the device pixel format descriptor.

    ASSERTOPENGL(!(ppfd->dwFlags & (PFD_SUPPORT_OTHER1 | PFD_SUPPORT_OTHER2 |
                                    PFD_SUPPORT_OTHER3 | PFD_SUPPORT_OTHER4)),
                 "dwFlags reserved for device formats\n");

    iRet = MAX_GENERIC_PFD + ipfdDevMax + ipfdMcdMax;

wglDescribePixelFormat_cleanup:

    return iRet;
}

int WINAPI wglDescribePixelFormat(HDC hdc, int ipfd, UINT cjpfd,
                                  LPPIXELFORMATDESCRIPTOR ppfd)
{
    int iRet = 0;
    int ipfdDevMax, ipfdMcdMax;
    DWORD dwObjectType;
    HDC hdcDriver = NULL;
    LPDIRECTDRAWSURFACE pdds;
    DDSURFACEDESC ddsd;

// Validate DC.

    switch (dwObjectType = wglObjectType(hdc))
    {
    case OBJ_DC:
    case OBJ_MEMDC:
    case OBJ_ENHMETADC:
        break;
    default:
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(0);
    }

    // Check to see if this is a DirectDraw DC.  If it is, use the
    // device DC returned from DirectDraw.
    if (pfnGetSurfaceFromDC != NULL &&
        pfnGetSurfaceFromDC(hdc, &pdds, &hdcDriver) == DD_OK)
    {
        // pdds reference must be released before exiting this function.

        // Retrieve surface description for later use.
        memset(&ddsd, 0, sizeof(ddsd));
        ddsd.dwSize = sizeof(ddsd);
        if (pdds->lpVtbl->GetSurfaceDesc(pdds, &ddsd) != DD_OK)
        {
            goto wglDescribePixelFormat_cleanup;
        }
    }
    else
    {
        pdds = NULL;
        
        hdcDriver = GetCompatibleDevice(hdc, dwObjectType);
        if (hdcDriver == NULL)
        {
            goto wglDescribePixelFormat_cleanup;
        }

        // NOTE: From this point on, all exit cases must cleanup hdcDriver
    }

// Get the number of hardware supported formats.

    wglNumHardwareFormats(hdcDriver, dwObjectType, &ipfdMcdMax, &ipfdDevMax);

    iRet = InternalDescribePixelFormat(hdc, hdcDriver, ipfd, cjpfd, ppfd,
                                       ipfdDevMax, ipfdMcdMax,
                                       pdds, &ddsd);
    
wglDescribePixelFormat_cleanup:

    if (pdds != NULL)
    {
        pdds->lpVtbl->Release(pdds);
    }
    else if (hdcDriver != hdc)
    {
        ReleaseDC((HWND) NULL, hdcDriver);
    }

    return iRet;
}

#ifdef _MCD_
/******************************Public*Routine******************************\
* GenMcdGenericCompatibleFormat
*
* Determines if pixelformat in gengc can be supported by generic code.
*
* Note:
*   The implication of not being compatible is that generic cannot be
*   used for driver kickbacks and MCD contexts cannot be converted.
*
* Returns:
*   TRUE if compatible, FALSE otherwise.
*
* History:
*  04-Jun-1996 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

BOOL FASTCALL GenMcdGenericCompatibleFormat(__GLGENcontext *gengc)
{
    PIXELFORMATDESCRIPTOR *ppfd;

// Software-only formats are definitely supported.

    ppfd = &gengc->gsurf.pfd;
    if ((ppfd->dwFlags & (PFD_GENERIC_FORMAT|PFD_GENERIC_ACCELERATED))
        == PFD_GENERIC_FORMAT)
        return TRUE;

// Layer planes are not supported.

    if (gengc->iLayerPlane)
        return FALSE;

// Generic is PFD_SWAP_COPY only.  There can't be many apps that rely
// on PFD_SWAP_EXCHANGE behavior (usually they look for PFD_SWAP_COPY
// so the back buffer can be used as backing store), but for now I think
// we should be conservative.
//
// Note: most MGA cards will set PFD_SWAP_COPY or neither (i.e., either
// style might be used depending on window size).

    if (ppfd->dwFlags & PFD_SWAP_EXCHANGE)
        return FALSE;

// Can only support 8bpp stencils.

    if ((ppfd->cStencilBits != 0) && (ppfd->cStencilBits != 8))
        return FALSE;

// Passed all the checks, we're compatible.

    return TRUE;
}
#endif

/******************************Public*Routine******************************\
* wglSwapBuffers
*
\**************************************************************************/

BOOL WINAPI wglSwapBuffers(HDC hdc)
{
    int  ipfd;
    BOOL bRet = FALSE;
    GLGENwindow *pwnd;
    GLWINDOWID gwid;

// Validate the DC.

    if (IsDirectDrawDevice(hdc))
    {
        SetLastError(ERROR_INVALID_FUNCTION);
        return FALSE;
    }
    
    switch ( wglObjectType(hdc) )
    {
    case OBJ_DC:
        break;
    case OBJ_MEMDC:
        return(TRUE);           // early out -- nothing to do if memory DC
    default:
        WARNING("wglSwapBuffers(): invalid hdc\n");
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
        return(FALSE);
    }

// Validate pixel format.

    WindowIdFromHdc(hdc, &gwid);
    pwnd = pwndGetFromID(&gwid);
    if ( pwnd )
    {
        if (pwnd->ipfd > 0)
        {
            // Dispatch to driver or generic.  Which one can be determined by
            // the pixel format.

            if ( pwnd->ipfd <= pwnd->ipfdDevMax )
            {
                // Some ICDs do not need glFinish synchronization so
                // we don't do it here.  __DrvSwapBuffers will call
                // it if necessary.
                bRet = __DrvSwapBuffers(hdc, TRUE);
            }
            else
            {
                // Finish OpenGL calls in this thread before doing the swap.
                // We use glFinish instead of glFlush to ensure that all
                // OpenGL operations are completed.
                glFinish();

                ENTER_WINCRIT(pwnd);
                
                // Can't rely on the pwnd's HDC because it may have
                // been released since SetPixelFormat.  Always use
                // the DC passed in as the target.
                bRet = glsrvSwapBuffers(hdc, pwnd);

                LEAVE_WINCRIT(pwnd);
            }
        }

        pwndRelease(pwnd);
    }
    else
    {
        SAVE_ERROR_CODE(ERROR_INVALID_HANDLE);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\i386\fastpoly.c ===
/*
** Copyright 1991, 1992, 1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <windows.h>
#include <winddi.h>

#include "render.h"
#include "context.h"
#include "global.h"
#include "gencx.h"
#include "..\inc\wglp.h"

#define FLT_TO_FIX(value) \
    *((GLint *)&value) = (GLint)(*((__GLfloat *)&(value)) * (__GLfloat)65536.0)

/* This routine sets gc->polygon.shader.cfb to gc->drawBuffer */

void __fastTriangleSetup(__GLcontext *gc)
{
    SPANREC deltaRec;

    if (gc->polygon.shader.modeFlags & __GL_SHADE_RGB) {
        if (gc->polygon.shader.modeFlags & __GL_SHADE_DITHER) {
            __fastRGBSmoothSpanSetup(gc);
            __fastRGBFlatSpanSetup(gc);
        } else {
            __fastRGBNDSmoothSpanSetup(gc);
            __fastRGBNDFlatSpanSetup(gc);
        }
    } else {
        if (gc->polygon.shader.modeFlags & __GL_SHADE_DITHER) {
            __fastCISmoothSpanSetup(gc);
            __fastCIFlatSpanSetup(gc);
        } else {
            __fastCINDSmoothSpanSetup(gc);
            __fastCINDFlatSpanSetup(gc);
        }
    }

    deltaRec.r = 0;
    deltaRec.g = 0;
    deltaRec.b = 0;
    deltaRec.a = 0;
    deltaRec.z = 0;

    __fastDeltaSpan(gc, &deltaRec);     // Set up initial delta values
}

/*static*/ void fastFillSubTriangle(__GLcontext *gc, GLint iyBottom, GLint iyTop)
{
    GLint ixLeft, ixRight;
    GLint ixLeftFrac, ixRightFrac;
    GLint dxLeftFrac, dxRightFrac;
    GLint dxLeftLittle, dxRightLittle;
    GLint dxLeftBig, dxRightBig;
    GLint spanWidth, clipY0, clipY1;
    GLuint modeFlags;
    __GLGENcontext  *gengc = (__GLGENcontext *)gc;
#ifdef NT
    __GLstippleWord stackWords[__GL_MAX_STACK_STIPPLE_WORDS];
    __GLstippleWord *words;
    GLuint maxWidth;
#else
    __GLstippleWord words[__GL_MAX_STIPPLE_WORDS];
#endif
    __GLspanFunc spanFunc = 
        ((FASTFUNCS *)(*((VOID **)(gengc->pPrivateArea))))->__fastSpanFuncPtr;

#ifdef NT
    maxWidth = (gc->transform.clipX1 - gc->transform.clipX0) + 31;
    if (maxWidth > __GL_MAX_STACK_STIPPLE_BITS)
    {
        words = __wglTempAlloc(gc, (maxWidth+__GL_STIPPLE_BITS-1)/8);
        if (words == NULL)
        {
            return;
        }
    }
    else
    {
        words = stackWords;
    }
#endif
    
    ixLeft = gc->polygon.shader.ixLeft;
    ixLeftFrac = gc->polygon.shader.ixLeftFrac;
    ixRight = gc->polygon.shader.ixRight;
    ixRightFrac = gc->polygon.shader.ixRightFrac;
    clipY0 = gc->transform.clipY0;
    clipY1 = gc->transform.clipY1;
    dxLeftFrac = gc->polygon.shader.dxLeftFrac;
    dxLeftBig = gc->polygon.shader.dxLeftBig;
    dxLeftLittle = gc->polygon.shader.dxLeftLittle;
    dxRightFrac = gc->polygon.shader.dxRightFrac;
    dxRightBig = gc->polygon.shader.dxRightBig;
    dxRightLittle = gc->polygon.shader.dxRightLittle;
    modeFlags = gc->polygon.shader.modeFlags;
    gc->polygon.shader.stipplePat = words;

    if (modeFlags & __GL_SHADE_DEPTH_TEST) {
	gc->polygon.shader.zbuf =
	    __GL_DEPTH_ADDR(&gc->depthBuffer, (__GLzValue*),
			    ixLeft, iyBottom);
    }
    gc->polygon.shader.cfb = gc->drawBuffer;
    while (iyBottom < iyTop) {
	spanWidth = ixRight - ixLeft;
	/*
	** Only render spans that have non-zero width and which are
	** not scissored out vertically.
	*/
	if ((spanWidth > 0) && (iyBottom >= clipY0) && (iyBottom < clipY1)) {
	    gc->polygon.shader.frag.x = ixLeft;
	    gc->polygon.shader.frag.y = iyBottom;
	    gc->polygon.shader.length = spanWidth;

            if (gc->state.raster.drawBuffer == GL_FRONT_AND_BACK) {
                gc->polygon.shader.cfb = &gc->frontBuffer;
                (*spanFunc)(gc);

                if (!((GLint)gc->polygon.shader.cfb->buf.other & DIB_FORMAT))
                    wglCopyBits(gengc->pdco, gengc->pwo, gengc->ColorsBitmap,
                                __GL_UNBIAS_X(gc, ixLeft) + 
                                              gc->drawBuffer->buf.xOrigin,
                                __GL_UNBIAS_Y(gc, iyBottom) + 
                                              gc->drawBuffer->buf.yOrigin,
                                spanWidth, TRUE);


                gc->polygon.shader.cfb = &gc->backBuffer;
                (*spanFunc)(gc);
            } else {

                (*spanFunc)(gc);

                if (!((GLint)gc->drawBuffer->buf.other & DIB_FORMAT))
                    wglCopyBits(gengc->pdco, gengc->pwo, gengc->ColorsBitmap,
                                __GL_UNBIAS_X(gc, ixLeft) + 
                                              gc->drawBuffer->buf.xOrigin,
                                __GL_UNBIAS_Y(gc, iyBottom) + 
                                              gc->drawBuffer->buf.yOrigin,
                                spanWidth, TRUE);
            }
	}

	/* Advance right edge fixed point, adjusting for carry */
	ixRightFrac += dxRightFrac;
	if (ixRightFrac < 0) {
	    /* Carry/Borrow'd. Use large step */
	    ixRight += dxRightBig;
	    ixRightFrac &= ~0x80000000;
	} else {
	    ixRight += dxRightLittle;
	}

	iyBottom++;
	ixLeftFrac += dxLeftFrac;
	if (ixLeftFrac < 0) {
	    /* Carry/Borrow'd.  Use large step */
	    ixLeft += dxLeftBig;
	    ixLeftFrac &= ~0x80000000;

	    if (modeFlags & __GL_SHADE_RGB) {
		if (modeFlags & __GL_SHADE_SMOOTH) {
		    *((GLint *)&gc->polygon.shader.frag.color.r) += 
                        *((GLint *)&gc->polygon.shader.rBig);
		    *((GLint *)&gc->polygon.shader.frag.color.g) += 
                        *((GLint *)&gc->polygon.shader.gBig);
		    *((GLint *)&gc->polygon.shader.frag.color.b) += 
                        *((GLint *)&gc->polygon.shader.bBig);
		    *((GLint *)&gc->polygon.shader.frag.color.a) += 
                        *((GLint *)&gc->polygon.shader.aBig);
		}
	    } else {
		if (modeFlags & __GL_SHADE_SMOOTH) {
		    *((GLint *)&gc->polygon.shader.frag.color.r) += 
                        *((GLint *)&gc->polygon.shader.rBig);
		}
	    }
	    if (modeFlags & __GL_SHADE_DEPTH_ITER) {
		gc->polygon.shader.frag.z += gc->polygon.shader.zBig;
	    }

	    if (modeFlags & __GL_SHADE_DEPTH_TEST) {
		/* The implicit multiply is taken out of the loop */
		gc->polygon.shader.zbuf = (__GLzValue*)
		    ((GLubyte*) gc->polygon.shader.zbuf
		     + gc->polygon.shader.zbufBig);
	    }
	} else {
	    /* Use small step */
	    ixLeft += dxLeftLittle;
	    if (modeFlags & __GL_SHADE_RGB) {
		if (modeFlags & __GL_SHADE_SMOOTH) {
		    *((GLint *)&gc->polygon.shader.frag.color.r) += 
                        *((GLint *)&gc->polygon.shader.rLittle);
		    *((GLint *)&gc->polygon.shader.frag.color.g) += 
                        *((GLint *)&gc->polygon.shader.gLittle);
		    *((GLint *)&gc->polygon.shader.frag.color.b) += 
                        *((GLint *)&gc->polygon.shader.bLittle);
		    *((GLint *)&gc->polygon.shader.frag.color.a) += 
                        *((GLint *)&gc->polygon.shader.aLittle);
		}
	    } else {
		if (modeFlags & __GL_SHADE_SMOOTH) {
		    *((GLint *)&gc->polygon.shader.frag.color.r) += 
                        *((GLint *)&gc->polygon.shader.rLittle);
		}
            }
	    if (modeFlags & __GL_SHADE_DEPTH_ITER) {
		gc->polygon.shader.frag.z += gc->polygon.shader.zLittle;
	    }
	    if (modeFlags & __GL_SHADE_DEPTH_TEST) {
		/* The implicit multiply is taken out of the loop */
		gc->polygon.shader.zbuf = (__GLzValue*)
		    ((GLubyte*) gc->polygon.shader.zbuf
		     + gc->polygon.shader.zbufLittle);
	    }
	}
    }
    gc->polygon.shader.ixLeft = ixLeft;
    gc->polygon.shader.ixLeftFrac = ixLeftFrac;
    gc->polygon.shader.ixRight = ixRight;
    gc->polygon.shader.ixRightFrac = ixRightFrac;

#ifdef NT
    if (maxWidth > __GL_MAX_STACK_STIPPLE_BITS)
    {
        __wglTempFree(gc, words);
    }
#endif
}

#define __TWO_31 ((__GLfloat) 2147483648.0)

#define __FRACTION(result,f) \
    result = (GLint) ((f) * __TWO_31)

static void SnapXLeft(__GLcontext *gc, __GLfloat xLeft, __GLfloat dxdyLeft)
{
    __GLfloat little, dx;
    GLint ixLeft, ixLeftFrac, frac, lineBytes, elementSize, ilittle, ibig;

    ixLeft = (GLint) xLeft;
    dx = xLeft - ixLeft;
    __FRACTION(ixLeftFrac,dx);

    /* Pre-add .5 to allow truncation in spanWidth calculation */
    ixLeftFrac += 0x40000000;
    gc->polygon.shader.ixLeft = ixLeft + (((GLuint) ixLeftFrac) >> 31);
    gc->polygon.shader.ixLeftFrac = ixLeftFrac & ~0x80000000;

    /* Compute big and little steps */
    ilittle = (GLint) dxdyLeft;
    little = (__GLfloat) ilittle;
    if (dxdyLeft < 0) {
	ibig = ilittle - 1;
	dx = little - dxdyLeft;
	__FRACTION(frac,dx);
	gc->polygon.shader.dxLeftFrac = -frac;
    } else {
	ibig = ilittle + 1;
	dx = dxdyLeft - little;
	__FRACTION(frac,dx);
	gc->polygon.shader.dxLeftFrac = frac;
    }
    if (gc->polygon.shader.modeFlags & __GL_SHADE_DEPTH_TEST) {
	/*
	** Compute the big and little depth buffer steps.  We walk the
	** memory pointers for the depth buffer along the edge of the
	** triangle as we walk the edge.  This way we don't have to
	** recompute the buffer address as we go.
	*/
	elementSize = gc->depthBuffer.buf.elementSize;
	lineBytes = elementSize * gc->depthBuffer.buf.outerWidth;
	gc->polygon.shader.zbufLittle = lineBytes + ilittle * elementSize;
	gc->polygon.shader.zbufBig = lineBytes + ibig * elementSize;
    }
    gc->polygon.shader.dxLeftLittle = ilittle;
    gc->polygon.shader.dxLeftBig = ibig;
}

static void SnapXRight(__GLshade *sh, __GLfloat xRight, __GLfloat dxdyRight)
{
    __GLfloat little, big, dx;
    GLint ixRight, ixRightFrac, frac;

    ixRight = (GLint) xRight;
    dx = xRight - ixRight;
    __FRACTION(ixRightFrac,dx);

    /* Pre-add .5 to allow truncation in spanWidth calculation */
    ixRightFrac += 0x40000000;
    sh->ixRight = ixRight + (((GLuint) ixRightFrac) >> 31);
    sh->ixRightFrac = ixRightFrac & ~0x80000000;

    /* Compute big and little steps */
    little = (__GLfloat) ((GLint) dxdyRight);
    if (dxdyRight < 0) {
	big = little - 1;
	dx = little - dxdyRight;
	__FRACTION(frac,dx);
	sh->dxRightFrac = -frac;
    } else {
	big = little + 1;
	dx = dxdyRight - little;
	__FRACTION(frac,dx);
	sh->dxRightFrac = frac;
    }
    sh->dxRightLittle = (GLint) little;
    sh->dxRightBig = (GLint) big;
}

static void SetInitialParameters(__GLshade *sh, const __GLvertex *a,
				 const __GLcolor *ac, __GLfloat aFog,
				 __GLfloat dx, __GLfloat dy)
{
    __GLfloat little = sh->dxLeftLittle;
    __GLfloat big = sh->dxLeftBig;
    GLuint modeFlags = sh->modeFlags;

    if (big > little) {
	if (modeFlags & __GL_SHADE_RGB) {
	    if (modeFlags & __GL_SHADE_SMOOTH) {
		sh->frag.color.r = ac->r + dx*sh->drdx + dy*sh->drdy;
		sh->rLittle = sh->drdy + little * sh->drdx;
		sh->rBig = sh->rLittle + sh->drdx;

		sh->frag.color.g = ac->g + dx*sh->dgdx + dy*sh->dgdy;
		sh->gLittle = sh->dgdy + little * sh->dgdx;
		sh->gBig = sh->gLittle + sh->dgdx;

		sh->frag.color.b = ac->b + dx*sh->dbdx + dy*sh->dbdy;
		sh->bLittle = sh->dbdy + little * sh->dbdx;
		sh->bBig = sh->bLittle + sh->dbdx;

		sh->frag.color.a = ac->a + dx*sh->dadx + dy*sh->dady;
		sh->aLittle = sh->dady + little * sh->dadx;
		sh->aBig =sh->aLittle + sh->dadx;

                FLT_TO_FIX(sh->frag.color.r);
                FLT_TO_FIX(sh->frag.color.g);
                FLT_TO_FIX(sh->frag.color.b);
                FLT_TO_FIX(sh->frag.color.a);

                FLT_TO_FIX(sh->rLittle);
                FLT_TO_FIX(sh->gLittle);
                FLT_TO_FIX(sh->bLittle);
                FLT_TO_FIX(sh->aLittle);

                FLT_TO_FIX(sh->rBig);
                FLT_TO_FIX(sh->gBig);
                FLT_TO_FIX(sh->bBig);
                FLT_TO_FIX(sh->aBig);

	    }
	} else {
	    if (modeFlags & __GL_SHADE_SMOOTH) {
		sh->frag.color.r = ac->r + dx*sh->drdx + dy*sh->drdy;
		sh->rLittle = sh->drdy + little * sh->drdx;
		sh->rBig = sh->rLittle + sh->drdx;

                FLT_TO_FIX(sh->frag.color.r);
                FLT_TO_FIX(sh->rLittle);
                FLT_TO_FIX(sh->rBig);
            }
	}
	if (modeFlags & __GL_SHADE_DEPTH_ITER) {
	    __GLfloat zLittle;

	    sh->frag.z = (__GLzValue)
		(a->window.z + dx*sh->dzdxf + dy*sh->dzdyf);
	    zLittle = sh->dzdyf + little * sh->dzdxf;
	    sh->zLittle = (GLint)zLittle;
	    sh->zBig = (GLint)(zLittle + sh->dzdxf);
	}
	if (modeFlags & __GL_SHADE_SLOW_FOG) {
	    sh->frag.f = aFog + dx*sh->dfdx + dy*sh->dfdy;
	    sh->fLittle = sh->dfdy + little * sh->dfdx;
	    sh->fBig = sh->fLittle + sh->dfdx;

            FLT_TO_FIX(sh->frag.f);
            FLT_TO_FIX(sh->fLittle);
            FLT_TO_FIX(sh->fBig);
	}
    } else {	
	if (modeFlags & __GL_SHADE_RGB) {
	    if (modeFlags & __GL_SHADE_SMOOTH) {
		sh->frag.color.r = ac->r + dx*sh->drdx + dy*sh->drdy;
		sh->rLittle = sh->drdy + little * sh->drdx;
		sh->rBig = sh->rLittle - sh->drdx;

		sh->frag.color.g = ac->g + dx*sh->dgdx + dy*sh->dgdy;
		sh->gLittle = sh->dgdy + little * sh->dgdx;
		sh->gBig = sh->gLittle - sh->dgdx;

		sh->frag.color.b = ac->b + dx*sh->dbdx + dy*sh->dbdy;
		sh->bLittle = sh->dbdy + little * sh->dbdx;
		sh->bBig = sh->bLittle - sh->dbdx;

		sh->frag.color.a = ac->a + dx*sh->dadx + dy*sh->dady;
		sh->aLittle = sh->dady + little * sh->dadx;
		sh->aBig =sh->aLittle - sh->dadx;

                FLT_TO_FIX(sh->frag.color.r);
                FLT_TO_FIX(sh->frag.color.g);
                FLT_TO_FIX(sh->frag.color.b);
                FLT_TO_FIX(sh->frag.color.a);

                FLT_TO_FIX(sh->rLittle);
                FLT_TO_FIX(sh->gLittle);
                FLT_TO_FIX(sh->bLittle);
                FLT_TO_FIX(sh->aLittle);

                FLT_TO_FIX(sh->rBig);
                FLT_TO_FIX(sh->gBig);
                FLT_TO_FIX(sh->bBig);
                FLT_TO_FIX(sh->aBig);
	    }
	} else {
	    if (modeFlags & __GL_SHADE_SMOOTH) {
		sh->frag.color.r = ac->r + dx*sh->drdx + dy*sh->drdy;
		sh->rLittle = sh->drdy + little * sh->drdx;
		sh->rBig = sh->rLittle - sh->drdx;

                FLT_TO_FIX(sh->frag.color.r);
                FLT_TO_FIX(sh->rLittle);
                FLT_TO_FIX(sh->rBig);
	    }
	}
	if (modeFlags & __GL_SHADE_DEPTH_ITER) {
	    __GLfloat zLittle;
	    sh->frag.z = (__GLzValue)
		(a->window.z + dx*sh->dzdxf + dy*sh->dzdyf);
	    zLittle = sh->dzdyf + little * sh->dzdxf;
	    sh->zLittle = (GLint)zLittle;
	    sh->zBig = (GLint)(zLittle - sh->dzdxf);
	}
	if (modeFlags & __GL_SHADE_SLOW_FOG) {
	    sh->frag.f = aFog + dx*sh->dfdx + dy*sh->dfdy;
	    sh->fLittle = sh->dfdy + little * sh->dfdx;
	    sh->fBig = sh->fLittle - sh->dfdx;

            FLT_TO_FIX(sh->frag.f);
            FLT_TO_FIX(sh->fLittle);
            FLT_TO_FIX(sh->fBig);
	}
    }
}


void __fastFillTriangle(__GLcontext *gc, __GLvertex *a, __GLvertex *b,
                        __GLvertex *c, GLboolean ccw)

{
    __GLfloat oneOverArea, t1, t2, t3, t4;
    __GLfloat dxAC, dxBC, dyAC, dyBC;
    __GLfloat aFog, bFog;
    __GLfloat dxAB, dyAB;
    __GLfloat dx, dy, dxdyLeft, dxdyRight;
    __GLcolor *ac, *bc;
    GLint aIY, bIY, cIY;
    GLuint modeFlags;
    SPANREC deltaRec;


    /* Pre-compute one over polygon area */

    oneOverArea = __glOne / gc->polygon.shader.area;

    /* Fetch some stuff we are going to reuse */
    modeFlags = gc->polygon.shader.modeFlags;
    dxAC = gc->polygon.shader.dxAC;
    dxBC = gc->polygon.shader.dxBC;
    dyAC = gc->polygon.shader.dyAC;
    dyBC = gc->polygon.shader.dyBC;
    ac = a->color;
    bc = b->color;

    /*
    ** Compute delta values for unit changes in x or y for each
    ** parameter.
    */
    t1 = dyAC * oneOverArea;
    t2 = dyBC * oneOverArea;
    t3 = dxAC * oneOverArea;
    t4 = dxBC * oneOverArea;
    if (modeFlags & __GL_SHADE_RGB) {
	if (modeFlags & __GL_SHADE_SMOOTH) {
	    __GLfloat drAC, dgAC, dbAC, daAC;
	    __GLfloat drBC, dgBC, dbBC, daBC;
	    __GLcolor *cc;

	    cc = c->color;
	    drAC = ac->r - cc->r;
	    drBC = bc->r - cc->r;
	    gc->polygon.shader.drdx = drAC * t2 - drBC * t1;
	    gc->polygon.shader.drdy = drBC * t3 - drAC * t4;
	    dgAC = ac->g - cc->g;
	    dgBC = bc->g - cc->g;
	    gc->polygon.shader.dgdx = dgAC * t2 - dgBC * t1;
	    gc->polygon.shader.dgdy = dgBC * t3 - dgAC * t4;
	    dbAC = ac->b - cc->b;
	    dbBC = bc->b - cc->b;
	    gc->polygon.shader.dbdx = dbAC * t2 - dbBC * t1;
	    gc->polygon.shader.dbdy = dbBC * t3 - dbAC * t4;
	    daAC = ac->a - cc->a;
	    daBC = bc->a - cc->a;
	    gc->polygon.shader.dadx = daAC * t2 - daBC * t1;
	    gc->polygon.shader.dady = daBC * t3 - daAC * t4;

            RtlCopyMemory(&deltaRec.r, &gc->polygon.shader.drdx, 
                          4 * sizeof(__GLfloat));

            FLT_TO_FIX(deltaRec.r);
            FLT_TO_FIX(deltaRec.g);
            FLT_TO_FIX(deltaRec.b);
            FLT_TO_FIX(deltaRec.a);
	} else {
	    __GLcolor *flatColor = gc->vertex.provoking->color;
	    gc->polygon.shader.frag.color.r = flatColor->r;
	    gc->polygon.shader.frag.color.g = flatColor->g;
	    gc->polygon.shader.frag.color.b = flatColor->b;
	    gc->polygon.shader.frag.color.a = flatColor->a;

            FLT_TO_FIX(gc->polygon.shader.frag.color.r);
            FLT_TO_FIX(gc->polygon.shader.frag.color.g);
            FLT_TO_FIX(gc->polygon.shader.frag.color.b);
            FLT_TO_FIX(gc->polygon.shader.frag.color.a);
	}
    } else {
	if (modeFlags & __GL_SHADE_SMOOTH) {
	    __GLfloat drAC;
	    __GLfloat drBC;
	    __GLcolor *cc;

	    cc = c->color;
	    drAC = ac->r - cc->r;
	    drBC = bc->r - cc->r;
	    gc->polygon.shader.drdx = drAC * t2 - drBC * t1;
	    gc->polygon.shader.drdy = drBC * t3 - drAC * t4;

            deltaRec.r = *((GLint *)&gc->polygon.shader.drdx);
            FLT_TO_FIX(deltaRec.r);
	} else {
	    __GLcolor *flatColor = gc->vertex.provoking->color;
	    gc->polygon.shader.frag.color.r = flatColor->r;
            FLT_TO_FIX(gc->polygon.shader.frag.color.r);
	}
    }
    if (modeFlags & __GL_SHADE_DEPTH_ITER) {
	__GLfloat dzAC, dzBC;

	dzAC = a->window.z - c->window.z;
	dzBC = b->window.z - c->window.z;
	gc->polygon.shader.dzdxf = dzAC * t2 - dzBC * t1;
	gc->polygon.shader.dzdyf = dzBC * t3 - dzAC * t4;
	deltaRec.z = gc->polygon.shader.dzdx = (GLint) gc->polygon.shader.dzdxf;
    }

    __fastDeltaSpan(gc, &deltaRec);     // Set up span delta values


    /* Snap each y coordinate to its pixel center */
    aIY = (GLint) (a->window.y + __glHalf);
    bIY = (GLint) (b->window.y + __glHalf);
    cIY = (GLint) (c->window.y + __glHalf);

    /*
    ** This algorithim always fills from bottom to top, left to right.
    ** Because of this, ccw triangles are inherently faster because
    ** the parameter values need not be recomputed.
    */
    dxAB = a->window.x - b->window.x;
    dyAB = a->window.y - b->window.y;
    if (ccw) {
	dxdyLeft = dxAC / dyAC;
	dy = (aIY + __glHalf) - a->window.y;
	SnapXLeft(gc, a->window.x + dy*dxdyLeft, dxdyLeft);
	dx = (gc->polygon.shader.ixLeft + __glHalf) - a->window.x;
	SetInitialParameters(&gc->polygon.shader, a, ac, aFog, dx, dy);
	if (aIY != bIY) {
	    dxdyRight = dxAB / dyAB;
	    SnapXRight(&gc->polygon.shader, a->window.x + dy*dxdyRight,
		       dxdyRight);
	    fastFillSubTriangle(gc, aIY, bIY);
	}

	if (bIY != cIY) {
	    dxdyRight = dxBC / dyBC;
	    dy = (bIY + __glHalf) - b->window.y;
	    SnapXRight(&gc->polygon.shader, b->window.x + dy*dxdyRight,
		       dxdyRight);
	    fastFillSubTriangle(gc, bIY, cIY);
	}
    } else {
	dxdyRight = dxAC / dyAC;
	dy = (aIY + __glHalf) - a->window.y;
	SnapXRight(&gc->polygon.shader, a->window.x + dy*dxdyRight, dxdyRight);
	if (aIY != bIY) {
	    dxdyLeft = dxAB / dyAB;
	    SnapXLeft(gc, a->window.x + dy*dxdyLeft, dxdyLeft);
	    dx = (gc->polygon.shader.ixLeft + __glHalf) - a->window.x;
	    SetInitialParameters(&gc->polygon.shader, a, ac, aFog, dx, dy);
	    fastFillSubTriangle(gc, aIY, bIY);
	}

	if (bIY != cIY) {
	    dxdyLeft = dxBC / dyBC;
	    dy = (bIY + __glHalf) - b->window.y;
	    SnapXLeft(gc, b->window.x + dy*dxdyLeft, dxdyLeft);
	    dx = (gc->polygon.shader.ixLeft + __glHalf) - b->window.x;
	    SetInitialParameters(&gc->polygon.shader, b, bc, bFog, dx, dy);
	    fastFillSubTriangle(gc, bIY, cIY);
	}
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\i386\math.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: math.asm
;
; Fast math routines.
;
; Created: 11/1/1996
; Author: Otto Berkes [ottob]
;
; Copyright (c) 1996 Microsoft Corporation
;----------------------------------------------------------------------;
        .386

        .model  small,pascal

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include gli386.inc
        .list

	PROFILE = 0
	include profile.inc

;
;
; We're trying to solve:
;
;	1/sqrt(x)
;	
; which in IEEE float is:
;
;	1/sqrt(M * 2^[E-127])
;
;	To simplify, substitute e = [E-127]
;
; We can simplify this by pulling a large portion of the exponent out
; by using only that portion of the exponent divisible by two (so we can
; pull it out of the sqrt term):
;
;	1/sqrt(M * 2^(2*[e div 2]) * 2^[e MOD 2])
;	
; which is:
;	
;	1/ (2^[e div 2] * sqrt(M * 2^[e MOD 2]))
;
; or
;
;	(2^[e div 2])^(-1) * 1/sqrt(M * 2^[e MOD 2])
;
; =
;	2^-[e div 2] * 1/sqrt(M * 2^[e MOD 2])
;
; substitute back for e = [E-127]:
;
;	2^-[(E - 127) div 2] * 1/sqrt(M * 2^[(E - 127) MOD 2])
;
; =
;	2^-[(E div 2) - 63] * 1/sqrt(M * 2^[(E - 1) MOD 2])
;
; =
;	2^[63 - (E div 2)] * 1/sqrt(M * 2^[(E - 1) MOD 2])
;
; As a floating-point number, 2^[63 - (E div 2)] is just the exponent value:
;
;	[63 - (E div 2)] + 127
;
; or
;	[(127+63) - (E div 2)]
;
; Remembering to account for the implicit '1' im the mantissa of IEEE floating-
; point numbers, the range of (M * 2^[(E - 1) MOD 2]) is 0.800000 to
; 0.ffffff*2, which is the interval [0.5, 2.0).  We can use the fact that this
; is a relatively small range, and therefore can use a table lookup near the
; actual value.  The table will contain values for the piece-wise approximation
; to the curve 1/sqrt(M * 2^[(E - 1) MOD 2]) using an acceptable interval.
; These values can then be used to approximate the desired inverse square root 
; value.  At this point, all that remains is to apply the correct exponent 
; for the number, which is simply [(127+63) - (E div 2)] from the above 
; equations.
;
; To do the piecewise-linear approximation, we can store a table of values at
; the appropriate intervals, and the deltas between them.  However, this
; will require calculating the difference between the interval value and
; x.  We can do a bit better by using slope-intercept (y = mx + b)m so the
; table will store (m, b).
;
; With a 512-entry table, we will get at least 16 bits of precision.  This
; result was obtined using simulations.

.data

; The following 'C' code generates the table below:

;#define SQRT_TAB_SIZE_LOG2	9       // 512-entry table
;
;#define MANTISSA_SIZE          24
;#define SQRT_TAB_SIZE          (1 << SQRT_TAB_SIZE_LOG2)
;#define SQRT_INC               (1 << (MANTISSA_SIZE - SQRT_TAB_SIZE_LOG2))
;#define CASTFIX(a)             (*((LONG *)&(a)))
;
;void genTable()
;{
;    int i;
;    float x;
;    float xNext;
;    float y;
;    float yNext;
;    float xInterval;
;
;    // We will start our table with the case where the exponent is even.
;
;    CASTFIX(x) = 0x3f000000;
;
;    // We will use the current and next values to generate the piece-wise
;    // data for the curve.  The interval between 'current' and 'next' is
;    // based on the smallest change possible in the floating-point value
;    // that also represents a difference of one table-lookup entry.
;
;    // When we switch to the odd-exponent case (at 1.0), we have to adjust
;    // for the fact that effective interval between successive values
;    /  is doubled.
;
;    CASTFIX(xNext) = CASTFIX(x) + SQRT_INC;
;    y = (float)1.0 / sqrt((double)x);
;
;    // Calculate 1.0 / (piece-wise approximation interval).
;
;    xInterval = xNext - x;
;
;    xInterval = (float)1.0 / xInterval;
;
;    // Now, generate the table:
;
;    for (i = 0; i < SQRT_TAB_SIZE; i++) {
;        float m;
;        float b;
;
;        // We increment our floating-point values using integer operations
;        // to ensure accuracy:
;
;        CASTFIX(xNext) = CASTFIX(x) + SQRT_INC;
;
;        // Find next point on curve:
;
;        yNext = (float)1.0 / sqrt((double)xNext);
;
;        // Test for odd-exponent case:
;
;        if (CASTFIX(x) == 0x3f800000)
;            xInterval *= (float)0.5;
;
;        m = (yNext - y) * xInterval;
;        b = y - (m * x);
;
;        printf("\t\tdd\t0%8xh, 0%8xh\n", CASTFIX(m), CASTFIX(b));
;
;        y = yNext;
;        x = xNext;
;    }
;}


invSqrtTab	dd	0bfb47e00h, 04007a1fah
		dd	0bfb37000h, 040075e36h
		dd	0bfb26600h, 040071b31h
		dd	0bfb16000h, 04006d8ech
		dd	0bfb05800h, 0400695e4h
		dd	0bfaf5800h, 0400654a4h
		dd	0bfae5600h, 0400612a2h
		dd	0bfad5800h, 04005d165h
		dd	0bfac5e00h, 0400590f1h
		dd	0bfab6400h, 04005503eh
		dd	0bfaa6e00h, 040051058h
		dd	0bfa97800h, 04004d033h
		dd	0bfa88800h, 040049163h
		dd	0bfa79600h, 0400451d0h
		dd	0bfa6aa00h, 040041396h
		dd	0bfa5be00h, 04003d522h
		dd	0bfa4d400h, 0400396fah
		dd	0bfa3ee00h, 0400359a8h
		dd	0bfa30800h, 040031c1dh
		dd	0bfa22400h, 04002dee2h
		dd	0bfa14400h, 04002a282h
		dd	0bfa06600h, 040026674h
		dd	0bf9f8800h, 040022a30h
		dd	0bf9eae00h, 04001eecah
		dd	0bf9dd400h, 04001b32eh
		dd	0bf9cfc00h, 0400177e8h
		dd	0bf9c2800h, 040013d86h
		dd	0bf9b5400h, 0400102efh
		dd	0bf9a8400h, 04000c93fh
		dd	0bf99b400h, 040008f5bh
		dd	0bf98e600h, 0400055d2h
		dd	0bf981800h, 040001c16h
		dd	0bf975000h, 03fffc7abh
		dd	0bf968600h, 03fff55a6h
		dd	0bf95c000h, 03ffee580h
		dd	0bf94fc00h, 03ffe761ah
		dd	0bf943800h, 03ffe0652h
		dd	0bf937400h, 03ffd9628h
		dd	0bf92b600h, 03ffd290eh
		dd	0bf91f800h, 03ffcbb95h
		dd	0bf913a00h, 03ffc4dbdh
		dd	0bf907e00h, 03ffbe0afh
		dd	0bf8fc600h, 03ffb7597h
		dd	0bf8f0c00h, 03ffb08f8h
		dd	0bf8e5800h, 03ffa9f80h
		dd	0bf8da000h, 03ffa3354h
		dd	0bf8cee00h, 03ff9ca56h
		dd	0bf8c3c00h, 03ff960ffh
		dd	0bf8b8a00h, 03ff8f74fh
		dd	0bf8adc00h, 03ff88fa8h
		dd	0bf8a2e00h, 03ff827aah
		dd	0bf898000h, 03ff7bf55h
		dd	0bf88d600h, 03ff75911h
		dd	0bf882e00h, 03ff6f3adh
		dd	0bf878400h, 03ff68cbfh
		dd	0bf86de00h, 03ff627eah
		dd	0bf863600h, 03ff5c18ah
		dd	0bf859400h, 03ff55e81h
		dd	0bf84f000h, 03ff4f9edh
		dd	0bf845000h, 03ff4977dh
		dd	0bf83ae00h, 03ff43381h
		dd	0bf831000h, 03ff3d1aeh
		dd	0bf827200h, 03ff36f8ch
		dd	0bf81d400h, 03ff30d1bh
		dd	0bf813a00h, 03ff2acdbh
		dd	0bf809e00h, 03ff24b0dh
		dd	0bf800600h, 03ff1eb75h
		dd	0bf7edc00h, 03ff18b91h
		dd	0bf7db000h, 03ff12ca5h
		dd	0bf7c8400h, 03ff0cd6eh
		dd	0bf7b5c00h, 03ff06f32h
		dd	0bf7a3400h, 03ff010ach
		dd	0bf791000h, 03fefb324h
		dd	0bf77f000h, 03fef569ch
		dd	0bf76d000h, 03feef9cch
		dd	0bf75b000h, 03fee9cb4h
		dd	0bf749400h, 03fee40a0h
		dd	0bf737c00h, 03fede592h
		dd	0bf726800h, 03fed8b8ch
		dd	0bf714c00h, 03fed2ea3h
		dd	0bf704000h, 03fecd6b3h
		dd	0bf6f2800h, 03fec7a8dh
		dd	0bf6e1c00h, 03fec2217h
		dd	0bf6d1000h, 03febc95eh
		dd	0bf6c0400h, 03feb7062h
		dd	0bf6afc00h, 03feb1878h
		dd	0bf69f400h, 03feac04ch
		dd	0bf68ec00h, 03fea67deh
		dd	0bf67ec00h, 03fea11deh
		dd	0bf66e800h, 03fe9ba45h
		dd	0bf65e800h, 03fe963c5h
		dd	0bf64ec00h, 03fe90e60h
		dd	0bf63f000h, 03fe8b8bch
		dd	0bf62f400h, 03fe862d9h
		dd	0bf620000h, 03fe80f73h
		dd	0bf610400h, 03fe7b912h
		dd	0bf601000h, 03fe76532h
		dd	0bf5f2000h, 03fe71276h
		dd	0bf5e2c00h, 03fe6be1ch
		dd	0bf5d3c00h, 03fe66ae8h
		dd	0bf5c5000h, 03fe618dch
		dd	0bf5b6000h, 03fe5c530h
		dd	0bf5a7800h, 03fe57414h
		dd	0bf598c00h, 03fe52157h
		dd	0bf58a800h, 03fe4d12fh
		dd	0bf57c000h, 03fe47f65h
		dd	0bf56dc00h, 03fe42ecbh
		dd	0bf55f800h, 03fe3ddf8h
		dd	0bf551800h, 03fe38e58h
		dd	0bf543800h, 03fe33e80h
		dd	0bf535c00h, 03fe2efdeh
		dd	0bf527c00h, 03fe29f96h
		dd	0bf51a000h, 03fe25086h
		dd	0bf50c800h, 03fe202b0h
		dd	0bf4ff000h, 03fe1b4a4h
		dd	0bf4f1c00h, 03fe167d5h
		dd	0bf4e4400h, 03fe1195dh
		dd	0bf4d7000h, 03fe0cc24h
		dd	0bf4c9c00h, 03fe07eb6h
		dd	0bf4bcc00h, 03fe0328ah
		dd	0bf4afc00h, 03fdfe62ah
		dd	0bf4a3000h, 03fdf9b0fh
		dd	0bf496000h, 03fdf4e47h
		dd	0bf489800h, 03fdf0441h
		dd	0bf47c800h, 03fdeb711h
		dd	0bf470400h, 03fde6e24h
		dd	0bf463c00h, 03fde2388h
		dd	0bf457400h, 03fddd8bah
		dd	0bf44b000h, 03fdd8f3ah
		dd	0bf43ec00h, 03fdd4589h
		dd	0bf432800h, 03fdcfba7h
		dd	0bf426800h, 03fdcb317h
		dd	0bf41a800h, 03fdc6a57h
		dd	0bf40e800h, 03fdc2167h
		dd	0bf402c00h, 03fdbd9cdh
		dd	0bf3f6c00h, 03fdb907dh
		dd	0bf3eb400h, 03fdb4a0dh
		dd	0bf3dfc00h, 03fdb036fh
		dd	0bf3d4000h, 03fdabb19h
		dd	0bf3c8800h, 03fda741fh
		dd	0bf3bd400h, 03fda2e83h
		dd	0bf3b2000h, 03fd9e8bah
		dd	0bf3a6800h, 03fd9a136h
		dd	0bf39b400h, 03fd95b13h
		dd	0bf390800h, 03fd917e3h
		dd	0bf385000h, 03fd8cfd5h
		dd	0bf37a400h, 03fd88c4fh
		dd	0bf36f800h, 03fd8489eh
		dd	0bf364400h, 03fd8019ah
		dd	0bf359c00h, 03fd7bf28h
		dd	0bf34f000h, 03fd77af6h
		dd	0bf344400h, 03fd73699h
		dd	0bf339c00h, 03fd6f3a9h
		dd	0bf32f400h, 03fd6b08fh
		dd	0bf324c00h, 03fd66d4bh
		dd	0bf31a800h, 03fd62b78h
		dd	0bf310000h, 03fd5e7e0h
		dd	0bf305c00h, 03fd5a5bbh
		dd	0bf2fb800h, 03fd5636dh
		dd	0bf2f1800h, 03fd52295h
		dd	0bf2e7400h, 03fd4dff5h
		dd	0bf2dd800h, 03fd4a06eh
		dd	0bf2d3400h, 03fd45d7ch
		dd	0bf2c9800h, 03fd41da7h
		dd	0bf2bf800h, 03fd3dc07h
		dd	0bf2b6000h, 03fd39d89h
		dd	0bf2ac000h, 03fd35b99h
		dd	0bf2a2800h, 03fd31ccfh
		dd	0bf298c00h, 03fd2dc37h
		dd	0bf28f400h, 03fd29d21h
		dd	0bf285c00h, 03fd25de5h
		dd	0bf27c400h, 03fd21e83h
		dd	0bf273000h, 03fd1e0a7h
		dd	0bf269800h, 03fd1a0f9h
		dd	0bf260400h, 03fd162d3h
		dd	0bf257000h, 03fd12488h
		dd	0bf24e000h, 03fd0e7c8h
		dd	0bf244c00h, 03fd0a933h
		dd	0bf23bc00h, 03fd06c2bh
		dd	0bf232800h, 03fd02d4ch
		dd	0bf229c00h, 03fcff1b0h
		dd	0bf220c00h, 03fcfb43ch
		dd	0bf218000h, 03fcf785ah
		dd	0bf20f400h, 03fcf3c55h
		dd	0bf206400h, 03fcefe75h
		dd	0bf1fdc00h, 03fcec3e3h
		dd	0bf1f4c00h, 03fce85bbh
		dd	0bf1ec800h, 03fce4ca0h
		dd	0bf1e3c00h, 03fce0fech
		dd	0bf1db400h, 03fcdd4d2h
		dd	0bf1d2c00h, 03fcd9996h
		dd	0bf1ca800h, 03fcd5ff7h
		dd	0bf1c2000h, 03fcd2477h
		dd	0bf1b9800h, 03fcce8d5h
		dd	0bf1b1800h, 03fccb095h
		dd	0bf1a9400h, 03fcc7672h
		dd	0bf1a0c00h, 03fcc3a6ah
		dd	0bf199000h, 03fcc038fh
		dd	0bf190800h, 03fcbc743h
		dd	0bf188c00h, 03fcb902ah
		dd	0bf180800h, 03fcb5562h
		dd	0bf178c00h, 03fcb1e0bh
		dd	0bf170c00h, 03fcae4cbh
		dd	0bf168c00h, 03fcaab6bh
		dd	0bf161000h, 03fca73b7h
		dd	0bf159400h, 03fca3be4h
		dd	0bf151800h, 03fca03f2h
		dd	0bf149800h, 03fc9ca12h
		dd	0bf142400h, 03fc99582h
		dd	0bf13a400h, 03fc95b62h
		dd	0bf133000h, 03fc92698h
		dd	0bf12b400h, 03fc8ee0bh
		dd	0bf123c00h, 03fc8b733h
		dd	0bf11c400h, 03fc8803dh
		dd	0bf114c00h, 03fc84929h
		dd	0bf10d800h, 03fc813ceh
		dd	0bf106400h, 03fc7de56h
		dd	0bf0fec00h, 03fc7a6e8h
		dd	0bf0f7800h, 03fc77136h
		dd	0bf0f0400h, 03fc73b67h
		dd	0bf0e9000h, 03fc7057bh
		dd	0bf0e2000h, 03fc6d14fh
		dd	0bf0dac00h, 03fc69b29h
		dd	0bf0d3c00h, 03fc666c5h
		dd	0bf0ccc00h, 03fc63245h
		dd	0bf0c5800h, 03fc5fbc8h
		dd	0bf0bec00h, 03fc5c8f2h
		dd	0bf0b7c00h, 03fc5941eh
		dd	0bf0b0c00h, 03fc55f2eh
		dd	0bf0aa000h, 03fc52c07h
		dd	0bf0a3000h, 03fc4f6dfh
		dd	0bf09c400h, 03fc4c382h
		dd	0bf095c00h, 03fc491f2h
		dd	0bf08ec00h, 03fc45c76h
		dd	0bf088000h, 03fc428c8h
		dd	0bf081800h, 03fc3f6eah
		dd	0bf07b000h, 03fc3c4f2h
		dd	0bf074000h, 03fc38f06h
		dd	0bf06dc00h, 03fc35ec8h
		dd	0bf067400h, 03fc32c82h
		dd	0bf060800h, 03fc2f832h
		dd	0bf05a400h, 03fc2c7a9h
		dd	0bf053c00h, 03fc29515h
		dd	0bf04d800h, 03fc2645ah
		dd	0bf047000h, 03fc23192h
		dd	0bf040800h, 03fc1feb0h
		dd	0bf03a800h, 03fc1cfa0h
		dd	0bf034000h, 03fc19c8ah
		dd	0bf02dc00h, 03fc16b52h
		dd	0bf027c00h, 03fc13bfah
		dd	0bf021800h, 03fc10a90h
		dd	0bf01b400h, 03fc0d90dh
		dd	0bf015000h, 03fc0a771h
		dd	0bf00f400h, 03fc079b6h
		dd	0bf009000h, 03fc047e8h
		dd	0bf003000h, 03fc01800h
		dd	0beff4000h, 03fbfd000h
		dd	0befdc400h, 03fbf70a1h
		dd	0befc4c00h, 03fbf11e5h
		dd	0befad800h, 03fbeb3ceh
		dd	0bef96400h, 03fbe555ah
		dd	0bef7f800h, 03fbdf893h
		dd	0bef68e00h, 03fbd9bf4h
		dd	0bef52600h, 03fbd3f7eh
		dd	0bef3c200h, 03fbce3b6h
		dd	0bef26200h, 03fbc889eh
		dd	0bef10600h, 03fbc2e38h
		dd	0beefac00h, 03fbbd400h
		dd	0beee5400h, 03fbb79f8h
		dd	0beed0200h, 03fbb212eh
		dd	0beebb200h, 03fbac896h
		dd	0beea6600h, 03fba70b9h
		dd	0bee91a00h, 03fba1889h
		dd	0bee7d400h, 03fb9c1a0h
		dd	0bee69000h, 03fb96aeeh
		dd	0bee54e00h, 03fb91474h
		dd	0bee41200h, 03fb8bf48h
		dd	0bee2d400h, 03fb86942h
		dd	0bee19e00h, 03fb8151ah
		dd	0bee06600h, 03fb7c018h
		dd	0bedf3400h, 03fb76c6ch
		dd	0bede0400h, 03fb71900h
		dd	0bedcd600h, 03fb6c5d4h
		dd	0bedbac00h, 03fb67379h
		dd	0beda8400h, 03fb62161h
		dd	0bed95e00h, 03fb5cf8eh
		dd	0bed83a00h, 03fb57e00h
		dd	0bed71a00h, 03fb52d48h
		dd	0bed5fc00h, 03fb4dcd8h
		dd	0bed4e000h, 03fb48cb0h
		dd	0bed3c800h, 03fb43d64h
		dd	0bed2b000h, 03fb3edd2h
		dd	0bed19c00h, 03fb39f1eh
		dd	0bed08a00h, 03fb350b8h
		dd	0becf7c00h, 03fb30333h
		dd	0bece6c00h, 03fb2b4d7h
		dd	0becd6200h, 03fb267f3h
		dd	0becc5a00h, 03fb21b61h
		dd	0becb5200h, 03fb1ce8dh
		dd	0beca4e00h, 03fb182a2h
		dd	0bec94c00h, 03fb1370ch
		dd	0bec84a00h, 03fb0eb36h
		dd	0bec74e00h, 03fb0a0e4h
		dd	0bec65200h, 03fb05652h
		dd	0bec55800h, 03fb00c1ah
		dd	0bec45e00h, 03fafc1a4h
		dd	0bec36a00h, 03faf78bah
		dd	0bec27600h, 03faf2f93h
		dd	0bec18400h, 03faee6c9h
		dd	0bec09600h, 03fae9ef8h
		dd	0bebfa600h, 03fae5650h
		dd	0bebeba00h, 03fae0ea2h
		dd	0bebdd000h, 03fadc756h
		dd	0bebce800h, 03fad806ch
		dd	0bebc0000h, 03fad3948h
		dd	0bebb1e00h, 03facf3c3h
		dd	0beba3a00h, 03facad67h
		dd	0beb95800h, 03fac6770h
		dd	0beb87a00h, 03fac2280h
		dd	0beb79c00h, 03fabdd57h
		dd	0beb6c000h, 03fab9897h
		dd	0beb5e600h, 03fab5440h
		dd	0beb50e00h, 03fab1054h
		dd	0beb43600h, 03faacc32h
		dd	0beb36200h, 03faa891eh
		dd	0beb28e00h, 03faa45d6h
		dd	0beb1bc00h, 03faa02fah
		dd	0beb0ec00h, 03fa9c08eh
		dd	0beb01e00h, 03fa97e92h
		dd	0beaf5000h, 03fa93c63h
		dd	0beae8600h, 03fa8fb4ah
		dd	0beadba00h, 03fa8b959h
		dd	0beacf400h, 03fa87927h
		dd	0beac2a00h, 03fa83776h
		dd	0beab6600h, 03fa7f788h
		dd	0beaaa200h, 03fa7b76ah
		dd	0bea9e000h, 03fa777c2h
		dd	0bea91e00h, 03fa737e9h
		dd	0bea85e00h, 03fa6f889h
		dd	0bea7a000h, 03fa6b9a2h
		dd	0bea6e400h, 03fa67b36h
		dd	0bea62800h, 03fa63c9ch
		dd	0bea56e00h, 03fa5fe7ch
		dd	0bea4b400h, 03fa5c02fh
		dd	0bea3fe00h, 03fa5830bh
		dd	0bea34600h, 03fa5450dh
		dd	0bea29400h, 03fa508e8h
		dd	0bea1de00h, 03fa4cb3ch
		dd	0bea12c00h, 03fa48ebeh
		dd	0bea07c00h, 03fa452c2h
		dd	0be9fcc00h, 03fa4169ah
		dd	0be9f1e00h, 03fa3daf5h
		dd	0be9e7000h, 03fa39f25h
		dd	0be9dc400h, 03fa363dah
		dd	0be9d1a00h, 03fa32915h
		dd	0be9c7000h, 03fa2ee26h
		dd	0be9bc800h, 03fa2b3beh
		dd	0be9b2000h, 03fa2792ch
		dd	0be9a7a00h, 03fa23f22h
		dd	0be99d600h, 03fa205a4h
		dd	0be993200h, 03fa1cbfch
		dd	0be989000h, 03fa192dfh
		dd	0be97ec00h, 03fa158e5h
		dd	0be974e00h, 03fa120e2h
		dd	0be96ae00h, 03fa0e802h
		dd	0be961000h, 03fa0afb1h
		dd	0be957200h, 03fa07738h
		dd	0be94d800h, 03fa04006h
		dd	0be943a00h, 03fa0073eh
		dd	0be93a200h, 03f9fd078h
		dd	0be930a00h, 03f9f998ch
		dd	0be927000h, 03f9f61c1h
		dd	0be91da00h, 03f9f2b43h
		dd	0be914400h, 03f9ef4a0h
		dd	0be90b000h, 03f9ebe92h
		dd	0be901a00h, 03f9e87a3h
		dd	0be8f8a00h, 03f9e52c3h
		dd	0be8ef600h, 03f9e1c46h
		dd	0be8e6600h, 03f9de71eh
		dd	0be8dd600h, 03f9db1d2h
		dd	0be8d4600h, 03f9d7c62h
		dd	0be8cb800h, 03f9d478ch
		dd	0be8c2c00h, 03f9d1352h
		dd	0be8b9e00h, 03f9cde36h
		dd	0be8b1400h, 03f9caa76h
		dd	0be8a8a00h, 03f9c7694h
		dd	0be8a0000h, 03f9c428eh
		dd	0be897600h, 03f9c0e67h
		dd	0be88f000h, 03f9bdba1h
		dd	0be886800h, 03f9ba7f7h
		dd	0be87e200h, 03f9b74eeh
		dd	0be875e00h, 03f9b4287h
		dd	0be86d800h, 03f9b0f3bh
		dd	0be865600h, 03f9add56h
		dd	0be85d200h, 03f9aaa8ch
		dd	0be855200h, 03f9a792ch
		dd	0be84d000h, 03f9a46e6h
		dd	0be844e00h, 03f9a1480h
		dd	0be83d000h, 03f99e387h
		dd	0be835200h, 03f99b26eh
		dd	0be82d400h, 03f998136h
		dd	0be825600h, 03f994fdfh
		dd	0be81da00h, 03f991f31h
		dd	0be816000h, 03f98ef2eh
		dd	0be80e400h, 03f98be42h
		dd	0be806a00h, 03f988e01h
		dd	0be7fe000h, 03f985da2h
		dd	0be7ef400h, 03f982ebch
		dd	0be7e0000h, 03f97fe20h
		dd	0be7d1400h, 03f97cefeh
		dd	0be7c2400h, 03f979ef2h
		dd	0be7b3c00h, 03f977063h
		dd	0be7a5400h, 03f9741b7h
		dd	0be796800h, 03f971220h
		dd	0be788400h, 03f96e408h
		dd	0be779c00h, 03f96b506h
		dd	0be76b800h, 03f9686b6h
		dd	0be75d800h, 03f96591ah
		dd	0be74f400h, 03f962a90h
		dd	0be741400h, 03f95fcbch
		dd	0be733400h, 03f95cecch
		dd	0be725800h, 03f95a193h
		dd	0be717c00h, 03f95743eh
		dd	0be70a400h, 03f9547a1h
		dd	0be6fc800h, 03f951a15h
		dd	0be6ef000h, 03f94ed42h
		dd	0be6e1800h, 03f94c054h
		dd	0be6d4000h, 03f94934bh
		dd	0be6c7000h, 03f9467d3h
		dd	0be6b9c00h, 03f943b6ah
		dd	0be6ac800h, 03f940ee8h
		dd	0be69f800h, 03f93e322h
		dd	0be692800h, 03f93b742h
		dd	0be685c00h, 03f938c20h
		dd	0be678c00h, 03f93600ch
		dd	0be66c000h, 03f9334b8h
		dd	0be65f800h, 03f930a24h
		dd	0be652c00h, 03f92de9ch
		dd	0be646400h, 03f92b3d6h
		dd	0be639c00h, 03f9288f7h
		dd	0be62d400h, 03f925dffh
		dd	0be621000h, 03f9233cah
		dd	0be615000h, 03f920a5ah
		dd	0be608800h, 03f91df18h
		dd	0be5fc800h, 03f91b578h
		dd	0be5f0800h, 03f918bc0h
		dd	0be5e4800h, 03f9161f0h
		dd	0be5d8800h, 03f913808h
		dd	0be5ccc00h, 03f910ee8h
		dd	0be5c0c00h, 03f90e4d0h
		dd	0be5b5400h, 03f90bc62h
		dd	0be5a9800h, 03f9092fbh
		dd	0be59e000h, 03f906a5fh
		dd	0be592800h, 03f9041ach
		dd	0be587000h, 03f9018e2h
		dd	0be57b800h, 03f8ff001h
		dd	0be570400h, 03f8fc7edh
		dd	0be565000h, 03f8f9fc2h
		dd	0be559c00h, 03f8f7782h
		dd	0be54e800h, 03f8f4f2ah
		dd	0be543800h, 03f8f27a2h
		dd	0be538800h, 03f8f0004h
		dd	0be52d800h, 03f8ed850h
		dd	0be522c00h, 03f8eb16eh
		dd	0be517c00h, 03f8e898eh
		dd	0be50d000h, 03f8e6280h
		dd	0be502400h, 03f8e3b5dh
		dd	0be4f7800h, 03f8e1424h
		dd	0be4ecc00h, 03f8decd6h
		dd	0be4e2800h, 03f8dc748h
		dd	0be4d7c00h, 03f8d9fcfh
		dd	0be4cd800h, 03f8d7a18h
		dd	0be4c3000h, 03f8d5360h
		dd	0be4b8800h, 03f8d2c92h
		dd	0be4ae800h, 03f8d078ah
		dd	0be4a4000h, 03f8ce094h
		dd	0be49a000h, 03f8cbb64h
		dd	0be48fc00h, 03f8c9531h
		dd	0be485c00h, 03f8c6fd9h
		dd	0be47bc00h, 03f8c4a6dh
		dd	0be471c00h, 03f8c24edh
		dd	0be467c00h, 03f8bff59h
		dd	0be45e000h, 03f8bdaa2h
		dd	0be454000h, 03f8bb4e6h
		dd	0be44a800h, 03f8b90fah
		dd	0be440800h, 03f8b6b16h
		dd	0be437000h, 03f8b4704h
		dd	0be42d800h, 03f8b22dfh
		dd	0be423c00h, 03f8afdb3h
		dd	0be41a400h, 03f8ad968h
		dd	0be410c00h, 03f8ab50ah
		dd	0be407800h, 03f8a918eh
		dd	0be3fe000h, 03f8a6d0ah
		dd	0be3f4c00h, 03f8a496ah
		dd	0be3eb400h, 03f8a24c0h
		dd	0be3e2400h, 03f8a01f2h
		dd	0be3d9000h, 03f89de1ah
		dd	0be3d0000h, 03f89bb28h
		dd	0be3c6c00h, 03f89972bh
		dd	0be3bd800h, 03f89731ch
		dd	0be3b4c00h, 03f8950eeh
		dd	0be3abc00h, 03f892db4h
		dd	0be3a3000h, 03f890b62h
		dd	0be399c00h, 03f88e709h
		dd	0be391400h, 03f88c591h
		dd	0be388400h, 03f88a20fh
		dd	0be37fc00h, 03f888075h
		dd	0be377000h, 03f885dcch
		dd	0be36e400h, 03f883b12h
		dd	0be365800h, 03f881847h
		dd	0be35d400h, 03f87f768h
		dd	0be354800h, 03f87d47ah

.code

SQRT_TAB_LOG2       equ     9           ;; log2 of the lookup-table
MANTISSA_SIZE       equ     24          ;; number if mantissa bits in fp value
                                        ;; number of represented mantissa bits
                                        ;; (one less than total due to hidden
                                        ;; leading one).
MANTISSA_BITS       equ     (MANTISSA_SIZE - 1)
ELEMENT_SIZE_LOG2   equ     3           ;; log2 of each table entry (8 bytes)
                                        ;; shift required to get bits in value
                                        ;; in the correct place to use as an
                                        ;; index for the table lookup
EXPONENT_SHIFT      equ     (MANTISSA_BITS - (SQRT_TAB_LOG2 - 1)\
                             - ELEMENT_SIZE_LOG2)
                                        ;; mask value for clamping to [.5..2)
CLAMP_MASK          equ     ((1 SHL (MANTISSA_BITS+1)) - 1)
                                        ;; mask for sign/exponent bits
MANTISSA_MASK        equ     ((1 SHL MANTISSA_BITS) - 1)
                                        ;; mask for sign/exponent bits
EXPONENT_MASK       equ     (-1 AND (NOT MANTISSA_MASK))
                                        ;; mask for table lookup
TABLE_MASK          equ     ((1 SHL (SQRT_TAB_LOG2 + ELEMENT_SIZE_LOG2)) - 1) \
                            AND (NOT((1 SHL ELEMENT_SIZE_LOG2) - 1))
                                        ;; bias used to represent clamped value
EXPONENT_BIAS_EVEN  equ     3f000000h
                                        ;; bias value used for final exponent
                                        ;; computation
LARGE_EXPONENT_BIAS equ     (((127 + 127/2) SHL (MANTISSA_BITS+1)) OR CLAMP_MASK)


x 	equ DWORD PTR 8[ebp]
num 	equ DWORD PTR -8[ebp]

@__FastInvSqrt@4 PROC NEAR

	push	ebp
	mov	ebp, esp
	sub	esp, 8
        push    ecx

        mov     eax, x
        mov     ecx, eax
        shr     ecx, EXPONENT_SHIFT     ;; ecx is table index (8 frac. bits)
        and     eax, CLAMP_MASK		;; clamp number to [0.5, 2.0]
        and     ecx, TABLE_MASK		;; (8 bytes)/(table entry)
        or      eax, EXPONENT_BIAS_EVEN	;; re-adjust exponent for clamped number
        mov     num, eax
        fld     num
        fmul    [invSqrtTab+ecx]        ;; find mx
        mov     eax, LARGE_EXPONENT_BIAS;; (127+63)<<23 to re-adjust exponent
        sub     eax, x                  ;; divide exponent by 2
        fadd    [invSqrtTab+ecx+4]      ;; get mx + b
        shr     eax, 1
        and     eax, EXPONENT_MASK     	;; mask exponent
        mov     num, eax
        fmul    num                     ;; now adjust for exponent

        pop     ecx
	mov	esp, ebp
	pop	ebp
	ret     4

@__FastInvSqrt@4 endp

len 	equ DWORD PTR -4[ebp]
num 	equ DWORD PTR -8[ebp]

@__glNormalize@8 PROC NEAR

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	fld	DWORD PTR [edx]
	fmul	DWORD PTR [edx]		;; x
	fld	DWORD PTR [edx+4]
	fmul	DWORD PTR [edx+4]	;; y x
	fld	DWORD PTR [edx+8]
	fmul	DWORD PTR [edx+8]	;; z y x
	fxch	ST(2)			;; x y z
	faddp	ST(1), ST		;; xy z
	faddp	ST(1), ST		;; xyz
	fstp	len
	mov	eax, len
	test	eax, eax
	jne	notZeroLen

	mov	[ecx], eax
	mov	[ecx+4], eax
	mov	[ecx+8], eax
	mov	esp, ebp
	pop	ebp
	ret	0

notZeroLen:

	cmp	eax, __FLOAT_ONE
	jne	notOneLen
	cmp	ecx, edx
	je	normExit
	mov	eax, [edx]
	mov	[ecx], eax
	mov	eax, [edx+4]
	mov	[ecx+4], eax
	mov	eax, [edx+8]
	mov	[ecx+8], eax
	mov	esp, ebp
	pop	ebp
	ret	0

notOneLen:

	;; eax already has length

	push	edi
        mov     edi, eax
        shr     edi, EXPONENT_SHIFT     ;; edi is table index (8 frac. bits)
        and     eax, CLAMP_MASK		;; clamp number to [0.5, 2.0]
        and     edi, TABLE_MASK		;; (8 bytes)/(table entry)
        or      eax, EXPONENT_BIAS_EVEN	;; re-adjust exponent for clamped number
        mov     num, eax
        fld     num
        fmul    [invSqrtTab+edi]        ;; find mx
        mov     eax, LARGE_EXPONENT_BIAS;; (127+63)<<23 to re-adjust exponent
        sub     eax, len                ;; divide exponent by 2
        fadd    [invSqrtTab+edi+4]      ;; get mx + b
        shr     eax, 1
        and     eax, EXPONENT_MASK     	;; mask exponent
        mov     num, eax
        fmul    num                     ;; now adjust for exponent

	fld	DWORD PTR [edx]		;; 1/sqrt(len) on stack
	fmul	ST, ST(1)
	fld	DWORD PTR [edx+4]
	fmul	ST, ST(2)
	fld	DWORD PTR [edx+8]
	fmul	ST, ST(3)		;; z y x len
	fxch	ST(2)			;; x y z len
	fstp	DWORD PTR [ecx]
	fstp	DWORD PTR [ecx+4]
	fstp	DWORD PTR [ecx+8]
	fstp	ST(0)			;; pop len
	
        pop	edi
	mov	esp, ebp
	pop	ebp
	ret	0

normExit:

	mov	esp, ebp
	pop	ebp
	ret     0

@__glNormalize@8 ENDP

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\i386\gli386.c ===
/******************************Module*Header*******************************\
* Module Name: gli386.c                                                    *
*                                                                          *
* This module implements a program which generates structure offset        *
* definitions for OpenGL structures that are accessed in assembly code.    *
*                                                                          *
* Created: 24-Aug-1992 01:24:49                                            *
* Author: Charles Whitmer [chuckwh]                                        *
* Ported for OpenGL 4/1/1994 Otto Berkes [ottob]                           *
*                                                                          *
* Copyright (c) 1994 Microsoft Corporation                                 *
\**************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <stdio.h>
#include <windows.h>
#include <ddraw.h>

#include <glp.h>
#include "types.h"
#include "context.h"
#include "render.h"
#include "attrib.h"
#include "gencx.h"
#define __BUILD_GLI386__
#include "..\..\dlist\dl_pdata.h"


#define OFFSET(type, field) ((LONG)(&((type *)0)->field))

// pblank prints a blank line.

#define pblank()     fprintf(outfh,"\n")

// pstruct defines an empty structure with the correct size.

#define pstruct(n,c) fprintf(outfh,                           \
                     "%s  struc\n  db %d dup(0)\n%s  ends\n", \
                     n,c,n);

// pstr prints a string.

#define pstr(s)  fprintf(outfh,"%s\n",s)


// pcomment prints a comment.

#define pcomment(s)  fprintf(outfh,"; %s\n",s)

// pequate prints an equate statement.

#define pequate(m,v) fprintf(outfh,"%s equ 0%lXH\n",m,v);

void CreateInc(FILE *outfh)
{
    __GLmatrix *m = 0;
    __GLfloat one = (__GLfloat)1;
    
    pblank();
    pcomment("------------------------------------------------------------------");
    pcomment(" Module Name: gli386.inc");
    pcomment("");
    pcomment(" Defines OpenGL assembly-language structures.");
    pcomment("");
    pcomment(" Copyright (c) 1994, 1995 Microsoft Corporation");
    pcomment("------------------------------------------------------------------");
    pblank();
    pblank();
    pblank();

    pcomment("Matrix structure offsets");
    pblank();
    pequate("__MATRIX_M00           ", &m->matrix[0][0]);
    pequate("__MATRIX_M01           ", &m->matrix[0][1]);
    pequate("__MATRIX_M02           ", &m->matrix[0][2]);
    pequate("__MATRIX_M03           ", &m->matrix[0][3]);
    pequate("__MATRIX_M10           ", &m->matrix[1][0]);
    pequate("__MATRIX_M11           ", &m->matrix[1][1]);
    pequate("__MATRIX_M12           ", &m->matrix[1][2]);
    pequate("__MATRIX_M13           ", &m->matrix[1][3]);
    pequate("__MATRIX_M20           ", &m->matrix[2][0]);
    pequate("__MATRIX_M21           ", &m->matrix[2][1]);
    pequate("__MATRIX_M22           ", &m->matrix[2][2]);
    pequate("__MATRIX_M23           ", &m->matrix[2][3]);
    pequate("__MATRIX_M30           ", &m->matrix[3][0]);
    pequate("__MATRIX_M31           ", &m->matrix[3][1]);
    pequate("__MATRIX_M32           ", &m->matrix[3][2]);
    pequate("__MATRIX_M33           ", &m->matrix[3][3]);
    pblank();

    // GLGENwindow

    pcomment("GLGENwindow structure");
    pblank();
    pequate("GENWIN_sem             ", OFFSET(GLGENwindow, sem));
    pequate("GENWIN_lUsers          ", OFFSET(GLGENwindow, lUsers));
    pequate("GENWIN_gengc           ", OFFSET(GLGENwindow, gengc));
    pequate("GENWIN_owningThread    ", OFFSET(GLGENwindow, owningThread));
    pequate("GENWIN_lockRecursion   ", OFFSET(GLGENwindow, lockRecursion));
    pblank();

// Stuff from: \nt\private\windows\gdi\opengl\server\inc\gencx.h

    pcomment("__GLGENcontextRec structure");
    pblank();
    pstruct("GLGENcontextRec",sizeof(struct __GLGENcontextRec));
    pblank();
    pequate("GENCTX_hrc               ",OFFSET(struct __GLGENcontextRec,hrc       ));
    pequate("GENCTX_pajTranslateVector",OFFSET(struct __GLGENcontextRec,pajTranslateVector));
    pequate("GENCTX_pPrivateArea      ",OFFSET(struct __GLGENcontextRec,pPrivateArea));
    pequate("GENGC_ColorsBits         ",OFFSET(struct __GLGENcontextRec,ColorsBits));
    pequate("GENGC_SPAN_r             ",OFFSET(struct __GLGENcontextRec,genAccel.spanValue.r));
    pequate("GENGC_SPAN_g             ",OFFSET(struct __GLGENcontextRec,genAccel.spanValue.g));
    pequate("GENGC_SPAN_b             ",OFFSET(struct __GLGENcontextRec,genAccel.spanValue.b));
    pequate("GENGC_SPAN_a             ",OFFSET(struct __GLGENcontextRec,genAccel.spanValue.a));
    pequate("GENGC_SPAN_s             ",OFFSET(struct __GLGENcontextRec,genAccel.spanValue.s));
    pequate("GENGC_SPAN_t             ",OFFSET(struct __GLGENcontextRec,genAccel.spanValue.t));
    pequate("GENGC_SPAN_dr            ",OFFSET(struct __GLGENcontextRec,genAccel.spanDelta.r));
    pequate("GENGC_SPAN_dg            ",OFFSET(struct __GLGENcontextRec,genAccel.spanDelta.g));
    pequate("GENGC_SPAN_db            ",OFFSET(struct __GLGENcontextRec,genAccel.spanDelta.b));
    pequate("GENGC_SPAN_da            ",OFFSET(struct __GLGENcontextRec,genAccel.spanDelta.a));
    pequate("GENGC_SPAN_ds            ",OFFSET(struct __GLGENcontextRec,genAccel.spanDelta.s));
    pequate("GENGC_SPAN_dt            ",OFFSET(struct __GLGENcontextRec,genAccel.spanDelta.t));
    pequate("GENGC_SPAN_z             ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.frag.z));
    pequate("GENGC_SPAN_dz            ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.dzdx));
    pequate("GENGC_SPAN_zbuf          ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.zbuf));
    pequate("GENGC_SPAN_ppix          ",OFFSET(struct __GLGENcontextRec,genAccel.pPix));
    pequate("GENGC_SPAN_x             ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.frag.x));
    pequate("GENGC_SPAN_y             ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.frag.y));
    pequate("GENGC_SPAN_length        ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.length));
    pequate("GENGC_rAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.rAccum));
    pequate("GENGC_gAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.gAccum));
    pequate("GENGC_bAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.bAccum));
    pequate("GENGC_aAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.aAccum));
    pequate("GENGC_zAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.zAccum));
    pequate("GENGC_sAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.sAccum));
    pequate("GENGC_tAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.tAccum));
    pequate("GENGC_pixAccum           ",OFFSET(struct __GLGENcontextRec,genAccel.pixAccum));
    pequate("GENGC_ditherAccum        ",OFFSET(struct __GLGENcontextRec,genAccel.ditherAccum));
    pequate("GENGC_sResult            ",OFFSET(struct __GLGENcontextRec,genAccel.sResult[0]));
    pequate("GENGC_tResult            ",OFFSET(struct __GLGENcontextRec,genAccel.tResult[0]));
    pequate("GENGC_sResultNew         ",OFFSET(struct __GLGENcontextRec,genAccel.sResultNew[0]));
    pequate("GENGC_tResultNew         ",OFFSET(struct __GLGENcontextRec,genAccel.tResultNew[0]));
    pequate("GENGC_sMask              ",OFFSET(struct __GLGENcontextRec,genAccel.sMask));
    pequate("GENGC_tMaskSubDiv        ",OFFSET(struct __GLGENcontextRec,genAccel.tMaskSubDiv));
    pequate("GENGC_tShiftSubDiv       ",OFFSET(struct __GLGENcontextRec,genAccel.tShiftSubDiv));
    pequate("GENGC_texImage           ",OFFSET(struct __GLGENcontextRec,genAccel.texImage));
    pequate("GENGC_texImageReplace    ",OFFSET(struct __GLGENcontextRec,genAccel.texImageReplace));
    pequate("GENGC_texPalette         ",OFFSET(struct __GLGENcontextRec,genAccel.texPalette));
    pequate("GENGC_qwAccum            ",OFFSET(struct __GLGENcontextRec,genAccel.qwAccum));
    pequate("GENGC_SPAN_dqwdx         ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.dqwdx));
    pequate("GENGC_SPAN_qw            ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.frag.qw));
    pequate("GENGC_xlatPalette        ",OFFSET(struct __GLGENcontextRec,xlatPalette));
    pequate("GENGC_sStepX             ",OFFSET(struct __GLGENcontextRec,genAccel.sStepX));
    pequate("GENGC_tStepX             ",OFFSET(struct __GLGENcontextRec,genAccel.tStepX));
    pequate("GENGC_qwStepX            ",OFFSET(struct __GLGENcontextRec,genAccel.qwStepX));
    pequate("GENGC_subDs              ",OFFSET(struct __GLGENcontextRec,genAccel.subDs));
    pequate("GENGC_subDt              ",OFFSET(struct __GLGENcontextRec,genAccel.subDt));
    pequate("GENGC_rDisplay           ",OFFSET(struct __GLGENcontextRec,genAccel.displayColor[0]));
    pequate("GENGC_gDisplay           ",OFFSET(struct __GLGENcontextRec,genAccel.displayColor[1]));
    pequate("GENGC_bDisplay           ",OFFSET(struct __GLGENcontextRec,genAccel.displayColor[2]));
    pequate("GENGC_aDisplay           ",OFFSET(struct __GLGENcontextRec,genAccel.displayColor[3]));
    pequate("GENGC_bytesPerPixel      ",OFFSET(struct __GLGENcontextRec,genAccel.xMultiplier));
    pequate("GENGC_bpp                ",OFFSET(struct __GLGENcontextRec,genAccel.bpp));
    pequate("GENGC_flags              ",OFFSET(struct __GLGENcontextRec,genAccel.flags));
    pequate("GENGC_pInvTranslateVector",OFFSET(struct __GLGENcontextRec,pajInvTranslateVector));
    pequate("GENGC_pwndMakeCur        ", OFFSET(__GLGENcontext, pwndMakeCur));
    pequate("GENGC_pwndLocked         ", OFFSET(__GLGENcontext, pwndLocked));
    pequate("GENGC_fsLocks            ", OFFSET(__GLGENcontext, fsLocks));
    pequate("GENGC_fsGenLocks         ", OFFSET(__GLGENcontext, fsGenLocks));
    pblank();
    
    pequate("COLOR_r                ",OFFSET(struct __GLcolorRec,r  ));
    pequate("COLOR_g                ",OFFSET(struct __GLcolorRec,g  ));
    pequate("COLOR_b                ",OFFSET(struct __GLcolorRec,b  ));
    pequate("COLOR_a                ",OFFSET(struct __GLcolorRec,a  ));
    pblank();

// Stuff from: \nt\private\windows\gdi\opengl\server\inc\gencx.h

    pcomment("__GLcontextRec structure");
    pblank();
    pblank();
    pequate("GC_paTeb                   ",OFFSET(struct __GLcontextRec,paTeb));
    pequate("GC_oneOverRedVertexScale   ",OFFSET(struct __GLcontextRec,oneOverRedVertexScale));
    pequate("GC_oneOverGreenVertexScale ",OFFSET(struct __GLcontextRec,oneOverGreenVertexScale));
    pequate("GC_oneOverBlueVertexScale  ",OFFSET(struct __GLcontextRec,oneOverBlueVertexScale));
    pequate("GC_redVertexScale          ",OFFSET(struct __GLcontextRec,redVertexScale));
    pequate("GC_greenVertexScale        ",OFFSET(struct __GLcontextRec,greenVertexScale));
    pequate("GC_blueVertexScale         ",OFFSET(struct __GLcontextRec,blueVertexScale));
    pequate("GC_alphaVertexScale        ",OFFSET(struct __GLcontextRec,alphaVertexScale));
    pequate("GC_redClampTable           ",OFFSET(struct __GLcontextRec,redClampTable[0]));
    pequate("GC_greenClampTable         ",OFFSET(struct __GLcontextRec,greenClampTable[0]));
    pequate("GC_blueClampTable          ",OFFSET(struct __GLcontextRec,blueClampTable[0]));
    pequate("GC_alphaClampTable         ",OFFSET(struct __GLcontextRec,alphaClampTable[0]));


    pequate("GC_SHADER_R            ", OFFSET(__GLcontext, polygon.shader.frag.color.r));
    pequate("GC_SHADER_G            ", OFFSET(__GLcontext, polygon.shader.frag.color.g));
    pequate("GC_SHADER_B            ", OFFSET(__GLcontext, polygon.shader.frag.color.b));
    pequate("GC_SHADER_A            ", OFFSET(__GLcontext, polygon.shader.frag.color.a));
    pequate("GC_SHADER_DRDX         ", OFFSET(__GLcontext, polygon.shader.drdx));
    pequate("GC_SHADER_DGDX         ", OFFSET(__GLcontext, polygon.shader.dgdx));
    pequate("GC_SHADER_DBDX         ", OFFSET(__GLcontext, polygon.shader.dbdx));
    pequate("GC_SHADER_DADX         ", OFFSET(__GLcontext, polygon.shader.dadx));
    pblank();

    pequate("GC_LIGHT_front         ", OFFSET(__GLcontext, light.front));
    pequate("GC_LIGHT_back          ", OFFSET(__GLcontext, light.back));
    pblank();

    pequate("GC_mInv                ", OFFSET(__GLcontext, mInv));
    pblank();


    pcomment("Other constants");
    pblank();
    pequate("__FLOAT_ONE                 ", *(long*)&one);
    pblank();
    pequate("SURFACE_TYPE_DIB            ", SURFACE_TYPE_DIB);
    pequate("GEN_TEXTURE_ORTHO           ", GEN_TEXTURE_ORTHO);
    pequate("PANEEDS_NORMAL              ", PANEEDS_NORMAL);
    pequate("__GL_CLIP_USER0             ", __GL_CLIP_USER0);
    pequate("__GL_FRONTFACE              ", __GL_FRONTFACE);
    pequate("__GL_BACKFACE               ", __GL_BACKFACE);
    pequate("__GL_NORMALIZE_ENABLE       ", __GL_NORMALIZE_ENABLE);
    pequate("__GL_SPEC_LOOKUP_TABLE_SIZE ", __GL_SPEC_LOOKUP_TABLE_SIZE);
    pequate("__GL_MATERIAL_AMBIENT       ", __GL_MATERIAL_AMBIENT);
    pequate("__GL_MATERIAL_DIFFUSE       ", __GL_MATERIAL_DIFFUSE);
    pequate("__GL_MATERIAL_SPECULAR      ", __GL_MATERIAL_SPECULAR);
    pequate("__GL_MATERIAL_EMISSIVE      ", __GL_MATERIAL_EMISSIVE);
    
    pblank();
    pequate("GC_SHADE_rLittle       ",OFFSET(__GLcontext, polygon.shader.rLittle));
    pequate("GC_SHADE_gLittle       ",OFFSET(__GLcontext, polygon.shader.gLittle));
    pequate("GC_SHADE_bLittle       ",OFFSET(__GLcontext, polygon.shader.bLittle));
    pequate("GC_SHADE_aLittle       ",OFFSET(__GLcontext, polygon.shader.aLittle));

    pblank();
    pequate("GC_SHADE_drdy          ",OFFSET(__GLcontext, polygon.shader.drdy));
    pequate("GC_SHADE_dgdy          ",OFFSET(__GLcontext, polygon.shader.dgdy));
    pequate("GC_SHADE_dbdy          ",OFFSET(__GLcontext, polygon.shader.dbdy));
    pequate("GC_SHADE_dady          ",OFFSET(__GLcontext, polygon.shader.dady));

    pblank();
    pequate("GC_SHADE_drdx          ",OFFSET(__GLcontext, polygon.shader.drdx           ));
    pequate("GC_SHADE_dgdx          ",OFFSET(__GLcontext, polygon.shader.dgdx           ));
    pequate("GC_SHADE_dbdx          ",OFFSET(__GLcontext, polygon.shader.dbdx           ));
    pequate("GC_SHADE_dadx          ",OFFSET(__GLcontext, polygon.shader.dadx           ));

    pblank();
    pequate("GC_VIEWPORT_xScale     ", OFFSET(__GLcontext, state.viewport.xScale));
    pequate("GC_VIEWPORT_yScale     ", OFFSET(__GLcontext, state.viewport.yScale));
    pequate("GC_VIEWPORT_zScale     ", OFFSET(__GLcontext, state.viewport.zScale));
    pequate("GC_VIEWPORT_xCenter    ", OFFSET(__GLcontext, state.viewport.xCenter));
    pequate("GC_VIEWPORT_yCenter    ", OFFSET(__GLcontext, state.viewport.yCenter));
    pequate("GC_VIEWPORT_zCenter    ", OFFSET(__GLcontext, state.viewport.zCenter));

    pblank();
    pequate("GC_STATE_clipPlanes0       ",OFFSET(__GLcontext, state.transform.eyeClipPlanes));
    pequate("GC_STATE_enablesClipPlanes ",OFFSET(__GLcontext, state.enables.clipPlanes));
    pequate("GC_STATE_enablesGeneral    ",OFFSET(__GLcontext, state.enables.general));
    pequate("GC_STATE_lightModelAmbient ",OFFSET(__GLcontext, state.light.model.ambient));

    pblank();
    pequate("GC_LIGHT_sources       ",OFFSET(__GLcontext, light.sources));

    pblank();
    pequate("GC_VERTEX_paNeeds      ",OFFSET(__GLcontext, vertex.paNeeds));

    pblank();
    pequate("VERTEX_color           ", OFFSET(__GLvertex, color));

    pblank();
#ifndef _WIN95_
    pequate("TeglPaTeb              ", TeglPaTeb);
    pequate("TeglSectionInfo        ", TeglSectionInfo);
#else
    pequate("GtiPaTeb               ", OFFSET(GLTEBINFO, glReserved1));
    pequate("GtiSectionInfo         ", OFFSET(GLTEBINFO, glSectionInfo));
#endif

    pblank();
    pequate("sizeof_MATERIAL                ", sizeof(__GLmaterialMachine));
    pequate("MATERIAL_scale                 ", OFFSET(__GLmaterialMachine, scale));
    pequate("MATERIAL_threshold             ", OFFSET(__GLmaterialMachine, threshold));
    pequate("MATERIAL_specTable             ", OFFSET(__GLmaterialMachine, specTable));
    pequate("MATERIAL_alpha                 ", OFFSET(__GLmaterialMachine, alpha));
    pequate("MATERIAL_paSceneColor          ", OFFSET(__GLmaterialMachine, paSceneColor));
    pequate("MATERIAL_colorMaterialChange   ", OFFSET(__GLmaterialMachine, colorMaterialChange));
    pequate("MATERIAL_cachedEmissiveAmbient ", OFFSET(__GLmaterialMachine, cachedEmissiveAmbient));
    pequate("MATERIAL_cachedNonLit          ", OFFSET(__GLmaterialMachine, cachedNonLit));

    pblank();
    pequate("sizeof_LIGHTSOURCE     ", sizeof(__GLlightSourceMachine));
    pequate("LIGHTSOURCE_next       ", OFFSET(__GLlightSourceMachine, next));
    pequate("LIGHTSOURCE_front      ", OFFSET(__GLlightSourceMachine, front));
    pequate("LIGHTSOURCE_back       ", OFFSET(__GLlightSourceMachine, back));
    pequate("LIGHTSOURCE_unitVPpli  ", OFFSET(__GLlightSourceMachine, unitVPpli.x));
    pequate("LIGHTSOURCE_hHat       ", OFFSET(__GLlightSourceMachine, hHat.x));
    pequate("LIGHTSOURCE_state      ", OFFSET(__GLlightSourceMachine, state));

    pblank();
    pequate("sizeof_LIGHTSOURCESTATE   ", sizeof(__GLlightSourceState));
    pequate("LIGHTSOURCESTATE_ambient  ", OFFSET(__GLlightSourceState, ambient));
    pequate("LIGHTSOURCESTATE_diffuse  ", OFFSET(__GLlightSourceState, diffuse));
    pequate("LIGHTSOURCESTATE_specular ", OFFSET(__GLlightSourceState, specular));
   
    pblank();
    pequate("sizeof_LIGHTSOURCEPERMATERIAL   ", sizeof(__GLlightSourcePerMaterialMachine));
    pequate("LIGHTSOURCEPERMATERIAL_ambient  ", OFFSET(__GLlightSourcePerMaterialMachine, ambient.r));
    pequate("LIGHTSOURCEPERMATERIAL_specular ", OFFSET(__GLlightSourcePerMaterialMachine, specular.r));
    pequate("LIGHTSOURCEPERMATERIAL_diffuse  ", OFFSET(__GLlightSourcePerMaterialMachine, diffuse.r));
    
    pblank();
    pequate("PA_flags               ", OFFSET(POLYARRAY, flags));
    pequate("PA_pdNextVertex        ", OFFSET(POLYARRAY, pdNextVertex));
    pequate("PA_pdFlush             ", OFFSET(POLYARRAY, pdFlush));
    pequate("PA_pdCurNormal         ", OFFSET(POLYARRAY, pdCurNormal));
    pequate("PA_pdCurTexture        ", OFFSET(POLYARRAY, pdCurTexture));
    pequate("PA_pdCurColor          ", OFFSET(POLYARRAY, pdCurColor));
    pequate("PA_pd0                 ", OFFSET(POLYARRAY, pd0));
    pequate("PA_andClipCodes        ", OFFSET(POLYARRAY, andClipCodes));
    pequate("PA_orClipCodes         ", OFFSET(POLYARRAY, orClipCodes));
    pequate("POLYARRAY_IN_BEGIN     ", POLYARRAY_IN_BEGIN);
    pequate("POLYARRAY_VERTEX3      ", POLYARRAY_VERTEX3);
    pequate("POLYARRAY_VERTEX2      ", POLYARRAY_VERTEX2);
    pequate("POLYARRAY_TEXTURE2     ", POLYARRAY_TEXTURE2);
    pequate("POLYARRAY_TEXTURE3     ", POLYARRAY_TEXTURE3);
    pequate("POLYARRAY_CLAMP_COLOR  ", POLYARRAY_CLAMP_COLOR);
#ifdef GL_EXT_cull_vertex
    pequate("POLYARRAY_HAS_CULLED_VERTEX", POLYARRAY_HAS_CULLED_VERTEX);
    pequate("GL_EXT_cull_vertex", 1);
    pequate("NOT_GL_CLIP_CULL_VERTEX", ~__GL_CLIP_CULL_VERTEX);
#endif // GL_EXT_cull_vertex

    pblank();
    pequate("PD_flags               ", OFFSET(POLYDATA, flags));
    pequate("PD_obj                 ", OFFSET(POLYDATA, obj.x));
    pequate("PD_normal              ", OFFSET(POLYDATA, normal.x));
    pequate("PD_texture             ", OFFSET(POLYDATA, texture.x));
    pequate("PD_colors0             ", OFFSET(POLYDATA, colors[0].r));
    pequate("PD_clip                ", OFFSET(POLYDATA, clip.x));
    pequate("PD_window              ", OFFSET(POLYDATA, window.x));
    pequate("PD_eye                 ", OFFSET(POLYDATA, eye.x));
    pequate("PD_clipCode            ", OFFSET(POLYDATA, clipCode));
    pequate("POLYDATA_VERTEX3       ", POLYDATA_VERTEX3);
    pequate("POLYDATA_VERTEX2       ", POLYDATA_VERTEX2);
    pequate("POLYDATA_DLIST_TEXTURE2", POLYDATA_DLIST_TEXTURE2);
    pequate("POLYDATA_DLIST_TEXTURE3", POLYDATA_DLIST_TEXTURE3);
    pequate("POLYDATA_NORMAL_VALID  ", POLYDATA_NORMAL_VALID);
    pequate("POLYDATA_TEXTURE_VALID ", POLYDATA_TEXTURE_VALID);
    pequate("POLYDATA_COLOR_VALID   ", POLYDATA_COLOR_VALID);
    pequate("POLYDATA_NORMAL_VALID  ", POLYDATA_NORMAL_VALID);
    pequate("POLYDATA_DLIST_COLOR_4 ", POLYDATA_DLIST_COLOR_4);
    pequate("sizeof_POLYDATA        ", sizeof(POLYDATA));
#ifdef GL_EXT_cull_vertex
    pequate("PD_color               ", OFFSET(POLYDATA, color));
    pequate("POLYDATA_VERTEX_USED   ", POLYDATA_VERTEX_USED);
#endif // GL_EXT_cull_vertex

    pblank();
    pequate("GLMATRIX_xfNorm        ", OFFSET(__GLmatrix, xfNorm));

// Stuff from: \nt\private\windows\gdi\opengl\dlist\dl_pdata.h

    pblank();
    pblank();
    pequate("__PDATA_SIZE_T2F       ", __PDATA_SIZE_T2F);
    pequate("__PDATA_SIZE_C3F       " , __PDATA_SIZE_C3F);
    pequate("__PDATA_SIZE_C4F       ", __PDATA_SIZE_C4F);
    pequate("__PDATA_SIZE_N3F       ", __PDATA_SIZE_N3F);
    pequate("__PDATA_SIZE_V3F       ", __PDATA_SIZE_V3F);
    pequate("__PDATA_PD_FLAGS_T2F   ", __PDATA_PD_FLAGS_T2F);
    pequate("__PDATA_PD_FLAGS_C3F   ", __PDATA_PD_FLAGS_C3F);
    pequate("__PDATA_PD_FLAGS_C4F   ", __PDATA_PD_FLAGS_C4F);
    pequate("__PDATA_PD_FLAGS_N3F   ", __PDATA_PD_FLAGS_N3F);
    pequate("__PDATA_PD_FLAGS_V3F   ", __PDATA_PD_FLAGS_V3F);
    pequate("__PDATA_PA_FLAGS_T2F   ", __PDATA_PA_FLAGS_T2F);
    pequate("__PDATA_PA_FLAGS_C3F   ", __PDATA_PA_FLAGS_C3F);
    pequate("__PDATA_PA_FLAGS_C4F   ", __PDATA_PA_FLAGS_C4F);
    pequate("__PDATA_PA_FLAGS_N3F   ", __PDATA_PA_FLAGS_N3F);
    pequate("__PDATA_PA_FLAGS_V3F   ", __PDATA_PA_FLAGS_V3F);
}

#undef pstruct

// pcomment prints a comment.

#undef pcomment
#define pcomment(s)  fprintf(outfh,"// %s\n",s)

// pequate prints an equate statement.

#undef pequate
#define pequate(m,v) fprintf(outfh,"#define %s 0x%lX\n",m,v);

void CreateH(FILE *outfh)
{
    __GLmatrix *m = 0;
    __GLfloat one = (__GLfloat)1;
    
    pblank();
    pcomment("");
    pcomment(" Module Name: gli386.h");
    pcomment("");
    pcomment(" Defines OpenGL inline assembly structures.");
    pcomment("");
    pcomment(" Copyright (c) 1994-1996 Microsoft Corporation");
    pcomment("");
    pblank();
    pblank();
    pblank();

    pcomment("Matrix structure offsets");
    pblank();
    pequate("__MATRIX_M00", &m->matrix[0][0]);
    pequate("__MATRIX_M01", &m->matrix[0][1]);
    pequate("__MATRIX_M02", &m->matrix[0][2]);
    pequate("__MATRIX_M03", &m->matrix[0][3]);
    pequate("__MATRIX_M10", &m->matrix[1][0]);
    pequate("__MATRIX_M11", &m->matrix[1][1]);
    pequate("__MATRIX_M12", &m->matrix[1][2]);
    pequate("__MATRIX_M13", &m->matrix[1][3]);
    pequate("__MATRIX_M20", &m->matrix[2][0]);
    pequate("__MATRIX_M21", &m->matrix[2][1]);
    pequate("__MATRIX_M22", &m->matrix[2][2]);
    pequate("__MATRIX_M23", &m->matrix[2][3]);
    pequate("__MATRIX_M30", &m->matrix[3][0]);
    pequate("__MATRIX_M31", &m->matrix[3][1]);
    pequate("__MATRIX_M32", &m->matrix[3][2]);
    pequate("__MATRIX_M33", &m->matrix[3][3]);
    pblank();

    pcomment("__GLGENcontextRec structure");
    pblank();
    pblank();
    pequate("GENCTX_hrc               ",OFFSET(struct __GLGENcontextRec,hrc       ));
    pequate("GENCTX_pajTranslateVector",OFFSET(struct __GLGENcontextRec,pajTranslateVector));
    pequate("GENCTX_pPrivateArea      ",OFFSET(struct __GLGENcontextRec,pPrivateArea));
    pequate("GENGC_ColorsBits         ",OFFSET(struct __GLGENcontextRec,ColorsBits));
    pequate("GENGC_SPAN_r             ",OFFSET(struct __GLGENcontextRec,genAccel.spanValue.r));
    pequate("GENGC_SPAN_g             ",OFFSET(struct __GLGENcontextRec,genAccel.spanValue.g));
    pequate("GENGC_SPAN_b             ",OFFSET(struct __GLGENcontextRec,genAccel.spanValue.b));
    pequate("GENGC_SPAN_a             ",OFFSET(struct __GLGENcontextRec,genAccel.spanValue.a));
    pequate("GENGC_SPAN_s             ",OFFSET(struct __GLGENcontextRec,genAccel.spanValue.s));
    pequate("GENGC_SPAN_t             ",OFFSET(struct __GLGENcontextRec,genAccel.spanValue.t));
    pequate("GENGC_SPAN_dr            ",OFFSET(struct __GLGENcontextRec,genAccel.spanDelta.r));
    pequate("GENGC_SPAN_dg            ",OFFSET(struct __GLGENcontextRec,genAccel.spanDelta.g));
    pequate("GENGC_SPAN_db            ",OFFSET(struct __GLGENcontextRec,genAccel.spanDelta.b));
    pequate("GENGC_SPAN_da            ",OFFSET(struct __GLGENcontextRec,genAccel.spanDelta.a));
    pequate("GENGC_SPAN_ds            ",OFFSET(struct __GLGENcontextRec,genAccel.spanDelta.s));
    pequate("GENGC_SPAN_dt            ",OFFSET(struct __GLGENcontextRec,genAccel.spanDelta.t));
    pequate("GENGC_SPAN_z             ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.frag.z));
    pequate("GENGC_SPAN_dz            ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.dzdx));
    pequate("GENGC_SPAN_zbuf          ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.zbuf));
    pequate("GENGC_SPAN_ppix          ",OFFSET(struct __GLGENcontextRec,genAccel.pPix));
    pequate("GENGC_SPAN_x             ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.frag.x));
    pequate("GENGC_SPAN_y             ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.frag.y));
    pequate("GENGC_SPAN_length        ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.length));
    pequate("GENGC_rAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.rAccum));
    pequate("GENGC_gAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.gAccum));
    pequate("GENGC_bAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.bAccum));
    pequate("GENGC_aAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.aAccum));
    pequate("GENGC_zAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.zAccum));
    pequate("GENGC_sAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.sAccum));
    pequate("GENGC_tAccum             ",OFFSET(struct __GLGENcontextRec,genAccel.tAccum));
    pequate("GENGC_pixAccum           ",OFFSET(struct __GLGENcontextRec,genAccel.pixAccum));
    pequate("GENGC_ditherAccum        ",OFFSET(struct __GLGENcontextRec,genAccel.ditherAccum));
    pequate("GENGC_sResult            ",OFFSET(struct __GLGENcontextRec,genAccel.sResult[0]));
    pequate("GENGC_tResult            ",OFFSET(struct __GLGENcontextRec,genAccel.tResult[0]));
    pequate("GENGC_sResultNew         ",OFFSET(struct __GLGENcontextRec,genAccel.sResultNew[0]));
    pequate("GENGC_tResultNew         ",OFFSET(struct __GLGENcontextRec,genAccel.tResultNew[0]));
    pequate("GENGC_sMask              ",OFFSET(struct __GLGENcontextRec,genAccel.sMask));
    pequate("GENGC_tMaskSubDiv        ",OFFSET(struct __GLGENcontextRec,genAccel.tMaskSubDiv));
    pequate("GENGC_tShiftSubDiv       ",OFFSET(struct __GLGENcontextRec,genAccel.tShiftSubDiv));
    pequate("GENGC_texImage           ",OFFSET(struct __GLGENcontextRec,genAccel.texImage));
    pequate("GENGC_texImageReplace    ",OFFSET(struct __GLGENcontextRec,genAccel.texImageReplace));
    pequate("GENGC_texPalette         ",OFFSET(struct __GLGENcontextRec,genAccel.texPalette));
    pequate("GENGC_qwAccum            ",OFFSET(struct __GLGENcontextRec,genAccel.qwAccum));
    pequate("GENGC_SPAN_dqwdx         ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.dqwdx));
    pequate("GENGC_SPAN_qw            ",OFFSET(struct __GLGENcontextRec,gc.polygon.shader.frag.qw));
    pequate("GENGC_xlatPalette        ",OFFSET(struct __GLGENcontextRec,xlatPalette));
    pequate("GENGC_sStepX             ",OFFSET(struct __GLGENcontextRec,genAccel.sStepX));
    pequate("GENGC_tStepX             ",OFFSET(struct __GLGENcontextRec,genAccel.tStepX));
    pequate("GENGC_qwStepX            ",OFFSET(struct __GLGENcontextRec,genAccel.qwStepX));
    pequate("GENGC_subDs              ",OFFSET(struct __GLGENcontextRec,genAccel.subDs));
    pequate("GENGC_subDt              ",OFFSET(struct __GLGENcontextRec,genAccel.subDt));
    pequate("GENGC_rDisplay           ",OFFSET(struct __GLGENcontextRec,genAccel.displayColor[0]));
    pequate("GENGC_gDisplay           ",OFFSET(struct __GLGENcontextRec,genAccel.displayColor[1]));
    pequate("GENGC_bDisplay           ",OFFSET(struct __GLGENcontextRec,genAccel.displayColor[2]));
    pequate("GENGC_aDisplay           ",OFFSET(struct __GLGENcontextRec,genAccel.displayColor[3]));
    pequate("GENGC_bytesPerPixel      ",OFFSET(struct __GLGENcontextRec,genAccel.xMultiplier));
    pequate("GENGC_bpp                ",OFFSET(struct __GLGENcontextRec,genAccel.bpp));
    pequate("GENGC_flags              ",OFFSET(struct __GLGENcontextRec,genAccel.flags));
    pequate("GENGC_pInvTranslateVector",OFFSET(struct __GLGENcontextRec,pajInvTranslateVector));
    pblank();
    
    pequate("COLOR_r                  ",OFFSET(struct __GLcolorRec,r  ));
    pequate("COLOR_g                  ",OFFSET(struct __GLcolorRec,g  ));
    pequate("COLOR_b                  ",OFFSET(struct __GLcolorRec,b  ));
    pequate("COLOR_a                  ",OFFSET(struct __GLcolorRec,a  ));
    pblank();

    pequate("GC_SHADER_R              ", OFFSET(__GLcontext, polygon.shader.frag.color.r));
    pequate("GC_SHADER_G              ", OFFSET(__GLcontext, polygon.shader.frag.color.g));
    pequate("GC_SHADER_B              ", OFFSET(__GLcontext, polygon.shader.frag.color.b));
    pequate("GC_SHADER_A              ", OFFSET(__GLcontext, polygon.shader.frag.color.a));
    
    pblank();
    pequate("GC_SHADE_rLittle         ",OFFSET(__GLcontext, polygon.shader.rLittle        ));
    pequate("GC_SHADE_gLittle         ",OFFSET(__GLcontext, polygon.shader.gLittle        ));
    pequate("GC_SHADE_bLittle         ",OFFSET(__GLcontext, polygon.shader.bLittle        ));
    pequate("GC_SHADE_aLittle         ",OFFSET(__GLcontext, polygon.shader.aLittle        ));

    pblank();
    pequate("GC_SHADE_drdy            ",OFFSET(__GLcontext, polygon.shader.drdy           ));
    pequate("GC_SHADE_dgdy            ",OFFSET(__GLcontext, polygon.shader.dgdy           ));
    pequate("GC_SHADE_dbdy            ",OFFSET(__GLcontext, polygon.shader.dbdy           ));
    pequate("GC_SHADE_dady            ",OFFSET(__GLcontext, polygon.shader.dady           ));

    pblank();
    pequate("GC_SHADE_drdx            ",OFFSET(__GLcontext, polygon.shader.drdx           ));
    pequate("GC_SHADE_dgdx            ",OFFSET(__GLcontext, polygon.shader.dgdx           ));
    pequate("GC_SHADE_dbdx            ",OFFSET(__GLcontext, polygon.shader.dbdx           ));
    pequate("GC_SHADE_dadx            ",OFFSET(__GLcontext, polygon.shader.dadx           ));

    pblank();
    pequate("VERTEX_color             ", OFFSET(__GLvertex, color));
    
    pblank();
    pequate("GC_VIEWPORT_xScale       ", OFFSET(__GLcontext, state.viewport.xScale));
    pequate("GC_VIEWPORT_yScale       ", OFFSET(__GLcontext, state.viewport.yScale));
    pequate("GC_VIEWPORT_zScale       ", OFFSET(__GLcontext, state.viewport.zScale));
    pequate("GC_VIEWPORT_xCenter      ", OFFSET(__GLcontext, state.viewport.xCenter));
    pequate("GC_VIEWPORT_yCenter      ", OFFSET(__GLcontext, state.viewport.yCenter));
    pequate("GC_VIEWPORT_zCenter      ", OFFSET(__GLcontext, state.viewport.zCenter));

    pblank();
    pequate("__FLOAT_ONE", *(long*)&one);
    
    pblank();
    pequate("VCLIP_x", OFFSET(__GLvertex, clip.x));
    pequate("VFCOL_r", OFFSET(__GLvertex, colors[__GL_FRONTFACE].r));
    pequate("VBCOL_r", OFFSET(__GLvertex, colors[__GL_BACKFACE].r));
    pequate("VTEX_x", OFFSET(__GLvertex, texture.x));
    pequate("VNOR_x", OFFSET(__GLvertex, normal.x));
    pequate("VEYE_x", OFFSET(__GLvertex, eyeX));

    pblank();
    pequate("PA_flags           ", OFFSET(POLYARRAY, flags));
    pequate("PA_pdNextVertex    ", OFFSET(POLYARRAY, pdNextVertex));
    pequate("PA_pdFlush         ", OFFSET(POLYARRAY, pdFlush));
    pequate("PA_pdCurNormal     ", OFFSET(POLYARRAY, pdCurNormal));
    pequate("PA_pdCurTexture    ", OFFSET(POLYARRAY, pdCurTexture));
    pequate("PA_pdCurColor      ", OFFSET(POLYARRAY, pdCurColor));
    
    pblank();
    pequate("PD_flags           ", OFFSET(POLYDATA, flags));
    pequate("PD_obj             ", OFFSET(POLYDATA, obj.x));
    pequate("PD_normal          ", OFFSET(POLYDATA, normal.x));
    pequate("PD_texture         ", OFFSET(POLYDATA, texture.x));
    pequate("PD_colors0         ", OFFSET(POLYDATA, colors[0].r));
    pequate("PD_clip            ", OFFSET(POLYDATA, clip.x));
    pequate("PD_window          ", OFFSET(POLYDATA, window.x));
    pequate("sizeof_POLYDATA    ", sizeof(POLYDATA));
}

/******************************Public*Routine******************************\
* GLi386                                                                   *
*                                                                          *
* This is how we make structures consistent between C and ASM for OpenGL.  *
*                                                                          *
\**************************************************************************/

int __cdecl main(int argc,char *argv[])
{
    FILE *outfh;
    char *outName;
    char *dot;

    if (argc != 2) {
        fprintf(stderr, "Usage: %s file_name\n", argv[0]);
        exit(1);

    }

    outfh = fopen(argv[1], "w");
    if (NULL == outfh) {
        fprintf(stderr, "Cannot open %s\n", argv[1]);
        exit(1);
    }
    CreateInc(outfh);
    fclose(outfh);

    dot = strrchr(argv[1], '.');
    if (dot == NULL)
    {
        fprintf(stderr, "Cannot create H\n", argv[1]);
        exit(1);
    }
    *(++dot) = 'h';
    *(++dot) = 0;
    outfh = fopen(argv[1], "w");
    if (NULL == outfh) {
        fprintf(stderr, "Cannot open %s\n", argv[1]);
        exit(1);
    }

    CreateH(outfh);
    fclose(outfh);
    
    // UNUSED
#if 0
// Stuff from: \nt\public\sdk\inc\gl\gl.h

    pcomment("Pixel Format Descriptor");
    pblank();
    pequate("PFD_cColorBits     ",OFFSET(PIXELFORMATDESCRIPTOR,cColorBits ));
    pequate("PFD_iPixelType     ",OFFSET(PIXELFORMATDESCRIPTOR,iPixelType ));
    pequate("PFD_cDepthBits     ",OFFSET(PIXELFORMATDESCRIPTOR,cDepthBits ));


    pcomment("GL Test Functions");
    pblank();

    pequate("GL_NEVER           ",GL_NEVER   );
    pequate("GL_LESS            ",GL_LESS    );
    pequate("GL_EQUAL           ",GL_EQUAL   );
    pequate("GL_LEQUAL          ",GL_LEQUAL  );
    pequate("GL_GREATER         ",GL_GREATER );
    pequate("GL_NOTEQUAL        ",GL_NOTEQUAL);
    pequate("GL_GEQUAL          ",GL_GEQUAL  );
    pequate("GL_ALWAYS          ",GL_ALWAYS  );
    pblank();
    pblank();

    pcomment("GL Mode Flags");
    pblank();
    pequate("__GL_SHADE_RGB         ",__GL_SHADE_RGB        );
    pequate("__GL_SHADE_SMOOTH      ",__GL_SHADE_SMOOTH     );
    pequate("__GL_SHADE_DEPTH_TEST  ",__GL_SHADE_DEPTH_TEST );
    pequate("__GL_SHADE_DITHER      ",__GL_SHADE_DITHER     );
    pequate("__GL_SHADE_LOGICOP     ",__GL_SHADE_LOGICOP    );
    pequate("__GL_SHADE_MASK        ",__GL_SHADE_MASK       );
    pblank();
    pblank();

    pcomment("GL Type Sizes");
    pblank();
    pequate("GLbyteSize             ",sizeof(GLbyte));
    pequate("GLshortSize            ",sizeof(GLshort));
    pequate("GLintSize              ",sizeof(GLint));
    pequate("GLfloatSize            ",sizeof(GLfloat));
    pequate("__GLfloatSize          ",sizeof(__GLfloat));
    pequate("__GLzValueSize         ",sizeof(__GLzValue));
    pblank();
    pblank(); 

// Stuff from: \nt\private\windows\gdi\opengl\server\inc\render.h

    pcomment("__GLfragmentRec structure");
    pblank();

    pstruct("GLfragmentRec",sizeof(struct __GLfragmentRec));
    pblank();
    pequate("FRAG_x             ",OFFSET(struct __GLfragmentRec,x       ));
    pequate("FRAG_y             ",OFFSET(struct __GLfragmentRec,y       ));
    pequate("FRAG_z             ",OFFSET(struct __GLfragmentRec,z       ));
    pequate("FRAG_color         ",OFFSET(struct __GLfragmentRec,color   ));
    pequate("FRAG_s             ",OFFSET(struct __GLfragmentRec,s       ));
    pequate("FRAG_t             ",OFFSET(struct __GLfragmentRec,t       ));
    pequate("FRAG_qw            ",OFFSET(struct __GLfragmentRec,qw      ));
    pequate("FRAG_f             ",OFFSET(struct __GLfragmentRec,f       ));
    pblank();

    pcomment("__GLshadeRec structure");
    pblank();
    pstruct("__GLshadeRec",sizeof(struct __GLshadeRec));
    pblank();
    pequate("SHADE_dxLeftLittle ",OFFSET(struct __GLshadeRec,dxLeftLittle   ));
    pequate("SHADE_dxLeftBig    ",OFFSET(struct __GLshadeRec,dxLeftBig      ));
    pequate("SHADE_dxLeftFrac   ",OFFSET(struct __GLshadeRec,dxLeftFrac     ));
    pequate("SHADE_ixLeft       ",OFFSET(struct __GLshadeRec,ixLeft         ));
    pequate("SHADE_ixLeftFrac   ",OFFSET(struct __GLshadeRec,ixLeftFrac     ));

    pequate("SHADE_dxRightLittle",OFFSET(struct __GLshadeRec,dxRightLittle  ));
    pequate("SHADE_dxRightBig   ",OFFSET(struct __GLshadeRec,dxRightBig     ));
    pequate("SHADE_dxRightFrac  ",OFFSET(struct __GLshadeRec,dxRightFrac    ));
    pequate("SHADE_ixRight      ",OFFSET(struct __GLshadeRec,ixRight        ));
    pequate("SHADE_ixRightFrac  ",OFFSET(struct __GLshadeRec,ixRightFrac    ));

    pequate("SHADE_area         ",OFFSET(struct __GLshadeRec,area           ));
    pequate("SHADE_dxAC         ",OFFSET(struct __GLshadeRec,dxAC           ));
    pequate("SHADE_dxBC         ",OFFSET(struct __GLshadeRec,dxBC           ));
    pequate("SHADE_dyAC         ",OFFSET(struct __GLshadeRec,dyAC           ));
    pequate("SHADE_dyBC         ",OFFSET(struct __GLshadeRec,dyBC           ));

    pequate("SHADE_frag         ",OFFSET(struct __GLshadeRec,frag           ));
    pequate("SHADE_spanLength   ",OFFSET(struct __GLshadeRec,length         ));

    pequate("SHADE_rBig         ",OFFSET(struct __GLshadeRec,rBig           ));
    pequate("SHADE_gBig         ",OFFSET(struct __GLshadeRec,gBig           ));
    pequate("SHADE_bBig         ",OFFSET(struct __GLshadeRec,bBig           ));
    pequate("SHADE_aBig         ",OFFSET(struct __GLshadeRec,aBig           ));

    pequate("SHADE_zLittle      ",OFFSET(struct __GLshadeRec,zLittle        ));
    pequate("SHADE_zBig         ",OFFSET(struct __GLshadeRec,zBig           ));
    pequate("SHADE_dzdx         ",OFFSET(struct __GLshadeRec,dzdx           ));
    pequate("SHADE_dzdyf        ",OFFSET(struct __GLshadeRec,dzdyf          ));
    pequate("SHADE_dzdxf        ",OFFSET(struct __GLshadeRec,dzdxf          ));

    pequate("SHADE_sLittle      ",OFFSET(struct __GLshadeRec,sLittle        ));
    pequate("SHADE_tLittle      ",OFFSET(struct __GLshadeRec,tLittle        ));
    pequate("SHADE_qwLittle     ",OFFSET(struct __GLshadeRec,qwLittle       ));

    pequate("SHADE_sBig         ",OFFSET(struct __GLshadeRec,sBig           ));
    pequate("SHADE_tBig         ",OFFSET(struct __GLshadeRec,tBig           ));
    pequate("SHADE_qwBig        ",OFFSET(struct __GLshadeRec,qwBig          ));

    pequate("SHADE_dsdx         ",OFFSET(struct __GLshadeRec,dsdx           ));
    pequate("SHADE_dtdx         ",OFFSET(struct __GLshadeRec,dtdx           ));
    pequate("SHADE_dqwdx        ",OFFSET(struct __GLshadeRec,dqwdx          ));

    pequate("SHADE_dsdy         ",OFFSET(struct __GLshadeRec,dsdy           ));
    pequate("SHADE_dtdy         ",OFFSET(struct __GLshadeRec,dtdy           ));
    pequate("SHADE_dqwdy        ",OFFSET(struct __GLshadeRec,dqwdy          ));

    pequate("SHADE_fLittle      ",OFFSET(struct __GLshadeRec,fLittle        ));
    pequate("SHADE_fBig         ",OFFSET(struct __GLshadeRec,fBig           ));
    pequate("SHADE_dfdy         ",OFFSET(struct __GLshadeRec,dfdy           ));
    pequate("SHADE_dfdx         ",OFFSET(struct __GLshadeRec,dfdx           ));

    pequate("SHADE_modeFlags    ",OFFSET(struct __GLshadeRec,modeFlags      ));

    pequate("SHADE_zbuf         ",OFFSET(struct __GLshadeRec,zbuf           ));
    pequate("SHADE_zbufBig      ",OFFSET(struct __GLshadeRec,zbufBig        ));
    pequate("SHADE_zbufLittle   ",OFFSET(struct __GLshadeRec,zbufLittle     ));

    pequate("SHADE_sbuf         ",OFFSET(struct __GLshadeRec,sbuf           ));
    pequate("SHADE_sbufBig      ",OFFSET(struct __GLshadeRec,sbufBig        ));
    pequate("SHADE_sbufLittle   ",OFFSET(struct __GLshadeRec,sbufLittle     ));

    pequate("SHADE_colors       ",OFFSET(struct __GLshadeRec,colors         ));
    pequate("SHADE_fbcolors     ",OFFSET(struct __GLshadeRec,fbcolors       ));
    pequate("SHADE_stipplePat   ",OFFSET(struct __GLshadeRec,stipplePat     ));
    pequate("SHADE_done         ",OFFSET(struct __GLshadeRec,done           ));
    pequate("SHADE_cfb          ",OFFSET(struct __GLshadeRec,cfb            ));
    pblank();
    pblank();


    pcomment("__GLpolygonMachineRec structure");
    pblank();
    pstruct("GLpolygonMachineRec",sizeof(struct __GLpolygonMachineRec));
    pblank();
    pequate("POLY_stipple       ",OFFSET(struct __GLpolygonMachineRec,stipple));
    pequate("POLY_shader        ",OFFSET(struct __GLpolygonMachineRec,shader ));
    pblank();
    pblank();


// Stuff from: \nt\private\windows\gdi\opengl\server\inc\buffers.h

    pequate("DIB_FORMAT         ",DIB_FORMAT);

    pcomment("__GLbufferRec structure");
    pblank();
    pstruct("GLbufferRec",sizeof(struct __GLbufferRec));
    pblank();
    pequate("BUF_gc             ",OFFSET(struct __GLbufferRec,gc          ));
    pequate("BUF_width          ",OFFSET(struct __GLbufferRec,width       ));
    pequate("BUF_height         ",OFFSET(struct __GLbufferRec,height      ));
    pequate("BUF_depth          ",OFFSET(struct __GLbufferRec,depth       ));
    pequate("BUF_base           ",OFFSET(struct __GLbufferRec,base        ));
    pequate("BUF_size           ",OFFSET(struct __GLbufferRec,size        ));
    pequate("BUF_elementSize    ",OFFSET(struct __GLbufferRec,elementSize ));
    pequate("BUF_outerWidth     ",OFFSET(struct __GLbufferRec,outerWidth  ));
    pequate("BUF_xOrigin        ",OFFSET(struct __GLbufferRec,xOrigin     ));
    pequate("BUF_yOrigin        ",OFFSET(struct __GLbufferRec,yOrigin     ));
    pequate("BUF_other          ",OFFSET(struct __GLbufferRec,other       ));
    pblank();
    pblank();


    pcomment("__GLcolorBufferRec structure");
    pblank();
    pstruct("GLcolorBufferRec",sizeof(struct __GLcolorBufferRec));
    pblank();
    pequate("CBUF_redMax        ",OFFSET(struct __GLcolorBufferRec,redMax     ));
    pequate("CBUF_greenMax      ",OFFSET(struct __GLcolorBufferRec,greenMax   ));
    pequate("CBUF_blueMax       ",OFFSET(struct __GLcolorBufferRec,blueMax    ));
    pequate("CBUF_iRedScale     ",OFFSET(struct __GLcolorBufferRec,iRedScale  ));
    pequate("CBUF_iGreenScale   ",OFFSET(struct __GLcolorBufferRec,iGreenScale));
    pequate("CBUF_iBlueScale    ",OFFSET(struct __GLcolorBufferRec,iBlueScale ));
    pequate("CBUF_iAlphaScale   ",OFFSET(struct __GLcolorBufferRec,iAlphaScale));
    pequate("CBUF_iRedShift     ",OFFSET(struct __GLcolorBufferRec,redShift  ));
    pequate("CBUF_iGreenShift   ",OFFSET(struct __GLcolorBufferRec,greenShift));
    pequate("CBUF_iBlueShift    ",OFFSET(struct __GLcolorBufferRec,blueShift ));
    pequate("CBUF_iAlphaShift   ",OFFSET(struct __GLcolorBufferRec,alphaShift));
    pequate("CBUF_sourceMask    ",OFFSET(struct __GLcolorBufferRec,sourceMask ));
    pequate("CBUF_destMask      ",OFFSET(struct __GLcolorBufferRec,destMask   ));
    pequate("CBUF_other         ",OFFSET(struct __GLcolorBufferRec,other      ));
    pblank();
    pblank();


// Stuff from: \nt\private\windows\gdi\opengl\server\inc\attrib.h


    pcomment("__GLdepthStateRec structure");
    pblank();
    pstruct("GLdepthStateRec",sizeof(struct __GLdepthStateRec));
    pblank();
    pequate("DEPTH_testFunc     ",OFFSET(struct __GLdepthStateRec,testFunc   ));
    pequate("DEPTH_writeEnable  ",OFFSET(struct __GLdepthStateRec,writeEnable));
    pblank();
    pblank();

    pcomment("__GLattributeRec structure");
    pblank();
    pstruct("GLattributeRec",sizeof(struct __GLattributeRec));
    pblank();
    pequate("ATTR_polygonStipple",OFFSET(struct __GLattributeRec,polygonStipple));
    pequate("ATTR_depth         ",OFFSET(struct __GLattributeRec,depth));
    pequate("ATTR_enables       ",OFFSET(struct __GLattributeRec,enables));
    pequate("ATTR_raster        ",OFFSET(struct __GLattributeRec,raster));
    pequate("ATTR_hints         ",OFFSET(struct __GLattributeRec,hints));
    pblank();
    pblank();


// Stuff from: \nt\private\windows\gdi\opengl\server\inc\context.h

    pcomment("__GLcontextConstantsRec structure");
    pblank();
    pstruct("GLcontextConstantsRec",sizeof(struct __GLcontextConstantsRec));
    pblank();
    pequate("CTXCONST_viewportXAdjust",OFFSET(struct __GLcontextConstantsRec,viewportXAdjust));
    pequate("CTXCONST_viewportYAdjust",OFFSET(struct __GLcontextConstantsRec,viewportYAdjust));
    pequate("CTXCONST_width          ",OFFSET(struct __GLcontextConstantsRec,width));
    pequate("CTXCONST_height         ",OFFSET(struct __GLcontextConstantsRec,height));


    pcomment("__GLcontextRec structure");
    pblank();
    pstruct("GLcontextRec",sizeof(struct __GLcontextRec));
    pblank();
    pequate("CTX_gcState        ",OFFSET(struct __GLcontextRec,gcState    ));
    pequate("CTX_state          ",OFFSET(struct __GLcontextRec,state      ));
    pequate("CTX_renderMode     ",OFFSET(struct __GLcontextRec,renderMode ));
    pequate("CTX_modes          ",OFFSET(struct __GLcontextRec,modes      ));
    pequate("CTX_constants      ",OFFSET(struct __GLcontextRec,constants  ));
    pequate("CTX_drawBuffer     ",OFFSET(struct __GLcontextRec,drawBuffer ));
    pequate("CTX_readBuffer     ",OFFSET(struct __GLcontextRec,readBuffer ));
    pequate("CTX_polygon        ",OFFSET(struct __GLcontextRec,polygon    ));
    pequate("CTX_pixel          ",OFFSET(struct __GLcontextRec,pixel      ));
    pblank();
    pblank();

    pcomment("SPANREC structure");
    pblank();
    pstruct("SPANREC",sizeof(SPANREC));
    pblank();
    pequate("SPANREC_r               ",OFFSET(SPANREC,r       ));
    pequate("SPANREC_g               ",OFFSET(SPANREC,g       ));
    pequate("SPANREC_b               ",OFFSET(SPANREC,b       ));
    pequate("SPANREC_a               ",OFFSET(SPANREC,a       ));
    pequate("SPANREC_z               ",OFFSET(SPANREC,z       ));
    pblank();
    pblank();

    pcomment("GENACCEL structure");
    pblank();
    pstruct("GENACCEL",sizeof(GENACCEL));
    pblank();
    pequate("SURFACE_TYPE_DIB   ",SURFACE_TYPE_DIB);
    pblank();
    pequate("GENACCEL_spanDelta             ",
        OFFSET(GENACCEL,spanDelta                ));
    pequate("GENACCEL_flags                 ",
        OFFSET(GENACCEL,flags                    ));
    pequate("GENACCEL_fastSpanFuncPtr       ",
        OFFSET(GENACCEL,__fastSpanFuncPtr ));
    pequate("GENACCEL_fastFlatSpanFuncPtr   ",
        OFFSET(GENACCEL,__fastFlatSpanFuncPtr ));
    pequate("GENACCEL_fastSmoothSpanFuncPtr ",
        OFFSET(GENACCEL,__fastSmoothSpanFuncPtr ));
    pequate("GENACCEL_fastZSpanFuncPtr      ",
        OFFSET(GENACCEL,__fastZSpanFuncPtr));
    pblank();
    pblank();
#endif
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\i386\soprim.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: so_prim.asm
;
; xform routines.
;
; Created: 10/14/1996
; Author: Otto Berkes [ottob]
;
; Copyright (c) 1996 Microsoft Corporation
;----------------------------------------------------------------------;
        .386

        .model  small,pascal

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include gli386.inc
        .list

	PROFILE = 0
	include profile.inc
	
.data

extrn	___glClipCodes :DWORD
extrn	___glOne:DWORD
extrn	___glHalf:DWORD
extrn	___glZero:DWORD

;------------------------------------------------------------------------------------------
; Internal definitions:
;
_R_ 	= 0
_G_ 	= 4
_B_ 	= 8
_A_ 	= 12

_X_	= 0
_Y_	= 4
_Z_	= 8
_W_	= 12


;------------------------------------------------------------------------------------------
; pdLast is passed as parameter
;
pdLast      equ [ebp+8]

;
; Temporary data
;
gc        equ -4[ebp]
pa        equ -8[ebp]

.code

extrn    @__glNormalize@8:NEAR

;------------------------------------------------------------------------------------------
; Makes clip code for frustum clip planes
; General case
;
; Input:
;   edx        = pointer to POLYARRAY
;   ecx        = pointer to graphics context
;   pdLast     = pointer to the last vertex 
;   pa         = pointer to POLYARRAY
;   gc         = pointer to graphics context
;   ReuseClipCode   if set to 1, new clip code is combined using OR with existing one
;
; Returns:
;   eax = andClipCodes for POLYARRAY
;
PAClipCheckFrustum MACRO ReuseClipCode

        mov     edx, DWORD PTR [edx+PA_pd0]

vertexLoop:

        mov     esi, DWORD PTR [edx+PD_clip+_W_]   ; esi = clipW
        or      esi, esi                           ; if (clipW == 0) go to special case
        jz      @WEqZero
	    
        fld     ___glOne
        fdiv    DWORD PTR [edx+PD_clip+_W_]     ; start division

; edi will accumulate index to clip table
; bit 6  - 1 if clipW < 0
; bit 5  - 1 if clipX < 0
; bit 4  - 1 if abs(clipX) < abs(clipW)
; bit 3  - 1 if clipY < 0
; bit 2  - 1 if abs(clipY) < abs(clipW)
; bit 1  - 1 if clipZ < 0
; bit 0  - 1 if abs(clipZ) < abs(clipW)
        xor     edi, edi	
        add     esi, esi			; esi = abs(clipW) shifted left 1 bit
        mov     ebx, [edx+PD_clip+_X_]		; ebx = clipX
        adc     edi, edi			; edi = sign clipW 
        add     esi, 1                          ; X-W bit should be set when X-W <= 0 !!!

        add     ebx, ebx							; ebx = abs(clipX) shifted left 1 bit
        adc     edi, edi                        ; edi = edi << 1 + sign(clipX)

        sub     ebx, esi
        adc     edi, edi                        ; edi = edi << 1 + sign(abs(clipX) - abs(clipW))

        mov     ebx, [edx+PD_clip+_Y_]
        mov     ecx, pa

        add     ebx, ebx
        adc     edi, edi			; edi = edi << 1 + sign(clipY)

        sub     ebx, esi
        adc     edi, edi			; edi = edi << 1 + sign(abs(clipY) - abs(clipW))

        mov     ebx, [edx+PD_clip+_Z_]
        add     edx, sizeof_POLYDATA            ; advance vertex ptr

        add     ebx, ebx                        ; edi = edi << 1 + sign(clipZ)
        adc     edi, edi

        sub     ebx, esi
        adc     edi, edi                        ; edi = edi << 1 + sign(abs(clipZ) - abs(clipW))

        mov     esi, [ecx+PA_orClipCodes]       ; get prim OR code
        mov     ebx, [ecx+PA_andClipCodes]      ; get prim AND code

        mov     ecx, ___glClipCodes[edi*4]      ; ecx = clip code
        mov     edi, pa
if ReuseClipCode eq 1
        or      ecx, [edx+PD_clipCode-sizeof_POLYDATA] ; update vertex clip code
endif
        mov     [edx+PD_clipCode-sizeof_POLYDATA], ecx ; store vertex clip code
        or      esi, ecx                         ; compute prim OR
        and     ebx, ecx                         ; "          " AND
        mov     [edi+PA_orClipCodes],  esi       ; store prim OR
        mov     [edi+PA_andClipCodes], ebx       ; store prim AND
        mov     ebx, gc
        mov     edi, pdLast

        ;; Save invW in window.w:

        fstp DWORD PTR [edx+PD_window+_W_ - sizeof_POLYDATA]

        or      ecx, ecx
        jnz     @Done

        fld     DWORD PTR [edx+PD_clip+_X_ - sizeof_POLYDATA]
        fmul    DWORD PTR [ebx+GC_VIEWPORT_xScale]
        fld     DWORD PTR [edx+PD_clip+_Y_ - sizeof_POLYDATA]
        fmul    DWORD PTR [ebx+GC_VIEWPORT_yScale]
        fld     DWORD PTR [edx+PD_clip+_Z_ - sizeof_POLYDATA]
        fmul    DWORD PTR [ebx+GC_VIEWPORT_zScale]                 ; z y x
        fxch    st(2)                                              ; x y z
        fmul    DWORD PTR [edx+PD_window+_W_ - sizeof_POLYDATA]    ; X y z
        fxch    st(1)                                              ; y X z
        fmul    DWORD PTR [edx+PD_window+_W_ - sizeof_POLYDATA]    ; Y X z
        fxch    st(2)                                              ; z X Y
        fmul    DWORD PTR [edx+PD_window+_W_ - sizeof_POLYDATA]    ; Z X Y
        fxch    st(1)                                              ; X Z Y
        fadd    DWORD PTR [ebx+GC_VIEWPORT_xCenter]                ; x Z Y
        fxch    st(2)                                              ; Y Z x
        fadd    DWORD PTR [ebx+GC_VIEWPORT_yCenter]                ; y Z x
        fxch    st(1)                                              ; Z y x
        fadd    DWORD PTR [ebx+GC_VIEWPORT_zCenter]                ; z y x	    
        fxch    st(2)                                              ; x y z
        fstp    DWORD PTR [edx+PD_window+_X_ - sizeof_POLYDATA]
        fstp    DWORD PTR [edx+PD_window+_Y_ - sizeof_POLYDATA]
        fstp    DWORD PTR [edx+PD_window+_Z_ - sizeof_POLYDATA]

@Done:

        cmp     edx, edi                           ; pd > pdLast?
        jbe     vertexLoop                         ; yes -> process next vertex

@Exit:

        mov     edx, pa
        pop	edi
        pop	esi
        pop	ebx
        mov	esp, ebp
        pop	ebp
        mov     eax, [edx + PA_andClipCodes]       ; return value
        ret	4
;
; W == 0
;
@WEqZero:
        xor     edi, edi	
        mov     ebx, [edx+PD_clip+_X_]          ; ebx = clipX
        add     ebx, ebx			; ebx = abs(clipX) shifted left 1 bit
        adc     edi, edi			; edi = edi << 1 + sign(clipX)
        add     edi, edi			; edi = edi << 1
        mov     ebx, [edx+PD_clip+_Y_]
        mov     ecx, pa
        add     ebx, ebx
        adc     edi, edi                        ; edi = edi << 1 + sign(clipY)
        add     edi, edi                        ; edi = edi << 1
        mov     ebx, [edx+PD_clip+_Z_]
        add     edx, sizeof_POLYDATA            ; advance vertex ptr
        add     ebx, ebx                        ; edi = edi << 1 + sign(clipZ)
        adc     edi, edi
        add     edi, edi                        ; edi = edi << 1
        mov     esi, [ecx+PA_orClipCodes]       ; get prim OR code
        mov     ebx, [ecx+PA_andClipCodes]      ; get prim AND code
        mov     ecx, ___glClipCodes[edi*4]      ; ecx = clip code
        mov     edi, pa
if ReuseClipCode eq 1
        or      ecx, [edx+PD_clipCode-sizeof_POLYDATA] ; update vertex clip code
endif
        mov     [edx+PD_clipCode-sizeof_POLYDATA], ecx ; store vertex clip code
        or      esi, ecx                        ; compute prim OR
        and     ebx, ecx                        ; "          " AND
        mov     [edi+PA_orClipCodes],  esi      ; store prim OR
        mov     [edi+PA_andClipCodes], ebx      ; store prim AND
        mov     ebx, gc
        mov     edi, pdLast

        ;; Save invW in window.w:
        mov     DWORD PTR [edx+PD_window+_W_ - sizeof_POLYDATA], 0

        or      ecx, ecx
        jnz     @Done

        mov     ecx, DWORD PTR [ebx+GC_VIEWPORT_xCenter]
        mov     ebx, DWORD PTR [ebx+GC_VIEWPORT_yCenter]
        mov     DWORD PTR [edx+PD_window+_X_ - sizeof_POLYDATA], ecx
        mov     ecx, DWORD PTR [ebx+GC_VIEWPORT_zCenter]
        mov     DWORD PTR [edx+PD_window+_Y_ - sizeof_POLYDATA], ebx
        mov     DWORD PTR [edx+PD_window+_Z_ - sizeof_POLYDATA], ecx
        jmp     @Done

ENDM
;------------------------------------------------------------------------------------------
; Make clip code for frustum clip planes
; General case
;
; Prototype:
;   GLuint FASTCALL PAClipCheckFrustum(__GLcontext *gc, POLYARRAY *pa,
;                                      POLYDATA *pdLast);
; Input:
;   edx        = pa pointer to POLYARRAY
;   ecx        = gc pointer to graphics context
;   [esp+4]    = pointer to the last vertex 
;   andClipCodes for POLYARRAY is set to -1
;   orClipCodes  for POLYARRAY is set to 0
;
; Returns:
;   andClipCodes for POLYARRAY
;
@PAClipCheckFrustum@12 PROC NEAR

        push    ebp
        mov     ebp, esp
        sub     esp, 12
        mov     DWORD PTR pa, edx
        mov     DWORD PTR gc, ecx
        push    ebx
        push    esi
        push    edi
        PAClipCheckFrustum 0

@PAClipCheckFrustum@12 ENDP
;------------------------------------------------------------------------------------------
; Makes clip code for frustum clip planes
; Case when vertices have W == 1.0
;
; Input:
;   edx        = pa pointer to POLYARRAY
;   ecx        = gc pointer to graphics context
;   pa         = pointer to POLYARRAY
;   gc         = pointer to graphics context
;   pdLast     = pointer to the last vertex 
;   ReuseClipCode   if set to 1, new clip code is combined using OR with existing one
;
; Returns:
;   eax = andClipCodes for POLYARRAY
;
PAClipCheckFrustumWOne MACRO ReuseClipCode

        mov     edx, DWORD PTR [edx+PA_pd0]

vertexLoop:

; edi will accumulate index to clip table
; bit 6  - 1 if clipW < 0   --- always 0 for this case
; bit 5  - 1 if clipX < 0
; bit 4  - 1 if abs(clipX) < abs(clipW)
; bit 3  - 1 if clipY < 0
; bit 2  - 1 if abs(clipY) < abs(clipW)
; bit 1  - 1 if clipZ < 0
; bit 0  - 1 if abs(clipZ) < abs(clipW)
        xor     edi, edi	
        mov     ebx, [edx+PD_clip+_X_]          ; ebx = clipX
        mov     esi, (__FLOAT_ONE*2) + 1

        add     ebx, ebx                        ; ebx = abs(clipX) shifted left 1 bit
        adc     edi, edi			; edi = edi << 1 + sign(clipX)

        sub     ebx, esi
        adc     edi, edi			; edi = edi << 1 + sign(abs(clipX) - abs(clipW))

        mov     ebx, [edx+PD_clip+_Y_]
        mov     ecx, pa

        add     ebx, ebx
        adc     edi, edi			; edi = edi << 1 + sign(clipY)

        sub     ebx, esi
        adc     edi, edi			; edi = edi << 1 + sign(abs(clipY) - abs(clipW))

        mov     ebx, [edx+PD_clip+_Z_]
        add     edx, sizeof_POLYDATA            ; advance vertex ptr

        add     ebx, ebx			; edi = edi << 1 + sign(clipZ)
        adc     edi, edi

        sub     ebx, esi
        adc     edi, edi			; edi = edi << 1 + sign(abs(clipZ) - abs(clipW))

        mov     esi, [ecx+PA_orClipCodes]       ; get prim OR code
        mov     ebx, [ecx+PA_andClipCodes]      ; get prim AND code

        mov     ecx, ___glClipCodes[edi*4]      ; ecx = clip code
        mov     edi, pa
if ReuseClipCode eq 1
        or      ecx, [edx+PD_clipCode-sizeof_POLYDATA] ; update vertex clip code
endif
        mov     [edx+PD_clipCode-sizeof_POLYDATA], ecx ; store vertex clip code
        or      esi, ecx                         ; compute prim OR
        and     ebx, ecx                         ; "          " AND
        mov     [edi+PA_orClipCodes],  esi       ; store prim OR
        mov     [edi+PA_andClipCodes], ebx       ; store prim AND
        mov     ebx, gc
        mov     edi, pdLast

        ;; Save invW in window.w:

        mov     DWORD PTR [edx+PD_window+_W_ - sizeof_POLYDATA], __FLOAT_ONE

        or      ecx, ecx
        jnz     @Done

        fld     DWORD PTR [edx+PD_clip+_X_ - sizeof_POLYDATA]
        fmul    DWORD PTR [ebx+GC_VIEWPORT_xScale]
        fld     DWORD PTR [edx+PD_clip+_Y_ - sizeof_POLYDATA]
        fmul    DWORD PTR [ebx+GC_VIEWPORT_yScale]
        fld     DWORD PTR [edx+PD_clip+_Z_ - sizeof_POLYDATA]
        fmul    DWORD PTR [ebx+GC_VIEWPORT_zScale]                 ; z y x
        fxch    st(2)                                              ; x y z
        fadd    DWORD PTR [ebx+GC_VIEWPORT_xCenter]                ; x y z
        fxch    st(1)                                              ; y x z
        fadd    DWORD PTR [ebx+GC_VIEWPORT_yCenter]                ; y x z
        fxch    st(2)                                              ; z x y
        fadd    DWORD PTR [ebx+GC_VIEWPORT_zCenter]                ; z x y	    
        fxch    st(1)                                              ; x z y
        fstp    DWORD PTR [edx+PD_window+_X_ - sizeof_POLYDATA]
        fstp    DWORD PTR [edx+PD_window+_Z_ - sizeof_POLYDATA]
        fstp    DWORD PTR [edx+PD_window+_Y_ - sizeof_POLYDATA]
@Done:
        cmp     edx, edi                           ; pd > pdLast?
        jbe     vertexLoop                         ; yes -> process next vertex
@Exit:
    mov  edx, pa
	pop	 edi
	pop	 esi
	pop	 ebx
	mov	 esp, ebp
	pop	 ebp
	mov  eax, [edx + PA_andClipCodes]       ; return value
	ret	 4

ENDM
;------------------------------------------------------------------------------------------
; Makes clip code for frustum clip planes
; Case when vertices have W == 1.0
;
; Prototype:
;   GLuint FASTCALL PAClipCheckFrustumWOne(__GLcontext *gc, POLYARRAY *pa,
;                                          POLYDATA *pdLast);
; Input:
;   edx        = pa pointer to POLYARRAY
;   ecx        = gc pointer to graphics context
;   [esp+4]    = pointer to the last vertex 
;   andClipCodes for POLYARRAY is set to -1
;   orClipCodes  for POLYARRAY is set to 0
;
; Returns:
;   eax = andClipCodes for POLYARRAY
;
@PAClipCheckFrustumWOne@12 PROC NEAR

        push    ebp
        mov     ebp, esp
        sub     esp, 12
        mov     DWORD PTR pa, edx
        mov     DWORD PTR gc, ecx
        push    ebx
        push    esi
        push    edi
        PAClipCheckFrustumWOne 0

@PAClipCheckFrustumWOne@12 ENDP
;------------------------------------------------------------------------------------------
; Makes clip code for frustum clip planes
; Case when vertices have W == 1.0 and Z == 0.0
;
; Input:
;   edx        = pa pointer to POLYARRAY
;   ecx        = gc pointer to graphics context
;   pa         = pointer to POLYARRAY
;   gc         = pointer to graphics context
;   pdLast     = pointer to the last vertex 
;   ReuseClipCode   if set to 1, new clip code is combined using OR with existing one
;
; Returns:
;   eax = andClipCodes for POLYARRAY
;
PAClipCheckFrustum2D MACRO ReuseClipCode

        mov     edx, DWORD PTR [edx+PA_pd0]

vertexLoop:

; edi will accumulate index to clip table
; bit 6  - 1 if clipW < 0   --- always 0 for this case
; bit 5  - 1 if clipX < 0
; bit 4  - 1 if abs(clipX) < abs(clipW)
; bit 3  - 1 if clipY < 0
; bit 2  - 1 if abs(clipY) < abs(clipW)
; bit 1  - 1 if clipZ < 0
; bit 0  - 1 if abs(clipZ) < abs(clipW)
        xor     edi, edi	
        mov     ebx, [edx+PD_clip+_X_]          ; ebx = clipX
        mov     esi, (__FLOAT_ONE*2) + 1        

        add     ebx, ebx			; ebx = abs(clipX) shifted left 1 bit
        adc     edi, edi			; edi = edi << 1 + sign(clipX)

        sub     ebx, esi
        adc     edi, edi			; edi = edi << 1 + sign(abs(clipX) - abs(clipW))

        mov     ebx, [edx+PD_clip+_Y_]
        mov     ecx, pa

        add     ebx, ebx
        adc     edi, edi			; edi = edi << 1 + sign(clipY)

        sub     ebx, esi
        adc     edi, edi                        ; edi = edi << 1 + sign(abs(clipY) - abs(clipW))

        add     edx, sizeof_POLYDATA            ; advance vertex ptr
        add     edi, edi                        ; sign(clipZ) = 0
        lea     edi, [edi+edi+1]                ; sign(abs(clipZ) - abs(clipW)) = 0

        mov     esi, [ecx+PA_orClipCodes]       ; get prim OR code
        mov     ebx, [ecx+PA_andClipCodes]      ; get prim AND code

        mov     ecx, ___glClipCodes[edi*4]      ; ecx = clip code
        mov     edi, pa
if ReuseClipCode eq 1
        or      ecx, [edx+PD_clipCode-sizeof_POLYDATA] ; update vertex clip code
endif
        mov     [edx+PD_clipCode-sizeof_POLYDATA], ecx ; store vertex clip code
        or      esi, ecx                        ; compute prim OR
        and     ebx, ecx                        ; "          " AND
        mov     [edi+PA_orClipCodes],  esi      ; store prim OR
        mov     [edi+PA_andClipCodes], ebx      ; store prim AND
        mov     ebx, gc
        mov     edi, pdLast

        ;; Save invW in window.w:

        mov  DWORD PTR [edx+PD_window+_W_ - sizeof_POLYDATA], __FLOAT_ONE

        or      ecx, ecx
        jnz     @Done

        fld     DWORD PTR [edx+PD_clip+_X_ - sizeof_POLYDATA]
        fmul    DWORD PTR [ebx+GC_VIEWPORT_xScale]
        fld     DWORD PTR [edx+PD_clip+_Y_ - sizeof_POLYDATA]
        fmul    DWORD PTR [ebx+GC_VIEWPORT_yScale]
        fxch    st(1)                                              ; x y
        fadd    DWORD PTR [ebx+GC_VIEWPORT_xCenter]                ; x y
        fxch    st(1)                                              ; y x
        fadd    DWORD PTR [ebx+GC_VIEWPORT_yCenter]                ; y x
        fxch    st(1)                                              ; x y
        mov     ecx, DWORD PTR [ebx+GC_VIEWPORT_zCenter]           	    
        mov     DWORD PTR [edx+PD_window+_Z_ - sizeof_POLYDATA], ecx
        fstp    DWORD PTR [edx+PD_window+_X_ - sizeof_POLYDATA]
        fstp    DWORD PTR [edx+PD_window+_Y_ - sizeof_POLYDATA]
@Done:
        cmp     edx, edi                        ; pd > pdLast?
        jbe     vertexLoop                      ; yes -> process next vertex
@Exit:
        mov     edx, pa
        pop     edi
        pop     esi
        pop     ebx
        mov     esp, ebp
        pop     ebp
        mov     eax, [edx + PA_andClipCodes]    ; return value
        ret     4

ENDM
;------------------------------------------------------------------------------------------
; Makes clip code for frustum clip planes
; Case when vertices have W == 1.0
;
; Prototype:
;   GLuint FASTCALL PAClipCheckFrustum2D(__GLcontext *gc, POLYARRAY *pa,
;                                        POLYDATA *pdLast);
; Input:
;   edx        = pa pointer to POLYARRAY
;   ecx        = gc pointer to graphics context
;   [esp+4]    = pointer to the last vertex 
;   andClipCodes for POLYARRAY is set to -1
;   orClipCodes  for POLYARRAY is set to 0
;
; Returns:
;   eax = andClipCodes for POLYARRAY
;
@PAClipCheckFrustum2D@12 PROC NEAR

        push    ebp
        mov     ebp, esp
        sub     esp, 12
        xor     eax, eax
        mov     pa, edx
        mov     [edx+PA_orClipCodes], eax       ; PA orClipCodes = 0
        dec     eax
        push    ebx
        mov     [edx+PA_andClipCodes], eax      ; PA andClipCodes = -1
        push    esi
        mov     DWORD PTR gc, ecx
        push    edi
        PAClipCheckFrustum2D 0

@PAClipCheckFrustum2D@12 ENDP
;------------------------------------------------------------------------------------------
; Makes clip code for user planes
;
; Input:
;   edx     = pa
;   ecx     = gc
;   pdLast  = pointer to the last vertex 
;   ReuseClipCode   if set to 1, new clip code is combined using OR with existing one
;
PAClipCheckUser MACRO ReuseClipCode

result          equ -16[ebp]
cwSave	        equ -20[ebp]
cwTemp	        equ -24[ebp]
clipPlaneMask   equ -28[ebp]
firstPlane      equ -32[ebp]

	;; We have to turn on rounding with double precision.  There is
	;; too much error in the dot product otherwise (test with tlogo).

        fnstcw  WORD PTR cwSave
        mov	edi, DWORD PTR cwSave
        and     edi, 0f0ffh
        or      edi, 00200h
        mov	cwTemp, edi	
        fldcw   WORD PTR cwTemp

        mov	edi, pdLast                     ; edi will store POLYARRAY pointer
        mov	edx, DWORD PTR [edx+PA_pd0]
        mov     esi, DWORD PTR [ecx+GC_STATE_enablesClipPlanes]     ; esi = clipPlaneMask
        mov	ebx, [ecx+GC_STATE_clipPlanes0] ; ebx points to the current user plane
        or      esi, esi
        jz      @Exit1                          ; No user planes

        mov     clipPlaneMask, esi              ; save clipPlaneMask
        mov     firstPlane, ebx                 ; save pointer to the first clip plane

@vertexLoop:

        mov     esi, clipPlaneMask              ; reload clipPlaneMask
        xor     eax, eax                        ; prepare clip code
        mov	ecx, __GL_CLIP_USER0            ; ecx stores  __GL_CLIP_USER bits
        mov     ebx, firstPlane                 ; reload pointer to the first clip plane

@doAnotherPlane:

        test    esi, 1                          ; if (clipPlanesMask & 1 == 0) skip the  plane
        je      SHORT @noClipTest

;
; Dot the vertex clip coordinate against the clip plane and see
; if the sign is negative.  If so, then the point is out.
;	     
; 	    if (x * plane->x + y * plane->y + z * plane->z + w * plane->w <
;		 __glZero)
;
	fld     DWORD PTR [ebx+_X_]
	fmul    DWORD PTR [edx+PD_eye+_X_]
	fld     DWORD PTR [ebx+_Y_]
	fmul    DWORD PTR [edx+PD_eye+_Y_]
	fld     DWORD PTR [ebx+_Z_]
	fmul    DWORD PTR [edx+PD_eye+_Z_]    ; z y x
	fxch    ST(2)                         ; x y z
	faddp   ST(1), ST(0)                  ; xy z
	fld	DWORD PTR [ebx+_W_]           ; w xy z
	fmul    DWORD PTR [edx+PD_eye+_W_]
	fxch    ST(2)                         ; z xy w
	faddp   ST(1), ST(0)                  ; zxy w
	faddp   ST(1), ST(0)                  ; zxyw

	fstp    DWORD PTR result
	cmp	result, 0
	jge	@noClipTest

	or	eax, ecx                      ; 	code |= bit;

@noClipTest:

	add	ecx, ecx                      ; bit <<= 1;
	add	ebx, 16                       ; plane++;
	shr	esi, 1                        ; clipPlanesMask >>= 1;
	jne	SHORT @doAnotherPlane

if ReuseClipCode eq 1
        or      [edx+PD_clipCode], eax        ; store vertex clip code
else
        mov     [edx+PD_clipCode], eax        ; store vertex clip code
endif

        add     edx, sizeof_POLYDATA          ; advance vertex ptr
        cmp     edx, edi
        jbe     @vertexLoop                   ; process next vertex

;; restore FP state:

        fldcw   WORD PTR cwSave

@Exit1:

ENDM

;-------------------------------------------------------------------------------------------
; Make clip code when user clip planes are present
;
; Prototype:
;   GLuint FASTCALL PAClipCheckFrustumAll(__GLcontext *gc, POLYARRAY *pa,
;                                         POLYDATA *pdLast);
; Input:
;   edx        = pa pointer to POLYARRAY
;   ecx        = gc pointer to graphics context
;   [esp+4]    = pointer to the last vertex 
;   andClipCodes for POLYARRAY is set to -1
;   orClipCodes  for POLYARRAY is set to 0
;
; Returns:
;   eax = andClipCodes for POLYARRAY
;
@PAClipCheckAll@12 PROC NEAR

        push    ebp
        mov     ebp, esp
        sub     esp, 32
        mov     DWORD PTR pa, edx
        mov     DWORD PTR gc, ecx
        push    ebx
        push    esi
        push    edi

        PAClipCheckUser 0       ; Check user clip planes first
        mov     edx, pa    
        PAClipCheckFrustum 1    ; Check frustum clip planes. We have to use OR when 
                                ; updating vertex clip code

@PAClipCheckAll@12 ENDP
;--------------------------------------------------------------------------------------------

pd 	    equ -4[ebp]
pdLast  equ -8[ebp]

@PolyArrayPropagateSameColor@8 PROC NEAR

	push	ebp
	mov	eax, DWORD PTR [edx+PA_pdNextVertex]
	mov	ebp, esp
	sub	eax, sizeof_POLYDATA
	sub	esp, 8
	mov	DWORD PTR pdLast, eax
	push	ebx
	push	esi
	mov	ebx, DWORD PTR [edx+PA_pd0]
	push	edi

; EAX = pdLast = pa->pdNextVertex-1;
; EBX = pd = pa->pd0;

	mov	DWORD PTR pd, ebx

; if (pd > pdLast)

	cmp	eax, ebx
	jb	@Done

	mov	eax, [edx+PA_flags]
	lea	edi, DWORD PTR [ebx+PD_colors0]

;     if (pa->flags & POLYARRAY_CLAMP_COLOR) {

	test	eax, POLYARRAY_CLAMP_COLOR
	je	@ClampDone

	mov	eax, [edi+_R_]
	mov	ebx, [ecx+GC_redVertexScale]
	sub	ebx, eax
        mov     [ecx+GC_redClampTable], eax
	shr	eax, 31
	add	ebx, ebx

	mov	edx, [edi+_G_]
	adc	eax, eax
	mov	ebx, [ecx+GC_greenVertexScale]
	sub	ebx, edx

 	mov	eax, [4*eax+ecx+GC_redClampTable]

        mov     [ecx+GC_greenClampTable], edx
	shr	edx, 31
	add	ebx, ebx

	mov	[edi+_R_], eax

	adc	edx, edx

	mov	eax, [edi+_B_]
	mov	ebx, [ecx+GC_blueVertexScale]
	sub	ebx, eax

	mov	edx, [4*edx+ecx+GC_greenClampTable]

        mov     [ecx+GC_blueClampTable], eax
	shr	eax, 31
	add	ebx, ebx

	mov	[edi+_G_], edx

	adc	eax, eax

	mov	edx, [edi+_A_]
	mov	ebx, [ecx+GC_alphaVertexScale]
	sub	ebx, edx

 	mov	eax, [4*eax+ecx+GC_blueClampTable]

        mov     [ecx+GC_alphaClampTable], edx
	shr	edx, 31
	add	ebx, ebx
	adc	edx, edx

	mov	[edi+_B_], eax

 	mov	edx, [4*edx+ecx+GC_alphaClampTable]
	mov	[edi+_A_], edx

@ClampDone:

;; Register usage.
;; EAX: r, EBX: g, ECX: b, EDX: a
;; ESI: &pdLast->colors[0]
;; EDI: &pd->colors[0]

	mov     edi, pd
	mov     esi, pdLast
	lea     edi, [edi+PD_colors0+sizeof_POLYDATA]
	lea     esi, [esi+PD_colors0]
		
	mov     eax, [edi+_R_-sizeof_POLYDATA]
	cmp     edi, esi
	ja      @Done
	mov     ebx, [edi+_G_-sizeof_POLYDATA]
	mov     ecx, [edi+_B_-sizeof_POLYDATA]
	mov     edx, [edi+_A_-sizeof_POLYDATA]
@DoLoop:
	mov     [edi+_R_], eax
	mov     [edi+_G_], ebx
	mov     [edi+_B_], ecx
	mov     [edi+_A_], edx
	add     edi, sizeof_POLYDATA
	cmp     edi, esi
	jbe     @DoLoop
@Done:
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
@PolyArrayPropagateSameColor@8 ENDP
;------------------------------------------------------------------------
; Copy cached non lit color from GC to a polydata
;
; Input:
;       PDreg           - register with POLYDATA address
;       GCreg           - register with GC address
;       GC_LIGHT_value  - front or back light (0 or 1)
;       face            - 0 for front face, 1 for back face
;       tmpreg1,
;       tmpreg2         - temporary registers       
;
COPY_CACHED_NON_LIT MACRO PDreg, GCreg, GC_LIGHT_value, face, tmpreg1, tmpreg2

	mov	eax, [ebx+GC_LIGHT_value+MATERIAL_cachedNonLit+_R_]
	mov	ecx, [ebx+GC_LIGHT_value+MATERIAL_cachedNonLit+_G_]
	mov	[esi+PD_colors0+(face*16)+_R_], eax
	mov	[esi+PD_colors0+(face*16)+_G_], ecx
	mov	eax, [ebx+GC_LIGHT_value+MATERIAL_cachedNonLit+_B_]
	mov	ecx, [ebx+GC_LIGHT_value+MATERIAL_alpha]
	mov	[esi+PD_colors0+(face*16)+_B_], eax
	mov	[esi+PD_colors0+(face*16)+_A_], ecx

ENDM
;------------------------------------------------------------------------
; No lights case
;
POLYARRAYZIPPYCALCRGBCOLOR0 MACRO GC_LIGHT_value, face

	push	ebp
	mov	ebp, esp
	sub	esp, 56
	push	ebx
	push	esi
	push	edi

	mov	esi, pdFirst
	mov	edi, pdLast
	mov	ebx, ecx                ; ebx = gc
;
; for (pd = pdFirst; pd <= pdLast; pd++)
;
@lightVertexLoop:

        COPY_CACHED_NON_LIT <esi>, <ebx>, GC_LIGHT_value, face, <eax>, <ecx>

	add	esi, sizeof_POLYDATA
	cmp	edi, esi
	jae	@lightVertexLoop

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12
ENDM
;------------------------------------------------------------------------
; Parameters:
;
;       ecx                     -  GC
;       NUMBER_OF_LIGHTS        - 1 for one light, 2 for more than one light
;

pdFirst equ 12[ebp]
pdLast  equ 16[ebp]
pd	equ pdFirst

face 	equ -4[ebp]
nonBack	equ -4[ebp]
nxi 	equ DWORD PTR -8[ebp]
nyi 	equ DWORD PTR -12[ebp]
nzi 	equ DWORD PTR -16[ebp]
n1  	equ DWORD PTR -20[ebp]
n2  	equ DWORD PTR -24[ebp]
ifx 	equ -28[ebp]
msm	equ -32[ebp]
baseEmissiveAmbientR	equ DWORD PTR -36[ebp]
baseEmissiveAmbientG	equ DWORD PTR -40[ebp]
baseEmissiveAmbientB	equ DWORD PTR -44[ebp]
rsi	equ DWORD PTR -48[ebp]
gsi	equ DWORD PTR -52[ebp]
bsi	equ DWORD PTR -56[ebp]

;;
;; We will handle infinite lights with special cases for front and
;; back faces.
;;

POLYARRAYZIPPYCALCRGBCOLOR MACRO GC_LIGHT_value, LIGHTSOURCE_value, face, NUMBER_OF_LIGHTS

;; GL_LIGHT_value = GL_LIGHT_front or GC_LIGHT_back
;; LIGHTSOURCE_value = LIGHTSOURCE_front or LIGHTSOURCE_back
;; face = __GL_FRONTFACE or __GL_BACKFACE

	push	ebp
	mov	ebp, esp
	sub	esp, 56
if NUMBER_OF_LIGHTS eq 2
	xor	eax, eax
endif
	push	ebx
	push	esi
	push	edi

;; NOTE: esi, ebx held constant in this routine.
;; esi = pd
;; ebx = gc

	mov	esi, pdFirst
	mov	ebx, ecx

;; Start the vertex-processing loop
;;
;; for (pd = pdFirst; pd <= pdLast; pd++)

@lightVertexLoop:

;; If normal has not changed for this vertex, use the previously computed color.
;;	if (!(pd->flags & POLYDATA_NORMAL_VALID))

	mov	edx, [esi+PD_flags]
	test    edx, POLYDATA_NORMAL_VALID
	jne     @normalIsValid

	mov	eax, [(face*16) + esi + (PD_colors0 - sizeof_POLYDATA)+_R_]
	mov	ecx, [(face*16) + esi + (PD_colors0 - sizeof_POLYDATA)+_G_]
	mov	[(face*16) + esi + PD_colors0+_R_], eax
	mov	[(face*16) + esi + PD_colors0+_G_], ecx
	mov	eax, [(face*16) + esi + (PD_colors0 - sizeof_POLYDATA)+_B_]
	mov	ecx, [(face*16) + esi + (PD_colors0 - sizeof_POLYDATA)+_A_]
	mov	[(face*16) + esi + PD_colors0+_B_], eax
	mov     [(face*16) + esi + PD_colors0+_A_], ecx

	;; loop to next pd

	mov	edi, pdLast
	add	esi, sizeof_POLYDATA
if NUMBER_OF_LIGHTS eq 2
	xor	eax, eax
endif
	cmp	edi, esi
	jae	@lightVertexLoop
	jmp     @lightsDone

@normalIsValid:

if NUMBER_OF_LIGHTS eq 2
	mov	nonBack, eax
endif

	mov	edi, [ebx+GC_LIGHT_sources]

if face eq __GL_FRONTFACE

else
	mov	eax, [esi+PD_normal+_X_]
	mov	ecx, [esi+PD_normal+_Y_]
	mov	edx, [esi+PD_normal+_Z_]

	xor	eax, 80000000h
	xor	ecx, 80000000h
	xor	edx, 80000000h

	mov	nxi, eax
	mov	nyi, ecx
	mov	nzi, edx
endif

if NUMBER_OF_LIGHTS eq 2

	test	edi, edi
	je	@lightSourcesDone
@lightSourcesLoop:

endif

;; 	for (lsm = gc->light.sources; lsm; lsm = lsm->next)

	;; edi = lsm (light source pointer)
	
;;	n1 = nxi * lsm->unitVPpli.x + nyi * lsm->unitVPpli.y +
;;	     nzi * lsm->unitVPpli.z;

if face eq __GL_FRONTFACE
	fld     DWORD PTR [esi+PD_normal+_X_]
	fmul    DWORD PTR [edi+LIGHTSOURCE_unitVPpli+_X_]
	fld     DWORD PTR [esi+PD_normal+_Y_]
	fmul    DWORD PTR [edi+LIGHTSOURCE_unitVPpli+_Y_]
	fld     DWORD PTR [esi+PD_normal+_Z_]
	fmul    DWORD PTR [edi+LIGHTSOURCE_unitVPpli+_Z_]
else
	fld     nxi
	fmul    DWORD PTR [edi+LIGHTSOURCE_unitVPpli+_X_]
	fld     nyi
	fmul    DWORD PTR [edi+LIGHTSOURCE_unitVPpli+_Y_]
	fld     nzi
	fmul    DWORD PTR [edi+LIGHTSOURCE_unitVPpli+_Z_]
endif
	fxch    ST(2)
	faddp   ST(1), ST
	faddp   ST(1), ST
	fstp    n1

;;	    if (__GL_FLOAT_GTZ(n1))

if NUMBER_OF_LIGHTS eq 2
	mov	ecx, nonBack
endif

	cmp	n1, 0
	jg	@f

if NUMBER_OF_LIGHTS eq 2
	mov	edi, [edi+LIGHTSOURCE_next]
	test	edi, edi
	je	@lightSourcesDone
	jmp	@lightSourcesLoop
else
        COPY_CACHED_NON_LIT <esi>, <ebx>, GC_LIGHT_value, face, <eax>, <ecx>

	;; loop to next pd

	mov	edi, pdLast
	add	esi, sizeof_POLYDATA
	cmp	edi, esi
	jae	@lightVertexLoop
	jmp     @lightsDone
endif

@@:

if NUMBER_OF_LIGHTS eq 2
	test	ecx, ecx                ; Has lighting been computed
	jne	@f
endif
	
	fld	DWORD PTR [ebx+GC_LIGHT_value+MATERIAL_cachedEmissiveAmbient+_B_]
if NUMBER_OF_LIGHTS eq 2
	inc	ecx
endif
	fld	DWORD PTR [ebx+GC_LIGHT_value+MATERIAL_cachedEmissiveAmbient+_G_]
if NUMBER_OF_LIGHTS eq 2
	mov	nonBack, ecx
endif
	fld	DWORD PTR [ebx+GC_LIGHT_value+MATERIAL_cachedEmissiveAmbient+_R_]
@@:

;;		n2 = (nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * lsm->hHat.z)
;;                      - msm_threshold;

if face eq __GL_FRONTFACE
	fld     DWORD PTR [esi+PD_normal+_X_]
	fmul    DWORD PTR [edi+LIGHTSOURCE_hHat+_X_]
	fld     DWORD PTR [esi+PD_normal+_Y_]
	fmul    DWORD PTR [edi+LIGHTSOURCE_hHat+_Y_]
	fxch    ST(1)
	fsub    DWORD PTR [ebx+GC_LIGHT_value+MATERIAL_threshold]
	fld     DWORD PTR [esi+PD_normal+_Z_]
	fmul    DWORD PTR [edi+LIGHTSOURCE_hHat+_Z_]
else
	fld     nxi
	fmul    DWORD PTR [edi+LIGHTSOURCE_hHat+_X_]
	fld     nyi
	fmul    DWORD PTR [edi+LIGHTSOURCE_hHat+_Y_]
	fxch    ST(1)
	fsub    DWORD PTR [ebx+GC_LIGHT_value+MATERIAL_threshold]
	fld     nzi
	fmul    DWORD PTR [edi+LIGHTSOURCE_hHat+_Z_]
endif
	fxch    ST(2)
	faddp   ST(1), ST
	faddp   ST(1), ST
	fstp    n2

;;	if (__GL_FLOAT_GEZ(n2))

	mov	eax, n2
	or	eax, eax
	js	@noSpecularEffect

;;	     ifx = (GLint)(n2 * msm_scale + __glHalf);


	fld     n2
	fmul    DWORD PTR [ebx+GC_LIGHT_value+MATERIAL_scale]
	mov	edx, __FLOAT_ONE
;; Note: we don't have to do this add since we can assume that rounding
;; enabled:
;;	fadd    ___glHalf
	mov	ecx, [ebx+GC_LIGHT_value+MATERIAL_specTable]
	fistp   DWORD PTR ifx

;;	    if (ifx < __GL_SPEC_LOOKUP_TABLE_SIZE )

	mov	eax, ifx
	cmp	eax, __GL_SPEC_LOOKUP_TABLE_SIZE
	jge	@specularSaturate

;; 		n2 = msm_specTable[ifx];

	mov	edx, DWORD PTR [ecx+eax*4]

@specularSaturate:
	mov	n2, edx

	fld     n2
	fmul    DWORD PTR [edi+LIGHTSOURCE_value+LIGHTSOURCEPERMATERIAL_specular+_R_]
	fld     n2
	fmul    DWORD PTR [edi+LIGHTSOURCE_value+LIGHTSOURCEPERMATERIAL_specular+_G_]
	fld     n2
	fmul    DWORD PTR [edi+LIGHTSOURCE_value+LIGHTSOURCEPERMATERIAL_specular+_B_]
	fxch    ST(2)       	; r g b R G B
	faddp	ST(3), ST	; g b R G B
	faddp	ST(3), ST	; b R G B
	faddp	ST(3), ST	; R G B

@noSpecularEffect:

	;; now handle diffuse affect:

	fld     n1
	fmul    DWORD PTR [edi+LIGHTSOURCE_value+LIGHTSOURCEPERMATERIAL_diffuse+_R_]
	fld     n1
	fmul    DWORD PTR [edi+LIGHTSOURCE_value+LIGHTSOURCEPERMATERIAL_diffuse+_G_]
	fld     n1
	fmul    DWORD PTR [edi+LIGHTSOURCE_value+LIGHTSOURCEPERMATERIAL_diffuse+_B_]
	fxch    ST(2)       	; r g b R G B
	faddp	ST(3), ST	; g b R G B
if NUMBER_OF_LIGHTS eq 2
	mov	edi, [edi+LIGHTSOURCE_next]
endif
	faddp	ST(3), ST	; b R G B
if NUMBER_OF_LIGHTS eq 2
	test	edi, edi
endif
	faddp	ST(3), ST	; R G B

if NUMBER_OF_LIGHTS eq 2
	jne	@lightSourcesLoop

@lightSourcesDone:

	mov	eax, nonBack
	test	eax,eax
	jne	@f
        COPY_CACHED_NON_LIT <esi>, <ebx>, GC_LIGHT_value, face, <eax>, <ecx>

	;; loop to next pd

	mov	edi, pdLast
	add	esi, sizeof_POLYDATA
	xor	eax, eax
	cmp	edi, esi
	jae	@lightVertexLoop
	jmp     @lightsDone
@@:

endif ; NUMBER_OF_LIGHTS eq 2

	;; OK, we had some lighting for this vertex. Now, handle clamping:

	fstp	rsi
	mov	eax, [ebx+GC_redVertexScale]
	fstp	gsi
	mov	edx, rsi
	fstp	bsi
	
	mov	ecx, [ebx+GC_greenVertexScale]
	mov	edi, gsi
	sub	eax, edx
	sub	ecx, edi
	or	eax, edx
	or	ecx, edi
	mov	edx, [ebx+GC_blueVertexScale]
	or	eax, ecx
	mov	edi, bsi
	or	eax, edi
	sub	edx, edi
	or	eax, edx
	jns	@noClamp

	mov	eax, rsi
	mov	ecx, [ebx+GC_redVertexScale]
	sub	ecx, eax
        mov     [ebx+GC_redClampTable], eax
	shr	eax, 31
	add	ecx, ecx

	mov	edx, gsi
	adc	eax, eax
	mov	ecx, [ebx+GC_greenVertexScale]
	sub	ecx, edx

 	mov	eax, [4*eax+ebx+GC_redClampTable]

       	mov     [ebx+GC_greenClampTable], edx
	shr	edx, 31
	add	ecx, ecx
	mov	rsi, eax
	adc	edx, edx

	mov	eax, bsi
	mov	ecx, [ebx+GC_blueVertexScale]
	sub	ecx, eax

	mov	edx, [4*edx+ebx+GC_greenClampTable]

        mov     [ebx+GC_blueClampTable], eax
	shr	eax, 31
	add	ecx, ecx

	mov	gsi, edx

	adc	eax, eax
 	mov	eax, [4*eax+ebx+GC_blueClampTable]
	mov	bsi, eax

@noClamp:

	;; store colors

	mov	eax, [ebx+GC_LIGHT_value+MATERIAL_alpha]
	mov	ecx, rsi
	mov	edx, gsi
	mov	edi, bsi
	mov	[esi+PD_colors0+(face*16)+_A_], eax
	mov	[esi+PD_colors0+(face*16)+_R_], ecx
	mov	[esi+PD_colors0+(face*16)+_G_], edx
	mov	[esi+PD_colors0+(face*16)+_B_], edi

	;; loop to next pd

	mov	edi, pdLast
	add	esi, sizeof_POLYDATA
	xor	eax, eax
	cmp	edi, esi
	jae	@lightVertexLoop

@lightsDone:

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12

ENDM
;--------------------------------------------------------------------------------
@PolyArrayZippyCalcRGBColorFront@20 PROC NEAR
	POLYARRAYZIPPYCALCRGBCOLOR GC_LIGHT_front, LIGHTSOURCE_front, __GL_FRONTFACE, 2
@PolyArrayZippyCalcRGBColorFront@20 ENDP

@PolyArrayZippyCalcRGBColorBack@20 PROC NEAR
	POLYARRAYZIPPYCALCRGBCOLOR GC_LIGHT_back, LIGHTSOURCE_back, __GL_BACKFACE, 2
@PolyArrayZippyCalcRGBColorBack@20 ENDP
;
; Functions for the one light source
;
@PolyArrayZippyCalcRGBColorFront1@20 PROC NEAR
	POLYARRAYZIPPYCALCRGBCOLOR GC_LIGHT_front, LIGHTSOURCE_front, __GL_FRONTFACE, 1
@PolyArrayZippyCalcRGBColorFront1@20 ENDP

@PolyArrayZippyCalcRGBColorBack1@20 PROC NEAR
	POLYARRAYZIPPYCALCRGBCOLOR GC_LIGHT_back, LIGHTSOURCE_back, __GL_BACKFACE, 1
@PolyArrayZippyCalcRGBColorBack1@20 ENDP
;
; Functions for the no light sources
;
@PolyArrayZippyCalcRGBColorFront0@20 PROC NEAR
	POLYARRAYZIPPYCALCRGBCOLOR0 GC_LIGHT_front, __GL_FRONTFACE
@PolyArrayZippyCalcRGBColorFront0@20 ENDP

@PolyArrayZippyCalcRGBColorBack0@20 PROC NEAR
	POLYARRAYZIPPYCALCRGBCOLOR0 GC_LIGHT_back, __GL_BACKFACE
@PolyArrayZippyCalcRGBColorBack0@20 ENDP
;--------------------------------------------------------------------------------
; void FASTCALL PolyArrayZippyCalcRGBColor(__GLcontext* gc, int face, POLYARRAY* pa, 
;                                          POLYDATA* pdFirst, POLYDATA* pdLast)
;
; Input:
;       ecx             = gc
;       edx             = face (0 - front, 1 - back)
;       [esp+4]         = pa 
;       [esp+8]         = pdFirst
;       [esp+12]        = pdLast
;
@PolyArrayZippyCalcRGBColor@20 PROC NEAR

        push    edi
	mov	edi, [ecx+GC_LIGHT_sources]
        or      edi, edi
        jz      @noLights
        cmp     [edi+LIGHTSOURCE_next], 0
        jne     @multipleLights 
;
; one lignt case
;
        pop     edi
	test	edx, edx
	je	@PolyArrayZippyCalcRGBColorFront1@20
	jmp	@PolyArrayZippyCalcRGBColorBack1@20
                
@noLights:
        pop     edi
	test	edx, edx
	je	@PolyArrayZippyCalcRGBColorFront0@20
	jmp	@PolyArrayZippyCalcRGBColorBack0@20

@multipleLights:
        pop     edi

	test	edx, edx
	je	@PolyArrayZippyCalcRGBColorFront@20
	jmp	@PolyArrayZippyCalcRGBColorBack@20

@PolyArrayZippyCalcRGBColor@20 ENDP
;--------------------------------------------------------------------------------
; void FASTCALL PolyArrayZippyCalcRGBColor(__GLcontext* gc, int face, POLYARRAY* pa, 
;                                          POLYDATA* pdFirst, POLYDATA* pdLast)
;
; Input:
;       ecx             = gc
;       edx             = face (0 - front, 1 - back)
;       [esp+4]         = pa 
;       [esp+8]         = pdFirst
;       [esp+12]        = pdLast
;
emissiveAmbientR	equ DWORD PTR -60[ebp]
emissiveAmbientG	equ DWORD PTR -64[ebp]
emissiveAmbientB	equ DWORD PTR -68[ebp]
colorMaterialChange	equ           -72[ebp]
alpha			equ DWORD PTR -76[ebp]
ri			equ DWORD PTR -80[ebp]
gi			equ DWORD PTR -84[ebp]
bi			equ DWORD PTR -88[ebp]
diffuseSpecularR	equ DWORD PTR -92[ebp]
diffuseSpecularG	equ DWORD PTR -96[ebp]
diffuseSpecularB	equ DWORD PTR -100[ebp]

@PolyArrayFastCalcRGBColor@20 PROC NEAR
	mov	eax, [ecx+GC_LIGHT_front+MATERIAL_colorMaterialChange]
	test	edx, edx
	je	@f
	mov	eax, [ecx+GC_LIGHT_back+MATERIAL_colorMaterialChange]
@@:
	test	eax, eax
	je	@PolyArrayZippyCalcRGBColor@20

	push	ebp
	mov	ebp, esp
	sub	esp, 100
	test	edx, edx
	push	ebx
	mov	ebx, ecx
	push	esi

;; if (face == __GL_FRONTFACE)
;;     msm = &gc->light.front;
;;         else
;;     msm = &gc->light.back;

	lea	ecx, DWORD PTR [ebx+GC_LIGHT_front]
	je	short @f
	lea	ecx, DWORD PTR [ebx+GC_LIGHT_back]
@@:
	push	edi
	mov	DWORD PTR face, edx
	mov	msm, ecx
	mov	eax, [ecx+MATERIAL_colorMaterialChange]
	mov	colorMaterialChange, eax
	test	eax, __GL_MATERIAL_AMBIENT

	jne	@baseEmissiveSimple

	mov	eax, [ecx+MATERIAL_cachedEmissiveAmbient+_R_]
	mov	edx, [ecx+MATERIAL_cachedEmissiveAmbient+_G_]
	mov	baseEmissiveAmbientR, eax
	mov	emissiveAmbientR, eax
	mov	baseEmissiveAmbientG, edx
	mov	emissiveAmbientG, edx

	mov	eax, [ecx+MATERIAL_cachedEmissiveAmbient+_B_]
	mov	esi, pdFirst
	mov	edi, pdLast
	mov	baseEmissiveAmbientB, eax
	cmp	edi, esi
	mov	emissiveAmbientB, eax
	jb	@lightsDone

	jmp	@baseEmissiveDone

@baseEmissiveSimple:

	mov	eax, [ecx+MATERIAL_paSceneColor+_R_]
	mov	edx, [ecx+MATERIAL_paSceneColor+_G_]
	mov	baseEmissiveAmbientR, eax
	mov	emissiveAmbientR, eax
	mov	baseEmissiveAmbientG, edx
	mov	emissiveAmbientG, edx

	mov	eax, [ecx+MATERIAL_paSceneColor+_B_]
	mov	esi, pdFirst
	mov	edi, pdLast
	mov	baseEmissiveAmbientB, eax
	cmp	edi, esi
	mov	emissiveAmbientB, eax
	jb	@lightsDone

@baseEmissiveDone:

; If there is no emissive or ambient color material change, this
; will be the emissive and ambient components.
;
;    emissiveAmbientI.r = baseEmissiveAmbient.r;
;    emissiveAmbientI.g = baseEmissiveAmbient.g;
;    emissiveAmbientI.b = baseEmissiveAmbient.b;

;;
;;
;; Vertex loop follows:
;;
;;

;; for (pd = pdFirst; pd <= pdLast; pd++)

@lightVertexLoop:

        ;; If normal has not changed for this vertex, use the previously 
        ;; computed color.
        ;; [if !(pd->flags & (POLYDATA_NORMAL_VALID | POLYDATA_COLOR_VALID))]

        mov	edx, [esi+PD_flags]
        test	edx, POLYDATA_NORMAL_VALID OR POLYDATA_COLOR_VALID
        jne	@normalOrColorIsValid
        mov	eax, face
        shl	eax, 4
        lea	edi, [eax + esi + PD_colors0]
        lea	esi, [eax + esi + (PD_colors0 - sizeof_POLYDATA)]
        movsd
        movsd
        movsd
        movsd

        mov	esi, pd
        mov	edi, pdLast
        add	esi, sizeof_POLYDATA
        cmp	edi, esi
        mov	pd, esi
        jae	@lightVertexLoop
        jmp	@lightsDone

@normalOrColorIsValid:

        ;; if (pd->flags & POLYDATA_COLOR_VALID)
        ;;     ri = pd->colors[0].r * gc->oneOverRedVertexScale;
        ;;     gi = pd->colors[0].g * gc->oneOverGreenVertexScale;
        ;;     bi = pd->colors[0].b * gc->oneOverBlueVertexScale;
        ;;     alpha = pd->colors[0].a;

        test	edx, POLYDATA_COLOR_VALID
        je	@usePreviousColors

        mov	eax, [esi+PD_colors0+_A_]
        mov	alpha, eax
        mov	eax, colorMaterialChange
        fld	DWORD PTR [esi+PD_colors0+_R_]
        fmul	DWORD PTR [ebx+GC_oneOverRedVertexScale]
        fld	DWORD PTr [esi+PD_colors0+_G_]
        fmul	DWORD PTR [ebx+GC_oneOverGreenVertexScale]
        fld	DWORD PTR [esi+PD_colors0+_B_]
        fmul	DWORD PTR [ebx+GC_oneOverBlueVertexScale]	;; b g r
        fxch	ST(2)						;; r g b
        fstp	ri
        fstp	gi
        fstp	bi	;; FPU stack empty

        test	eax, __GL_MATERIAL_AMBIENT
        je	@noMaterialAmbient

	
        ;; 
        ;; Handle ambient color changes:
        ;;
        ;;	if (msm_colorMaterialChange & __GL_MATERIAL_AMBIENT) {
        ;;	    emissiveAmbient.r = baseEmissiveAmbient.r + ri * lm_ambient.r;
        ;;	    emissiveAmbient.g = baseEmissiveAmbient.g + gi * lm_ambient.g;
        ;;	    emissiveAmbient.b = baseEmissiveAmbient.b + bi * lm_ambient.b;
        ;;	}

        fld	ri
        fmul	DWORD PTR [ebx+GC_STATE_lightModelAmbient+_R_]
        fld	gi
        mov	edi, [ebx+GC_LIGHT_sources]
        fmul	DWORD PTR [ebx+GC_STATE_lightModelAmbient+_G_]
        fld	bi
        test	edi, edi
        fmul	DWORD PTR [ebx+GC_STATE_lightModelAmbient+_B_]	; b g r
        fxch	ST(1)						; g b r
        fadd	baseEmissiveAmbientG				; G b r
        fxch	ST(1)						; b G r
        fadd	baseEmissiveAmbientB				; B G r
        fxch	ST(2)						; r G B
        fadd	baseEmissiveAmbientR				; R G B

        jne	@ambientLoop

        fstp	emissiveAmbientR	;; If we don't have to process
        fstp	emissiveAmbientG	;; the lights, pop the FPU stack
        fstp	emissiveAmbientB	;; and continue
        jmp	@emissiveAmbientDone

@ambientLoop:

	;; Add per-light per-material ambient values.
	;; We will start with the current basEmissiveAmbient values
	;; already on the stack.

	;; for (lsm = gc->light.sources; lsm; lsm = lsm->next) {
	;;     emissiveAmbientI.r += ri * lsm->state.ambient.r;
	;;     emissiveAmbientI.g += gi * lsm->stats.ambient.g;
	;;     emissiveAmbientI.b += bi * lsm->state.ambient.b;
	;; }


        mov     edx, [edi+LIGHTSOURCE_state]		; lss
                
        fld     ri
        fmul    DWORD PTR [edx+LIGHTSOURCESTATE_ambient+_R_]
        fld     gi
        fmul    DWORD PTR [edx+LIGHTSOURCESTATE_ambient+_G_]
        fld     bi
        fmul    DWORD PTR [edx+LIGHTSOURCESTATE_ambient+_B_]	;; b g r R G B
        fxch    ST(2)						;; r g b R G B
        faddp   ST(3), ST(0)
        mov     edi, [edi+LIGHTSOURCE_next]
        faddp   ST(3), ST(0)
        test    edi, edi
        faddp   ST(3), ST(0)
        jne     @ambientLoop

        ;; There are no lights, so pop the emissive result at this point 
        ;; and continue:

        fstp	emissiveAmbientR
        fstp	emissiveAmbientG
        fstp	emissiveAmbientB
        jmp	@emissiveAmbientDone

@noMaterialAmbient:
	
	;;
	;; Handle emissive material changes if needed:
	;;

	test	eax, __GL_MATERIAL_EMISSIVE
	je	@emissiveAmbientDone

	;; emissiveAmbientR = baseEmissiveAmbientR + pd->colors[0].r;
	;; emissiveAmbientG = baseEmissiveAmbientG + pd->colors[0].g;
	;; emissiveAmbientB = baseEmissiveAmbientB + pd->colors[0].b;
	
	fld	baseEmissiveAmbientR
	fadd	DWORD PTR [esi+PD_colors0+_R_]
	fld	baseEmissiveAmbientG
	fadd	DWORD PTR [esi+PD_colors0+_G_]
	fld	baseEmissiveAmbientB
	fadd	DWORD PTR [esi+PD_colors0+_B_]	; b g r
	fxch	ST(2)				; r g b
	fstp	emissiveAmbientR
	fstp	emissiveAmbientG
	fstp	emissiveAmbientB

@emissiveAmbientDone:
@usePreviousColors:

	;;
	;; OK, we're done handling emissive and diffuse color changes, or
	;; we're simply using the previous values.  Now, handle portion of
	;; lighting which depends on the vertex normals (diffuse + specular):
	;;
	
	;; if (pd->flags & POLYDATA_NORMAL_VALID)

	mov	edx, [esi+PD_flags]
	test	edx, POLYDATA_NORMAL_VALID
	je	@normalNotValid

	mov	eax, face

;;	if (face == __GL_FRONTFACE)

	mov	ecx, [esi+PD_normal+_X_]
	mov	edx, [esi+PD_normal+_Y_]
	mov	esi, [esi+PD_normal+_Z_]

	test	eax, eax
	je	@notBackFace

	;; negate the floating-point normal values

	xor	ecx, 80000000h
	xor	edx, 80000000h
	xor	esi, 80000000h

@notBackFace:

	mov	nxi, ecx
	mov	nyi, edx
	mov	nzi, esi

	jmp	@calcColor


@normalNotValid:

;;	if (!(msm_colorMaterialChange & (__GL_MATERIAL_SPECULAR | __GL_MATERIAL_DIFFUSE)))
;;	    goto store_color;
	
	test	eax, __GL_MATERIAL_SPECULAR OR __GL_MATERIAL_DIFFUSE
	je	@storeColor

@calcColor:


	fld	___glZero
	mov	esi, [ebx+GC_LIGHT_sources]
	fld	___glZero
	test	esi, esi
	fld	___glZero
	je	@lightSourcesDone

@lightSourcesLoop:

;; 	for (lsm = gc->light.sources; lsm; lsm = lsm->next)


	mov	eax, face

;; 	    lspmm = &lsm->front + face;

	lea	ecx, [esi+LIGHTSOURCE_front]
	test	eax, eax
	je	@f
	lea	ecx, [esi+LIGHTSOURCE_back]
@@:

	;; esi = lsm
	;; ecx = lspmm
	
;;	    n1 = nxi * lsm->unitVPpli.x + nyi * lsm->unitVPpli.y +
;;		nzi * lsm->unitVPpli.z;


	fld     nxi
	mov	edi, msm
	fmul    DWORD PTR [esi+LIGHTSOURCE_unitVPpli+_X_]
	fld     nyi
	fmul    DWORD PTR [esi+LIGHTSOURCE_unitVPpli+_Y_]
	fld     nzi
	fmul    DWORD PTR [esi+LIGHTSOURCE_unitVPpli+_Z_]
	fxch    ST(2)
	faddp   ST(1), ST
	faddp   ST(1), ST
	fstp    n1

;;	    if (__GL_FLOAT_GTZ(n1))

	mov	eax, n1
	cmp	eax, 0
	jg	@f
	mov	esi, [esi+LIGHTSOURCE_next]
	test	esi, esi
	jne	@lightSourcesLoop
	jmp	@lightSourcesDone
@@:

;;		n2 = (nxi * lsm->hHat.x + nyi * lsm->hHat.y + nzi * lsm->hHat.z)
;;                      - msm_threshold;

	fld     nxi
	fmul    DWORD PTR [esi+LIGHTSOURCE_hHat+_X_]
	fld     nyi
	fmul    DWORD PTR [esi+LIGHTSOURCE_hHat+_Y_]
	fxch    ST(1)
	fsub    DWORD PTR [edi+MATERIAL_threshold]
	fld     nzi
	fmul    DWORD PTR [esi+LIGHTSOURCE_hHat+_Z_]
	fxch    ST(2)
	faddp   ST(1), ST
	faddp   ST(1), ST
	fstp    n2

;;	if (__GL_FLOAT_GEZ(n2))

	mov	eax, n2
	or	eax, eax
	js	@noSpecularEffect

;;	     ifx = (GLint)(n2 * msm_scale + __glHalf);


	fld     n2
	fmul    DWORD PTR [edi+MATERIAL_scale]
	mov	edx, __FLOAT_ONE
;; Note: we don't have to do this add since we can assume that rounding
;; enabled:
;;	fadd    ___glHalf
	mov	edi, [edi+MATERIAL_specTable]
	fistp   DWORD PTR ifx

;;	    if (ifx < __GL_SPEC_LOOKUP_TABLE_SIZE )

	mov	eax, ifx
	cmp	eax, __GL_SPEC_LOOKUP_TABLE_SIZE
	jge	@specularSaturate

;; 		n2 = msm_specTable[ifx];

	mov	edx, DWORD PTR [edi+eax*4]

@specularSaturate:
	mov	eax, colorMaterialChange
	mov	n2, edx
	test	eax, __GL_MATERIAL_SPECULAR
	je	@noSpecularMaterialChange
	
	fld	n2
	mov	edx, [esi+LIGHTSOURCE_state]
	fmul	ri
	fld	n2
	fmul	gi
	fld	n2
	fmul	bi		; b g r
	fxch	ST(2)		; r g b
	fmul	DWORD PTR [edx+LIGHTSOURCESTATE_specular+_R_]
	fxch	ST(1)		; g r b
	fmul	DWORD PTR [edx+LIGHTSOURCESTATE_specular+_G_]
	fxch	ST(2)		; b r g
	fmul	DWORD PTR [edx+LIGHTSOURCESTATE_specular+_B_]
	fxch	ST(1)		; r b g R G B
	faddp	ST(3), ST(0)	; b g R G B
	fxch	ST(1)		; g b R G B
	faddp	ST(3), ST(0)	; b R G B
	faddp	ST(3), ST(0)	; R G B
	jmp	short @noSpecularEffect
	

@noSpecularMaterialChange:


	fld     n2
	fmul    DWORD PTR [ecx+LIGHTSOURCEPERMATERIAL_specular+_R_]
	fld     n2
	fmul    DWORD PTR [ecx+LIGHTSOURCEPERMATERIAL_specular+_G_]
	fld     n2
	fmul    DWORD PTR [ecx+LIGHTSOURCEPERMATERIAL_specular+_B_]
	fxch    ST(2)       	; r g b R G B
	faddp	ST(3), ST	; g b R G B
	faddp	ST(3), ST	; b R G B
	faddp	ST(3), ST	; R G B

@noSpecularEffect:
	;; now handle diffuse affect:
	mov	eax, colorMaterialChange
	test	eax, __GL_MATERIAL_DIFFUSE
	je	@noDiffuseMaterialChange
	fld	n1
	mov	edx, [esi+LIGHTSOURCE_state]
	fmul	ri
	fld	n1
	fmul	gi
	fld	n1
	fmul	bi		; b g r
	fxch	ST(2)		; r g b
	fmul	DWORD PTR [edx+LIGHTSOURCESTATE_diffuse+_R_]
	fxch	ST(1)		; g r b
	fmul	DWORD PTR [edx+LIGHTSOURCESTATE_diffuse+_G_]
	fxch	ST(2)		; b r g
	fmul	DWORD PTR [edx+LIGHTSOURCESTATE_diffuse+_B_]
	fxch	ST(1)		; r b g R G B
	faddp	ST(3), ST(0)	; b g R G B
	fxch	ST(1)		; g b R G B
	faddp	ST(3), ST(0)	; b R G B
	faddp	ST(3), ST(0)	; R G B
	jmp	short @lightSourcesDone

@noDiffuseMaterialChange:

	fld     n1
	fmul    DWORD PTR [ecx+LIGHTSOURCEPERMATERIAL_diffuse+_R_]
	fld     n1
	fmul    DWORD PTR [ecx+LIGHTSOURCEPERMATERIAL_diffuse+_G_]
	fld     n1
	fmul    DWORD PTR [ecx+LIGHTSOURCEPERMATERIAL_diffuse+_B_]
	fxch    ST(2)       	; r g b R G B
	faddp	ST(3), ST	; g b R G B
	mov	esi, [esi+LIGHTSOURCE_next]
	faddp	ST(3), ST	; b R G B
	test	esi, esi
	faddp	ST(3), ST	; R G B
	jne	@lightSourcesLoop
	
@lightSourcesDone:

	fst	diffuseSpecularR
        fadd    emissiveAmbientR    ; R g b
        fxch    ST(1)               ; g R b
	fst	diffuseSpecularG
        fadd    emissiveAmbientG    ; G R b
        fxch    ST(2)               ; b R G
	fst	diffuseSpecularB
        fadd    emissiveAmbientB    ; B R G
        fxch    ST(1)               ; R B G
	fstp	rsi
        mov	eax, [ebx+GC_redVertexScale]
	fstp	bsi
        mov	ecx, [ebx+GC_greenVertexScale]
	fstp	gsi
        mov	edx, rsi

        jmp     short @handleClamp

@storeColor:

	;; Now add emissiveAmbient (on FP stack) and diffuseSpecular.
	;; Interleave with start of clamping:

        fld     emissiveAmbientR
        mov	eax, [ebx+GC_redVertexScale]
        fadd    diffuseSpecularR
        mov	ecx, [ebx+GC_greenVertexScale]
        fld     emissiveAmbientG
        fadd    diffuseSpecularG
        fld     emissiveAmbientB
        fadd    diffuseSpecularB
        fxch    ST(2)               ; r g b
        fstp    rsi
        fstp    gsi
        mov	edx, rsi
        fstp    bsi

@handleClamp:

	;; handle clamping:

	mov	edi, gsi
	sub	eax, edx
	sub	ecx, edi
	or	eax, edx
	or	ecx, edi
	mov	edx, [ebx+GC_blueVertexScale]
	or	eax, ecx
	mov	edi, bsi
	or	eax, edi
	sub	edx, edi
	or	eax, edx
	jns	@noClamp

	mov	eax, rsi
	mov	ecx, [ebx+GC_redVertexScale]
	sub	ecx, eax
        mov     [ebx+GC_redClampTable], eax
	shr	eax, 31
	add	ecx, ecx

	mov	edx, gsi
	adc	eax, eax
	mov	ecx, [ebx+GC_greenVertexScale]
	sub	ecx, edx

 	mov	eax, [4*eax+ebx+GC_redClampTable]

       	mov     [ebx+GC_greenClampTable], edx
	shr	edx, 31
	add	ecx, ecx
	mov	rsi, eax
	adc	edx, edx

	mov	eax, bsi
	mov	ecx, [ebx+GC_blueVertexScale]
	sub	ecx, eax

        mov	edx, [4*edx+ebx+GC_greenClampTable]

        mov     [ebx+GC_blueClampTable], eax
	shr	eax, 31
	add	ecx, ecx

	mov	gsi, edx

	adc	eax, eax
 	mov	eax, [4*eax+ebx+GC_blueClampTable]
	mov	bsi, eax

@noClamp:

        ;; ecx = pd->colors[face]

	mov	edx, msm

	mov	eax, face
	mov	esi, pd
	shl	eax, 4
	lea	ecx, [esi+PD_colors0]
	mov	edi, colorMaterialChange
	add	ecx, eax

	test	edi, __GL_MATERIAL_DIFFUSE
	je	@noAlphaChange

	mov	edx, alpha
	mov	eax, [ebx+GC_alphaVertexScale]
	test	edx, edx
	jns	@f
	xor	edx, edx
@@:
	sub	eax, edx
	jge	@alphaDone
	mov	edx, [ebx+GC_alphaVertexScale]
	jmp	short @alphaDone

@noAlphaChange:

	mov	edx, [edx+MATERIAL_alpha]

@alphaDone:
	
	mov	edi, pdLast
	add	esi, sizeof_POLYDATA

	;; store colors

	mov	[ecx+_A_], edx
	mov	eax, rsi
	mov	edx, gsi
	mov	[ecx+_R_], eax
	mov	pd, esi
	mov	eax, bsi
	mov	[ecx+_G_], edx
	mov	[ecx+_B_], eax

	;; loop to next pd

	cmp	edi, esi
	jae	@lightVertexLoop
	
@lightsDone:

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12
@PolyArrayFastCalcRGBColor@20 ENDP

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\i386\span_f.asm ===
;----------------------------------------------------------------------
; Module name: span_f.asm
;
; Created: 2/3/94
; Author:  Otto Berkes [ottob]
;
; Draw fast flat-shaded, z-buffered scanlines.
;----------------------------------------------------------------------


.code


;----------------------------------------------------------------------
; __fastxxxFlatSpan
;
; Draw a flat-shaded span.
;----------------------------------------------------------------------

XNAME <begin::>

PROCNAME <FlatSpan  PROC	uses ebx edx esi edi, GLCONTEXT: ptr>
	LOCAL xlatAddr: dword
	LOCAL rAccum: dword
	LOCAL gAccum: dword
	LOCAL bAccum: dword
	LOCAL aAccum: dword
	LOCAL zAccum: dword
	LOCAL zDelta: dword
	LOCAL ditherVals: dword
	LOCAL ditherVals2: dword
	LOCAL ditherVals3: dword
	LOCAL ditherVals4: dword

	mov	esi, GLCONTEXT
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_color.COLOR_r
	mov	rAccum, eax
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_color.COLOR_g
	mov	gAccum, eax
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_color.COLOR_b
	mov	bAccum, eax
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_color.COLOR_a
	mov	aAccum, eax
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_z
	mov	zAccum, eax

	mov	ebx, [esi].GENCTX_pPrivateArea
	mov	ebx, [ebx]
	mov	eax, [ebx].SPANREC_z
	mov	zDelta, eax

	mov	edi, [esi].GENCTX_ColorsBits
	mov	edx, [esi].CTX_polygon.POLY_shader.SHADE_cfb
	test	dword ptr [edx].BUF_other, DIB_FORMAT
	je	@no_dib
	mov	edi, [edx].BUF_base
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_y
	sub	eax, [esi].CTX_constants.CTXCONST_viewportYAdjust
	add	eax, [edx].BUF_yOrigin
	mov	ebx, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_x
	sub	ebx, [esi].CTX_constants.CTXCONST_viewportXAdjust
	add	ebx, [edx].BUF_xOrigin
	mul	dword ptr [edx].BUF_outerWidth
XNAME <bpp::>
	shl	ebx, 2
	add	eax, ebx
	add	edi, eax
@no_dib:
	mov	eax, [esi].GENCTX_pajTranslateVector
if RGBMODE eq 0
XNAME <cixlat_ofs::>
	add	eax, GLintSize		; for color-index modes, the first
endif					; entry is the # of entries!
	mov	xlatAddr, eax

					; calculate dither values for span
if DITHER
	mov	edx, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_y
	and	edx, 03h
	shl	edx, 2
	mov	edx, Dither_4x4[edx]
	mov	ecx, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_x
	and	ecx, 03h
	shl	ecx, 3
	ror	edx, cl		;edx has x-aligned dither entries for span
endif

if RGBMODE ;>>>>>>>>>>>>>>>> RGBMODE RGB case

;; Pre-calculate 4 dither values along scanline since the color is constant

	mov	ecx, [esi].CTX_polygon.POLY_shader.SHADE_spanLength
	lea	esi, ditherVals
	cmp	ecx, 0
	jle	@fastSpanDone

if DITHER ;>>>>>>>>>>>>>>>> RGB dither case
	cmp	ecx, 4
	jle	@genDitherLoop
	mov	ecx, 4

@genDitherLoop:

;; Blue component

	mov	eax, bAccum
	shr	eax, 8
	add	al, dl
	adc	ah, 0
ifdef CLAMPCOLOR
XNAME <bmax::>
	mov	al, 011111b
	cmp	al, ah
	sbb	ah, 0
endif
	mov	al, ah
	xor	ah, ah
XNAME <bshift::>
	shl	eax, 11
	mov	ebx, eax

;; Green component

	mov	eax, gAccum
	shr	eax, 8
	add	al, dl
	adc	ah, 0
ifdef CLAMPCOLOR
XNAME <gmax::>
	mov	al, 0111111b
	cmp	al, ah
	sbb	ah, 0
endif
	mov	al, ah
	xor	ah, ah
XNAME <gshift::>
	shl	eax, 5
	or	ebx, eax

;; Red component

	mov	eax, rAccum
	shr	eax, 8
	add	al, dl
	adc	ah, 0
ifdef CLAMPCOLOR
XNAME <rmax::>
	mov	al, 011111b
	cmp	al, ah
	sbb	ah, 0
endif
	mov	al, ah
	xor	ah, ah
XNAME <rshift::>
	shl	eax, 0
	or	ebx, eax

	xchg	ebx, eax

	mov	ebx, xlatAddr		;translate to physical color
XNAME <xlat::>
	xlatb

XNAME <write_dither1::>			;write result into dither buffer
	mov	[esi], ax
XNAME <write_dither2::>
	add	esi, 2

	ror	edx, 8			;advance dither to next x-address
	dec	ecx
	jg	@genDitherLoop

else ;>>>>>>>>>>>>>>>> RGB no-dither case

	mov	eax, bAccum
	shr	eax, 16
XNAME <bshift::>
	shl	eax, 11
	mov	edx, eax

	mov	eax, gAccum
	shr	eax, 16
XNAME <gshift::>
	shl	eax, 5
	or	edx, eax

	mov	eax, rAccum
	shr	eax, 16
XNAME <rshift::>
	shl	eax, 0
	or	edx, eax

	mov	eax, edx
	mov	ebx, xlatAddr		;translate to physical color
XNAME <xlat::>
	xlatb
	mov	dl, al


endif ;<<<<<<<<<<<<<<<< end RGB DITHER cases

else  ;>>>>>>>>>>>>>>>> RGBMODE color-index case

	mov	ecx, [esi].CTX_polygon.POLY_shader.SHADE_spanLength
	lea	esi, ditherVals
	cmp	ecx, 0
	jle	@fastSpanDone

if DITHER ;>>>>>>>>>>>>>>>> dithered color-index case
	cmp	ecx, 4
	jle	@genDitherLoop
	mov	ecx, 4

@genDitherLoop:
	mov	eax, rAccum
	shr	eax, 8
	add	al, dl
	adc	ah, 0
	mov	al, ah
	xor	ah, ah
XNAME <cixlat_shift::>
	shl	eax, 2			; 4 or 1 byte/entry
	add	eax, xlatAddr
	mov	eax, [eax]
XNAME <write_dither1::>			;write result into dither buffer
	mov	[esi], ax
XNAME <write_dither2::>
	add	esi, 2
	
	ror	edx, 8
	dec	ecx
	jg	@genDitherLoop

else ;>>>>>>>>>>>>>>>> solid color-index case

	mov	eax, rAccum
	shr	eax, 16
XNAME <cixlat_shift::>
	shl	eax, 2			; 4 or 1 byte/entry
	add	eax, xlatAddr
	mov	eax, [eax]
	mov	edx, eax		; we store pre-computed value in edx
endif ;<<<<<<<<<<<<<<<< end color-index DITHER cases


endif ;<<<<<<<<<<<<<<<< end RGBMODE cases


;; load up interpolation/count registers

	mov	esi, GLCONTEXT
	mov	ecx, [esi].CTX_polygon.POLY_shader.SHADE_spanLength
	mov	eax, zAccum
	mov	esi, [esi].CTX_polygon.POLY_shader.SHADE_zbuf
if DITHER
	xor	ebx, ebx
endif


;; start of z-buffer/color-interpolation loop

	;;ztest-pass case

align 4
@ztest_pass:
XNAME <ztest_begin::>
	cmp	eax, [esi]
XNAME <ztest_pass::>
	jae	near ptr @ztest_fail_cont
@ztest_pass_cont:
XNAME <zwrite::>
	mov	[esi],eax
	add	eax, zDelta
	add	esi, __GLzValueSize	
XNAME <ztest_end::>

if DITHER
XNAME <and_dither::>
	and	ebx, 7h
	lea	edx, ditherVals
XNAME <get_dither::>
	mov	dx, [edx + ebx]
endif

XNAME <write_pix::>
	mov	[edi], dx
XNAME <dest_inc1::>
if DITHER
	add	ebx, 2
endif
	add	edi, 2
	dec	ecx
XNAME <ztest_jmp::>
	jg	near ptr @ztest_pass
	jmp	short @fastSpanDone

	;;ztest-fail case
	;; not much to do here except advance adresses, dither
align 4
@ztest_fail:
	cmp	eax, [esi]
XNAME <ztest_fail::>
	jb	near ptr @ztest_pass_cont
@ztest_fail_cont:
	add	eax, zDelta
	add	esi, __GLzValueSize	
XNAME <dest_inc2::>
if DITHER
	add	ebx, 2
endif
	add	edi, 2
	dec	ecx
	jg	short @ztest_fail

@fastSpanDone:
	ret

PROCNAME <FlatSpan  ENDP>

XNAME <end::>



;----------------------------------------------------------------------
; __fastxxxFlatSpanSetup(GLCONTEXT *)
;
; Copy the span routine from the template and modify it to reflect
; the current state.
;----------------------------------------------------------------------


PROCNAME <FlatSpanSetup PROC	uses ebx edx esi edi, GLCONTEXT: ptr>
	LOCAL funcAddr: dword

	COPYPROC

	mov	esi, GLCONTEXT
	mov	edx, [esi].CTX_drawBuffer

	; ecx = bytes/pixel

	xor	ecx, ecx
	mov	cl, [esi].GENCTX_CurrentFormat.PFD_cColorBits
	add	cl, 7
	shr	cl, 3

	; ebx is index for byte-per-pixel modifications

	mov	ebx, ecx
	and	ebx, 0eh
	shl	ebx, 1

;; bytes/pixel adjustment (shifts)

	mov	al, [esi].GENCTX_CurrentFormat.PFD_cColorBits
	add	al, 7
	shr	al, 4
	XOFS	bpp
	mov	[edi]+2, al


if RGBMODE ;>>>>>>>>>>>>>>>> RGB case

	;; blue max and shift

ifdef CLAMPCOLOR
if DITHER
	mov	al, [edx].CBUF_blueMax
	XOFS	bmax
	mov	[edi]+1, al
endif
endif
	mov	al, [edx].CBUF_iBlueShift
	XOFS	bshift
	mov	[edi]+2, al
	

	;; green max and shift

ifdef CLAMPCOLOR
if DITHER
	mov	al, [edx].CBUF_greenMax
	XOFS	gmax
	mov	[edi]+1, al
endif
endif
	mov	al, [edx].CBUF_iGreenShift
	XOFS	gshift
	mov	[edi]+2, al
	

	;; red max and shift

ifdef CLAMPCOLOR
if DITHER
	mov	al, [edx].CBUF_redMax
	XOFS	rmax
	mov	[edi]+1, al
endif
endif
	mov	al, [edx].CBUF_iRedShift
	XOFS	rshift
	mov	[edi]+2, al
	
	;; paletted-device color-translation

	cmp	byte ptr [esi].GENCTX_CurrentFormat.PFD_cColorBits, 8
	je	@doTranslate

	XOFS	xlat
	mov	byte ptr [edi], NOP_CODE

@doTranslate:

else ;>>>>>>>>>>>>>>>> color-index case

				; no offset or address-shift needed
	cmp	byte ptr [esi].GENCTX_CurrentFormat.PFD_cColorBits, 8
	jg	@longXlat		; for 8-bit CI mode
	XOFS	cixlat_ofs
	mov	byte ptr [edi]+2, 0
	XOFS	cixlat_shift
	mov	byte ptr [edi]+2, 0
@longXlat:

endif ;>>>>>>>>>>>>>>>> end RGB cases


if DITHER
	;; dither-write

	mov	ax, word ptr write_dither_ops[ebx]
	XOFS	write_dither1
	mov	[edi], ax
	mov	al, byte ptr write_dither_ops[ebx+2]
	mov	[edi]+2, al

	; account for pixel size

	XOFS	write_dither2
	mov	[edi]+2, cl

endif

	;; pixel-write

	mov	ax, word ptr write_fpix_ops[ebx]
	XOFS	write_pix
	mov	[edi], ax
	mov	al, byte ptr write_fpix_ops[ebx+2]
	mov	[edi]+2, al

if DITHER
	;; dither-value fetch

	mov	eax, dword ptr read_dither_ops[ebx]
	XOFS	get_dither
	mov	[edi], eax
endif

	;; z-test conditions

	mov	eax, [esi].CTX_state.ATTR_depth.DEPTH_testFunc
	and	eax, 3
	mov	ebx, eax
	shl	ebx, 2
	shl	eax, 1
	add	ebx, eax	; 6 bytes/jump

	;; z-test pass condition
	
	mov	ax, word ptr ztest_pass_functions[ebx]
	XOFS	ztest_pass
	mov	[edi], ax

	;; z-test fail condition

	mov	ax, word ptr ztest_fail_functions[ebx]
	XOFS	ztest_fail
	mov	[edi], ax


	;; z write-enable

	test  	dword ptr [esi].CTX_state.ATTR_depth.DEPTH_writeEnable, 1
	jne	@zwriteEnabled

	XOFS	zwrite
	mov	byte ptr [edi], NOP_CODE
	mov	byte ptr [edi]+1, NOP_CODE

@zwriteEnabled:

	;; destination-offset increment

	XOFS	dest_inc1
	mov	[edi]+2, cl
if DITHER
	mov	[edi]+5, cl
endif
	XOFS	dest_inc2
	mov	[edi]+2, cl
if DITHER
	mov	[edi]+5, cl

	shl	cl, 2		; 4 dither entries used
	dec	cl
	XOFS	and_dither
	mov	[edi]+2, cl
endif	

	;; z-buffer enable

	test	dword ptr [esi].CTX_polygon.POLY_shader.SHADE_modeFlags,__GL_SHADE_DEPTH_TEST
	jne	@depthTestEnabled

	XOFS	ztest_end
	mov	eax, edi
	XOFS	ztest_begin
	sub	eax, edi	
	mov	ebx, eax

	;if z-buffer is not enabled so jump around initial z test...

	XOFS	ztest_begin
	mov	[edi], JMP_CODE
	sub	bl, 2		;account for instruction encoding
	add	[edi]+1, bl

	;and continue to loop "under" z test

	XOFS	ztest_jmp
	add	[edi]+2, eax
@depthTestEnabled:
	ret




;; Enumerate the needed read/write operations for the various pixel
;; sizes.  The byte and dword versions have an extra NOP since the
;; 16-bit operation takes 3 bytes due to the 066h prefix.  Alternatively,
;; we could get around this by fixing up the addresses.  The other NOP
;; pads is not embedded in code; it simply keeps things dword-aligned


align 4
write_fpix_ops:		
write_fpix_byte:		
	mov	[edi], dl
	nop
	nop
write_fpix_word:	
	mov	[edi], dx
	nop
write_fpix_dword:	
	mov	[edi], edx
	nop
	nop


align 4
write_dither_ops:		
write_dither_byte:		
	mov	[esi], al
	nop
	nop
write_dither_word:	
	mov	[esi], ax
	nop
write_dither_dword:	
	mov	[esi], eax
	nop
	nop


align 4
read_dither_ops:			
read_dither_byte:			
	mov	dl, [edx+ebx]
	nop
read_dither_word:	
	mov	dx, [edx+ebx]
read_dither_dword:	
	mov	edx, [edx+ebx]
	nop


PROCNAME <FlatSpanSetup ENDP>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\i386\span.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: span.asm
;
; Created: 2/3/94
; Author:  Otto Berkes [ottob]
;
; Get serious about drawing scanlines.
;
; Copyright (c) 1994 Microsoft Corporation
;----------------------------------------------------------------------;


.386

.model  small,c

assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
assume fs:nothing,gs:nothing

.xlist
include gli386.inc
.list


.data

NOP_CODE = 090h		;nop
JMP_CODE = 0EBh		;short jump

;; 4x4 (Bayer) dither matrix (Foley & van Dam 13.15) biased for
;; fractional values between 0 and 0ffh

Dither_4x4	dd	0008020a0h
 	   	dd	0c040e060h
	   	dd	030b01090h
	   	dd	0f070d050h

.code

;; Z-test function opcodes.  The assembled operands required for the
;; selected z-comparison are inserted into the loaded span routine 


ztest_fail_functions_short::
psZtest_never:
	db	2 dup (NOP_CODE)
psZtest_l:
	jb	short @target
psZtest_e:
	je	short @target
psZtest_le:
	jbe	short @target
psZtest_g:
	ja	short @target
psZtest_ne:
	jne	short @target
psZtest_ge:
	jae	short @target
psZtest_always:
	jmp	short $+2


ztest_pass_functions_short::
fsZtest_never:
	db	2 dup (NOP_CODE)
fsZtest_ge:
	jae	short @target
fsZtest_ne:
	jne	short @target
fsZtest_g:
	ja	short @target
fsZtest_le:
	jbe	short @target
fsZtest_e:
	je	short @target
fsZtest_l:
	jb	short @target
fsZtest_always:
	jmp	short $+2

@target:

ztest_fail_functions::
pZtest_never:
	db	6 dup (NOP_CODE)
pZtest_l:
	jb	near ptr @target
pZtest_e:
	je	near ptr @target
pZtest_le:
	jbe	near ptr @target
pZtest_g:
	ja	near ptr @target
pZtest_ne:
	jne	near ptr @target
pZtest_ge:
	jae	near ptr @target
pZtest_always:
	jmp	$+6


ztest_pass_functions::
fZtest_never:
	db	6 dup (NOP_CODE)
fZtest_ge:
	jae	near ptr @target
fZtest_ne:
	jne	near ptr @target
fZtest_g:
	ja	near ptr @target
fZtest_le:
	jbe	near ptr @target
fZtest_e:
	je	near ptr @target
fZtest_l:
	jb	near ptr @target
fZtest_always:
	jmp	$+6


;----------------------------------------------------------------------
; int __fastProcsSize
;
; Returns size needed for function/data storage.  This could be done as
; a global...
;----------------------------------------------------------------------

__fastProcsSize	PROC
	mov	eax, size __FASTFUNCSINTERNAL
	ret
__fastProcsSize	ENDP


;----------------------------------------------------------------------
; __fastDepthTestSpan
;
; Run the z interpolation for the supplied span.
;----------------------------------------------------------------------


zspan_begin::

__fastDepthTestSpan	PROC	uses ebx edx esi edi, GLCONTEXT: ptr
	LOCAL deltazx:	dword
	LOCAL scan_len: dword
	LOCAL scan_len_org: dword
	LOCAL mask_addr: dword

	mov	esi, GLCONTEXT

	mov	edi, [esi].CTX_polygon.POLY_shader.SHADE_zbuf	; edi points to z-buffer
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_spanLength
	mov	scan_len, eax
	mov	scan_len_org, eax
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_dzdx
	mov	deltazx, eax
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_stipplePat
	mov	mask_addr, eax
						; eax is initial z value
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_z
	xor	esi, esi			; esi maintains "fail" count

align 4
z_loop:
	mov	ecx, scan_len
	sub	scan_len, 32
	test	ecx, ecx
	jle	z_done

	cmp	ecx, 32
	jle	short small_zfrag
	mov	ecx, 32
small_zfrag:

;; alternative for above?	
;;	mov	eax, 32		; ecx = min(ecx-1, 31)
;;	cmp	eax, ecx
;;	sbb	ah, 0
;;	dec	ecx
;;	or	cl, ch
;;	and	ecx, 01fh

	mov	edx, 07fffffffh	; mask bit
	mov	ebx, -1		; initial mask value is all 1's
	
align 4
zrep_pass:			; case for test pass
	cmp	eax, [edi]
zspan_pass_op::
	jae	short zcmp_fail_r1
zspan_write::
zcmp_pass_r1:
	mov	[edi],eax
	add	eax, deltazx
	add	edi, __GlzValueSize	
	ror	edx, 1
	dec	ecx
	jg	short zrep_pass

	mov	ecx, mask_addr
	mov	[ecx], ebx
	add	ecx, 4
	mov	mask_addr, ecx
	jmp	short z_loop

align 4
zrep_fail:			; case for test fail
	cmp	eax, [edi]
zspan_fail_op::
	jb	short zcmp_pass_r1
zcmp_fail_r1:
	add	eax, deltazx
	and	ebx, edx
	inc	esi		; increment fail count
	add	edi, __GLzValueSize	
	ror	edx, 1
	dec	ecx
	jg	short zrep_fail

	mov	ecx, mask_addr
	mov	[ecx], ebx
	add	ecx, 4
	mov	mask_addr, ecx
	jmp	short z_loop

z_done:
	xor	eax, eax
	cmp	esi, 0
	jne	z_fails
	ret
z_fails:
	inc	eax
	xor	ebx, ebx
	cmp	esi, scan_len_org
	jne	z_fails_some
	mov	esi, GLCONTEXT
	mov	dword ptr [esi].CTX_polygon.POLY_shader.SHADE_done, 1
z_fails_some:
	ret

__fastDepthTestSpan	ENDP

zspan_end::


XOFS	MACRO	target
	mov	edi, funcAddr
	add	edi, offset target - offset zspan_begin
ENDM

;----------------------------------------------------------------------
; __fastDepthTestSpanSetup(GLCONTEXT *)
;
; Copy the span depth-test span routine from the template and modify it 
; to reflect the current z mode.
;----------------------------------------------------------------------


__fastDepthTestSpanSetup  PROC	uses ebx edx esi edi, GLCONTEXT: ptr
	LOCAL funcAddr: dword

	mov	edi, GLCONTEXT
	mov	edi, [edi].GENCTX_pPrivateArea
	add	edi, __spanZFunc
	mov	funcAddr, edi
	mov	esi, offset __fastDepthTestSpan
	mov	ecx, (zspan_end - zspan_begin + 3) / 4
	rep	movsd

	mov	esi, GLCONTEXT
	mov	edx, [esi].CTX_drawBuffer

	;; z-test conditions

	mov	ebx, [esi].CTX_state.ATTR_depth.DEPTH_testFunc
	and	ebx, 3
	add	ebx, ebx		; 2 bytes/short jump

	;; z-test pass condition
	
	mov	al, byte ptr ztest_pass_functions_short[ebx]
	XOFS	zspan_pass_op
	mov	[edi], al

	;; z-test fail condition

	mov	al, byte ptr ztest_fail_functions_short[ebx]
	XOFS	zspan_fail_op
	mov	[edi], al


	;; z write-enable

	test  	dword ptr [esi].CTX_state.ATTR_depth.DEPTH_writeEnable, 1
	jne	@zwriteEnabled

	XOFS	zspan_write
	mov	byte ptr [edi], NOP_CODE
	mov	byte ptr [edi]+1, NOP_CODE

        mov     eax, funcAddr
@zwriteEnabled:
	ret
__fastDepthTestSpanSetup ENDP


;----------------------------------------------------------------------
; __fastDeltaSpan(GLCONTEXT *)
;
; Set up the scan x delta values for subsequent spans.
;----------------------------------------------------------------------


__fastDeltaSpan	PROC	uses ebx esi edi, GLCONTEXT: ptr, SCANDELTA: ptr

	mov	esi, GLCONTEXT
	mov	ebx, [esi].CTX_polygon.POLY_shader.SHADE_modeFlags
	mov	edi, [esi].GENCTX_pPrivateArea
        mov     edi, [edi]
	mov	esi, SCANDELTA

	test	ebx, __GL_SHADE_RGB
        jne	@doRGB

	mov	eax, __spanFlatFunc
        test	ebx, __GL_SHADE_SMOOTH
	je	@flatI
	mov	ecx, [esi].SPANREC_r
	mov	[edi].FASTFUNCS_spanDelta.SPANREC_r, ecx
	cmp	ecx, 0
	je	@flatI
	mov	eax, __spanSmoothFunc
@flatI:
	mov	ecx, [esi].SPANREC_z
	mov	[edi].FASTFUNCS_spanDelta.SPANREC_z, ecx
	mov	esi, GLCONTEXT
	add	eax, [esi].GENCTX_pPrivateArea
	mov	[edi].FASTFUNCS_fastSpanFuncPtr, eax
	ret

@doRGB:
	mov	eax, __spanFlatFunc
        test	ebx, __GL_SHADE_SMOOTH
	je	@flatRGB
	mov	ecx, [esi].SPANREC_r
	mov	edx, ecx
	mov	[edi].FASTFUNCS_spanDelta.SPANREC_r, ecx
	mov	ecx, [esi].SPANREC_g
	or	edx, ecx
	mov	[edi].FASTFUNCS_spanDelta.SPANREC_g, ecx
	mov	ecx, [esi].SPANREC_b
	or	edx, ecx
	mov	[edi].FASTFUNCS_spanDelta.SPANREC_b, ecx
	je	@flatRGB
	mov	eax, offset __spanSmoothFunc
@flatRGB:
	mov	ecx, [esi].SPANREC_z
	mov	[edi].FASTFUNCS_spanDelta.SPANREC_z, ecx
	mov	esi, GLCONTEXT
	add	eax, [esi].GENCTX_pPrivateArea
	mov	[edi].FASTFUNCS_fastSpanFuncPtr, eax
	ret

__fastDeltaSpan ENDP


;======================================================================
; Smooth-shaded dithered RGB spans.
;======================================================================


PROCNAME	MACRO	name
	__fastRGB&name
ENDM

XNAME	MACRO	name
	pix_ssrgb_&name
ENDM

COPYPROC	MACRO
	mov	edi, GLCONTEXT
	mov	edi, [edi].GENCTX_pPrivateArea
	add	edi, __spanSmoothFunc
	mov	funcAddr, edi
	mov	esi, offset __fastRGBSmoothSpan
	mov	ecx, (pix_ssrgb_end - pix_ssrgb_begin + 3) / 4
	rep	movsd
ENDM

;;Macro to compute relative offset between a base and target

XOFS	MACRO	target
	mov	edi, funcAddr
	add	edi, offset pix_ssrgb_&target - offset pix_ssrgb_begin
;;	Note:  the assembler produces an error if we try to combine the
;;	above into a single operation due to "mismatched segments".  Arg!
ENDM

DITHER = 1
RGBMODE = 1

;=================
INCLUDE	span_s.asm
;=================


;======================================================================
; Flat-shaded dithered RGB spans.
;======================================================================


PROCNAME	MACRO	name
	__fastRGB&name
ENDM

XNAME	MACRO	name
	pix_fsrgb_&name
ENDM

COPYPROC	MACRO
	mov	edi, GLCONTEXT
	mov	edi, [edi].GENCTX_pPrivateArea
	add	edi, __spanFlatFunc
	mov	funcAddr, edi
	mov	esi, offset __fastRGBFlatSpan
	mov	ecx, (pix_fsrgb_end - pix_fsrgb_begin + 3) / 4
	rep	movsd
ENDM

;;Macro to compute relative offset between a base and target

XOFS	MACRO	target
	mov	edi, funcAddr
	add	edi, offset pix_fsrgb_&target - offset pix_fsrgb_begin
ENDM

DITHER = 1
RGBMODE = 1

;=================
INCLUDE	span_f.asm
;=================


;======================================================================
; Smooth-shaded dithered CI spans.
;======================================================================


PROCNAME	MACRO	name
	__fastCI&name
ENDM

XNAME	MACRO	name
	pix_ssci_&name
ENDM

COPYPROC	MACRO
	mov	edi, GLCONTEXT
	mov	edi, [edi].GENCTX_pPrivateArea
	add	edi, __spanSmoothFunc
	mov	funcAddr, edi
	mov	esi, offset __fastCISmoothSpan
	mov	ecx, (pix_ssci_end - pix_ssci_begin + 3) / 4
	rep	movsd
ENDM

;;Macro to compute relative offset between a base and target

XOFS	MACRO	target
	mov	edi, funcAddr	
	add	edi, offset pix_ssci_&target - offset pix_ssci_begin
ENDM

DITHER = 1
RGBMODE = 0

;=================
INCLUDE	span_s.asm
;=================


;======================================================================
; Flat-shaded dithered CI spans.
;======================================================================


PROCNAME	MACRO	name
	__fastCI&name
ENDM

XNAME	MACRO	name
	pix_fsci_&name
ENDM

COPYPROC	MACRO
	mov	edi, GLCONTEXT
	mov	edi, [edi].GENCTX_pPrivateArea
	add	edi, __spanFlatFunc
	mov	funcAddr, edi
	mov	esi, offset __fastCIFlatSpan
	mov	ecx, (pix_fsci_end - pix_fsci_begin + 3) / 4
	rep	movsd
ENDM

;;Macro to compute relative offset between a base and target

XOFS	MACRO	target
	mov	edi, funcAddr
	add	edi, offset pix_fsci_&target - offset pix_fsci_begin
ENDM

DITHER = 1
RGBMODE = 0

;=================
INCLUDE	span_f.asm
;=================


;======================================================================
;======================================================================
;
; Non-dithered routines
;
;======================================================================
;======================================================================


;======================================================================
; Smooth-shaded non-dithered RGB spans.
;======================================================================


PROCNAME	MACRO	name
	__fastRGBND&name
ENDM

XNAME	MACRO	name
	pix_ssrgbnd_&name
ENDM

COPYPROC	MACRO
	mov	edi, GLCONTEXT
	mov	edi, [edi].GENCTX_pPrivateArea
	add	edi, __spanSmoothFunc
	mov	funcAddr, edi
	mov	esi, offset __fastRGBNDSmoothSpan
	mov	ecx, (pix_ssrgbnd_end - pix_ssrgbnd_begin + 3) / 4
	rep	movsd
ENDM

;;Macro to compute relative offset between a base and target

XOFS	MACRO	target
	mov	edi, funcAddr
	add	edi, offset pix_ssrgbnd_&target - offset pix_ssrgbnd_begin
;;	Note:  the assembler produces an error if we try to combine the
;;	above into a single operation due to "mismatched segments".  Arg!
ENDM

DITHER = 0
RGBMODE = 1

;=================
INCLUDE	span_s.asm
;=================


;======================================================================
; Flat-shaded non-dithered RGB spans.
;======================================================================


PROCNAME	MACRO	name
	__fastRGBND&name
ENDM

XNAME	MACRO	name
	pix_fsrgbnd_&name
ENDM

COPYPROC	MACRO
	mov	edi, GLCONTEXT
	mov	edi, [edi].GENCTX_pPrivateArea
	add	edi, __spanFlatFunc
	mov	funcAddr, edi
	mov	esi, offset __fastRGBNDFlatSpan
	mov	ecx, (pix_fsrgbnd_end - pix_fsrgbnd_begin + 3) / 4
	rep	movsd
ENDM

;;Macro to compute relative offset between a base and target

XOFS	MACRO	target
	mov	edi, funcAddr
	add	edi, offset pix_fsrgbnd_&target - offset pix_fsrgbnd_begin
ENDM

DITHER = 0
RGBMODE = 1

;=================
INCLUDE	span_f.asm
;=================


;======================================================================
; Smooth-shaded non-dithered CI spans.
;======================================================================


PROCNAME	MACRO	name
	__fastCIND&name
ENDM

XNAME	MACRO	name
	pix_sscind_&name
ENDM

COPYPROC	MACRO
	mov	edi, GLCONTEXT
	mov	edi, [edi].GENCTX_pPrivateArea
	add	edi, __spanSmoothFunc
	mov	funcAddr, edi
	mov	esi, offset __fastCINDSmoothSpan
	mov	ecx, (pix_sscind_end - pix_sscind_begin + 3) / 4
	rep	movsd
ENDM

;;Macro to compute relative offset between a base and target

XOFS	MACRO	target
	mov	edi, funcAddr
	add	edi, offset pix_sscind_&target - offset pix_sscind_begin
ENDM

DITHER = 0
RGBMODE = 0

;=================
INCLUDE	span_s.asm
;=================


;======================================================================
; Flat-shaded non-dithered CI spans.
;======================================================================


PROCNAME	MACRO	name
	__fastCIND&name
ENDM

XNAME	MACRO	name
	pix_fscind_&name
ENDM

COPYPROC	MACRO
	mov	edi, GLCONTEXT
	mov	edi, [edi].GENCTX_pPrivateArea
	add	edi, __spanFlatFunc
	mov	funcAddr, edi
	mov	esi, offset __fastCINDFlatSpan
	mov	ecx, (pix_fscind_end - pix_fscind_begin + 3) / 4
	rep	movsd
ENDM

;;Macro to compute relative offset between a base and target

XOFS	MACRO	target
	mov	edi, funcAddr
	add	edi, offset pix_fscind_&target - offset pix_fscind_begin
ENDM

DITHER = 0
RGBMODE = 0

;=================
INCLUDE	span_f.asm
;=================


.data


__FASTFUNCSINTERNAL struct
	__funcsPtr		dd      ?
align 4
	__spanZFunc		db (zspan_end - zspan_begin + 3) dup (0)
align 4
	__spanSmoothFunc	db (pix_ssrgb_end - pix_ssrgb_begin + 3) dup (0)
align 4
	__spanFlatFunc		db (pix_fsrgb_end - pix_fsrgb_begin + 3) dup (0)
align	4
	__pad			dd	?
__FASTFUNCSINTERNAL ENDS

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\i386\span_s.asm ===
;----------------------------------------------------------------------
; Module name: span_s.asm
;
; Created: 2/3/94
; Author:  Otto Berkes [ottob]
;
; Draw fast smooth-shaded, z-buffered scanlines.
;----------------------------------------------------------------------


.code


;----------------------------------------------------------------------
; __fastxxxSmoothSpan
;
; Draw a smooth-shaded span.
;----------------------------------------------------------------------

XNAME <begin::>

PROCNAME <SmoothSpan  PROC	uses ebx edx esi edi, GLCONTEXT: ptr>
	LOCAL xlatAddr: dword
	LOCAL rAccum: dword
	LOCAL gAccum: dword
	LOCAL bAccum: dword
	LOCAL aAccum: dword
	LOCAL zAccum: dword
	LOCAL rDelta: dword
	LOCAL gDelta: dword
	LOCAL bDelta: dword
	LOCAL aDelta: dword
	LOCAL zDelta: dword

	; all this copying is needed for multi-threaded operation.  We could
	; optimize for color-index...

	mov	esi, GLCONTEXT
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_color.COLOR_r
	mov	rAccum, eax
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_color.COLOR_g
	mov	gAccum, eax
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_color.COLOR_b
	mov	bAccum, eax
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_color.COLOR_a
	mov	aAccum, eax
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_z
	mov	zAccum, eax

	mov	ebx, [esi].GENCTX_pPrivateArea
	mov	ebx, [ebx]
	mov	eax, [ebx].SPANREC_r
	mov	rDelta, eax
	mov	eax, [ebx].SPANREC_g
	mov	gDelta, eax
	mov	eax, [ebx].SPANREC_b
	mov	bDelta, eax
	mov	eax, [ebx].SPANREC_a
	mov	aDelta, eax
	mov	eax, [ebx].SPANREC_z
	mov	zDelta, eax


	mov	edi, [esi].GENCTX_ColorsBits
	mov	edx, [esi].CTX_polygon.POLY_shader.SHADE_cfb
	test	dword ptr [edx].BUF_other, DIB_FORMAT
	je	@no_dib
	mov	edi, [edx].BUF_base
	mov	eax, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_y
	sub	eax, [esi].CTX_constants.CTXCONST_viewportYAdjust
	add	eax, [edx].BUF_yOrigin
	mov	ebx, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_x
	sub	ebx, [esi].CTX_constants.CTXCONST_viewportXAdjust
	add	ebx, [edx].BUF_xOrigin
	mul	dword ptr [edx].BUF_outerWidth
XNAME <bpp::>
	shl	ebx, 2
	add	eax, ebx
	add	edi, eax
@no_dib:
	mov	eax, [esi].GENCTX_pajTranslateVector
if RGBMODE eq 0
XNAME <cixlat_ofs::>
	add	eax, GLintSize		; for color-index modes, the first
endif					; entry is the # of entries!
	mov	xlatAddr, eax
					; calculate dither values for span
if DITHER
	mov	edx, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_y
	and	edx, 03h
	shl	edx, 2
	mov	edx, Dither_4x4[edx]
	mov	ecx, [esi].CTX_polygon.POLY_shader.SHADE_frag.FRAG_x
	and	ecx, 03h
	shl	ecx, 3
	ror	edx, cl		;edx has x-aligned dither entries for span
endif
	mov	ecx, [esi].CTX_polygon.POLY_shader.SHADE_spanLength
	cmp	ecx, 0
	jle	@fastSpanDone
				;esi now points to z-buffer
	mov	esi, [esi].CTX_polygon.POLY_shader.SHADE_zbuf
if DITHER eq 0
	mov	edx, zAccum	
endif

if RGBMODE eq 0
	mov	ebx, rAccum	
endif


;; start of z-buffer/color-interpolation loop

	;;ztest-pass case

align 4
@ztest_pass:
XNAME <ztest_begin::>

if DITHER
	mov	eax, zAccum		; perform z test
	cmp	eax, [esi]
else
	cmp	edx, [esi]
endif

XNAME <ztest_pass::>				; check condition
	jae	near ptr @ztest_fail_cont

@ztest_pass_cont:				; test passed->write the z value
XNAME <zwrite::>
	mov	[esi],eax

if DITHER					; increment z interpolation
	add	eax, zDelta		; and address
	mov	zAccum, eax
else
	add	edx, zDelta
endif
	add	esi, __GLzValueSize	

XNAME <ztest_end::>


if RGBMODE ;>>>>>>>>>>>>>>>> RGBMODE RGB case

;; Red component (r bits)			; calculate color value for RGB

	mov	eax, rAccum
if DITHER
	shr	eax, 8
	add	al, dl
	adc	ah, 0
ifdef CLAMPCOLOR
XNAME <rmax::>
	mov	al, 011111b
	cmp	al, ah
	sbb	ah, 0
endif
	mov	al, ah
	xor	ah, ah
else
	shr	eax, 16
endif
XNAME <rshift::>
	shl	eax, 0
	mov	ebx, eax


;; Green component (g bits)

	mov	eax, gAccum
if DITHER
	shr	eax, 8
	add	al, dl
	adc	ah, 0
ifdef CLAMPCOLOR
XNAME <gmax::>
	mov	al, 0111111b
	cmp	al, ah
	sbb	ah, 0
endif
	mov	al, ah
	xor	ah, ah
else
	shr	eax, 16
endif
XNAME <gshift::>
	shl	eax, 5
	or	ebx, eax


;; Blue component (b bits)

	mov	eax, bAccum
if DITHER
	shr	eax, 8
	add	al, dl
	adc	ah, 0
ifdef CLAMPCOLOR
XNAME <bmax::>
	mov	al, 011111b
	cmp	al, ah
	sbb	ah, 0
endif
	mov	al, ah
	xor	ah, ah
else
	shr	eax, 16
endif
XNAME <bshift::>
	shl	eax, 11
	or	ebx, eax

	xchg	ebx, eax
	mov	ebx, xlatAddr		;translate to physical color
XNAME <xlat::>
	xlatb


else ;>>>>>>>>>>>>>>>> RGBMODE color-index case


;; Red component (r bits)		; calculate color value for indexed
					; mode
	mov	eax, ebx
if DITHER
	shr	eax, 8
	add	al, dl
	adc	ah, 0
	mov	al, ah
	xor	ah, ah
else
	shr	eax, 16
endif
XNAME <cixlat_shift::>
	shl	eax, 2			; 4 or 1 bytes/entry
	add	eax, xlatAddr
	mov	eax, [eax]

endif  ;<<<<<<<<<<<<<<<< end RGBMODE cases


XNAME <write_pix::>			; write the color value
	mov	[edi], ax
XNAME <dest_inc1::>
	add	edi, 2

if DITHER				; increment color values, dither
	ror	edx, 8
endif
if RGBMODE
	mov	ebx, rDelta
	add	rAccum, ebx
	mov	ebx, gDelta
	add	gAccum, ebx
	mov	ebx, bDelta
	add	bAccum, ebx
else
	add	ebx, rDelta
endif

	dec	ecx
XNAME <ztest_jmp::>
	jg	near ptr @ztest_pass
	jmp	short @fastSpanDone


	;;ztest-fail case
	;; not much to do here except advance interpolation values
align 4
@ztest_fail:
if DITHER
	cmp	eax, [esi]			; perform z test
else
	cmp	edx, [esi]
endif
XNAME <ztest_fail::>
	jb	near ptr @ztest_pass_cont	; check condition
@ztest_fail_cont:
if DITHER
	add	eax, zDelta		; increment z interpolator
else
	add	edx, zDelta
endif
	add	esi, __GLzValueSize
if RGBMODE
	mov	ebx, rDelta		; increment color interpolators
	add	rAccum, ebx
	mov	ebx, gDelta
	add	gAccum, ebx
	mov	ebx, bDelta
	add	bAccum, ebx
else
	add	ebx, rDelta
endif
XNAME <dest_inc2::>
	add	edi, 2
if DITHER
	ror	edx, 8
endif
	dec	ecx
	jg	short @ztest_fail

@fastSpanDone:
	ret

PROCNAME <SmoothSpan  ENDP>

XNAME <end::>



;----------------------------------------------------------------------
; __fastxxxSmoothSpanSetup(GLCONTEXT *)
;
; Copy the span routine from the template and modify it to reflect
; the current state.
;----------------------------------------------------------------------

 
PROCNAME <SmoothSpanSetup  PROC	uses ebx edx esi edi, GLCONTEXT: ptr>
	LOCAL funcAddr: dword

	COPYPROC

	mov	esi, GLCONTEXT
	mov	edx, [esi].CTX_drawBuffer

;; bytes/pixel adjustment (shifts)

	mov	al, [esi].GENCTX_CurrentFormat.PFD_cColorBits
	add	al, 7
	shr	al, 4
	XOFS	bpp
	mov	[edi]+2, al

;; z-test conditions

	mov	eax, [esi].CTX_state.ATTR_depth.DEPTH_testFunc
	and	eax, 3
	mov	ebx, eax
	shl	ebx, 2
	shl	eax, 1
	add	ebx, eax	; 6 bytes/jump

	;; z-test pass condition
	
	mov	ax, word ptr ztest_pass_functions[ebx]
	XOFS	ztest_pass
	mov	[edi], ax

	;; z-test fail condition

	mov	ax, word ptr ztest_fail_functions[ebx]
	XOFS	ztest_fail
	mov	[edi], ax


	;; z write-enable

	test  	dword ptr [esi].CTX_state.ATTR_depth.DEPTH_writeEnable, 1
	jne	@zwriteEnabled

	XOFS	zwrite
	mov	byte ptr [edi], NOP_CODE
	mov	byte ptr [edi]+1, NOP_CODE

@zwriteEnabled:

if RGBMODE

	;; blue max and shift

ifdef CLAMPCOLOR
if DITHER
	mov	al, [edx].CBUF_blueMax
	XOFS	bmax
	mov	[edi]+1, al
endif
endif
	mov	al, [edx].CBUF_iBlueShift
	XOFS	bshift
	mov	[edi]+2, al
	

	;; green max and shift

ifdef CLAMPCOLOR
if DITHER
	mov	al, [edx].CBUF_greenMax
	XOFS	gmax
	mov	[edi]+1, al
endif
endif
	mov	al, [edx].CBUF_iGreenShift
	XOFS	gshift
	mov	[edi]+2, al
	

	;; red max and shift

ifdef CLAMPCOLOR
if DITHER
	mov	al, [edx].CBUF_redMax
	XOFS	rmax
	mov	[edi]+1, al
endif
endif
	mov	al, [edx].CBUF_iRedShift
	XOFS	rshift
	mov	[edi]+2, al

	
	;; color-translation

	cmp	byte ptr [esi].GENCTX_CurrentFormat.PFD_cColorBits, 8
	je	@doTranslate

	XOFS	xlat
	mov	byte ptr [edi], NOP_CODE

@doTranslate:
else ;>>>>>>>>>>>>>>>> color-index case
			; no offset or address-shift needed for 8-bit color
	cmp	byte ptr [esi].GENCTX_CurrentFormat.PFD_cColorBits, 8
	jg	@longXlat		; for 8-bit CI mode
	XOFS	cixlat_ofs
	mov	byte ptr [edi]+2, 0
	XOFS	cixlat_shift
	mov	byte ptr [edi]+2, 0
@longXlat:
endif ;>>>>>>>>>>>>>>>> end RGB cases

	;; pixel-write

	xor	ebx, ebx
	mov	bl, [esi].GENCTX_CurrentFormat.PFD_cColorBits
	add	bl, 7
	shr	bl, 3
	mov	ecx, ebx
	and	ebx, 0eh
	shl	ebx, 1
	mov	ax, word ptr write_pixel_ops[ebx]
	XOFS	write_pix
	mov	[edi], ax
	mov	al, byte ptr write_pixel_ops[ebx+2]
	mov	[edi]+2, al

	;; destination-offset increment

	XOFS	dest_inc1
	mov	[edi]+2, cl
	XOFS	dest_inc2
	mov	[edi]+2, cl

	;; z-buffer enable

	test	dword ptr [esi].CTX_polygon.POLY_shader.SHADE_modeFlags,__GL_SHADE_DEPTH_TEST
	jne	@depthTestEnabled

	XOFS	ztest_end
	mov	eax, edi
	XOFS	ztest_begin
	sub	eax, edi	
	mov	ebx, eax

	;if z-buffer is not enabled so jump around initial z test...

	XOFS	ztest_begin
	mov	[edi], JMP_CODE
	sub	bl, 2		;account for instruction encoding
	add	[edi]+1, bl

	;and continue to loop "under" z test

	XOFS	ztest_jmp
	add	[edi]+2, eax
@depthTestEnabled:
	ret

align 4
write_pixel_ops:		
write_pix_byte:			
	mov	[edi], al
	nop
	nop
write_pix_word:	
	mov	[edi], ax
	nop
write_pix_dword:	
	mov	[edi], eax
	nop
	nop

PROCNAME <SmoothSpanSetup  ENDP>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\i386\texspans.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: texspans.asm
;
; Generator file for texture routines. 
;
; Created: 011/15/1995
; Author: Otto Berkes [ottob]
;
; Copyright (c) 1995 Microsoft Corporation
;----------------------------------------------------------------------;

        .386

        .model  small,pascal

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include gli386.inc
        .list

	PROFILE = 0
	include profile.inc

	.data

extrn	_gbMulTable:BYTE

__One	dd	__FLOAT_ONE

dither0 dd 	0a8288808h
dither1 dd	068e848c8h
dither2	dd	09818b838h
dither3	dd	058d878f8h

rBits 		= 3
gBits 		= 3
bBits 		= 2

rShift		= 0
gShift		= 3
bShift		= 6


FAST_REPLACE = 0
REPLACE = 0
FLAT_SHADING = 0
SMOOTH_SHADING = 0

ALPHA = 0
ZBUFFER = 0
ZCMP_L = 0

.code

PROCSTART	MACRO	base, subset
	public @&base&subset&@4
@&base&subset&@4 PROC
	PROF_ENTRY
ENDM

PROCEND	MACRO	base, subset
@&base&subset&@4 ENDP
ENDM

PALETTE_ENABLED = 0
PALETTE_ONLY = 0


;;----------------------------------------------------------------------
;;
;; FAST REPLACE MODES
;;
;;----------------------------------------------------------------------


FAST_REPLACE = 1

;;------------------------------
;; 8bpp 332 texture fast-replace
;;------------------------------


BPP = 8
rBits 		= 3
gBits 		= 3
bBits 		= 2
rShift		= 0
gShift		= 3
bShift		= 6

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastFastPerspReplace>,<332>
INCLUDE texspanr.asm
PROCEND   <__fastFastPerspReplace>,<332>

ZBUFFER = 1

PROCSTART <__fastFastPerspReplaceZle>,<332>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspReplaceZle>,<332>

ZCMP_L = 1

PROCSTART <__fastFastPerspReplaceZlt>,<332>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspReplaceZlt>,<332>

;;-------------------------------
;; 16bpp 565 texture fast-replace
;;-------------------------------


BPP = 16
rBits 		= 5
gBits 		= 6
bBits 		= 5
rShift		= 11
gShift		= 5
bShift		= 0


ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastFastPerspReplace>,<565>
INCLUDE texspanr.asm
PROCEND   <__fastFastPerspReplace>,<565>

ZBUFFER = 1

PROCSTART <__fastFastPerspReplaceZle>,<565>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspReplaceZle>,<565>

ZCMP_L = 1

PROCSTART <__fastFastPerspReplaceZlt>,<565>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspReplaceZlt>,<565>

FAST_REPLACE = 0


;;----------------------------------------------------------------------
;;
;; REPLACE MODES - RGB(A)
;;
;;----------------------------------------------------------------------


REPLACE = 1

;;----------------------------
;; 8bpp 332 texture replace
;;----------------------------


BPP = 8
rBits 		= 3
gBits 		= 3
bBits 		= 2
rShift		= 0
gShift		= 3
bShift		= 6

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastPerspReplaceAlpha>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceAlpha>,<332>

ZBUFFER = 1

PROCSTART <__fastPerspReplaceAlphaZle>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceAlphaZle>,<332>

ZCMP_L = 1

PROCSTART <__fastPerspReplaceAlphaZlt>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceAlphaZlt>,<332>

;;----------------------------
;; 16bpp 555 texture replace
;;----------------------------

BPP = 16
rBits 		= 5
gBits 		= 5
bBits 		= 5
rShift		= 10
gShift		= 5
bShift		= 0


ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastPerspReplaceAlpha>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceAlpha>,<555>

ZBUFFER = 1

PROCSTART <__fastPerspReplaceAlphaZle>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceAlphaZle>,<555>

ZCMP_L = 1

PROCSTART <__fastPerspReplaceAlphaZlt>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceAlphaZlt>,<555>


;;----------------------------
;; 16bpp 565 texture replace
;;----------------------------


BPP = 16
rBits 		= 5
gBits 		= 6
bBits 		= 5
rShift		= 11
gShift		= 5
bShift		= 0


ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastPerspReplaceAlpha>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceAlpha>,<565>

ZBUFFER = 1

PROCSTART <__fastPerspReplaceAlphaZle>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceAlphaZle>,<565>

ZCMP_L = 1

PROCSTART <__fastPerspReplaceAlphaZlt>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceAlphaZlt>,<565>


;;----------------------------
;; 32bpp 888 texture replace
;;----------------------------


BPP = 32
rBits 		= 8
gBits 		= 8
bBits 		= 8
rShift		= 16
gShift		= 8
bShift		= 0


ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastPerspReplace>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplace>,<888>

ZBUFFER = 1

PROCSTART <__fastPerspReplaceZle>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceZle>,<888>

ZCMP_L = 1

PROCSTART <__fastPerspReplaceZlt>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceZlt>,<888>

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastPerspReplaceAlpha>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceAlpha>,<888>

ZBUFFER = 1

PROCSTART <__fastPerspReplaceAlphaZle>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceAlphaZle>,<888>

ZCMP_L = 1

PROCSTART <__fastPerspReplaceAlphaZlt>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspReplaceAlphaZlt>,<888>

;;----------------------------------------------------------------------
;;
;; REPLACE MODES - PALETTE
;;
;;----------------------------------------------------------------------

PALETTE_ONLY = 1
FAST_REPLACE = 1

;;----------------------------------
;; 8bpp 332 texture replace, palette
;;----------------------------------


BPP = 8
rBits 		= 3
gBits 		= 3
bBits 		= 2
rShift		= 0
gShift		= 3
bShift		= 6

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastFastPerspPalReplace>,<332>
INCLUDE texspanr.asm
PROCEND   <__fastFastPerspPalReplace>,<332>

ZBUFFER = 1

PROCSTART <__fastFastPerspPalReplaceZle>,<332>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspPalReplaceZle>,<332>

ZCMP_L = 1

PROCSTART <__fastFastPerspPalReplaceZlt>,<332>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspPalReplaceZlt>,<332>

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastFastPerspPalReplaceAlpha>,<332>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspPalReplaceAlpha>,<332>

ZBUFFER = 1

PROCSTART <__fastFastPerspPalReplaceAlphaZle>,<332>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspPalReplaceAlphaZle>,<332>

ZCMP_L = 1

PROCSTART <__fastFastPerspPalReplaceAlphaZlt>,<332>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspPalReplaceAlphaZlt>,<332>

;;-----------------------------------
;; 16bpp 555 texture replace, palette
;;-----------------------------------

BPP = 16
rBits 		= 5
gBits 		= 5
bBits 		= 5
rShift		= 10
gShift		= 5
bShift		= 0


ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastFastPerspPalReplaceAlpha>,<555>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspPalReplaceAlpha>,<555>

ZBUFFER = 1

PROCSTART <__fastFastPerspPalReplaceAlphaZle>,<555>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspPalReplaceAlphaZle>,<555>

ZCMP_L = 1

PROCSTART <__fastFastPerspPalReplaceAlphaZlt>,<555>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspPalReplaceAlphaZlt>,<555>


;;-----------------------------------
;; 16bpp 565 texture replace, palette
;;-----------------------------------


BPP = 16
rBits 		= 5
gBits 		= 6
bBits 		= 5
rShift		= 11
gShift		= 5
bShift		= 0


ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastFastPerspPalReplace>,<565>
INCLUDE texspanr.asm
PROCEND   <__fastFastPerspPalReplace>,<565>

ZBUFFER = 1

PROCSTART <__fastFastPerspPalReplaceZle>,<565>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspPalReplaceZle>,<565>

ZCMP_L = 1

PROCSTART <__fastFastPerspPalReplaceZlt>,<565>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspPalReplaceZlt>,<565>

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastFastPerspPalReplaceAlpha>,<565>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspPalReplaceAlpha>,<565>

ZBUFFER = 1

PROCSTART <__fastFastPerspPalReplaceAlphaZle>,<565>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspPalReplaceAlphaZle>,<565>

ZCMP_L = 1

PROCSTART <__fastFastPerspPalReplaceAlphaZlt>,<565>
INCLUDE texspan.asm
PROCEND   <__fastFastPerspPalReplaceAlphaZlt>,<565>

FAST_REPLACE = 0

;;-----------------------------------
;; 32bpp 888 texture replace, palette
;;-----------------------------------


BPP = 32
rBits 		= 8
gBits 		= 8
bBits 		= 8
rShift		= 16
gShift		= 8
bShift		= 0


ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastPerspPalReplace>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspPalReplace>,<888>

ZBUFFER = 1

PROCSTART <__fastPerspPalReplaceZle>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspPalReplaceZle>,<888>

ZCMP_L = 1

PROCSTART <__fastPerspPalReplaceZlt>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspPalReplaceZlt>,<888>

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastPerspPalReplaceAlpha>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspPalReplaceAlpha>,<888>

ZBUFFER = 1

PROCSTART <__fastPerspPalReplaceAlphaZle>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspPalReplaceAlphaZle>,<888>

ZCMP_L = 1

PROCSTART <__fastPerspPalReplaceAlphaZlt>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspPalReplaceAlphaZlt>,<888>

PALETTE_ONLY = 0

REPLACE = 0


;; For all of the modes below, enable the palette path:


PALETTE_ENABLED = 1


;;----------------------------------------------------------------------
;;
;; FLAT-SHADING MODES
;;
;;----------------------------------------------------------------------


FLAT_SHADING = 1

;;------------------------------
;; 8bpp 332 texture flat-shading
;;------------------------------


BPP = 8
rBits 		= 3
gBits 		= 3
bBits 		= 2
rShift		= 0
gShift		= 3
bShift		= 6

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastPerspFlat>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlat>,<332>

ZBUFFER = 1

PROCSTART <__fastPerspFlatZle>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatZle>,<332>

ZCMP_L = 1

PROCSTART <__fastPerspFlatZlt>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatZlt>,<332>

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastPerspFlatAlpha>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatAlpha>,<332>

ZBUFFER = 1

PROCSTART <__fastPerspFlatAlphaZle>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatAlphaZle>,<332>

ZCMP_L = 1

PROCSTART <__fastPerspFlatAlphaZlt>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatAlphaZlt>,<332>

;;-------------------------------
;; 16bpp 555 texture flat-shading
;;-------------------------------

BPP = 16
rBits 		= 5
gBits 		= 5
bBits 		= 5
rShift		= 10
gShift		= 5
bShift		= 0


ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastPerspFlat>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlat>,<555>

ZBUFFER = 1

PROCSTART <__fastPerspFlatZle>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatZle>,<555>

ZCMP_L = 1

PROCSTART <__fastPerspFlatZlt>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatZlt>,<555>

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastPerspFlatAlpha>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatAlpha>,<555>

ZBUFFER = 1

PROCSTART <__fastPerspFlatAlphaZle>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatAlphaZle>,<555>

ZCMP_L = 1

PROCSTART <__fastPerspFlatAlphaZlt>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatAlphaZlt>,<555>


;;-------------------------------
;; 16bpp 565 texture flat-shading
;;-------------------------------


BPP = 16
rBits 		= 5
gBits 		= 6
bBits 		= 5
rShift		= 11
gShift		= 5
bShift		= 0


ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastPerspFlat>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlat>,<565>

ZBUFFER = 1

PROCSTART <__fastPerspFlatZle>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatZle>,<565>

ZCMP_L = 1

PROCSTART <__fastPerspFlatZlt>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatZlt>,<565>

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastPerspFlatAlpha>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatAlpha>,<565>

ZBUFFER = 1

PROCSTART <__fastPerspFlatAlphaZle>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatAlphaZle>,<565>

ZCMP_L = 1

PROCSTART <__fastPerspFlatAlphaZlt>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatAlphaZlt>,<565>


;;-------------------------------
;; 32bpp 888 texture flat-shading
;;-------------------------------


BPP = 32
rBits 		= 8
gBits 		= 8
bBits 		= 8
rShift		= 16
gShift		= 8
bShift		= 0


ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastPerspFlat>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlat>,<888>

ZBUFFER = 1

PROCSTART <__fastPerspFlatZle>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatZle>,<888>

ZCMP_L = 1

PROCSTART <__fastPerspFlatZlt>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatZlt>,<888>

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastPerspFlatAlpha>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatAlpha>,<888>

ZBUFFER = 1

PROCSTART <__fastPerspFlatAlphaZle>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatAlphaZle>,<888>

ZCMP_L = 1

PROCSTART <__fastPerspFlatAlphaZlt>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspFlatAlphaZlt>,<888>

FLAT_SHADING = 0






;;----------------------------------------------------------------------
;;
;; SMOOTH-SHADING MODES
;;
;;----------------------------------------------------------------------


SMOOTH_SHADING = 1

;;--------------------------------
;; 8bpp 332 texture smooth-shading
;;--------------------------------


BPP = 8
rBits 		= 3
gBits 		= 3
bBits 		= 2
rShift		= 0
gShift		= 3
bShift		= 6

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastPerspSmooth>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmooth>,<332>

ZBUFFER = 1

PROCSTART <__fastPerspSmoothZle>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothZle>,<332>

ZCMP_L = 1

PROCSTART <__fastPerspSmoothZlt>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothZlt>,<332>

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastPerspSmoothAlpha>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothAlpha>,<332>

ZBUFFER = 1

PROCSTART <__fastPerspSmoothAlphaZle>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothAlphaZle>,<332>

ZCMP_L = 1

PROCSTART <__fastPerspSmoothAlphaZlt>,<332>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothAlphaZlt>,<332>

;;---------------------------------
;; 16bpp 555 texture smooth-shading
;;---------------------------------

BPP = 16
rBits 		= 5
gBits 		= 5
bBits 		= 5
rShift		= 10
gShift		= 5
bShift		= 0


ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastPerspSmooth>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmooth>,<555>

ZBUFFER = 1

PROCSTART <__fastPerspSmoothZle>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothZle>,<555>

ZCMP_L = 1

PROCSTART <__fastPerspSmoothZlt>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothZlt>,<555>

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastPerspSmoothAlpha>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothAlpha>,<555>

ZBUFFER = 1

PROCSTART <__fastPerspSmoothAlphaZle>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothAlphaZle>,<555>

ZCMP_L = 1

PROCSTART <__fastPerspSmoothAlphaZlt>,<555>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothAlphaZlt>,<555>


;;---------------------------------
;; 16bpp 565 texture smooth-shading
;;---------------------------------


BPP = 16
rBits 		= 5
gBits 		= 6
bBits 		= 5
rShift		= 11
gShift		= 5
bShift		= 0


ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastPerspSmooth>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmooth>,<565>

ZBUFFER = 1

PROCSTART <__fastPerspSmoothZle>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothZle>,<565>

ZCMP_L = 1

PROCSTART <__fastPerspSmoothZlt>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothZlt>,<565>

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastPerspSmoothAlpha>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothAlpha>,<565>

ZBUFFER = 1

PROCSTART <__fastPerspSmoothAlphaZle>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothAlphaZle>,<565>

ZCMP_L = 1

PROCSTART <__fastPerspSmoothAlphaZlt>,<565>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothAlphaZlt>,<565>


;;---------------------------------
;; 32bpp 888 texture smooth-shading
;;---------------------------------


BPP = 32
rBits 		= 8
gBits 		= 8
bBits 		= 8
rShift		= 16
gShift		= 8
bShift		= 0


ZBUFFER = 0
ZCMP_L = 0
ALPHA = 0

PROCSTART <__fastPerspSmooth>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmooth>,<888>

ZBUFFER = 1

PROCSTART <__fastPerspSmoothZle>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothZle>,<888>

ZCMP_L = 1

PROCSTART <__fastPerspSmoothZlt>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothZlt>,<888>

ZBUFFER = 0
ZCMP_L = 0
ALPHA = 1

PROCSTART <__fastPerspSmoothAlpha>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothAlpha>,<888>

ZBUFFER = 1

PROCSTART <__fastPerspSmoothAlphaZle>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothAlphaZle>,<888>

ZCMP_L = 1

PROCSTART <__fastPerspSmoothAlphaZlt>,<888>
INCLUDE texspan.asm
PROCEND   <__fastPerspSmoothAlphaZlt>,<888>

FLAT_SHADING = 0


end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\i386\xform.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: xform.asm
;
; xform routines.
;
; Created: 09/28/1995
; Author: Hock San Lee [hockl]
;
; Copyright (c) 1995 Microsoft Corporation
;----------------------------------------------------------------------;
        .386

        .model  small,pascal

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .xlist
        include gli386.inc
        .list

	PROFILE = 0
	include profile.inc
	
	.data

extrn _invSqrtTable: DWORD


;; This debug equate will enable printf-type tracking of the transform calls--
;; quite handy for conformance-type failures.  '2' will always print, '1' will
;; only print the first time...

;;DEBUG EQU	2

ifdef DEBUG

str1	db	'xform1  ',0
str2	db	'xform2  ',0
str3	db	'xform3  ',0
str4	db	'xform4  ',0
str5	db	'xform5  ',0
str6	db	'xform6  ',0
str7	db	'xform7  ',0
str8	db	'xform8  ',0
str9	db	'xform9  ',0
str10	db	'xform10 ',0
str11	db	'xform11 ',0
str12	db	'xform12 ',0
str13	db	'xform13 ',0
str14	db	'xform14 ',0
str15	db	'xform15 ',0

endif
        .code

ifdef DEBUG

if DEBUG eq 1

DBGPRINTID MACRO idNum

	push	ecx
	push	edx
	mov	edx, offset idNum
	cmp	byte ptr [edx][0], 0
	je	@@1
	push	offset idNum
	call	DWORD PTR __imp__OutputDebugStringA@4
	mov	edx, offset idNum
	mov	byte ptr [edx][0], 0
	@@1:
	pop	edx
	pop	ecx

	ENDM

elseif DEBUG eq 2

DBGPRINTID MACRO idNum

	push	ecx
	push	edx
	push	offset idNum
	call	DWORD PTR __imp__OutputDebugStringA@4
	pop	edx
	pop	ecx

	ENDM

endif

else

DBGPRINTID MACRO idNum
	ENDM

endif

        align   4

EXTRN	__imp__OutputDebugStringA@4:NEAR
;
; Note: These xform routines must allow for the case where the result
; vector is equal to the source vector.
;

; The basic assumptions below are that multiplies and adds have a 3-cycle
; latency that can be hidden using pipelining, fxch is free when paired with
; fadd and fmul, and that the latency for fld is always 1.
;
; The goal is to have each line below consume either 1 or 0 cycles (fxch).
; There's not much we can do at the end of the routine, since we have no
; choice but to wait for the last couple of intructions to get through the
; pipeline.
;
;
; The comments show the age and position of the elements in the pipeline
; (when relevant). Items with higher numbers are newer (in the pipeline)
; than items with lower numbers.  The entries are ordered from stack
; positions 0-7, left to right.
;
; Note that computetions for the terms are intermixed to allow eliminate
; latency where possible.  Unfortunately, this makes the code hard to
; follow.  That's probably why the compiler won't generate code like
; this...
;
;							--- Otto ---
;

_X_	EQU	0
_Y_	EQU	4
_Z_	EQU	8
_W_	EQU	12	


;------------------------------Public-Routine------------------------------
;
; Avoid some transformation computations by knowing that the incoming
; vertex has w=1.
;
; res->x = x*m->matrix[0][0] + y*m->matrix[1][0] + z*m->matrix[2][0] 
;	   + m->matrix[3][0];
; res->y = x*m->matrix[0][1] + y*m->matrix[1][1] + z*m->matrix[2][1]
;          + m->matrix[3][1];
; res->z = x*m->matrix[0][2] + y*m->matrix[1][2] + z*m->matrix[2][2]
;          + m->matrix[3][2];
; res->w = x*m->matrix[0][3] + y*m->matrix[1][3] + z*m->matrix[2][3]
;          + m->matrix[3][3];
;
; History:
;  Thu 28-Sep-1995 -by- Otto Berkes [ottob]
; Wrote it.
;--------------------------------------------------------------------------

__GL_ASM_XFORM3 MACRO input, result

;EAX = m->matrix
;EDX = v[]

;---------------------------------------------------------------------------
; Start computation for x term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]			; x1
	fmul	DWORD PTR [eax][__MATRIX_M00]
	fld	DWORD PTR [input][_Y_]			; x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M10]
	fld	DWORD PTR [input][_Z_]			; x3 x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M20]
	fxch	ST(2)					; x1 x2 x3
	fadd	DWORD PTR [eax][__MATRIX_M30]		; x3 x1 x2

;---------------------------------------------------------------------------
; Start computation for y term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M01]		; y1 x  x  x
;
; OVERLAP -- compute second add for previous term
;
	fxch	ST(1)					; x  y1 x  x
	faddp	ST(2),ST(0)				; y1 x  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M11]		; y2 y1 x  x
;
; OVERLAP -- compute previous final term
;
	fxch	ST(2)					; x  y1 y2 x
	faddp	ST(3),ST(0)				; y1 y2 x
;
	fld	DWORD PTR [input][_Z_]
	fmul	DWORD PTR [eax][__MATRIX_M21]		; y3 y1 y2 x
	fxch	ST(1)					; y1 y3 y2 x
	fadd	DWORD PTR [eax][__MATRIX_M31]		; y3 y2 y1 x
;

;---------------------------------------------------------------------------
; Start computation for z term:
;---------------------------------------------------------------------------


	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M02]		; z1 y  y  y  x
;
; OVERLAP -- compute second add for previous result
;
	fxch	ST(1)					; y  z1 y  y  x
	faddp	ST(2),ST(0)				; z1 y  y  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M12]		; z2 z1 y  y  x
;
; OVERLAP -- compute previous final result
;
	fxch	ST(2)					; y  z1 z2 y  x
	faddp	ST(3),ST(0)				; z1 z2 y  x
; 
	fld	DWORD PTR [input][_Z_]			
	fmul	DWORD PTR [eax][__MATRIX_M22]		; z3 z1 z2 y  x
	fxch	ST(1)					; z1 z3 z2 y  x
	fadd	DWORD PTR [eax][__MATRIX_M32]		; z3 z1 z2 y  x
;


;---------------------------------------------------------------------------
; Start computation for w term:
;---------------------------------------------------------------------------


	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M03]		; w1 z  z  z  y  x
;
; OVERLAP -- compute second add for previous result
;
	fxch	ST(1)					; z  w1 z  z  y  x
	faddp	ST(2),ST(0)				; w1 z  z  y  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M13]		; w2 w1 z  z  y  x
;
; OVERLAP -- compute previous final result
;
	fxch	ST(2)					; z w1 w2 z  y   x
	faddp	ST(3),ST(0)				; w1 w2 z y  x
;
	fld	DWORD PTR [input][_Z_]			
	fmul	DWORD PTR [eax][__MATRIX_M23]		; w3 w1 w2 z  y  x
	fxch	ST(1)					; w1 w3 w2 z  y  x
	fadd	DWORD PTR [eax][__MATRIX_M33]		; w3 w2 w1 z  y  x
	fxch	ST(1)					; w2 w3 w1 z  y  x
	faddp	ST(2),ST(0)				; w1 w2 z  y  x
;
; OVERLAP -- store final x
;
	fxch	ST(4)					; x  w2 z  y  w1
	fstp	DWORD PTR [result][_X_]			; w2 z  y  w1
;
	faddp	ST(3),ST(0)				; z  y  w
;
; store final z, y, w
;
	fstp	DWORD PTR [result][_Z_]			; y  w
	fstp	DWORD PTR [result][_Y_]			; w
	fstp	DWORD PTR [result][_W_]			; (empty)

ENDM


;------------------------------Public-Routine------------------------------
;
; Full 4x4 transformation.
;
; if (w == ((__GLfloat) 1.0)) {
;     __glXForm3(res, v, m);
; } else {
;     res->x = x*m->matrix[0][0] + y*m->matrix[1][0] + z*m->matrix[2][0]
;               + w*m->matrix[3][0];
;     res->y = x*m->matrix[0][1] + y*m->matrix[1][1] + z*m->matrix[2][1]
;               + w*m->matrix[3][1];
;     res->z = x*m->matrix[0][2] + y*m->matrix[1][2] + z*m->matrix[2][2]
;               + w*m->matrix[3][2];
;     res->w = x*m->matrix[0][3] + y*m->matrix[1][3] + z*m->matrix[2][3]
;               + w*m->matrix[3][3];
; }
;
; History:
;  Thu 28-Sep-1995 -by- Otto Berkes [ottob]
; Wrote it.
;--------------------------------------------------------------------------

__GL_ASM_XFORM4 MACRO input, result

;EAX = m->matrix
;EDX = v[]

;---------------------------------------------------------------------------
; Start computation for x term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]			; x1
	fmul	DWORD PTR [eax][__MATRIX_M00]
	fld	DWORD PTR [input][_Y_]			; x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M10]
	fld	DWORD PTR [input][_Z_]			; x3 x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M20]
	fld	DWORD PTR [input][_W_]			; x4 x3 x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M30]

;---------------------------------------------------------------------------
; Start computation for y term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M01]		; y1 x  x  x  x
;
; OVERLAP -- compute first add for previous term
;
	fxch	ST(1)					; x  y1 x  x  x
	faddp	ST(2),ST(0)				; y1 x  x  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M11]		; y2 y1 x  x  x
;
; OVERLAP -- compute second add for previous term
;
	fxch	ST(2)					; x  y1 y2 x  x
	faddp	ST(3),ST(0)				; y1 y2 x  x
;
	fld	DWORD PTR [input][_Z_]
	fmul	DWORD PTR [eax][__MATRIX_M21]		; y3 y1 y2 x  x
;
; OVERLAP -- compute previous final term
;
	fxch	ST(3)					; x  y1 y2 y3 x
	faddp	ST(4),ST(0)				; y1 y2 y3 x
;
	fld	DWORD PTR [input][_W_]			; y4 y1 y2 y3 x
	fmul	DWORD PTR [eax][__MATRIX_M31]
;

;---------------------------------------------------------------------------
; Start computation for z term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M02]		; z1 y  y  y  y  x
;
; OVERLAP -- compute first add for previous term
;
	fxch	ST(1)					; y  z1 y  y  y  x
	faddp	ST(2),ST(0)				; z1 y  y  y  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M12]		; z2 z1 y  y  y  x
;
; OVERLAP -- compute second add for previous term
;
	fxch	ST(2)					; y  z1 z2 y  y  x
	faddp	ST(3),ST(0)				; z1 z2 y  y  x
;
	fld	DWORD PTR [input][_Z_]
	fmul	DWORD PTR [eax][__MATRIX_M22]		; z3 z1 z2 y  y  x
;
; OVERLAP -- compute previous final term
;
	fxch	ST(3)					; y  z1 z2 z3 y  x
	faddp	ST(4),ST(0)				; z1 z2 z3 y  x
;
	fld	DWORD PTR [input][_W_]			; z4 z1 z2 z3 y  x
	fmul	DWORD PTR [eax][__MATRIX_M32]

;---------------------------------------------------------------------------
; Start computation for w term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M03]		; w1 z  z  z  z  y  x
;
; OVERLAP -- compute first add for previous term
;
	fxch	ST(1)					; z  w1 z  z  z  y  x
	faddp	ST(2),ST(0)				; w1 z  z  z  y  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M13]		; w2 w1 z  z  z  y  x
;
; OVERLAP -- compute second add for previous term
; 
	fxch	ST(2)					; z  w1 w2 z  z  y  x
	faddp	ST(3),ST(0)				; w1 w2 z  z  y  x

	faddp	ST(1), ST(0)				; w1 z z  y  x
;
	fld	DWORD PTR [input][_Z_]
	fmul	DWORD PTR [eax][__MATRIX_M23]		; w2 w1 z  z  y  x
;
; OVERLAP -- compute previous final term
;
	fxch	ST(2)					; z  w1 w2 z  y  x
	faddp	ST(3),ST(0)				; w1 w2 z  y  x

	faddp	ST(1), ST(0)				; w  z  y  x

;
	fld	DWORD PTR [input][_W_]			; w2 w1 z  y  x
	fmul	DWORD PTR [eax][__MATRIX_M33]

;
; OVERLAP -- store final x
;
	fxch	ST(4)					; x  w1 z  y  w2
	fstp	DWORD PTR [result][_X_]			; w1 z  y  w2

;
	faddp	ST(3),ST(0)				; z  y  w
;
; store final z, y, w
;
	fstp	DWORD PTR [result][_Z_]			; y  w
	fstp	DWORD PTR [result][_Y_]			; w
	fstp	DWORD PTR [result][_W_]			; (empty)
ENDM


;------------------------------Public-Routine------------------------------
;
; Avoid some transformation computations by knowing that the incoming
; vertex has z=0 and w=1
;
; res->x = x*m->matrix[0][0] + y*m->matrix[1][0] + m->matrix[3][0];
; res->y = x*m->matrix[0][1] + y*m->matrix[1][1] + m->matrix[3][1];
; res->z = x*m->matrix[0][2] + y*m->matrix[1][2] + m->matrix[3][2];
; res->w = x*m->matrix[0][3] + y*m->matrix[1][3] + m->matrix[3][3];
;
; History:
;  Thu 28-Sep-1995 -by- Otto Berkes [ottob]
; Wrote it.
;--------------------------------------------------------------------------

__GL_ASM_XFORM2 MACRO input, result

;EAX = m->matrix
;EDX = v[]

;---------------------------------------------------------------------------
; Start computation for x term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]			; x1
	fmul	DWORD PTR [eax][__MATRIX_M00]
	fld	DWORD PTR [input][_Y_]			; x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M10]

;---------------------------------------------------------------------------
; Start computation for y term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M01]		; y1 x  x
;
; OVERLAP -- compute second add for previous term
;
	fxch	ST(1)					; x  y1 x
	fadd	DWORD PTR [eax][__MATRIX_M30]		; x  y1 x

	fxch	ST(1)					; y1 x  x
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M11]		; y2 y1 x  x
;
; OVERLAP -- compute previous final term
;
	fxch	ST(2)					; x  y1 y2 x
	faddp	ST(3),ST(0)				; y1 y2 x

;---------------------------------------------------------------------------
; Start computation for z term:
;---------------------------------------------------------------------------


	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M02]		; z1 y  y  x
;
; OVERLAP -- compute add for previous result
;
	fxch	ST(1)					; y  z1 y  x
	fadd	DWORD PTR [eax][__MATRIX_M31]		; y  z1 y  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M12]		; z2 y  z1 y  x

	fxch	ST(1)					; y  z2 z1 y  x
	faddp	ST(3),ST(0)				; z2 z1 y  x


;---------------------------------------------------------------------------
; Start computation for w term:
;---------------------------------------------------------------------------


	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M03]		; w1 z  z  y  x
;
; OVERLAP -- compute add for previous result
;
	fxch	ST(1)
	fadd	DWORD PTR [eax][__MATRIX_M32]		; z  w1 z  y  x
;
	fxch	ST(1)					; w1 z  z  y  x
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M13]		; w2 w1 z  z  y  x
;
; OVERLAP -- compute final z
;
	fxch	ST(2)					; z  w1 w2 z  y  x
	faddp	ST(3), ST(0)				; w1 w2 z  y  x
;
;
; OVERLAP -- store final x
;
	fxch	ST(4)					; x  w2 z  y  w1
	fstp	DWORD PTR [result][_X_]
;
; OVERLAP -- compute add for previous result
;
	fadd	DWORD PTR [eax][__MATRIX_M33]		; w2 z  y  w1
	fxch	ST(2)					; y  z  w2 w1
;
; OVERLAP -- store final y
;
	fstp	DWORD PTR [result][_Y_]			; z  w2 w1
;
; finish up
;
	fxch	ST(1)					; w2 z  w1
	faddp	ST(2), ST(0)				; z  w

	fstp	DWORD PTR [result][_Z_]			; w
	fstp	DWORD PTR [result][_W_]			; (empty)

ENDM


;------------------------------Public-Routine------------------------------
;
; Avoid some transformation computations by knowing that the incoming
; vertex has z=0 and w=1.  The w column of the matrix is [0 0 0 1].
;
; res->x = x*m->matrix[0][0] + y*m->matrix[1][0] + m->matrix[3][0];
; res->y = x*m->matrix[0][1] + y*m->matrix[1][1] + m->matrix[3][1];
; res->z = x*m->matrix[0][2] + y*m->matrix[1][2] + m->matrix[3][2];
; res->w = ((__GLfloat) 1.0);
;
; History:
;  Thu 28-Sep-1995 -by- Otto Berkes [ottob]
; Wrote it.
;--------------------------------------------------------------------------

__GL_ASM_XFORM2_W MACRO input, result

;EAX = m->matrix
;EDX = v[]

;---------------------------------------------------------------------------
; Start computation for x term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]			; x1
	fmul	DWORD PTR [eax][__MATRIX_M00]
	fld	DWORD PTR [input][_Y_]			; x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M10]

;---------------------------------------------------------------------------
; Start computation for y term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M01]		; y1 x  x
;
; OVERLAP -- compute second add for previous term
;
	fxch	ST(1)					; x  y1 x
	fadd	DWORD PTR [eax][__MATRIX_M30]		; x  y1 x

	fxch	ST(1)					; y1 x  x
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M11]		; y2 y1 x  x
;
; OVERLAP -- compute previous final term
;
	fxch	ST(2)					; x  y1 y2 x
	faddp	ST(3),ST(0)				; y1 y2 x
;
	fadd	DWORD PTR [eax][__MATRIX_M31]		; y2 y1 x

;---------------------------------------------------------------------------
; Start computation for z term:
;---------------------------------------------------------------------------


	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M02]		; z1 y  y  x
;
; OVERLAP -- compute add for previous result
;
	fxch	ST(1)					; y  z1 y  x
	faddp	ST(2),ST(0)				; z1 y  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M12]		; z2 z1 y  x
	fxch	ST(1)					; z1 z2 y  x
	fadd	DWORD PTR [eax][__MATRIX_M32]		; z2 z1 y  x

; 
; OVERLAP -- finish up
;
	fxch	ST(2)					; y  z1 z2 x
	fstp	DWORD PTR [result][_Y_]			; z1 z2 x
	faddp	ST(1),ST(0)				; z  x
	fxch	ST(1)					; x  z
	fstp	DWORD PTR [result][_X_]			; z
        mov     DWORD PTR [result][_W_], __FLOAT_ONE
	fstp	DWORD PTR [result][_Z_]			; (empty)
ENDM


;------------------------------Public-Routine------------------------------
;
; Avoid some transformation computations by knowing that the incoming
; vertex has w=1.  The w column of the matrix is [0 0 0 1].
;
; res->x = x*m->matrix[0][0] + y*m->matrix[1][0] + z*m->matrix[2][0]
;	+ m->matrix[3][0];
; res->y = x*m->matrix[0][1] + y*m->matrix[1][1] + z*m->matrix[2][1]
;	+ m->matrix[3][1];
; res->z = x*m->matrix[0][2] + y*m->matrix[1][2] + z*m->matrix[2][2]
;	+ m->matrix[3][2];
; res->w = ((__GLfloat) 1.0);
;
; History:
;  Thu 28-Sep-1995 -by- Otto Berkes [ottob]
; Wrote it.
;--------------------------------------------------------------------------

__GL_ASM_XFORM3_W MACRO input, result

;EAX = m->matrix
;EDX = v[]

;---------------------------------------------------------------------------
; Start computation for x term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]			; x1
	fmul	DWORD PTR [eax][__MATRIX_M00]
	fld	DWORD PTR [input][_Y_]			; x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M10]
	fld	DWORD PTR [input][_Z_]			; x3 x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M20]
	fxch	ST(2)					; x1 x2 x3
	fadd	DWORD PTR [eax][__MATRIX_M30]		; x3 x1 x2

;---------------------------------------------------------------------------
; Start computation for y term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M01]		; y1 x  x  x
;
; OVERLAP -- compute second add for previous term
;
	fxch	ST(1)					; x  y1 x  x
	faddp	ST(2),ST(0)				; y1 x  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M11]		; y2 y1 x  x
;
; OVERLAP -- compute previous final term
;
	fxch	ST(2)					; x  y1 y2 x
	faddp	ST(3),ST(0)				; y1 y2 x
;
	fld	DWORD PTR [input][_Z_]
	fmul	DWORD PTR [eax][__MATRIX_M21]		; y3 y1 y2 x
	fxch	ST(1)					; y1 y3 y2 x
	fadd	DWORD PTR [eax][__MATRIX_M31]		; y3 y2 y1 x

;---------------------------------------------------------------------------
; Start computation for z term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M02]		; z1 y  y  y  x
;
; OVERLAP -- compute second add for previous result
;
	fxch	ST(1)					; y  z1 y  y  x
	faddp	ST(2),ST(0)				; z1 y  y  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M12]		; z2 z1 y  y  x
;
; OVERLAP -- compute previous final result
;
	fxch	ST(2)					; y  z1 z2 y  x
	faddp	ST(3),ST(0)				; z1 z2 y  x
;
	fld	DWORD PTR [input][_Z_]			
	fmul	DWORD PTR [eax][__MATRIX_M22]		; z3 z1 z2 y  x
	fxch	ST(1)					; z1 z3 z2 y  x
	fadd	DWORD PTR [eax][__MATRIX_M32]		; z3 z2 z1 y  x
	fxch	ST(1)					; z2 z3 z1 y  x
	faddp	ST(2),ST(0)				; z1 z2 y  x
;
; finish up
;
	fxch	ST(2)					; y  z2 z1 x
	fstp	DWORD PTR [result][_Y_]			; z2 z1 x
	faddp	ST(1), ST(0)				; z  x
	fxch	ST(1)					; x  z
	fstp	DWORD PTR [result][_X_]			; z
        mov     DWORD PTR [result][_W_], __FLOAT_ONE
	fstp	DWORD PTR [result][_Z_]			; (empty)
ENDM


;------------------------------Public-Routine------------------------------
;
; Avoid some transformation computations by knowing that we're
; only doing the 3x3 used for normals.
;
; res->x = x*m->matrix[0][0] + y*m->matrix[1][0] + z*m->matrix[2][0];
; res->y = x*m->matrix[0][1] + y*m->matrix[1][1] + z*m->matrix[2][1];
; res->z = x*m->matrix[0][2] + y*m->matrix[1][2] + z*m->matrix[2][2];
;
; History:
;  Fri 29-July-1996 -by- Otto Berkes [ottob]
; Wrote it.
;--------------------------------------------------------------------------

__GL_ASM_XFORM3x3 MACRO input, result

;EAX = m->matrix
;EDX = v[]

;---------------------------------------------------------------------------
; Start computation for x term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]			; x1
	fmul	DWORD PTR [eax][__MATRIX_M00]
	fld	DWORD PTR [input][_Y_]			; x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M10]
	fld	DWORD PTR [input][_Z_]			; x3 x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M20]

;---------------------------------------------------------------------------
; Start computation for y term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M01]		; y1 x  x  x
;
; OVERLAP -- compute second add for previous term
;
	fxch	ST(1)					; x  y1 x  x
	faddp	ST(2),ST(0)				; y1 x  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M11]		; y2 y1 x  x
;
; OVERLAP -- compute previous final term
;
	fxch	ST(2)					; x  y1 y2 x
	faddp	ST(3),ST(0)				; y1 y2 x
;
	fld	DWORD PTR [input][_Z_]
	fmul	DWORD PTR [eax][__MATRIX_M21]		; y3 y1 y2 x

;---------------------------------------------------------------------------
; Start computation for z term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M02]		; z1 y  y  y  x
;
; OVERLAP -- compute second add for previous result
;
	fxch	ST(1)					; y  z1 y  y  x
	faddp	ST(2),ST(0)				; z1 y  y  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M12]		; z2 z1 y  y  x
;
; OVERLAP -- compute previous final result
;
	fxch	ST(2)					; y  z1 z2 y  x
	faddp	ST(3),ST(0)				; z1 z2 y  x
;
	fld	DWORD PTR [input][_Z_]			
	fmul	DWORD PTR [eax][__MATRIX_M22]		; z3 z1 z2 y  x
	fxch	ST(1)					; z1 z3 z2 y  x
	faddp	ST(2),ST(0)				; z1 z2 y  x
;
; finish up
;
	fxch	ST(2)					; y  z2 z1 x
	fstp	DWORD PTR [result][_Y_]			; z2 z1 x
	faddp	ST(1), ST(0)				; z  x
	fxch	ST(1)					; x  z
	fstp	DWORD PTR [result][_X_]			; z
	fstp	DWORD PTR [result][_Z_]			; (empty)
ENDM


;------------------------------Public-Routine------------------------------
;
; Full 4x4 transformation.  The w column of the matrix is [0 0 0 1].
;
; if (w == ((__GLfloat) 1.0)) {
;     __glXForm3_W(res, v, m);
; } else {
;     res->x = x*m->matrix[0][0] + y*m->matrix[1][0] + z*m->matrix[2][0]
;	    + w*m->matrix[3][0];
;     res->y = x*m->matrix[0][1] + y*m->matrix[1][1] + z*m->matrix[2][1]
;	    + w*m->matrix[3][1];
;     res->z = x*m->matrix[0][2] + y*m->matrix[1][2] + z*m->matrix[2][2]
;	    + w*m->matrix[3][2];
;     res->w = w;
; }
;
; History:
;  Thu 28-Sep-1995 -by- Otto Berkes [ottob]
; Wrote it.
;--------------------------------------------------------------------------

__GL_ASM_XFORM4_W MACRO input, result

;EAX = m->matrix
;EDX = v[]

;---------------------------------------------------------------------------
; Start computation for x term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]			; x1
	fmul	DWORD PTR [eax][__MATRIX_M00]
	fld	DWORD PTR [input][_Y_]			; x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M10]
	fld	DWORD PTR [input][_Z_]			; x3 x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M20]
	fld	DWORD PTR [input][_W_]			; x4 x3 x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M30]

;---------------------------------------------------------------------------
; Start computation for y term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M01]		; y1 x  x  x  x
;
; OVERLAP -- compute first add for previous term
;
	fxch	ST(1)					; x  y1 x  x  x
	faddp	ST(2),ST(0)				; y1 x  x  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M11]		; y2 y1 x  x  x
;
; OVERLAP -- compute second add for previous term
;
	fxch	ST(2)					; x  y1 y2 x  x
	faddp	ST(3),ST(0)				; y1 y2 x  x
;
	fld	DWORD PTR [input][_Z_]
	fmul	DWORD PTR [eax][__MATRIX_M21]		; y3 y1 y2 x  x
;
; OVERLAP -- compute previous final term
;
	fxch	ST(3)					; x  y1 y2 y3 x
	faddp	ST(4),ST(0)				; y1 y2 y3 x
;
	fld	DWORD PTR [input][_W_]			; y4 y1 y2 y3 x
	fmul	DWORD PTR [eax][__MATRIX_M31]

;---------------------------------------------------------------------------
; Start computation for z term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M02]		; z1 y  y  y  y  x
;
; OVERLAP -- compute first add for previous term
;
	fxch	ST(1)					; y  z1 y  y  y  x
	faddp	ST(2),ST(0)				; z1 y  y  y  x
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M12]		; z2 z1 y  y  y  x
;
; OVERLAP -- compute second add for previous term
;
	fxch	ST(2)					; y  z1 z2 y  y  x
	faddp	ST(3),ST(0)				; z1 z2 y  y  x

	fld	DWORD PTR [input][_Z_]
	fmul	DWORD PTR [eax][__MATRIX_M22]		; z3 z1 z2 y  y  x
;
; OVERLAP -- compute previous final term
;
	fxch	ST(1)					; z1 z3 z2 y  y  x
	faddp	ST(2), ST(0)				; z1 z2 y  y  x
;
	fxch	ST(2)					; y  z1 z2 y  x
	faddp	ST(3),ST(0)				; z1 z2 y  x

;
	fld	DWORD PTR [input][_W_]			; z3 z2 z1 y  x
	fmul	DWORD PTR [eax][__MATRIX_M32]

	fxch	ST(1)					; z2 z3 z1 y  x
	faddp	ST(2), ST(0)				; z1 z2 y  x

;
; OVERLAP -- store final y
;
	fxch	ST(2)					; y  z1 z2 x
	fstp	DWORD PTR [result][_Y_]			; z1 z2 x
	faddp	ST(1), ST(0)				; z  x
	fxch	ST(1)					; x  z
	fstp	DWORD PTR [result][_X_]			; z
	push	DWORD PTR [input][_W_]
	fstp	DWORD PTR [result][_Z_]			; (empty)
	pop	DWORD PTR [result][_W_]
ENDM


;------------------------------Public-Routine------------------------------
;
; Avoid some transformation computations by knowing that the incoming
; vertex has z=0 and w=1.
;
; The matrix looks like:
; | . . 0 0 |
; | . . 0 0 |
; | 0 0 . 0 |
; | . . . 1 |
;
; res->x = x*m->matrix[0][0] + y*m->matrix[1][0] + m->matrix[3][0];
; res->y = x*m->matrix[0][1] + y*m->matrix[1][1] + m->matrix[3][1];
; res->z = m->matrix[3][2];
; res->w = ((__GLfloat) 1.0);
;
; History:
;  Thu 28-Sep-1995 -by- Otto Berkes [ottob]
; Wrote it.
;--------------------------------------------------------------------------

__GL_ASM_XFORM2_2DW MACRO input, result

;EAX = m->matrix
;EDX = v[]

;---------------------------------------------------------------------------
; Start computation for x term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]			; x1
	fmul	DWORD PTR [eax][__MATRIX_M00]
	fld	DWORD PTR [input][_Y_]			; x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M10]
	fxch	ST(1)					; x1 x2
	fadd	DWORD PTR [eax][__MATRIX_M30]

;---------------------------------------------------------------------------
; Start computation for y term:
;---------------------------------------------------------------------------


	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M01]		; y1 x  x
;
; OVERLAP -- compute add for previous result
;
	fxch	ST(1)					; x  y1 x
	faddp	ST(2),ST(0)				; w1 z
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M11]		; y2 y1 x
;
; OVERLAP -- store final x
;
	fxch	ST(2)					; x  y1 y2 
	fstp	DWORD PTR [result][_X_]			; y1 y2
;
	fadd	DWORD PTR [eax][__MATRIX_M31]		; y2 y1
;
; Not much we can do for the last term in the pipe...

	push	DWORD PTR [eax][__MATRIX_M32]
	faddp	ST(1),ST(0)				; y
	pop	DWORD PTR [result][_Z_]
        mov     DWORD PTR [result][_W_], __FLOAT_ONE	
	fstp	DWORD PTR [result][_Y_]			; (empty)
ENDM


;------------------------------Public-Routine------------------------------
;
; Avoid some transformation computations by knowing that the incoming
; vertex has w=1.
;
; The matrix looks like:
; | . . 0 0 |
; | . . 0 0 |
; | 0 0 . 0 |
; | . . . 1 |
;
; res->x = x*m->matrix[0][0] + y*m->matrix[1][0] + m->matrix[3][0];
; res->y = x*m->matrix[0][1] + y*m->matrix[1][1] + m->matrix[3][1];
; res->z = z*m->matrix[2][2] + m->matrix[3][2];
; res->w = ((__GLfloat) 1.0);
;
; History:
;  Thu 28-Sep-1995 -by- Otto Berkes [ottob]
; Wrote it.
;--------------------------------------------------------------------------

__GL_ASM_XFORM3_2DW MACRO input, result

;EAX = m->matrix
;EDX = v[]

;---------------------------------------------------------------------------
; Start computation for x term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]			; x1
	fmul	DWORD PTR [eax][__MATRIX_M00]
	fld	DWORD PTR [input][_Y_]			; x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M10]
	fxch	ST(1)					; x1 x2
	fadd	DWORD PTR [eax][__MATRIX_M30]

;---------------------------------------------------------------------------
; Start computation for y term:
;---------------------------------------------------------------------------


	fld	DWORD PTR [input][_X_]
	fmul	DWORD PTR [eax][__MATRIX_M01]		; y1 x  x
;
; OVERLAP -- compute add for previous result
;
	fxch	ST(1)					; x  y1 x
	faddp	ST(2),ST(0)				; w1 z
;
	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M11]		; y2 y1 x
;
; OVERLAP -- store final x
;
	fxch	ST(2)					; x  y1 y2 
	fstp	DWORD PTR [result][_X_]			; y1 y2
;
	fadd	DWORD PTR [eax][__MATRIX_M31]		; y2 y1

;---------------------------------------------------------------------------
; Start computation for z term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_Z_]
	fmul	DWORD PTR [eax][__MATRIX_M22]		; z  y  y
;
; OVERLAP -- compute add for previous result
;
	fxch	ST(1)					; y  z  y
	faddp	ST(2),ST(0)				; z  y

	fadd	DWORD PTR [eax][__MATRIX_M32]		; z y
        mov     DWORD PTR [result][_W_], __FLOAT_ONE
	fstp	DWORD PTR [result][_Z_]			; y
	fstp	DWORD PTR [result][_Y_]			; (empty)
ENDM


;------------------------------Public-Routine------------------------------
;
; Full 4x4 transformation.
;
; The matrix looks like:
; | . . 0 0 |
; | . . 0 0 |
; | 0 0 . 0 |
; | . . . 1 |
;
; if (w == ((__GLfloat) 1.0)) {
;     __glXForm3_2DW(res, v, m);
; } else {
;     res->x = x*m->matrix[0][0] + y*m->matrix[1][0] + w*m->matrix[3][0];
;     res->y = x*m->matrix[0][1] + y*m->matrix[1][1] + w*m->matrix[3][1];
;     res->z = z*m->matrix[2][2] + w*m->matrix[3][2];
;     res->w = w;
; }
;
; History:
;  Thu 28-Sep-1995 -by- Otto Berkes [ottob]
; Wrote it.
;--------------------------------------------------------------------------

__GL_ASM_XFORM4_2DW MACRO input, result

;EAX = m->matrix
;EDX = v[]


;---------------------------------------------------------------------------
; Start computation for x term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]			; x1
	fmul	DWORD PTR [eax][__MATRIX_M00]
	fld	DWORD PTR [input][_Y_]			; x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M10]
        fld     DWORD PTR [input][_W_]                  ; x3 x2 x1
	fmul	DWORD PTR [eax][__MATRIX_M30]
        fxch    ST(2)                                   ; x1 x2 x3
        faddp   ST(1), ST                               ; x1+x2 x3

	fld	DWORD PTR [input][_X_]			; y1 x1+x2 x3
	fmul	DWORD PTR [eax][__MATRIX_M01]
	fld	DWORD PTR [input][_Y_]			; y2 y1 x1+x2 x3
	fmul	DWORD PTR [eax][__MATRIX_M11]
        fxch    ST(2)                                   ; x1+x2 y1 y2 x3
        faddp   ST(3), ST                               ; y1 y2 X

        fld     DWORD PTR [input][_W_]                  ; y3 y1 y2 X
	fmul	DWORD PTR [eax][__MATRIX_M31]
        fxch    ST(1)                                   ; y1 y3 y2 X
        faddp   ST(2), ST                               ; y3 y1+y2 X

        fld     DWORD PTR [input][_Z_]                  ; z1 y3 y1+y2 X
	fmul	DWORD PTR [eax][__MATRIX_M22]
        fld     DWORD PTR [input][_W_]                  ; z2 z1 y3 y1+y2 X
	fmul	DWORD PTR [eax][__MATRIX_M32]
        fxch    ST(2)                                   ; y3 z1 z2 y1+y2 X
        faddp   ST(3), ST                               ; z1 z2 Y X
        fxch    ST(3)                                   ; X z2 Y z1
        fstp    DWORD PTR [result][_X_]                 ; z2 Y z2
        faddp   ST(2), ST                               ; Y Z
        fstp    DWORD PTR [result][_Y_]
        fstp    DWORD PTR [result][_Z_]
        push    DWORD PTR [input][_W_]
        pop     DWORD PTR [result][_W_]

ENDM


;------------------------------Public-Routine------------------------------
;
; Avoid some transformation computations by knowing that the incoming
; vertex has z=0 and w=1.
;
; The matrix looks like:
; | . 0 0 0 |
; | 0 . 0 0 |
; | 0 0 . 0 |
; | . . . 1 |
;
; res->x = x*m->matrix[0][0] + m->matrix[3][0];
; res->y = y*m->matrix[1][1] + m->matrix[3][1];
; res->z = m->matrix[3][2];
; res->w = ((__GLfloat) 1.0);
;
; History:
;  Thu 28-Sep-1995 -by- Otto Berkes [ottob]
; Wrote it.
;--------------------------------------------------------------------------

__GL_ASM_XFORM2_2DNRW MACRO input, result

;EAX = m->matrix
;EDX = v[]

;---------------------------------------------------------------------------
; Start computation for x term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]			; x
	fmul	DWORD PTR [eax][__MATRIX_M00]

;---------------------------------------------------------------------------
; Start computation for y term:
;---------------------------------------------------------------------------


	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M11]		; y  x
;
; OVERLAP -- compute add for previous result
;
	fxch	ST(1)					; x  y
	fadd	DWORD PTR [eax][__MATRIX_M30]		; x  y

	fxch	ST(1)					; y  x
        mov     DWORD PTR [result][_W_], __FLOAT_ONE	
	fadd	DWORD PTR [eax][__MATRIX_M31]		; y  x

; Not much we can do for the last term in the pipe...

	push	DWORD PTR [eax][__MATRIX_M32]

	fstp	DWORD PTR [result][_Y_]			; x
	fstp	DWORD PTR [result][_X_]			; (empty)
	pop	DWORD PTR [result][_Z_]
ENDM


;------------------------------Public-Routine------------------------------
;
; Avoid some transformation computations by knowing that the incoming
; vertex has w=1.
;
; The matrix looks like:
; | . 0 0 0 |
; | 0 . 0 0 |
; | 0 0 . 0 |
; | . . . 1 |
;
; res->x = x*m->matrix[0][0] + m->matrix[3][0];
; res->y = y*m->matrix[1][1] + m->matrix[3][1];
; res->z = z*m->matrix[2][2] + m->matrix[3][2];
; res->w = ((__GLfloat) 1.0);
;
; History:
;  Thu 28-Sep-1995 -by- Otto Berkes [ottob]
; Wrote it.
;--------------------------------------------------------------------------

__GL_ASM_XFORM3_2DNRW MACRO input, result

;EAX = m->matrix
;EDX = v[]

;---------------------------------------------------------------------------
; Start computation for x term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]			; x
	fmul	DWORD PTR [eax][__MATRIX_M00]

;---------------------------------------------------------------------------
; Start computation for y term:
;---------------------------------------------------------------------------


	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M11]		; y  x
;
; OVERLAP -- compute add for previous result
;
	fxch	ST(1)					; x  y
	fadd	DWORD PTR [eax][__MATRIX_M30]		; x  y
	fxch	ST(1)					; y  x

;---------------------------------------------------------------------------
; Start computation for z term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_Z_]
	fmul	DWORD PTR [eax][__MATRIX_M22]		; z  y  x

;
; OVERLAP -- compute add for previous result
;
	fxch	ST(1)					; y  z  x
	fadd	DWORD PTR [eax][__MATRIX_M31]		; y  z  x

	fxch	ST(2)					; x  z  y
	fstp	DWORD PTR [result][_X_]			; z  y
	
	fadd	DWORD PTR [eax][__MATRIX_M32]		; z  y

	fxch	ST(1)					; y  z
	fstp	DWORD PTR [result][_Y_]			; z

        mov     DWORD PTR [result][_W_], __FLOAT_ONE	

	fstp	DWORD PTR [result][_Z_]			; (empty)
ENDM


;------------------------------Public-Routine------------------------------
;
; Full 4x4 transformation.
;
; The matrix looks like:
; | . 0 0 0 |
; | 0 . 0 0 |
; | 0 0 . 0 |
; | . . . 1 |
;
; if (w == ((__GLfloat) 1.0)) {
;     __glXForm3_2DNRW(res, v, m);
; } else {
;     res->x = x*m->matrix[0][0] + w*m->matrix[3][0];
;     res->y = y*m->matrix[1][1] + w*m->matrix[3][1];
;     res->z = z*m->matrix[2][2] + w*m->matrix[3][2];
;     res->w = w;
; }
;
; History:
;  Thu 28-Sep-1995 -by- Otto Berkes [ottob]
; Wrote it.
;--------------------------------------------------------------------------

__GL_ASM_XFORM4_2DNRW MACRO input, result

;EAX = m->matrix
;EDX = v[]

;---------------------------------------------------------------------------
; Start computation for x term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_X_]			; x
	fmul	DWORD PTR [eax][__MATRIX_M00]
	fld	DWORD PTR [input][_W_]			; x  x
	fmul	DWORD PTR [eax][__MATRIX_M30]

;---------------------------------------------------------------------------
; Start computation for y term:
;---------------------------------------------------------------------------


	fld	DWORD PTR [input][_Y_]
	fmul	DWORD PTR [eax][__MATRIX_M11]		; y  x  x

;
; OVERLAP -- compute add for previous result
;
	fxch	ST(1)					; x  y  x
	faddp	ST(2),ST(0)				; y  x

	fld	DWORD PTR [input][_W_]
	fmul	DWORD PTR [eax][__MATRIX_M31]		; y  y  x

	fxch	ST(2)					; x  y  y
	fstp	DWORD PTR [result][_X_]			; y  y

;---------------------------------------------------------------------------
; Start computation for z term:
;---------------------------------------------------------------------------

	fld	DWORD PTR [input][_Z_]
	fmul	DWORD PTR [eax][__MATRIX_M22]		; z  y  y

	fxch	ST(1)					; y  z  y
	faddp	ST(2), ST(0)				; z  y

	fld	DWORD PTR [input][_W_]			; z  z  y
	fmul	DWORD PTR [eax][__MATRIX_M32]

	fxch	ST(2)					; y  z  z
	fstp	DWORD PTR [result][_Y_]			; z  z

	faddp	ST(1), ST(0)				; z

	push	DWORD PTR [input][_W_]
	fstp	DWORD PTR [result][_Z_]			; (empty)
        pop     DWORD PTR [result][_W_]
ENDM

SINGLE_COORD_NEEDED = 1

ifdef SINGLE_COORD_NEEDED

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Generate single-coordinate matrix routines.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;; ifdef __GL_ASM_XFORM3

;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3(__GLcoord *res, const __GLfloat v[3],
;		    const __GLmatrix *m)
;
;--------------------------------------------------------------------------

        public @__glXForm3@12
@__glXForm3@12 proc near

	PROF_ENTRY
DBGPRINTID str1

	mov	eax, DWORD PTR [esp + 4]

        __GL_ASM_XFORM3 <edx>, <ecx>

	ret	4
@__glXForm3@12 endp

;; endif ; __GL_ASM_XFORM3


;; ifdef __GL_ASM_XFORM4

;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm4(__GLcoord *res, const __GLfloat v[4],
;		    const __GLmatrix *m)
;
;--------------------------------------------------------------------------

        public @__glXForm4@12
@__glXForm4@12 proc near

	PROF_ENTRY
DBGPRINTID str2

	cmp	DWORD PTR [edx][_W_],__FLOAT_ONE		; special case w = 1
	je	@__glXForm3@12

	mov	eax, DWORD PTR [esp + 4]

        __GL_ASM_XFORM4 <edx>, <ecx>

	ret	4
@__glXForm4@12 endp

;; endif ; __GL_ASM_XFORM4

;; ifdef __GL_ASM_XFORM2

;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm2(__GLcoord *res, const __GLfloat v[2],
;		    const __GLmatrix *m)
;
;--------------------------------------------------------------------------

        public @__glXForm2@12
@__glXForm2@12 proc near

	PROF_ENTRY
DBGPRINTID str3

	mov	eax, DWORD PTR [esp + 4]

        __GL_ASM_XFORM2 <edx>, <ecx>

	ret	4
@__glXForm2@12 endp

;; endif ; __GL_ASM_XFORM2

;; ifdef __GL_ASM_XFORM2_W

;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm2_W(__GLcoord *res, const __GLfloat v[2],
;		    const __GLmatrix *m)
;
;--------------------------------------------------------------------------

        public @__glXForm2_W@12
@__glXForm2_W@12 proc near

	PROF_ENTRY
DBGPRINTID str4

	mov	eax, DWORD PTR [esp + 4]

        __GL_ASM_XFORM2_W <edx>, <ecx>

	ret	4
@__glXForm2_W@12 endp

;; endif ; __GL_ASM_XFORM2_W

;; ifdef __GL_ASM_XFORM3_W

;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3_W(__GLcoord *res, const __GLfloat v[3],
;		    const __GLmatrix *m)
;
;--------------------------------------------------------------------------

        public @__glXForm3_W@12
@__glXForm3_W@12 proc near

	PROF_ENTRY
DBGPRINTID str5

	mov	eax, DWORD PTR [esp + 4]

        __GL_ASM_XFORM3_W <edx>, <ecx>

	ret	4
@__glXForm3_W@12 endp

;; endif ; __GL_ASM_XFORM3_W

;; ifdef __GL_ASM_XFORM3x3

;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3x3(__GLcoord *res, const __GLfloat v[3],
;		    const __GLmatrix *m)
;
;--------------------------------------------------------------------------

        public @__glXForm3x3@12
@__glXForm3x3@12 proc near

	PROF_ENTRY
DBGPRINTID str15

	mov	eax, DWORD PTR [esp + 4]

        __GL_ASM_XFORM3x3 <edx>, <ecx>

	ret	4
@__glXForm3x3@12 endp

;; endif ; __GL_ASM_XFORM3X3

;; ifdef __GL_ASM_XFORM4_W

;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm4_W(__GLcoord *res, const __GLfloat v[3],
;		    const __GLmatrix *m)
;
;--------------------------------------------------------------------------

        public @__glXForm4_W@12
@__glXForm4_W@12 proc near

	PROF_ENTRY
DBGPRINTID str6

	cmp	DWORD PTR [edx][_W_],__FLOAT_ONE		; special case w = 1
	je	@__glXForm3_W@12

	mov	eax, DWORD PTR [esp + 4]

        __GL_ASM_XFORM4_W <edx>, <ecx>

	ret	4
@__glXForm4_W@12 endp

;; endif ; __GL_ASM_XFORM4_W

;; ifdef __GL_ASM_XFORM2_2DW

;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm2_2DW(__GLcoord *res, const __GLfloat v[2],
;		    const __GLmatrix *m)
;
;--------------------------------------------------------------------------

        public @__glXForm2_2DW@12
@__glXForm2_2DW@12 proc near

	PROF_ENTRY
DBGPRINTID str7

	mov	eax, DWORD PTR [esp + 4]

        __GL_ASM_XFORM2_2DW <edx>, <ecx>

	ret	4
@__glXForm2_2DW@12 endp

;; endif ; __GL_ASM_XFORM2_2DW

;; ifdef __GL_ASM_XFORM3_2DW

;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3_2DW(__GLcoord *res, const __GLfloat v[3],
;		    const __GLmatrix *m)
;
;--------------------------------------------------------------------------

        public @__glXForm3_2DW@12
@__glXForm3_2DW@12 proc near

	PROF_ENTRY
DBGPRINTID str8

	mov	eax, DWORD PTR [esp + 4]

        __GL_ASM_XFORM3_2DW <edx>, <ecx>

	ret	4
@__glXForm3_2DW@12 endp

;; endif ; __GL_ASM_XFORM3_2DW

;; ifdef __GL_ASM_XFORM4_2DW

;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm4_2DW(__GLcoord *res, const __GLfloat v[4],
;		    const __GLmatrix *m)
;--------------------------------------------------------------------------

        public @__glXForm4_2DW@12
@__glXForm4_2DW@12 proc near

	PROF_ENTRY
DBGPRINTID str9

	cmp	DWORD PTR [edx][_W_],__FLOAT_ONE		; special case w = 1
	je	@__glXForm3_2DW@12

	mov	eax, DWORD PTR [esp + 4]

        __GL_ASM_XFORM4_2DW <edx>, <ecx>

	ret	4
@__glXForm4_2DW@12 endp

;; endif ; __GL_ASM_XFORM4_2DW

;; ifdef __GL_ASM_XFORM2_2DNRW

;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm2_2DNRW(__GLcoord *res, const __GLfloat v[2],
;		      const __GLmatrix *m)
;
;--------------------------------------------------------------------------

        public @__glXForm2_2DNRW@12
@__glXForm2_2DNRW@12 proc near

	PROF_ENTRY
DBGPRINTID str10

	mov	eax, DWORD PTR [esp + 4]

        __GL_ASM_XFORM2_2DNRW <edx>, <ecx>

	ret	4
@__glXForm2_2DNRW@12 endp

;; endif ; __GL_ASM_XFORM2_2DNRW


;; ifdef __GL_ASM_XFORM3_2DNRW

;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3_2DNRW(__GLcoord *res, const __GLfloat v[3],
;		      const __GLmatrix *m)
;
;--------------------------------------------------------------------------

        public @__glXForm3_2DNRW@12
@__glXForm3_2DNRW@12 proc near

	PROF_ENTRY
DBGPRINTID str11

	mov	eax, DWORD PTR [esp + 4]

        __GL_ASM_XFORM3_2DNRW <edx>, <ecx>

	ret	4
@__glXForm3_2DNRW@12 endp

;; endif ; __GL_ASM_XFORM3_2DNRW

;; ifdef __GL_ASM_XFORM4_2DNRW

;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm4_2DNRW(__GLcoord *res, const __GLfloat v[4],
;		      const __GLmatrix *m)
;
;--------------------------------------------------------------------------

        public @__glXForm4_2DNRW@12
@__glXForm4_2DNRW@12 proc near

	PROF_ENTRY
DBGPRINTID str12

	cmp	DWORD PTR [edx][_W_],__FLOAT_ONE	; special case w = 1
	je	@__glXForm3_2DNRW@12

	mov	eax, DWORD PTR [esp + 4]

        __GL_ASM_XFORM4_2DNRW <edx>, <ecx>

	ret	4
@__glXForm4_2DNRW@12 endp

;; endif ; __GL_ASM_XFORM4_2DNRW

endif ;;SINGLE_COORD_NEEDED


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Now, generate batched-coordinate matrix routines.
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;------------------------------Public-Routine------------------------------
; Macro used in all batch routines
;
; ecx     = coordinate address
; edx     = coordinate address for last vertex
; [esp+4] = matrix 
;
; name    = function name
; func    = function name to transform a single vertex
;
; Used registers: 
;   eax, ecx, edx
;
glXFormBatch  MACRO name, func

        public @&name&@12

@&name&@12 PROC NEAR

	PROF_ENTRY
DBGPRINTID str1

        mov     eax, DWORD PTR [esp + 4]
vertexLoop:
        func    <ecx>, <ecx>
	add	ecx, sizeof_POLYDATA
	cmp	ecx, edx
	jbe	vertexLoop
	ret     4

@&name&@12 ENDP

ENDM
;-------------------------------------------------------------------------
;
; Macro to normalize a normal
;
; Input:
;       regPD   - register with POLYDATA address
;       reg2    - any register (will be destroed)
;       reg3    - any register (will be destroed)
;       tmpmem1 - memory offset for temporary data
;       tmpmem2 - memory offset for temporary data
;
; Algoriphm
;
; Computation of 1/sqrt(x), where x is a positive floating point number
;
; x = 2^(E-127)*M,    E - exponent (8 bits), M - mantissa (23 bits)
;
; 1/sqrt(x) = 1/sqrt(2^(E-127)*M)
;
; if E is odd, i.e. E = 2*n + 1 then we have
;
; x = 1/sqrt(2^(2*n + 1 - 127)*M) = 1/sqrt(2^(2*(n-63))*M) = 1/[2^(n-63)*sqrt(M)] = 
;
;   = 2^(63-n)/sqrt(M) 
;
; if E is even, i.e. E = 2*n then we have
;
; x = 1/sqrt(2^(2*n - 127)*M) = 1/sqrt(2^(2*n-126)*M/2) = 1/[2^(n-63)*sqrt(M/2)] = 
;
;   = 2^(63-n)/sqrt(M/2) 
;
; Using K bits of M and 1 lowest bit of E we can make a K+1 bits index (I) into a table.
; Actually mantissa will have K+1 bits, because of one hidden bit. 
;
; Table will store 1/sqrt(mantissa) or 1/sqrt(mantissa/2), depending on lowest E bit. 
;
; if I == 0 .. 2^(K+1)-1, then
;
; Table[I] = (float)(1.0/sqrt(((i & (2^K - 1))/(2^K)+1.0))),   if I & 2^(K) != 0
;
; Table[I] = (float)(1.0/sqrt(((i & (2^K - 1))/(2^K)+1.0)/2.0)),   if I & 2^(K) == 0
;
; 1.0 is added because of the hidden bit in mantissa.
;
;
;
; 31               23 22                           0
;---------------------------------------------------
;!                 !  !   K bits      !            !
;--------------------------------------------------- 
;                   !
;                   -------------- bit from exponent    
;
; Bit from the exponent and K bits from mantissa are shifted right by 23 - K bits and 
; this is the index to a table.
;
; n = E div 2
;
; To multiply by 2^(63-n) we can just add (63-n) << MANTISSA_BITS to a result
; from the table. (Or we can substruct (n-63) << MANTISSA_BITS).
;
; void FASTCALL __glNormalize(float* result, float* source)
;
; edx = result
; ecx = source
;

MANTISSA_SIZE   equ     24          ; number if mantissa bits in fp value
MANTISSA_BITS   equ     (MANTISSA_SIZE - 1)
MANTISSA_MASK   equ     ((1 SHL MANTISSA_BITS) - 1)
EXPONENT_MASK   equ     (-1 AND (NOT MANTISSA_MASK))
K               equ     9           ; K used bits of mantissa

NORMALIZE macro regPD, reg2, reg3, tmpmem1, tmpmem2

	fld	DWORD PTR [regPD+PD_normal]
	fmul	DWORD PTR [regPD+PD_normal]     ;; x
	fld	DWORD PTR [regPD+PD_normal+4]
	fmul	DWORD PTR [regPD+PD_normal+4]   ;; y x
	fld	DWORD PTR [regPD+PD_normal+8]
	fmul	DWORD PTR [regPD+PD_normal+8]   ;; z y x
	fxch	ST(2)			        ;; x y z
	faddp	ST(1), ST		        ;; xy z
	faddp	ST(1), ST		        ;; xyz
	fstp	tmpmem1                         ;; length

	mov	reg2, tmpmem1
	cmp	reg2, __FLOAT_ONE
	je	@continue
        mov     reg3, reg2
        and     reg3, MANTISSA_MASK SHL 1 + 1
        shr     reg2, 1
        shr     reg3, MANTISSA_BITS - K
        and     reg2, EXPONENT_MASK
        mov     reg3, [_invSqrtTable + reg3*4]
        sub     reg2, 63 SHL MANTISSA_BITS
        sub     reg3, reg2
        mov     tmpmem2, reg3                   ;; 1/sqrt(length)
	fld	DWORD PTR [regPD+PD_normal]	
	fmul	tmpmem2                         ;; x
        fld	DWORD PTR [regPD+PD_normal+4]       
	fmul	tmpmem2                         ;; y x
	fld	DWORD PTR [regPD+PD_normal+8]       
	fmul	tmpmem2                         ;; z y x 
	fxch	ST(2)			        ;; x y z 
	fstp	DWORD PTR [regPD+PD_normal]
	fstp	DWORD PTR [regPD+PD_normal+4]
	fstp	DWORD PTR [regPD+PD_normal+8]
@continue:
ENDM
;------------------------------------------------------------
; Macro used in all batch routines for normal transformation
;
; ecx     = pointer to a polyarray 
; edx     = matrix 
;
; name    = function name
; func    = function name to transform a single vertex
;
; Used registers: 
;   eax, ecx, edx
;
glXFormBatchNormal  MACRO name, func

        public @&name&@8

@&name&@8 PROC NEAR

	PROF_ENTRY
DBGPRINTID str1

        mov     eax, edx                ; matrix pointer
        mov     edx, [ecx+PA_pdNextVertex]
        mov     ecx, [ecx+PA_pd0]
@vertexLoop:
        test    DWORD PTR [ecx+PD_flags], POLYDATA_NORMAL_VALID
        jz      @nextVertex
        func    <ecx+PD_normal>, <ecx+PD_normal>
@nextVertex:
        add	ecx, sizeof_POLYDATA
        cmp	ecx, edx
        jl	@vertexLoop

        ret

@&name&@8 ENDP

ENDM
;------------------------------------------------------------
; Macro used in all batch routines for normal transformation
; with normalization
;
; ecx     = pointer to a polyarray 
; edx     = matrix 
;
; name    = function name
; func    = function name to transform a single vertex
;
; Used registers: 
;   eax, ecx, edx
;
glXFormBatchNormalN  MACRO name, func

        public @&name&@8

@&name&@8 PROC NEAR

	PROF_ENTRY
DBGPRINTID str1
        push    ebp
        mov     ebp, esp
        sub     esp, 8
        push    ebx
        push    esi

        mov     eax, edx                ; matrix pointer
        mov     edx, [ecx+PA_pdNextVertex]
        mov     ecx, [ecx+PA_pd0]
@vertexLoop:
        test    DWORD PTR [ecx+PD_flags], POLYDATA_NORMAL_VALID
        jz      @nextVertex
        func    <ecx+PD_normal>, <ecx+PD_normal>

        NORMALIZE <ecx>, <ebx>, <esi>, <DWORD PTR -4[ebp]>, <DWORD PTR -8[ebp]>

@nextVertex:
        add	ecx, sizeof_POLYDATA
        cmp	ecx, edx
	jl	@vertexLoop

        pop     esi
        pop     ebx
        mov     esp, ebp
        pop     ebp
	ret

@&name&@8 ENDP

ENDM
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3Batch(__GLcoord *start, __GLcoord *end,
;		    const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM3

    glXformBatch __glXForm3Batch, __GL_ASM_XFORM3

;; endif ; __GL_ASM_XFORM3
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm4Batch(__GLcoord *start, __GLcoord *end,
;		    const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM4

    glXformBatch __glXForm4Batch, __GL_ASM_XFORM4

;; endif ; __GL_ASM_XFORM4
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm2Batch(__GLcoord *start, __GLcoord *end,
;		    const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM2

    glXformBatch __glXForm2Batch, __GL_ASM_XFORM2

;; endif ; __GL_ASM_XFORM2
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm2_WBatch(__GLcoord *start, __GLcoord *end,
;		    const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM2_W

    glXformBatch __glXForm2_WBatch, __GL_ASM_XFORM2_W

;; endif ; __GL_ASM_XFORM2_W
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3_WBatch(__GLcoord *start, __GLcoord *end,
;		    const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM3_W

    glXformBatch __glXForm3_WBatch, __GL_ASM_XFORM3_W

;; endif ; __GL_ASM_XFORM3_W
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3x3Batch(__GLcoord *start, __GLcoord *end,
;		    const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM3x3

    glXformBatch __glXForm3x3Batch, __GL_ASM_XFORM3x3

;; endif ; __GL_ASM_XFORM3X3
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3x3BatchNormal(POLYARRAY* pa, const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM3x3Normal

    glXformBatchNormal __glXForm3x3BatchNormal, __GL_ASM_XFORM3x3

;; endif ; __GL_ASM_XFORM3X3
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3x3BatchNormalN(POLYARRAY* pa, const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM3x3Normal

    glXformBatchNormalN __glXForm3x3BatchNormalN, __GL_ASM_XFORM3x3

;; endif ; __GL_ASM_XFORM3X3
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm4_WBatch(__GLcoord *start, __GLcoord *end,
;		    const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM4_W

    glXformBatch __glXForm4_WBatch, __GL_ASM_XFORM4_W

;; endif ; __GL_ASM_XFORM4_W
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm2_2DWBatch(__GLcoord *start, __GLcoord *end,
;		    const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM2_2DW

    glXformBatch __glXForm2_2DWBatch, __GL_ASM_XFORM2_2DW

;; endif ; __GL_ASM_XFORM2_2DW
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3_2DWBatch(__GLcoord *start, __GLcoord *end,
;		    const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM3_2DW

    glXformBatch __glXForm3_2DWBatch, __GL_ASM_XFORM3_2DW

;; endif ; __GL_ASM_XFORM3_2DW
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3_2DWBatchNormal(POLYARRAY* pa, const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM3_2DW

    glXformBatchNormal __glXForm3_2DWBatchNormal, __GL_ASM_XFORM3x3

;; endif ; __GL_ASM_XFORM3_2DW
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3_2DWBatchNormalN(POLYARRAY* pa, const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM3_2DW

    glXformBatchNormalN __glXForm3_2DWBatchNormalN, __GL_ASM_XFORM3x3

;; endif ; __GL_ASM_XFORM3_2DW
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm4_2DWBatch(__GLcoord *start, __GLcoord *end,
;		    const __GLmatrix *m)
;; ifdef __GL_ASM_XFORM4_2DW

    glXformBatch __glXForm4_2DWBatch, __GL_ASM_XFORM4_2DW

;; endif ; __GL_ASM_XFORM4_2DW
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm2_2DNRWBatch(__GLcoord *start, __GLcoord *end,
;		      const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM2_2DNRW

    glXformBatch __glXForm2_2DNRWBatch, __GL_ASM_XFORM2_2DNRW

;; endif ; __GL_ASM_XFORM2_2DNRW
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3_2DNRWBatch(__GLcoord *start, __GLcoord *end,
;		      const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM3_2DNRW

    glXformBatch __glXForm3_2DNRWBatch, __GL_ASM_XFORM3_2DNRW

;; endif ; __GL_ASM_XFORM3_2DNRW
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3_2DNRWBatchNormal(POLYARRAY* pa, const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM3_2DNRW

    glXformBatchNormal __glXForm3_2DNRWBatchNormal, __GL_ASM_XFORM3x3

;; endif ; __GL_ASM_XFORM3_2DNRW
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm3_2DNRWBatchNormalN(POLYARRAY* pa, const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM3_2DNRW

    glXformBatchNormalN __glXForm3_2DNRWBatchNormalN, __GL_ASM_XFORM3x3

;; endif ; __GL_ASM_XFORM3_2DNRW
;------------------------------Public-Routine------------------------------
;
; void FASTCALL __glXForm4_2DNRWBatch(__GLcoord *start, __GLcoord *end,
;		      const __GLmatrix *m)
;
;; ifdef __GL_ASM_XFORM4_2DNRW

    glXformBatch __glXForm4_2DNRWBatch, __GL_ASM_XFORM4_2DNRW

;; endif ; __GL_ASM_XFORM4_2DNRW

;-------------------------------------------------------------------------
;
; void FASTCALL __glNormalizeBatch(POLYARRAY* pa)
;
; ecx = POLYARRAY
;
@__glNormalizeBatch@4 PROC NEAR

	push	ebp
	mov	ebp, esp
        sub     esp, 8
        push    ebx
        push    edx

        mov     edx, DWORD PTR [ecx+PA_pd0]
        mov     ebx, DWORD PTR [ecx+PA_pdNextVertex]

vertexLoop:
        test    [edx+PD_flags], POLYDATA_NORMAL_VALID
        jz      nextVertex

        NORMALIZE <edx>, <eax>, <ecx>, <DWORD PTR -4[ebp]>, <DWORD PTR -8[ebp]>

nextVertex:

        add     edx, sizeof_POLYDATA
        cmp     edx, ebx
        jl      vertexLoop

        pop     edx
        pop     ebx
	mov	esp, ebp
	pop	ebp
	ret	0

@__glNormalizeBatch@4 ENDP

END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\i386\texspan.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: texspan.asm
;
; Include file for "body" of texture routines. 
;
; Created: 011/15/1995
; Author: Otto Berkes [ottob]
;
; Copyright (c) 1995 Microsoft Corporation
;----------------------------------------------------------------------;


rMask = ((1 SHL rBits) - 1) SHL rShift
gMask = ((1 SHL gBits) - 1) SHL gShift
bMask = ((1 SHL bBits) - 1) SHL bShift


if REPLACE

rRightShiftAdj	= 16 - (rShift + rBits)
gRightShiftAdj	= 16 - (gShift + gBits)
bRightShiftAdj	= 16 - (bShift + bBits)

else

rRightShiftAdj	= 16 - (rShift)
gRightShiftAdj	= 16 - (gShift)
bRightShiftAdj	= 16 - (bShift)

endif

TMASK_SUBDIV equ [esi].GENGC_tMaskSubDiv
TSHIFT_SUBDIV equ [esi].GENGC_tShiftSubDiv

if FAST_REPLACE
    TEXPALETTE equ [esi].GENGC_texImageReplace
    if (PALETTE_ONLY)
        TEXIMAGE equ [esi].GENGC_texImage
    else
        TEXIMAGE equ [esi].GENGC_texImageReplace
    endif
    if PALETTE_ONLY
        TEX_BPP_LOG2 = 0
    elseif (BPP eq 8)
        TEX_BPP_LOG2 = 0
    else
        TEX_BPP_LOG2 = 1
    endif
else
TEXPALETTE equ [esi].GENGC_texPalette
TEXIMAGE equ [esi].GENGC_texImage
if PALETTE_ONLY
    TEX_BPP_LOG2 = 0
else
    TEX_BPP_LOG2 = 2
endif
endif

;;
;;
;; Macros for alpha modulation, and alpha reads
;;
;;


ALPHAMODULATE MACRO

mov	ah, [esi].GENGC_aAccum+2
mov	al, [edx+3]
and	eax, 0ffffh
mov	ch, _gbMulTable[eax]
mov	[esi].GENGC_aDisplay, ch

ENDM


ALPHANOMODULATE MACRO

mov	ch, [edx+3]
mov	[esi].GENGC_aDisplay, ch

ENDM


;; There are AGIs and other nasties in the alpha-read code.  There's
;; not much we can really do, unfortunately...


if (BPP eq 8)

ALPHAREAD MACRO

xor	eax, eax
mov	al, [ebx]
mov	ebx, [esi].GENGC_pInvTranslateVector
mov	cl, 0ffh
mov	al, [ebx+eax]
mov	ebx, eax
and	ebx, rMask
sub	cl, ch 
shl	ebx, gBits + bBits
mov	bh, cl
mov	ch, _gbMulTable[ebx]
mov	ebx, eax
mov	[esi].GENGC_rDisplay, ch
and	ebx, gMask
shl	ebx, bBits
mov	bh, cl
mov	ch, _gbMulTable[ebx]
mov	ebx, eax
mov	[esi].GENGC_gDisplay, ch
and	ebx, bMask
mov	bh, cl
mov	ch, _gbMulTable[ebx]
mov	[esi].GENGC_bDisplay, ch

ENDM

endif

if (BPP eq 16)

ALPHAREAD MACRO

mov	ax, [ebx]
mov	cl, 0ffh
mov	ebx, eax
and	ebx, rMask
sub	cl, ch
shr	ebx, rShift - (8 - rBits)
mov	bh, cl
mov	ch, _gbMulTable[ebx]
mov	ebx, eax
mov	[esi].GENGC_rDisplay, ch
and	ebx, gMask
shr	ebx, gShift - (8 - gBits)
mov	bh, cl
mov	ch, _gbMulTable[ebx]
mov	ebx, eax
mov	[esi].GENGC_gDisplay, ch
and	ebx, bMask
shl	ebx, (8 - bBits)
mov	bh, cl
mov	ch, _gbMulTable[ebx]
mov	[esi].GENGC_bDisplay, ch

ENDM

elseif (BPP eq 32)

ALPHAREAD MACRO

xor	eax, eax
mov	cl, 0ffh
mov	al, [ebx+2]
sub	cl, ch
mov	ah, cl
mov	al, _gbMulTable[eax]
mov	[esi].GENGC_rDisplay, al
mov	al, [ebx+1]
mov	ah, cl
mov	al, _gbMulTable[eax]
mov	[esi].GENGC_gDisplay, al
mov	al, [ebx]
mov	ah, cl
mov	al, _gbMulTable[eax]
mov	[esi].GENGC_bDisplay, al

ENDM

endif


;;
;;
;; Macros for advancing a single pixel unit
;;
;;


if (BPP eq 8)
PIXADVANCE MACRO var
inc	var
ENDM
elseif (BPP eq 16)
PIXADVANCE MACRO var
add	var, (BPP / 8)
ENDM
else
PIXADVANCE MACRO var
add	var, [esi].GENGC_bytesPerPixel
ENDM
endif

if (BPP le 16)
PIXADVANCE2 MACRO var1, var2
lea	var1, [var2 + (BPP / 8)]
ENDM
else
PIXADVANCE2 MACRO var1, var2
mov	var1, var2
add	var1, [esi].GENGC_bytesPerPixel
ENDM
endif

;;
;;
;; Macros for advancing the accumulators if the z-buffer test fails:
;;
;;


if FAST_REPLACE

ZBUFFER_FAIL_ADVANCE MACRO
mov	ecx, [esi].GENGC_zAccum		;U
mov	eax, [esi].GENGC_SPAN_dz	; V
mov	ebx, [esi].GENGC_pixAccum	;U
add	edi, 2				; V
add	ecx, eax			;U
PIXADVANCE ebx				; V
sub	ebp, 010001h			;U
mov	[esi].GENGC_zAccum, ecx		; V
mov	[esi].GENGC_pixAccum, ebx	;U
jl	doSubDiv			; V
test	ebp, 08000h			;U
je	loopTopNoDiv			; V
jmp	spanExit
ENDM

elseif REPLACE

ZBUFFER_FAIL_ADVANCE MACRO
mov	ecx, [esi].GENGC_zAccum		;U
mov	eax, [esi].GENGC_SPAN_dz	; V
add	edi, 2				;U
add	ecx, eax			; V
mov	eax, [esi].GENGC_ditherAccum	;U
mov	ebx, [esi].GENGC_pixAccum	; V
ror	eax, 8				;U
mov	[esi].GENGC_zAccum, ecx		; V
PIXADVANCE ebx				;U
sub	ebp, 010001h			; V
mov	[esi].GENGC_pixAccum, ebx	;U
mov	[esi].GENGC_ditherAccum, eax	; V
jl	doSubDiv			;U
test	ebp, 08000h			; V
je	loopTopNoDiv			;U
jmp	spanExit			; V
ENDM

elseif FLAT_SHADING

ZBUFFER_FAIL_ADVANCE MACRO
mov	ecx, [esi].GENGC_zAccum		;U
mov	eax, [esi].GENGC_SPAN_dz	; V
add	edi, 2				;U
add	ecx, eax			; V
mov	ebx, [esi].GENGC_pixAccum	;U
mov	eax, [esi].GENGC_ditherAccum	; V
mov	[esi].GENGC_zAccum, ecx		;U
PIXADVANCE ebx				; V
ror	eax, 8				;U
sub	ebp, 010001h			; V
mov	[esi].GENGC_pixAccum, ebx	;U
mov	[esi].GENGC_ditherAccum, eax	; V
jl	doSubDiv			;U
test	ebp, 08000h			; V
je	loopTopNoDiv			;U
jmp	spanExit
ENDM

elseif SMOOTH_SHADING

ZBUFFER_FAIL_ADVANCE MACRO
mov	ecx, [esi].GENGC_zAccum		;U
mov	eax, [esi].GENGC_SPAN_dz	; V
add	edi, 2				;U
add	ecx, eax			; V
mov	eax, [esi].GENGC_rAccum		;U
mov	[esi].GENGC_zAccum, ecx		; V
mov	ebx, [esi].GENGC_SPAN_dr	;U
mov	ecx, [esi].GENGC_gAccum		; V
add	eax, ebx			;U
mov	edx, [esi].GENGC_SPAN_dg	; V
mov	[esi].GENGC_rAccum, eax		;U
add	ecx, edx			; V
mov	eax, [esi].GENGC_bAccum		;U
mov	ebx, [esi].GENGC_SPAN_db	; V
mov	[esi].GENGC_gAccum, ecx		;U
add	ebx, eax			; V
mov	eax, [esi].GENGC_ditherAccum	;U
mov	[esi].GENGC_bAccum, ebx		; V
ror	eax, 8				;U
if ALPHA
mov	ecx, [esi].GENGC_aAccum
endif
mov	ebx, [esi].GENGC_pixAccum	;U
if ALPHA
add	ecx, [esi].GENGC_SPAN_da
endif
PIXADVANCE ebx				;U
if ALPHA
mov	[esi].GENGC_aAccum, ecx
endif
mov	[esi].GENGC_pixAccum, ebx	; V
sub	ebp, 010001h			;U
mov	[esi].GENGC_ditherAccum, eax	; V
jl	doSubDiv			;U
test	ebp, 08000h			; V
je	loopTopNoDiv			;U
jmp	spanExit			; V
ENDM

endif

;;----------------------------------------------------------------------
;;
;; This is the start of the texture routine.  Kick off the divide, and use
;; the dead time to set up all of the accumulators and other variables.
;;
;;----------------------------------------------------------------------

ZBUFFER_EARLY_OUT = 1

if ZBUFFER
push	ebx						;U
push	esi						; V
push	edi						;U
push	ebp						; V

if ZBUFFER_EARLY_OUT

mov	edi, [ecx].GENGC_SPAN_zbuf			;U
mov	esi, [ecx].GENGC_SPAN_z				; V
mov	edx, [ecx].GENGC_SPAN_length			;U
mov	ebp, [ecx].GENGC_SPAN_dz	                ; V

@zLoop:

mov	ebx, esi			;U
mov	eax, [edi]			; V
shr	ebx, 16				;U
and	eax, 0ffffh			; V
cmp	ebx, eax			;U
if ZCMP_L
jl	@zFirstWrite			; V
else
jle	@zFirstWrite			; V
endif
add	edi, 2				;U
add	esi, ebp			; V
dec	edx				;U
jne	@zLoop				; V

pop	ebp
pop	edi
pop	esi
pop	ebx

ret	0

@zFirstWrite:

endif	;; ZBUFFER_EARLY_OUT

endif	;; ZBUFFER


;;
;; Start the divide:
;;
mov	eax, [ecx].GENGC_flags
  fld	DWORD PTR [ecx].GENGC_SPAN_qw                   ;qwAccum
  fld	DWORD PTR [ecx].GENGC_SPAN_qw                   ;qwAccum qwAccum
test	eax, GEN_TEXTURE_ORTHO
jne	@f
  fdivr	__One			                        ;1/qw qwAccum
@@:

;;
;; Save the registers that we need to:
;;

if ZBUFFER
else
push	ebx						;U
push	esi						; V
push	edi						;U
push	ebp						; V
endif

mov	esi, ecx					;U

;;
;; Set up accumulators:
;;

if FAST_REPLACE

if ZBUFFER
mov     eax, [esi].GENGC_SPAN_z				; V
endif
mov     ebx, [esi].GENGC_SPAN_s				;U
mov     ecx, [esi].GENGC_SPAN_t				; V
if ZBUFFER
mov     [esi].GENGC_zAccum, eax				;U
endif
mov     [esi].GENGC_sAccum, ebx				; V
mov     [esi].GENGC_tAccum, ecx				;U
mov     ebx, [esi].GENGC_SPAN_qw                        ; V
mov	eax, [esi].GENGC_SPAN_y				;U
mov     [esi].GENGC_qwAccum, ebx			; V
mov	edx, [esi].GENGC_SPAN_ppix			;U
mov	edi, [esi].GENGC_flags				; V
mov	ebx, [esi].GENGC_SPAN_x				;U
test	edi, SURFACE_TYPE_DIB				; V
jne	@f						;U
mov	edx, [esi].GENGC_ColorsBits			; V
jmp	short @pixAccumDone
@@:
if (BPP eq 8)
add	edx, ebx                                        ;U
elseif (BPP eq 16)
lea	edx, [edx + 2*ebx]
else
lea	edx, [edx + 4*ebx]
cmp	[esi].GENGC_bpp, 32
je	@f
sub	edx, ebx
@@:
endif

@pixAccumDone:

test	edi, GEN_TEXTURE_ORTHO				; V
mov	ebp, [esi].GENGC_SPAN_length			;U
je	@f						; V

else


if REPLACE
else

;; Handle RGB accumulators

if FLAT_SHADING
mov     eax, [ecx].GENGC_SPAN_r                         ;U
mov     ebx, [ecx].GENGC_SPAN_g				; V
shr     eax, rBits                                      ;U
mov	ecx, [esi].GENGC_SPAN_b				; V
shr     ebx, gBits                                      ;U
and     eax, 0ff00h                                     ; V
shr     ecx, bBits                                      ;U
and     ebx, 0ff00h                                     ; V
and     ecx, 0ff00h                                     ;U
mov     [esi].GENGC_rAccum, eax				; V
mov	[esi].GENGC_gAccum, ebx				;U
mov	[esi].GENGC_bAccum, ecx				; V
else
mov     eax, [ecx].GENGC_SPAN_r                         ;U
mov     ebx, [ecx].GENGC_SPAN_g				; V
mov	ecx, [esi].GENGC_SPAN_b				;U
mov     [esi].GENGC_rAccum, eax				; V
mov	[esi].GENGC_gAccum, ebx				;U
mov	[esi].GENGC_bAccum, ecx				; V
endif	;; FLAT_SHADING

endif	;; NOT REPLACE

if ZBUFFER
mov     eax, [esi].GENGC_SPAN_z				; V
endif
mov     ebx, [esi].GENGC_SPAN_s				;U
mov     ecx, [esi].GENGC_SPAN_t				; V
if ZBUFFER
mov     [esi].GENGC_zAccum, eax				;U
endif
mov     [esi].GENGC_sAccum, ebx				; V
mov     [esi].GENGC_tAccum, ecx				;U
mov     ebx, [esi].GENGC_SPAN_qw                        ; V
mov	eax, [esi].GENGC_SPAN_y				;U
mov     [esi].GENGC_qwAccum, ebx			; V
and	eax, 03h					;U
mov	ecx, [esi].GENGC_SPAN_x				; V
lea	eax, [eax*4 + offset dither0]			;U
lea	ecx, [ecx*8]					; V
mov	edx, [esi].GENGC_SPAN_ppix			;U
mov	edi, [esi].GENGC_flags				; V
mov	ebx, [esi].GENGC_SPAN_x				;U
test	edi, SURFACE_TYPE_DIB				; V
jne	@f						;U
mov	edx, [esi].GENGC_ColorsBits			; V
jmp	short @pixAccumDone
@@:
if (BPP eq 8)
add	edx, ebx                                        ;U
elseif (BPP eq 16)
lea	edx, [edx + 2*ebx]
else
lea	edx, [edx + 4*ebx]
cmp	[esi].GENGC_bpp, 32
je	@f
sub	edx, ebx
@@:
endif

@pixAccumDone:

mov	eax, [eax]					; V
and	ecx, 018h					;U
test	edi, GEN_TEXTURE_ORTHO				; V
mov	ebp, [esi].GENGC_SPAN_length			;U
je	@f						; V

endif

mov	edi, [esi].GENGC_sAccum				; V
mov	ebx, [esi].GENGC_tAccum				;U
mov	DWORD PTR [esi].GENGC_sResult, edi		; V
mov	DWORD PTR [esi].GENGC_tResult, ebx		;U
mov	edi, [esi].GENGC_flags				; V
jmp	short @stResultDone1				;U

;;
;; Kick off the next divide:
;;

@@:

  fild	DWORD PTR [esi].GENGC_sAccum	; s 1/qw qwAccum
  fmul	ST, ST(1)			; s/qw 1/qw qwAccum
  fild	DWORD PTr [esi].GENGC_tAccum	; t s/qw 1/qw qwAccum
  fmulp	ST(2), ST			; s/qw t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_sResult	; t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_tResult	; qwAccum
  fadd	DWORD PTR [esi].GENGC_qwStepX	; qwAccum
  fld	ST(0)				; qwAccum qwAccum
  fdivr	__One			        ; 1/qw qwAccum

@stResultDone1:

ror	eax, cl						;UV (4)
add	ebp, 070000h					;U
mov	[esi].GENGC_ditherAccum, eax			; V
dec	ebp						;U
mov	[esi].GENGC_pixAccum, edx			; V
mov	eax, [esi].GENGC_sAccum				;U
mov	ebx, [esi].GENGC_tAccum				; V
add	eax, [esi].GENGC_sStepX				;U
add	ebx, [esi].GENGC_tStepX				; V
mov	[esi].GENGC_sAccum, eax				;U
mov	[esi].GENGC_tAccum, ebx				; V
mov	eax, [esi].GENGC_sResult			;U
mov	ebx, [esi].GENGC_tResult			; V
mov	cl, TSHIFT_SUBDIV       			;U
sar	ebx, cl						;UV (4)
and	ebx, NOT 7					;U

if ALPHA
mov	ecx, [esi].GENGC_SPAN_a
endif

test	edi, GEN_TEXTURE_ORTHO				; V
mov	[esi].GENGC_tResult, ebx			;U

if ALPHA
mov	[esi].GENGC_aAccum, ecx
endif

je	@f
mov	ecx, [esi].GENGC_sAccum				; V
mov	edx, [esi].GENGC_tAccum				;U
mov	DWORD PTR [esi].GENGC_sResultNew, ecx		; V
mov	DWORD PTR [esi].GENGC_tResultNew, edx		;U
jmp	short @stResultDone2				; V

@@:

;; We may have to burn some cycles here...

  fild	DWORD PTR [esi].GENGC_sAccum	; s 1/qw qwAccum
  fmul	ST, ST(1)			; s/qw 1/qw qwAccum
  fild	DWORD PTr [esi].GENGC_tAccum	; t s/qw 1/qw qwAccum
  fmulp	ST(2), ST			; s/qw t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_sResultNew; t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_tResultNew; qwAccum
  fadd	DWORD PTR [esi].GENGC_qwStepX	; qwAccum

@stResultDone2:

mov	cl, TSHIFT_SUBDIV       			;U
mov	edx, [esi].GENGC_tResultNew			; V
sar	edx, cl						;UV (4)
and	edx, NOT 7					;U
mov	ecx, [esi].GENGC_sResultNew			; V
mov	[esi].GENGC_tResultNew, edx			;U
sub	ecx, eax					; V
sar	ecx, 3						;U
sub	edx, ebx					; V
sar	edx, 3						;U
mov	[esi].GENGC_subDs, ecx				; V
mov	[esi].GENGC_subDt, edx				;U
mov	eax, [esi].GENGC_flags				; V
mov	edi, [esi].GENGC_SPAN_zbuf			;U

loopTop:

;;
;; This is the start of the outer loop.  We come back here on each
;; subdivision.  The key thing is to kick off the next divide:
;;

test	eax, GEN_TEXTURE_ORTHO				; V
jne	@f						;U

  fld	ST(0)				; qwAccum qwAccum    
  fadd	DWORD PTR [esi].GENGC_qwStepX	; qwAccum+ qwAccum
  fxch	ST(1)				; qwAccum qwAccum+
  fdivr	__One				; 1/qw qwAccum+  -- let the divide rip!

@@:

loopTopNoDiv:

;;
;; This is the start of the inner loop.  This is where the pixel-level
;; work happens:
;;

;;
;; First, do z-buffering is enabled:
;;

if ZBUFFER

mov	eax, [edi]			;U
mov	ebx, [esi].GENGC_zAccum		; V
shr	ebx, 16				;U
and	eax, 0ffffh			; V
cmp	ebx, eax			;U
if ZCMP_L
jl	@zWrite				; V
else
jle	@zWrite				; V
endif

ZBUFFER_FAIL_ADVANCE

@zWrite:
mov	[edi], bx			;UV

endif  ;;ZBUFFER

;;
;; Now, get pointer to current texel value in EDX.  There are two cases,
;; one if there is a palette-lookup, and one if we index straight into
;; the texture.
;;


if PALETTE_ENABLED

mov     ecx, TEXPALETTE                         ;U
mov     eax, TMASK_SUBDIV                       ; V
test    ecx, ecx                                ;U
je      @noPalette				; V

mov     edx, [esi].GENGC_tResult                ; V
mov     ebx, [esi].GENGC_sResult                ;U
and     edx, eax                                ; V
mov     eax, [esi].GENGC_sMask                  ;U
and     ebx, eax	                        ; V
shr     edx, 6		                        ;U
mov     eax, DWORD PTR [esi].GENGC_sResult      ; V
shr     ebx, 16		                        ;U
mov     ecx, TEXIMAGE                           ; V
add     edx, ecx                                ;U
add     eax, [esi].GENGC_subDs                  ; V
mov     ecx, DWORD PTR [esi].GENGC_tResult      ;U
add     edx, ebx			        ; V
add     ecx, [esi].GENGC_subDt                  ;U
mov     DWORD PTR [esi].GENGC_sResult, eax      ; V
xor	eax, eax				;U
mov	ebx, TEXPALETTE         		; V
mov     DWORD PTR [esi].GENGC_tResult, ecx      ;U
mov	al, [edx]				; V
lea	edx, [ebx+4*eax]			;U
jmp	short @paletteDone                      ; V

@noPalette:

endif ;;PALETTE_ENABLED

mov     eax, TMASK_SUBDIV                       ;U
mov     edx, [esi].GENGC_tResult                ; V
mov     ebx, [esi].GENGC_sResult                ;U
and     edx, eax                                ; V
shr     edx, (6-TEX_BPP_LOG2)                   ;U
mov     ecx, [esi].GENGC_sMask                  ; V
and     ebx, ecx                                ;U
mov	eax, DWORD PTR [esi].GENGC_sResult      ; V
shr     ebx, (16-TEX_BPP_LOG2)                  ;U
mov	ecx, [esi].GENGC_subDs                  ; V
add	eax, ecx				;U
add     edx, ebx			        ; V
mov     ecx, TEXIMAGE                           ;U
mov	ebx, [esi].GENGC_subDt                  ; V
add     edx, ecx                                ;U
mov	ecx, DWORD PTR [esi].GENGC_tResult      ; V
add	ecx, ebx				;U
mov     DWORD PTR [esi].GENGC_sResult, eax      ; V
mov     DWORD PTR [esi].GENGC_tResult, ecx      ;U

if (PALETTE_ONLY)
mov	al, [edx]				; V
and	eax, 0ffh				;U
mov	ebx, TEXPALETTE         		; V
lea	edx, [ebx+4*eax]			;U
endif


@paletteDone:


;;
;; We are now ready to handle each of the 4 basic modes on a case-by-case
;; basis.  We will generally try to adhere to the following register
;; usage:
;;	eax - red
;;	ebx - green
;;	ecx - blue
;;	ebx, edx - framebuffer pointers
;;

if FAST_REPLACE

;;----------------------------------------------------------------------
;;
;; ** Replace mode (compressed)
;;
;;----------------------------------------------------------------------


if ALPHA

cmp	BYTE PTR [edx+3], 0ffh		;U
je	@noAlpha			; V
mov	ebx, [esi].GENGC_pixAccum	;U	;; get ready to do read
cmp	BYTE PTR [edx+3], 0		; V
jne	@alphaRead			;U

;; Alpha is 0 in the texture, so just increment all the accumulators

if ZBUFFER
	mov	ecx, [esi].GENGC_zAccum		;U
	add	edi, 2				; V
	add	ecx, [esi].GENGC_SPAN_dz	;U
endif

PIXADVANCE ebx					;U

if ZBUFFER
	mov	[esi].GENGC_zAccum, ecx		;U
endif

ror	eax, 8				; V
sub	ebp, 010001h			;U
mov	[esi].GENGC_pixAccum, ebx	; V
mov	[esi].GENGC_ditherAccum, eax	;U

;; Finish incrementing all of our accumulators

jl	doSubDiv			; V
test	ebp, 08000h			;U
je	loopTopNoDiv			; V

jmp	spanExit

@alphaRead:

;;
;; Get pixel value and calculate total effect with alpha
;;

;; To make this easy on ourselves, we'll use the uncompressed palette
;; to do the alpha modulation:


ALPHANOMODULATE
sub	edx, [esi].GENGC_texImageReplace
add	edx, [esi].GENGC_texPalette
ALPHAREAD

mov	al, [edx+2]			;U get texel value
mov	ah, [esi].GENGC_aDisplay
mov	bl, [edx+1]			;U
mov	bh, [esi].GENGC_aDisplay
mov	cl, [edx]			; V
mov	ch, [esi].GENGC_aDisplay
and	eax, 0ffffh
and	ebx, 0ffffh
and	ecx, 0ffffh
mov	ah, _gbMulTable[eax]
mov	bh, _gbMulTable[ebx]
mov	ch, _gbMulTable[ecx]
add	ah, [esi].GENGC_rDisplay
add	bh, [esi].GENGC_gDisplay
add	ch, [esi].GENGC_bDisplay

if (BPP eq 32)
shl	eax, -rRightShiftAdj
else
shr	eax, rRightShiftAdj		;U
endif
mov	edx, [esi].GENGC_pixAccum	; V
shr	ebx, gRightShiftAdj		;U
and	eax, rMask			; V
shr	ecx, bRightShiftAdj		;U
and	ebx, gMask			; V
and	ecx, bMask			;U
or	eax, ebx			; V
or	eax, ecx			;U
PIXADVANCE2 ebx, edx			; V

if ZBUFFER
mov	ecx, [esi].GENGC_zAccum		; V
add	edi, 2				;U
add	ecx, [esi].GENGC_SPAN_dz	; V
endif

mov	[esi].GENGC_pixAccum, ebx	;U

if ZBUFFER
mov	[esi].GENGC_zAccum, ecx		;U
endif

if (BPP eq 8)
sub	ebp, 010001h			; V
mov	al, [esi].GENGC_xlatPalette[eax];U	;; AGI without z-buffering
mov	[edx], al			;U
elseif (BPP eq 16)
sub	ebp, 010001h
mov	[edx], ax
else
mov	[edx], ax
shr	eax, 16
sub	ebp, 010001h
mov	[edx+2], al
endif

;; Finish the loop:

jl	doSubDiv			; V
test	ebp, 08000h			;U
je	loopTopNoDiv			; V

jmp	spanExit

endif  ;;ALPHA

@noAlpha:

mov	ebx, [esi].GENGC_pixAccum	;U

if (BPP eq 8)
mov	al, [edx]			; V get texel value
elseif (BPP eq 16)
mov	ax, [edx]
else
mov	eax, [edx]
endif

PIXADVANCE2 ecx, ebx			;U

if ZBUFFER
	mov	edx, [esi].GENGC_zAccum		; V
	add	edi, 2				;U
	add	edx, [esi].GENGC_SPAN_dz	; V
	mov	[esi].GENGC_zAccum, edx		;U
endif

mov	[esi].GENGC_pixAccum, ecx	; V

if (BPP eq 8)
sub	ebp, 010001h			;U
mov	[ebx], al			; V
elseif (BPP eq 16)
sub	ebp, 010001h
mov	[ebx], ax
else
mov	[ebx], ax
shr	eax, 16
sub	ebp, 010001h
mov	[ebx+2], al
endif

;; Finish incrementing all of our accumulators

jl	doSubDiv			;U
test	ebp, 08000h			; V
je	loopTopNoDiv			;U

jmp	spanExit

elseif REPLACE


;;----------------------------------------------------------------------
;;
;; ** Replace mode (non-compressed)
;;
;;----------------------------------------------------------------------

if ALPHA

cmp	BYTE PTR [edx+3], 0ffh		;U
je	@noAlpha			; V
mov	ebx, [esi].GENGC_pixAccum	;U	;; get ready to do read
cmp	BYTE PTR [edx+3], 0		; V
jne	@alphaRead			;U

;; Alpha is 0 in the texture, so just increment all the accumulators

if ZBUFFER
	mov	ecx, [esi].GENGC_zAccum		;U
	add	edi, 2				; V
	add	ecx, [esi].GENGC_SPAN_dz	;U
endif

mov	eax, [esi].GENGC_ditherAccum	; V

if ZBUFFER
	mov	[esi].GENGC_zAccum, ecx		;U
endif

PIXADVANCE ebx				;U
ror	eax, 8				; V
sub	ebp, 010001h			;U
mov	[esi].GENGC_pixAccum, ebx	; V
mov	[esi].GENGC_ditherAccum, eax	;U

;; Finish incrementing all of our accumulators

jl	doSubDiv			; V
test	ebp, 08000h			;U
je	loopTopNoDiv			; V

jmp	spanExit

@alphaRead:

;;
;; Get pixel value and calculate total effect with alpha
;;

ALPHANOMODULATE
ALPHAREAD

mov	al, [edx+2]			;U get texel value
mov	ah, [esi].GENGC_aDisplay
mov	bl, [edx+1]			;U
mov	bh, [esi].GENGC_aDisplay
mov	cl, [edx]			; V
mov	ch, [esi].GENGC_aDisplay
and	eax, 0ffffh
and	ebx, 0ffffh
and	ecx, 0ffffh
mov	ah, _gbMulTable[eax]
mov	bh, _gbMulTable[ebx]
mov	ch, _gbMulTable[ecx]
add	ah, [esi].GENGC_rDisplay
add	bh, [esi].GENGC_gDisplay
add	ch, [esi].GENGC_bDisplay

if (BPP eq 32)
shl	eax, -rRightShiftAdj
else
shr	eax, rRightShiftAdj		;U
endif
mov	edx, [esi].GENGC_pixAccum	; V
shr	ebx, gRightShiftAdj		;U
and	eax, rMask			; V
shr	ecx, bRightShiftAdj		;U
and	ebx, gMask			; V
and	ecx, bMask			;U
or	eax, ebx			; V
or	eax, ecx			;U
PIXADVANCE2 ebx, edx			; V

if ZBUFFER
mov	ecx, [esi].GENGC_zAccum		; V
add	edi, 2				;U
add	ecx, [esi].GENGC_SPAN_dz	; V
endif

mov	[esi].GENGC_pixAccum, ebx	;U

if ZBUFFER
mov	[esi].GENGC_zAccum, ecx		;U
endif

if (BPP eq 8)
sub	ebp, 010001h			; V
mov	al, [esi].GENGC_xlatPalette[eax];U	;; AGI without z-buffering
mov	[edx], al			;U
elseif (BPP eq 16)
sub	ebp, 010001h
mov	[edx], ax
else
mov	[edx], ax
shr	eax, 16
sub	ebp, 010001h
mov	[edx+2], al
endif

;; Finish the loop:

jl	doSubDiv			; V
test	ebp, 08000h			;U
je	loopTopNoDiv			; V

jmp	spanExit

endif  ;;ALPHA

@noAlpha:

mov	ah, [edx+2]			;U get texel value
mov	bh, [edx+1]			; V
if (BPP eq 32)
shl	eax, -rRightShiftAdj
else
shr	eax, rRightShiftAdj		;U
endif
mov	ch, [edx]			; V
shr	ebx, gRightShiftAdj		;U
and	eax, rMask			; V
shr	ecx, bRightShiftAdj		;U
and	ebx, gMask			; V
or	eax, ebx			;U
and	ecx, bMask			; V
mov	edx, [esi].GENGC_pixAccum	;U
or	eax, ecx			; V
PIXADVANCE2 ebx, edx			;U

if ZBUFFER
mov	ecx, [esi].GENGC_zAccum		; V
add	edi, 2				;U
add	ecx, [esi].GENGC_SPAN_dz	; V
mov	[esi].GENGC_zAccum, ecx		;U
endif

if (BPP eq 8)
sub	ebp, 010001h			; V
mov	[esi].GENGC_pixAccum, ebx	;U
mov	al, [esi].GENGC_xlatPalette[eax]; V
mov	[edx], al			;U
elseif (BPP eq 16)
sub	ebp, 010001h
mov	[esi].GENGC_pixAccum, ebx
mov	[edx], ax
else
mov	[edx], ax
shr	eax, 16
mov	[esi].GENGC_pixAccum, ebx
sub	ebp, 010001h
mov	[edx+2], al
endif

;; Finish the loop:

jl	doSubDiv			; V
test	ebp, 08000h			;U
je	loopTopNoDiv			; V

jmp	spanExit


elseif FLAT_SHADING

;;----------------------------------------------------------------------
;;
;; ** Flat shading
;;
;;----------------------------------------------------------------------


if ALPHA

mov	ebx, [esi].GENGC_pixAccum	;; get ready to do read
cmp	BYTE PTR [edx+3], 0		
jne	@alphaRead			

;; Alpha is 0 in the texture, so just increment all the accumulators

if ZBUFFER
	mov	ecx, [esi].GENGC_zAccum		
	mov	eax, [esi].GENGC_SPAN_dz	
	add	edi, 2				
	add	ecx, eax			
endif

mov	eax, [esi].GENGC_ditherAccum		

if ZBUFFER
	mov	[esi].GENGC_zAccum, ecx		
endif

ror	eax, 8				;U
PIXADVANCE ebx				; V
sub	ebp, 010001h			;U
mov	[esi].GENGC_pixAccum, ebx	; V
mov	[esi].GENGC_ditherAccum, eax	;U

;; Finish incrementing all of our accumulators

jl	doSubDiv			; V
test	ebp, 08000h			;U
je	loopTopNoDiv			; V
jmp	spanExit

@alphaRead:

cmp	BYTE PTR [edx+3], 0ffh
jne	@doAlpha
cmp	BYTE PTR [esi].GENGC_aAccum+2, 0ffh
jne	@doAlpha

;; Set mix color to 1, 0, 0, 0

mov	DWORD PTR [esi].GENGC_rDisplay, 0ff000000h
jmp	short @doneAlpha

;;
;; Get pixel value and calculate total effect with alpha
;;

@doAlpha:

ALPHAMODULATE
ALPHAREAD

@doneAlpha:

endif  ;;ALPHA

mov	ebx, [edx]                      ;U
mov     ecx, ebx                        ; V
shr     ebx, 16                         ;U
mov     edx, ecx                        ; V
shr     ecx, 8                          ;U
mov     eax, [esi].GENGC_rAccum		; V
and     ebx, 0ffh                       ;U
and     ecx, 0ffh                       ; V
or      ebx, eax                        ;U
mov     eax, [esi].GENGC_gAccum		; V
and     edx, 0ffh                       ;U
or      ecx, eax                        ; V
mov     eax, [esi].GENGC_bAccum		;U
or      edx, eax                        ; V
mov	ebx, DWORD PTR _gbMulTable[ebx]	;U
mov	ecx, DWORD PTR _gbMulTable[ecx]	; V
mov	edx, DWORD PTR _gbMulTable[edx]	;U


if ALPHA

mov	bh, [esi].GENGC_aDisplay
mov	ch, bh
mov	dh, bh

and	ebx, 0ffffh
and	ecx, 0ffffh
and	edx, 0ffffh

mov	bl, _gbMulTable[ebx]
mov	cl, _gbMulTable[ecx]
mov	dl, _gbMulTable[edx]

add	bl, [esi].GENGC_rDisplay
add	cl, [esi].GENGC_gDisplay
add	dl, [esi].GENGC_bDisplay

endif

;; do the dithering

shl	ebx, (rBits+8)			;U
mov	eax, [esi].GENGC_ditherAccum	; V
shl	ecx, (gBits+8)			;U
and	eax, 0f800h			; V
shl	edx, (bBits+8)			;U
add	ebx, eax			; V
add	ecx, eax			;U
add	edx, eax			; V

;;
;; Compose the final pixel:
;;

if (BPP eq 32)
shl	ebx, -rRightShiftAdj
else
shr	ebx, rRightShiftAdj		;U
endif
mov	eax, [esi].GENGC_ditherAccum	; V
ror	eax, 8				;U
and	ebx, rMask			; V
shr	ecx, gRightShiftAdj		;U
mov	[esi].GENGC_ditherAccum, eax	; V
shr	edx, bRightShiftAdj		;U
and	ecx, gMask			; V
or	ebx, ecx			;U
and	edx, bMask			; V
or	ebx, edx			;U

;;
;; Advance the frame buffer pointer:
;;

mov	ecx, [esi].GENGC_pixAccum	; V
mov	edx, ecx			;U
if (BPP le 16)
add     ecx, (BPP / 8)                  ; V
else
add     ecx, [esi].GENGC_bytesPerPixel  ; V
endif
mov	[esi].GENGC_pixAccum, ecx	;U

;;
;; A good time to start incrementing all of our accumulators:
;;

if ZBUFFER
	mov	ecx, [esi].GENGC_zAccum		; V
	mov	eax, [esi].GENGC_SPAN_dz	;U
	add	ecx, eax			; V
	add	edi, 2				;U
	mov	[esi].GENGC_zAccum, ecx		; V
endif

;;
;; Write the pixel into the frame buffer
;;

if (BPP eq 8)
mov	al, [esi].GENGC_xlatPalette[ebx]; V
sub	ebp, 010001h			;U
mov	[edx], al			; V
elseif (BPP eq 16)
sub	ebp, 010001h
mov	[edx], bx
else
mov	[edx], bx
shr	ebx, 16
sub	ebp, 010001h
mov	[edx+2], bl
endif

;; Finish incrementing all of our accumulators

jl	doSubDiv			;U
test	ebp, 08000h			; V
je	loopTopNoDiv			;U

elseif SMOOTH_SHADING

;;----------------------------------------------------------------------
;;
;; ** Smooth shading
;;
;;----------------------------------------------------------------------

if ALPHA

mov	ebx, [esi].GENGC_pixAccum	;; get ready to do read
cmp	BYTE PTR [edx+3], 0		
jne	@alphaRead			

;; Alpha is 0 in the texture, so just increment all the accumulators

if ZBUFFER
	mov	ecx, [esi].GENGC_zAccum		
	mov	eax, [esi].GENGC_SPAN_dz	
	add	eax, ecx			
	add	edi, 2				
	mov	[esi].GENGC_zAccum, eax		
endif

mov	eax, [esi].GENGC_rAccum		
mov	ebx, [esi].GENGC_gAccum		
mov	ecx, [esi].GENGC_bAccum		
add	eax, [esi].GENGC_SPAN_dr	
add	ebx, [esi].GENGC_SPAN_dg	
add	ecx, [esi].GENGC_SPAN_db	
mov	[esi].GENGC_rAccum, eax		
mov	[esi].GENGC_gAccum, ebx		
mov	[esi].GENGC_bAccum, ecx		

mov	eax, [esi].GENGC_ditherAccum	
mov	ecx, [esi].GENGC_aAccum		

ror	eax, 8				
mov	ebx, [esi].GENGC_pixAccum	
add	ecx, [esi].GENGC_SPAN_da	
PIXADVANCE ebx				
mov	[esi].GENGC_aAccum, ecx		
mov	[esi].GENGC_pixAccum, ebx	
sub	ebp, 010001h			
mov	[esi].GENGC_ditherAccum, eax	

;; Finish incrementing all of our accumulators

jl	doSubDiv			;U
test	ebp, 08000h			; V
je	loopTopNoDiv			;U
jmp	spanExit

@alphaRead:

cmp	BYTE PTR [edx+3], 0ffh
jne	@doAlpha
cmp	BYTE PTR [esi].GENGC_aAccum+2, 0ffh
jne	@doAlpha

;; Set mix color to 1, 0, 0, 0

mov	DWORD PTR [esi].GENGC_rDisplay, 0ff000000h
jmp	short @doneAlpha

;;
;; Get pixel value and calculate total effect with alpha
;;

@doAlpha:

ALPHAMODULATE
ALPHAREAD

@doneAlpha:

endif  ;;ALPHA

mov	ebx, [esi].GENGC_rAccum		;U
mov	eax, [edx]			; V
shr     ebx, rBits                      ;U
and     eax, 0ff0000h                   ; V
shr	eax, 16				;U
mov	ecx, [esi].GENGC_gAccum		; V
shr	ecx, gBits			;U
and     ebx, 0ff00h                     ; V
or      ebx, eax                        ;U
mov	eax, [edx]			; V
shr     eax, 8                          ;U
mov	edx, [edx]			; V
and     eax, 0ffh                       ;U
and	ecx, 0ff00h			; V
or      ecx, eax                        ;U
mov     eax, [esi].GENGC_bAccum		; V
shr     eax, bBits                      ;U
and     edx, 0ffh                       ; V
and     eax, 0ff00h                     ;U
mov	ebx, DWORD PTR _gbMulTable[ebx]	; V get multiplied 8-bit R value
or      edx, eax                        ;U
mov	ecx, DWORD PTR _gbMulTable[ecx]	; V get multiplied 8-bit G value
mov	eax, [esi].GENGC_ditherAccum	;U
mov	edx, DWORD PTR _gbMulTable[edx]	; V get multiplied 8-bit B value


if ALPHA

mov	bh, [esi].GENGC_aDisplay
mov	ch, bh
mov	dh, bh

and	ebx, 0ffffh
and	ecx, 0ffffh
and	edx, 0ffffh

mov	bl, _gbMulTable[ebx]
mov	cl, _gbMulTable[ecx]
mov	dl, _gbMulTable[edx]

add	bl, [esi].GENGC_rDisplay
add	cl, [esi].GENGC_gDisplay
add	dl, [esi].GENGC_bDisplay

endif

shl	ebx, (rBits+8)			;U
and	eax, 0f800h			; V
shl	ecx, (gBits+8)			;U
add	ebx, eax			; V
shl	edx, (bBits+8)			;U
add	ecx, eax			; V

if (BPP eq 32)
shl	ebx, -rRightShiftAdj
else
shr	ebx, rRightShiftAdj		;U
endif
add	edx, eax			; V
shr	ecx, gRightShiftAdj		;U
and	ebx, rMask			; V
shr	edx, bRightShiftAdj		;U
and	ecx, gMask			; V
or	ebx, ecx			;U
and	edx, bMask			; V
or	ebx, edx			;U

;;
;; A good time to start incrementing all of our accumulators
;;

if ZBUFFER
	mov	ecx, [esi].GENGC_zAccum		; V
	mov	eax, [esi].GENGC_SPAN_dz	;U
	add	eax, ecx			; V
	add	edi, 2				;U
	mov	[esi].GENGC_zAccum, eax		; V
endif

mov	eax, [esi].GENGC_rAccum		;U
mov	ecx, [esi].GENGC_SPAN_dr	; V
mov	edx, [esi].GENGC_gAccum		;U
add     eax, ecx                        ; V
mov     ecx, [esi].GENGC_SPAN_dg        ;U
mov     [esi].GENGC_rAccum, eax         ; V
add     edx, ecx                        ;U
mov     eax, [esi].GENGC_bAccum         ; V
mov	ecx, [esi].GENGC_SPAN_db        ;U
add     eax, ecx                        ; V
mov     [esi].GENGC_gAccum, edx         ;U
mov     [esi].GENGC_bAccum, eax         ; V

mov	eax, [esi].GENGC_ditherAccum	;U
mov	ecx, [esi].GENGC_pixAccum	; V
ror	eax, 8				;U
mov	edx, ecx			; V
if (BPP le 16)
add	ecx, (BPP / 8)			;U
else
add	ecx, [esi].GENGC_bytesPerPixel	;U
endif
mov	[esi].GENGC_ditherAccum, eax	; V
mov	[esi].GENGC_pixAccum, ecx	;U

if ALPHA
mov	ecx, [esi].GENGC_aAccum
add	ecx, [esi].GENGC_SPAN_da
mov	[esi].GENGC_aAccum, ecx
endif

if (BPP eq 8)
mov	al, [esi].GENGC_xlatPalette[ebx]; V
sub	ebp, 010001h			;U
mov	[edx], al			; V
elseif (BPP eq 16)
sub	ebp, 010001h
mov	[edx], bx
else
mov	[edx], bx
shr	ebx, 16
sub	ebp, 010001h
mov	[edx+2], bl
endif

;; Finish incrementing all of our accumulators

jl	doSubDiv			;U
test	ebp, 08000h			; V
je	loopTopNoDiv			;U

endif  ;;SMOOTH_SHADING

;;
;; This is the exit point.  We need to pop the unused floating-point
;; registers off the stack, and return:
;;

spanExit:

fstp	ST(0)
fstp	ST(0)

pop	ebp
pop	edi
pop	esi
pop	ebx

ret	0

;;
;; This is the subdivision code.  After the required number of steps, the
;; routine will jump here to calculate the next set of interpolants based
;; on subdivision:
;;

doSubDiv:

add	ebp, 080000h

mov	ecx, [esi].GENGC_flags

;;
;; Increment the big S and T steps:
;;

mov	edx, [esi].GENGC_sAccum

test	ebp, 08000h
jne	short spanExit

mov	ebx, [esi].GENGC_tAccum

add	edx, [esi].GENGC_sStepX
add	ebx, [esi].GENGC_tStepX
mov	[esi].GENGC_sAccum, edx
mov	[esi].GENGC_tAccum, ebx
mov	eax, [esi].GENGC_sResultNew
mov	ebx, [esi].GENGC_tResultNew

test	ecx, GEN_TEXTURE_ORTHO
je	@f

mov	ecx, DWORD PTR [esi].GENGC_tAccum
mov	DWORD PTR [esi].GENGC_sResultNew, edx
mov	DWORD PTR [esi].GENGC_tResultNew, ecx
jmp	short @stResultDone3

;;
;; Do the floating-point computation for perspective:
;;

@@:

  fild	DWORD PTR [esi].GENGC_sAccum	; s 1/qw qwAccum
  fmul	ST, ST(1)			; s/qw 1/qw qwAccum
  fild	DWORD PTr [esi].GENGC_tAccum	; t s/qw 1/qw qwAccum
  fmulp	ST(2), ST			; s/qw t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_sResultNew; t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_tResultNew; qwAccum

@stResultDone3:

;;
;; Now, calculate the per-pixel deltas:
;;

mov	cl, TSHIFT_SUBDIV       	;U
mov	edx, [esi].GENGC_tResultNew	; V
sar	edx, cl				;UV (4)
mov	ecx, [esi].GENGC_sResultNew	;U
and	edx, NOT 7			; V
sub	ecx, eax			;U
mov	[esi].GENGC_tResultNew, edx	; V
sar	ecx, 3				;U
sub	edx, ebx			; V
sar	edx, 3				;U
mov	[esi].GENGC_subDs, ecx		; V
mov	[esi].GENGC_subDt, edx		;U
mov	[esi].GENGC_sResult, eax	; V
mov	[esi].GENGC_tResult, ebx	;U
mov	eax, [esi].GENGC_flags		; V
jmp	loopTop				;U
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\asm.h ===
#ifndef __glasm_h_
#define __glasm_h_

/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
*/

/*
** Add defines to this file when routines are written in assembler.  This is
** so that the functions written in C will not be compiled.  If the name is
** not defined, then the functions written in assembler will not be assembled
**
** The "GROUP" defines turn on a number of functions.  See the code in soft
** for details.
**
** SGI code originally used __GL_USEASMCODE as one big switch.
** This method allows finer control over what is written in assembler.
*/

/* Define the following to disable all asm code and test the C code */
#ifndef __GL_ASM_DISABLE_ALL_ASM

#if defined(_X86_)
#define __GL_ASM_XFORM2
#define __GL_ASM_XFORM2BATCH
#define __GL_ASM_XFORM3
#define __GL_ASM_XFORM3BATCH
#define __GL_ASM_XFORM4
#define __GL_ASM_XFORM4BATCH
#define __GL_ASM_XFORM2_W
#define __GL_ASM_XFORM2_WBATCH
#define __GL_ASM_XFORM3_W
#define __GL_ASM_XFORM3_WBATCH
#define __GL_ASM_XFORM3x3
#define __GL_ASM_XFORM3x3BATCH
#define __GL_ASM_XFORM4_W
#define __GL_ASM_XFORM4_WBATCH
#define __GL_ASM_XFORM2_2DW
#define __GL_ASM_XFORM2_2DWBATCH
#define __GL_ASM_XFORM3_2DW
#define __GL_ASM_XFORM3_2DWBATCH
#define __GL_ASM_XFORM4_2DW
#define __GL_ASM_XFORM4_2DWBATCH
#define __GL_ASM_XFORM2_2DNRW
#define __GL_ASM_XFORM2_2DNRWBATCH
#define __GL_ASM_XFORM3_2DNRW
#define __GL_ASM_XFORM3_2DNRWBATCH
#define __GL_ASM_XFORM4_2DNRW
#define __GL_ASM_XFORM4_2DNRWBATCH
#define __GL_ASM_POLYARRAYPROPAGATESAMECOLOR
#define __GL_ASM_POLYARRAYFASTCALCRGBCOLOR
#define __GL_ASM_POLYARRAYZIPPYCALCRGBCOLOR
#define __GL_ASM_PACLIPCHECKFRUSTUM
#define __GL_ASM_PACLIPCHECKFRUSTUM2D
#define __GL_ASM_PACLIPCHECKALL
#define __GL_ASM_FAST_DLIST_PLAYBACK
#define __GL_ASM_GLCLTNORMAL3F
#define __GL_ASM_GLCLTNORMAL3FV
#define __GL_ASM_GLCLTTEXCOORD2F
#define __GL_ASM_GLCLTTEXCOORD2FV
#define __GL_ASM_GLCLTTEXCOORD3F
#define __GL_ASM_GLCLTTEXCOORD3FV
#define __GL_ASM_GLCLTVERTEX2F
#define __GL_ASM_GLCLTVERTEX2FV
#define __GL_ASM_GLCLTVERTEX3F
#define __GL_ASM_GLCLTVERTEX3FV
#define __GL_ASM_GLCLTCOLOR3F_INRGBA
#define __GL_ASM_GLCLTCOLOR3FV_INRGBA
#define __GL_ASM_GLCLTCOLOR4F_INRGBA
#define __GL_ASM_GLCLTCOLOR4FV_INRGBA
#define __GL_ASM_NORMALIZE
#define __GL_ASM_NORMAL_BATCH
#endif /* X86 */

#if defined(_MIPS_)
#define __GL_ASM_NORMALIZE
#define __GL_ASM_MULTMATRIX
#define __GL_ASM_CLAMPANDSCALECOLOR
#define __GL_ASM_XFORM2
#define __GL_ASM_XFORM3
#define __GL_ASM_XFORM4
#define __GL_ASM_XFORM2_W
#define __GL_ASM_XFORM3_W
#define __GL_ASM_XFORM4_W
#define __GL_ASM_XFORM2_2DW
#define __GL_ASM_XFORM3_2DW
#define __GL_ASM_XFORM4_2DW
#define __GL_ASM_XFORM2_2DNRW
#define __GL_ASM_XFORM3_2DNRW
#define __GL_ASM_XFORM4_2DNRW
#if 0
    #define __GL_ASM_POINT
    #define __GL_ASM_POINTFAST
    #define __GL_ASM_OTHERLSTRIPVERTEXFAST
    #define __GL_ASM_FASTCALCRGBCOLOR
    #define __GL_ASM_SAVEN
    #define __GL_ASM_SAVECI
    #define __GL_ASM_SAVEC
    #define __GL_ASM_SAVET
    #define __GL_ASM_SAVECT
    #define __GL_ASM_SAVENT
    #define __GL_ASM_SAVECIALL
    #define __GL_ASM_SAVECALL
    #define __GL_ASM_VALIDATEVERTEX2
    #define __GL_ASM_VALIDATEVERTEX3
    #define __GL_ASM_VALIDATEVERTEX4
#endif
#endif /* MIPS */

#if defined(_PPC_)
#define __GL_ASM_NORMALIZE
#define __GL_ASM_MULTMATRIX
#define __GL_ASM_CLAMPANDSCALECOLOR
#define __GL_ASM_XFORM2
#define __GL_ASM_XFORM3
#define __GL_ASM_XFORM4
#define __GL_ASM_XFORM2_W
#define __GL_ASM_XFORM3_W
#define __GL_ASM_XFORM4_W
#define __GL_ASM_XFORM2_2DW
#define __GL_ASM_XFORM3_2DW
#define __GL_ASM_XFORM4_2DW
#define __GL_ASM_XFORM2_2DNRW
#define __GL_ASM_XFORM3_2DNRW
#define __GL_ASM_XFORM4_2DNRW
#if 0
#define __GL_ASM_POINT
#define __GL_ASM_POINTFAST
#define __GL_ASM_OTHERLSTRIPVERTEXFAST
#define __GL_ASM_FASTCALCRGBCOLOR
#define __GL_ASM_SAVEN
#define __GL_ASM_SAVECI
#define __GL_ASM_SAVEC
#define __GL_ASM_SAVET
#define __GL_ASM_SAVECT
#define __GL_ASM_SAVENT
#define __GL_ASM_SAVECIALL
#define __GL_ASM_SAVECALL
#define __GL_ASM_VALIDATEVERTEX2
#define __GL_ASM_VALIDATEVERTEX3
#define __GL_ASM_VALIDATEVERTEX4
#endif
#endif /* PPC */

#if defined(_ALPHA_)
//#define __GL_ASM_PACLIPCHECKFRUSTUM
//#define __GL_ASM_POLYARRAYFASTCALCRGBCOLOR
#define __GL_ASM_NORMALIZE
#define __GL_ASM_VECSUB4
//#define __GL_ASM_XFORM1		
//#define __GL_ASM_XFORM1BATCH		
//#define __GL_ASM_XFORM2		
//#define __GL_ASM_XFORM2BATCH		
//#define __GL_ASM_XFORM3	
#define __GL_ASM_XFORM3BATCH	
//#define __GL_ASM_XFORM4		
#define __GL_ASM_XFORM4BATCH		
//#define __GL_ASM_XFORM1_W	
//#define __GL_ASM_XFORM1_WBATCH	
//#define __GL_ASM_XFORM2_W	
//#define __GL_ASM_XFORM2_WBATCH	
//#define __GL_ASM_XFORM3_W	
#define __GL_ASM_XFORM3_WBATCH	
//#define __GL_ASM_XFORM3x3
#define __GL_ASM_XFORM3x3BATCH
//#define __GL_ASM_XFORM4_W	
#define __GL_ASM_XFORM4_WBATCH	
//#define __GL_ASM_XFORM1_2DW	
//#define __GL_ASM_XFORM1_2DWBATCH	
//#define __GL_ASM_XFORM2_2DW	
//#define __GL_ASM_XFORM2_2DWBATCH	
//#define __GL_ASM_XFORM3_2DW	
#define __GL_ASM_XFORM3_2DWBATCH	
//#define __GL_ASM_XFORM4_2DW	
//#define __GL_ASM_XFORM4_2DWBATCH	
//#define __GL_ASM_XFORM1_2DNRW	
//#define __GL_ASM_XFORM1_2DNRWBATCH	
//#define __GL_ASM_XFORM2_2DNRW	
//#define __GL_ASM_XFORM2_2DNRWBATCH	
//#define __GL_ASM_XFORM3_2DNRW	
#define __GL_ASM_XFORM3_2DNRWBATCH	
//#define __GL_ASM_XFORM4_2DNRW	
//#define __GL_ASM_XFORM4_2DNRWBATCH	
#if 0
#define __GL_ASM_SAVEN
#define __GL_ASM_SAVECI
#define __GL_ASM_SAVEC
#define __GL_ASM_SAVET
#define __GL_ASM_SAVECT
#define __GL_ASM_SAVENT
#define __GL_ASM_SAVECIALL
#define __GL_ASM_SAVECALL
#endif
#endif /* ALPHA */

#endif /* __GL_ASM_DISABLE_ALL_ASM */

#endif /* __glasm_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\ia64\glia64.c ===
//
// No Check-in Source Code.
//
// Do not make this code available to non-Microsoft personnel
// 	without Intel's express permission
//
/**
***  Copyright  (C) 1996-97 Intel Corporation. All rights reserved.
***
*** The information and source code contained herein is the exclusive
*** property of Intel Corporation and may not be disclosed, examined
*** or reproduced in whole or in part without explicit written authorization
*** from the company.
**/

/******************************Module*Header*******************************\
* Module Name: glia64.c                                                    *
*                                                                          *
* This module implements a program which generates structure offset        *
* definitions for OpenGL structures that are accessed in assembly code.    *
*                                                                          *
* Created: 24-Aug-1992 01:24:49                                            *
* Author: Charles Whitmer [chuckwh]                                        *
* Ported for OpenGL 4/1/1994 Otto Berkes [ottob]                           *
*                                                                          *
* Copyright (c) 1994 Microsoft Corporation                                 *
\**************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <stdio.h>
#include <windows.h>
#include <ddraw.h>
#include <glp.h>

// #include <winddi.h>

#include "types.h"
#include "render.h"
#include "context.h"
#include "attrib.h"
#include "gencx.h"


#define OFFSET(type, field) ((LONG)(&((type *)0)->field))

// pcomment prints a comment.

#define pcomment(s)  fprintf(outfh,"// %s\n",s)

// pequate prints an equate statement.

#define pequate(m,v) fprintf(outfh,"%s == 0x%lX\n",m,v);

// pblank prints a blank line.

#define pblank()     fprintf(outfh,"\n")

// pstruct defines an empty structure with the correct size.

#define pstruct(n,c) fprintf(outfh,                           \
                     ".size  %s  %d\n", \
                     n,c);

// pstr prints a string.

#define pstr(s)  fprintf(outfh,"%s\n",s)

//extern __cdecl exit(int);

/******************************Public*Routine******************************\
* GLia64                                                                  *
*                                                                          *
* This is how we make structures consistent between C and ASM for OpenGL.  *
*                                                                          *
\**************************************************************************/

int __cdecl main(int argc,char *argv[])
{
    FILE *outfh;
    char *outName;

    if (argc == 2) {
        outName = argv[ 1 ];
    } else {
#ifdef TREE2
        outName = "\\nt\\private\\windows\\gdi\\opengl2\\server\\soft\\ia64\\oglia64.inc";
#else
        outName = "\\nt\\private\\windows\\gdi\\opengl\\server\\soft\\ia64\\oglia64.inc";
#endif
    }
    outfh = fopen( outName, "w" );
    if (outfh == NULL) {
        fprintf(stderr, "GENia64: Could not create output file '%s'.\n", outName);
        exit (1);
    }

    fprintf( stderr, "GLia64: Writing %s header file.\n", outName );

    pblank();
    pcomment("------------------------------------------------------------------");
    pcomment(" Module Name: glia64.inc");
    pcomment("");
    pcomment(" Defines OpenGL assembly-language structures.");
    pcomment("");
    pcomment(" Copyright (c) 1994 Microsoft Corporation");
    pcomment("------------------------------------------------------------------");
    pblank();
    pblank();
    pblank();

    // UNUSED
#if 0
// Stuff from: \nt\public\sdk\inc\gl\gl.h

    pcomment("Pixel Format Descriptor");
    pblank();
    pequate("PFD_cColorBits     ",OFFSET(PIXELFORMATDESCRIPTOR,cColorBits ));
    pequate("PFD_iPixelType     ",OFFSET(PIXELFORMATDESCRIPTOR,iPixelType ));
    pequate("PFD_cDepthBits     ",OFFSET(PIXELFORMATDESCRIPTOR,cDepthBits ));


    pcomment("GL Test Functions");
    pblank();

    pequate("GL_NEVER           ",GL_NEVER   );
    pequate("GL_LESS            ",GL_LESS    );
    pequate("GL_EQUAL           ",GL_EQUAL   );
    pequate("GL_LEQUAL          ",GL_LEQUAL  );
    pequate("GL_GREATER         ",GL_GREATER );
    pequate("GL_NOTEQUAL        ",GL_NOTEQUAL);
    pequate("GL_GEQUAL          ",GL_GEQUAL  );
    pequate("GL_ALWAYS          ",GL_ALWAYS  );
    pblank();
    pblank();

    pcomment("GL Mode Flags");
    pblank();
    pequate("__GL_SHADE_RGB         ",__GL_SHADE_RGB        );
    pequate("__GL_SHADE_SMOOTH      ",__GL_SHADE_SMOOTH     );
    pequate("__GL_SHADE_DEPTH_TEST  ",__GL_SHADE_DEPTH_TEST );
    pequate("__GL_SHADE_DITHER      ",__GL_SHADE_DITHER     );
    pequate("__GL_SHADE_LOGICOP     ",__GL_SHADE_LOGICOP    );
    pequate("__GL_SHADE_MASK        ",__GL_SHADE_MASK       );
    pblank();
    pblank();

    pcomment("GL Type Sizes");
    pblank();
    pequate("GLbyteSize             ",sizeof(GLbyte));
    pequate("GLshortSize            ",sizeof(GLshort));
    pequate("GLintSize              ",sizeof(GLint));
    pequate("GLfloatSize            ",sizeof(GLfloat));
    pequate("__GLfloatSize          ",sizeof(__GLfloat));
    pequate("__GLzValueSize         ",sizeof(__GLzValue));
    pblank();
    pblank(); 


// Stuff from: \nt\private\windows\gdi\opengl\server\inc\types.h

    pcomment("__GLcolorRec structure");
    pblank();
    pstruct("GLcolorRec",sizeof(struct __GLcolorRec));
    pblank();
    pequate("COLOR_r            ",OFFSET(struct __GLcolorRec,r  ));
    pequate("COLOR_g            ",OFFSET(struct __GLcolorRec,g  ));
    pequate("COLOR_b            ",OFFSET(struct __GLcolorRec,b  ));
    pequate("COLOR_a            ",OFFSET(struct __GLcolorRec,a  ));
    pblank();
    pblank();


// Stuff from: \nt\private\windows\gdi\opengl\server\inc\render.h

    pcomment("__GLfragmentRec structure");
    pblank();

    pstruct("GLfragmentRec",sizeof(struct __GLfragmentRec));
    pblank();
    pequate("FRAG_x             ",OFFSET(struct __GLfragmentRec,x       ));
    pequate("FRAG_y             ",OFFSET(struct __GLfragmentRec,y       ));
    pequate("FRAG_z             ",OFFSET(struct __GLfragmentRec,z       ));
    pequate("FRAG_color         ",OFFSET(struct __GLfragmentRec,color   ));
    pequate("FRAG_s             ",OFFSET(struct __GLfragmentRec,s       ));
    pequate("FRAG_t             ",OFFSET(struct __GLfragmentRec,t       ));
    pequate("FRAG_qw            ",OFFSET(struct __GLfragmentRec,qw      ));
    pequate("FRAG_f             ",OFFSET(struct __GLfragmentRec,f       ));
    pblank();

    pcomment("__GLshadeRec structure");
    pblank();
    pstruct("__GLshadeRec",sizeof(struct __GLshadeRec));
    pblank();
    pequate("SHADE_dxLeftLittle ",OFFSET(struct __GLshadeRec,dxLeftLittle   ));
    pequate("SHADE_dxLeftBig    ",OFFSET(struct __GLshadeRec,dxLeftBig      ));
    pequate("SHADE_dxLeftFrac   ",OFFSET(struct __GLshadeRec,dxLeftFrac     ));
    pequate("SHADE_ixLeft       ",OFFSET(struct __GLshadeRec,ixLeft         ));
    pequate("SHADE_ixLeftFrac   ",OFFSET(struct __GLshadeRec,ixLeftFrac     ));

    pequate("SHADE_dxRightLittle",OFFSET(struct __GLshadeRec,dxRightLittle  ));
    pequate("SHADE_dxRightBig   ",OFFSET(struct __GLshadeRec,dxRightBig     ));
    pequate("SHADE_dxRightFrac  ",OFFSET(struct __GLshadeRec,dxRightFrac    ));
    pequate("SHADE_ixRight      ",OFFSET(struct __GLshadeRec,ixRight        ));
    pequate("SHADE_ixRightFrac  ",OFFSET(struct __GLshadeRec,ixRightFrac    ));

    pequate("SHADE_area         ",OFFSET(struct __GLshadeRec,area           ));
    pequate("SHADE_dxAC         ",OFFSET(struct __GLshadeRec,dxAC           ));
    pequate("SHADE_dxBC         ",OFFSET(struct __GLshadeRec,dxBC           ));
    pequate("SHADE_dyAC         ",OFFSET(struct __GLshadeRec,dyAC           ));
    pequate("SHADE_dyBC         ",OFFSET(struct __GLshadeRec,dyBC           ));

    pequate("SHADE_frag         ",OFFSET(struct __GLshadeRec,frag           ));
    pequate("SHADE_spanLength   ",OFFSET(struct __GLshadeRec,length         ));

    pequate("SHADE_rLittle      ",OFFSET(struct __GLshadeRec,rLittle        ));
    pequate("SHADE_gLittle      ",OFFSET(struct __GLshadeRec,gLittle        ));
    pequate("SHADE_bLittle      ",OFFSET(struct __GLshadeRec,bLittle        ));
    pequate("SHADE_aLittle      ",OFFSET(struct __GLshadeRec,aLittle        ));

    pequate("SHADE_rBig         ",OFFSET(struct __GLshadeRec,rBig           ));
    pequate("SHADE_gBig         ",OFFSET(struct __GLshadeRec,gBig           ));
    pequate("SHADE_bBig         ",OFFSET(struct __GLshadeRec,bBig           ));
    pequate("SHADE_aBig         ",OFFSET(struct __GLshadeRec,aBig           ));

    pequate("SHADE_drdx         ",OFFSET(struct __GLshadeRec,drdx           ));
    pequate("SHADE_dgdx         ",OFFSET(struct __GLshadeRec,dgdx           ));
    pequate("SHADE_dbdx         ",OFFSET(struct __GLshadeRec,dbdx           ));
    pequate("SHADE_dadx         ",OFFSET(struct __GLshadeRec,dadx           ));

    pequate("SHADE_drdy         ",OFFSET(struct __GLshadeRec,drdy           ));
    pequate("SHADE_dgdy         ",OFFSET(struct __GLshadeRec,dgdy           ));
    pequate("SHADE_dbdy         ",OFFSET(struct __GLshadeRec,dbdy           ));
    pequate("SHADE_dady         ",OFFSET(struct __GLshadeRec,dady           ));

    pequate("SHADE_zLittle      ",OFFSET(struct __GLshadeRec,zLittle        ));
    pequate("SHADE_zBig         ",OFFSET(struct __GLshadeRec,zBig           ));
    pequate("SHADE_dzdx         ",OFFSET(struct __GLshadeRec,dzdx           ));
    pequate("SHADE_dzdyf        ",OFFSET(struct __GLshadeRec,dzdyf          ));
    pequate("SHADE_dzdxf        ",OFFSET(struct __GLshadeRec,dzdxf          ));

    pequate("SHADE_sLittle      ",OFFSET(struct __GLshadeRec,sLittle        ));
    pequate("SHADE_tLittle      ",OFFSET(struct __GLshadeRec,tLittle        ));
    pequate("SHADE_qwLittle     ",OFFSET(struct __GLshadeRec,qwLittle       ));

    pequate("SHADE_sBig         ",OFFSET(struct __GLshadeRec,sBig           ));
    pequate("SHADE_tBig         ",OFFSET(struct __GLshadeRec,tBig           ));
    pequate("SHADE_qwBig        ",OFFSET(struct __GLshadeRec,qwBig          ));

    pequate("SHADE_dsdx         ",OFFSET(struct __GLshadeRec,dsdx           ));
    pequate("SHADE_dtdx         ",OFFSET(struct __GLshadeRec,dtdx           ));
    pequate("SHADE_dqwdx        ",OFFSET(struct __GLshadeRec,dqwdx          ));

    pequate("SHADE_dsdy         ",OFFSET(struct __GLshadeRec,dsdy           ));
    pequate("SHADE_dtdy         ",OFFSET(struct __GLshadeRec,dtdy           ));
    pequate("SHADE_dqwdy        ",OFFSET(struct __GLshadeRec,dqwdy          ));

    pequate("SHADE_fLittle      ",OFFSET(struct __GLshadeRec,fLittle        ));
    pequate("SHADE_fBig         ",OFFSET(struct __GLshadeRec,fBig           ));
    pequate("SHADE_dfdy         ",OFFSET(struct __GLshadeRec,dfdy           ));
    pequate("SHADE_dfdx         ",OFFSET(struct __GLshadeRec,dfdx           ));

    pequate("SHADE_modeFlags    ",OFFSET(struct __GLshadeRec,modeFlags      ));

    pequate("SHADE_zbuf         ",OFFSET(struct __GLshadeRec,zbuf           ));
    pequate("SHADE_zbufBig      ",OFFSET(struct __GLshadeRec,zbufBig        ));
    pequate("SHADE_zbufLittle   ",OFFSET(struct __GLshadeRec,zbufLittle     ));

    pequate("SHADE_sbuf         ",OFFSET(struct __GLshadeRec,sbuf           ));
    pequate("SHADE_sbufBig      ",OFFSET(struct __GLshadeRec,sbufBig        ));
    pequate("SHADE_sbufLittle   ",OFFSET(struct __GLshadeRec,sbufLittle     ));

    pequate("SHADE_colors       ",OFFSET(struct __GLshadeRec,colors         ));
    pequate("SHADE_fbcolors     ",OFFSET(struct __GLshadeRec,fbcolors       ));
    pequate("SHADE_stipplePat   ",OFFSET(struct __GLshadeRec,stipplePat     ));
    pequate("SHADE_done         ",OFFSET(struct __GLshadeRec,done           ));
    pequate("SHADE_cfb          ",OFFSET(struct __GLshadeRec,cfb            ));
    pblank();
    pblank();


    pcomment("__GLpolygonMachineRec structure");
    pblank();
    pstruct("GLpolygonMachineRec",sizeof(struct __GLpolygonMachineRec));
    pblank();
    pequate("POLY_stipple       ",OFFSET(struct __GLpolygonMachineRec,stipple));
    pequate("POLY_shader        ",OFFSET(struct __GLpolygonMachineRec,shader ));
    pblank();
    pblank();


// Stuff from: \nt\private\windows\gdi\opengl\server\inc\buffers.h

    pequate("DIB_FORMAT         ",DIB_FORMAT);

    pcomment("__GLbufferRec structure");
    pblank();
    pstruct("GLbufferRec",sizeof(struct __GLbufferRec));
    pblank();
    pequate("BUF_gc             ",OFFSET(struct __GLbufferRec,gc          ));
    pequate("BUF_width          ",OFFSET(struct __GLbufferRec,width       ));
    pequate("BUF_height         ",OFFSET(struct __GLbufferRec,height      ));
    pequate("BUF_depth          ",OFFSET(struct __GLbufferRec,depth       ));
    pequate("BUF_base           ",OFFSET(struct __GLbufferRec,base        ));
    pequate("BUF_size           ",OFFSET(struct __GLbufferRec,size        ));
    pequate("BUF_elementSize    ",OFFSET(struct __GLbufferRec,elementSize ));
    pequate("BUF_outerWidth     ",OFFSET(struct __GLbufferRec,outerWidth  ));
    pequate("BUF_xOrigin        ",OFFSET(struct __GLbufferRec,xOrigin     ));
    pequate("BUF_yOrigin        ",OFFSET(struct __GLbufferRec,yOrigin     ));
    pequate("BUF_other          ",OFFSET(struct __GLbufferRec,other       ));
    pblank();
    pblank();


    pcomment("__GLcolorBufferRec structure");
    pblank();
    pstruct("GLcolorBufferRec",sizeof(struct __GLcolorBufferRec));
    pblank();
    pequate("CBUF_redMax        ",OFFSET(struct __GLcolorBufferRec,redMax     ));
    pequate("CBUF_greenMax      ",OFFSET(struct __GLcolorBufferRec,greenMax   ));
    pequate("CBUF_blueMax       ",OFFSET(struct __GLcolorBufferRec,blueMax    ));
    pequate("CBUF_iRedScale     ",OFFSET(struct __GLcolorBufferRec,iRedScale  ));
    pequate("CBUF_iGreenScale   ",OFFSET(struct __GLcolorBufferRec,iGreenScale));
    pequate("CBUF_iBlueScale    ",OFFSET(struct __GLcolorBufferRec,iBlueScale ));
    pequate("CBUF_iAlphaScale   ",OFFSET(struct __GLcolorBufferRec,iAlphaScale));
    pequate("CBUF_iRedShift     ",OFFSET(struct __GLcolorBufferRec,redShift  ));
    pequate("CBUF_iGreenShift   ",OFFSET(struct __GLcolorBufferRec,greenShift));
    pequate("CBUF_iBlueShift    ",OFFSET(struct __GLcolorBufferRec,blueShift ));
    pequate("CBUF_iAlphaShift   ",OFFSET(struct __GLcolorBufferRec,alphaShift));
    pequate("CBUF_sourceMask    ",OFFSET(struct __GLcolorBufferRec,sourceMask ));
    pequate("CBUF_destMask      ",OFFSET(struct __GLcolorBufferRec,destMask   ));
    pequate("CBUF_other         ",OFFSET(struct __GLcolorBufferRec,other      ));
    pblank();
    pblank();


// Stuff from: \nt\private\windows\gdi\opengl\server\inc\attrib.h


    pcomment("__GLdepthStateRec structure");
    pblank();
    pstruct("GLdepthStateRec",sizeof(struct __GLdepthStateRec));
    pblank();
    pequate("DEPTH_testFunc     ",OFFSET(struct __GLdepthStateRec,testFunc   ));
    pequate("DEPTH_writeEnable  ",OFFSET(struct __GLdepthStateRec,writeEnable));
    pblank();
    pblank();

    pcomment("__GLattributeRec structure");
    pblank();
    pstruct("GLattributeRec",sizeof(struct __GLattributeRec));
    pblank();
    pequate("ATTR_polygonStipple",OFFSET(struct __GLattributeRec,polygonStipple));
    pequate("ATTR_depth         ",OFFSET(struct __GLattributeRec,depth));
    pequate("ATTR_enables       ",OFFSET(struct __GLattributeRec,enables));
    pequate("ATTR_raster        ",OFFSET(struct __GLattributeRec,raster));
    pequate("ATTR_hints         ",OFFSET(struct __GLattributeRec,hints));
    pblank();
    pblank();


// Stuff from: \nt\private\windows\gdi\opengl\server\inc\context.h

    pcomment("__GLcontextConstantsRec structure");
    pblank();
    pstruct("GLcontextConstantsRec",sizeof(struct __GLcontextConstantsRec));
    pblank();
    pequate("CTXCONST_viewportXAdjust",OFFSET(struct __GLcontextConstantsRec,viewportXAdjust));
    pequate("CTXCONST_viewportYAdjust",OFFSET(struct __GLcontextConstantsRec,viewportYAdjust));
    pequate("CTXCONST_width          ",OFFSET(struct __GLcontextConstantsRec,width));
    pequate("CTXCONST_height         ",OFFSET(struct __GLcontextConstantsRec,height));


    pcomment("__GLcontextRec structure");
    pblank();
    pstruct("GLcontextRec",sizeof(struct __GLcontextRec));
    pblank();
    pequate("CTX_gcState        ",OFFSET(struct __GLcontextRec,gcState    ));
    pequate("CTX_state          ",OFFSET(struct __GLcontextRec,state      ));
    pequate("CTX_renderMode     ",OFFSET(struct __GLcontextRec,renderMode ));
    pequate("CTX_modes          ",OFFSET(struct __GLcontextRec,modes      ));
    pequate("CTX_constants      ",OFFSET(struct __GLcontextRec,constants  ));
    pequate("CTX_drawBuffer     ",OFFSET(struct __GLcontextRec,drawBuffer ));
    pequate("CTX_readBuffer     ",OFFSET(struct __GLcontextRec,readBuffer ));
    pequate("CTX_polygon        ",OFFSET(struct __GLcontextRec,polygon    ));
    pequate("CTX_pixel          ",OFFSET(struct __GLcontextRec,pixel      ));
    pblank();
    pblank();


// Stuff from: \nt\private\windows\gdi\opengl\server\inc\gencx.h

    pcomment("__GLGENcontextRec structure");
    pblank();
    pstruct("GLGENcontextRec",sizeof(struct __GLGENcontextRec));
    pblank();
    pequate("GENCTX_hrc               ",OFFSET(struct __GLGENcontextRec,hrc       ));
    pequate("GENCTX_CurrentDC         ",OFFSET(struct __GLGENcontextRec,CurrentDC ));
    pequate("GENCTX_CurrentFormat     ",OFFSET(struct __GLGENcontextRec,CurrentFormat ));    
    pequate("GENCTX_iDCType           ",OFFSET(struct __GLGENcontextRec,iDCType   ));
    pequate("GENCTX_iSurfType         ",OFFSET(struct __GLGENcontextRec,iSurfType ));
    pequate("GENCTX_ColorsBits        ",OFFSET(struct __GLGENcontextRec,ColorsBits));
    pequate("GENCTX_pajTranslateVector",OFFSET(struct __GLGENcontextRec,pajTranslateVector));
    pequate("GENCTX_pPrivateArea      ",OFFSET(struct __GLGENcontextRec,pPrivateArea));
    pblank();
    pblank();

    pcomment("SPANREC structure");
    pblank();
    pstruct("SPANREC",sizeof(SPANREC));
    pblank();
    pequate("SPANREC_r               ",OFFSET(SPANREC,r       ));
    pequate("SPANREC_g               ",OFFSET(SPANREC,g       ));
    pequate("SPANREC_b               ",OFFSET(SPANREC,b       ));
    pequate("SPANREC_a               ",OFFSET(SPANREC,a       ));
    pequate("SPANREC_z               ",OFFSET(SPANREC,z       ));
    pblank();
    pblank();

    pcomment("GENACCEL structure");
    pblank();
    pstruct("GENACCEL",sizeof(GENACCEL));
    pblank();
    pequate("SURFACE_TYPE_DIB   ",SURFACE_TYPE_DIB);
    pblank();
    pequate("GENACCEL_spanDelta             ",
        OFFSET(GENACCEL,spanDelta                ));
    pequate("GENACCEL_flags                 ",
        OFFSET(GENACCEL,flags                    ));
    pequate("GENACCEL_fastSpanFuncPtr       ",
        OFFSET(GENACCEL,__fastSpanFuncPtr ));
    pequate("GENACCEL_fastFlatSpanFuncPtr   ",
        OFFSET(GENACCEL,__fastFlatSpanFuncPtr ));
    pequate("GENACCEL_fastSmoothSpanFuncPtr ",
        OFFSET(GENACCEL,__fastSmoothSpanFuncPtr ));
    pequate("GENACCEL_fastZSpanFuncPtr      ",
        OFFSET(GENACCEL,__fastZSpanFuncPtr));
    pblank();
    pblank();
#endif
    
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\buffers.h ===
#ifndef __glbuffers_h_
#define	__glbuffers_h_

/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/
#include "render.h"
#include "parray.h"
#include "procs.h"

typedef struct __GLbufferMachineRec {
    /*
    ** GL_TRUE if store procs need to call gc->front->store and 
    ** gc->back->store in order to store one fragment (only TRUE if 
    ** drawBuffer is GL_FRONT_AND_BACK).  This is needed because many
    ** frame buffers can draw to both front and back under some conditions
    ** (like when not blending), but not under other conditions.
    */
    GLboolean doubleStore;
} __GLbufferMachine;

/************************************************************************/

/*
** Generic buffer description.  This description is used for software
** and hardware buffers of all kinds.
*/
struct __GLbufferRec {
    /*
    ** Which context is using this buffer.
    */
    __GLcontext *gc;

    /*
    ** Dimensions of the buffer.
    */
    GLint width, height, depth;

    /*
    ** Base of framebuffer.
    */
    void* base;

    /*
    ** Number of bytes consumed by the framebuffer.
    */
    GLuint size;

    /*
    ** Size of each element in the framebuffer.
    */
    GLuint elementSize;

    /*
    ** If this buffer is part of a larger (say full screen) buffer
    ** then this is the size of that larger buffer.  Otherwise it is
    ** just a copy of width.
    */
    GLint outerWidth;

    /*
    ** If this buffer is part of a larger (say full screen) buffer
    ** then these are the location of this buffer in the larger
    ** buffer.
    */
    GLint xOrigin, yOrigin;

    /*
    ** Flags.
    */
    GLuint flags;
};

/*
** Generic address macro for a buffer.  Coded to assume that
** the buffer is not part of a larger buffer.
** The input coordinates x,y are biased by the x & y viewport
** adjusts in gc->transform, and thus they need to be de-adjusted
** here.
*/
#define	__GL_FB_ADDRESS(fb,cast,x,y) \
    ((cast (fb)->buf.base) \
	+ ((y) - (fb)->buf.gc->constants.viewportYAdjust) \
            * (fb)->buf.outerWidth \
	+ (x) - (fb)->buf.gc->constants.viewportXAdjust)

extern void __glResizeBuffer(__GLGENbuffers *buffers, __GLbuffer *buf,
			     GLint w, GLint h);
extern void FASTCALL __glInitGenericCB(__GLcontext *gc, __GLcolorBuffer *cfb);

/************************************************************************/

struct __GLalphaBufferRec {
    __GLbuffer buf;
    __GLfloat alphaScale;
    void (FASTCALL *store)
        (__GLalphaBuffer *afb, GLint x, GLint y, const __GLcolor *color);
    void (FASTCALL *storeSpan) (__GLalphaBuffer *afb);
    void (FASTCALL *storeSpan2)
        (__GLalphaBuffer *afb, GLint x, GLint y, GLint w, __GLcolor *colors );
    void (FASTCALL *fetch)
        (__GLalphaBuffer *afb, GLint x, GLint y, __GLcolor *result);
    void (FASTCALL *readSpan)
        (__GLalphaBuffer *afb, GLint x, GLint y, GLint w, __GLcolor *results);
    void (FASTCALL *clear)(__GLalphaBuffer *afb);
};

/************************************************************************/

struct __GLcolorBufferRec {
    __GLbuffer buf;
    __GLalphaBuffer alphaBuf;

    GLint redMax;
    GLint greenMax;
    GLint blueMax;
    GLint alphaMax; // XXX not used, just here for consistency with rgb

    /*
    ** Color component scale factors.  Given a component value between
    ** zero and one, this scales the component into a zero-N value
    ** which is suitable for usage in the color buffer.  Note that these
    ** values are not necessarily the same as the max values above,
    ** which define precise bit ranges for the buffer.  These values
    ** are never zero, for instance.
    **/
    __GLfloat redScale;
    __GLfloat greenScale;
    __GLfloat blueScale;

    /* Integer versions of above */
    GLint iRedScale;
    GLint iGreenScale;
    GLint iBlueScale;

    /* Used primarily by pixmap code */
    GLint redShift;
    GLint greenShift;
    GLint blueShift;
    GLint alphaShift;
#ifdef NT
    GLuint allShifts;
#endif

    /*
    ** Alpha is treated a little bit differently.  alphaScale and
    ** iAlphaScale are used to define a range of alpha values that are
    ** generated during various rendering steps.  These values will then
    ** be used as indices into a lookup table to see if the alpha test
    ** passes or not.  Because of this, the number should be fairly large
    ** (e.g., one is not good enough).
    */
    __GLfloat alphaScale;
    GLint iAlphaScale;

    __GLfloat oneOverRedScale;
    __GLfloat oneOverGreenScale;
    __GLfloat oneOverBlueScale;
    __GLfloat oneOverAlphaScale;

    /*
    ** Color mask state for the buffer.  When writemasking is enabled
    ** the source and dest mask will contain depth depedent masking.
    */
    GLuint sourceMask, destMask;

    /*
    ** This function updates the internal procedure pointers based
    ** on a state change in the context.
    */
    void (FASTCALL *pick)(__GLcontext *gc, __GLcolorBuffer *cfb);

    /*
    ** When the buffer needs resizing this procedure should be called.
    */
    void (*resize)(__GLGENbuffers *buffers, __GLcolorBuffer *cfb, 
		   GLint w, GLint h);

    /*
    ** Store a fragment into the buffer.  For color buffers, the
    ** procedure will optionally dither, writemask, blend and logic op
    ** the fragment before final storage.
    */
    void (FASTCALL *store)(__GLcolorBuffer *cfb, const __GLfragment *frag);

    /*
    ** Fetch a color from the buffer.  This returns the r, g, b and a
    ** values for an RGB buffer.  For an index buffer the "r" value
    ** returned is the index.
    */
    void (*fetch)(__GLcolorBuffer *cfb, GLint x, GLint y,
		  __GLcolor *result);

    /*
    ** Similar to fetch, except that the data is always read from
    ** the current read buffer, not from the current draw buffer.
    */
    void (*readColor)(__GLcolorBuffer *cfb, GLint x, GLint y,
		      __GLcolor *result);
    void (*readSpan)(__GLcolorBuffer *cfb, GLint x, GLint y,
		          __GLcolor *results, GLint w);

    /*
    ** Return a span of data from the accumulation buffer into the
    ** color buffer(s), multiplying by "scale" before storage.
    */
    void (*returnSpan)(__GLcolorBuffer *cfb, GLint x, GLint y,
		       const __GLaccumCell *acbuf, __GLfloat scale, GLint w);

    /*
    ** Store a span (line) of colors into the color buffer.  A minimal
    ** implementation need only copy the values directly into
    ** the framebuffer, assuming that the PickSpanProcs is providing
    ** software implementations of all of the modes.
    */
    __GLspanFunc storeSpan;
    __GLstippledSpanFunc storeStippledSpan;
    __GLspanFunc storeLine; 
    __GLstippledSpanFunc storeStippledLine;

    /*
    ** Read a span (line) of colors from the color buffer.  The returned
    ** format is in the same format used for storage.
    */
    __GLspanFunc fetchSpan;
    __GLstippledSpanFunc fetchStippledSpan;
    __GLspanFunc fetchLine;
    __GLstippledSpanFunc fetchStippledLine;

    /*
    ** Clear the scissor area of the color buffer, clipped to
    ** the window size.  Apply dithering if enabled.
    */
    void (FASTCALL *clear)(__GLcolorBuffer *cfb);

    /*
    ** Pointer to bitmap information.
    */
    struct __GLGENbitmapRec *bitmap;
};

/* generic span read routine */
extern GLboolean __glReadSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
			      __GLcolor *results, GLint w);

/* generic accum return span routine */
extern void __glReturnSpan(__GLcolorBuffer *cfb, GLint x, GLint y,
			   const __GLaccumCell *ac, __GLfloat scale,
			   GLint w);

/* generic span fetch routine */
extern GLboolean FASTCALL __glFetchSpan(__GLcontext *gc);

/************************************************************************/

struct __GLdepthBufferRec {
    __GLbuffer buf;

    GLuint writeMask;

    /*
    ** Scale factor used to convert users ZValues (0.0 to 1.0, inclusive)
    ** into this depth buffers range.
    */
    GLuint scale;

    /*
    ** This function updates the internal procedure pointers based
    ** on a state change in the context.
    */
    void (FASTCALL *pick)(__GLcontext *gc, __GLdepthBuffer *dfb, GLint depthIndex );

    /*
    ** Attempt to update the depth buffer using z.  If the depth function
    ** passes then the depth buffer is updated and True is returned,
    ** otherwise False is returned.  The caller is responsible for
    ** updating the stencil buffer.
    */

    GLboolean (*store)(__GLdepthBuffer *dfb, GLint x, GLint y, __GLzValue z);

    /*
    ** Clear the scissor area of the buffer clipped to the window
    ** area.  No other modes apply.
    */
    void (FASTCALL *clear)(__GLdepthBuffer *dfb);

    /*
    ** Direct access routines used by ReadPixels(), WritePixels(), 
    ** CopyPixels().
    */
    GLboolean (*store2)(__GLdepthBuffer *dfb, GLint x, GLint y, __GLzValue z);
    __GLzValue (FASTCALL *fetch)(__GLdepthBuffer *dfb, GLint x, GLint y);

    /*
    ** When using MCD, depth values are passed to the MCD driver via a
    ** 32-bit depth scanline buffer.  The normal store proc, for 16-bit
    ** MCD depth buffers, will translate an incoming 16-bit depth value
    ** into a 32-bit value before copying it into the scanline buffer.
    **
    ** However, some code paths (such as the generic MCD line code)
    ** already do all computations in 32-bit no matter what the MCD
    ** depth buffer size.  These code paths need a proc to write their
    ** values untranslated.
    **
    ** The storeRaw proc will store the incoming z value without any
    ** translation.
    */

    GLboolean (*storeRaw)(__GLdepthBuffer *dfb, GLint x, GLint y, __GLzValue z);
};

#define	__GL_DEPTH_ADDR(a,b,c,d) __GL_FB_ADDRESS(a,b,c,d)

/************************************************************************/

struct __GLstencilBufferRec {
    __GLbuffer buf;

    /*
    ** Stencil test lookup table.  The stencil buffer value is masked
    ** against the stencil mask and then used as an index into this
    ** table which contains either GL_TRUE or GL_FALSE for the
    ** index.
    */
    GLboolean *testFuncTable;

    /*
    ** Stencil op tables.  These tables contain the new stencil buffer
    ** value given the old stencil buffer value as an index.
    */
    __GLstencilCell *failOpTable;
    __GLstencilCell *depthFailOpTable;
    __GLstencilCell *depthPassOpTable;

    /*
    ** This function updates the internal procedure pointers based
    ** on a state change in the context.
    */
    void (FASTCALL *pick)(__GLcontext *gc, __GLstencilBuffer *sfb);

    /*
    ** Store a fragment into the buffer.
    */
    void (*store)(__GLstencilBuffer *sfb, GLint x, GLint y,
		  GLint value);

    /* 
    ** Fetch a value.
    */
    GLint (FASTCALL *fetch)(__GLstencilBuffer *sfb, GLint x, GLint y);

    /*
    ** Return GL_TRUE if the stencil test passes.
    */
    GLboolean (FASTCALL *testFunc)(__GLstencilBuffer *sfb, GLint x, GLint y);

    /*
    ** Apply the stencil ops to this position.
    */
    void (FASTCALL *failOp)(__GLstencilBuffer *sfb, GLint x, GLint y);
    void (FASTCALL *passDepthFailOp)(__GLstencilBuffer *sfb, GLint x, GLint y);
    void (FASTCALL *depthPassOp)(__GLstencilBuffer *sfb, GLint x, GLint y);

    /*
    ** Clear the scissor area of the buffer clipped to the window
    ** area.  No other modes apply.
    */
    void (FASTCALL *clear)(__GLstencilBuffer *sfb);
};

#define	__GL_STENCIL_ADDR(a,b,c,d) __GL_FB_ADDRESS(a,b,c,d)

/************************************************************************/

struct __GLaccumBufferRec {
    __GLbuffer buf;

    /*
    ** Scaling factors to convert from color buffer values to accum
    ** buffer values.
    */
    __GLfloat redScale;
    __GLfloat greenScale;
    __GLfloat blueScale;
    __GLfloat alphaScale;

    __GLfloat oneOverRedScale;
    __GLfloat oneOverGreenScale;
    __GLfloat oneOverBlueScale;
    __GLfloat oneOverAlphaScale;

    __GLuicolor shift, mask, sign; // Cache of commonly used values
    __GLcolor *colors;  // Temporary scanline buffer ptr
    /*
    ** This function updates the internal procedure pointers based
    ** on a state change in the context.
    */
    void (FASTCALL *pick)(__GLcontext *gc, __GLaccumBuffer *afb);

    /*
    ** Clear a rectangular region in the buffer.  The scissor area is
    ** cleared.
    */
    void (FASTCALL *clear)(__GLaccumBuffer *afb);

    /*
    ** Accumulate data into the accum buffer.
    */
    void (*accumulate)(__GLaccumBuffer *afb, __GLfloat value);

    /*
    ** Load data into the accum buffer.
    */
    void (*load)(__GLaccumBuffer *afb, __GLfloat value);

    /*
    ** Return data from the accum buffer to the current framebuffer.
    */
    void (*ret)(__GLaccumBuffer *afb, __GLfloat value);

    /*
    ** Multiply the accum buffer by the value.
    */
    void (*mult)(__GLaccumBuffer *afb, __GLfloat value);


    /*
    ** Add the value to the accum buffer.
    */
    void (*add)(__GLaccumBuffer *afb, __GLfloat value);
};

#define	__GL_ACCUM_ADDRESS(a,b,c,d) __GL_FB_ADDRESS(a,b,c,d)

/************************************************************************/

extern void FASTCALL __glInitAccum64(__GLcontext *gc, __GLaccumBuffer *afb);
extern void FASTCALL __glFreeAccum64(__GLcontext *gc, __GLaccumBuffer *afb);
extern void FASTCALL __glInitAccum32(__GLcontext *gc, __GLaccumBuffer *afb);

extern void FASTCALL __glInitCI4(__GLcontext *gc, __GLcolorBuffer *cfb);
extern void FASTCALL __glInitCI8(__GLcontext *gc, __GLcolorBuffer *cfb);
extern void FASTCALL __glInitCI16(__GLcontext *gc, __GLcolorBuffer *cfb);

extern void FASTCALL __glInitStencil8(__GLcontext *gc, __GLstencilBuffer *sfb);
extern void FASTCALL __glInitAlpha(__GLcontext *gc, __GLcolorBuffer *cfb);
extern void FASTCALL __glFreeStencil8(__GLcontext *gc, __GLstencilBuffer *sfb);

#ifdef NT
extern void FASTCALL __glInitDepth16(__GLcontext *gc, __GLdepthBuffer *dfb);
#endif
extern void FASTCALL __glInitDepth32(__GLcontext *gc, __GLdepthBuffer *dfb);
extern void FASTCALL __glFreeDepth32(__GLcontext *gc, __GLdepthBuffer *dfb);

extern void FASTCALL __glClearBuffers(__GLcontext *gc, GLuint mask);

#endif /* __glbuffers_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\generic\i386\texspanr.asm ===
;---------------------------Module-Header------------------------------;
; Module Name: texspanr.asm
;
; Fast replace-mode texturing. 
;
; Created: 011/15/1995
; Author: Otto Berkes [ottob]
;
; Copyright (c) 1995 Microsoft Corporation
;----------------------------------------------------------------------;


rMask = ((1 SHL rBits) - 1) SHL rShift
gMask = ((1 SHL gBits) - 1) SHL gShift
bMask = ((1 SHL bBits) - 1) SHL bShift

rRightShiftAdj	= 16 - (rShift + rBits)
gRightShiftAdj	= 16 - (gShift + gBits)
bRightShiftAdj	= 16 - (bShift + bBits)

TMASK_SUBDIV equ [esi].GENGC_tMaskSubDiv
TSHIFT_SUBDIV equ [esi].GENGC_tShiftSubDiv

if FAST_REPLACE
    TEXPALETTE equ [esi].GENGC_texImageReplace
    if (PALETTE_ONLY)
        TEXIMAGE equ [esi].GENGC_texImage
    else
        TEXIMAGE equ [esi].GENGC_texImageReplace
    endif
    if PALETTE_ONLY
        TEX_BPP_LOG2 = 0
    elseif (BPP eq 8)
        TEX_BPP_LOG2 = 0
    else
        TEX_BPP_LOG2 = 1
    endif
else

.error

endif

if PALETTE_ONLY

HANDLE_PALETTE MACRO
mov	bl, [edx]				; V
and	ebx, 0ffh				;U
mov	edx, TEXPALETTE				; V
lea	edx, [edx+4*ebx]			;U
ENDM


HANDLE_PALETTEX MACRO
mov	al, [edx]				; V
and	eax, 0ffh				;U
mov	ebx, TEXPALETTE				; V
mov	edx, TEMP2				;U
lea	ebx, [ebx+4*eax]			; V
mov	TEMP2, edx				;U
GET_TEXEL_ACCUM					; V
						;U
ENDM

else

HANDLE_PALETTE MACRO
ENDM

endif

TEMP	equ [esi].GENGC_sResult

;;
;;
;; Macros for advancing a single pixel unit
;;
;;


if (BPP eq 8)
PIXADVANCE MACRO var
inc	var
ENDM
elseif (BPP eq 16)
PIXADVANCE MACRO var
add	var, (BPP / 8)
ENDM
else
PIXADVANCE MACRO var
add	var, [esi].GENGC_bytesPerPixel
ENDM
endif

;;
;; Get pointer to current texel value in EDX:
;;

GET_TEXEL_ADDRESS MACRO

mov     eax, TMASK_SUBDIV                       ;U
mov     edx, [esi].GENGC_tResult                ; V
mov     ebx, [esi].GENGC_sResult                ;U
and     edx, eax                                ; V
shr     edx, (6-TEX_BPP_LOG2)                   ;U
mov     ecx, [esi].GENGC_sMask                  ; V
and     ebx, ecx                                ;U
mov	eax, DWORD PTR [esi].GENGC_sResult      ; V
shr     ebx, (16-TEX_BPP_LOG2)                  ;U
mov	ecx, [esi].GENGC_subDs                  ; V
add	eax, ecx				;U
add     edx, ebx			        ; V
mov     ecx, TEXIMAGE                           ;U
mov	ebx, [esi].GENGC_subDt                  ; V
add     edx, ecx                                ;U
mov	ecx, DWORD PTR [esi].GENGC_tResult      ; V
add	ecx, ebx				;U
mov     DWORD PTR [esi].GENGC_sResult, eax      ; V
mov     DWORD PTR [esi].GENGC_tResult, ecx      ;U
HANDLE_PALETTE

ENDM

if (BPP eq 8)
GET_TEXEL MACRO
mov	al, [edx]				; V get texel value
ENDM
elseif (BPP eq 16)
GET_TEXEL MACRO
mov	ax, [edx]
ENDM
endif


GET_TEXEL_ADDRESS2 MACRO count

;; input : ecx = GENGC_tResult, edi = GENGC_sResult
;; output: edx = final texel address
;; free  : ebx, edx are free

mov     ebx, TMASK_SUBDIV			;U
mov     edx, ecx				; V
mov	TEMP, eax				;U
and     edx, ebx                                ; V
mov	eax, edi				;U
mov	ebx, [esi].GENGC_sMask                  ; V
shr     edx, (6-TEX_BPP_LOG2)                   ;U
and	eax, ebx				; V
shr	eax, (16-TEX_BPP_LOG2)			;U
mov	ebx, TEXIMAGE				; V
add     edx, eax			        ;U
mov	eax, [esi].GENGC_subDs			; V
add	edx, ebx				;U
add	edi, eax				; V
mov	ebx, [esi].GENGC_subDt			;U
mov	eax, TEMP				; V
add	ecx, ebx				;U
HANDLE_PALETTE

ENDM

if (BPP eq 8)
GET_TEXEL_ACCUM MACRO
mov	al, [edx]				; V get texel value
ror	eax, BPP				;U
ENDM
elseif (BPP eq 16)
GET_TEXEL_ACCUM MACRO
mov	ax, [edx]
ror	eax, BPP
ENDM
endif


if (BPP eq 8)
WRITE_TEXEL_DECEBP MACRO
mov	al, [edx]
dec	ebp
mov	[edi-1], al
ENDM
elseif (BPP eq 16)
WRITE_TEXEL_DECEBP MACRO
mov	ax, [edx]
dec	ebp
mov	[edi-2], ax
ENDM
endif



;;----------------------------------------------------------------------
;;
;; This is the start of the texture routine.  Kick off the divide, and use
;; the dead time to set up all of the accumulators and other variables.
;;
;;----------------------------------------------------------------------

;;
;; Start the divide:
;;

mov	eax, [ecx].GENGC_flags
  fld	DWORD PTR [ecx].GENGC_SPAN_qw                   ;qwAccum
  fld	DWORD PTR [ecx].GENGC_SPAN_qw                   ;qwAccum qwAccum
test	eax, GEN_TEXTURE_ORTHO
jne	@f
  fdivr	__One			                        ;1/qw qwAccum
@@:

;;
;; Save the registers that we need to:
;;

push	ebx						;U
push	esi						; V
push	edi						;U
push	ebp						; V

mov	esi, ecx					;U

;;
;; Set up accumulators:
;;

mov     eax, [ecx].GENGC_SPAN_s				; V
mov     ebx, [ecx].GENGC_SPAN_t				;U
mov     [ecx].GENGC_sAccum, eax				; V
mov     [esi].GENGC_tAccum, ebx				;U
mov     ecx, [esi].GENGC_SPAN_qw                        ; V
mov	edi, [esi].GENGC_SPAN_ppix			;U
mov     [esi].GENGC_qwAccum, ecx			; V
mov	eax, [esi].GENGC_flags                          ;U
mov	ebx, [esi].GENGC_SPAN_x				; V
test	eax, SURFACE_TYPE_DIB		                ;U
jne	@f						; V
mov	edi, [esi].GENGC_ColorsBits			;U
jmp	short @pixAccumDone
@@:
if (BPP eq 8)
add	edi, ebx                                        ; V
elseif (BPP eq 16)
lea	edi, [edi + 2*ebx]
endif

@pixAccumDone:

mov	ebp, [esi].GENGC_SPAN_length			;U

;;
;; Before we get into the main loop, do pixel-by-pixel writes until
;; we're DWORD aligned:
;;

test	edi, 3
je	alignmentDone

getAligned:

test    eax, GEN_TEXTURE_ORTHO
je      @f

mov     edx, [esi].GENGC_sAccum
mov     eax, [esi].GENGC_tAccum
mov     DWORD PTR [esi].GENGC_sResult, edx
mov     DWORD PTR [esi].GENGC_tResult, eax
jmp     short @stResultDone1

@@:

  fild	DWORD PTR [esi].GENGC_sAccum	; s 1/qw qwAccum
  fmul	ST, ST(1)			; s/qw 1/qw qwAccum
  fild	DWORD PTr [esi].GENGC_tAccum	; t s/qw 1/qw qwAccum
  fmulp	ST(2), ST			; s/qw t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_sResult	; t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_tResult	; qwAccum
  fadd	DWORD PTR [esi].GENGC_SPAN_dqwdx; qwAccum
  fld	ST(0)				; qwAccum qwAccum
  fdivr	__One			        ; 1/qw qwAccum

@stResultDone1:

mov	cl, TSHIFT_SUBDIV       		;U
mov	edx, [esi].GENGC_tResult		; V
sar	edx, cl					;UV (4)
and	edx, NOT 7				;U
mov     ebx, [esi].GENGC_sResult        	; V
mov	[esi].GENGC_tResult, edx		;U
and     edx, TMASK_SUBDIV                       ; V
shr     edx, (6-TEX_BPP_LOG2)                   ;U
and     ebx, [esi].GENGC_sMask                  ; V
shr     ebx, (16-TEX_BPP_LOG2)                  ;U
mov	ecx, TEXIMAGE				; V
add     edx, ecx    	                        ;U
PIXADVANCE edi					; V
add     edx, ebx			        ;U
HANDLE_PALETTE


mov	eax, [esi].GENGC_sAccum			; V
mov	ebx, [esi].GENGC_tAccum			;U
add	eax, [esi].GENGC_SPAN_ds		; V
add	ebx, [esi].GENGC_SPAN_dt		;U
mov	[esi].GENGC_sAccum, eax			; V
mov	[esi].GENGC_tAccum, ebx			;U

WRITE_TEXEL_DECEBP

jle	spanExit			; V
test	edi, 3
mov     eax, [esi].GENGC_flags
jne	getAligned

alignmentDone:

;;
;; Kick off the next divide:
;;

test    eax, GEN_TEXTURE_ORTHO
je      @f

mov     edx, [esi].GENGC_sAccum
mov     eax, [esi].GENGC_tAccum
mov     DWORD PTR [esi].GENGC_sResult, edx
mov     DWORD PTR [esi].GENGC_tResult, eax
jmp     short @stResultDone2

@@:

  fild	DWORD PTR [esi].GENGC_sAccum	; s 1/qw qwAccum
  fmul	ST, ST(1)			; s/qw 1/qw qwAccum
  fild	DWORD PTr [esi].GENGC_tAccum	; t s/qw 1/qw qwAccum
  fmulp	ST(2), ST			; s/qw t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_sResult	; t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_tResult	; qwAccum
  fadd	DWORD PTR [esi].GENGC_qwStepX	; qwAccum
  fld	ST(0)				; qwAccum qwAccum
  fdivr	__One			        ; 1/qw qwAccum

@stResultDone2:

mov	eax, [esi].GENGC_sAccum				; V
mov	ebx, [esi].GENGC_tAccum				;U
add	eax, [esi].GENGC_sStepX				; V
add	ebx, [esi].GENGC_tStepX				;U
mov	[esi].GENGC_sAccum, eax				; V
mov	[esi].GENGC_tAccum, ebx				;U
mov	eax, [esi].GENGC_sResult			; V
mov	ebx, [esi].GENGC_tResult			;U
mov	cl, TSHIFT_SUBDIV       			; V
sar	ebx, cl						;UV (4)
and	ebx, NOT 7					;U
mov     ecx, [esi].GENGC_flags                     	; V
mov	[esi].GENGC_tResult, ebx			;U
test    ecx, GEN_TEXTURE_ORTHO                          ; V
je      @f

mov     ecx, [esi].GENGC_sAccum
mov     edx, [esi].GENGC_tAccum
mov     DWORD PTR [esi].GENGC_sResultNew, ecx
mov     DWORD PTR [esi].GENGC_tResultNew, edx
jmp     short @stResultDone3


;; We may have to burn some cycles here...

@@:

  fild	DWORD PTR [esi].GENGC_sAccum	; s 1/qw qwAccum
  fmul	ST, ST(1)			; s/qw 1/qw qwAccum
  fild	DWORD PTr [esi].GENGC_tAccum	; t s/qw 1/qw qwAccum
  fmulp	ST(2), ST			; s/qw t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_sResultNew; t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_tResultNew; qwAccum
  fadd	DWORD PTR [esi].GENGC_qwStepX	; qwAccum

@stResultDone3:

mov	cl, TSHIFT_SUBDIV       			;U
mov	edx, [esi].GENGC_tResultNew			; V
sar	edx, cl						;UV (4)
and	edx, NOT 7					;U
mov	ecx, [esi].GENGC_sResultNew			; V
mov	[esi].GENGC_tResultNew, edx			;U
sub	ecx, eax					; V
sar	ecx, 3						;U
sub	edx, ebx					; V
sar	edx, 3						;U
mov	[esi].GENGC_subDs, ecx				; V
mov	[esi].GENGC_subDt, edx				;U

;;
;; 
;;

;; If we have fewer than 4 (or 2) pixels, just do right edge...

if (BPP eq 8)
test	ebp, 0fffch			;U
else
test	ebp, 0fffeh			;U
endif
je	singlePixels

add	ebp, 070000h

mov	[esi].GENGC_pixAccum, edi
mov	ecx, [esi].GENGC_tResult
mov	eax, [esi].GENGC_flags
mov	edi, [esi].GENGC_sResult

loopTop:

;;
;; This is the start of the outer loop.  We come back here on each
;; subdivision.  The key thing is to kick off the next divide:
;;

test	eax, GEN_TEXTURE_ORTHO
jne	@f

  fld	ST(0)				; qwAccum qwAccum    
  fadd	DWORD PTR [esi].GENGC_qwStepX	; qwAccum+ qwAccum
  fxch	ST(1)				; qwAccum qwAccum+
  fdivr	__One				; 1/qw qwAccum+  -- let the divide rip!

@@:

loopTopNoDiv:

;; If we have fewer than 4 (or 2) pixels, just do right edge...

if (BPP eq 8)

GET_TEXEL_ADDRESS2
GET_TEXEL_ACCUM
GET_TEXEL_ADDRESS2
GET_TEXEL_ACCUM
GET_TEXEL_ADDRESS2
GET_TEXEL_ACCUM
GET_TEXEL_ADDRESS2
mov	ebx, [esi].GENGC_pixAccum	; V
add	ebx, 4				;U
GET_TEXEL_ACCUM				; V
					;U
sub	ebp, 040004h			; V
mov	[esi].GENGC_pixAccum, ebx	;U
mov	[ebx-4], eax			; V

else

GET_TEXEL_ADDRESS2
GET_TEXEL_ACCUM
GET_TEXEL_ADDRESS2
mov	ebx, [esi].GENGC_pixAccum
add	ebx, 4
GET_TEXEL_ACCUM
sub	ebp, 020002h
mov	[esi].GENGC_pixAccum, ebx
mov	[ebx-4], eax

endif


jle	doSubDiv			;U
if (BPP eq 8)
test	ebp, 0fffch			; V
else
test	ebp, 0fffeh
endif
je	doRightEdgePixels		;U
jmp	loopTopNoDiv                    ; V


doRightEdgePixels:

test	ebp, 0ffffh			; V
je	spanExit			;U

mov	[esi].GENGC_sResult, edi
mov	[esi].GENGC_tResult, ecx
mov	edi, [esi].GENGC_pixAccum

rightEdgePixels:

PIXADVANCE edi				;U

GET_TEXEL_ADDRESS
GET_TEXEL

if (BPP eq 8)
sub	ebp, 010001h			;U
mov	[edi-1], al			; V
elseif (BPP eq 16)
sub	ebp, 010001h
mov	[edi-2], ax
endif

test	ebp, 0ffffh			;U
jne	rightEdgePixels			; V

;;
;; This is the exit point.  We need to pop the unused floating-point
;; registers off the stack, and return:
;;

spanExit:

fstp	ST(0)
fstp	ST(0)

pop	ebp
pop	edi
pop	esi
pop	ebx

ret	0


singlePixels:

PIXADVANCE edi				;U

GET_TEXEL_ADDRESS
GET_TEXEL

dec	ebp

if (BPP eq 8)
mov	[edi-1], al			; V
elseif (BPP eq 16)
mov	[edi-2], ax
endif

jg	singlePixels			; V

;;
;; This is the exit point.  We need to pop the unused floating-point
;; registers off the stack, and return:
;;

fstp	ST(0)
mov	eax, [esi].GENGC_flags
pop	ebp
pop	edi
pop	esi
pop	ebx
test	eax, GEN_TEXTURE_ORTHO
je	@f
fstp	ST(0)
@@:

ret	0



;;
;; This is the subdivision code.  After the required number of steps, the
;; routine will jump here to calculate the next set of interpolants based
;; on subdivision:
;;

doSubDiv:

add	ebp, 080000h

mov	eax, [esi].GENGC_sAccum

if (BPP eq 8)
test	ebp, 0fffch			; V
else
test	ebp, 0fffeh
endif
je	doRightEdgePixels		;U

test	ebp, 0ffffh
je	spanExit

mov	ecx, [esi].GENGC_flags

mov	ebx, [esi].GENGC_tAccum

;;
;; Increment the big S and T steps:
;;

add	eax, [esi].GENGC_sStepX
add	ebx, [esi].GENGC_tStepX
mov	[esi].GENGC_sAccum, eax
mov	[esi].GENGC_tAccum, ebx
mov	edi, [esi].GENGC_sResultNew
mov	ebx, [esi].GENGC_tResultNew

test	ecx, GEN_TEXTURE_ORTHO
je	@f

;;
;; Handle ortho case (easy)
;;

mov	edx, DWORD PTR [esi].GENGC_tAccum
mov	DWORD PTR [esi].GENGC_sResultNew, eax
mov	DWORD PTR [esi].GENGC_tResultNew, edx
jmp	short @stResultDone4

;;
;; Do the floating-point computation for perspective:
;;

@@:

  fild	DWORD PTR [esi].GENGC_sAccum	; s 1/qw qwAccum
  fmul	ST, ST(1)			; s/qw 1/qw qwAccum
  fild	DWORD PTr [esi].GENGC_tAccum	; t s/qw 1/qw qwAccum
  fmulp	ST(2), ST			; s/qw t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_sResultNew; t/qw qwAccum
  fistp	QWORD PTR [esi].GENGC_tResultNew; qwAccum

@stResultDone4:

;;
;; Now, calculate the per-pixel deltas:
;;

mov	cl, TSHIFT_SUBDIV       	;U
mov	edx, [esi].GENGC_tResultNew	; V
sar	edx, cl				;UV (4)
mov	ecx, [esi].GENGC_sResultNew	;U
and	edx, NOT 7			; V
sub	ecx, edi			;U
mov	[esi].GENGC_tResultNew, edx	; V
sar	ecx, 3				;U
sub	edx, ebx			; V
sar	edx, 3				;U
mov	[esi].GENGC_subDs, ecx		; V
mov	[esi].GENGC_subDt, edx		;U
mov	ecx, ebx			; V
mov	eax, [esi].GENGC_flags		;U
jmp	loopTop                         ; V
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\constant.h ===
#ifndef __glconstants_h_
#define __glconstants_h_

/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
*/

/*
** Some pixel code depends upon this constant in deciding what the longest
** horizontal span of a DrawPixels command can possibly be.  With 2048, it
** is allocating an array of size 32K.  If this constant increases too much,
** then the pixel code might need to be revisited.
*/
#define __GL_MAX_MAX_VIEWPORT		16384

/*
** The following is the maximum number of __GLcolor structures to allocate on
** the stack.  It is set to keep a maximum of 1K bytes allocated on the stack
*/
#define __GL_MAX_STACKED_COLORS         64

#endif /* __glconstants_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\attrib.h ===
#ifndef __glattrib_h_
#define __glattrib_h_

/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** $Revision: 1.14 $
** $Date: 1993/10/07 18:34:31 $
*/
#include "lighting.h"
#include "pixel.h"
#include "texture.h"
#include "eval.h"
#include "vertex.h"
#include "glarray.h"

typedef struct __GLcurrentStateRec {
    __GLvertex rasterPos;

    /*
    ** Raster pos valid bit.
    */
    GLboolean validRasterPos;

    /*
    ** Edge tag state.
    */
    GLboolean edgeTag;

    /*
    ** Current color and colorIndex.  These variables are also used for
    ** the current rasterPos color and colorIndex as set by the user.
    */
    __GLcolor userColor;
    __GLfloat userColorIndex;

    __GLcoord normal;
    __GLcoord texture;
} __GLcurrentState;

/************************************************************************/

typedef struct __GLpointStateRec {
    __GLfloat requestedSize;
    __GLfloat smoothSize;
    GLint aliasedSize;
} __GLpointState;

/************************************************************************/

/*
** Line state.  Contains all the client controllable line state.
*/
typedef struct {
    __GLfloat requestedWidth;
    __GLfloat smoothWidth;
    GLint aliasedWidth;
    GLushort stipple;
    GLshort stippleRepeat;
} __GLlineState;

/************************************************************************/

/*
** Polygon state.  Contains all the user controllable polygon state
** except for the stipple state.
*/
typedef struct __GLpolygonStateRec {
    GLenum frontMode;
    GLenum backMode;

    /*
    ** Culling state.  Culling can be enabled/disabled and set to cull
    ** front or back faces.  The FrontFace call determines whether clockwise
    ** or counter-clockwise oriented vertices are front facing.
    */
    GLenum cull;
    GLenum frontFaceDirection;

    /*
    ** Polygon offset state
    */
    __GLfloat factor;
    __GLfloat units;
} __GLpolygonState;

/************************************************************************/

/*
** Polygon stipple state.
*/
typedef struct __GLpolygonStippleStateRec {
    GLubyte stipple[4*32];
} __GLpolygonStippleState;

/************************************************************************/

typedef struct __GLfogStateRec {
    GLenum mode;
#ifdef NT
    GLuint flags;
#endif
    __GLcolor color;
#ifdef NT
    __GLfloat density2neg;
#endif
    __GLfloat density, start, end;
    __GLfloat oneOverEMinusS;
    __GLfloat index;
} __GLfogState;

// fog flags
// __GL_FOG_GRAY_RGB is set when the clamped and scaled fog color contains
// identical R, G, and B values
#define __GL_FOG_GRAY_RGB   0x0001

/************************************************************************/

/*
** Depth state.  Contains all the user settable depth state.
*/
typedef struct __GLdepthStateRec __GLdepthState;
struct __GLdepthStateRec {
    /*
    ** Depth buffer test function.  The z value is compared using zFunction
    ** against the current value in the zbuffer.  If the comparison
    ** succeeds the new z value is written into the z buffer masked
    ** by the z write mask.
    */
    GLenum testFunc;

    /*
    ** Writemask enable.  When GL_TRUE writing to the depth buffer is
    ** allowed.
    */
    GLboolean writeEnable;

    /*
    ** Value used to clear the z buffer when glClear is called.
    */
    GLdouble clear;
};

/************************************************************************/

typedef struct __GLaccumStateRec {
    __GLcolor clear;
} __GLaccumState;

/************************************************************************/

/*
** Stencil state.  Contains all the user settable stencil state.
*/
typedef struct __GLstencilStateRec {
    /*
    ** Stencil test function.  When the stencil is enabled this
    ** function is applied to the reference value and the stored stencil
    ** value as follows:
    **		result = ref comparision (mask & stencilBuffer[x][y])
    ** If the test fails then the fail op is applied and rendering of
    ** the pixel stops.
    */
    GLenum testFunc;

    /*
    ** Stencil clear value.  Used by glClear.
    */
    GLshort clear;

    /*
    ** Reference stencil value.
    */
    GLshort reference;

    /*
    ** Stencil mask.  This is anded against the contents of the stencil
    ** buffer during comparisons.
    */
    GLshort mask;

    /*
    ** Stencil write mask
    */
    GLshort writeMask;

    /*
    ** When the stencil comparison fails this operation is applied to
    ** the stencil buffer.
    */
    GLenum fail;

    /*
    ** When the stencil comparison passes and the depth test
    ** fails this operation is applied to the stencil buffer.
    */
    GLenum depthFail;

    /*
    ** When both the stencil comparison passes and the depth test
    ** passes this operation is applied to the stencil buffer.
    */
    GLenum depthPass;
} __GLstencilState;

/************************************************************************/

typedef struct __GLviewportRec {
    /*
    ** Viewport parameters from user, as integers.
    */
    GLint x, y;
    GLsizei width, height;

    /*
    ** Depthrange parameters from user.
    */
    GLdouble zNear, zFar;

/*XXX move me */
    /*
    ** Internal form of viewport and depth range used to compute
    ** window coordinates from clip coordinates.
    */
    __GLfloat xScale, xCenter;
    __GLfloat yScale, yCenter;
    __GLfloat zScale, zCenter;
} __GLviewport;

/************************************************************************/

typedef struct __GLtransformStateRec {
    /*
    ** Current mode of the matrix stack.  This determines what effect
    ** the various matrix operations (load, mult, scale) apply to.
    */
    GLenum matrixMode;

    /*
    ** User clipping planes in eye space.  These are the user clip planes
    ** projected into eye space.  
    */
/* XXX BUG! stacking of eyeClipPlanes is busted! */
    __GLcoord *eyeClipPlanes;
    __GLcoord *eyeClipPlanesSet;
} __GLtransformState;

/************************************************************************/

/*
** Enable structures.  Anything that can be glEnable'd or glDisable'd is
** contained in this structure.  The enables are kept as single bits
** in a couple of bitfields.
*/

/* Bits in "general" enable word */
#define __GL_ALPHA_TEST_ENABLE			(1 <<  0)
#define __GL_BLEND_ENABLE			(1 <<  1)
#define __GL_INDEX_LOGIC_OP_ENABLE		(1 <<  2)
#define __GL_DITHER_ENABLE			(1 <<  3)
#define __GL_DEPTH_TEST_ENABLE			(1 <<  4)
#define __GL_FOG_ENABLE				(1 <<  5)
#define __GL_LIGHTING_ENABLE			(1 <<  6)
#define __GL_COLOR_MATERIAL_ENABLE		(1 <<  7)
#define __GL_LINE_STIPPLE_ENABLE		(1 <<  8)
#define __GL_LINE_SMOOTH_ENABLE			(1 <<  9)
#define __GL_POINT_SMOOTH_ENABLE		(1 << 10)
#define __GL_POLYGON_SMOOTH_ENABLE		(1 << 11)
#define __GL_CULL_FACE_ENABLE			(1 << 12)
#define __GL_POLYGON_STIPPLE_ENABLE		(1 << 13)
#define __GL_SCISSOR_TEST_ENABLE		(1 << 14)
#define __GL_STENCIL_TEST_ENABLE		(1 << 15)
#define __GL_TEXTURE_1D_ENABLE			(1 << 16)
#define __GL_TEXTURE_2D_ENABLE			(1 << 17)
#define __GL_TEXTURE_GEN_S_ENABLE		(1 << 18)
#define __GL_TEXTURE_GEN_T_ENABLE		(1 << 19)
#define __GL_TEXTURE_GEN_R_ENABLE		(1 << 20)
#define __GL_TEXTURE_GEN_Q_ENABLE		(1 << 21)
#define __GL_NORMALIZE_ENABLE			(1 << 22)
#define __GL_AUTO_NORMAL_ENABLE			(1 << 23)
#define __GL_POLYGON_OFFSET_POINT_ENABLE        (1 << 24)
#define __GL_POLYGON_OFFSET_LINE_ENABLE         (1 << 25)
#define __GL_POLYGON_OFFSET_FILL_ENABLE         (1 << 26)
#define __GL_COLOR_LOGIC_OP_ENABLE              (1 << 27)
#ifdef GL_EXT_flat_paletted_lighting
// NOTE: Not currently enabled, can be reused if necessary
#define __GL_PALETTED_LIGHTING_ENABLE           (1 << 28)
#endif // GL_EXT_flat_paletted_lighting
#ifdef GL_WIN_specular_fog
#define __GL_FOG_SPEC_TEX_ENABLE                (1 << 29)
#endif //GL_WIN_specular_fog
#ifdef GL_WIN_multiple_textures
#define __GL_TEXCOMBINE_CLAMP_ENABLE            (1 << 30)
#endif // GL_WIN_multiple_textures

/*
** Composities of the above bits for each glPushAttrib group that has
** multiple enables, except for those defined below
*/
#define __GL_COLOR_BUFFER_ENABLES				       \
    (__GL_ALPHA_TEST_ENABLE | __GL_BLEND_ENABLE | __GL_INDEX_LOGIC_OP_ENABLE \
     | __GL_DITHER_ENABLE | __GL_COLOR_LOGIC_OP_ENABLE)

#define __GL_LIGHTING_ENABLES \
    (__GL_LIGHTING_ENABLE | __GL_COLOR_MATERIAL_ENABLE)

#define __GL_LINE_ENABLES \
    (__GL_LINE_STIPPLE_ENABLE | __GL_LINE_SMOOTH_ENABLE)

#define __GL_POLYGON_ENABLES				\
    (__GL_POLYGON_SMOOTH_ENABLE | __GL_CULL_FACE_ENABLE	\
     | __GL_POLYGON_STIPPLE_ENABLE | __GL_POLYGON_OFFSET_POINT_ENABLE \
     | __GL_POLYGON_OFFSET_LINE_ENABLE | __GL_POLYGON_OFFSET_FILL_ENABLE)

#define __GL_TEXTURE_ENABLES				      \
    (__GL_TEXTURE_1D_ENABLE | __GL_TEXTURE_2D_ENABLE	      \
     | __GL_TEXTURE_GEN_S_ENABLE | __GL_TEXTURE_GEN_T_ENABLE  \
     | __GL_TEXTURE_GEN_R_ENABLE | __GL_TEXTURE_GEN_Q_ENABLE)

/* Bits in "eval1" enable word */
#define __GL_MAP1_VERTEX_3_ENABLE		(1 << __GL_V3)
#define __GL_MAP1_VERTEX_4_ENABLE		(1 << __GL_V4)
#define __GL_MAP1_COLOR_4_ENABLE		(1 << __GL_C4)
#define __GL_MAP1_INDEX_ENABLE			(1 << __GL_I)
#define __GL_MAP1_NORMAL_ENABLE			(1 << __GL_N3)
#define __GL_MAP1_TEXTURE_COORD_1_ENABLE	(1 << __GL_T1)
#define __GL_MAP1_TEXTURE_COORD_2_ENABLE	(1 << __GL_T2)
#define __GL_MAP1_TEXTURE_COORD_3_ENABLE	(1 << __GL_T3)
#define __GL_MAP1_TEXTURE_COORD_4_ENABLE	(1 << __GL_T4)

/* Bits in "eval2" enable word */
#define __GL_MAP2_VERTEX_3_ENABLE		(1 << __GL_V3)
#define __GL_MAP2_VERTEX_4_ENABLE		(1 << __GL_V4)
#define __GL_MAP2_COLOR_4_ENABLE		(1 << __GL_C4)
#define __GL_MAP2_INDEX_ENABLE			(1 << __GL_I)
#define __GL_MAP2_NORMAL_ENABLE			(1 << __GL_N3)
#define __GL_MAP2_TEXTURE_COORD_1_ENABLE	(1 << __GL_T1)
#define __GL_MAP2_TEXTURE_COORD_2_ENABLE	(1 << __GL_T2)
#define __GL_MAP2_TEXTURE_COORD_3_ENABLE	(1 << __GL_T3)
#define __GL_MAP2_TEXTURE_COORD_4_ENABLE	(1 << __GL_T4)

/* Bits in "clipPlanes" enable word */
#define __GL_CLIP_PLANE0_ENABLE			(1 << 0)
#define __GL_CLIP_PLANE1_ENABLE			(1 << 1)
#define __GL_CLIP_PLANE2_ENABLE			(1 << 2)
#define __GL_CLIP_PLANE3_ENABLE			(1 << 3)
#define __GL_CLIP_PLANE4_ENABLE			(1 << 4)
#define __GL_CLIP_PLANE5_ENABLE			(1 << 5)

/* Bits in "lights" enable word */
#define __GL_LIGHT0_ENABLE			(1 << 0)
#define __GL_LIGHT1_ENABLE			(1 << 1)
#define __GL_LIGHT2_ENABLE			(1 << 2)
#define __GL_LIGHT3_ENABLE			(1 << 3)
#define __GL_LIGHT4_ENABLE			(1 << 4)
#define __GL_LIGHT5_ENABLE			(1 << 5)
#define __GL_LIGHT6_ENABLE			(1 << 6)
#define __GL_LIGHT7_ENABLE			(1 << 7)

typedef struct __GLenableStateRec __GLenableState;
struct __GLenableStateRec {
    GLuint general;
    GLuint lights;
    GLuint clipPlanes;
    GLushort eval1, eval2;
};

/************************************************************************/

typedef struct __GLrasterStateRec __GLrasterState;
struct __GLrasterStateRec {
    /*
    ** Alpha function.  The alpha function is applied to the alpha color
    ** value and the reference value.  If it fails then the pixel is
    ** not rendered.
    */
    GLenum alphaFunction;
    __GLfloat alphaReference;

    /*
    ** Alpha blending source and destination factors.
    */
    GLenum blendSrc;
    GLenum blendDst;

    /*
    ** Logic op.  Logic op is only used during color index mode.
    */
    GLenum logicOp;

    /*
    ** Color to fill the color portion of the framebuffer when clear
    ** is called.
    */
    __GLcolor clear;
    __GLfloat clearIndex;

    /*
    ** Color index write mask.  The color values are masked with this
    ** value when writing to the frame buffer so that only the bits set
    ** in the mask are changed in the frame buffer.
    */
    GLint writeMask;

    /*
    ** RGB write masks.  These booleans enable or disable writing of
    ** the r, g, b, and a components.
    */
    GLboolean rMask, gMask, bMask, aMask;

    /*
    ** This state variable tracks which buffer(s) is being drawn into.
    */
    GLenum drawBuffer;

    /*
    ** Draw buffer specified by user.  May be different from drawBuffer
    ** above.  If the user specifies GL_FRONT_LEFT, for example, then 
    ** drawBuffer is set to GL_FRONT, and drawBufferReturn to 
    ** GL_FRONT_LEFT.
    */
    GLenum drawBufferReturn;
};

/************************************************************************/

/*
** Hint state.  Contains all the user controllable hint state.
*/
typedef struct {
    GLenum perspectiveCorrection;
    GLenum pointSmooth;
    GLenum lineSmooth;
    GLenum polygonSmooth;
    GLenum fog;
#ifdef GL_WIN_phong_shading
    GLenum phong;
#endif
} __GLhintState;

/************************************************************************/

/*
** All stackable list state.
*/
typedef struct __GLdlistStateRec {
    GLuint listBase;
} __GLdlistState;

/************************************************************************/

/*
** Scissor state from user.
*/
typedef struct __GLscissorRec {
    GLint scissorX, scissorY, scissorWidth, scissorHeight;
} __GLscissor;

/************************************************************************/

struct __GLattributeRec {
    /*
    ** Mask of which fields in this structure are valid.
    */
    GLuint mask;

    __GLcurrentState current;
    __GLpointState point;
    __GLlineState line;
    __GLpolygonState polygon;
    __GLpolygonStippleState polygonStipple;
    __GLpixelState pixel;
    __GLlightState light;
    __GLfogState fog;
    __GLdepthState depth;
    __GLaccumState accum;
    __GLstencilState stencil;
    __GLviewport viewport;
    __GLtransformState transform;
    __GLenableState enables;
    __GLrasterState raster;
    __GLhintState hints;
    __GLevaluatorState evaluator;
    __GLdlistState list;
    __GLtextureState texture;
    __GLscissor scissor;
};

/************************************************************************/

/*
** Attribution machine state.  This manages the stack of attributes.
*/
typedef struct {
    /*
    ** Attribute stack.  The attribute stack keeps track of the
    ** attributes that have been pushed.
    */
    __GLattribute **stack;

    /*
    ** Attribute stack pointer.
    */
    __GLattribute **stackPointer;
} __GLattributeMachine;

extern void FASTCALL __glFreeAttributeState(__GLcontext *gc);
extern GLboolean FASTCALL __glCopyContext(__GLcontext *dst, const __GLcontext *src,
				 GLuint mask);
extern GLenum __glErrorCheckMaterial(GLenum face, GLenum p, GLfloat pv0);

/************************************************************************/
// Client attribute states.
typedef struct __GLclientAttributeRec {
    // Mask of which fields in this structure are valid.
    GLbitfield          mask;

    __GLpixelPackMode   pixelPackModes;
    __GLpixelUnpackMode pixelUnpackModes;
    __GLvertexArray     vertexArray;
} __GLclientAttribute;

/*
** Client attribution machine state.  This manages the stack of client
** attributes.
*/
typedef struct {
    /*
    ** Client attribute stack.  The client attribute stack keeps track of the
    ** client attributes that have been pushed.
    */
    __GLclientAttribute **stack;

    /*
    ** Client attribute stack pointer.
    */
    __GLclientAttribute **stackPointer;
} __GLclientAttributeMachine;

extern void FASTCALL __glFreeClientAttributeState(__GLcontext *gc);

extern GLuint FASTCALL __glInternalPopAttrib(__GLcontext *, GLboolean);
extern GLuint FASTCALL __glInternalPopClientAttrib(__GLcontext *, GLboolean,
                                                   GLboolean);

#endif /* __glattrib_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\context.h ===
#ifndef __glcontext_h_
#define __glcontext_h_

/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Graphics context structures.
*/
#include "os.h"
#include "attrib.h"
#include "feedback.h"
#include "select.h"
#include "buffers.h"
#include "pixel.h"
#include "dlist.h"
#include "xform.h"
#include "render.h"
#include "oleauto.h"
#include "parray.h"
#include "procs.h"
#include "gldrv.h"
#include "glarray.h"

// Disable long to float conversion warning.  see also gencx.h
#pragma warning (disable:4244)

/*
** Mode and limit information for a context.  This information is
** kept around in the context so that values can be used during
** command execution, and for returning information about the
** context to the application.
*/
struct __GLcontextModesRec {
    GLboolean rgbMode;
    GLboolean colorIndexMode;
    GLboolean doubleBufferMode;
    GLboolean stereoMode;
    GLboolean haveAccumBuffer;
    GLboolean haveDepthBuffer;
    GLboolean haveStencilBuffer;

    /* The number of bits present in various buffers */
    GLint accumBits;
    GLint *auxBits;
    GLint depthBits;
    GLint stencilBits;
    GLint indexBits;
    GLint indexFractionBits;
    GLint redBits, greenBits, blueBits, alphaBits;
    GLuint redMask, greenMask, blueMask, alphaMask;
#ifdef NT
    GLuint allMask;
    GLuint rgbMask;
#endif
    GLint maxAuxBuffers;

    /* False if running from inside the X server */
    GLboolean isDirect;

    /* frame buffer level */
    GLint level;
};

/*
** Various constants.  Most of these will never change through the life
** of the context.
*/
typedef struct __GLcontextConstantsRec {
    /* Specific size limits */
    GLint numberOfLights;
    GLint numberOfClipPlanes;
    GLint numberOfTextures;
    GLint numberOfTextureEnvs;
    GLint maxViewportWidth;
    GLint maxViewportHeight;

#ifdef GL_WIN_multiple_textures
    /* Maximum number of current textures */
    GLuint numberOfCurrentTextures;
    GLenum texCombineNaturalClamp;
#endif // GL_WIN_multiple_textures

    /*
    ** Viewport offsets: These numbers are added to the viewport center
    ** values to adjust the computed window coordinates into a
    ** numerically well behaved space (fixed point represented in a
    ** floating point number).
    */
    GLint viewportXAdjust;
    GLint viewportYAdjust;
    __GLfloat fviewportXAdjust;
    __GLfloat fviewportYAdjust;

    /*
    ** These values are computed from viewportXAdjust when the context
    ** is created.  It is assumed that x and y are forced into the same
    ** fixed point range by viewportXAdjust and viewportYAdjust.
    **
    ** viewportEpsilon is computed as the smallest possible value that can
    ** be represented in that fixed point space.
    **
    ** viewportAlmostHalf is equal to 0.5 - viewportEpsilon.
    */
    __GLfloat viewportEpsilon;
    __GLfloat viewportAlmostHalf;

    /* Scales that bring colors values from 0.0 to 1.0 into internal range */
    __GLfloat redScale, blueScale, greenScale, alphaScale;

    /*
    ** Geometry of the current window.
    */
    GLint width, height;

    /*
    ** Size of the alpha lookup table for alpha testing, and conversion
    ** value to convert from scaled alpha to alpha to be used for lookup table.
    */
    GLint alphaTestSize;
    __GLfloat alphaTableConv;

    /*
    ** Random getable constants
    */
    GLint maxTextureSize;
    GLint maxMipMapLevel;
    GLint subpixelBits;
    GLint maxListNesting;
    __GLfloat pointSizeMinimum;
    __GLfloat pointSizeMaximum;
    __GLfloat pointSizeGranularity;
    __GLfloat lineWidthMinimum;
    __GLfloat lineWidthMaximum;
    __GLfloat lineWidthGranularity;
    GLint maxEvalOrder;
    GLint maxPixelMapTable;
    GLint maxAttribStackDepth;
    GLint maxClientAttribStackDepth;
    GLint maxNameStackDepth;

    /*
    ** GDI's Y is inverted.  These two constants help out.
    */
    GLboolean yInverted;
    GLint ySign;
} __GLcontextConstants;

/************************************************************************/

typedef enum __GLbeginModeEnum {
    __GL_NOT_IN_BEGIN = 0,
    __GL_IN_BEGIN = 1,
    __GL_NEED_VALIDATE = 2
} __GLbeginMode;

#ifdef NT_SERVER_SHARE_LISTS
//
// Information for tracking dlist locks so we know what to unlock during
// cleanup
//
typedef struct _DlLockEntry
{
    __GLdlist *dlist;
} DlLockEntry;

typedef struct _DlLockArray
{
    GLsizei nAllocated;
    GLsizei nFilled;
    DlLockEntry *pdleEntries;
} DlLockArray;
#endif

// Signature stamp for gc's.  Must be non-zero.
// Currently spells 'GLGC' in byte order.
#define GC_SIGNATURE 0x43474c47

struct __GLcontextRec {

    /************************************************************************/

    /*
    ** Initialization and signature flag.  If this flag is set to the
    ** gc signature value then the gc is initialized.
    ** This could be a simple bit flag except that having the signature
    ** is convenient for identifying gc's in memory during debugging.
    */
    GLuint gcSig;

    /************************************************************************/

    /*
    ** Stackable state.  All of the current user controllable state
    ** is resident here.
    */
    __GLattribute state;

    /************************************************************************/

    /*
    ** Unstackable State
    */

    /*
    ** Current glBegin mode.  Legal values are 0 (not in begin mode), 1
    ** (in beginMode), or 2 (not in begin mode, some validation is
    ** needed).  Because all state changing routines have to fetch this
    ** value, we have overloaded state validation into it.  There is
    ** special code in the __glim_Begin (for software renderers) which
    ** deals with validation.
    */
    __GLbeginMode beginMode;

    /* Current rendering mode */
    GLenum renderMode;

    /*
    ** Most recent error code, or GL_NO_ERROR if no error has occurred
    ** since the last glGetError.
    */
    GLint error;

    /*
    ** Mode information that describes the kind of buffers and rendering
    ** modes that this context manages.
    */
    __GLcontextModes modes;

    /* Implementation dependent constants */
    __GLcontextConstants constants;

    /* Feedback and select state */
    __GLfeedbackMachine feedback;

    __GLselectMachine select;

    /* Display list state */
    __GLdlistMachine dlist;

#ifdef NT
    /* Saved client side dispatch tables.  Used by display list. */
    GLCLTPROCTABLE savedCltProcTable;
    GLEXTPROCTABLE savedExtProcTable;
#endif

    /************************************************************************/

    /*
    ** The remaining state is used primarily by the software renderer.
    */

    /*
    ** Mask word for validation state to help guide the gc validation
    ** code.  Only operations which are largely expensive are broken
    ** out here.  See the #define's below for the values being used.
    */
    GLuint validateMask;

    /*
    ** Mask word of dirty bits.  Most routines just set the GENERIC bit to
    ** dirty, others may set more specific bits.  The list of bits is
    ** listed below.
    */
    GLuint dirtyMask;

    /* Current draw buffer, set by glDrawBuffer */
    __GLcolorBuffer *drawBuffer;

    /* Current read buffer, set by glReadBuffer */
    __GLcolorBuffer *readBuffer;

    /* Function pointers that are mode dependent */
    __GLprocs procs;

    /* Attribute stack state */
    __GLattributeMachine attributes;

    /* Client attribute stack state */
    __GLclientAttributeMachine clientAttributes;

    /* Machine structures defining software rendering "machine" state */
    __GLvertexMachine vertex;
    __GLlightMachine light;
    __GLtextureMachine texture;
    __GLevaluatorMachine eval;
    __GLtransformMachine transform;
    __GLlineMachine line;
    __GLpolygonMachine polygon;
    __GLpixelMachine pixel;
    __GLbufferMachine buffers;

#ifdef NT
    __GLfloat redClampTable[4];
    __GLfloat greenClampTable[4];
    __GLfloat blueClampTable[4];
    __GLfloat alphaClampTable[4];
    __GLfloat oneOverRedVertexScale;
    __GLfloat oneOverGreenVertexScale;
    __GLfloat oneOverBlueVertexScale;
    __GLfloat oneOverAlphaVertexScale;
    __GLfloat redVertexScale;
    __GLfloat greenVertexScale;
    __GLfloat blueVertexScale;
    __GLfloat alphaVertexScale;
    GLboolean vertexToBufferIdentity;
    __GLfloat redVertexToBufferScale;
    __GLfloat blueVertexToBufferScale;
    __GLfloat greenVertexToBufferScale;
    __GLfloat alphaVertexToBufferScale;
    GLuint textureKey;
    GLubyte *alphaTestFuncTable;
#endif

    /* Buffers */
    __GLcolorBuffer *front;
    __GLcolorBuffer *back;
    __GLcolorBuffer frontBuffer;
    __GLcolorBuffer backBuffer;
    __GLcolorBuffer *auxBuffer;
    __GLstencilBuffer stencilBuffer;
    __GLdepthBuffer depthBuffer;
    __GLaccumBuffer accumBuffer;

#ifdef NT
    // Temporary buffers allocated by the gc.  The abnormal process exit
    // code will release these buffers.
    void * apvTempBuf[6];
#endif // NT

#ifdef NT_SERVER_SHARE_LISTS
    DlLockArray dla;
#endif

#ifdef NT
    // TEB polyarray pointer for this thread.  It allows fast access to the
    // polyarray structure in the TEB equivalent to the GLTEB_CLTPOLYARRAY
    // macro.  This field is kept current in MakeCurrent.
    POLYARRAY *paTeb;

    // Vertex array client states
    __GLvertexArray vertexArray;

    // Saved vertex array state for execution of display-listed
    // vertex array calls
    __GLvertexArray savedVertexArray;

    __GLmatrix *mInv;
#endif // NT
};

#ifdef NT
// Associate the temporary buffer with the gc for abnormal process cleanup.
#define GC_TEMP_BUFFER_ALLOC(gc, pv)                                    \
        {                                                               \
            int _i;                                                     \
            for (_i = 0; _i < sizeof(gc->apvTempBuf)/sizeof(void *); _i++)\
            {                                                           \
                if (!gc->apvTempBuf[_i])                                \
                {                                                       \
                    gc->apvTempBuf[_i] = pv;                            \
                    break;                                              \
                }                                                       \
            }                                                           \
            ASSERTOPENGL(_i < sizeof(gc->apvTempBuf)/sizeof(void *),    \
                "gc->apvTempBuf overflows\n");                          \
        }

// Unassociate the temporary buffer with the gc.
#define GC_TEMP_BUFFER_FREE(gc, pv)                                     \
        {                                                               \
            int _i;                                                     \
            for (_i = 0; _i < sizeof(gc->apvTempBuf)/sizeof(void *); _i++)\
            {                                                           \
                if (gc->apvTempBuf[_i] == pv)                           \
                {                                                       \
                    gc->apvTempBuf[_i] = (void *) NULL;                 \
                    break;                                              \
                }                                                       \
            }                                                           \
            ASSERTOPENGL(_i < sizeof(gc->apvTempBuf)/sizeof(void *),    \
                "gc->apvTempBuf entry not found\n");                    \
        }

// Cleanup any temporary buffer allocated in gc in abnormal process exit.
#define GC_TEMP_BUFFER_EXIT_CLEANUP(gc)                                 \
        {                                                               \
            int _i;                                                     \
            for (_i = 0; _i < sizeof(gc->apvTempBuf)/sizeof(void *); _i++)\
            {                                                           \
                if (gc->apvTempBuf[_i])                                 \
                {                                                       \
                    WARNING("Abnormal process exit: free allocated buffers\n");\
                    gcTempFree(gc, gc->apvTempBuf[_i]);              \
                    gc->apvTempBuf[_i] = (void *) NULL;                 \
                }                                                       \
            }                                                           \
        }
#endif // NT

/*
** Bit values for the validateMask word
*/
#define __GL_VALIDATE_ALPHA_FUNC	0x00000001
#define __GL_VALIDATE_STENCIL_FUNC	0x00000002
#define __GL_VALIDATE_STENCIL_OP	0x00000004

/*
** Bit values for dirtyMask word.
**
** These are all for delayed validation.  There are a few things that do
** not trigger delayed validation.  They are:
**
** Matrix operations -- matrices are validated immediately.
** Material changes -- they also validate immediately.
** Color Material change -- validated immediately.
** Color Material enable -- validated immediately.
** Pixel Map changes -- no validation.
*/

/*
** All things not listed elsewhere.
*/
#define __GL_DIRTY_GENERIC		0x00000001

/*
** Line stipple, line stipple enable, line width, line smooth enable,
** line smooth hint.
*/
#define __GL_DIRTY_LINE			0x00000002

/*
** Polygon stipple, polygon stipple enable, polygon smooth enable, face
** culling, front face orientation, polygon mode, point smooth hint.
*/
#define __GL_DIRTY_POLYGON		0x00000004

/*
** Point smooth, point smooth hint, point width.
*/
#define __GL_DIRTY_POINT		0x00000008

/*
** Pixel store, pixel zoom, pixel transfer, (pixel maps don't cause
** validation), read buffer.
*/
#define __GL_DIRTY_PIXEL		0x00000010

/*
** Light, Light Model, lighting enable, lightx enable, (color material
** validates immediately), (NOT shade model -- it is generic), (color material
** enable validates immediately)
*/
#define __GL_DIRTY_LIGHTING		0x00000020

/*
** Polygon stipple
*/
#define __GL_DIRTY_POLYGON_STIPPLE	0x00000040

/*
** the depth mode has changed.  Need to update depth function pointers.
*/
#define	__GL_DIRTY_DEPTH		0x00000080

/*
** Need to update texture and function pointers.
*/
#define	__GL_DIRTY_TEXTURE      0x00000100

#define __GL_DIRTY_ALL			0x000001ff

/*
** Bit values for changes to material colors
**
** These values are shared with MCDMATERIAL_
*/
#define __GL_MATERIAL_AMBIENT		0x00000001
#define __GL_MATERIAL_DIFFUSE		0x00000002
#define __GL_MATERIAL_SPECULAR		0x00000004
#define __GL_MATERIAL_EMISSIVE		0x00000008
#define __GL_MATERIAL_SHININESS		0x00000010
#define __GL_MATERIAL_COLORINDEXES	0x00000020
#define __GL_MATERIAL_ALL		0x0000003f

#define __GL_DELAY_VALIDATE(gc)		      \
    ASSERTOPENGL((gc)->beginMode != __GL_IN_BEGIN, "Dirty state in begin\n"); \
    (gc)->beginMode = __GL_NEED_VALIDATE;     \
    (gc)->dirtyMask |= __GL_DIRTY_GENERIC

#define __GL_DELAY_VALIDATE_MASK(gc, mask)	\
    ASSERTOPENGL((gc)->beginMode != __GL_IN_BEGIN, "Dirty state in begin\n"); \
    (gc)->beginMode = __GL_NEED_VALIDATE;     	\
    (gc)->dirtyMask |= (mask)

#define __GL_CLAMP_CI(target, gc, r)                            \
{                                                               \
    if ((r) > (GLfloat)(gc)->frontBuffer.redMax) {              \
        GLfloat fraction;                                       \
        GLint integer;                                          \
                                                                \
        integer = (GLint) (r);                                  \
        fraction = (r) - (GLfloat) integer;                     \
        integer = integer & (GLint)(gc)->frontBuffer.redMax;    \
        target = (GLfloat) integer + fraction;                  \
    } else if ((r) < 0) {                                       \
        GLfloat fraction;                                       \
        GLint integer;                                          \
                                                                \
        integer = (GLint) __GL_FLOORF(r);                       \
        fraction = (r) - (GLfloat) integer;                     \
        integer = integer & (GLint)(gc)->frontBuffer.redMax;    \
        target = (GLfloat) integer + fraction;                  \
    } else {                                                    \
        target = r;                                             \
    }\
}

#define __GL_CHECK_CLAMP_CI(target, gc, flags, r)               \
{                                                               \
    if (((r) > (GLfloat)(gc)->frontBuffer.redMax) ||            \
        ((r) < 0))                                              \
        flags |= POLYARRAY_CLAMP_COLOR;                         \
    (target) = (r);                                             \
}

#define __GL_COLOR_CLAMP_INDEX_R(value)                                 \
    (((ULONG)((CASTINT(value) & 0x80000000)) >> 30) |                   \
     ((ULONG)(((CASTINT(gc->redVertexScale) - CASTINT(value)) & 0x80000000)) >> 31))	\

#define __GL_COLOR_CLAMP_INDEX_G(value)                                 \
    (((ULONG)((CASTINT(value) & 0x80000000)) >> 30) |                   \
     ((ULONG)(((CASTINT(gc->greenVertexScale) - CASTINT(value)) & 0x80000000)) >> 31))	\

#define __GL_COLOR_CLAMP_INDEX_B(value)                                 \
    (((ULONG)((CASTINT(value) & 0x80000000)) >> 30) |                   \
     ((ULONG)(((CASTINT(gc->blueVertexScale) - CASTINT(value)) & 0x80000000)) >> 31))	\

#define __GL_COLOR_CLAMP_INDEX_A(value)                                 \
    (((ULONG)((CASTINT(value) & 0x80000000)) >> 30) |                   \
     ((ULONG)(((CASTINT(gc->alphaVertexScale) - CASTINT(value)) & 0x80000000)) >> 31))  \

#define __GL_SCALE_R(target, gc, r)                                         \
    (target) = (r) * (gc)->redVertexScale

#define __GL_SCALE_G(target, gc, g)                                         \
    (target) = (g) * (gc)->greenVertexScale

#define __GL_SCALE_B(target, gc, b)                                         \
    (target) = (b) * (gc)->blueVertexScale

#define __GL_SCALE_A(target, gc, a)                                         \
    (target) = (a) * (gc)->alphaVertexScale

#define __GL_COLOR_CHECK_CLAMP_R(value, flags)                                 \
    (flags) |=                                                                 \
    ((ULONG)(CASTINT(value) & 0x80000000) |                                    \
     (ULONG)((CASTINT(gc->redVertexScale) - CASTINT(value)) & 0x80000000))

#define __GL_COLOR_CHECK_CLAMP_G(value, flags)                                 \
    (flags) |=                                                                 \
    ((ULONG)(CASTINT(value) & 0x80000000) |                                    \
     (ULONG)((CASTINT(gc->greenVertexScale) - CASTINT(value)) & 0x80000000))

#define __GL_COLOR_CHECK_CLAMP_B(value, flags)                                 \
    (flags) |=                                                                 \
    ((ULONG)(CASTINT(value) & 0x80000000) |                                    \
     (ULONG)((CASTINT(gc->blueVertexScale) - CASTINT(value)) & 0x80000000))

#define __GL_COLOR_CHECK_CLAMP_A(value, flags)                                 \
    (flags) |=                                                                 \
    ((ULONG)(CASTINT(value) & 0x80000000) |                                    \
     (ULONG)((CASTINT(gc->alphaVertexScale) - CASTINT(value)) & 0x80000000))

#define __GL_COLOR_CHECK_CLAMP_RGB(gc, r, g, b)                              \
    ((CASTINT(r) | ((ULONG)(CASTINT(gc->redVertexScale) - CASTINT(r))) |     \
      CASTINT(g) | ((ULONG)(CASTINT(gc->greenVertexScale) - CASTINT(g))) |   \
      CASTINT(b) | ((ULONG)(CASTINT(gc->blueVertexScale) - CASTINT(b)))) &   \
     0x80000000)


#define __GL_SCALE_AND_CHECK_CLAMP_R(target, gc, flags, r)                  \
{                                                                           \
    __GL_SCALE_R(target, gc, r);                                            \
    __GL_COLOR_CHECK_CLAMP_R(target, flags);                                \
}

#define __GL_SCALE_AND_CHECK_CLAMP_G(target, gc, flags, g)                  \
{                                                                           \
    __GL_SCALE_G(target, gc, g);                                            \
    __GL_COLOR_CHECK_CLAMP_G(target, flags);                                \
}

#define __GL_SCALE_AND_CHECK_CLAMP_B(target, gc, flags, b)                  \
{                                                                           \
    __GL_SCALE_B(target, gc, b);                                            \
    __GL_COLOR_CHECK_CLAMP_B(target, flags);                                \
}

#define __GL_SCALE_AND_CHECK_CLAMP_A(target, gc, flags, a)                  \
{                                                                           \
    __GL_SCALE_A(target, gc, a);                                            \
    __GL_COLOR_CHECK_CLAMP_A(target, flags);                                \
}

#define __GL_CLAMP_R(target, gc, r)                                         \
{                                                                           \
    (gc)->redClampTable[0] = (r);                                           \
    target = (gc)->redClampTable[__GL_COLOR_CLAMP_INDEX_R((gc)->redClampTable[0])]; \
}

#define __GL_CLAMP_G(target, gc, g)                                         \
{                                                                           \
    (gc)->greenClampTable[0] = (g);                                         \
    target = (gc)->greenClampTable[__GL_COLOR_CLAMP_INDEX_G((gc)->greenClampTable[0])]; \
}

#define __GL_CLAMP_B(target, gc, b)                                         \
{                                                                           \
    (gc)->blueClampTable[0] = (b);                                          \
    target = (gc)->blueClampTable[__GL_COLOR_CLAMP_INDEX_B((gc)->blueClampTable[0])]; \
}

#define __GL_CLAMP_A(target, gc, a)                                         \
{                                                                           \
    (gc)->alphaClampTable[0] = (a);                                         \
    target = (gc)->alphaClampTable[__GL_COLOR_CLAMP_INDEX_A((gc)->alphaClampTable[0])]; \
}

/* Aggregate clamping routines. */


#ifdef _X86_

#define __GL_SCALE_RGB(rOut, gOut, bOut, gc, r, g, b)                   \
    __GL_SCALE_R(rOut, gc, r);                                    	\
    __GL_SCALE_G(gOut, gc, g);                                    	\
    __GL_SCALE_B(bOut, gc, b);

#define __GL_SCALE_RGBA(rOut, gOut, bOut, aOut, gc, r, g, b, a)         \
    __GL_SCALE_R(rOut, gc, r);                                    	\
    __GL_SCALE_G(gOut, gc, g);                                    	\
    __GL_SCALE_B(bOut, gc, b);                                    	\
    __GL_SCALE_A(aOut, gc, a);

#define __GL_CLAMP_RGB(rOut, gOut, bOut, gc, r, g, b)       		\
    __GL_CLAMP_R(rOut, gc, r);                                    	\
    __GL_CLAMP_G(gOut, gc, g);                                    	\
    __GL_CLAMP_B(bOut, gc, b);

#define __GL_CLAMP_RGBA(rOut, gOut, bOut, aOut, gc, r, g, b, a)         \
    __GL_CLAMP_R(rOut, gc, r);                                          \
    __GL_CLAMP_G(gOut, gc, g);                                    	\
    __GL_CLAMP_B(bOut, gc, b);                                    	\
    __GL_CLAMP_A(aOut, gc, a);

#define __GL_SCALE_AND_CHECK_CLAMP_RGB(rOut, gOut, bOut, gc, flags, r, g, b)\
    __GL_SCALE_AND_CHECK_CLAMP_R(rOut, gc, flags, r);         		\
    __GL_SCALE_AND_CHECK_CLAMP_G(gOut, gc, flags, g);         		\
    __GL_SCALE_AND_CHECK_CLAMP_B(bOut, gc, flags, b);

#define __GL_SCALE_AND_CHECK_CLAMP_RGBA(rOut, gOut, bOut, aOut, gc, flags,\
                                        r, g, b, a)                     \
    __GL_SCALE_AND_CHECK_CLAMP_R(rOut, gc, flags, r);                   \
    __GL_SCALE_AND_CHECK_CLAMP_G(gOut, gc, flags, g);                   \
    __GL_SCALE_AND_CHECK_CLAMP_B(bOut, gc, flags, b);                   \
    __GL_SCALE_AND_CHECK_CLAMP_A(aOut, gc, flags, a);

#else // NOT _X86_

/* The following code is written in a "load, compute, store" style.
** It is preferable for RISC CPU's with larger numbers of registers,
** such as DEC Alpha.  VC++ for Alpha does not do
** a good job expanding the __GL_CLAMP_R, __GL_CLAMP_G, __GL_CLAMP_B,
** __GL_CLAMP_A macros, due to all the pointer indirections and the
** basic blocks defined by {} brackets.
*/

#define __GL_SCALE_RGB(rOut, gOut, bOut, gc, r, g, b)               \
{                                                                   \
    __GLfloat rScale, gScale, bScale;                               \
    __GLfloat rs, gs, bs;                                           \
                                                                    \
    rScale = (gc)->redVertexScale;                                  \
    gScale = (gc)->greenVertexScale;                                \
    bScale = (gc)->blueVertexScale;                                 \
                                                                    \
    rs = (r) * rScale;                                              \
    gs = (g) * gScale;                                              \
    bs = (b) * bScale;                                              \
                                                                    \
    rOut = rs;                                                      \
    gOut = gs;                                                      \
    bOut = bs;                                                      \
}

#define __GL_SCALE_RGBA(rOut, gOut, bOut, aOut, gc, r, g, b, a)     \
{                                                                   \
    __GLfloat rScale, gScale, bScale, aScale;                       \
    __GLfloat rs, gs, bs, as;                                       \
                                                                    \
    rScale = (gc)->redVertexScale;                                  \
    gScale = (gc)->greenVertexScale;                                \
    bScale = (gc)->blueVertexScale;                                 \
    aScale = (gc)->alphaVertexScale;                                \
                                                                    \
    rs = (r) * rScale;                                              \
    gs = (g) * gScale;                                              \
    bs = (b) * bScale;                                              \
    as = (a) * aScale;                                              \
                                                                    \
    rOut = rs;                                                      \
    gOut = gs;                                                      \
    bOut = bs;                                                      \
    aOut = as;                                                      \
}

#define __GL_CLAMP_RGB(rOut, gOut, bOut, gc, r, g, b)               \
{                                                                   \
    __GLfloat dst_r, dst_g, dst_b;                                  \
    ULONG index_r, index_g, index_b;                                \
    LONG clamp_r, clamp_g, clamp_b;                                 \
    LONG i_rScale, i_gScale, i_bScale;                              \
    ULONG sign_mask = 0x80000000;                                   \
                                                                    \
    (gc)->redClampTable[0] = (r);                                   \
    (gc)->greenClampTable[0] = (g);                                 \
    (gc)->blueClampTable[0] = (b);                                  \
                                                                    \
    i_rScale = CASTINT((gc)->redVertexScale);                       \
    i_gScale = CASTINT((gc)->greenVertexScale);                     \
    i_bScale = CASTINT((gc)->blueVertexScale);                      \
                                                                    \
    clamp_r = CASTINT((gc)->redClampTable[0]);                      \
    clamp_g = CASTINT((gc)->greenClampTable[0]);                    \
    clamp_b = CASTINT((gc)->blueClampTable[0]);                     \
                                                                    \
    index_r =                                                       \
        (((ULONG)((clamp_r & sign_mask)) >> 30) |                   \
         ((ULONG)(((i_rScale - clamp_r) & sign_mask)) >> 31));      \
                                                                    \
    index_g =                                                       \
        (((ULONG)((clamp_g & sign_mask)) >> 30) |                   \
         ((ULONG)(((i_gScale - clamp_g) & sign_mask)) >> 31));      \
                                                                    \
    index_b =                                                       \
        (((ULONG)((clamp_b & sign_mask)) >> 30) |                   \
         ((ULONG)(((i_bScale - clamp_b) & sign_mask)) >> 31));      \
                                                                    \
    dst_r = (gc)->redClampTable[index_r];                           \
    dst_g = (gc)->greenClampTable[index_g];                         \
    dst_b = (gc)->blueClampTable[index_b];                          \
                                                                    \
    rOut = dst_r;                                                   \
    gOut = dst_g;                                                   \
    bOut = dst_b;                                                   \
}



#define __GL_CLAMP_RGBA(rOut, gOut, bOut, aOut, gc, r, g, b, a)     \
{                                                                   \
    __GLfloat dst_r, dst_g, dst_b, dst_a;                           \
    ULONG index_r, index_g, index_b, index_a;                       \
    LONG clamp_r, clamp_g, clamp_b, clamp_a;                        \
    LONG i_rScale, i_gScale, i_bScale, i_aScale;                    \
    ULONG sign_mask = 0x80000000;                                   \
                                                                    \
    (gc)->redClampTable[0] = (r);                                   \
    (gc)->greenClampTable[0] = (g);                                 \
    (gc)->blueClampTable[0] = (b);                                  \
    (gc)->alphaClampTable[0] = (a);                                 \
                                                                    \
    i_rScale = CASTINT((gc)->redVertexScale);                       \
    i_gScale = CASTINT((gc)->greenVertexScale);                     \
    i_bScale = CASTINT((gc)->blueVertexScale);                      \
    i_aScale = CASTINT((gc)->alphaVertexScale);                     \
                                                                    \
    clamp_r = CASTINT((gc)->redClampTable[0]);                      \
    clamp_g = CASTINT((gc)->greenClampTable[0]);                    \
    clamp_b = CASTINT((gc)->blueClampTable[0]);                     \
    clamp_a = CASTINT((gc)->alphaClampTable[0]);                    \
                                                                    \
    index_r =                                                       \
        (((ULONG)((clamp_r & sign_mask)) >> 30) |                   \
         ((ULONG)(((i_rScale - clamp_r) & sign_mask)) >> 31));      \
                                                                    \
    index_g =                                                       \
        (((ULONG)((clamp_g & sign_mask)) >> 30) |                   \
         ((ULONG)(((i_gScale - clamp_g) & sign_mask)) >> 31));      \
                                                                    \
    index_b =                                                       \
        (((ULONG)((clamp_b & sign_mask)) >> 30) |                   \
         ((ULONG)(((i_bScale - clamp_b) & sign_mask)) >> 31));      \
                                                                    \
    index_a =                                                       \
        (((ULONG)((clamp_a & sign_mask)) >> 30) |                   \
         ((ULONG)(((i_aScale - clamp_a) & sign_mask)) >> 31));      \
                                                                    \
    dst_r = (gc)->redClampTable[index_r];                           \
    dst_g = (gc)->greenClampTable[index_g];                         \
    dst_b = (gc)->blueClampTable[index_b];                          \
    dst_a = (gc)->alphaClampTable[index_a];                         \
                                                                    \
    rOut = dst_r;                                                   \
    gOut = dst_g;                                                   \
    bOut = dst_b;                                                   \
    aOut = dst_a;                                                   \
}


#define __GL_SCALE_AND_CHECK_CLAMP_RGB(rOut, gOut, bOut, gc, flags, r, g, b)\
{                                                                   \
    ULONG sign_mask = 0x80000000;                                   \
    __GLfloat rScale, gScale, bScale;                               \
    LONG i_rScale, i_gScale, i_bScale;                              \
    LONG i_r, i_g, i_b;                                             \
    __GLfloat fr, fg, fb;                                           \
    ULONG the_flags_copy, r_flags, g_flags, b_flags;                \
                                                                    \
    the_flags_copy = (flags);                                       \
                                                                    \
    rScale = (gc)->redVertexScale;                                  \
    gScale = (gc)->greenVertexScale;                                \
    bScale = (gc)->blueVertexScale;                                 \
                                                                    \
    i_rScale = CASTINT((gc)->redVertexScale);                       \
    i_gScale = CASTINT((gc)->greenVertexScale);                     \
    i_bScale = CASTINT((gc)->blueVertexScale);                      \
                                                                    \
    fr = (r) * rScale;                                              \
    fg = (g) * gScale;                                              \
    fb = (b) * bScale;                                              \
                                                                    \
    rOut = fr;                                                      \
    gOut = fg;                                                      \
    bOut = fb;                                                      \
                                                                    \
    i_r = CASTINT((rOut));  		                            \
    i_g = CASTINT((gOut));					    \
    i_b = CASTINT((bOut));	                                    \
                                                                    \
    r_flags =                                                       \
        ((ULONG)(i_r & sign_mask) |                                 \
         (ULONG)((i_rScale - i_r) & sign_mask));                    \
                                                                    \
    g_flags =                                                       \
        ((ULONG)(i_g & sign_mask) |                                 \
         (ULONG)((i_gScale - i_g) & sign_mask));                    \
                                                                    \
    b_flags =                                                       \
        ((ULONG)(i_b & sign_mask) |                                 \
         (ULONG)((i_bScale - i_b) & sign_mask));                    \
                                                                    \
    the_flags_copy |= r_flags | g_flags | b_flags;                  \
    (flags) = the_flags_copy;                                       \
}


#define __GL_SCALE_AND_CHECK_CLAMP_RGBA(rOut, gOut, bOut, aOut, gc, flags, \
                                        r, g, b, a)\
{                                                                   \
    ULONG sign_mask = 0x80000000;                                   \
    __GLfloat rScale, gScale, bScale, aScale;                       \
    LONG i_rScale, i_gScale, i_bScale, i_aScale;                    \
    LONG i_r, i_g, i_b, i_a;                                        \
    __GLfloat fr, fg, fb, fa;                                       \
    ULONG the_flags_copy, r_flags, g_flags, b_flags, a_flags;       \
                                                                    \
    the_flags_copy = (flags);                                       \
                                                                    \
    rScale = (gc)->redVertexScale;                                  \
    gScale = (gc)->greenVertexScale;                                \
    bScale = (gc)->blueVertexScale;                                 \
    aScale = (gc)->alphaVertexScale;                                \
                                                                    \
    i_rScale = CASTINT((gc)->redVertexScale);                       \
    i_gScale = CASTINT((gc)->greenVertexScale);                     \
    i_bScale = CASTINT((gc)->blueVertexScale);                      \
    i_aScale = CASTINT((gc)->alphaVertexScale);                     \
                                                                    \
    fr = (r) * rScale;                                              \
    fg = (g) * gScale;                                              \
    fb = (b) * bScale;                                              \
    fa = (a) * aScale;                                              \
                                                                    \
    rOut = fr;                                                      \
    gOut = fg;                                                      \
    bOut = fb;                                                      \
    aOut = fa;                                                      \
                                                                    \
    i_r = CASTINT((rOut));                                          \
    i_g = CASTINT((gOut));                                          \
    i_b = CASTINT((bOut));                                          \
    i_a = CASTINT((aOut));                                          \
                                                                    \
    r_flags =                                                       \
        ((ULONG)(i_r & sign_mask) |                                 \
         (ULONG)((i_rScale - i_r) & sign_mask));                    \
                                                                    \
    g_flags =                                                       \
        ((ULONG)(i_g & sign_mask) |                                 \
         (ULONG)((i_gScale - i_g) & sign_mask));                    \
                                                                    \
    b_flags =                                                       \
        ((ULONG)(i_b & sign_mask) |                                 \
         (ULONG)((i_bScale - i_b) & sign_mask));                    \
                                                                    \
    a_flags =                                                       \
        ((ULONG)(i_a & sign_mask) |                                 \
         (ULONG)((i_aScale - i_a) & sign_mask));                    \
                                                                    \
    the_flags_copy |= r_flags | g_flags | b_flags | a_flags;        \
    (flags) = the_flags_copy;                                       \
}

#endif // NOT _X86_


/************************************************************************/

/* Applies to current context */
extern void FASTCALL __glSetError(GLenum code);
#ifdef NT
/* Used when no RC is current */
extern void FASTCALL __glSetErrorEarly(__GLcontext *gc, GLenum code);
#endif // NT

extern void FASTCALL __glFreeEvaluatorState(__GLcontext *gc);
extern void FASTCALL __glFreeDlistState(__GLcontext *gc);
extern void FASTCALL __glFreeMachineState(__GLcontext *gc);
extern void FASTCALL __glFreePixelState(__GLcontext *gc);
extern void FASTCALL __glFreeTextureState(__GLcontext *gc);

extern void FASTCALL __glInitDlistState(__GLcontext *gc);
extern void FASTCALL __glInitEvaluatorState(__GLcontext *gc);
extern void FASTCALL __glInitPixelState(__GLcontext *gc);
extern void FASTCALL __glInitTextureState(__GLcontext *gc);
extern void FASTCALL __glInitTransformState(__GLcontext *gc);

void FASTCALL __glEarlyInitContext(__GLcontext *gc);
void FASTCALL __glContextSetColorScales(__GLcontext *gc);
void FASTCALL __glContextUnsetColorScales(__GLcontext *gc);
void FASTCALL __glSoftResetContext(__GLcontext *gc);
void FASTCALL __glDestroyContext(__GLcontext *gc);

#endif /* __glcontext_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\cpu.h ===
#ifndef __glcpu_h_
#define __glcpu_h_

/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** CPU dependent constants.
*/

#include <float.h>
#include <math.h>

#define __GL_BITS_PER_BYTE	8
#define __GL_STIPPLE_MSB	1

#define __GL_FLOAT_MANTISSA_BITS	23
#define __GL_FLOAT_MANTISSA_SHIFT	0
#define __GL_FLOAT_EXPONENT_BIAS	127
#define __GL_FLOAT_EXPONENT_BITS	8
#define __GL_FLOAT_EXPONENT_SHIFT	23
#define __GL_FLOAT_SIGN_SHIFT		31
#define __GL_FLOAT_MANTISSA_MASK (((1 << __GL_FLOAT_MANTISSA_BITS) - 1) << __GL_FLOAT_MANTISSA_SHIFT)
#define __GL_FLOAT_EXPONENT_MASK (((1 << __GL_FLOAT_EXPONENT_BITS) - 1) << __GL_FLOAT_EXPONENT_SHIFT)

// If the MSB of a FP number is known then float-to-int conversion
// becomes a simple shift and mask
// The value must be positive
#define __GL_FIXED_FLOAT_TO_INT(flt, shift) \
    ((*(LONG *)&(flt) >> (shift)) & \
     ((1 << (__GL_FLOAT_MANTISSA_BITS-(shift)))-1) | \
     (1 << (__GL_FLOAT_MANTISSA_BITS-(shift))))

// Same as above except without the MSB, which can be useful
// for getting unbiased numbers when the bias is only the MSB
// The value must be positive
#define __GL_FIXED_FLOAT_TO_INT_NO_MSB(flt, shift) \
    ((*(LONG *)&(flt) >> (shift)) & \
     ((1 << (__GL_FLOAT_MANTISSA_BITS-(shift)))-1))

// Produces the fixed-point form
// The value must be positive
#define __GL_FIXED_FLOAT_TO_FIXED(flt) \
    ((*(LONG *)&(flt)) & \
     ((1 << (__GL_FLOAT_MANTISSA_BITS))-1) | \
     (1 << (__GL_FLOAT_MANTISSA_BITS)))

#define __GL_FIXED_FLOAT_TO_FIXED_NO_MSB(flt) \
    ((*(LONG *)&(flt)) & \
     ((1 << (__GL_FLOAT_MANTISSA_BITS))-1))

// The fixed-point fraction as an integer
// The value must be positive
#define __GL_FIXED_FLOAT_FRACTION(flt, shift) \
    (*(LONG *)&(flt) & ((1 << (shift))-1))

// Converts the fixed-point form to an IEEE float, but still typed
// as an int because a cast to float would cause the compiler to do
// an int-float conversion
// The value must be positive
#define __GL_FIXED_TO_FIXED_FLOAT(fxed, shift) \
    ((fxed) & ((1 << (__GL_FLOAT_MANTISSA_BITS))-1) | \
     ((__GL_FLOAT_EXPONENT_BIAS+(shift)) << __GL_FLOAT_EXPONENT_SHIFT))
      
// On the x86, it's faster to do zero compares with an integer cast
// than it is to do the fcomp.
// In the case of the equality test there is only a check for
// +0.  IEEE floats can also be -0, so great care should be
// taken not to use the zero test unless missing this case is
// unimportant
//
// Additionally, FP compares are faster as integers

// These operations work for all normalized FP numbers, -0 included
#ifdef _X86_
#define __GL_FLOAT_GTZ(flt)             (*(LONG *)&(flt) > 0)
#define __GL_FLOAT_LTZ(flt)             (*(ULONG *)&(flt) > 0x80000000)
#define __GL_FLOAT_GEZ(flt)             (*(ULONG *)&(flt) <= 0x80000000)
#define __GL_FLOAT_LEZ(flt)             (*(LONG *)&(flt) <= 0)
#define __GL_FLOAT_EQZ(flt)             ((*(ULONG *)&(flt) & 0x7fffffff) == 0)
#define __GL_FLOAT_NEZ(flt)             ((*(ULONG *)&(flt) & 0x7fffffff) != 0)
#define __GL_FLOAT_COMPARE_PONE(flt, op) (*(LONG *)&(flt) op 0x3f800000)
#else
#define __GL_FLOAT_GTZ(flt)             ((flt) > __glZero)
#define __GL_FLOAT_LTZ(flt)             ((flt) < __glZero)
#define __GL_FLOAT_GEZ(flt)             ((flt) >= __glZero)
#define __GL_FLOAT_LEZ(flt)             ((flt) <= __glZero)
#define __GL_FLOAT_EQZ(flt)             ((flt) == __glZero)
#define __GL_FLOAT_NEZ(flt)             ((flt) != __glZero)
#define __GL_FLOAT_COMPARE_PONE(flt, op) ((flt) op __glOne)
#endif // _X86_

// These operations only account for positive zero.  -0 will not work
#ifdef _X86_
#define __GL_FLOAT_EQPZ(flt)            (*(LONG *)&(flt) == 0)
#define __GL_FLOAT_NEPZ(flt)            (*(LONG *)&(flt) != 0)
#define __GL_FLOAT_EQ(f1, f2)           (*(LONG *)&(f1) == *(LONG *)&(f2))
#define __GL_FLOAT_NE(f1, f2)           (*(LONG *)&(f1) != *(LONG *)&(f2))
#else
#define __GL_FLOAT_EQPZ(flt)            ((flt) == __glZero)
#define __GL_FLOAT_NEPZ(flt)            ((flt) != __glZero)
#define __GL_FLOAT_EQ(f1, f2)           ((f1) == (f2))
#define __GL_FLOAT_NE(f1, f2)           ((f1) != (f2))
#endif // _X86_

// Macro to start an FP divide in the FPU, used to overlap a
// divide with integer operations
// Can't just use C because it stores the result immediately
#ifdef _X86_

#define __GL_FLOAT_SIMPLE_BEGIN_DIVIDE(num, den, result) \
    __asm fld num \
    __asm fdiv den
#define __GL_FLOAT_SIMPLE_END_DIVIDE(result) \
    __asm fstp DWORD PTR result

__inline void __GL_FLOAT_BEGIN_DIVIDE(__GLfloat num, __GLfloat den,
                                      __GLfloat *result)
{
    __asm fld num
    __asm fdiv den
}
__inline void __GL_FLOAT_END_DIVIDE(__GLfloat *result)
{
    __asm mov eax, result
    __asm fstp DWORD PTR [eax]
}
#else
#define __GL_FLOAT_SIMPLE_BEGIN_DIVIDE(num, den, result) \
    ((result) = (num)/(den))
#define __GL_FLOAT_SIMPLE_END_DIVIDE(result)
#define __GL_FLOAT_BEGIN_DIVIDE(num, den, result) (*(result) = (num)/(den))
#define __GL_FLOAT_END_DIVIDE(result)
#endif // _X86_

//**********************************************************************
//
// Math helper functions and macros
//
//**********************************************************************

#define CASTFIX(a)              (*((LONG *)&(a)))
#define CASTINT(a)              CASTFIX(a)
#define CASTFLOAT(a)            (*((__GLfloat *)&(a)))

#define FLT_TO_RGBA(ul, pColor) \
    (ul) =\
    (((ULONG)(FLT_TO_UCHAR_SCALE(pColor->a, GENACCEL(gc).aAccelPrimScale)) << 24) | \
     ((ULONG)(FLT_TO_UCHAR_SCALE(pColor->r, GENACCEL(gc).rAccelPrimScale)) << 16) | \
     ((ULONG)(FLT_TO_UCHAR_SCALE(pColor->g, GENACCEL(gc).gAccelPrimScale)) << 8)  | \
     ((ULONG)(FLT_TO_UCHAR_SCALE(pColor->b, GENACCEL(gc).bAccelPrimScale))))

#define FLT_TO_CINDEX(ul, pColor) \
    (ul) =\
    ((ULONG)(FLT_TO_UCHAR_SCALE(pColor->r, GENACCEL(gc).rAccelPrimScale)) << 16)

#ifdef _X86_

#pragma warning(disable:4035) // Function doesn't return a value

// Convert float to int 15.16
__inline LONG __fastcall FLT_TO_FIX(
    float a)
{
    LARGE_INTEGER li;

    __asm {
        mov     eax, a
        test    eax, 07fffffffh
        jz      RetZero
        add     eax, 08000000h
        mov     a, eax
        fld     a
        fistp   li
        mov     eax, DWORD PTR li
        jmp     Done
    RetZero:
        xor     eax, eax
    Done:
    }
}

// Convert float to int 15.16, can cause overflow exceptions
__inline LONG __fastcall UNSAFE_FLT_TO_FIX(
    float a)
{
    LONG l;

    __asm {
        mov     eax, a
        test    eax, 07fffffffh
        jz      RetZero
        add     eax, 08000000h
        mov     a, eax
        fld     a
        fistp   l
        mov     eax, l
        jmp     Done
    RetZero:
        xor     eax, eax
    Done:
    }
}

// Convert float to int 0.31
__inline LONG __fastcall FLT_FRACTION(
    float a)
{
    LARGE_INTEGER li;

    __asm {
        mov     eax, a
        test    eax, 07fffffffh
        jz      RetZero
        add     eax, 0f800000h
        mov     a, eax
        fld     a
        fistp   li
        mov     eax, DWORD PTR li
        jmp     Done
    RetZero:
        xor     eax, eax
    Done:
    }
}

// Convert float to int 0.31, can cause overflow exceptions
__inline LONG __fastcall UNSAFE_FLT_FRACTION(
    float a)
{
    LONG l;

    __asm {
        mov     eax, a
        test    eax, 07fffffffh
        jz      RetZero
        add     eax, 0f800000h
        mov     a, eax
        fld     a
        fistp   l
        mov     eax, l
        jmp     Done
    RetZero:
        xor     eax, eax
    Done:
    }
}

#pragma warning(default:4035) // Function doesn't return a value

// Convert float*scale to int
__inline LONG __fastcall FLT_TO_FIX_SCALE(
    float a,
    float b)
{
    LARGE_INTEGER li;

    __asm {
        fld     a
        fmul    b
        fistp   li
    }

    return li.LowPart;
}

#define FLT_TO_UCHAR_SCALE(value_in, scale) \
    ((UCHAR)FLT_TO_FIX_SCALE(value_in, scale))

__inline LONG __fastcall FTOL(
    float a)
{
    LARGE_INTEGER li;

    _asm {
        fld     a
        fistp   li
    }

    return li.LowPart;
}

// Can cause overflow exceptions
__inline LONG __fastcall UNSAFE_FTOL(
    float a)
{
    LONG l;

    _asm {
        fld     a
        fistp   l
    }

    return l;
}

// Requires R-G-B to be FP stack 2-1-0
// Requires gc in edx
#define FLT_STACK_RGB_TO_GC_FIXED(rOffset, gOffset, bOffset)	              \
    __asm fld __glVal65536						      \
    __asm fmul st(3), st(0)						      \
    __asm fmul st(2), st(0)						      \
    __asm fmulp st(1), st(0)						      \
    __asm fistp DWORD PTR [edx+bOffset]					      \
    __asm fistp DWORD PTR [edx+gOffset]					      \
    __asm fistp DWORD PTR [edx+rOffset]					      

#define FPU_SAVE_MODE()                 \
    DWORD cwSave;                       \
    DWORD cwTemp;                       \
                                        \
    __asm {                             \
        _asm fnstcw  WORD PTR cwSave    \
        _asm mov     eax, cwSave        \
        _asm mov     cwTemp, eax        \
    }

#define FPU_RESTORE_MODE()              \
    __asm {                             \
        _asm fldcw   WORD PTR cwSave    \
    }

#define FPU_RESTORE_MODE_NO_EXCEPTIONS()\
    __asm {                             \
        _asm fnclex                     \
        _asm fldcw   WORD PTR cwSave    \
    }

#define FPU_CHOP_ON()                    \
    __asm {                              \
        _asm mov    eax, cwTemp          \
        _asm or     eax, 0x0c00          \
        _asm mov    cwTemp, eax          \
        _asm fldcw  WORD PTR cwTemp      \
    }

#define FPU_ROUND_ON()                   \
    __asm {                              \
        _asm mov    eax, cwTemp          \
        _asm and    eax,0xf3ff           \
        _asm mov    cwTemp, eax          \
        _asm fldcw  WORD PTR cwTemp      \
    }

#define FPU_ROUND_ON_PREC_HI()           \
    __asm {                              \
        _asm mov    eax, cwTemp          \
        _asm and    eax,0xf0ff           \
        _asm or     eax,0x0200           \
        _asm mov    cwTemp, eax          \
        _asm fldcw  WORD PTR cwTemp      \
    }

#define FPU_PREC_LOW()                   \
    __asm {                              \
        _asm mov    eax, cwTemp          \
        _asm and    eax, 0xfcff          \
        _asm mov    cwTemp, eax          \
        _asm fldcw  WORD PTR cwTemp      \
    }

#define FPU_PREC_LOW_MASK_EXCEPTIONS()   \
    __asm {                              \
        _asm mov    eax, cwTemp          \
        _asm and    eax, 0xfcff          \
        _asm or     eax, 0x3f            \
        _asm mov    cwTemp, eax          \
        _asm fldcw  WORD PTR cwTemp      \
    }

#define FPU_CHOP_ON_PREC_LOW()          \
    __asm {                             \
        _asm mov    eax, cwTemp         \
        _asm or     eax, 0x0c00         \
        _asm and    eax, 0xfcff         \
        _asm mov    cwTemp, eax         \
        _asm fldcw  WORD PTR cwTemp     \
    }

#define FPU_CHOP_OFF_PREC_HI()          \
    __asm {                             \
        _asm mov    eax, cwTemp         \
        _asm mov    ah, 2               \
        _asm mov    cwTemp, eax         \
        _asm fldcw  WORD PTR cwTemp     \
    }

#define CHOP_ROUND_ON()		
#define CHOP_ROUND_OFF()

#if DBG
#define ASSERT_CHOP_ROUND()         \
    {                               \
        WORD cw;                    \
        __asm {                     \
            __asm fnstcw cw         \
        }                           \
        ASSERTOPENGL((cw & 0xc00) == 0xc00, "Chop round must be on\n"); \
    }
#else
#define ASSERT_CHOP_ROUND()
#endif

#else // _X86_

#define FTOL(value) \
    ((GLint)(value))
#define UNSAFE_FTOL(value) \
    FTOL(value)
#define FLT_TO_FIX_SCALE(value_in, scale) \
    ((GLint)((__GLfloat)(value_in) * scale))
#define FLT_TO_UCHAR_SCALE(value_in, scale) \
    ((UCHAR)((GLint)((__GLfloat)(value_in) * scale)))
#define FLT_TO_FIX(value_in) \
    ((GLint)((__GLfloat)(value_in) * FIX_SCALEFACT))
#define UNSAFE_FLT_TO_FIX(value_in) \
    FLT_TO_FIX(value_in)
#define FLT_FRACTION(f) \
    FTOL((f) * __glVal2147483648)
#define UNSAFE_FLT_FRACTION(f) \
    FLT_FRACTION(f)

#define FPU_SAVE_MODE()
#define FPU_RESTORE_MODE()
#define FPU_RESTORE_MODE_NO_EXCEPTIONS()
#define FPU_CHOP_ON()
#define FPU_ROUND_ON()
#define FPU_ROUND_ON_PREC_HI()
#define FPU_PREC_LOW()
#define FPU_PREC_LOW_MASK_EXCEPTIONS()
#define FPU_CHOP_ON_PREC_LOW()
#define FPU_CHOP_OFF_PREC_HI()
#define CHOP_ROUND_ON()
#define CHOP_ROUND_OFF()
#define ASSERT_CHOP_ROUND()

#endif  //_X86_

//**********************************************************************
//
// Fast math routines/macros.  These may assume that the FPU is in
// single-precision, truncation mode as defined by the CPU_XXX macros.
//
//**********************************************************************

#ifdef _X86_

__inline float __gl_fast_ceilf(float f)
{
    LONG i;

    ASSERT_CHOP_ROUND();
    
    i = FTOL(f + ((float)1.0 - (float)FLT_EPSILON));

    return (float)i;
}

__inline float __gl_fast_floorf(float f)
{
    LONG i;

    ASSERT_CHOP_ROUND();

    if (__GL_FLOAT_LTZ(f)) {
        i = FTOL(f - ((float)1.0 - (float)FLT_EPSILON));
    } else {
        i = FTOL(f);
    }

    return (float)i;
}

__inline LONG __gl_fast_floorf_i(float f)
{
    ASSERT_CHOP_ROUND();

    if (__GL_FLOAT_LTZ(f)) {
        return FTOL(f - ((float)1.0 - (float)FLT_EPSILON));
    } else {
        return FTOL(f);
    }
}

#define __GL_FAST_FLOORF_I(f)  __gl_fast_floorf_i(f)
#define __GL_FAST_FLOORF(f)  __gl_fast_floorf(f)
#define __GL_FAST_CEILF(f)   __gl_fast_ceilf(f)

#else

#define __GL_FAST_FLOORF_I(f)  ((GLint)floor((double) (f)))
#define __GL_FAST_FLOORF(f)  ((__GLfloat)floor((double) (f)))
#define __GL_FAST_CEILF(f)   ((__GLfloat)ceil((double) (f)))

#endif


//**********************************************************************
//
// Other various macros:
//
//**********************************************************************


// Z16_SCALE is the same as FIX_SCALEFACT
#define FLT_TO_Z16_SCALE(value) FLT_TO_FIX(value)

/* NOTE: __glzValue better be unsigned */
#define __GL_Z_SIGN_BIT(z) \
    ((z) >> (sizeof(__GLzValue) * __GL_BITS_PER_BYTE - 1))

#ifdef NT
#define __GL_STIPPLE_MSB	1
#endif /* NT */

#endif /* __glcpu_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\dlist.h ===
#ifndef __gldlist_h_
#define __gldlist_h_

/*
** Copyright 1991-1993, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, copied or
** duplicated in any form, in whole or in part, without the prior written
** permission of Silicon Graphics, Inc.
**
** RESTRICTED RIGHTS LEGEND:
** Use, duplication or disclosure by the Government is subject to restrictions
** as set forth in subdivision (c)(1)(ii) of the Rights in Technical Data
** and Computer Software clause at DFARS 252.227-7013, and/or in similar or
** successor clauses in the FAR, DOD or NASA FAR Supplement. Unpublished -
** rights reserved under the Copyright Laws of the United States.
**
** Display list state descriptions.
**
*/
#include "os.h"
#include "types.h"

typedef const GLubyte * FASTCALL __GLlistExecFunc(__GLcontext *gc, const GLubyte *);

/* 
** Maximum recursive nesting of display list calls.
*/
#define __GL_MAX_LIST_NESTING		64

//
// Turn on list sharing for NT if we're a client/server implementation
//
#ifdef NT
#define NT_SERVER_SHARE_LISTS
#endif

#ifndef NT
/* 
** Machine specific opcodes should start here.  All opcodes lower than 
** this are reserved by the generic code.
*/
#define __GL_MACHINE_DLIST_OPCODE	10000

typedef void (FASTCALL *__GLdlistFreeProc)(__GLcontext *gc, GLubyte *);

/*
** A compiled, unoptimized dlist.  Conceptually a linked list of operations.
** An optimizer may work through the operations and delete, add, or change 
** them.
**
** These are only stored transiently.  They are created, optimized, and 
** converted into optimized dlists.
**
** This structure *MUST* be set up so that data is doubleword aligned!
*/
struct __GLdlistOpRec {
    __GLdlistOp *next;		/* Linked list chain */
    __GLdlistFreeProc dlistFree;
				/* This dlist free function is called when
				** the entire dlist is freed.  It is passed
				** a pointer to data.  It should *not* free
				** data, but only any memory that has been
				** allocated and is pointed to by the
				** structure contained in data (which will
				** be freed after this function returns).
				*/ 
    GLuint size;		/* Actual size of data */
    GLshort opcode;		/* Opcode for this operation */
    GLboolean aligned;		/* GL_TRUE if data needs to be doubleword 
				** aligned.
				*/
    GLboolean pad1;		/* Padding */
    GLubyte data[4];		/* Variable size */
};

typedef struct __GLcompiledDistRec {
    GLint freeCount;		/* Number of free functions defined */
    GLuint genericFlags;	/* Flags needed by generic optimizers */
    GLuint machineFlags;	/* Machine controlled flags */
    __GLdlistOp *dlist;		/* The linked list of operations */
    __GLdlistOp *lastDlist;	/* For quick appends */
} __GLcompiledDlist;

typedef struct __GLDlistFreeFnRec {
    __GLdlistFreeProc freeFn;
    GLubyte *data;
} __GLDlistFreeFn;
#endif // !NT

/* 
** A fully optimized dlist.  One of these is stored for every permanent
** dlist.
**
** NOTE: 'head' is assumed to start at word offset, but NOT a double word
** offset!
*/
typedef struct __GLdlistRec __GLdlist;
struct __GLdlistRec {
    GLuint refcount;	/* To deal with multi-threading, must be first */
    GLuint size;	/* Total size of this block */
#ifndef NT
    GLint freeCount;	/* Number of operations */
    __GLDlistFreeFn *freeFns;	/* Array of functions called before freeing */
#endif
    GLubyte *end;	/* End of optimized block */
#ifdef NT
#if 0
    GLint drawBuffer;   /* Contains DrawBuffer calls or not,
                           used for optimizing lock checking in
                           DCLDispatchLoop */
#endif
    GLuint used;        /* Amount of space used in the list so far */
    __GLdlist *nextBlock; /* Next block in chain of blocks */
#if 0
    GLuint pad;         /* Pad to put head on a word offset */
#endif
#endif // NT
    GLubyte head[4];	/* Optimized block (variable size) */
};

#ifdef NT
// Adds on overhead bytes for a given dlist op data size
// Currently the only overhead is four bytes for the function pointer
#define DLIST_SIZE(n) ((n)+sizeof(__GLlistExecFunc *))
#define DLIST_GENERIC_OP(name) __glle_##name
#else
#define DLIST_SIZE(n) (n)
#define DLIST_GENERIC_OP(name) __glop_##name
#define DLIST_OPT_OP(name) __glop_##name
#endif

#ifndef NT
/*
** Some data structure for storing and retrieving display lists quickly.
** This structure is kept hidden so that a new implementation can be used
** if desired.
*/
typedef struct __GLdlistArrayRec __GLdlistArray;
#endif

typedef struct __GLdlistMachineRec {
#ifndef NT
    __GLdlistArray *dlistArray;
#endif
    __GLnamesArray *namesArray;

#ifndef NT
    /*
    ** The optimizer for the display list.  Runs through a __GLcompiledDlist
    ** and deletes, changes, adds operations.  Presumably, this optimizer
    ** will be a set of function calls to other optimizers (some provided
    ** by the generic dlist code, some by machine specific code).
    **
    ** Operations created by the machine specific optimizers need to have
    ** opcodes starting with __GL_MACHINE_DLIST_OPCODE.
    */
    void (FASTCALL *optimizer)(__GLcontext *gc, __GLcompiledDlist *);

    /*
    ** This routine is called before puting each new command into the 
    ** display list at list compilation time.
    */
    void (FASTCALL *checkOp)(__GLcontext *gc, __GLdlistOp *);
#endif
    
    /*
    ** This routine is called when a new display list is about to be 
    ** compiled.
    */
    void (FASTCALL *initState)(__GLcontext *gc);

#ifndef NT
    /* 
    ** Array of functions pointers used for display list execution of 
    ** generic ops.
    */
    __GLlistExecFunc **baseListExec;

    /* 
    ** Array of functions pointers used for display list execution of 
    ** generic optimizations.
    */
    __GLlistExecFunc **listExec;

    /*
    ** The machine specific list execution routines.  These function
    ** pointers are bound into the display list at list compilation time,
    ** so it is illegal to be changing these dynamically based upon the 
    ** machine state.  Any optimizations based upon the current state need
    ** to be performed in the machine specific code.  The first entry of
    ** this array corresponds to opcode __GL_MACHINE_DLIST_OPCODE, and 
    ** subsequent entries correspond to subsequent opcodes.
    **
    ** machineListExec is a pointer to an array of function pointers.
    */
    __GLlistExecFunc **machineListExec;
#endif

    /*
    ** If a list is being executed (glCallList or glCallLists) then this
    ** is the current nesting of calls.  It is constrained by the limit
    ** __GL_MAX_LIST_NESTING (this prevents infinite recursion).
    */
    GLint nesting;

    /*
    ** GL_COMPILE or GL_COMPILE_AND_EXECUTE.
    */
    GLenum mode;

    /*
    ** List being compiled - 0 means none.
    */
    GLuint currentList;

#ifdef NT
    /* Points to the current begin record when compiling poly array */
    struct __gllc_Begin_Rec *beginRec;

    /* Skip compiling of the next PolyData when compiling poly array */
    GLboolean skipPolyData;
#endif

#if 0
#ifdef NT
    // Whether the current list contains a DrawBuffer call or not
    GLboolean drawBuffer;
#endif
#endif

#ifndef NT
    /*
    ** Data for the current list being compiled.
    */
    __GLcompiledDlist listData;

    /*
    ** For fast memory manipulation.  Check out soft/so_memmgr for details.
    */
    __GLarena *arena;
#else
    /*
    ** Data for current list
    */
    __GLdlist *listData;
#endif
} __GLdlistMachine;

#ifndef NT
extern void FASTCALL__glDestroyDisplayLists(__GLcontext *gc);
#endif
#ifdef NT_SERVER_SHARE_LISTS
extern GLboolean FASTCALL __glCanShareDlist(__GLcontext *gc, __GLcontext *share_cx);
#endif
extern void FASTCALL __glShareDlist(__GLcontext *gc, __GLcontext *share_cx);

// Perform thread-exit cleanup for dlists
#ifdef NT_SERVER_SHARE_LISTS
extern void __glDlistThreadCleanup(__GLcontext *gc);
#endif

/*
** Assorted routines needed by dlist compilation routines.
*/

/* 
** Create and destroy display list ops.  __glDlistAllocOp2() sets an
** out of memory error before returning NULL if there is no memory left.
*/
#ifndef NT
extern __GLdlistOp *__glDlistAllocOp(__GLcontext *gc, GLuint size);
extern __GLdlistOp *__glDlistAllocOp2(__GLcontext *gc, GLuint size);
extern void FASTCALL __glDlistFreeOp(__GLcontext *gc, __GLdlistOp *op);

/*
** Append the given op to the currently under construction list.
*/
extern void FASTCALL __glDlistAppendOp(__GLcontext *gc, __GLdlistOp *newop,
                                       __GLlistExecFunc *listExec);
#else
extern __GLdlist *__glDlistGrow(GLuint size);
#endif

/*
** Create and destroy optimized display lists.
*/
extern __GLdlist *__glAllocDlist(__GLcontext *gc, GLuint size);
extern void FASTCALL __glFreeDlist(__GLcontext *gc, __GLdlist *dlist);

#ifndef NT
/*
** Generic dlist memory manager.
*/
extern void *__glDlistAlloc(GLuint size);
extern void *__glDlistRealloc(void *oldmem, GLuint oldsize, GLuint newsize);
extern void FASTCALL __glDlistFree(void *memory, GLuint size);

/*
** Generic table of display list execution routines.
*/
extern __GLlistExecFunc *__glListExecTable[];
#endif

#endif /* __gldlist_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\multimedia\opengl\server\inc\feedback.h ===
#ifndef __glfeedback_h_
#define __glfeedback_h_

/*
** Copyright 1991, Silicon Graphics, Inc.
** All Rights Reserved.
**
** This is UNPUBLISHED PROPRIETARY SOURCE CODE of Silicon Graphics, Inc.;
** the contents of this file may not be disclosed to third parties, c