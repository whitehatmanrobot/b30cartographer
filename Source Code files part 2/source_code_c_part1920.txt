*********************************************************************

    AdjustedColor = (UserColorFormat & ~0x01100000);

    for (i=0; i < 5; i++)
        {
        if (AdjustedColor == HwDeviceExtension->ColorFormatTable[i])
            {
            Pobject->ColorFormat = DRF_NUM(_PGRAPH, _CTX_SWITCH,_COLOR_BUFFER,i);

            //******************************************************************
            // Determine if we need to set the ALPHA bit for this color format
            //******************************************************************

            if (UserColorFormat & 0x00100000)
                Pobject->ColorFormat |= DRF_DEF(_PGRAPH,_CTX_SWITCH,_ALPHA,_ENABLED);
            }
        }

    //**************************************************************************
    // Set the MonoFormat bit (either 0 or 1)
    //**************************************************************************

    Pobject->MonoFormat = MonoFormat;

    }


//******************************************************************************
//
//  Function:   ClearPatchContext()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID ClearPatchContext(PHW_DEVICE_EXTENSION HwDeviceExtension,
                        PPATCHCONTEXT PatchContext)

    {
    ULONG i;

    //**************************************************************************
    // Initialize context configuration.
    //**************************************************************************

    PatchContext->ImageConfig  = DRF_NUM(_PGRAPH, _CTX_SWITCH, _PATCH_CONFIG, 0x17);
    PatchContext->VideoConfig  = (ULONG)NULL;
//    PatchContext->ImageVideo   = NULL;
//    PatchContext->Canvas       = NULL;
//    PatchContext->Rop          = NULL;
//    PatchContext->RopPat       = NULL;
//    PatchContext->RopDst       = NULL;
//    PatchContext->Beta         = NULL;
//    PatchContext->BetaSrc      = NULL;
//    PatchContext->BetaPat      = NULL;
//    PatchContext->BetaDst      = NULL;
//    PatchContext->ColorKey     = NULL;
//    PatchContext->PlaneMask    = NULL;
//    PatchContext->PlaneMaskDst = NULL;
//    PatchContext->Clip         = NULL;
//    PatchContext->Pattern      = NULL;
//    PatchContext->ColorMap0    = NULL;
//    PatchContext->ColorMap1    = NULL;
//    PatchContext->VideoSwitch  = NULL;

    }

//******************************************************************************
//
//  Function:   NV1SetupPatches()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV1SetupPatches(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    PRENDEROBJECT PObject;
    ULONG Data;
    ULONG PatchCount;
    PHWINFO NVInfo;
    ULONG ColorFormat;
    ULONG MonoFormat;

    //**************************************************************************
    //
    // Enable FLOWTHRU
    //
    //      In order to access many of the registers in the Graphics Engine,
    //      we need to enable FLOWTHRU and disable the FIFO engine.
    //      FLOWTHRU = ENABLED,  FIFO = DISABLED, DMA = DISABLED
    //      CLASS = 0 to specify graphics registers.
    //
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO,_DISABLED)          |
                            DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
                            DRF_DEF(_PGRAPH,_MISC,_DMA,_DISABLED)           |
                            DRF_DEF(_PGRAPH,_MISC,_CLASS_WRITE,_ENABLED)    |
                            DRF_NUM(_PGRAPH,_MISC,_CLASS,0));

    //**************************************************************************
    // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
    //**************************************************************************

    GR_DONE;

    //**************************************************************************
    // Checks for any interrupt requests.  For this miniport,
    // we shouldn't be getting any
    //**************************************************************************

    GR_IDLE;

    //**************************************************************************
    // Reset interrupt registers
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_INTR_0, 0x11111111);
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_INTR_1, 0x11111111);

    //**************************************************************************
    // Init the PatchContexts to NULL for all the patches that we'll be using
    //**************************************************************************

    for (PatchCount=0; PatchCount < NUM_PATCHES; PatchCount++)
       {

       //***********************************************************************
       // Get the RENDER object structure that will be used for this patch
       //***********************************************************************

       PObject = &(HwDeviceExtension->RenderObject[PatchCount]);

       //***********************************************************************
       // Initialize the patch context values
       //***********************************************************************

       ClearPatchContext(HwDeviceExtension, &(PObject->RCPatchContext));

       }



    //**************************************************************************
    // Set the color format according to what the current mode depth is
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    switch (NVInfo->Framebuffer.Depth)
        {
        case 32:
            ColorFormat = NV_COLOR_FORMAT_LE_X8R8G8B8;
            break;
        case 16:
            ColorFormat = NV_COLOR_FORMAT_LE_X17R5G5B5;
            break;
        case 8:
            ColorFormat = NV_COLOR_FORMAT_LE_X24Y8;
            break;
        default:
            ColorFormat = NV_COLOR_FORMAT_LE_X8R8G8B8;
            break;
        }

    //**************************************************************************
    // Default mono format is 0 and ALPHA NOT enabled
    //**************************************************************************

    MonoFormat = MONO_FORMAT_LE;

    //**************************************************************************
    // Now setup the individual patches that we'll be using for
    // the NT Display driver
    //**************************************************************************

RECTANGLE:

    //**************************************************************************
    // Set Patch for RECTANGLE
    //**************************************************************************

    SetPatchContext(HwDeviceExtension, RECTANGLE_PATCH);

    //**************************************************************************
    // Setup the Render object (MY_RENDER_SOLID_RECTANGLE)
    //**************************************************************************

    MonoFormat = MONO_FORMAT_LE;
    SetupRenderObject(HwDeviceExtension, RECTANGLE_SUBCHANNEL, RECTANGLE_PATCH,
                      NV_RENDER_SOLID_RECTANGLE, MY_RENDER_SOLID_RECTANGLE,
                      ColorFormat,MonoFormat);

    //**************************************************************************
    // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
    // And check for any interrupt requests.  For this miniport, shouldn't getting any !!
    //**************************************************************************

    GR_DONE;
    GR_IDLE;


TRIANGLE:

    //**************************************************************************
    // Since we've only got 8 subchannels, we don't have enough room for the
    // TRIANGLE object.  If we need it use it later (i.e. Direct 3D/OpenGL), we'll need
    // to manually swap out one of the current objects and load the TRIANGLE object
    //**************************************************************************


//    //**************************************************************************
//    // Set Patch for TRIANGLE
//    //**************************************************************************
//
//    SetPatchContext(HwDeviceExtension, TRIANGLE_PATCH);
//
//    //**************************************************************************
//    // Setup the Render object (MY_RENDER_SOLID_TRIANGLE)
//    //**************************************************************************
//
//    MonoFormat = MONO_FORMAT_LE;
//    SetupRenderObject(HwDeviceExtension,TRIANGLE_SUBCHANNEL,TRIANGLE_PATCH ,
//                      NV_RENDER_SOLID_TRIANGLE, MY_RENDER_SOLID_TRIANGLE,
//                      ColorFormat,MonoFormat);
//
//    //**************************************************************************
//    // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
//    // And check for any interrupt requests.  For this miniport, shouldn't getting any !!
//    //**************************************************************************
//
//    GR_DONE;
//    GR_IDLE;


BLIT:

    //**************************************************************************
    // Set Patch for BLIT
    //**************************************************************************

    SetPatchContext(HwDeviceExtension, BLIT_PATCH);

    //**************************************************************************
    // Setup the BLIT object
    //**************************************************************************

    MonoFormat = MONO_FORMAT_LE;
    SetupRenderObject(HwDeviceExtension,BLIT_SUBCHANNEL,BLIT_PATCH ,
                      NV_IMAGE_BLIT, MY_RENDER_SCRN_TO_SCRN_BLIT,
                      ColorFormat, MonoFormat);

    //**************************************************************************
    // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
    // And check for any interrupt requests.  For this miniport, shouldn't getting any !!
    //**************************************************************************

    GR_DONE;
    GR_IDLE;


CPU_TO_SCREEN_BLIT:

    //**************************************************************************
    // Set Patch for IMAGE FROM CPU
    //**************************************************************************

    SetPatchContext(HwDeviceExtension, IMAGE_FROM_CPU_PATCH);

    //**************************************************************************
    // Setup the IMAGE_FROM_CPU object
    //**************************************************************************

    MonoFormat = MONO_FORMAT_LE;
    SetupRenderObject(HwDeviceExtension,IMAGE_FROM_CPU_SUBCHANNEL,IMAGE_FROM_CPU_PATCH,
                      NV_IMAGE_FROM_CPU, MY_IMAGE_FROM_CPU_BLIT,
                      ColorFormat, MonoFormat);

    //**************************************************************************
    // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
    // And check for any interrupt requests.  For this miniport, shouldn't getting any !!
    //**************************************************************************

    GR_DONE;
    GR_IDLE;



IMAGE_MONO_BLIT:

    //**************************************************************************
    // For text, we want color 0 (background) to be transparent
    // So set the color format appropriately with ALPHA channel enabled
    //**************************************************************************

    switch (NVInfo->Framebuffer.Depth)
        {
        case 32:
            ColorFormat = NV_COLOR_FORMAT_LE_A8R8G8B8;
            break;
        case 16:
            ColorFormat = NV_COLOR_FORMAT_LE_X16A1R5G5B5;
            break;
        case 8:
            ColorFormat = NV_COLOR_FORMAT_LE_X16A8Y8;
            break;
        default:
            ColorFormat = NV_COLOR_FORMAT_LE_A8R8G8B8;
            break;
        }

    //**************************************************************************
    // Set Patch for IMAGE MONO FROM CPU
    //**************************************************************************

    SetPatchContext(HwDeviceExtension, IMAGE_MONO_FROM_CPU_PATCH);

    //**************************************************************************
    // Setup the IMAGE_MONO_FROM_CPU object
    //**************************************************************************

    MonoFormat = MONO_FORMAT_CGA6;
    SetupRenderObject(HwDeviceExtension,IMAGE_MONO_FROM_CPU_SUBCHANNEL,IMAGE_MONO_FROM_CPU_PATCH,
                      NV_IMAGE_MONOCHROME_FROM_CPU, MY_IMAGE_MONO_FROM_CPU_BLIT,
                      ColorFormat, MonoFormat);

    //**************************************************************************
    // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
    // And check for any interrupt requests.  For this miniport, shouldn't getting any !!
    //**************************************************************************

    GR_DONE;
    GR_IDLE;



    //**************************************************************************
    // We're done with the Graphics registers for now.
    // Make sure the FIFO and DMA engines are enabled.
    //
    //      FLOWTHRU = ENABLED,  FIFO = ENABLED, DMA = ENABLED
    //
    // DON'T TOUCH THE CLASS bits!!
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO,_ENABLED)           |
                            DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
                            DRF_DEF(_PGRAPH,_MISC,_DMA,_ENABLED));

    }




//******************************************************************************
//
//  Function:   SetupRenderObject()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID SetupRenderObject(PHW_DEVICE_EXTENSION HwDeviceExtension,
                       ULONG SubChannel, ULONG PatchID,
                       ULONG RenderObjectClass, ULONG UserObjectName,
                       ULONG ColorFormat, ULONG MonoFormat)

    {
    PCOMMONOBJECT PObject;
    ULONG Class;
    ULONG Instance;
    ULONG Data;

    //**************************************************************************
    //
    // Enable FLOWTHRU
    //
    //      In order to access many of the registers in the Graphics Engine,
    //      we need to enable FLOWTHRU and disable the FIFO engine.
    //
    //      FLOWTHRU = ENABLED,  FIFO = DISABLED, DMA = DISABLED
    //      CLASS = 0 to access graphics registers.
    //
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO,_DISABLED)          |
                            DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
                            DRF_DEF(_PGRAPH,_MISC,_DMA,_DISABLED)           |
                            DRF_DEF(_PGRAPH,_MISC,_CLASS_WRITE,_ENABLED)    |
                            DRF_NUM(_PGRAPH,_MISC,_CLASS,0));

    //**************************************************************************
    // Get a ptr to the RENDER object structure (Source Object)
    //**************************************************************************

    PObject = (PCOMMONOBJECT) &(HwDeviceExtension->RenderObject[PatchID]);

    //**************************************************************************
    // Save the user specified name of the object
    // Also mark which object is currently using the specified subchannel
    //**************************************************************************

    PObject->Base.Name = UserObjectName;
    HwDeviceExtension->FifoTable.ObjectStack[SubChannel] = UserObjectName;

    //**************************************************************************
    // Set Color format of the RENDER object
    //**************************************************************************

    SetObjectColorFormat(HwDeviceExtension,PObject,ColorFormat,MonoFormat);

    //**************************************************************************
    // After updating non-rendering objects and their contexts,
    // we now need to calculate the context for the the RENDER object.
    //
    // A Simple Patch:
    //
    //      RENDER SOLID  ----->  IMAGE TO  ------>  VIDEO SINK
    //        RECTANGLE             VIDEO
    //
    //**************************************************************************

    CalculateRenderObjectContext(HwDeviceExtension,(PRENDEROBJECT)PObject,RenderObjectClass);

    //**************************************************************************
    // CAREFUL!
    //
    // 1) When setting Device specific CTX_SWITCH registers,
    //    an INTERRUPT is generated.  So to avoid this,
    //    DISABLE interrupts when setting these registers !!
    //
    //     - Update-> The reason why interrupts were being generated
    //                is because the PATCH_ID switch was getting SET
    //                in the CTX_SWITCH register.  This is ok for Resource
    //                Manager code which handles interrupts, but here in this
    //                Miniport, we're doing a ONE TIME init of all the objects
    //                and don't want interrupts.  Disabling/Enabling
    //                interrupts around the USER_xxx_CTX_SWITCH registers
    //                is no longer necessary.  Oh Yeah!
    //
    // 2) If the object changed or is NEW, we need to set the device's
    //    OWN context switch register (as opposed to PGRAPH_CTX_SWITCH)
    //    First determine the device, then load the instance in the specific
    //    device's CTX_SWITCH register.  However, be aware that this WILL CLEAR
    //    FLOWTHRU !!! We need to make sure and re-enable it. Otherwise,
    //    subsequent functions which touch graphics registers may not work correctly.
    //
    // 2)  Also, the CTX_SWITCH register MUST be set BEFORE we call
    //     UpdateRenderObjectContext().  Otherwise, the graphics engine
    //     will stop when rendering the object.  I'm not sure I understand
    //     why this is, but for now, just make sure it occurs BEFORE, not AFTER.
    //
    //**************************************************************************

//    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_INTR_EN_0, 0x00000000);

    //**************************************************************************
    // Get the physical instance from the context (Bottom 16 bits)
    // We will always be using Channel 0 (Specified in the Upper bits)
    //**************************************************************************

    Instance = (PObject->Context) & 0x0000ffff;

    switch (RenderObjectClass)
        {
        case NV_RENDER_SOLID_POINT:
            break;
        case NV_RENDER_SOLID_LINE:
            break;
        case NV_RENDER_SOLID_LIN:
            break;
        case NV_RENDER_SOLID_TRIANGLE:
            UTRI_REG_WR32(UTRI_Base, NV_UTRI_CTX_SWITCH, (0 | Instance) );
            break;
        case NV_RENDER_SOLID_RECTANGLE:
            URECT_REG_WR32(URECT_Base, NV_URECT_CTX_SWITCH, (0 | Instance) );
            break;
        case NV_RENDER_TEXTURE_BILINEAR:
            break;
        case NV_RENDER_TEXTURE_QUADRATIC:
            break;
        case NV_IMAGE_BLIT:
            UBLIT_REG_WR32(UBLIT_Base, NV_UBLIT_CTX_SWITCH, (0 | Instance) );
            break;
        case NV_IMAGE_FROM_CPU:
            UIMAGE_REG_WR32(UIMAGE_Base, NV_UIMAGE_CTX_SWITCH, (0 | Instance) );
            break;
        case NV_IMAGE_MONOCHROME_FROM_CPU:
            UBITMAP_REG_WR32(UIMAGE_Base, NV_UBITMAP_CTX_SWITCH, (0 | Instance) );
            break;
        default:
            break;
        }

//    //*************************************************************************
//    // Now that we've set the device specific CTX_SWITCH register,
//    // re-enable interrupts
//    //*************************************************************************
//
//    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_INTR_EN_0, 0x11111111);

    //**************************************************************************
    // FLOWTHRU was cleared up above! Make sure and RE-enable it,
    // Otherwise, UpdateRenderObjectContext may not work correctly.
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO,_DISABLED));

    //**************************************************************************
    // Now store the context for the RENDER object
    //**************************************************************************

    UpdateRenderObjectContext(HwDeviceExtension, UserObjectName, SubChannel,
                              PObject->Context);

    //**************************************************************************
    // FifoResend may be useful for debugging later on (not yet tested)
    //**************************************************************************

//    FifoResend(HwDeviceExtension);

    //**************************************************************************
    // Determine the CLASS value to store in the PGRAPH_MISC register
    // See Appendix E of the Graphics Register reference
    //**************************************************************************

    switch (RenderObjectClass)
        {
        case NV_RENDER_SOLID_POINT:
            Class = 0x8;
            break;
        case NV_RENDER_SOLID_LINE:
            Class = 0x9;
            break;
        case NV_RENDER_SOLID_LIN:
            Class = 0xA;
            break;
        case NV_RENDER_SOLID_TRIANGLE:
            Class = 0xB;
            break;
        case NV_RENDER_SOLID_RECTANGLE:
            Class = 0xC;
            break;
        case NV_RENDER_TEXTURE_BILINEAR:
            Class = 0xD;
            break;
        case NV_RENDER_TEXTURE_QUADRATIC:
            Class = 0xE;
            break;
        case NV_IMAGE_BLIT:
            Class = 0x10;       // UBLIT
            break;
        case NV_IMAGE_FROM_CPU:
            Class = 0x11;       // UIMAGE
            break;
        case NV_IMAGE_MONOCHROME_FROM_CPU:
            Class = 0x12;       // UBITMAP
            break;
        default:
            Class = 8;      // Default to a Point
            break;
        }

    //**************************************************************************
    // Prepare to put this value in the GRAPHIC_MISC register, Bit position 12.
    //**************************************************************************

    Class = Class << 12;

    //**************************************************************************
    // We're done modifying the Graphics registers.
    // ReEnable the FIFO and DMA engines as well as
    // specify the CLASS of the object.
    //
    //      FLOWTHRU = ENABLED,  FIFO = ENABLED, DMA = ENABLED
    //
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO,_ENABLED)           |
                            DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
                            DRF_DEF(_PGRAPH,_MISC,_DMA,_ENABLED)            |
                            DRF_DEF(_PGRAPH,_MISC,_CLASS_WRITE,_ENABLED)    |
                            Class);

    //**************************************************************************
    // Enable CACHE1.  Do NOT enable CACHE0 (Why? Runout data present?).
    // Otherwise, the rendering functions will NOT work.
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_ENABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_ENABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHES,_REASSIGN,_ENABLED);

    }


//******************************************************************************
//
//  Function:   ClearOutRenderObjects()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID ClearOutRenderObjects(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    ULONG i;
    ULONG Length;
    ULONG ObjectCount;
    PULONG Ptr;

    //**************************************************************************
    // Get length of RENDER object structure (in Dwords)
    //**************************************************************************

    Length = sizeof(RENDEROBJECT)/4;

    //**************************************************************************
    // Fill render object memory with zeros
    //**************************************************************************

    for (ObjectCount=0; ObjectCount < 10; ObjectCount++)
        {
        Ptr = (PULONG)&(HwDeviceExtension->RenderObject[ObjectCount]);

        //**********************************************************************
        // Clear out one object
        //**********************************************************************

        for (i=0; i<Length; i++)
            {
            *Ptr = 0;
            Ptr++;
            }

        }

    }


//******************************************************************************
//
//  Function:   NV1GetNVInfo()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

BOOLEAN NV1GetNVInfo(PHW_DEVICE_EXTENSION HwDeviceExtension)


    {
    PHWINFO NVInfo;
    ULONG refresh;
    ULONG DepthIndex;
    ULONG i,j;
    BOOLEAN status=TRUE;

    //**************************************************************************
    // Get ptr to NVInfo structure
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    //**************************************************************************
    // Get Chip revision and implementation
    //**************************************************************************

    NVInfo->Chip.Implementation = PMC_REG_RD_DRF(PMC_Base,_PMC,_BOOT_0,_IMPLEMENTATION);
    NVInfo->Chip.Revision = PMC_REG_RD_DRF(PMC_Base,_PMC,_BOOT_0,_REVISION);
    NVInfo->Chip.Architecture = PMC_REG_RD_DRF(PMC_Base,_PMC,_BOOT_0,_ARCHITECTURE);
    NVInfo->Chip.Manufacturer = PMC_REG_RD_DRF(PMC_Base,_PMC,_BOOT_0,_MANUFACTURER);

    //**************************************************************************
    // Get memory type
    //**************************************************************************

    NVInfo->Framebuffer.RamType = PEXTDEV_REG_RD_DRF(PEXTDEV_Base,_PEXTDEV,_BOOT_0,_STRAP_RAM_TYPE) ==
                            NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_VRAM ? BUFFER_VRAM : BUFFER_DRAM;

    //**************************************************************************
    // Get amount of VRAM
    //**************************************************************************

    switch (PFB_REG_RD_DRF(PFB_Base,_PFB,_BOOT_0, _RAM_AMOUNT))
        {
        case NV_PFB_BOOT_0_RAM_AMOUNT_4MB:
            NVInfo->Framebuffer.RamSizeMb = 4;
            NVInfo->Framebuffer.RamSize   = 0x00400000;
            break;
        case NV_PFB_BOOT_0_RAM_AMOUNT_2MB:
            NVInfo->Framebuffer.RamSizeMb = 2;
            NVInfo->Framebuffer.RamSize   = 0x00200000;
            break;
        case NV_PFB_BOOT_0_RAM_AMOUNT_1MB:
            NVInfo->Framebuffer.RamSizeMb = 1;
            NVInfo->Framebuffer.RamSize   = 0x00100000;
            break;
        default:
            //******************************************************************
            // Invalid memory configuration
            //******************************************************************
            status=FALSE;
            return(status);
        }

    //**************************************************************************
    // Don't forget to fixup the RangeOffset array.
    // NVIsPresent() put a default value (4Mb) for the length of the Dumb Frame Buffer..
    // Now that we know what the correct memory size is, let's make sure to
    // update the correct value.
    //**************************************************************************

    RangeOffsets[NV_PDFB_INDEX].ulLength =  NVInfo->Framebuffer.RamSize;

    //**************************************************************************
    // Default to 640x480x16x1 framebuffer with VGA timing
    //**************************************************************************

    NVInfo->Framebuffer.DpmLevel          = 0;
    NVInfo->Framebuffer.Resolution        = RESOLUTION_640X480;
    NVInfo->Framebuffer.Depth             = 16;
    NVInfo->Framebuffer.RefreshRate       = 60;
    NVInfo->Framebuffer.Count             = 1;
    NVInfo->Framebuffer.ActiveCount       = 1;
    NVInfo->Framebuffer.ActiveMask        = 1;
    NVInfo->Framebuffer.Current           = 0;
    NVInfo->Framebuffer.FlipUsageCount    = 0;
    NVInfo->Framebuffer.FlipTo            = 0;
    NVInfo->Framebuffer.FlipFrom          = 0;
    NVInfo->Framebuffer.UpdateFlags       = 0;
    NVInfo->Framebuffer.HorizFrontPorch   = 0;
    NVInfo->Framebuffer.HorizSyncWidth    = 0;
    NVInfo->Framebuffer.HorizBackPorch    = 0;
    NVInfo->Framebuffer.HorizDisplayWidth = 0;
    NVInfo->Framebuffer.VertFrontPorch    = 0;
    NVInfo->Framebuffer.VertSyncWidth     = 0;
    NVInfo->Framebuffer.VertBackPorch     = 0;
    NVInfo->Framebuffer.VertDisplayWidth  = 0;
    NVInfo->Framebuffer.HSyncPolarity     = 0;
    NVInfo->Framebuffer.VSyncPolarity     = 0;
    NVInfo->Framebuffer.CSync             = 0;
    NVInfo->Framebuffer.ConfigPageHeight  = 0;
    NVInfo->Pram.CurrentSize              = 0;
//    NVInfo->Pram.AvailableSize[0]         = NV_PRAM_DEVICE_SIZE_12_KBYTES + NV_PRAM_MIN_SIZE_INSTANCE_MEM;
//    NVInfo->Pram.AvailableSize[1]         = NV_PRAM_DEVICE_SIZE_20_KBYTES + NV_PRAM_MIN_SIZE_INSTANCE_MEM;
//    NVInfo->Pram.AvailableSize[2]         = NV_PRAM_DEVICE_SIZE_36_KBYTES + NV_PRAM_MIN_SIZE_INSTANCE_MEM;
//    NVInfo->Pram.AvailableSize[3]         = NV_PRAM_DEVICE_SIZE_68_KBYTES + NV_PRAM_MIN_SIZE_INSTANCE_MEM;

    //**************************************************************************
    // Default Refresh Rate
    //**************************************************************************

    NVInfo->Framebuffer.RefreshRate = 60;
    NVInfo->Framebuffer.HSyncPolarity = BUFFER_HSYNC_NEGATIVE;
    NVInfo->Framebuffer.VSyncPolarity = BUFFER_HSYNC_NEGATIVE;

    //**************************************************************************
    // Default resolution
    //**************************************************************************

    NVInfo->Framebuffer.Resolution        = RESOLUTION_640X480;
    NVInfo->Framebuffer.HorizDisplayWidth = 640;
    NVInfo->Framebuffer.VertDisplayWidth  = 480;
    NVInfo->Framebuffer.Depth             = 16;

    //**************************************************************************
    // Determine refresh rate
    //**************************************************************************

    if (NVInfo->Framebuffer.RefreshRate < 72)
        refresh = 0;
    else if (NVInfo->Framebuffer.RefreshRate < 75)
        refresh = 1;
    else if (NVInfo->Framebuffer.RefreshRate < 85)
        refresh = 2;
    else if (NVInfo->Framebuffer.RefreshRate < 100)
        refresh = 3;
    else if (NVInfo->Framebuffer.RefreshRate < 120)
        refresh = 4;
    else
        refresh = 5;

    //**************************************************************************
    // Get depth index into fbTimingTable
    //**************************************************************************

    switch (NVInfo->Framebuffer.Depth)
      {
      case 8:
         DepthIndex = 0;
         break;
      case 16:
         DepthIndex = 1;
         break;
      case 32:
         DepthIndex = 2;
         break;
      default:
         DepthIndex = 0;
         break;
     }

    //**************************************************************************
    // Init Timing Table
    //**************************************************************************

    NVInfo->Framebuffer.HorizFrontPorch = fbTimingTable[NVInfo->Framebuffer.Resolution + DepthIndex][refresh][4];
    NVInfo->Framebuffer.HorizSyncWidth  = fbTimingTable[NVInfo->Framebuffer.Resolution + DepthIndex][refresh][5];
    NVInfo->Framebuffer.HorizBackPorch  = fbTimingTable[NVInfo->Framebuffer.Resolution + DepthIndex][refresh][6];
    NVInfo->Framebuffer.VertFrontPorch  = fbTimingTable[NVInfo->Framebuffer.Resolution + DepthIndex][refresh][7];
    NVInfo->Framebuffer.VertSyncWidth   = fbTimingTable[NVInfo->Framebuffer.Resolution + DepthIndex][refresh][8];
    NVInfo->Framebuffer.VertBackPorch   = fbTimingTable[NVInfo->Framebuffer.Resolution + DepthIndex][refresh][9];
    NVInfo->Framebuffer.HSyncPolarity   = fbTimingTable[NVInfo->Framebuffer.Resolution + DepthIndex][refresh][10];
    NVInfo->Framebuffer.VSyncPolarity   = fbTimingTable[NVInfo->Framebuffer.Resolution + DepthIndex][refresh][11];
    NVInfo->Framebuffer.CSync           = fbTimingTable[NVInfo->Framebuffer.Resolution + DepthIndex][refresh][12];
    NVInfo->Dac.VClk                    = fbTimingTable[NVInfo->Framebuffer.Resolution + DepthIndex][refresh][13];
    NVInfo->Framebuffer.RefreshRate     = fbTimingTable[NVInfo->Framebuffer.Resolution + DepthIndex][refresh][14];

    //**************************************************************************
    // TODO: Need to add code to check amount of memory required for
    //       HASH TABLE, PRAM, and INSTANCES.  If not enough, then need to
    //       downgrade resolution until there is enough.
    //**************************************************************************

    //**************************************************************************
    // Determine the DAC type
    //**************************************************************************

    switch (PFB_REG_RD_DRF(PFB_Base,_PFB,_BOOT_0,_DAC_WIDTH))
        {
        case NV_PFB_BOOT_0_DAC_WIDTH_16_BIT:
            NVInfo->Dac.InputWidth = 16;
        case NV_PFB_BOOT_0_DAC_WIDTH_32_BIT:
            NVInfo->Dac.InputWidth = 32;
        case NV_PFB_BOOT_0_DAC_WIDTH_64_BIT:
            NVInfo->Dac.InputWidth = 64;
        }


    //**************************************************************************
    // Update the DAC flags and types
    //**************************************************************************

    NVInfo->Dac.UpdateFlags = 0;
    NVInfo->Dac.FinishFlags = 0;

    //**************************************************************************
    // Initialize the cursor data (transparent)
    // The cursor registers actually get set in NVSetMode
    //**************************************************************************

    NVInfo->Dac.CursorType = NV1_DAC_CURSOR_TWO_COLOR_XOR;
    NVInfo->Dac.CursorEmulation = FALSE;
    NVInfo->Dac.CursorExclude= FALSE;
    NVInfo->Dac.CursorColor1 = 0x00000000;
    NVInfo->Dac.CursorColor2 = 0x00ffffff;
    NVInfo->Dac.CursorColor3 = 0x00000000;

    for (i=0;i<128;i++)
        NVInfo->Dac.CursorImagePlane[0][i] = 0xff;

    for (i=0;i<128;i++)
        NVInfo->Dac.CursorImagePlane[1][i] = 0xff;

    for (i=0;i<32;i++)
        for (j=0;j<32;j++)
            NVInfo->Dac.CursorColorImage[i][j]= 0x00000000;

    //**************************************************************************
    // Initialize palette to gray scale
    //**************************************************************************

    for (i=0;i<256;i++)
        NVInfo->Dac.Palette[i] = (i<<16) | (i<<8) | i;

    //**************************************************************************
    // Initialize Power Management state
    //**************************************************************************

    NVInfo->Dac.DpmLevel = 0;

    //**************************************************************************
    // Initialize Video Clock
    //**************************************************************************

    NVInfo->Dac.VClk= 0;

    //**************************************************************************
    // Return success
    //**************************************************************************

    return(status);
    }


//******************************************************************************
//
//  Function:   NV1SetupGraphicsEngine()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV1SetupGraphicsEngine(PHW_DEVICE_EXTENSION HwDeviceExtension)


    {
    ULONG Data;
    PHWINFO NVInfo;


    //**************************************************************************
    // Wait Graphics engine to be IDLE
    //**************************************************************************

    GR_IDLE;

    //**************************************************************************
    // Get ptr to NVInfo structure
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    //**************************************************************************
    // Master Control Registers
    //
    //      - Enable all ENGINES
    //      - HARDWARE interrupts on PIN A were already init in ModeSet code
    //        (PMC_INTR_EN_0_INTA set to HARDWARE)
    //
    //**************************************************************************

    PMC_REG_WR32(PMC_Base, NV_PMC_ENABLE, 0xfff000ff);  // Reset Text, Graphics
    PMC_REG_WR32(PMC_Base, NV_PMC_ENABLE, 0xffffffff);  //   and Fifo Engines

    //**************************************************************************
    // We MUST make sure to initialize these register addresses to 0.
    // If we don't, the Graphics Engine may not work !
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHES,_REASSIGN,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_NUM(PFIFO_Base,_PFIFO,_RUNOUT_PUT,_ADDRESS,0);
    PFIFO_REG_WR_DRF_NUM(PFIFO_Base,_PFIFO,_RUNOUT_GET,_ADDRESS,0);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_ENABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_ENABLED);

    //**************************************************************************
    // Enable FLOWTHRU
    //
    //      In order to access many of the registers in the Graphics Engine,
    //      we need to enable FLOWTHRU and disable the FIFO engine.
    //      FLOWTHRU = ENABLED,  FIFO = DISABLED, DMA = DISABLED
    //      Class = 0 to access graphics registers
    //
    // NOTE:
    //      Just about every GRAPHICS register requires FLOWTHRU to be enabled.
    //      (except for PGRAPH_INTR_0 and PGRAPH_MISC). So we need to be careful
    //      that it is enabled when we need it.  When setting CTX_SWITCH registers,
    //      this bit can become disabled.  So be careful!  WE don't currently
    //      implement a Resource Manager/ Interrupt handling. If these registers
    //      are accessed when FLOWTHRU is disabled, the graphics engine will probably
    //      STOP , waiting for someone (the Resource Manager) to fix the error
    //      condition. This may occur in the user's 'While control.free < N' loop.
    //      Also, make sure to init CLASS field to 0.  Class = 0 should be
    //      used to denote writes to the graphics registers.
    //
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO,_DISABLED)          |
                            DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
                            DRF_DEF(_PGRAPH,_MISC,_DMA,_DISABLED)           |
                            DRF_DEF(_PGRAPH,_MISC,_CLASS_WRITE,_ENABLED)    |
                            DRF_NUM(_PGRAPH,_MISC,_CLASS,0));

    //**************************************************************************
    // Reset state machine in graphics engine
    //**************************************************************************

    PGRAPH_REG_WR_DRF_DEF(PGRAPH_Base,_PGRAPH, _DEBUG_1, _VOLATILE_RESET, _LAST);
    PGRAPH_REG_WR_DRF_DEF(PGRAPH_Base,_PGRAPH, _DEBUG_0, _STATE, _RESET);

    //**************************************************************************
    // Deal with bug in chip.
    // Block write is only enabled under certain conditions
    // For now, we always enable it
    //**************************************************************************

//******************************************************************************
//    if ((pDev.Framebuffer.RamType == BUFFER_VRAM)
//      && ((((pDev.Framebuffer.RamSizeMb != 4) && (pDev.Framebuffer.Depth == 32))
//       || ((pDev.Framebuffer.RamSizeMb == 1) && (pDev.Framebuffer.Depth == 16)))))
//         pDev.Graphics.Debug0 &= ~DRF_DEF(_PGRAPH, _DEBUG_0, _BLOCK, _ENABLED);
//    else
//         pDev.Graphics.Debug0 |=  DRF_DEF(_PGRAPH, _DEBUG_0, _BLOCK, _ENABLED);
//******************************************************************************

    Data = PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_DEBUG_0);
    Data |= DRF_DEF(_PGRAPH,_DEBUG_0,_BLOCK, _ENABLED);
    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_DEBUG_0,Data);

//******************************************************************************
// Need to load these DEBUG registers appropriately.
// Otherwise, performance may be dog slow !!!!
// Currently, we assume REV_B !!!!!  (Not yet tested on other REVS)
//******************************************************************************


    NVInfo->Graphics.Debug0 = DRF_DEF(_PGRAPH, _DEBUG_0, _ALPHA_ABORT,     _ENABLED) |
                             DRF_DEF(_PGRAPH, _DEBUG_0, _EDGE_FILLING,    _ENABLED) |
                             DRF_DEF(_PGRAPH, _DEBUG_0, _WRITE_ONLY_ROPS, _ENABLED) |
                             DRF_DEF(_PGRAPH, _DEBUG_0, _NONBLOCK_BROAD,  _ENABLED) |
                             DRF_DEF(_PGRAPH, _DEBUG_0, _BLOCK_BROAD,     _ENABLED) |
                             DRF_DEF(_PGRAPH,_DEBUG_0, _BLOCK, _ENABLED)            |
                             DRF_DEF(_PGRAPH,_DEBUG_0, _BULK_READS, _ENABLED);

//******************************************************************************
// Revision was already obtained in GetNVInfo during FindAdapter call
//******************************************************************************

    switch (NVInfo->Chip.Revision)
        {
        case NV1_REV_B_02:
        case NV1_REV_B_03:
            NVInfo->Graphics.Debug1 = DRF_DEF(_PGRAPH, _DEBUG_1, _HIRES_TM,        _DISABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _FAST_BUS,        _DISABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _TM_QUAD_HANDOFF, _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _FAST_RMW_BLITS,  _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _PATT_BLOCK,      _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _TRI_OPTS,        _DISABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _BI_RECTS,        _DISABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _DMA_ACTIVITY,    _IGNORE)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _VOLATILE_RESET,  _NOT_LAST);
            NVInfo->Graphics.Debug2 = DRF_DEF(_PGRAPH, _DEBUG_2, _VOLATILE_RESET,  _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _TM_FASTINPUT,    _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _BUSY_PATIENCE,   _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _TRAPEZOID_TEXEL, _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _MONO_ABORT,      _DISABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _BETA_ABORT,      _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _ALPHA_ABORT,     _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _AVOID_RMW_BLEND, _DISABLED);
            break;
        case NV1_REV_C_01:
        case NV1_REV_C_02:
            NVInfo->Graphics.Debug1 = DRF_DEF(_PGRAPH, _DEBUG_1, _HIRES_TM,           _DISABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _FAST_BUS,           _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _TM_QUAD_HANDOFF,    _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _FAST_RMW_BLITS,     _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _PATT_BLOCK,         _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _TRI_OPTS,           _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _BI_RECTS,           _DISABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _DMA_ACTIVITY,       _IGNORE)
                                   | DRF_DEF(_PGRAPH, _DEBUG_1, _VOLATILE_RESET,     _NOT_LAST);
            NVInfo->Graphics.Debug2 = DRF_DEF(_PGRAPH, _DEBUG_2, _VOLATILE_RESET,     _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _TM_FASTINPUT,       _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _BUSY_PATIENCE,      _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _TRAPEZOID_TEXEL,    _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _MONO_ABORT,         _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _BETA_ABORT,         _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _ALPHA_ABORT,        _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_2, _AVOID_RMW_BLEND,    _ENABLED);
            NVInfo->Graphics.Debug3 = DRF_DEF(_PGRAPH, _DEBUG_3, _TM_RANGE_INTERRUPT, _DISABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_3, _MONO_BLOCK,         _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_3, _SPARE1,             _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_3, _SPARE2,             _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_3, _SPARE3,             _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_3, _SPARE4,             _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_3, _SPARE5,             _ENABLED)
                                   | DRF_DEF(_PGRAPH, _DEBUG_3, _SPARE6,             _ENABLED);
            break;
        }


    //**************************************************************************
    // Set the DEBUG register appropriately
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_DEBUG_0,NVInfo->Graphics.Debug0);
    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_DEBUG_1,NVInfo->Graphics.Debug1);
    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_DEBUG_2,NVInfo->Graphics.Debug2);

//******************************************************************************
//    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_DEBUG_0, pDev.Graphics.Debug0);
//    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_DEBUG_1, pDev.Graphics.Debug1);
//    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_DEBUG_2, pDev.Graphics.Debug2);
//
//    Need to check revision of chip if need to write out this register
//    if ((pDev.Chip.Revision == NV1_REV_C_01) || (pDev.Chip.Revision == NV1_REV_C_02))
//       REG_WR32(NV_PGRAPH_DEBUG_3, pDev.Graphics.Debug3);
//
//    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_DEBUG_2, pDev.Graphics.Debug2);
//******************************************************************************


    //**************************************************************************
    // Initialize DMA related instance registers to zero
    //**************************************************************************

    PDMA_REG_WR32(PDMA_Base,NV_PDMA_GR_CHANNEL, NV_PDMA_GR_CHANNEL_ACCESS_DISABLED);
    PDMA_REG_WR32(PDMA_Base,NV_PDMA_GR_INSTANCE, 0x00000000);
    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_DMA,0x00000000);
    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_NOTIFY,0x00000000);
    PDMA_REG_WR32(PDMA_Base,NV_PDMA_GR_CHANNEL,  NV_PDMA_GR_CHANNEL_ACCESS_ENABLED);

    //**************************************************************************
    // Init Context register for the first time
    // Instance is zero, and Channel is currently invalid
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_CTX_SWITCH,  0x00000000);
    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_CTX_CONTROL, DRF_DEF (_PGRAPH,_CTX_CONTROL,_MINIMUM_TIME,_33US)
                                                 | DRF_DEF (_PGRAPH,_CTX_CONTROL,_TIME,_EXPIRED)
                                                 | DRF_DEF (_PGRAPH,_CTX_CONTROL,_CHID,_INVALID)
                                                 | DRF_DEF (_PGRAPH,_CTX_CONTROL,_SWITCHING,_IDLE)
                                                 | DRF_DEF (_PGRAPH,_CTX_CONTROL,_DEVICE,_ENABLED));

//******************************************************************************
// Update system canvas to current settings.  In order to include offscreen access
// system clients, calculate the canvas height based on the limit of buffer[0].
//******************************************************************************

//******************************************************************************
//    CanvasHeight = pDev.Framebuffer.Limit[0]
//                             / (pDev.Framebuffer.Depth / 8)
//                             / pDev.Framebuffer.HorizDisplayWidth;
//    if (CanvasHeight > 0x0FFF)
//        CanvasHeight = 0x0FFF;
//******************************************************************************

//******************************************************************************
// On NV1, 320x200, 320x240 and 512x384 modes aren't really accelerated by the
// hardware directly.  The canvas and clip width has to be set up for 640 pixels
// like the hardware.
//******************************************************************************

//******************************************************************************
//      switch (pDev.Framebuffer.Resolution)
//        {
//        case RESOLUTION_320X200:
//        case RESOLUTION_320X240:
//        case RESOLUTION_512X384:
//            CanvasWidth = pDev.Framebuffer.HorizDisplayWidth * 2;
//            break;
//        default:
//            CanvasWidth = pDev.Framebuffer.HorizDisplayWidth;
//            break;
//        }
//
//    grSysCanvas->xyMin    = PACK_XY(0, 0);
//    grSysCanvas->xyMax    = PACK_XY(CanvasWidth, CanvasHeight);
//
//
//    grSysCanvas->ClipMisc = 0;
//    for (i = 0; i <MAX_CLIP_REGIONS; i++)
//        {
//        grSysCanvas->xyClipMin[i] = PACK_XY(0, 0);
//        grSysCanvas->xyClipMax[i] = PACK_XY(CanvasWidth, CanvasHeight);
//        grSysCanvas->InOutClip[i] = 0;
//        }
//******************************************************************************

    //**************************************************************************
    // Init color format table
    //**************************************************************************

    InitColorFormatTable(HwDeviceExtension);

    //**************************************************************************
    // Clear out local Graphics Channel (GrTable) memory (We only use 1 channel)
    //**************************************************************************

    ClearOutGrTable(HwDeviceExtension);

    //**************************************************************************
    // Clear out local FIFO table structure (We only use 1 channel)
    //**************************************************************************

    ClearOutFifoTable(HwDeviceExtension);

    //**************************************************************************
    // Clear out local RENDEROBJECT structures (Currently allow up to 10 objects)
    //**************************************************************************

    ClearOutRenderObjects(HwDeviceExtension);

//    //*************************************************************************
//    // Clear out local local NVInfo structure
//    //*************************************************************************
//
//    ClearOutNVInfo(HwDeviceExtension);

    //**************************************************************************
    // Clear out hardware Cached Context registers and FIFO Context memory
    //**************************************************************************

    ClearOutContextMemoryAndRegisters(HwDeviceExtension);

    //**************************************************************************
    // Clear out hardware HASH TABLE memory and local hash table)
    //**************************************************************************

    ClearOutHashTables(HwDeviceExtension);

    //**************************************************************************
    // Init current channel 0 context.
    // Since we cleared out the Fifo table up above (FifoTable.InUse=INVALID),
    // an initial 'default' context will be loaded
    //**************************************************************************

    LoadChannelContext(HwDeviceExtension);

    //**************************************************************************
    // Reset ALL the interrupts that the Graphics Engine can generate.
    // Then enable all of them.
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_INTR_0,    0x11111111);
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_INTR_EN_0, 0x11111111);

    //**************************************************************************
    // The second graphics interrupt register is more information for the
    // first interrupt register.  Don't bother enabling it.
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_INTR_1,    0x11111111);
    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_INTR_EN_1, 0x00000000);

    //**************************************************************************
    // We're done with the Graphics registers for now.
    // ReEnable the FIFO and DMA engines.
    //
    //      FLOWTHRU = ENABLED,  FIFO = ENABLED, DMA = ENABLED
    //      Specify Class = 0 to access graphics registers
    //
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO,_ENABLED)           |
                            DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
                            DRF_DEF(_PGRAPH,_MISC,_DMA,_ENABLED)            |
                            DRF_DEF(_PGRAPH,_MISC,_CLASS_WRITE,_ENABLED)    |
                            DRF_NUM(_PGRAPH,_MISC,_CLASS,0));

    //**************************************************************************
    // The Graphics engine is now ready to be used!
    //**************************************************************************

    HwDeviceExtension->NvInfo.Graphics.Enabled = TRUE;


    }



//******************************************************************************
//
//  Function:   dacCalcPLL()
//
//  Routine Description:
//
//       Find closest DAC PLL parameters for a given frequency.
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//      pusCmdStream - array of commands to be interpreted.
//
//  Return Value:
//
//      The status of the operation (can only fail on a bad command); TRUE for
//      success, FALSE for failure.
//
//******************************************************************************

VOID dacCalcPClkVClkRatio(PHW_DEVICE_EXTENSION HwDeviceExtension )

    {
    PHWINFO pDev;

    pDev = &(HwDeviceExtension->NvInfo);

    //
    // changed calculation - 28 Nov 95 ibb
    // this is so that the p/v ratio is minimised especially for
    // certain customers who want to drive NTSC and thus want 25 MHz
    // out from the DAC, and not 12.5 MHz as is the case with p/v of 2.
    //
    if (pDev->Dac.VClk < 50000000)
      pDev->Dac.PClkVClkRatio = 1;
    else if (pDev->Dac.VClk < 100000000)
      pDev->Dac.PClkVClkRatio = 2;
    else if (pDev->Dac.VClk < 200000000)
      pDev->Dac.PClkVClkRatio = 4;
    else if (pDev->Dac.VClk < 400000000)
      pDev->Dac.PClkVClkRatio = 8;
    else // if (pDev->Dac.VClk < 800000000)
      pDev->Dac.PClkVClkRatio = 16;
    }

//******************************************************************************
//
//  Function:   dacCalcPLL()
//
//  Routine Description:
//
//       Find closest DAC PLL parameters for a given frequency.
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//      pusCmdStream - array of commands to be interpreted.
//
//  Return Value:
//
//      The status of the operation (can only fail on a bad command); TRUE for
//      success, FALSE for failure.
//
//******************************************************************************

VOID dacCalcPLL(PHW_DEVICE_EXTENSION HwDeviceExtension )


    {
    U032 DeltaNew;
    U032 DeltaOld;
    U032 VClk;
    U032 Freq;
    U032 M;
    U032 N;
    U032 O;
    U032 P;
    U032 MinN;
    U032 MaxN;

    PHWINFO pDev;

    //**************************************************************************
    // Get pointer to hardware information
    //**************************************************************************

    pDev = &(HwDeviceExtension->NvInfo);

    //
    // Calc VPLL.
    //
    DeltaOld = 0xFFFFFFFF;
    VClk     = pDev->Dac.VClk / 1000;
    //
    // Calculate frequencies using KHz to keep the math precision inside 32 bits.
    //
    for (P = 1; P <= 8; P <<= 1)
    {
        Freq = VClk * P;
        //
        // Bound the parameters to the internal frequencies of the DAC.
        //
        if ((Freq >= 64000) && (Freq <= 170000))
        {
            for (M = 7; M <= 12; M++)
            {
                N    = VClk * P * M / 12096;
                Freq = N * 12096 / P / M;
                if (Freq > VClk)
                    DeltaNew = Freq - VClk;
                else
                    DeltaNew = VClk - Freq;
                if (DeltaNew < DeltaOld)
                {
                    //
                    // Closer match.
                    //
                    pDev->Dac.VPllM = M;
                    pDev->Dac.VPllN = N;
                    pDev->Dac.VPllO = 1;
                    pDev->Dac.VPllP = P;
                    DeltaOld = DeltaNew;
                }
            }
        }
    }

    }




//******************************************************************************
//
//  Function:   NV1SetMode()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//      pusCmdStream - array of commands to be interpreted.
//
//  Return Value:
//
//      The status of the operation (can only fail on a bad command); TRUE for
//      success, FALSE for failure.
//
//******************************************************************************

VOID NV1SetMode(PHW_DEVICE_EXTENSION HwDeviceExtension,
                        PMODE_ENTRY RequestedMode  )


    {
    ULONG ulCmd;
    ULONG ulPort;
    UCHAR jValue;
    USHORT usValue;
    ULONG culCount;
    ULONG ulIndex;
    ULONG ulBase;

    ULONG OutData;
    UCHAR SaveMCLK[4];
    ULONG index;
    PHWINFO NVInfo;
    ULONG DepthIndex;
    ULONG Refresh;
    ULONG DACWidth;
    ULONG i;
    ULONG m,n,o,p;
    ULONG clock;

    //**************************************************************************
    //
    // NOTE: Currently, this setmode code does NOT contain all the smart detection
    //       that the Resource Manager contains (due to time constraints), as follows:
    //
    //          - DAC Pclk/VClk ratio calculations
    //          - PRAM size (currently set to 20kb)
    //          - Framebuffer count = 0 (no double buffering)
    //          - DRAM detection (only VRAM functionality is implemented)
    //
    //       When the rest of the display driver is completed, we may want to
    //       pull in the rest of this functionality from the Resource Manager code.
    //
    //**************************************************************************

    //**************************************************************************
    // Get pointer to NVInfo structure
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    //**************************************************************************
    // Fill frame buffer with data (testing purposes)
    //**************************************************************************

//    OutData=0xffffffff;
//    for (index=0;index < ((640*480*2)/4); index++)
//        {
//        VideoPortWriteRegisterBufferUlong(
//                ((PULONG)(HwDeviceExtension->VideoMemoryAddress)) + index,
//                &OutData,1);
//        }

    //**************************************************************************
    // Enable Hardware Interrupts, Disable Software interrupts
    //**************************************************************************

    PMC_REG_WR32( HwDeviceExtension->NV1_Lin_PMC_Registers, NV_PMC_INTR_EN_0, 0x1);

    //**************************************************************************
    // Turn off BIOS Fixups (code taken from RM)
    // BIOS Fixups were never applied anyway.
    //**************************************************************************

    PRM_REG_WR32( PRM_Base, NV_PRM_INTR_EN_0, 0x00000000);
    PRM_REG_WR32( PRM_Base, NV_PRM_TRACE, 0x00000000);
    PRM_REG_WR32( PRM_Base, NV_PRM_CONFIG_0, 0x00000000);
    PRM_REG_WR32( PRM_Base, NV_PRM_IGNORE_0, 0x33333333);
    PRM_REG_WR32( PRM_Base, NV_PRM_IGNORE_1, 0x33333333);

    //**************************************************************************
    // Restore MCLK to full speed for Windows
    // This involves restoring DAC registers.
    // Here, we just save them because so far, we have not turned off VGA mode
    // Even though we only write BYTES at a time to the DAC,
    // we must write DWORDS at a time to the NV interface.
    //**************************************************************************

    //**************************************************************************
    //  Set the clock speed
    //
    // The following switch statement let's us experiment with increasing
    // the clock speed of an NV1 card.  I've only been able to increase
    // the speed of a 2Mb VRAM card to 65Mhz, and the speed of a 4Mb VRAM card
    // to 60Mhz.  As the clock is increased beyond the spec'd speed of NV1 (50Mhz),
    // you'll notice more and more graphics being drawn incorrectly with garbage.
    // At a certain point, the card just won't work.  This is somewhat useful
    // for predicting how much performance will increase when increasing the
    // clock speed.  For now, just default to the standard 50Mhz.
    //**************************************************************************

    clock = 50;

    switch (clock)
        {
        case 30:
            m=7;
            n=139;
            o=1;
            p=4;
            break;
        case 40:
            m=12;
            n=159;
            o=1;
            p=2;
            break;
        case 50:
            m=11;
            n=91;
            o=1;
            p=1;
            break;
        case 60:
            m=7;
            n=139;
            o=1;
            p=2;
            break;
        case 65:
            m=12;
            n=129;
            o=1;
            p=1;
            break;
        case 70:
            m=12;
            n=139;
            o=1;
            p=1;
            break;
        default:
            m=11;
            n=91;
            o=1;
            p=1;
            break;
        }


    OutData=(SGS_DAC_MPLL_M & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_MPLL_M>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, m);

    //**************************************************************************
    // Add Delay for DAC ??
    //**************************************************************************

    OutData=(SGS_DAC_MPLL_N & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_MPLL_N>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, n);

    //**************************************************************************
    // Add Delay for DAC ??
    //**************************************************************************

    OutData=(SGS_DAC_MPLL_O & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_MPLL_O>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, o);

    //**************************************************************************
    // Add Delay for DAC ??
    //**************************************************************************

    OutData=(SGS_DAC_MPLL_P & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_MPLL_P>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, p);



    OutData=(SGS_DAC_MPLL_M & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_MPLL_M>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData = PDAC_REG_RD32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA);
    SaveMCLK[0] = (UCHAR) (OutData & 0xff);

    //**************************************************************************
    // Add Delay for DAC ??
    //**************************************************************************

    OutData=(SGS_DAC_MPLL_N & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_MPLL_N>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData = PDAC_REG_RD32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA);
    SaveMCLK[1] = (UCHAR) (OutData & 0xff);

    //**************************************************************************
    // Add Delay for DAC ??
    //**************************************************************************

    OutData=(SGS_DAC_MPLL_O & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_MPLL_O>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData = PDAC_REG_RD32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA);
    SaveMCLK[2] = (UCHAR) (OutData & 0xff);

    //**************************************************************************
    // Add Delay for DAC ??
    //**************************************************************************

    OutData=(SGS_DAC_MPLL_P & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_MPLL_P>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData = PDAC_REG_RD32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA);
    SaveMCLK[3] = (UCHAR) (OutData & 0xff);

    //**************************************************************************
    // Output the config register for RAM
    //
    // TO DO: Need to calculate this value in realtime!!
    //        For now, specify 20Kb
    //**************************************************************************

    NVInfo->Pram.ConfigReg = DRF_DEF(_PRAM,_CONFIG_0,_SIZE,_20KB);
    NVInfo->Pram.HashDepth = 4;
    NVInfo->Pram.RunOutMask = 0x0fff;
    NVInfo->Pram.CurrentSize = NV_PRAM_DEVICE_SIZE_20_KBYTES;

    //**************************************************************************
    // Setup the NV1 memory map
    //**************************************************************************

    NVInfo->Pram.HashTableAddr = DEVICE_BASE(NV_PRAMHT);
    NVInfo->Pram.FifoRunoutAddr = DEVICE_BASE(NV_PRAMRO);
    NVInfo->Pram.FifoContextAddr = DEVICE_BASE(NV_PRAMFC);
    NVInfo->Pram.AudioScratchAddr = DEVICE_BASE(NV_PRAMAU);
    NVInfo->Pram.AuthScratchAddr = DEVICE_BASE(NV_PRAMPW);

    //**************************************************************************
    // For now, just force VClk = 0, which will force PClkVClkRatio to be 1.
    // (There's a lot of code associated with calculating this ratio.  So for
    // now, we just default to 1.  May want to pull this code in later)
    //**************************************************************************

//    NVInfo->Dac.VClk = 0;
//    NVInfo->Dac.PClkVClkRatio = 1;

    //**************************************************************************
    //  For now, set count to zero (no double buffering for now)
    //
    //  For NV1, we want a completely flat and available dumb frame buffer.
    //  Enabling double buffering causes PRAMIN Instance memory to be
    //  split in two places (i.e. on a 2 Mb system, instance memory would occur
    //  at end of 1 Mb and at end of 2Mb)  This is fine for apps that use
    //  the VIDEO_SWITCH class and an RM, which alternates between two buffers.
    //  But the problem is that the Instance memory gets in the way when
    //  giving offscreen memory to Direct X.  So by DISABLING double buffering,
    //  we avoid this issue entirely. We can do this because 1) we're bypassing
    //  the NVidia patch architecture (for the most part) in this display driver
    //  that is...we're not using the VIDEO_SWITCH_CLASS to flip buffers, we flip
    //  buffers directly by going straight to the PFB_START_ADDRESS register. and
    //  2) We're not using Resource Manager.  This miniport does all the initialization
    //  that a Resource Manager normally would do.
    //
    //**************************************************************************

    NVInfo->Framebuffer.Count = 0;

    //**************************************************************************
    // Now get the appropriate values from the requested mode
    // and set them in the NVInfo structure
    //**************************************************************************

    switch (RequestedMode->Width)
       {
       case 1600:
          NVInfo->Framebuffer.Resolution = RESOLUTION_1600X1200;
          break;
       case 1280:
          NVInfo->Framebuffer.Resolution = RESOLUTION_1280X1024;
          break;
       case 1152:
          NVInfo->Framebuffer.Resolution = RESOLUTION_1152X864;
          break;
       case 1024:
          NVInfo->Framebuffer.Resolution = RESOLUTION_1024X768;
          break;
       case 800:
          NVInfo->Framebuffer.Resolution = RESOLUTION_800X600;
          break;
       case 640:
          NVInfo->Framebuffer.Resolution = RESOLUTION_640X480;
          break;
       default:
          NVInfo->Framebuffer.Resolution = RESOLUTION_640X480;
          break;
       }

    //**************************************************************************
    // Set the requested depth
    //**************************************************************************

    NVInfo->Framebuffer.Depth = RequestedMode->Depth;

    if (RequestedMode->Depth == 32)
       DepthIndex = 2;
    else if (RequestedMode->Depth == 16)
       DepthIndex = 1;
    else
       DepthIndex = 0;

    //**************************************************************************
    // Determine refresh rate
    //**************************************************************************

    if (RequestedMode->RefreshRate < 72)
        Refresh = 0;
    else if (RequestedMode->RefreshRate < 75)
        Refresh = 1;
    else if (RequestedMode->RefreshRate < 85)
        Refresh = 2;
    else if (RequestedMode->RefreshRate < 100)
        Refresh = 3;
    else if (RequestedMode->RefreshRate < 120)
        Refresh = 4;
    else
        Refresh = 5;

    //**************************************************************************
    // Set the display resolution and monitor timings
    //**************************************************************************

    NVInfo->Framebuffer.HorizDisplayWidth = fbTimingTable[NVInfo->Framebuffer.Resolution+DepthIndex][Refresh][1];
    NVInfo->Framebuffer.VertDisplayWidth  = fbTimingTable[NVInfo->Framebuffer.Resolution+DepthIndex][Refresh][2];

    NVInfo->Framebuffer.HorizFrontPorch = fbTimingTable[NVInfo->Framebuffer.Resolution+DepthIndex][Refresh][4];
    NVInfo->Framebuffer.HorizSyncWidth  = fbTimingTable[NVInfo->Framebuffer.Resolution+DepthIndex][Refresh][5];
    NVInfo->Framebuffer.HorizBackPorch  = fbTimingTable[NVInfo->Framebuffer.Resolution+DepthIndex][Refresh][6];
    NVInfo->Framebuffer.VertFrontPorch  = fbTimingTable[NVInfo->Framebuffer.Resolution+DepthIndex][Refresh][7];
    NVInfo->Framebuffer.VertSyncWidth   = fbTimingTable[NVInfo->Framebuffer.Resolution+DepthIndex][Refresh][8];
    NVInfo->Framebuffer.VertBackPorch   = fbTimingTable[NVInfo->Framebuffer.Resolution+DepthIndex][Refresh][9];
    NVInfo->Framebuffer.HSyncPolarity   = fbTimingTable[NVInfo->Framebuffer.Resolution+DepthIndex][Refresh][10];
    NVInfo->Framebuffer.VSyncPolarity   = fbTimingTable[NVInfo->Framebuffer.Resolution+DepthIndex][Refresh][11];
    NVInfo->Framebuffer.CSync           = fbTimingTable[NVInfo->Framebuffer.Resolution+DepthIndex][Refresh][12];
    NVInfo->Dac.VClk                    = fbTimingTable[NVInfo->Framebuffer.Resolution+DepthIndex][Refresh][13];
    NVInfo->Framebuffer.RefreshRate     = fbTimingTable[NVInfo->Framebuffer.Resolution+DepthIndex][Refresh][14];

    //**************************************************************************
    // Now that NVInfo->Dac.Vclk is initialized, calculate
    // the PClkVclk ratio and PLL values as well
    //**************************************************************************

    dacCalcPLL(HwDeviceExtension );
    dacCalcPClkVClkRatio(HwDeviceExtension );

    //**************************************************************************
    // Set 20Kb always...  (20Kb set up above)
    //**************************************************************************

    PRAM_REG_WR32( PRAM_Base, NV_PRAM_CONFIG_0, NVInfo->Pram.ConfigReg);

    //**************************************************************************
    // Output the Frame Buffer control register
    // Start at address 0
    //**************************************************************************

    OutData = 0x00000000;
    PFB_REG_WR32( PFB_Base, NV_PFB_START, OutData);

    //**************************************************************************
    // Output the Frame Buffer config0 register
    //**************************************************************************

    switch (NVInfo->Framebuffer.Resolution)
    {
        case RESOLUTION_1600X1200:
            NVInfo->Framebuffer.ConfigReg = DRF_DEF(_PFB, _CONFIG_0, _RESOLUTION, _1600_PIXELS)
                                         | DRF_DEF(_PFB, _CONFIG_0, _SCANLINE,   _NO_DUPLICATE);
            break;
        case RESOLUTION_1280X1024:
            NVInfo->Framebuffer.ConfigReg = DRF_DEF(_PFB, _CONFIG_0, _RESOLUTION, _1280_PIXELS)
                                         | DRF_DEF(_PFB, _CONFIG_0, _SCANLINE,   _NO_DUPLICATE);
            break;
        case RESOLUTION_1152X864:
            NVInfo->Framebuffer.ConfigReg = DRF_DEF(_PFB, _CONFIG_0, _RESOLUTION, _1152_PIXELS)
                                         | DRF_DEF(_PFB, _CONFIG_0, _SCANLINE,   _NO_DUPLICATE);
            break;
        case RESOLUTION_1024X768:
            NVInfo->Framebuffer.ConfigReg = DRF_DEF(_PFB, _CONFIG_0, _RESOLUTION, _1024_PIXELS)
                                         | DRF_DEF(_PFB, _CONFIG_0, _SCANLINE,   _NO_DUPLICATE);
            break;
        case RESOLUTION_800X600:
            NVInfo->Framebuffer.ConfigReg = DRF_DEF(_PFB, _CONFIG_0, _RESOLUTION, _800_PIXELS)
                                         | DRF_DEF(_PFB, _CONFIG_0, _SCANLINE,   _NO_DUPLICATE);
            break;
        case RESOLUTION_640X480:
            NVInfo->Framebuffer.ConfigReg = DRF_DEF(_PFB, _CONFIG_0, _RESOLUTION, _640_PIXELS)
                                         | DRF_DEF(_PFB, _CONFIG_0, _SCANLINE,   _NO_DUPLICATE);
            break;
    }

    //**************************************************************************
    //  For now, we don't enable a second buffer (Count = 0 always, set up above)
    //
    //  For NV1, we want a completely flat and available dumb frame buffer.
    //  Enabling double buffering causes PRAMIN Instance memory to be
    //  split in two places (i.e. on a 2 Mb system, instance memory would occur
    //  at end of 1 Mb and at end of 2Mb)  This is fine for apps that use
    //  the VIDEO_SWITCH class and an RM, which alternates between two buffers.
    //  But the problem is that the Instance memory gets in the way when
    //  giving offscreen memory to Direct X.  So by DISABLING double buffering,
    //  we avoid this issue entirely. We can do this because 1) we're bypassing
    //  the NVidia patch architecture (for the most part) in this display driver
    //  that is...we're not using the VIDEO_SWITCH_CLASS to flip buffers, we flip
    //  buffers directly by going straight to the PFB_START_ADDRESS register. and
    //  2) We're not using Resource Manager.  This miniport does all the initialization
    //  that a Resource Manager normally would do.
    //
    //**************************************************************************

    if (NVInfo->Framebuffer.Count == 2)
        NVInfo->Framebuffer.ConfigReg |= DRF_DEF(_PFB, _CONFIG_0, _SECOND_BUFFER, _ENABLED);
    else
        NVInfo->Framebuffer.ConfigReg |= DRF_DEF(_PFB, _CONFIG_0, _SECOND_BUFFER, _DISABLED);

    //**************************************************************************
    // PClkVClk Ratio is hard coded up above for now....
    //**************************************************************************

    switch (NVInfo->Framebuffer.Depth)
        {
        case 32:
            NVInfo->Framebuffer.ConfigReg |= DRF_DEF(_PFB, _CONFIG_0, _PIXEL_DEPTH, _32_BITS);
            PFB_FLD_WR_DRF_NUM(PFB_Base,_PFB, _DELAY_0, _SYNC, 16 / NVInfo->Dac.PClkVClkRatio + 3);
            break;
        case 16:
            NVInfo->Framebuffer.ConfigReg |= DRF_DEF(_PFB, _CONFIG_0, _PIXEL_DEPTH, _16_BITS);
            PFB_FLD_WR_DRF_NUM(PFB_Base,_PFB, _DELAY_0, _SYNC, 16 / NVInfo->Dac.PClkVClkRatio + 3);
            break;
        case 8:
            NVInfo->Framebuffer.ConfigReg |= DRF_DEF(_PFB, _CONFIG_0, _PIXEL_DEPTH, _8_BITS);
            PFB_FLD_WR_DRF_NUM(PFB_Base,_PFB, _DELAY_0, _SYNC, 15 / NVInfo->Dac.PClkVClkRatio + 3);
        }

    //**************************************************************************
    // Page height was set to zero in GetNVInfo() - disabled
    //**************************************************************************

    NVInfo->Framebuffer.ConfigReg |= DRF_NUM(_PFB, _CONFIG_0, _PAGE_HEIGHT, NVInfo->Framebuffer.ConfigPageHeight);

    //**************************************************************************
    // Currently , PClkVClk Ratio is set to 1 up above...
    //**************************************************************************

    switch (NVInfo->Dac.PClkVClkRatio)
    {
        case 1:
            NVInfo->Framebuffer.ConfigReg |= DRF_DEF(_PFB, _CONFIG_0, _PCLK_VCLK_RATIO, _1_TO_1);
            break;
        case 2:
            NVInfo->Framebuffer.ConfigReg |= DRF_DEF(_PFB, _CONFIG_0, _PCLK_VCLK_RATIO, _2_TO_1);
            break;
        case 4:
            NVInfo->Framebuffer.ConfigReg |= DRF_DEF(_PFB, _CONFIG_0, _PCLK_VCLK_RATIO, _4_TO_1);
            break;
        case 8:
            NVInfo->Framebuffer.ConfigReg |= DRF_DEF(_PFB, _CONFIG_0, _PCLK_VCLK_RATIO, _8_TO_1);
            break;
        case 16:
            NVInfo->Framebuffer.ConfigReg |= DRF_DEF(_PFB, _CONFIG_0, _PCLK_VCLK_RATIO, _16_TO_1);
            break;
    }

    //**************************************************************************
    // No stereoscopic stuff..
    //**************************************************************************

    NVInfo->Framebuffer.ConfigReg |= DRF_DEF(_PFB, _CONFIG_0, _STEREOSCOPIC, _DISABLED);

    //**************************************************************************
    // Finally output the ConfigReg value
    //**************************************************************************

    PFB_REG_WR32( PFB_Base, NV_PFB_CONFIG_0,NVInfo->Framebuffer.ConfigReg );


    //**************************************************************************
    // Set LOW_MARK for VRAM type adapters only
    //...May want to pull in the DRAM code later!!!!
    //**************************************************************************

    OutData = (NV_PFB_CONFIG_1_FIFO_LOW_MARK_512_BITS);
    PFB_REG_WR32( HwDeviceExtension->NV1_Lin_PFB_Registers, NV_PFB_CONFIG_1, OutData);

    //**************************************************************************
    // Output for Monitor timings/Framebuffer display registers
    //**************************************************************************

    PFB_REG_WR32(PFB_Base,NV_PFB_HOR_FRNT_PORCH,NVInfo->Framebuffer.HorizFrontPorch);
    PFB_REG_WR32(PFB_Base,NV_PFB_HOR_SYNC_WIDTH,NVInfo->Framebuffer.HorizSyncWidth);
    PFB_REG_WR32(PFB_Base,NV_PFB_HOR_BACK_PORCH,NVInfo->Framebuffer.HorizBackPorch);
    PFB_REG_WR32(PFB_Base,NV_PFB_HOR_DISP_WIDTH,NVInfo->Framebuffer.HorizDisplayWidth);
    PFB_REG_WR32(PFB_Base,NV_PFB_VER_FRNT_PORCH,NVInfo->Framebuffer.VertFrontPorch);
    PFB_REG_WR32(PFB_Base,NV_PFB_VER_SYNC_WIDTH,NVInfo->Framebuffer.VertSyncWidth);
    PFB_REG_WR32(PFB_Base,NV_PFB_VER_BACK_PORCH,NVInfo->Framebuffer.VertBackPorch);
    PFB_REG_WR32(PFB_Base,NV_PFB_VER_DISP_WIDTH,NVInfo->Framebuffer.VertDisplayWidth);

    //**************************************************************************
    // DAC Load Width/Depth
    //**************************************************************************

    OutData=(SGS_DAC_CONFIG_0 & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);


    OutData=((SGS_DAC_CONFIG_0>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    //**************************************************************************
    // Determine the DAC Width first...
    //**************************************************************************

    DACWidth = PFB_REG_RD_DRF(PFB_Base,_PFB,_BOOT_0,_DAC_WIDTH);

    switch (DACWidth)
        {
        case NV_PFB_BOOT_0_DAC_WIDTH_16_BIT:
            NVInfo->Dac.InputWidth =16;
            OutData = (SGS_DAC_CONFIG_0_PORT_WIDTH_16BIT << 2) ;
            break;
        case NV_PFB_BOOT_0_DAC_WIDTH_32_BIT:
            NVInfo->Dac.InputWidth =32;
            OutData = (SGS_DAC_CONFIG_0_PORT_WIDTH_32BIT << 2) ;
            break;
        case NV_PFB_BOOT_0_DAC_WIDTH_64_BIT:
            NVInfo->Dac.InputWidth =64;
            OutData = (SGS_DAC_CONFIG_0_PORT_WIDTH_64BIT << 2) ;
            break;
        }

    //**************************************************************************
    // Then set the pixel depth appropriately
    //**************************************************************************

    switch (NVInfo->Framebuffer.Depth)
        {
        case 8:
            OutData |= (SGS_DAC_CONFIG_0_PIXEL_DEPTH_8BIT) |
                       (SGS_DAC_CONFIG_0_IDC_MODE_INDEX << 6);
            break;
        case 16:
            OutData |= (SGS_DAC_CONFIG_0_PIXEL_DEPTH_16BIT) |
                       (SGS_DAC_CONFIG_0_IDC_MODE_DIRECT_COLOR << 6);
            break;
        case 32:
            OutData |= (SGS_DAC_CONFIG_0_PIXEL_DEPTH_32BIT) |
                       (SGS_DAC_CONFIG_0_IDC_MODE_DIRECT_COLOR <<6);
            break;
        }

    //**************************************************************************
    // Set DAC_CONFIG_0 register
    //**************************************************************************

    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    //**************************************************************************
    // DAC Load PCLK/VCLK ratio
    //**************************************************************************

    OutData=(SGS_DAC_CONFIG_1 & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_CONFIG_1>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    //**************************************************************************
    // Currently , PClkVClk Ratio is set to 1 up above...
    //**************************************************************************

    switch (NVInfo->Dac.PClkVClkRatio)
    {
        case 1:
            OutData=( SGS_DAC_CONFIG_1_VCLK_DIVIDE_BY_1 << 0) | (SGS_DAC_CONFIG_1_VCLK_IMPEDENCE_LOW << 3);
            break;
        case 2:
            OutData=( SGS_DAC_CONFIG_1_VCLK_DIVIDE_BY_2 << 0) | (SGS_DAC_CONFIG_1_VCLK_IMPEDENCE_LOW << 3);
            break;
        case 4:
            OutData=( SGS_DAC_CONFIG_1_VCLK_DIVIDE_BY_4 << 0) | (SGS_DAC_CONFIG_1_VCLK_IMPEDENCE_LOW << 3);
            break;
        case 8:
            OutData=( SGS_DAC_CONFIG_1_VCLK_DIVIDE_BY_8 << 0) | (SGS_DAC_CONFIG_1_VCLK_IMPEDENCE_LOW << 3);
            break;
        case 16:
            OutData=( SGS_DAC_CONFIG_1_VCLK_DIVIDE_BY_16 << 0) | (SGS_DAC_CONFIG_1_VCLK_IMPEDENCE_LOW << 3);
            break;
    }

    PDAC_REG_WR32(PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    //**************************************************************************
    // Prepare to output green power down level register
    //**************************************************************************

    if (NVInfo->Framebuffer.HSyncPolarity)
        OutData = DRF_DEF(_PFB,_GREEN_0,_POLAR_HSYNC,_POSITIVE);
    else
        OutData = DRF_DEF(_PFB,_GREEN_0,_POLAR_HSYNC,_NEGATIVE);

    if (NVInfo->Framebuffer.VSyncPolarity)
        OutData |= DRF_DEF(_PFB,_GREEN_0,_POLAR_VSYNC,_POSITIVE);
    else
        OutData |= DRF_DEF(_PFB,_GREEN_0,_POLAR_VSYNC,_NEGATIVE);

    if (NVInfo->Framebuffer.CSync)
        OutData |= DRF_DEF(_PFB,_GREEN_0,_CSYNC,_ENABLED);
    else
        OutData |= DRF_DEF(_PFB,_GREEN_0,_CSYNC,_DISABLED);

    //**************************************************************************
    // Make sure video is re-enabled
    //**************************************************************************

    OutData |= DRF_DEF(_PFB,_GREEN_0,_LEVEL,_VIDEO_ENABLED);

    //**************************************************************************
    // Green register
    //**************************************************************************

    PFB_REG_WR32( PFB_Base, NV_PFB_GREEN_0, OutData);

    //**************************************************************************
    // Pixel Mask Register
    //**************************************************************************

    OutData= 0xff;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_PIXEL_MASK, OutData);


    //**************************************************************************
    // DAC PLL values
    //**************************************************************************

    OutData=(SGS_DAC_VPLL_M & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_VPLL_M>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData= NVInfo->Dac.VPllM;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);



    OutData=(SGS_DAC_VPLL_N & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_VPLL_N>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData= NVInfo->Dac.VPllN;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);



    OutData=(SGS_DAC_VPLL_O & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_VPLL_O>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData= NVInfo->Dac.VPllO;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);



    OutData=(SGS_DAC_VPLL_P & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_VPLL_P>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData= NVInfo->Dac.VPllP;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    //**************************************************************************
    // Init palette registers (for 8bpp modes only)
    //**************************************************************************

    if (NVInfo->Framebuffer.Depth == 8)
        NV1_InitPalette(HwDeviceExtension);


    //**************************************************************************
    // Init hardware cursor
    //**************************************************************************

    OutData=(SGS_DAC_CURSOR_CTRL & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_CURSOR_CTRL>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData= SGS_DAC_CURSOR_CTRL_DISPLAY_TWO_COLOR_XOR;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    //**************************************************************************
    // Set cursor color 1
    //**************************************************************************

    OutData=(SGS_DAC_CURSOR_COLOR_1_RED & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);
    OutData=((SGS_DAC_CURSOR_COLOR_1_RED>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);
    OutData= 0;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    OutData=(SGS_DAC_CURSOR_COLOR_1_GREEN & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);
    OutData=((SGS_DAC_CURSOR_COLOR_1_GREEN>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);
    OutData= 0;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    OutData=(SGS_DAC_CURSOR_COLOR_1_BLUE & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);
    OutData=((SGS_DAC_CURSOR_COLOR_1_BLUE>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);
    OutData= 0;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    //**************************************************************************
    // Set cursor color 2
    //**************************************************************************

    OutData=(SGS_DAC_CURSOR_COLOR_2_RED & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);
    OutData=((SGS_DAC_CURSOR_COLOR_2_RED>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);
    OutData= 0xff;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    OutData=(SGS_DAC_CURSOR_COLOR_2_GREEN & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);
    OutData=((SGS_DAC_CURSOR_COLOR_2_GREEN>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);
    OutData= 0xff;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    OutData=(SGS_DAC_CURSOR_COLOR_2_BLUE & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);
    OutData=((SGS_DAC_CURSOR_COLOR_2_BLUE>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);
    OutData= 0xff;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    //**************************************************************************
    // Set cursor color 3
    //**************************************************************************

    OutData=(SGS_DAC_CURSOR_COLOR_3_RED & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);
    OutData=((SGS_DAC_CURSOR_COLOR_3_RED>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);
    OutData= 0;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    OutData=(SGS_DAC_CURSOR_COLOR_3_GREEN & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);
    OutData=((SGS_DAC_CURSOR_COLOR_3_GREEN>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);
    OutData= 0;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    OutData=(SGS_DAC_CURSOR_COLOR_3_BLUE & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);
    OutData=((SGS_DAC_CURSOR_COLOR_3_BLUE>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);
    OutData= 0;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    //**************************************************************************
    // Set cursor image plane 0
    //**************************************************************************

// Someone already loaded a cursor image?? BIOS?
//    OutData=(SGS_DAC_CURSOR_PLANE_0_WRITE_0 & 0xff);
//    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);
//
//    OutData=((SGS_DAC_CURSOR_PLANE_0_WRITE_0>>8) & 0xff);
//    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);
//
//    for (i=0;i<128;i++)
//        {
//        OutData = NVInfo->Dac.CursorImagePlane[0][i];
//        PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);
//        }
//
//    //**************************************************************************
//    // Set cursor image plane 1
//    //**************************************************************************
//
//    OutData=(SGS_DAC_CURSOR_PLANE_1_WRITE_0 & 0xff);
//    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);
//
//    OutData=((SGS_DAC_CURSOR_PLANE_1_WRITE_0>>8) & 0xff);
//    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);
//
//    for (i=0;i<128;i++)
//        {
//        OutData = NVInfo->Dac.CursorImagePlane[1][i];
//        PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);
//        }

    //**************************************************************************
    // Set cursor position
    //**************************************************************************

    OutData=(SGS_DAC_CURSOR_POS_X_LO & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_CURSOR_POS_X_LO>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData=512;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData>>8);


    OutData=(SGS_DAC_CURSOR_POS_Y_LO & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_CURSOR_POS_Y_LO>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData=384;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData>>8);


    //**************************************************************************
    // Set palette register (DAC State Writable)?
    //**************************************************************************

    OutData=(SGS_DAC_RGB_EXT_PAL_CTRL & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_RGB_EXT_PAL_CTRL>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData= 0;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);


    //**************************************************************************
    // DAC Power Management values
    //**************************************************************************

    OutData=(SGS_DAC_POWER_MGMNT_A & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_POWER_MGMNT_A>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData= 0x88;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);



    OutData=(SGS_DAC_POWER_MGMNT_B & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_POWER_MGMNT_B>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData= 0x0;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);



    OutData=(SGS_DAC_POWER_MGMNT_C & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_POWER_MGMNT_C>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData= 0x0;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);



    OutData=(SGS_DAC_VBLANK_CTRL & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_VBLANK_CTRL>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData= 0x0;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    //**************************************************************************
    // Disable SERR
    //**************************************************************************

    OutData = PBUS_REG_RD32( HwDeviceExtension->NV1_Lin_PBUS_Registers, NV_PBUS_PCI_NV_1);
    OutData = (OutData & (~0x00000100));    // SERR DISABLED ???  Why?
    PBUS_REG_WR32( HwDeviceExtension->NV1_Lin_PBUS_Registers, NV_PBUS_PCI_NV_1, OutData);

    //**************************************************************************
    // Enable HARDWARE interrupts throught Pin 1 (A)
    // Enable INTA_Hardware interrupts, NO SOFTWARE Interrupts allowed
    //**************************************************************************

    OutData = 0x1;
    PMC_REG_WR32( HwDeviceExtension->NV1_Lin_PMC_Registers, NV_PMC_INTR_EN_0, OutData);

    } // end NV1SetMode()


//******************************************************************************
//
//  Function:   SetObjectCachedCtxRegs()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID SetObjectCachedCtxRegs(PHW_DEVICE_EXTENSION HwDeviceExtension,
                            ULONG CurrentSubChannel, ULONG ObjectName, ULONG NewContext)


    {
    ULONG SubChannelCount;

    //**************************************************************************
    // Update object's context in FIFO's cached context registers
    //**************************************************************************

    for (SubChannelCount = 0; SubChannelCount < 8; SubChannelCount++)
        {
        if (HwDeviceExtension->FifoTable.ObjectStack[SubChannelCount] == ObjectName )
            {
            PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE1_CTX(SubChannelCount),NewContext);

            //******************************************************************
            // If this is the current subchannel, tell engine the context
            // has been dirtied and needs to be updated
            // We shouldn't have to specify the SubChannel here because
            // that's done by hardware automatically, when we write out
            // the method???(Verify)
            //******************************************************************

            if (SubChannelCount == CurrentSubChannel)
                {
                PFIFO_FLD_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL1,_CTX,_DIRTY);

                //**************************************************************
                // This should be CHANGED so that object swapping works !!!!!
                //**************************************************************

                PFIFO_FLD_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL1,_OBJECT,_CHANGED);

                }

            }

        }

    }



//******************************************************************************
//
//  Function:   SetObjectHash()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID SetObjectHash(PHW_DEVICE_EXTENSION HwDeviceExtension,
                    ULONG ObjectName, ULONG Context)


    {
    ULONG   HashValue;
    ULONG   HashEntry;
    ULONG   i;
    ULONG  *HashTablePtr;


    //**************************************************************************
    // Get ptr to array of hashed objects (object names)
    //**************************************************************************

    HashTablePtr = &(HwDeviceExtension->HashTable[0]);

    //**************************************************************************
    // Get hash value for this object in channel 0
    //**************************************************************************

    HashValue = FIFO_HASH(ObjectName,0);

    //**************************************************************************
    // Find first empty entry (FOR NOW WE ASSUME HASH_DEPTH = 4) UPDATE !!!!!!!
    //**************************************************************************

    for (i=0; i<HASH_DEPTH; i++)
        {
        HashEntry = HASH_ENTRY(HashValue,i);

        //**********************************************************************
        // Need to multiply HashEntry by 2 because HashEntry is only an index
        // from 0 - 255.  That is, when searching through the hash table, each
        // object context takes up 8 bytes.  However, C compiler will already
        // convert address into a ULONG address.  So end result is:
        //  HashEntry (aligned on 8 byte bndry) =  HashTablePtr + (HashEntry*4) *2.
        //**********************************************************************

        if ( *(HashTablePtr+HashEntry*2) == (ULONG)NULL)
            break;

        //**********************************************************************
        // If Object already exists, then use this SAME entry.
        //**********************************************************************

        if ( *(HashTablePtr+HashEntry*2) == ObjectName)
            break;

        }

    //**************************************************************************
    // If we did not find an empty entry, choose one randomly (use 2 for now)
    //**************************************************************************

    if (i == HASH_DEPTH)
        HashEntry = HASH_ENTRY(HashValue,2);

    //**************************************************************************
    // Add object to our local hash table array
    //**************************************************************************

    *(HashTablePtr+HashEntry*2) = ObjectName;

    //**************************************************************************
    // Set object name in hardware HASH table memory
    //**************************************************************************

    PRAMHT_REG_WR32(PRAMHT_Base,DEVICE_BASE(NV_PRAMHT) + HashEntry*8, ObjectName);

    //**************************************************************************
    // Set object context in hardware HASH table memory
    // No lie, using channel 0
    //**************************************************************************

    PRAMHT_REG_WR32(PRAMHT_Base,DEVICE_BASE(NV_PRAMHT) + HashEntry*8+4,Context & 0x00ffffff);
    }


//******************************************************************************
//
//  Function:   FifoResend()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID FifoResend(PHW_DEVICE_EXTENSION HwDeviceExtension)


    {
    ULONG Data;
    ULONG Method;
    ULONG caches, push0, pull0;

    //**************************************************************************
    // THIS FUNCTION HAS NOT YET BEEN TESTED
    //**************************************************************************

    //**************************************************************************
    // Saved FIFO state
    //**************************************************************************

    caches = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHES);
    push0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0);
    pull0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0);

    //**************************************************************************
    // Disable CACHE first
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHES,_REASSIGN,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_DISABLED);

    //**************************************************************************
    // Resend Data
    //**************************************************************************

    PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE0_GET,0x00000000);
    PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE0_PUT,0x00000004);

    //**************************************************************************
    // Channel 0
    //**************************************************************************

    PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE0_PUSH1, 0);
    PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE0_CTX(0), 0);

    //**************************************************************************
    // Wait for it to drain
    //**************************************************************************

    while (PFIFO_REG_RD_DRF(PFIFO_Base,_PFIFO,_CACHE0_STATUS,_LOW_MARK) ==
                                                NV_PFIFO_CACHE0_STATUS_LOW_MARK_NOT_EMPTY)
        {
        if (PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_INTR_0) &  0x11111011)
            VideoDebugPrint((1, "Error - FifoResend."));  /// oooopppssss
        }

    //**************************************************************************
    // Disable CACHE0
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE0_PULL0,_ACCESS, _DISABLED);

    //**************************************************************************
    // Re-Enable CACHE1
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_ENABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_ENABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHES,_REASSIGN,_ENABLED);


    }

//******************************************************************************
//
//  Function:   ClearOutGrTable()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID ClearOutGrTable(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    PGRAPHICSCHANNEL Ptr;

    //**************************************************************************
    // Get ptr to our Graphics Channel
    //**************************************************************************

    Ptr = (PGRAPHICSCHANNEL) &(HwDeviceExtension->GrTable);

    Ptr->NotifyObject       = NULL;
    Ptr->Notify             = (ULONG)NULL;
    Ptr->CurrentRop         = NULL;
    Ptr->CurrentBeta        = NULL;
    Ptr->CurrentColorKey    = NULL;
    Ptr->CurrentPlaneMask   = NULL;
    Ptr->CurrentClip        = NULL;
    Ptr->CurrentPattern     = NULL;
    Ptr->CurrentPatch       = NULL;
    Ptr->PatchList          = NULL;
    Ptr->PatchCount         = (ULONG)NULL;
    Ptr->Exceptions         = (ULONG)NULL;
    }

//******************************************************************************
//
//  Function:   ClearOutFifoTable()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID ClearOutFifoTable(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    ULONG i;
    PFIFO Ptr;

    //**************************************************************************
    // Get ptr to our FIFO structure
    //**************************************************************************

    Ptr = (PFIFO) &(HwDeviceExtension->FifoTable);

    //**************************************************************************
    // Initialize FIFO table structure
    //**************************************************************************

    Ptr->InUse = INVALID;
    Ptr->ChID = INVALID;                    // We will always use channel 0 (for now)
    Ptr->ObjectCount = 0;                   // No objects loaded yet

    //**************************************************************************
    // Clear out the objects
    //**************************************************************************

    for (i=0; i<NUM_SUBCHANNELS; i++)
        Ptr->ObjectStack[i] = (ULONG)NULL;  // 0 means not used

    }



//******************************************************************************
//
//  Function:   ClearOutNVInfo()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID ClearOutNVInfo(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    ULONG i;
    ULONG Length;
    PULONG Ptr;

    //**************************************************************************
    // Get length of HWINFO object structure (in Dwords)
    //**************************************************************************

    Length = sizeof(HWINFO)/4;

    //**************************************************************************
    // Get Ptr to NVInfo structure and fill it with zeros
    //**************************************************************************

    Ptr = (PULONG)&(HwDeviceExtension->NvInfo);

    for (i=0; i<Length; i++)
            {
            *Ptr = 0;
            Ptr++;
            }


    }


//******************************************************************************
//
//  Function:   ClearOutHashTables()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID ClearOutHashTables(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    ULONG i;
    ULONG caches, push0, pull0;

    //**************************************************************************
    // Save FIFO cache1 state
    //**************************************************************************

    caches = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHES);
    push0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0);
    pull0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0);

    //**************************************************************************
    // Disable CACHE1 first
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHES,_REASSIGN,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_DISABLED);

   //***************************************************************************
    // Clear out local hash table with zeros (currently 1k worth)
    //**************************************************************************

    for (i=0; i < 256 * HASH_DEPTH; i++)
        HwDeviceExtension->HashTable[i] = 0;

    //**************************************************************************
    // Clear out hash virtual registers ( 128 of these , one per channel ?)
    // When the Hash Engine looks thru Hash Table memory and it finds
    // an entry that matches the one in the virtual register, then
    // the physical information about the object will be written to
    // the corresponding hash physical register.  Otherwise, zero will be written
    //      -------------------------------------------------------------
    //  n  |                   Object Handle                             |
    //      -------------------------------------------------------------
    //**************************************************************************

    for (i=0; i < 128  ; i++)
        PRAM_REG_WR32(PRAM_Base,NV_PRAM_HASH_VIRTUAL(i),0 );


    //**************************************************************************
    // Clear out hardware hash memory (current 8K worth)
    // There are 256 structures, each containing 4 entries which are each 8 bytes
    // For NV1 (currently), memory_size = 256 * HASH_DEPTH * 8 = 8k
    //      --------------------------------------------------------------
    //     |                    Object Handle                             |
    //  n   --------------------------------------------------------------
    //     | Channel ID       Phys Device Address   Phys Instance Address |
    //      --------------------------------------------------------------
    //**************************************************************************

    for (i=0; i < (256 * HASH_DEPTH * 8) ; i+=8) // Advance 8 bytes each time
        {
        PRAMHT_REG_WR32(PRAMHT_Base,DEVICE_BASE(NV_PRAMHT)+i,0 );
        PRAMHT_REG_WR32(PRAMHT_Base,DEVICE_BASE(NV_PRAMHT)+i+4,0 );
        }

    //**************************************************************************
    // Restore saved FIFO cache1 state
    //**************************************************************************

    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0,pull0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0,push0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHES,caches);


    }

//******************************************************************************
//
//  Function:   ClearOutContextMemoryAndRegisters()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID ClearOutContextMemoryAndRegisters(PHW_DEVICE_EXTENSION HwDeviceExtension)


    {
    ULONG CurrentChID;
    ULONG Data;
    ULONG CurrentInstance;
    ULONG InitContextPtr;
    ULONG ContextPtr;
    ULONG caches;
    ULONG cache1push0;
    ULONG cache1pull0;

    //**************************************************************************
    // Saved FIFO state
    //**************************************************************************

    caches = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHES);
    cache1push0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0);
    cache1pull0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0);

    //**************************************************************************
    // Disable Fifo access
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHES,_REASSIGN,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_DISABLED);

    //**************************************************************************
    // Tell Cache1 to use Channel 0
    //**************************************************************************

    CurrentChID=0;
    PFIFO_REG_WR_DRF_NUM(PFIFO_Base,_PFIFO,_CACHE1_PUSH1,_CHID, CurrentChID);

    //**************************************************************************
    // Clean out FIFO CONTEXT memory
    // Currently, There are a 128 total possible channels, each channel
    // contains 8 contexts, each 4 bytes.  Memory_size = 128 * 8 * 4;
    // However, since we are only using channel 0, just clear out channel 0.
    //**************************************************************************

    CurrentChID=0;
    InitContextPtr = DEVICE_BASE(NV_PRAMFC) + (CurrentChID*32) ;
    for (ContextPtr=InitContextPtr; ContextPtr < (InitContextPtr + 32); ContextPtr+=4)
        PRAMFC_REG_WR32(PRAMFC_Base, ContextPtr , 0);

    //**************************************************************************
    // Initialize Cache1 to use subchannel zero
    //**************************************************************************

    PFIFO_REG_WR_DRF_NUM(PFIFO_Base,_PFIFO,_CACHE1_PULL1,_SUBCHANNEL,0);

    //**************************************************************************
    // Set PUT and GET pointers to address 0
    //**************************************************************************

    PFIFO_REG_WR_DRF_NUM(PFIFO_Base,_PFIFO,_CACHE1_PUT,_ADDRESS,0);
    PFIFO_REG_WR_DRF_NUM(PFIFO_Base,_PFIFO,_CACHE1_GET,_ADDRESS,0);

    //**************************************************************************
    // Clear out CACHED CONTEXT registers
    //**************************************************************************

    PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE0_CTX(0), 0);

    PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE1_CTX(0), 0);
    PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE1_CTX(1), 0);
    PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE1_CTX(2), 0);
    PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE1_CTX(3), 0);
    PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE1_CTX(4), 0);
    PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE1_CTX(5), 0);
    PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE1_CTX(6), 0);
    PFIFO_REG_WR32(PFIFO_Base,NV_PFIFO_CACHE1_CTX(7), 0);

    //**************************************************************************
    // Check if Context has changed.
    // (Make sure that Chroma, Beta, Plane_Mask, UserClip, Alpha,
    // and Mono have not changed).
    // For now, we FORCE context to be loaded up above, so it should be the same..
    //**************************************************************************

//    Data = PGRAPH_REG_RD32(PGRAPH_Base, NV_PGRAPH_CTX_SWITCH);
//    CurrentInstance = DRF_VAL(_PGRAPH,_CTX_SWITCH,_INSTANCE,Data);
//
//    if ( (CurrentContext & 0xffff) != CurrentInstance)
//            ASSERTDD(FALSE, "ClearOutContextMemory.");  /// oooopppssss

    //**************************************************************************
    // Make sure that channel is the same
    //**************************************************************************

//    CurrentChID = PGRAPH_REG_RD_DRF(PGRAPH_Base,_PGRAPH,_MISC,_CLASS);
//    if (CurrentChID != ((CurrentContext >> 16) & 0x7f))
//        {
//          ASSERTDD(FALSE, "ClearOutContextMemory.");  /// oooopppssss
//        PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE0_PULL1,_OBJECT,_CHANGED);
//        }

    //**************************************************************************
    // Check object_changed bit for CACHE1
    // Set CACHE0 bit to have same value.
    //**************************************************************************

//    Data = PFIFO_REG_RD32(PFIFO_Base,NV_PFIFO_CACHE1_PULL1);
//
//    if (Data)
//        PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE0_PULL1,_OBJECT,_CHANGED);
//    else
//        PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE0_PULL1,_OBJECT,_UNCHANGED);

    //**************************************************************************
    // Restore saved FIFO state
    //**************************************************************************

    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0,cache1pull0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0,cache1push0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHES,caches);


    }


//******************************************************************************
//
//  Function:   LoadChannelContext()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID LoadChannelContext(PHW_DEVICE_EXTENSION HwDeviceExtension)


    {
    ULONG Data;
    ULONG Result;
    ULONG CurrentInstance;
    ULONG SavedGraphicsState;
    ULONG CurrentChID;
    ULONG caches;
    ULONG cache0push0;
    ULONG cache0pull0;
    ULONG cache1push0;
    ULONG cache1pull0;
    ULONG XYLogicMisc1;
    PGRAPHICSCHANNEL GrTablePtr;
    ULONG i;

    //**************************************************************************
    // Get pointer to graphics channel
    //**************************************************************************

    GrTablePtr = &(HwDeviceExtension->GrTable);

    //**************************************************************************
    // Saved FIFO state
    //**************************************************************************

    caches = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHES);
    cache0push0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE0_PUSH0);
    cache0pull0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE0_PULL0);
    cache1push0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0);
    cache1pull0 = PFIFO_REG_RD32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0);

    //**************************************************************************
    // Disable Fifo access
    //**************************************************************************

    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHES,_REASSIGN,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE0_PUSH0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE0_PULL0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PUSH0,_ACCESS,_DISABLED);
    PFIFO_REG_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL0,_ACCESS,_DISABLED);

    //**************************************************************************
    // Force Cache 0 and Cache 1 to be set for channel 0
    //**************************************************************************

    PFIFO_REG_WR_DRF_NUM(PFIFO_Base,_PFIFO,_CACHE0_PUSH1,_CHID, 0);
    PFIFO_REG_WR_DRF_NUM(PFIFO_Base,_PFIFO,_CACHE1_PUSH1,_CHID, 0);

    //**************************************************************************
    // Default Cache 1 to be set for subchannel 0 also.
    // Signal that the object is DIRTY and the object has CHANGED
    // since we haven't loaded it yet.  We don't bother setting
    // the subchannel for Cache0 because that's mainly used by the Resource Mgr.
    // Make sure the subsequent macros are the FLD type, to preserve what's
    // currently in the register.
    //**************************************************************************

    PFIFO_REG_WR_DRF_NUM(PFIFO_Base,_PFIFO,_CACHE1_PULL1,_SUBCHANNEL, 0);
    PFIFO_FLD_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL1,_CTX,_DIRTY);
    PFIFO_FLD_WR_DRF_DEF(PFIFO_Base,_PFIFO,_CACHE1_PULL1,_OBJECT,_CHANGED);

    //**************************************************************************
    // Check for any outstanding graphics exceptions
    //**************************************************************************
//
//    while (PGRAPH_REG_RD32(PGRAPH_Base, NV_PGRAPH_INTR_0) & 0x11111011)
//        ASSERTDD(FALSE, "LoadChannelContext.");      // Uh oh....shouldn't happen

    //**************************************************************************
    // Reset graphics state engine.  I'm not sure if this is necessary?
    // but I'm including it because the Resource Manager uses it.
    //**************************************************************************

    if (PGRAPH_REG_RD32(PGRAPH_Base, NV_PGRAPH_DEBUG_1) & 0x01)
        PGRAPH_FLD_WR_DRF_DEF(PGRAPH_Base,_PGRAPH,_DEBUG_0,_STATE,_NORMAL);


    //**************************************************************************
    // Init Context Control register for the first time
    // Instance is zero, and Channel is currently invalid
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_CTX_CONTROL,
                               DRF_DEF(_PGRAPH, _CTX_CONTROL, _MINIMUM_TIME, _2MS)
                             | DRF_DEF(_PGRAPH, _CTX_CONTROL, _TIME,         _EXPIRED)
                             | DRF_DEF(_PGRAPH, _CTX_CONTROL, _CHID,         _INVALID)
                             | DRF_DEF(_PGRAPH, _CTX_CONTROL, _SWITCHING,    _IDLE)
                             | DRF_DEF(_PGRAPH, _CTX_CONTROL, _DEVICE,       _ENABLED));


    //**************************************************************************
    // Note: I'm skipping the grTextureFixup() call because
    //       we won't be using textures at this point.
    //**************************************************************************

    //**************************************************************************
    // Init Static State to Default value first, just to be safe. Necessary?
    // ROP, Beta, ColorKey, PlaneMask, Clip, and Pattern
    //**************************************************************************

//    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ROP3, 0xcc);     // Source Copy
//    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_BETA,0x07f8 );
//    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PLANE_MASK, 0);
//    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_CHROMA, 0);

    //**************************************************************************
    // Load STATIC STATE as follows:
    // ROP, Beta, ColorKey, PlaneMask, Clip, and Pattern
    //**************************************************************************

    if (GrTablePtr->CurrentRop)
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ROP3, GrTablePtr->CurrentRop->Rop3);

    if (GrTablePtr->CurrentBeta)
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_BETA, GrTablePtr->CurrentBeta->Beta);

    if (GrTablePtr->CurrentClip)
        {
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_UCLIP_XMIN, GrTablePtr->CurrentClip->xClipMin);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_UCLIP_YMIN, GrTablePtr->CurrentClip->yClipMin);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_UCLIP_XMAX, GrTablePtr->CurrentClip->xClipMax);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_UCLIP_YMAX, GrTablePtr->CurrentClip->yClipMax);
        XYLogicMisc1 = (DRF_DEF(_PGRAPH, _XY_LOGIC_MISC1, _SEL_XCMIN, _USERMIN)  |
                     DRF_DEF(_PGRAPH, _XY_LOGIC_MISC1, _SEL_XCMAX, _USERMAX)  |
                     DRF_DEF(_PGRAPH, _XY_LOGIC_MISC1, _SEL_YCMIN, _USERMIN)  |
                     DRF_DEF(_PGRAPH, _XY_LOGIC_MISC1, _SEL_YCMAX, _USERMAX)) ;
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_XY_LOGIC_MISC1,XYLogicMisc1);


        }

    if (GrTablePtr->CurrentPlaneMask)
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PLANE_MASK, GrTablePtr->CurrentPlaneMask->Color);

    if (GrTablePtr->CurrentColorKey)
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_CHROMA, GrTablePtr->CurrentColorKey->Color);

    if (GrTablePtr->CurrentPattern)
        {
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATT_COLOR0_0, GrTablePtr->CurrentPattern->PattColor0);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATT_COLOR0_1, GrTablePtr->CurrentPattern->PattColor0Alpha);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATT_COLOR1_0, GrTablePtr->CurrentPattern->PattColor1);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATT_COLOR1_1, GrTablePtr->CurrentPattern->PattColor1Alpha);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATTERN(0), GrTablePtr->CurrentPattern->Pattern0);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATTERN(1), GrTablePtr->CurrentPattern->Pattern1);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_PATTERN_SHAPE, GrTablePtr->CurrentPattern->PatternShape);
        }

    //**************************************************************************
    // Load RENDERING STATE as follows:
    //**************************************************************************

    if (GrTablePtr->CurrentPatch)
        {

        //**********************************************************************
        // STATIC STATE vs. RENDERING STATE
        //
        // STATIC STATE values are those attributes associated with the patch
        // and are specified when creating a patch.
        //
        // RENDERING STATE refers to the current attributes that are present
        // when an object is currently rendering.  That is, if a blit is
        // is interrupted, additional registers need to be saved and restored
        // such as the current source color or BETA ram values, so that the
        // rendering state can be restored EXACTLY the way it was prior to
        // being context switched.  Since this Miniport driver will not handle
        // context switching (We are in full control of context switching here),
        // we do not have to worry about saving/restoring them.(Need to init, though?)
        //
        // So for now, we do nothing.  As long as we keep track of the
        // static state objects, we should be fine.
        //**********************************************************************

        }

    else

        {
        //**********************************************************************
        // Init default values for the rendering state, since no patch was present
        //**********************************************************************

        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_CANVAS_MIN, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_CANVAS_MAX, 0x1fff1fff);

        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_CLIP_MISC, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_CLIP0_MIN, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_CLIP1_MIN, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_CLIP0_MAX, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_CLIP1_MAX, 0x00000000);

        //**********************************************************************
        // TO DO!!
        //
        // NOTE: We need to determine what mode we are in so we can ENABLE/DISABLE
        //       DAC bypass appropriately !!!
        //
        // Currently set as follows:  DITHERING enabled and DACBYPASS enabled
        //
        //**********************************************************************

        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_CANVAS_MISC, 0x00110001);

        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_SOURCE_COLOR, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MONO_COLOR0, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MONO_COLOR1, 0x00000000);

        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_UCLIP_XMIN, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_UCLIP_YMIN, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_UCLIP_XMAX, 0x00007fff);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_UCLIP_YMAX, 0x00007fff);

        for (i=0;i < 14;i++)
            PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_BETA_RAM(i), 0x00000000);

        for (i=0;i < 18;i++)
            {
            PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_X_RAM(i), 0x00000000);
            PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_Y_RAM(i), 0x00000000);
            }

        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_ICLIP_XMAX, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_ABS_ICLIP_YMAX, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_XY_LOGIC_MISC0, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_XY_LOGIC_MISC1, 0x00000000);

        //**********************************************************************
        // Always use the USER clip rects
        //**********************************************************************

        XYLogicMisc1 |= (DRF_DEF(_PGRAPH, _XY_LOGIC_MISC1, _SEL_XCMIN, _USERMIN)  |
                     DRF_DEF(_PGRAPH, _XY_LOGIC_MISC1, _SEL_XCMAX, _USERMAX)  |
                     DRF_DEF(_PGRAPH, _XY_LOGIC_MISC1, _SEL_YCMIN, _USERMIN)  |
                     DRF_DEF(_PGRAPH, _XY_LOGIC_MISC1, _SEL_YCMAX, _USERMAX)) ;
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_XY_LOGIC_MISC1,XYLogicMisc1);


        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_X_MISC, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_Y_MISC, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_SUBDIVIDE, 0x00000000);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_EDGEFILL, 0x00000000);


        //**********************************************************************
        // Now that we've initialized the registers, go ahead and mark
        // this channel as valid in the FIFO table structure
        //**********************************************************************

        HwDeviceExtension->FifoTable.InUse = 1;             // 1 = Valid
        HwDeviceExtension->FifoTable.ChID = 0;              // Channel 0 always
        }


    //**************************************************************************
    // TO DO:
    // Notify object --> Need to update??
    //**************************************************************************


    //**************************************************************************
    // Reset Context Switch bits
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base,NV_PGRAPH_EXCEPTIONS,0);


    //**************************************************************************
    // Update and validate the channel (0)
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_CTX_CONTROL,
                                DRF_DEF(_PGRAPH,_CTX_CONTROL,_MINIMUM_TIME, _2MS) |
                                DRF_DEF(_PGRAPH,_CTX_CONTROL,_TIME, _NOT_EXPIRED) |
                                DRF_DEF(_PGRAPH,_CTX_CONTROL,_CHID, _VALID)       |
                                DRF_DEF(_PGRAPH,_CTX_CONTROL,_SWITCHING,_IDLE)    |
                                DRF_DEF(_PGRAPH,_CTX_CONTROL,_DEVICE,_ENABLED));


    //**************************************************************************
    // Restore saved FIFO state
    //**************************************************************************

    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE0_PULL0,cache0pull0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE0_PUSH0,cache0push0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PULL0,cache1pull0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHE1_PUSH0,cache1push0);
    PFIFO_REG_WR32(PFIFO_Base, NV_PFIFO_CACHES,caches);

    }


//******************************************************************************
//
// Function: NV1_SetColorLookup()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV1_SetColorLookup(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_CLUT ClutBuffer,
    ULONG ClutBufferSize
    )


    {
    ULONG OutData;
    USHORT i;

    //**************************************************************************
    // Set the first CLUT index
    //**************************************************************************

    OutData=(SGS_DAC_RGB_EXT_PAL_CTRL & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_RGB_EXT_PAL_CTRL>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData= 0x0;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    OutData= (UCHAR) ClutBuffer->FirstEntry;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_WRITE_PAL_ADDR,OutData);

    //**************************************************************************
    //  Set CLUT registers directly on the hardware
    //**************************************************************************

    for (i = 0; i < ClutBuffer->NumEntries; i++)
        {
        OutData= (ULONG) ((UCHAR)(ClutBuffer->LookupTable[i].RgbArray.Red));
        PDAC_REG_WR32 (PDAC_Base,SGS_DAC_UPORT_COLOR,OutData);

        OutData= (ULONG) ((UCHAR)(ClutBuffer->LookupTable[i].RgbArray.Green));
        PDAC_REG_WR32 (PDAC_Base,SGS_DAC_UPORT_COLOR,OutData);

        OutData= (ULONG) ((UCHAR)(ClutBuffer->LookupTable[i].RgbArray.Blue));
        PDAC_REG_WR32 (PDAC_Base,SGS_DAC_UPORT_COLOR,OutData);
        }

    }


//******************************************************************************
//
// Function: NV1_InitPalette()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************


VOID NV1_InitPalette(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    )

    {
    ULONG OutData;
    USHORT i;

    //**************************************************************************
    // Set the first CLUT index
    //**************************************************************************

    OutData=(SGS_DAC_RGB_EXT_PAL_CTRL & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_LO, OutData);

    OutData=((SGS_DAC_RGB_EXT_PAL_CTRL>>8) & 0xff);
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_HI, OutData);

    OutData= 0x0;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_INDEX_DATA, OutData);

    OutData= 0x0;
    PDAC_REG_WR32( PDAC_Base, SGS_DAC_UPORT_WRITE_PAL_ADDR,OutData);

    //**************************************************************************
    //  Set CLUT registers directly on the hardware
    // Init to a gray scale so we'll something appear instead of just black
    //**************************************************************************

    for (i = 0; i < 256 ; i++)
        {
        OutData= (ULONG) ((UCHAR)(i));
        PDAC_REG_WR32 (PDAC_Base,SGS_DAC_UPORT_COLOR,OutData);

        OutData= (ULONG) ((UCHAR)(i));
        PDAC_REG_WR32 (PDAC_Base,SGS_DAC_UPORT_COLOR,OutData);

        OutData= (ULONG) ((UCHAR)(i));
        PDAC_REG_WR32 (PDAC_Base,SGS_DAC_UPORT_COLOR,OutData);
        }

    }


//******************************************************************************
//
// Function:    NV1_MapMemoryRanges()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

ULONG NV1_MapMemoryRanges(PVOID HwDeviceExtension)

    {
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PHWREG LinearMasterControlAddress;
    PHWREG LinearPFBControlAddress;
    ULONG SavedPMC;
    ULONG SavedIntrEn0;
    ULONG SavedConfig0;
    ULONG SavedDelay0;
    ULONG SavedGreen0;

    //**************************************************************************
    // Map memory for the NV hardware registers.  Not all of these ranges
    // are necessary, but we may need to access some of them later.
    // So we'll map a good majority of them for now.
    //**************************************************************************

    //**************************************************************************
    // Map memory for the NV1 MASTER CONTROL registers (4k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PMC_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PMC_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PMC_Registers.LowPart += RangeOffsets[NV_PMC_INDEX].ulOffset;
    hwDeviceExtension->NV1_PMC_Length = RangeOffsets[NV_PMC_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PMC_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PMC_Registers,
              hwDeviceExtension->NV1_PMC_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map Master Control Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }

    LinearMasterControlAddress = hwDeviceExtension->NV1_Lin_PMC_Registers;

    //**************************************************************************
    // Enable ALL devices and interrupts.  Memory registers will NOT be accessible
    // until we do this final step. (Trying to read an NV Memory location before
    // setting this register will cause the debugger to hang the bus).
    //
    // NOTE:   Memory locations which are UNDEFINED for the NV architecture
    //         could hang the BUS if read.  So be careful about which
    //         memory locations you look at.  Some debuggers don't handle
    //         this too well.  So you might not be able to manually
    //         examine the registers if your debugger tries to read more
    //         than one location at once (possibly reading some undefined regs)
    //         Also, the NV architecture is a 32-bit environment and
    //         does not like reading/writing bytes at a time.
    //**************************************************************************

    PMC_REG_WR32(LinearMasterControlAddress,NV_PMC_ENABLE, 0xffffffff);

    //**************************************************************************
    // Map memory for the NV1 FRAME BUFFER CONTROL registers (4k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PFB_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PFB_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PFB_Registers.LowPart += RangeOffsets[NV_PFB_INDEX].ulOffset;
    hwDeviceExtension->NV1_PFB_Length = RangeOffsets[NV_PFB_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PFB_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PFB_Registers,
              hwDeviceExtension->NV1_PFB_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map Frame Buffer Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }

    LinearPFBControlAddress = hwDeviceExtension->NV1_Lin_PFB_Registers;


    //**************************************************************************
    // Map memory for the NV1 REAL MODE CONTROL registers (32k worth )
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PRM_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PRM_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PRM_Registers.LowPart += RangeOffsets[NV_PRM_INDEX].ulOffset;
    hwDeviceExtension->NV1_PRM_Length = RangeOffsets[NV_PRM_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PRM_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PRM_Registers,
              hwDeviceExtension->NV1_PRM_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map Real Mode Control Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 DAC registers (4k worth??)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PDAC_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PDAC_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PDAC_Registers.LowPart += RangeOffsets[NV_PDAC_INDEX].ulOffset;
    hwDeviceExtension->NV1_PDAC_Length = RangeOffsets[NV_PDAC_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PDAC_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PDAC_Registers,
              hwDeviceExtension->NV1_PDAC_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map DAC Registers\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 RAM registers (4k worth??)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PRAM_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PRAM_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PRAM_Registers.LowPart += RangeOffsets[NV_PRAM_INDEX].ulOffset;
    hwDeviceExtension->NV1_PRAM_Length = RangeOffsets[NV_PRAM_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PRAM_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PRAM_Registers,
              hwDeviceExtension->NV1_PRAM_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map RAM Registers\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 RAMFC registers
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PRAMFC_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PRAMFC_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PRAMFC_Registers.LowPart += RangeOffsets[NV_PRAMFC_INDEX].ulOffset;
    hwDeviceExtension->NV1_PRAMFC_Length = RangeOffsets[NV_PRAMFC_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PRAMFC_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PRAMFC_Registers,
              hwDeviceExtension->NV1_PRAMFC_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map RAMFC Registers\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 RAMHT registers
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PRAMHT_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PRAMHT_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PRAMHT_Registers.LowPart += RangeOffsets[NV_PRAMHT_INDEX].ulOffset;
    hwDeviceExtension->NV1_PRAMHT_Length = RangeOffsets[NV_PRAMHT_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PRAMHT_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PRAMHT_Registers,
              hwDeviceExtension->NV1_PRAMHT_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map RAMHT Registers\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 FIFO registers (8k worth??)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PFIFO_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PFIFO_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PFIFO_Registers.LowPart += RangeOffsets[NV_PFIFO_INDEX].ulOffset;
    hwDeviceExtension->NV1_PFIFO_Length = RangeOffsets[NV_PFIFO_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PFIFO_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PFIFO_Registers,
              hwDeviceExtension->NV1_PFIFO_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map FIFO Registers\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 PBUS registers (4k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PBUS_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PBUS_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PBUS_Registers.LowPart += RangeOffsets[NV_PBUS_INDEX].ulOffset;
    hwDeviceExtension->NV1_PBUS_Length = RangeOffsets[NV_PBUS_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PBUS_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PBUS_Registers,
              hwDeviceExtension->NV1_PBUS_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map PBUS Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 PGRAPH registers (4k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PGRAPH_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PGRAPH_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PGRAPH_Registers.LowPart += RangeOffsets[NV_PGRAPH_INDEX].ulOffset;
    hwDeviceExtension->NV1_PGRAPH_Length = RangeOffsets[NV_PGRAPH_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PGRAPH_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PGRAPH_Registers,
              hwDeviceExtension->NV1_PGRAPH_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map PGRAPH Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 Rectangle USER registers (8k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_URECT_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_URECT_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_URECT_Registers.LowPart += RangeOffsets[NV_URECT_INDEX].ulOffset;
    hwDeviceExtension->NV1_URECT_Length = RangeOffsets[NV_URECT_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_URECT_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_URECT_Registers,
              hwDeviceExtension->NV1_URECT_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map URECT Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 Triangle registers (8k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_UTRI_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_UTRI_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_UTRI_Registers.LowPart += RangeOffsets[NV_UTRI_INDEX].ulOffset;
    hwDeviceExtension->NV1_UTRI_Length = RangeOffsets[NV_UTRI_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_UTRI_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_UTRI_Registers,
              hwDeviceExtension->NV1_UTRI_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map UTRI Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 BLIT registers (8k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_UBLIT_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_UBLIT_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_UBLIT_Registers.LowPart += RangeOffsets[NV_UBLIT_INDEX].ulOffset;
    hwDeviceExtension->NV1_UBLIT_Length = RangeOffsets[NV_UBLIT_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_UBLIT_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_UBLIT_Registers,
              hwDeviceExtension->NV1_UBLIT_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map UBLIT Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 IMAGE From CPU registers (8k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_UIMAGE_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_UIMAGE_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_UIMAGE_Registers.LowPart += RangeOffsets[NV_UIMAGE_INDEX].ulOffset;
    hwDeviceExtension->NV1_UIMAGE_Length = RangeOffsets[NV_UIMAGE_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_UIMAGE_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_UIMAGE_Registers,
              hwDeviceExtension->NV1_UIMAGE_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map UIMAGE Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 IMAGE MONO From CPU registers (8k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_UBITMAP_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_UBITMAP_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_UBITMAP_Registers.LowPart += RangeOffsets[NV_UBITMAP_INDEX].ulOffset;
    hwDeviceExtension->NV1_UBITMAP_Length = RangeOffsets[NV_UBITMAP_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_UBITMAP_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_UBITMAP_Registers,
              hwDeviceExtension->NV1_UBITMAP_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map UBITMAP Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }

    //**************************************************************************
    // Map memory for the NV1 PCI CONFIG registers (512 bytes worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_CONFIG_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_CONFIG_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_CONFIG_Registers.LowPart += RangeOffsets[NV_CONFIG_INDEX].ulOffset;
    hwDeviceExtension->NV1_CONFIG_Length = RangeOffsets[NV_CONFIG_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_CONFIG_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_CONFIG_Registers,
              hwDeviceExtension->NV1_CONFIG_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map CONFIG Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 DMA registers (4k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PDMA_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PDMA_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PDMA_Registers.LowPart += RangeOffsets[NV_PDMA_INDEX].ulOffset;
    hwDeviceExtension->NV1_PDMA_Length = RangeOffsets[NV_PDMA_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PDMA_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PDMA_Registers,
              hwDeviceExtension->NV1_PDMA_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map PDMA Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 PTIMER registers (4k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PTIMER_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PTIMER_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PTIMER_Registers.LowPart += RangeOffsets[NV_PTIMER_INDEX].ulOffset;
    hwDeviceExtension->NV1_PTIMER_Length = RangeOffsets[NV_PTIMER_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PTIMER_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PTIMER_Registers,
              hwDeviceExtension->NV1_PTIMER_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map PTIMER Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 PAUDIO registers (4k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PAUDIO_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PAUDIO_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PAUDIO_Registers.LowPart += RangeOffsets[NV_PAUDIO_INDEX].ulOffset;
    hwDeviceExtension->NV1_PAUDIO_Length = RangeOffsets[NV_PAUDIO_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PAUDIO_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PAUDIO_Registers,
              hwDeviceExtension->NV1_PAUDIO_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map PAUDIO Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 PAUTH registers (4k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PAUTH_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PAUTH_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PAUTH_Registers.LowPart += RangeOffsets[NV_PAUTH_INDEX].ulOffset;
    hwDeviceExtension->NV1_PAUTH_Length = RangeOffsets[NV_PAUTH_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PAUTH_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PAUTH_Registers,
              hwDeviceExtension->NV1_PAUTH_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map PAUTH Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 PEXTDEV registers (4k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PEXTDEV_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PEXTDEV_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PEXTDEV_Registers.LowPart += RangeOffsets[NV_PEXTDEV_INDEX].ulOffset;
    hwDeviceExtension->NV1_PEXTDEV_Length = RangeOffsets[NV_PEXTDEV_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PEXTDEV_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PEXTDEV_Registers,
              hwDeviceExtension->NV1_PEXTDEV_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map PEXTDEV Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 PEEPROM registers (4k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PEEPROM_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PEEPROM_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PEEPROM_Registers.LowPart += RangeOffsets[NV_PEEPROM_INDEX].ulOffset;
    hwDeviceExtension->NV1_PEEPROM_Length = RangeOffsets[NV_PEEPROM_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PEEPROM_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PEEPROM_Registers,
              hwDeviceExtension->NV1_PEEPROM_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map PEEPROM Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 PROM registers (32k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PROM_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PROM_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PROM_Registers.LowPart += RangeOffsets[NV_PROM_INDEX].ulOffset;
    hwDeviceExtension->NV1_PROM_Length = RangeOffsets[NV_PROM_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PROM_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PROM_Registers,
              hwDeviceExtension->NV1_PROM_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map PROM Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }


    //**************************************************************************
    // Map memory for the NV1 PALT registers (32k worth)
    // Here, we obtain a virtual address from the physical address
    //**************************************************************************

    hwDeviceExtension->NV1_Phys_PALT_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_PALT_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_PALT_Registers.LowPart += RangeOffsets[NV_PALT_INDEX].ulOffset;
    hwDeviceExtension->NV1_PALT_Length = RangeOffsets[NV_PALT_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_PALT_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_PALT_Registers,
              hwDeviceExtension->NV1_PALT_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map PALT Regs\n"));
        return(ERROR_INVALID_PARAMETER);
        }

    //******************************************************************
    // Store the USER channel address in our HwDeviceExtension
    // structure, so that we can verify that the graphics engine is
    // working HERE in the miniport, before the display driver takes over.
    //******************************************************************
    hwDeviceExtension->NV1_Phys_USER_Registers.HighPart = 0x00000000;
    hwDeviceExtension->NV1_Phys_USER_Registers.LowPart = NVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart.LowPart;
    hwDeviceExtension->NV1_Phys_USER_Registers.LowPart += RangeOffsets[NV_USER_INDEX].ulOffset;
    hwDeviceExtension->NV1_USER_Length = RangeOffsets[NV_USER_INDEX].ulLength;

    if ( ( hwDeviceExtension->NV1_Lin_USER_Registers =
              VideoPortGetDeviceBase(hwDeviceExtension,
                      hwDeviceExtension->NV1_Phys_USER_Registers,
              hwDeviceExtension->NV1_USER_Length, FALSE)) == NULL)
        {
        VideoDebugPrint((1, "NVFindAdapter - Failed to map USER Channel\n"));
        return(ERROR_INVALID_PARAMETER);
        }



    //**************************************************************************
    // Init the Master Control Register
    //**************************************************************************

    SavedPMC = PMC_REG_RD32(LinearMasterControlAddress, NV_PMC_ENABLE);
    SavedIntrEn0 = PMC_REG_RD32(LinearMasterControlAddress, NV_PMC_INTR_EN_0);

    PMC_REG_WR32(LinearMasterControlAddress, NV_PMC_ENABLE, 0xffffffff);

    //**************************************************************************
    // Prepare to write to the frame buffer control registers
    //**************************************************************************

    SavedConfig0 = PFB_REG_RD32(LinearPFBControlAddress, NV_PFB_CONFIG_0);
    SavedDelay0 = PFB_REG_RD32(LinearPFBControlAddress, NV_PFB_DELAY_0);
    SavedGreen0 = PFB_REG_RD32(LinearPFBControlAddress, NV_PFB_GREEN_0);

    //**************************************************************************
    // TEST CODE:
    // Blank the screen, then turn it back on just to verify that we've
    // correctly mapped the NV registers and that they are enabled.
    //**************************************************************************

    PFB_REG_WR32(LinearPFBControlAddress, NV_PFB_GREEN_0, 0x00000001);
    PFB_REG_WR32(LinearPFBControlAddress, NV_PFB_GREEN_0, SavedGreen0);

    //**************************************************************************
    // Turn off all NV interrupts
    //**************************************************************************

    PMC_REG_WR32(LinearMasterControlAddress, NV_PMC_INTR_EN_0, 0x0);

    //**************************************************************************
    // Return successful
    //**************************************************************************

    return(NO_ERROR);
    } // NV1_MapMemoryRanges()



//******************************************************************************
//
// Function: NV1_IsPresent()
//
// Routine Description:
//
// Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
// Return Value:
//
//******************************************************************************


BOOLEAN NV1_IsPresent(PHW_DEVICE_EXTENSION HwDeviceExtension,
                      PVIDEO_ACCESS_RANGE pNVAccessRange,
                      PULONG NV1Slot)


    {
    VIDEO_ACCESS_RANGE TempAccessRange;
    USHORT  usVendorId,stVendorId;
    USHORT  usDeviceId;
    ULONG   ulSlot     = 0;
    ULONG   Address;
    ULONG   i;

    //**************************************************************************
    // VideoPortGetAccessRanges calls the PCI Bios to determine
    //    if the specified device is present or not.  This appears
    //    to be the equivalent call to the PCI Bios FIND_PCI_DEVICE call.
    //
    // Specify NumRequestedResources = 0
    //         RequestedResources = NULL
    //         NumAccessRanges = 1
    //         TempAccessRanges = Bus relative memory ranges for device (returned)
    //         VendorID = ID which identifies manufacturer
    //         DeviceID = ID which identifies device
    //         Slot = Specifies the Nth device of this type.
    //                Specify 0 to find the first (zero'th) occurence of device)
    //**************************************************************************

    stVendorId = ST1_VENDOR_ID;
    usVendorId = NV1_VENDOR_ID;
    usDeviceId = NV1_DEVICE_NV1_ID;

    //**************************************************************************
    // First, check and see if NV1 is present
    //**************************************************************************

    if (VideoPortGetAccessRanges(HwDeviceExtension,
                                 0,
                                 NULL,
                                 1,
                                 &TempAccessRange,
                                 &usVendorId,
                                 &usDeviceId,
                                 &ulSlot) == NO_ERROR)
        {

Treat_SGS_Same_As_NV:

        VideoDebugPrint((1,"Found an NV1 in pci slot %d\n", ulSlot));
        HwDeviceExtension->ulSlot = ulSlot;

        //**********************************************************************
        //  At this point we have identified an NV1 on the PCi bus by using the
        //  vendor and device id.
        //**********************************************************************

        HwDeviceExtension->ulChipID   = NV1_DEVICE_NV1_ID;
        HwDeviceExtension->ulRevLevel = REV_UNDEF;
        HwDeviceExtension->BoardID = NV1_VENDOR_ID;

        //**********************************************************************
        // Save the slot number of later (for VideoPortSetBusData)
        //**********************************************************************

        *NV1Slot = ulSlot;

        //**********************************************************************
        //  TO DO:  The VideoPortGetAccessRanges call seems to work
        //          by calling the PCI Bios.  However, to be safe, we should
        //          add additional code to manually search for an NV1 adapter
        //          (ala the ScanNVMechanism1/2 routines in the Resource Manager)
        //          just in case some system BIOS's don't work correctly, or
        //          we're using a system with an older/buggy PCI Bios
        //**********************************************************************

        //**********************************************************************
        // Initialize the BASE PHYSICAL ADDRESS of the NV adapter in the Access Ranges
        //**********************************************************************

        pNVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeStart = TempAccessRange.RangeStart;
        pNVAccessRange[NV_PHYSICAL_BASE_ADDRESS].RangeLength = TempAccessRange.RangeLength;

        //**********************************************************************
        // QUERY_PUBLIC_ACCESS_RANGES will use the following values to properly map
        // in the public access ranges.  For our display driver, we're going
        // to declare 4 public access ranges:   1) NV User Channel
        //                                      2) Graphics Status Register
        //                                      3) Frame Buffer VBLANK register
        //                                      4) Frame Buffer START register
        // Only the miniport will have access to all of the other privileged
        // graphics registers.
        //**********************************************************************

        //**********************************************************************
        // Init NV memory range offset values to zero
        //**********************************************************************

        for (i=0 ; i<NV_NUM_RANGES ;i++)
          {
          RangeOffsets[i].ulOffset = 0;
          RangeOffsets[i].ulLength = 0;
          }

        //**********************************************************************
        // Initialize the actual offset values
        //**********************************************************************

        RangeOffsets[NV_PMC_INDEX].ulOffset = DEVICE_BASE(NV_PMC);
        RangeOffsets[NV_PMC_INDEX].ulLength = DEVICE_EXTENT(NV_PMC);

        RangeOffsets[NV_PFB_INDEX].ulOffset = DEVICE_BASE(NV_PFB);
        RangeOffsets[NV_PFB_INDEX].ulLength = DEVICE_EXTENT(NV_PFB);

        RangeOffsets[NV_PRM_INDEX].ulOffset = DEVICE_BASE(NV_PRM);
        RangeOffsets[NV_PRM_INDEX].ulLength = DEVICE_EXTENT(NV_PRM);

        RangeOffsets[NV_PDAC_INDEX].ulOffset = DEVICE_BASE(NV_PDAC);
        RangeOffsets[NV_PDAC_INDEX].ulLength = DEVICE_EXTENT(NV_PDAC);

        RangeOffsets[NV_PRAM_INDEX].ulOffset = DEVICE_BASE(NV_PRAM);
        RangeOffsets[NV_PRAM_INDEX].ulLength = DEVICE_EXTENT(NV_PRAM);

        RangeOffsets[NV_PRAMFC_INDEX].ulOffset = DEVICE_BASE(NV_PRAMFC);
        RangeOffsets[NV_PRAMFC_INDEX].ulLength = DEVICE_EXTENT(NV_PRAMFC);

        RangeOffsets[NV_PRAMHT_INDEX].ulOffset = DEVICE_BASE(NV_PRAMHT);
        RangeOffsets[NV_PRAMHT_INDEX].ulLength = DEVICE_EXTENT(NV_PRAMHT);

        RangeOffsets[NV_PFIFO_INDEX].ulOffset = DEVICE_BASE(NV_PFIFO);
        RangeOffsets[NV_PFIFO_INDEX].ulLength = DEVICE_EXTENT(NV_PFIFO);

        RangeOffsets[NV_PBUS_INDEX].ulOffset = DEVICE_BASE(NV_PBUS);
        RangeOffsets[NV_PBUS_INDEX].ulLength = DEVICE_EXTENT(NV_PBUS);

        RangeOffsets[NV_PGRAPH_INDEX].ulOffset = DEVICE_BASE(NV_PGRAPH);
        RangeOffsets[NV_PGRAPH_INDEX].ulLength = DEVICE_EXTENT(NV_PGRAPH);

        RangeOffsets[NV_URECT_INDEX].ulOffset = DEVICE_BASE(NV_URECT);
        RangeOffsets[NV_URECT_INDEX].ulLength = DEVICE_EXTENT(NV_URECT);

        RangeOffsets[NV_UTRI_INDEX].ulOffset = DEVICE_BASE(NV_UTRI);
        RangeOffsets[NV_UTRI_INDEX].ulLength = DEVICE_EXTENT(NV_UTRI);

        RangeOffsets[NV_UBLIT_INDEX].ulOffset = DEVICE_BASE(NV_UBLIT);
        RangeOffsets[NV_UBLIT_INDEX].ulLength = DEVICE_EXTENT(NV_UBLIT);

        RangeOffsets[NV_UIMAGE_INDEX].ulOffset = DEVICE_BASE(NV_UIMAGE);
        RangeOffsets[NV_UIMAGE_INDEX].ulLength = DEVICE_EXTENT(NV_UIMAGE);

        RangeOffsets[NV_UBITMAP_INDEX].ulOffset = DEVICE_BASE(NV_UBITMAP);
        RangeOffsets[NV_UBITMAP_INDEX].ulLength = DEVICE_EXTENT(NV_UBITMAP);

        RangeOffsets[NV_CONFIG_INDEX].ulOffset = DEVICE_BASE(NV_CONFIG);
        RangeOffsets[NV_CONFIG_INDEX].ulLength = DEVICE_EXTENT(NV_CONFIG);

        RangeOffsets[NV_PDMA_INDEX].ulOffset = DEVICE_BASE(NV_PDMA);
        RangeOffsets[NV_PDMA_INDEX].ulLength = DEVICE_EXTENT(NV_PDMA);

        RangeOffsets[NV_PTIMER_INDEX].ulOffset = DEVICE_BASE(NV_PTIMER);
        RangeOffsets[NV_PTIMER_INDEX].ulLength = DEVICE_EXTENT(NV_PTIMER);

        RangeOffsets[NV_PAUDIO_INDEX].ulOffset = DEVICE_BASE(NV_PAUDIO);
        RangeOffsets[NV_PAUDIO_INDEX].ulLength = DEVICE_EXTENT(NV_PAUDIO);

        RangeOffsets[NV_PAUTH_INDEX].ulOffset = DEVICE_BASE(NV_PAUTH);
        RangeOffsets[NV_PAUTH_INDEX].ulLength = DEVICE_EXTENT(NV_PAUTH);

        RangeOffsets[NV_PEXTDEV_INDEX].ulOffset = DEVICE_BASE(NV_PEXTDEV);
        RangeOffsets[NV_PEXTDEV_INDEX].ulLength = DEVICE_EXTENT(NV_PEXTDEV);

        RangeOffsets[NV_PEEPROM_INDEX].ulOffset = DEVICE_BASE(NV_PEEPROM);
        RangeOffsets[NV_PEEPROM_INDEX].ulLength = DEVICE_EXTENT(NV_PEEPROM);

        RangeOffsets[NV_PROM_INDEX].ulOffset = DEVICE_BASE(NV_PROM);
        RangeOffsets[NV_PROM_INDEX].ulLength = DEVICE_EXTENT(NV_PROM);

        RangeOffsets[NV_PALT_INDEX].ulOffset = DEVICE_BASE(NV_PALT);
        RangeOffsets[NV_PALT_INDEX].ulLength = DEVICE_EXTENT(NV_PALT);

        //**********************************************************************
        // The following 5 ranges (in addition to the frame buffer range)
        // are the only ones that we'll pass to the display driver.
        // The previous ranges will only be used within this miniport driver.
        //
        // First, init the USER channel
        // NOTE: We will ONLY be using 1 Channel (for the display driver only)
        //       So we only need to allocate 64k for 1 channel.
        // Second, init the Graphics Status register
        // Third, init access to Vertical Blanking register (PFB_CONFIG_0)
        // Fourth, init access to Frame Buffer Start Address register (PFB_START_ADDRESS)
        // Fifth, init access to SGS DAC register (SGS_DAC)
        // Finally, init access to the dumb frame buffer
        //**********************************************************************

        RangeOffsets[NV_USER_INDEX].ulOffset = DEVICE_BASE(NV_USER);
//      RangeOffsets[NV_USER_INDEX].ulLength = DEVICE_EXTENT(NV_USER);
        RangeOffsets[NV_USER_INDEX].ulLength = 0x10000;

        //**********************************************************************
        // Just allocate memory for the GRAPHICS STATUS register
        //**********************************************************************

        RangeOffsets[NV_PGRAPH_STATUS_INDEX].ulOffset = NV_PGRAPH_STATUS;
        RangeOffsets[NV_PGRAPH_STATUS_INDEX].ulLength = 16;

        //**********************************************************************
        // Just allocate memory for the PFB_CONFIG_0 register
        // so we can check if we're in vertical blanking or not
        //**********************************************************************

        RangeOffsets[NV_PFB_CONFIG_0_INDEX].ulOffset = NV_PFB_CONFIG_0;
        RangeOffsets[NV_PFB_CONFIG_0_INDEX].ulLength = 16;


        //**********************************************************************
        // Just allocate memory for the PFB_START_ADDRESS register
        // so we can flip the current buffer
        //**********************************************************************

        RangeOffsets[NV_PFB_START_ADDRESS_INDEX].ulOffset = NV_PFB_START;
        RangeOffsets[NV_PFB_START_ADDRESS_INDEX].ulLength = 16;

        //**********************************************************************
        // Allocate memory for the SGS DAC memory range
        // so we can set the cursor registers.  Just allocate 64 bytes.
        // That will cover the entire needed range.
        //**********************************************************************

        RangeOffsets[NV_SGS_DAC_INDEX].ulOffset = DEVICE_BASE(NV_PDAC);
        RangeOffsets[NV_SGS_DAC_INDEX].ulLength = 64;


        //**********************************************************************
        // DUMB FRAME BUFFER location
        // The actual amount of memory is determined later in NV_GetNVInfo,
        // but for now, just default to 4Mb.  This value will be fixed up
        // in NV_GetNVInfo so that IOCTL_VIDEO_MAP_MEMORY will subsequently
        // map in the correct number of bytes.
        //**********************************************************************

        RangeOffsets[NV_PDFB_INDEX].ulOffset = DEVICE_BASE(NV_PDFB);
        RangeOffsets[NV_PDFB_INDEX].ulLength =  0x400000;



        //**********************************************************************
        //  Make sure the base Physical Address of NV device access range is
        //  stored in the PCI configuration space. Here, we get the the base
        //  address currently stored in PCI configuration space.
        //      PCIConfiguration is an ENUMERATED type
        //      Address will hold the PCI Common Config information
        //**********************************************************************

        VideoPortGetBusData(HwDeviceExtension,
                            PCIConfiguration,
                            ulSlot,
                            (PVOID) &Address,
                            FIELD_OFFSET(PCI_COMMON_CONFIG, u.type0.BaseAddresses),
                            sizeof(ULONG));

        //**********************************************************************
        //  Make sure the base Physical Address access range returned by
        //  GetAccessRanges is the same as the one returned by GetBusData.
        //  If not, then use SetBusData to make them agree.
        //**********************************************************************

        if (Address != TempAccessRange.RangeStart.LowPart)
            {
            VideoDebugPrint((0, "I really wish they we're equal, but\n"
                                "they're not, so make them equal!\n"));

            VideoPortSetBusData(HwDeviceExtension,
                                PCIConfiguration,
                                ulSlot,
                                (PVOID) &TempAccessRange.RangeStart.LowPart,
                                FIELD_OFFSET(PCI_COMMON_CONFIG, u.type0.BaseAddresses),
                                sizeof(ULONG));
            }


        return(TRUE);
        }


    //**************************************************************************
    // Also, check if an ST equivalent of the chip is present
    //**************************************************************************

    else if (VideoPortGetAccessRanges(HwDeviceExtension,
                                 0,
                                 NULL,
                                 1,
                                 &TempAccessRange,
                                 &stVendorId,
                                 &usDeviceId,
                                 &ulSlot) == NO_ERROR)
        {
        goto Treat_SGS_Same_As_NV;
        }

    //**************************************************************************
    // Didn't recognize NV1 or ST
    //**************************************************************************

    else

        return(FALSE);

    }


//******************************************************************************
//
// Function: NV1Interrupt()
//
// Routine Description:
//
//      Debug Interrupt routine to catch any inadvertent Interrupts that
//      the NV engine may generate (since we don't implement a resource manager)
//
// Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
// Return Value:
//
//******************************************************************************


BOOLEAN NV1Interrupt(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    ULONG OutData;
    ULONG SavedEnable;
    ULONG SavedWho;
    ULONG SavedPgraph;
    ULONG SavedAddress;
    ULONG SavedData;
    ULONG SavedCtxSwitch;
    ULONG SavedCtxControl;

    //**************************************************************************
    // Get the current state of some important registers
    // to help us figure out why an interrupt was generated.
    //**************************************************************************

    SavedEnable = PMC_REG_RD32(PMC_Base, NV_PMC_INTR_EN_0);
    SavedWho    = PMC_REG_RD32(PMC_Base, NV_PMC_INTR_0);
    SavedWho    = SavedWho & (~0x10000000);
    SavedPgraph = PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_INTR_0);
    SavedAddress = PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_TRAPPED_ADDR);
    SavedData = PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_TRAPPED_DATA);
    SavedCtxSwitch = PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_CTX_SWITCH);
    SavedCtxControl = PGRAPH_REG_RD32(PGRAPH_Base,NV_PGRAPH_CTX_CONTROL);

    //**************************************************************************
    // Check the interrupt that occurred
    //**************************************************************************

    if (SavedWho & 0x01000000)

        {
        OutData = DRF_DEF(_PGRAPH,_INTR_0,_VBLANK,_RESET);
        PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_INTR_0, OutData);
        return(TRUE);                   // This is probably 0x01000000 (VBLANK)
        }

    else if (SavedWho & ~0x11000000)    // Check all except vblank

        {
        //**********************************************************************
        // ARGHHHHH......ACCCKKKKK!!!!
        // We shouldn't be causing any interrupts....!!!!!
        // We don't have a Resource Manager yet.....
        //**********************************************************************

        OutData = DRF_DEF(_PFIFO,_INTR_0,_RUNOUT,_RESET) ;
        return(TRUE);       // This is PFIFO pending
        }


    return(FALSE);          // Someone else's interrupt, let them handle it

    }





//******************************************************************************
//
//  Function:   NV1ObjectSwappingTest()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV1ObjectSwappingTest(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
//      PRENDEROBJECT PObject;
//      ULONG Data;
//      ULONG PatchCount;
//      PHWINFO NVInfo;
//      ULONG ColorFormat;
//      ULONG MonoFormat;
//      ULONG FreeCount;
//      NvChannel *nv;
//
//      //**************************************************************************
//      // NOTE: This function currently just tests the SWAPPING of objects only.
//      //       If we need to load in a brand NEW object, then we'll
//      //       need to completely initialize that object, as in NVSetupPatches.
//      //       Since we're just swapping out the triangle and rectangle object
//      //       here, I've skipped the calls to ClearPatchContext() and
//      //       SetPatchContext().  Remember, the context of a RENDER object
//      //       depends on the 'static' objects that make up its patch.
//      //       That is, SetPatchContext() generates the context of an object
//      //       depending on the IMAGE_SOLID,BLACK_RECTANGLE, ROP_SOLID, and
//      //       PATTERN objects that make up the patch associated with the
//      //       RENDER object.
//      //**************************************************************************
//
//      //**************************************************************************
//      // Wait for the Graphics Engine to be idle AS WELL AS the FIFO !!
//      // We MUST make sure that the NV engines (the Graphics Engine and FIFO) are both
//      // idle before we swap out OBJECTS. Otherwise, swapping out objects
//      // while something is still being drawn will probably generate interrupts.
//      //**************************************************************************
//
//      nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);
//
//      FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.free;
//      while (FreeCount < NV_GUARANTEED_FIFO_SIZE)
//          FreeCount = nv->subchannel[RECTANGLE_SUBCHANNEL].control.free;
//
//      GR_DONE;
//
//
//      //**************************************************************************
//      //
//      // Enable FLOWTHRU
//      //
//      //      In order to access many of the registers in the Graphics Engine,
//      //      we need to enable FLOWTHRU and disable the FIFO engine.
//      //      FLOWTHRU = ENABLED,  FIFO = DISABLED, DMA = DISABLED
//      //      CLASS = 0 to specify graphics registers.
//      //
//      //**************************************************************************
//
//      PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
//                              DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
//                              DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
//                              DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
//                              DRF_DEF(_PGRAPH,_MISC,_FIFO,_DISABLED)          |
//                              DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
//                              DRF_DEF(_PGRAPH,_MISC,_DMA,_DISABLED)           |
//                              DRF_DEF(_PGRAPH,_MISC,_CLASS_WRITE,_ENABLED)    |
//                              DRF_NUM(_PGRAPH,_MISC,_CLASS,0));
//
//      //**************************************************************************
//      // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
//      //**************************************************************************
//
//      GR_DONE;
//
//      //**************************************************************************
//      // Checks for any interrupt requests.  For this miniport,
//      // we shouldn't be getting any
//      //**************************************************************************
//
//      GR_IDLE;
//
//
//      //**************************************************************************
//      // Set the color format according to what the current mode depth is
//      //**************************************************************************
//
//      NVInfo = &(HwDeviceExtension->NvInfo);
//
//      switch (NVInfo->Framebuffer.Depth)
//          {
//          case 32:
//              ColorFormat = NV_COLOR_FORMAT_LE_X8R8G8B8;
//              break;
//          case 16:
//              ColorFormat = NV_COLOR_FORMAT_LE_X17R5G5B5;
//              break;
//          case 8:
//              ColorFormat = NV_COLOR_FORMAT_LE_X24Y8;
//              break;
//          default:
//              ColorFormat = NV_COLOR_FORMAT_LE_X8R8G8B8;
//              break;
//          }
//
//      //**************************************************************************
//      // Default mono format is 0 and ALPHA NOT enabled
//      //**************************************************************************
//
//      MonoFormat = MONO_FORMAT_LE;
//
//      //**************************************************************************
//      // Now setup the individual patches that we'll be using for
//      // the NT Display driver
//      //**************************************************************************
//
//  RECTANGLE_SWAP:
//
//      //**************************************************************************
//      // Replace RECTANGLE with TRIANGLE
//      //**************************************************************************
//
//      MonoFormat = MONO_FORMAT_LE;
//      SetupRenderObject(HwDeviceExtension,RECTANGLE_SUBCHANNEL,TRIANGLE_PATCH ,
//                        NV_RENDER_SOLID_TRIANGLE, MY_RENDER_SOLID_TRIANGLE,
//                        ColorFormat,MonoFormat);
//
//      //**************************************************************************
//      // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
//      // And check for any interrupt requests.  For this miniport, shouldn't getting any !!
//      //**************************************************************************
//
//      GR_DONE;
//      GR_IDLE;
//
//
//  //TRIANGLE_SWAP:
//  //
//  //    //**************************************************************************
//  //    // Replace the TRIANGLE object with RECTANGLE
//  //    //**************************************************************************
//  //
//  //    MonoFormat = MONO_FORMAT_LE;
//  //    SetupRenderObject(HwDeviceExtension,TRIANGLE_SUBCHANNEL,RECTANGLE_PATCH ,
//  //                      NV_RENDER_SOLID_RECTANGLE, MY_RENDER_SOLID_RECTANGLE,
//  //                      ColorFormat,MonoFormat);
//  //
//  //    //**************************************************************************
//  //    // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
//  //    // And check for any interrupt requests.  For this miniport, shouldn't getting any !!
//  //    //**************************************************************************
//  //
//  //    GR_DONE;
//  //    GR_IDLE;
//  //
//  //
//      //**************************************************************************
//      // We're done with the Graphics registers for now.
//      // Make sure the FIFO and DMA engines are enabled.
//      //
//      //      FLOWTHRU = ENABLED,  FIFO = ENABLED, DMA = ENABLED
//      //
//      // DON'T TOUCH THE CLASS bits!!
//      //**************************************************************************
//
//      PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
//                              DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
//                              DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
//                              DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
//                              DRF_DEF(_PGRAPH,_MISC,_FIFO,_ENABLED)           |
//                              DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
//                              DRF_DEF(_PGRAPH,_MISC,_DMA,_ENABLED));
//
    }



//******************************************************************************
//
//  Function:   NV1ObjectSwappingTryIt()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV1ObjectSwappingTryIt(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
//
//      ULONG i;
//      ULONG x,y,Color;
//      NvChannel *nv;
//
//      //**************************************************************************
//      // Get pointer to NV channel area
//      //**************************************************************************
//
//      nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);
//
//      //**************************************************************************
//      // Rectangle subchannel is NOW the Triangle subchannel.
//      // See if we successfully swapped it.  Note the RECTANGLE_SUBCHANNEL
//      // is being used, but we're actually writing out TRIANGLE methods.
//      //**************************************************************************
//
//      Color = 0x000000ff;
//      x = 125;
//      y = 125;
//
//      while (nv->subchannel[RECTANGLE_SUBCHANNEL].control.free < 4*4);
//      nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidTriangle.Color = 0xff000000 | Color;
//      nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidTriangle.Triangle.y0_x0 = (((y+10) << 16) | (x-10) );
//      nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidTriangle.Triangle.y1_x1 = (((y+10) << 16) | (x+10) );
//      nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidTriangle.Triangle.y2_x2 = (((y-10) << 16) | x);
//
//      Color = 0x0000ff00;
//      x = 225;
//      y = 225;
//
//      while (nv->subchannel[RECTANGLE_SUBCHANNEL].control.free < 4*4);
//      nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidTriangle.Color = 0xff000000 | Color;
//      nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidTriangle.Triangle.y0_x0 = (((y+10) << 16) | (x-10) );
//      nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidTriangle.Triangle.y1_x1 = (((y+10) << 16) | (x+10) );
//      nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidTriangle.Triangle.y2_x2 = (((y-10) << 16) | x);
//
//
//  //    //**************************************************************************
//  //    // Triangle subchannel is NOW the Rectangle subchannel.
//  //    // Note the TRIANGLE_SUBCHANNEL is being used, but we're actually
//  //    // writing out RECTANGLE methods.
//  //    //**************************************************************************
//  //
//  //    Color = 0x00ff0000;
//  //    x = 325;
//  //    y = 325;
//  //
//  //
//  //    while (nv->subchannel[TRIANGLE_SUBCHANNEL].control.free < 3*4);
//  //    nv->subchannel[TRIANGLE_SUBCHANNEL].renderSolidRectangle.Color = 0xff000000 | Color;
//  //    nv->subchannel[TRIANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].y_x = ((y << 16) | x );
//  //    nv->subchannel[TRIANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].height_width = 0x00500040;
//  //
//  //
//  //
//  //    Color = 0x00ff00ff;
//  //    x = 425;
//  //    y = 425;
//  //
//  //    while (nv->subchannel[TRIANGLE_SUBCHANNEL].control.free < 3*4);
//  //    nv->subchannel[TRIANGLE_SUBCHANNEL].renderSolidRectangle.Color = 0xff000000 | Color;
//  //    nv->subchannel[TRIANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].y_x = ((y << 16) | x );
//  //    nv->subchannel[TRIANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].height_width = 0x00600040;
//  //
//
    }


//******************************************************************************
//
//  Function:   NV1ObjectSwappingRestore()
//
//  Routine Description:
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NV1ObjectSwappingRestore(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
//      PRENDEROBJECT PObject;
//      ULONG Data;
//      ULONG PatchCount;
//      PHWINFO NVInfo;
//      ULONG ColorFormat;
//      ULONG MonoFormat;
//
//      ULONG FreeCount;
//      NvChannel *nv;
//
//
//      //**************************************************************************
//      // NOTE: This function currently just tests the SWAPPING of objects only.
//      //       If we need to load in a brand NEW object, then we'll
//      //       need to completely initialize that object, as in NVSetupPatches.
//      //       Since we're just swapping out the triangle and rectangle object
//      //       here, I've skipped the calls to ClearPatchContext() and
//      //       SetPatchContext().  Remember, the context of a RENDER object
//      //       depends on the 'static' objects that make up its patch.
//      //       That is, SetPatchContext() generates the context of an object
//      //       depending on the IMAGE_SOLID,BLACK_RECTANGLE, ROP_SOLID, and
//      //       PATTERN objects that make up the patch associated with the
//      //       RENDER object.
//      //**************************************************************************
//
//      //**************************************************************************
//      // Wait for the Graphics Engine to be idle AS WELL AS the FIFO !!
//      // We MUST make sure that the NV engines (the Graphics Engine and FIFO) are both
//      // idle before we swap out OBJECTS. Otherwise, swapping out objects
//      // while something is still being drawn will probably generate interrupts.
//      //**************************************************************************
//
//      nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);
//
//      FreeCount = nv->subchannel[TRIANGLE_SUBCHANNEL].control.free;
//      while (FreeCount < NV_GUARANTEED_FIFO_SIZE)
//          FreeCount = nv->subchannel[TRIANGLE_SUBCHANNEL].control.free;
//
//      GR_DONE;
//
//
//      //**************************************************************************
//      //
//      // Enable FLOWTHRU
//      //
//      //      In order to access many of the registers in the Graphics Engine,
//      //      we need to enable FLOWTHRU and disable the FIFO engine.
//      //      FLOWTHRU = ENABLED,  FIFO = DISABLED, DMA = DISABLED
//      //      CLASS = 0 to specify graphics registers.
//      //
//      //**************************************************************************
//
//      PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
//                              DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
//                              DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
//                              DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
//                              DRF_DEF(_PGRAPH,_MISC,_FIFO,_DISABLED)          |
//                              DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
//                              DRF_DEF(_PGRAPH,_MISC,_DMA,_DISABLED)           |
//                              DRF_DEF(_PGRAPH,_MISC,_CLASS_WRITE,_ENABLED)    |
//                              DRF_NUM(_PGRAPH,_MISC,_CLASS,0));
//
//      //**************************************************************************
//      // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
//      //**************************************************************************
//
//      GR_DONE;
//
//      //**************************************************************************
//      // Checks for any interrupt requests.  For this miniport,
//      // we shouldn't be getting any
//      //**************************************************************************
//
//      GR_IDLE;
//
//      //**************************************************************************
//      // Set the color format according to what the current mode depth is
//      //**************************************************************************
//
//      NVInfo = &(HwDeviceExtension->NvInfo);
//
//      switch (NVInfo->Framebuffer.Depth)
//          {
//          case 32:
//              ColorFormat = NV_COLOR_FORMAT_LE_X8R8G8B8;
//              break;
//          case 16:
//              ColorFormat = NV_COLOR_FORMAT_LE_X17R5G5B5;
//              break;
//          case 8:
//              ColorFormat = NV_COLOR_FORMAT_LE_X24Y8;
//              break;
//          default:
//              ColorFormat = NV_COLOR_FORMAT_LE_X8R8G8B8;
//              break;
//          }
//
//      //**************************************************************************
//      // Default mono format is 0 and ALPHA NOT enabled
//      //**************************************************************************
//
//      MonoFormat = MONO_FORMAT_LE;
//
//      //**************************************************************************
//      // Now setup the individual patches that we'll be using for
//      // the NT Display driver
//      //**************************************************************************
//
//  RECTANGLE_RESTORE:
//
//      //**************************************************************************
//      // Restore RECTANGLE object in TRIANGLE subchannel
//      //**************************************************************************
//
//      MonoFormat = MONO_FORMAT_LE;
//      SetupRenderObject(HwDeviceExtension,RECTANGLE_SUBCHANNEL,RECTANGLE_PATCH ,
//                        NV_RENDER_SOLID_RECTANGLE, MY_RENDER_SOLID_RECTANGLE,
//                        ColorFormat,MonoFormat);
//
//      //**************************************************************************
//      // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
//      // And check for any interrupt requests.  For this miniport, shouldn't getting any !!
//      //**************************************************************************
//
//      GR_DONE;
//      GR_IDLE;
//
//
//  //TRIANGLE_RESTORE:
//  //
//  //    //**************************************************************************
//  //    // Restore the TRIANGLE object
//  //    //**************************************************************************
//  //
//  //    MonoFormat = MONO_FORMAT_LE;
//  //    SetupRenderObject(HwDeviceExtension,TRIANGLE_SUBCHANNEL,TRIANGLE_PATCH ,
//  //                      NV_RENDER_SOLID_TRIANGLE, MY_RENDER_SOLID_TRIANGLE,
//  //                      ColorFormat,MonoFormat);
//  //
//  //    //**************************************************************************
//  //    // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
//  //    // And check for any interrupt requests.  For this miniport, shouldn't getting any !!
//  //    //**************************************************************************
//  //
//  //    GR_DONE;
//  //    GR_IDLE;
//  //
//  //
//      //**************************************************************************
//      // We're done with the Graphics registers for now.
//      // Make sure the FIFO and DMA engines are enabled.
//      //
//      //      FLOWTHRU = ENABLED,  FIFO = ENABLED, DMA = ENABLED
//      //
//      // DON'T TOUCH THE CLASS bits!!
//      //**************************************************************************
//
//      PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
//                              DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
//                              DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
//                              DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
//                              DRF_DEF(_PGRAPH,_MISC,_FIFO,_ENABLED)           |
//                              DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
//                              DRF_DEF(_PGRAPH,_MISC,_DMA,_ENABLED));
//
    }


//******************************************************************************
//
// Function:    NV1WaitUntilFinished()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV1WaitUntilFinished(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    PHWINFO NVInfo;
    ULONG Width;
    ULONG Height;
    NvChannel *nv;

    //**************************************************************************
    // Get pointer to NV channel area
    //**************************************************************************

    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);

    //**************************************************************************
    // Wait until there's nothing left in the FIFO to be done
    //**************************************************************************

    while (nv->subchannel[RECTANGLE_SUBCHANNEL].control.free < NV_GUARANTEED_FIFO_SIZE);

    //**************************************************************************
    // Make ABSOLUTELY sure the graphics engine is not busy anymore
    // by checking the Graphics status register.
    // This is a MUST.  If we don't do this, mode switches may hang
    // on fast systems (p6-200's or better).
    //**************************************************************************

    GR_DONE;

    }

//******************************************************************************
//
// Function:    NV1SetOpenGLPatch()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV1SetOpenGLPatch(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    PRENDEROBJECT PObject;
    ULONG Data;
    ULONG PatchCount;
    PHWINFO NVInfo;
    ULONG ColorFormat;
    ULONG MonoFormat;
    ULONG FreeCount;
    NvChannel *nv;

    //**************************************************************************
    // NOTE: This function currently just tests the SWAPPING of objects only.
    //       If we need to load in a brand NEW object, then we'll
    //       need to completely initialize that object, as in NVSetupPatches.
    //       Since we're just swapping out the triangle and rectangle object
    //       here, I've skipped the calls to ClearPatchContext() and
    //       SetPatchContext().  Remember, the context of a RENDER object
    //       depends on the 'static' objects that make up its patch.
    //       That is, SetPatchContext() generates the context of an object
    //       depending on the IMAGE_SOLID,BLACK_RECTANGLE, ROP_SOLID, and
    //       PATTERN objects that make up the patch associated with the
    //       RENDER object.
    //**************************************************************************

    //**************************************************************************
    // Wait for the Graphics Engine to be idle AS WELL AS the FIFO !!
    // We MUST make sure that the NV engines (the Graphics Engine and FIFO) are both
    // idle before we swap out OBJECTS. Otherwise, swapping out objects
    // while something is still being drawn will probably generate interrupts.
    //**************************************************************************

    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);

    FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.free;
    while (FreeCount < NV_GUARANTEED_FIFO_SIZE)
        FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.free;

    GR_DONE;


    //**************************************************************************
    //
    // Enable FLOWTHRU
    //
    //      In order to access many of the registers in the Graphics Engine,
    //      we need to enable FLOWTHRU and disable the FIFO engine.
    //      FLOWTHRU = ENABLED,  FIFO = DISABLED, DMA = DISABLED
    //      CLASS = 0 to specify graphics registers.
    //
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO,_DISABLED)          |
                            DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
                            DRF_DEF(_PGRAPH,_MISC,_DMA,_DISABLED)           |
                            DRF_DEF(_PGRAPH,_MISC,_CLASS_WRITE,_ENABLED)    |
                            DRF_NUM(_PGRAPH,_MISC,_CLASS,0));

    //**************************************************************************
    // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
    //**************************************************************************

    GR_DONE;

    //**************************************************************************
    // Checks for any interrupt requests.  For this miniport,
    // we shouldn't be getting any
    //**************************************************************************

    GR_IDLE;


    //**************************************************************************
    // Set the color format according to what the current mode depth is
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    switch (NVInfo->Framebuffer.Depth)
        {
        case 32:
            ColorFormat = NV_COLOR_FORMAT_LE_X8R8G8B8;
            break;
        case 16:
            ColorFormat = NV_COLOR_FORMAT_LE_X17R5G5B5;
            break;
        case 8:
            ColorFormat = NV_COLOR_FORMAT_LE_X24Y8;
            break;
        default:
            ColorFormat = NV_COLOR_FORMAT_LE_X8R8G8B8;
            break;
        }

    //**************************************************************************
    // Default mono format is 0 and ALPHA NOT enabled
    //**************************************************************************


SWAP_IMAGE_FROM_CPU_WITH_TRIANGLE:

    //**************************************************************************
    // Replace IMAGE_FROM_CPU with TRIANGLE
    //**************************************************************************

    MonoFormat = MONO_FORMAT_LE;
    SetupRenderObject(HwDeviceExtension,TRIANGLE_SUBCHANNEL,TRIANGLE_PATCH ,
                      NV_RENDER_SOLID_TRIANGLE, MY_RENDER_SOLID_TRIANGLE,
                      ColorFormat,MonoFormat);

    //**************************************************************************
    // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
    // And check for any interrupt requests.  For this miniport, shouldn't getting any !!
    //**************************************************************************

    GR_DONE;
    GR_IDLE;

    //**************************************************************************
    // We're done with the Graphics registers for now.
    // Make sure the FIFO and DMA engines are enabled.
    //
    //      FLOWTHRU = ENABLED,  FIFO = ENABLED, DMA = ENABLED
    //
    // DON'T TOUCH THE CLASS bits!!
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO,_ENABLED)           |
                            DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
                            DRF_DEF(_PGRAPH,_MISC,_DMA,_ENABLED));


    }


//******************************************************************************
//
// Function:    NV1RestoreDisplayDriverPatch()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV1RestoreDisplayDriverPatch(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    PRENDEROBJECT PObject;
    ULONG Data;
    ULONG PatchCount;
    PHWINFO NVInfo;
    ULONG ColorFormat;
    ULONG MonoFormat;
    ULONG FreeCount;
    NvChannel *nv;

    //**************************************************************************
    // NOTE: This function currently just tests the SWAPPING of objects only.
    //       If we need to load in a brand NEW object, then we'll
    //       need to completely initialize that object, as in NVSetupPatches.
    //       Since we're just swapping out the triangle and rectangle object
    //       here, I've skipped the calls to ClearPatchContext() and
    //       SetPatchContext().  Remember, the context of a RENDER object
    //       depends on the 'static' objects that make up its patch.
    //       That is, SetPatchContext() generates the context of an object
    //       depending on the IMAGE_SOLID,BLACK_RECTANGLE, ROP_SOLID, and
    //       PATTERN objects that make up the patch associated with the
    //       RENDER object.
    //**************************************************************************

    //**************************************************************************
    // Wait for the Graphics Engine to be idle AS WELL AS the FIFO !!
    // We MUST make sure that the NV engines (the Graphics Engine and FIFO) are both
    // idle before we swap out OBJECTS. Otherwise, swapping out objects
    // while something is still being drawn will probably generate interrupts.
    //**************************************************************************

    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);

    FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.free;
    while (FreeCount < NV_GUARANTEED_FIFO_SIZE)
        FreeCount = nv->subchannel[IMAGE_FROM_CPU_SUBCHANNEL].control.free;

    GR_DONE;


    //**************************************************************************
    //
    // Enable FLOWTHRU
    //
    //      In order to access many of the registers in the Graphics Engine,
    //      we need to enable FLOWTHRU and disable the FIFO engine.
    //      FLOWTHRU = ENABLED,  FIFO = DISABLED, DMA = DISABLED
    //      CLASS = 0 to specify graphics registers.
    //
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO,_DISABLED)          |
                            DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
                            DRF_DEF(_PGRAPH,_MISC,_DMA,_DISABLED)           |
                            DRF_DEF(_PGRAPH,_MISC,_CLASS_WRITE,_ENABLED)    |
                            DRF_NUM(_PGRAPH,_MISC,_CLASS,0));

    //**************************************************************************
    // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
    //**************************************************************************

    GR_DONE;

    //**************************************************************************
    // Checks for any interrupt requests.  For this miniport,
    // we shouldn't be getting any
    //**************************************************************************

    GR_IDLE;

    //**************************************************************************
    // Now restore the individual patches that we'll be using for
    // the NT Display driver
    //**************************************************************************

SWAP_TRIANGLE_WITH_IMAGE_FROM_CPU:

    //**************************************************************************
    // For text, we want color 0 (background) to be transparent
    // So set the color format appropriately with ALPHA channel enabled
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    switch (NVInfo->Framebuffer.Depth)
        {
        case 32:
            ColorFormat = NV_COLOR_FORMAT_LE_X8R8G8B8;
            break;
        case 16:
            ColorFormat = NV_COLOR_FORMAT_LE_X17R5G5B5;
            break;
        case 8:
            ColorFormat = NV_COLOR_FORMAT_LE_X24Y8;
            break;
        default:
            ColorFormat = NV_COLOR_FORMAT_LE_X8R8G8B8;
            break;
        }

    //**************************************************************************
    // Setup the IMAGE_FROM_CPU object
    //**************************************************************************

    MonoFormat = MONO_FORMAT_LE;
    SetupRenderObject(HwDeviceExtension,IMAGE_FROM_CPU_SUBCHANNEL,IMAGE_FROM_CPU_PATCH,
                      NV_IMAGE_FROM_CPU, MY_IMAGE_FROM_CPU_BLIT,
                      ColorFormat, MonoFormat);

    //**************************************************************************
    // Wait for Engine to to be idle  (Reads PGRAPH_STATUS register)
    // And check for any interrupt requests.  For this miniport, shouldn't getting any !!
    //**************************************************************************

    GR_DONE;
    GR_IDLE;

    //**************************************************************************
    // We're done with the Graphics registers for now.
    // Make sure the FIFO and DMA engines are enabled.
    //
    //      FLOWTHRU = ENABLED,  FIFO = ENABLED, DMA = ENABLED
    //
    // DON'T TOUCH THE CLASS bits!!
    //**************************************************************************

    PGRAPH_REG_WR32(PGRAPH_Base, NV_PGRAPH_MISC,
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU_WRITE,_ENABLED) |
                            DRF_DEF(_PGRAPH,_MISC,_FLOWTHRU,_ENABLED)       |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO_WRITE,_ENABLED)     |
                            DRF_DEF(_PGRAPH,_MISC,_FIFO,_ENABLED)           |
                            DRF_DEF(_PGRAPH,_MISC,_DMA_WRITE,_ENABLED)      |
                            DRF_DEF(_PGRAPH,_MISC,_DMA,_ENABLED));


    }



//******************************************************************************
//
// Function:    NV1ClearScreen()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV1ClearScreen(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    PHWINFO NVInfo;
    ULONG Width;
    ULONG Height;
    NvChannel *nv;

    //**************************************************************************
    // Get pointer to NVInfo structure
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    //**************************************************************************
    // Get pointer to NV channel area
    //**************************************************************************

    nv = (NvChannel *)(HwDeviceExtension->NV1_Lin_USER_Registers);

    //**************************************************************************
    // Get width and height of current mode
    //**************************************************************************

    Width = NVInfo->Framebuffer.HorizDisplayWidth;
    Height = NVInfo->Framebuffer.VertDisplayWidth;

    //**************************************************************************
    // First set ROP, CLIP, and PATTERN objects.  Disable color keying
    //**************************************************************************

    SetRop(HwDeviceExtension,SRCCOPY);
    SetClip(HwDeviceExtension, 0, 0, 0x7fff, 0x7fff);
    SetPattern(HwDeviceExtension);
    SetColorKey(HwDeviceExtension, 0x00000000);

    //**************************************************************************
    // Fill Screen with black rectangle (color 0 will always be black
    // regardless of mode at this point)
    //**************************************************************************

    //**************************************************************************
    // Wait for FIFO to be available first
    //**************************************************************************

    while (nv->subchannel[RECTANGLE_SUBCHANNEL].control.free < 3*4);

    nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Color = 0x00000000;
    nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].y_x = ((0 << 16) | 0 );
    nv->subchannel[RECTANGLE_SUBCHANNEL].renderSolidRectangle.Rectangle[0].height_width = ((Height << 16) | (Width));


    }


//******************************************************************************
//
// Function:    NV1GraphicsTest()
//
// Routine Description:
//
// Arguments:
//
// Return Value:
//
//******************************************************************************

VOID NV1GraphicsTest(PHW_DEVICE_EXTENSION HwDeviceExtension)

    {
    PHWINFO NVInfo;
    LONG x_inc,y_inc;
    ULONG x,y;
    ULONG i;

    //**************************************************************************
    // Get pointer to NVInfo structure
    //**************************************************************************

    NVInfo = &(HwDeviceExtension->NvInfo);

    //**************************************************************************
    // Give it a try! First set ROP, CLIP, and PATTERN objects
    //**************************************************************************

    SetRop(HwDeviceExtension,SRCCOPY);
    SetClip(HwDeviceExtension, 0, 0, 0x40, 0x40);
    SetPattern(HwDeviceExtension);

    //**************************************************************************
    // Disable Color keying for now, because it's not currently used by
    // the display driver, and we can use it's subchannel with another object
    //
    // Update: Initialize the ColorKey! We need to use the COLOR KEY object for
    //         Direct Draw.  (Currently, the only place that uses it is Direct Draw)
    //         Specify color = 0 to make it inactive.  Specify (ALPHA_1_32/
    //         ALPHA_1_16/ALPHA_1_08 | Color) to activate the color key.
    //**************************************************************************

    SetColorKey(HwDeviceExtension, 0x00000000);

    //**************************************************************************
    // Draw some rectangles at top left.
    //**************************************************************************

    switch (NVInfo->Framebuffer.Depth)
        {
        case 32:
            //******************************************************************
            // Color Format in 32bpp mode is X8R8G8B8 (See SetupPatches)
            //******************************************************************

            RenderRectangle(HwDeviceExtension,0,0,  0x0000ffff);    // G and B
            RenderRectangle(HwDeviceExtension,10,10,0x00ff00ff);    // R and B
            RenderRectangle(HwDeviceExtension,20,20,0x00ffff00);    // R and G

            //******************************************************************
            // Verify ColorKey is working with color 0
            //******************************************************************

            SetColorKey(HwDeviceExtension, NV_ALPHA_1_32 | 0);      // Enable Color Key
            RenderRectangle(HwDeviceExtension,0,0,  0x0000000);     // Not drawn
            SetColorKey(HwDeviceExtension, 0);                      // Disable Color Key
            RenderRectangle(HwDeviceExtension,0,0,  0x0000000);     // Drawn

            break;

        case 16:
            //******************************************************************
            // Color Format in 16bpp mode is X17R5G5B5 (See SetupPatches)
            //******************************************************************

            RenderRectangle(HwDeviceExtension,0,0,  0x000003ff);    // G and B
            RenderRectangle(HwDeviceExtension,10,10,0x00007c1f);    // R and B
            RenderRectangle(HwDeviceExtension,20,20,0x00007fe0);    // R and G

            //******************************************************************
            // Verify ColorKey is working with color 0
            //******************************************************************

            SetColorKey(HwDeviceExtension, NV_ALPHA_1_16 | 0);      // Enable Color Key
            RenderRectangle(HwDeviceExtension,0,0,  0x0000000);     // Not drawn
            SetColorKey(HwDeviceExtension, 0);                      // Disable Color Key
            RenderRectangle(HwDeviceExtension,0,0,  0x0000000);     // Drawn

            break;

        case 8:
            //******************************************************************
            // Color Format in 8bpp mode is X24Y8 (See SetupPatches)
            //******************************************************************

            RenderRectangle(HwDeviceExtension,0,0,  0x00000030);    // Dark Grey
            RenderRectangle(HwDeviceExtension,10,10,0x00000080);    // Medium Grey
            RenderRectangle(HwDeviceExtension,20,20,0x000000c0);    // Light Grey

            //******************************************************************
            // Verify ColorKey is working with color 0
            //******************************************************************

            SetColorKey(HwDeviceExtension, NV_ALPHA_1_08 | 0);      // Enable Color Key
            RenderRectangle(HwDeviceExtension,0,0,0x0000000);       // Not Drawn
            SetColorKey(HwDeviceExtension, 0);                      // Disable Color Key
            RenderRectangle(HwDeviceExtension,0,0,0x0000000);       // Drawn

            break;
        }

//    //**************************************************************************
//    // Init clip to a large rectangle
//    //**************************************************************************
//
//    SetClip(HwDeviceExtension, 0, 0, 640, 0x480);
//
//    switch (NVInfo->Framebuffer.Depth)
//        {
//        case 32:
//            RenderTriangle(HwDeviceExtension,320,240,0x00ffffff);
//            RenderTriangle(HwDeviceExtension,400,400,0x0000ffff);
//            break;
//
//        case 16:
//            RenderTriangle(HwDeviceExtension,320,240,0x0000ffff);
//            RenderTriangle(HwDeviceExtension,400,400,0x000003ff);
//            break;
//
//        case 8:
//            RenderTriangle(HwDeviceExtension,320,240,0x000000ff);
//            RenderTriangle(HwDeviceExtension,400,400,0x00000080);
//            break;
//        }

    //**************************************************************************
    // Draw a bunch of rectangles just to prove that the NV engine is working
    //
    // NOTE: The following example will show up better in 16bpp modes
    //       with 5:5:5 format (We're just generating random colors,
    //       and they probably won't look good since we're not paying
    //       attention to the color format)
    //**************************************************************************

    SetClip(HwDeviceExtension, 100, 100, 200, 200);

    x=0;y=0;
    x_inc = 1; y_inc = 1;
    i = 0;

    while (i < 10000)
        {
        if ( (x > 640-64) || (x < 0))
            x_inc*=-1;

        if ( (y > 480-64) || (y < 0))
            y_inc*=-1;

        x += x_inc;
        y += y_inc;

        RenderRectangle(HwDeviceExtension,x,y,i);
//        RenderTriangle(HwDeviceExtension,x,y,i<<5);

        i++;
        }

    //**************************************************************************
    // Now test out ROP functionality
    //**************************************************************************

    SetClip(HwDeviceExtension, 200, 200, 300, 300);
    SetRop(HwDeviceExtension, SRCAND );           // Src AND ROP

    x=0;y=0;
    x_inc = 1; y_inc = 1;
    i = 0;

    while (i < 10000)
        {
        if ( (x > 640-64) || (x < 0))
            x_inc*=-1;

        if ( (y > 480-64) || (y < 0))
            y_inc*=-1;

        x += x_inc;
        y += y_inc;

        RenderRectangle(HwDeviceExtension,x,y,i);
//        RenderTriangle(HwDeviceExtension,x,y,i<<5);


        i++;
        }

    //**************************************************************************
    // Now test out PATTERN functionality
    //**************************************************************************

    SetClip(HwDeviceExtension, 200, 200, 300, 300);
    SetRop(HwDeviceExtension, PATCOPY );

    x=0;y=0;
    x_inc = 1; y_inc = 1;
    i = 0;

    while (i < 10000)
        {
        if ( (x > 640-64) || (x < 0))
            x_inc*=-1;

        if ( (y > 480-64) || (y < 0))
            y_inc*=-1;

        x += x_inc;
        y += y_inc;

        RenderRectangle(HwDeviceExtension,x,y,i);
//        RenderTriangle(HwDeviceExtension,x,y,i<<5);


        i++;
        }

    //**************************************************************************
    // Test out Screen to Screen Blits (IMAGE_BLIT class)
    //**************************************************************************

    SetClip(HwDeviceExtension, 0,0,640,480);
    SetRop(HwDeviceExtension, SRCCOPY );

    ScreenToScreenBlit(HwDeviceExtension,320,240,  0,0,  20,20);
    ScreenToScreenBlit(HwDeviceExtension,320,240,  50,50,  100,100);
    ScreenToScreenBlit(HwDeviceExtension,320,480,  0,0,  300,0);

    //**************************************************************************
    // Test out Memory to Screen Blits (IMAGE_FROM_CPU class)
    //**************************************************************************

    MemoryToScreenBlit(HwDeviceExtension,100,100,  200,200);

    //**************************************************************************
    // Test out Memory to Screen Blits (IMAGE_MONO_FROM_CPU class)
    // Used for text acceleration.  We want color 0 to be transparent
    // and color 1 to be visible (Make sure ALPHA channel is working)
    //**************************************************************************

    switch (NVInfo->Framebuffer.Depth)
        {
        case 32:
            //******************************************************************
            // Color Format in 32bpp mode is X8R8G8B8 (See SetupPatches)
            //******************************************************************

            ImageMonoBlit(HwDeviceExtension,100,0,(~NV_ALPHA_1_32) & 0x00ff0000, (NV_ALPHA_1_32) | 0x0000ff00);
            ImageMonoBlit(HwDeviceExtension,200,0,(~NV_ALPHA_1_32) & 0x00ff0000,(NV_ALPHA_1_32) | 0x0000ff00);
            ImageMonoBlit(HwDeviceExtension,300,0,(~NV_ALPHA_1_32) & 0x00ff0000,(NV_ALPHA_1_32) | 0x0000ff00);
            ImageMonoBlit(HwDeviceExtension,400,-1,(~NV_ALPHA_1_32) & 0x00ff0000,(NV_ALPHA_1_32) | 0x0000ff00);
            ImageMonoBlit(HwDeviceExtension,500,-10,(~NV_ALPHA_1_32) & 0x00ff0000,(NV_ALPHA_1_32) | 0x0000ff00);

            ImageMonoBlit(HwDeviceExtension,0,100,(~NV_ALPHA_1_32) & 0x00ff0000,(NV_ALPHA_1_32) | 0x0000ff00);
            ImageMonoBlit(HwDeviceExtension,0,200,(~NV_ALPHA_1_32) & 0x00ff0000,(NV_ALPHA_1_32) | 0x0000ff00);
            ImageMonoBlit(HwDeviceExtension,-1,300,(~NV_ALPHA_1_32) & 0x00ff0000,(NV_ALPHA_1_32) | 0x0000ff00);
            ImageMonoBlit(HwDeviceExtension,-10,400,(~NV_ALPHA_1_32) & 0x00ff0000,(NV_ALPHA_1_32) | 0x0000ff00);

            //******************************************************************
            // Test alignment
            //******************************************************************

            for (i=0; i<20;i++)
                ImageMonoBlit(HwDeviceExtension,300+i,i*20,(~NV_ALPHA_1_32) & 0x00ff0000,(NV_ALPHA_1_32) | 0x0000ff00);

            //******************************************************************
            // Print out character data
            //******************************************************************

            for (i=0;i <20;i++)
                ImageMonoLetterY(HwDeviceExtension, 400+i,i*20,(~NV_ALPHA_1_32) & 0x00ff0000,(NV_ALPHA_1_32) | 0x00eeeeee);

            break;

        case 16:
            //******************************************************************
            // Color Format in 16bpp mode is X17R5G5B5 (See SetupPatches)
            //******************************************************************

            ImageMonoBlit(HwDeviceExtension,100,0,(~NV_ALPHA_1_16) & 0x00007C00, (NV_ALPHA_1_16) | 0x000003E0);
            ImageMonoBlit(HwDeviceExtension,200,0,(~NV_ALPHA_1_16) & 0x00007C00,(NV_ALPHA_1_16) | 0x000003E0);
            ImageMonoBlit(HwDeviceExtension,300,0,(~NV_ALPHA_1_16) & 0x00007C00,(NV_ALPHA_1_16) | 0x000003E0);
            ImageMonoBlit(HwDeviceExtension,400,-1,(~NV_ALPHA_1_16) & 0x00007C00,(NV_ALPHA_1_16) | 0x000003E0);
            ImageMonoBlit(HwDeviceExtension,500,-10,(~NV_ALPHA_1_16) & 0x00007C00,(NV_ALPHA_1_16) | 0x000003E0);

            ImageMonoBlit(HwDeviceExtension,0,100,(~NV_ALPHA_1_16) & 0x00007C00,(NV_ALPHA_1_16) | 0x000003E0);
            ImageMonoBlit(HwDeviceExtension,0,200,(~NV_ALPHA_1_16) & 0x00007C00,(NV_ALPHA_1_16) | 0x000003E0);
            ImageMonoBlit(HwDeviceExtension,-1,300,(~NV_ALPHA_1_16) & 0x00007C00,(NV_ALPHA_1_16) | 0x000003E0);
            ImageMonoBlit(HwDeviceExtension,-10,400,(~NV_ALPHA_1_16) & 0x00007C00,(NV_ALPHA_1_16) | 0x000003E0);

            //******************************************************************
            // Test alignment
            //******************************************************************

            for (i=0; i<20;i++)
                ImageMonoBlit(HwDeviceExtension,300+i,i*20,(~NV_ALPHA_1_16) & 0x00007c00,(NV_ALPHA_1_16) | 0x000003e0);

            //******************************************************************
            // Print out character data
            //******************************************************************

            for (i=0;i <20;i++)
                ImageMonoLetterY(HwDeviceExtension, 400+i,i*20,(~NV_ALPHA_1_16) & 0x00007c00,(NV_ALPHA_1_16) | 0x00007fff);


            break;

        case 8:
            //******************************************************************
            // Color Format in 8bpp mode is X24Y8 (See SetupPatches)
            //******************************************************************

            ImageMonoBlit(HwDeviceExtension,100,0,(~NV_ALPHA_1_08) & 0x0, (NV_ALPHA_1_08) | 0xff);
            ImageMonoBlit(HwDeviceExtension,200,0,(~NV_ALPHA_1_08) & 0x0,(NV_ALPHA_1_08) | 0xff);
            ImageMonoBlit(HwDeviceExtension,300,0,(~NV_ALPHA_1_08) & 0x0,(NV_ALPHA_1_08) | 0xff);
            ImageMonoBlit(HwDeviceExtension,400,-1,(~NV_ALPHA_1_08) & 0x0,(NV_ALPHA_1_08) | 0xff);
            ImageMonoBlit(HwDeviceExtension,500,-10,(~NV_ALPHA_1_08) & 0x0,(NV_ALPHA_1_08) | 0xff);

            ImageMonoBlit(HwDeviceExtension,0,100,(~NV_ALPHA_1_08) & 0x0,(NV_ALPHA_1_08) | 0xff);
            ImageMonoBlit(HwDeviceExtension,0,200,(~NV_ALPHA_1_08) & 0x0,(NV_ALPHA_1_08) | 0xff);
            ImageMonoBlit(HwDeviceExtension,-1,300,(~NV_ALPHA_1_08) & 0x0,(NV_ALPHA_1_08) | 0xff);
            ImageMonoBlit(HwDeviceExtension,-10,400,(~NV_ALPHA_1_08) & 0x0,(NV_ALPHA_1_08) | 0xff);

            //******************************************************************
            // Test alignment
            //******************************************************************

            for (i=0; i<20;i++)
                ImageMonoBlit(HwDeviceExtension,300+i,i*20,(~NV_ALPHA_1_08) & 0x10,(NV_ALPHA_1_08) | 0xff);

            //******************************************************************
            // Print out character data
            //******************************************************************

            for (i=0;i <20;i++)
                ImageMonoLetterY(HwDeviceExtension, 400+i,i*20,(~NV_ALPHA_1_08) & 0x10,(NV_ALPHA_1_08) | 0xff);


            break;
        }

    //**************************************************************************
    // Default back to a full screen clip and SRCCOPY Rop
    // May need to modify this later for drawing to OFFSCREEN
    //**************************************************************************

    SetRop(HwDeviceExtension,SRCCOPY);
    SetClip(HwDeviceExtension, 0, 0, 0x7fff, 0x7fff);
    }
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nv3_ref.h ===
/* @(#) $Header: /resman.040/inc/nv3_ref.h 16    10/28/97 1:07p Kevink $
 NVidia Corporation */
/* basis: nv1 manuals 10.1
 95/06/27 NVidia Corporation */

#ifndef _NV_REF_H_
#define _NV_REF_H_

/* dev_bus.ref */
#define NV_SPACE                              0x01FFFFFF:0x00000000 /* RW--D */
/* dev_bus.ref */
#define NV_MSPACE                             0x00FFFFFF:0x00000000 /* RW--D */
/* dev_bus.ref */
#define NV_RSPACE                             0x00FFFFFF:0x00000000 /* RW--D */
/* dev_bus.ref */
#define NV_CONFIG                             0x000000FF:0x00000000 /* RW--D */
#define NV_CONFIG_PCI_NV_0                               0x00000000 /* R--4R */
#define NV_CONFIG_PCI_NV_0__ALIAS_1                NV_PBUS_PCI_NV_0 /*       */
#define NV_CONFIG_PCI_NV_0_VENDOR_ID                           15:0 /* C--UF */
#define NV_CONFIG_PCI_NV_0_VENDOR_ID_NVIDIA_SGS          0x000012D2 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_FUNC                     18:16 /* C--UF */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_FUNC_VGA            0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP                     31:19 /* C--UF */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV0            0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV1            0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV2            0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV3            0x00000003 /* C---V */
#define NV_CONFIG_PCI_NV_1                               0x00000004 /* RW-4R */
#define NV_CONFIG_PCI_NV_1__ALIAS_1                NV_PBUS_PCI_NV_1 /*       */
#define NV_CONFIG_PCI_NV_1_IO_SPACE                             0:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_IO_SPACE_DISABLED             0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_IO_SPACE_ENABLED              0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_MEMORY_SPACE                         1:1 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_MEMORY_SPACE_DISABLED         0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_MEMORY_SPACE_ENABLED          0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_BUS_MASTER                           2:2 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_BUS_MASTER_DISABLED           0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_BUS_MASTER_ENABLED            0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL                      4:4 /* C--VF */
#define NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL_DISABLED      0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL_ENABLED       0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_1_PALETTE_SNOOP                        5:5 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_PALETTE_SNOOP_DISABLED        0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_PALETTE_SNOOP_ENABLED         0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_CAPLIST                            20:20 /* R--VF */
#define NV_CONFIG_PCI_NV_1_CAPLIST_NOT_PRESENT           0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_1_CAPLIST_PRESENT               0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_1_66MHZ                              21:21 /* C--VF */
#define NV_CONFIG_PCI_NV_1_66MHZ_INCAPABLE               0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_1_66MHZ_CAPABLE                 0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_1_FAST_BACK2BACK                     23:23 /* C--VF */
#define NV_CONFIG_PCI_NV_1_FAST_BACK2BACK_INCAPABLE      0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_1_FAST_BACK2BACK_CAPABLE        0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING                      26:25 /* C--VF */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_FAST            0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_MEDIUM          0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_SLOW            0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_1_SIGNALED_TARGET                    27:27 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_SIGNALED_TARGET_NO_ABORT      0x00000000 /* R-I-V */
#define NV_CONFIG_PCI_NV_1_SIGNALED_TARGET_ABORT         0x00000001 /* R---V */
#define NV_CONFIG_PCI_NV_1_SIGNALED_TARGET_CLEAR         0x00000001 /* -W--V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET                    28:28 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_NO_ABORT      0x00000000 /* R-I-V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_ABORT         0x00000001 /* R---V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_CLEAR         0x00000001 /* -W--V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER                    29:29 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_NO_ABORT      0x00000000 /* R-I-V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_ABORT         0x00000001 /* R---V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_CLEAR         0x00000001 /* -W--V */
#define NV_CONFIG_PCI_NV_2                               0x00000008 /* R--4R */
#define NV_CONFIG_PCI_NV_2__ALIAS_1                NV_PBUS_PCI_NV_2 /*       */
#define NV_CONFIG_PCI_NV_2_REVISION_ID                          7:0 /* C--UF */
#define NV_CONFIG_PCI_NV_2_REVISION_ID_A01               0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_2_REVISION_ID_B01               0x00000010 /* C---V */
#define NV_CONFIG_PCI_NV_2_CLASS_CODE                          31:8 /* C--VF */
#define NV_CONFIG_PCI_NV_2_CLASS_CODE_VGA                0x00030000 /* C---V */
#define NV_CONFIG_PCI_NV_2_CLASS_CODE_MULTIMEDIA         0x00048000 /* ----V */
#define NV_CONFIG_PCI_NV_3                               0x0000000C /* RW-4R */
#define NV_CONFIG_PCI_NV_3__ALIAS_1                NV_PBUS_PCI_NV_3 /*       */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER                      15:11 /* RWIUF */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_0_CLOCKS        0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_8_CLOCKS        0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_240_CLOCKS      0x0000001E /* RW--V */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_248_CLOCKS      0x0000001F /* RW--V */
#define NV_CONFIG_PCI_NV_3_HEADER_TYPE                        23:16 /* C--VF */
#define NV_CONFIG_PCI_NV_3_HEADER_TYPE_SINGLEFUNC        0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_3_HEADER_TYPE_MULTIFUNC         0x00000080 /* ----V */
#define NV_CONFIG_PCI_NV_4                               0x00000010 /* RW-4R */
#define NV_CONFIG_PCI_NV_4__ALIAS_1                NV_PBUS_PCI_NV_4 /*       */
#define NV_CONFIG_PCI_NV_4_SPACE_TYPE                           0:0 /* C--VF */
#define NV_CONFIG_PCI_NV_4_SPACE_TYPE_MEMORY             0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_4_SPACE_TYPE_IO                 0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE                         2:1 /* C--VF */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_32_BIT           0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_20_BIT           0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_64_BIT           0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_4_PREFETCHABLE                         3:3 /* C--VF */
#define NV_CONFIG_PCI_NV_4_PREFETCHABLE_NOT              0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_4_PREFETCHABLE_MERGABLE         0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_4_BASE_ADDRESS                       31:24 /* RWXUF */
#define NV_CONFIG_PCI_NV_5                               0x00000014 /* RW-4R */
#define NV_CONFIG_PCI_NV_5__ALIAS_1                NV_PBUS_PCI_NV_5 /*       */
#define NV_CONFIG_PCI_NV_5_SPACE_TYPE                           0:0 /* C--VF */
#define NV_CONFIG_PCI_NV_5_SPACE_TYPE_MEMORY             0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_5_SPACE_TYPE_IO                 0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_5_ADDRESS_TYPE                         2:1 /* C--VF */
#define NV_CONFIG_PCI_NV_5_ADDRESS_TYPE_32_BIT           0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_5_ADDRESS_TYPE_20_BIT           0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_5_ADDRESS_TYPE_64_BIT           0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_5_PREFETCHABLE                         3:3 /* C--VF */
#define NV_CONFIG_PCI_NV_5_PREFETCHABLE_NOT              0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_5_PREFETCHABLE_MERGABLE         0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_5_BASE_ADDRESS                       31:24 /* RWXUF */
#define NV_CONFIG_PCI_NV_6                               0x00000018 /* RW-4R */
#define NV_CONFIG_PCI_NV_6__ALIAS_1                NV_PBUS_PCI_NV_6 /*       */
#define NV_CONFIG_PCI_NV_6_SPACE_TYPE                           0:0 /* C--VF */
#define NV_CONFIG_PCI_NV_6_SPACE_TYPE_MEMORY             0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_6_SPACE_TYPE_IO                 0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_6_BASE_ADDRESS                        31:8 /* RWXUF */
#define NV_CONFIG_PCI_NV_7(i)                    (0x0000001C+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_NV_7__SIZE_1                                4 /*       */
#define NV_CONFIG_PCI_NV_7__ALIAS_1                NV_PBUS_PCI_NV_7 /*       */
#define NV_CONFIG_PCI_NV_7_RESERVED                            31:0 /* C--VF */
#define NV_CONFIG_PCI_NV_7_RESERVED_0                    0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_11                              0x0000002C /* R--4R */
#define NV_CONFIG_PCI_NV_11__ALIAS_1              NV_PBUS_PCI_NV_11 /*       */
#define NV_CONFIG_PCI_NV_11_SUBSYSTEM_VENDOR_ID                15:0 /* R--UF */
#define NV_CONFIG_PCI_NV_11_SUBSYSTEM_VENDOR_ID_NONE     0x00000000 /* R---V */
#define NV_CONFIG_PCI_NV_11_SUBSYSTEM_ID                      31:16 /* R--UF */
#define NV_CONFIG_PCI_NV_11_SUBSYSTEM_ID_NONE            0x00000000 /* R---V */
#define NV_CONFIG_PCI_NV_12                              0x00000030 /* RW-4R */
#define NV_CONFIG_PCI_NV_12__ALIAS_1              NV_PBUS_PCI_NV_12 /*       */
#define NV_CONFIG_PCI_NV_12_ROM_DECODE                          0:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_12_ROM_DECODE_DISABLED          0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_12_ROM_DECODE_ENABLED           0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_12_ROM_BASE                          31:22 /* RWXUF */
#define NV_CONFIG_PCI_NV_13                              0x00000034 /* RW-4R */
#define NV_CONFIG_PCI_NV_13__ALIAS_1              NV_PBUS_PCI_NV_13 /*       */
#define NV_CONFIG_PCI_NV_13_CAP_PTR                             7:0 /* C--VF */
#define NV_CONFIG_PCI_NV_13_CAP_PTR_AGP                  0x00000044 /* C---V */
#define NV_CONFIG_PCI_NV_14                              0x00000038 /* R--4A */
#define NV_CONFIG_PCI_NV_14__ALIAS_1              NV_PBUS_PCI_NV_14 /*       */
#define NV_CONFIG_PCI_NV_14_RESERVED                           31:0 /* C--VF */
#define NV_CONFIG_PCI_NV_14_RESERVED_0                   0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_15                              0x0000003C /* RW-4R */
#define NV_CONFIG_PCI_NV_15__ALIAS_1              NV_PBUS_PCI_NV_15 /*       */
#define NV_CONFIG_PCI_NV_15_INTR_LINE                           7:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ0               0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ1               0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ15              0x0000000F /* RW--V */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_UNKNOWN            0x000000FF /* RW--V */
#define NV_CONFIG_PCI_NV_15_INTR_PIN                           15:8 /* C--VF */
#define NV_CONFIG_PCI_NV_15_INTR_PIN_INTA                0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_15_MIN_GNT                           23:16 /* C--VF */
#define NV_CONFIG_PCI_NV_15_MIN_GNT_NO_REQUIREMENTS      0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_15_MIN_GNT_750NS                0x00000003 /* C---V */
#define NV_CONFIG_PCI_NV_15_MAX_LAT                           31:24 /* C--VF */
#define NV_CONFIG_PCI_NV_15_MAX_LAT_NO_REQUIREMENTS      0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_15_MAX_LAT_250NS                0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_16                              0x00000040 /* RW-4R */
#define NV_CONFIG_PCI_NV_16__ALIAS_1              NV_PBUS_PCI_NV_16 /*       */
#define NV_CONFIG_PCI_NV_16_SUBSYSTEM_VENDOR_ID                15:0 /* RW-VF */
#define NV_CONFIG_PCI_NV_16_SUBSYSTEM_VENDOR_ID_NONE     0x00000000 /* R---V */
#define NV_CONFIG_PCI_NV_16_SUBSYSTEM_ID                      31:16 /* RW-VF */
#define NV_CONFIG_PCI_NV_16_SUBSYSTEM_ID_NONE            0x00000000 /* R---V */
#define NV_CONFIG_PCI_NV_17                              0x00000044 /* RW-4R */
#define NV_CONFIG_PCI_NV_17__ALIAS_1              NV_PBUS_PCI_NV_17 /*       */
#define NV_CONFIG_PCI_NV_17_AGP_REV_MAJOR                     23:20 /* C--VF */
#define NV_CONFIG_PCI_NV_17_AGP_REV_MAJOR_1              0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_17_AGP_REV_MINOR                     19:16 /* C--VF */
#define NV_CONFIG_PCI_NV_17_AGP_REV_MINOR_0              0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_17_NEXT_PTR                           15:8 /* C--VF */
#define NV_CONFIG_PCI_NV_17_NEXT_PTR_NULL                0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_17_CAP_ID                              7:0 /* C--VF */
#define NV_CONFIG_PCI_NV_17_CAP_ID_AGP                   0x00000002 /* C---V */
#define NV_CONFIG_PCI_NV_18                              0x00000048 /* RW-4R */
#define NV_CONFIG_PCI_NV_18__ALIAS_1              NV_PBUS_PCI_NV_18 /*       */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_RQ                     31:24 /* C--VF */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_RQ_4              0x00000004 /* C---V */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_SBA                      9:9 /* C--VF */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_SBA_NONE          0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_RATE                     1:0 /* C--VF */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_RATE_1X           0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_RATE_2X           0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_18_AGP_STATUS_RATE_1X_AND_2X    0x00000003 /* C---V */
#define NV_CONFIG_PCI_NV_19                              0x0000004C /* RW-4R */
#define NV_CONFIG_PCI_NV_19__ALIAS_1              NV_PBUS_PCI_NV_19 /*       */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_RQ_DEPTH              31:24 /* RWIVF */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_RQ_DEPTH_0       0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_AGP_ENABLE              8:8 /* RWIVF */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_AGP_ENABLE_OFF   0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_DATA_RATE               1:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_DATA_RATE_OFF    0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_DATA_RATE_1X     0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_19_AGP_COMMAND_DATA_RATE_2X     0x00000002 /* RW--V */
#define NV_CONFIG_PCI_NV_20                              0x00000050 /* RW-4R */
#define NV_CONFIG_PCI_NV_20__ALIAS_1              NV_PBUS_PCI_NV_20 /*       */
#define NV_CONFIG_PCI_NV_20_SOUND_BLASTER                       0:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_SOUND_BLASTER_DISABLED       0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_SOUND_BLASTER_ENABLED        0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_FM_SYNTHESIS                        1:1 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_FM_SYNTHESIS_DISABLED        0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_FM_SYNTHESIS_ENABLED         0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_GAME_PORT                           2:2 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_GAME_PORT_DISABLED           0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_GAME_PORT_ENABLED            0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_MPU401_IO                           3:3 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_MPU401_IO_DISABLED           0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_MPU401_IO_ENABLED            0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_MPU401_IRQ                          4:4 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_MPU401_IRQ_DISABLED          0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_MPU401_IRQ_ENABLED           0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_IO_ALIASING                         5:5 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_IO_ALIASING_DISABLED         0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_IO_ALIASING_ENABLED          0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_LEGACY_AUDIO                        7:7 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_LEGACY_AUDIO_ENABLED         0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_20_LEGACY_AUDIO_DISABLED        0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_SB_BASE                             9:8 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_SB_BASE_220H                 0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_SB_BASE_240H                 0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_20_SB_BASE_260H                 0x00000002 /* RW--V */
#define NV_CONFIG_PCI_NV_20_MPU_BASE                          13:12 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_MPU_BASE_330H                0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_MPU_BASE_230H                0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_20_MPU_BASE_300H                0x00000002 /* RW--V */
#define NV_CONFIG_PCI_NV_20_DMA_SNOOP                         16:16 /* RWIVF */
#define NV_CONFIG_PCI_NV_20_DMA_SNOOP_DISABLED           0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_20_DMA_SNOOP_ENABLED            0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_21                              0x00000054 /* RW-4R */
#define NV_CONFIG_PCI_NV_21__ALIAS_1              NV_PBUS_PCI_NV_21 /*       */
#define NV_CONFIG_PCI_NV_21_VGA                                 0:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_21_VGA_DISABLED                 0x00000000 /* RW--V */
#define NV_CONFIG_PCI_NV_21_VGA_ENABLED                  0x00000001 /* RWI-V */
#define NV_CONFIG_PCI_NV_22                              0x00000058 /* RW-4R */
#define NV_CONFIG_PCI_NV_22__ALIAS_1              NV_PBUS_PCI_NV_22 /*       */
#define NV_CONFIG_PCI_NV_22_SCRATCH                            23:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_22_SCRATCH_DEFAULT              0x0023D6CE /* RWI-V */
#define NV_CONFIG_PCI_NV_23                              0x0000005C /* RW-4R */
#define NV_CONFIG_PCI_NV_23__ALIAS_1              NV_PBUS_PCI_NV_23 /*       */
#define NV_CONFIG_PCI_NV_23_AGP2X_HIGHMARK                      4:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_23_AGP2X_HIGHMARK_8             0x00000008 /* RWI-V */
#define NV_CONFIG_PCI_NV_24(i)                   (0x00000060+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_NV_24__SIZE_1                              40 /*       */
#define NV_CONFIG_PCI_NV_24__ALIAS_1              NV_PBUS_PCI_NV_24 /*       */
#define NV_CONFIG_PCI_NV_24_RESERVED                           31:0 /* C--VF */
#define NV_CONFIG_PCI_NV_24_RESERVED_0                   0x00000000 /* C---V */
/* dev_bus.ref */
#define NV_RMA_ID                                        0x00000000 /* R--4R */
#define NV_RMA_ID__ALIAS_1                          NV_PRMIO_RMA_ID /*       */
#define NV_RMA_ID_CODE                                         31:0 /* C--UF */
#define NV_RMA_ID_CODE_VALID                             0x2B16D065 /* C---V */
#define NV_RMA_PTR                                       0x00000004 /* RW-4R */
#define NV_RMA_PTR__ALIAS_1                        NV_PRMIO_RMA_PTR /*       */
#define NV_RMA_PTR_ADDRESS                                     24:2 /* RWXUF */
#define NV_RMA_DATA                                      0x00000008 /* RW-4R */
#define NV_RMA_DATA__ALIAS_1                      NV_PRMIO_RMA_DATA /*       */
#define NV_RMA_DATA_PORT                                       31:0 /* RWXUF */
#define NV_RMA_DATA32                                    0x0000000C /* RW-2R */
#define NV_RMA_DATA32__ALIAS_1                  NV_PRMIO_RMA_DATA32 /*       */
#define NV_RMA_DATA32_MSW                                     31:16 /* -WXUF */
#define NV_RMA_DATA32_LSW                                      15:0 /* RWXUF */
#define NV_RMA_INCDATA                                   0x00000010 /* RW-4R */
#define NV_RMA_INCDATA__ALIAS_1                NV_PRMIO_RMA_INCDATA /*       */
#define NV_RMA_INCDATA_PORT                                    31:0 /* RWXUF */
#define NV_RMA_INCDATA32                                 0x00000014 /* RW-4R */
#define NV_RMA_INCDATA32__ALIAS_1            NV_PRMIO_RMA_INCDATA32 /*       */
#define NV_RMA_INCDATA32_PORT                                  31:0 /* RWXUF */
/* dev_bus.ref */
#define NV_RMAIO                              0x000000FF:0x00000000 /* RW--D */
/* dev_bus.ref */
#define NV_PRMIO_RMA_ID                                  0x00007100 /* R--4R */
#define NV_PRMIO_RMA_ID__ALIAS_1                          NV_RMA_ID /*       */
#define NV_PRMIO_RMA_PTR                                 0x00007104 /* RW-4R */
#define NV_PRMIO_RMA_PTR__ALIAS_1                        NV_RMA_PTR /*       */
#define NV_PRMIO_RMA_DATA                                0x00007108 /* RW-4R */
#define NV_PRMIO_RMA_DATA__ALIAS_1                      NV_RMA_DATA /*       */
#define NV_PRMIO_RMA_DATA32                              0x0000710C /* RW-2R */
#define NV_PRMIO_RMA_DATA32__ALIAS_1                  NV_RMA_DATA32 /*       */
#define NV_PRMIO_RMA_INCDATA                             0x00007110 /* RW-4R */
#define NV_PRMIO_RMA_INCDATA__ALIAS_1                NV_RMA_INCDATA /*       */
#define NV_PRMIO_RMA_INCDATA32                           0x00007114 /* RW-4R */
#define NV_PRMIO_RMA_INCDATA32__ALIAS_1            NV_RMA_INCDATA32 /*       */
/* dev_bus.ref */
#define NV_MEMORY                             0xFFFFFFFF:0x00000000 /* RW--D */
/* dev_realmode.ref */
/* dev_bus.ref */
#define NV_IO                                 0xFFFFFFFF:0x00000000 /* RW--D */
#define NV_IO_DMA_0000                                   0x00000000 /* -W-1R */
#define NV_IO_DMA_0000_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0001                                   0x00000001 /* -W-1R */
#define NV_IO_DMA_0001_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0002                                   0x00000002 /* -W-1R */
#define NV_IO_DMA_0002_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0003                                   0x00000003 /* -W-1R */
#define NV_IO_DMA_0003_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0004                                   0x00000004 /* -W-1R */
#define NV_IO_DMA_0004_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0005                                   0x00000005 /* -W-1R */
#define NV_IO_DMA_0005_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0006                                   0x00000006 /* -W-1R */
#define NV_IO_DMA_0006_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0007                                   0x00000007 /* -W-1R */
#define NV_IO_DMA_0007_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0008                                   0x00000008 /* -W-1R */
#define NV_IO_DMA_0008_CONTROLLER                               2:2 /* -W-VF */
#define NV_IO_DMA_0008_CONTROLLER_DISABLED               0x00000000 /* -W--V */
#define NV_IO_DMA_0008_CONTROLLER_ENABLED                0x00000001 /* -W--V */
#define NV_IO_DMA_000A                                   0x0000000A /* -W-1R */
#define NV_IO_DMA_000A_CHANNEL                                  1:0 /* -W-UF */
#define NV_IO_DMA_000A_MASK_BIT                                 2:2 /* -W-VF */
#define NV_IO_DMA_000A_MASK_BIT_CLEAR                    0x00000000 /* -W--V */
#define NV_IO_DMA_000A_MASK_BIT_SET                      0x00000001 /* -W--V */
#define NV_IO_DMA_000B                                   0x0000000B /* -W-1R */
#define NV_IO_DMA_000B_CHANNEL                                  1:0 /* -W-UF */
#define NV_IO_DMA_000B_AUTOINITIALIZE                           4:4 /* -W-VF */
#define NV_IO_DMA_000B_AUTOINITIALIZE_DISABLED           0x00000000 /* -W--V */
#define NV_IO_DMA_000B_AUTOINITIALIZE_ENABLED            0x00000001 /* -W--V */
#define NV_IO_DMA_000B_DIRECTION                                5:5 /* -W-VF */
#define NV_IO_DMA_000B_DIRECTION_INCREMENT               0x00000000 /* -W--V */
#define NV_IO_DMA_000B_DIRECTION_DECREMENT               0x00000001 /* -W--V */
#define NV_IO_DMA_000C                                   0x0000000C /* -W-1R */
#define NV_IO_DMA_000C_CLEAR_FLIPFLOP                           7:0 /* -W-VF */
#define NV_IO_DMA_0081                                   0x00000081 /* -W-1R */
#define NV_IO_DMA_0081_ADDRESS                                  3:0 /* -W-UF */
#define NV_IO_DMA_0082                                   0x00000082 /* -W-1R */
#define NV_IO_DMA_0082_ADDRESS                                  3:0 /* -W-UF */
#define NV_IO_DMA_0083                                   0x00000083 /* -W-1R */
#define NV_IO_DMA_0083_ADDRESS                                  3:0 /* -W-UF */
#define NV_IO_DMA_0087                                   0x00000087 /* -W-1R */
#define NV_IO_DMA_0087_ADDRESS                                  3:0 /* -W-UF */
/* dev_dac.ref */
#define NV_PRAMDAC                            0x00680FFF:0x00680300 /* RW--D */
#define NV_PRAMDAC_CU_START_POS                          0x00680300 /* RW-4R */
#define NV_PRAMDAC_CU_START_POS_X                              11:0 /* RWXSF */
#define NV_PRAMDAC_CU_START_POS_Y                             27:16 /* RWXSF */
#define NV_PRAMDAC_APLL_COEFF                            0x00680500 /* RW-4R */
#define NV_PRAMDAC_APLL_COEFF_MDIV                              7:0 /* RWIUF */
#define NV_PRAMDAC_APLL_COEFF_NDIV                             15:8 /* RWIUF */
#define NV_PRAMDAC_APLL_COEFF_PDIV                            18:16 /* RWIVF */
#define NV_PRAMDAC_MPLL_COEFF                            0x00680504 /* RW-4R */
#define NV_PRAMDAC_MPLL_COEFF_MDIV                              7:0 /* RWIUF */
#define NV_PRAMDAC_MPLL_COEFF_NDIV                             15:8 /* RWIUF */
#define NV_PRAMDAC_MPLL_COEFF_PDIV                            18:16 /* RWIVF */
#define NV_PRAMDAC_VPLL_COEFF                            0x00680508 /* RW-4R */
#define NV_PRAMDAC_VPLL_COEFF_MDIV                              7:0 /* RWIUF */
#define NV_PRAMDAC_VPLL_COEFF_NDIV                             15:8 /* RWIUF */
#define NV_PRAMDAC_VPLL_COEFF_PDIV                            18:16 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT                      0x0068050C /* RW-4R */
#define NV_PRAMDAC_PLL_COEFF_SELECT_DLL_BYPASS                  4:4 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_DLL_BYPASS_FALSE     0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_DLL_BYPASS_TRUE      0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_SOURCE                 8:8 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_SOURCE_DEFAULT  0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_SOURCE_PROG     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_BYPASS               12:12 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_BYPASS_FALSE    0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_MPLL_BYPASS_TRUE     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE               16:16 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE_DEFAULT  0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE_PROG     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_BYPASS               20:20 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_BYPASS_FALSE    0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_BYPASS_TRUE     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_PCLK_SOURCE               25:24 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_PCLK_SOURCE_VPLL     0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_PCLK_SOURCE_VIP      0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_PCLK_SOURCE_XTALOSC  0x00000002 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO                28:28 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO_DB1       0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO_DB2       0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL                     0x00680510 /* RW-4R */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_VALUE                     10:0 /* RWIVF */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_VAL                 0x0000044E /* RWI-V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN                   12:12 /* RWIVF */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_ON           0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_OFF          0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER                      0x00680514 /* RW-4R */
#define NV_PRAMDAC_PLL_TEST_COUNTER_NOOFIPCLKS                  9:0 /* -WIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VALUE                      15:0 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE                    16:16 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE_DEASSERTED    0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE_ASSERTED      0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_RESET                     20:20 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_RESET_DEASSERTED     0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_RESET_ASSERTED       0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE                    25:24 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_MCLK          0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_VCLK          0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_ACLK          0x00000002 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_PDIV_RST                  28:28 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_PDIVRST_DEASSERTED   0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_PDIVRST_ASSERTED     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_DLL_LOCK                  29:29 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_DLL_NOTLOCKED        0x00000000 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_DLL_LOCKED           0x00000001 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCK                 30:30 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_NOTLOCKED       0x00000000 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCKED          0x00000001 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCK                 31:31 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_NOTLOCKED       0x00000000 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED          0x00000001 /* R---V */
#define NV_PRAMDAC_PALETTE_TEST                          0x00680518 /* RW-4R */
#define NV_PRAMDAC_PALETTE_TEST_BLUE_DATA                       7:0 /* R--VF */
#define NV_PRAMDAC_PALETTE_TEST_GREEN_DATA                     15:8 /* R--VF */
#define NV_PRAMDAC_PALETTE_TEST_RED_DATA                      23:16 /* R--VF */
#define NV_PRAMDAC_PALETTE_TEST_MODE                          24:24 /* RWIVF */
#define NV_PRAMDAC_PALETTE_TEST_MODE_8BIT                0x00000000 /* RWI-V */
#define NV_PRAMDAC_PALETTE_TEST_MODE_24BIT               0x00000001 /* RW--V */
#define NV_PRAMDAC_PALETTE_TEST_ADDRINC                       28:28 /* RWIVF */
#define NV_PRAMDAC_PALETTE_TEST_ADDRINC_READWRITE        0x00000000 /* RWI-V */
#define NV_PRAMDAC_PALETTE_TEST_ADDRINC_WRITEONLY        0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL                       0x00680600 /* RW-4R */
#define NV_PRAMDAC_GENERAL_CONTROL_FF_COEFF                     1:0 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_FF_COEFF_DEF          0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE                     4:4 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE_GAMMA        0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_IDC_MODE_INDEX        0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE                    8:8 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE_NOTSE       0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE_SEL         0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_565_MODE                   12:12 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_565_MODE_NOTSEL       0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_565_MODE_SEL          0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL                 16:16 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL_OFF        0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL_ON         0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_TERMINATION                17:17 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_TERMINATION_37OHM     0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_TERMINATION_75OHM     0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC                        20:20 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC_6BITS             0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC_8BITS             0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP                  24:24 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP_DIS         0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP_EN          0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK                28:28 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK_EN        0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK_DIS       0x00000001 /* RW--V */
#define NV_PRAMDAC_PALETTE_RECOVERY                      0x00680604 /* R--4R */
#define NV_PRAMDAC_PALETTE_RECOVERY_ACTIVE_ADDRESS              7:0 /* R--UF */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER                10:8 /* R--VF */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_RED      0x00000001 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_GREEN    0x00000002 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_BLUE     0x00000004 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE                 13:12 /* R--VF */
#define NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE_WRITE      0x00000000 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE_READ       0x00000003 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_RED_DATA                  23:16 /* R--VF */
#define NV_PRAMDAC_PALETTE_RECOVERY_GREEN_DATA                31:24 /* R--VF */
#define NV_PRAMDAC_TEST_CONTROL                          0x00680608 /* RW-4R */
#define NV_PRAMDAC_TEST_CONTROL_CRC_RESET                       0:0 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_CRC_RESET_DEASSERTED     0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_RESET_ASSERTED       0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE                      4:4 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE_DEASSERTED    0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE_ASSERTED      0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL                     9:8 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_BLUE         0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_GREEN        0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_RED          0x00000002 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_TP_INS_EN                     12:12 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_TP_INS_EN_DEASSERTED     0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_TP_INS_EN_ASSERTED       0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC                    16:16 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC_ON            0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC_OFF           0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_DACTM                         20:20 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_DACTM_NORMAL             0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_DACTM_TEST               0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH1                        24:24 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_TPATH1_CLEAR             0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH1_SET               0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH31                       25:25 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_TPATH31_CLEAR            0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH31_SET              0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_SENSEB                        28:28 /* R--VF */
#define NV_PRAMDAC_TEST_CONTROL_SENSEB_SOMELO            0x00000000 /* R---V */
#define NV_PRAMDAC_TEST_CONTROL_SENSEB_ALLHI             0x00000001 /* R---V */
#define NV_PRAMDAC_CHECKSUM                              0x0068060C /* R--4R */
#define NV_PRAMDAC_CHECKSUM_VALUE                              23:0 /* R--VF */
#define NV_PRAMDAC_TESTPOINT_DATA                        0x00680610 /* -W-4R */
#define NV_PRAMDAC_TESTPOINT_DATA_RED                           9:0 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_GREEN                       19:10 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_BLUE                        29:20 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_BLACK                       30:30 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_NOTBLANK                    31:31 /* -W-VF */
#define NV_PRAMDAC_VSERR_WIDTH                           0x00680700 /* RW-4R */
#define NV_PRAMDAC_VSERR_WIDTH_VAL                             10:0 /* RWIVF */
#define NV_PRAMDAC_VEQU_END                              0x00680704 /* RW-4R */
#define NV_PRAMDAC_VEQU_END_VAL                                10:0 /* RWIVF */
#define NV_PRAMDAC_VBBLANK_END                           0x00680708 /* RW-4R */
#define NV_PRAMDAC_VBBLANK_END_VAL                             10:0 /* RWIVF */
#define NV_PRAMDAC_VBLANK_END                            0x0068070C /* RW-4R */
#define NV_PRAMDAC_VBLANK_END_VAL                              10:0 /* RWIVF */
#define NV_PRAMDAC_VBLANK_START                          0x00680710 /* RW-4R */
#define NV_PRAMDAC_VBLANK_START_VAL                            10:0 /* RWIVF */
#define NV_PRAMDAC_VBBLANK_START                         0x00680714 /* RW-4R */
#define NV_PRAMDAC_VBBLANK_START_VAL                           10:0 /* RWIVF */
#define NV_PRAMDAC_VEQU_START                            0x00680718 /* RW-4R */
#define NV_PRAMDAC_VEQU_START_VAL                              10:0 /* RWIVF */
#define NV_PRAMDAC_VTOTAL                                0x0068071C /* RW-4R */
#define NV_PRAMDAC_VTOTAL_VAL                                  10:0 /* RWIVF */
#define NV_PRAMDAC_HSYNC_WIDTH                           0x00680720 /* RW-4R */
#define NV_PRAMDAC_HSYNC_WIDTH_VAL                             10:0 /* RWIVF */
#define NV_PRAMDAC_HBURST_START                          0x00680724 /* RW-4R */
#define NV_PRAMDAC_HBURST_START_VAL                            10:0 /* RWIVF */
#define NV_PRAMDAC_HBURST_END                            0x00680728 /* RW-4R */
#define NV_PRAMDAC_HBURST_END_VAL                              10:0 /* RWIVF */
#define NV_PRAMDAC_HBLANK_START                          0x0068072C /* RW-4R */
#define NV_PRAMDAC_HBLANK_START_VAL                            10:0 /* RWIVF */
#define NV_PRAMDAC_HBLANK_END                            0x00680730 /* RW-4R */
#define NV_PRAMDAC_HBLANK_END_VAL                              10:0 /* RWIVF */
#define NV_PRAMDAC_HTOTAL                                0x00680734 /* RW-4R */
#define NV_PRAMDAC_HTOTAL_VAL                                  10:0 /* RWIVF */
#define NV_PRAMDAC_HEQU_WIDTH                            0x00680738 /* RW-4R */
#define NV_PRAMDAC_HEQU_WIDTH_VAL                              10:0 /* RWIVF */
#define NV_PRAMDAC_HSERR_WIDTH                           0x0068073C /* RW-4R */
#define NV_PRAMDAC_HSERR_WIDTH_VAL                             10:0 /* RWIVF */
/* dev_dac.ref */
#define NV_USER_DAC                           0x00681FFF:0x00681200 /* RW--D */
#define NV_USER_DAC_PIXEL_MASK                           0x006813C6 /* RWI1R */
#define NV_USER_DAC_PIXEL_MASK_VALUE                            7:0 /* RWIVF */
#define NV_USER_DAC_PIXEL_MASK_MASK                      0x000000FF /* RWI-V */
#define NV_USER_DAC_READ_MODE_ADDRESS                    0x006813C7 /* RW-1R */
#define NV_USER_DAC_READ_MODE_ADDRESS_VALUE                     7:0 /* RW-VF */
#define NV_USER_DAC_READ_MODE_ADDRESS_WO_VALUE                  7:0 /* -W-VF */
#define NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE                  1:0 /* R--VF */
#define NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE_WRITE     0x00000000 /* R---V */
#define NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE_READ      0x00000003 /* R---V */
#define NV_USER_DAC_WRITE_MODE_ADDRESS                   0x006813C8 /* RW-1R */
#define NV_USER_DAC_WRITE_MODE_ADDRESS_VALUE                    7:0 /* RW-VF */
#define NV_USER_DAC_PALETTE_DATA                         0x006813C9 /* RW-1R */
#define NV_USER_DAC_PALETTE_DATA_VALUE                          7:0 /* RW-VF */
/* dev_realmode.ref */
#define NV_IO_MPU_401_DATA                               0x00000330 /* R--1R */
#define NV_IO_MPU_401_DATA__ALIAS_1                      0x00000300 /* R--1R */
#define NV_IO_MPU_401_DATA__ALIAS_2                      0x00000230 /* R--1R */
#define NV_IO_MPU_401_DATA_VALUE                                7:0 /* R--VF */
#define NV_IO_MPU_401_DATA_ACK                           0x000000FE /* R---V */
#define NV_IO_MPU_401_STATUS                             0x00000331 /* R--1R */
#define NV_IO_MPU_401_STATUS__ALIAS_1                    0x00000301 /* R--1R */
#define NV_IO_MPU_401_STATUS__ALIAS_2                    0x00000231 /* R--1R */
#define NV_IO_MPU_401_STATUS_DATA                               5:0 /* R--VF */
#define NV_IO_MPU_401_STATUS_WRITE                              6:6 /* R--VF */
#define NV_IO_MPU_401_STATUS_WRITE_EMPTY                 0x00000000 /* R---V */
#define NV_IO_MPU_401_STATUS_WRITE_FULL                  0x00000001 /* R---V */
#define NV_IO_MPU_401_STATUS_READ                               7:7 /* R--VF */
#define NV_IO_MPU_401_STATUS_READ_FULL                   0x00000000 /* R---V */
#define NV_IO_MPU_401_STATUS_READ_EMPTY                  0x00000001 /* R---V */
#define NV_IO_MPU_401_COM                                0x00000331 /* -W-1R */
#define NV_IO_MPU_401_COM__ALIAS_1                       0x00000301 /* -W-1R */
#define NV_IO_MPU_401_COM__ALIAS_2                       0x00000231 /* -W-1R */
#define NV_IO_MPU_401_COM_UART_MODE                             7:0 /* -WIVF */
#define NV_IO_MPU_401_COM_UART_MODE_COMPLEX              0x000000ff /* -WI-V */
#define NV_IO_MPU_401_COM_UART_MODE_SIMPLE               0x0000003f /* -W--V */
/* dev_master.ref */
#define NV_PMC                                0x00000FFF:0x00000000 /* RW--D */
#define NV_PMC_BOOT_0                                    0x00000000 /* R--4R */
#define NV_PMC_BOOT_0_FIB_REVISION                              3:0 /* C--VF */
#define NV_PMC_BOOT_0_FIB_REVISION_0                     0x00000000 /* C---V */
#define NV_PMC_BOOT_0_FIB_REVISION_1                     0x00000001 /* ----V */
#define NV_PMC_BOOT_0_MASK_REVISION                             7:4 /* C--VF */
#define NV_PMC_BOOT_0_MASK_REVISION_A                    0x00000000 /* ----V */
#define NV_PMC_BOOT_0_MASK_REVISION_B                    0x00000001 /* C---V */
#define NV_PMC_BOOT_0_IMPLEMENTATION                           15:8 /* C--VF */
#define NV_PMC_BOOT_0_IMPLEMENTATION_NV3                 0x00000001 /* C---V */
#define NV_PMC_BOOT_0_ARCHITECTURE                            23:16 /* C--VF */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV0                   0x00000000 /* ----V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV1                   0x00000001 /* ----V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV2                   0x00000002 /* ----V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV3                   0x00000003 /* C---V */
#define NV_PMC_BOOT_0_MANUFACTURER                            27:24 /* C--UF */
#define NV_PMC_BOOT_0_MANUFACTURER_NVIDIA                0x00000000 /* C---V */
#define NV_PMC_BOOT_0_FOUNDRY                                 31:28 /* C--VF */
#define NV_PMC_BOOT_0_FOUNDRY_SGS                        0x00000000 /* ----V */
#define NV_PMC_BOOT_0_FOUNDRY_HELIOS                     0x00000001 /* ----V */
#define NV_PMC_BOOT_0_FOUNDRY_TSMC                       0x00000002 /* C---V */
#define NV_PMC_INTR_0                                    0x00000100 /* RW-4R */
#define NV_PMC_INTR_0_PAUDIO                                    0:0 /* R--VF */
#define NV_PMC_INTR_0_PAUDIO_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PAUDIO_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PMEDIA                                    4:4 /* R--VF */
#define NV_PMC_INTR_0_PMEDIA_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PMEDIA_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PFIFO                                     8:8 /* R--VF */
#define NV_PMC_INTR_0_PFIFO_NOT_PENDING                  0x00000000 /* R---V */
#define NV_PMC_INTR_0_PFIFO_PENDING                      0x00000001 /* R---V */
#define NV_PMC_INTR_0_PGRAPH0                                 12:12 /* R--VF */
#define NV_PMC_INTR_0_PGRAPH0_NOT_PENDING                0x00000000 /* R---V */
#define NV_PMC_INTR_0_PGRAPH0_PENDING                    0x00000001 /* R---V */
#define NV_PMC_INTR_0_PGRAPH1                                 13:13 /* R--VF */
#define NV_PMC_INTR_0_PGRAPH1_NOT_PENDING                0x00000000 /* R---V */
#define NV_PMC_INTR_0_PGRAPH1_PENDING                    0x00000001 /* R---V */
#define NV_PMC_INTR_0_PVIDEO                                  16:16 /* R--VF */
#define NV_PMC_INTR_0_PVIDEO_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PVIDEO_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PTIMER                                  20:20 /* R--VF */
#define NV_PMC_INTR_0_PTIMER_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PTIMER_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PFB                                     24:24 /* R--VF */
#define NV_PMC_INTR_0_PFB_NOT_PENDING                    0x00000000 /* R---V */
#define NV_PMC_INTR_0_PFB_PENDING                        0x00000001 /* R---V */
#define NV_PMC_INTR_0_PBUS                                    28:28 /* R--VF */
#define NV_PMC_INTR_0_PBUS_NOT_PENDING                   0x00000000 /* R---V */
#define NV_PMC_INTR_0_PBUS_PENDING                       0x00000001 /* R---V */
#define NV_PMC_INTR_0_SOFTWARE                                31:31 /* RWIVF */
#define NV_PMC_INTR_0_SOFTWARE_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PMC_INTR_0_SOFTWARE_PENDING                   0x00000001 /* RW--V */
#define NV_PMC_INTR_EN_0                                 0x00000140 /* RW-4R */
#define NV_PMC_INTR_EN_0_INTA                                   1:0 /* RWIVF */
#define NV_PMC_INTR_EN_0_INTA_DISABLED                   0x00000000 /* RWI-V */
#define NV_PMC_INTR_EN_0_INTA_HARDWARE                   0x00000001 /* RW--V */
#define NV_PMC_INTR_EN_0_INTA_SOFTWARE                   0x00000002 /* RW--V */
#define NV_PMC_INTR_READ_0                               0x00000160 /* R--4R */
#define NV_PMC_INTR_READ_0_INTA                                 0:0 /* R--VF */
#define NV_PMC_INTR_READ_0_INTA_LOW                      0x00000000 /* R---V */
#define NV_PMC_INTR_READ_0_INTA_HIGH                     0x00000001 /* R---V */
#define NV_PMC_ENABLE                                    0x00000200 /* RW-4R */
#define NV_PMC_ENABLE_PAUDIO                                    0:0 /* RWIVF */
#define NV_PMC_ENABLE_PAUDIO_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PAUDIO_ENABLED                     0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PMEDIA                                    4:4 /* RWIVF */
#define NV_PMC_ENABLE_PMEDIA_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PMEDIA_ENABLED                     0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PFIFO                                     8:8 /* RWIVF */
#define NV_PMC_ENABLE_PFIFO_DISABLED                     0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PFIFO_ENABLED                      0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PGRAPH                                  12:12 /* RWIVF */
#define NV_PMC_ENABLE_PGRAPH_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PGRAPH_ENABLED                     0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PPMI                                    16:16 /* RWIVF */
#define NV_PMC_ENABLE_PPMI_DISABLED                      0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PPMI_ENABLED                       0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PFB                                     20:20 /* RWIVF */
#define NV_PMC_ENABLE_PFB_DISABLED                       0x00000000 /* RW--V */
#define NV_PMC_ENABLE_PFB_ENABLED                        0x00000001 /* RWI-V */
#define NV_PMC_ENABLE_PCRTC                                   24:24 /* RWIVF */
#define NV_PMC_ENABLE_PCRTC_DISABLED                     0x00000000 /* RW--V */
#define NV_PMC_ENABLE_PCRTC_ENABLED                      0x00000001 /* RWI-V */
#define NV_PMC_ENABLE_PVIDEO                                  28:28 /* RWIVF */
#define NV_PMC_ENABLE_PVIDEO_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PVIDEO_ENABLED                     0x00000001 /* RW--V */
/* dev_bus.ref */
#define NV_PBUS                               0x00001FFF:0x00001000 /* RW--D */
#define NV_PBUS_DEBUG_0                                  0x00001080 /* RW-4R */
#define NV_PBUS_DEBUG_0_MODE                                    0:0 /* RWIVF */
#define NV_PBUS_DEBUG_0_MODE_DISABLED                    0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_MODE_ENABLED                     0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_0_DESKEWER                                4:4 /* RWIVF */
#define NV_PBUS_DEBUG_0_DESKEWER_ENABLED                 0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_DESKEWER_BYPASS                  0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_0_FBIO_SCLK_DELAY                        11:8 /* RWIVF */
#define NV_PBUS_DEBUG_0_FBIO_SCLK_DELAY_8                0x00000008 /* RWI-V */
#define NV_PBUS_DEBUG_SEL_0                              0x00001090 /* RW-4R */
#define NV_PBUS_DEBUG_SEL_0_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_1                              0x00001094 /* RW-4R */
#define NV_PBUS_DEBUG_SEL_1_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_2                              0x00001098 /* RW-4R */
#define NV_PBUS_DEBUG_SEL_2_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_3                              0x0000109C /* RW-4R */
#define NV_PBUS_DEBUG_SEL_3_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_HOST                               0x000010A0 /* RW-4R */
#define NV_PBUS_DEBUG_HOST_SEL                                  2:0 /* RWXUF */
#define NV_PBUS_DEBUG_1                                  0x00001084 /* RW-4R */
#define NV_PBUS_DEBUG_1_PCIM_THROTTLE                           0:0 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIM_THROTTLE_DISABLED           0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIM_THROTTLE_ENABLED            0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIM_CMD                                1:1 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIM_CMD_SIZE_BASED              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIM_CMD_MRL_ONLY                0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIM_AGP                                2:2 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIM_AGP_IS_AGP                  0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIM_AGP_IS_PCI                  0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_AGPM_CMD                                4:3 /* RWIVF */
#define NV_PBUS_DEBUG_1_AGPM_CMD_HP_ON_1ST               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_AGPM_CMD_LP_ONLY                 0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_AGPM_CMD_HP_ONLY                 0x00000002 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_WRITE                              5:5 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_WRITE_0_CYCLE               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_WRITE_1_CYCLE               0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_2_1                                6:6 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_2_1_DISABLED                0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_2_1_ENABLED                 0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RETRY                              7:7 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_RETRY_DISABLED              0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_RETRY_ENABLED               0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RD_BURST                           8:8 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_RD_BURST_DISABLED           0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RD_BURST_ENABLED            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_WR_BURST                           9:9 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_WR_BURST_DISABLED           0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_WR_BURST_ENABLED            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY                        10:10 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY_DISABLED          0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY_ENABLED           0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RMAIO                            11:11 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_RMAIO_DISABLED              0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_RMAIO_ENABLED               0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_CPUQ                             12:12 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_CPUQ_DISABLED               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_CPUQ_ENABLED                0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE1                                13:13 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE1_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE1_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE2                                14:14 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE2_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE2_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_INTR_0                                   0x00001100 /* RW-4R */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR                            0:0 /* RWXVF */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR_NOT_PENDING         0x00000000 /* R---V */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR_PENDING             0x00000001 /* R---V */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR_RESET               0x00000001 /* -W--V */
#define NV_PBUS_INTR_EN_0                                0x00001140 /* RWI4R */
#define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR                         0:0 /* RWIVF */
#define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR_DISABLED         0x00000000 /* RWI-V */
#define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR_ENABLED          0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0                                0x00001E80 /* RW-4R */
#define NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_0                        7:0 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_1                       15:8 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_2                      23:16 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_MASK_BIT                            24:24 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_MASK_BIT_CLEAR                 0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_MASK_BIT_SET                   0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_AUTOINITIALIZE                      25:25 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_AUTOINITIALIZE_DISABLED        0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_AUTOINITIALIZE_ENABLED         0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_DIRECTION                           26:26 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_DIRECTION_INCREMENT            0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_DIRECTION_DECREMENT            0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_CHANNEL                             29:28 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_CONTROLLER                          30:30 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_CONTROLLER_DISABLED            0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_CONTROLLER_ENABLED             0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_FLIPFLOP                            31:31 /* RWIVF */
#define NV_PBUS_RMC_DMA_0_FLIPFLOP_BYTE_0                0x00000000 /* RWI-V */
#define NV_PBUS_RMC_DMA_0_FLIPFLOP_BYTE_1                0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_1                                0x00001E84 /* RW-4R */
#define NV_PBUS_RMC_DMA_1_COUNT_BYTE_0                          7:0 /* RWXUF */
#define NV_PBUS_RMC_DMA_1_COUNT_BYTE_1                         15:8 /* RWXUF */
#define NV_PBUS_RMC_DMA_1_STATE                               28:28 /* RWXVF */
#define NV_PBUS_RMC_DMA_1_STATE_CLEAN                    0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_1_STATE_DIRTY                    0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_0                                 0x00001800 /* R--4R */
#define NV_PBUS_PCI_NV_0__ALIAS_1                NV_CONFIG_PCI_NV_0 /*       */
#define NV_PBUS_PCI_NV_1                                 0x00001804 /* RW-4R */
#define NV_PBUS_PCI_NV_1__ALIAS_1                NV_CONFIG_PCI_NV_1 /*       */
#define NV_PBUS_PCI_NV_2                                 0x00001808 /* R--4R */
#define NV_PBUS_PCI_NV_2__ALIAS_1                NV_CONFIG_PCI_NV_2 /*       */
#define NV_PBUS_PCI_NV_3                                 0x0000180C /* RW-4R */
#define NV_PBUS_PCI_NV_3__ALIAS_1                NV_CONFIG_PCI_NV_3 /*       */
#define NV_PBUS_PCI_NV_4                                 0x00001810 /* RW-4R */
#define NV_PBUS_PCI_NV_4__ALIAS_1                NV_CONFIG_PCI_NV_4 /*       */
#define NV_PBUS_PCI_NV_5                                 0x00001814 /* RW-4R */
#define NV_PBUS_PCI_NV_5__ALIAS_1                NV_CONFIG_PCI_NV_5 /*       */
#define NV_PBUS_PCI_NV_6                                 0x00001818 /* RW-4R */
#define NV_PBUS_PCI_NV_6__ALIAS_1                NV_CONFIG_PCI_NV_6 /*       */
#define NV_PBUS_PCI_NV_7(i)                      (0x0000181C+(i)*4) /* R--4A */
#define NV_PBUS_PCI_NV_7__SIZE_1                                  4 /*       */
#define NV_PBUS_PCI_NV_7__ALIAS_1                NV_CONFIG_PCI_NV_7 /*       */
#define NV_PBUS_PCI_NV_11                                0x0000182C /* R--4R */
#define NV_PBUS_PCI_NV_11__ALIAS_1              NV_CONFIG_PCI_NV_11 /*       */
#define NV_PBUS_PCI_NV_12                                0x00001830 /* RW-4R */
#define NV_PBUS_PCI_NV_12__ALIAS_1              NV_CONFIG_PCI_NV_12 /*       */
#define NV_PBUS_PCI_NV_13                                0x00001834 /* RW-4R */
#define NV_PBUS_PCI_NV_13__ALIAS_1              NV_CONFIG_PCI_NV_13 /*       */
#define NV_PBUS_PCI_NV_14                                0x00001838 /* R--4A */
#define NV_PBUS_PCI_NV_14__ALIAS_1              NV_CONFIG_PCI_NV_14 /*       */
#define NV_PBUS_PCI_NV_15                                0x0000183C /* RW-4R */
#define NV_PBUS_PCI_NV_15__ALIAS_1              NV_CONFIG_PCI_NV_15 /*       */
#define NV_PBUS_PCI_NV_16                                0x00001840 /* RW-4R */
#define NV_PBUS_PCI_NV_16__ALIAS_1              NV_CONFIG_PCI_NV_16 /*       */
#define NV_PBUS_PCI_NV_17                                0x00001844 /* RW-4R */
#define NV_PBUS_PCI_NV_17__ALIAS_1              NV_CONFIG_PCI_NV_17 /*       */
#define NV_PBUS_PCI_NV_18                                0x00001848 /* RW-4R */
#define NV_PBUS_PCI_NV_18__ALIAS_1              NV_CONFIG_PCI_NV_18 /*       */
#define NV_PBUS_PCI_NV_19                                0x0000184C /* RW-4R */
#define NV_PBUS_PCI_NV_19__ALIAS_1              NV_CONFIG_PCI_NV_19 /*       */
#define NV_PBUS_PCI_NV_20                                0x00001850 /* RW-4R */
#define NV_PBUS_PCI_NV_20__ALIAS_1              NV_CONFIG_PCI_NV_20 /*       */
#define NV_PBUS_PCI_NV_21                                0x00001854 /* RW-4R */
#define NV_PBUS_PCI_NV_21__ALIAS_1              NV_CONFIG_PCI_NV_21 /*       */
#define NV_PBUS_PCI_NV_22                                0x00001858 /* RW-4R */
#define NV_PBUS_PCI_NV_22__ALIAS_1              NV_CONFIG_PCI_NV_22 /*       */
#define NV_PBUS_PCI_NV_23                                0x0000185C /* RW-4R */
#define NV_PBUS_PCI_NV_23__ALIAS_1              NV_CONFIG_PCI_NV_23 /*       */
#define NV_PBUS_PCI_NV_24(i)                     (0x00001860+(i)*4) /* R--4A */
#define NV_PBUS_PCI_NV_24__SIZE_1                                40 /*       */
#define NV_PBUS_PCI_NV_24__ALIAS_1              NV_CONFIG_PCI_NV_24 /*       */
/* dev_fifo.ref */
#define NV_PFIFO                              0x00003FFF:0x00002000 /* RW--D */
#define NV_PFIFO_DELAY_0                                 0x00002040 /* RW-4R */
#define NV_PFIFO_DELAY_0_WAIT_RETRY                             7:0 /* RWIUF */
#define NV_PFIFO_DELAY_0_WAIT_RETRY_0                    0x00000000 /* RWI-V */
#define NV_PFIFO_DEBUG_0                                 0x00002080 /* R--4R */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0                           0:0 /* R-XVF */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0_NOT_PENDING        0x00000000 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0_PENDING            0x00000001 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1                           4:4 /* R-XVF */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1_NOT_PENDING        0x00000000 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1_PENDING            0x00000001 /* R---V */
#define NV_PFIFO_INTR_0                                  0x00002100 /* RW-4R */
#define NV_PFIFO_INTR_0_CACHE_ERROR                             0:0 /* RWXVF */
#define NV_PFIFO_INTR_0_CACHE_ERROR_NOT_PENDING          0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_CACHE_ERROR_PENDING              0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_CACHE_ERROR_RESET                0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_RUNOUT                                  4:4 /* RWXVF */
#define NV_PFIFO_INTR_0_RUNOUT_NOT_PENDING               0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_PENDING                   0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_RESET                     0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW                         8:8 /* RWXVF */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_NOT_PENDING      0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_PENDING          0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_RESET            0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_DMA_PUSHER                            12:12 /* RWXVF */
#define NV_PFIFO_INTR_0_DMA_PUSHER_NOT_PENDING           0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PUSHER_PENDING               0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PUSHER_RESET                 0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_DMA_PTE                               16:16 /* RWXVF */
#define NV_PFIFO_INTR_0_DMA_PTE_NOT_PENDING              0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PTE_PENDING                  0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PTE_RESET                    0x00000001 /* -W--V */
#define NV_PFIFO_INTR_EN_0                               0x00002140 /* RW-4R */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR                          0:0 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR_DISABLED          0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR_ENABLED           0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_RUNOUT                               4:4 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_RUNOUT_DISABLED               0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_ENABLED                0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW                      8:8 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW_DISABLED      0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW_ENABLED       0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_DMA_PUSHER                         12:12 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_DMA_PUSHER_DISABLED           0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_DMA_PUSHER_ENABLED            0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_DMA_PTE                            16:16 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_DMA_PTE_DISABLED              0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_DMA_PTE_ENABLED               0x00000001 /* RW--V */
#define NV_PFIFO_CONFIG_0                                0x00002200 /* RW-4R */
#define NV_PFIFO_CONFIG_0_DMA_FETCH                            10:8 /* RWXVF */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_32_BYTES             0x00000000 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_64_BYTES             0x00000001 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_96_BYTES             0x00000002 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_128_BYTES            0x00000003 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_160_BYTES            0x00000004 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_192_BYTES            0x00000005 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_224_BYTES            0x00000006 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_FETCH_256_BYTES            0x00000007 /* RW--V */
#define NV_PFIFO_CONFIG_0_DMA_WATERMARK                       22:18 /* RWXVF */
#define NV_PFIFO_RAMHT                                   0x00002210 /* RW-4R */
#define NV_PFIFO_RAMHT_BASE_ADDRESS                           15:12 /* RWXVF */
#define NV_PFIFO_RAMHT_BASE_ADDRESS_0                    0x00000000 /* RWI-V */
#define NV_PFIFO_RAMHT_SIZE                                   17:16 /* RWXVF */
#define NV_PFIFO_RAMHT_SIZE_4K                           0x00000000 /* RWI-V */
#define NV_PFIFO_RAMHT_SIZE_8K                           0x00000001 /* RW--V */
#define NV_PFIFO_RAMHT_SIZE_16K                          0x00000002 /* RW--V */
#define NV_PFIFO_RAMHT_SIZE_32K                          0x00000003 /* RW--V */
#define NV_PFIFO_RAMFC                                   0x00002214 /* RW-4R */
#define NV_PFIFO_RAMFC_BASE_ADDRESS                            15:9 /* RWXVF */
#define NV_PFIFO_RAMFC_BASE_ADDRESS_1C00                 0x00001C00 /* RWI-V */
#define NV_PFIFO_RAMRO                                   0x00002218 /* RW-4R */
#define NV_PFIFO_RAMRO_BASE_ADDRESS                            15:9 /* RWXVF */
#define NV_PFIFO_RAMRO_BASE_ADDRESS_1E00                 0x00001E00 /* RWI-V */
#define NV_PFIFO_RAMRO_SIZE                                   16:16 /* RWXVF */
#define NV_PFIFO_RAMRO_SIZE_512                          0x00000000 /* RWI-V */
#define NV_PFIFO_RAMRO_SIZE_8K                           0x00000001 /* RW--V */
#define NV_PFIFO_CACHES                                  0x00002500 /* RW-4R */
#define NV_PFIFO_CACHES_REASSIGN                                0:0 /* RWIVF */
#define NV_PFIFO_CACHES_REASSIGN_DISABLED                0x00000000 /* RWI-V */
#define NV_PFIFO_CACHES_REASSIGN_ENABLED                 0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PUSH0                            0x00003000 /* RW-4R */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_PUSH0                            0x00003200 /* RW-4R */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PUSH1                            0x00003004 /* RW-4R */
#define NV_PFIFO_CACHE0_PUSH1_CHID                              6:0 /* RWXUF */
#define NV_PFIFO_CACHE1_PUSH1                            0x00003204 /* RW-4R */
#define NV_PFIFO_CACHE1_PUSH1_CHID                              6:0 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA0                             0x00003220 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA0_ACCESS                             0:0 /* RWIVF */
#define NV_PFIFO_CACHE1_DMA0_ACCESS_DISABLED             0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_DMA0_ACCESS_ENABLED              0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA0_STATE                              4:4 /* R-IVF */
#define NV_PFIFO_CACHE1_DMA0_STATE_IDLE                  0x00000000 /* R-I-V */
#define NV_PFIFO_CACHE1_DMA0_STATE_BUSY                  0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_DMA1                             0x00003224 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA1_LENGTH                            23:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA2                             0x00003228 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA2_ADDRESS                           23:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA3                             0x0000322C /* RW-4R */
#define NV_PFIFO_CACHE1_DMA3_TARGET_NODE                        1:0 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA3_TARGET_NODE_PCI             0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_DMA3_TARGET_NODE_AGP             0x00000003 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_STATUS                       0x00003218 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_STATUS_METHOD                      12:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATUS_SUBCHANNEL                 15:13 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATUS_METHOD_COUNT               28:18 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATUS_REASON                     30:30 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATUS_REASON_DONE           0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_STATUS_REASON_NON_CACHE      0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_TLB_TAG                      0x00003230 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_TLB_TAG_ADDRESS                   23:12 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE                      0x00003234 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE_PAGE                        0:0 /* RWXVF */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE_PAGE_NOT_PRESENT     0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE_PAGE_PRESENT         0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE_FRAME_ADDRESS             31:12 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_TLB_PT_BASE                  0x00003238 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_TLB_PT_BASE_ADDRESS                19:2 /* RWXUF */
#define NV_PFIFO_CACHE0_PULL0                            0x00003040 /* RW-4R */
#define NV_PFIFO_CACHE0_PULL0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE0_PULL0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE0_PULL0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PULL0_HASH                              4:4 /* R-XVF */
#define NV_PFIFO_CACHE0_PULL0_HASH_SUCCEEDED             0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_PULL0_HASH_FAILED                0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_PULL0_DEVICE                            8:8 /* R-XVF */
#define NV_PFIFO_CACHE0_PULL0_DEVICE_HARDWARE            0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_PULL0_DEVICE_SOFTWARE            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_PULL0                            0x00003240 /* RW-4R */
#define NV_PFIFO_CACHE1_PULL0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE1_PULL0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_PULL0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_PULL0_HASH                              4:4 /* R-XVF */
#define NV_PFIFO_CACHE1_PULL0_HASH_SUCCEEDED             0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_HASH_FAILED                0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_DEVICE                            8:8 /* R-XVF */
#define NV_PFIFO_CACHE1_PULL0_DEVICE_HARDWARE            0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_DEVICE_SOFTWARE            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_PULL1                            0x00003250 /* RW-4R */
#define NV_PFIFO_CACHE1_PULL1_CTX                               4:4 /* RWXVF */
#define NV_PFIFO_CACHE1_PULL1_CTX_CLEAN                  0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_PULL1_CTX_DIRTY                  0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_STATUS                           0x00003014 /* R--4R */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS                           0x00003214 /* R--4R */
#define NV_PFIFO_CACHE1_STATUS_RANOUT                           0:0 /* R-XVF */
#define NV_PFIFO_CACHE1_STATUS_RANOUT_FALSE              0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_RANOUT_TRUE               0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_PUT                              0x00003010 /* RW-4R */
#define NV_PFIFO_CACHE0_PUT_ADDRESS                             2:2 /* RWXUF */
#define NV_PFIFO_CACHE1_PUT                              0x00003210 /* RW-4R */
#define NV_PFIFO_CACHE1_PUT_ADDRESS                             6:2 /* RWXUF */
#define NV_PFIFO_CACHE0_GET                              0x00003070 /* RW-4R */
#define NV_PFIFO_CACHE0_GET_ADDRESS                             2:2 /* RWXUF */
#define NV_PFIFO_CACHE1_GET                              0x00003270 /* RW-4R */
#define NV_PFIFO_CACHE1_GET_ADDRESS                             6:2 /* RWXUF */
#define NV_PFIFO_CACHE0_CTX(i)                  (0x00003080+(i)*16) /* RW-4A */
#define NV_PFIFO_CACHE0_CTX__SIZE_1                               1 /*       */
#define NV_PFIFO_CACHE0_CTX_INSTANCE                           15:0 /* RWXUF */
#define NV_PFIFO_CACHE0_CTX_DEVICE                            22:16 /* RWXUF */
#define NV_PFIFO_CACHE0_CTX_ENGINE                            23:23 /* RWXVF */
#define NV_PFIFO_CACHE0_CTX_ENGINE_SW                    0x00000000 /* RW--V */
#define NV_PFIFO_CACHE0_CTX_ENGINE_GRAPHICS              0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_CTX(i)                  (0x00003280+(i)*16) /* RW-4A */
#define NV_PFIFO_CACHE1_CTX__SIZE_1                               8 /*       */
#define NV_PFIFO_CACHE1_CTX_INSTANCE                           15:0 /* RWXUF */
#define NV_PFIFO_CACHE1_CTX_DEVICE                            22:16 /* RWXUF */
#define NV_PFIFO_CACHE1_CTX_ENGINE                            23:23 /* RWXVF */
#define NV_PFIFO_CACHE1_CTX_ENGINE_SW                    0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_CTX_ENGINE_GRAPHICS              0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_METHOD(i)                (0x00003100+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE0_METHOD__SIZE_1                            1 /*       */
#define NV_PFIFO_CACHE0_METHOD_ADDRESS                         12:2 /* RWXUF */
#define NV_PFIFO_CACHE0_METHOD_SUBCHANNEL                     15:13 /* RWXUF */
#define NV_PFIFO_CACHE1_METHOD(i)                (0x00003300+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE1_METHOD__SIZE_1                           32 /*       */
#define NV_PFIFO_CACHE1_METHOD_ADDRESS                         12:2 /* RWXUF */
#define NV_PFIFO_CACHE1_METHOD_SUBCHANNEL                     15:13 /* RWXUF */
#define NV_PFIFO_CACHE0_DATA(i)                  (0x00003104+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE0_DATA__SIZE_1                              1 /*       */
#define NV_PFIFO_CACHE0_DATA_VALUE                             31:0 /* RWXVF */
#define NV_PFIFO_CACHE1_DATA(i)                  (0x00003304+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE1_DATA__SIZE_1                             32 /*       */
#define NV_PFIFO_CACHE1_DATA_VALUE                             31:0 /* RWXVF */
#define NV_PFIFO_DEVICE(i)                       (0x00002800+(i)*4) /* R--4A */
#define NV_PFIFO_DEVICE__SIZE_1                                 128 /*       */
#define NV_PFIFO_DEVICE_CHID                                    6:0 /* R--UF */
#define NV_PFIFO_DEVICE_SWITCH                                24:24 /* R--VF */
#define NV_PFIFO_DEVICE_SWITCH_UNAVAILABLE               0x00000000 /* R---V */
#define NV_PFIFO_DEVICE_SWITCH_AVAILABLE                 0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS                           0x00002400 /* R--4R */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT                           0:0 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT_FALSE              0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT_TRUE               0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_PUT                              0x00002410 /* RW-4R */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS                            12:3 /* RWXUF */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_0                     8:3 /*       */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_1                    12:3 /*       */
#define NV_PFIFO_RUNOUT_GET                              0x00002420 /* RW-4R */
#define NV_PFIFO_RUNOUT_GET_ADDRESS                            13:3 /* RWXUF */
/* dev_graphics.ref */
#define NV_PGRAPH                             0x00401FFF:0x00400000 /* RW--D */
#define NV_PGRAPH_DEBUG_0                                0x00400080 /* RW-4R */
#define NV_PGRAPH_DEBUG_0_STATE                                 0:0 /* CW-VF */
#define NV_PGRAPH_DEBUG_0_STATE_NORMAL                   0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_0_STATE_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_0_AP_PIPE_STATE                         1:1 /* CW-VF */
#define NV_PGRAPH_DEBUG_0_AP_PIPE_STATE_NORMAL           0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_0_AP_PIPE_STATE_RESET            0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_0_CACHE_STATE                           2:2 /* CW-VF */
#define NV_PGRAPH_DEBUG_0_CACHE_STATE_NORMAL             0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_0_CACHE_STATE_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_0_3D_PIPE_STATE                         3:3 /* CW-VF */
#define NV_PGRAPH_DEBUG_0_3D_PIPE_STATE_NORMAL           0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_0_3D_PIPE_STATE_RESET            0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_0_BULK_READS                            4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_BULK_READS_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_BULK_READS_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_SPARE1                                8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_SPARE1_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_SPARE1_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_SPARE2                              12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_SPARE2_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_SPARE2_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_TILING                              16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_TILING_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_TILING_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_2D                  20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_2D_DISABLED    0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_2D_ENABLED     0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_3D                  21:21 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_3D_DISABLED    0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_3D_ENABLED     0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO                        24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_Y                           25:25 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_Y_DECR                 0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_Y_INCR                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT                         28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1                                0x00400084 /* RW-4R */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET                        0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET_NOT_LAST        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET_LAST            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY                          4:4 /* CW-VF */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY_IGNORE            0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY_CANCEL            0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_1_TURBO3D_2X                            8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TURBO3D_2X__DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TURBO3D_2X_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_TURBO3D_4X                            9:9 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TURBO3D_4X__DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TURBO3D_4X_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS                            12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_TRICLIP_OPTS                        13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TRICLIP_OPTS_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TRICLIP_OPTS_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_INSTANCE                            16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_INSTANCE_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_INSTANCE_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_CTX                                 20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_CTX_DISABLED                   0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_CTX_ENABLED                    0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_CACHE                               24:24 /* CW-VF */
#define NV_PGRAPH_DEBUG_1_CACHE_IGNORE                   0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_1_CACHE_FLUSH                    0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_1_ZCLAMP                              28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_ZCLAMP_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_ZCLAMP_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2                                0x00400088 /* RW-4R */
#define NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND                       0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE1                                4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE1_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE1_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_DPWR_FIFO                             8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_DPWR_FIFO_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_DPWR_FIFO_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_BILINEAR_3D                         12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_BILINEAR_3D_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_BILINEAR_3D_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D                      13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_FOG_3D                              14:14 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_FOG_3D_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_FOG_3D_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_LIGHTING_3D                         15:15 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_LIGHTING_3D_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_LIGHTING_3D_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_BILINEAR_2D                         16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_BILINEAR_2D_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_BILINEAR_2D_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_2D                      17:17 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_2D_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_2D_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_COELESCE_D3D                        20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_COELESCE_D3D_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_COELESCE_D3D_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_COELESCE_PTZ                        21:21 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_COELESCE_PTZ_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_COELESCE_PTZ_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_PREFETCH                            24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_PREFETCH_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_PREFETCH_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET                      28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3                                0x0040008C /* RW-4R */
#define NV_PGRAPH_DEBUG_3_CULLING                               0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_CULLING_DISABLED               0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_CULLING_ENABLED                0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH                      4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH_DISABLED      0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH_ENABLED       0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D                         5:5 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_ZFLUSH                                7:7 /* CW-VF */
#define NV_PGRAPH_DEBUG_3_ZFLUSH_IGNORE                  0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_3_ZFLUSH_ACTIVATE                0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_PTZ                        8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_PTZ_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_PTZ_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_D3D                        9:9 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_D3D_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_D3D_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_PTZ                   10:10 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_PTZ_DISABLED     0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_PTZ_ENABLED      0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_D3D                   11:11 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_D3D_DISABLED     0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_D3D_ENABLED      0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT                        12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_TRIEND_FLUSH                        13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_TRIEND_FLUSH_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_TRIEND_FLUSH_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_ZFIFO_NOP_OPT                       14:14 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_ZFIFO_NOP_OPT_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_ZFIFO_NOP_OPT_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_DITHER_3D                           15:15 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_DITHER_3D_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_DITHER_3D_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FORCE_CREAD                         16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FORCE_CREAD_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FORCE_CREAD_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FORCE_ZREAD                         17:17 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FORCE_ZREAD_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FORCE_ZREAD_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK                          20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL                     21:21 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FORMAT_CHECK                        22:22 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FORMAT_CHECK_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FORMAT_CHECK_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_ALPHA_CHECK                         24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_ALPHA_CHECK_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_ALPHA_CHECK_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SPARE1                              28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SPARE1_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SPARE1_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_0                                 0x00400100 /* RW-4R */
#define NV_PGRAPH_INTR_0_RESERVED                               0:0 /* RW-VF */
#define NV_PGRAPH_INTR_0_RESERVED_NOT_PENDING            0x00000000 /* R---V */
#define NV_PGRAPH_INTR_0_RESERVED_PENDING                0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_RESERVED_RESET                  0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH                         4:4 /* RWIVF */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH_NOT_PENDING      0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH_PENDING          0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH_RESET            0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_VBLANK                                 8:8 /* RWIVF */
#define NV_PGRAPH_INTR_0_VBLANK_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_VBLANK_PENDING                  0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_VBLANK_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_RANGE                                12:12 /* RWIVF */
#define NV_PGRAPH_INTR_0_RANGE_NOT_PENDING               0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_RANGE_PENDING                   0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_RANGE_RESET                     0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_METHOD_COUNT                         16:16 /* RWIVF */
#define NV_PGRAPH_INTR_0_METHOD_COUNT_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_METHOD_COUNT_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_METHOD_COUNT_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_FORMAT                               20:20 /* RWIVF */
#define NV_PGRAPH_INTR_0_FORMAT_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_FORMAT_PENDING                  0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_FORMAT_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP                         24:24 /* RWIVF */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_NOTIFY                               28:28 /* RWIVF */
#define NV_PGRAPH_INTR_0_NOTIFY_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_NOTIFY_PENDING                  0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_NOTIFY_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1                                 0x00400104 /* RW-4R */
#define NV_PGRAPH_INTR_1_METHOD                                 0:0 /* RWIVF */
#define NV_PGRAPH_INTR_1_METHOD_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_METHOD_PENDING                  0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_METHOD_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1_DATA                                   4:4 /* RWIVF */
#define NV_PGRAPH_INTR_1_DATA_NOT_PENDING                0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_DATA_PENDING                    0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_DATA_RESET                      0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY                        12:12 /* RWIVF */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_NOT_PENDING       0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_PENDING           0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_RESET             0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY                         16:16 /* RWIVF */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_EN_0                              0x00400140 /* RW-4R */
#define NV_PGRAPH_INTR_EN_0_RESERVED                            0:0 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_RESERVED_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_RESERVED_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH                      4:4 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH_DISABLED      0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH_ENABLED       0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_VBLANK                              8:8 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_VBLANK_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_VBLANK_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_RANGE                             12:12 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_RANGE_DISABLED               0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_RANGE_ENABLED                0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_METHOD_COUNT                      16:16 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_METHOD_COUNT_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_METHOD_COUNT_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_FORMAT                            20:20 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_FORMAT_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_FORMAT_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP                      24:24 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_NOTIFY                            28:28 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_NOTIFY_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_NOTIFY_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1                              0x00400144 /* RW-4R */
#define NV_PGRAPH_INTR_EN_1_METHOD                              0:0 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_METHOD_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_METHOD_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1_DATA                                4:4 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_DATA_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_DATA_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY                     12:12 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY                      16:16 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH                             0x00400180 /* RW-4R */
#define NV_PGRAPH_CTX_SWITCH_COLOR                              2:0 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_COLOR_R5G5B5                0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_R8G8B8                0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_R10G10B10             0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_Y8                    0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_Y16                   0x00000004 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_V8Y18U8Y08            0x00000005 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_Y18V8Y08U8            0x00000006 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_Y420                  0x00000007 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_ALPHA                              3:3 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_ALPHA_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_ALPHA_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SPARE1                             4:4 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_SPARE1_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_SPARE1_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_MONO_FORMAT                        8:8 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_MONO_FORMAT_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_MONO_FORMAT_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_DAC_BYPASS                         9:9 /* RWXVF */
#define NV_PGRAPH_CTX_SWITCH_DAC_BYPASS_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_DAC_BYPASS_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SPARE2                           10:10 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_SPARE2_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_SPARE2_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_ZWRITE                           12:12 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_ZWRITE_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_ZWRITE_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_CHROMA_KEY                       13:13 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_CHROMA_KEY_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_CHROMA_KEY_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PLANE_MASK                       14:14 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_PLANE_MASK_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_PLANE_MASK_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_USER_CLIP                        15:15 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_USER_CLIP_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_USER_CLIP_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER                       17:16 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_0                0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_1                0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_2                0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SRC_BUFFER_3                0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER0                      20:20 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER0_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER0_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER1                      21:21 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER1_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER1_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER2                      22:22 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER2_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER2_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER3                      23:23 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER3_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_DST_BUFFER3_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG                     28:24 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_RSVD0          0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_DST_SRC    0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_SRC_DST    0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_SRC_SRC    0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_DST_DST    0x00000004 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_DST_SRC    0x00000005 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_DST    0x00000006 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_SRC0   0x00000007 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_SRC1   0x00000008 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_SRC_PAT    0x00000009 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_PAT_SRC    0x0000000a /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_PAT_PAT    0x0000000b /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_SRC_SRC    0x0000000c /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_SRC_PAT    0x0000000d /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_PAT_SRC    0x0000000e /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_RSVD1          0x0000000f /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_SRC_DST    0x00000010 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_PAT_DST_SRC    0x00000011 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_PAT_DST    0x00000012 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_DST_PAT    0x00000013 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_PAT_SRC    0x00000014 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_DST_SRC_PAT    0x00000015 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_RSVD2          0x00000016 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_SRC_BYPASS     0x00000017 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD0    0x00000018 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_SRC_DST  0x00000019 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_DST_SRC  0x0000001a /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD1    0x0000001b /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD2    0x0000001c /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_SRC      0x0000001d /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD3    0x0000001e /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG_BLEND_RSVD4    0x0000001f /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SPARE3                           29:29 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_SPARE3_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_SPARE3_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_VOLATILE                         31:31 /* CWIVF */
#define NV_PGRAPH_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* CWI-V */
#define NV_PGRAPH_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_CTX_CACHE(i)                   (0x004001a0+(i)*4) /* RW-4A */
#define NV_PGRAPH_CTX_CACHE__SIZE_1                               8 /*       */
#define NV_PGRAPH_CTX_CACHE_COLOR                              2:0  /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_ALPHA                              3:3  /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_SPARE1                             4:4  /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_MONO_FORMAT                        8:8  /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_DAC_BYPASS                         9:9  /* RWXVF */
#define NV_PGRAPH_CTX_CACHE_SPARE2                            10:10 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE_ZWRITE                            12:12 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_CHROMA_KEY                        13:13 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_PLANE_MASK                        14:14 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_USER_CLIP                         15:15 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_SRC_BUFFER                        17:16 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_DST_BUFFER0                       20:20 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_DST_BUFFER1                       21:21 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_DST_BUFFER2                       22:22 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_DST_BUFFER3                       23:23 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_PATCH_CONFIG                      28:24 /* RWIVF */
#define NV_PGRAPH_CTX_CACHE_SPARE3                            29:29 /* RWXVF */
#define NV_PGRAPH_CTX_CONTROL                            0x00400190 /* RW-4R */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME                      1:0 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_33US          0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_262US         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_2MS           0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_17MS          0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_TIME                              8:8 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_TIME_EXPIRED               0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_TIME_NOT_EXPIRED           0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_CHID                            16:16 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_CHID_INVALID               0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_CHID_VALID                 0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_SWITCH                          20:20 /* R--VF */
#define NV_PGRAPH_CTX_CONTROL_SWITCH_UNAVAILABLE         0x00000000 /* R---V */
#define NV_PGRAPH_CTX_CONTROL_SWITCH_AVAILABLE           0x00000001 /* R---V */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING                       24:24 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING_IDLE             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING_BUSY             0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_DEVICE                          28:28 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_DEVICE_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_DEVICE_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_USER                               0x00400194 /* RW-4R */
#define NV_PGRAPH_CTX_USER_SUBCH                              15:13 /* RWXVF */
#define NV_PGRAPH_CTX_USER_CLASS                              20:16 /* RWXVF */
#define NV_PGRAPH_CTX_USER_CHID                               30:24 /* RWXVF */
#define NV_PGRAPH_FIFO                                   0x004006A4 /* RW-4R */
#define NV_PGRAPH_FIFO_ACCESS                                   0:0 /* RWIVF */
#define NV_PGRAPH_FIFO_ACCESS_DISABLED                   0x00000000 /* RW--V */
#define NV_PGRAPH_FIFO_ACCESS_ENABLED                    0x00000001 /* RWI-V */
#define NV_PGRAPH_STATUS                                 0x004006B0 /* R--4R */
#define NV_PGRAPH_STATUS_STATE                                  0:0 /* R-IVF */
#define NV_PGRAPH_STATUS_STATE_IDLE                      0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_STATE_BUSY                      0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_XY_LOGIC                               4:4 /* R-IVF */
#define NV_PGRAPH_STATUS_XY_LOGIC_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_XY_LOGIC_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_NOTIFY                            8:8 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_NOTIFY_IDLE                0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_NOTIFY_BUSY                0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_REGISTER                        12:12 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_REGISTER_IDLE              0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_REGISTER_BUSY              0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_DMA                             16:16 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_DMA_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_DMA_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_DMA_ENGINE                           17:17 /* R-IVF */
#define NV_PGRAPH_STATUS_DMA_ENGINE_IDLE                 0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_DMA_ENGINE_BUSY                 0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_DMA_NOTIFY                           20:20 /* R-IVF */
#define NV_PGRAPH_STATUS_DMA_NOTIFY_IDLE                 0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_DMA_NOTIFY_BUSY                 0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_3D                                   24:24 /* R-IVF */
#define NV_PGRAPH_STATUS_3D_IDLE                         0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_3D_BUSY                         0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_CACHE                                25:25 /* R-IVF */
#define NV_PGRAPH_STATUS_CACHE_IDLE                      0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_CACHE_BUSY                      0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_LIGHTING                             26:26 /* R-IVF */
#define NV_PGRAPH_STATUS_LIGHTING_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_LIGHTING_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_ZFIFO                                27:27 /* R-IVF */
#define NV_PGRAPH_STATUS_ZFIFO_IDLE                      0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_ZFIFO_BUSY                      0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_USER                            28:28 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_USER_IDLE                  0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_USER_BUSY                  0x00000001 /* R---V */
#define NV_PGRAPH_TRAPPED_ADDR                           0x004006B4 /* R--4R */
#define NV_PGRAPH_TRAPPED_ADDR_MTHD                            12:2 /* R-XUF */
#define NV_PGRAPH_TRAPPED_ADDR_SUBCH                          15:13 /* R-XUF */
#define NV_PGRAPH_TRAPPED_ADDR_CLASS                          20:16 /* R-XUF */
#define NV_PGRAPH_TRAPPED_ADDR_CHID                           30:24 /* R-XUF */
#define NV_PGRAPH_TRAPPED_DATA                           0x004006B8 /* R--4R */
#define NV_PGRAPH_TRAPPED_DATA_VALUE                           31:0 /* R-XVF */
#define NV_PGRAPH_TRAPPED_INST                           0x004006BC /* R--4R */
#define NV_PGRAPH_TRAPPED_INST_VALUE                           15:0 /* R-XVF */
#define NV_PGRAPH_CLIP_MISC                              0x004006A0 /* RW-4R */
#define NV_PGRAPH_CLIP_MISC_REGIONS                             1:0 /* RWIUF */
#define NV_PGRAPH_CLIP_MISC_REGIONS_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CLIP_MISC_REGIONS_1                    0x00000001 /* RW--V */
#define NV_PGRAPH_CLIP_MISC_REGIONS_2                    0x00000002 /* RW--V */
#define NV_PGRAPH_CLIP_MISC_RENDER                              4:4 /* RWIVF */
#define NV_PGRAPH_CLIP_MISC_RENDER_INCLUDED              0x00000000 /* RWI-V */
#define NV_PGRAPH_CLIP_MISC_RENDER_OCCLUDED              0x00000001 /* RW--V */
#define NV_PGRAPH_CLIP_MISC_COMPLEX                             8:8 /* RWIVF */
#define NV_PGRAPH_CLIP_MISC_COMPLEX_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CLIP_MISC_COMPLEX_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_SRC_CANVAS_MIN                         0x00400550 /* RW-4R */
#define NV_PGRAPH_SRC_CANVAS_MIN_X                             10:0 /* RWXUF */
#define NV_PGRAPH_SRC_CANVAS_MIN_Y                            30:16 /* RWXUF */
#define NV_PGRAPH_DST_CANVAS_MIN                         0x00400558 /* RW-4R */
#define NV_PGRAPH_DST_CANVAS_MIN_X                             10:0 /* RWXUF */
#define NV_PGRAPH_DST_CANVAS_MIN_Y                            30:16 /* RWXUF */
#define NV_PGRAPH_SRC_CANVAS_MAX                         0x00400554 /* RW-4R */
#define NV_PGRAPH_SRC_CANVAS_MAX_X                             10:0 /* RWXUF */
#define NV_PGRAPH_SRC_CANVAS_MAX_Y                            30:16 /* RWXUF */
#define NV_PGRAPH_DST_CANVAS_MAX                         0x0040055C /* RW-4R */
#define NV_PGRAPH_DST_CANVAS_MAX_X                             10:0 /* RWXUF */
#define NV_PGRAPH_DST_CANVAS_MAX_Y                            30:16 /* RWXUF */
#define NV_PGRAPH_CLIP0_MIN                              0x00400690 /* RW-4R */
#define NV_PGRAPH_CLIP0_MIN_X                                  10:0 /* RWXSF */
#define NV_PGRAPH_CLIP0_MIN_Y                                 30:16 /* RWXSF */
#define NV_PGRAPH_CLIP1_MIN                              0x00400698 /* RW-4R */
#define NV_PGRAPH_CLIP1_MIN_X                                  10:0 /* RWXSF */
#define NV_PGRAPH_CLIP1_MIN_Y                                 30:16 /* RWXSF */
#define NV_PGRAPH_CLIP0_MAX                              0x00400694 /* RW-4R */
#define NV_PGRAPH_CLIP0_MAX_X                                  10:0 /* RWXSF */
#define NV_PGRAPH_CLIP0_MAX_Y                                 30:16 /* RWXSF */
#define NV_PGRAPH_CLIP1_MAX                              0x0040069C /* RW-4R */
#define NV_PGRAPH_CLIP1_MAX_X                                  10:0 /* RWXSF */
#define NV_PGRAPH_CLIP1_MAX_Y                                 30:16 /* RWXSF */
#define NV_PGRAPH_DMA                                    0x00400680 /* RW-4R */
#define NV_PGRAPH_DMA_INSTANCE                                 15:0 /* RWXUF */
#define NV_PGRAPH_NOTIFY                                 0x00400684 /* RW-4R */
#define NV_PGRAPH_NOTIFY_INSTANCE                              15:0 /* RWXUF */
#define NV_PGRAPH_NOTIFY_REQ                                  16:16 /* RWIVF */
#define NV_PGRAPH_NOTIFY_REQ_NOT_PENDING                 0x00000000 /* RWI-V */
#define NV_PGRAPH_NOTIFY_REQ_PENDING                     0x00000001 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE                                 23:20 /* RWIVF */
#define NV_PGRAPH_NOTIFY_TYPE_HW                         0x00000000 /* RWI-V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_1                       0x00000001 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_2                       0x00000002 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_3                       0x00000003 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_4                       0x00000004 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_5                       0x00000005 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_6                       0x00000006 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_7                       0x00000007 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_8                       0x00000008 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_9                       0x00000009 /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_10                      0x0000000A /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_11                      0x0000000B /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_12                      0x0000000C /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_13                      0x0000000D /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_14                      0x0000000E /* RW--V */
#define NV_PGRAPH_NOTIFY_TYPE_SW_15                      0x0000000F /* RW--V */
#define NV_PGRAPH_INSTANCE                               0x00400688 /* RW-4R */
#define NV_PGRAPH_INSTANCE_TAG                                 15:0 /* RWXUF */
#define NV_PGRAPH_INSTANCE_TAG_INVALID                   0x00000000 /* RWI-V */
#define NV_PGRAPH_MEMFMT                                 0x0040068C /* RW-4R */
#define NV_PGRAPH_MEMFMT_INSTANCE                              15:0 /* RWXUF */
#define NV_PGRAPH_MEMFMT_LINEAR                               16:16 /* RWIVF */
#define NV_PGRAPH_MEMFMT_LINEAR_OUT                      0x00000000 /* RW--V */
#define NV_PGRAPH_MEMFMT_LINEAR_IN                       0x00000001 /* RW--V */
#define NV_PGRAPH_BOFFSET0                               0x00400630 /* RW-4R */
#define NV_PGRAPH_BOFFSET0_LINADRS                             22:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET0_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET1                               0x00400634 /* RW-4R */
#define NV_PGRAPH_BOFFSET1_LINADRS                             22:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET1_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET2                               0x00400638 /* RW-4R */
#define NV_PGRAPH_BOFFSET2_LINADRS                             22:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET2_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET3                               0x0040063C /* RW-4R */
#define NV_PGRAPH_BOFFSET3_LINADRS                             22:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET3_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BPITCH0                                0x00400650 /* RW-4R */
#define NV_PGRAPH_BPITCH0_VALUE                                12:0 /* RWXUF */
#define NV_PGRAPH_BPITCH1                                0x00400654 /* RW-4R */
#define NV_PGRAPH_BPITCH1_VALUE                                12:0 /* RWXUF */
#define NV_PGRAPH_BPITCH2                                0x00400658 /* RW-4R */
#define NV_PGRAPH_BPITCH2_VALUE                                12:0 /* RWXUF */
#define NV_PGRAPH_BPITCH3                                0x0040065C /* RW-4R */
#define NV_PGRAPH_BPITCH3_VALUE                                12:0 /* RWXUF */
#define NV_PGRAPH_BPIXEL                                 0x004006a8 /* RW-4R */
#define NV_PGRAPH_BPIXEL_DEPTH0_FMT                             1:0 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH0_FMT_Y16_BITS             0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_FMT_8_BITS               0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_FMT_16_BITS              0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_FMT_32_BITS              0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0                                 2:2 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH0_NOT_VALID                0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_FMT                             5:4 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH1_FMT_Y16_BITS             0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_FMT_8_BITS               0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_FMT_16_BITS              0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_FMT_32_BITS              0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1                                 6:6 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH1_NOT_VALID                0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_FMT                             9:8 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH2_FMT_Y16_BITS             0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_FMT_8_BITS               0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_FMT_16_BITS              0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_FMT_32_BITS              0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2                               10:10 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH2_NOT_VALID                0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_FMT                           13:12 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH3_FMT_Y16_BITS             0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_FMT_8_BITS               0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_FMT_16_BITS              0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_FMT_32_BITS              0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3                               14:14 /* RWXVF */
#define NV_PGRAPH_BPIXEL_DEPTH3_NOT_VALID                0x00000000 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX                            0x004006c0 /* RW-4R */
#define NV_PGRAPH_CACHE_INDEX_BANK                              2:2 /* RWXVF */
#define NV_PGRAPH_CACHE_INDEX_BANK_10                    0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_BANK_32                    0x00000001 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS                             12:3 /* RWXVF */
#define NV_PGRAPH_CACHE_INDEX_ADRS_0                     0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS_1024                  0x00000400 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP                              14:13 /* RWXVF */
#define NV_PGRAPH_CACHE_INDEX_OP_WR_CACHE                0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP_RD_CACHE                0x00000001 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP_RD_INDEX                0x00000002 /* RW--V */
#define NV_PGRAPH_CACHE_RAM                              0x004006c4 /* RW-4R */
#define NV_PGRAPH_CACHE_RAM_VALUE                              31:0 /* RWXVF */
#define NV_PGRAPH_ALPHACNTRL                             0x004006c8 /* RW-4R */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_KEY                          7:0 /* RWXUF */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE                     11:8 /* RWXVF */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_ILLEGAL       0x00000000 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_FALSE         0x00000001 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_LT            0x00000002 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_EQ            0x00000003 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_LE            0x00000004 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_GT            0x00000005 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_NE            0x00000006 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_GE            0x00000007 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_TRUE          0x00000008 /* RW--V */
#define NV_PGRAPH_PATT_COLOR0_0                          0x00400600 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR0_0_BLUE                            9:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR0_0_GREEN                         19:10 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR0_0_RED                           29:20 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR0_1                          0x00400604 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR0_1_ALPHA                           7:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_0                          0x00400608 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR1_0_BLUE                            9:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_0_GREEN                         19:10 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_0_RED                           29:20 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_1                          0x0040060C /* RW-4R */
#define NV_PGRAPH_PATT_COLOR1_1_ALPHA                           7:0 /* RWXUF */
#define NV_PGRAPH_PATTERN(i)                     (0x00400610+(i)*4) /* RW-4A */
#define NV_PGRAPH_PATTERN__SIZE_1                                 2 /*       */
#define NV_PGRAPH_PATTERN_BITMAP                               31:0 /* RWXVF */
#define NV_PGRAPH_PATTERN_SHAPE                          0x00400618 /* RW-4R */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE                           1:0 /* RWXVF */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_8X8                0x00000000 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_64X1               0x00000001 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_1X64               0x00000002 /* RW--V */
#define NV_PGRAPH_MONO_COLOR0                            0x0040061C /* RW-4R */
#define NV_PGRAPH_MONO_COLOR0_BLUE                              9:0 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR0_GREEN                           19:10 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR0_RED                             29:20 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR0_ALPHA                           30:30 /* RWXUF */
#define NV_PGRAPH_ROP3                                   0x00400624 /* RW-4R */
#define NV_PGRAPH_ROP3_VALUE                                    7:0 /* RWXVF */
#define NV_PGRAPH_PLANE_MASK                             0x00400628 /* RW-4R */
#define NV_PGRAPH_PLANE_MASK_BLUE                               9:0 /* RWXUF */
#define NV_PGRAPH_PLANE_MASK_GREEN                            19:10 /* RWXUF */
#define NV_PGRAPH_PLANE_MASK_RED                              29:20 /* RWXUF */
#define NV_PGRAPH_PLANE_MASK_ALPHA                            30:30 /* RWXUF */
#define NV_PGRAPH_CHROMA                                 0x0040062C /* RW-4R */
#define NV_PGRAPH_CHROMA_BLUE                                   9:0 /* RWXUF */
#define NV_PGRAPH_CHROMA_GREEN                                19:10 /* RWXUF */
#define NV_PGRAPH_CHROMA_RED                                  29:20 /* RWXUF */
#define NV_PGRAPH_CHROMA_ALPHA                                30:30 /* RWXUF */
#define NV_PGRAPH_BETA                                   0x00400640 /* RW-4R */
#define NV_PGRAPH_BETA_VALUE_FRACTION                         30:23 /* RWXUF */
#define NV_PGRAPH_CONTROL_OUT                            0x00400644 /* RW-4R */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR                      1:0 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_ZOH           0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_ZOH_MS        0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_FOH           0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U                            5:4 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_CYLINDRICAL         0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_WRAP                0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_MIRROR              0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_CLAMP               0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V                            7:6 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_CYLINDRICAL         0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_WRAP                0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_MIRROR              0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_CLAMP               0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT                      8:8 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT_LE_X8R8G8B8   0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT_LE_A8R8G8B8   0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_SRCCOLOR                        11:10 /* -W-UF */
#define NV_PGRAPH_CONTROL_OUT_SRCCOLOR_NORMAL            0x00000000 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_SRCCOLOR_COLOR_INVERSE     0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_SRCCOLOR_ALPHA_INVERSE     0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_SRCCOLOR_ALPHA_ONE         0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_CULLING                         13:12 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_CULLING_ILLEGAL            0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_CULLING_NONE               0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_CULLING_CLOCKWISE          0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_CULLING_COUNTERCLOCKWISE   0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZBUFFER                         15:15 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ZBUFFER_SCREEN             0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ZBUFFER_LINEAR             0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE                    19:16 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_ILLEGAL       0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_FALSE         0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_LT            0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_EQ            0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_LE            0x00000004 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_GT            0x00000005 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_NE            0x00000006 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_GE            0x00000007 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_TRUE          0x00000008 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE                      22:20 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_NEVER           0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALPHA           0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA      0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ZETA            0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALWAYS          0x00000004 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE                     26:24 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_NEVER          0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ALPHA          0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA     0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ZETA           0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ALWAYS         0x00000004 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ROP                             28:28 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ROP_BLEND_AND              0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ROP_ADD_WITH_SATURATION    0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_BETA                      29:29 /* -W-UF */
#define NV_PGRAPH_CONTROL_OUT_BLEND_BETA_SRCALPHA        0x00000000 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_BETA_DESTCOLOR       0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT0                    30:30 /* -W-UF */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT0_DESTCOLOR     0x00000000 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT0_ZERO          0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT1                    31:31 /* -W-UF */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT1_SRCCOLOR      0x00000000 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT1_ZERO          0x00000001 /* -W-UV */
#define NV_PGRAPH_DPRAM_INDEX                            0x00400648 /* RW-4R */
#define NV_PGRAPH_DPRAM_INDEX_ADRS                              5:0 /* RWIVF */
#define NV_PGRAPH_DPRAM_INDEX_ADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT                           10:8 /* RWIVF */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ADRS_0              0x00000000 /* RWI-V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ADRS_1              0x00000001 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_DATA_0              0x00000002 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_DATA_1              0x00000003 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_WE                  0x00000004 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ALPHA               0x00000005 /* RW--V */
#define NV_PGRAPH_DPRAM_DATA                             0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_DATA_VALUE                             31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ADRS_0                           0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_ADRS_0__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ADRS_0_VALUE                           19:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ADRS_1                           0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_ADRS_1__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ADRS_1_VALUE                           19:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_DATA_0                           0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_DATA_0__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_DATA_0_VALUE                           31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_DATA_1                           0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_DATA_1__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_DATA_1_VALUE                           31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_WE                               0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_WE__ALIAS_1            NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_WE_VALUE                               31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ALPHA                            0x0040064c /* RW-4R */
#define NV_PGRAPH_DPRAM_ALPHA__ALIAS_1         NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ALPHA_VALUE                            31:0 /* RWXVF */
#define NV_PGRAPH_ABS_X_RAM(i)                   (0x00400400+(i)*4) /* RW-4A */
#define NV_PGRAPH_ABS_X_RAM__SIZE_1                              32 /*       */
#define NV_PGRAPH_ABS_X_RAM_VALUE                              31:0 /* RWXUF */
#define NV_PGRAPH_X_RAM_BPORT(i)                 (0x00400c00+(i)*4) /* R--4A */
#define NV_PGRAPH_X_RAM_BPORT__SIZE_1                            32 /*       */
#define NV_PGRAPH_X_RAM_BPORT_VALUE                            31:0 /* R--UF */
#define NV_PGRAPH_ABS_Y_RAM(i)                   (0x00400480+(i)*4) /* RW-4A */
#define NV_PGRAPH_ABS_Y_RAM__SIZE_1                              32 /*       */
#define NV_PGRAPH_ABS_Y_RAM_VALUE                              31:0 /* RWXUF */
#define NV_PGRAPH_Y_RAM_BPORT(i)                 (0x00400c80+(i)*4) /* R--4A */
#define NV_PGRAPH_Y_RAM_BPORT__SIZE_1                            32 /*       */
#define NV_PGRAPH_Y_RAM_BPORT_VALUE                            31:0 /* R--UF */
#define NV_PGRAPH_XY_LOGIC_MISC0                         0x00400514 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC0_COUNTER                       17:0 /* RWIUF */
#define NV_PGRAPH_XY_LOGIC_MISC0_COUNTER_0               0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION                    20:20 /* RWXVF */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION_NONZERO       0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC0_INDEX                        31:28 /* RWIUF */
#define NV_PGRAPH_XY_LOGIC_MISC0_INDEX_0                 0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1                         0x00400518 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL                        0:0 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL_NEEDED          0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL_DONE            0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX                      4:4 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY                      5:5 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX                      8:8 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY                      9:9 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN                    12:12 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN_CANVASMIN     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN_USERMIN       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX                    13:13 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX_CANVASMAX     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX_USERMAX       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX                    14:14 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN                    16:16 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN_CANVASMIN     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN_USERMIN       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX                    17:17 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX_CANVASMAX     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX_USERMAX       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX                    18:18 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA                    20:20 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA_CLIPMAX       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_DUDX                         27:24 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_DUDX_VALUE              0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2                         0x0040051C /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF                        0:0 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF_DISABLE         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF_ENABLE          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX                      4:4 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY                      5:5 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPX                      8:8 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPY                      9:9 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_USERCLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMIN                    12:12 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMIN_CANVASMIN     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMIN_USERMIN       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMAX                    13:13 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMAX_CANVASMAX     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XCMAX_USERMAX       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX                    14:14 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMIN                    16:16 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMIN_CANVASMIN     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMIN_USERMIN       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMAX                    17:17 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMAX_CANVASMAX     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YCMAX_USERMAX       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX                    18:18 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA                    20:20 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA_CLIPMAX       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_DVDY                         27:24 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_DVDY_VALUE              0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC3                         0x00400520 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0                     0:0 /* RWXVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0_NULL         0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0_TRUE         0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY                   4:4 /* RWXVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY_NULL       0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX                      8:8 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX_NULL          0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX_TRUE          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG                     12:12 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG_NULL           0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG_TRUE           0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_DIMX                    22:16 /* RWXUF */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_DIMX_0             0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_WDIMX                   30:24 /* RWXUF */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_WDIMX_0            0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC                                 0x00400500 /* RW-4R */
#define NV_PGRAPH_X_MISC_BIT33_0                                0:0 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_BIT33_1                                1:1 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_BIT33_2                                2:2 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_BIT33_3                                3:3 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_0                                4:4 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_1                                5:5 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_2                                6:6 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_3                                7:7 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT                         29:28 /* RWXVF */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_EQ_0               0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_LT_0               0x00000001 /* RW--V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_GT_0               0x00000002 /* RW--V */
#define NV_PGRAPH_Y_MISC                                 0x00400504 /* RW-4R */
#define NV_PGRAPH_Y_MISC_BIT33_0                                0:0 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_BIT33_1                                1:1 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_BIT33_2                                2:2 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_BIT33_3                                3:3 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_0                                4:4 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_1                                5:5 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_2                                6:6 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_3                                7:7 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT                         29:28 /* RWXVF */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_EQ_0               0x00000000 /* RW--V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_LT_0               0x00000001 /* RW--V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_GT_0               0x00000002 /* RW--V */
#define NV_PGRAPH_ABS_UCLIP_XMIN                         0x0040053C /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_XMIN_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP_XMAX                         0x00400544 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_XMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP_YMIN                         0x00400540 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_YMIN_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP_YMAX                         0x00400548 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_YMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_XMIN                        0x00400560 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_XMIN_VALUE                        17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_XMAX                        0x00400568 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_XMAX_VALUE                        17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_YMIN                        0x00400564 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_YMIN_VALUE                        17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_YMAX                        0x0040056C /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_YMAX_VALUE                        17:0 /* RWXSF */
#define NV_PGRAPH_SOURCE_COLOR                           0x0040050C /* RW-4R */
#define NV_PGRAPH_SOURCE_COLOR_VALUE                           31:0 /* RWXVF */
#define NV_PGRAPH_EXCEPTIONS                             0x00400508 /* RW-4R */
#define NV_PGRAPH_EXCEPTIONS_VALID                             27:0 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_VALID_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MIN                         28:28 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MIN_NO_ERROR           0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MIN_ONLY               0x00000001 /* RW--V */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MIN                        29:29 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MIN_NO_ERROR          0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MIN_ONLY              0x00000001 /* RW--V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MAX                         30:30 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MAX_NO_ERROR           0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_MAX_ONLY               0x00000001 /* RW--V */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MAX                        31:31 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MAX_NO_ERROR          0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIPA_MAX_ONLY              0x00000001 /* RW--V */
#define NV_PGRAPH_ABS_ICLIP_XMAX                         0x00400534 /* RW-4R */
#define NV_PGRAPH_ABS_ICLIP_XMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_ICLIP_YMAX                         0x00400538 /* RW-4R */
#define NV_PGRAPH_ABS_ICLIP_YMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_CLIPX_0                                0x00400524 /* RW-4R */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN                             1:0 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX                             3:2 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN                             5:4 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX                             7:6 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN                             9:8 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX                           11:10 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN                           13:12 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX                           15:14 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN                           17:16 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX                           19:18 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN                           21:20 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX                           23:22 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN                           25:24 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX                           27:26 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN                           29:28 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX                           31:30 /* RWIVF */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1                                0x00400528 /* RW-4R */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN                             1:0 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX                             3:2 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN                             5:4 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX                             7:6 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN                            9:8 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX                          11:10 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MIN                          13:12 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP11_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP11MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX                          15:14 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN                          17:16 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX                          19:18 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN                          21:20 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX                          23:22 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN                          25:24 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX                          27:26 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN                          29:28 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX                          31:30 /* RWIVF */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0                                0x0040052c /* RW-4R */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN                             1:0 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX                             3:2 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN                             5:4 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX                             7:6 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN                             9:8 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX                           11:10 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN                           13:12 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX                           15:14 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN                           17:16 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX                           19:18 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN                           21:20 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX                           23:22 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN                           25:24 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX                           27:26 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN                           29:28 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX                           31:30 /* RWIVF */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1                                0x00400530 /* RW-4R */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN                             1:0 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX                             3:2 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN                             5:4 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN_LT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX                             7:6 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX_GT                   0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN                            9:8 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX                          11:10 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MIN                          13:12 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP11_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP11MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX                          15:14 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN                          17:16 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX                          19:18 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN                          21:20 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX                          23:22 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN                          25:24 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX                          27:26 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN                          29:28 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN_LT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX                          31:30 /* RWIVF */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX_GT                  0x00000001 /* RWI-V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_MISC24_0                               0x00400510 /* RW-4R */
#define NV_PGRAPH_MISC24_0_VALUE                               23:0 /* RWXSF */
#define NV_PGRAPH_MISC24_1                               0x00400570 /* RW-4R */
#define NV_PGRAPH_MISC24_1_VALUE                               23:0 /* RWXSF */
#define NV_PGRAPH_PASSTHRU                               0x0040054c /* RW-4R */
#define NV_PGRAPH_PASSTHRU_VALUE                               23:0 /* RWXSF */
#define NV_PGRAPH_ZFOG_RAM(i)                    (0x00400580+(i)*4) /* RW-4A */
#define NV_PGRAPH_ZFOG_RAM__SIZE_1                               16 /*       */
#define NV_PGRAPH_ZFOG_RAM_ZETA                                15:0 /* RWXUF */
#define NV_PGRAPH_ZFOG_RAM_FOG                                23:16 /* RWXUF */
#define NV_PGRAPH_D3D_XY                                 0x004005c0 /* RW-4R */
#define NV_PGRAPH_D3D_XY_X_VALUE                               15:0 /* RWXSF */
#define NV_PGRAPH_D3D_XY_Y_VALUE                              31:16 /* RWXSF */
#define NV_PGRAPH_D3D_UV                                 0x004005c4 /* RW-4R */
#define NV_PGRAPH_D3D_UV_U_VALUE                               15:0 /* RWXSF */
#define NV_PGRAPH_D3D_UV_V_VALUE                              31:16 /* RWXSF */
#define NV_PGRAPH_D3D_ZETA                               0x004005c8 /* RW-4R */
#define NV_PGRAPH_D3D_ZETA_VALUE                               15:0 /* RWXSF */
#define NV_PGRAPH_D3D_RGB                                0x004005cc /* RW-4R */
#define NV_PGRAPH_D3D_RGB_VALUE                                15:0 /* RWXSF */
#define NV_PGRAPH_D3D_FOG                                0x004005d0 /* RW-4R */
#define NV_PGRAPH_D3D_FOG_I0                                    3:0 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_I1                                    7:4 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_I2                                   11:8 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_I3                                  15:12 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_I4                                  19:16 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_I5                                  23:20 /* RWXSF */
#define NV_PGRAPH_D3D_FOG_FOG_VALUE                           31:24 /* RWXSF */
#define NV_PGRAPH_D3D_M                                  0x004005d4 /* RW-4R */
#define NV_PGRAPH_D3D_M_VALUE                                  31:0 /* RWXSF */
#define NV_PGRAPH_DMA_INTR_0                             0x00401100 /* RW-4R */
#define NV_PGRAPH_DMA_INTR_0_INSTANCE                           0:0 /* RWXVF */
#define NV_PGRAPH_DMA_INTR_0_INSTANCE_NOT_PENDING        0x00000000 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_INSTANCE_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_INSTANCE_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_INTR_0_PRESENT                            4:4 /* RWXVF */
#define NV_PGRAPH_DMA_INTR_0_PRESENT_NOT_PENDING         0x00000000 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_PRESENT_PENDING             0x00000001 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_PRESENT_RESET               0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_INTR_0_PROTECTION                         8:8 /* RWXVF */
#define NV_PGRAPH_DMA_INTR_0_PROTECTION_NOT_PENDING      0x00000000 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_PROTECTION_PENDING          0x00000001 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_PROTECTION_RESET            0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_INTR_0_LINEAR                           12:12 /* RWXVF */
#define NV_PGRAPH_DMA_INTR_0_LINEAR_NOT_PENDING          0x00000000 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_LINEAR_PENDING              0x00000001 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_LINEAR_RESET                0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_INTR_0_NOTIFY                           16:16 /* RWXVF */
#define NV_PGRAPH_DMA_INTR_0_NOTIFY_NOT_PENDING          0x00000000 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_NOTIFY_PENDING              0x00000001 /* R---V */
#define NV_PGRAPH_DMA_INTR_0_NOTIFY_RESET                0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_INTR_EN_0                          0x00401140 /* RW-4R */
#define NV_PGRAPH_DMA_INTR_EN_0_INSTANCE                        0:0 /* RWIVF */
#define NV_PGRAPH_DMA_INTR_EN_0_INSTANCE_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_INTR_EN_0_INSTANCE_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_INTR_EN_0_PRESENT                         4:4 /* RWIVF */
#define NV_PGRAPH_DMA_INTR_EN_0_PRESENT_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_INTR_EN_0_PRESENT_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_INTR_EN_0_PROTECTION                      8:8 /* RWIVF */
#define NV_PGRAPH_DMA_INTR_EN_0_PROTECTION_DISABLED      0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_INTR_EN_0_PROTECTION_ENABLED       0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_INTR_EN_0_LINEAR                        12:12 /* RWIVF */
#define NV_PGRAPH_DMA_INTR_EN_0_LINEAR_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_INTR_EN_0_LINEAR_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_INTR_EN_0_NOTIFY                        16:16 /* RWIVF */
#define NV_PGRAPH_DMA_INTR_EN_0_NOTIFY_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_INTR_EN_0_NOTIFY_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_ACCESS                             0x00401200 /* -W-4R */
#define NV_PGRAPH_DMA_PTE_ACCESS_PTE                            0:0 /* -W-VF */
#define NV_PGRAPH_DMA_PTE_ACCESS_PTE_ENABLE              0x00000001 /* -W--V */
#define NV_PGRAPH_DMA_CONTROL                            0x00401210 /* RW-4R */
#define NV_PGRAPH_DMA_CONTROL_ADJUST                           11:0 /* RWXUF */
#define NV_PGRAPH_DMA_CONTROL_PAGE_TABLE                      16:16 /* RWXVF */
#define NV_PGRAPH_DMA_CONTROL_PAGE_TABLE_NOT_PRESENT     0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_CONTROL_PAGE_TABLE_PRESENT         0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_CONTROL_TARGET_NODE                     25:24 /* RWXUF */
#define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_NVM            0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_CART           0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_PCI            0x00000002 /* RW--V */
#define NV_PGRAPH_DMA_CONTROL_TARGET_NODE_AGP            0x00000003 /* RW--V */
#define NV_PGRAPH_DMA_LIMIT                              0x00401220 /* RW-4R */
#define NV_PGRAPH_DMA_LIMIT_OFFSET                             31:0 /* RWXUF */
#define NV_PGRAPH_DMA_TLB_PTE                            0x00401230 /* RW-4R */
#define NV_PGRAPH_DMA_TLB_PTE_PAGE                              0:0 /* RWXVF */
#define NV_PGRAPH_DMA_TLB_PTE_PAGE_NOT_PRESENT           0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_TLB_PTE_PAGE_PRESENT               0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_TLB_PTE_ACCESS                            1:1 /* RWXVF */
#define NV_PGRAPH_DMA_TLB_PTE_ACCESS_READ_ONLY           0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_TLB_PTE_ACCESS_READ_WRITE          0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_TLB_PTE_FRAME_ADDRESS                   31:12 /* RWXUF */
#define NV_PGRAPH_DMA_TLB_TAG                            0x00401240 /* RW-4R */
#define NV_PGRAPH_DMA_TLB_TAG_ADDRESS                         31:12 /* RWXUF */
#define NV_PGRAPH_DMA_ADJ_OFFSET                         0x00401250 /* RW-4R */
#define NV_PGRAPH_DMA_ADJ_OFFSET_VALUE                         31:0 /* RWXUF */
#define NV_PGRAPH_DMA_OFFSET                             0x00401260 /* RW-4R */
#define NV_PGRAPH_DMA_OFFSET_VALUE                             31:0 /* RW-UF */
#define NV_PGRAPH_DMA_SIZE                               0x00401270 /* RW-4R */
#define NV_PGRAPH_DMA_SIZE_VALUE                               21:0 /* RW-UF */
#define NV_PGRAPH_DMA_XLATE_INST                         0x00401280 /* RW-4R */
#define NV_PGRAPH_DMA_XLATE_INST_VALUE                         15:0 /* RWXUF */
#define NV_PGRAPH_DMA_Y_SIZE                             0x00401290 /* RW-4R */
#define NV_PGRAPH_DMA_Y_SIZE_VALUE                             10:0 /* RW-UF */
#define NV_PGRAPH_DMA_LINEAR_LIMIT                       0x00401400 /* RW-4R */
#define NV_PGRAPH_DMA_LINEAR_LIMIT_VALUE                       22:0 /* RWXUF */
#define NV_PGRAPH_DMA_START(i)                  (0x00401800+(i)*16) /* RW-4A */
#define NV_PGRAPH_DMA_START__SIZE_1                               3 /*       */
#define NV_PGRAPH_DMA_START_VALUE                              31:0 /* RWXUF */
#define NV_PGRAPH_DMA_PITCH                              0x00401830 /* RW-4R */
#define NV_PGRAPH_DMA_PITCH_0                                  15:0 /* RWXS4 */
#define NV_PGRAPH_DMA_PITCH_1                                 31:16 /* RWXS4 */
#define NV_PGRAPH_DMA_FORMAT                             0x00401840 /* RW-4R */
#define NV_PGRAPH_DMA_FORMAT_SRC                                2:0 /* RWXS4 */
#define NV_PGRAPH_DMA_FORMAT_SRC_INC_1                   0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_FORMAT_SRC_INC_2                   0x00000002 /* RW--V */
#define NV_PGRAPH_DMA_FORMAT_SRC_INC_4                   0x00000004 /* RW--V */
#define NV_PGRAPH_DMA_FORMAT_DST                               10:8 /* RWXS4 */
#define NV_PGRAPH_DMA_FORMAT_DST_INC_1                   0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_FORMAT_DST_INC_2                   0x00000002 /* RW--V */
#define NV_PGRAPH_DMA_FORMAT_DST_INC_4                   0x00000004 /* RW--V */
#define NV_PGRAPH_DMA_MTMF_NOTIFY                        0x00401820 /* RW-4R */
#define NV_PGRAPH_DMA_MTMF_NOTIFY_TYPE                         31:0 /* RWIVF */
#define NV_PGRAPH_DMA_MTMF_NOTIFY_TYPE_HW                0x00000000 /* RWI-V */
/* dev_video.ref */
#define NV_PVIDEO                             0x006802FF:0x00680000 /* RW--D */
#define NV_PVIDEO_INTR_0                                 0x00680100 /* RWI4R */
#define NV_PVIDEO_INTR_0_NOTIFY                                 0:0 /* RWIVF */
#define NV_PVIDEO_INTR_0_NOTIFY_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PVIDEO_INTR_0_NOTIFY_PENDING                  0x00000001 /* R---V */
#define NV_PVIDEO_INTR_0_NOTIFY_RESET                    0x00000001 /* -W--V */
#define NV_PVIDEO_INTR_EN_0                              0x00680140 /* RWI4R */
#define NV_PVIDEO_INTR_EN_0_NOTIFY                              0:0 /* RWIVF */
#define NV_PVIDEO_INTR_EN_0_NOTIFY_DISABLED              0x00000000 /* RWI-V */
#define NV_PVIDEO_INTR_EN_0_NOTIFY_ENABLED               0x00000001 /* RW--V */
#define NV_PVIDEO_STEP_SIZE                              0x00680200 /* RW-4R */
#define NV_PVIDEO_STEP_SIZE_X                                  11:0 /* RWXVF */
#define NV_PVIDEO_STEP_SIZE_Y                                 27:16 /* RWXVF */
#define NV_PVIDEO_CONTROL_Y                              0x00680204 /* RW-4R */
#define NV_PVIDEO_CONTROL_Y_BLUR                                0:0 /* RW--F */
#define NV_PVIDEO_CONTROL_Y_BLUR_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_Y_BLUR_ON                      0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_Y_LINE                                4:4 /* RW--F */
#define NV_PVIDEO_CONTROL_Y_LINE_HALF                    0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_Y_LINE_FULL                    0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_X                              0x00680208 /* RW-4R */
#define NV_PVIDEO_CONTROL_X_WEIGHT                              0:0 /* RW--F */
#define NV_PVIDEO_CONTROL_X_WEIGHT_LIGHT                 0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_X_WEIGHT_HEAVY                 0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SHARPENING                          4:4 /* RW--F */
#define NV_PVIDEO_CONTROL_X_SHARPENING_OFF               0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SHARPENING_ON                0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SMOOTHING                           8:8 /* RW--F */
#define NV_PVIDEO_CONTROL_X_SMOOTHING_OFF                0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SMOOTHING_ON                 0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF0_START                            0x0068020c /* RW-4R */
#define NV_PVIDEO_BUFF0_START_ADDRESS                          22:2 /* RW-UF */
#define NV_PVIDEO_BUFF1_START                            0x00680210 /* RW-4R */
#define NV_PVIDEO_BUFF1_START_ADDRESS                          22:2 /* RW-UF */
#define NV_PVIDEO_BUFF0_PITCH                            0x00680214 /* RW-4R */
#define NV_PVIDEO_BUFF0_PITCH_LENGTH                           13:4 /* RW-UF */
#define NV_PVIDEO_BUFF1_PITCH                            0x00680218 /* RW-4R */
#define NV_PVIDEO_BUFF1_PITCH_LENGTH                           13:4 /* RW-UF */
#define NV_PVIDEO_BUFF0_OFFSET                           0x0068021c /* RW-4R */
#define NV_PVIDEO_BUFF0_OFFSET_Y                                5:4 /* RW--F */
#define NV_PVIDEO_BUFF0_OFFSET_Y_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_BUFF0_OFFSET_Y_QUARTER                 0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF0_OFFSET_Y_HALF                    0x00000002 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET                           0x00680220 /* RW-4R */
#define NV_PVIDEO_BUFF1_OFFSET_Y                                5:4 /* RW--F */
#define NV_PVIDEO_BUFF1_OFFSET_Y_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET_Y_QUARTER                 0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET_Y_HALF                    0x00000002 /* RW--V */
#define NV_PVIDEO_OE_STATE                               0x00680224 /* RW-4R */
#define NV_PVIDEO_OE_STATE_BUFF0_INTR_NOTIFY                    0:0 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF1_INTR_NOTIFY                    4:4 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF0_ERROR                          8:8 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF1_ERROR                        12:12 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF0_IN_USE                       16:16 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF1_IN_USE                       20:20 /* RWXVF */
#define NV_PVIDEO_OE_STATE_CURRENT_BUFFER                     24:24 /* RWXVF */
#define NV_PVIDEO_OE_STATE_CURRENT_BUFFER_0              0x00000000 /* RW--V */
#define NV_PVIDEO_OE_STATE_CURRENT_BUFFER_1              0x00000001 /* RW--V */
#define NV_PVIDEO_SU_STATE                               0x00680228 /* RW-4R */
#define NV_PVIDEO_SU_STATE_BUFF0_IN_USE                       16:16 /* RWXVF */
#define NV_PVIDEO_SU_STATE_BUFF1_IN_USE                       20:20 /* RWXVF */
#define NV_PVIDEO_RM_STATE                               0x0068022c /* RW-4R */
#define NV_PVIDEO_RM_STATE_BUFF0_INTR_NOTIFY                    0:0 /* RWXVF */
#define NV_PVIDEO_RM_STATE_BUFF1_INTR_NOTIFY                    4:4 /* RWXVF */
#define NV_PVIDEO_WINDOW_START                           0x00680230 /* RW-4R */
#define NV_PVIDEO_WINDOW_START_X                               10:0 /* RWXUF */
#define NV_PVIDEO_WINDOW_START_Y                              26:16 /* RWXUF */
#define NV_PVIDEO_WINDOW_SIZE                            0x00680234 /* RW-4R */
#define NV_PVIDEO_WINDOW_SIZE_X                                10:0 /* RWXUF */
#define NV_PVIDEO_WINDOW_SIZE_Y                               26:16 /* RWXUF */
#define NV_PVIDEO_FIFO_THRES                             0x00680238 /* RW-4R */
#define NV_PVIDEO_FIFO_THRES_SIZE                               6:3 /* RW--F */
#define NV_PVIDEO_FIFO_BURST                             0x0068023c /* RW-4R */
#define NV_PVIDEO_FIFO_BURST_LENGTH                             1:0 /* RW--F */
#define NV_PVIDEO_FIFO_BURST_LENGTH_32                   0x00000001 /* RW--V */
#define NV_PVIDEO_FIFO_BURST_LENGTH_64                   0x00000002 /* RW--V */
#define NV_PVIDEO_FIFO_BURST_LENGTH_128                  0x00000003 /* RW--V */
#define NV_PVIDEO_KEY                                    0x00680240 /* RW-4R */
#define NV_PVIDEO_KEY_INDEX                                     7:0 /* RW-VF */
#define NV_PVIDEO_KEY_565                                      15:0 /* RW-VF */
#define NV_PVIDEO_KEY_555                                      14:0 /* RW-VF */
#define NV_PVIDEO_KEY_888                                      23:0 /* RW-VF */
#define NV_PVIDEO_KEY_PACK                                    31:24 /* RW-VF */
#define NV_PVIDEO_OVERLAY                                0x00680244 /* RWI4R */
#define NV_PVIDEO_OVERLAY_VIDEO                                 0:0 /* RWI-F */
#define NV_PVIDEO_OVERLAY_VIDEO_OFF                      0x00000000 /* RWI-V */
#define NV_PVIDEO_OVERLAY_VIDEO_ON                       0x00000001 /* RW--V */
#define NV_PVIDEO_OVERLAY_KEY                                   4:4 /* RW--F */
#define NV_PVIDEO_OVERLAY_KEY_OFF                        0x00000000 /* RW--V */
#define NV_PVIDEO_OVERLAY_KEY_ON                         0x00000001 /* RW--V */
#define NV_PVIDEO_OVERLAY_FORMAT                                8:8 /* RW--F */
#define NV_PVIDEO_OVERLAY_FORMAT_CCIR                    0x00000000 /* RW--V */
#define NV_PVIDEO_OVERLAY_FORMAT_YUY2                    0x00000001 /* RW--V */
#define NV_PVIDEO_RED_CSC                                0x00680280 /* RW-4R */
#define NV_PVIDEO_RED_CSC_OFFSET                                7:0 /* RWX-F */
#define NV_PVIDEO_GREEN_CSC                              0x00680284 /* RW-4R */
#define NV_PVIDEO_GREEN_CSC_OFFSET                              7:0 /* RWX-F */
#define NV_PVIDEO_BLUE_CSC                               0x00680288 /* RW-4R */
#define NV_PVIDEO_BLUE_CSC_OFFSET                               7:0 /* RWX-F */
#define NV_PVIDEO_CSC_ADJUST                             0x0068028c /* RW-4R */
#define NV_PVIDEO_CSC_ADJUST_B_FLAG                             0:0 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_B_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_B_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_G_FLAG                             4:4 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_G_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_G_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_R_FLAG                             8:8 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_R_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_R_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_L_FLAG                           12:12 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_L_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_L_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_CHROMA                           16:16 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_CHROMA_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_CHROMA_ON                   0x00000001 /* RW--V */
/* vga.ref */
#define NV_PRMCIO                             0x00601FFF:0x00601000 /* RW--D */
#define NV_PRMCIO_INP0                                   0x006013c2 /* R--1R */
#define NV_PRMCIO_INP0__MONO                             0x006013ba /* R--1R */
#define NV_PRMCIO_INP0__COLOR                            0x006013da /* R--1R */
#define NV_PRMCIO_INP0__READ_MONO                        0x006013ca /* R--1R */
#define NV_PRMCIO_INP0__WRITE_MONO                       0x006013ba /* -W-1R */
#define NV_PRMCIO_INP0__WRITE_COLOR                      0x006013da /* -W-1R */
#define NV_PRMCIO_ARX                                    0x006013c0 /* RW-1R */
#define NV_PRMCIO_AR_PALETTE__WRITE                      0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_PALETTE__READ                       0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_MODE__WRITE                         0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_MODE__READ                          0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_MODE_INDEX                          0x00000010 /*       */
#define NV_PRMCIO_AR_OSCAN__WRITE                        0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_OSCAN__READ                         0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_OSCAN_INDEX                         0x00000011 /*       */
#define NV_PRMCIO_AR_PLANE__WRITE                        0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_PLANE__READ                         0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_PLANE_INDEX                         0x00000012 /*       */
#define NV_PRMCIO_AR_HPP__WRITE                          0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_HPP__READ                           0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_HPP_INDEX                           0x00000013 /*       */
#define NV_PRMCIO_AR_CSEL__WRITE                         0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_CSEL__READ                          0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_CSEL_INDEX                          0x00000014 /*       */
#define NV_PRMCIO_CRX__MONO                              0x006013b4 /* RW-1R */
#define NV_PRMCIO_CRX__COLOR                             0x006013d4 /* RW-1R */
#define NV_PRMCIO_CR__MONO                               0x006013b5 /* RW-1R */
#define NV_PRMCIO_CR__COLOR                              0x006013d5 /* RW-1R */
#define NV_PRMCIO_CRE__MONO                              0x006013b5 /* RW-1R */
#define NV_PRMCIO_CRE__COLOR                             0x006013d5 /* RW-1R */
/* vga.ref */
#define NV_CIO                                          0x3DF:0x3B0 /* ----- */
#define NV_CIO_INP0                                      0x000003c2 /* R--1R */
#define NV_CIO_INP0__MONO                                0x000003ba /* R--1R */
#define NV_CIO_INP0__COLOR                               0x000003da /* R--1R */
#define NV_CIO_INP0__READ_MONO                           0x000003ca /* R--1R */
#define NV_CIO_INP0__WRITE_MONO                          0x000003ba /* -W-1R */
#define NV_CIO_INP0__WRITE_COLOR                         0x000003da /* -W-1R */
#define NV_CIO_ARX                                       0x000003c0 /* RW-1R */
#define NV_CIO_AR_PALETTE__WRITE                         0x000003c0 /* -W-1R */
#define NV_CIO_AR_PALETTE__READ                          0x000003c1 /* R--1R */
#define NV_CIO_AR_MODE__WRITE                            0x000003c0 /* -W-1R */
#define NV_CIO_AR_MODE__READ                             0x000003c1 /* R--1R */
#define NV_CIO_AR_MODE_INDEX                             0x00000010 /*       */
#define NV_CIO_AR_OSCAN__WRITE                           0x000003c0 /* -W-1R */
#define NV_CIO_AR_OSCAN__READ                            0x000003c1 /* R--1R */
#define NV_CIO_AR_OSCAN_INDEX                            0x00000011 /*       */
#define NV_CIO_AR_PLANE__WRITE                           0x000003c0 /* -W-1R */
#define NV_CIO_AR_PLANE__READ                            0x000003c1 /* R--1R */
#define NV_CIO_AR_PLANE_INDEX                            0x00000012 /*       */
#define NV_CIO_AR_HPP__WRITE                             0x000003c0 /* -W-1R */
#define NV_CIO_AR_HPP__READ                              0x000003c1 /* R--1R */
#define NV_CIO_AR_HPP_INDEX                              0x00000013 /*       */
#define NV_CIO_AR_CSEL__WRITE                            0x000003c0 /* -W-1R */
#define NV_CIO_AR_CSEL__READ                             0x000003c1 /* R--1R */
#define NV_CIO_AR_CSEL_INDEX                             0x00000014 /*       */
#define NV_CIO_CRX__MONO                                 0x000003b4 /* RW-1R */
#define NV_CIO_CRX__COLOR                                0x000003d4 /* RW-1R */
#define NV_CIO_CR__MONO                                  0x000003b5 /* RW-1R */
#define NV_CIO_CR__COLOR                                 0x000003d5 /* RW-1R */
#define NV_CIO_CR_HDT_INDEX                              0x00000000 /*       */
#define NV_CIO_CR_HDE_INDEX                              0x00000001 /*       */
#define NV_CIO_CR_HBS_INDEX                              0x00000002 /*       */
#define NV_CIO_CR_HBE_INDEX                              0x00000003 /*       */
#define NV_CIO_CR_HBE_4_0                                       4:0 /* RW--F */
#define NV_CIO_CR_HRS_INDEX                              0x00000004 /*       */
#define NV_CIO_CR_HRE_INDEX                              0x00000005 /*       */
#define NV_CIO_CR_HRE_HBE_5                                     7:7 /* RW--F */
#define NV_CIO_CR_HRE_4_0                                       4:0 /* RW--F */
#define NV_CIO_CR_VDT_INDEX                              0x00000006 /*       */
#define NV_CIO_CR_OVL_INDEX                              0x00000007 /*       */
#define NV_CIO_CR_OVL_VDE_8                                     1:1 /* RW--F */
#define NV_CIO_CR_OVL_VDE_9                                     6:6 /* RW--F */
#define NV_CIO_CR_OVL_VDT_8                                     0:0 /* RW--F */
#define NV_CIO_CR_OVL_VDT_9                                     5:5 /* RW--F */
#define NV_CIO_CR_OVL_VBS_8                                     3:3 /* RW--F */
#define NV_CIO_CR_OVL_VRS_8                                     2:2 /* RW--F */
#define NV_CIO_CR_OVL_VRS_9                                     7:7 /* RW--F */
#define NV_CIO_CR_RSAL_INDEX                             0x00000008 /*       */
#define NV_CIO_CR_RSAL_PANNING                                  6:5 /* RW--F */
#define NV_CIO_CR_CELL_HT_INDEX                          0x00000009 /*       */
#define NV_CIO_CR_CELL_HT_SCANDBL                               7:7 /* RW--F */
#define NV_CIO_CR_CELL_HT_VBS_9                                 5:5 /* RW--F */
#define NV_CIO_CR_CURS_ST_INDEX                          0x0000000A /*       */
#define NV_CIO_CR_CURS_END_INDEX                         0x0000000B /*       */
#define NV_CIO_CR_SA_HI_INDEX                            0x0000000C /*       */
#define NV_CIO_CR_SA_LO_INDEX                            0x0000000D /*       */
#define NV_CIO_CR_TCOFF_HI_INDEX                         0x0000000E /*       */
#define NV_CIO_CR_TCOFF_LO_INDEX                         0x0000000F /*       */
#define NV_CIO_CR_VRS_INDEX                              0x00000010 /*       */
#define NV_CIO_CR_VRE_INDEX                              0x00000011 /*       */
#define NV_CIO_CR_VRE_3_0                                       3:0 /* RW--F */
#define NV_CIO_CR_VDE_INDEX                              0x00000012 /*       */
#define NV_CIO_CR_OFFSET_INDEX                           0x00000013 /*       */
#define NV_CIO_CR_ULINE_INDEX                            0x00000014 /*       */
#define NV_CIO_CR_VBS_INDEX                              0x00000015 /*       */
#define NV_CIO_CR_VBE_INDEX                              0x00000016 /*       */
#define NV_CIO_CR_MODE_INDEX                             0x00000017 /*       */
#define NV_CIO_CR_LCOMP_INDEX                            0x00000018 /*       */
#define NV_CIO_CR_GDATA_INDEX                            0x00000022 /*       */
#define NV_CIO_CR_ARFF_INDEX                             0x00000024 /*       */
#define NV_CIO_CR_ARX_INDEX                              0x00000026 /*       */
#define NV_CIO_CRE__MONO                                 0x000003b5 /* RW-1R */
#define NV_CIO_CRE__COLOR                                0x000003d5 /* RW-1R */
#define NV_CIO_CRE_RPC0_INDEX                           0x00000019 /*       */
#define NV_CIO_CRE_RPC0_START                                   4:0 /* RW--F */
#define NV_CIO_CRE_RPC0_OFFSET_10_8                             7:5 /* RW--F */
#define NV_CIO_CRE_RPC1_INDEX                            0x0000001A /*       */
#define NV_CIO_CRE_RPC1_LARGE                                  2:2 /* RW--F */
#define NV_CIO_CRE_FF_INDEX                              0x0000001B /*       */
#define NV_CIO_CRE_FF_BURST                                     2:0 /* RW--F */
#define NV_CIO_CRE_FF_BURST_8                            0x00000000 /* RW--V */
#define NV_CIO_CRE_FF_BURST_32                           0x00000001 /* RW--V */
#define NV_CIO_CRE_FF_BURST_64                           0x00000002 /* RW--V */
#define NV_CIO_CRE_FF_BURST_128                          0x00000003 /* RW--V */
#define NV_CIO_CRE_FF_BURST_256                          0x00000004 /* RW--V */
#define NV_CIO_CRE_ENH_INDEX                             0x0000001C /*       */
#define NV_CIO_CRE_PAGE0_INDEX                           0x0000001D /*       */
#define NV_CIO_CRE_PAGE1_INDEX                           0x0000001E /*       */
#define NV_CIO_CRE_FFLWM__INDEX                          0x00000020 /*       */
#define NV_CIO_CRE_FFLWM_LWM                                    5:0 /* RW--F */
#define NV_CIO_CRE_LSR_INDEX                             0x00000025 /*       */
#define NV_CIO_CRE_LSR_FORMAT                                   7:6 /* RW--F */
#define NV_CIO_CRE_LSR_FORMAT_8BIT                       0x00000001 /* RW--V */
#define NV_CIO_CRE_LSR_FORMAT_555                        0x00000002 /* RW--V */
#define NV_CIO_CRE_LSR_FORMAT_565                        0x00000003 /* RW--V */
#define NV_CIO_CRE_LSR_VDE_10                                   1:1 /* RW--F */
#define NV_CIO_CRE_LSR_VDT_10                                   0:0 /* RW--F */
#define NV_CIO_CRE_LSR_HBE_6                                    4:4 /* RW--F */
#define NV_CIO_CRE_LSR_VBS_10                                   3:3 /* RW--F */
#define NV_CIO_CRE_LSR_VRS_10                                   2:2 /* RW--F */
#define NV_CIO_CRE_PIXEL_INDEX                           0x00000028 /*       */
#define NV_CIO_CRE_PIXEL_FORMAT                                 1:0 /* RW--F */
#define NV_CIO_CRE_PIXEL_FORMAT_VGA                      0x00000000 /* RW--V */
#define NV_CIO_CRE_PIXEL_FORMAT_8BPP                     0x00000001 /* RW--V */
#define NV_CIO_CRE_PIXEL_FORMAT_16BPP                    0x00000002 /* RW--V */
#define NV_CIO_CRE_PIXEL_FORMAT_32BPP                    0x00000003 /* RW--V */
#define NV_CIO_CRE_PIXEL_TILING                                 2:2 /* RW--F */
#define NV_CIO_CRE_DEC__INDEX                            0x00000029 /*       */
#define NV_CIO_CRE_OSCOL__INDEX                          0x0000002A /*       */
#define NV_CIO_CRE_SCRATCH0__INDEX                       0x0000002B /*       */
#define NV_CIO_CRE_SCRATCH1__INDEX                       0x0000002C /*       */
#define NV_CIO_CRE_HEB__INDEX                            0x0000002D /*       */
#define NV_CIO_CRE_HEB_ILC_8                                    4:4 /* RW--F */
#define NV_CIO_CRE_HEB_HRS_8                                    3:3 /* RW--F */
#define NV_CIO_CRE_HEB_HBS_8                                    2:2 /* RW--F */
#define NV_CIO_CRE_HEB_HDE_8                                    1:1 /* RW--F */
#define NV_CIO_CRE_HEB_HDT_8                                    0:0 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR0_INDEX                      0x00000030 /*       */
#define NV_CIO_CRE_HCUR_ADDR0_ADR                               6:0 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR1_INDEX                      0x00000031 /*       */
#define NV_CIO_CRE_HCUR_ADDR1_ADR                               7:3 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR1_CUR_DBL                           1:1 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR1_ENABLE                            0:0 /* RW--F */
#define NV_CIO_CRE_VID_END0__INDEX                       0x00000032 /*       */
#define NV_CIO_CRE_VID_END_7_0                                  7:0 /* RW--F */
#define NV_CIO_CRE_VID_END1__INDEX                       0x00000033 /*       */
#define NV_CIO_CRE_VID_END_ENABLE                               4:4 /* RW--F */
#define NV_CIO_CRE_VID_END_10_8                                 2:0 /* RW--F */
#define NV_CIO_CRE_RL0__INDEX                            0x00000034 /*       */
#define NV_CIO_CRE_RL1__INDEX                            0x00000035 /*       */
#define NV_CIO_CRE_RMA__INDEX                            0x00000038 /*       */
#define NV_CIO_CRE_ILACE__INDEX                          0x00000039 /*       */
#define NV_CIO_CRE_TREG__INDEX                           0x0000003D /*       */
#define NV_CIO_CRE_TREG_HCNT                                    6:6 /* RW--F */
#define NV_CIO_CRE_TREG_VCNT                                    4:4 /* RW--F */
#define NV_CIO_CRE_TREG_HCNT_INDEX                       0x00000000 /*       */
#define NV_CIO_CRE_TREG_VCNTA_INDEX                      0x00000006 /*       */
#define NV_CIO_CRE_TREG_VCNTB_INDEX                      0x00000007 /*       */
#define NV_CIO_CRE_DDC_STATUS__INDEX                     0x0000003E /*       */
#define NV_CIO_CRE_DDC_WR__INDEX                         0x0000003F /*       */
/* vga.ref */
#define NV_PRMVIO                             0x000C7FFF:0x000C0000 /* RW--D */
#define NV_PRMVIO_MBEN                                   0x000C0094 /* RW-1R */
#define NV_PRMVIO_ADDEN                                  0x000C46e8 /* RW-1R */
#define NV_PRMVIO_VSE1                                   0x000C0102 /* RW-1R */
#define NV_PRMVIO_VSE2                                   0x000C03c3 /* RW-1R */
#define NV_PRMVIO_MISC__READ                             0x000C03cc /* R--1R */
#define NV_PRMVIO_MISC__WRITE                            0x000C03c2 /* -W-1R */
#define NV_PRMVIO_SRX                                    0x000C03c4 /* RW-1R */
#define NV_PRMVIO_SR_RESET                               0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_RESET_INDEX                         0x00000000 /*       */
#define NV_PRMVIO_SR_CLOCK                               0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_CLOCK_INDEX                         0x00000001 /*       */
#define NV_PRMVIO_SR_PLANE_MASK                          0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_PLANE_MASK_INDEX                    0x00000002 /*       */
#define NV_PRMVIO_SR_CHAR_MAP                            0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_CHAR_MAP_INDEX                      0x00000003 /*       */
#define NV_PRMVIO_SR_MEM_MODE                            0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_MEM_MODE_INDEX                      0x00000004 /*       */
#define NV_PRMVIO_SR_LOCK                                0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_LOCK_INDEX                          0x00000006 /*       */
#define NV_PRMVIO_GRX                                    0x000C03ce /* RW-1R */
#define NV_PRMVIO_GX_SR                                  0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_SR_INDEX                            0x00000000 /*       */
#define NV_PRMVIO_GX_SREN                                0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_SREN_INDEX                          0x00000001 /*       */
#define NV_PRMVIO_GX_CCOMP                               0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_CCOMP_INDEX                         0x00000002 /*       */
#define NV_PRMVIO_GX_ROP                                 0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_ROP_INDEX                           0x00000003 /*       */
#define NV_PRMVIO_GX_READ_MAP                            0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_READ_MAP_INDEX                      0x00000004 /*       */
#define NV_PRMVIO_GX_MODE                                0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_MODE_INDEX                          0x00000005 /*       */
#define NV_PRMVIO_GX_MISC                                0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_MISC_INDEX                          0x00000006 /*       */
#define NV_PRMVIO_GX_DONT_CARE                           0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_DONT_CARE_INDEX                     0x00000007 /*       */
#define NV_PRMVIO_GX_BIT_MASK                            0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_BIT_MASK_INDEX                      0x00000008 /*       */
/* vga.ref */
#define NV_PRMVGA                             0x000BFFFF:0x000A0000 /* RW--D */
/* dev_media.ref */
#define NV_PME                                0x00200FFF:0x00200000 /* RW--D */
#define NV_PME_DEBUG_0                                   0x00200080 /* RWI4R */
#define NV_PME_DEBUG_0_DET_FIELD_SWITCH                         0:0 /* RWI-F */
#define NV_PME_DEBUG_0_DET_FIELD_SWITCH_DISABLED         0x00000000 /* RWI-V */
#define NV_PME_DEBUG_0_DET_FIELD_SWITCH_ENABLED          0x00000001 /* RW--V */
#define NV_PME_DEBUG_1                                   0x00200084 /* RWI4R */
#define NV_PME_DEBUG_1_SEL                                      1:0 /* RWI-F */
#define NV_PME_DEBUG_1_SEL_VIPCLK                        0x00000000 /* RWI-V */
#define NV_PME_DEBUG_1_SEL_MCLK                          0x00000001 /* RW--V */
#define NV_PME_DEBUG_1_SEL_GLOB                          0x00000002 /* RW--V */
#define NV_PME_DEBUG_1_VIPCLK_SEL                               6:4 /* RWI-F */
#define NV_PME_DEBUG_1_VIPCLK_SEL_DEFAULT                0x00000000 /* RWI-V */
#define NV_PME_DEBUG_1_MCLK_SEL                                 9:8 /* RWI-F */
#define NV_PME_DEBUG_1_MCLK_SEL_DEFAULT                  0x00000000 /* RWI-V */
#define NV_PME_INTR_0                                    0x00200100 /* RWI4R */
#define NV_PME_INTR_0_IMAGE_NOTIFY                              0:0 /* RWIVF */
#define NV_PME_INTR_0_IMAGE_NOTIFY_NOT_PENDING           0x00000000 /* R-I-V */
#define NV_PME_INTR_0_IMAGE_NOTIFY_PENDING               0x00000001 /* R---V */
#define NV_PME_INTR_0_IMAGE_NOTIFY_RESET                 0x00000001 /* -W--V */
#define NV_PME_INTR_0_VBI_NOTIFY                                4:4 /* RWIVF */
#define NV_PME_INTR_0_VBI_NOTIFY_NOT_PENDING             0x00000000 /* R-I-V */
#define NV_PME_INTR_0_VBI_NOTIFY_PENDING                 0x00000001 /* R---V */
#define NV_PME_INTR_0_VBI_NOTIFY_RESET                   0x00000001 /* -W--V */
#define NV_PME_INTR_0_VID_NOTIFY                                8:8 /* RWIVF */
#define NV_PME_INTR_0_VID_NOTIFY_NOT_PENDING             0x00000000 /* R-I-V */
#define NV_PME_INTR_0_VID_NOTIFY_PENDING                 0x00000001 /* R---V */
#define NV_PME_INTR_0_VID_NOTIFY_RESET                   0x00000001 /* -W--V */
#define NV_PME_INTR_0_AUD_NOTIFY                              12:12 /* RWIVF */
#define NV_PME_INTR_0_AUD_NOTIFY_NOT_PENDING             0x00000000 /* R-I-V */
#define NV_PME_INTR_0_AUD_NOTIFY_PENDING                 0x00000001 /* R---V */
#define NV_PME_INTR_0_AUD_NOTIFY_RESET                   0x00000001 /* -W--V */
#define NV_PME_INTR_0_VMI                                     16:16 /* RWIVF */
#define NV_PME_INTR_0_VMI_NOT_PENDING                    0x00000000 /* R-I-V */
#define NV_PME_INTR_0_VMI_PENDING                        0x00000001 /* R---V */
#define NV_PME_INTR_0_VMI_RESET                          0x00000001 /* -W--V */
#define NV_PME_INTR_EN_0                                 0x00200140 /* RWI4R */
#define NV_PME_INTR_EN_0_IMAGE_NOTIFY                           0:0 /* RWIVF */
#define NV_PME_INTR_EN_0_IMAGE_NOTIFY_DISABLED           0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_IMAGE_NOTIFY_ENABLED            0x00000001 /* RW--V */
#define NV_PME_INTR_EN_0_VBI_NOTIFY                             4:4 /* RWIVF */
#define NV_PME_INTR_EN_0_VBI_NOTIFY_DISABLED             0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_VBI_NOTIFY_ENABLED              0x00000001 /* RW--V */
#define NV_PME_INTR_EN_0_VID_NOTIFY                             8:8 /* RWIVF */
#define NV_PME_INTR_EN_0_VID_NOTIFY_DISABLED             0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_VID_NOTIFY_ENABLED              0x00000001 /* RW--V */
#define NV_PME_INTR_EN_0_AUD_NOTIFY                           12:12 /* RWIVF */
#define NV_PME_INTR_EN_0_AUD_NOTIFY_DISABLED             0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_AUD_NOTIFY_ENABLED              0x00000001 /* RW--V */
#define NV_PME_INTR_EN_0_VMI                                  16:16 /* RWIVF */
#define NV_PME_INTR_EN_0_VMI_DISABLED                    0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_VMI_ENABLED                     0x00000001 /* RW--V */
#define NV_PME_CONFIG_0                                  0x00200200 /* RWI4R */
#define NV_PME_CONFIG_0_BUS_MODE                                1:0 /* RWIVF */
#define NV_PME_CONFIG_0_BUS_MODE_DISABLED                0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_BUS_MODE_VMI                     0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_BUS_MODE_CCIR656                 0x00000002 /* RW--V */
#define NV_PME_CONFIG_0_IMAGE                                   4:4 /* RWIVF */
#define NV_PME_CONFIG_0_IMAGE_DISABLED                   0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_IMAGE_ENABLED                    0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_VBI_MODE                                9:8 /* RWIVF */
#define NV_PME_CONFIG_0_VBI_MODE_DISABLED                0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_VBI_MODE_1                       0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_VBI_MODE_2                       0x00000002 /* RW--V */
#define NV_PME_CONFIG_0_VID_CD                                12:12 /* RWIVF */
#define NV_PME_CONFIG_0_VID_CD_DISABLED                  0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_VID_CD_ENABLED                   0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_AUD_CD                                16:16 /* RWIVF */
#define NV_PME_CONFIG_0_AUD_CD_DISABLED                  0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_AUD_CD_ENABLED                   0x00000001 /* RW--V */
#define NV_PME_CONFIG_1                                  0x00200204 /* RWI4R */
#define NV_PME_CONFIG_1_BUFFS                                   0:0 /* RWIVF */
#define NV_PME_CONFIG_1_BUFFS_PNVM                       0x00000000 /* RWI-V */
#define NV_PME_CONFIG_1_BUFFS_SYS                        0x00000001 /* RW--V */
#define NV_PME_CONFIG_1_HOST                                    4:4 /* RWIVF */
#define NV_PME_CONFIG_1_HOST_PCI                         0x00000000 /* RWI-V */
#define NV_PME_CONFIG_1_HOST_AGP                         0x00000001 /* RW--V */
#define NV_PME_VID_BUFF0_START_SYS                       0x00200300 /* RWI4R */ 
#define NV_PME_VID_BUFF0_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_VID_BUFF1_START_SYS                       0x00200304 /* RWI4R */ 
#define NV_PME_VID_BUFF1_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_VID_BUFF0_START_PNVM                      0x00200308 /* RWI4R */ 
#define NV_PME_VID_BUFF0_START_PNVM_ADDRESS                    22:4 /* RWXUF */
#define NV_PME_VID_BUFF1_START_PNVM                      0x0020030c /* RWI4R */ 
#define NV_PME_VID_BUFF1_START_PNVM_ADDRESS                    22:4 /* RWXUF */
#define NV_PME_VID_BUFF0_LENGTH                          0x00200310 /* RWI4R */ 
#define NV_PME_VID_BUFF0_LENGTH_BITS                          15:12 /* RWXUF */
#define NV_PME_VID_BUFF1_LENGTH                          0x00200314 /* RWI4R */ 
#define NV_PME_VID_BUFF1_LENGTH_BITS                          15:12 /* RWXUF */
#define NV_PME_VID_ME_STATE                              0x00200318 /* RW-4R */
#define NV_PME_VID_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWIVF */
#define NV_PME_VID_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VID_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
#define NV_PME_VID_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
#define NV_PME_VID_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
#define NV_PME_VID_SU_STATE                              0x0020031c /* RW-4R */
#define NV_PME_VID_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VID_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VID_RM_STATE                              0x00200320 /* RW-4R */
#define NV_PME_VID_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_VID_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VID_RM_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_VID_RM_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_VID_CURRENT                               0x00200324 /* RWI4R */ 
#define NV_PME_VID_CURRENT_POS                                 15:2 /* RWXUF */
#define NV_PME_AUD_BUFF0_START_SYS                       0x00200340 /* RWI4R */ 
#define NV_PME_AUD_BUFF0_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_AUD_BUFF1_START_SYS                       0x00200344 /* RWI4R */ 
#define NV_PME_AUD_BUFF1_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_AUD_BUFF0_START_PNVM                      0x00200348 /* RWI4R */ 
#define NV_PME_AUD_BUFF0_START_PNVM_ADDRESS                    22:4 /* RWXUF */
#define NV_PME_AUD_BUFF1_START_PNVM                      0x0020034c /* RWI4R */ 
#define NV_PME_AUD_BUFF1_START_PNVM_ADDRESS                    22:4 /* RWXUF */
#define NV_PME_AUD_BUFF0_LENGTH                          0x00200350 /* RWI4R */ 
#define NV_PME_AUD_BUFF0_LENGTH_BITS                          12:10 /* RWXUF */
#define NV_PME_AUD_BUFF1_LENGTH                          0x00200354 /* RWI4R */ 
#define NV_PME_AUD_BUFF1_LENGTH_BITS                          12:10 /* RWXUF */
#define NV_PME_AUD_ME_STATE                              0x00200358 /* RW-4R */
#define NV_PME_AUD_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWIVF */
#define NV_PME_AUD_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_AUD_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
#define NV_PME_AUD_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
#define NV_PME_AUD_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
#define NV_PME_AUD_SU_STATE                              0x0020035c /* RW-4R */
#define NV_PME_AUD_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_AUD_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_AUD_RM_STATE                              0x00200360 /* RW-4R */
#define NV_PME_AUD_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_AUD_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_AUD_RM_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_AUD_RM_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_AUD_CURRENT                               0x00200364 /* RWI4R */ 
#define NV_PME_AUD_CURRENT_POS                                 12:2 /* RWXUF */
#define NV_PME_VBI_BUFF0_START                           0x00200380 /* RWI4R */ 
#define NV_PME_VBI_BUFF0_START_ADDRESS                         22:4 /* RWXUF */
#define NV_PME_VBI_BUFF1_START                           0x00200384 /* RWI4R */ 
#define NV_PME_VBI_BUFF1_START_ADDRESS                         22:4 /* RWXUF */
#define NV_PME_VBI_BUFF0_PITCH                           0x00200388 /* RWI4R */ 
#define NV_PME_VBI_BUFF0_PITCH_VALUE                           13:4 /* RWXUF */
#define NV_PME_VBI_BUFF1_PITCH                           0x0020038c /* RWI4R */ 
#define NV_PME_VBI_BUFF1_PITCH_VALUE                           13:4 /* RWXUF */
#define NV_PME_VBI_BUFF0_LENGTH                          0x00200390 /* RWI4R */ 
#define NV_PME_VBI_BUFF0_LENGTH_BITS                           19:4 /* RWXUF */
#define NV_PME_VBI_BUFF1_LENGTH                          0x00200394 /* RWI4R */ 
#define NV_PME_VBI_BUFF1_LENGTH_BITS                           19:4 /* RWXUF */
#define NV_PME_VBI_ME_STATE                              0x00200398 /* RW-4R */
#define NV_PME_VBI_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF0_ERROR_CODE                   10:8 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF1_ERROR_CODE                  14:12 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VBI_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
#define NV_PME_VBI_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
#define NV_PME_VBI_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
#define NV_PME_VBI_SU_STATE                              0x0020039c /* RW-4R */
#define NV_PME_VBI_SU_STATE_BUFF0_FIELD                         8:8 /* RWXVF */
#define NV_PME_VBI_SU_STATE_BUFF1_FIELD                       12:12 /* RWXVF */
#define NV_PME_VBI_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VBI_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VBI_RM_STATE                              0x002003a0 /* RW-4R */
#define NV_PME_VBI_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_VBI_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VBI                                       0x002003a4 /* RWI4R */
#define NV_PME_VBI_START_LINE                                   4:0 /* RWX-F */
#define NV_PME_VBI_NUM_LINES                                  20:16 /* RWX-F */
#define NV_PME_IMAGE_BUFF0_START                         0x00200400 /* RWI4R */ 
#define NV_PME_IMAGE_BUFF0_START_ADDRESS                       22:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF1_START                         0x00200404 /* RWI4R */ 
#define NV_PME_IMAGE_BUFF1_START_ADDRESS                       22:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF0_PITCH                         0x00200408 /* RWI4R */ 
#define NV_PME_IMAGE_BUFF0_PITCH_VALUE                         13:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF1_PITCH                         0x0020040c /* RWI4R */ 
#define NV_PME_IMAGE_BUFF1_PITCH_VALUE                         13:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF0_LENGTH                        0x00200410 /* RWI4R */ 
#define NV_PME_IMAGE_BUFF0_LENGTH_BITS                         19:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF1_LENGTH                        0x00200414 /* RWI4R */ 
#define NV_PME_IMAGE_BUFF1_LENGTH_BITS                         19:4 /* RWXUF */
#define NV_PME_IMAGE_ME_STATE                            0x00200418 /* RW-4R */
#define NV_PME_IMAGE_ME_STATE_BUFF0_INTR_NOTIFY                 0:0 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF1_INTR_NOTIFY                 4:4 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF0_ERROR_CODE                 10:8 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF1_ERROR_CODE                14:12 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF0_IN_USE                    16:16 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF1_IN_USE                    20:20 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER                  24:24 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER_0           0x00000000 /* RW--V */
#define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER_1           0x00000001 /* RW--V */
#define NV_PME_IMAGE_SU_STATE                            0x0020041c /* RW-4R */
#define NV_PME_IMAGE_SU_STATE_BUFF0_FIELD                       8:8 /* RWXVF */
#define NV_PME_IMAGE_SU_STATE_BUFF1_FIELD                     12:12 /* RWXVF */
#define NV_PME_IMAGE_SU_STATE_BUFF0_IN_USE                    16:16 /* RWXVF */
#define NV_PME_IMAGE_SU_STATE_BUFF1_IN_USE                    20:20 /* RWXVF */
#define NV_PME_IMAGE_RM_STATE                            0x00200420 /* RW-4R */
#define NV_PME_IMAGE_RM_STATE_BUFF0_INTR_NOTIFY                 0:0 /* RWXVF */
#define NV_PME_IMAGE_RM_STATE_BUFF1_INTR_NOTIFY                 4:4 /* RWXVF */
#define NV_PME_IMAGE_BUFF0_SCALE_INCR                    0x00200424 /* RW-4R */
#define NV_PME_IMAGE_BUFF0_SCALE_INCR_Y                       26:16 /* RWXVF */
#define NV_PME_IMAGE_BUFF0_SCALE_INCR_X                        10:0 /* RWXVF */
#define NV_PME_IMAGE_BUFF1_SCALE_INCR                    0x00200428 /* RW-4R */
#define NV_PME_IMAGE_BUFF1_SCALE_INCR_Y                       26:16 /* RWXVF */
#define NV_PME_IMAGE_BUFF1_SCALE_INCR_X                        10:0 /* RWXVF */
#define NV_PME_IMAGE_Y_CROP                              0x0020042c /* RW-4R */
#define NV_PME_IMAGE_Y_CROP_STARTLINE                           8:0 /* RWXVF */
#define NV_PME_FIFO_LINE_START                           0x00200480 /* R--4R */
#define NV_PME_FIFO_LINE_START_ADDRESS                         20:4 /* R-XVF */
#define NV_PME_FIFO_CURRENT                              0x00200484 /* RWI4R */
#define NV_PME_FIFO_CURRENT_ADDRESS                            20:2 /* RWXVF */
#define NV_PME_VMI_POLL                                  0x00200488 /* R--4R */
#define NV_PME_VMI_POLL_UNCD                                    0:0 /* R-IVF */
#define NV_PME_VMI_POLL_UNCD_NOT_PENDING                 0x00000000 /* R-IVF */
#define NV_PME_VMI_POLL_UNCD_PENDING                     0x00000001 /* R--VF */
#define NV_PME_VMI_POLL_VIDCD                                   1:1 /* R-IVF */
#define NV_PME_VMI_POLL_VIDCD_NOT_PENDING                0x00000000 /* R-IVF */
#define NV_PME_VMI_POLL_VIDCD_PENDING                    0x00000001 /* R--VF */
#define NV_PME_VMI_POLL_AUDCD                                   2:2 /* R-IVF */
#define NV_PME_VMI_POLL_AUDCD_NOT_PENDING                0x00000000 /* R-IVF */
#define NV_PME_VMI_POLL_AUDCD_PENDING                    0x00000001 /* R--VF */
#define NV_PME_VMI_POLL_INT                                     3:3 /* R-IVF */
#define NV_PME_VMI_POLL_INT_NOT_PENDING                  0x00000000 /* R-IVF */
#define NV_PME_VMI_POLL_INT_PENDING                      0x00000001 /* R--VF */
#define NV_PME_VMI_POLL_CPURDREC                                4:4 /* R-IVF */
#define NV_PME_VMI_POLL_CPURDREC_NOT_PENDING             0x00000000 /* R-IVF */
#define NV_PME_VMI_POLL_CPURDREC_PENDING                 0x00000001 /* R--VF */
#define NV_PME_EXTERNAL(i)                       (0x00200600+(i)*4) /* RW-4A */
#define NV_PME_EXTERNAL_SIZE_1                                  256 /*       */  
#define NV_PME_EXTERNAL_DATA                                    7:0 /* RWXVF */
/* usr_beta_solid.ref */
#define NV_UBETA                              0x00411FFF:0x00410000 /* -W--D */
#define NV_UBETA_CTX_SWITCH                              0x00410000 /* -W-4R */
#define NV_UBETA_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UBETA_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UBETA_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UBETA_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UBETA_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UBETA_SET_NOTIFY                              0x00410104 /* -W-4R */
#define NV_UBETA_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UBETA_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UBETA_SET_BETA1D31                            0x00410300 /* -W-4R */
#define NV_UBETA_SET_BETA1D31_VALUE_FRACTION                  30:21 /* -W-UF */
#define NV_UBETA_SET_BETA1D31_VALUE                           31:31 /* -W-SF */
/* usr_rop_solid.ref */
#define NV_UROP                               0x00421FFF:0x00420000 /* -W--D */
#define NV_UROP_CTX_SWITCH                               0x00420000 /* -W-4R */
#define NV_UROP_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
#define NV_UROP_CTX_SWITCH_CHID                               22:16 /* -W-UF */
#define NV_UROP_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
#define NV_UROP_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
#define NV_UROP_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
#define NV_UROP_SET_NOTIFY                               0x00420104 /* -W-4R */
#define NV_UROP_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
#define NV_UROP_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
#define NV_UROP_SET_ROP                                  0x00420300 /* -W-4R */
#define NV_UROP_SET_ROP_VALUE                                   7:0 /* -W-VF */
/* usr_color_key.ref */
#define NV_UCHROMA                            0x00431FFF:0x00430000 /* -W--D */
#define NV_UCHROMA_CTX_SWITCH                            0x00430000 /* -W-4R */
#define NV_UCHROMA_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_UCHROMA_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_UCHROMA_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_UCHROMA_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_UCHROMA_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_UCHROMA_SET_NOTIFY                            0x00430104 /* -W-4R */
#define NV_UCHROMA_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UCHROMA_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UCHROMA_SET_COLOR                             0x00430304 /* -W-4R */
#define NV_UCHROMA_SET_COLOR_VALUE                             31:0 /* -W-VF */
/* usr_plane_switch.ref */
#define NV_UPLANE                             0x00441FFF:0x00440000 /* -W--D */
#define NV_UPLANE_CTX_SWITCH                             0x00440000 /* -W-4R */
#define NV_UPLANE_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UPLANE_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UPLANE_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UPLANE_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UPLANE_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UPLANE_SET_NOTIFY                             0x00440104 /* -W-4R */
#define NV_UPLANE_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UPLANE_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UPLANE_SET_COLOR                              0x00440304 /* -W-4R */
#define NV_UPLANE_SET_COLOR_VALUE                              31:0 /* -W-VF */
/* usr_clipping.ref */
#define NV_UCLIP                              0x00451FFF:0x00450000 /* -W--D */
#define NV_UCLIP_CTX_SWITCH                              0x00450000 /* -W-4R */
#define NV_UCLIP_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UCLIP_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UCLIP_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UCLIP_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UCLIP_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UCLIP_SET_NOTIFY                              0x00450104 /* -W-4R */
#define NV_UCLIP_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UCLIP_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UCLIP_SET_RECT_0                              0x00450300 /* -W-4R */
#define NV_UCLIP_SET_RECT_0_X                                  15:0 /* -W-SF */
#define NV_UCLIP_SET_RECT_0_Y                                 31:16 /* -W-SF */
#define NV_UCLIP_SET_RECT_1                              0x00450304 /* -W-4R */
#define NV_UCLIP_SET_RECT_1_WIDTH                              15:0 /* -W-UF */
#define NV_UCLIP_SET_RECT_1_HEIGHT                            31:16 /* -W-UF */
/* usr_d3d0_triangle_zeta.ref */
#define NV_UD3D0Z                             0x00571FFF:0x00570000 /* -W--D */
#define NV_UD3D0Z_CTX_SWITCH                             0x00570000 /* -W-4R */
#define NV_UD3D0Z_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UD3D0Z_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UD3D0Z_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UD3D0Z_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UD3D0Z_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UD3D0Z_SET_NOTIFY                             0x00570104 /* -W-4R */
#define NV_UD3D0Z_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UD3D0Z_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UD3D0Z_TEXTURE_OFFSET                         0x00570304 /* -W-4R */
#define NV_UD3D0Z_TEXTURE_OFFSET_VALUE                         31:0 /* -W-UF */
#define NV_UD3D0Z_TEXTURE_FORMAT                         0x00570308 /* -W-4R */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY_COLOR_MASK          15:0 /* -W-UF */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY                    16:16 /* -W-UF */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY_DISABLED      0x00000000 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_KEY_ENABLED       0x00000001 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT                 21:20 /* -W-UF */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_A1R5G5B5   0x00000000 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_X1R5G5B5   0x00000001 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_A4R4G4B4   0x00000002 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_COLOR_FORMAT_R5G6B5     0x00000003 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN                     27:24 /* -W-UF */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_1X1            0x00000000 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_2X2            0x00000001 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_4X4            0x00000002 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_8X8            0x00000003 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_16X16          0x00000004 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_32X32          0x00000005 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_64X64          0x00000006 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_128X128        0x00000007 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_256X256        0x00000008 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_512X512        0x00000009 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_1024X1024      0x0000000a /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MIN_2048X2048      0x0000000b /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX                     31:28 /* -W-UF */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_1X1            0x00000000 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_2X2            0x00000001 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_4X4            0x00000002 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_8X8            0x00000003 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_16X16          0x00000004 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_32X32          0x00000005 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_64X64          0x00000006 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_128X128        0x00000007 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_256X256        0x00000008 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_512X512        0x00000009 /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_1024X1024      0x0000000a /* -W-UV */
#define NV_UD3D0Z_TEXTURE_FORMAT_SIZE_MAX_2048X2048      0x0000000b /* -W-UV */
#define NV_UD3D0Z_FILTER                                 0x0057030C /* -W-4R */
#define NV_UD3D0Z_FILTER_SPREADX                                7:0 /* -W-UF */
#define NV_UD3D0Z_FILTER_SPREADY                               15:8 /* -W-UF */
#define NV_UD3D0Z_FILTER_MIPMAP                               23:16 /* -W-SF */
#define NV_UD3D0Z_FILTER_TURBO                                31:24 /* -W-SF */
#define NV_UD3D0Z_FOG_COLOR                              0x00570310 /* -W-4R */
#define NV_UD3D0Z_FOG_COLOR_BLU                                 7:0 /* -W-UF */
#define NV_UD3D0Z_FOG_COLOR_GRN                                15:8 /* -W-UF */
#define NV_UD3D0Z_FOG_COLOR_RED                               23:16 /* -W-UF */
#define NV_UD3D0Z_FOG_COLOR_VALUE                              31:0 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT                            0x00570314 /* -W-4R */
#define NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR                      1:0 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR_ZOH           0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR_ZOH_MS        0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_INTERPOLATOR_FOH           0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_U                            5:4 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_U_CYLINDRICAL         0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_U_WRAP                0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_U_MIRROR              0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_U_CLAMP               0x00000003 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_V                            7:6 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_V_CYLINDRICAL         0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_V_WRAP                0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_V_MIRROR              0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_WRAP_V_CLAMP               0x00000003 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_FORMAT                      8:8 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_FORMAT_LE_X8R8G8B8   0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_FORMAT_LE_A8R8G8B8   0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_SRCCOLOR                        11:10 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_SRCCOLOR_NORMAL            0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_SRCCOLOR_COLOR_INVERSE     0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_SRCCOLOR_ALPHA_INVERSE     0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_SRCCOLOR_ALPHA_ONE         0x00000003 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_CULLING                         13:12 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_CULLING_NONE               0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_CULLING_CLOCKWISE          0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_CULLING_COUNTERCLOCKWISE   0x00000003 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZBUFFER                         15:15 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_ZBUFFER_SCREEN             0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZBUFFER_LINEAR             0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE                    19:16 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_FALSE         0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_LT            0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_EQ            0x00000003 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_LE            0x00000004 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_GT            0x00000005 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_NE            0x00000006 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_GE            0x00000007 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_COMPARE_TRUE          0x00000008 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE                      22:20 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_NEVER           0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ALPHA           0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA      0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ZETA            0x00000003 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ZETA_WRITE_ALWAYS          0x00000004 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE                     26:24 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_NEVER          0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_ALPHA          0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA     0x00000002 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_ZETA           0x00000003 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_COLOR_WRITE_ALWAYS         0x00000004 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ROP                             28:28 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_ROP_BLEND_AND              0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_ROP_ADD_WITH_SATURATION    0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_BLEND_BETA                      29:29 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_BLEND_BETA_SRCALPHA        0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_BLEND_BETA_DESTCOLOR       0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_BLEND_INPUT0                    30:30 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_BLEND_INPUT0_DESTCOLOR     0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_BLEND_INPUT0_ZERO          0x00000001 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_BLEND_INPUT1                    31:31 /* -W-UF */
#define NV_UD3D0Z_CONTROL_OUT_BLEND_INPUT1_SRCCOLOR      0x00000000 /* -W-UV */
#define NV_UD3D0Z_CONTROL_OUT_BLEND_INPUT1_ZERO          0x00000001 /* -W-UV */
#define NV_UD3D0Z_ALPHA_CONTROL                          0x00570318 /* -W-4R */
#define NV_UD3D0Z_ALPHA_CONTROL_ALPHA_KEY                       7:0 /* -WXUF */
#define NV_UD3D0Z_ALPHA_CONTROL_ALPHA_COMPARE                  11:8 /* -WIUF */
#define NV_UD3D0Z_ALPHA_CONTROL_ALPHA_COMPARE_ILLEGAL    0x00000000 /* -W-UV */
#define NV_UD3D0Z_ALPHA_CONTROL_ALPHA_COMPARE_FALSE      0x00000001 /* -W-UV */
#define NV_UD3D0Z_ALPHA_CONTROL_ALPHA_COMPARE_LT         0x00000002 /* -W-UV */
#define NV_UD3D0Z_ALPHA_CONTROL_ALPHA_COMPARE_EQ         0x00000003 /* -W-UV */
#define NV_UD3D0Z_ALPHA_CONTROL_ALPHA_COMPARE_LE         0x00000004 /* -W-UV */
#define NV_UD3D0Z_ALPHA_CONTROL_ALPHA_COMPARE_GT         0x00000005 /* -W-UV */
#define NV_UD3D0Z_ALPHA_CONTROL_ALPHA_COMPARE_NE         0x00000006 /* -W-UV */
#define NV_UD3D0Z_ALPHA_CONTROL_ALPHA_COMPARE_GE         0x00000007 /* -W-UV */
#define NV_UD3D0Z_ALPHA_CONTROL_ALPHA_COMPARE_TRUE       0x00000008 /* -WIUV */
#define NV_UD3D0Z_SPECULAR(i)                   (0x00571000+(i)*32) /* -W-4A */
#define NV_UD3D0Z_SPECULAR__SIZE_1                              128 /*       */
#define NV_UD3D0Z_SPECULAR_I0                                   3:0 /* -W-UF */
#define NV_UD3D0Z_SPECULAR_I1                                   7:4 /* -W-UF */
#define NV_UD3D0Z_SPECULAR_I2                                  11:8 /* -W-UF */
#define NV_UD3D0Z_SPECULAR_I3                                 15:12 /* -W-UF */
#define NV_UD3D0Z_SPECULAR_I4                                 19:16 /* -W-UF */
#define NV_UD3D0Z_SPECULAR_I5                                 23:20 /* -W-UF */
#define NV_UD3D0Z_SPECULAR_FOG                                31:24 /* -W-UF */
#define NV_UD3D0Z_COLOR(i)                      (0x00571004+(i)*32) /* -W-4A */
#define NV_UD3D0Z_COLOR__SIZE_1                                 128 /*       */
#define NV_UD3D0Z_COLOR_B8                                      7:0 /* -W-UF */
#define NV_UD3D0Z_COLOR_G8                                     16:8 /* -W-UF */
#define NV_UD3D0Z_COLOR_R8                                    23:16 /* -W-UF */
#define NV_UD3D0Z_COLOR_A8                                    32:24 /* -W-UF */
#define NV_UD3D0Z_X(i)                          (0x00571008+(i)*32) /* -W-4A */
#define NV_UD3D0Z_X__SIZE_1                                     128 /*       */
#define NV_UD3D0Z_X_VALUE                                      31:0 /* -W-FF */
#define NV_UD3D0Z_Y(i)                          (0x0057100C+(i)*32) /* -W-4A */
#define NV_UD3D0Z_Y__SIZE_1                                     128 /*       */
#define NV_UD3D0Z_Y_VALUE                                      31:0 /* -W-FF */
#define NV_UD3D0Z_Z(i)                          (0x00571010+(i)*32) /* -W-4A */
#define NV_UD3D0Z_Z__SIZE_1                                     128 /*       */
#define NV_UD3D0Z_Z_VALUE                                      31:0 /* -W-FF */
#define NV_UD3D0Z_M(i)                          (0x00571014+(i)*32) /* -W-4A */
#define NV_UD3D0Z_M__SIZE_1                                     128 /*       */
#define NV_UD3D0Z_M_VALUE                                      31:0 /* -W-FF */
#define NV_UD3D0Z_U(i)                          (0x00571018+(i)*32) /* -W-4A */
#define NV_UD3D0Z_U__SIZE_1                                     128 /*       */
#define NV_UD3D0Z_U_VALUE                                      31:0 /* -W-FF */
#define NV_UD3D0Z_V(i)                          (0x0057101c+(i)*32) /* -W-4A */
#define NV_UD3D0Z_V__SIZE_1                                     128 /*       */
#define NV_UD3D0Z_V_VALUE                                      31:0 /* -W-FF */
/* usr_pattern.ref */
#define NV_UPATT                              0x00461FFF:0x00460000 /* -W--D */
#define NV_UPATT_CTX_SWITCH                              0x00460000 /* -W-4R */
#define NV_UPATT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UPATT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UPATT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UPATT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UPATT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UPATT_SET_NOTIFY                              0x00460104 /* -W-4R */
#define NV_UPATT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UPATT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UPATT_SET_SHAPE                               0x00460308 /* -W-4R */
#define NV_UPATT_SET_SHAPE_VALUE                                1:0 /* -W-VF */
#define NV_UPATT_SET_SHAPE_VALUE_8X8                     0x00000000 /* -W--V */
#define NV_UPATT_SET_SHAPE_VALUE_64X1                    0x00000001 /* -W--V */
#define NV_UPATT_SET_SHAPE_VALUE_1X64                    0x00000002 /* -W--V */
#define NV_UPATT_SET_COLOR0                              0x00460310 /* -W-4R */
#define NV_UPATT_SET_COLOR0_VALUE                              31:0 /* -W-VF */
#define NV_UPATT_SET_COLOR1                              0x00460314 /* -W-4R */
#define NV_UPATT_SET_COLOR1_VALUE                              31:0 /* -W-VF */
#define NV_UPATT_SET_PATTERN(i)                  (0x00460318+(i)*4) /* -W-4A */
#define NV_UPATT_SET_PATTERN__SIZE_1                              2 /*       */
#define NV_UPATT_SET_PATTERN_BITMAP                            31:0 /* -W-VF */
/* usr_point.ref */
#define NV_UPOINT                             0x00481FFF:0x00480000 /* -W--D */
#define NV_UPOINT_CTX_SWITCH                             0x00480000 /* -W-4R */
#define NV_UPOINT_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UPOINT_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UPOINT_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UPOINT_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UPOINT_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UPOINT_SET_NOTIFY                             0x00480104 /* -W-4R */
#define NV_UPOINT_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UPOINT_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UPOINT_COLOR                                  0x00480304 /* -W-4R */
#define NV_UPOINT_COLOR_VALUE                                  31:0 /* -W-VF */
#define NV_UPOINT_POINT(i)                       (0x00480400+(i)*4) /* -W-4A */
#define NV_UPOINT_POINT__SIZE_1                                  32 /*       */
#define NV_UPOINT_POINT_X                                      15:0 /* -W-SF */
#define NV_UPOINT_POINT_Y                                     31:16 /* -W-SF */
#define NV_UPOINT_POINT32_0(i)                   (0x00480480+(i)*8) /* -W-4A */
#define NV_UPOINT_POINT32_0__SIZE_1                              16 /*       */
#define NV_UPOINT_POINT32_0_X                                  31:0 /* -W-SF */
#define NV_UPOINT_POINT32_1(i)                   (0x00480484+(i)*8) /* -W-4A */
#define NV_UPOINT_POINT32_1__SIZE_1                              16 /*       */
#define NV_UPOINT_POINT32_1_Y                                  31:0 /* -W-SF */
#define NV_UPOINT_CPOINT_0(i)                    (0x00480500+(i)*8) /* -W-4A */
#define NV_UPOINT_CPOINT_0__SIZE_1                               16 /*       */
#define NV_UPOINT_CPOINT_0_COLOR                               31:0 /* -W-VF */
#define NV_UPOINT_CPOINT_1(i)                    (0x00480504+(i)*8) /* -W-4A */
#define NV_UPOINT_CPOINT_1__SIZE_1                               16 /*       */
#define NV_UPOINT_CPOINT_1_X                                   15:0 /* -W-SF */
#define NV_UPOINT_CPOINT_1_Y                                  31:16 /* -W-SF */
/* usr_pointz.ref */
#define NV_UPOINTZ                            0x00581FFF:0x00580000 /* -W--D */
#define NV_UPOINTZ_CTX_SWITCH                            0x00580000 /* -W-4R */
#define NV_UPOINTZ_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_UPOINTZ_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_UPOINTZ_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_UPOINTZ_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_UPOINTZ_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_UPOINTZ_SET_NOTIFY                            0x00580104 /* -W-4R */
#define NV_UPOINTZ_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UPOINTZ_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UPOINTZ_CONTROL_OUT                           0x00580304 /* -W-4R */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE                   19:16 /* -W-UF */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_FALSE        0x00000001 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_LT           0x00000002 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_EQ           0x00000003 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_LE           0x00000004 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_GT           0x00000005 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_NE           0x00000006 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_GE           0x00000007 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_COMPARE_TRUE         0x00000008 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE                     22:20 /* -W-UF */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_NEVER          0x00000000 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ALPHA          0x00000001 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA     0x00000002 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ZETA           0x00000003 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ZETA_WRITE_ALWAYS         0x00000004 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE                    26:24 /* -W-UF */
#define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_NEVER         0x00000000 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_ALPHA         0x00000001 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA    0x00000002 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_ZETA          0x00000003 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_COLOR_WRITE_ALWAYS        0x00000004 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ROP                            28:28 /* -W-UF */
#define NV_UPOINTZ_CONTROL_OUT_ROP_BLEND_AND             0x00000000 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_ROP_ADD_WITH_SATURATION   0x00000001 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_BLEND_BETA                     29:29 /* -W-UF */
#define NV_UPOINTZ_CONTROL_OUT_BLEND_BETA_SRCALPHA       0x00000000 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_BLEND_BETA_DESTCOLOR      0x00000001 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_BLEND_INPUT0                   30:30 /* -W-UF */
#define NV_UPOINTZ_CONTROL_OUT_BLEND_INPUT0_DESTCOLOR    0x00000000 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_BLEND_INPUT0_ZERO         0x00000001 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_BLEND_INPUT1                   31:31 /* -W-UF */
#define NV_UPOINTZ_CONTROL_OUT_BLEND_INPUT1_SRCCOLOR     0x00000000 /* -W-UV */
#define NV_UPOINTZ_CONTROL_OUT_BLEND_INPUT1_ZERO         0x00000001 /* -W-UV */
#define NV_UPOINTZ_ALPHA_CONTROL                         0x00580308 /* -W-4R */
#define NV_UPOINTZ_ALPHA_CONTROL_ALPHA_KEY                      7:0 /* -WXVF */
#define NV_UPOINTZ_ALPHA_CONTROL_ALPHA_COMPARE                 11:8 /* -WIUF */
#define NV_UPOINTZ_ALPHA_CONTROL_ALPHA_COMPARE_ILLEGAL   0x00000000 /* -W-UV */
#define NV_UPOINTZ_ALPHA_CONTROL_ALPHA_COMPARE_FALSE     0x00000001 /* -W-UV */
#define NV_UPOINTZ_ALPHA_CONTROL_ALPHA_COMPARE_LT        0x00000002 /* -W-UV */
#define NV_UPOINTZ_ALPHA_CONTROL_ALPHA_COMPARE_EQ        0x00000003 /* -W-UV */
#define NV_UPOINTZ_ALPHA_CONTROL_ALPHA_COMPARE_LE        0x00000004 /* -W-UV */
#define NV_UPOINTZ_ALPHA_CONTROL_ALPHA_COMPARE_GT        0x00000005 /* -W-UV */
#define NV_UPOINTZ_ALPHA_CONTROL_ALPHA_COMPARE_NE        0x00000006 /* -W-UV */
#define NV_UPOINTZ_ALPHA_CONTROL_ALPHA_COMPARE_GE        0x00000007 /* -W-UV */
#define NV_UPOINTZ_ALPHA_CONTROL_ALPHA_COMPARE_TRUE      0x00000008 /* -WIUV */
#define NV_UPOINTZ_POINT                                 0x005807FC /* -W-4R */
#define NV_UPOINTZ_POINT_X                                     15:0 /* -W-SF */
#define NV_UPOINTZ_POINT_Y                                    31:16 /* -W-SF */
#define NV_UPOINTZ_COLOR(i)                      (0x00580800+(i)*8) /* -W-4A */
#define NV_UPOINTZ_COLOR__SIZE_1                                256 /*       */
#define NV_UPOINTZ_COLOR_VALUE                                 31:0 /* -W-VF */
#define NV_UPOINTZ_ZETA(i)                       (0x00580804+(i)*8) /* -W-4A */
#define NV_UPOINTZ_ZETA__SIZE_1                                 256 /*       */
#define NV_UPOINTZ_ZETA_VALUE                                  31:0 /* -W-VF */
/* usr_line.ref */
#define NV_ULINE                              0x00491FFF:0x00490000 /* -W--D */
#define NV_ULINE_CTX_SWITCH                              0x00490000 /* -W-4R */
#define NV_ULINE_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_ULINE_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_ULINE_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_ULINE_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_ULINE_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_ULINE_SET_NOTIFY                              0x00490104 /* -W-4R */
#define NV_ULINE_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_ULINE_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_ULINE_COLOR                                   0x00490304 /* -W-4R */
#define NV_ULINE_COLOR_VALUE                                   31:0 /* -W-VF */
#define NV_ULINE_LINE_0(i)                       (0x00490400+(i)*8) /* -W-4A */
#define NV_ULINE_LINE_0__SIZE_1                                  16 /*       */
#define NV_ULINE_LINE_0_X                                      15:0 /* -W-SF */
#define NV_ULINE_LINE_0_Y                                     31:16 /* -W-SF */
#define NV_ULINE_LINE_1(i)                       (0x00490404+(i)*8) /* -W-4A */
#define NV_ULINE_LINE_1__SIZE_1                                  16 /*       */
#define NV_ULINE_LINE_1_X                                      15:0 /* -W-SF */
#define NV_ULINE_LINE_1_Y                                     31:16 /* -W-SF */
#define NV_ULINE_LINE32_0(i)                    (0x00490480+(i)*16) /* -W-4A */
#define NV_ULINE_LINE32_0__SIZE_1                                 8 /*       */
#define NV_ULINE_LINE32_0_X                                    31:0 /* -W-SF */
#define NV_ULINE_LINE32_1(i)                    (0x00490484+(i)*16) /* -W-4A */
#define NV_ULINE_LINE32_1__SIZE_1                                 8 /*       */
#define NV_ULINE_LINE32_1_Y                                    31:0 /* -W-SF */
#define NV_ULINE_LINE32_2(i)                    (0x00490488+(i)*16) /* -W-4A */
#define NV_ULINE_LINE32_2__SIZE_1                                 8 /*       */
#define NV_ULINE_LINE32_2_X                                    31:0 /* -W-SF */
#define NV_ULINE_LINE32_3(i)                    (0x0049048C+(i)*16) /* -W-4A */
#define NV_ULINE_LINE32_3__SIZE_1                                 8 /*       */
#define NV_ULINE_LINE32_3_Y                                    31:0 /* -W-SF */
#define NV_ULINE_POLYLINE(i)                     (0x00490500+(i)*4) /* -W-4A */
#define NV_ULINE_POLYLINE__SIZE_1                                32 /*       */
#define NV_ULINE_POLYLINE_X                                    15:0 /* -W-SF */
#define NV_ULINE_POLYLINE_Y                                   31:16 /* -W-SF */
#define NV_ULINE_POLYLINE32_0(i)                 (0x00490580+(i)*8) /* -W-4A */
#define NV_ULINE_POLYLINE32_0__SIZE_1                            16 /*       */
#define NV_ULINE_POLYLINE32_0_X                                31:0 /* -W-SF */
#define NV_ULINE_POLYLINE32_1(i)                 (0x00490584+(i)*8) /* -W-4A */
#define NV_ULINE_POLYLINE32_1__SIZE_1                            16 /*       */
#define NV_ULINE_POLYLINE32_1_Y                                31:0 /* -W-SF */
#define NV_ULINE_CPOLYLINE_0(i)                  (0x00490600+(i)*8) /* -W-4A */
#define NV_ULINE_CPOLYLINE_0__SIZE_1                             16 /*       */
#define NV_ULINE_CPOLYLINE_0_COLOR                             31:0 /* -W-VF */
#define NV_ULINE_CPOLYLINE_1(i)                  (0x00490604+(i)*8) /* -W-4A */
#define NV_ULINE_CPOLYLINE_1__SIZE_1                             16 /*       */
#define NV_ULINE_CPOLYLINE_1_X                                 15:0 /* -W-SF */
#define NV_ULINE_CPOLYLINE_1_Y                                31:16 /* -W-SF */
/* usr_lin.ref */
#define NV_ULIN                               0x004A1FFF:0x004A0000 /* -W--D */
#define NV_ULIN_CTX_SWITCH                               0x004A0000 /* -W-4R */
#define NV_ULIN_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
#define NV_ULIN_CTX_SWITCH_CHID                               22:16 /* -W-UF */
#define NV_ULIN_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
#define NV_ULIN_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
#define NV_ULIN_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
#define NV_ULIN_SET_NOTIFY                               0x004A0104 /* -W-4R */
#define NV_ULIN_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
#define NV_ULIN_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
#define NV_ULIN_COLOR                                    0x004A0304 /* -W-4R */
#define NV_ULIN_COLOR_VALUE                                    31:0 /* -W-VF */
#define NV_ULIN_LIN_0(i)                         (0x004A0400+(i)*8) /* -W-4A */
#define NV_ULIN_LIN_0__SIZE_1                                    16 /*       */
#define NV_ULIN_LIN_0_X                                        15:0 /* -W-SF */
#define NV_ULIN_LIN_0_Y                                       31:16 /* -W-SF */
#define NV_ULIN_LIN_1(i)                         (0x004A0404+(i)*8) /* -W-4A */
#define NV_ULIN_LIN_1__SIZE_1                                    16 /*       */
#define NV_ULIN_LIN_1_X                                        15:0 /* -W-SF */
#define NV_ULIN_LIN_1_Y                                       31:16 /* -W-SF */
#define NV_ULIN_LIN32_0(i)                      (0x004A0480+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_0__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_0_X                                      31:0 /* -W-SF */
#define NV_ULIN_LIN32_1(i)                      (0x004A0484+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_1__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_1_Y                                      31:0 /* -W-SF */
#define NV_ULIN_LIN32_2(i)                      (0x004A0488+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_2__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_2_X                                      31:0 /* -W-SF */
#define NV_ULIN_LIN32_3(i)                      (0x004A048C+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_3__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_3_Y                                      31:0 /* -W-SF */
#define NV_ULIN_POLYLIN(i)                       (0x004A0500+(i)*4) /* -W-4A */
#define NV_ULIN_POLYLIN__SIZE_1                                  32 /*       */
#define NV_ULIN_POLYLIN_X                                      15:0 /* -W-SF */
#define NV_ULIN_POLYLIN_Y                                     31:16 /* -W-SF */
#define NV_ULIN_POLYLIN32_0(i)                   (0x004A0580+(i)*8) /* -W-4A */
#define NV_ULIN_POLYLIN32_0__SIZE_1                              16 /*       */
#define NV_ULIN_POLYLIN32_0_X                                  31:0 /* -W-SF */
#define NV_ULIN_POLYLIN32_1(i)                   (0x004A0584+(i)*8) /* -W-4A */
#define NV_ULIN_POLYLIN32_1__SIZE_1                              16 /*       */
#define NV_ULIN_POLYLIN32_1_Y                                  31:0 /* -W-SF */
#define NV_ULIN_CPOLYLIN_0(i)                    (0x004A0600+(i)*8) /* -W-4A */
#define NV_ULIN_CPOLYLIN_0__SIZE_1                               16 /*       */
#define NV_ULIN_CPOLYLIN_0_COLOR                               31:0 /* -W-VF */
#define NV_ULIN_CPOLYLIN_1(i)                    (0x004A0604+(i)*8) /* -W-4A */
#define NV_ULIN_CPOLYLIN_1__SIZE_1                               16 /*       */
#define NV_ULIN_CPOLYLIN_1_X                                   15:0 /* -W-SF */
#define NV_ULIN_CPOLYLIN_1_Y                                  31:16 /* -W-SF */
/* usr_mem_to_mem.ref */
#define NV_UMEMFMT                            0x004D1FFF:0x004D0000 /* -W--D */
#define NV_UMEMFMT_CTX_SWITCH                            0x004D0000 /* -W-4R */
#define NV_UMEMFMT_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_UMEMFMT_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_UMEMFMT_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_UMEMFMT_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_UMEMFMT_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_UMEMFMT_SET_NOTIFY                            0x004D0104 /* -W-4R */
#define NV_UMEMFMT_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UMEMFMT_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UMEMFMT_OFFSET_IN                             0x004D030C /* -W-4R */
#define NV_UMEMFMT_OFFSET_IN_VALUE                             31:0 /* -W-UF */
#define NV_UMEMFMT_OFFSET_OUT                            0x004D0310 /* -W-4R */
#define NV_UMEMFMT_OFFSET_OUT_VALUE                            31:0 /* -W-UF */
#define NV_UMEMFMT_PITCH_IN                              0x004D0314 /* -W-4R */
#define NV_UMEMFMT_PITCH_IN_VALUE                              31:0 /* -W-SF */
#define NV_UMEMFMT_PITCH_OUT                             0x004D0318 /* -W-4R */
#define NV_UMEMFMT_PITCH_OUT_VALUE                             31:0 /* -W-SF */
#define NV_UMEMFMT_LINE_LENGTH_IN                        0x004D031C /* -W-4R */
#define NV_UMEMFMT_LINE_LENGTH_IN_VALUE                        31:0 /* -W-UF */
#define NV_UMEMFMT_LINE_COUNT                            0x004D0320 /* -W-4R */
#define NV_UMEMFMT_LINE_COUNT_VALUE                            31:0 /* -W-UF */
#define NV_UMEMFMT_FORMAT                                0x004D0324 /* -W-4R */
#define NV_UMEMFMT_FORMAT_INPUT_INC                             2:0 /* -W-UF */
#define NV_UMEMFMT_FORMAT_INPUT_INC_1                    0x00000001 /* -WIUV */
#define NV_UMEMFMT_FORMAT_INPUT_INC_2                    0x00000002 /* -W-UV */
#define NV_UMEMFMT_FORMAT_INPUT_INC_4                    0x00000004 /* -W-UV */
#define NV_UMEMFMT_FORMAT_OUTPUT_INC                           10:8 /* -W-UF */
#define NV_UMEMFMT_FORMAT_OUTPUT_INC_1                   0x00000001 /* -WIUV */
#define NV_UMEMFMT_FORMAT_OUTPUT_INC_2                   0x00000002 /* -W-UV */
#define NV_UMEMFMT_FORMAT_OUTPUT_INC_4                   0x00000004 /* -W-UV */
#define NV_UMEMFMT_BUF_NOTIFY                            0x004D0328 /* -W-4R */
#define NV_UMEMFMT_BUF_NOTIFY_VALUE                            31:0 /* -W-UF */
/* usr_triangle.ref */
#define NV_UTRI                               0x004B1FFF:0x004B0000 /* -W--D */
#define NV_UTRI_CTX_SWITCH                               0x004B0000 /* -W-4R */
#define NV_UTRI_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
#define NV_UTRI_CTX_SWITCH_CHID                               22:16 /* -W-UF */
#define NV_UTRI_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
#define NV_UTRI_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
#define NV_UTRI_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
#define NV_UTRI_SET_NOTIFY                               0x004B0104 /* -W-4R */
#define NV_UTRI_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
#define NV_UTRI_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
#define NV_UTRI_COLOR                                    0x004B0304 /* -W-4R */
#define NV_UTRI_COLOR_VALUE                                    31:0 /* -W-VF */
#define NV_UTRI_TRIANGLE_0                               0x004B0310 /* -W-4R */
#define NV_UTRI_TRIANGLE_0_X                                   15:0 /* -W-SF */
#define NV_UTRI_TRIANGLE_0_Y                                  31:16 /* -W-SF */
#define NV_UTRI_TRIANGLE_1                               0x004B0314 /* -W-4R */
#define NV_UTRI_TRIANGLE_1_X                                   15:0 /* -W-SF */
#define NV_UTRI_TRIANGLE_1_Y                                  31:16 /* -W-SF */
#define NV_UTRI_TRIANGLE_2                               0x004B0318 /* -W-4R */
#define NV_UTRI_TRIANGLE_2_X                                   15:0 /* -W-SF */
#define NV_UTRI_TRIANGLE_2_Y                                  31:16 /* -W-SF */
#define NV_UTRI_TRIANGLE32_0                             0x004B0320 /* -W-4R */
#define NV_UTRI_TRIANGLE32_0_X                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_1                             0x004B0324 /* -W-4R */
#define NV_UTRI_TRIANGLE32_1_Y                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_2                             0x004B0328 /* -W-4R */
#define NV_UTRI_TRIANGLE32_2_X                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_3                             0x004B032C /* -W-4R */
#define NV_UTRI_TRIANGLE32_3_Y                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_4                             0x004B0330 /* -W-4R */
#define NV_UTRI_TRIANGLE32_4_X                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_5                             0x004B0334 /* -W-4R */
#define NV_UTRI_TRIANGLE32_5_Y                                 31:0 /* -W-SF */
#define NV_UTRI_TRIMESH(i)                       (0x004B0400+(i)*4) /* -W-4A */
#define NV_UTRI_TRIMESH__SIZE_1                                  32 /*       */
#define NV_UTRI_TRIMESH_X                                      15:0 /* -W-SF */
#define NV_UTRI_TRIMESH_Y                                     31:16 /* -W-SF */
#define NV_UTRI_TRIMESH32_0(i)                   (0x004B0480+(i)*8) /* -W-4A */
#define NV_UTRI_TRIMESH32_0__SIZE_1                              16 /*       */
#define NV_UTRI_TRIMESH32_0_X                                  31:0 /* -W-SF */
#define NV_UTRI_TRIMESH32_1(i)                   (0x004B0484+(i)*8) /* -W-4A */
#define NV_UTRI_TRIMESH32_1__SIZE_1                              16 /*       */
#define NV_UTRI_TRIMESH32_1_Y                                  31:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_0(i)                  (0x004B0500+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_0__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_0_COLOR                              31:0 /* -W-VF */
#define NV_UTRI_CTRIANGLE_1(i)                  (0x004B0504+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_1__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_1_X                                  15:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_1_Y                                 31:16 /* -W-SF */
#define NV_UTRI_CTRIANGLE_2(i)                  (0x004B0508+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_2__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_2_X                                  15:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_2_Y                                 31:16 /* -W-SF */
#define NV_UTRI_CTRIANGLE_3(i)                  (0x004B050C+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_3__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_3_X                                  15:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_3_Y                                 31:16 /* -W-SF */
#define NV_UTRI_CTRIMESH_0(i)                    (0x004B0580+(i)*8) /* -W-4A */
#define NV_UTRI_CTRIMESH_0__SIZE_1                               16 /*       */
#define NV_UTRI_CTRIMESH_0_COLOR                               31:0 /* -W-VF */
#define NV_UTRI_CTRIMESH_1(i)                    (0x004B0584+(i)*8) /* -W-4A */
#define NV_UTRI_CTRIMESH_1__SIZE_1                               16 /*       */
#define NV_UTRI_CTRIMESH_1_X                                   15:0 /* -W-SF */
#define NV_UTRI_CTRIMESH_1_Y                                  31:16 /* -W-SF */
/* usr_rectangle.ref */
#define NV_URECT                              0x00471FFF:0x00470000 /* -W--D */
#define NV_URECT_CTX_SWITCH                              0x00470000 /* -W-4R */
#define NV_URECT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_URECT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_URECT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_URECT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_URECT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_URECT_SET_NOTIFY                              0x00470104 /* -W-4R */
#define NV_URECT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_URECT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_URECT_COLOR                                   0x00470304 /* -W-4R */
#define NV_URECT_COLOR_VALUE                                   31:0 /* -W-VF */
#define NV_URECT_RECTANGLE_0(i)                  (0x00470400+(i)*8) /* -W-4A */
#define NV_URECT_RECTANGLE_0__SIZE_1                             16 /*       */
#define NV_URECT_RECTANGLE_0_X                                 15:0 /* -W-SF */
#define NV_URECT_RECTANGLE_0_Y                                31:16 /* -W-SF */
#define NV_URECT_RECTANGLE_1(i)                  (0x00470404+(i)*8) /* -W-4A */
#define NV_URECT_RECTANGLE_1__SIZE_1                             16 /*       */
#define NV_URECT_RECTANGLE_1_WIDTH                             15:0 /* -W-UF */
#define NV_URECT_RECTANGLE_1_HEIGHT                           31:16 /* -W-UF */
/* usr_image_blit.ref */
#define NV_UBLIT                              0x00501FFF:0x00500000 /* -W--D */
#define NV_UBLIT_CTX_SWITCH                              0x00500000 /* -W-4R */
#define NV_UBLIT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UBLIT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UBLIT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UBLIT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UBLIT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UBLIT_SET_NOTIFY                              0x00500104 /* -W-4R */
#define NV_UBLIT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UBLIT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UBLIT_POINT_IN                                0x00500300 /* -W-4R */
#define NV_UBLIT_POINT_IN_X                                    15:0 /* -W-SF */
#define NV_UBLIT_POINT_IN_Y                                   31:16 /* -W-SF */
#define NV_UBLIT_POINT_OUT                               0x00500304 /* -W-4R */
#define NV_UBLIT_POINT_OUT_X                                   15:0 /* -W-SF */
#define NV_UBLIT_POINT_OUT_Y                                  31:16 /* -W-SF */
#define NV_UBLIT_SIZE                                    0x00500308 /* -W-4R */
#define NV_UBLIT_SIZE_WIDTH                                    15:0 /* -W-UF */
#define NV_UBLIT_SIZE_HEIGHT                                  31:16 /* -W-UF */
/* usr_image_from_cpu.ref */
#define NV_UIMAGE                             0x00511FFF:0x00510000 /* -W--D */
#define NV_UIMAGE_CTX_SWITCH                             0x00510000 /* -W-4R */
#define NV_UIMAGE_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UIMAGE_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UIMAGE_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UIMAGE_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UIMAGE_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UIMAGE_SET_NOTIFY                             0x00510104 /* -W-4R */
#define NV_UIMAGE_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UIMAGE_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UIMAGE_POINT                                  0x00510304 /* -W-4R */
#define NV_UIMAGE_POINT_X                                      15:0 /* -W-SF */
#define NV_UIMAGE_POINT_Y                                     31:16 /* -W-SF */
#define NV_UIMAGE_SIZE                                   0x00510308 /* -W-4R */
#define NV_UIMAGE_SIZE_WIDTH                                   15:0 /* -W-UF */
#define NV_UIMAGE_SIZE_HEIGHT                                 31:16 /* -W-UF */
#define NV_UIMAGE_SIZE_IN                                0x0051030C /* -W-4R */
#define NV_UIMAGE_SIZE_IN_WIDTH                                15:0 /* -W-UF */
#define NV_UIMAGE_SIZE_IN_HEIGHT                              31:16 /* -W-UF */
#define NV_UIMAGE_COLOR(i)                       (0x00510400+(i)*4) /* -W-4A */
#define NV_UIMAGE_COLOR__SIZE_1                                  32 /*       */
#define NV_UIMAGE_COLOR_VALUE                                  31:0 /* -W-VF */
/* usr_bitmap_from_cpu.ref */
#define NV_UBITMAP                            0x00521FFF:0x00520000 /* -W--D */
#define NV_UBITMAP_CTX_SWITCH                            0x00520000 /* -W-4R */
#define NV_UBITMAP_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_UBITMAP_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_UBITMAP_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_UBITMAP_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_UBITMAP_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_UBITMAP_SET_NOTIFY                            0x00520104 /* -W-4R */
#define NV_UBITMAP_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UBITMAP_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UBITMAP_COLOR0                                0x00520308 /* -W-4R */
#define NV_UBITMAP_COLOR0_VALUE                                31:0 /* -W-VF */
#define NV_UBITMAP_COLOR1                                0x0052030C /* -W-4R */
#define NV_UBITMAP_COLOR1_VALUE                                31:0 /* -W-VF */
#define NV_UBITMAP_POINT                                 0x00520310 /* -W-4R */
#define NV_UBITMAP_POINT_X                                     15:0 /* -W-SF */
#define NV_UBITMAP_POINT_Y                                    31:16 /* -W-SF */
#define NV_UBITMAP_SIZE                                  0x00520314 /* -W-4R */
#define NV_UBITMAP_SIZE_WIDTH                                  15:0 /* -W-UF */
#define NV_UBITMAP_SIZE_HEIGHT                                31:16 /* -W-UF */
#define NV_UBITMAP_SIZE_IN                               0x00520318 /* -W-4R */
#define NV_UBITMAP_SIZE_IN_WIDTH                               15:0 /* -W-UF */
#define NV_UBITMAP_SIZE_IN_HEIGHT                             31:16 /* -W-UF */
#define NV_UBITMAP_MONOCHROME(i)                 (0x00520400+(i)*4) /* -W-4A */
#define NV_UBITMAP_MONOCHROME__SIZE_1                            32 /*       */
#define NV_UBITMAP_MONOCHROME_BITMAP                           31:0 /* -W-VF */
/* usr_image_to_mem.ref */
#define NV_UTOMEM                             0x00541FFF:0x00540000 /* -W--D */
#define NV_UTOMEM_CTX_SWITCH                             0x00540000 /* -W-4R */
#define NV_UTOMEM_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UTOMEM_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UTOMEM_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UTOMEM_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UTOMEM_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UTOMEM_SET_NOTIFY                             0x00540104 /* -W-4R */
#define NV_UTOMEM_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UTOMEM_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UTOMEM_POINT                                  0x00540308 /* -W-4R */
#define NV_UTOMEM_POINT_X                                      15:0 /* -W-SF */
#define NV_UTOMEM_POINT_Y                                     31:16 /* -W-SF */
#define NV_UTOMEM_SIZE                                   0x0054030C /* -W-4R */
#define NV_UTOMEM_SIZE_WIDTH                                   15:0 /* -W-UF */
#define NV_UTOMEM_SIZE_HEIGHT                                 31:16 /* -W-UF */
#define NV_UTOMEM_IMAGE_PITCH                            0x00540310 /* -W-4R */
#define NV_UTOMEM_IMAGE_PITCH_VALUE                            31:0 /* -W-SF */
#define NV_UTOMEM_IMAGE_START                            0x00540314 /* -W-4R */
#define NV_UTOMEM_IMAGE_START_OFFSET                           31:0 /* -W-UF */
/* usr_scaled_image_from_mem.ref */
#define NV_USCALED                            0x004E1FFF:0x004E0000 /* -W--D */
#define NV_USCALED_CTX_SWITCH                            0x004E0000 /* -W-4R */
#define NV_USCALED_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_USCALED_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_USCALED_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_USCALED_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_USCALED_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_USCALED_SET_NOTIFY                            0x004E0104 /* -W-4R */
#define NV_USCALED_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_USCALED_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_USCALED_CLIP_0                                0x004E0308 /* -W-4R */
#define NV_USCALED_CLIP_0_X                                    15:0 /* -W-SF */
#define NV_USCALED_CLIP_0_Y                                   31:16 /* -W-SF */
#define NV_USCALED_CLIP_1                                0x004E030C /* -W-4R */
#define NV_USCALED_CLIP_1_WIDTH                                15:0 /* -W-UF */
#define NV_USCALED_CLIP_1_HEIGHT                              31:16 /* -W-UF */
#define NV_USCALED_RECTANGLE_OUT_0                       0x004E0310 /* -W-4R */
#define NV_USCALED_RECTANGLE_OUT_0_X                           15:0 /* -W-SF */
#define NV_USCALED_RECTANGLE_OUT_0_Y                          31:16 /* -W-SF */
#define NV_USCALED_RECTANGLE_OUT_1                       0x004E0314 /* -W-4R */
#define NV_USCALED_RECTANGLE_OUT_1_WIDTH                       15:0 /* -W-UF */
#define NV_USCALED_RECTANGLE_OUT_1_HEIGHT                     31:16 /* -W-UF */
#define NV_USCALED_DELTA_DU_DX                           0x004E0318 /* -W-4R */
#define NV_USCALED_DELTA_DU_DX_R_FRACTION                      19:0 /* -W-SF */
#define NV_USCALED_DELTA_DU_DX_R_INT                          31:20 /* -W-UF */
#define NV_USCALED_DELTA_DU_DX_R                               31:0 /* -W-UF */
#define NV_USCALED_DELTA_DV_DY                           0x004E031C /* -W-4R */
#define NV_USCALED_DELTA_DV_DY_R_FRACTION                      19:0 /* -W-SF */
#define NV_USCALED_DELTA_DV_DY_R_INT                          31:20 /* -W-UF */
#define NV_USCALED_DELTA_DV_DY_R                               31:0 /* -W-UF */
#define NV_USCALED_SIZE                                  0x004E0400 /* -W-4R */
#define NV_USCALED_SIZE_WIDTH                                  15:0 /* -W-UF */
#define NV_USCALED_SIZE_HEIGHT                                31:16 /* -W-UF */
#define NV_USCALED_PITCH                                 0x004E0404 /* -W-4R */
#define NV_USCALED_PITCH_VALUE                                 31:0 /* -W-SF */
#define NV_USCALED_OFFSET                                0x004E0408 /* -W-4R */
#define NV_USCALED_OFFSET_VALUE                               31:0  /* -W-UF */
#define NV_USCALED_POINT                                 0x004E040C /* -W-4R */
#define NV_USCALED_POINT_V_FRACTION                            11:0 /* -W-UF */
#define NV_USCALED_POINT_V_INT                                15:12 /* -W-UF */
#define NV_USCALED_POINT_V_VALUE                               15:0 /* -W-UF */
#define NV_USCALED_POINT_U_FRACTION                           19:16 /* -W-UF */
#define NV_USCALED_POINT_U_INT                                31:20 /* -W-UF */
#define NV_USCALED_POINT_U_VALUE                               31:0 /* -W-UF */
#define NV_USCALED_SIZE_Y                                0x004E0400 /* -W-4R */
#define NV_USCALED_SIZE_Y_WIDTH                                15:0 /* -W-UF */
#define NV_USCALED_SIZE_Y_HEIGHT                              31:16 /* -W-UF */
#define NV_USCALED_PITCH_420                             0x004E0404 /* -W-4R */
#define NV_USCALED_PITCH_420_Y                                 15:0 /* -W-UF */
#define NV_USCALED_PITCH_420_UV                               31:16 /* -W-UF */
#define NV_USCALED_OFFSET_Y                              0x004E0408 /* -W-4R */
#define NV_USCALED_OFFSET_Y_VALUE                             31:0  /* -W-UF */
#define NV_USCALED_OFFSET_U                              0x004E040C /* -W-4R */
#define NV_USCALED_OFFSET_U_VALUE                             31:0  /* -W-UF */
#define NV_USCALED_OFFSET_V                              0x004E0410 /* -W-4R */
#define NV_USCALED_OFFSET_V_VALUE                             31:0  /* -W-UF */
#define NV_USCALED_POINT_Y                               0x004E0414 /* -W-4R */
#define NV_USCALED_POINT_Y_V_FRACTION                          11:0 /* -W-UF */
#define NV_USCALED_POINT_Y_V_INT                              15:12 /* -W-UF */
#define NV_USCALED_POINT_Y_V_VALUE                             15:0 /* -W-UF */
#define NV_USCALED_POINT_Y_U_FRACTION                         19:16 /* -W-UF */
#define NV_USCALED_POINT_Y_U_INT                              31:20 /* -W-UF */
#define NV_USCALED_POINT_Y_U_VALUE                            31:16 /* -W-UF */
/* usr_stretch_from_cpu.ref */
#define NV_USTRTCH                            0x00551FFF:0x00550000 /* -W--D */
#define NV_USTRTCH_CTX_SWITCH                            0x00550000 /* -W-4R */
#define NV_USTRTCH_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_USTRTCH_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_USTRTCH_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_USTRTCH_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_USTRTCH_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_USTRTCH_SET_NOTIFY                            0x00550104 /* -W-4R */
#define NV_USTRTCH_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_USTRTCH_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_USTRTCH_SIZE_IN                               0x00550304 /* -W-4R */
#define NV_USTRTCH_SIZE_IN_WIDTH                               15:0 /* -W-UF */
#define NV_USTRTCH_SIZE_IN_HEIGHT                             31:16 /* -W-UF */
#define NV_USTRTCH_DELTA_DX_DU                           0x00550308 /* -W-4R */
#define NV_USTRTCH_DELTA_DX_DU_R_FRACTION                      19:0 /* -W-UF */
#define NV_USTRTCH_DELTA_DX_DU_R_INT                          31:20 /* -W-UF */
#define NV_USTRTCH_DELTA_DX_DU_R                               31:0 /* -W-UF */
#define NV_USTRTCH_DELTA_DY_DV                           0x0055030C /* -W-4R */
#define NV_USTRTCH_DELTA_DY_DV_R_FRACTION                      19:0 /* -W-UF */
#define NV_USTRTCH_DELTA_DY_DV_R_INT                          31:20 /* -W-UF */
#define NV_USTRTCH_DELTA_DY_DV_R                               31:0 /* -W-UF */
#define NV_USTRTCH_CLIP_0                                0x00550310 /* -W-4R */
#define NV_USTRTCH_CLIP_0_X                                    15:0 /* -W-SF */
#define NV_USTRTCH_CLIP_0_Y                                   31:16 /* -W-SF */
#define NV_USTRTCH_CLIP_1                                0x00550314 /* -W-4R */
#define NV_USTRTCH_CLIP_1_WIDTH                                15:0 /* -W-UF */
#define NV_USTRTCH_CLIP_1_HEIGHT                              31:16 /* -W-UF */
#define NV_USTRTCH_POINT12D4                             0x00550318 /* -W-4R */
#define NV_USTRTCH_POINT12D4_X_FRACTION                         3:0 /* -W-SF */
#define NV_USTRTCH_POINT12D4_X_INT                             15:4 /* -W-SF */
#define NV_USTRTCH_POINT12D4_X                                 15:0 /* -W-SF */
#define NV_USTRTCH_POINT12D4_Y_FRACTION                       19:16 /* -W-SF */
#define NV_USTRTCH_POINT12D4_Y_INT                            31:20 /* -W-SF */
#define NV_USTRTCH_POINT12D4_Y                                31:16 /* -W-SF */
#define NV_USTRTCH_COLOR(i)                      (0x00550400+(i)*4) /* -W-4A */
#define NV_USTRTCH_COLOR__SIZE_1                               1792 /*       */
#define NV_USTRTCH_COLOR_VALUE                                 31:0 /* -W-VF */
/* usr_win95_text.ref */
#define NV_UW95TXT                            0x004C1FFF:0x004C0000 /* -W--D */
#define NV_UW95TXT_CTX_SWITCH                            0x004C0000 /* -W-4R */
#define NV_UW95TXT_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_UW95TXT_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_UW95TXT_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_UW95TXT_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_UW95TXT_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_UW95TXT_SET_NOTIFY                            0x004C0104 /* -W-4R */
#define NV_UW95TXT_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UW95TXT_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UW95TXT_COLOR_A                               0x004C03FC /* -W-4R */
#define NV_UW95TXT_COLOR_A_VALUE                               31:0 /* -W-VF */
#define NV_UW95TXT_RECT_NCLIP_0(i)               (0x004C0400+(i)*8) /* -W-4A */
#define NV_UW95TXT_RECT_NCLIP_0__SIZE_1                          64 /*       */
#define NV_UW95TXT_RECT_NCLIP_0_Y                              15:0 /* -W-SF */
#define NV_UW95TXT_RECT_NCLIP_0_X                             31:16 /* -W-SF */
#define NV_UW95TXT_RECT_NCLIP_1(i)               (0x004C0404+(i)*8) /* -W-4A */
#define NV_UW95TXT_RECT_NCLIP_1__SIZE_1                          64 /*       */
#define NV_UW95TXT_RECT_NCLIP_1_HEIGHT                         15:0 /* -W-UF */
#define NV_UW95TXT_RECT_NCLIP_1_WIDTH                         31:16 /* -W-UF */
#define NV_UW95TXT_CLIP_B_0                              0x004C07F4 /* -W-4R */
#define NV_UW95TXT_CLIP_B_0_LEFT                               15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_B_0_TOP                               31:16 /* -W-SF */
#define NV_UW95TXT_CLIP_B_1                              0x004C07F8 /* -W-4R */
#define NV_UW95TXT_CLIP_B_1_RIGHT                              15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_B_1_BOTTOM                            31:16 /* -W-SF */
#define NV_UW95TXT_COLOR_B                               0x004C07FC /* -W-4R */
#define NV_UW95TXT_COLOR_B_VALUE                               31:0 /* -W-VF */
#define NV_UW95TXT_RECT_CLIP_0(i)                (0x004C0800+(i)*8) /* -W-4A */
#define NV_UW95TXT_RECT_CLIP_0__SIZE_1                           64 /*       */
#define NV_UW95TXT_RECT_CLIP_0_LEFT                            15:0 /* -W-SF */
#define NV_UW95TXT_RECT_CLIP_0_TOP                            31:16 /* -W-SF */
#define NV_UW95TXT_RECT_CLIP_1(i)                (0x004C0804+(i)*8) /* -W-4A */
#define NV_UW95TXT_RECT_CLIP_1__SIZE_1                           64 /*       */
#define NV_UW95TXT_RECT_CLIP_1_RIGHT                           15:0 /* -W-SF */
#define NV_UW95TXT_RECT_CLIP_1_BOTTOM                         31:16 /* -W-SF */
#define NV_UW95TXT_CLIP_C_0                              0x004C0BEC /* -W-4R */
#define NV_UW95TXT_CLIP_C_0_LEFT                               15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_C_0_TOP                               31:16 /* -W-SF */
#define NV_UW95TXT_CLIP_C_1                              0x004C0BF0 /* -W-4R */
#define NV_UW95TXT_CLIP_C_1_RIGHT                              15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_C_1_BOTTOM                            31:16 /* -W-SF */
#define NV_UW95TXT_COLOR1_C                              0x004C0BF4 /* -W-4R */
#define NV_UW95TXT_COLOR1_C_VALUE                              31:0 /* -W-VF */
#define NV_UW95TXT_SIZE_C                                0x004C0BF8 /* -W-4R */
#define NV_UW95TXT_SIZE_C_WIDTH                                15:0 /* -W-UF */
#define NV_UW95TXT_SIZE_C_HEIGHT                              31:16 /* -W-UF */
#define NV_UW95TXT_POINT_C                               0x004C0BFC /* -W-4R */
#define NV_UW95TXT_POINT_C_X                                   15:0 /* -W-SF */
#define NV_UW95TXT_POINT_C_Y                                  31:16 /* -W-SF */
#define NV_UW95TXT_MONO_COLOR1_C(i)              (0x004C0C00+(i)*4) /* -W-4A */
#define NV_UW95TXT_MONO_COLOR1_C__SIZE_1                        128 /*       */
#define NV_UW95TXT_MONO_COLOR1_C_BITMAP                        31:0 /* -W-VF */
#define NV_UW95TXT_CLIP_D_0                              0x004C0FE8 /* -W-4R */
#define NV_UW95TXT_CLIP_D_0_LEFT                               15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_D_0_TOP                               31:16 /* -W-SF */
#define NV_UW95TXT_CLIP_D_1                              0x004C0FEC /* -W-4R */
#define NV_UW95TXT_CLIP_D_1_RIGHT                              15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_D_1_BOTTOM                            31:16 /* -W-SF */
#define NV_UW95TXT_COLOR1_D                              0x004C0FF0 /* -W-4R */
#define NV_UW95TXT_COLOR1_D_VALUE                              31:0 /* -W-VF */
#define NV_UW95TXT_SIZE_IN_D                             0x004C0FF4 /* -W-4R */
#define NV_UW95TXT_SIZE_IN_D_WIDTH                             15:0 /* -W-UF */
#define NV_UW95TXT_SIZE_IN_D_HEIGHT                           31:16 /* -W-UF */
#define NV_UW95TXT_SIZE_OUT_D                            0x004C0FF8 /* -W-4R */
#define NV_UW95TXT_SIZE_OUT_D_WIDTH                            15:0 /* -W-UF */
#define NV_UW95TXT_SIZE_OUT_D_HEIGHT                          31:16 /* -W-UF */
#define NV_UW95TXT_POINT_D                               0x004C0FFC /* -W-4R */
#define NV_UW95TXT_POINT_D_X                                   15:0 /* -W-SF */
#define NV_UW95TXT_POINT_D_Y                                  31:16 /* -W-SF */
#define NV_UW95TXT_MONO_COLOR1_D(i)              (0x004C1000+(i)*4) /* -W-4A */
#define NV_UW95TXT_MONO_COLOR1_D__SIZE_1                        128 /*       */
#define NV_UW95TXT_MONO_COLOR1_D_BITMAP                        31:0 /* -W-VF */
#define NV_UW95TXT_CLIP_E_0                              0x004C13E4 /* -W-4R */
#define NV_UW95TXT_CLIP_E_0_LEFT                               15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_E_0_TOP                               31:16 /* -W-SF */
#define NV_UW95TXT_CLIP_E_1                              0x004C13E8 /* -W-4R */
#define NV_UW95TXT_CLIP_E_1_RIGHT                              15:0 /* -W-SF */
#define NV_UW95TXT_CLIP_E_1_BOTTOM                            31:16 /* -W-SF */
#define NV_UW95TXT_COLOR0_E                              0x004C13EC /* -W-4R */
#define NV_UW95TXT_COLOR0_E_VALUE                              31:0 /* -W-VF */
#define NV_UW95TXT_COLOR1_E                              0x004C13F0 /* -W-4R */
#define NV_UW95TXT_COLOR1_E_VALUE                              31:0 /* -W-VF */
#define NV_UW95TXT_SIZE_IN_E                             0x004C13F4 /* -W-4R */
#define NV_UW95TXT_SIZE_IN_E_WIDTH                             15:0 /* -W-UF */
#define NV_UW95TXT_SIZE_IN_E_HEIGHT                           31:16 /* -W-UF */
#define NV_UW95TXT_SIZE_OUT_E                            0x004C13F8 /* -W-4R */
#define NV_UW95TXT_SIZE_OUT_E_WIDTH                            15:0 /* -W-UF */
#define NV_UW95TXT_SIZE_OUT_E_HEIGHT                          31:16 /* -W-UF */
#define NV_UW95TXT_POINT_E                               0x004C13FC /* -W-4R */
#define NV_UW95TXT_POINT_E_X                                   15:0 /* -W-SF */
#define NV_UW95TXT_POINT_E_Y                                  31:16 /* -W-SF */
#define NV_UW95TXT_MONO_COLOR01_E(i)             (0x004C1400+(i)*4) /* -W-4A */
#define NV_UW95TXT_MONO_COLOR01_E__SIZE_1                       128 /*       */
#define NV_UW95TXT_MONO_COLOR01_E_BITMAP                       31:0 /* -W-VF */
/* usr_image_in_mem.ref */
#define NV_UINMEM                             0x005C1FFF:0x005C0000 /* -W--D */
#define NV_UINMEM_CTX_SWITCH                             0x005C0000 /* -W-4R */
#define NV_UINMEM_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UINMEM_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UINMEM_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UINMEM_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UINMEM_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UINMEM_SET_NOTIFY                             0x005C0104 /* -W-4R */
#define NV_UINMEM_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UINMEM_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UINMEM_PITCH                                  0x005C0308 /* -W-4R */
#define NV_UINMEM_PITCH_VALUE                                  15:0 /* -WXUF */
#define NV_UINMEM_OFFSET                                 0x005C030C /* -W-4R */
#define NV_UINMEM_OFFSET_LINADRS                               22:0 /* -WIUF */
#define NV_UINMEM_OFFSET_LINADRS_0                       0x00000000 /* -WI-V */
#define NV_UINMEM_FORMAT                                 0x005C0300 /* -W-4R */
#define NV_UINMEM_FORMAT_VALUE                                 31:0 /* -WXUF */
#define NV_UINMEM_FORMAT_VALUE_LE_Y8_P4                  0x01010000 /* -W--V */
#define NV_UINMEM_FORMAT_VALUE_LE_Y16_P2                 0x01010001 /* -W--V */
#define NV_UINMEM_FORMAT_VALUE_LE_X1R5G5B5_P2            0x01000000 /* -W--V */
#define NV_UINMEM_FORMAT_VALUE_LE_X8R8G8B8               0x00000001 /* -W--V */
/* dev_framebuffer.ref */
#define NV_PFB                                0x00100FFF:0x00100000 /* RW--D */
#define NV_PFB_BOOT_0                                    0x00100000 /* RW-4R */
#define NV_PFB_BOOT_0_RAM_AMOUNT                                1:0 /* RWIVF */
#define NV_PFB_BOOT_0_RAM_AMOUNT_8MB                     0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_2MB                     0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_4MB                     0x00000002 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_UNDEFINED               0x00000003 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_DEFAULT                 0x00000002 /* RWI-V */
#define NV_PFB_BOOT_0_RAM_WIDTH_128                             2:2 /* RW-VF */
#define NV_PFB_BOOT_0_RAM_WIDTH_128_OFF                  0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_WIDTH_128_ON                   0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_BANKS                                 3:3 /* RWIVF */
#define NV_PFB_BOOT_0_RAM_BANKS_2BANK                    0x00000000 /* RWI-V */
#define NV_PFB_BOOT_0_RAM_BANKS_4BANK                    0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAMDATA_TWIDDLE                           4:4 /* RWIVF */
#define NV_PFB_BOOT_0_RAMDATA_TWIDDLE_OFF                0x00000000 /* RWI-V */
#define NV_PFB_BOOT_0_RAMDATA_TWIDDLE_ON                 0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_EXTENSION                      5:5 /* RWIVF */
#define NV_PFB_BOOT_0_RAM_AMOUNT_EXTENSION_OFF           0x00000000 /* RWI-V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_EXTENSION_8MB           0x00000001 /* RW--V */
#define NV_PFB_DELAY_1                                   0x00100044 /* RW-4R */
#define NV_PFB_DELAY_1_WRITE_ENABLE_RISE                        1:0 /* RWIUF */
#define NV_PFB_DELAY_1_WRITE_ENABLE_RISE_0               0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1_WRITE_ENABLE_FALL                        5:4 /* RWIUF */
#define NV_PFB_DELAY_1_WRITE_ENABLE_FALL_0               0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1_CAS_ENABLE_RISE                          9:8 /* RWIUF */
#define NV_PFB_DELAY_1_CAS_ENABLE_RISE_0                 0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1_CAS_ENABLE_FALL                        13:12 /* RWIUF */
#define NV_PFB_DELAY_1_CAS_ENABLE_FALL_0                 0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1_OUTPUT_DATA                            17:16 /* RWIUF */
#define NV_PFB_DELAY_1_OUTPUT_DATA_0                     0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1_RAS_ENABLE                             21:20 /* RWIUF */
#define NV_PFB_DELAY_1_RAS_ENABLE_0                      0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0                                   0x00100080 /* RW-4R */
#define NV_PFB_DEBUG_0_PAGE_MODE                                0:0 /* RWIVF */
#define NV_PFB_DEBUG_0_PAGE_MODE_ENABLED                 0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_PAGE_MODE_DISABLED                0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_REFRESH                                  4:4 /* RWIVF */
#define NV_PFB_DEBUG_0_REFRESH_ENABLED                   0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_REFRESH_DISABLED                  0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_REFRESH_COUNTX64                        12:8 /* RWIVF */
#define NV_PFB_DEBUG_0_REFRESH_COUNTX64_DEFAULT          0x00000010 /* RWI-V */
#define NV_PFB_DEBUG_0_CASOE                                  20:20 /* RWIVF */
#define NV_PFB_DEBUG_0_CASOE_ENABLED                     0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_CASOE_DISABLED                    0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_CKE_INVERT                             28:28 /* RWIVF */
#define NV_PFB_DEBUG_0_CKE_INVERT_OFF                    0x00000000 /* RWIVF */
#define NV_PFB_DEBUG_0_CKE_INVERT_ON                     0x00000001 /* RW-VF */
#define NV_PFB_DEBUG_0_REFINC                                 29:29 /* RWIVF */
#define NV_PFB_DEBUG_0_REFINC_DISABLED                   0x00000000 /* RW-VF */
#define NV_PFB_DEBUG_0_REFINC_ENABLED                    0x00000001 /* RWIVF */
#define NV_PFB_DEBUG_0_SAVE_POWER                             30:30 /* RWIVF */
#define NV_PFB_DEBUG_0_SAVE_POWER_ON                     0x00000000 /* RWIVF */
#define NV_PFB_DEBUG_0_SAVE_POWER_OFF                    0x00000001 /* RW-VF */
#define NV_PFB_GREEN_0                                   0x001000C0 /* RW-4R */
#define NV_PFB_GREEN_0_LEVEL                                    1:0 /* RWIVF */
#define NV_PFB_GREEN_0_LEVEL_VIDEO_ENABLED               0x00000000 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_VIDEO_DISABLED              0x00000001 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_TIMING_DISABLED             0x00000002 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_MEMORY_DISABLED             0x00000003 /* RWI-V */
#define NV_PFB_CONFIG_0                                  0x00100200 /* RW-4R */
#define NV_PFB_CONFIG_0_TYPE                                   14:0 /* RWIVF */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_FIXED_8BPP          0x00000120 /* RW-VF */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_FIXED_16BPP         0x00000220 /* RW-VF */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_FIXED_32BPP         0x00000320 /* RW-VF */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_VAR_8BPP            0x00004120 /* RW-VF */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_VAR_16BPP           0x00004220 /* RW-VF */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_VAR_32BPP           0x00004320 /* RW-VF */
#define NV_PFB_CONFIG_0_TYPE_TETRIS                      0x00002000 /* RW-VF */
#define NV_PFB_CONFIG_0_TYPE_NOTILING                    0x00001114 /* RWIVF */
#define NV_PFB_CONFIG_0_TETRIS_MODE                           17:15 /* RWI-V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_PASS                 0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_1                    0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_2                    0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_3                    0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_4                    0x00000004 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_5                    0x00000005 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_6                    0x00000006 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_7                    0x00000007 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_SHIFT                          19:18 /* RWI-V */
#define NV_PFB_CONFIG_0_TETRIS_SHIFT_0                   0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TETRIS_SHIFT_1                   0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_SHIFT_2                   0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_BANK_SWAP                             22:20 /* RWI-V */
#define NV_PFB_CONFIG_0_BANK_SWAP_OFF                    0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_BANK_SWAP_1M                     0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_BANK_SWAP_2M                     0x00000005 /* RW--V */
#define NV_PFB_CONFIG_0_BANK_SWAP_4M                     0x00000007 /* RW--V */
#define NV_PFB_CONFIG_0_UNUSED                                23:23 /* RW--V */
#define NV_PFB_CONFIG_1                                  0x00100204 /* RW-4R */
#define NV_PFB_CONFIG_1_CAS_LATENCY                             2:0 /* RWIVF */
#define NV_PFB_CONFIG_1_CAS_LATENCY_3                    0x00000003 /* RWI-V */
#define NV_PFB_CONFIG_1_NEC_MODE                                3:3 /* RW-VF */
#define NV_PFB_CONFIG_1_NEC_MODE_DISABLED                0x00000000 /* RW--V */
#define NV_PFB_CONFIG_1_NEC_MODE_ENABLED                 0x00000001 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_RAS                                 7:4 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_RAS_DEFAULT                  0x00000009 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_RAS_9CYCLES                  0x00000008 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_PCHG                               10:8 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_PCHG_DEFAULT                 0x00000002 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_LOW                               14:12 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_LOW_DEFAULT                  0x00000006 /* RWI-V */
#define NV_PFB_CONFIG_1_MRS_TO_RAS                            18:16 /* RWIUF */
#define NV_PFB_CONFIG_1_MRS_TO_RAS_DEFAULT               0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_WRITE_TO_READ                         22:20 /* RWIUF */
#define NV_PFB_CONFIG_1_WRITE_TO_READ_DEFAULT            0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_TO_CAS_M1                         26:24 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_TO_CAS_M1_DEFAULT            0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_READ_TO_WRITE                         30:28 /* RWIUF */
#define NV_PFB_CONFIG_1_READ_TO_WRITE_DEFAULT            0x00000004 /* RWI-V */
#define NV_PFB_CONFIG_1_READ_TO_PCHG                          31:31 /* RWIUF */
#define NV_PFB_CONFIG_1_READ_TO_PCHG_ON                  0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_READ_TO_PCHG_OFF                 0x00000000 /* RW--V */
#define NV_PFB_CONFIG_1_ED_RAC1                                 0:0 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAC1_DEFAULT                  0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RWT1                                 1:1 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RWT1_DEFAULT                  0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RPC1                                 2:2 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RPC1_DEFAULT                  0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_PMAW                                 4:4 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_PMAW_DEFAULT                  0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_PAGE                                 5:5 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_PAGE_DEFAULT                  0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RAC0_0                               8:8 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAC0_0_DEFAULT                0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RAC0_1                               9:9 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAC0_1_DEFAULT                0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RAC1_0                             10:10 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAC1_0_DEFAULT                0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RAC1_1                             12:12 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAC1_1_DEFAULT                0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RAD0_0                             13:13 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAD0_0_DEFAULT                0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RAD0_1                             14:14 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RAD0_1_DEFAULT                0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RPC0_0                             16:16 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RPC0_0_DEFAULT                0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RPC0_1                             17:17 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RPC0_1_DEFAULT                0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RPC1_0                             18:18 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RPC1_0_DEFAULT                0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_ED_RPC1_1                             20:20 /* RWIUF */
#define NV_PFB_CONFIG_1_ED_RPC1_1_DEFAULT                0x00000001 /* RWI-V */
#define NV_PFB_RTL                                       0x00100300 /* RW-4R */
#define NV_PFB_RTL_S                                            1:0 /* RWIUF */
#define NV_PFB_RTL_S_DEFAULT                             0x00000002 /* RWI-V */
#define NV_PFB_RTL_V                                            5:4 /* RWIUF */
#define NV_PFB_RTL_V_DEFAULT                             0x00000002 /* RWI-V */
#define NV_PFB_RTL_M                                            9:8 /* RWIUF */
#define NV_PFB_RTL_M_DEFAULT                             0x00000002 /* RWI-V */
#define NV_PFB_RTL_H                                          13:12 /* RWIUF */
#define NV_PFB_RTL_H_DEFAULT                             0x00000001 /* RWI-V */
#define NV_PFB_RTL_A                                          17:16 /* RWIUF */
#define NV_PFB_RTL_A_DEFAULT                             0x00000001 /* RWI-V */
#define NV_PFB_RTL_G                                          21:20 /* RWIUF */
#define NV_PFB_RTL_G_DEFAULT                             0x00000001 /* RWI-V */
#define NV_PFB_RTL_ARB_GR_HI_PRIOR                            24:24 /* RWIUF */
#define NV_PFB_RTL_ARB_GR_HI_PRIOR_DEFAULT               0x00000000 /* RWI-V */
#define NV_PFB_RTL_ARB_MEDIA_HI_PRIOR                         28:28 /* RWIUF */
#define NV_PFB_RTL_ARB_MEDIA_HI_PRIOR_DEFAULT            0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_RESOLUTION                              5:0 /* RWIVF */
#define NV_PFB_CONFIG_0_RESOLUTION_320_PIXELS            0x0000000a /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_400_PIXELS            0x0000000d /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_480_PIXELS            0x0000000f /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_512_PIXELS            0x00000010 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_640_PIXELS            0x00000014 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_800_PIXELS            0x00000019 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_960_PIXELS            0x0000001e /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1024_PIXELS           0x00000020 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1152_PIXELS           0x00000024 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1280_PIXELS           0x00000028 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1600_PIXELS           0x00000032 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_DEFAULT               0x00000014 /* RWI-V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH                             9:8 /* RWIVF */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_8_BITS               0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_16_BITS              0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_32_BITS              0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_DEFAULT              0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING                                12:12 /* RWIVF */
#define NV_PFB_CONFIG_0_TILING_ENABLED                   0x00000000 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DISABLED                  0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG                          23:13 /* RWIVF */
#define NV_PFB_CONFIG_0_TILING_DEBUG_DISABLED            0x00000000 /* RW--V */
#define NV_PFB_CONFIG_0_TILE                                  14:12 /* RWIVF */
#define NV_PFB_CONFIG_0_TILE_OLD1024_FIXED               0x00000000 /* RW-VF */
#define NV_PFB_CONFIG_0_TILE_OLD1024_VARIABLE            0x00000004 /* RW-VF */
#define NV_PFB_CONFIG_0_TILE_TETRIS_ALLOW                0x00000001 /* RW-VF */
#define NV_PFB_CONFIG_0_TILE_TETRIS_REDUNDANT            0x00000002 /* RW-VF */
#define NV_PFB_CONFIG_0_TILE_TETRIS_REDUNDANT2           0x00000003 /* RW-VF */
#define NV_PFB_CONFIG_0_TILING_DEBUG_ON                       13:13 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_ON_ENABLED          0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_ON_DISABLED         0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TILESIZE                 14:14 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TILESIZE_FIXED      0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TILESIZE_VARIABLE   0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE              17:15 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_PASS    0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_1       0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_2       0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_3       0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_4       0x00000004 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_5       0x00000005 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_6       0x00000006 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_7       0x00000007 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT             19:18 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT_0      0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT_1      0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT_2      0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP                20:20 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_OFF       0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_ON        0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB            22:21 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB_1M    0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB_2M    0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB_4M    0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_UNUSED                   23:23 /* RW--V */
#define NV_PFB_CONFIG_1_SGRAM100                                3:3 /* RWIVF */
#define NV_PFB_CONFIG_1_SGRAM100_ENABLED                 0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_SGRAM100_DISABLED                0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_CKE_ALWAYSON                           29:29 /* RWIVF */
#define NV_PFB_DEBUG_0_CKE_ALWAYSON_OFF                  0x00000000 /* RW-VF */
#define NV_PFB_DEBUG_0_CKE_ALWAYSON_ON                   0x00000001 /* RWIVF */
/* dev_framebuffer.ref */
#define NV_PNVM                               0x017FFFFF:0x01000000 /* RW--M */
#define NV_PNVM_DATA032(i)                       (0x01000000+(i)*4) /* RW-4A */
#define NV_PNVM_DATA032__SIZE_1                              524288 /*       */
#define NV_PNVM_DATA032_VALUE                                  31:0 /* RWXVF */
#define NV_PNVM_DATA024(i)           (0x01000000+((i)/2)*4+((i)%2)) /* RW-3A */
#define NV_PNVM_DATA024__SIZE_1                             1048576 /*       */
#define NV_PNVM_DATA024_VALUE                                  23:0 /* RWXVF */
#define NV_PNVM_DATA016(i)           (0x01000000+((i)/3)*4+((i)%3)) /* RW-2A */
#define NV_PNVM_DATA016__SIZE_1                             1572864 /*       */
#define NV_PNVM_DATA016_VALUE                                  15:0 /* RWXVF */
#define NV_PNVM_DATA008(i)                         (0x01000000+(i)) /* RW-1A */
#define NV_PNVM_DATA008__SIZE_1                             2097152 /*       */
#define NV_PNVM_DATA008_VALUE                                   7:0 /* RWXVF */
/* dev_framebuffer.ref */
#define NV_PRAMIN                             0x01FFFFFF:0x01C00000 /* RW--M */
#define NV_PRAMIN_DATA032(i)                       (0x01C00000+(i)*4) /* RW-4A */
#define NV_PRAMIN_DATA032__SIZE_1                              524288 /*       */
#define NV_PRAMIN_DATA032_VALUE                                  31:0 /* RWXVF */
#define NV_PRAMIN_DATA024(i)           (0x01C00000+((i)/2)*4+((i)%2)) /* RW-3A */
#define NV_PRAMIN_DATA024__SIZE_1                             1048576 /*       */
#define NV_PRAMIN_DATA024_VALUE                                  23:0 /* RWXVF */
#define NV_PRAMIN_DATA016(i)           (0x01C00000+((i)/3)*4+((i)%3)) /* RW-2A */
#define NV_PRAMIN_DATA016__SIZE_1                             1572864 /*       */
#define NV_PRAMIN_DATA016_VALUE                                  15:0 /* RWXVF */
#define NV_PRAMIN_DATA008(i)                         (0x01C00000+(i)) /* RW-1A */
#define NV_PRAMIN_DATA008__SIZE_1                             2097152 /*       */
#define NV_PRAMIN_DATA008_VALUE                                   7:0 /* RWXVF */
/* dev_ram.ref */
#define NV_PRAMIN                             0x01FFFFFF:0x01C00000 /* RW--M */
#define NV_PRAMIN_CONTEXT_0                   ( 0*32+31):( 0*32+ 0) /*       */
#define NV_PRAMIN_CONTEXT_1                   ( 1*32+31):( 1*32+ 0) /*       */
#define NV_PRAMIN_CONTEXT_2                   ( 2*32+31):( 2*32+ 0) /*       */
#define NV_PRAMIN_CONTEXT_3                   ( 3*32+31):( 3*32+ 0) /*       */
#define NV_PRAMIN_RAMHT_0                     0x01C00FFF:0x01C00000 /* RW--M */
#define NV_PRAMIN_RAMAU_0                     0x01C01BFF:0x01C01000 /* RW--M */
#define NV_PRAMIN_RAMFC_0                     0x01C01DFF:0x01C01C00 /* RW--M */
#define NV_PRAMIN_RAMRO_0                     0x01C01FFF:0x01C01E00 /* RW--M */
#define NV_PRAMIN_RAMRM_0                     0x01C02FFF:0x01C02000 /* RW--M */
/* dev_ram.ref */
#define NV_FIFO_DMA_METHOD_ADDRESS            ( 0*32+12):( 0*32+ 2) /* RWXUF */
#define NV_FIFO_DMA_METHOD_SUBCHANNEL         ( 0*32+15):( 0*32+13) /* RWXUF */
#define NV_FIFO_DMA_METHOD_COUNT              ( 0*32+28):( 0*32+18) /* RWXUF */
#define NV_FIFO_DMA_DATA                      ( 1*32+31):( 1*32+ 0) /* RWXUF */
/* dev_framebuffer.ref */
#define NV_PDFB                               0x017FFFFF:0x01000000 /* RW--D */
#define NV_PDFB_DATA032(i)                       (0x01000000+(i)*4) /* RW-4A */
#define NV_PDFB_DATA032__SIZE_1                              524288 /*       */
#define NV_PDFB_DATA032_VALUE                                  31:0 /* RWXVF */
#define NV_PDFB_DATA024(i)           (0x01000000+((i)/2)*4+((i)%2)) /* RW-3A */
#define NV_PDFB_DATA024__SIZE_1                             1048576 /*       */
#define NV_PDFB_DATA024_VALUE                                  23:0 /* RWXVF */
#define NV_PDFB_DATA016(i)           (0x01000000+((i)/3)*4+((i)%3)) /* RW-2A */
#define NV_PDFB_DATA016__SIZE_1                             1572864 /*       */
#define NV_PDFB_DATA016_VALUE                                  15:0 /* RWXVF */
#define NV_PDFB_DATA008(i)                         (0x01000000+(i)) /* RW-1A */
#define NV_PDFB_DATA008__SIZE_1                             2097152 /*       */
#define NV_PDFB_DATA008_VALUE                                   7:0 /* RWXVF */
/* dev_ram.ref */
#define NV_PRAM                               0x00006FFF:0x00006000 /* RW--D */
/* dev_ext_devices.ref */
#define NV_PEXTDEV                            0x00101FFF:0x00101000 /* RW--D */
#define NV_PEXTDEV_BOOT_0                                0x00101000 /* RW-4R */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED                       0:0 /* RWXVF */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED_33MHZ          0x00000000 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED_66MHZ          0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR                      1:1 /* RWXVF */
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_NO_BIOS       0x00000000 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_BIOS          0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE                        2:2 /* RWXVF */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_SGRAM_16MBIT    0x00000000 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_SGRAM_8MBIT     0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_NEC_MODE                        3:3 /* RWXVF */
#define NV_PEXTDEV_BOOT_0_STRAP_NEC_MODE_OFF             0x00000000 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_NEC_MODE_ON              0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH                       4:4 /* RWXVF */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH_64             0x00000000 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH_128            0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE                        5:5 /* RWXVF */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_PCI             0x00000000 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_AGP             0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL                         6:6 /* RWXVF */
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_13500K           0x00000000 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_14318180         0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE                          8:7 /* RWXVF */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_SECAM             0x00000000 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_NTSC              0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_PAL               0x00000002 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_DISABLED          0x00000003 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_2X                          9:9 /* RWXVF */
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_2X_ENABLED           0x00000000 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_AGP_2X_DISABLED          0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_UNUSED                        10:10 /* RWXVF */
#define NV_PEXTDEV_BOOT_0_STRAP_OVERWRITE                     11:11 /* RWIVF */
#define NV_PEXTDEV_BOOT_0_STRAP_OVERWRITE_DISABLED       0x00000000 /* RWI-V */
#define NV_PEXTDEV_BOOT_0_STRAP_OVERWRITE_ENABLED        0x00000001 /* RW--V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_EDO             0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_SGRAM_256K      0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_NEC_EDO         0x00000002 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_NEC_SGRAM       0x00000003 /* R---V */
/* dev_ext_devices.ref */
#define NV_PDAC                               0x00680FFF:0x00680000 /* RW--D */
#define NV_PDAC_DATA(i)                          (0x00500000+(i)*4) /* RW-4A */
#define NV_PDAC_DATA__SIZE_1                                     16 /*       */
#define NV_PDAC_DATA_VALUE                                      7:0 /* RW-VF */
/* dev_ext_devices.ref */
/* dev_ext_devices.ref */
#define NV_PROM                               0x0011FFFF:0x00110000 /* RW--D */
#define NV_PROM_DATA(i)                            (0x00110000+(i)) /* RW-1A */
#define NV_PROM_DATA__SIZE_1                                  65536 /*       */
#define NV_PROM_DATA_VALUE                                      7:0 /* RW-VF */
/* dev_ext_devices.ref */
#define NV_PALT                               0x0012FFFF:0x00120000 /* RW--D */
#define NV_PALT_DATA(i)                            (0x00120000+(i)) /* RW-1A */
#define NV_PALT_DATA__SIZE_1                                  65536 /*       */
#define NV_PALT_DATA_VALUE                                      7:0 /* RW-VF */
/* dev_realmode.ref */
#define NV_PRM                                0x00005FFF:0x00004000 /* RW--D */
#define NV_PRM_INTR_0                                    0x00004100 /* RW-4R */
#define NV_PRM_INTR_0_TRACE_MPU401                              0:0 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_MPU401_NOT_PENDING           0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_MPU401_PENDING               0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_MPU401_RESET                 0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_FM                                  4:4 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_FM_NOT_PENDING               0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_FM_PENDING                   0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_FM_RESET                     0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL                          8:8 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL_NOT_PENDING       0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL_PENDING           0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL_RESET             0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_SB_MIXER                          12:12 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_SB_MIXER_NOT_PENDING         0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_MIXER_PENDING             0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_MIXER_RESET               0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW                          16:16 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_NOT_PENDING         0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_PENDING             0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_RESET               0x00000001 /* -W--V */
#define NV_PRM_INTR_EN_0                                 0x00004140 /* RW-4R */
#define NV_PRM_INTR_EN_0_TRACE_MPU401                           0:0 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_MPU401_DISABLED           0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_MPU401_ENABLED            0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_FM                               4:4 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_FM_DISABLED               0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_FM_ENABLED                0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL                       8:8 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL_DISABLED       0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL_ENABLED        0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_SB_MIXER                       12:12 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_SB_MIXER_DISABLED         0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_SB_MIXER_ENABLED          0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW                       16:16 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW_DISABLED         0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW_ENABLED          0x00000001 /* RW--V */
#define NV_PRM_RAMRM                                     0x00004200 /* RW-4R */
#define NV_PRM_RAMRM_BASE_ADDRESS                             15:12 /* RWXVF */
#define NV_PRM_RAMRM_BASE_ADDRESS_2000                   0x00002000 /* RWI-V */
#define NV_PRM_TRACE                                     0x00004300 /* RW-4R */
#define NV_PRM_TRACE_IO_CAPTURE                                 1:0 /* RWIVF */
#define NV_PRM_TRACE_IO_CAPTURE_DISABLED                 0x00000000 /* RWI-V */
#define NV_PRM_TRACE_IO_CAPTURE_WRITES                   0x00000001 /* RW--V */
#define NV_PRM_TRACE_IO_CAPTURE_READS                    0x00000002 /* RW--V */
#define NV_PRM_TRACE_IO_CAPTURE_READS_WRITES             0x00000003 /* RW--V */
#define NV_PRM_TRACE_IO_WRITE                                   4:4 /* RWXVF */
#define NV_PRM_TRACE_IO_WRITE_NONE                       0x00000000 /* R---V */
#define NV_PRM_TRACE_IO_WRITE_OCCURED                    0x00000001 /* R---V */
#define NV_PRM_TRACE_IO_WRITE_RESET                      0x00000001 /* -W--V */
#define NV_PRM_TRACE_IO_READ                                    5:5 /* RWXVF */
#define NV_PRM_TRACE_IO_READ_NONE                        0x00000000 /* R---V */
#define NV_PRM_TRACE_IO_READ_OCCURED                     0x00000001 /* R---V */
#define NV_PRM_TRACE_IO_READ_RESET                       0x00000001 /* -W--V */
#define NV_PRM_TRACE_INDEX                               0x00004310 /* RW-4R */
#define NV_PRM_TRACE_INDEX_ADDRESS                              9:0 /* RWXUF */
#define NV_PRM_TRACE_INDEX_ADDRESS_0                     0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0                                  0x00004320 /* RW-4R */
#define NV_PRM_IGNORE_0_MPU401                                  1:0 /* RWXVF */
#define NV_PRM_IGNORE_0_MPU401_DISABLED                  0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401_WRITES                    0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401_READS                     0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401_READS_WRITES              0x00000003 /* RW--V */
#define NV_PRM_IGNORE_0_FM                                      5:4 /* RWXVF */
#define NV_PRM_IGNORE_0_FM_DISABLED                      0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_FM_WRITES                        0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_FM_READS                         0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_FM_READS_WRITES                  0x00000003 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL                              9:8 /* RWXVF */
#define NV_PRM_IGNORE_0_SB_DIGITAL_DISABLED              0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL_WRITES                0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL_READS                 0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL_READS_WRITES          0x00000003 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER                              13:12 /* RWXVF */
#define NV_PRM_IGNORE_0_SB_MIXER_DISABLED                0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER_WRITES                  0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER_READS                   0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER_READS_WRITES            0x00000003 /* RW--V */
/* dev_realmode.ref */
#define NV_PRMIO                              0x00007FFF:0x00007000 /* RW--D */
/* dev_realmode.ref */
/* dev_fifo.ref */
#define NV_USER                               0x00FFFFFF:0x00800000 /* RW--D */
#define NV_USER_OBJECT(i,j)     (0x00800000+(i)*0x10000+(j)*0x2000) /* -W-4A */
#define NV_USER_OBJECT__SIZE_1                                  128 /*       */
#define NV_USER_OBJECT__SIZE_2                                    8 /*       */
#define NV_USER_OBJECT_HANDLE                                  31:0 /* -W-VF */
#define NV_USER_FREE016(i,j)        (0x00800010+(i)*65536+(j)*8192) /* R--2A */
#define NV_USER_FREE016__SIZE_1                                 128 /*       */
#define NV_USER_FREE016__SIZE_2                                   8 /*       */
#define NV_USER_FREE016_COUNT_LO                                1:0 /* C--UF */
#define NV_USER_FREE016_COUNT_LO_0                       0x00000000 /* C---V */
#define NV_USER_FREE016_COUNT                                   9:2 /* R--UF */
#define NV_USER_FREE016_COUNT_HI                              15:10 /* C--UF */
#define NV_USER_FREE016_COUNT_HI_0                       0x00000000 /* C---V */
#define NV_USER_FREE032(i,j)        (0x00800010+(i)*65536+(j)*8192) /* R--4A */
#define NV_USER_FREE032__SIZE_1                                 128 /*       */
#define NV_USER_FREE032__SIZE_2                                   8 /*       */
#define NV_USER_FREE032_COUNT_LO                                1:0 /* C--UF */
#define NV_USER_FREE032_COUNT_LO_0                       0x00000000 /* C---V */
#define NV_USER_FREE032_COUNT                                   9:2 /* R--UF */
#define NV_USER_FREE032_COUNT_HI                              31:10 /* C--UF */
#define NV_USER_FREE032_COUNT_HI_0                       0x00000000 /* C---V */
#define NV_USER_ZERO016(i,j,k) (0x0800012+(i)*65536+(j)*8192+(k)*2) /* R--2A */
#define NV_USER_ZERO016__SIZE_1                                 128 /*       */
#define NV_USER_ZERO016__SIZE_2                                   8 /*       */
#define NV_USER_ZERO016__SIZE_3                                   7 /*       */
#define NV_USER_ZERO016_COUNT                                  15:0 /* C--UF */
#define NV_USER_ZERO016_COUNT_0                          0x00000000 /* C---V */
#define NV_USER_ZERO032(i,j,k) (0x0800014+(i)*65536+(j)*8192+(k)*4) /* R--4A */
#define NV_USER_ZERO032__SIZE_1                                 128 /*       */
#define NV_USER_ZERO032__SIZE_2                                   8 /*       */
#define NV_USER_ZERO032__SIZE_3                                   3 /*       */
#define NV_USER_ZERO032_COUNT                                  31:0 /* C--UF */
#define NV_USER_ZERO032_COUNT_0                          0x00000000 /* C---V */
/* dev_misc.ref */
#define NV_USER_ADR_CHID                                      22:16 /*       */
#define NV_USER_ADR_SUBCHID                                   15:13 /*       */
#define NV_USER_ADR_METHOD                                     12:0 /*       */
#define NV_USER_DEVICE                                        22:16 /*       */
/* dev_timer.ref */
#define NV_PTIMER                             0x00009FFF:0x00009000 /* RW--D */
#define NV_PTIMER_INTR_0                                 0x00009100 /* RW-4R */
#define NV_PTIMER_INTR_0_ALARM                                  0:0 /* RWXVF */
#define NV_PTIMER_INTR_0_ALARM_NOT_PENDING               0x00000000 /* R---V */
#define NV_PTIMER_INTR_0_ALARM_PENDING                   0x00000001 /* R---V */
#define NV_PTIMER_INTR_0_ALARM_RESET                     0x00000001 /* -W--V */
#define NV_PTIMER_INTR_EN_0                              0x00009140 /* RW-4R */
#define NV_PTIMER_INTR_EN_0_ALARM                               0:0 /* RWIVF */
#define NV_PTIMER_INTR_EN_0_ALARM_DISABLED               0x00000000 /* RWI-V */
#define NV_PTIMER_INTR_EN_0_ALARM_ENABLED                0x00000001 /* RW--V */
#define NV_PTIMER_NUMERATOR                              0x00009200 /* RW-4R */
#define NV_PTIMER_NUMERATOR_VALUE                              15:0 /* RWIUF */
#define NV_PTIMER_NUMERATOR_VALUE_0                      0x00000000 /* RWI-V */
#define NV_PTIMER_DENOMINATOR                            0x00009210 /* RW-4R */
#define NV_PTIMER_DENOMINATOR_VALUE                            15:0 /* RWIUF */
#define NV_PTIMER_DENOMINATOR_VALUE_0                    0x00000000 /* RWI-V */
#define NV_PTIMER_TIME_0                                 0x00009400 /* RW-4R */
#define NV_PTIMER_TIME_0_NSEC                                  31:5 /* RWXUF */
#define NV_PTIMER_TIME_1                                 0x00009410 /* RW-4R */
#define NV_PTIMER_TIME_1_NSEC                                  28:0 /* RWXUF */
#define NV_PTIMER_ALARM_0                                0x00009420 /* RW-4R */
#define NV_PTIMER_ALARM_0_NSEC                                 31:5 /* RWXUF */
/* dev_realmode.ref */
#define NV_TRACE                              0x0000FFFF:0x00000000 /* RW--M */
#define NV_TRACE_DATA                         ( 0*32+ 7):( 0*32+ 0) /* RWXVF */
#define NV_TRACE_ACCESS                       ( 0*32+14):( 0*32+14) /* RWXVF */
#define NV_TRACE_ACCESS_WRITE                            0x00000000 /* RW--V */
#define NV_TRACE_ACCESS_READ                             0x00000001 /* RW--V */
#define NV_TRACE_TYPE                         ( 0*32+15):( 0*32+15) /* RWXVF */
#define NV_TRACE_TYPE_IO                                 0x00000000 /* RW--V */
#define NV_TRACE_TYPE_MEMORY                             0x00000001 /* RW--V */
#define NV_TRACE_ADDRESS                      ( 0*32+31):( 0*32+16) /* RWXUF */
/* dev_ram.ref */
#define NV_RAMHT__SIZE_0                      0x00000FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_1                      0x00001FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_2                      0x00003FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_3                      0x00007FFF:0x00000000 /* RW--M */
#define NV_RAMHT_HANDLE                       ( 0*32+31):( 0*32+ 0) /* RWXVF */
#define NV_RAMHT_INSTANCE                     ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_RAMHT_DEVICE                       ( 1*32+22):( 1*32+16) /* RWXUF */
#define NV_RAMHT_ENGINE                       ( 1*32+23):( 1*32+23) /* RWXVF */
#define NV_RAMHT_ENGINE_SW                               0x00000000 /* RW--V */
#define NV_RAMHT_ENGINE_GRAPHICS                         0x00000001 /* RW--V */
#define NV_RAMHT_CHID                         ( 1*32+30):( 1*32+24) /* RWXUF */
/* dev_ram.ref */
#define NV_RAMRO__SIZE_0                      0x000001FF:0x00000000 /* RW--M */
#define NV_RAMRO__SIZE_1                      0x00001FFF:0x00000000 /* RW--M */
#define NV_RAMRO_METHOD                       ( 0*32+15):( 0*32+ 0) /* RWXUF */
#define NV_RAMRO_CHID                         ( 0*32+22):( 0*32+16) /* RWXUF */
#define NV_RAMRO_TYPE                         ( 0*32+23):( 0*32+23) /* RWXVF */
#define NV_RAMRO_TYPE_WRITE                              0x00000000 /* RW--V */
#define NV_RAMRO_TYPE_READ                               0x00000001 /* RW--V */
#define NV_RAMRO_BYTE_ENABLES                 ( 0*32+27):( 0*32+24) /* RWXVF */
#define NV_RAMRO_REASON                       ( 0*32+31):( 0*32+28) /* RWXVF */
#define NV_RAMRO_REASON_ILLEGAL_ACCESS                   0x00000000 /* RW--V */
#define NV_RAMRO_REASON_NO_CACHE_AVAILABLE               0x00000001 /* RW--V */
#define NV_RAMRO_REASON_CACHE_RAN_OUT                    0x00000002 /* RW--V */
#define NV_RAMRO_REASON_FREE_COUNT_OVERRUN               0x00000003 /* RW--V */
#define NV_RAMRO_REASON_CAUGHT_LYING                     0x00000004 /* RW--V */
#define NV_RAMRO_REASON_RESERVED_ACCESS                  0x00000005 /* RW--V */
#define NV_RAMRO_DATA                         ( 1*32+31):( 1*32+ 0) /* RWXVF */
/* dev_ram.ref */
/* dev_ram.ref */
#define NV_RAMFC__SIZE_0                      0x000001FF:0x00000000 /* RW--M */
#define NV_RAMFC__SIZE_1                      0x00000FFF:0x00000000 /* RW--M */
#define NV_RAMFC_INSTANCE_0                   ( 0*32+15):( 0*32+ 0) /* RWXUF */
#define NV_RAMFC_DEVICE_0                     ( 0*32+22):( 0*32+16) /* RWXUF */
#define NV_RAMFC_DEVICE_0_NOT_FOUND                      0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_0                     ( 0*32+23):( 0*32+23) /* RWXVF */
#define NV_RAMFC_ENGINE_0_SW                             0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_0_GRAPHICS                       0x00000001 /* RW--V */
#define NV_RAMFC_INSTANCE_1                   ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_RAMFC_DEVICE_1                     ( 1*32+22):( 1*32+16) /* RWXUF */
#define NV_RAMFC_DEVICE_1_NOT_FOUND                      0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_1                     ( 1*32+23):( 1*32+23) /* RWXVF */
#define NV_RAMFC_ENGINE_1_SW                             0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_1_GRAPHICS                       0x00000001 /* RW--V */
#define NV_RAMFC_INSTANCE_7                   ( 7*32+15):( 7*32+ 0) /* RWXUF */
#define NV_RAMFC_DEVICE_7                     ( 7*32+22):( 7*32+16) /* RWXUF */
#define NV_RAMFC_DEVICE_7_NOT_FOUND                      0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_7                     ( 7*32+23):( 7*32+23) /* RWXVF */
#define NV_RAMFC_ENGINE_7_SW                             0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_7_GRAPHICS                       0x00000001 /* RW--V */
/* dev_ram.ref */
/* dev_ram.ref */
/* dev_ram.ref */
#define NV_DMA_ADJUST                         ( 0*32+11):( 0*32+ 0) /* RWXUF */
#define NV_DMA_PAGE_TABLE                     ( 0*32+16):( 0*32+16) /* RWXVF */
#define NV_DMA_PAGE_TABLE_NOT_PRESENT                    0x00000000 /* RW--V */
#define NV_DMA_PAGE_TABLE_PRESENT                        0x00000001 /* RW--V */
#define NV_DMA_TARGET_NODE                    ( 0*32+25):( 0*32+24) /* RWXVF */
#define NV_DMA_TARGET_NODE_NVM                           0x00000000 /* RW--V */
#define NV_DMA_TARGET_NODE_PCI                           0x00000002 /* RW--V */
#define NV_DMA_TARGET_NODE_AGP                           0x00000003 /* RW--V */
#define NV_DMA_LIMIT                          ( 1*32+31):( 1*32+ 0) /* RWXUF */
#define NV_DMA_PAGE                           ( 2*32+ 0):( 2*32+ 0) /* RWXVF */
#define NV_DMA_PAGE_NOT_PRESENT                          0x00000000 /* RW--V */
#define NV_DMA_PAGE_PRESENT                              0x00000001 /* RW--V */
#define NV_DMA_ACCESS                         ( 2*32+ 1):( 2*32+ 1) /* RWXVF */
#define NV_DMA_ACCESS_READ_ONLY                          0x00000000 /* RW--V */
#define NV_DMA_ACCESS_READ_AND_WRITE                     0x00000001 /* RW--V */
#define NV_DMA_FRAME_ADDRESS                  ( 2*32+31):( 2*32+12) /* RWXUF */
/* dev_ram.ref */
#define NV_SUBCHAN_CTX_SWITCH                 ( 0*32+31):( 0*32+ 0) /* RWXUF */
#define NV_SUBCHAN_DMA_INSTANCE               ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_SUBCHAN_NOTIFY_INSTANCE            ( 1*32+31):( 1*32+16) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_INSTANCE            ( 2*32+15):( 2*32+ 0) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_LINEAR              ( 2*32+16):( 2*32+16) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_LINEAR_OUT                     0x00000000 /* RW--V */
#define NV_SUBCHAN_MEMFMT_LINEAR_IN                      0x00000001 /* RW--V */
/* dev_ram.ref */
/* dev_ram.ref */
/* dev_ram.ref */
#endif /* _NV_REF_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nv1c_ref.h ===
/* %W% %E% NVidia Corporation */

#ifndef _NV_REF_H_
#define _NV_REF_H_

/* dev_bus.ref */
#define NV_SPACE                              0x01FFFFFF:0x00000000 /* RW--D */
/* dev_bus.ref */
#define NV_CONFIG                             0x000001FF:0x00000000 /* RW--D */
#define NV_CONFIG_PCI_VGA_0                              0x00000000 /* R--4R */
#define NV_CONFIG_PCI_VGA_0__ALIAS_1              NV_PBUS_PCI_VGA_0 /*       */
#define NV_CONFIG_PCI_VGA_0_VENDOR_ID                          15:0 /* R--VF */
#define NV_CONFIG_PCI_VGA_0_VENDOR_ID_NVIDIA             0x000010DE /* R---V */
#define NV_CONFIG_PCI_VGA_0_VENDOR_ID_SGS                0x0000104A /* R---V */
#define NV_CONFIG_PCI_VGA_0_DEVICE_ID_FUNC                    18:16 /* C--UF */
#define NV_CONFIG_PCI_VGA_0_DEVICE_ID_FUNC_VGA           0x00000000 /* C---V */
#define NV_CONFIG_PCI_VGA_0_DEVICE_ID_FUNC_NV            0x00000001 /* ----V */
#define NV_CONFIG_PCI_VGA_0_DEVICE_ID_CHIP                    31:19 /* C--UF */
#define NV_CONFIG_PCI_VGA_0_DEVICE_ID_CHIP_NV0           0x00000000 /* ----V */
#define NV_CONFIG_PCI_VGA_0_DEVICE_ID_CHIP_NV1           0x00000001 /* C---V */
#define NV_CONFIG_PCI_VGA_0_DEVICE_ID_CHIP_NV2           0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_0                               0x00000100 /* R--4R */
#define NV_CONFIG_PCI_NV_0__ALIAS_1                NV_PBUS_PCI_NV_0 /*       */
#define NV_CONFIG_PCI_NV_0_VENDOR_ID                           15:0 /* R--VF */
#define NV_CONFIG_PCI_NV_0_VENDOR_ID_NVIDIA              0x000010DE /* R---V */
#define NV_CONFIG_PCI_NV_0_VENDOR_ID_SGS                 0x0000104A /* R---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_FUNC                     18:16 /* C--UF */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_FUNC_VGA            0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_FUNC_NV             0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP                     31:19 /* C--UF */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV0            0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV1            0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CHIP_NV2            0x00000002 /* ----V */
#define NV_CONFIG_PCI_VGA_1                              0x00000004 /* RW-4R */
#define NV_CONFIG_PCI_VGA_1__ALIAS_1              NV_PBUS_PCI_VGA_1 /*       */
#define NV_CONFIG_PCI_VGA_1_IO_SPACE                            0:0 /* RWIVF */
#define NV_CONFIG_PCI_VGA_1_IO_SPACE_DISABLED            0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_VGA_1_IO_SPACE_ENABLED             0x00000001 /* RW--V */
#define NV_CONFIG_PCI_VGA_1_MEMORY_SPACE                        1:1 /* RWIVF */
#define NV_CONFIG_PCI_VGA_1_MEMORY_SPACE_DISABLED        0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_VGA_1_MEMORY_SPACE_ENABLED         0x00000001 /* RW--V */
#define NV_CONFIG_PCI_VGA_1_PALETTE_SNOOP                       5:5 /* RWIVF */
#define NV_CONFIG_PCI_VGA_1_PALETTE_SNOOP_DISABLED       0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_VGA_1_PALETTE_SNOOP_ENABLED        0x00000001 /* RW--V */
#define NV_CONFIG_PCI_VGA_1_FAST_BACK2BACK                    23:23 /* C--VF */
#define NV_CONFIG_PCI_VGA_1_FAST_BACK2BACK_INCAPABLE     0x00000000 /* ----V */
#define NV_CONFIG_PCI_VGA_1_FAST_BACK2BACK_CAPABLE       0x00000001 /* C---V */
#define NV_CONFIG_PCI_VGA_1_DEVSEL_TIMING                     26:25 /* C--VF */
#define NV_CONFIG_PCI_VGA_1_DEVSEL_TIMING_FAST           0x00000000 /* ----V */
#define NV_CONFIG_PCI_VGA_1_DEVSEL_TIMING_MEDIUM         0x00000001 /* C---V */
#define NV_CONFIG_PCI_VGA_1_DEVSEL_TIMING_SLOW           0x00000002 /* ----V */
#define NV_CONFIG_PCI_VGA_1_SIGNALED_TARGET                   27:27 /* RWIVF */
#define NV_CONFIG_PCI_VGA_1_SIGNALED_TARGET_NO_ABORT     0x00000000 /* R-I-V */
#define NV_CONFIG_PCI_VGA_1_SIGNALED_TARGET_ABORT        0x00000001 /* R---V */
#define NV_CONFIG_PCI_VGA_1_SIGNALED_TARGET_CLEAR        0x00000001 /* -W--V */
#define NV_CONFIG_PCI_NV_1                               0x00000104 /* RW-4R */
#define NV_CONFIG_PCI_NV_1__ALIAS_1                NV_PBUS_PCI_NV_1 /*       */
#define NV_CONFIG_PCI_NV_1_IO_SPACE                             0:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_IO_SPACE_DISABLED             0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_IO_SPACE_ENABLED              0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_MEMORY_SPACE                         1:1 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_MEMORY_SPACE_DISABLED         0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_MEMORY_SPACE_ENABLED          0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_BUS_MASTER                           2:2 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_BUS_MASTER_DISABLED           0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_BUS_MASTER_ENABLED            0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL                      4:4 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL_DISABLED      0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_WRITE_AND_INVAL_ENABLED       0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_SERR                                 8:8 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_SERR_DISABLED                 0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_1_SERR_ENABLED                  0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_1_FAST_BACK2BACK                     23:23 /* C--VF */
#define NV_CONFIG_PCI_NV_1_FAST_BACK2BACK_INCAPABLE      0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_1_FAST_BACK2BACK_CAPABLE        0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING                      26:25 /* C--VF */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_FAST            0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_MEDIUM          0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_1_DEVSEL_TIMING_SLOW            0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET                    28:28 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_NO_ABORT      0x00000000 /* R-I-V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_ABORT         0x00000001 /* R---V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_TARGET_CLEAR         0x00000001 /* -W--V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER                    29:29 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_NO_ABORT      0x00000000 /* R-I-V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_ABORT         0x00000001 /* R---V */
#define NV_CONFIG_PCI_NV_1_RECEIVED_MASTER_CLEAR         0x00000001 /* -W--V */
#define NV_CONFIG_PCI_NV_1_SYSTEM_ERROR                       30:30 /* RWIVF */
#define NV_CONFIG_PCI_NV_1_SYSTEM_ERROR_NOT_SIGNALED     0x00000000 /* R-I-V */
#define NV_CONFIG_PCI_NV_1_SYSTEM_ERROR_SIGNALED         0x00000001 /* R---V */
#define NV_CONFIG_PCI_NV_1_SYSTEM_ERROR_CLEAR            0x00000001 /* -W--V */
#define NV_CONFIG_PCI_VGA_2                              0x00000008 /* R--4R */
#define NV_CONFIG_PCI_VGA_2__ALIAS_1              NV_PBUS_PCI_VGA_2 /*       */
#define NV_CONFIG_PCI_VGA_2_REVISION_ID                         7:0 /* C--UF */
#define NV_CONFIG_PCI_VGA_2_REVISION_ID_A                0x00000000 /* ----V */
#define NV_CONFIG_PCI_VGA_2_REVISION_ID_B                0x00000001 /* ----V */
#define NV_CONFIG_PCI_VGA_2_REVISION_ID_B02              0x00000002 /* ----V */
#define NV_CONFIG_PCI_VGA_2_REVISION_ID_B03              0x00000003 /* C---V */
#define NV_CONFIG_PCI_VGA_2_REVISION_ID_C01              0x00000004 /* ----V */
#define NV_CONFIG_PCI_VGA_2_CLASS_CODE                         31:8 /* C--VF */
#define NV_CONFIG_PCI_VGA_2_CLASS_CODE_VGA               0x00030000 /* C---V */
#define NV_CONFIG_PCI_VGA_2_CLASS_CODE_MULTIMEDIA        0x00048000 /* ----V */
#define NV_CONFIG_PCI_NV_2                               0x00000108 /* R--4R */
#define NV_CONFIG_PCI_NV_2__ALIAS_1                NV_PBUS_PCI_NV_2 /*       */
#define NV_CONFIG_PCI_NV_2_REVISION_ID                          7:0 /* C--UF */
#define NV_CONFIG_PCI_NV_2_REVISION_ID_A                 0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_2_REVISION_ID_B                 0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_2_REVISION_ID_B02               0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_2_REVISION_ID_B03               0x00000003 /* C---V */
#define NV_CONFIG_PCI_NV_2_REVISION_ID_C01               0x00000004 /* ----V */
#define NV_CONFIG_PCI_NV_2_CLASS_CODE                          31:8 /* C--VF */
#define NV_CONFIG_PCI_NV_2_CLASS_CODE_VGA                0x00030000 /* ----V */
#define NV_CONFIG_PCI_NV_2_CLASS_CODE_MULTIMEDIA         0x00048000 /* C---V */
#define NV_CONFIG_PCI_VGA_3                              0x0000000C /* RW-4R */
#define NV_CONFIG_PCI_VGA_3__ALIAS_1              NV_PBUS_PCI_VGA_3 /*       */
#define NV_CONFIG_PCI_VGA_3_HEADER_TYPE                       23:16 /* C--VF */
#define NV_CONFIG_PCI_VGA_3_HEADER_TYPE_MULTIFUNC        0x00000080 /* C---V */
#define NV_CONFIG_PCI_NV_3                               0x0000010C /* RW-4R */
#define NV_CONFIG_PCI_NV_3__ALIAS_1                NV_PBUS_PCI_NV_3 /*       */
#define NV_CONFIG_PCI_NV_3_CACHE_LINE_SIZE                      7:0 /* RWIUF */
#define NV_CONFIG_PCI_NV_3_CACHE_LINE_SIZE_0_DWORDS      0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER                      15:11 /* RWIUF */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_0_CLOCKS        0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_8_CLOCKS        0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_240_CLOCKS      0x0000001E /* RW--V */
#define NV_CONFIG_PCI_NV_3_LATENCY_TIMER_248_CLOCKS      0x0000001F /* RW--V */
#define NV_CONFIG_PCI_NV_3_HEADER_TYPE                        23:16 /* C--VF */
#define NV_CONFIG_PCI_NV_3_HEADER_TYPE_MULTIFUNC         0x00000080 /* C---V */
#define NV_CONFIG_PCI_NV_4                               0x00000110 /* RW-4R */
#define NV_CONFIG_PCI_NV_4__ALIAS_1                NV_PBUS_PCI_NV_4 /*       */
#define NV_CONFIG_PCI_NV_4_SPACE_TYPE                           0:0 /* C--VF */
#define NV_CONFIG_PCI_NV_4_SPACE_TYPE_MEMORY             0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_4_SPACE_TYPE_IO                 0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE                         2:1 /* C--VF */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_32_BIT           0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_20_BIT           0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_4_ADDRESS_TYPE_64_BIT           0x00000002 /* ----V */
#define NV_CONFIG_PCI_NV_4_PREFETCHABLE                         3:3 /* C--VF */
#define NV_CONFIG_PCI_NV_4_PREFETCHABLE_NOT              0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_4_PREFETCHABLE_MERGABLE         0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_4_BASE_ADDRESS                       31:25 /* RWIUF */
#define NV_CONFIG_PCI_NV_4_BASE_ADDRESS_0                0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_VGA_4(i)                   (0x00000010+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_VGA_4__SIZE_1                               6 /*       */
#define NV_CONFIG_PCI_VGA_4__ALIAS_1              NV_PBUS_PCI_VGA_4 /*       */
#define NV_CONFIG_PCI_VGA_4_RESERVED                           31:0 /* C--VF */
#define NV_CONFIG_PCI_VGA_4_RESERVED_0                   0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_5(i)                    (0x00000114+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_NV_5__SIZE_1                                5 /*       */
#define NV_CONFIG_PCI_NV_5__ALIAS_1                NV_PBUS_PCI_NV_5 /*       */
#define NV_CONFIG_PCI_NV_5_RESERVED                            31:0 /* C--VF */
#define NV_CONFIG_PCI_NV_5_RESERVED_0                    0x00000000 /* C---V */
#define NV_CONFIG_PCI_VGA_10(i)                  (0x00000028+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_VGA_10__SIZE_1                              2 /*       */
#define NV_CONFIG_PCI_VGA_10__ALIAS_1            NV_PBUS_PCI_VGA_10 /*       */
#define NV_CONFIG_PCI_VGA_10_RESERVED                          31:0 /* C--VF */
#define NV_CONFIG_PCI_VGA_10_RESERVED_0                  0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_10(i)                   (0x00000128+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_NV_10__SIZE_1                               2 /*       */
#define NV_CONFIG_PCI_NV_10__ALIAS_1              NV_PBUS_PCI_NV_10 /*       */
#define NV_CONFIG_PCI_NV_10_RESERVED                           31:0 /* C--VF */
#define NV_CONFIG_PCI_NV_10_RESERVED_0                   0x00000000 /* C---V */
#define NV_CONFIG_PCI_VGA_12                             0x00000030 /* RW-4R */
#define NV_CONFIG_PCI_VGA_12__ALIAS_1            NV_PBUS_PCI_VGA_12 /*       */
#define NV_CONFIG_PCI_VGA_12_ROM_DECODE                         0:0 /* RWIVF */
#define NV_CONFIG_PCI_VGA_12_ROM_DECODE_DISABLED         0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_VGA_12_ROM_DECODE_ENABLED          0x00000001 /* RW--V */
#define NV_CONFIG_PCI_VGA_12_ROM_BASE                         31:22 /* RWXUF */
#define NV_CONFIG_PCI_NV_12                              0x00000130 /* RW-4R */
#define NV_CONFIG_PCI_NV_12__ALIAS_1              NV_PBUS_PCI_NV_12 /*       */
#define NV_CONFIG_PCI_NV_12_ROM_DECODE                          0:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_12_ROM_DECODE_DISABLED          0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_12_ROM_DECODE_ENABLED           0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_12_ROM_BASE                          31:22 /* RWXUF */
#define NV_CONFIG_PCI_VGA_13(i)                  (0x00000034+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_VGA_13__SIZE_1                              2 /*       */
#define NV_CONFIG_PCI_VGA_13__ALIAS_1            NV_PBUS_PCI_VGA_13 /*       */
#define NV_CONFIG_PCI_VGA_13_RESERVED                          31:0 /* C--VF */
#define NV_CONFIG_PCI_VGA_13_RESERVED_0                  0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_13(i)                   (0x00000134+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_NV_13__SIZE_1                               2 /*       */
#define NV_CONFIG_PCI_NV_13__ALIAS_1              NV_PBUS_PCI_NV_13 /*       */
#define NV_CONFIG_PCI_NV_13_RESERVED                           31:0 /* C--VF */
#define NV_CONFIG_PCI_NV_13_RESERVED_0                   0x00000000 /* C---V */
#define NV_CONFIG_PCI_VGA_15                             0x0000003C /* RW-4R */
#define NV_CONFIG_PCI_VGA_15__ALIAS_1            NV_PBUS_PCI_VGA_15 /*       */
#define NV_CONFIG_PCI_VGA_15_INTR_LINE                          7:0 /* RWIVF */
#define NV_CONFIG_PCI_VGA_15_INTR_LINE_IRQ0              0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_VGA_15_INTR_LINE_IRQ1              0x00000001 /* RW--V */
#define NV_CONFIG_PCI_VGA_15_INTR_LINE_IRQ15             0x0000000F /* RW--V */
#define NV_CONFIG_PCI_VGA_15_INTR_LINE_UNKNOWN           0x000000FF /* RW--V */
#define NV_CONFIG_PCI_VGA_15_INTR_PIN                          15:8 /* C--VF */
#define NV_CONFIG_PCI_VGA_15_INTR_PIN_INTA               0x00000001 /* C---V */
#define NV_CONFIG_PCI_VGA_15_MIN_GNT                          23:16 /* C--VF */
#define NV_CONFIG_PCI_VGA_15_MIN_GNT_NO_REQUIREMENTS     0x00000000 /* C---V */
#define NV_CONFIG_PCI_VGA_15_MIN_GNT_750NS               0x00000003 /* ----V */
#define NV_CONFIG_PCI_VGA_15_MAX_LAT                          31:24 /* C--VF */
#define NV_CONFIG_PCI_VGA_15_MAX_LAT_NO_REQUIREMENTS     0x00000000 /* C---V */
#define NV_CONFIG_PCI_VGA_15_MAX_LAT_250NS               0x00000001 /* ----V */
#define NV_CONFIG_PCI_NV_15                              0x0000013C /* RW-4R */
#define NV_CONFIG_PCI_NV_15__ALIAS_1              NV_PBUS_PCI_NV_15 /*       */
#define NV_CONFIG_PCI_NV_15_INTR_LINE                           7:0 /* RWIVF */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ0               0x00000000 /* RWI-V */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ1               0x00000001 /* RW--V */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_IRQ15              0x0000000F /* RW--V */
#define NV_CONFIG_PCI_NV_15_INTR_LINE_UNKNOWN            0x000000FF /* RW--V */
#define NV_CONFIG_PCI_NV_15_INTR_PIN                           15:8 /* C--VF */
#define NV_CONFIG_PCI_NV_15_INTR_PIN_INTA                0x00000001 /* C---V */
#define NV_CONFIG_PCI_NV_15_MIN_GNT                           23:16 /* C--VF */
#define NV_CONFIG_PCI_NV_15_MIN_GNT_NO_REQUIREMENTS      0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_15_MIN_GNT_750NS                0x00000003 /* C---V */
#define NV_CONFIG_PCI_NV_15_MAX_LAT                           31:24 /* C--VF */
#define NV_CONFIG_PCI_NV_15_MAX_LAT_NO_REQUIREMENTS      0x00000000 /* ----V */
#define NV_CONFIG_PCI_NV_15_MAX_LAT_250NS                0x00000001 /* C---V */
#define NV_CONFIG_PCI_VGA_16(i)                  (0x00000040+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_VGA_16__SIZE_1                             48 /*       */
#define NV_CONFIG_PCI_VGA_16__ALIAS_1            NV_PBUS_PCI_VGA_16 /*       */
#define NV_CONFIG_PCI_VGA_16_RESERVED                          31:0 /* C--VF */
#define NV_CONFIG_PCI_VGA_16_RESERVED_0                  0x00000000 /* C---V */
#define NV_CONFIG_PCI_NV_16(i)                   (0x00000140+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_NV_16__SIZE_1                              48 /*       */
#define NV_CONFIG_PCI_NV_16__ALIAS_1              NV_PBUS_PCI_NV_16 /*       */
#define NV_CONFIG_PCI_NV_16_RESERVED                           31:0 /* C--VF */
#define NV_CONFIG_PCI_NV_16_RESERVED_0                   0x00000000 /* C---V */
/* dev_bus.ref */
#define NV_MEMORY                             0xFFFFFFFF:0x00000000 /* RW--D */
#define NV_MEMORY_RMC_SVGA                               0x000B1E10 /* RW-4R */
#define NV_MEMORY_RMC_SVGA__ALIAS_1                NV_PBUS_RMC_SVGA /*       */
#define NV_MEMORY_RMC_ACCESS(i)                  (0x000B1E00+(i)*4) /* -W-4A */
#define NV_MEMORY_RMC_ACCESS__SIZE_1                              4 /*       */
#define NV_MEMORY_RMC_ACCESS_SECURITY                          31:0 /* -W-VF */
#define NV_MEMORY_RMC_ACCESS_SECURITY_DISABLE            0x564E6F4E /* -W--V */
#define NV_MEMORY_RMC_ACCESS_SECURITY_ENABLE             0x564E6F47 /* -W--V */
#define NV_MEMORY_RMC_WINDOW(i)                 (0x000B1E40+(i)*16) /* RW-4A */
#define NV_MEMORY_RMC_WINDOW__SIZE_1                              3 /*       */
#define NV_MEMORY_RMC_WINDOW__ALIAS_1            NV_PBUS_RMC_WINDOW /*       */
#define NV_MEMORY_BIOS_ROM008(i)                   (0x000C0000+(i)) /* RW-1A */
#define NV_MEMORY_BIOS_ROM008__SIZE_1                         32768 /*       */
#define NV_MEMORY_BIOS_ROM008_VALUE                             7:0 /* RW-VF */
#define NV_MEMORY_BIOS_ROM016(i)                 (0x000C0000+(i)*2) /* RW-2A */
#define NV_MEMORY_BIOS_ROM016__SIZE_1                         16384 /*       */
#define NV_MEMORY_BIOS_ROM016_VALUE                            15:0 /* RW-VF */
#define NV_MEMORY_BIOS_ROM032(i)                 (0x000C0000+(i)*4) /* RW-4A */
#define NV_MEMORY_BIOS_ROM032__SIZE_1                          8192 /*       */
#define NV_MEMORY_BIOS_ROM032_VALUE                            31:0 /* RW-VF */
#define NV_MEMORY_BIOS_RAM008(i)                   (0x000B1000+(i)) /* RW-1A */
#define NV_MEMORY_BIOS_RAM008__SIZE_1                          3584 /*       */
#define NV_MEMORY_BIOS_RAM008_VALUE                             7:0 /* RW-VF */
#define NV_MEMORY_BIOS_RAM016(i)                 (0x000B1000+(i)*2) /* RW-2A */
#define NV_MEMORY_BIOS_RAM016__SIZE_1                          1792 /*       */
#define NV_MEMORY_BIOS_RAM016_VALUE                            15:0 /* RW-VF */
#define NV_MEMORY_BIOS_RAM032(i)                 (0x000B1000+(i)*4) /* RW-4A */
#define NV_MEMORY_BIOS_RAM032__SIZE_1                           896 /*       */
#define NV_MEMORY_BIOS_RAM032_VALUE                            31:0 /* RW-VF */
#define NV_MEMORY_WINDOW008(i,j)          (0x000B2000+(i)*8192+(j)) /* RW-1A */
#define NV_MEMORY_WINDOW008__SIZE_1                               3 /*       */
#define NV_MEMORY_WINDOW008__SIZE_2                            8192 /*       */
#define NV_MEMORY_WINDOW008_VALUE                               7:0 /* RW-VF */
#define NV_MEMORY_WINDOW016(i,j)        (0x000B2000+(i)*8192+(j)*2) /* RW-2A */
#define NV_MEMORY_WINDOW016__SIZE_1                               3 /*       */
#define NV_MEMORY_WINDOW016__SIZE_2                            4096 /*       */
#define NV_MEMORY_WINDOW016_VALUE                              15:0 /* RW-VF */
#define NV_MEMORY_WINDOW032(i,j)        (0x000B2000+(i)*8192+(j)*4) /* RW-4A */
#define NV_MEMORY_WINDOW032__SIZE_1                               3 /*       */
#define NV_MEMORY_WINDOW032__SIZE_2                            2048 /*       */
#define NV_MEMORY_WINDOW032_VALUE                              31:0 /* RW-VF */
#define NV_MEMORY_RMC_VL                                 0x000B1E90 /* RW-4R */
#define NV_MEMORY_RMC_VL__ALIAS_1                    NV_PBUS_RMC_VL /*       */
#define NV_MEMORY_RMC_DMA_0                              0x000B1E80 /* RW-4R */
#define NV_MEMORY_RMC_DMA_0__ALIAS_1              NV_PBUS_RMC_DMA_0 /*       */
#define NV_MEMORY_RMC_DMA_1                              0x000B1E84 /* RW-4R */
#define NV_MEMORY_RMC_DMA_1__ALIAS_1              NV_PBUS_RMC_DMA_1 /*       */
/* dev_realmode.ref */
#define NV_MEMORY_TRACE                                  0x000B1F00 /* RW-4R */
#define NV_MEMORY_TRACE__ALIAS_1                       NV_PRM_TRACE /*       */
#define NV_MEMORY_TRACE_INDEX                            0x000B1F10 /* RW-4R */
#define NV_MEMORY_TRACE_INDEX__ALIAS_1           NV_PRM_TRACE_INDEX /*       */
#define NV_MEMORY_IGNORE_0                               0x000B1F20 /* RW-4R */
#define NV_MEMORY_IGNORE_0__ALIAS_1                    NV_PRM_TRACE /*       */
#define NV_MEMORY_IGNORE_1                               0x000B1F24 /* RW-4R */
#define NV_MEMORY_IGNORE_1__ALIAS_1                    NV_PRM_TRACE /*       */
/* dev_bus.ref */
#define NV_IO                                 0xFFFFFFFF:0x00000000 /* RW--D */
#define NV_IO_VSE_03C3                                   0x000003C3 /* RW-1R */
#define NV_IO_VSE_03C3_ENABLE                                   0:0 /* RW-VF */
#define NV_IO_VSE_03C3_ENABLE_DISABLED                   0x00000000 /* RW--V */
#define NV_IO_VSE_03C3_ENABLE_ENABLED                    0x00000001 /* RW--V */
#define NV_IO_VSE_46E8                                   0x000046E8 /* RW-1R */
#define NV_IO_VSE_46E8_ENABLE                                   3:3 /* RW-VF */
#define NV_IO_VSE_46E8_ENABLE_DISABLED                   0x00000000 /* RW--V */
#define NV_IO_VSE_46E8_ENABLE_ENABLED                    0x00000001 /* RW--V */
#define NV_IO_VSE_46E8_SETUP                                    4:4 /* RW-VF */
#define NV_IO_VSE_46E8_SETUP_DISABLED                    0x00000000 /* RW--V */
#define NV_IO_VSE_46E8_SETUP_ENABLED                     0x00000001 /* RW--V */
#define NV_IO_POS_0102                                   0x00000102 /* RW-1R */
#define NV_IO_POS_0102_ENABLE                                   0:0 /* RW-VF */
#define NV_IO_POS_0102_ENABLE_DISABLED                   0x00000000 /* RW--V */
#define NV_IO_POS_0102_ENABLE_ENABLED                    0x00000001 /* RW--V */
#define NV_IO_DMA_0000                                   0x00000000 /* -W-1R */
#define NV_IO_DMA_0000_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0001                                   0x00000001 /* -W-1R */
#define NV_IO_DMA_0001_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0002                                   0x00000002 /* -W-1R */
#define NV_IO_DMA_0002_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0003                                   0x00000003 /* -W-1R */
#define NV_IO_DMA_0003_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0004                                   0x00000004 /* -W-1R */
#define NV_IO_DMA_0004_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0005                                   0x00000005 /* -W-1R */
#define NV_IO_DMA_0005_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0006                                   0x00000006 /* -W-1R */
#define NV_IO_DMA_0006_ADDRESS                                  7:0 /* -W-UF */
#define NV_IO_DMA_0007                                   0x00000007 /* -W-1R */
#define NV_IO_DMA_0007_COUNT                                    7:0 /* -W-UF */
#define NV_IO_DMA_0008                                   0x00000008 /* -W-1R */
#define NV_IO_DMA_0008_CONTROLLER                               2:2 /* -W-VF */
#define NV_IO_DMA_0008_CONTROLLER_DISABLED               0x00000000 /* -W--V */
#define NV_IO_DMA_0008_CONTROLLER_ENABLED                0x00000001 /* -W--V */
#define NV_IO_DMA_000A                                   0x0000000A /* -W-1R */
#define NV_IO_DMA_000A_CHANNEL                                  1:0 /* -W-UF */
#define NV_IO_DMA_000A_MASK_BIT                                 2:2 /* -W-VF */
#define NV_IO_DMA_000A_MASK_BIT_CLEAR                    0x00000000 /* -W--V */
#define NV_IO_DMA_000A_MASK_BIT_SET                      0x00000001 /* -W--V */
#define NV_IO_DMA_000B                                   0x0000000B /* -W-1R */
#define NV_IO_DMA_000B_CHANNEL                                  1:0 /* -W-UF */
#define NV_IO_DMA_000B_AUTOINITIALIZE                           4:4 /* -W-VF */
#define NV_IO_DMA_000B_AUTOINITIALIZE_DISABLED           0x00000000 /* -W--V */
#define NV_IO_DMA_000B_AUTOINITIALIZE_ENABLED            0x00000001 /* -W--V */
#define NV_IO_DMA_000B_DIRECTION                                5:5 /* -W-VF */
#define NV_IO_DMA_000B_DIRECTION_INCREMENT               0x00000000 /* -W--V */
#define NV_IO_DMA_000B_DIRECTION_DECREMENT               0x00000001 /* -W--V */
#define NV_IO_DMA_000C                                   0x0000000C /* -W-1R */
#define NV_IO_DMA_000C_CLEAR_FLIPFLOP                           7:0 /* -W-VF */
#define NV_IO_DMA_0081                                   0x00000081 /* -W-1R */
#define NV_IO_DMA_0081_ADDRESS                                  3:0 /* -W-UF */
#define NV_IO_DMA_0082                                   0x00000082 /* -W-1R */
#define NV_IO_DMA_0082_ADDRESS                                  3:0 /* -W-UF */
#define NV_IO_DMA_0083                                   0x00000083 /* -W-1R */
#define NV_IO_DMA_0083_ADDRESS                                  3:0 /* -W-UF */
#define NV_IO_DMA_0087                                   0x00000087 /* -W-1R */
#define NV_IO_DMA_0087_ADDRESS                                  3:0 /* -W-UF */
/* dev_realmode.ref */
#define NV_IO_GAME_PORT                                  0x00000201 /* RW-1R */
#define NV_IO_GAME_PORT__ALIAS_1                 NV_PRMIO_GAME_PORT /*       */
#define NV_IO_GAME_PORT_DATA                                    7:0 /* RW-VF */
#define NV_IO_FM_ADDRESS__SOUND_BLASTER                  0x00000228 /* -W-1R */
#define NV_IO_FM_ADDRESS__ADLIB                          0x00000388 /* -W-1R */
#define NV_IO_RM_ADDRESS_INDEX                                  7:0 /* -WIUF */
#define NV_IO_RM_ADDRESS_INDEX_0                         0x00000000 /* -WI-V */
#define NV_IO_SB_WRITE_STATUS                            0x0000022C /* R--1R */
#define NV_IO_SB_WRITE_STATUS__ALIAS_1     NV_PRMIO_SB_WRITE_STATUS /*       */
#define NV_IO_SB_WRITE_STATUS_STATE                             7:7 /* R-IVF */
#define NV_IO_SB_WRITE_STATUS_STATE_EMPTY                0x00000000 /* R-I-V */
#define NV_IO_SB_WRITE_STATUS_STATE_FULL                 0x00000001 /* R---V */
#define NV_IO_SB_READ_STATUS                             0x0000022E /* RW-1R */
#define NV_IO_SB_READ_STATUS__ALIAS_1       NV_PRMIO_SB_READ_STATUS /*       */
#define NV_IO_SB_READ_STATUS_STATE                              7:7 /* RWIVF */
#define NV_IO_SB_READ_STATUS_STATE_EMPTY                 0x00000000 /* RWI-V */
#define NV_IO_SB_READ_STATUS_STATE_FULL                  0x00000001 /* RW--V */
#define NV_IO_MPU_401_DATA                               0x00000330 /* R--1R */
#define NV_IO_MPU_401_DATA__ALIAS_1           NV_PRMIO_MPU_401_DATA /*       */
#define NV_IO_MPU_401_DATA_VALUE                                7:0 /* R--VF */
#define NV_IO_MPU_401_DATA_ACK                           0x000000FE /* R---V */
#define NV_IO_MPU_401_STATUS                             0x00000331 /* R--1R */
#define NV_IO_MPU_401_STATUS__ALIAS_1       NV_PRMIO_MPU_401_STATUS /*       */
#define NV_IO_MPU_401_STATUS_DATA                               5:0 /* R--VF */
#define NV_IO_MPU_401_STATUS_WRITE                              6:6 /* R--VF */
#define NV_IO_MPU_401_STATUS_WRITE_EMPTY                 0x00000000 /* R---V */
#define NV_IO_MPU_401_STATUS_WRITE_FULL                  0x00000001 /* R---V */
#define NV_IO_MPU_401_STATUS_READ                               7:7 /* R--VF */
#define NV_IO_MPU_401_STATUS_READ_FULL                   0x00000000 /* R---V */
#define NV_IO_MPU_401_STATUS_READ_EMPTY                  0x00000001 /* R---V */
#define NV_IO_MISC_OUT__WRITE                            0x000003C2 /* -W-1R */
#define NV_IO_MISC_OUT__READ                             0x000003CC /* R--1R */
#define NV_IO_EX_MISC_OUT_IO_ADDRESS                            0:0 /* RWIVF */
#define NV_IO_EX_MISC_OUT_IO_ADDRESS_MONO                0x00000000 /* RWI-V */
#define NV_IO_EX_MISC_OUT_IO_ADDRESS_COLOR               0x00000001 /* RW--V */
#define NV_IO_EX_MISC_OUT_RAM_ACCESS                            1:1 /* RWIVF */
#define NV_IO_EX_MISC_OUT_RAM_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_IO_EX_MISC_OUT_RAM_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_IO_EX_MISC_OUT_CLOCK_SELECT                          3:2 /* RWIVF */
#define NV_IO_EX_MISC_OUT_CLOCK_SELECT_25MHZ             0x00000000 /* RWI-V */
#define NV_IO_EX_MISC_OUT_CLOCK_SELECT_28MHZ             0x00000001 /* RW--V */
#define NV_IO_EX_MISC_OUT_OE_PAGE                               5:5 /* RWIVF */
#define NV_IO_EX_MISC_OUT_OE_PAGE_LOW_64K                0x00000000 /* RWI-V */
#define NV_IO_EX_MISC_OUT_OE_PAGE_HIGH_64K               0x00000001 /* RW--V */
#define NV_IO_EX_MISC_OUT_HSYNC_POLARITY                        6:6 /* RWIVF */
#define NV_IO_EX_MISC_OUT_HSYNC_POLARITY_POSITIVE        0x00000000 /* RWI-V */
#define NV_IO_EX_MISC_OUT_HSYNC_POLARITY_NEGATIVE        0x00000001 /* RW--V */
#define NV_IO_EX_MISC_OUT_VSYNC_POLARITY                        7:7 /* RWIVF */
#define NV_IO_EX_MISC_OUT_VSYNC_POLARITY_POSITIVE        0x00000000 /* RWI-V */
#define NV_IO_EX_MISC_OUT_VSYNC_POLARITY_NEGATIVE        0x00000001 /* RW--V */
#define NV_IO_EX_FEATURE__WRITE_MONO                     0x000003BA /* -W-1R */
#define NV_IO_EX_FEATURE__WRITE_COLOR                    0x000003DA /* -W-1R */
#define NV_IO_EX_FEATURE__READ                           0x000003CA /* R--1R */
#define NV_IO_EX_FEATURE_CONTROL_0                              0:0 /* C--VF */
#define NV_IO_EX_FEATURE_CONTROL_0_0                     0x00000000 /* C---V */
#define NV_IO_EX_FEATURE_CONTROL_1                              1:1 /* C--VF */
#define NV_IO_EX_FEATURE_CONTROL_1_0                     0x00000000 /* C---V */
#define NV_IO_EX_FEATURE_VSYNC_SELECT                           7:7 /* RWIVF */
#define NV_IO_EX_FEATURE_VSYNC_SELECT_ONLY               0x00000000 /* RWI-V */
#define NV_IO_EX_FEATURE_VSYNC_SELECT_OR_DISPLAY         0x00000001 /* RW--V */
#define NV_IO_EX_STATUS_0__READ                          0x000003C2 /* R--1R */
#define NV_IO_EX_STATUS_0_SENSE_CODE                            4:4 /* RWIVF */
#define NV_IO_EX_STATUS_0_SENSE_CODE_OFF                 0x00000000 /* RW--V */
#define NV_IO_EX_STATUS_0_SENSE_CODE_ON                  0x00000001 /* RWI-V */
#define NV_IO_EX_STATUS_0_FEATURE_0                             5:5 /* C--VF */
#define NV_IO_EX_STATUS_0_FEATURE_0_0                    0x00000000 /* C---V */
#define NV_IO_EX_STATUS_0_FEATURE_1                             6:6 /* C--VF */
#define NV_IO_EX_STATUS_0_FEATURE_1_0                    0x00000000 /* C---V */
#define NV_IO_EX_STATUS_0_VTRACE_INTR                           7:7 /* R-IVF */
#define NV_IO_EX_STATUS_0_VTRACE_INTR_VBLANK             0x00000000 /* R-I-V */
#define NV_IO_EX_STATUS_0_VTRACE_INTR_DISPLAY            0x00000001 /* R---V */
#define NV_IO_EX_STATUS_1__READ_MONO                     0x000003BA /* R--1R */
#define NV_IO_EX_STATUS_1__READ_COLOR                    0x000003DA /* R--1R */
#define NV_IO_EX_STATUS_1_BLANK                                 0:0 /* R-XVF */
#define NV_IO_EX_STATUS_1_BLANK_DISPLAY                  0x00000000 /* R---V */
#define NV_IO_EX_STATUS_1_BLANK_HORZ_VERT                0x00000001 /* R---V */
#define NV_IO_EX_STATUS_1_LPEN_STROBE                           1:1 /* C--VF */
#define NV_IO_EX_STATUS_1_LPEN_STROBE_0                  0x00000000 /* C---V */
#define NV_IO_EX_STATUS_1_LPEN_SWITCH                           2:2 /* C--VF */
#define NV_IO_EX_STATUS_1_LPEN_SWITCH_0                  0x00000001 /* C---V */
#define NV_IO_EX_STATUS_1_VSYNC                                 3:3 /* R-IVF */
#define NV_IO_EX_STATUS_1_VSYNC_OUTSIDE                  0x00000000 /* R-I-V */
#define NV_IO_EX_STATUS_1_VSYNC_INSIDE                   0x00000001 /* R---V */
#define NV_IO_EX_STATUS_1_DIAGNOSTICS                           5:4 /* C--VF */
#define NV_IO_EX_STATUS_1_DIAGNOSTICS_0                  0x00000000 /* C---V */
#define NV_IO_SQ_ADDRESS                                 0x000003C4 /* RW-1R */
#define NV_IO_SQ_ADDRESS__ALIAS_1               NV_PRMIO_SQ_ADDRESS /*       */
#define NV_IO_SQ_ADDRESS_INDEX                                  2:0 /* RWIUF */
#define NV_IO_SQ_ADDRESS_INDEX_0                         0x00000000 /* RWI-V */
#define NV_IO_SQ_MAP_MASK                                0x000003C5 /* RW-1R */
#define NV_IO_SQ_MAP_MASK__ALIAS_1             NV_PRMIO_SQ_MAP_MASK /*       */
#define NV_IO_SQ_MAP_MASK__INDEX                         0x00000002 /*       */
#define NV_IO_SQ_MAP_MASK_PLANE_MASK_0                          0:0 /* RWIVF */
#define NV_IO_SQ_MAP_MASK_PLANE_MASK_0_DONT_WRITE        0x00000000 /* RWI-V */
#define NV_IO_SQ_MAP_MASK_PLANE_MASK_0_WRITE             0x00000001 /* RW--V */
#define NV_IO_SQ_MAP_MASK_PLANE_MASK_1                          1:1 /* RWIVF */
#define NV_IO_SQ_MAP_MASK_PLANE_MASK_1_DONT_WRITE        0x00000000 /* RWI-V */
#define NV_IO_SQ_MAP_MASK_PLANE_MASK_1_WRITE             0x00000001 /* RW--V */
#define NV_IO_SQ_MAP_MASK_PLANE_MASK_2                          2:2 /* RWIVF */
#define NV_IO_SQ_MAP_MASK_PLANE_MASK_2_DONT_WRITE        0x00000000 /* RWI-V */
#define NV_IO_SQ_MAP_MASK_PLANE_MASK_2_WRITE             0x00000001 /* RW--V */
#define NV_IO_SQ_MAP_MASK_PLANE_MASK_3                          3:3 /* RWIVF */
#define NV_IO_SQ_MAP_MASK_PLANE_MASK_3_DONT_WRITE        0x00000000 /* RWI-V */
#define NV_IO_SQ_MAP_MASK_PLANE_MASK_3_WRITE             0x00000001 /* RW--V */
#define NV_IO_SQ_CHAR_MAP                                0x000003C5 /* RW-1R */
#define NV_IO_SQ_CHAR_MAP__ALIAS_1             NV_PRMIO_SQ_CHAR_MAP /*       */
#define NV_IO_SQ_CHAR_MAP__INDEX                         0x00000003 /*       */
#define NV_IO_SQ_CHAR_MAP_FONT_0_LO                             1:0 /* RWXVF */
#define NV_IO_SQ_CHAR_MAP_FONT_0_LO_0K                   0x00000000 /* RW--V */
#define NV_IO_SQ_CHAR_MAP_FONT_0_LO_16K                  0x00000001 /* RW--V */
#define NV_IO_SQ_CHAR_MAP_FONT_0_LO_32K                  0x00000002 /* RW--V */
#define NV_IO_SQ_CHAR_MAP_FONT_0_LO_48K                  0x00000003 /* RW--V */
#define NV_IO_SQ_CHAR_MAP_FONT_1_LO                             3:2 /* RWXVF */
#define NV_IO_SQ_CHAR_MAP_FONT_1_LO_0K                   0x00000000 /* RW--V */
#define NV_IO_SQ_CHAR_MAP_FONT_1_LO_16K                  0x00000001 /* RW--V */
#define NV_IO_SQ_CHAR_MAP_FONT_1_LO_32K                  0x00000002 /* RW--V */
#define NV_IO_SQ_CHAR_MAP_FONT_1_LO_48K                  0x00000003 /* RW--V */
#define NV_IO_SQ_CHAR_MAP_FONT_0_HI                             4:4 /* RWXVF */
#define NV_IO_SQ_CHAR_MAP_FONT_0_HI_PLUS_0K              0x00000000 /* RW--V */
#define NV_IO_SQ_CHAR_MAP_FONT_0_HI_PLUS_16K             0x00000001 /* RW--V */
#define NV_IO_SQ_CHAR_MAP_FONT_1_HI                             5:5 /* RWXVF */
#define NV_IO_SQ_CHAR_MAP_FONT_1_HI_PLUS_0K              0x00000000 /* RW--V */
#define NV_IO_SQ_CHAR_MAP_FONT_1_HI_PLUS_16K             0x00000001 /* RW--V */
#define NV_IO_SQ_MEM_MAP                                 0x000003C5 /* RW-1R */
#define NV_IO_SQ_MEM_MAP__ALIAS_1               NV_PRMIO_SQ_MEM_MAP /*       */
#define NV_IO_SQ_MEM_MAP__INDEX                          0x00000004 /*       */
#define NV_IO_SQ_MEM_MAP_ALPHA_GRAPH                            0:0 /* C--VF */
#define NV_IO_SQ_MEM_MAP_ALPHA_GRAPH_0                   0x00000000 /* C---V */
#define NV_IO_SQ_MEM_MAP_EXT_MEMORY                             1:1 /* C--VF */
#define NV_IO_SQ_MEM_MAP_EXT_MEMORY_64K                  0x00000001 /* C---V */
#define NV_IO_SQ_MEM_MAP_ODD_EVEN                               2:2 /* RWIVF */
#define NV_IO_SQ_MEM_MAP_ODD_EVEN_ODD_EVEN               0x00000000 /* RWI-V */
#define NV_IO_SQ_MEM_MAP_ODD_EVEN_SEQUENTIAL             0x00000001 /* RW--V */
#define NV_IO_SQ_MEM_MAP_CHAIN_FOUR                             3:3 /* RWIVF */
#define NV_IO_SQ_MEM_MAP_CHAIN_FOUR_PLANAR               0x00000000 /* RWI-V */
#define NV_IO_SQ_MEM_MAP_CHAIN_FOUR_PIXEL                0x00000001 /* RW--V */
#define NV_IO_CC_ADDRESS__MONO                           0x000003B4 /* RW-1R */
#define NV_IO_CC_ADDRESS__COLOR                          0x000003D4 /* RW-1R */
#define NV_IO_CC_ADDRESS_INDEX                                  5:0 /* RWIUF */
#define NV_IO_CC_ADDRESS_INDEX_0                         0x00000000 /* RWI-V */
#define NV_IO_CC_MAX_SCAN__MONO                          0x000003B5 /* RW-1R */
#define NV_IO_CC_MAX_SCAN__COLOR                         0x000003D5 /* RW-1R */
#define NV_IO_CC_MAX_SCAN__INDEX                         0x00000009 /*       */
#define NV_IO_CC_MAX_SCAN_CHAR_HEIGHT                           4:0 /* RWXUF */
#define NV_IO_CC_MAX_SCAN_2T4                                   5:5 /* RWXVF */
#define NV_IO_CC_MAX_SCAN_LINE_CMP9                             6:6 /* RWXVF */
#define NV_IO_CC_MAX_SCAN_VBS9                                  7:7 /* RWXVF */
#define NV_IO_CC_CURSOR_START__MONO                      0x000003B5 /* RW-1R */
#define NV_IO_CC_CURSOR_START__COLOR                     0x000003D5 /* RW-1R */
#define NV_IO_CC_CURSOR_START__INDEX                     0x0000000A /*       */
#define NV_IO_CC_CURSOR_START_START                             4:0 /* RWXUF */
#define NV_IO_CC_CURSOR_START_DISABLE                           5:5 /* RWXVF */
#define NV_IO_CC_CURSOR_START_DISABLE_CURSOR_ON          0x00000000 /* RW--V */
#define NV_IO_CC_CURSOR_START_DISABLE_CURSOR_OFF         0x00000001 /* RW--V */
#define NV_IO_CC_START_HI__MONO                          0x000003B5 /* RW-1R */
#define NV_IO_CC_START_HI__COLOR                         0x000003D5 /* RW-1R */
#define NV_IO_CC_START_HI__INDEX                         0x0000000C /*       */
#define NV_IO_CC_START_HI_ADDRESS                               7:0 /* RWXUF */
#define NV_IO_CC_START_LO__MONO                          0x000003B5 /* RW-1R */
#define NV_IO_CC_START_LO__COLOR                         0x000003D5 /* RW-1R */
#define NV_IO_CC_START_LO__INDEX                         0x0000000D /*       */
#define NV_IO_CC_START_LO_ADDRESS                               7:0 /* RWXUF */
#define NV_IO_CC_CURSOR_HI__MONO                         0x000003B5 /* RW-1R */
#define NV_IO_CC_CURSOR_HI__COLOR                        0x000003D5 /* RW-1R */
#define NV_IO_CC_CURSOR_HI__INDEX                        0x0000000E /*       */
#define NV_IO_CC_CURSOR_HI_LOCATION                             7:0 /* RWXUF */
#define NV_IO_CC_CURSOR_LO__MONO                         0x000003B5 /* RW-1R */
#define NV_IO_CC_CURSOR_LO__COLOR                        0x000003D5 /* RW-1R */
#define NV_IO_CC_CURSOR_LO__INDEX                        0x0000000F /*       */
#define NV_IO_CC_CURSOR_LO_LOCATION                             7:0 /* RWXUF */
#define NV_IO_CC_OFFSET__MONO                            0x000003B5 /* RW-1R */
#define NV_IO_CC_OFFSET__COLOR                           0x000003D5 /* RW-1R */
#define NV_IO_CC_OFFSET__INDEX                           0x00000013 /*       */
#define NV_IO_CC_OFFSET_PITCH                                   7:0 /* RWXUF */
#define NV_IO_GC_ADDRESS                                 0x000003CE /* RW-1R */
#define NV_IO_GC_ADDRESS__ALIAS_1               NV_PRMIO_GC_ADDRESS /*       */
#define NV_IO_GC_ADDRESS_INDEX                                  3:0 /* RWIUF */
#define NV_IO_GC_ADDRESS_INDEX_0                         0x00000000 /* RWI-V */
#define NV_IO_GC_SR                                      0x000003CF /* RW-1R */
#define NV_IO_GC_SR__ALIAS_1                         NV_PRMIO_GC_SR /*       */
#define NV_IO_GC_SR__INDEX                               0x00000000 /*       */
#define NV_IO_GC_SR_VALUE_0                                     0:0 /* RWIVF */
#define NV_IO_GC_SR_VALUE_0_RESET_PLANE                  0x00000000 /* RWI-V */
#define NV_IO_GC_SR_VALUE_0_SET_PLANE                    0x00000001 /* RW--V */
#define NV_IO_GC_SR_VALUE_1                                     1:1 /* RWIVF */
#define NV_IO_GC_SR_VALUE_1_RESET_PLANE                  0x00000000 /* RWI-V */
#define NV_IO_GC_SR_VALUE_1_SET_PLANE                    0x00000001 /* RW--V */
#define NV_IO_GC_SR_VALUE_2                                     2:2 /* RWIVF */
#define NV_IO_GC_SR_VALUE_2_RESET_PLANE                  0x00000000 /* RWI-V */
#define NV_IO_GC_SR_VALUE_2_SET_PLANE                    0x00000001 /* RW--V */
#define NV_IO_GC_SR_VALUE_3                                     3:3 /* RWIVF */
#define NV_IO_GC_SR_VALUE_3_RESET_PLANE                  0x00000000 /* RWI-V */
#define NV_IO_GC_SR_VALUE_3_SET_PLANE                    0x00000001 /* RW--V */
#define NV_IO_GC_ENABLE_SR                               0x000003CF /* RW-1R */
#define NV_IO_GC_ENABLE_SR__ALIAS_1           NV_PRMIO_GC_ENABLE_SR /*       */
#define NV_IO_GC_ENABLE_SR__INDEX                        0x00000001 /*       */
#define NV_IO_GC_ENABLE_SR_ENABLE_0                             0:0 /* RWIVF */
#define NV_IO_GC_ENABLE_SR_ENABLE_0_CPU_DATA             0x00000000 /* RWI-V */
#define NV_IO_GC_ENABLE_SR_ENABLE_0_GC_SR_VALUE          0x00000001 /* RW--V */
#define NV_IO_GC_ENABLE_SR_ENABLE_1                             1:1 /* RWIVF */
#define NV_IO_GC_ENABLE_SR_ENABLE_1_CPU_DATA             0x00000000 /* RWI-V */
#define NV_IO_GC_ENABLE_SR_ENABLE_1_GC_SR_VALUE          0x00000001 /* RW--V */
#define NV_IO_GC_ENABLE_SR_ENABLE_2                             2:2 /* RWIVF */
#define NV_IO_GC_ENABLE_SR_ENABLE_2_CPU_DATA             0x00000000 /* RWI-V */
#define NV_IO_GC_ENABLE_SR_ENABLE_2_GC_SR_VALUE          0x00000001 /* RW--V */
#define NV_IO_GC_ENABLE_SR_ENABLE_3                             3:3 /* RWIVF */
#define NV_IO_GC_ENABLE_SR_ENABLE_3_CPU_DATA             0x00000000 /* RWI-V */
#define NV_IO_GC_ENABLE_SR_ENABLE_3_GC_SR_VALUE          0x00000001 /* RW--V */
#define NV_IO_GC_COLOR_COMP                              0x000003CF /* RW-1R */
#define NV_IO_GC_COLOR_COMP__ALIAS_1         NV_PRMIO_GC_COLOR_COMP /*       */
#define NV_IO_GC_COLOR_COMP__INDEX                       0x00000002 /*       */
#define NV_IO_GC_COLOR_COMP_COLOR_0                             0:0 /* RWIVF */
#define NV_IO_GC_COLOR_COMP_COLOR_0_0                    0x00000000 /* RWI-V */
#define NV_IO_GC_COLOR_COMP_COLOR_1                             1:1 /* RWIVF */
#define NV_IO_GC_COLOR_COMP_COLOR_1_0                    0x00000000 /* RWI-V */
#define NV_IO_GC_COLOR_COMP_COLOR_2                             2:2 /* RWIVF */
#define NV_IO_GC_COLOR_COMP_COLOR_2_0                    0x00000000 /* RWI-V */
#define NV_IO_GC_COLOR_COMP_COLOR_3                             3:3 /* RWIVF */
#define NV_IO_GC_COLOR_COMP_COLOR_3_0                    0x00000000 /* RWI-V */
#define NV_IO_GC_ROTATE                                  0x000003CF /* RW-1R */
#define NV_IO_GC_ROTATE__ALIAS_1                 NV_PRMIO_GC_ROTATE /*       */
#define NV_IO_GC_ROTATE__INDEX                           0x00000003 /*       */
#define NV_IO_GC_ROTATE_RIGHT                                   2:0 /* RWIVF */
#define NV_IO_GC_ROTATE_RIGHT_0                          0x00000000 /* RWI-V */
#define NV_IO_GC_ROTATE_FUNCTION                                4:3 /* RWIVF */
#define NV_IO_GC_ROTATE_FUNCTION_NOP                     0x00000000 /* RWI-V */
#define NV_IO_GC_ROTATE_FUNCTION_AND                     0x00000001 /* RW--V */
#define NV_IO_GC_ROTATE_FUNCTION_OR                      0x00000002 /* RW--V */
#define NV_IO_GC_ROTATE_FUNCTION_XOR                     0x00000003 /* RW--V */
#define NV_IO_GC_READ_MAP                                0x000003CF /* RW-1R */
#define NV_IO_GC_READ_MAP__ALIAS_1             NV_PRMIO_GC_READ_MAP /*       */
#define NV_IO_GC_READ_MAP__INDEX                         0x00000004 /*       */
#define NV_IO_GC_READ_MAP_PLANE                                 1:0 /* RWIUF */
#define NV_IO_GC_READ_MAP_PLANE_0                        0x00000000 /* RWI-V */
#define NV_IO_GC_MODE                                    0x000003CF /* RW-1R */
#define NV_IO_GC_MODE__ALIAS_1                     NV_PRMIO_GC_MODE /*       */
#define NV_IO_GC_MODE__INDEX                             0x00000005 /*       */
#define NV_IO_GC_MODE_WRITE_MODE                                1:0 /* RWIVF */
#define NV_IO_GC_MODE_WRITE_MODE_0                       0x00000000 /* RWI-V */
#define NV_IO_GC_MODE_TEST                                      2:2 /* C--VF */
#define NV_IO_GC_MODE_TEST_0                             0x00000000 /* C---V */
#define NV_IO_GC_MODE_READ_MODE                                 3:3 /* RWIVF */
#define NV_IO_GC_MODE_READ_MODE_LATCH                    0x00000000 /* RWI-V */
#define NV_IO_GC_MODE_READ_MODE_COMPARISON               0x00000001 /* RW--V */
#define NV_IO_GC_MODE_ODD_EVEN                                  4:4 /* RWIVF */
#define NV_IO_GC_MODE_ODD_EVEN_SEQUENTIAL                0x00000000 /* RWI-V */
#define NV_IO_GC_MODE_ODD_EVEN_ODD_EVEN                  0x00000001 /* RW--V */
#define NV_IO_GC_MODE_SHIFT                                     6:5 /* RWIVF */
#define NV_IO_GC_MODE_SHIFT_PLANAR                       0x00000000 /* RWI-V */
#define NV_IO_GC_MODE_SHIFT_CGA                          0x00000001 /* RW--V */
#define NV_IO_GC_MODE_SHIFT_PIXEL                        0x00000002 /* RW--V */
#define NV_IO_GC_MISC                                    0x000003CF /* RW-1R */
#define NV_IO_GC_MISC__ALIAS_1                     NV_PRMIO_GC_MISC /*       */
#define NV_IO_GC_MISC__INDEX                             0x00000006 /*       */
#define NV_IO_GC_MISC_GRAPH_ALPHA                               0:0 /* RWIVF */
#define NV_IO_GC_MISC_GRAPH_ALPHA_ALPHANUMERICS          0x00000000 /* RWI-V */
#define NV_IO_GC_MISC_GRAPH_ALPHA_GRAPHICS               0x00000001 /* RW--V */
#define NV_IO_GC_MISC_CHAIN_OE                                  1:1 /* RWIVF */
#define NV_IO_GC_MISC_CHAIN_OE_EGA_VGA                   0x00000000 /* RWI-V */
#define NV_IO_GC_MISC_CHAIN_OE_MDA                       0x00000001 /* RW--V */
#define NV_IO_GC_MISC_MEMORY_MAP                                3:2 /* RWIVF */
#define NV_IO_GC_MISC_MEMORY_MAP_ALL                     0x00000000 /* RWI-V */
#define NV_IO_GC_MISC_MEMORY_MAP_EGA                     0x00000001 /* RW--V */
#define NV_IO_GC_MISC_MEMORY_MAP_MDA                     0x00000002 /* RW--V */
#define NV_IO_GC_MISC_MEMORY_MAP_CGA                     0x00000003 /* RW--V */
#define NV_IO_GC_DONT_CARE                               0x000003CF /* RW-1R */
#define NV_IO_GC_DONT_CARE__ALIAS_1           NV_PRMIO_GC_DONT_CARE /*       */
#define NV_IO_GC_DONT_CARE__INDEX                        0x00000007 /*       */
#define NV_IO_GC_DONT_CARE_COLOR_0                              0:0 /* RWIVF */
#define NV_IO_GC_DONT_CARE_COLOR_0_DONT_COMPARE          0x00000000 /* RWI-V */
#define NV_IO_GC_DONT_CARE_COLOR_0_COMPARE               0x00000001 /* RW--V */
#define NV_IO_GC_DONT_CARE_COLOR_1                              1:1 /* RWIVF */
#define NV_IO_GC_DONT_CARE_COLOR_1_DONT_COMPARE          0x00000000 /* RWI-V */
#define NV_IO_GC_DONT_CARE_COLOR_1_COMPARE               0x00000001 /* RW--V */
#define NV_IO_GC_DONT_CARE_COLOR_2                              2:2 /* RWIVF */
#define NV_IO_GC_DONT_CARE_COLOR_2_DONT_COMPARE          0x00000000 /* RWI-V */
#define NV_IO_GC_DONT_CARE_COLOR_2_COMPARE               0x00000001 /* RW--V */
#define NV_IO_GC_DONT_CARE_COLOR_3                              3:3 /* RWIVF */
#define NV_IO_GC_DONT_CARE_COLOR_3_DONT_COMPARE          0x00000000 /* RWI-V */
#define NV_IO_GC_DONT_CARE_COLOR_3_COMPARE               0x00000001 /* RW--V */
#define NV_IO_GC_BIT_MASK                                0x000003CF /* RW-1R */
#define NV_IO_GC_BIT_MASK__ALIAS_1             NV_PRMIO_GC_BIT_MASK /*       */
#define NV_IO_GC_BIT_MASK__INDEX                         0x00000008 /*       */
#define NV_IO_GC_BIT_MASK_VALUE_0                               0:0 /* RWIVF */
#define NV_IO_GC_BIT_MASK_VALUE_0_DONT_WRITE             0x00000000 /* RWI-V */
#define NV_IO_GC_BIT_MASK_VALUE_0_WRITE                  0x00000001 /* RW--V */
#define NV_IO_GC_BIT_MASK_VALUE_1                               1:1 /* RWIVF */
#define NV_IO_GC_BIT_MASK_VALUE_1_DONT_WRITE             0x00000000 /* RWI-V */
#define NV_IO_GC_BIT_MASK_VALUE_1_WRITE                  0x00000001 /* RW--V */
#define NV_IO_GC_BIT_MASK_VALUE_2                               2:2 /* RWIVF */
#define NV_IO_GC_BIT_MASK_VALUE_2_DONT_WRITE             0x00000000 /* RWI-V */
#define NV_IO_GC_BIT_MASK_VALUE_2_WRITE                  0x00000001 /* RW--V */
#define NV_IO_GC_BIT_MASK_VALUE_3                               3:3 /* RWIVF */
#define NV_IO_GC_BIT_MASK_VALUE_3_DONT_WRITE             0x00000000 /* RWI-V */
#define NV_IO_GC_BIT_MASK_VALUE_3_WRITE                  0x00000001 /* RW--V */
#define NV_IO_GC_BIT_MASK_VALUE_4                               4:4 /* RWIVF */
#define NV_IO_GC_BIT_MASK_VALUE_4_DONT_WRITE             0x00000000 /* RWI-V */
#define NV_IO_GC_BIT_MASK_VALUE_4_WRITE                  0x00000001 /* RW--V */
#define NV_IO_GC_BIT_MASK_VALUE_5                               5:5 /* RWIVF */
#define NV_IO_GC_BIT_MASK_VALUE_5_DONT_WRITE             0x00000000 /* RWI-V */
#define NV_IO_GC_BIT_MASK_VALUE_5_WRITE                  0x00000001 /* RW--V */
#define NV_IO_GC_BIT_MASK_VALUE_6                               6:6 /* RWIVF */
#define NV_IO_GC_BIT_MASK_VALUE_6_DONT_WRITE             0x00000000 /* RWI-V */
#define NV_IO_GC_BIT_MASK_VALUE_6_WRITE                  0x00000001 /* RW--V */
#define NV_IO_GC_BIT_MASK_VALUE_7                               7:7 /* RWIVF */
#define NV_IO_GC_BIT_MASK_VALUE_7_DONT_WRITE             0x00000000 /* RWI-V */
#define NV_IO_GC_BIT_MASK_VALUE_7_WRITE                  0x00000001 /* RW--V */
#define NV_IO_AT_ADDRESS__WRITE_FLIPFLOP0                0x000003C0 /* -W-1R */
#define NV_IO_AT_ADDRESS__READ                           0x000003C0 /* R--1R */
#define NV_IO_AT_ADDRESS_INDEX                                  4:0 /* RWIUF */
#define NV_IO_AT_ADDRESS_INDEX_0                         0x00000000 /* RWI-V */
#define NV_IO_AT_ADDRESS_PALETTE_ACCESS                         5:5 /* RWIVF */
#define NV_IO_AT_ADDRESS_PALETTE_ACCESS_CPU              0x00000000 /* RWI-V */
#define NV_IO_AT_ADDRESS_PALETTE_ACCESS_DISPLAY          0x00000001 /* RW--V */
#define NV_IO_AT_MODE__WRITE_FLIPFLOP1                   0x000003C0 /* -W-1R */
#define NV_IO_AT_MODE__READ                              0x000003C1 /* R--1R */
#define NV_IO_AT_MODE__INDEX                             0x00000010 /*       */
#define NV_IO_AT_MODE_G_OR_A                                    0:0 /* RWXVF */
#define NV_IO_AT_MODE_G_OR_A_ALPHA                       0x00000000 /* RW--V */
#define NV_IO_AT_MODE_G_OR_A_GRAPHICS                    0x00000001 /* RW--V */
#define NV_IO_AT_MODE_DISPLAY                                   1:1 /* RWXVF */
#define NV_IO_AT_MODE_DISPLAY_COLOR                      0x00000000 /* RW--V */
#define NV_IO_AT_MODE_DISPLAY_MDA                        0x00000001 /* RW--V */
#define NV_IO_AT_MODE_EXTEND_9                                  2:2 /* RWXVF */
#define NV_IO_AT_MODE_EXTEND_9_BACKGROUND                0x00000000 /* RW--V */
#define NV_IO_AT_MODE_EXTEND_9_BIT_8                     0x00000001 /* RW--V */
#define NV_IO_AT_MODE_BLINK_ENABLE                              3:3 /* RWXVF */
#define NV_IO_AT_MODE_BLINK_ENABLE_INTENSITY             0x00000000 /* RW--V */
#define NV_IO_AT_MODE_BLINK_ENABLE_BLINKING_ENABLED      0x00000001 /* RW--V */
#define NV_IO_AT_MODE_PIXEL_PANNING_COMP                        5:5 /* RWXVF */
#define NV_IO_AT_MODE_PIXEL_CLOCK_SELECT                        6:6 /* RWXVF */
#define NV_IO_AT_MODE_PALETTE_SIZE                              7:7 /* RWXVF */
#define NV_IO_DAC_DATA                                   0x000003C9 /* RW-1R */
#define NV_IO_DAC_DATA__ALIAS_1                   NV_PRMIO_DAC_DATA /*       */
#define NV_IO_DAC_DATA_VALUE                                    7:0 /* RW-VF */
/* dev_master.ref */
#define NV_PMC                                0x00000FFF:0x00000000 /* RW--D */
#define NV_PMC_BOOT_0                                    0x00000000 /* R--4R */
#define NV_PMC_BOOT_0_REVISION                                  7:0 /* C--VF */
#define NV_PMC_BOOT_0_REVISION_A                         0x00000000 /* ----V */
#define NV_PMC_BOOT_0_REVISION_B                         0x00000001 /* ----V */
#define NV_PMC_BOOT_0_REVISION_B02                       0x00000002 /* ----V */
#define NV_PMC_BOOT_0_REVISION_B03                       0x00000003 /* C---V */
#define NV_PMC_BOOT_0_REVISION_C01                       0x00000004 /* ----V */
#define NV_PMC_BOOT_0_IMPLEMENTATION                           15:8 /* R--VF */
#define NV_PMC_BOOT_0_IMPLEMENTATION_NV0                 0x00000000 /* R---V */
#define NV_PMC_BOOT_0_IMPLEMENTATION_NV1V32              0x00000001 /* R---V */
#define NV_PMC_BOOT_0_IMPLEMENTATION_NV1D32              0x00000002 /* R---V */
#define NV_PMC_BOOT_0_IMPLEMENTATION_PICASSO             0x00000003 /* R---V */
#define NV_PMC_BOOT_0_ARCHITECTURE                            23:16 /* C--VF */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV0                   0x00000000 /* ----V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV1                   0x00000001 /* C---V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV2                   0x00000002 /* ----V */
#define NV_PMC_BOOT_0_MANUFACTURER                            31:24 /* R--VF */
#define NV_PMC_BOOT_0_MANUFACTURER_NVIDIA                0x00000000 /* R---V */
#define NV_PMC_BOOT_0_MANUFACTURER_SGS                   0x00000001 /* R---V */
#define NV_PMC_DEBUG_0                                   0x00000080 /* R--4R */
#define NV_PMC_DEBUG_0_NVBUS_PAUDIO                             0:0 /* RWIVF */
#define NV_PMC_DEBUG_0_NVBUS_PAUDIO_DISABLED             0x00000000 /* RWI-V */
#define NV_PMC_DEBUG_0_NVBUS_PAUDIO_ENABLED              0x00000001 /* RW--V */
#define NV_PMC_DEBUG_0_NVBUS_PGRAPH                           12:12 /* RWIVF */
#define NV_PMC_DEBUG_0_NVBUS_PGRAPH_DISABLED             0x00000000 /* RWI-V */
#define NV_PMC_DEBUG_0_NVBUS_PGRAPH_ENABLED              0x00000001 /* RW--V */
#define NV_PMC_INTR_0                                    0x00000100 /* RW-4R */
#define NV_PMC_INTR_0_PAUDIO                                    0:0 /* R--VF */
#define NV_PMC_INTR_0_PAUDIO_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PAUDIO_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PDMA                                      4:4 /* R--VF */
#define NV_PMC_INTR_0_PDMA_NOT_PENDING                   0x00000000 /* R---V */
#define NV_PMC_INTR_0_PDMA_PENDING                       0x00000001 /* R---V */
#define NV_PMC_INTR_0_PFIFO                                     8:8 /* R--VF */
#define NV_PMC_INTR_0_PFIFO_NOT_PENDING                  0x00000000 /* R---V */
#define NV_PMC_INTR_0_PFIFO_PENDING                      0x00000001 /* R---V */
#define NV_PMC_INTR_0_PGRAPH                                  12:12 /* R--VF */
#define NV_PMC_INTR_0_PGRAPH_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PGRAPH_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PRM                                     16:16 /* R--VF */
#define NV_PMC_INTR_0_PRM_NOT_PENDING                    0x00000000 /* R---V */
#define NV_PMC_INTR_0_PRM_PENDING                        0x00000001 /* R---V */
#define NV_PMC_INTR_0_PTIMER                                  20:20 /* R--VF */
#define NV_PMC_INTR_0_PTIMER_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PTIMER_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PFB                                     24:24 /* R--VF */
#define NV_PMC_INTR_0_PFB_NOT_PENDING                    0x00000000 /* R---V */
#define NV_PMC_INTR_0_PFB_PENDING                        0x00000001 /* R---V */
#define NV_PMC_INTR_0_SOFTWARE                                28:28 /* RWIVF */
#define NV_PMC_INTR_0_SOFTWARE_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PMC_INTR_0_SOFTWARE_PENDING                   0x00000001 /* RW--V */
#define NV_PMC_INTR_EN_0                                 0x00000140 /* RW-4R */
#define NV_PMC_INTR_EN_0_INTA                                   1:0 /* RWIVF */
#define NV_PMC_INTR_EN_0_INTA_DISABLED                   0x00000000 /* RWI-V */
#define NV_PMC_INTR_EN_0_INTA_HARDWARE                   0x00000001 /* RW--V */
#define NV_PMC_INTR_EN_0_INTA_SOFTWARE                   0x00000002 /* RW--V */
#define NV_PMC_INTR_EN_0_INTB                                   5:4 /* RWIVF */
#define NV_PMC_INTR_EN_0_INTB_DISABLED                   0x00000000 /* RWI-V */
#define NV_PMC_INTR_EN_0_INTB_HARDWARE                   0x00000001 /* RW--V */
#define NV_PMC_INTR_EN_0_INTB_SOFTWARE                   0x00000002 /* RW--V */
#define NV_PMC_INTR_EN_0_INTC                                   9:8 /* RWIVF */
#define NV_PMC_INTR_EN_0_INTC_DISABLED                   0x00000000 /* RWI-V */
#define NV_PMC_INTR_EN_0_INTC_HARDWARE                   0x00000001 /* RW--V */
#define NV_PMC_INTR_EN_0_INTC_SOFTWARE                   0x00000002 /* RW--V */
#define NV_PMC_INTR_EN_0_INTD                                 13:12 /* RWIVF */
#define NV_PMC_INTR_EN_0_INTD_DISABLED                   0x00000000 /* RWI-V */
#define NV_PMC_INTR_EN_0_INTD_HARDWARE                   0x00000001 /* RW--V */
#define NV_PMC_INTR_EN_0_INTD_SOFTWARE                   0x00000002 /* RW--V */
#define NV_PMC_INTR_READ_0                               0x00000160 /* R--4R */
#define NV_PMC_INTR_READ_0_INTA                                 0:0 /* R--VF */
#define NV_PMC_INTR_READ_0_INTA_LOW                      0x00000000 /* R---V */
#define NV_PMC_INTR_READ_0_INTA_HIGH                     0x00000001 /* R---V */
#define NV_PMC_INTR_READ_0_INTB                                 4:4 /* R--VF */
#define NV_PMC_INTR_READ_0_INTB_LOW                      0x00000000 /* R---V */
#define NV_PMC_INTR_READ_0_INTB_HIGH                     0x00000001 /* R---V */
#define NV_PMC_INTR_READ_0_INTC                                 8:8 /* R--VF */
#define NV_PMC_INTR_READ_0_INTC_LOW                      0x00000000 /* R---V */
#define NV_PMC_INTR_READ_0_INTC_HIGH                     0x00000001 /* R---V */
#define NV_PMC_INTR_READ_0_INTD                               12:12 /* R--VF */
#define NV_PMC_INTR_READ_0_INTD_LOW                      0x00000000 /* R---V */
#define NV_PMC_INTR_READ_0_INTD_HIGH                     0x00000001 /* R---V */
#define NV_PMC_INTR_READ_0_SERR                               16:16 /* R--VF */
#define NV_PMC_INTR_READ_0_SERR_LOW                      0x00000000 /* R---V */
#define NV_PMC_INTR_READ_0_SERR_HIGH                     0x00000001 /* R---V */
#define NV_PMC_ENABLE                                    0x00000200 /* RW-4R */
#define NV_PMC_ENABLE_PAUDIO                                    0:0 /* RWIVF */
#define NV_PMC_ENABLE_PAUDIO_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PAUDIO_ENABLED                     0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PDMA                                      4:4 /* RWIVF */
#define NV_PMC_ENABLE_PDMA_DISABLED                      0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PDMA_ENABLED                       0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PFIFO                                     8:8 /* RWIVF */
#define NV_PMC_ENABLE_PFIFO_DISABLED                     0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PFIFO_ENABLED                      0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PGRAPH                                  12:12 /* RWIVF */
#define NV_PMC_ENABLE_PGRAPH_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PGRAPH_ENABLED                     0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PRM                                     16:16 /* RWIVF */
#define NV_PMC_ENABLE_PRM_DISABLED                       0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PRM_ENABLED                        0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PFB                                     24:24 /* RWIVF */
#define NV_PMC_ENABLE_PFB_DISABLED                       0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PFB_ENABLED                        0x00000001 /* RW--V */
#define NV_PMC_WATCHDOG                                  0x00000400 /* RW-4R */
#define NV_PMC_WATCHDOG_TIMEOUT                                 3:0 /* RWIVF */
#define NV_PMC_WATCHDOG_TIMEOUT_1_US                     0x00000000 /* RWI-V */
#define NV_PMC_WATCHDOG_TIMEOUT_2_US                     0x00000001 /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_4_US                     0x00000002 /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_8_US                     0x00000003 /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_16_US                    0x00000004 /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_32_US                    0x00000005 /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_64_US                    0x00000006 /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_128_US                   0x00000007 /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_256_US                   0x00000008 /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_512_US                   0x00000009 /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_1_MS                     0x0000000A /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_2_MS                     0x0000000B /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_4_MS                     0x0000000C /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_8_MS                     0x0000000D /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_16_MS                    0x0000000E /* RW--V */
#define NV_PMC_WATCHDOG_TIMEOUT_32_MS                    0x0000000F /* RW--V */
#define NV_PMC_WATCHDOG_STATE                                  10:8 /* RWIVF */
#define NV_PMC_WATCHDOG_STATE_SLEEPING                   0x00000000 /* RWI-V */
#define NV_PMC_WATCHDOG_STATE_SNIFFING                   0x00000001 /* RW--V */
#define NV_PMC_WATCHDOG_STATE_GROWLING                   0x00000002 /* RW--V */
#define NV_PMC_WATCHDOG_STATE_BARKING                    0x00000003 /* RW--V */
#define NV_PMC_WATCHDOG_STATE_BITING                     0x00000004 /* RW--V */
/* dev_bus.ref */
#define NV_PBUS                               0x00001FFF:0x00001000 /* RW--D */
#define NV_PBUS_DEBUG_0                                  0x00001080 /* RW-4R */
#define NV_PBUS_DEBUG_0_MCLK_DIVIDE                             0:0 /* RWIVF */
#define NV_PBUS_DEBUG_0_MCLK_DIVIDE_BY_TWO               0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_MCLK_DIVIDE_BY_ONE               0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_0_MCLK_LCLK                               4:4 /* RWIVF */
#define NV_PBUS_DEBUG_0_MCLK_LCLK_ASYNCHRONOUS           0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_MCLK_LCLK_SYNCHRONOUS            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_0_MEMORY_READ                             8:8 /* RWIVF */
#define NV_PBUS_DEBUG_0_MEMORY_READ_DWORD                0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_MEMORY_READ_LINE                 0x00000001 /* RW--V */
#define NV_PBUS_ACCESS                                   0x00001200 /* RW-4R */
#define NV_PBUS_ACCESS_GAME_PORT                                0:0 /* RWIVF */
#define NV_PBUS_ACCESS_GAME_PORT_DISABLED                0x00000000 /* RWI-V */
#define NV_PBUS_ACCESS_GAME_PORT_ENABLED                 0x00000001 /* RW--V */
#define NV_PBUS_ACCESS_MDA                                      4:4 /* RWIVF */
#define NV_PBUS_ACCESS_MDA_DISABLED                      0x00000000 /* RWI-V */
#define NV_PBUS_ACCESS_MDA_ENABLED                       0x00000001 /* RW--V */
#define NV_PBUS_ACCESS_SOUND_BOARD                              8:8 /* RWIVF */
#define NV_PBUS_ACCESS_SOUND_BOARD_DISABLED              0x00000000 /* RWI-V */
#define NV_PBUS_ACCESS_SOUND_BOARD_ENABLED               0x00000001 /* RW--V */
#define NV_PBUS_ACCESS_RM_CONTROL                             12:12 /* RWIVF */
#define NV_PBUS_ACCESS_RM_CONTROL_DISABLED               0x00000000 /* RWI-V */
#define NV_PBUS_ACCESS_RM_CONTROL_ENABLED                0x00000001 /* RW--V */
#define NV_PBUS_ACCESS_MPU_401                                17:16 /* RWIVF */
#define NV_PBUS_ACCESS_MPU_401_DISABLED                  0x00000000 /* RWI-V */
#define NV_PBUS_ACCESS_MPU_401_0330H                     0x00000001 /* RW--V */
#define NV_PBUS_ACCESS_MPU_401_0300H                     0x00000002 /* RW--V */
#define NV_PBUS_ACCESS_MPU_401_0230H                     0x00000003 /* RW--V */
#define NV_PBUS_ACCESS_DMA                                    20:20 /* RWIVF */
#define NV_PBUS_ACCESS_DMA_DISABLED                      0x00000000 /* RWI-V */
#define NV_PBUS_ACCESS_DMA_ENABLED                       0x00000001 /* RW--V */
#define NV_PBUS_ACCESS_FM_SYNTHESIS                           24:24 /* RWIVF */
#define NV_PBUS_ACCESS_FM_SYNTHESIS_DISABLED             0x00000000 /* RWI-V */
#define NV_PBUS_ACCESS_FM_SYNTHESIS_ENABLED              0x00000001 /* RW--V */
#define NV_PBUS_RMC_SVGA                                 0x00001410 /* RW-4R */
#define NV_PBUS_RMC_SVGA__ALIAS_1                NV_MEMORY_RMC_SVGA /*       */
#define NV_PBUS_RMC_SVGA_SEGMENT                                3:0 /* RWXUF */
#define NV_PBUS_RMC_SVGA_SEGMENT_0K                      0x00000000 /* RW--V */
#define NV_PBUS_RMC_SVGA_SEGMENT_64K                     0x00000001 /* RW--V */
#define NV_PBUS_RMC_SVGA_SEGMENT_896K                    0x0000000E /* RW--V */
#define NV_PBUS_RMC_SVGA_SEGMENT_960K                    0x0000000F /* RW--V */
#define NV_PBUS_RMC_SVGA_TYPE                                 12:12 /* RWXVF */
#define NV_PBUS_RMC_SVGA_TYPE_LINEAR                     0x00000000 /* RW--V */
#define NV_PBUS_RMC_SVGA_TYPE_VGA                        0x00000001 /* RW--V */
#define NV_PBUS_RMC_WINDOW(i)                   (0x00001440+(i)*16) /* RW-4A */
#define NV_PBUS_RMC_WINDOW__SIZE_1                                3 /*       */
#define NV_PBUS_RMC_WINDOW__ALIAS_1            NV_MEMORY_RMC_WINDOW /*       */
#define NV_PBUS_RMC_WINDOW_SEGMENT                            24:13 /* RWXUF */
#define NV_PBUS_RMC_WINDOW_SEGMENT_0K                    0x00000000 /* RW--V */
#define NV_PBUS_RMC_WINDOW_SEGMENT_8K                    0x00000001 /* RW--V */
#define NV_PBUS_RMC_WINDOW_SEGMENT_32752K                0x00000FFE /* RW--V */
#define NV_PBUS_RMC_WINDOW_SEGMENT_32760K                0x00000FFF /* RW--V */
#define NV_PBUS_RMC_VL                                   0x00001490 /* RW-4R */
#define NV_PBUS_RMC_VL__ALIAS_1                    NV_MEMORY_RMC_VL /*       */
#define NV_PBUS_RMC_VL_VSE_46E8_ENABLE                          3:3 /* RWIVF */
#define NV_PBUS_RMC_VL_VSE_46E8_ENABLE_DISABLED          0x00000000 /* RWI-V */
#define NV_PBUS_RMC_VL_VSE_46E8_ENABLE_ENABLED           0x00000001 /* RW--V */
#define NV_PBUS_RMC_VL_VSE_46E8_SETUP                           4:4 /* RWIVF */
#define NV_PBUS_RMC_VL_VSE_46E8_SETUP_DISABLED           0x00000000 /* RWI-V */
#define NV_PBUS_RMC_VL_VSE_46E8_SETUP_ENABLED            0x00000001 /* RW--V */
#define NV_PBUS_RMC_VL_POS_0102_ENABLE                        16:16 /* RWIVF */
#define NV_PBUS_RMC_VL_POS_0102_ENABLE_DISABLED          0x00000000 /* RWI-V */
#define NV_PBUS_RMC_VL_POS_0102_ENABLE_ENABLED           0x00000001 /* RW--V */
#define NV_PBUS_RMC_VL_VSE_03C3_ENABLE                        24:24 /* RWIVF */
#define NV_PBUS_RMC_VL_VSE_03C3_ENABLE_DISABLED          0x00000000 /* RWI-V */
#define NV_PBUS_RMC_VL_VSE_03C3_ENABLE_ENABLED           0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0                                0x00001480 /* RW-4R */
#define NV_PBUS_RMC_DMA_0__ALIAS_1              NV_MEMORY_RMC_DMA_0 /*       */
#define NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_0                        7:0 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_1                       15:8 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_ADDRESS_BYTE_2                      23:16 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_MASK_BIT                            24:24 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_MASK_BIT_CLEAR                 0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_MASK_BIT_SET                   0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_AUTOINITIALIZE                      25:25 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_AUTOINITIALIZE_DISABLED        0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_AUTOINITIALIZE_ENABLED         0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_DIRECTION                           26:26 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_DIRECTION_INCREMENT            0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_DIRECTION_DECREMENT            0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_CHANNEL                             29:28 /* RWXUF */
#define NV_PBUS_RMC_DMA_0_CONTROLLER                          30:30 /* RWXVF */
#define NV_PBUS_RMC_DMA_0_CONTROLLER_DISABLED            0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_0_CONTROLLER_ENABLED             0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_0_FLIPFLOP                            31:31 /* RWIVF */
#define NV_PBUS_RMC_DMA_0_FLIPFLOP_BYTE_0                0x00000000 /* RWI-V */
#define NV_PBUS_RMC_DMA_0_FLIPFLOP_BYTE_1                0x00000001 /* RW--V */
#define NV_PBUS_RMC_DMA_1                                0x00001484 /* RW-4R */
#define NV_PBUS_RMC_DMA_1__ALIAS_1              NV_MEMORY_RMC_DMA_1 /*       */
#define NV_PBUS_RMC_DMA_1_COUNT_BYTE_0                          7:0 /* RWXUF */
#define NV_PBUS_RMC_DMA_1_COUNT_BYTE_1                         15:8 /* RWXUF */
#define NV_PBUS_RMC_DMA_1_STATE                               28:28 /* RWXVF */
#define NV_PBUS_RMC_DMA_1_STATE_CLEAN                    0x00000000 /* RW--V */
#define NV_PBUS_RMC_DMA_1_STATE_DIRTY                    0x00000001 /* RW--V */
#define NV_PBUS_PCI_VGA_0                                0x00001800 /* R--4R */
#define NV_PBUS_PCI_VGA_0__ALIAS_1              NV_CONFIG_PCI_VGA_0 /*       */
#define NV_PBUS_PCI_NV_0                                 0x00001900 /* R--4R */
#define NV_PBUS_PCI_NV_0__ALIAS_1                NV_CONFIG_PCI_NV_0 /*       */
#define NV_PBUS_PCI_VGA_1                                0x00001804 /* RW-4R */
#define NV_PBUS_PCI_VGA_1__ALIAS_1              NV_CONFIG_PCI_VGA_1 /*       */
#define NV_PBUS_PCI_NV_1                                 0x00001904 /* RW-4R */
#define NV_PBUS_PCI_NV_1__ALIAS_1                NV_CONFIG_PCI_NV_1 /*       */
#define NV_PBUS_PCI_VGA_2                                0x00001808 /* R--4R */
#define NV_PBUS_PCI_VGA_2__ALIAS_1               NV_CONFIG_PCI_NV_2 /*       */
#define NV_PBUS_PCI_NV_2                                 0x00001908 /* R--4R */
#define NV_PBUS_PCI_NV_2__ALIAS_1                NV_CONFIG_PCI_NV_2 /*       */
#define NV_PBUS_PCI_VGA_3                                0x0000180C /* RW-4R */
#define NV_PBUS_PCI_VGA_3__ALIAS_1              NV_CONFIG_PCI_VGA_3 /*       */
#define NV_PBUS_PCI_NV_3                                 0x0000190C /* RW-4R */
#define NV_PBUS_PCI_NV_3__ALIAS_1                NV_CONFIG_PCI_NV_3 /*       */
#define NV_PBUS_PCI_NV_4                                 0x00001910 /* RW-4R */
#define NV_PBUS_PCI_NV_4__ALIAS_1                NV_CONFIG_PCI_NV_4 /*       */
#define NV_PBUS_PCI_VGA_4(i)                     (0x00001810+(i)*4) /* R--4A */
#define NV_PBUS_PCI_VGA_4__SIZE_1                                 6 /*       */
#define NV_PBUS_PCI_VGA_4__ALIAS_1              NV_CONFIG_PCI_VGA_4 /*       */
#define NV_PBUS_PCI_NV_5(i)                      (0x00001914+(i)*4) /* R--4A */
#define NV_PBUS_PCI_NV_5__SIZE_1                                  5 /*       */
#define NV_PBUS_PCI_NV_5__ALIAS_1                NV_CONFIG_PCI_NV_5 /*       */
#define NV_PBUS_PCI_VGA_10(i)                    (0x00001828+(i)*4) /* R--4A */
#define NV_PBUS_PCI_VGA_10__SIZE_1                                2 /*       */
#define NV_PBUS_PCI_VGA_10__ALIAS_1            NV_CONFIG_PCI_VGA_10 /*       */
#define NV_PBUS_PCI_NV_10(i)                     (0x00001928+(i)*4) /* R--4A */
#define NV_PBUS_PCI_NV_10__SIZE_1                                 2 /*       */
#define NV_PBUS_PCI_NV_10__ALIAS_1              NV_CONFIG_PCI_NV_10 /*       */
#define NV_PBUS_PCI_VGA_12                               0x00001830 /* RW-4R */
#define NV_PBUS_PCI_VGA_12__ALIAS_1            NV_CONFIG_PCI_VGA_12 /*       */
#define NV_PBUS_PCI_NV_12                                0x00001930 /* RW-4R */
#define NV_PBUS_PCI_NV_12__ALIAS_1              NV_CONFIG_PCI_NV_12 /*       */
#define NV_PBUS_PCI_VGA_13(i)                    (0x00001834+(i)*4) /* R--4A */
#define NV_PBUS_PCI_VGA_13__SIZE_1                                2 /*       */
#define NV_PBUS_PCI_VGA_13__ALIAS_1            NV_CONFIG_PCI_VGA_13 /*       */
#define NV_PBUS_PCI_NV_13(i)                     (0x00001934+(i)*4) /* R--4A */
#define NV_PBUS_PCI_NV_13__SIZE_1                                 2 /*       */
#define NV_PBUS_PCI_NV_13__ALIAS_1              NV_CONFIG_PCI_NV_13 /*       */
#define NV_PBUS_PCI_VGA_15                               0x0000183C /* RW-4R */
#define NV_PBUS_PCI_VGA_15__ALIAS_1            NV_CONFIG_PCI_VGA_15 /*       */
#define NV_PBUS_PCI_NV_15                                0x0000193C /* RW-4R */
#define NV_PBUS_PCI_NV_15__ALIAS_1              NV_CONFIG_PCI_NV_15 /*       */
#define NV_PBUS_PCI_VGA_16(i)                    (0x00001840+(i)*4) /* R--4A */
#define NV_PBUS_PCI_VGA_16__SIZE_1                               48 /*       */
#define NV_PBUS_PCI_VGA_16__ALIAS_1            NV_CONFIG_PCI_VGA_16 /*       */
#define NV_PBUS_PCI_NV_16(i)                     (0x00001940+(i)*4) /* R--4A */
#define NV_PBUS_PCI_NV_16__SIZE_1                                48 /*       */
#define NV_PBUS_PCI_NV_16__ALIAS_1              NV_CONFIG_PCI_NV_16 /*       */
/* dev_fifo.ref */
#define NV_PFIFO                              0x00003FFF:0x00002000 /* RW--D */
#define NV_PFIFO_DELAY_0                                 0x00002040 /* RW-4R */
#define NV_PFIFO_DELAY_0_WAIT_RETRY                             7:0 /* RWIUF */
#define NV_PFIFO_DELAY_0_WAIT_RETRY_0                    0x00000000 /* RWI-V */
#define NV_PFIFO_DEBUG_0                                 0x00002080 /* R--4R */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0                           0:0 /* R-XVF */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0_NOT_PENDING        0x00000000 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0_PENDING            0x00000001 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1                           4:4 /* R-XVF */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1_NOT_PENDING        0x00000000 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1_PENDING            0x00000001 /* R---V */
#define NV_PFIFO_INTR_0                                  0x00002100 /* RW-4R */
#define NV_PFIFO_INTR_0_CACHE_ERROR                             0:0 /* RWXVF */
#define NV_PFIFO_INTR_0_CACHE_ERROR_NOT_PENDING          0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_CACHE_ERROR_PENDING              0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_CACHE_ERROR_RESET                0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_RUNOUT                                  4:4 /* RWXVF */
#define NV_PFIFO_INTR_0_RUNOUT_NOT_PENDING               0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_PENDING                   0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_RESET                     0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW                         8:8 /* RWXVF */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_NOT_PENDING      0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_PENDING          0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_RESET            0x00000001 /* -W--V */
#define NV_PFIFO_INTR_EN_0                               0x00002140 /* RW-4R */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR                          0:0 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR_DISABLED          0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR_ENABLED           0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_RUNOUT                               4:4 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_RUNOUT_DISABLED               0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_ENABLED                0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW                      8:8 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW_DISABLED      0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW_ENABLED       0x00000001 /* RW--V */
#define NV_PFIFO_CONFIG_0                                0x00002200 /* RW-4R */
#define NV_PFIFO_CONFIG_0_FREE_LIE                              1:0 /* RWXVF */
#define NV_PFIFO_CONFIG_0_FREE_LIE_DISABLED              0x00000000 /* RW--V */
#define NV_PFIFO_CONFIG_0_FREE_LIE_252_BYTES             0x00000001 /* RW--V */
#define NV_PFIFO_CONFIG_0_FREE_LIE_508_BYTES             0x00000002 /* RW--V */
#define NV_PFIFO_CONFIG_0_FREE_LIE_1020_BYTES            0x00000003 /* RW--V */
#define NV_PFIFO_CACHES                                  0x00002500 /* RW-4R */
#define NV_PFIFO_CACHES_REASSIGN                                0:0 /* RWIVF */
#define NV_PFIFO_CACHES_REASSIGN_DISABLED                0x00000000 /* RWI-V */
#define NV_PFIFO_CACHES_REASSIGN_ENABLED                 0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PUSH0                            0x00003000 /* RW-4R */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_PUSH0                            0x00003200 /* RW-4R */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PUSH1                            0x00003010 /* RW-4R */
#define NV_PFIFO_CACHE0_PUSH1_CHID                              6:0 /* RWXUF */

//	Fix double-definition warning

#ifdef	NV_PFIFO_CACHE1_PUSH1
#undef	NV_PFIFO_CACHE1_PUSH1
#endif
#define NV_PFIFO_CACHE1_PUSH1                            0x00003210 /* RW-4R */
#define NV_PFIFO_CACHE1_PUSH1_CHID                              6:0 /* RWXUF */
#define NV_PFIFO_CACHE0_PULL0                            0x00003040 /* RW-4R */
#define NV_PFIFO_CACHE0_PULL0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE0_PULL0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE0_PULL0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_PULL0                            0x00003240 /* R--4R */
#define NV_PFIFO_CACHE1_PULL0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE1_PULL0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_PULL0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_PULL0_HASH                              4:4 /* R-XVF */
#define NV_PFIFO_CACHE1_PULL0_HASH_SUCCEEDED             0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_HASH_FAILED                0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_DEVICE                            8:8 /* R-XVF */
#define NV_PFIFO_CACHE1_PULL0_DEVICE_HARDWARE            0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_DEVICE_SOFTWARE            0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_PULL1                            0x00003050 /* RW-4R */
#define NV_PFIFO_CACHE0_PULL1_OBJECT                            8:8 /* RWXVF */
#define NV_PFIFO_CACHE0_PULL1_OBJECT_UNCHANGED           0x00000000 /* RW--V */
#define NV_PFIFO_CACHE0_PULL1_OBJECT_CHANGED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_PULL1                            0x00003250 /* RW-4R */
#define NV_PFIFO_CACHE1_PULL1_SUBCHANNEL                        2:0 /* RWXUF */
#define NV_PFIFO_CACHE1_PULL1_CTX                               4:4 /* RWXVF */
#define NV_PFIFO_CACHE1_PULL1_CTX_CLEAN                  0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_PULL1_CTX_DIRTY                  0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_PULL1_OBJECT                            8:8 /* RWXVF */
#define NV_PFIFO_CACHE1_PULL1_OBJECT_UNCHANGED           0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_PULL1_OBJECT_CHANGED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_STATUS                           0x00003020 /* R--4R */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS                           0x00003220 /* R--4R */
#define NV_PFIFO_CACHE1_STATUS_RANOUT                           0:0 /* R-XVF */
#define NV_PFIFO_CACHE1_STATUS_RANOUT_FALSE              0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_RANOUT_TRUE               0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_PUT                              0x00003030 /* RW-4R */
#define NV_PFIFO_CACHE0_PUT_ADDRESS                             2:2 /* RWXUF */
#define NV_PFIFO_CACHE1_PUT                              0x00003230 /* RW-4R */
#define NV_PFIFO_CACHE1_PUT_ADDRESS                             6:2 /* RWXUF */
#define NV_PFIFO_CACHE0_GET                              0x00003070 /* RW-4R */
#define NV_PFIFO_CACHE0_GET_ADDRESS                             2:2 /* RWXUF */
#define NV_PFIFO_CACHE1_GET                              0x00003270 /* RW-4R */
#define NV_PFIFO_CACHE1_GET_ADDRESS                             6:2 /* RWXUF */
#define NV_PFIFO_CACHE0_CTX(i)                  (0x00003080+(i)*16) /* RW-4A */
#define NV_PFIFO_CACHE0_CTX__SIZE_1                               1 /*       */
#define NV_PFIFO_CACHE0_CTX_INSTANCE                           15:0 /* RWXUF */
#define NV_PFIFO_CACHE0_CTX_DEVICE                            22:16 /* RWXUF */
#define NV_PFIFO_CACHE1_CTX(i)                  (0x00003280+(i)*16) /* RW-4A */
#define NV_PFIFO_CACHE1_CTX__SIZE_1                               8 /*       */
#define NV_PFIFO_CACHE1_CTX_INSTANCE                           15:0 /* RWXUF */
#define NV_PFIFO_CACHE1_CTX_DEVICE                            22:16 /* RWXUF */
#define NV_PFIFO_CACHE1_CTX_LIE                               24:24 /* RWXVF */
#define NV_PFIFO_CACHE1_CTX_LIE_DISABLED                 0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_CTX_LIE_ENABLED                  0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_METHOD(i)                (0x00003100+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE0_METHOD__SIZE_1                            1 /*       */
#define NV_PFIFO_CACHE0_METHOD_ADDRESS                         12:2 /* RWXUF */
#define NV_PFIFO_CACHE0_METHOD_SUBCHANNEL                     15:13 /* RWXUF */
#define NV_PFIFO_CACHE1_METHOD(i)                (0x00003300+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE1_METHOD__SIZE_1                           32 /*       */
#define NV_PFIFO_CACHE1_METHOD_ADDRESS                         12:2 /* RWXUF */
#define NV_PFIFO_CACHE1_METHOD_SUBCHANNEL                     15:13 /* RWXUF */
#define NV_PFIFO_CACHE0_DATA(i)                  (0x00003104+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE0_DATA__SIZE_1                              1 /*       */
#define NV_PFIFO_CACHE0_DATA_VALUE                             31:0 /* RWXVF */
#define NV_PFIFO_CACHE1_DATA(i)                  (0x00003304+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE1_DATA__SIZE_1                             32 /*       */
#define NV_PFIFO_CACHE1_DATA_VALUE                             31:0 /* RWXVF */
#define NV_PFIFO_DEVICE(i)                       (0x00002800+(i)*4) /* R--4A */
#define NV_PFIFO_DEVICE__SIZE_1                                 128 /*       */
#define NV_PFIFO_DEVICE_CHID                                    6:0 /* R--UF */
#define NV_PFIFO_DEVICE_SWITCH                                24:24 /* R--VF */
#define NV_PFIFO_DEVICE_SWITCH_UNAVAILABLE               0x00000000 /* R---V */
#define NV_PFIFO_DEVICE_SWITCH_AVAILABLE                 0x00000001 /* R---V */
#define NV_PFIFO_DEVICE_ACCESS                                28:28 /* R--VF */
#define NV_PFIFO_DEVICE_ACCESS_DISABLED                  0x00000000 /* R---V */
#define NV_PFIFO_DEVICE_ACCESS_ENABLED                   0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS                           0x00002400 /* R--4R */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT                           0:0 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT_FALSE              0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT_TRUE               0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_PUT                              0x00002410 /* RW-4R */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS                            13:3 /* RWXUF */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_0                    10:3 /*       */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_1                    11:3 /*       */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_2                    12:3 /*       */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_3                    13:3 /*       */
#define NV_PFIFO_RUNOUT_GET                              0x00002420 /* RW-4R */
#define NV_PFIFO_RUNOUT_GET_ADDRESS                            13:3 /* RWXUF */
/* dev_dma.ref */
#define NV_PDMA                               0x00100FFF:0x00100000 /* RW--D */
#define NV_PDMA_RM_INTR_0                                0x00100100 /* RW-4R */
#define NV_PDMA_RM_INTR_0_BUS_ERROR                           12:12 /* RWXVF */
#define NV_PDMA_RM_INTR_0_BUS_ERROR_NOT_PENDING          0x00000000 /* R---V */
#define NV_PDMA_RM_INTR_0_BUS_ERROR_PENDING              0x00000001 /* R---V */
#define NV_PDMA_RM_INTR_0_BUS_ERROR_RESET                0x00000001 /* -W--V */
#define NV_PDMA_AU_INTR_0                                0x00100108 /* RW-4R */
#define NV_PDMA_AU_INTR_0_INSTANCE                              0:0 /* RWXVF */
#define NV_PDMA_AU_INTR_0_INSTANCE_NOT_PENDING           0x00000000 /* R---V */
#define NV_PDMA_AU_INTR_0_INSTANCE_PENDING               0x00000001 /* R---V */
#define NV_PDMA_AU_INTR_0_INSTANCE_RESET                 0x00000001 /* -W--V */
#define NV_PDMA_AU_INTR_0_PRESENT                               4:4 /* RWXVF */
#define NV_PDMA_AU_INTR_0_PRESENT_NOT_PENDING            0x00000000 /* R---V */
#define NV_PDMA_AU_INTR_0_PRESENT_PENDING                0x00000001 /* R---V */
#define NV_PDMA_AU_INTR_0_PRESENT_RESET                  0x00000001 /* -W--V */
#define NV_PDMA_AU_INTR_0_PROTECTION                            8:8 /* RWXVF */
#define NV_PDMA_AU_INTR_0_PROTECTION_NOT_PENDING         0x00000000 /* R---V */
#define NV_PDMA_AU_INTR_0_PROTECTION_PENDING             0x00000001 /* R---V */
#define NV_PDMA_AU_INTR_0_PROTECTION_RESET               0x00000001 /* -W--V */
#define NV_PDMA_AU_INTR_0_BUS_ERROR                           12:12 /* RWXVF */
#define NV_PDMA_AU_INTR_0_BUS_ERROR_NOT_PENDING          0x00000000 /* R---V */
#define NV_PDMA_AU_INTR_0_BUS_ERROR_PENDING              0x00000001 /* R---V */
#define NV_PDMA_AU_INTR_0_BUS_ERROR_RESET                0x00000001 /* -W--V */
#define NV_PDMA_GR_INTR_0                                0x00100110 /* RW-4R */
#define NV_PDMA_GR_INTR_0_INSTANCE                              0:0 /* RWXVF */
#define NV_PDMA_GR_INTR_0_INSTANCE_NOT_PENDING           0x00000000 /* R---V */
#define NV_PDMA_GR_INTR_0_INSTANCE_PENDING               0x00000001 /* R---V */
#define NV_PDMA_GR_INTR_0_INSTANCE_RESET                 0x00000001 /* -W--V */
#define NV_PDMA_GR_INTR_0_PRESENT                               4:4 /* RWXVF */
#define NV_PDMA_GR_INTR_0_PRESENT_NOT_PENDING            0x00000000 /* R---V */
#define NV_PDMA_GR_INTR_0_PRESENT_PENDING                0x00000001 /* R---V */
#define NV_PDMA_GR_INTR_0_PRESENT_RESET                  0x00000001 /* -W--V */
#define NV_PDMA_GR_INTR_0_PROTECTION                            8:8 /* RWXVF */
#define NV_PDMA_GR_INTR_0_PROTECTION_NOT_PENDING         0x00000000 /* R---V */
#define NV_PDMA_GR_INTR_0_PROTECTION_PENDING             0x00000001 /* R---V */
#define NV_PDMA_GR_INTR_0_PROTECTION_RESET               0x00000001 /* -W--V */
#define NV_PDMA_GR_INTR_0_BUS_ERROR                           12:12 /* RWXVF */
#define NV_PDMA_GR_INTR_0_BUS_ERROR_NOT_PENDING          0x00000000 /* R---V */
#define NV_PDMA_GR_INTR_0_BUS_ERROR_PENDING              0x00000001 /* R---V */
#define NV_PDMA_GR_INTR_0_BUS_ERROR_RESET                0x00000001 /* -W--V */
#define NV_PDMA_RM_INTR_EN_0                             0x00100140 /* RW-4R */
#define NV_PDMA_RM_INTR_EN_0_BUS_ERROR                        12:12 /* RWIVF */
#define NV_PDMA_RM_INTR_EN_0_BUS_ERROR_DISABLED          0x00000000 /* RWI-V */
#define NV_PDMA_RM_INTR_EN_0_BUS_ERROR_ENABLED           0x00000001 /* RW--V */
#define NV_PDMA_AU_INTR_EN_0                             0x00100148 /* RW-4R */
#define NV_PDMA_AU_INTR_EN_0_INSTANCE                           0:0 /* RWIVF */
#define NV_PDMA_AU_INTR_EN_0_INSTANCE_DISABLED           0x00000000 /* RWI-V */
#define NV_PDMA_AU_INTR_EN_0_INSTANCE_ENABLED            0x00000001 /* RW--V */
#define NV_PDMA_AU_INTR_EN_0_PRESENT                            4:4 /* RWIVF */
#define NV_PDMA_AU_INTR_EN_0_PRESENT_DISABLED            0x00000000 /* RWI-V */
#define NV_PDMA_AU_INTR_EN_0_PRESENT_ENABLED             0x00000001 /* RW--V */
#define NV_PDMA_AU_INTR_EN_0_PROTECTION                         8:8 /* RWIVF */
#define NV_PDMA_AU_INTR_EN_0_PROTECTION_DISABLED         0x00000000 /* RWI-V */
#define NV_PDMA_AU_INTR_EN_0_PROTECTION_ENABLED          0x00000001 /* RW--V */
#define NV_PDMA_AU_INTR_EN_0_BUS_ERROR                        12:12 /* RWIVF */
#define NV_PDMA_AU_INTR_EN_0_BUS_ERROR_DISABLED          0x00000000 /* RWI-V */
#define NV_PDMA_AU_INTR_EN_0_BUS_ERROR_ENABLED           0x00000001 /* RW--V */
#define NV_PDMA_GR_INTR_EN_0                             0x00100150 /* RW-4R */
#define NV_PDMA_GR_INTR_EN_0_INSTANCE                           0:0 /* RWIVF */
#define NV_PDMA_GR_INTR_EN_0_INSTANCE_DISABLED           0x00000000 /* RWI-V */
#define NV_PDMA_GR_INTR_EN_0_INSTANCE_ENABLED            0x00000001 /* RW--V */
#define NV_PDMA_GR_INTR_EN_0_PRESENT                            4:4 /* RWIVF */
#define NV_PDMA_GR_INTR_EN_0_PRESENT_DISABLED            0x00000000 /* RWI-V */
#define NV_PDMA_GR_INTR_EN_0_PRESENT_ENABLED             0x00000001 /* RW--V */
#define NV_PDMA_GR_INTR_EN_0_PROTECTION                         8:8 /* RWIVF */
#define NV_PDMA_GR_INTR_EN_0_PROTECTION_DISABLED         0x00000000 /* RWI-V */
#define NV_PDMA_GR_INTR_EN_0_PROTECTION_ENABLED          0x00000001 /* RW--V */
#define NV_PDMA_GR_INTR_EN_0_BUS_ERROR                        12:12 /* RWIVF */
#define NV_PDMA_GR_INTR_EN_0_BUS_ERROR_DISABLED          0x00000000 /* RWI-V */
#define NV_PDMA_GR_INTR_EN_0_BUS_ERROR_ENABLED           0x00000001 /* RW--V */
#define NV_PDMA_AU_CONTROL                               0x00100600 /* RW-4R */
#define NV_PDMA_AU_CONTROL_ADJUST                              11:0 /* RWXUF */
#define NV_PDMA_AU_CONTROL_PAGE_TABLE                         16:16 /* RWIVF */
#define NV_PDMA_AU_CONTROL_PAGE_TABLE_NOT_PRESENT        0x00000000 /* RWI-V */
#define NV_PDMA_AU_CONTROL_PAGE_TABLE_PRESENT            0x00000001 /* RW--V */
#define NV_PDMA_AU_CONTROL_LIMIT32                            20:20 /* RWXUF */
#define NV_PDMA_GR_CONTROL                               0x00100800 /* RW-4R */
#define NV_PDMA_GR_CONTROL_ADJUST                              11:0 /* RWXUF */
#define NV_PDMA_GR_CONTROL_PAGE_TABLE                         16:16 /* RWIVF */
#define NV_PDMA_GR_CONTROL_PAGE_TABLE_NOT_PRESENT        0x00000000 /* RWI-V */
#define NV_PDMA_GR_CONTROL_PAGE_TABLE_PRESENT            0x00000001 /* RW--V */
#define NV_PDMA_GR_CONTROL_LIMIT32                            20:20 /* RWXUF */
#define NV_PDMA_AU_LIMIT                                 0x00100604 /* RW-4R */
#define NV_PDMA_AU_LIMIT_OFFSET                                31:0 /* RWXUF */
#define NV_PDMA_GR_LIMIT                                 0x00100804 /* RW-4R */
#define NV_PDMA_GR_LIMIT_OFFSET                                31:0 /* RWXUF */
#define NV_PDMA_AU_TLB_PTE                               0x00100608 /* RW-4R */
#define NV_PDMA_AU_TLB_PTE_PAGE                                 0:0 /* RWXVF */
#define NV_PDMA_AU_TLB_PTE_PAGE_NOT_PRESENT              0x00000000 /* RW--V */
#define NV_PDMA_AU_TLB_PTE_PAGE_PRESENT                  0x00000001 /* RW--V */
#define NV_PDMA_AU_TLB_PTE_ACCESS                               1:1 /* RWXVF */
#define NV_PDMA_AU_TLB_PTE_ACCESS_READ_ONLY              0x00000000 /* RW--V */
#define NV_PDMA_AU_TLB_PTE_ACCESS_READ_WRITE             0x00000001 /* RW--V */
#define NV_PDMA_AU_TLB_PTE_FRAME_ADDRESS                      31:12 /* RWXUF */
#define NV_PDMA_GR_TLB_PTE                               0x00100808 /* RW-4R */
#define NV_PDMA_GR_TLB_PTE_PAGE                                 0:0 /* RWXVF */
#define NV_PDMA_GR_TLB_PTE_PAGE_NOT_PRESENT              0x00000000 /* RW--V */
#define NV_PDMA_GR_TLB_PTE_PAGE_PRESENT                  0x00000001 /* RW--V */
#define NV_PDMA_GR_TLB_PTE_ACCESS                               1:1 /* RWXVF */
#define NV_PDMA_GR_TLB_PTE_ACCESS_READ_ONLY              0x00000000 /* RW--V */
#define NV_PDMA_GR_TLB_PTE_ACCESS_READ_WRITE             0x00000001 /* RW--V */
#define NV_PDMA_GR_TLB_PTE_FRAME_ADDRESS                      31:12 /* RWXUF */
#define NV_PDMA_AU_CHANNEL                               0x00100610 /* RW-4R */
#define NV_PDMA_AU_CHANNEL_ACCESS                               0:0 /* RWIVF */
#define NV_PDMA_AU_CHANNEL_ACCESS_DISABLED               0x00000000 /* RWI-V */
#define NV_PDMA_AU_CHANNEL_ACCESS_ENABLED                0x00000001 /* RW--V */
#define NV_PDMA_GR_CHANNEL                               0x00100810 /* RW-4R */
#define NV_PDMA_GR_CHANNEL_ACCESS                               0:0 /* RWIVF */
#define NV_PDMA_GR_CHANNEL_ACCESS_DISABLED               0x00000000 /* RWI-V */
#define NV_PDMA_GR_CHANNEL_ACCESS_ENABLED                0x00000001 /* RW--V */
#define NV_PDMA_RM_STATUS_0                              0x00100414 /* R--4R */
#define NV_PDMA_RM_STATUS_0_STATE                               0:0 /* R-XVF */
#define NV_PDMA_RM_STATUS_0_STATE_IDLE                   0x00000000 /* R---V */
#define NV_PDMA_RM_STATUS_0_STATE_BUSY                   0x00000001 /* R---V */
#define NV_PDMA_AU_STATUS_0                              0x00100614 /* R--4R */
#define NV_PDMA_AU_STATUS_0_STATE                               0:0 /* R-XVF */
#define NV_PDMA_AU_STATUS_0_STATE_IDLE                   0x00000000 /* R---V */
#define NV_PDMA_AU_STATUS_0_STATE_BUSY                   0x00000001 /* R---V */
#define NV_PDMA_AU_STATUS_0_FETCH_STATE                         4:4 /* R-IVF */
#define NV_PDMA_AU_STATUS_0_FETCH_STATE_IDLE             0x00000000 /* R-I-V */
#define NV_PDMA_AU_STATUS_0_FETCH_STATE_BUSY             0x00000001 /* R---V */
#define NV_PDMA_AU_STATUS_0_DRAIN_STATE                         8:8 /* R-IVF */
#define NV_PDMA_AU_STATUS_0_DRAIN_STATE_IDLE             0x00000000 /* R-I-V */
#define NV_PDMA_AU_STATUS_0_DRAIN_STATE_BUSY             0x00000001 /* R---V */
#define NV_PDMA_AU_STATUS_0_FLUSH_STATE                       12:12 /* R-IVF */
#define NV_PDMA_AU_STATUS_0_FLUSH_STATE_IDLE             0x00000000 /* R-I-V */
#define NV_PDMA_AU_STATUS_0_FLUSH_STATE_BUSY             0x00000001 /* R---V */
#define NV_PDMA_AU_STATUS_0_READ_STATE                        16:16 /* R-IVF */
#define NV_PDMA_AU_STATUS_0_READ_STATE_IDLE              0x00000000 /* R-I-V */
#define NV_PDMA_AU_STATUS_0_READ_STATE_BUSY              0x00000001 /* R---V */
#define NV_PDMA_AU_STATUS_0_NOTIFY_STATE                      20:20 /* R-IVF */
#define NV_PDMA_AU_STATUS_0_NOTIFY_STATE_IDLE            0x00000000 /* R-I-V */
#define NV_PDMA_AU_STATUS_0_NOTIFY_STATE_BUSY            0x00000001 /* R---V */
#define NV_PDMA_GR_STATUS_0                              0x00100814 /* R--4R */
#define NV_PDMA_GR_STATUS_0_STATE                               0:0 /* R-XVF */
#define NV_PDMA_GR_STATUS_0_STATE_IDLE                   0x00000000 /* R---V */
#define NV_PDMA_GR_STATUS_0_STATE_BUSY                   0x00000001 /* R---V */
#define NV_PDMA_GR_STATUS_0_FETCH_STATE                         4:4 /* R-IVF */
#define NV_PDMA_GR_STATUS_0_FETCH_STATE_IDLE             0x00000000 /* R-I-V */
#define NV_PDMA_GR_STATUS_0_FETCH_STATE_BUSY             0x00000001 /* R---V */
#define NV_PDMA_GR_STATUS_0_DRAIN_STATE                         8:8 /* R-IVF */
#define NV_PDMA_GR_STATUS_0_DRAIN_STATE_IDLE             0x00000000 /* R-I-V */
#define NV_PDMA_GR_STATUS_0_DRAIN_STATE_BUSY             0x00000001 /* R---V */
#define NV_PDMA_GR_STATUS_0_FLUSH_STATE                       12:12 /* R-IVF */
#define NV_PDMA_GR_STATUS_0_FLUSH_STATE_IDLE             0x00000000 /* R-I-V */
#define NV_PDMA_GR_STATUS_0_FLUSH_STATE_BUSY             0x00000001 /* R---V */
#define NV_PDMA_GR_STATUS_0_READ_STATE                        16:16 /* R-IVF */
#define NV_PDMA_GR_STATUS_0_READ_STATE_IDLE              0x00000000 /* R-I-V */
#define NV_PDMA_GR_STATUS_0_READ_STATE_BUSY              0x00000001 /* R---V */
#define NV_PDMA_GR_STATUS_0_NOTIFY_STATE                      20:20 /* R-IVF */
#define NV_PDMA_GR_STATUS_0_NOTIFY_STATE_IDLE            0x00000000 /* R-I-V */
#define NV_PDMA_GR_STATUS_0_NOTIFY_STATE_BUSY            0x00000001 /* R---V */
#define NV_PDMA_AU_STATUS_1                              0x00100618 /* RW-4R */
#define NV_PDMA_AU_STATUS_1_CONTROL                             0:0 /* RWIVF */
#define NV_PDMA_AU_STATUS_1_CONTROL_INVALID              0x00000000 /* RW--V */
#define NV_PDMA_AU_STATUS_1_CONTROL_VALID                0x00000001 /* RWI-V */
#define NV_PDMA_AU_STATUS_1_OFFSET                              4:4 /* RWIVF */
#define NV_PDMA_AU_STATUS_1_OFFSET_INVALID               0x00000000 /* RWI-V */
#define NV_PDMA_AU_STATUS_1_OFFSET_VALID                 0x00000001 /* RW--V */
#define NV_PDMA_AU_STATUS_1_TLB_PTE                             8:8 /* RWIVF */
#define NV_PDMA_AU_STATUS_1_TLB_PTE_INVALID              0x00000000 /* RW--V */
#define NV_PDMA_AU_STATUS_1_TLB_PTE_VALID                0x00000001 /* RWI-V */
#define NV_PDMA_AU_STATUS_1_ADJ_OFFSET32                      12:12 /* RWXUF */
#define NV_PDMA_GR_STATUS_1                              0x00100818 /* RW-4R */
#define NV_PDMA_GR_STATUS_1_CONTROL                             0:0 /* RWIVF */
#define NV_PDMA_GR_STATUS_1_CONTROL_INVALID              0x00000000 /* RW--V */
#define NV_PDMA_GR_STATUS_1_CONTROL_VALID                0x00000001 /* RWI-V */
#define NV_PDMA_GR_STATUS_1_OFFSET                              4:4 /* RWIVF */
#define NV_PDMA_GR_STATUS_1_OFFSET_INVALID               0x00000000 /* RWI-V */
#define NV_PDMA_GR_STATUS_1_OFFSET_VALID                 0x00000001 /* RW--V */
#define NV_PDMA_GR_STATUS_1_TLB_PTE                             8:8 /* RWIVF */
#define NV_PDMA_GR_STATUS_1_TLB_PTE_INVALID              0x00000000 /* RW--V */
#define NV_PDMA_GR_STATUS_1_TLB_PTE_VALID                0x00000001 /* RWI-V */
#define NV_PDMA_GR_STATUS_1_ADJ_OFFSET32                      12:12 /* RWXUF */
#define NV_PDMA_AU_TLB_TAG                               0x00100620 /* RW-4R */
#define NV_PDMA_AU_TLB_TAG_ADDRESS                            31:12 /* RWXUF */
#define NV_PDMA_GR_TLB_TAG                               0x00100820 /* RW-4R */
#define NV_PDMA_GR_TLB_TAG_ADDRESS                            31:12 /* RWXUF */
#define NV_PDMA_AU_ADJ_OFFSET                            0x00100630 /* RW-4R */
#define NV_PDMA_AU_ADJ_OFFSET_VALUE                            31:0 /* RWXUF */
#define NV_PDMA_GR_ADJ_OFFSET                            0x00100830 /* RW-4R */
#define NV_PDMA_GR_ADJ_OFFSET_VALUE                            31:0 /* RWXUF */
#define NV_PDMA_RM_PHY_START                             0x00100440 /* RW-4R */
#define NV_PDMA_RM_PHY_START_ADDRESS                           31:0 /* RWXUF */
#define NV_PDMA_AU_PHY_START                             0x00100640 /* RW-4R */
#define NV_PDMA_AU_PHY_START_ADDRESS                           31:0 /* RWXUF */
#define NV_PDMA_GR_PHY_START                             0x00100840 /* RW-4R */
#define NV_PDMA_GR_PHY_START_ADDRESS                           31:0 /* RWXUF */
#define NV_PDMA_RM_BUFF_OUT(i)                   (0x00100500+(i)*4) /* RW-4A */
#define NV_PDMA_RM_BUFF_OUT__SIZE_1                               1 /*       */
#define NV_PDMA_RM_BUFF_OUT_DATA                               31:0 /* RWXVF */
#define NV_PDMA_AU_BUFF_OUT(i)                   (0x00100700+(i)*4) /* RW-4A */
#define NV_PDMA_AU_BUFF_OUT__SIZE_1                               4 /*       */
#define NV_PDMA_AU_BUFF_OUT_DATA                               31:0 /* RWXVF */
#define NV_PDMA_GR_BUFF_OUT(i)                   (0x00100900+(i)*4) /* RW-4A */
#define NV_PDMA_GR_BUFF_OUT__SIZE_1                               8 /*       */
#define NV_PDMA_GR_BUFF_OUT_DATA                               31:0 /* RWXVF */
#define NV_PDMA_BUFF_IN(i)                       (0x00100580+(i)*4) /* RW-4A */
#define NV_PDMA_BUFF_IN__SIZE_1                                   8 /*       */
#define NV_PDMA_BUFF_IN_DATA                                   31:0 /* RWXVF */
#define NV_PDMA_AU_INSTANCE                              0x00100680 /* RW-4R */
#define NV_PDMA_AU_INSTANCE_ID                                 15:0 /* RWIUF */
#define NV_PDMA_AU_INSTANCE_ID_0                         0x00000000 /* RWI-V */
#define NV_PDMA_GR_INSTANCE                              0x00100880 /* RW-4R */
#define NV_PDMA_GR_INSTANCE_ID                                 15:0 /* RWIUF */
#define NV_PDMA_GR_INSTANCE_ID_0                         0x00000000 /* RWI-V */
#define NV_PDMA_AU_OFFSET                                0x00100690 /* -W-4R */
#define NV_PDMA_AU_OFFSET_VALUE                                31:0 /* -W-UF */
#define NV_PDMA_GR_OFFSET                                0x00100890 /* -W-4R */
#define NV_PDMA_GR_OFFSET_VALUE                                31:0 /* -W-UF */
#define NV_PDMA_AU_OUT8                                  0x001006A0 /* -W-1R */
#define NV_PDMA_AU_OUT8_DATA                                    7:0 /* -W-VF */
#define NV_PDMA_AU_OUT16                                 0x001006A0 /* -W-2R */
#define NV_PDMA_AU_OUT16_DATA                                  15:0 /* -W-VF */
#define NV_PDMA_AU_OUT32                                 0x001006A0 /* -W-4R */
#define NV_PDMA_AU_OUT32_DATA                                  31:0 /* -W-VF */
#define NV_PDMA_GR_OUT8                                  0x001008A0 /* -W-1R */
#define NV_PDMA_GR_OUT8_DATA                                    7:0 /* -W-VF */
#define NV_PDMA_GR_OUT16                                 0x001008A0 /* -W-2R */
#define NV_PDMA_GR_OUT16_DATA                                  15:0 /* -W-VF */
#define NV_PDMA_GR_OUT32                                 0x001008A0 /* -W-4R */
#define NV_PDMA_GR_OUT32_DATA                                  31:0 /* -W-VF */
#define NV_PDMA_RM_FLUSH8                                0x001004B0 /* -W-1R */
#define NV_PDMA_RM_FLUSH8_DATA                                  7:0 /* -W-VF */
#define NV_PDMA_RM_FLUSH16                               0x001004B0 /* -W-2R */
#define NV_PDMA_RM_FLUSH16_DATA                                15:0 /* -W-VF */
#define NV_PDMA_RM_FLUSH32                               0x001004B0 /* -W-4R */
#define NV_PDMA_RM_FLUSH32_DATA                                31:0 /* -W-VF */
#define NV_PDMA_AU_FLUSH8                                0x001006B0 /* -W-1R */
#define NV_PDMA_AU_FLUSH8_DATA                                  7:0 /* -W-VF */
#define NV_PDMA_AU_FLUSH16                               0x001006B0 /* -W-2R */
#define NV_PDMA_AU_FLUSH16_DATA                                15:0 /* -W-VF */
#define NV_PDMA_AU_FLUSH32                               0x001006B0 /* -W-4R */
#define NV_PDMA_AU_FLUSH32_DATA                                31:0 /* -W-VF */
#define NV_PDMA_GR_FLUSH8                                0x001008B0 /* -W-1R */
#define NV_PDMA_GR_FLUSH8_DATA                                  7:0 /* -W-VF */
#define NV_PDMA_GR_FLUSH16                               0x001008B0 /* -W-2R */
#define NV_PDMA_GR_FLUSH16_DATA                                15:0 /* -W-VF */
#define NV_PDMA_GR_FLUSH32                               0x001008B0 /* -W-4R */
#define NV_PDMA_GR_FLUSH32_DATA                                31:0 /* -W-VF */
#define NV_PDMA_AU_FLUSH_BUFF                            0x001006C0 /* -W-4R */
#define NV_PDMA_AU_FLUSH_BUFF_NOW                              31:0 /* -W-VF */
#define NV_PDMA_GR_FLUSH_BUFF                            0x001008C0 /* -W-4R */
#define NV_PDMA_GR_FLUSH_BUFF_NOW                              31:0 /* -W-VF */
#define NV_PDMA_RM_IN                                    0x001004D0 /* -W-4R */
#define NV_PDMA_RM_IN_REPLY_ADDRESS                            23:0 /* -W-VF */
#define NV_PDMA_AU_IN                                    0x001006D0 /* -W-4R */
#define NV_PDMA_AU_IN_REPLY_ADDRESS                            23:0 /* -W-VF */
#define NV_PDMA_GR_IN                                    0x001008D0 /* -W-4R */
#define NV_PDMA_GR_IN_REPLY_ADDRESS                            23:0 /* -W-VF */
#define NV_PDMA_AU_NOTIFY                                0x001006E0 /* -W-4R */
#define NV_PDMA_AU_NOTIFY_INSTANCE                             15:0 /* -W-UF */
#define NV_PDMA_GR_NOTIFY                                0x001008E0 /* -W-4R */
#define NV_PDMA_GR_NOTIFY_INSTANCE                             15:0 /* -W-UF */
/* dev_timer.ref */
#define NV_PTIMER                             0x00101FFF:0x00101000 /* RW--D */
#define NV_PTIMER_INTR_0                                 0x00101100 /* RW-4R */
#define NV_PTIMER_INTR_0_ALARM                                  0:0 /* RWXVF */
#define NV_PTIMER_INTR_0_ALARM_NOT_PENDING               0x00000000 /* R---V */
#define NV_PTIMER_INTR_0_ALARM_PENDING                   0x00000001 /* R---V */
#define NV_PTIMER_INTR_0_ALARM_RESET                     0x00000001 /* -W--V */
#define NV_PTIMER_INTR_EN_0                              0x00101140 /* RW-4R */
#define NV_PTIMER_INTR_EN_0_ALARM                               0:0 /* RWIVF */
#define NV_PTIMER_INTR_EN_0_ALARM_DISABLED               0x00000000 /* RWI-V */
#define NV_PTIMER_INTR_EN_0_ALARM_ENABLED                0x00000001 /* RW--V */
#define NV_PTIMER_NUMERATOR                              0x00101200 /* RW-4R */
#define NV_PTIMER_NUMERATOR_VALUE                              15:0 /* RWIUF */
#define NV_PTIMER_NUMERATOR_VALUE_0                      0x00000000 /* RWI-V */
#define NV_PTIMER_DENOMINATOR                            0x00101210 /* RW-4R */
#define NV_PTIMER_DENOMINATOR_VALUE                            15:0 /* RWIUF */
#define NV_PTIMER_DENOMINATOR_VALUE_0                    0x00000000 /* RWI-V */
#define NV_PTIMER_TIME_0                                 0x00101400 /* RW-4R */
#define NV_PTIMER_TIME_0_NSEC                                  31:5 /* RWXUF */
#define NV_PTIMER_TIME_1                                 0x00101404 /* RW-4R */
#define NV_PTIMER_TIME_1_NSEC                                  28:0 /* RWXUF */
#define NV_PTIMER_ALARM_0                                0x00101410 /* RW-4R */
#define NV_PTIMER_ALARM_0_NSEC                                 31:5 /* RWXUF */
/* dev_audio.ref */
#define NV_PAUDIO                             0x00300FFF:0x00300000 /* RW--D */
#define NV_PAUDIO_GREEN_0                                0x003000C0 /* RW-4R */
#define NV_PAUDIO_GREEN_0_CODEC                                 0:0 /* RWIVF */
#define NV_PAUDIO_GREEN_0_CODEC_DISABLED                 0x00000000 /* RWI-V */
#define NV_PAUDIO_GREEN_0_CODEC_ENABLED                  0x00000001 /* RW--V */
#define NV_PAUDIO_GREEN_0_AUDIO                                 4:4 /* RWIVF */
#define NV_PAUDIO_GREEN_0_AUDIO_DISABLED                 0x00000000 /* RWI-V */
#define NV_PAUDIO_GREEN_0_AUDIO_ENABLED                  0x00000001 /* RW--V */
#define NV_PAUDIO_GREEN_0_APUMP                                 8:8 /* RWIVF */
#define NV_PAUDIO_GREEN_0_APUMP_DISABLED                 0x00000000 /* RWI-V */
#define NV_PAUDIO_GREEN_0_APUMP_ENABLED                  0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_0                                 0x00300100 /* RW-4R */
#define NV_PAUDIO_INTR_0_NOTIFY                                 0:0 /* RWIVF */
#define NV_PAUDIO_INTR_0_NOTIFY_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_0_NOTIFY_PENDING                  0x00000001 /* R---V */
#define NV_PAUDIO_INTR_0_NOTIFY_RESET                    0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_0_OVERFLOW                               4:4 /* RWIVF */
#define NV_PAUDIO_INTR_0_OVERFLOW_NOT_PENDING            0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_0_OVERFLOW_PENDING                0x00000001 /* R---V */
#define NV_PAUDIO_INTR_0_OVERFLOW_RESET                  0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_1                                 0x00300104 /* RW-4R */
#define NV_PAUDIO_INTR_1_SYNC                                   0:0 /* RWIVF */
#define NV_PAUDIO_INTR_1_SYNC_NOT_PENDING                0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_1_SYNC_PENDING                    0x00000001 /* R---V */
#define NV_PAUDIO_INTR_1_SYNC_RESET                      0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_1_IDLE                                   4:4 /* RWIVF */
#define NV_PAUDIO_INTR_1_IDLE_NOT_PENDING                0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_1_IDLE_PENDING                    0x00000001 /* R---V */
#define NV_PAUDIO_INTR_1_IDLE_RESET                      0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_1_NEAR_BUSY                              8:8 /* RWIVF */
#define NV_PAUDIO_INTR_1_NEAR_BUSY_NOT_PENDING           0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_1_NEAR_BUSY_PENDING               0x00000001 /* R---V */
#define NV_PAUDIO_INTR_1_NEAR_BUSY_RESET                 0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_1_TOO_BUSY                             12:12 /* RWIVF */
#define NV_PAUDIO_INTR_1_TOO_BUSY_NOT_PENDING            0x00000000 /* R-I-V */
#define NV_PAUDIO_INTR_1_TOO_BUSY_PENDING                0x00000001 /* R---V */
#define NV_PAUDIO_INTR_1_TOO_BUSY_RESET                  0x00000001 /* -W--V */
#define NV_PAUDIO_INTR_EN_0                              0x00300140 /* RW-4R */
#define NV_PAUDIO_INTR_EN_0_NOTIFY                              0:0 /* RWIVF */
#define NV_PAUDIO_INTR_EN_0_NOTIFY_DISABLED              0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_0_NOTIFY_ENABLED               0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_0_OVERFLOW                            4:4 /* RWIVF */
#define NV_PAUDIO_INTR_EN_0_OVERFLOW_DISABLED            0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_0_OVERFLOW_ENABLED             0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_1                              0x00300144 /* RW-4R */
#define NV_PAUDIO_INTR_EN_1_SYNC                                0:0 /* RWIVF */
#define NV_PAUDIO_INTR_EN_1_SYNC_DISABLED                0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_1_SYNC_ENABLED                 0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_1_IDLE                                4:4 /* RWIVF */
#define NV_PAUDIO_INTR_EN_1_IDLE_DISABLED                0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_1_IDLE_ENABLED                 0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_1_NEAR_BUSY                           8:8 /* RWIVF */
#define NV_PAUDIO_INTR_EN_1_NEAR_BUSY_DISABLED           0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_1_NEAR_BUSY_ENABLED            0x00000001 /* RW--V */
#define NV_PAUDIO_INTR_EN_1_TOO_BUSY                          12:12 /* RWIVF */
#define NV_PAUDIO_INTR_EN_1_TOO_BUSY_DISABLED            0x00000000 /* RWI-V */
#define NV_PAUDIO_INTR_EN_1_TOO_BUSY_ENABLED             0x00000001 /* RW--V */
#define NV_PAUDIO_CONTEXT                                0x00300A08 /* RW-4R */
#define NV_PAUDIO_CONTEXT_INSTANCE                             15:0 /* RWXUF */
#define NV_PAUDIO_BLOCK_NEW                              0x00300200 /* RW-4R */
#define NV_PAUDIO_BLOCK_NEW_LENGTH                              7:0 /* RWXUF */
#define NV_PAUDIO_BLOCK_NEW_RATIO                             13:12 /* RWXVF */
#define NV_PAUDIO_BLOCK_NEW_RATIO_1X                     0x00000000 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_RATIO_2X                     0x00000001 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_RATIO_4X                     0x00000002 /* RW--V */
#define NV_PAUDIO_BLOCK_NEW_RATIO_8X                     0x00000003 /* RW--V */
#define NV_PAUDIO_BLOCK_ENGINE                           0x00300204 /* RW-4R */
#define NV_PAUDIO_BLOCK_ENGINE_LENGTH                           7:0 /* RWXUF */
#define NV_PAUDIO_BLOCK_ENGINE_RATIO                          13:12 /* RWXVF */
#define NV_PAUDIO_BLOCK_ENGINE_RATIO_1X                  0x00000000 /* RW--V */
#define NV_PAUDIO_BLOCK_ENGINE_RATIO_2X                  0x00000001 /* RW--V */
#define NV_PAUDIO_BLOCK_ENGINE_RATIO_4X                  0x00000002 /* RW--V */
#define NV_PAUDIO_BLOCK_ENGINE_RATIO_8X                  0x00000003 /* RW--V */
#define NV_PAUDIO_BLOCK_PUMP                             0x00300208 /* RW-4R */
#define NV_PAUDIO_BLOCK_PUMP_LENGTH                             7:0 /* R-XUF */
#define NV_PAUDIO_BLOCK_PUMP_RATIO                            13:12 /* RWXVF */
#define NV_PAUDIO_BLOCK_PUMP_RATIO_1X                    0x00000000 /* RW--V */
#define NV_PAUDIO_BLOCK_PUMP_RATIO_2X                    0x00000001 /* RW--V */
#define NV_PAUDIO_BLOCK_PUMP_RATIO_4X                    0x00000002 /* RW--V */
#define NV_PAUDIO_BLOCK_PUMP_RATIO_8X                    0x00000003 /* RW--V */
#define NV_PAUDIO_NEAR_MARK                              0x00300400 /* RW-4R */
#define NV_PAUDIO_NEAR_MARK_COUNT                               7:0 /* RWXUF */
#define NV_PAUDIO_SAMPLE_COUNT                           0x00300410 /* R--4R */
#define NV_PAUDIO_SAMPLE_COUNT_VALUE                            7:0 /* R-XUF */
#define NV_PAUDIO_SAMPLE_COUNT_BUFFER                           8:8 /* R-XUF */
#define NV_PAUDIO_TERMINATION                            0x00300980 /* RW-4R */
#define NV_PAUDIO_TERMINATION_LEVEL                            15:0 /* RWXUF */
#define NV_PAUDIO_TERMINATION_LEVEL_DISABLED             0x00000000 /* RW--V */
#define NV_PAUDIO_USAGE                                  0x0030080C /* RW-4R */
#define NV_PAUDIO_USAGE_LEVEL                                  15:0 /* RWXUF */
#define NV_PAUDIO_CODEC(i)                      (0x00300500+(i)*16) /* RW-4A */
#define NV_PAUDIO_CODEC__SIZE_1                                   4 /*       */
#define NV_PAUDIO_CODEC_DATA                                    7:0 /* RW-VF */
#define NV_PAUDIO_CACHE_ANALOG                           0x00300600 /* -W-4R */
#define NV_PAUDIO_CACHE_ANALOG_CHANNEL_0                       15:0 /* -W-VF */
#define NV_PAUDIO_CACHE_ANALOG_CHANNEL_1                      31:16 /* -W-VF */
#define NV_PAUDIO_CACHE_INPUT                            0x00300610 /* -W-4R */
#define NV_PAUDIO_CACHE_INPUT_CHANNEL_0                        15:0 /* -W-VF */
#define NV_PAUDIO_CACHE_INPUT_CHANNEL_1                       31:16 /* -W-VF */
#define NV_PAUDIO_CACHE_OUTPUT                           0x00300620 /* -W-4R */
#define NV_PAUDIO_CACHE_OUTPUT_CHANNEL_0                       15:0 /* -W-VF */
#define NV_PAUDIO_CACHE_OUTPUT_CHANNEL_1                      31:16 /* -W-VF */
#define NV_PAUDIO_FETCH(i)                       (0x00300640+(i)*4) /* -W-4A */
#define NV_PAUDIO_FETCH__SIZE_1                                   4 /*       */
#define NV_PAUDIO_FETCH_DATA                                   31:0 /* -W-VF */
#define NV_PAUDIO_TIME_RETURN(i)                 (0x00300660+(i)*4) /* -W-4A */
#define NV_PAUDIO_TIME_RETURN__SIZE_1                             2 /*       */
#define NV_PAUDIO_TIME_RETURN_VALUE                            31:0 /* -W-VF */
#define NV_PAUDIO_HEADER(i)                      (0x00300680+(i)*4) /* -W-4A */
#define NV_PAUDIO_HEADER__SIZE_1                                 32 /*       */
#define NV_PAUDIO_HEADER_DATA                                  31:0 /* -W-VF */
#define NV_PAUDIO_ROOT_INPUT                             0x00300800 /* RW-4R */
#define NV_PAUDIO_ROOT_INPUT_INSTANCE                          15:0 /* RWXUF */
#define NV_PAUDIO_ROOT_OUTPUT                            0x00300804 /* RW-4R */
#define NV_PAUDIO_ROOT_OUTPUT_INSTANCE                         15:0 /* RWXUF */
#define NV_PAUDIO_ROOT_NOTE                              0x00300808 /* RW-4R */
#define NV_PAUDIO_ROOT_NOTE_INSTANCE                           15:0 /* RWXUF */
#define NV_PAUDIO_DIAG(i)                        (0x0030080C+(i)*4) /* RW-4A */
#define NV_PAUDIO_DIAG__SIZE_1                                  253 /*       */
#define NV_PAUDIO_DIAG_DATA                                    31:0 /* RW-VF */
/* dev_graphics.ref */
#define NV_PGRAPH                             0x00400FFF:0x00400000 /* RW--D */
#define NV_PGRAPH_DEBUG_0                                0x00400080 /* RW-4R */
#define NV_PGRAPH_DEBUG_0_STATE                                 0:0 /* CW-VF */
#define NV_PGRAPH_DEBUG_0_STATE_NORMAL                   0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_0_STATE_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_0_BULK_READS                            4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_BULK_READS_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_BULK_READS_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_BLOCK                                 8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_BLOCK_DISABLED                 0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_BLOCK_ENABLED                  0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_BLOCK_BROAD                         12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_BLOCK_BROAD_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_BLOCK_BROAD_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_NONBLOCK_BROAD                      16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_NONBLOCK_BROAD_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_NONBLOCK_BROAD_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS                     20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_EDGE_FILLING                        24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_EDGE_FILLING_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_EDGE_FILLING_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT                         28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1                                0x00400084 /* RW-4R */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET                        0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET_NOT_LAST        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET_LAST            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY                          4:4 /* CW-VF */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY_IGNORE            0x00000000 /* CW--V */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY_CANCEL            0x00000001 /* -W--V */
#define NV_PGRAPH_DEBUG_1_BI_RECTS                              8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_BI_RECTS_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_BI_RECTS_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS                            12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_PATT_BLOCK                          16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_PATT_BLOCK_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_PATT_BLOCK_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_FAST_RMW_BLITS                      20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_FAST_RMW_BLITS_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_FAST_RMW_BLITS_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_TM_QUAD_HANDOFF                     24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TM_QUAD_HANDOFF_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TM_QUAD_HANDOFF_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_FAST_BUS                            28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_FAST_BUS_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_FAST_BUS_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_HIRES_TM                            29:29 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_HIRES_TM_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_HIRES_TM_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2                                0x00400088 /* RW-4R */
#define NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND                       0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_AVOID_RMW_BLEND_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_ALPHA_ABORT                           4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_ALPHA_ABORT_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_ALPHA_ABORT_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_BETA_ABORT                            8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_BETA_ABORT_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_BETA_ABORT_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_MONO_ABORT                          12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_MONO_ABORT_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_MONO_ABORT_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_TRAPEZOID_TEXEL                     16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_TRAPEZOID_TEXEL_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_TRAPEZOID_TEXEL_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_BUSY_PATIENCE                       20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_BUSY_PATIENCE_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_BUSY_PATIENCE_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_TM_FASTINPUT                        24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_TM_FASTINPUT_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_TM_FASTINPUT_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET                      28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3                                0x0040008c /* RW-4R */
#define NV_PGRAPH_DEBUG_3_TM_RANGE_INTERRUPT                    0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_TM_RANGE_INTERRUPT_DISABLED    0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_TM_RANGE_INTERRUPT_ENABLED     0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_MONO_BLOCK                            4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_MONO_BLOCK_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_MONO_BLOCK_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SPARE1                                8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SPARE1_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SPARE1_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SPARE2                              12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SPARE2_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SPARE2_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SPARE3                              16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SPARE3_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SPARE3_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SPARE4                              20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SPARE4_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SPARE4_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SPARE5                              24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SPARE5_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SPARE5_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SPARE6                              28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SPARE6_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SPARE6_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_0                                 0x00400100 /* RW-4R */
#define NV_PGRAPH_INTR_0_RESERVED                               0:0 /* RW-VF */
#define NV_PGRAPH_INTR_0_RESERVED_NOT_PENDING            0x00000000 /* R---V */
#define NV_PGRAPH_INTR_0_RESERVED_PENDING                0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_RESERVED_RESET                  0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH                         4:4 /* RWIVF */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH_NOT_PENDING      0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH_PENDING          0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_CONTEXT_SWITCH_RESET            0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_VBLANK                                 8:8 /* RWIVF */
#define NV_PGRAPH_INTR_0_VBLANK_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_VBLANK_PENDING                  0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_VBLANK_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_RANGE                                12:12 /* RWIVF */
#define NV_PGRAPH_INTR_0_RANGE_NOT_PENDING               0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_RANGE_PENDING                   0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_RANGE_RESET                     0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_METHOD_COUNT                         16:16 /* RWIVF */
#define NV_PGRAPH_INTR_0_METHOD_COUNT_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_METHOD_COUNT_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_METHOD_COUNT_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_SOFTWARE                             20:20 /* RWIVF */
#define NV_PGRAPH_INTR_0_SOFTWARE_NOT_PENDING            0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_SOFTWARE_PENDING                0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_SOFTWARE_RESET                  0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP                         24:24 /* RWIVF */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_COMPLEX_CLIP_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_0_NOTIFY                               28:28 /* RWIVF */
#define NV_PGRAPH_INTR_0_NOTIFY_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_0_NOTIFY_PENDING                  0x00000001 /* R---V */
#define NV_PGRAPH_INTR_0_NOTIFY_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1                                 0x00400104 /* RW-4R */
#define NV_PGRAPH_INTR_1_METHOD                                 0:0 /* RWIVF */
#define NV_PGRAPH_INTR_1_METHOD_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_METHOD_PENDING                  0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_METHOD_RESET                    0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1_DATA                                   4:4 /* RWIVF */
#define NV_PGRAPH_INTR_1_DATA_NOT_PENDING                0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_DATA_PENDING                    0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_DATA_RESET                      0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1_NOTIFY_INST                            8:8 /* RWIVF */
#define NV_PGRAPH_INTR_1_NOTIFY_INST_NOT_PENDING         0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_NOTIFY_INST_PENDING             0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_NOTIFY_INST_RESET               0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY                        12:12 /* RWIVF */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_NOT_PENDING       0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_PENDING           0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_DOUBLE_NOTIFY_RESET             0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY                         16:16 /* RWIVF */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_INTR_1_CTXSW_NOTIFY_RESET              0x00000001 /* -W--V */
#define NV_PGRAPH_INTR_EN_0                              0x00400140 /* RW-4R */
#define NV_PGRAPH_INTR_EN_0_RESERVED                            0:0 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_RESERVED_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_RESERVED_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH                      4:4 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH_DISABLED      0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_CONTEXT_SWITCH_ENABLED       0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_VBLANK                              8:8 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_VBLANK_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_VBLANK_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_RANGE                             12:12 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_RANGE_DISABLED               0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_RANGE_ENABLED                0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_METHOD_COUNT                      16:16 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_METHOD_COUNT_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_METHOD_COUNT_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_SOFTWARE                          20:20 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_SOFTWARE_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_SOFTWARE_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP                      24:24 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_COMPLEX_CLIP_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_0_NOTIFY                            28:28 /* RWIVF */
#define NV_PGRAPH_INTR_EN_0_NOTIFY_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_0_NOTIFY_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1                              0x00400144 /* RW-4R */
#define NV_PGRAPH_INTR_EN_1_METHOD                              0:0 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_METHOD_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_METHOD_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1_DATA                                4:4 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_DATA_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_DATA_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1_NOTIFY_INST                         8:8 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_NOTIFY_INST_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_NOTIFY_INST_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY                     12:12 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_DOUBLE_NOTIFY_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY                      16:16 /* RWIVF */
#define NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_1_CTXSW_NOTIFY_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH                             0x00400180 /* RW-4R */
#define NV_PGRAPH_CTX_SWITCH_INSTANCE                          15:0 /* RW-VF */
#define NV_PGRAPH_CTX_SWITCH_PATCH_CONFIG                       4:0 /* RWXVF */
#define NV_PGRAPH_CTX_SWITCH_CHROMA_KEY                         5:5 /* RWXVF */
#define NV_PGRAPH_CTX_SWITCH_CHROMA_KEY_DISABLED         0x00000000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_CHROMA_KEY_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_BETA_MAXIMUM                       5:5 /* RWXVF */
#define NV_PGRAPH_CTX_SWITCH_BETA_MAXIMUM_DISABLED       0x00000000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_BETA_MAXIMUM_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PLANE_MASK                         6:6 /* RWXVF */
#define NV_PGRAPH_CTX_SWITCH_PLANE_MASK_DISABLED         0x00000000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PLANE_MASK_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_USER_CLIP                          7:7 /* RWXVF */
#define NV_PGRAPH_CTX_SWITCH_USER_CLIP_DISABLED          0x00000000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_USER_CLIP_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_NOTIFY                             8:8 /* RWXVF */
#define NV_PGRAPH_CTX_SWITCH_NOTIFY_INVALID              0x00000000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_NOTIFY_VALID                0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_COLOR_BUFFER                      12:9 /* RWXVF */
#define NV_PGRAPH_CTX_SWITCH_ALPHA                            13:13 /* RWXVF */
#define NV_PGRAPH_CTX_SWITCH_ALPHA_DISABLED              0x00000000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_ALPHA_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_SOURCE_BUFFER                    13:13 /* RW-VF */
#define NV_PGRAPH_CTX_SWITCH_MONO_FORMAT                      14:14 /* RWXVF */
#define NV_PGRAPH_CTX_SWITCH_MONO_FORMAT_LE              0x00000000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_MONO_FORMAT_CGA6            0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH_PATCH_ID                         15:15 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_PATCH_ID_0                  0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_CHID                             22:16 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_CHID_0                      0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_OBJECT                           31:31 /* RWIVF */
#define NV_PGRAPH_CTX_SWITCH_OBJECT_UNCHANGED            0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_SWITCH_OBJECT_CHANGED              0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL                            0x00400190 /* RW-4R */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME                      1:0 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_33US          0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_262US         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_2MS           0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_17MS          0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_TIME                              8:8 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_TIME_EXPIRED               0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_TIME_NOT_EXPIRED           0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_CHID                            16:16 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_CHID_INVALID               0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_CHID_VALID                 0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_SWITCH                          20:20 /* R--VF */
#define NV_PGRAPH_CTX_CONTROL_SWITCH_UNAVAILABLE         0x00000000 /* R---V */
#define NV_PGRAPH_CTX_CONTROL_SWITCH_AVAILABLE           0x00000001 /* R---V */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING                       24:24 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING_IDLE             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING_BUSY             0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_DEVICE                          28:28 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_DEVICE_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_DEVICE_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_MISC                                   0x004006A4 /* RW-4R */
#define NV_PGRAPH_MISC_FIFO                                     0:0 /* RWIVF */
#define NV_PGRAPH_MISC_FIFO_DISABLED                     0x00000000 /* RW--V */
#define NV_PGRAPH_MISC_FIFO_ENABLED                      0x00000001 /* RWI-V */
#define NV_PGRAPH_MISC_DMA                                      4:4 /* RWIVF */
#define NV_PGRAPH_MISC_DMA_DISABLED                      0x00000000 /* RW--V */
#define NV_PGRAPH_MISC_DMA_ENABLED                       0x00000001 /* RWI-V */
#define NV_PGRAPH_MISC_FLOWTHRU                                 8:8 /* RWIVF */
#define NV_PGRAPH_MISC_FLOWTHRU_DISABLED                 0x00000000 /* RW--V */
#define NV_PGRAPH_MISC_FLOWTHRU_ENABLED                  0x00000001 /* RWI-V */
#define NV_PGRAPH_MISC_CLASS                                  16:12 /* RWXVF */
#define NV_PGRAPH_MISC_FIFO_WRITE                             24:24 /* CW-VF */
#define NV_PGRAPH_MISC_FIFO_WRITE_IGNORED                0x00000000 /* -W--V */
#define NV_PGRAPH_MISC_FIFO_WRITE_ENABLED                0x00000001 /* CW--V */
#define NV_PGRAPH_MISC_DMA_WRITE                              25:25 /* CW-VF */
#define NV_PGRAPH_MISC_DMA_WRITE_IGNORED                 0x00000000 /* -W--V */
#define NV_PGRAPH_MISC_DMA_WRITE_ENABLED                 0x00000001 /* CW--V */
#define NV_PGRAPH_MISC_FLOWTHRU_WRITE                         26:26 /* CW-VF */
#define NV_PGRAPH_MISC_FLOWTHRU_WRITE_IGNORED            0x00000000 /* -W--V */
#define NV_PGRAPH_MISC_FLOWTHRU_WRITE_ENABLED            0x00000001 /* CW--V */
#define NV_PGRAPH_MISC_CLASS_WRITE                            27:27 /* CW-VF */
#define NV_PGRAPH_MISC_CLASS_WRITE_IGNORED               0x00000000 /* -W--V */
#define NV_PGRAPH_MISC_CLASS_WRITE_ENABLED               0x00000001 /* CW--V */
#define NV_PGRAPH_STATUS                                 0x004006B0 /* R--4R */
#define NV_PGRAPH_STATUS_STATE                                  0:0 /* R-IVF */
#define NV_PGRAPH_STATUS_STATE_IDLE                      0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_STATE_BUSY                      0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_XY_LOGIC                               4:4 /* R-IVF */
#define NV_PGRAPH_STATUS_XY_LOGIC_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_XY_LOGIC_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_NOTIFY                            8:8 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_NOTIFY_IDLE                0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_NOTIFY_BUSY                0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_REGISTER                        12:12 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_REGISTER_IDLE              0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_REGISTER_BUSY              0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_DMA                             16:16 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_DMA_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_DMA_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_DMA_NOTIFY                           20:20 /* R-IVF */
#define NV_PGRAPH_STATUS_DMA_NOTIFY_IDLE                 0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_DMA_NOTIFY_BUSY                 0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_FIFO                            24:24 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_FIFO_IDLE                  0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_FIFO_BUSY                  0x00000001 /* R---V */
#define NV_PGRAPH_TRAPPED_ADDR                           0x004006A8 /* R--4R */
#define NV_PGRAPH_TRAPPED_ADDR_VALUE                           20:2 /* R-XUF */
#define NV_PGRAPH_TRAPPED_DATA                           0x004006AC /* R--4R */
#define NV_PGRAPH_TRAPPED_DATA_VALUE                           31:0 /* R-XVF */
#define NV_PGRAPH_CANVAS_MISC                            0x00400634 /* RW-4R */
#define NV_PGRAPH_CANVAS_MISC_DAC_BYPASS                        0:0 /* RWXVF */
#define NV_PGRAPH_CANVAS_MISC_DAC_BYPASS_DISABLED        0x00000000 /* RW--V */
#define NV_PGRAPH_CANVAS_MISC_DAC_BYPASS_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_CANVAS_MISC_RETAINED                          4:4 /* RWXVF */
#define NV_PGRAPH_CANVAS_MISC_RETAINED_DISABLED          0x00000000 /* RW--V */
#define NV_PGRAPH_CANVAS_MISC_RETAINED_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_CANVAS_MISC_DAC_DECODE                      12:12 /* RWXVF */
#define NV_PGRAPH_CANVAS_MISC_DAC_DECODE_SINGLE          0x00000000 /* RW--V */
#define NV_PGRAPH_CANVAS_MISC_DAC_DECODE_TRIPLE          0x00000001 /* RW--V */
#define NV_PGRAPH_CANVAS_MISC_DITHER                          16:16 /* RWXVF */
#define NV_PGRAPH_CANVAS_MISC_DITHER_DISABLED            0x00000000 /* RW--V */
#define NV_PGRAPH_CANVAS_MISC_DITHER_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_CANVAS_MISC_REPLICATE                       20:20 /* RWXVF */
#define NV_PGRAPH_CANVAS_MISC_REPLICATE_DISABLED         0x00000000 /* RW--V */
#define NV_PGRAPH_CANVAS_MISC_REPLICATE_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_CANVAS_MISC_SOFTWARE                        24:24 /* RWXVF */
#define NV_PGRAPH_CANVAS_MISC_SOFTWARE_DISABLED          0x00000000 /* RW--V */
#define NV_PGRAPH_CANVAS_MISC_SOFTWARE_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_CLIP_MISC                              0x004006A0 /* RW-4R */
#define NV_PGRAPH_CLIP_MISC_REGIONS                             1:0 /* RWIUF */
#define NV_PGRAPH_CLIP_MISC_REGIONS_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CLIP_MISC_REGIONS_1                    0x00000001 /* RW--V */
#define NV_PGRAPH_CLIP_MISC_REGIONS_2                    0x00000002 /* RW--V */
#define NV_PGRAPH_CLIP_MISC_RENDER                              4:4 /* RWIVF */
#define NV_PGRAPH_CLIP_MISC_RENDER_INCLUDED              0x00000000 /* RWI-V */
#define NV_PGRAPH_CLIP_MISC_RENDER_OCCLUDED              0x00000001 /* RW--V */
#define NV_PGRAPH_CLIP_MISC_COMPLEX                             8:8 /* RWIVF */
#define NV_PGRAPH_CLIP_MISC_COMPLEX_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_CLIP_MISC_COMPLEX_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_CANVAS_MIN                             0x00400688 /* RW-4R */
#define NV_PGRAPH_CANVAS_MIN_X                                 15:0 /* RWXSF */
#define NV_PGRAPH_CANVAS_MIN_Y                                31:16 /* RWXSF */
#define NV_PGRAPH_CANVAS_MAX                             0x0040068C /* RW-4R */
#define NV_PGRAPH_CANVAS_MAX_X                                 11:0 /* RWXUF */
#define NV_PGRAPH_CANVAS_MAX_Y                                27:16 /* RWXUF */
#define NV_PGRAPH_CLIP0_MIN                              0x00400690 /* RW-4R */
#define NV_PGRAPH_CLIP0_MIN_X                                  11:0 /* RWXSF */
#define NV_PGRAPH_CLIP0_MIN_Y                                 27:16 /* RWXSF */
#define NV_PGRAPH_CLIP1_MIN                              0x00400698 /* RW-4R */
#define NV_PGRAPH_CLIP1_MIN_X                                  11:0 /* RWXSF */
#define NV_PGRAPH_CLIP1_MIN_Y                                 27:16 /* RWXSF */
#define NV_PGRAPH_CLIP0_MAX                              0x00400694 /* RW-4R */
#define NV_PGRAPH_CLIP0_MAX_X                                  11:0 /* RWXSF */
#define NV_PGRAPH_CLIP0_MAX_Y                                 27:16 /* RWXSF */
#define NV_PGRAPH_CLIP1_MAX                              0x0040069C /* RW-4R */
#define NV_PGRAPH_CLIP1_MAX_X                                  11:0 /* RWXSF */
#define NV_PGRAPH_CLIP1_MAX_Y                                 27:16 /* RWXSF */
#define NV_PGRAPH_DMA                                    0x00400680 /* RW-4R */
#define NV_PGRAPH_DMA_INSTANCE                                 15:0 /* RWXUF */
#define NV_PGRAPH_NOTIFY                                 0x00400684 /* RW-4R */
#define NV_PGRAPH_NOTIFY_INSTANCE                              15:0 /* RWXUF */
#define NV_PGRAPH_NOTIFY_WRITE                                16:16 /* RWIVF */
#define NV_PGRAPH_NOTIFY_WRITE_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PGRAPH_NOTIFY_WRITE_PENDING                   0x00000001 /* RW--V */
#define NV_PGRAPH_NOTIFY_INTERRUPT                            20:20 /* RWIVF */
#define NV_PGRAPH_NOTIFY_INTERRUPT_NOT_PENDING           0x00000000 /* RWI-V */
#define NV_PGRAPH_NOTIFY_INTERRUPT_PENDING               0x00000001 /* RW--V */
#define NV_PGRAPH_PATT_COLOR0_0                          0x00400600 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR0_0_BLUE                            9:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR0_0_GREEN                         19:10 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR0_0_RED                           29:20 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR0_1                          0x00400604 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR0_1_ALPHA                           7:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_0                          0x00400608 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR1_0_BLUE                            9:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_0_GREEN                         19:10 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_0_RED                           29:20 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1_1                          0x0040060C /* RW-4R */
#define NV_PGRAPH_PATT_COLOR1_1_ALPHA                           7:0 /* RWXUF */
#define NV_PGRAPH_PATTERN(i)                     (0x00400610+(i)*4) /* RW-4A */
#define NV_PGRAPH_PATTERN__SIZE_1                                 2 /*       */
#define NV_PGRAPH_PATTERN_BITMAP                               31:0 /* RWXVF */
#define NV_PGRAPH_PATTERN_SHAPE                          0x00400618 /* RW-4R */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE                           1:0 /* RWXVF */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_8X8                0x00000000 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_64X1               0x00000001 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_1X64               0x00000002 /* RW--V */
#define NV_PGRAPH_MONO_COLOR0                            0x0040061C /* RW-4R */
#define NV_PGRAPH_MONO_COLOR0_BLUE                              9:0 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR0_GREEN                           19:10 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR0_RED                             29:20 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR0_ALPHA                           30:30 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR1                            0x00400620 /* RW-4R */
#define NV_PGRAPH_MONO_COLOR1_BLUE                              9:0 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR1_GREEN                           19:10 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR1_RED                             29:20 /* RWXUF */
#define NV_PGRAPH_MONO_COLOR1_ALPHA                           30:30 /* RWXUF */
#define NV_PGRAPH_ROP3                                   0x00400624 /* RW-4R */
#define NV_PGRAPH_ROP3_VALUE                                    7:0 /* RWXVF */
#define NV_PGRAPH_PLANE_MASK                             0x00400628 /* RW-4R */
#define NV_PGRAPH_PLANE_MASK_BLUE                               9:0 /* RWXUF */
#define NV_PGRAPH_PLANE_MASK_GREEN                            19:10 /* RWXUF */
#define NV_PGRAPH_PLANE_MASK_RED                              29:20 /* RWXUF */
#define NV_PGRAPH_PLANE_MASK_ALPHA                            30:30 /* RWXUF */
#define NV_PGRAPH_CHROMA                                 0x0040062C /* RW-4R */
#define NV_PGRAPH_CHROMA_BLUE                                   9:0 /* RWXUF */
#define NV_PGRAPH_CHROMA_GREEN                                19:10 /* RWXUF */
#define NV_PGRAPH_CHROMA_RED                                  29:20 /* RWXUF */
#define NV_PGRAPH_CHROMA_ALPHA                                30:30 /* RWXUF */
#define NV_PGRAPH_BETA                                   0x00400630 /* RW-4R */
#define NV_PGRAPH_BETA_VALUE_FRACTION                         30:23 /* RWXUF */
#define NV_PGRAPH_ABS_X_RAM(i)                   (0x00400400+(i)*4) /* RW-4A */
#define NV_PGRAPH_ABS_X_RAM__SIZE_1                              18 /*       */
#define NV_PGRAPH_ABS_X_RAM_VALUE                              31:0 /* RWXUF */
#define NV_PGRAPH_REL_X_RAM(i)                   (0x00400500+(i)*4) /* RW-4A */
#define NV_PGRAPH_REL_X_RAM__SIZE_1                              18 /*       */
#define NV_PGRAPH_REL_X_RAM_VALUE                              31:0 /* -W-UF */
#define NV_PGRAPH_X_RAM_BPORT(i)                 (0x00400c00+(i)*4) /* R--4A */
#define NV_PGRAPH_X_RAM_BPORT__SIZE_1                            18 /*       */
#define NV_PGRAPH_X_RAM_BPORT_VALUE                            31:0 /* R--UF */
#define NV_PGRAPH_ABS_Y_RAM(i)                   (0x00400480+(i)*4) /* RW-4A */
#define NV_PGRAPH_ABS_Y_RAM__SIZE_1                              18 /*       */
#define NV_PGRAPH_ABS_Y_RAM_VALUE                              31:0 /* RWXUF */
#define NV_PGRAPH_REL_Y_RAM(i)                   (0x00400580+(i)*4) /* RW-4A */
#define NV_PGRAPH_REL_Y_RAM__SIZE_1                              18 /*       */
#define NV_PGRAPH_REL_Y_RAM_VALUE                              31:0 /* -W-UF */
#define NV_PGRAPH_Y_RAM_BPORT(i)                 (0x00400c80+(i)*4) /* R--4A */
#define NV_PGRAPH_Y_RAM_BPORT__SIZE_1                            18 /*       */
#define NV_PGRAPH_Y_RAM_BPORT_VALUE                            31:0 /* R--UF */
#define NV_PGRAPH_XY_LOGIC_MISC0                         0x00400640 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC0_MINOR                          8:0 /* RWIUF */
#define NV_PGRAPH_XY_LOGIC_MISC0_MINOR_0                 0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION                    12:12 /* RWXVF */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION_NONZERO       0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC0_MAJOR                        24:16 /* RWIUF */
#define NV_PGRAPH_XY_LOGIC_MISC0_MAJOR_0                 0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC0_INDEX                        31:28 /* RWIUF */
#define NV_PGRAPH_XY_LOGIC_MISC0_INDEX_0                 0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1                         0x00400644 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIALIZE                     0:0 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIALIZE_NEEDED       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIALIZE_DONE         0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_IMAGECLIPX                     4:4 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_IMAGECLIPX_NOTNULL      0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_IMAGECLIPX_NULL         0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_IMAGECLIPY                     5:5 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_IMAGECLIPY_NOTNULL      0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_IMAGECLIPY_NULL         0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX                      8:8 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY                      9:9 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_USERCLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN                    12:12 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN_CANVASMIN     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMIN_USERMIN       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX                    13:13 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX_CANVASMAX     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XCMAX_USERMAX       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX                    14:14 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN                    16:16 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN_CANVASMIN     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMIN_USERMIN       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX                    17:17 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX_CANVASMAX     0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YCMAX_USERMAX       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX                    18:18 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAGE                   20:20 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAGE_CLIPMAX      0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAGE_IMAGEMAX     0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_TM_COORD_FLAG                24:24 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_TM_COORD_FLAG_SET       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_TM_COORD_FLAG_CLR       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_FRACT_FMT                    25:25 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_FRACT_FMT_DISABLED      0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_FRACT_FMT_ENABLED       0x00000001 /* RW--V */
#define NV_PGRAPH_X_MISC                                 0x00400648 /* RW-4R */
#define NV_PGRAPH_X_MISC_BIT33_0                                0:0 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_BIT33_1                                1:1 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_BIT33_2                                2:2 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_BIT33_3                                3:3 /* RWIVF */
#define NV_PGRAPH_X_MISC_BIT33_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_0                                4:4 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_1                                5:5 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_2                                6:6 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_RANGE_3                                7:7 /* RWIVF */
#define NV_PGRAPH_X_MISC_RANGE_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_X_MISC_CLIP0_MIN                              9:8 /* RWIVF */
#define NV_PGRAPH_X_MISC_CLIP0_MIN_GT                    0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP0_MIN_LT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_X_MISC_CLIP0_MIN_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP0_MAX                            11:10 /* RWIVF */
#define NV_PGRAPH_X_MISC_CLIP0_MAX_LT                    0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP0_MAX_GT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_X_MISC_CLIP0_MAX_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP1_MIN                            13:12 /* RWIVF */
#define NV_PGRAPH_X_MISC_CLIP1_MIN_GT                    0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP1_MIN_LT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_X_MISC_CLIP1_MIN_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP1_MAX                            15:14 /* RWIVF */
#define NV_PGRAPH_X_MISC_CLIP1_MAX_LT                    0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP1_MAX_GT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_X_MISC_CLIP1_MAX_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP2_MIN                            17:16 /* RWIVF */
#define NV_PGRAPH_X_MISC_CLIP2_MIN_GT                    0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP2_MIN_LT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_X_MISC_CLIP2_MIN_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP2_MAX                            19:18 /* RWIVF */
#define NV_PGRAPH_X_MISC_CLIP2_MAX_LT                    0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP2_MAX_GT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_X_MISC_CLIP2_MAX_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP3_MIN                            21:20 /* RWIVF */
#define NV_PGRAPH_X_MISC_CLIP3_MIN_GT                    0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP3_MIN_LT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_X_MISC_CLIP3_MIN_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP3_MAX                            23:22 /* RWIVF */
#define NV_PGRAPH_X_MISC_CLIP3_MAX_LT                    0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC_CLIP3_MAX_GT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_X_MISC_CLIP3_MAX_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT                         29:28 /* RWXVF */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_EQ_0               0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_LT_0               0x00000001 /* RW--V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_GT_0               0x00000002 /* RW--V */
#define NV_PGRAPH_Y_MISC                                 0x0040064c /* RW-4R */
#define NV_PGRAPH_Y_MISC_BIT33_0                                0:0 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_BIT33_1                                1:1 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_BIT33_2                                2:2 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_BIT33_3                                3:3 /* RWIVF */
#define NV_PGRAPH_Y_MISC_BIT33_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_0                                4:4 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_0_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_1                                5:5 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_1_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_2                                6:6 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_2_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_RANGE_3                                7:7 /* RWIVF */
#define NV_PGRAPH_Y_MISC_RANGE_3_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_Y_MISC_CLIP0_MIN                              9:8 /* RWIVF */
#define NV_PGRAPH_Y_MISC_CLIP0_MIN_GT                    0x00000000 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP0_MIN_LT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_Y_MISC_CLIP0_MIN_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP0_MAX                            11:10 /* RWIVF */
#define NV_PGRAPH_Y_MISC_CLIP0_MAX_LT                    0x00000000 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP0_MAX_GT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_Y_MISC_CLIP0_MAX_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP1_MIN                            13:12 /* RWIVF */
#define NV_PGRAPH_Y_MISC_CLIP1_MIN_GT                    0x00000000 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP1_MIN_LT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_Y_MISC_CLIP1_MIN_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP1_MAX                            15:14 /* RWIVF */
#define NV_PGRAPH_Y_MISC_CLIP1_MAX_LT                    0x00000000 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP1_MAX_GT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_Y_MISC_CLIP1_MAX_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP2_MIN                            17:16 /* RWIVF */
#define NV_PGRAPH_Y_MISC_CLIP2_MIN_GT                    0x00000000 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP2_MIN_LT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_Y_MISC_CLIP2_MIN_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP2_MAX                            19:18 /* RWIVF */
#define NV_PGRAPH_Y_MISC_CLIP2_MAX_LT                    0x00000000 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP2_MAX_GT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_Y_MISC_CLIP2_MAX_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP3_MIN                            21:20 /* RWIVF */
#define NV_PGRAPH_Y_MISC_CLIP3_MIN_GT                    0x00000000 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP3_MIN_LT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_Y_MISC_CLIP3_MIN_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP3_MAX                            23:22 /* RWIVF */
#define NV_PGRAPH_Y_MISC_CLIP3_MAX_LT                    0x00000000 /* RW--V */
#define NV_PGRAPH_Y_MISC_CLIP3_MAX_GT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_Y_MISC_CLIP3_MAX_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT                         29:28 /* RWXVF */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_EQ_0               0x00000000 /* RW--V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_LT_0               0x00000001 /* RW--V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_GT_0               0x00000002 /* RW--V */
#define NV_PGRAPH_ABS_UCLIP_XMIN                         0x00400460 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_XMIN_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_REL_UCLIP_XMIN                         0x00400560 /* -W-4R */
#define NV_PGRAPH_REL_UCLIP_XMIN_VALUE                         17:0 /* -W-SF */
#define NV_PGRAPH_ABS_UCLIP_XMAX                         0x00400464 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_XMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_REL_UCLIP_XMAX                         0x00400564 /* -W-4R */
#define NV_PGRAPH_REL_UCLIP_XMAX_VALUE                         17:0 /* -W-SF */
#define NV_PGRAPH_ABS_UCLIP_YMIN                         0x00400468 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_YMIN_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_REL_UCLIP_YMIN                         0x00400568 /* -W-4R */
#define NV_PGRAPH_REL_UCLIP_YMIN_VALUE                         17:0 /* -W-SF */
#define NV_PGRAPH_ABS_UCLIP_YMAX                         0x0040046C /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_YMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_REL_UCLIP_YMAX                         0x0040056C /* -W-4R */
#define NV_PGRAPH_REL_UCLIP_YMAX_VALUE                         17:0 /* -W-SF */
#define NV_PGRAPH_SOURCE_COLOR                           0x00400654 /* RW-4R */
#define NV_PGRAPH_SOURCE_COLOR_VALUE                           31:0 /* RWXVF */
#define NV_PGRAPH_SUBDIVIDE                              0x00400658 /* RW-4R */
#define NV_PGRAPH_SUBDIVIDE_BTM_MAJOR_0123                      3:0 /* RWXVF */
#define NV_PGRAPH_SUBDIVIDE_QTM_MAJOR_0268                      3:0 /* RW-VF */
#define NV_PGRAPH_SUBDIVIDE_BTM_MINOR_0213                      7:4 /* RWXVF */
#define NV_PGRAPH_SUBDIVIDE_QTM_MINOR_0628                      7:4 /* RW-VF */
#define NV_PGRAPH_SUBDIVIDE_BTM_EDGE_01                       19:16 /* RWXVF */
#define NV_PGRAPH_SUBDIVIDE_QTM_EDGE_02                       19:16 /* RW-VF */
#define NV_PGRAPH_SUBDIVIDE_BTM_EDGE_23                       23:20 /* RWXVF */
#define NV_PGRAPH_SUBDIVIDE_QTM_EDGE_68                       23:20 /* RW-VF */
#define NV_PGRAPH_SUBDIVIDE_BTM_EDGE_02                       27:24 /* RWXVF */
#define NV_PGRAPH_SUBDIVIDE_QTM_EDGE_06                       27:24 /* RW-VF */
#define NV_PGRAPH_SUBDIVIDE_BTM_EDGE_13                       31:28 /* RWXVF */
#define NV_PGRAPH_SUBDIVIDE_QTM_EDGE_28                       31:28 /* RW-VF */
#define NV_PGRAPH_SUBDIVIDE_BY_1                         0x00000000 /* RW--V */
#define NV_PGRAPH_SUBDIVIDE_BY_2                         0x00000001 /* RW--V */
#define NV_PGRAPH_SUBDIVIDE_BY_4                         0x00000002 /* RW--V */
#define NV_PGRAPH_SUBDIVIDE_BY_8                         0x00000003 /* RW--V */
#define NV_PGRAPH_SUBDIVIDE_BY_16                        0x00000004 /* RW--V */
#define NV_PGRAPH_SUBDIVIDE_BY_32                        0x00000005 /* RW--V */
#define NV_PGRAPH_SUBDIVIDE_BY_64                        0x00000006 /* RW--V */
#define NV_PGRAPH_SUBDIVIDE_BY_128                       0x00000007 /* RW--V */
#define NV_PGRAPH_SUBDIVIDE_BY_256                       0x00000008 /* RW--V */
#define NV_PGRAPH_EXCEPTIONS                             0x00400650 /* RW-4R */
#define NV_PGRAPH_EXCEPTIONS_X_VALID                            8:0 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_X_VALID_0                   0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_Y_VALID                          20:12 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_Y_VALID_0                   0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_XY                          24:24 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_CLIP_XY_NO_ERROR            0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_XY_ONLY                0x00000001 /* RW--V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_WH                          28:28 /* RWIVF */
#define NV_PGRAPH_EXCEPTIONS_CLIP_WH_NO_ERROR            0x00000000 /* RWI-V */
#define NV_PGRAPH_EXCEPTIONS_CLIP_WH_ONLY                0x00000001 /* RW--V */
#define NV_PGRAPH_EDGEFILL                               0x0040065c /* RW-4R */
#define NV_PGRAPH_EDGEFILL_STAGE                                1:0 /* RWXVF */
#define NV_PGRAPH_EDGEFILL_STAGE_FIRST_STRIP             0x00000000 /* RW--V */
#define NV_PGRAPH_EDGEFILL_STAGE_MIDDLE_STRIPS           0x00000001 /* RW--V */
#define NV_PGRAPH_EDGEFILL_STAGE_LAST_STRIP              0x00000002 /* RW--V */
#define NV_PGRAPH_EDGEFILL_FIRST_MAJMIN                         4:4 /* RWXVF */
#define NV_PGRAPH_EDGEFILL_FIRST_MINMAJ                         8:8 /* RWXVF */
#define NV_PGRAPH_EDGEFILL_X16_MIN                            17:16 /* RWIVF */
#define NV_PGRAPH_EDGEFILL_X16_MIN_GT                    0x00000000 /* RW--V */
#define NV_PGRAPH_EDGEFILL_X16_MIN_LT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_EDGEFILL_X16_MIN_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_EDGEFILL_X16_MAX                            19:18 /* RWIVF */
#define NV_PGRAPH_EDGEFILL_X16_MAX_LT                    0x00000000 /* RW--V */
#define NV_PGRAPH_EDGEFILL_X16_MAX_GT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_EDGEFILL_X16_MAX_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_EDGEFILL_Y16_MIN                            21:20 /* RWIVF */
#define NV_PGRAPH_EDGEFILL_Y16_MIN_GT                    0x00000000 /* RW--V */
#define NV_PGRAPH_EDGEFILL_Y16_MIN_LT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_EDGEFILL_Y16_MIN_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_EDGEFILL_Y16_MAX                            23:22 /* RWIVF */
#define NV_PGRAPH_EDGEFILL_Y16_MAX_LT                    0x00000000 /* RW--V */
#define NV_PGRAPH_EDGEFILL_Y16_MAX_GT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_EDGEFILL_Y16_MAX_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_EDGEFILL_X17_MIN                            25:24 /* RWIVF */
#define NV_PGRAPH_EDGEFILL_X17_MIN_GT                    0x00000000 /* RW--V */
#define NV_PGRAPH_EDGEFILL_X17_MIN_LT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_EDGEFILL_X17_MIN_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_EDGEFILL_X17_MAX                            27:26 /* RWIVF */
#define NV_PGRAPH_EDGEFILL_X17_MAX_LT                    0x00000000 /* RW--V */
#define NV_PGRAPH_EDGEFILL_X17_MAX_GT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_EDGEFILL_X17_MAX_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_EDGEFILL_Y17_MIN                            29:28 /* RWIVF */
#define NV_PGRAPH_EDGEFILL_Y17_MIN_GT                    0x00000000 /* RW--V */
#define NV_PGRAPH_EDGEFILL_Y17_MIN_LT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_EDGEFILL_Y17_MIN_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_EDGEFILL_Y17_MAX                            31:30 /* RWIVF */
#define NV_PGRAPH_EDGEFILL_Y17_MAX_LT                    0x00000000 /* RW--V */
#define NV_PGRAPH_EDGEFILL_Y17_MAX_GT                    0x00000001 /* RWI-V */
#define NV_PGRAPH_EDGEFILL_Y17_MAX_EQ                    0x00000002 /* RW--V */
#define NV_PGRAPH_BETA_RAM(i)                    (0x00400700+(i)*4) /* RW-4A */
#define NV_PGRAPH_BETA_RAM__SIZE_1                               14 /*       */
#define NV_PGRAPH_BETA_RAM_VALUE                               24:0 /* RWXUF */
#define NV_PGRAPH_BETA_RAM_BPORT(i)              (0x00400d00+(i)*4) /* R--4A */
#define NV_PGRAPH_BETA_RAM_BPORT__SIZE_1                         14 /*       */
#define NV_PGRAPH_BETA_RAM_BPORT_VALUE                         24:0 /* R--UF */
#define NV_PGRAPH_ABS_ICLIP_XMAX                         0x00400450 /* RW-4R */
#define NV_PGRAPH_ABS_ICLIP_XMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_REL_ICLIP_XMAX                         0x00400550 /* -W-4R */
#define NV_PGRAPH_REL_ICLIP_XMAX_VALUE                         17:0 /* -W-SF */
#define NV_PGRAPH_ABS_ICLIP_YMAX                         0x00400454 /* RW-4R */
#define NV_PGRAPH_ABS_ICLIP_YMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_REL_ICLIP_YMAX                         0x00400554 /* -W-4R */
#define NV_PGRAPH_REL_ICLIP_YMAX_VALUE                         17:0 /* -W-SF */
#define NV_PGRAPH_BIT33                                  0x00400660 /* RW-4R */
#define NV_PGRAPH_BIT33_X_REG0                                  0:0 /* RWXVF */
#define NV_PGRAPH_BIT33_X_REG3                                  1:1 /* RWXVF */
#define NV_PGRAPH_BIT33_X_REG6                                  2:2 /* RWXVF */
#define NV_PGRAPH_BIT33_X_REG9                                  3:3 /* RWXVF */
#define NV_PGRAPH_BIT33_X_REG12                                 4:4 /* RWXVF */
#define NV_PGRAPH_BIT33_X_REG15                                 5:5 /* RWXVF */
#define NV_PGRAPH_BIT33_X_REG16                                 6:6 /* RWXVF */
#define NV_PGRAPH_BIT33_X_REG17                                 7:7 /* RWXVF */
#define NV_PGRAPH_BIT33_Y_REG0                                16:16 /* RWXVF */
#define NV_PGRAPH_BIT33_Y_REG3                                17:17 /* RWXVF */
#define NV_PGRAPH_BIT33_Y_REG6                                18:18 /* RWXVF */
#define NV_PGRAPH_BIT33_Y_REG9                                19:19 /* RWXVF */
#define NV_PGRAPH_BIT33_Y_REG12                               20:20 /* RWXVF */
#define NV_PGRAPH_BIT33_Y_REG15                               21:21 /* RWXVF */
#define NV_PGRAPH_BIT33_Y_REG16                               22:22 /* RWXVF */
#define NV_PGRAPH_BIT33_Y_REG17                               23:23 /* RWXVF */
#define NV_PGRAPH_DEBUG_0                                0x00400080 /* RW-4R */
#define NV_PGRAPH_DEBUG_1                                0x00400084 /* RW-4R */
#define NV_PGRAPH_DEBUG_2                                0x00400088 /* RW-4R */
#define NV_PGRAPH_DEBUG_3                                0x0040008c /* RW-4R */
#define NV_PGRAPH_INTR_0                                 0x00400100 /* RW-4R */
#define NV_PGRAPH_INTR_1                                 0x00400104 /* RW-4R */
#define NV_PGRAPH_INTR_EN_0                              0x00400140 /* RW-4R */
#define NV_PGRAPH_INTR_EN_1                              0x00400144 /* RW-4R */
#define NV_PGRAPH_CTX_SWITCH                             0x00400180 /* RW-4R */
#define NV_PGRAPH_CTX_CONTROL                            0x00400190 /* RW-4R */
#define NV_PGRAPH_MISC                                   0x004006A4 /* RW-4R */
#define NV_PGRAPH_STATUS                                 0x004006B0 /* R--4R */
#define NV_PGRAPH_TRAPPED_ADDR                           0x004006A8 /* R--4R */
#define NV_PGRAPH_TRAPPED_DATA                           0x004006AC /* R--4R */
#define NV_PGRAPH_CANVAS_MISC                            0x00400634 /* RW-4R */
#define NV_PGRAPH_CLIP_MISC                              0x004006A0 /* RW-4R */
#define NV_PGRAPH_CANVAS_MIN                             0x00400688 /* RW-4R */
#define NV_PGRAPH_CANVAS_MAX                             0x0040068C /* RW-4R */
#define NV_PGRAPH_CLIP0_MIN                              0x00400690 /* RW-4R */
#define NV_PGRAPH_CLIP1_MIN                              0x00400698 /* RW-4R */
#define NV_PGRAPH_CLIP0_MAX                              0x00400694 /* RW-4R */
#define NV_PGRAPH_CLIP1_MAX                              0x0040069C /* RW-4R */
#define NV_PGRAPH_DMA                                    0x00400680 /* RW-4R */
#define NV_PGRAPH_NOTIFY                                 0x00400684 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR0_0                          0x00400600 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR0_1                          0x00400604 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR1_0                          0x00400608 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR1_1                          0x0040060C /* RW-4R */
#define NV_PGRAPH_PATTERN_SHAPE                          0x00400618 /* RW-4R */
#define NV_PGRAPH_MONO_COLOR0                            0x0040061C /* RW-4R */
#define NV_PGRAPH_MONO_COLOR1                            0x00400620 /* RW-4R */
#define NV_PGRAPH_ROP3                                   0x00400624 /* RW-4R */
#define NV_PGRAPH_PLANE_MASK                             0x00400628 /* RW-4R */
#define NV_PGRAPH_CHROMA                                 0x0040062C /* RW-4R */
#define NV_PGRAPH_BETA                                   0x00400630 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC0                         0x00400640 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC1                         0x00400644 /* RW-4R */
#define NV_PGRAPH_X_MISC                                 0x00400648 /* RW-4R */
#define NV_PGRAPH_Y_MISC                                 0x0040064c /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_XMIN                         0x00400460 /* RW-4R */
#define NV_PGRAPH_REL_UCLIP_XMIN                         0x00400560 /* -W-4R */
#define NV_PGRAPH_ABS_UCLIP_XMAX                         0x00400464 /* RW-4R */
#define NV_PGRAPH_REL_UCLIP_XMAX                         0x00400564 /* -W-4R */
#define NV_PGRAPH_ABS_UCLIP_YMIN                         0x00400468 /* RW-4R */
#define NV_PGRAPH_REL_UCLIP_YMIN                         0x00400568 /* -W-4R */
#define NV_PGRAPH_ABS_UCLIP_YMAX                         0x0040046C /* RW-4R */
#define NV_PGRAPH_REL_UCLIP_YMAX                         0x0040056C /* -W-4R */
#define NV_PGRAPH_SOURCE_COLOR                           0x00400654 /* RW-4R */
#define NV_PGRAPH_SUBDIVIDE                              0x00400658 /* RW-4R */
#define NV_PGRAPH_EXCEPTIONS                             0x00400650 /* RW-4R */
#define NV_PGRAPH_EDGEFILL                               0x0040065c /* RW-4R */
#define NV_PGRAPH_ABS_ICLIP_XMAX                         0x00400450 /* RW-4R */
#define NV_PGRAPH_REL_ICLIP_XMAX                         0x00400550 /* -W-4R */
#define NV_PGRAPH_ABS_ICLIP_YMAX                         0x00400454 /* RW-4R */
#define NV_PGRAPH_REL_ICLIP_YMAX                         0x00400554 /* -W-4R */
#define NV_PGRAPH_BIT33                                  0x00400660 /* RW-4R */
/* usr_beta_solid.ref */
#define NV_UBETA                              0x00411FFF:0x00410000 /* -W--D */
#define NV_UBETA_CTX_SWITCH                              0x00410000 /* -W-4R */
#define NV_UBETA_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UBETA_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UBETA_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UBETA_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UBETA_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UBETA_SET_NOTIFY                              0x00410104 /* -W-4R */
#define NV_UBETA_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UBETA_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UBETA_SET_BETA1D31                            0x00410300 /* -W-4R */
#define NV_UBETA_SET_BETA1D31_VALUE_FRACTION                  30:21 /* -W-UF */
#define NV_UBETA_SET_BETA1D31_VALUE                           31:31 /* -W-SF */
/* usr_rop_solid.ref */
#define NV_UROP                               0x00421FFF:0x00420000 /* -W--D */
#define NV_UROP_CTX_SWITCH                               0x00420000 /* -W-4R */
#define NV_UROP_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
#define NV_UROP_CTX_SWITCH_CHID                               22:16 /* -W-UF */
#define NV_UROP_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
#define NV_UROP_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
#define NV_UROP_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
#define NV_UROP_SET_NOTIFY                               0x00420104 /* -W-4R */
#define NV_UROP_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
#define NV_UROP_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
#define NV_UROP_SET_ROP                                  0x00420300 /* -W-4R */
#define NV_UROP_SET_ROP_VALUE                                   7:0 /* -W-VF */
/* usr_color_key.ref */
#define NV_UCHROMA                            0x00431FFF:0x00430000 /* -W--D */
#define NV_UCHROMA_CTX_SWITCH                            0x00430000 /* -W-4R */
#define NV_UCHROMA_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_UCHROMA_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_UCHROMA_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_UCHROMA_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_UCHROMA_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_UCHROMA_SET_NOTIFY                            0x00430104 /* -W-4R */
#define NV_UCHROMA_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UCHROMA_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UCHROMA_SET_COLOR                             0x00430304 /* -W-4R */
#define NV_UCHROMA_SET_COLOR_VALUE                             31:0 /* -W-VF */
/* usr_plane_switch.ref */
#define NV_UPLANE                             0x00441FFF:0x00440000 /* -W--D */
#define NV_UPLANE_CTX_SWITCH                             0x00440000 /* -W-4R */
#define NV_UPLANE_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UPLANE_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UPLANE_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UPLANE_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UPLANE_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UPLANE_SET_NOTIFY                             0x00440104 /* -W-4R */
#define NV_UPLANE_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UPLANE_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UPLANE_SET_COLOR                              0x00440304 /* -W-4R */
#define NV_UPLANE_SET_COLOR_VALUE                              31:0 /* -W-VF */
/* usr_clipping.ref */
#define NV_UCLIP                              0x00451FFF:0x00450000 /* -W--D */
#define NV_UCLIP_CTX_SWITCH                              0x00450000 /* -W-4R */
#define NV_UCLIP_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UCLIP_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UCLIP_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UCLIP_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UCLIP_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UCLIP_SET_NOTIFY                              0x00450104 /* -W-4R */
#define NV_UCLIP_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UCLIP_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UCLIP_SET_RECT_0                              0x00450300 /* -W-4R */
#define NV_UCLIP_SET_RECT_0_X                                  15:0 /* -W-SF */
#define NV_UCLIP_SET_RECT_0_Y                                 31:16 /* -W-SF */
#define NV_UCLIP_SET_RECT_1                              0x00450304 /* -W-4R */
#define NV_UCLIP_SET_RECT_1_WIDTH                              15:0 /* -W-UF */
#define NV_UCLIP_SET_RECT_1_HEIGHT                            31:16 /* -W-UF */
/* usr_pattern.ref */
#define NV_UPATT                              0x00461FFF:0x00460000 /* -W--D */
#define NV_UPATT_CTX_SWITCH                              0x00460000 /* -W-4R */
#define NV_UPATT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UPATT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UPATT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UPATT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UPATT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UPATT_SET_NOTIFY                              0x00460104 /* -W-4R */
#define NV_UPATT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UPATT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UPATT_SET_SHAPE                               0x00460308 /* -W-4R */
#define NV_UPATT_SET_SHAPE_VALUE                                1:0 /* -W-VF */
#define NV_UPATT_SET_SHAPE_VALUE_8X8                     0x00000000 /* -W--V */
#define NV_UPATT_SET_SHAPE_VALUE_64X1                    0x00000001 /* -W--V */
#define NV_UPATT_SET_SHAPE_VALUE_1X64                    0x00000002 /* -W--V */
#define NV_UPATT_SET_COLOR0                              0x00460310 /* -W-4R */
#define NV_UPATT_SET_COLOR0_VALUE                              31:0 /* -W-VF */
#define NV_UPATT_SET_COLOR1                              0x00460314 /* -W-4R */
#define NV_UPATT_SET_COLOR1_VALUE                              31:0 /* -W-VF */
#define NV_UPATT_SET_PATTERN(i)                  (0x00460318+(i)*4) /* -W-4A */
#define NV_UPATT_SET_PATTERN__SIZE_1                              2 /*       */
#define NV_UPATT_SET_PATTERN_BITMAP                            31:0 /* -W-VF */
/* usr_point.ref */
#define NV_UPOINT                             0x00481FFF:0x00480000 /* -W--D */
#define NV_UPOINT_CTX_SWITCH                             0x00480000 /* -W-4R */
#define NV_UPOINT_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UPOINT_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UPOINT_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UPOINT_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UPOINT_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UPOINT_SET_NOTIFY                             0x00480104 /* -W-4R */
#define NV_UPOINT_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UPOINT_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UPOINT_COLOR                                  0x00480304 /* -W-4R */
#define NV_UPOINT_COLOR_VALUE                                  31:0 /* -W-VF */
#define NV_UPOINT_POINT(i)                       (0x00480400+(i)*4) /* -W-4A */
#define NV_UPOINT_POINT__SIZE_1                                  32 /*       */
#define NV_UPOINT_POINT_X                                      15:0 /* -W-SF */
#define NV_UPOINT_POINT_Y                                     31:16 /* -W-SF */
#define NV_UPOINT_POINT32_0(i)                   (0x00480480+(i)*8) /* -W-4A */
#define NV_UPOINT_POINT32_0__SIZE_1                              16 /*       */
#define NV_UPOINT_POINT32_0_X                                  31:0 /* -W-SF */
#define NV_UPOINT_POINT32_1(i)                   (0x00480484+(i)*8) /* -W-4A */
#define NV_UPOINT_POINT32_1__SIZE_1                              16 /*       */
#define NV_UPOINT_POINT32_1_Y                                  31:0 /* -W-SF */
#define NV_UPOINT_CPOINT_0(i)                    (0x00480500+(i)*8) /* -W-4A */
#define NV_UPOINT_CPOINT_0__SIZE_1                               16 /*       */
#define NV_UPOINT_CPOINT_0_COLOR                               31:0 /* -W-VF */
#define NV_UPOINT_CPOINT_1(i)                    (0x00480504+(i)*8) /* -W-4A */
#define NV_UPOINT_CPOINT_1__SIZE_1                               16 /*       */
#define NV_UPOINT_CPOINT_1_X                                   15:0 /* -W-SF */
#define NV_UPOINT_CPOINT_1_Y                                  31:16 /* -W-SF */
/* usr_line.ref */
#define NV_ULINE                              0x00491FFF:0x00490000 /* -W--D */
#define NV_ULINE_CTX_SWITCH                              0x00490000 /* -W-4R */
#define NV_ULINE_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_ULINE_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_ULINE_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_ULINE_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_ULINE_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_ULINE_SET_NOTIFY                              0x00490104 /* -W-4R */
#define NV_ULINE_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_ULINE_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_ULINE_COLOR                                   0x00490304 /* -W-4R */
#define NV_ULINE_COLOR_VALUE                                   31:0 /* -W-VF */
#define NV_ULINE_LINE_0(i)                       (0x00490400+(i)*8) /* -W-4A */
#define NV_ULINE_LINE_0__SIZE_1                                  16 /*       */
#define NV_ULINE_LINE_0_X                                      15:0 /* -W-SF */
#define NV_ULINE_LINE_0_Y                                     31:16 /* -W-SF */
#define NV_ULINE_LINE_1(i)                       (0x00490404+(i)*8) /* -W-4A */
#define NV_ULINE_LINE_1__SIZE_1                                  16 /*       */
#define NV_ULINE_LINE_1_X                                      15:0 /* -W-SF */
#define NV_ULINE_LINE_1_Y                                     31:16 /* -W-SF */
#define NV_ULINE_LINE32_0(i)                    (0x00490480+(i)*16) /* -W-4A */
#define NV_ULINE_LINE32_0__SIZE_1                                 8 /*       */
#define NV_ULINE_LINE32_0_X                                    31:0 /* -W-SF */
#define NV_ULINE_LINE32_1(i)                    (0x00490484+(i)*16) /* -W-4A */
#define NV_ULINE_LINE32_1__SIZE_1                                 8 /*       */
#define NV_ULINE_LINE32_1_Y                                    31:0 /* -W-SF */
#define NV_ULINE_LINE32_2(i)                    (0x00490488+(i)*16) /* -W-4A */
#define NV_ULINE_LINE32_2__SIZE_1                                 8 /*       */
#define NV_ULINE_LINE32_2_X                                    31:0 /* -W-SF */
#define NV_ULINE_LINE32_3(i)                    (0x0049048C+(i)*16) /* -W-4A */
#define NV_ULINE_LINE32_3__SIZE_1                                 8 /*       */
#define NV_ULINE_LINE32_3_Y                                    31:0 /* -W-SF */
#define NV_ULINE_POLYLINE(i)                     (0x00490500+(i)*4) /* -W-4A */
#define NV_ULINE_POLYLINE__SIZE_1                                32 /*       */
#define NV_ULINE_POLYLINE_X                                    15:0 /* -W-SF */
#define NV_ULINE_POLYLINE_Y                                   31:16 /* -W-SF */
#define NV_ULINE_POLYLINE32_0(i)                 (0x00490580+(i)*8) /* -W-4A */
#define NV_ULINE_POLYLINE32_0__SIZE_1                            16 /*       */
#define NV_ULINE_POLYLINE32_0_X                                31:0 /* -W-SF */
#define NV_ULINE_POLYLINE32_1(i)                 (0x00490584+(i)*8) /* -W-4A */
#define NV_ULINE_POLYLINE32_1__SIZE_1                            16 /*       */
#define NV_ULINE_POLYLINE32_1_Y                                31:0 /* -W-SF */
#define NV_ULINE_CPOLYLINE_0(i)                  (0x00490600+(i)*8) /* -W-4A */
#define NV_ULINE_CPOLYLINE_0__SIZE_1                             16 /*       */
#define NV_ULINE_CPOLYLINE_0_COLOR                             31:0 /* -W-VF */
#define NV_ULINE_CPOLYLINE_1(i)                  (0x00490604+(i)*8) /* -W-4A */
#define NV_ULINE_CPOLYLINE_1__SIZE_1                             16 /*       */
#define NV_ULINE_CPOLYLINE_1_X                                 15:0 /* -W-SF */
#define NV_ULINE_CPOLYLINE_1_Y                                31:16 /* -W-SF */
/* usr_lin.ref */
#define NV_ULIN                               0x004A1FFF:0x004A0000 /* -W--D */
#define NV_ULIN_CTX_SWITCH                               0x004A0000 /* -W-4R */
#define NV_ULIN_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
#define NV_ULIN_CTX_SWITCH_CHID                               22:16 /* -W-UF */
#define NV_ULIN_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
#define NV_ULIN_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
#define NV_ULIN_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
#define NV_ULIN_SET_NOTIFY                               0x004A0104 /* -W-4R */
#define NV_ULIN_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
#define NV_ULIN_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
#define NV_ULIN_COLOR                                    0x004A0304 /* -W-4R */
#define NV_ULIN_COLOR_VALUE                                    31:0 /* -W-VF */
#define NV_ULIN_LIN_0(i)                         (0x004A0400+(i)*8) /* -W-4A */
#define NV_ULIN_LIN_0__SIZE_1                                    16 /*       */
#define NV_ULIN_LIN_0_X                                        15:0 /* -W-SF */
#define NV_ULIN_LIN_0_Y                                       31:16 /* -W-SF */
#define NV_ULIN_LIN_1(i)                         (0x004A0404+(i)*8) /* -W-4A */
#define NV_ULIN_LIN_1__SIZE_1                                    16 /*       */
#define NV_ULIN_LIN_1_X                                        15:0 /* -W-SF */
#define NV_ULIN_LIN_1_Y                                       31:16 /* -W-SF */
#define NV_ULIN_LIN32_0(i)                      (0x004A0480+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_0__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_0_X                                      31:0 /* -W-SF */
#define NV_ULIN_LIN32_1(i)                      (0x004A0484+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_1__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_1_Y                                      31:0 /* -W-SF */
#define NV_ULIN_LIN32_2(i)                      (0x004A0488+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_2__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_2_X                                      31:0 /* -W-SF */
#define NV_ULIN_LIN32_3(i)                      (0x004A048C+(i)*16) /* -W-4A */
#define NV_ULIN_LIN32_3__SIZE_1                                   8 /*       */
#define NV_ULIN_LIN32_3_Y                                      31:0 /* -W-SF */
#define NV_ULIN_POLYLIN(i)                       (0x004A0500+(i)*4) /* -W-4A */
#define NV_ULIN_POLYLIN__SIZE_1                                  32 /*       */
#define NV_ULIN_POLYLIN_X                                      15:0 /* -W-SF */
#define NV_ULIN_POLYLIN_Y                                     31:16 /* -W-SF */
#define NV_ULIN_POLYLIN32_0(i)                   (0x004A0580+(i)*8) /* -W-4A */
#define NV_ULIN_POLYLIN32_0__SIZE_1                              16 /*       */
#define NV_ULIN_POLYLIN32_0_X                                  31:0 /* -W-SF */
#define NV_ULIN_POLYLIN32_1(i)                   (0x004A0584+(i)*8) /* -W-4A */
#define NV_ULIN_POLYLIN32_1__SIZE_1                              16 /*       */
#define NV_ULIN_POLYLIN32_1_Y                                  31:0 /* -W-SF */
#define NV_ULIN_CPOLYLIN_0(i)                    (0x004A0600+(i)*8) /* -W-4A */
#define NV_ULIN_CPOLYLIN_0__SIZE_1                               16 /*       */
#define NV_ULIN_CPOLYLIN_0_COLOR                               31:0 /* -W-VF */
#define NV_ULIN_CPOLYLIN_1(i)                    (0x004A0604+(i)*8) /* -W-4A */
#define NV_ULIN_CPOLYLIN_1__SIZE_1                               16 /*       */
#define NV_ULIN_CPOLYLIN_1_X                                   15:0 /* -W-SF */
#define NV_ULIN_CPOLYLIN_1_Y                                  31:16 /* -W-SF */
/* usr_triangle.ref */
#define NV_UTRI                               0x004B1FFF:0x004B0000 /* -W--D */
#define NV_UTRI_CTX_SWITCH                               0x004B0000 /* -W-4R */
#define NV_UTRI_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
#define NV_UTRI_CTX_SWITCH_CHID                               22:16 /* -W-UF */
#define NV_UTRI_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
#define NV_UTRI_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
#define NV_UTRI_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
#define NV_UTRI_SET_NOTIFY                               0x004B0104 /* -W-4R */
#define NV_UTRI_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
#define NV_UTRI_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
#define NV_UTRI_COLOR                                    0x004B0304 /* -W-4R */
#define NV_UTRI_COLOR_VALUE                                    31:0 /* -W-VF */
#define NV_UTRI_TRIANGLE_0                               0x004B0310 /* -W-4R */
#define NV_UTRI_TRIANGLE_0_X                                   15:0 /* -W-SF */
#define NV_UTRI_TRIANGLE_0_Y                                  31:16 /* -W-SF */
#define NV_UTRI_TRIANGLE_1                               0x004B0314 /* -W-4R */
#define NV_UTRI_TRIANGLE_1_X                                   15:0 /* -W-SF */
#define NV_UTRI_TRIANGLE_1_Y                                  31:16 /* -W-SF */
#define NV_UTRI_TRIANGLE_2                               0x004B0318 /* -W-4R */
#define NV_UTRI_TRIANGLE_2_X                                   15:0 /* -W-SF */
#define NV_UTRI_TRIANGLE_2_Y                                  31:16 /* -W-SF */
#define NV_UTRI_TRIANGLE32_0                             0x004B0320 /* -W-4R */
#define NV_UTRI_TRIANGLE32_0_X                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_1                             0x004B0324 /* -W-4R */
#define NV_UTRI_TRIANGLE32_1_Y                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_2                             0x004B0328 /* -W-4R */
#define NV_UTRI_TRIANGLE32_2_X                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_3                             0x004B032C /* -W-4R */
#define NV_UTRI_TRIANGLE32_3_Y                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_4                             0x004B0330 /* -W-4R */
#define NV_UTRI_TRIANGLE32_4_X                                 31:0 /* -W-SF */
#define NV_UTRI_TRIANGLE32_5                             0x004B0334 /* -W-4R */
#define NV_UTRI_TRIANGLE32_5_Y                                 31:0 /* -W-SF */
#define NV_UTRI_TRIMESH(i)                       (0x004B0400+(i)*4) /* -W-4A */
#define NV_UTRI_TRIMESH__SIZE_1                                  32 /*       */
#define NV_UTRI_TRIMESH_X                                      15:0 /* -W-SF */
#define NV_UTRI_TRIMESH_Y                                     31:16 /* -W-SF */
#define NV_UTRI_TRIMESH32_0(i)                   (0x004B0480+(i)*8) /* -W-4A */
#define NV_UTRI_TRIMESH32_0__SIZE_1                              16 /*       */
#define NV_UTRI_TRIMESH32_0_X                                  31:0 /* -W-SF */
#define NV_UTRI_TRIMESH32_1(i)                   (0x004B0484+(i)*8) /* -W-4A */
#define NV_UTRI_TRIMESH32_1__SIZE_1                              16 /*       */
#define NV_UTRI_TRIMESH32_1_Y                                  31:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_0(i)                  (0x004B0500+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_0__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_0_COLOR                              31:0 /* -W-VF */
#define NV_UTRI_CTRIANGLE_1(i)                  (0x004B0504+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_1__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_1_X                                  15:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_1_Y                                 31:16 /* -W-SF */
#define NV_UTRI_CTRIANGLE_2(i)                  (0x004B0508+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_2__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_2_X                                  15:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_2_Y                                 31:16 /* -W-SF */
#define NV_UTRI_CTRIANGLE_3(i)                  (0x004B050C+(i)*16) /* -W-4A */
#define NV_UTRI_CTRIANGLE_3__SIZE_1                               8 /*       */
#define NV_UTRI_CTRIANGLE_3_X                                  15:0 /* -W-SF */
#define NV_UTRI_CTRIANGLE_3_Y                                 31:16 /* -W-SF */
#define NV_UTRI_CTRIMESH_0(i)                    (0x004B0580+(i)*8) /* -W-4A */
#define NV_UTRI_CTRIMESH_0__SIZE_1                               16 /*       */
#define NV_UTRI_CTRIMESH_0_COLOR                               31:0 /* -W-VF */
#define NV_UTRI_CTRIMESH_1(i)                    (0x004B0584+(i)*8) /* -W-4A */
#define NV_UTRI_CTRIMESH_1__SIZE_1                               16 /*       */
#define NV_UTRI_CTRIMESH_1_X                                   15:0 /* -W-SF */
#define NV_UTRI_CTRIMESH_1_Y                                  31:16 /* -W-SF */
/* usr_rectangle.ref */
#define NV_URECT                              0x004C1FFF:0x004C0000 /* -W--D */
#define NV_URECT_CTX_SWITCH                              0x004C0000 /* -W-4R */
#define NV_URECT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_URECT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_URECT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_URECT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_URECT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_URECT_SET_NOTIFY                              0x004C0104 /* -W-4R */
#define NV_URECT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_URECT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_URECT_COLOR                                   0x004C0304 /* -W-4R */
#define NV_URECT_COLOR_VALUE                                   31:0 /* -W-VF */
#define NV_URECT_RECTANGLE_0(i)                  (0x004C0400+(i)*8) /* -W-4A */
#define NV_URECT_RECTANGLE_0__SIZE_1                             16 /*       */
#define NV_URECT_RECTANGLE_0_X                                 15:0 /* -W-SF */
#define NV_URECT_RECTANGLE_0_Y                                31:16 /* -W-SF */
#define NV_URECT_RECTANGLE_1(i)                  (0x004C0404+(i)*8) /* -W-4A */
#define NV_URECT_RECTANGLE_1__SIZE_1                             16 /*       */
#define NV_URECT_RECTANGLE_1_WIDTH                             15:0 /* -W-UF */
#define NV_URECT_RECTANGLE_1_HEIGHT                           31:16 /* -W-UF */
/* usr_bilinear.ref */
#define NV_UBTM                               0x004D1FFF:0x004D0000 /* -W--D */
#define NV_UBTM_CTX_SWITCH                               0x004D0000 /* -W-4R */
#define NV_UBTM_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
#define NV_UBTM_CTX_SWITCH_CHID                               22:16 /* -W-UF */
#define NV_UBTM_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
#define NV_UBTM_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
#define NV_UBTM_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
#define NV_UBTM_SET_NOTIFY                               0x004D0104 /* -W-4R */
#define NV_UBTM_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
#define NV_UBTM_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
#define NV_UBTM_SUBDIVIDE_IN                             0x004D0304 /* -W-4R */
#define NV_UBTM_SUBDIVIDE_IN_MAJOR_0123                         3:0 /* -W-VF */
#define NV_UBTM_SUBDIVIDE_IN_MINOR_0213                         7:4 /* -W-VF */
#define NV_UBTM_SUBDIVIDE_IN_EDGE_01                          19:16 /* -W-VF */
#define NV_UBTM_SUBDIVIDE_IN_EDGE_23                          23:20 /* -W-VF */
#define NV_UBTM_SUBDIVIDE_IN_EDGE_02                          27:24 /* -W-VF */
#define NV_UBTM_SUBDIVIDE_IN_EDGE_13                          31:28 /* -W-VF */
#define NV_UBTM_SUBDIVIDE_IN_BY_1                        0x00000000 /* -W--V */
#define NV_UBTM_SUBDIVIDE_IN_BY_2                        0x00000001 /* -W--V */
#define NV_UBTM_SUBDIVIDE_IN_BY_4                        0x00000002 /* -W--V */
#define NV_UBTM_SUBDIVIDE_IN_BY_8                        0x00000003 /* -W--V */
#define NV_UBTM_SUBDIVIDE_IN_BY_16                       0x00000004 /* -W--V */
#define NV_UBTM_SUBDIVIDE_IN_BY_32                       0x00000005 /* -W--V */
#define NV_UBTM_SUBDIVIDE_IN_BY_64                       0x00000006 /* -W--V */
#define NV_UBTM_SUBDIVIDE_IN_BY_128                      0x00000007 /* -W--V */
#define NV_UBTM_SUBDIVIDE_IN_BY_256                      0x00000008 /* -W--V */
#define NV_UBTM_POINT_OUT(i)                     (0x004D0310+(i)*4) /* -W-4A */
#define NV_UBTM_POINT_OUT__SIZE_1                                 4 /*       */
#define NV_UBTM_POINT_OUT_X                                    15:0 /* -W-SF */
#define NV_UBTM_POINT_OUT_Y                                   31:16 /* -W-SF */
#define NV_UBTM_POINT_OUT12D4(i)                 (0x004D0350+(i)*4) /* -W-4A */
#define NV_UBTM_POINT_OUT12D4__SIZE_1                             4 /*       */
#define NV_UBTM_POINT_OUT12D4_X_FRACTION                        3:0 /* -W-UF */
#define NV_UBTM_POINT_OUT12D4_X                                15:4 /* -W-SF */
#define NV_UBTM_POINT_OUT12D4_Y_FRACTION                      19:16 /* -W-UF */
#define NV_UBTM_POINT_OUT12D4_Y                               31:20 /* -W-SF */
#define NV_UBTM_COLOR(i)                         (0x004D0400+(i)*4) /* -W-4A */
#define NV_UBTM_COLOR__SIZE_1                                    32 /*       */
#define NV_UBTM_COLOR_VALUE                                    31:0 /* -W-VF */
/* usr_quadratic.ref */
#define NV_UQTM                               0x004E1FFF:0x004E0000 /* -W--D */
#define NV_UQTM_CTX_SWITCH                               0x004E0000 /* -W-4R */
#define NV_UQTM_CTX_SWITCH_INSTANCE                            15:0 /* -W-UF */
#define NV_UQTM_CTX_SWITCH_CHID                               22:16 /* -W-UF */
#define NV_UQTM_CTX_SWITCH_VOLATILE                           31:31 /* -W-VF */
#define NV_UQTM_CTX_SWITCH_VOLATILE_IGNORE               0x00000000 /* -W--V */
#define NV_UQTM_CTX_SWITCH_VOLATILE_RESET                0x00000001 /* -W--V */
#define NV_UQTM_SET_NOTIFY                               0x004E0104 /* -W-4R */
#define NV_UQTM_SET_NOTIFY_PARAMETER                           31:0 /* -W-VF */
#define NV_UQTM_SET_NOTIFY_PARAMETER_WRITE               0x00000000 /* -W--V */
#define NV_UQTM_SUBDIVIDE_IN                             0x004E0304 /* -W-4R */
#define NV_UQTM_SUBDIVIDE_IN_MAJOR_0268                         3:0 /* -W-VF */
#define NV_UQTM_SUBDIVIDE_IN_MINOR_0628                         7:4 /* -W-VF */
#define NV_UQTM_SUBDIVIDE_IN_EDGE_02                          19:16 /* -W-VF */
#define NV_UQTM_SUBDIVIDE_IN_EDGE_68                          23:20 /* -W-VF */
#define NV_UQTM_SUBDIVIDE_IN_EDGE_06                          27:24 /* -W-VF */
#define NV_UQTM_SUBDIVIDE_IN_EDGE_28                          31:28 /* -W-VF */
#define NV_UQTM_SUBDIVIDE_IN_BY_1                        0x00000000 /* -W--V */
#define NV_UQTM_SUBDIVIDE_IN_BY_2                        0x00000001 /* -W--V */
#define NV_UQTM_SUBDIVIDE_IN_BY_4                        0x00000002 /* -W--V */
#define NV_UQTM_SUBDIVIDE_IN_BY_8                        0x00000003 /* -W--V */
#define NV_UQTM_SUBDIVIDE_IN_BY_16                       0x00000004 /* -W--V */
#define NV_UQTM_SUBDIVIDE_IN_BY_32                       0x00000005 /* -W--V */
#define NV_UQTM_SUBDIVIDE_IN_BY_64                       0x00000006 /* -W--V */
#define NV_UQTM_SUBDIVIDE_IN_BY_128                      0x00000007 /* -W--V */
#define NV_UQTM_SUBDIVIDE_IN_BY_256                      0x00000008 /* -W--V */
#define NV_UQTM_POINT_OUT(i)                     (0x004E0310+(i)*4) /* -W-4A */
#define NV_UQTM_POINT_OUT__SIZE_1                                 9 /*       */
#define NV_UQTM_POINT_OUT_X                                    15:0 /* -W-SF */
#define NV_UQTM_POINT_OUT_Y                                   31:16 /* -W-SF */
#define NV_UQTM_POINT_OUT12D4(i)                 (0x004E0350+(i)*4) /* -W-4A */
#define NV_UQTM_POINT_OUT12D4__SIZE_1                             9 /*       */
#define NV_UQTM_POINT_OUT12D4_X_FRACTION                        3:0 /* -W-UF */
#define NV_UQTM_POINT_OUT12D4_X                                15:4 /* -W-SF */
#define NV_UQTM_POINT_OUT12D4_Y_FRACTION                      19:16 /* -W-UF */
#define NV_UQTM_POINT_OUT12D4_Y                               31:20 /* -W-SF */
#define NV_UQTM_COLOR(i)                         (0x004E0400+(i)*4) /* -W-4A */
#define NV_UQTM_COLOR__SIZE_1                                    32 /*       */
#define NV_UQTM_COLOR_VALUE                                    31:0 /* -W-VF */
/* usr_image_blit.ref */
#define NV_UBLIT                              0x00501FFF:0x00500000 /* -W--D */
#define NV_UBLIT_CTX_SWITCH                              0x00500000 /* -W-4R */
#define NV_UBLIT_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UBLIT_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UBLIT_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UBLIT_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UBLIT_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UBLIT_SET_NOTIFY                              0x00500104 /* -W-4R */
#define NV_UBLIT_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UBLIT_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UBLIT_POINT_IN                                0x00500300 /* -W-4R */
#define NV_UBLIT_POINT_IN_X                                    15:0 /* -W-SF */
#define NV_UBLIT_POINT_IN_Y                                   31:16 /* -W-SF */
#define NV_UBLIT_POINT_OUT                               0x00500304 /* -W-4R */
#define NV_UBLIT_POINT_OUT_X                                   15:0 /* -W-SF */
#define NV_UBLIT_POINT_OUT_Y                                  31:16 /* -W-SF */
#define NV_UBLIT_SIZE                                    0x00500308 /* -W-4R */
#define NV_UBLIT_SIZE_WIDTH                                    15:0 /* -W-UF */
#define NV_UBLIT_SIZE_HEIGHT                                  31:16 /* -W-UF */
/* usr_image_from_cpu.ref */
#define NV_UIMAGE                             0x00511FFF:0x00510000 /* -W--D */
#define NV_UIMAGE_CTX_SWITCH                             0x00510000 /* -W-4R */
#define NV_UIMAGE_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UIMAGE_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UIMAGE_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UIMAGE_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UIMAGE_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UIMAGE_SET_NOTIFY                             0x00510104 /* -W-4R */
#define NV_UIMAGE_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UIMAGE_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UIMAGE_POINT                                  0x00510304 /* -W-4R */
#define NV_UIMAGE_POINT_X                                      15:0 /* -W-SF */
#define NV_UIMAGE_POINT_Y                                     31:16 /* -W-SF */
#define NV_UIMAGE_SIZE                                   0x00510308 /* -W-4R */
#define NV_UIMAGE_SIZE_WIDTH                                   15:0 /* -W-UF */
#define NV_UIMAGE_SIZE_HEIGHT                                 31:16 /* -W-UF */
#define NV_UIMAGE_SIZE_IN                                0x0051030C /* -W-4R */
#define NV_UIMAGE_SIZE_IN_WIDTH                                15:0 /* -W-UF */
#define NV_UIMAGE_SIZE_IN_HEIGHT                              31:16 /* -W-UF */
#define NV_UIMAGE_COLOR(i)                       (0x00510400+(i)*4) /* -W-4A */
#define NV_UIMAGE_COLOR__SIZE_1                                  32 /*       */
#define NV_UIMAGE_COLOR_VALUE                                  31:0 /* -W-VF */
/* usr_bitmap_from_cpu.ref */
#define NV_UBITMAP                            0x00521FFF:0x00520000 /* -W--D */
#define NV_UBITMAP_CTX_SWITCH                            0x00520000 /* -W-4R */
#define NV_UBITMAP_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_UBITMAP_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_UBITMAP_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_UBITMAP_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_UBITMAP_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_UBITMAP_SET_NOTIFY                            0x00520104 /* -W-4R */
#define NV_UBITMAP_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UBITMAP_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UBITMAP_COLOR0                                0x00520308 /* -W-4R */
#define NV_UBITMAP_COLOR0_VALUE                                31:0 /* -W-VF */
#define NV_UBITMAP_COLOR1                                0x0052030C /* -W-4R */
#define NV_UBITMAP_COLOR1_VALUE                                31:0 /* -W-VF */
#define NV_UBITMAP_POINT                                 0x00520310 /* -W-4R */
#define NV_UBITMAP_POINT_X                                     15:0 /* -W-SF */
#define NV_UBITMAP_POINT_Y                                    31:16 /* -W-SF */
#define NV_UBITMAP_SIZE                                  0x00520314 /* -W-4R */
#define NV_UBITMAP_SIZE_WIDTH                                  15:0 /* -W-UF */
#define NV_UBITMAP_SIZE_HEIGHT                                31:16 /* -W-UF */
#define NV_UBITMAP_SIZE_IN                               0x00520318 /* -W-4R */
#define NV_UBITMAP_SIZE_IN_WIDTH                               15:0 /* -W-UF */
#define NV_UBITMAP_SIZE_IN_HEIGHT                             31:16 /* -W-UF */
#define NV_UBITMAP_MONOCHROME(i)                 (0x00520400+(i)*4) /* -W-4A */
#define NV_UBITMAP_MONOCHROME__SIZE_1                            32 /*       */
#define NV_UBITMAP_MONOCHROME_BITMAP                           31:0 /* -W-VF */
/* usr_image_from_mem.ref */
#define NV_UFROMEM                            0x00531FFF:0x00530000 /* -W--D */
#define NV_UFROMEM_CTX_SWITCH                            0x00530000 /* -W-4R */
#define NV_UFROMEM_CTX_SWITCH_INSTANCE                         15:0 /* -W-UF */
#define NV_UFROMEM_CTX_SWITCH_CHID                            22:16 /* -W-UF */
#define NV_UFROMEM_CTX_SWITCH_VOLATILE                        31:31 /* -W-VF */
#define NV_UFROMEM_CTX_SWITCH_VOLATILE_IGNORE            0x00000000 /* -W--V */
#define NV_UFROMEM_CTX_SWITCH_VOLATILE_RESET             0x00000001 /* -W--V */
#define NV_UFROMEM_DMA_REPLY(i)                  (0x00530040+(i)*4) /* -W-4A */
#define NV_UFROMEM_DMA_REPLY__SIZE_1                             16 /*       */
#define NV_UFROMEM_DMA_REPLY_DATA                              31:0 /* -W-VF */
#define NV_UFROMEM_SET_NOTIFY                            0x00530104 /* -W-4R */
#define NV_UFROMEM_SET_NOTIFY_PARAMETER                        31:0 /* -W-VF */
#define NV_UFROMEM_SET_NOTIFY_PARAMETER_WRITE            0x00000000 /* -W--V */
#define NV_UFROMEM_POINT                                 0x00530308 /* -W-4R */
#define NV_UFROMEM_POINT_X                                     15:0 /* -W-SF */
#define NV_UFROMEM_POINT_Y                                    31:16 /* -W-SF */
#define NV_UFROMEM_SIZE                                  0x0053030C /* -W-4R */
#define NV_UFROMEM_SIZE_WIDTH                                  15:0 /* -W-UF */
#define NV_UFROMEM_SIZE_HEIGHT                                31:16 /* -W-UF */
#define NV_UFROMEM_PITCH                                 0x00530310 /* -W-4R */
#define NV_UFROMEM_PITCH_VALUE                                 31:0 /* -W-SF */
#define NV_UFROMEM_IMAGE_START                           0x00530314 /* -W-4R */
#define NV_UFROMEM_PITCH_START_OFFSET                          31:0 /* -W-UF */
/* usr_image_to_mem.ref */
#define NV_UTOMEM                             0x00541FFF:0x00540000 /* -W--D */
#define NV_UTOMEM_CTX_SWITCH                             0x00540000 /* -W-4R */
#define NV_UTOMEM_CTX_SWITCH_INSTANCE                          15:0 /* -W-UF */
#define NV_UTOMEM_CTX_SWITCH_CHID                             22:16 /* -W-UF */
#define NV_UTOMEM_CTX_SWITCH_VOLATILE                         31:31 /* -W-VF */
#define NV_UTOMEM_CTX_SWITCH_VOLATILE_IGNORE             0x00000000 /* -W--V */
#define NV_UTOMEM_CTX_SWITCH_VOLATILE_RESET              0x00000001 /* -W--V */
#define NV_UTOMEM_SET_NOTIFY                             0x00540104 /* -W-4R */
#define NV_UTOMEM_SET_NOTIFY_PARAMETER                         31:0 /* -W-VF */
#define NV_UTOMEM_SET_NOTIFY_PARAMETER_WRITE             0x00000000 /* -W--V */
#define NV_UTOMEM_POINT                                  0x00540308 /* -W-4R */
#define NV_UTOMEM_POINT_X                                      15:0 /* -W-SF */
#define NV_UTOMEM_POINT_Y                                     31:16 /* -W-SF */
#define NV_UTOMEM_SIZE                                   0x0054030C /* -W-4R */
#define NV_UTOMEM_SIZE_WIDTH                                   15:0 /* -W-UF */
#define NV_UTOMEM_SIZE_HEIGHT                                 31:16 /* -W-UF */
#define NV_UTOMEM_IMAGE_PITCH                            0x00540310 /* -W-4R */
#define NV_UTOMEM_IMAGE_PITCH_VALUE                            31:0 /* -W-SF */
#define NV_UTOMEM_IMAGE_START                            0x00540314 /* -W-4R */
#define NV_UTOMEM_IMAGE_START_OFFSET                           31:0 /* -W-UF */
/* usr_bilinear_beta.ref */
#define NV_UBTMB                              0x005D1FFF:0x005D0000 /* -W--D */
#define NV_UBTMB_CTX_SWITCH                              0x005D0000 /* -W-4R */
#define NV_UBTMB_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UBTMB_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UBTMB_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UBTMB_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UBTMB_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UBTMB_SET_NOTIFY                              0x005D0104 /* -W-4R */
#define NV_UBTMB_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UBTMB_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UBTMB_SUBDIVIDE_IN                            0x005D0304 /* -W-4R */
#define NV_UBTMB_SUBDIVIDE_IN_MAJOR_0123                        3:0 /* -W-VF */
#define NV_UBTMB_SUBDIVIDE_IN_MINOR_0213                        7:4 /* -W-VF */
#define NV_UBTMB_SUBDIVIDE_IN_EDGE_01                         19:16 /* -W-VF */
#define NV_UBTMB_SUBDIVIDE_IN_EDGE_23                         23:20 /* -W-VF */
#define NV_UBTMB_SUBDIVIDE_IN_EDGE_02                         27:24 /* -W-VF */
#define NV_UBTMB_SUBDIVIDE_IN_EDGE_13                         31:28 /* -W-VF */
#define NV_UBTMB_SUBDIVIDE_IN_BY_1                       0x00000000 /* -W--V */
#define NV_UBTMB_SUBDIVIDE_IN_BY_2                       0x00000001 /* -W--V */
#define NV_UBTMB_SUBDIVIDE_IN_BY_4                       0x00000002 /* -W--V */
#define NV_UBTMB_SUBDIVIDE_IN_BY_8                       0x00000003 /* -W--V */
#define NV_UBTMB_SUBDIVIDE_IN_BY_16                      0x00000004 /* -W--V */
#define NV_UBTMB_SUBDIVIDE_IN_BY_32                      0x00000005 /* -W--V */
#define NV_UBTMB_SUBDIVIDE_IN_BY_64                      0x00000006 /* -W--V */
#define NV_UBTMB_SUBDIVIDE_IN_BY_128                     0x00000007 /* -W--V */
#define NV_UBTMB_SUBDIVIDE_IN_BY_256                     0x00000008 /* -W--V */
#define NV_UBTMB_POINT_OUT(i)                    (0x005D0310+(i)*4) /* -W-4A */
#define NV_UBTMB_POINT_OUT__SIZE_1                                4 /*       */
#define NV_UBTMB_POINT_OUT_X                                   15:0 /* -W-SF */
#define NV_UBTMB_POINT_OUT_Y                                  31:16 /* -W-SF */
#define NV_UBTMB_POINT_OUT12D4(i)                (0x005D0350+(i)*4) /* -W-4A */
#define NV_UBTMB_POINT_OUT12D4__SIZE_1                            4 /*       */
#define NV_UBTMB_POINT_OUT12D4_X_FRACTION                       3:0 /* -W-UF */
#define NV_UBTMB_POINT_OUT12D4_X                               15:4 /* -W-SF */
#define NV_UBTMB_POINT_OUT12D4_Y_FRACTION                     19:16 /* -W-UF */
#define NV_UBTMB_POINT_OUT12D4_Y                              31:20 /* -W-SF */
#define NV_UBTMB_BETA(i)                         (0x005D0380+(i)*4) /* -W-4A */
#define NV_UBTMB_BETA__SIZE_1                                     2 /*       */
#define NV_UBTMB_BETA_VALUE_0_FRACTION                         14:0 /* -W-UF */
#define NV_UBTMB_BETA_VALUE_0                                 15:15 /* -W-SF */
#define NV_UBTMB_BETA_VALUE_1_FRACTION                        30:16 /* -W-UF */
#define NV_UBTMB_BETA_VALUE_1                                 31:31 /* -W-SF */
#define NV_UBTMB_COLOR(i)                        (0x005D0400+(i)*4) /* -W-4A */
#define NV_UBTMB_COLOR__SIZE_1                                   32 /*       */
#define NV_UBTMB_COLOR_VALUE                                   31:0 /* -W-VF */
/* usr_quadratic_beta.ref */
#define NV_UQTMB                              0x005E1FFF:0x005E0000 /* -W--D */
#define NV_UQTMB_CTX_SWITCH                              0x005E0000 /* -W-4R */
#define NV_UQTMB_CTX_SWITCH_INSTANCE                           15:0 /* -W-UF */
#define NV_UQTMB_CTX_SWITCH_CHID                              22:16 /* -W-UF */
#define NV_UQTMB_CTX_SWITCH_VOLATILE                          31:31 /* -W-VF */
#define NV_UQTMB_CTX_SWITCH_VOLATILE_IGNORE              0x00000000 /* -W--V */
#define NV_UQTMB_CTX_SWITCH_VOLATILE_RESET               0x00000001 /* -W--V */
#define NV_UQTMB_SET_NOTIFY                              0x005E0104 /* -W-4R */
#define NV_UQTMB_SET_NOTIFY_PARAMETER                          31:0 /* -W-VF */
#define NV_UQTMB_SET_NOTIFY_PARAMETER_WRITE              0x00000000 /* -W--V */
#define NV_UQTMB_SUBDIVIDE_IN                            0x005E0304 /* -W-4R */
#define NV_UQTMB_SUBDIVIDE_IN_MAJOR_0268                        3:0 /* -W-VF */
#define NV_UQTMB_SUBDIVIDE_IN_MINOR_0628                        7:4 /* -W-VF */
#define NV_UQTMB_SUBDIVIDE_IN_EDGE_02                         19:16 /* -W-VF */
#define NV_UQTMB_SUBDIVIDE_IN_EDGE_68                         23:20 /* -W-VF */
#define NV_UQTMB_SUBDIVIDE_IN_EDGE_06                         27:24 /* -W-VF */
#define NV_UQTMB_SUBDIVIDE_IN_EDGE_28                         31:28 /* -W-VF */
#define NV_UQTMB_SUBDIVIDE_IN_BY_1                       0x00000000 /* -W--V */
#define NV_UQTMB_SUBDIVIDE_IN_BY_2                       0x00000001 /* -W--V */
#define NV_UQTMB_SUBDIVIDE_IN_BY_4                       0x00000002 /* -W--V */
#define NV_UQTMB_SUBDIVIDE_IN_BY_8                       0x00000003 /* -W--V */
#define NV_UQTMB_SUBDIVIDE_IN_BY_16                      0x00000004 /* -W--V */
#define NV_UQTMB_SUBDIVIDE_IN_BY_32                      0x00000005 /* -W--V */
#define NV_UQTMB_SUBDIVIDE_IN_BY_64                      0x00000006 /* -W--V */
#define NV_UQTMB_SUBDIVIDE_IN_BY_128                     0x00000007 /* -W--V */
#define NV_UQTMB_SUBDIVIDE_IN_BY_256                     0x00000008 /* -W--V */
#define NV_UQTMB_POINT_OUT(i)                    (0x005E0310+(i)*4) /* -W-4A */
#define NV_UQTMB_POINT_OUT__SIZE_1                                9 /*       */
#define NV_UQTMB_POINT_OUT_X                                   15:0 /* -W-SF */
#define NV_UQTMB_POINT_OUT_Y                                  31:16 /* -W-SF */
#define NV_UQTMB_POINT_OUT12D4(i)                (0x005E0350+(i)*4) /* -W-4A */
#define NV_UQTMB_POINT_OUT12D4__SIZE_1                            9 /*       */
#define NV_UQTMB_POINT_OUT12D4_X_FRACTION                       3:0 /* -W-UF */
#define NV_UQTMB_POINT_OUT12D4_X                               15:4 /* -W-SF */
#define NV_UQTMB_POINT_OUT12D4_Y_FRACTION                     19:16 /* -W-UF */
#define NV_UQTMB_POINT_OUT12D4_Y                              31:20 /* -W-SF */
#define NV_UQTMB_BETA(i)                         (0x005E0380+(i)*4) /* -W-4A */
#define NV_UQTMB_BETA__SIZE_1                                     5 /*       */
#define NV_UQTMB_BETA_VALUE_0_FRACTION                         14:0 /* -W-UF */
#define NV_UQTMB_BETA_VALUE_0                                 15:15 /* -W-SF */
#define NV_UQTMB_BETA_VALUE_1_FRACTION                        30:16 /* -W-UF */
#define NV_UQTMB_BETA_VALUE_1                                 31:31 /* -W-SF */
#define NV_UQTMB_COLOR(i)                        (0x005E0400+(i)*4) /* -W-4A */
#define NV_UQTMB_COLOR__SIZE_1                                   32 /*       */
#define NV_UQTMB_COLOR_VALUE                                   31:0 /* -W-VF */
/* dev_framebuffer.ref */
#define NV_PFB                                0x00600FFF:0x00600000 /* RW--D */
#define NV_PFB_BOOT_0                                    0x00600000 /* RW-4R */
#define NV_PFB_BOOT_0_RAM_AMOUNT                                1:0 /* RWIVF */
#define NV_PFB_BOOT_0_RAM_AMOUNT_1MB                     0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_2MB                     0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_4MB                     0x00000002 /* RWI-V */
#define NV_PFB_BOOT_0_DAC_WIDTH                                 9:8 /* RWXVF */
#define NV_PFB_BOOT_0_DAC_WIDTH_16_BIT                   0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_DAC_WIDTH_32_BIT                   0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_DAC_WIDTH_64_BIT                   0x00000002 /* RW--V */
#define NV_PFB_BOOT_0_RAS_PRECHARGE                           12:12 /* RWIVF */
#define NV_PFB_BOOT_0_RAS_PRECHARGE_3_CYCLES             0x00000000 /* RWI-V */
#define NV_PFB_BOOT_0_RAS_PRECHARGE_2_CYCLES             0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_BLOCK_MODE                          17:16 /* RWIVF */
#define NV_PFB_BOOT_0_RAM_BLOCK_MODE_DISABLED            0x00000000 /* RWI-V */
#define NV_PFB_BOOT_0_RAM_BLOCK_MODE_BY_8                0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_BLOCK_MODE_BY_4                0x00000003 /* RW--V */
#define NV_PFB_BOOT_0_RAM_WRITE_PER_BIT                       20:20 /* RWIVF */
#define NV_PFB_BOOT_0_RAM_WRITE_PER_BIT_DISABLED         0x00000000 /* RWI-V */
#define NV_PFB_BOOT_0_RAM_WRITE_PER_BIT_ENABLED          0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_VRAM_SAM                                24:24 /* RWIVF */
#define NV_PFB_BOOT_0_VRAM_SAM_8192_BIT                  0x00000000 /* RWI-V */
#define NV_PFB_BOOT_0_VRAM_SAM_4096_BIT                  0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_HYPER_PAGE                          28:28 /* RWIVF */
#define NV_PFB_BOOT_0_RAM_HYPER_PAGE_DISABLED            0x00000000 /* RWI-V */
#define NV_PFB_BOOT_0_RAM_HYPER_PAGE_ENABLED             0x00000001 /* RW--V */
#define NV_PFB_DELAY_0                                   0x00600040 /* RW-4R */
#define NV_PFB_DELAY_0_SYNC                                     4:0 /* RWIUF */
#define NV_PFB_DELAY_0_SYNC_0                            0x00000000 /* RWI-V */
#define NV_PFB_DELAY_0_DSF                                      9:8 /* RWIUF */
#define NV_PFB_DELAY_0_DSF_0                             0x00000000 /* RWI-V */
#define NV_PFB_DELAY_0_SOE_RISE                               13:12 /* RWIUF */
#define NV_PFB_DELAY_0_SOE_RISE_0                        0x00000000 /* RWI-V */
#define NV_PFB_DELAY_0_SOE_FALL                               17:16 /* RWIUF */
#define NV_PFB_DELAY_0_SOE_FALL_0                        0x00000000 /* RWI-V */
#define NV_PFB_DELAY_0_LOAD_CLK                               25:20 /* RWIUF */
#define NV_PFB_DELAY_0_LOAD_CLK_0                        0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1                                   0x00600044 /* RW-4R */
#define NV_PFB_DELAY_1_WRITE_ENABLE_RISE                        1:0 /* RWIUF */
#define NV_PFB_DELAY_1_WRITE_ENABLE_RISE_0               0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1_WRITE_ENABLE_FALL                        5:4 /* RWIUF */
#define NV_PFB_DELAY_1_WRITE_ENABLE_FALL_0               0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1_OUTPUT_ENABLE                            9:8 /* RWIUF */
#define NV_PFB_DELAY_1_OUTPUT_ENABLE_0                   0x00000000 /* RWI-V */
#define NV_PFB_DELAY_1_OUTPUT_DATA                            17:16 /* RWIUF */
#define NV_PFB_DELAY_1_OUTPUT_DATA_0                     0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0                                   0x00600080 /* RW-4R */
#define NV_PFB_DEBUG_0_PAGE_MODE                                0:0 /* RWIVF */
#define NV_PFB_DEBUG_0_PAGE_MODE_ENABLED                 0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_PAGE_MODE_DISABLED                0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_REFRESH                                  4:4 /* RWIVF */
#define NV_PFB_DEBUG_0_REFRESH_ENABLED                   0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_REFRESH_DISABLED                  0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_SELFTIME                                 8:8 /* RWIVF */
#define NV_PFB_DEBUG_0_SELFTIME_ENABLED                  0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_SELFTIME_DISABLED                 0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_TRANSFER                               12:12 /* RWIVF */
#define NV_PFB_DEBUG_0_TRANSFER_ENABLED                  0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_TRANSFER_DISABLED                 0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_LOAD_CLK_FIX_DELAY                     16:16 /* RWIVF */
#define NV_PFB_DEBUG_0_LOAD_CLK_FIX_DELAY_DISABLED       0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_LOAD_CLK_FIX_DELAY_ENABLED        0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_CASOE                                  20:20 /* RWIVF */
#define NV_PFB_DEBUG_0_CASOE_ENABLED                     0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_CASOE_DISABLED                    0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_FIFO_DRAIN_HINT                        31:24 /* RWIUF */
#define NV_PFB_DEBUG_0_FIFO_DRAIN_HINT_0                 0x00000000 /* RWI-V */
#define NV_PFB_GREEN_0                                   0x006000C0 /* RW-4R */
#define NV_PFB_GREEN_0_LEVEL                                    1:0 /* RWIVF */
#define NV_PFB_GREEN_0_LEVEL_VIDEO_ENABLED               0x00000000 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_VIDEO_DISABLED              0x00000001 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_TIMING_DISABLED             0x00000002 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_MEMORY_DISABLED             0x00000003 /* RWI-V */
#define NV_PFB_GREEN_0_POLAR_HSYNC                            17:16 /* RWIVF */
#define NV_PFB_GREEN_0_POLAR_HSYNC_HIGH                  0x00000000 /* RWI-V */
#define NV_PFB_GREEN_0_POLAR_HSYNC_LOW                   0x00000001 /* RW--V */
#define NV_PFB_GREEN_0_POLAR_HSYNC_POSITIVE              0x00000002 /* RW--V */
#define NV_PFB_GREEN_0_POLAR_HSYNC_NEGATIVE              0x00000003 /* RW--V */
#define NV_PFB_GREEN_0_POLAR_VSYNC                            21:20 /* RWIVF */
#define NV_PFB_GREEN_0_POLAR_VSYNC_LOW                   0x00000000 /* RWI-V */
#define NV_PFB_GREEN_0_POLAR_VSYNC_HIGH                  0x00000001 /* RW--V */
#define NV_PFB_GREEN_0_POLAR_VSYNC_POSITIVE              0x00000002 /* RW--V */
#define NV_PFB_GREEN_0_POLAR_VSYNC_NEGATIVE              0x00000003 /* RW--V */
#define NV_PFB_GREEN_0_CSYNC                                  24:24 /* RWIVF */
#define NV_PFB_GREEN_0_CSYNC_DISABLED                    0x00000000 /* RWI-V */
#define NV_PFB_GREEN_0_CSYNC_ENABLED                     0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0                                  0x00600200 /* RW-4R */
#define NV_PFB_CONFIG_0_VERTICAL                                0:0 /* R-XVF */
#define NV_PFB_CONFIG_0_VERTICAL_DISPLAY                 0x00000000 /* R---V */
#define NV_PFB_CONFIG_0_VERTICAL_BLANK                   0x00000001 /* R---V */
#define NV_PFB_CONFIG_0_RESOLUTION                              6:4 /* RWIVF */
#define NV_PFB_CONFIG_0_RESOLUTION_576_PIXELS            0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_RESOLUTION_640_PIXELS            0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_800_PIXELS            0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1024_PIXELS           0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1152_PIXELS           0x00000004 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1280_PIXELS           0x00000005 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1600_PIXELS           0x00000006 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH                             9:8 /* RWIVF */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_4_BITS               0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_8_BITS               0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_16_BITS              0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_32_BITS              0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_SECOND_BUFFER                         12:12 /* RWIVF */
#define NV_PFB_CONFIG_0_SECOND_BUFFER_DISABLED           0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_SECOND_BUFFER_ENABLED            0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_PAGE_HEIGHT                           18:16 /* RWIVF */
#define NV_PFB_CONFIG_0_PAGE_HEIGHT_DISABLED             0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_PAGE_HEIGHT_4_LINES              0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_PAGE_HEIGHT_8_LINES              0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_PAGE_HEIGHT_16_LINES             0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_PAGE_HEIGHT_32_LINES             0x00000004 /* RW--V */
#define NV_PFB_CONFIG_0_SCANLINE                              20:20 /* RWIVF */
#define NV_PFB_CONFIG_0_SCANLINE_NO_DUPLICATE            0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_SCANLINE_DUPLICATE               0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_PCLK_VCLK_RATIO                       26:24 /* RWIVF */
#define NV_PFB_CONFIG_0_PCLK_VCLK_RATIO_1_TO_1           0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_PCLK_VCLK_RATIO_2_TO_1           0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_PCLK_VCLK_RATIO_4_TO_1           0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_PCLK_VCLK_RATIO_8_TO_1           0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_PCLK_VCLK_RATIO_16_TO_1          0x00000004 /* RW--V */
#define NV_PFB_CONFIG_0_STEREOSCOPIC                          28:28 /* RWIVF */
#define NV_PFB_CONFIG_0_STEREOSCOPIC_DISABLED            0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_STEREOSCOPIC_ENABLED             0x00000001 /* RW--V */
#define NV_PFB_CONFIG_1                                  0x00600204 /* RW-4R */
#define NV_PFB_CONFIG_1_FIFO_LOW_MARK                           0:0 /* RWIVF */
#define NV_PFB_CONFIG_1_FIFO_LOW_MARK_512_BITS           0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_FIFO_LOW_MARK_2048_BITS          0x00000001 /* RW--V */
#define NV_PFB_START                                     0x00600400 /* RW-4R */
#define NV_PFB_START_ADDRESS                                   21:1 /* RWIUF */
#define NV_PFB_START_ADDRESS_0                           0x00000000 /* RWI-V */
#define NV_PFB_HOR_FRNT_PORCH                            0x00600500 /* RW-4R */
#define NV_PFB_HOR_FRNT_PORCH_PIXELS                           10:0 /* RWIUF */
#define NV_PFB_HOR_FRNT_PORCH_PIXELS_1                   0x00000001 /* RWI-V */
#define NV_PFB_HOR_SYNC_WIDTH                            0x00600510 /* RW-4R */
#define NV_PFB_HOR_SYNC_WIDTH_PIXELS                           10:0 /* RWIUF */
#define NV_PFB_HOR_SYNC_WIDTH_PIXELS_1                   0x00000001 /* RWI-V */
#define NV_PFB_HOR_BACK_PORCH                            0x00600520 /* RW-4R */
#define NV_PFB_HOR_BACK_PORCH_PIXELS                           10:0 /* RWIUF */
#define NV_PFB_HOR_BACK_PORCH_PIXELS_1                   0x00000001 /* RWI-V */
#define NV_PFB_HOR_DISP_WIDTH                            0x00600530 /* RW-4R */
#define NV_PFB_HOR_DISP_WIDTH_PIXELS                           10:0 /* RWIUF */
#define NV_PFB_HOR_DISP_WIDTH_PIXELS_1                   0x00000001 /* RWI-V */
#define NV_PFB_VER_FRNT_PORCH                            0x00600540 /* RW-4R */
#define NV_PFB_VER_FRNT_PORCH_LINES                            10:0 /* RWIUF */
#define NV_PFB_VER_FRNT_PORCH_LINES_1                    0x00000001 /* RWI-V */
#define NV_PFB_VER_SYNC_WIDTH                            0x00600550 /* RW-4R */
#define NV_PFB_VER_SYNC_WIDTH_LINES                            10:0 /* RWIUF */
#define NV_PFB_VER_SYNC_WIDTH_LINES_1                    0x00000001 /* RWI-V */
#define NV_PFB_VER_BACK_PORCH                            0x00600560 /* RW-4R */
#define NV_PFB_VER_BACK_PORCH_LINES                            10:0 /* RWIUF */
#define NV_PFB_VER_BACK_PORCH_LINES_1                    0x00000001 /* RWI-V */
#define NV_PFB_VER_DISP_WIDTH                            0x00600570 /* RW-4R */
#define NV_PFB_VER_DISP_WIDTH_LINES                            10:0 /* RWIUF */
#define NV_PFB_VER_DISP_WIDTH_LINES_1                    0x00000001 /* RWI-V */
/* dev_ram.ref */
#define NV_PRAM                               0x00602FFF:0x00602000 /* RW--D */
#define NV_PRAM_CONFIG_0                                 0x00602200 /* RW-4R */
#define NV_PRAM_CONFIG_0_SIZE                                   1:0 /* RWIVF */
#define NV_PRAM_CONFIG_0_SIZE_12KB                       0x00000000 /* RWI-V */
#define NV_PRAM_CONFIG_0_SIZE_20KB                       0x00000001 /* RW--V */
#define NV_PRAM_CONFIG_0_SIZE_36KB                       0x00000002 /* RW--V */
#define NV_PRAM_CONFIG_0_SIZE_68KB                       0x00000003 /* RW--V */
#define NV_PRAM_HASH_VIRTUAL(i)                  (0x00602400+(i)*4) /* -W-4A */
#define NV_PRAM_HASH_VIRTUAL__SIZE_1                            128 /*       */
#define NV_PRAM_HASH_VIRTUAL_HANDLE                            31:0 /* -W-VF */
#define NV_PRAM_HASH_PHYSICAL                            0x00602600 /* R--4R */
#define NV_PRAM_HASH_PHYSICAL_INSTANCE                         15:0 /* R-IUF */
#define NV_PRAM_HASH_PHYSICAL_INSTANCE_0                 0x00000000 /* R-I-V */
#define NV_PRAM_HASH_PHYSICAL_DEVICE                          22:16 /* R-IUF */
#define NV_PRAM_HASH_PHYSICAL_DEVICE_NOT_FOUND           0x00000000 /* R-I-V */
#define NV_PRAM_HASH_PHYSICAL_FREE_LIE                        24:24 /* R-IVF */
#define NV_PRAM_HASH_PHYSICAL_FREE_LIE_DISABLED          0x00000000 /* R-I-V */
#define NV_PRAM_HASH_PHYSICAL_FREE_LIE_ENABLED           0x00000001 /* R---V */
/* dev_ram.ref */
#define NV_PRAMFC                             0x0064BFFF:0x00648000 /* RW--D */
/* dev_ram.ref */
#define NV_PRAMAU                             0x00604FFF:0x00604000 /* RW--D */
/* dev_spooks.ref */
#define NV_PAUTH                              0x00605FFF:0x00605000 /* RW--D */
#define NV_PAUTH_DEBUG_0                                 0x00605080 /* R--4R */
#define NV_PAUTH_DEBUG_0_BREACH                                 0:0 /* R-IVF */
#define NV_PAUTH_DEBUG_0_BREACH_NOT_DETECTED             0x00000000 /* R-I-V */
#define NV_PAUTH_DEBUG_0_BREACH_DETECTED                 0x00000001 /* R---V */
#define NV_PAUTH_DEBUG_0_EEPROM                                 4:4 /* R-IVF */
#define NV_PAUTH_DEBUG_0_EEPROM_VALID                    0x00000000 /* R-I-V */
#define NV_PAUTH_DEBUG_0_EEPROM_INVALID                  0x00000001 /* R---V */
#define NV_PAUTH_CHIP_TOKEN_0                            0x00605400 /* R--4R */
#define NV_PAUTH_CHIP_TOKEN_0_ENCRYPT_01_08                     7:0 /* R--VF */
#define NV_PAUTH_CHIP_TOKEN_0_ENCRYPT_09_16                    15:8 /* R--VF */
#define NV_PAUTH_CHIP_TOKEN_0_ENCRYPT_17_24                   23:16 /* R--VF */
#define NV_PAUTH_CHIP_TOKEN_0_ENCRYPT_25_32                   31:24 /* R--VF */
#define NV_PAUTH_CHIP_TOKEN_1                            0x00605404 /* R--4R */
#define NV_PAUTH_CHIP_TOKEN_1_ENCRYPT_33_40                     7:0 /* R--VF */
#define NV_PAUTH_CHIP_TOKEN_1_ENCRYPT_41_48                    15:8 /* R--VF */
#define NV_PAUTH_CHIP_TOKEN_1_ENCRYPT_49_56                   23:16 /* R--VF */
#define NV_PAUTH_CHIP_TOKEN_1_ENCRYPT_57_64                   31:24 /* R--VF */
#define NV_PAUTH_PASSWD_0(i)                  (0x00605800+(i)*0x10) /* RW-4A */
#define NV_PAUTH_PASSWD_0__SIZE_1                               128 /*       */
#define NV_PAUTH_PASSWD_0_ENCRYPT_01_08                         7:0 /* CW-VF */
#define NV_PAUTH_PASSWD_0_ENCRYPT_01_08_0                0x00000000 /* CW--V */
#define NV_PAUTH_PASSWD_0_ENCRYPT_09_16                        15:8 /* CW-VF */
#define NV_PAUTH_PASSWD_0_ENCRYPT_09_16_0                0x00000000 /* CW--V */
#define NV_PAUTH_PASSWD_0_ENCRYPT_17_24                       23:16 /* CW-VF */
#define NV_PAUTH_PASSWD_0_ENCRYPT_17_24_0                0x00000000 /* CW--V */
#define NV_PAUTH_PASSWD_0_ENCRYPT_25_32                       31:24 /* CW-VF */
#define NV_PAUTH_PASSWD_0_ENCRYPT_25_32_0                0x00000000 /* CW--V */
#define NV_PAUTH_PASSWD_1(i)                  (0x00605804+(i)*0x10) /* RW-4A */
#define NV_PAUTH_PASSWD_1__SIZE_1                               128 /*       */
#define NV_PAUTH_PASSWD_1_ENCRYPT_33_40                         7:0 /* CW-VF */
#define NV_PAUTH_PASSWD_1_ENCRYPT_33_40_0                0x00000000 /* CW--V */
#define NV_PAUTH_PASSWD_1_ENCRYPT_41_48                        15:8 /* CW-VF */
#define NV_PAUTH_PASSWD_1_ENCRYPT_41_48_0                0x00000000 /* CW--V */
#define NV_PAUTH_PASSWD_1_ENCRYPT_49_56                       23:16 /* CW-VF */
#define NV_PAUTH_PASSWD_1_ENCRYPT_49_56_0                0x00000000 /* CW--V */
#define NV_PAUTH_PASSWD_1_ENCRYPT_57_64                       31:24 /* CW-VF */
#define NV_PAUTH_PASSWD_1_ENCRYPT_57_64_0                0x00000000 /* CW--V */
#define NV_PAUTH_PASSWD_2(i)                  (0x00605808+(i)*0x10) /* RW-4A */
#define NV_PAUTH_PASSWD_2__SIZE_1                               128 /*       */
#define NV_PAUTH_PASSWD_2_RESERVED                             31:0 /* CW-VF */
#define NV_PAUTH_PASSWD_2_RESERVED_0                     0x00000000 /* CW--V */
#define NV_PAUTH_PASSWD_3(i)                  (0x0060580C+(i)*0x10) /* RW-4A */
#define NV_PAUTH_PASSWD_3__SIZE_1                               128 /*       */
#define NV_PAUTH_PASSWD_3_RESERVED                             15:0 /* CW-VF */
#define NV_PAUTH_PASSWD_3_RESERVED_0                     0x00000000 /* CW--V */
#define NV_PAUTH_PASSWD_3_APP_SN_0                            23:16 /* CW-VF */
#define NV_PAUTH_PASSWD_3_APP_SN_0_0                     0x00000000 /* CW--V */
#define NV_PAUTH_PASSWD_3_APP_SN_1                            31:24 /* CW-VF */
#define NV_PAUTH_PASSWD_3_APP_SN_1_0                     0x00000000 /* CW--V */
#define NV_PAUTH_UNUSED_0(i)                     (0x00605000+(i)*4) /* R--4A */
#define NV_PAUTH_UNUSED_0__SIZE_1                                32 /*       */
#define NV_PAUTH_UNUSED_0_VALUE                                31:0 /* C--VF */
#define NV_PAUTH_UNUSED_0_VALUE_0                        0x00000000 /* C---V */
#define NV_PAUTH_UNUSED_1(i)                     (0x00605084+(i)*4) /* R--4A */
#define NV_PAUTH_UNUSED_1__SIZE_1                               223 /*       */
#define NV_PAUTH_UNUSED_1_VALUE                                31:0 /* C--VF */
#define NV_PAUTH_UNUSED_1_VALUE_0                        0x00000000 /* C---V */
#define NV_PAUTH_UNUSED_2(i)                     (0x00605408+(i)*4) /* R--4A */
#define NV_PAUTH_UNUSED_2__SIZE_1                               254 /*       */
#define NV_PAUTH_UNUSED_2_VALUE                                31:0 /* C--VF */
#define NV_PAUTH_UNUSED_2_VALUE_0                        0x00000000 /* C---V */
/* dev_ram.ref */
#define NV_PRAMPW                             0x00606FFF:0x00606000 /* RW--D */
/* dev_ext_devices.ref */
#define NV_PEXTDEV                            0x00608FFF:0x00608000 /* RW--D */
#define NV_PEXTDEV_BOOT_0                                0x00608000 /* R--4R */
#define NV_PEXTDEV_BOOT_0_STRAP_VENDOR                          0:0 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_VENDOR_NVIDIA            0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_VENDOR_SGS               0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE                        1:1 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_VRAM            0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_DRAM            0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BOARD                           3:2 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_BOARD_MOTHER             0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BOARD_ADAPTER_1          0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BOARD_ADAPTER_2          0x00000002 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BOARD_ADAPTER_3          0x00000003 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE                        4:4 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_PCI             0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_VL              0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RESERVED                        7:5 /* R-XVF */
/* dev_ext_devices.ref */
#define NV_PDAC                               0x00609FFF:0x00609000 /* RW--D */
#define NV_PDAC_DATA(i)                          (0x00609000+(i)*4) /* RW-4A */
#define NV_PDAC_DATA__SIZE_1                                     16 /*       */
#define NV_PDAC_DATA_VALUE                                      7:0 /* RW-VF */
/* dev_ext_devices.ref */
#define NV_PEEPROM                            0x0060AFFF:0x0060A000 /* RW--D */
#define NV_PEEPROM_CONTROL                               0x0060A400 /* RW-4R */
#define NV_PEEPROM_CONTROL_DATA                                 7:0 /* RWXVF */
#define NV_PEEPROM_CONTROL_ADDRESS                             14:8 /* RWXUF */
#define NV_PEEPROM_CONTROL_COMMAND                            25:24 /* RWIVF */
#define NV_PEEPROM_CONTROL_COMMAND_NOP_0                 0x00000000 /* RWI-V */
#define NV_PEEPROM_CONTROL_COMMAND_WRITE                 0x00000001 /* RW--V */
#define NV_PEEPROM_CONTROL_COMMAND_READ                  0x00000002 /* RW--V */
#define NV_PEEPROM_CONTROL_COMMAND_NOP_3                 0x00000003 /* RW--V */
#define NV_PEEPROM_CONTROL_STATUS                             28:28 /* R-IVF */
#define NV_PEEPROM_CONTROL_STATUS_IDLE                   0x00000000 /* R---V */
#define NV_PEEPROM_CONTROL_STATUS_BUSY                   0x00000001 /* R-I-V */
/* dev_ext_devices.ref */
#define NV_PROM                               0x00617FFF:0x00610000 /* RW--D */
#define NV_PROM_DATA(i)                            (0x00610000+(i)) /* RW-1A */
#define NV_PROM_DATA__SIZE_1                                  32768 /*       */
#define NV_PROM_DATA_VALUE                                      7:0 /* RW-VF */
/* dev_ext_devices.ref */
#define NV_PALT                               0x0061FFFF:0x00618000 /* RW--D */
#define NV_PALT_DATA(i)                            (0x00618000+(i)) /* RW-1A */
#define NV_PALT_DATA__SIZE_1                                  32768 /*       */
#define NV_PALT_DATA_VALUE                                      7:0 /* RW-VF */
/* dev_ram.ref */
#define NV_PRAMHT                             0x00647FFF:0x00640000 /* RW--D */
/* dev_ram.ref */
#define NV_PRAMRO                             0x00653FFF:0x00650000 /* RW--D */
/* dev_realmode.ref */
#define NV_PRM                                0x006C7FFF:0x006C0000 /* RW--D */
#define NV_PRM_DEBUG_0                                   0x006C0080 /* RW-4R */
#define NV_PRM_DEBUG_0_FLIPFLOP                                 0:0 /* RWIVF */
#define NV_PRM_DEBUG_0_FLIPFLOP_ADDRESS                  0x00000000 /* RWI-V */
#define NV_PRM_DEBUG_0_FLIPFLOP_DATA                     0x00000001 /* RW--V */
#define NV_PRM_DEBUG_0_TEXT_WRITE                               4:4 /* RWIVF */
#define NV_PRM_DEBUG_0_TEXT_WRITE_NOT_PENDING            0x00000000 /* RWI-V */
#define NV_PRM_DEBUG_0_TEXT_WRITE_PENDING                0x00000001 /* RW--V */
#define NV_PRM_DEBUG_0_TEXT_WRITE_SYNC                          8:8 /* R-IVF */
#define NV_PRM_DEBUG_0_TEXT_WRITE_SYNC_NOT_PENDING       0x00000000 /* R-I-V */
#define NV_PRM_DEBUG_0_TEXT_WRITE_SYNC_PENDING           0x00000001 /* R---V */
#define NV_PRM_DEBUG_0_TEXT_CHARACTER                         12:12 /* RWIVF */
#define NV_PRM_DEBUG_0_TEXT_CHARACTER_FOREGROUND         0x00000000 /* RWI-V */
#define NV_PRM_DEBUG_0_TEXT_CHARACTER_BACKGROUND         0x00000001 /* RW--V */
#define NV_PRM_DEBUG_0_TEXT_CURSOR                            16:16 /* RWIVF */
#define NV_PRM_DEBUG_0_TEXT_CURSOR_FOREGROUND            0x00000000 /* RWI-V */
#define NV_PRM_DEBUG_0_TEXT_CURSOR_OFF                   0x00000001 /* RW--V */
#define NV_PRM_DEBUG_0_TEXT                                   20:20 /* RWIVF */
#define NV_PRM_DEBUG_0_TEXT_DISABLED                     0x00000000 /* RWI-V */
#define NV_PRM_DEBUG_0_TEXT_ENABLED                      0x00000001 /* RW--V */
#define NV_PRM_DEBUG_0_TEXT_STATE                             24:24 /* R-IVF */
#define NV_PRM_DEBUG_0_TEXT_STATE_IDLE                   0x00000000 /* R-I-V */
#define NV_PRM_DEBUG_0_TEXT_STATE_RENDERING              0x00000001 /* R---V */
#define NV_PRM_DEBUG_0_TRACE_FLIPFLOP                         28:28 /* RWIVF */
#define NV_PRM_DEBUG_0_TRACE_FLIPFLOP_DISABLED           0x00000000 /* RWI-V */
#define NV_PRM_DEBUG_0_TRACE_FLIPFLOP_ENABLED            0x00000001 /* RW--V */
#define NV_PRM_INTR_0                                    0x006C0100 /* RW-4R */
#define NV_PRM_INTR_0_TRACE_INDEX                             12:12 /* RWIVF */
#define NV_PRM_INTR_0_TRACE_INDEX_NOT_PENDING            0x00000000 /* R-I-V */
#define NV_PRM_INTR_0_TRACE_INDEX_PENDING                0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_INDEX_RESET                  0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW                          16:16 /* RWIVF */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_NOT_PENDING         0x00000000 /* R-I-V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_PENDING             0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_RESET               0x00000001 /* -W--V */
#define NV_PRM_INTR_0_VBLANK                                  20:20 /* RWIVF */
#define NV_PRM_INTR_0_VBLANK_NOT_PENDING                 0x00000000 /* R-I-V */
#define NV_PRM_INTR_0_VBLANK_PENDING                     0x00000001 /* R---V */
#define NV_PRM_INTR_0_VBLANK_RESET                       0x00000001 /* -W--V */
#define NV_PRM_INTR_EN_0                                 0x006C0140 /* RW-4R */
#define NV_PRM_INTR_EN_0_TRACE_INDEX                          12:12 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_INDEX_DISABLED            0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_INDEX_ENABLED             0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW                       16:16 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW_DISABLED         0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW_ENABLED          0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_VBLANK                               20:20 /* RWIVF */
#define NV_PRM_INTR_EN_0_VBLANK_DISABLED                 0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_VBLANK_ENABLED                  0x00000001 /* RW--V */
#define NV_PRM_CONFIG_0                                  0x006C0200 /* RW-4R */
#define NV_PRM_CONFIG_0_TEXT                                    0:0 /* RWIVF */
#define NV_PRM_CONFIG_0_TEXT_DISABLED                    0x00000000 /* RWI-V */
#define NV_PRM_CONFIG_0_TEXT_ENABLED                     0x00000001 /* RW--V */
#define NV_PRM_CONFIG_0_DAC_WIDTH                               4:4 /* RWIVF */
#define NV_PRM_CONFIG_0_DAC_WIDTH_6_BITS                 0x00000000 /* RWI-V */
#define NV_PRM_CONFIG_0_DAC_WIDTH_8_BITS                 0x00000001 /* RW--V */
#define NV_PRM_TRACE                                     0x006C1F00 /* RW-4R */
#define NV_PRM_TRACE__ALIAS_1                       NV_MEMORY_TRACE /*       */
#define NV_PRM_TRACE_IO_CAPTURE                                 1:0 /* RWIVF */
#define NV_PRM_TRACE_IO_CAPTURE_DISABLED                 0x00000000 /* RWI-V */
#define NV_PRM_TRACE_IO_CAPTURE_WRITES                   0x00000001 /* RW--V */
#define NV_PRM_TRACE_IO_CAPTURE_READS                    0x00000002 /* RW--V */
#define NV_PRM_TRACE_IO_CAPTURE_READS_WRITES             0x00000003 /* RW--V */
#define NV_PRM_TRACE_IO_WRITE                                   4:4 /* RWIVF */
#define NV_PRM_TRACE_IO_WRITE_NONE                       0x00000000 /* R-I-V */
#define NV_PRM_TRACE_IO_WRITE_OCCURED                    0x00000001 /* R---V */
#define NV_PRM_TRACE_IO_WRITE_RESET                      0x00000001 /* -W--V */
#define NV_PRM_TRACE_IO_READ                                    5:5 /* RWIVF */
#define NV_PRM_TRACE_IO_READ_NONE                        0x00000000 /* R-I-V */
#define NV_PRM_TRACE_IO_READ_OCCURED                     0x00000001 /* R---V */
#define NV_PRM_TRACE_IO_READ_RESET                       0x00000001 /* -W--V */
#define NV_PRM_TRACE_VGA_CAPTURE                                9:8 /* RWIVF */
#define NV_PRM_TRACE_VGA_CAPTURE_DISABLED                0x00000000 /* RWI-V */
#define NV_PRM_TRACE_VGA_CAPTURE_WRITES                  0x00000001 /* RW--V */
#define NV_PRM_TRACE_VGA_CAPTURE_READS                   0x00000002 /* RW--V */
#define NV_PRM_TRACE_VGA_CAPTURE_READS_WRITES            0x00000003 /* RW--V */
#define NV_PRM_TRACE_VGA_WRITE                                12:12 /* RWIVF */
#define NV_PRM_TRACE_VGA_WRITE_NONE                      0x00000000 /* R-I-V */
#define NV_PRM_TRACE_VGA_WRITE_OCCURED                   0x00000001 /* R---V */
#define NV_PRM_TRACE_VGA_WRITE_RESET                     0x00000001 /* -W--V */
#define NV_PRM_TRACE_VGA_READ                                 13:13 /* RWIVF */
#define NV_PRM_TRACE_VGA_READ_NONE                       0x00000000 /* R-I-V */
#define NV_PRM_TRACE_VGA_READ_OCCURED                    0x00000001 /* R---V */
#define NV_PRM_TRACE_VGA_READ_RESET                      0x00000001 /* -W--V */
#define NV_PRM_TRACE_INDEX                               0x006C1F10 /* RW-4R */
#define NV_PRM_TRACE_INDEX__ALIAS_1           NV_MEMORY_TRACE_INDEX /*       */
#define NV_PRM_TRACE_INDEX_ADDRESS                             13:0 /* RWIUF */
#define NV_PRM_TRACE_INDEX_ADDRESS_0                     0x00000000 /* RWI-V */
#define NV_PRM_IGNORE_0                                  0x006C1F20 /* RW-4R */
#define NV_PRM_IGNORE_0__ALIAS_1                    NV_MEMORY_TRACE /*       */
#define NV_PRM_IGNORE_0_DAC                                     1:0 /* RWIVF */
#define NV_PRM_IGNORE_0_DAC_DISABLED                     0x00000000 /* RWI-V */
#define NV_PRM_IGNORE_0_DAC_WRITES                       0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_DAC_READS                        0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_DAC_READS_WRITES                 0x00000003 /* RW--V */
#define NV_PRM_IGNORE_0_GAMEPORT                                5:4 /* RWIVF */
#define NV_PRM_IGNORE_0_GAMEPORT_DISABLED                0x00000000 /* RWI-V */
#define NV_PRM_IGNORE_0_GAMEPORT_WRITES                  0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_GAMEPORT_READS                   0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_GAMEPORT_READS_WRITES            0x00000003 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401                                  9:8 /* RWIVF */
#define NV_PRM_IGNORE_0_MPU401_DISABLED                  0x00000000 /* RWI-V */
#define NV_PRM_IGNORE_0_MPU401_WRITES                    0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401_READS                     0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401_READS_WRITES              0x00000003 /* RW--V */
#define NV_PRM_IGNORE_1                                  0x006C1F24 /* RW-4R */
#define NV_PRM_IGNORE_1__ALIAS_1                    NV_MEMORY_TRACE /*       */
#define NV_PRM_IGNORE_1_FM_INDEX                                1:0 /* RWIVF */
#define NV_PRM_IGNORE_1_FM_INDEX_DISABLED                0x00000000 /* RWI-V */
#define NV_PRM_IGNORE_1_FM_INDEX_WRITES                  0x00000001 /* RW--V */
#define NV_PRM_IGNORE_1_FM_INDEX_READS                   0x00000002 /* RW--V */
#define NV_PRM_IGNORE_1_FM_INDEX_READS_WRITES            0x00000003 /* RW--V */
#define NV_PRM_IGNORE_1_FM_DATA                                 5:4 /* RWIVF */
#define NV_PRM_IGNORE_1_FM_DATA_DISABLED                 0x00000000 /* RWI-V */
#define NV_PRM_IGNORE_1_FM_DATA_WRITES                   0x00000001 /* RW--V */
#define NV_PRM_IGNORE_1_FM_DATA_READS                    0x00000002 /* RW--V */
#define NV_PRM_IGNORE_1_FM_DATA_READS_WRITES             0x00000003 /* RW--V */
#define NV_PRM_IGNORE_1_SB_DIGITAL                              9:8 /* RWIVF */
#define NV_PRM_IGNORE_1_SB_DIGITAL_DISABLED              0x00000000 /* RWI-V */
#define NV_PRM_IGNORE_1_SB_DIGITAL_WRITES                0x00000001 /* RW--V */
#define NV_PRM_IGNORE_1_SB_DIGITAL_READS                 0x00000002 /* RW--V */
#define NV_PRM_IGNORE_1_SB_DIGITAL_READS_WRITES          0x00000003 /* RW--V */
#define NV_PRM_IGNORE_1_VGA_HW                                17:16 /* RWIVF */
#define NV_PRM_IGNORE_1_VGA_HW_DISABLED                  0x00000000 /* RWI-V */
#define NV_PRM_IGNORE_1_VGA_HW_WRITES                    0x00000001 /* RW--V */
#define NV_PRM_IGNORE_1_VGA_HW_READS                     0x00000002 /* RW--V */
#define NV_PRM_IGNORE_1_VGA_HW_READS_WRITES              0x00000003 /* RW--V */
#define NV_PRM_IGNORE_1_VGA_SW                                21:20 /* RWIVF */
#define NV_PRM_IGNORE_1_VGA_SW_DISABLED                  0x00000000 /* RWI-V */
#define NV_PRM_IGNORE_1_VGA_SW_WRITES                    0x00000001 /* RW--V */
#define NV_PRM_IGNORE_1_VGA_SW_READS                     0x00000002 /* RW--V */
#define NV_PRM_IGNORE_1_VGA_SW_READS_WRITES              0x00000003 /* RW--V */
#define NV_PRM_IGNORE_1_VGA_MISC                              25:24 /* RWIVF */
#define NV_PRM_IGNORE_1_VGA_MISC_DISABLED                0x00000000 /* RWI-V */
#define NV_PRM_IGNORE_1_VGA_MISC_WRITES                  0x00000001 /* RW--V */
#define NV_PRM_IGNORE_1_VGA_MISC_READS                   0x00000002 /* RW--V */
#define NV_PRM_IGNORE_1_VGA_MISC_READS_WRITES            0x00000003 /* RW--V */
#define NV_PRM_MPU_401                                   0x006C0400 /* RW-4R */
#define NV_PRM_MPU_401_DATA                                     7:0 /* RWXVF */
#define NV_PRM_MPU_401_DATA_ACK                          0x000000FE /* RW--V */
#define NV_PRM_MPU_401_WRITE_STATUS                             8:8 /* RWIVF */
#define NV_PRM_MPU_401_WRITE_STATUS_EMPTY                0x00000000 /* RWI-V */
#define NV_PRM_MPU_401_WRITE_STATUS_FULL                 0x00000001 /* RW--V */
#define NV_PRM_MPU_401_WRITE_FORCE                            12:12 /* RWIVF */
#define NV_PRM_MPU_401_WRITE_FORCE_EMPTY                 0x00000000 /* RWI-V */
#define NV_PRM_MPU_401_WRITE_FORCE_DISABLED              0x00000001 /* RW--V */
#define NV_PRM_MPU_401_READ_STATUS                            16:16 /* RWIVF */
#define NV_PRM_MPU_401_READ_STATUS_FULL                  0x00000000 /* RWI-V */
#define NV_PRM_MPU_401_READ_STATUS_EMPTY                 0x00000001 /* RW--V */
#define NV_PRM_MPU_401_READ_FORCE                             20:20 /* RWIVF */
#define NV_PRM_MPU_401_READ_FORCE_FULL                   0x00000000 /* RWI-V */
#define NV_PRM_MPU_401_READ_FORCE_DISABLED               0x00000001 /* RW--V */
#define NV_PRM_MPU_401_UART_MODE                              24:24 /* RWIVF */
#define NV_PRM_MPU_401_UART_MODE_COMPLEX                 0x00000000 /* RWI-V */
#define NV_PRM_MPU_401_UART_MODE_SIMPLE                  0x00000001 /* RW--V */
/* dev_realmode.ref */
#define NV_PRMIO                              0x006DFFFF:0x006D0000 /* RW--D */
#define NV_PRMIO_GAME_PORT                               0x006D0201 /* RW-1R */
#define NV_PRMIO_GAME_PORT__ALIAS_1                 NV_IO_GAME_PORT /*       */
#define NV_PRMIO_FM_ADDRESS__SOUND_BLASTER               0x006D0228 /* -W-1R */
#define NV_PRMIO_FM_ADDRESS__ADLIB                       0x006D0388 /* -W-1R */
#define NV_PRMIO_SB_WRITE_STATUS                         0x006D022C /* R--1R */
#define NV_PRMIO_SB_WRITE_STATUS__ALIAS_1     NV_IO_SB_WRITE_STATUS /*       */
#define NV_PRMIO_SB_READ_STATUS                          0x006D022E /* RW-1R */
#define NV_PRMIO_SB_READ_STATUS__ALIAS_1       NV_IO_SB_READ_STATUS /*       */
#define NV_PRMIO_MPU_401_DATA                            0x006D0330 /* R--1R */
#define NV_PRMIO_MPU_401_DATA__ALIAS_1           NV_IO_MPU_401_DATA /*       */
#define NV_PRMIO_MPU_401_STATUS                          0x006D0331 /* R--1R */
#define NV_PRMIO_MPU_401_STATUS__ALIAS_1       NV_IO_MPU_401_STATUS /*       */
#define NV_PRMIO_EX_MISC_OUT__WRITE                      0x006D03C2 /* -W-1R */
#define NV_PRMIO_EX_MISC_OUT__READ                       0x006D03CC /* R--1R */
#define NV_PRMIO_EX_FEATURE__WRITE_MONO                  0x006D03BA /* -W-1R */
#define NV_PRMIO_EX_FEATURE__WRITE_COLOR                 0x006D03DA /* -W-1R */
#define NV_PRMIO_EX_FEATURE__READ                        0x006D03CA /* R--1R */
#define NV_PRMIO_EX_STATUS_0__READ                       0x006D03c2 /* R--1R */
#define NV_PRMIO_EX_STATUS_1__READ_MONO                  0x006D03BA /* R--1R */
#define NV_PRMIO_EX_STATUS_1__READ_COLOR                 0x006D03DA /* R--1R */
#define NV_PRMIO_SQ_ADDRESS                              0x006D03C4 /* RW-1R */
#define NV_PRMIO_SQ_ADDRESS__ALIAS_1               NV_IO_SQ_ADDRESS /*       */
#define NV_PRMIO_SQ_MAP_MASK                             0x006D03C5 /* RW-1R */
#define NV_PRMIO_SQ_MAP_MASK__ALIAS_1             NV_IO_SQ_MAP_MASK /*       */
#define NV_PRMIO_SQ_MAP_MASK__INDEX                      0x00000002 /*       */
#define NV_PRMIO_SQ_CHAR_MAP                             0x006D03C5 /* RW-1R */
#define NV_PRMIO_SQ_CHAR_MAP__ALIAS_1             NV_IO_SQ_CHAR_MAP /*       */
#define NV_PRMIO_SQ_CHAR_MAP__INDEX                      0x00000003 /*       */
#define NV_PRMIO_SQ_MEM_MAP                              0x006D03C5 /* RW-1R */
#define NV_PRMIO_SQ_MEM_MAP__ALIAS_1               NV_IO_SQ_MEM_MAP /*       */
#define NV_PRMIO_SQ_MEM_MAP__INDEX                       0x00000004 /*       */
#define NV_PRMIO_CC_ADDRESS__MONO                        0x006D03B4 /* RW-1R */
#define NV_PRMIO_CC_ADDRESS__COLOR                       0x006D03D4 /* RW-1R */
#define NV_PRMIO_CC_MAX_SCAN__MONO                       0x006D03B5 /* RW-1R */
#define NV_PRMIO_CC_MAX_SCAN__COLOR                      0x006D03D5 /* RW-1R */
#define NV_PRMIO_CC_MAX_SCAN__INDEX                      0x00000009 /*       */
#define NV_PRMIO_CC_CURSOR_START__MONO                   0x006D03B5 /* RW-1R */
#define NV_PRMIO_CC_CURSOR_START__COLOR                  0x006D03D5 /* RW-1R */
#define NV_PRMIO_CC_CURSOR_START__INDEX                  0x0000000A /*       */
#define NV_PRMIO_CC_START_HI__MONO                       0x006D03B5 /* RW-1R */
#define NV_PRMIO_CC_START_HI__COLOR                      0x006D03D5 /* RW-1R */
#define NV_PRMIO_CC_START_HI__INDEX                      0x0000000C /*       */
#define NV_PRMIO_CC_START_LO__MONO                       0x006D03B5 /* RW-1R */
#define NV_PRMIO_CC_START_LO__COLOR                      0x006D03D5 /* RW-1R */
#define NV_PRMIO_CC_START_LO__INDEX                      0x0000000D /*       */
#define NV_PRMIO_CC_CURSOR_HI__MONO                      0x006D03B5 /* RW-1R */
#define NV_PRMIO_CC_CURSOR_HI__COLOR                     0x006D03D5 /* RW-1R */
#define NV_PRMIO_CC_CURSOR_HI__INDEX                     0x0000000E /*       */
#define NV_PRMIO_CC_CURSOR_LO__MONO                      0x006D03B5 /* RW-1R */
#define NV_PRMIO_CC_CURSOR_LO__COLOR                     0x006D03D5 /* RW-1R */
#define NV_PRMIO_CC_CURSOR_LO__INDEX                     0x0000000F /*       */
#define NV_PRMIO_CC_OFFSET__MONO                         0x006D03B5 /* RW-1R */
#define NV_PRMIO_CC_OFFSET__COLOR                        0x006D03D5 /* RW-1R */
#define NV_PRMIO_CC_OFFSET__INDEX                        0x00000013 /*       */
#define NV_PRMIO_GC_ADDRESS                              0x006D03CE /* RW-1R */
#define NV_PRMIO_GC_ADDRESS__ALIAS_1               NV_IO_GC_ADDRESS /*       */
#define NV_PRMIO_GC_SR                                   0x006D03CF /* RW-1R */
#define NV_PRMIO_GC_SR__ALIAS_1                         NV_IO_GC_SR /*       */
#define NV_PRMIO_GC_SR__INDEX                            0x00000000 /*       */
#define NV_PRMIO_GC_ENABLE_SR                            0x006D03CF /* RW-1R */
#define NV_PRMIO_GC_ENABLE_SR__ALIAS_1           NV_IO_GC_ENABLE_SR /*       */
#define NV_PRMIO_GC_ENABLE_SR__INDEX                     0x00000001 /*       */
#define NV_PRMIO_GC_COLOR_COMP                           0x006D03CF /* RW-1R */
#define NV_PRMIO_GC_COLOR_COMP__ALIAS_1         NV_IO_GC_COLOR_COMP /*       */
#define NV_PRMIO_GC_COLOR_COMP__INDEX                    0x00000002 /*       */
#define NV_PRMIO_GC_ROTATE                               0x006D03CF /* RW-1R */
#define NV_PRMIO_GC_ROTATE__ALIAS_1                 NV_IO_GC_ROTATE /*       */
#define NV_PRMIO_GC_ROTATE__INDEX                        0x00000003 /*       */
#define NV_PRMIO_GC_READ_MAP                             0x006D03CF /* RW-1R */
#define NV_PRMIO_GC_READ_MAP__ALIAS_1             NV_IO_GC_READ_MAP /*       */
#define NV_PRMIO_GC_READ_MAP__INDEX                      0x00000004 /*       */
#define NV_PRMIO_GC_MODE                                 0x006D03CF /* RW-1R */
#define NV_PRMIO_GC_MODE__ALIAS_1                     NV_IO_GC_MODE /*       */
#define NV_PRMIO_GC_MODE__INDEX                          0x00000005 /*       */
#define NV_PRMIO_GC_MISC                                 0x006D03CF /* RW-1R */
#define NV_PRMIO_GC_MISC__ALIAS_1                     NV_IO_GC_MISC /*       */
#define NV_PRMIO_GC_MISC__INDEX                          0x00000006 /*       */
#define NV_PRMIO_GC_DONT_CARE                            0x006D03CF /* RW-1R */
#define NV_PRMIO_GC_DONT_CARE__ALIAS_1           NV_IO_GC_DONT_CARE /*       */
#define NV_PRMIO_GC_DONT_CARE__INDEX                     0x00000007 /*       */
#define NV_PRMIO_GC_BIT_MASK                             0x006D03CF /* RW-1R */
#define NV_PRMIO_GC_BIT_MASK__ALIAS_1             NV_IO_GC_BIT_MASK /*       */
#define NV_PRMIO_GC_BIT_MASK__INDEX                      0x00000008 /*       */
#define NV_PRMIO_AT_ADDRESS__WRITE_FLIPFLOP0             0x006D03C0 /* -W-1R */
#define NV_PRMIO_AT_ADDRESS__READ                        0x006D03C0 /* R--1R */
#define NV_PRMIO_AT_MODE__WRITE_FLIPFLOP1                0x006D03C0 /* -W-1R */
#define NV_PRMIO_AT_MODE__READ                           0x006D03C1 /* R--1R */
#define NV_PRMIO_DAC_DATA                                0x006D03C9 /* RW-1R */
#define NV_PRMIO_DAC_DATA__ALIAS_1                   NV_IO_DAC_DATA /*       */
/* dev_realmode.ref */
#define NV_PRMVGA                             0x006EFFFF:0x006E0000 /* RW--D */
/* dev_ram.ref */
#define NV_PRAMIN                             0x007FFFFF:0x00700000 /* RW--D */
/* dev_fifo.ref */
#define NV_USER                               0x00FFFFFF:0x00800000 /* RW--D */
#define NV_USER_OBJECT(i,j)     (0x00800000+(i)*0x10000+(j)*0x2000) /* -W-4A */
#define NV_USER_OBJECT__SIZE_1                                  128 /*       */
#define NV_USER_OBJECT__SIZE_2                                    8 /*       */
#define NV_USER_OBJECT_HANDLE                                  31:0 /* -W-VF */
#define NV_USER_FREE016(i,j)        (0x00800010+(i)*65536+(j)*8192) /* R--2A */
#define NV_USER_FREE016__SIZE_1                                 128 /*       */
#define NV_USER_FREE016__SIZE_2                                   8 /*       */
#define NV_USER_FREE016_COUNT_LO                                1:0 /* C--UF */
#define NV_USER_FREE016_COUNT_LO_0                       0x00000000 /* C---V */
#define NV_USER_FREE016_COUNT                                   9:2 /* R--UF */
#define NV_USER_FREE016_COUNT_HI                              15:10 /* C--UF */
#define NV_USER_FREE016_COUNT_HI_0                       0x00000000 /* C---V */
#define NV_USER_FREE032(i,j)        (0x00800010+(i)*65536+(j)*8192) /* R--4A */
#define NV_USER_FREE032__SIZE_1                                 128 /*       */
#define NV_USER_FREE032__SIZE_2                                   8 /*       */
#define NV_USER_FREE032_COUNT_LO                                1:0 /* C--UF */
#define NV_USER_FREE032_COUNT_LO_0                       0x00000000 /* C---V */
#define NV_USER_FREE032_COUNT                                   9:2 /* R--UF */
#define NV_USER_FREE032_COUNT_HI                              31:10 /* C--UF */
#define NV_USER_FREE032_COUNT_HI_0                       0x00000000 /* C---V */
#define NV_USER_ZERO016(i,j,k) (0x0800012+(i)*65536+(j)*8192+(k)*2) /* R--2A */
#define NV_USER_ZERO016__SIZE_1                                 128 /*       */
#define NV_USER_ZERO016__SIZE_2                                   8 /*       */
#define NV_USER_ZERO016__SIZE_3                                   7 /*       */
#define NV_USER_ZERO016_COUNT                                  15:0 /* C--UF */
#define NV_USER_ZERO016_COUNT_0                          0x00000000 /* C---V */
#define NV_USER_ZERO032(i,j,k) (0x0800014+(i)*65536+(j)*8192+(k)*4) /* R--4A */
#define NV_USER_ZERO032__SIZE_1                                 128 /*       */
#define NV_USER_ZERO032__SIZE_2                                   8 /*       */
#define NV_USER_ZERO032__SIZE_3                                   3 /*       */
#define NV_USER_ZERO032_COUNT                                  31:0 /* C--UF */
#define NV_USER_ZERO032_COUNT_0                          0x00000000 /* C---V */
#define NV_USER_PW(i,j,k)   (0x800020+(i)*0x10000+(j)*0x2000+(k)*4) /* -W-4A */
#define NV_USER_PW__SIZE_1                                      128 /*       */
#define NV_USER_PW__SIZE_2                                        8 /*       */
#define NV_USER_PW__SIZE_3                                        4 /*       */
#define NV_USER_PW_PASSWORD                                    31:0 /* -W-VF */
/* dev_framebuffer.ref */
#define NV_PDFB                               0x01FFFFFF:0x01000000 /* RW--D */
#define NV_PDFB_DATA032(i)                       (0x01000000+(i)*4) /* RW-4A */
#define NV_PDFB_DATA032__SIZE_1                             4194304 /*       */
#define NV_PDFB_DATA032_VALUE                                  31:0 /* RWXVF */
#define NV_PDFB_DATA024(i)           (0x01000000+((i)/2)*4+((i)%2)) /* RW-3A */
#define NV_PDFB_DATA024__SIZE_1                             8388608 /*       */
#define NV_PDFB_DATA024_VALUE                                  23:0 /* RWXVF */
#define NV_PDFB_DATA016(i)           (0x01000000+((i)/3)*4+((i)%3)) /* RW-2A */
#define NV_PDFB_DATA016__SIZE_1                            12582912 /*       */
#define NV_PDFB_DATA016_VALUE                                  15:0 /* RWXVF */
#define NV_PDFB_DATA008(i)                         (0x01000000+(i)) /* RW-1A */
#define NV_PDFB_DATA008__SIZE_1                            16777216 /*       */
#define NV_PDFB_DATA008_VALUE                                   7:0 /* RWXVF */
/* dev_dma.ref */
#define NV_NOTIFY                             0x0000000F:0x00000000 /* RW--M */
#define NV_NOTIFY_TIME_0                      ( 0*32+31):( 0*32+ 5) /* RWXUF */
#define NV_NOTIFY_TIME_1                      ( 1*32+28):( 1*32+ 0) /* RWXUF */
#define NV_NOTIFY_RETURN_VALUE                ( 2*32+31):( 2*32+ 0) /* RWXVF */
#define NV_NOTIFY_ERROR_CODE                  ( 3*32+15):( 3*32+ 0) /* RWXUF */
#define NV_NOTIFY_STATUS                      ( 3*32+31):( 3*32+24) /* RWXUF */
#define NV_NOTIFY_STATUS_COMPLETED                       0x00000000 /* RW--V */
#define NV_NOTIFY_STATUS_IN_PROCESS                      0x00000001 /* RW--V */
/* dev_realmode.ref */
#define NV_TRACE                              0x0000FFFF:0x00000000 /* RW--M */
#define NV_TRACE_DATA                         ( 0*32+ 7):( 0*32+ 0) /* RWXVF */
#define NV_TRACE_FLIPFLOP                     ( 0*32+13):( 0*32+13) /* RWXVF */
#define NV_TRACE_FLIPFLOP_ADDRESS                        0x00000000 /* RW--V */
#define NV_TRACE_FLIPFLOP_DATA                           0x00000001 /* RW--V */
#define NV_TRACE_ACCESS                       ( 0*32+14):( 0*32+14) /* RWXVF */
#define NV_TRACE_ACCESS_WRITE                            0x00000000 /* RW--V */
#define NV_TRACE_ACCESS_READ                             0x00000001 /* RW--V */
#define NV_TRACE_TYPE                         ( 0*32+15):( 0*32+15) /* RWXVF */
#define NV_TRACE_TYPE_IO                                 0x00000000 /* RW--V */
#define NV_TRACE_TYPE_MEMORY                             0x00000001 /* RW--V */
#define NV_TRACE_ADDRESS                      ( 0*32+31):( 0*32+16) /* RWXUF */
/* dev_ram.ref */
#define NV_RAMHT__SIZE_0                      0x00000FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_1                      0x00001FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_2                      0x00003FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_3                      0x00007FFF:0x00000000 /* RW--M */
#define NV_RAMHT_HANDLE                       ( 0*32+31):( 0*32+ 0) /* RWXVF */
#define NV_RAMHT_INSTANCE                     ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_RAMHT_DEVICE                       ( 1*32+22):( 1*32+16) /* RWXUF */
#define NV_RAMHT_CHID                         ( 1*32+30):( 1*32+24) /* RWXUF */
#define NV_RAMHT_FREE_LIE                     ( 1*32+31):( 1*32+31) /* RWXVF */
#define NV_RAMHT_FREE_LIE_DISABLED                       0x00000000 /* RW--V */
#define NV_RAMHT_FREE_LIE_ENABLED                        0x00000001 /* RW--V */
/* dev_ram.ref */
#define NV_RAMRO__SIZE_0                      0x000007FF:0x00000000 /* RW--M */
#define NV_RAMRO__SIZE_1                      0x00000FFF:0x00000000 /* RW--M */
#define NV_RAMRO__SIZE_2                      0x00001FFF:0x00000000 /* RW--M */
#define NV_RAMRO__SIZE_3                      0x00003FFF:0x00000000 /* RW--M */
#define NV_RAMRO_METHOD                       ( 0*32+15):( 0*32+ 0) /* RWXUF */
#define NV_RAMRO_CHID                         ( 0*32+22):( 0*32+16) /* RWXUF */
#define NV_RAMRO_SIZE                         ( 0*32+26):( 0*32+26) /* RWXVF */
#define NV_RAMRO_SIZE_ILLEGAL                            0x00000000 /* RW--V */
#define NV_RAMRO_SIZE_16_BIT                             0x00000001 /* RW--V */
#define NV_RAMRO_TYPE                         ( 0*32+27):( 0*32+27) /* RWXVF */
#define NV_RAMRO_TYPE_WRITE                              0x00000000 /* RW--V */
#define NV_RAMRO_TYPE_READ                               0x00000001 /* RW--V */
#define NV_RAMRO_REASON                       ( 0*32+31):( 0*32+28) /* RWXVF */
#define NV_RAMRO_REASON_ILLEGAL_ACCESS                   0x00000000 /* RW--V */
#define NV_RAMRO_REASON_NO_CACHE_AVAILABLE               0x00000001 /* RW--V */
#define NV_RAMRO_REASON_CACHE_RAN_OUT                    0x00000002 /* RW--V */
#define NV_RAMRO_REASON_FREE_COUNT_OVERRUN               0x00000003 /* RW--V */
#define NV_RAMRO_REASON_CAUGHT_LYING                     0x00000004 /* RW--V */
#define NV_RAMRO_REASON_RESERVED_ACCESS                  0x00000005 /* RW--V */
#define NV_RAMRO_DATA                         ( 1*32+31):( 1*32+ 0) /* RWXVF */
/* dev_ram.ref */
#define NV_RAMAU                              0x00000BFF:0x00000000 /* RW--M */
#define NV_RAMAU_DATA                                          31:0 /* RWXVF */
/* dev_ram.ref */
#define NV_RAMFC__SIZE_0                      0x000007FF:0x00000000 /* RW--M */
#define NV_RAMFC__SIZE_1                      0x00000FFF:0x00000000 /* RW--M */
#define NV_RAMFC__SIZE_2                      0x00001FFF:0x00000000 /* RW--M */
#define NV_RAMFC__SIZE_3                      0x00003FFF:0x00000000 /* RW--M */
#define NV_RAMFC_INSTANCE_0                   ( 0*32+15):( 0*32+ 0) /* RWXUF */
#define NV_RAMFC_DEVICE_0                     ( 0*32+22):( 0*32+16) /* RWXUF */
#define NV_RAMFC_DEVICE_0_NOT_FOUND                      0x00000000 /* RW--V */
#define NV_RAMFC_LIE_0                        ( 0*32+24):( 0*32+24) /* RWXVF */
#define NV_RAMFC_LIE_0_DISABLED                          0x00000000 /* RW--V */
#define NV_RAMFC_LIE_0_ENABLED                           0x00000001 /* RW--V */
#define NV_RAMFC_SUBCHANNEL                   ( 0*32+30):( 0*32+28) /* RWXUF */
#define NV_RAMFC_OBJECT                       ( 0*32+31):( 0*32+31) /* RWXVF */
#define NV_RAMFC_OBJECT_UNCHANGED                        0x00000000 /* RW--V */
#define NV_RAMFC_OBJECT_CHANGED                          0x00000001 /* RW--V */
#define NV_RAMFC_INSTANCE_1                   ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_RAMFC_DEVICE_1                     ( 1*32+22):( 1*32+16) /* RWXUF */
#define NV_RAMFC_DEVICE_1_NOT_FOUND                      0x00000000 /* RW--V */
#define NV_RAMFC_LIE_1                        ( 1*32+24):( 1*32+24) /* RWXVF */
#define NV_RAMFC_LIE_1_DISABLED                          0x00000000 /* RW--V */
#define NV_RAMFC_LIE_1_ENABLED                           0x00000001 /* RW--V */
#define NV_RAMFC_INSTANCE_7                   ( 7*32+15):( 7*32+ 0) /* RWXUF */
#define NV_RAMFC_DEVICE_7                     ( 7*32+22):( 7*32+16) /* RWXUF */
#define NV_RAMFC_DEVICE_7_NOT_FOUND                      0x00000000 /* RW--V */
#define NV_RAMFC_LIE_7                        ( 7*32+24):( 7*32+24) /* RWXVF */
#define NV_RAMFC_LIE_7_DISABLED                          0x00000000 /* RW--V */
#define NV_RAMFC_LIE_7_ENABLED                           0x00000001 /* RW--V */
/* dev_ram.ref */
#define NV_RAMPW                              0x000003FF:0x00000000 /* RW--M */
#define NV_RAMPW_PASSWORD_0                   ( 0*32+31):( 0*32+ 0) /* RWXVF */
#define NV_RAMPW_PASSWORD_1                   ( 1*32+31):( 1*32+ 0) /* RWXVF */
/* dev_ram.ref */
#define NV_RAMIN                              0x000FFFFF:0x00000000 /* RW--M */
#define NV_RAMIN_CONTEXT_0                    ( 0*32+31):( 0*32+ 0) /*       */
#define NV_RAMIN_CONTEXT_1                    ( 1*32+31):( 1*32+ 0) /*       */
#define NV_RAMIN_CONTEXT_2                    ( 2*32+31):( 2*32+ 0) /*       */
#define NV_RAMIN_CONTEXT_3                    ( 3*32+31):( 3*32+ 0) /*       */
/* dev_ram.ref */
#define NV_DMA_ADJUST                         ( 0*32+11):( 0*32+ 0) /* RWXUF */
#define NV_DMA_PAGE_TABLE                     ( 0*32+16):( 0*32+16) /* RWXVF */
#define NV_DMA_PAGE_TABLE_NOT_PRESENT                    0x00000000 /* RW--V */
#define NV_DMA_PAGE_TABLE_PRESENT                        0x00000001 /* RW--V */
#define NV_DMA_LIMIT                          ( 1*32+31):( 1*32+ 0) /* RWXUF */
#define NV_DMA_PAGE                           ( 2*32+ 0):( 2*32+ 0) /* RWXVF */
#define NV_DMA_PAGE_NOT_PRESENT                          0x00000000 /* RW--V */
#define NV_DMA_PAGE_PRESENT                              0x00000001 /* RW--V */
#define NV_DMA_ACCESS                         ( 2*32+ 1):( 2*32+ 1) /* RWXVF */
#define NV_DMA_ACCESS_READ_ONLY                          0x00000000 /* RW--V */
#define NV_DMA_ACCESS_READ_AND_WRITE                     0x00000001 /* RW--V */
#define NV_DMA_FRAME_ADDRESS                  ( 2*32+31):( 2*32+12) /* RWXUF */
/* dev_ram.ref */
#define NV_AUDIN                              0x00000033:0x00000000 /* RW--M */
#define NV_AUDIN_AE_STATE                     ( 0*32+31):( 0*32+ 0) /* RWWVF */
#define NV_AUDIN_AE_SKIP_COUNT                ( 1*32+31):( 1*32+ 0) /* RWWUF */
#define NV_AUDIN_AE_POSITION                  ( 2*32+31):( 2*32+ 0) /* RWWUF */
#define NV_AUDIN_RM_NEXT_INSTANCE             ( 3*32+15):( 3*32+ 0) /* RWWUF */
#define NV_AUDIN_RM_STATE                     ( 3*32+31):( 3*32+16) /* RWWVF */
#define NV_AUDIN_SU_START_TIME_LOW            ( 4*32+15):( 4*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_STATE                     ( 4*32+31):( 4*32+16) /* RWWVF */
#define NV_AUDIN_SU_START_TIME_HIGH           ( 5*32+31):( 5*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_SKIP_INC                  ( 6*32+31):( 6*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_BUFF0_DMA_INSTANCE        ( 7*32+15):( 7*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_BUFF0_NOTIFY_INSTANCE     ( 7*32+31):( 7*32+16) /* RWWUF */
#define NV_AUDIN_SU_BUFF0_START_POSITION      ( 8*32+31):( 8*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_BUFF0_LAST_SAMPLE_PLUS1   ( 9*32+31):( 9*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_BUFF1_DMA_INSTANCE        (10*32+15):(10*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_BUFF1_NOTIFY_INSTANCE     (10*32+31):(10*32+16) /* RWWUF */
#define NV_AUDIN_SU_BUFF1_START_POSITION      (11*32+31):(11*32+ 0) /* RWWUF */
#define NV_AUDIN_SU_BUFF1_LAST_SAMPLE_PLUS1   (12*32+31):(12*32+ 0) /* RWWUF */
#define NV_AUDIN_AE_BUFF0_INTR_NOTIFY         ( 0*32+20):( 0*32+20) /* RWXVF */
#define NV_AUDIN_AE_BUFF1_INTR_NOTIFY         ( 0*32+21):( 0*32+21) /* RWXVF */
#define NV_AUDIN_AE_BUFF0_INTR_CHAIN_GAP      ( 0*32+22):( 0*32+22) /* RWXVF */
#define NV_AUDIN_AE_BUFF1_INTR_CHAIN_GAP      ( 0*32+23):( 0*32+23) /* RWXVF */
#define NV_AUDIN_AE_BUFF0_IN_USE              ( 0*32+24):( 0*32+24) /* RWXVF */
#define NV_AUDIN_AE_BUFF1_IN_USE              ( 0*32+25):( 0*32+25) /* RWXVF */
#define NV_AUDIN_AE_CURRENT_BUFFER            ( 0*32+28):( 0*32+28) /* RWXVF */
#define NV_AUDIN_AE_CURRENT_BUFFER_0                     0x00000000 /* RW--V */
#define NV_AUDIN_AE_CURRENT_BUFFER_1                     0x00000001 /* RW--V */
#define NV_AUDIN_RM_BUFF0_INTR_NOTIFY         ( 3*32+20):( 3*32+20) /* RWXVF */
#define NV_AUDIN_RM_BUFF1_INTR_NOTIFY         ( 3*32+21):( 3*32+21) /* RWXVF */
#define NV_AUDIN_RM_BUFF0_INTR_CHAIN_GAP      ( 3*32+22):( 3*32+22) /* RWXVF */
#define NV_AUDIN_RM_BUFF1_INTR_CHAIN_GAP      ( 3*32+23):( 3*32+23) /* RWXVF */
#define NV_AUDIN_SU_BUFF0_OFFSET              ( 4*32+17):( 4*32+16) /* RWXVF */
#define NV_AUDIN_SU_BUFF1_OFFSET              ( 4*32+21):( 4*32+20) /* RWXVF */
#define NV_AUDIN_SU_BUFF0_IN_USE              ( 4*32+24):( 4*32+24) /* RWXVF */
#define NV_AUDIN_SU_BUFF1_IN_USE              ( 4*32+25):( 4*32+25) /* RWXVF */
#define NV_AUDIN_SU_BUFF0_NOTIFY              ( 4*32+26):( 4*32+26) /* RWXVF */
#define NV_AUDIN_SU_BUFF0_NOTIFY_DMA_WRITE               0x00000000 /* RW--V */
#define NV_AUDIN_SU_BUFF0_NOTIFY_INTERRUPT               0x00000001 /* RW--V */
#define NV_AUDIN_SU_BUFF1_NOTIFY              ( 4*32+27):( 4*32+27) /* RWXVF */
#define NV_AUDIN_SU_BUFF1_NOTIFY_DMA_WRITE               0x00000000 /* RW--V */
#define NV_AUDIN_SU_BUFF1_NOTIFY_INTERRUPT               0x00000001 /* RW--V */
#define NV_AUDIN_SU_FORMAT                    ( 4*32+29):( 4*32+28) /* RWXVF */
#define NV_AUDIN_SU_FORMAT_LINEAR                        0x00000000 /* RW--V */
#define NV_AUDIN_SU_FORMAT_ULAW                          0x00000001 /* RW--V */
#define NV_AUDIN_SU_FORMAT_ALAW                          0x00000002 /* RW--V */
#define NV_AUDIN_SU_FORMAT_OFFSET8                       0x00000003 /* RW--V */
#define NV_AUDIN_SU_CHANNEL                   ( 4*32+30):( 4*32+30) /* RWXVF */
#define NV_AUDIN_SU_CHANNEL_MONO                         0x00000000 /* RW--V */
#define NV_AUDIN_SU_CHANNEL_STEREO                       0x00000001 /* RW--V */
#define NV_AUDIN_SU_PDFB                      ( 4*32+31):( 4*32+31) /* RWXVF */
/* dev_ram.ref */
#define NV_AUDOUT                             0x0000003B:0x00000000 /* RW--M */
#define NV_AUDOUT_AE_POSITION_LOW             ( 0*32+15):( 0*32+ 0) /* RWXUF */
#define NV_AUDOUT_AE_STATE                    ( 0*32+31):( 0*32+16) /* RWXVF */
#define NV_AUDOUT_AE_POSITION                 ( 1*32+31):( 1*32+ 0) /* RWXUF */
#define NV_AUDOUT_AE_VOLUME_CHANNEL_1         ( 2*32+15):( 2*32+ 0) /* RWXUF */
#define NV_AUDOUT_AE_VOLUME_CHANNEL_0         ( 2*32+31):( 2*32+16) /* RWXUF */
#define NV_AUDOUT_RM_NEXT_INSTANCE            ( 3*32+15):( 3*32+ 0) /* RWXUF */
#define NV_AUDOUT_RM_STATE                    ( 3*32+31):( 3*32+16) /* RWXVF */
#define NV_AUDOUT_RM_VOLUME_CHANNEL_1         ( 4*32+15):( 4*32+ 0) /* RWXUF */
#define NV_AUDOUT_RM_VOLUME_CHANNEL_0         ( 4*32+31):( 4*32+16) /* RWXUF */
#define NV_AUDOUT_SU_POSITION_INC             ( 5*32+31):( 5*32+ 0) /* RWXUF */
#define NV_AUDOUT_SU_VOLUME_CHANNEL_1         ( 6*32+15):( 6*32+ 0) /* RWXUF */
#define NV_AUDOUT_SU_VOLUME_CHANNEL_0         ( 6*32+31):( 6*32+16) /* RWXUF */
#define NV_AUDOUT_SU_START_TIME_LOW           ( 7*32+15):( 7*32+ 0) /* RWXUF */
#define NV_AUDOUT_SU_STATE                    ( 7*32+31):( 7*32+16) /* RWXUF */
#define NV_AUDOUT_SU_START_TIME_HIGH          ( 8*32+31):( 8*32+ 0) /* RWXUF */
#define NV_AUDOUT_SU_BUFF0_DMA_INSTANCE       ( 9*32+15):( 9*32+ 0) /* RWXUF */
#define NV_AUDOUT_SU_BUFF0_NOTIFY_INSTANCE    ( 9*32+31):( 9*32+16) /* RWXUF */
#define NV_AUDOUT_SU_BUFF0_START_POSITION     (10*32+31):(10*32+ 0) /* RWXUF */
#define NV_AUDOUT_SU_BUFF0_LAST_SAMPLE_PLUS1  (11*32+31):(11*32+ 0) /* RWXUF */
#define NV_AUDOUT_SU_BUFF1_DMA_INSTANCE       (12*32+15):(12*32+ 0) /* RWXUF */
#define NV_AUDOUT_SU_BUFF1_NOTIFY_INSTANCE    (12*32+31):(12*32+16) /* RWXUF */
#define NV_AUDOUT_SU_BUFF1_START_POSITION     (13*32+31):(13*32+ 0) /* RWXUF */
#define NV_AUDOUT_SU_BUFF1_LAST_SAMPLE_PLUS1  (14*32+31):(14*32+ 0) /* RWXUF */
#define NV_AUDOUT_AE_INTR_MIXING              ( 0*32+16):( 0*32+16) /* RWXVF */
#define NV_AUDOUT_AE_INTR_VOLUME              ( 0*32+17):( 0*32+17) /* RWXVF */
#define NV_AUDOUT_AE_BUFF0_INTR_NOTIFY        ( 0*32+20):( 0*32+20) /* RWXVF */
#define NV_AUDOUT_AE_BUFF1_INTR_NOTIFY        ( 0*32+21):( 0*32+21) /* RWXVF */
#define NV_AUDOUT_AE_BUFF0_INTR_CHAIN_GAP     ( 0*32+22):( 0*32+22) /* RWXVF */
#define NV_AUDOUT_AE_BUFF1_INTR_CHAIN_GAP     ( 0*32+23):( 0*32+23) /* RWXVF */
#define NV_AUDOUT_AE_BUFF0_IN_USE             ( 0*32+24):( 0*32+24) /* RWXVF */
#define NV_AUDOUT_AE_BUFF1_IN_USE             ( 0*32+25):( 0*32+25) /* RWXVF */
#define NV_AUDOUT_AE_CURRENT_BUFFER           ( 0*32+28):( 0*32+28) /* RWXVF */
#define NV_AUDOUT_AE_CURRENT_BUFFER_0                    0x00000000 /* RW--V */
#define NV_AUDOUT_AE_CURRENT_BUFFER_1                    0x00000001 /* RW--V */
#define NV_AUDOUT_RM_INTR_MIXING              ( 3*32+16):( 3*32+16) /* RWXVF */
#define NV_AUDOUT_RM_INTR_VOLUME              ( 3*32+17):( 3*32+17) /* RWXVF */
#define NV_AUDOUT_RM_BUFF0_INTR_NOTIFY        ( 3*32+20):( 3*32+20) /* RWXVF */
#define NV_AUDOUT_RM_BUFF1_INTR_NOTIFY        ( 3*32+21):( 3*32+21) /* RWXVF */
#define NV_AUDOUT_RM_BUFF0_INTR_CHAIN_GAP     ( 3*32+22):( 3*32+22) /* RWXVF */
#define NV_AUDOUT_RM_BUFF1_INTR_CHAIN_GAP     ( 3*32+23):( 3*32+23) /* RWXVF */
#define NV_AUDOUT_SU_BUFF0_BYTE_OFFSET        ( 7*32+17):( 7*32+16) /* RWXVF */
#define NV_AUDOUT_SU_BUFF1_BYTE_OFFSET        ( 7*32+21):( 7*32+20) /* RWXVF */
#define NV_AUDOUT_SU_BUFF0_IN_USE             ( 7*32+24):( 7*32+24) /* RWXVF */
#define NV_AUDOUT_SU_BUFF1_IN_USE             ( 7*32+25):( 7*32+25) /* RWXVF */
#define NV_AUDOUT_SU_BUFF0_NOTIFY             ( 7*32+26):( 7*32+26) /* RWXVF */
#define NV_AUDOUT_SU_BUFF0_NOTIFY_DMA_WRITE              0x00000000 /* RW--V */
#define NV_AUDOUT_SU_BUFF0_NOTIFY_INTERRUPT              0x00000001 /* RW--V */
#define NV_AUDOUT_SU_BUFF1_NOTIFY             ( 7*32+27):( 7*32+27) /* RWXVF */
#define NV_AUDOUT_SU_BUFF1_NOTIFY_DMA_WRITE              0x00000000 /* RW--V */
#define NV_AUDOUT_SU_BUFF1_NOTIFY_INTERRUPT              0x00000001 /* RW--V */
#define NV_AUDOUT_SU_FORMAT                   ( 7*32+29):( 7*32+28) /* RWXVF */
#define NV_AUDOUT_SU_FORMAT_LINEAR                       0x00000000 /* RW--V */
#define NV_AUDOUT_SU_FORMAT_ULAW                         0x00000001 /* RW--V */
#define NV_AUDOUT_SU_FORMAT_ALAW                         0x00000002 /* RW--V */
#define NV_AUDOUT_SU_FORMAT_OFFSET8                      0x00000003 /* RW--V */
#define NV_AUDOUT_SU_CHANNEL                  ( 7*32+30):( 7*32+30) /* RWXVF */
#define NV_AUDOUT_SU_CHANNEL_MONO                        0x00000000 /* RW--V */
#define NV_AUDOUT_SU_CHANNEL_STEREO                      0x00000001 /* RW--V */
#define NV_AUDOUT_SU_PDFB                     ( 7*32+31):( 7*32+31) /* RWXVF */
/* dev_ram.ref */
#define NV_AUDNOTE                            0x0000007B:0x00000000 /* RW--M */
#define NV_AUDNOTE_AE_VIBRATO_TREMOLO_LEVEL   ( 0*32+15):( 0*32+ 0) /* RWXUF */
#define NV_AUDNOTE_AE_STATE                   ( 0*32+31):( 0*32+16) /* RWXVF */
#define NV_AUDNOTE_AE_ADSR_LEVEL              ( 1*32+31):( 1*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_POSITION_LOW            ( 2*32+15):( 2*32+ 0) /* RWXUF */
#define NV_AUDNOTE_AE_ADSR_VOLUME             ( 2*32+31):( 2*32+16) /* RWXUF */
#define NV_AUDNOTE_AE_POSITION_INC            ( 3*32+31):( 3*32+ 0) /* RWXUF */
#define NV_AUDNOTE_AE_VIBRATO_POSITION        ( 4*32+31):( 4*32+ 0) /* RWXUF */
#define NV_AUDNOTE_AE_VIBRATO_VALUE           ( 5*32+31):( 5*32+ 0) /* RWXUF */
#define NV_AUDNOTE_AE_TREMOLO_POSITION        ( 6*32+31):( 6*32+ 0) /* RWXUF */
#define NV_AUDNOTE_AE_VOLUME_CHANNEL_1        ( 7*32+15):( 7*32+ 0) /* RWXUF */
#define NV_AUDNOTE_AE_VOLUME_CHANNEL_0        ( 7*32+31):( 7*32+16) /* RWXUF */
#define NV_AUDNOTE_RM_NEXT_INSTANCE           ( 8*32+15):( 8*32+ 0) /* RWXUF */
#define NV_AUDNOTE_RM_STATE                   ( 8*32+31):( 8*32+16) /* RWXVF */
#define NV_AUDNOTE_RM_VOLUME_CHANNEL_1        ( 9*32+15):( 9*32+ 0) /* RWXUF */
#define NV_AUDNOTE_RM_VOLUME_CHANNEL_0        ( 9*32+31):( 9*32+16) /* RWXUF */
#define NV_AUDNOTE_SU_STATE                   (10*32+31):(10*32+16) /* RWXVF */
#define NV_AUDNOTE_SU_DMA_INSTANCE            (11*32+15):(11*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_NOTIFY_INSTANCE         (11*32+31):(11*32+16) /* RWXUF */
#define NV_AUDNOTE_SU_START_TIME_LOW          (12*32+15):(12*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_STOP_TIME_LOW           (12*32+31):(12*32+16) /* RWXUF */
#define NV_AUDNOTE_SU_START_TIME_HIGH         (13*32+31):(13*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_STOP_TIME_HIGH          (14*32+31):(14*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_VIBRATO_TREMOLO_TIME_LO (15*32+15):(15*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_RELEASE_TIME_LOW        (15*32+31):(15*32+16) /* RWXUF */
#define NV_AUDNOTE_SU_VIBRATO_TREMOLO_TIME_HI (16*32+31):(16*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_RELEASE_TIME_HIGH       (17*32+31):(17*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_VOLUME_CHANNEL_1        (18*32+15):(18*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_VOLUME_CHANNEL_0        (18*32+31):(18*32+16) /* RWXUF */
#define NV_AUDNOTE_SU_POSITION                (19*32+31):(19*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_POSITION_INC            (20*32+31):(20*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_LOOP_START_POSITION     (21*32+31):(21*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_LOOP_LAST_SAMPLE_PLUS1  (22*32+31):(22*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_LAST_SAMPLE_PLUS1       (23*32+31):(23*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_ATTACK_RATE             (24*32+15):(24*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_DECAY_RATE              (24*32+31):(24*32+16) /* RWXUF */
#define NV_AUDNOTE_SU_RELEASE_RATE            (25*32+15):(25*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_SUSTAIN_RATE            (25*32+31):(25*32+16) /* RWXUF */
#define NV_AUDNOTE_SU_SUSTAIN_LEVEL           (26*32+15):(26*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_PORTAMENTO_RATE         (26*32+31):(26*32+16) /* RWXUF */
#define NV_AUDNOTE_SU_VIBRATO_DEPTH           (27*32+15):(27*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_VIBRATO_TREMOLO_ATTACK  (27*32+31):(27*32+16) /* RWXUF */
#define NV_AUDNOTE_SU_VIBRATO_POSITION_INC    (28*32+15):(28*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_TREMOLO_POSITION_INC    (28*32+31):(28*32+16) /* RWXUF */
#define NV_AUDNOTE_SU_TREMOLO_DEPTH           (29*32+15):(29*32+ 0) /* RWXUF */
#define NV_AUDNOTE_SU_TREMOLO_OFFSET          (29*32+31):(29*32+16) /* RWXUF */
#define NV_AUDNOTE_AE_INTR_MIXING             ( 0*32+16):( 0*32+16) /* RWXVF */
#define NV_AUDNOTE_AE_INTR_VOLUME             ( 0*32+17):( 0*32+17) /* RWXVF */
#define NV_AUDNOTE_AE_INTR_NOTIFY             ( 0*32+20):( 0*32+20) /* RWXVF */
#define NV_AUDNOTE_AE_IN_USE                  ( 0*32+24):( 0*32+24) /* RWXVF */
#define NV_AUDNOTE_RM_INTR_MIXING             ( 8*32+16):( 8*32+16) /* RWXVF */
#define NV_AUDNOTE_RM_INTR_VOLUME             ( 8*32+17):( 8*32+17) /* RWXVF */
#define NV_AUDNOTE_RM_INTR_NOTIFY             ( 8*32+20):( 8*32+20) /* RWXVF */
#define NV_AUDNOTE_SU_OFFSET                  (10*32+17):(10*32+16) /* RWXVF */
#define NV_AUDNOTE_SU_IN_USE                  (10*32+24):(10*32+24) /* RWXVF */
#define NV_AUDNOTE_SU_NOTIFY                  (10*32+26):(10*32+26) /* RWXVF */
#define NV_AUDNOTE_SU_NOTIFY_DMA_WRITE                   0x00000000 /* RW--V */
#define NV_AUDNOTE_SU_NOTIFY_INTERRUPT                   0x00000001 /* RW--V */
#define NV_AUDNOTE_SU_FORMAT                  (10*32+29):(10*32+28) /* RWXVF */
#define NV_AUDNOTE_SU_FORMAT_LINEAR                      0x00000000 /* RW--V */
#define NV_AUDNOTE_SU_FORMAT_ULAW                        0x00000001 /* RW--V */
#define NV_AUDNOTE_SU_FORMAT_ALAW                        0x00000002 /* RW--V */
#define NV_AUDNOTE_SU_FORMAT_OFFSET8                     0x00000003 /* RW--V */
#define NV_AUDNOTE_SU_CHANNEL                 (10*32+30):(10*32+30) /* RWXVF */
#define NV_AUDNOTE_SU_CHANNEL_MONO                       0x00000000 /* RW--V */
#define NV_AUDNOTE_SU_CHANNEL_STEREO                     0x00000001 /* RW--V */
#define NV_AUDNOTE_SU_PDFB                    (10*32+31):(10*32+31) /* RWXVF */
#endif /* _NV_REF_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nv4_ref.h ===
/* NVidia Corporation */ 
/* basis: nv4 manuals 
built on Thu Mar  5 04:04:41 PST 1998*/

#ifndef _NV_REG_H_
#define _NV_REG_H_


/* dev_bus.ref */
#define NV_SPACE                              0x01FFFFFF:0x00000000 /* RW--D */
/* dev_bus.ref */
#define NV_MSPACE                             0x00FFFFFF:0x00000000 /* RW--D */
/* dev_bus.ref */
#define NV_RSPACE                             0x00FFFFFF:0x00000000 /* RW--D */
/* dev_bus.ref */
#define NV_CONFIG                             0x000000FF:0x00000000 /* RW--D */
#define NV_CONFIG_PCI_NV_0                               0x00000000 /* R--4R */
#define NV_CONFIG_PCI_NV_0__ALIAS_1                NV_PBUS_PCI_NV_0 /*       */
#define NV_CONFIG_PCI_NV_1                               0x00000004 /* RW-4R */
#define NV_CONFIG_PCI_NV_1__ALIAS_1                NV_PBUS_PCI_NV_1 /*       */
#define NV_CONFIG_PCI_NV_2                               0x00000008 /* R--4R */
#define NV_CONFIG_PCI_NV_2__ALIAS_1                NV_PBUS_PCI_NV_2 /*       */
#define NV_CONFIG_PCI_NV_3                               0x0000000C /* RW-4R */
#define NV_CONFIG_PCI_NV_3__ALIAS_1                NV_PBUS_PCI_NV_3 /*       */
#define NV_CONFIG_PCI_NV_4                               0x00000010 /* RW-4R */
#define NV_CONFIG_PCI_NV_4__ALIAS_1                NV_PBUS_PCI_NV_4 /*       */
#define NV_CONFIG_PCI_NV_5                               0x00000014 /* RW-4R */
#define NV_CONFIG_PCI_NV_5__ALIAS_1                NV_PBUS_PCI_NV_5 /*       */
#define NV_CONFIG_PCI_NV_6(i)                    (0x00000018+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_NV_6__SIZE_1                                5 /*       */
#define NV_CONFIG_PCI_NV_6__ALIAS_1                NV_PBUS_PCI_NV_6 /*       */
#define NV_CONFIG_PCI_NV_11                              0x0000002C /* R--4R */
#define NV_CONFIG_PCI_NV_11__ALIAS_1              NV_PBUS_PCI_NV_11 /*       */
#define NV_CONFIG_PCI_NV_12                              0x00000030 /* RW-4R */
#define NV_CONFIG_PCI_NV_12__ALIAS_1              NV_PBUS_PCI_NV_12 /*       */
#define NV_CONFIG_PCI_NV_13                              0x00000034 /* RW-4R */
#define NV_CONFIG_PCI_NV_13__ALIAS_1              NV_PBUS_PCI_NV_13 /*       */
#define NV_CONFIG_PCI_NV_14                              0x00000038 /* R--4A */
#define NV_CONFIG_PCI_NV_14__ALIAS_1              NV_PBUS_PCI_NV_14 /*       */
#define NV_CONFIG_PCI_NV_15                              0x0000003C /* RW-4R */
#define NV_CONFIG_PCI_NV_15__ALIAS_1              NV_PBUS_PCI_NV_15 /*       */
#define NV_CONFIG_PCI_NV_16                              0x00000040 /* RW-4R */
#define NV_CONFIG_PCI_NV_16__ALIAS_1              NV_PBUS_PCI_NV_16 /*       */
#define NV_CONFIG_PCI_NV_17                              0x00000044 /* RW-4R */
#define NV_CONFIG_PCI_NV_17__ALIAS_1              NV_PBUS_PCI_NV_17 /*       */
#define NV_CONFIG_PCI_NV_18                              0x00000048 /* RW-4R */
#define NV_CONFIG_PCI_NV_18__ALIAS_1              NV_PBUS_PCI_NV_18 /*       */
#define NV_CONFIG_PCI_NV_19                              0x0000004C /* RW-4R */
#define NV_CONFIG_PCI_NV_19__ALIAS_1              NV_PBUS_PCI_NV_19 /*       */
#define NV_CONFIG_PCI_NV_20                              0x00000050 /* RW-4R */
#define NV_CONFIG_PCI_NV_20__ALIAS_1              NV_PBUS_PCI_NV_20 /*       */
#define NV_CONFIG_PCI_NV_21                              0x00000054 /* RW-4R */
#define NV_CONFIG_PCI_NV_21__ALIAS_1              NV_PBUS_PCI_NV_21 /*       */
#define NV_CONFIG_PCI_NV_22                              0x00000058 /* RW-4R */
#define NV_CONFIG_PCI_NV_22__ALIAS_1              NV_PBUS_PCI_NV_22 /*       */
#define NV_CONFIG_PCI_NV_23                              0x0000005C /* RW-4A */
#define NV_CONFIG_PCI_NV_23__ALIAS_1              NV_PBUS_PCI_NV_23 /*       */
#define NV_CONFIG_PCI_NV_24                              0x00000060 /* RW-4R */
#define NV_CONFIG_PCI_NV_24__ALIAS_1              NV_PBUS_PCI_NV_24 /*       */
#define NV_CONFIG_PCI_NV_25                              0x00000064 /* RW-4R */
#define NV_CONFIG_PCI_NV_25__ALIAS_1              NV_PBUS_PCI_NV_25 /*       */
#define NV_CONFIG_PCI_NV_26(i)                   (0x00000068+(i)*4) /* R--4A */
#define NV_CONFIG_PCI_NV_26__SIZE_1                              38 /*       */
#define NV_CONFIG_PCI_NV_26__ALIAS_1              NV_PBUS_PCI_NV_25 /*       */
/* dev_bus.ref */
/* dev_bus.ref */
/* dev_bus.ref */
#define NV_PRMIO_RMA_ID                                  0x00007100 /* R--4R */
#define NV_PRMIO_RMA_ID_CODE                                   31:0 /* C--UF */
#define NV_PRMIO_RMA_ID_CODE_VALID                       0x2B16D065 /* C---V */
#define NV_PRMIO_RMA_PTR                                 0x00007104 /* RW-4R */
#define NV_PRMIO_RMA_PTR_ADDRESS                               24:2 /* RWXUF */
#define NV_PRMIO_RMA_DATA                                0x00007108 /* RW-4R */
#define NV_PRMIO_RMA_DATA_PORT                                 31:0 /* RWXUF */
#define NV_PRMIO_RMA_DATA32                              0x0000710C /* RW-4R */
#define NV_PRMIO_RMA_DATA32_BYTE2                             23:16 /* RWXUF */
#define NV_PRMIO_RMA_DATA32_BYTE1                              15:8 /* RWXUF */
#define NV_PRMIO_RMA_DATA32_BYTE0                               7:0 /* RWXUF */
/* dev_bus.ref */
#define NV_EXPROM                             0x0000FFFF:0x00000000 /* R---D */
#define NV_EXPROM_BIOS_ROM008(i)                   (0x00000000+(i)) /* RW-1A */
#define NV_EXPROM_BIOS_ROM008__SIZE_1                         65536 /*       */
#define NV_EXPROM_BIOS_ROM008_VALUE                             7:0 /* RW-VF */
#define NV_EXPROM_BIOS_ROM016(i)                 (0x00000000+(i)*2) /* RW-2A */
#define NV_EXPROM_BIOS_ROM016__SIZE_1                         32768 /*       */
#define NV_EXPROM_BIOS_ROM016_VALUE                            15:0 /* RW-VF */
#define NV_EXPROM_BIOS_ROM032(i)                 (0x00000000+(i)*4) /* RW-4A */
#define NV_EXPROM_BIOS_ROM032__SIZE_1                         16384 /*       */
#define NV_EXPROM_BIOS_ROM032_VALUE                            31:0 /* RW-VF */
/* dev_bus.ref */
#define NV_MEMORY                             0xFFFFFFFF:0x00000000 /* RW--D */
/* dev_realmode.ref */
/* dev_bus.ref */
#define NV_IO                                 0xFFFFFFFF:0x00000000 /* RW--D */
/* dev_dac.ref */
#define NV_PRAMDAC                            0x00680FFF:0x00680300 /* RW--D */
#define NV_PRAMDAC_CU_START_POS                          0x00680300 /* RW-4R */
#define NV_PRAMDAC_CU_START_POS_X                              11:0 /* RWXSF */
#define NV_PRAMDAC_CU_START_POS_Y                             27:16 /* RWXSF */
#define NV_PRAMDAC_NVPLL_COEFF                           0x00680500 /* RW-4R */
#define NV_PRAMDAC_NVPLL_COEFF_MDIV                             7:0 /* RWIUF */
#define NV_PRAMDAC_NVPLL_COEFF_NDIV                            15:8 /* RWIUF */
#define NV_PRAMDAC_NVPLL_COEFF_PDIV                           18:16 /* RWIVF */
#define NV_PRAMDAC_MPLL_COEFF                            0x00680504 /* RW-4R */
#define NV_PRAMDAC_MPLL_COEFF_MDIV                              7:0 /* RWIUF */
#define NV_PRAMDAC_MPLL_COEFF_NDIV                             15:8 /* RWIUF */
#define NV_PRAMDAC_MPLL_COEFF_PDIV                            18:16 /* RWIVF */
#define NV_PRAMDAC_VPLL_COEFF                            0x00680508 /* RW-4R */
#define NV_PRAMDAC_VPLL_COEFF_MDIV                              7:0 /* RWIUF */
#define NV_PRAMDAC_VPLL_COEFF_NDIV                             15:8 /* RWIUF */
#define NV_PRAMDAC_VPLL_COEFF_PDIV                            18:16 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT                      0x0068050C /* RW-4R */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE                 0:0 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE_XTAL     0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VPLL_SOURCE_VIP      0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_SOURCE                     10:8 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_SOURCE_DEFAULT       0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_SOURCE_PROG_MPLL     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_SOURCE_PROG_VPLL     0x00000002 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_SOURCE_PROG_NVPLL    0x00000004 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_SOURCE_PROG_ALL      0x00000007 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VS_PCLK_TV                17:16 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VS_PCLK_TV_NONE      0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VS_PCLK_TV_VSCLK     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VS_PCLK_TV_PCLK      0x00000002 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VS_PCLK_TV_BOTH      0x00000003 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_TVCLK_SOURCE              20:20 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_TVCLK_SOURCE_EXT     0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_TVCLK_SOURCE_VIP     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_TVCLK_RATIO               24:24 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_TVCLK_RATIO_DB1      0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_TVCLK_RATIO_DB2      0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO                28:28 /* RWIVF */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO_DB1       0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_COEFF_SELECT_VCLK_RATIO_DB2       0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL                     0x00680510 /* RW-4R */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_VALUE                     10:0 /* RWIVF */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_VAL                 0x0000044E /* RWI-V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN                   14:12 /* RWIVF */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_ON           0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_MPLL         0x00000001 /* RWI-V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_VPLL         0x00000002 /* RWI-V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_NVPLL        0x00000004 /* RWI-V */
#define NV_PRAMDAC_PLL_SETUP_CONTROL_PWRDWN_OFF          0x00000007 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER                      0x00680514 /* RW-4R */
#define NV_PRAMDAC_PLL_TEST_COUNTER_NOOFIPCLKS                  9:0 /* -WIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VALUE                      15:0 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE                    16:16 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE_DEASSERTED    0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_ENABLE_ASSERTED      0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_RESET                     20:20 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_RESET_DEASSERTED     0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_RESET_ASSERTED       0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE                    25:24 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_MCLK          0x00000002 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_VCLK          0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_SOURCE_NVCLK         0x00000000 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_PDIV_RST                  28:28 /* RWIVF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_PDIVRST_DEASSERTED   0x00000000 /* RWI-V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_PDIVRST_ASSERTED     0x00000001 /* RW--V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_NVPLL_LOCK                29:29 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_NVPLL_NOTLOCKED      0x00000000 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_NVPLL_LOCKED         0x00000001 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCK                 30:30 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_NOTLOCKED       0x00000000 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_MPLL_LOCKED          0x00000001 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCK                 31:31 /* R--VF */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_NOTLOCKED       0x00000000 /* R---V */
#define NV_PRAMDAC_PLL_TEST_COUNTER_VPLL_LOCKED          0x00000001 /* R---V */
#define NV_PRAMDAC_PALETTE_TEST                          0x00680518 /* RW-4R */
#define NV_PRAMDAC_PALETTE_TEST_BLUE_DATA                       7:0 /* R--VF */
#define NV_PRAMDAC_PALETTE_TEST_GREEN_DATA                     15:8 /* R--VF */
#define NV_PRAMDAC_PALETTE_TEST_RED_DATA                      23:16 /* R--VF */
#define NV_PRAMDAC_PALETTE_TEST_MODE                          24:24 /* RWIVF */
#define NV_PRAMDAC_PALETTE_TEST_MODE_8BIT                0x00000000 /* RWI-V */
#define NV_PRAMDAC_PALETTE_TEST_MODE_24BIT               0x00000001 /* RW--V */
#define NV_PRAMDAC_PALETTE_TEST_ADDRINC                       28:28 /* RWIVF */
#define NV_PRAMDAC_PALETTE_TEST_ADDRINC_READWRITE        0x00000000 /* RWI-V */
#define NV_PRAMDAC_PALETTE_TEST_ADDRINC_WRITEONLY        0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL                       0x00680600 /* RW-4R */
#define NV_PRAMDAC_GENERAL_CONTROL_PIXMIX32_BIT                 0:0 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_PIXMIX32_BIT_24       0x00000001 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_PIXMIX32_BIT_31       0x00000000 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_PIXMIX                       5:4 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_PIXMIX_OFF            0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_PIXMIX_POS            0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_PIXMIX_NEG            0x00000002 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_PIXMIX_ON             0x00000003 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE                    8:8 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE_NOTSEL      0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_VGA_STATE_SEL         0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE                   12:12 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE_NOTSEL       0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE_SEL          0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE_15           0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE_16           0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE_24           0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_ALT_MODE_30           0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL                 16:16 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL_OFF        0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_BLK_PEDSTL_ON         0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_TERMINATION                17:17 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_TERMINATION_37OHM     0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_TERMINATION_75OHM     0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC                        20:20 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC_6BITS             0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_BPC_8BITS             0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP                  24:24 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP_DIS         0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_DAC_SLEEP_EN          0x00000001 /* RW--V */
#define NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK                28:28 /* RWIVF */
#define NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK_EN        0x00000000 /* RWI-V */
#define NV_PRAMDAC_GENERAL_CONTROL_PALETTE_CLK_DIS       0x00000001 /* RW--V */
#define NV_PRAMDAC_PALETTE_RECOVERY                      0x00680604 /* R--4R */
#define NV_PRAMDAC_PALETTE_RECOVERY_ACTIVE_ADDRESS              7:0 /* R--UF */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER                10:8 /* R--VF */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_RED      0x00000001 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_GREEN    0x00000002 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_RGB_POINTER_BLUE     0x00000004 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE                 13:12 /* R--VF */
#define NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE_WRITE      0x00000000 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_DAC_STATE_READ       0x00000003 /* R---V */
#define NV_PRAMDAC_PALETTE_RECOVERY_RED_DATA                  23:16 /* R--VF */
#define NV_PRAMDAC_PALETTE_RECOVERY_GREEN_DATA                31:24 /* R--VF */
#define NV_PRAMDAC_TEST_CONTROL                          0x00680608 /* RW-4R */
#define NV_PRAMDAC_TEST_CONTROL_CRC_RESET                       0:0 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_CRC_RESET_DEASSERTED     0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_RESET_ASSERTED       0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE                      4:4 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE_DEASSERTED    0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_ENABLE_ASSERTED      0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL                     9:8 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_BLUE         0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_GREEN        0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_CRC_CHANNEL_RED          0x00000002 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_TP_INS_EN                     12:12 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_TP_INS_EN_DEASSERTED     0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_TP_INS_EN_ASSERTED       0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC                    16:16 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC_ON            0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_PWRDWN_DAC_OFF           0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_DACTM                         20:20 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_DACTM_NORMAL             0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_DACTM_TEST               0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH1                        24:24 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_TPATH1_CLEAR             0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH1_SET               0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH31                       25:25 /* RWIVF */
#define NV_PRAMDAC_TEST_CONTROL_TPATH31_CLEAR            0x00000000 /* RWI-V */
#define NV_PRAMDAC_TEST_CONTROL_TPATH31_SET              0x00000001 /* RW--V */
#define NV_PRAMDAC_TEST_CONTROL_SENSEB                        28:28 /* R--VF */
#define NV_PRAMDAC_TEST_CONTROL_SENSEB_SOMELO            0x00000000 /* R---V */
#define NV_PRAMDAC_TEST_CONTROL_SENSEB_ALLHI             0x00000001 /* R---V */
#define NV_PRAMDAC_CHECKSUM                              0x0068060C /* R--4R */
#define NV_PRAMDAC_CHECKSUM_VALUE                              23:0 /* R--VF */
#define NV_PRAMDAC_TESTPOINT_DATA                        0x00680610 /* -W-4R */
#define NV_PRAMDAC_TESTPOINT_DATA_RED                           9:0 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_GREEN                       19:10 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_BLUE                        29:20 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_BLACK                       30:30 /* -W-VF */
#define NV_PRAMDAC_TESTPOINT_DATA_NOTBLANK                    31:31 /* -W-VF */
#define NV_PRAMDAC_TV_SETUP                              0x00680700 /* RW-4R */
#define NV_PRAMDAC_TV_SETUP_DEV_TYPE                            0:0 /* RWIVF */
#define NV_PRAMDAC_TV_SETUP_DEV_TYPE_SLAVE               0x00000000 /* RWI-V */
#define NV_PRAMDAC_TV_SETUP_DEV_TYPE_MASTER              0x00000001 /* RW--V */
#define NV_PRAMDAC_TV_SETUP_VS_PIXFMT                           6:4 /* RWIVF */
#define NV_PRAMDAC_TV_SETUP_VS_PIXFMT_555                0x00000000 /* RWI-V */
#define NV_PRAMDAC_TV_SETUP_VS_PIXFMT_565                0x00000001 /* RW--V */
#define NV_PRAMDAC_TV_SETUP_VS_PIXFMT_888                0x00000002 /* RW--V */
#define NV_PRAMDAC_TV_SETUP_VS_PIXFMT_101010             0x00000003 /* RW--V */
#define NV_PRAMDAC_TV_SETUP_VS_PIXFMT_YUV                0x00000004 /* RW--V */
#define NV_PRAMDAC_TV_SETUP_DATA_SRC                            9:8 /* RWIVF */
#define NV_PRAMDAC_TV_SETUP_DATA_SRC_COMP                0x00000000 /* RWI-V */
#define NV_PRAMDAC_TV_SETUP_DATA_SRC_SCALER              0x00000001 /* RW--V */
#define NV_PRAMDAC_TV_SETUP_DATA_SRC_VIP                 0x00000002 /* RW--V */
#define NV_PRAMDAC_TV_SETUP_COMP_SRC                          12:12 /* RWIVF */
#define NV_PRAMDAC_TV_SETUP_COMP_SRC_SCALER              0x00000000 /* RWI-V */
#define NV_PRAMDAC_TV_SETUP_COMP_SRC_NO_SCALER           0x00000001 /* RW--V */
#define NV_PRAMDAC_TV_SETUP_SYNC_POL                          17:16 /* RWIVF */
#define NV_PRAMDAC_TV_SETUP_SYNC_POL_NEG_NONE            0x00000000 /* RWI-V */
#define NV_PRAMDAC_TV_SETUP_SYNC_POL_NEG_HSYNC           0x00000001 /* RW--V */
#define NV_PRAMDAC_TV_SETUP_SYNC_POL_NEG_VSYNC           0x00000002 /* RW--V */
#define NV_PRAMDAC_TV_SETUP_SYNC_POL_NEG_BOTH            0x00000003 /* RW--V */
#define NV_PRAMDAC_TV_SETUP_VIP_VSYNC                         20:20 /* RWIVF */
#define NV_PRAMDAC_TV_SETUP_VIP_VSYNC_LEAD               0x00000000 /* RWI-V */
#define NV_PRAMDAC_TV_SETUP_VIP_VSYNC_TRAIL              0x00000001 /* RW--V */
#define NV_PRAMDAC_TV_SETUP_VIP_DATAPOS                       24:24 /* RWIVF */
#define NV_PRAMDAC_TV_SETUP_VIP_DATAPOS_7_0              0x00000000 /* RWI-V */
#define NV_PRAMDAC_TV_SETUP_VIP_DATAPOS_11_4             0x00000001 /* RW--V */
#define NV_PRAMDAC_TV_SETUP_VIP_FIELD                         28:28 /* RWIVF */
#define NV_PRAMDAC_TV_SETUP_VIP_FIELD_0                  0x00000000 /* RWI-V */
#define NV_PRAMDAC_TV_SETUP_VIP_FIELD_1                  0x00000001 /* RW--V */
#define NV_PRAMDAC_TV_VBLANK_START                       0x00680704 /* RW-4R */
#define NV_PRAMDAC_TV_VBLANK_START_VAL                         10:0 /* RWIVF */
#define NV_PRAMDAC_TV_VBLANK_END                         0x00680708 /* RW-4R */
#define NV_PRAMDAC_TV_VBLANK_END_VAL                           10:0 /* RWIVF */
#define NV_PRAMDAC_TV_HBLANK_START                       0x0068070C /* RW-4R */
#define NV_PRAMDAC_TV_HBLANK_START_VAL                         10:0 /* RWIVF */
#define NV_PRAMDAC_TV_HBLANK_END                         0x00680710 /* RW-4R */
#define NV_PRAMDAC_TV_HBLANK_END_VAL                           10:0 /* RWIVF */
#define NV_PRAMDAC_BLANK_COLOR                           0x00680714 /* RW-4R */
#define NV_PRAMDAC_BLANK_COLOR_VAL                             23:0 /* RWIVF */
#define NV_PRAMDAC_TV_CHECKSUM                           0x00680718 /* RW-4R */
#define NV_PRAMDAC_TV_CHECKSUM_VAL                             23:0 /* R--VF */
#define NV_PRAMDAC_TV_VSYNC                                   28:28 /* R--VF */
#define NV_PRAMDAC_TV_VSYNC_ACTIVE                       0x00000000 /* R---V */
#define NV_PRAMDAC_TV_VSYNC_INACTIVE                     0x00000001 /* R---V */
#define NV_PRAMDAC_TV_TEST_CONTROL                       0x0068071c /* RW-4R */
#define NV_PRAMDAC_TV_TEST_CONTROL_CRC_RESET                    0:0 /* RWIVF */
#define NV_PRAMDAC_TV_TEST_CONTROL_CRC_RESET_DEASSERTED  0x00000000 /* RWI-V */
#define NV_PRAMDAC_TV_TEST_CONTROL_CRC_RESET_ASSERTED    0x00000001 /* RW--V */
#define NV_PRAMDAC_TV_TEST_CONTROL_CRC_ENABLE                   4:4 /* RWIVF */
#define NV_PRAMDAC_TV_TEST_CONTROL_CRC_ENABLE_DEASSERTED 0x00000000 /* RWI-V */
#define NV_PRAMDAC_TV_TEST_CONTROL_CRC_ENABLE_ASSERTED   0x00000001 /* RW--V */
#define NV_PRAMDAC_TV_TEST_CONTROL_CRC_CHANNEL                  9:8 /* RWIVF */
#define NV_PRAMDAC_TV_TEST_CONTROL_CRC_CHANNEL_7_0       0x00000000 /* RWI-V */
#define NV_PRAMDAC_TV_TEST_CONTROL_CRC_CHANNEL_15_8      0x00000001 /* RW--V */
#define NV_PRAMDAC_TV_TEST_CONTROL_CRC_CHANNEL_23_16     0x00000002 /* RW--V */

// Added for NV5 flat panel support
#define NV_PRAMDAC_FP_VDISPLAY_END                       0x00680800 /* RW-4R */
#define NV_PRAMDAC_FP_VDISPLAY_END_VAL                         10:0 /* RWIVF */
#define NV_PRAMDAC_FP_VTOTAL                             0x00680804 /* RW-4R */
#define NV_PRAMDAC_FP_VTOTAL_VAL                               10:0 /* RWIVF */
#define NV_PRAMDAC_FP_VCRTC                              0x00680808 /* RW-4R */
#define NV_PRAMDAC_FP_VCRTC_VAL                                10:0 /* RWIVF */
#define NV_PRAMDAC_FP_VSYNC_START                        0x0068080c /* RW-4R */
#define NV_PRAMDAC_FP_VSYNC_START_VAL                          10:0 /* RWIVF */
#define NV_PRAMDAC_FP_VSYNC_END                          0x00680810 /* RW-4R */
#define NV_PRAMDAC_FP_VSYNC_END_VAL                            10:0 /* RWIVF */
#define NV_PRAMDAC_FP_VVALID_START                       0x00680814 /* RW-4R */
#define NV_PRAMDAC_FP_VVALID_START_VAL                         10:0 /* RWIVF */
#define NV_PRAMDAC_FP_VVALID_END                         0x00680818 /* RW-4R */
#define NV_PRAMDAC_FP_VVALID_END_VAL                           10:0 /* RWIVF */
#define NV_PRAMDAC_FP_HDISPLAY_END                       0x00680820 /* RW-4R */
#define NV_PRAMDAC_FP_HDISPLAY_END_VAL                         10:0 /* RWIVF */
#define NV_PRAMDAC_FP_HTOTAL                             0x00680824 /* RW-4R */
#define NV_PRAMDAC_FP_HTOTAL_VAL                               10:0 /* RWIVF */
#define NV_PRAMDAC_FP_HCRTC                              0x00680828 /* RW-4R */
#define NV_PRAMDAC_FP_HCRTC_VAL                                10:0 /* RWIVF */
#define NV_PRAMDAC_FP_HSYNC_START                        0x0068082c /* RW-4R */
#define NV_PRAMDAC_FP_HSYNC_START_VAL                          10:0 /* RWIVF */
#define NV_PRAMDAC_FP_HSYNC_END                          0x00680830 /* RW-4R */
#define NV_PRAMDAC_FP_HSYNC_END_VAL                            10:0 /* RWIVF */
#define NV_PRAMDAC_FP_HVALID_START                       0x00680834 /* RW-4R */
#define NV_PRAMDAC_FP_HVALID_START_VAL                         10:0 /* RWIVF */
#define NV_PRAMDAC_FP_HVALID_END                         0x00680838 /* RW-4R */
#define NV_PRAMDAC_FP_HVALID_END_VAL                           10:0 /* RWIVF */
#define NV_PRAMDAC_FP_CHECKSUM                           0x00680840 /* RW-4R */
#define NV_PRAMDAC_FP_CHECKSUM_VAL                             23:0 /* R--VF */
#define NV_PRAMDAC_FP_CHECKSUM_STATUS                         24:24 /* R--VF */
#define NV_PRAMDAC_FP_CHECKSUM_STATUS_CAPTURED           0x00000001 /* R---V */
#define NV_PRAMDAC_FP_CHECKSUM_STATUS_WAITING            0x00000000 /* R---V */
#define NV_PRAMDAC_FP_VSYNC                                   28:28 /* R--VF */
#define NV_PRAMDAC_FP_VSYNC_LOW                          0x00000000 /* R---V */
#define NV_PRAMDAC_FP_VSYNC_HIGH                         0x00000001 /* R---V */
#define NV_PRAMDAC_FP_TEST_CONTROL                       0x00680844 /* RW-4R */
#define NV_PRAMDAC_FP_TEST_CONTROL_CRC_RESET                    0:0 /* RWIVF */
#define NV_PRAMDAC_FP_TEST_CONTROL_CRC_RESET_DEASSERTED  0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_TEST_CONTROL_CRC_RESET_ASSERTED    0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_TEST_CONTROL_CRC_ENABLE                   4:4 /* RWIVF */
#define NV_PRAMDAC_FP_TEST_CONTROL_CRC_ENABLE_DEASSERTED 0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_TEST_CONTROL_CRC_ENABLE_ASSERTED   0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_TEST_CONTROL_CRC_CHANNEL                  9:8 /* RWIVF */
#define NV_PRAMDAC_FP_TEST_CONTROL_CRC_CHANNEL_7_0       0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_TEST_CONTROL_CRC_CHANNEL_15_8      0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_TEST_CONTROL_CRC_CHANNEL_23_16     0x00000002 /* RW--V */
#define NV_PRAMDAC_FP_TEST_CONTROL_CRC_CAPTURE                10:10 /* RWIVF */
#define NV_PRAMDAC_FP_TEST_CONTROL_CRC_CAPTURE_ALWAYS    0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_TEST_CONTROL_CRC_CAPTURE_ONE       0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL                         0x00680848 /* RW-4R */
#define NV_PRAMDAC_FP_TG_CONTROL_VSYNC                          1:0 /* RWIVF */
#define NV_PRAMDAC_FP_TG_CONTROL_VSYNC_NEG               0x00000000 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_VSYNC_POS               0x00000001 /* RWI-V */
#define NV_PRAMDAC_FP_TG_CONTROL_VSYNC_DISABLE           0x00000002 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_VSYNC_RSVD              0x00000003 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_HSYNC                          5:4 /* RWIVF */
#define NV_PRAMDAC_FP_TG_CONTROL_HSYNC_NEG               0x00000000 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_HSYNC_POS               0x00000001 /* RWI-V */
#define NV_PRAMDAC_FP_TG_CONTROL_HSYNC_DISABLE           0x00000002 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_HSYNC_RSVD              0x00000003 /* RWI-V */
#define NV_PRAMDAC_FP_TG_CONTROL_MODE                           9:8 /* RWIVF */
#define NV_PRAMDAC_FP_TG_CONTROL_MODE_SCALE              0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_TG_CONTROL_MODE_CENTER             0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_MODE_NATIVE             0x00000002 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_CENTER                       13:12 /* RWIVF */
#define NV_PRAMDAC_FP_TG_CONTROL_CENTER_NONE             0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_TG_CONTROL_CENTER_HORIZ            0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_CENTER_VERT             0x00000002 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_CENTER_BOTH             0x00000003 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_NATIVE                       17:16 /* RWIVF */
#define NV_PRAMDAC_FP_TG_CONTROL_NATIVE_NONE             0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_TG_CONTROL_NATIVE_HORIZ            0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_NATIVE_VERT             0x00000002 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_NATIVE_BOTH             0x00000003 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_READ                         20:20 /* RWIVF */
#define NV_PRAMDAC_FP_TG_CONTROL_READ_ACTUAL             0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_TG_CONTROL_READ_PROG               0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_WIDTH                        24:24 /* RWIVF */
#define NV_PRAMDAC_FP_TG_CONTROL_WIDTH_24                0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_TG_CONTROL_WIDTH_12                0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_DISPEN                       29:28 /* RWIVF */
#define NV_PRAMDAC_FP_TG_CONTROL_DISPEN_NEG              0x00000000 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_DISPEN_POS              0x00000001 /* RWI-V */
#define NV_PRAMDAC_FP_TG_CONTROL_DISPEN_DISABLE          0x00000002 /* RW--V */
#define NV_PRAMDAC_FP_TG_CONTROL_DISPEN_RSVD             0x00000003 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_0                            0x00680880 /* RW-4R */
#define NV_PRAMDAC_FP_DEBUG_0_XSCALE                            0:0 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_0_XSCALE_DISABLE             0x00000000 /* RW--V */
#define NV_PRAMDAC_FP_DEBUG_0_XSCALE_ENABLE              0x00000001 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_0_YSCALE                            4:4 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_0_YSCALE_DISABLE             0x00000000 /* RW--V */
#define NV_PRAMDAC_FP_DEBUG_0_YSCALE_ENABLE              0x00000001 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_0_XINTERP                           8:8 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_0_XINTERP_TRUNCATE           0x00000000 /* RW--V */
#define NV_PRAMDAC_FP_DEBUG_0_XINTERP_BILINEAR           0x00000001 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_0_YINTERP                         12:12 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_0_YINTERP_TRUNCATE           0x00000000 /* RW--V */
#define NV_PRAMDAC_FP_DEBUG_0_YINTERP_BILINEAR           0x00000001 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_0_VCNTR                           17:16 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_0_TEST_NONE                  0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_0_TEST_VCNTR                 0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_DEBUG_0_TEST_NEWPIX                0x00000002 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_0_TEST_BOTH                  0x00000003 /* RW--V */
#define NV_PRAMDAC_FP_DEBUG_0_XWEIGHT                         20:20 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_0_XWEIGHT_TRUNCATE           0x00000000 /* RW--V */
#define NV_PRAMDAC_FP_DEBUG_0_XWEIGHT_ROUND              0x00000001 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_0_YWEIGHT                         24:24 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_0_YWEIGHT_TRUNCATE           0x00000000 /* RW--V */
#define NV_PRAMDAC_FP_DEBUG_0_YWEIGHT_ROUND              0x00000001 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_0_PWRDOWN                         28:28 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_NONE               0x00000000 /* RW--V */
#define NV_PRAMDAC_FP_DEBUG_0_PWRDOWN_FPCLK              0x00000001 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_1                            0x00680884 /* RW-4R */
#define NV_PRAMDAC_FP_DEBUG_1_XSCALE_VALUE                     11:0 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_1_XSCALE_VALUE_ZERO          0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_1_XSCALE_TESTMODE                 12:12 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_1_XSCALE_TESTMODE_DISABLE    0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_1_XSCALE_TESTMODE_ENABLE     0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_DEBUG_1_YSCALE_VALUE                    27:16 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_1_YSCALE_VALUE_ZERO          0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_1_YSCALE_TESTMODE                 28:28 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_1_YSCALE_TESTMODE_DISABLE    0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_1_YSCALE_TESTMODE_ENABLE     0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_DEBUG_2                            0x00680888 /* RW-4R */
#define NV_PRAMDAC_FP_DEBUG_2_HTOTAL_VALUE                     10:0 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_2_HTOTAL_TESTMODE                 12:12 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_2_HTOTAL_TESTMODE_DISABLE    0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_2_HTOTAL_TESTMODE_ENABLE     0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_DEBUG_2_VTOTAL_VALUE                    25:16 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_2_VTOTAL_TESTMODE                 28:28 /* RWIVF */
#define NV_PRAMDAC_FP_DEBUG_2_VTOTAL_TESTMODE_DISABLE    0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_DEBUG_2_VTOTAL_TESTMODE_ENABLE     0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_DEBUG_3                            0x0068088c /* R--4R */
#define NV_PRAMDAC_FP_DEBUG_3_XSTEPSIZE                        12:0 /* R--VF */
#define NV_PRAMDAC_FP_DEBUG_3_YSTEPSIZE                       28:16 /* R--VF */
#define NV_PRAMDAC_FP_RAM_CONTROL                        0x006808A0 /* RW-4R */
#define NV_PRAMDAC_FP_RAM_CONTROL_ADDRESS                       8:0 /* RW-VF */
#define NV_PRAMDAC_FP_RAM_CONTROL_TESTMODE                    16:16 /* RWIVF */
#define NV_PRAMDAC_FP_RAM_CONTROL_TESTMODE_DISABLE       0x00000000 /* RWI-V */
#define NV_PRAMDAC_FP_RAM_CONTROL_TESTMODE_ENABLE        0x00000001 /* RW--V */
#define NV_PRAMDAC_FP_RAM_DATA_0                         0x006808A4 /* RWI4R */
#define NV_PRAMDAC_FP_RAM_DATA_0_VAL                           31:0 /* RW--F */
#define NV_PRAMDAC_FP_RAM_DATA_1                         0x006808A8 /* RWI4R */
#define NV_PRAMDAC_FP_RAM_DATA_1_VAL                           31:0 /* RW--F */
#define NV_PRAMDAC_FP_RAM_DATA_2                         0x006808AC /* RWI4R */
#define NV_PRAMDAC_FP_RAM_DATA_2_VAL                            7:0 /* RW--F */


/* dev_dac.ref */
#define NV_USER_DAC                           0x00681FFF:0x00681200 /* RW--D */
#define NV_USER_DAC_PIXEL_MASK                           0x006813C6 /* RWI1R */
#define NV_USER_DAC_PIXEL_MASK_VALUE                            7:0 /* RWIVF */
#define NV_USER_DAC_PIXEL_MASK_MASK                      0x000000FF /* RWI-V */
#define NV_USER_DAC_READ_MODE_ADDRESS                    0x006813C7 /* RW-1R */
#define NV_USER_DAC_READ_MODE_ADDRESS_VALUE                     7:0 /* RW-VF */
#define NV_USER_DAC_READ_MODE_ADDRESS_WO_VALUE                  7:0 /* -W-VF */
#define NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE                  1:0 /* R--VF */
#define NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE_WRITE     0x00000000 /* R---V */
#define NV_USER_DAC_READ_MODE_ADDRESS_RW_STATE_READ      0x00000003 /* R---V */
#define NV_USER_DAC_WRITE_MODE_ADDRESS                   0x006813C8 /* RW-1R */
#define NV_USER_DAC_WRITE_MODE_ADDRESS_VALUE                    7:0 /* RW-VF */
#define NV_USER_DAC_PALETTE_DATA                         0x006813C9 /* RW-1R */
#define NV_USER_DAC_PALETTE_DATA_VALUE                          7:0 /* RW-VF */
/* dev_dac.ref */
#define NV_PDAC                               0x00680FFF:0x00680000 /* RW--D */
/* dev_dac.ref */
#define NV_PRMDIO                             0x00681FFF:0x00681000 /* RW--D */
/* dev_realmode.ref */
#define NV_IO_MPU_401_DATA                               0x00000330 /* R--1R */
#define NV_IO_MPU_401_DATA__ALIAS_1                      0x00000300 /* R--1R */
#define NV_IO_MPU_401_DATA__ALIAS_2                      0x00000230 /* R--1R */
#define NV_IO_MPU_401_DATA_VALUE                                7:0 /* R--VF */
#define NV_IO_MPU_401_DATA_ACK                           0x000000FE /* R---V */
#define NV_IO_MPU_401_STATUS                             0x00000331 /* R--1R */
#define NV_IO_MPU_401_STATUS__ALIAS_1                    0x00000301 /* R--1R */
#define NV_IO_MPU_401_STATUS__ALIAS_2                    0x00000231 /* R--1R */
#define NV_IO_MPU_401_STATUS_DATA                               5:0 /* R--VF */
#define NV_IO_MPU_401_STATUS_WRITE                              6:6 /* R--VF */
#define NV_IO_MPU_401_STATUS_WRITE_EMPTY                 0x00000000 /* R---V */
#define NV_IO_MPU_401_STATUS_WRITE_FULL                  0x00000001 /* R---V */
#define NV_IO_MPU_401_STATUS_READ                               7:7 /* R--VF */
#define NV_IO_MPU_401_STATUS_READ_FULL                   0x00000000 /* R---V */
#define NV_IO_MPU_401_STATUS_READ_EMPTY                  0x00000001 /* R---V */
#define NV_IO_MPU_401_COM                                0x00000331 /* -W-1R */
#define NV_IO_MPU_401_COM__ALIAS_1                       0x00000301 /* -W-1R */
#define NV_IO_MPU_401_COM__ALIAS_2                       0x00000231 /* -W-1R */
#define NV_IO_MPU_401_COM_UART_MODE                             7:0 /* -WIVF */
#define NV_IO_MPU_401_COM_UART_MODE_COMPLEX              0x000000ff /* -WI-V */
#define NV_IO_MPU_401_COM_UART_MODE_SIMPLE               0x0000003f /* -W--V */
/* dev_master.ref */
#define NV_PMC                                0x00000FFF:0x00000000 /* RW--D */
#define NV_PMC_BOOT_0                                    0x00000000 /* R--4R */
#define NV_PMC_BOOT_0_MINOR_REVISION                            3:0 /* C--VF */
#define NV_PMC_BOOT_0_MINOR_REVISION_0                   0x00000000 /* C---V */
#define NV_PMC_BOOT_0_MAJOR_REVISION                            7:4 /* C--VF */
#define NV_PMC_BOOT_0_MAJOR_REVISION_A                   0x00000000 /* C---V */
#define NV_PMC_BOOT_0_MAJOR_REVISION_B                   0x00000001 /* ----V */
#define NV_PMC_BOOT_0_IMPLEMENTATION                           11:8 /* C--VF */
#define NV_PMC_BOOT_0_IMPLEMENTATION_NV4_0               0x00000000 /* C---V */
#define NV_PMC_BOOT_0_ARCHITECTURE                            15:12 /* C--VF */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV0                   0x00000000 /* ----V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV1                   0x00000001 /* ----V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV2                   0x00000002 /* ----V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV3                   0x00000003 /* ----V */
#define NV_PMC_BOOT_0_ARCHITECTURE_NV4                   0x00000004 /* C---V */
#define NV_PMC_BOOT_0_FIB_REVISION                            19:16 /* C--VF */
#define NV_PMC_BOOT_0_FIB_REVISION_0                     0x00000000 /* C---V */
#define NV_PMC_BOOT_0_MASK_REVISION                           23:20 /* C--VF */
#define NV_PMC_BOOT_0_MASK_REVISION_A                    0x00000000 /* C---V */
#define NV_PMC_BOOT_0_MASK_REVISION_B                    0x00000001 /* ----V */
#define NV_PMC_BOOT_0_MANUFACTURER                            27:24 /* C--UF */
#define NV_PMC_BOOT_0_MANUFACTURER_NVIDIA                0x00000000 /* C---V */
#define NV_PMC_BOOT_0_FOUNDRY                                 31:28 /* C--VF */
#define NV_PMC_BOOT_0_FOUNDRY_SGS                        0x00000000 /* ----V */
#define NV_PMC_BOOT_0_FOUNDRY_HELIOS                     0x00000001 /* ----V */
#define NV_PMC_BOOT_0_FOUNDRY_TSMC                       0x00000002 /* C---V */
#define NV_PMC_INTR_0                                    0x00000100 /* RW-4R */
#define NV_PMC_INTR_0_PMEDIA                                    4:4 /* R--VF */
#define NV_PMC_INTR_0_PMEDIA_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PMEDIA_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PFIFO                                     8:8 /* R--VF */
#define NV_PMC_INTR_0_PFIFO_NOT_PENDING                  0x00000000 /* R---V */
#define NV_PMC_INTR_0_PFIFO_PENDING                      0x00000001 /* R---V */
#define NV_PMC_INTR_0_PGRAPH                                  12:12 /* R--VF */
#define NV_PMC_INTR_0_PGRAPH_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PGRAPH_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PVIDEO                                  16:16 /* R--VF */
#define NV_PMC_INTR_0_PVIDEO_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PVIDEO_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PTIMER                                  20:20 /* R--VF */
#define NV_PMC_INTR_0_PTIMER_NOT_PENDING                 0x00000000 /* R---V */
#define NV_PMC_INTR_0_PTIMER_PENDING                     0x00000001 /* R---V */
#define NV_PMC_INTR_0_PCRTC                                   24:24 /* R--VF */
#define NV_PMC_INTR_0_PCRTC_NOT_PENDING                  0x00000000 /* R---V */
#define NV_PMC_INTR_0_PCRTC_PENDING                      0x00000001 /* R---V */
#define NV_PMC_INTR_0_PBUS                                    28:28 /* R--VF */
#define NV_PMC_INTR_0_PBUS_NOT_PENDING                   0x00000000 /* R---V */
#define NV_PMC_INTR_0_PBUS_PENDING                       0x00000001 /* R---V */
#define NV_PMC_INTR_0_SOFTWARE                                31:31 /* RWIVF */
#define NV_PMC_INTR_0_SOFTWARE_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PMC_INTR_0_SOFTWARE_PENDING                   0x00000001 /* RW--V */
#define NV_PMC_INTR_EN_0                                 0x00000140 /* RW-4R */
#define NV_PMC_INTR_EN_0_INTA                                   1:0 /* RWIVF */
#define NV_PMC_INTR_EN_0_INTA_DISABLED                   0x00000000 /* RWI-V */
#define NV_PMC_INTR_EN_0_INTA_HARDWARE                   0x00000001 /* RW--V */
#define NV_PMC_INTR_EN_0_INTA_SOFTWARE                   0x00000002 /* RW--V */
#define NV_PMC_INTR_READ_0                               0x00000160 /* R--4R */
#define NV_PMC_INTR_READ_0_INTA                                 0:0 /* R--VF */
#define NV_PMC_INTR_READ_0_INTA_LOW                      0x00000000 /* R---V */
#define NV_PMC_INTR_READ_0_INTA_HIGH                     0x00000001 /* R---V */
#define NV_PMC_ENABLE                                    0x00000200 /* RW-4R */
#define NV_PMC_ENABLE_PMEDIA                                    4:4 /* RWIVF */
#define NV_PMC_ENABLE_PMEDIA_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PMEDIA_ENABLED                     0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PFIFO                                     8:8 /* RWIVF */
#define NV_PMC_ENABLE_PFIFO_DISABLED                     0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PFIFO_ENABLED                      0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PGRAPH                                  12:12 /* RWIVF */
#define NV_PMC_ENABLE_PGRAPH_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PGRAPH_ENABLED                     0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PPMI                                    16:16 /* RWIVF */
#define NV_PMC_ENABLE_PPMI_DISABLED                      0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PPMI_ENABLED                       0x00000001 /* RW--V */
#define NV_PMC_ENABLE_PFB                                     20:20 /* RWIVF */
#define NV_PMC_ENABLE_PFB_DISABLED                       0x00000000 /* RW--V */
#define NV_PMC_ENABLE_PFB_ENABLED                        0x00000001 /* RWI-V */
#define NV_PMC_ENABLE_PCRTC                                   24:24 /* RWIVF */
#define NV_PMC_ENABLE_PCRTC_DISABLED                     0x00000000 /* RW--V */
#define NV_PMC_ENABLE_PCRTC_ENABLED                      0x00000001 /* RWI-V */
#define NV_PMC_ENABLE_PVIDEO                                  28:28 /* RWIVF */
#define NV_PMC_ENABLE_PVIDEO_DISABLED                    0x00000000 /* RWI-V */
#define NV_PMC_ENABLE_PVIDEO_ENABLED                     0x00000001 /* RW--V */
/* dev_bus.ref */
#define NV_PBUS                               0x00001FFF:0x00001000 /* RW--D */
#define NV_PBUS_DEBUG_0                                  0x00001080 /* RW-4R */
#define NV_PBUS_DEBUG_0_FBIO_SCLK_DELAY                         3:0 /* RWIUF */
#define NV_PBUS_DEBUG_0_FBIO_SCLK_DELAY_8                0x00000008 /* RWI-V */
#define NV_PBUS_DEBUG_0_FBIO_SCLK_PC                            4:4 /* RWIVF */
#define NV_PBUS_DEBUG_0_FBIO_SCLK_PC_NORMAL              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_FBIO_SCLK_PC_OVERRIDE            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_0_FBIO_FBCLK_DELAY                       11:8 /* RWIUF */
#define NV_PBUS_DEBUG_0_FBIO_FBCLK_DELAY_8               0x00000008 /* RWI-V */
#define NV_PBUS_DEBUG_0_FBIO_FBCLK_PC                         12:12 /* RWIVF */
#define NV_PBUS_DEBUG_0_FBIO_FBCLK_PC_NORMAL             0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_FBIO_FBCLK_PC_OVERRIDE           0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_0_FBIO_ACLK_DELAY                       19:16 /* RWIUF */
#define NV_PBUS_DEBUG_0_FBIO_ACLK_DELAY_8                0x00000008 /* RWI-V */
#define NV_PBUS_DEBUG_0_FBIO_ACLK_PC                          20:20 /* RWIVF */
#define NV_PBUS_DEBUG_0_FBIO_ACLK_PC_NORMAL              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_FBIO_ACLK_PC_OVERRIDE            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_0_FBIO_RCLK_DELAY                       27:24 /* RWIUF */
#define NV_PBUS_DEBUG_0_FBIO_RCLK_DELAY_8                0x00000008 /* RWI-V */
#define NV_PBUS_DEBUG_0_FBIO_RCLK_PC                          28:28 /* RWIVF */
#define NV_PBUS_DEBUG_0_FBIO_RCLK_PC_NORMAL              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_0_FBIO_RCLK_PC_OVERRIDE            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1                                  0x00001084 /* RW-4R */
#define NV_PBUS_DEBUG_1_PCIM_THROTTLE                           0:0 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIM_THROTTLE_DISABLED           0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIM_THROTTLE_ENABLED            0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIM_CMD                                1:1 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIM_CMD_SIZE_BASED              0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIM_CMD_MRL_ONLY                0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_HASH_DECODE                             2:2 /* RWIVF */
#define NV_PBUS_DEBUG_1_HASH_DECODE_1FF                  0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_HASH_DECODE_2FF                  0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_AGPM_CMD                                4:3 /* RWIVF */
#define NV_PBUS_DEBUG_1_AGPM_CMD_HP_ON_1ST               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_AGPM_CMD_LP_ONLY                 0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_AGPM_CMD_HP_ONLY                 0x00000002 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_WRITE                              5:5 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_WRITE_0_CYCLE               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_WRITE_1_CYCLE               0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_2_1                                6:6 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_2_1_DISABLED                0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_2_1_ENABLED                 0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RETRY                              7:7 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_RETRY_DISABLED              0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_RETRY_ENABLED               0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RD_BURST                           8:8 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_RD_BURST_DISABLED           0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_RD_BURST_ENABLED            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_WR_BURST                           9:9 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_WR_BURST_DISABLED           0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_WR_BURST_ENABLED            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY                        10:10 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY_DISABLED          0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_EARLY_RTY_ENABLED           0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_PCIS_CPUQ                             12:12 /* RWIVF */
#define NV_PBUS_DEBUG_1_PCIS_CPUQ_DISABLED               0x00000000 /* RW--V */
#define NV_PBUS_DEBUG_1_PCIS_CPUQ_ENABLED                0x00000001 /* RWI-V */
#define NV_PBUS_DEBUG_1_DPSH_DECODE                           13:13 /* RWIVF */
#define NV_PBUS_DEBUG_1_DPSH_DECODE_NV4                  0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_DPSH_DECODE_NV3                  0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE1                                14:14 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE1_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE1_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE2                                15:15 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE2_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE2_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE3                                16:16 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE3_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE3_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE4                                17:17 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE4_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE4_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE5                                18:18 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE5_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE5_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE6                                19:19 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE6_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE6_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE7                                20:20 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE7_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE7_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE8                                21:21 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE8_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE8_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE9                                22:22 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE9_ZERO                      0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE9_ONE                       0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_1_SPARE10                               23:23 /* RWIVF */
#define NV_PBUS_DEBUG_1_SPARE10_ZERO                     0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_1_SPARE10_ONE                      0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_2                                  0x00001088 /* RW-4R */
#define NV_PBUS_DEBUG_2_AGP_DIFFERENTIAL                        0:0 /* RWIVF */
#define NV_PBUS_DEBUG_2_AGP_DIFFERENTIAL_DISABLED        0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_2_AGP_DIFFERENTIAL_ENABLED         0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_2_AGP_SB_STB_DELAY                        9:4 /* RWIUF */
#define NV_PBUS_DEBUG_2_AGP_SB_STB_DELAY_34              0x00000022 /* RWI-V */
#define NV_PBUS_DEBUG_2_AGP_SB_STB_PC                         12:12 /* RWIVF */
#define NV_PBUS_DEBUG_2_AGP_SB_STB_PC_NORMAL             0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_2_AGP_SB_STB_PC_OVERRIDE           0x00000001 /* RW0-V */
#define NV_PBUS_DEBUG_3                                  0x0000108C /* RW-4R */
#define NV_PBUS_DEBUG_3_AGP_MAX_SIZE                            1:0 /* RWIVF */
#define NV_PBUS_DEBUG_3_AGP_MAX_SIZE_UNLIMITED           0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_3_AGP_MAX_SIZE_32_BYTES            0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_3_AGP_MAX_SIZE_64_BYTES            0x00000002 /* RW--V */
#define NV_PBUS_DEBUG_CTL                                0x00001090 /* RW-4R */
#define NV_PBUS_DEBUG_CTL_MODE                                  0:0 /* RWIVF */
#define NV_PBUS_DEBUG_CTL_MODE_DISABLED                  0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTL_MODE_ENABLED                   0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_CTL_READ_SELECT                           4:4 /* RWIVF */
#define NV_PBUS_DEBUG_CTL_READ_SELECT_0                  0x00000000 /* RWI-V */
#define NV_PBUS_DEBUG_CTL_READ_SELECT_1                  0x00000001 /* RW--V */
#define NV_PBUS_DEBUG_READ                               0x00001094 /* R--4R */
#define NV_PBUS_DEBUG_READ_DATA                                31:0 /* R-XUF */
#define NV_PBUS_DEBUG_HOST                               0x0000109C /* RW-4R */
#define NV_PBUS_DEBUG_HOST_SEL                                  2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_0                              0x000010A0 /* RW-4R */
#define NV_PBUS_DEBUG_SEL_0_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_1                              0x000010A4 /* RW-4R */
#define NV_PBUS_DEBUG_SEL_1_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_2                              0x000010A8 /* RW-4R */
#define NV_PBUS_DEBUG_SEL_2_X                                   2:0 /* RWXUF */
#define NV_PBUS_DEBUG_SEL_3                              0x000010AC /* RW-4R */
#define NV_PBUS_DEBUG_SEL_3_X                                   2:0 /* RWXUF */
#define NV_PBUS_INTR_0                                   0x00001100 /* RW-4R */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR                            0:0 /* RWXVF */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR_NOT_PENDING         0x00000000 /* R---V */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR_PENDING             0x00000001 /* R---V */
#define NV_PBUS_INTR_0_PCI_BUS_ERROR_RESET               0x00000001 /* -W--V */
#define NV_PBUS_INTR_EN_0                                0x00001140 /* RWI4R */
#define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR                         0:0 /* RWIVF */
#define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR_DISABLED         0x00000000 /* RWI-V */
#define NV_PBUS_INTR_EN_0_PCI_BUS_ERROR_ENABLED          0x00000001 /* RW--V */
#define NV_PBUS_ROM_CONFIG                               0x00001200 /* RWI4R */
#define NV_PBUS_ROM_CONFIG_TW1                                  3:0 /* RWIVF */
#define NV_PBUS_ROM_CONFIG_TW1_DEFAULT                   0x0000000F /* RWI-V */
#define NV_PBUS_ROM_CONFIG_TW0                                  5:4 /* RWIVF */
#define NV_PBUS_ROM_CONFIG_TW0_DEFAULT                   0x00000003 /* RWI-V */
#define NV_PBUS_PCI_NV_0                                 0x00001800 /* R--4R */
#define NV_PBUS_PCI_NV_0__ALIAS_1                NV_CONFIG_PCI_NV_0 /*       */
#define NV_PBUS_PCI_NV_0_VENDOR_ID                             15:0 /* C--UF */
#define NV_PBUS_PCI_NV_0_VENDOR_ID_NVIDIA_SGS            0x000012D2 /* ----V */
#define NV_PBUS_PCI_NV_0_VENDOR_ID_NVIDIA                0x000010DE /* C---V */
#define NV_PBUS_PCI_NV_0_DEVICE_ID_FUNC                       18:16 /* C--UF */
#define NV_PBUS_PCI_NV_0_DEVICE_ID_FUNC_VGA              0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_0_DEVICE_ID_CHIP                       31:19 /* C--UF */
#define NV_PBUS_PCI_NV_0_DEVICE_ID_CHIP_NV0              0x00000000 /* ----V */
#define NV_PBUS_PCI_NV_0_DEVICE_ID_CHIP_NV1              0x00000001 /* ----V */
#define NV_PBUS_PCI_NV_0_DEVICE_ID_CHIP_NV2              0x00000002 /* ----V */
#define NV_PBUS_PCI_NV_0_DEVICE_ID_CHIP_NV3              0x00000003 /* ----V */
#define NV_PBUS_PCI_NV_0_DEVICE_ID_CHIP_NV4              0x00000004 /* C---V */

// Used to determine chip id on Win2k 
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV04                0x00000020 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID0         0x00000028 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID1         0x00000029 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID2         0x0000002A /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV05_DEVID3         0x0000002B /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID0         0x0000002C /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID1         0x0000002D /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID2         0x0000002E /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV06_DEVID3         0x0000002F /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID0         0x000000A0 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID1         0x000000A1 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID2         0x000000A2 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV0A_DEVID3         0x000000A3 /* ----V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID0         0x00000100 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID1         0x00000101 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID2         0x00000102 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV10_DEVID3         0x00000103 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID0         0x00000110 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID1         0x00000111 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID2         0x00000112 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV11_DEVID3         0x00000113 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_CRUSH11_DEVID0      0x000001A0 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID0         0x00000150 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID1         0x00000151 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID2         0x00000152 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV15_DEVID3         0x00000153 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID0         0x00000200 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID1         0x00000201 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID2         0x00000202 /* C---V */
#define NV_CONFIG_PCI_NV_0_DEVICE_ID_NV20_DEVID3         0x00000203 /* C---V */

#define NV_PBUS_PCI_NV_1                                 0x00001804 /* RW-4R */
#define NV_PBUS_PCI_NV_1__ALIAS_1                NV_CONFIG_PCI_NV_1 /*       */
#define NV_PBUS_PCI_NV_1_IO_SPACE                               0:0 /* RWIVF */
#define NV_PBUS_PCI_NV_1_IO_SPACE_DISABLED               0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_1_IO_SPACE_ENABLED                0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_1_MEMORY_SPACE                           1:1 /* RWIVF */
#define NV_PBUS_PCI_NV_1_MEMORY_SPACE_DISABLED           0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_1_MEMORY_SPACE_ENABLED            0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_1_BUS_MASTER                             2:2 /* RWIVF */
#define NV_PBUS_PCI_NV_1_BUS_MASTER_DISABLED             0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_1_BUS_MASTER_ENABLED              0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_1_WRITE_AND_INVAL                        4:4 /* C--VF */
#define NV_PBUS_PCI_NV_1_WRITE_AND_INVAL_DISABLED        0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_1_WRITE_AND_INVAL_ENABLED         0x00000001 /* ----V */
#define NV_PBUS_PCI_NV_1_PALETTE_SNOOP                          5:5 /* RWIVF */
#define NV_PBUS_PCI_NV_1_PALETTE_SNOOP_DISABLED          0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_1_PALETTE_SNOOP_ENABLED           0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_1_CAPLIST                              20:20 /* C--VF */
#define NV_PBUS_PCI_NV_1_CAPLIST_NOT_PRESENT             0x00000000 /* ----V */
#define NV_PBUS_PCI_NV_1_CAPLIST_PRESENT                 0x00000001 /* C---V */
#define NV_PBUS_PCI_NV_1_66MHZ                                21:21 /* C--VF */
#define NV_PBUS_PCI_NV_1_66MHZ_INCAPABLE                 0x00000000 /* ----V */
#define NV_PBUS_PCI_NV_1_66MHZ_CAPABLE                   0x00000001 /* ----V */
#define NV_PBUS_PCI_NV_1_FAST_BACK2BACK                       23:23 /* C--VF */
#define NV_PBUS_PCI_NV_1_FAST_BACK2BACK_INCAPABLE        0x00000000 /* ----V */
#define NV_PBUS_PCI_NV_1_FAST_BACK2BACK_CAPABLE          0x00000001 /* C---V */
#define NV_PBUS_PCI_NV_1_DEVSEL_TIMING                        26:25 /* C--VF */
#define NV_PBUS_PCI_NV_1_DEVSEL_TIMING_FAST              0x00000000 /* ----V */
#define NV_PBUS_PCI_NV_1_DEVSEL_TIMING_MEDIUM            0x00000001 /* C---V */
#define NV_PBUS_PCI_NV_1_DEVSEL_TIMING_SLOW              0x00000002 /* ----V */
#define NV_PBUS_PCI_NV_1_SIGNALED_TARGET                      27:27 /* RWIVF */
#define NV_PBUS_PCI_NV_1_SIGNALED_TARGET_NO_ABORT        0x00000000 /* R-I-V */
#define NV_PBUS_PCI_NV_1_SIGNALED_TARGET_ABORT           0x00000001 /* R---V */
#define NV_PBUS_PCI_NV_1_SIGNALED_TARGET_CLEAR           0x00000001 /* -W--V */
#define NV_PBUS_PCI_NV_1_RECEIVED_TARGET                      28:28 /* RWIVF */
#define NV_PBUS_PCI_NV_1_RECEIVED_TARGET_NO_ABORT        0x00000000 /* R-I-V */
#define NV_PBUS_PCI_NV_1_RECEIVED_TARGET_ABORT           0x00000001 /* R---V */
#define NV_PBUS_PCI_NV_1_RECEIVED_TARGET_CLEAR           0x00000001 /* -W--V */
#define NV_PBUS_PCI_NV_1_RECEIVED_MASTER                      29:29 /* RWIVF */
#define NV_PBUS_PCI_NV_1_RECEIVED_MASTER_NO_ABORT        0x00000000 /* R-I-V */
#define NV_PBUS_PCI_NV_1_RECEIVED_MASTER_ABORT           0x00000001 /* R---V */
#define NV_PBUS_PCI_NV_1_RECEIVED_MASTER_CLEAR           0x00000001 /* -W--V */
#define NV_PBUS_PCI_NV_2                                 0x00001808 /* R--4R */
#define NV_PBUS_PCI_NV_2__ALIAS_1                NV_CONFIG_PCI_NV_2 /*       */
#define NV_PBUS_PCI_NV_2_REVISION_ID                            7:0 /* C--UF */
#define NV_PBUS_PCI_NV_2_REVISION_ID_A01                 0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_2_REVISION_ID_B01                 0x00000010 /* ----V */
#define NV_PBUS_PCI_NV_2_CLASS_CODE                            31:8 /* C--VF */
#define NV_PBUS_PCI_NV_2_CLASS_CODE_VGA                  0x00030000 /* C---V */
#define NV_PBUS_PCI_NV_2_CLASS_CODE_MULTIMEDIA           0x00048000 /* ----V */
#define NV_PBUS_PCI_NV_3                                 0x0000180C /* RW-4R */
#define NV_PBUS_PCI_NV_3__ALIAS_1                NV_CONFIG_PCI_NV_3 /*       */
#define NV_PBUS_PCI_NV_3_LATENCY_TIMER                        15:11 /* RWIUF */
#define NV_PBUS_PCI_NV_3_LATENCY_TIMER_0_CLOCKS          0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_3_LATENCY_TIMER_8_CLOCKS          0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_3_LATENCY_TIMER_240_CLOCKS        0x0000001E /* RW--V */
#define NV_PBUS_PCI_NV_3_LATENCY_TIMER_248_CLOCKS        0x0000001F /* RW--V */
#define NV_PBUS_PCI_NV_3_HEADER_TYPE                          23:16 /* C--VF */
#define NV_PBUS_PCI_NV_3_HEADER_TYPE_SINGLEFUNC          0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_3_HEADER_TYPE_MULTIFUNC           0x00000080 /* ----V */
#define NV_PBUS_PCI_NV_4                                 0x00001810 /* RW-4R */
#define NV_PBUS_PCI_NV_4__ALIAS_1                NV_CONFIG_PCI_NV_4 /*       */
#define NV_PBUS_PCI_NV_4_SPACE_TYPE                             0:0 /* C--VF */
#define NV_PBUS_PCI_NV_4_SPACE_TYPE_MEMORY               0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_4_SPACE_TYPE_IO                   0x00000001 /* ----V */
#define NV_PBUS_PCI_NV_4_ADDRESS_TYPE                           2:1 /* C--VF */
#define NV_PBUS_PCI_NV_4_ADDRESS_TYPE_32_BIT             0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_4_ADDRESS_TYPE_20_BIT             0x00000001 /* ----V */
#define NV_PBUS_PCI_NV_4_ADDRESS_TYPE_64_BIT             0x00000002 /* ----V */
#define NV_PBUS_PCI_NV_4_PREFETCHABLE                           3:3 /* C--VF */
#define NV_PBUS_PCI_NV_4_PREFETCHABLE_NOT                0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_4_PREFETCHABLE_MERGABLE           0x00000001 /* ----V */
#define NV_PBUS_PCI_NV_4_BASE_ADDRESS                         31:24 /* RWXUF */
#define NV_PBUS_PCI_NV_5                                 0x00001814 /* RW-4R */
#define NV_PBUS_PCI_NV_5__ALIAS_1                NV_CONFIG_PCI_NV_5 /*       */
#define NV_PBUS_PCI_NV_5_SPACE_TYPE                             0:0 /* C--VF */
#define NV_PBUS_PCI_NV_5_SPACE_TYPE_MEMORY               0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_5_SPACE_TYPE_IO                   0x00000001 /* ----V */
#define NV_PBUS_PCI_NV_5_ADDRESS_TYPE                           2:1 /* C--VF */
#define NV_PBUS_PCI_NV_5_ADDRESS_TYPE_32_BIT             0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_5_ADDRESS_TYPE_20_BIT             0x00000001 /* ----V */
#define NV_PBUS_PCI_NV_5_ADDRESS_TYPE_64_BIT             0x00000002 /* ----V */
#define NV_PBUS_PCI_NV_5_PREFETCHABLE                           3:3 /* C--VF */
#define NV_PBUS_PCI_NV_5_PREFETCHABLE_NOT                0x00000000 /* ----V */
#define NV_PBUS_PCI_NV_5_PREFETCHABLE_MERGABLE           0x00000001 /* C---V */
#define NV_PBUS_PCI_NV_5_BASE_ADDRESS                         31:24 /* RWXUF */
#define NV_PBUS_PCI_NV_6(i)                      (0x00001818+(i)*4) /* R--4A */
#define NV_PBUS_PCI_NV_6__SIZE_1                                  5 /*       */
#define NV_PBUS_PCI_NV_6__ALIAS_1                NV_CONFIG_PCI_NV_6 /*       */
#define NV_PBUS_PCI_NV_6_RESERVED                              31:0 /* C--VF */
#define NV_PBUS_PCI_NV_6_RESERVED_0                      0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_11                                0x0000182C /* R--4R */
#define NV_PBUS_PCI_NV_11__ALIAS_1              NV_CONFIG_PCI_NV_11 /*       */
#define NV_PBUS_PCI_NV_11_SUBSYSTEM_VENDOR_ID                  15:0 /* R--UF */
#define NV_PBUS_PCI_NV_11_SUBSYSTEM_VENDOR_ID_NONE       0x00000000 /* R---V */
#define NV_PBUS_PCI_NV_11_SUBSYSTEM_ID                        31:16 /* R--UF */
#define NV_PBUS_PCI_NV_11_SUBSYSTEM_ID_NONE              0x00000000 /* R---V */
#define NV_PBUS_PCI_NV_12                                0x00001830 /* RW-4R */
#define NV_PBUS_PCI_NV_12__ALIAS_1              NV_CONFIG_PCI_NV_12 /*       */
#define NV_PBUS_PCI_NV_12_ROM_DECODE                            0:0 /* RWIVF */
#define NV_PBUS_PCI_NV_12_ROM_DECODE_DISABLED            0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_12_ROM_DECODE_ENABLED             0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_12_ROM_BASE                            31:16 /* RWXUF */
#define NV_PBUS_PCI_NV_13                                0x00001834 /* RW-4R */
#define NV_PBUS_PCI_NV_13__ALIAS_1              NV_CONFIG_PCI_NV_13 /*       */
#define NV_PBUS_PCI_NV_13_CAP_PTR                               7:0 /* C--VF */
#define NV_PBUS_PCI_NV_13_CAP_PTR_AGP                    0x00000044 /* ----V */
#define NV_PBUS_PCI_NV_13_CAP_PTR_POWER_MGMT             0x00000060 /* C---V */
#define NV_PBUS_PCI_NV_14                                0x00001838 /* R--4A */
#define NV_PBUS_PCI_NV_14__ALIAS_1              NV_CONFIG_PCI_NV_14 /*       */
#define NV_PBUS_PCI_NV_14_RESERVED                             31:0 /* C--VF */
#define NV_PBUS_PCI_NV_14_RESERVED_0                     0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_15                                0x0000183C /* RW-4R */
#define NV_PBUS_PCI_NV_15__ALIAS_1              NV_CONFIG_PCI_NV_15 /*       */
#define NV_PBUS_PCI_NV_15_INTR_LINE                             7:0 /* RWIVF */
#define NV_PBUS_PCI_NV_15_INTR_LINE_IRQ0                 0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_15_INTR_LINE_IRQ1                 0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_15_INTR_LINE_IRQ15                0x0000000F /* RW--V */
#define NV_PBUS_PCI_NV_15_INTR_LINE_UNKNOWN              0x000000FF /* RW--V */
#define NV_PBUS_PCI_NV_15_INTR_PIN                             15:8 /* C--VF */
#define NV_PBUS_PCI_NV_15_INTR_PIN_INTA                  0x00000001 /* C---V */
#define NV_PBUS_PCI_NV_15_MIN_GNT                             23:16 /* C--VF */
#define NV_PBUS_PCI_NV_15_MIN_GNT_NO_REQUIREMENTS        0x00000000 /* ----V */
#define NV_PBUS_PCI_NV_15_MIN_GNT_750NS                  0x00000003 /* ----V */
#define NV_PBUS_PCI_NV_15_MIN_GNT_1250NS                 0x00000005 /* C---V */
#define NV_PBUS_PCI_NV_15_MAX_LAT                             31:24 /* C--VF */
#define NV_PBUS_PCI_NV_15_MAX_LAT_NO_REQUIREMENTS        0x00000000 /* ----V */
#define NV_PBUS_PCI_NV_15_MAX_LAT_250NS                  0x00000001 /* C---V */
#define NV_PBUS_PCI_NV_16                                0x00001840 /* RW-4R */
#define NV_PBUS_PCI_NV_16__ALIAS_1              NV_CONFIG_PCI_NV_16 /*       */
#define NV_PBUS_PCI_NV_16_SUBSYSTEM_VENDOR_ID                  15:0 /* RW-VF */
#define NV_PBUS_PCI_NV_16_SUBSYSTEM_VENDOR_ID_NONE       0x00000000 /* R---V */
#define NV_PBUS_PCI_NV_16_SUBSYSTEM_ID                        31:16 /* RW-VF */
#define NV_PBUS_PCI_NV_16_SUBSYSTEM_ID_NONE              0x00000000 /* R---V */
#define NV_PBUS_PCI_NV_17                                0x00001844 /* RW-4R */
#define NV_PBUS_PCI_NV_17__ALIAS_1              NV_CONFIG_PCI_NV_17 /*       */
#define NV_PBUS_PCI_NV_17_AGP_REV_MAJOR                       23:20 /* C--VF */
#define NV_PBUS_PCI_NV_17_AGP_REV_MAJOR_1                0x00000001 /* C---V */
#define NV_PBUS_PCI_NV_17_AGP_REV_MINOR                       19:16 /* C--VF */
#define NV_PBUS_PCI_NV_17_AGP_REV_MINOR_0                0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_17_NEXT_PTR                             15:8 /* C--VF */
#define NV_PBUS_PCI_NV_17_NEXT_PTR_NULL                  0x00000000 /* C---V */
#define NV_PBUS_PCI_NV_17_CAP_ID                                7:0 /* C--VF */
#define NV_PBUS_PCI_NV_17_CAP_ID_AGP                     0x00000002 /* C---V */
#define NV_PBUS_PCI_NV_18                                0x00001848 /* RW-4R */
#define NV_PBUS_PCI_NV_18__ALIAS_1              NV_CONFIG_PCI_NV_18 /*       */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_RQ                       31:24 /* C--VF */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_RQ_16               0x0000000F /* C---V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_SBA                        9:9 /* C--VF */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_SBA_NONE            0x00000000 /* ----V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_SBA_CAPABLE         0x00000001 /* C---V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_RATE                       1:0 /* C--VF */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_RATE_1X             0x00000001 /* ----V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_RATE_2X             0x00000002 /* ----V */
#define NV_PBUS_PCI_NV_18_AGP_STATUS_RATE_1X_AND_2X      0x00000003 /* C---V */
#define NV_PBUS_PCI_NV_19                                0x0000184C /* RW-4R */
#define NV_PBUS_PCI_NV_19__ALIAS_1              NV_CONFIG_PCI_NV_19 /*       */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_RQ_DEPTH                27:24 /* RWIVF */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_RQ_DEPTH_0         0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_SBA_ENABLE                9:9 /* RWIVF */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_SBA_ENABLE_OFF     0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_SBA_ENABLE_ON      0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_AGP_ENABLE                8:8 /* RWIVF */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_AGP_ENABLE_OFF     0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_AGP_ENABLE_ON      0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_DATA_RATE                 1:0 /* RWIVF */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_DATA_RATE_OFF      0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_DATA_RATE_1X       0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_19_AGP_COMMAND_DATA_RATE_2X       0x00000002 /* RW--V */
#define NV_PBUS_PCI_NV_20                                0x00001850 /* RW-4R */
#define NV_PBUS_PCI_NV_20__ALIAS_1              NV_CONFIG_PCI_NV_20 /*       */
#define NV_PBUS_PCI_NV_20_ROM_SHADOW                            0:0 /* RWIVF */
#define NV_PBUS_PCI_NV_20_ROM_SHADOW_DISABLED            0x00000000 /* RWI-V */
#define NV_PBUS_PCI_NV_20_ROM_SHADOW_ENABLED             0x00000001 /* RW--V */
#define NV_PBUS_PCI_NV_21                                0x00001854 /* RW-4R */
#define NV_PBUS_PCI_NV_21__ALIAS_1              NV_CONFIG_PCI_NV_21 /*       */
#define NV_PBUS_PCI_NV_21_VGA                                   0:0 /* RWIVF */
#define NV_PBUS_PCI_NV_21_VGA_DISABLED                   0x00000000 /* RW--V */
#define NV_PBUS_PCI_NV_21_VGA_ENABLED                    0x00000001 /* RWI-V */
#define NV_PBUS_PCI_NV_22                                0x00001858 /* RW-4R */
#define NV_PBUS_PCI_NV_22__ALIAS_1              NV_CONFIG_PCI_NV_22 /*       */
#define NV_PBUS_PCI_NV_22_SCRATCH                              23:0 /* RWIVF */
#define NV_PBUS_PCI_NV_22_SCRATCH_DEFAULT                0x0023D6CE /* RWI-V */
#define NV_PBUS_PCI_NV_23                                0x0000185C /* RW-4A */
#define NV_PBUS_PCI_NV_23__ALIAS_1              NV_CONFIG_PCI_NV_23 /*       */
#define NV_PBUS_PCI_NV_23_DT_TIMEOUT                            3:0 /* RWIVF */
#define NV_PBUS_PCI_NV_23_DT_TIMEOUT_16                  0x0000000F /* RWI-V */
#define NV_PBUS_PCI_NV_24                                0x00001860 /* RW-4R */
#define NV_PBUS_PCI_NV_24__ALIAS_1              NV_CONFIG_PCI_NV_24 /*       */
#define NV_PBUS_PCI_NV_24_PME_D3_COLD                         31:31 /* C--VF */
#define NV_PBUS_PCI_NV_24_PME_D3_COLD_SUPPORTED          0x00000001 /* ---VF */
#define NV_PBUS_PCI_NV_24_PME_D3_COLD_NOT_SUPPORTED      0x00000000 /* C--VF */
#define NV_PBUS_PCI_NV_24_PME_D3_HOT                          30:30 /* C--VF */
#define NV_PBUS_PCI_NV_24_PME_D3_HOT_SUPPORTED           0x00000001 /* ---VF */
#define NV_PBUS_PCI_NV_24_PME_D3_HOT_NOT_SUPPORTED       0x00000000 /* C--VF */
#define NV_PBUS_PCI_NV_24_PME_D2                              29:29 /* C--VF */
#define NV_PBUS_PCI_NV_24_PME_D2_SUPPORTED               0x00000001 /* ---VF */
#define NV_PBUS_PCI_NV_24_PME_D2_NOT_SUPPORTED           0x00000000 /* C--VF */
#define NV_PBUS_PCI_NV_24_PME_D1                              28:28 /* C--VF */
#define NV_PBUS_PCI_NV_24_PME_D1_SUPPORTED               0x00000001 /* ---VF */
#define NV_PBUS_PCI_NV_24_PME_D1_NOT_SUPPORTED           0x00000000 /* C--VF */
#define NV_PBUS_PCI_NV_24_PME_D0                              27:27 /* C--VF */
#define NV_PBUS_PCI_NV_24_PME_D0_SUPPORTED               0x00000001 /* ---VF */
#define NV_PBUS_PCI_NV_24_PME_D0_NOT_SUPPORTED           0x00000000 /* C--VF */
#define NV_PBUS_PCI_NV_24_D2                                  26:26 /* C--VF */
#define NV_PBUS_PCI_NV_24_D2_SUPPORTED                   0x00000001 /* ---VF */
#define NV_PBUS_PCI_NV_24_D2_NOT_SUPPORTED               0x00000000 /* C--VF */
#define NV_PBUS_PCI_NV_24_D1                                  25:25 /* C--VF */
#define NV_PBUS_PCI_NV_24_D1_SUPPORTED                   0x00000001 /* ---VF */
#define NV_PBUS_PCI_NV_24_D1_NOT_SUPPORTED               0x00000000 /* C--VF */
#define NV_PBUS_PCI_NV_24_DSI                                 21:21 /* C--VF */
#define NV_PBUS_PCI_NV_24_DSI_NOT_REQUIRED               0x00000000 /* C--VF */
#define NV_PBUS_PCI_NV_24_PME_CLOCK                           19:19 /* C--VF */
#define NV_PBUS_PCI_NV_24_PME_CLOCK_NOT_REQUIRED         0x00000000 /* C--VF */
#define NV_PBUS_PCI_NV_24_VERSION                             18:16 /* C--VF */
#define NV_PBUS_PCI_NV_24_VERSION_1                      0x00000001 /* C--VF */
#define NV_PBUS_PCI_NV_24_NEXT_PTR                             15:8 /* R--VF */
#define NV_PBUS_PCI_NV_24_NEXT_PTR_NULL                  0x00000000 /* ----V */
#define NV_PBUS_PCI_NV_24_NEXT_PTR_AGP                   0x00000044 /* ----V */
#define NV_PBUS_PCI_NV_24_CAP_ID                                7:0 /* C--VF */
#define NV_PBUS_PCI_NV_24_CAP_ID_POWER_MGMT              0x00000001 /* C---V */
#define NV_PBUS_PCI_NV_25                                0x00001864 /* RW-4R */
#define NV_PBUS_PCI_NV_25__ALIAS_1              NV_CONFIG_PCI_NV_25 /*       */
#define NV_PBUS_PCI_NV_25_POWER_STATE                           1:0 /* RWIVF */
#define NV_PBUS_PCI_NV_25_POWER_STATE_D3_HOT             0x00000003 /* RW-VF */
#define NV_PBUS_PCI_NV_25_POWER_STATE_D2                 0x00000002 /* RW-VF */
#define NV_PBUS_PCI_NV_25_POWER_STATE_D1                 0x00000001 /* RW-VF */
#define NV_PBUS_PCI_NV_25_POWER_STATE_D0                 0x00000000 /* RWIVF */
#define NV_PBUS_PCI_NV_26(i)                     (0x00001868+(i)*4) /* R--4A */
#define NV_PBUS_PCI_NV_26__SIZE_1                                38 /*       */
#define NV_PBUS_PCI_NV_26__ALIAS_1              NV_CONFIG_PCI_NV_25 /*       */
#define NV_PBUS_PCI_NV_26_RESERVED                             31:0 /* C--VF */
#define NV_PBUS_PCI_NV_26_RESERVED_0                     0x00000000 /* C---V */
/* dev_fifo.ref */
#define NV_PFIFO                              0x00003FFF:0x00002000 /* RW--D */
#define NV_PFIFO_DELAY_0                                 0x00002040 /* RW-4R */
#define NV_PFIFO_DELAY_0_WAIT_RETRY                             9:0 /* RWIUF */
#define NV_PFIFO_DELAY_0_WAIT_RETRY_0                    0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_TIMESLICE                           0x00002044 /* RW-4R */
#define NV_PFIFO_DMA_TIMESLICE_SELECT                          16:0 /* RWIUF */
#define NV_PFIFO_DMA_TIMESLICE_SELECT_1                  0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_TIMESLICE_SELECT_16K                0x00003fff /* RW--V */
#define NV_PFIFO_DMA_TIMESLICE_SELECT_32K                0x00007fff /* RW--V */
#define NV_PFIFO_DMA_TIMESLICE_SELECT_64K                0x0000ffff /* RW--V */
#define NV_PFIFO_DMA_TIMESLICE_SELECT_128K               0x0001ffff /* RW--V */
#define NV_PFIFO_DMA_TIMESLICE_TIMEOUT                        24:24 /* RWIUF */
#define NV_PFIFO_DMA_TIMESLICE_TIMEOUT_DISABLED          0x00000000 /* RW--V */
#define NV_PFIFO_DMA_TIMESLICE_TIMEOUT_ENABLED           0x00000001 /* RWI-V */
#define NV_PFIFO_PIO_TIMESLICE                           0x00002048 /* RW-4R */
#define NV_PFIFO_PIO_TIMESLICE_SELECT                          16:0 /* RWIUF */
#define NV_PFIFO_PIO_TIMESLICE_SELECT_1                  0x00000000 /* RWI-V */
#define NV_PFIFO_PIO_TIMESLICE_SELECT_16K                0x00003fff /* RW--V */
#define NV_PFIFO_PIO_TIMESLICE_SELECT_32K                0x00007fff /* RW--V */
#define NV_PFIFO_PIO_TIMESLICE_SELECT_64K                0x0000ffff /* RW--V */
#define NV_PFIFO_PIO_TIMESLICE_SELECT_128K               0x0001ffff /* RW--V */
#define NV_PFIFO_PIO_TIMESLICE_TIMEOUT                        24:24 /* RWIUF */
#define NV_PFIFO_PIO_TIMESLICE_TIMEOUT_DISABLED          0x00000000 /* RW--V */
#define NV_PFIFO_PIO_TIMESLICE_TIMEOUT_ENABLED           0x00000001 /* RWI-V */
#define NV_PFIFO_TIMESLICE                               0x0000204C /* RW-4R */
#define NV_PFIFO_TIMESLICE_TIMER                               17:0 /* RWIUF */
#define NV_PFIFO_TIMESLICE_TIMER_EXPIRED                 0x0003FFFF /* RWI-V */
#define NV_PFIFO_NEXT_CHANNEL                            0x00002050 /* RW-4R */
#define NV_PFIFO_NEXT_CHANNEL_CHID                              3:0 /* RWXUF */
#define NV_PFIFO_NEXT_CHANNEL_MODE                              8:8 /* RWXVF */
#define NV_PFIFO_NEXT_CHANNEL_MODE_PIO                   0x00000000 /* RW--V */
#define NV_PFIFO_NEXT_CHANNEL_MODE_DMA                   0x00000001 /* RW--V */
#define NV_PFIFO_NEXT_CHANNEL_SWITCH                          12:12 /* RWIVF */
#define NV_PFIFO_NEXT_CHANNEL_SWITCH_NOT_PENDING         0x00000000 /* RWI-V */
#define NV_PFIFO_NEXT_CHANNEL_SWITCH_PENDING             0x00000001 /* RW--V */
#define NV_PFIFO_DEBUG_0                                 0x00002080 /* R--4R */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0                           0:0 /* R-XVF */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0_NOT_PENDING        0x00000000 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR0_PENDING            0x00000001 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1                           4:4 /* R-XVF */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1_NOT_PENDING        0x00000000 /* R---V */
#define NV_PFIFO_DEBUG_0_CACHE_ERROR1_PENDING            0x00000001 /* R---V */
#define NV_PFIFO_INTR_0                                  0x00002100 /* RW-4R */
#define NV_PFIFO_INTR_0_CACHE_ERROR                             0:0 /* RWXVF */
#define NV_PFIFO_INTR_0_CACHE_ERROR_NOT_PENDING          0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_CACHE_ERROR_PENDING              0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_CACHE_ERROR_RESET                0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_RUNOUT                                  4:4 /* RWXVF */
#define NV_PFIFO_INTR_0_RUNOUT_NOT_PENDING               0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_PENDING                   0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_RESET                     0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW                         8:8 /* RWXVF */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_NOT_PENDING      0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_PENDING          0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_RUNOUT_OVERFLOW_RESET            0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_DMA_PUSHER                            12:12 /* RWXVF */
#define NV_PFIFO_INTR_0_DMA_PUSHER_NOT_PENDING           0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PUSHER_PENDING               0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PUSHER_RESET                 0x00000001 /* -W--V */
#define NV_PFIFO_INTR_0_DMA_PT                                16:16 /* RWXVF */
#define NV_PFIFO_INTR_0_DMA_PT_NOT_PENDING               0x00000000 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PT_PENDING                   0x00000001 /* R---V */
#define NV_PFIFO_INTR_0_DMA_PT_RESET                     0x00000001 /* -W--V */
#define NV_PFIFO_INTR_EN_0                               0x00002140 /* RW-4R */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR                          0:0 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR_DISABLED          0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_CACHE_ERROR_ENABLED           0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_RUNOUT                               4:4 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_RUNOUT_DISABLED               0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_ENABLED                0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW                      8:8 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW_DISABLED      0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_RUNOUT_OVERFLOW_ENABLED       0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_DMA_PUSHER                         12:12 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_DMA_PUSHER_DISABLED           0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_DMA_PUSHER_ENABLED            0x00000001 /* RW--V */
#define NV_PFIFO_INTR_EN_0_DMA_PT                             16:16 /* RWIVF */
#define NV_PFIFO_INTR_EN_0_DMA_PT_DISABLED               0x00000000 /* RWI-V */
#define NV_PFIFO_INTR_EN_0_DMA_PT_ENABLED                0x00000001 /* RW--V */
#define NV_PFIFO_RAMHT                                   0x00002210 /* RW-4R */
#define NV_PFIFO_RAMHT_BASE_ADDRESS                             8:4 /* RWIUF */
#define NV_PFIFO_RAMHT_BASE_ADDRESS_10000                0x00000010 /* RWI-V */
#define NV_PFIFO_RAMHT_SIZE                                   17:16 /* RWIUF */
#define NV_PFIFO_RAMHT_SIZE_4K                           0x00000000 /* RWI-V */
#define NV_PFIFO_RAMHT_SIZE_8K                           0x00000001 /* RW--V */
#define NV_PFIFO_RAMHT_SIZE_16K                          0x00000002 /* RW--V */
#define NV_PFIFO_RAMHT_SIZE_32K                          0x00000003 /* RW--V */
#define NV_PFIFO_RAMHT_SEARCH                                 25:24 /* RWIUF */
#define NV_PFIFO_RAMHT_SEARCH_16                         0x00000000 /* RWI-V */
#define NV_PFIFO_RAMHT_SEARCH_32                         0x00000001 /* RW--V */
#define NV_PFIFO_RAMHT_SEARCH_64                         0x00000002 /* RW--V */
#define NV_PFIFO_RAMHT_SEARCH_128                        0x00000003 /* RW--V */
#define NV_PFIFO_RAMFC                                   0x00002214 /* RW-4R */
#define NV_PFIFO_RAMFC_BASE_ADDRESS                             8:1 /* RWIUF */
#define NV_PFIFO_RAMFC_BASE_ADDRESS_11000                0x00000088 /* RWI-V */
#define NV_PFIFO_RAMRO                                   0x00002218 /* RW-4R */
#define NV_PFIFO_RAMRO_BASE_ADDRESS                             8:1 /* RWIUF */
#define NV_PFIFO_RAMRO_BASE_ADDRESS_11200                0x00000089 /* RWI-V */
#define NV_PFIFO_RAMRO_BASE_ADDRESS_12000                0x00000090 /* RW--V */
#define NV_PFIFO_RAMRO_SIZE                                   16:16 /* RWIVF */
#define NV_PFIFO_RAMRO_SIZE_512                          0x00000000 /* RWI-V */
#define NV_PFIFO_RAMRO_SIZE_8K                           0x00000001 /* RW--V */
#define NV_PFIFO_CACHES                                  0x00002500 /* RW-4R */
#define NV_PFIFO_CACHES_REASSIGN                                0:0 /* RWIVF */
#define NV_PFIFO_CACHES_REASSIGN_DISABLED                0x00000000 /* RWI-V */
#define NV_PFIFO_CACHES_REASSIGN_ENABLED                 0x00000001 /* RW--V */
#define NV_PFIFO_CACHES_DMA_SUSPEND                             4:4 /* R--VF */
#define NV_PFIFO_CACHES_DMA_SUSPEND_IDLE                 0x00000000 /* R---V */
#define NV_PFIFO_CACHES_DMA_SUSPEND_BUSY                 0x00000001 /* R---V */
#define NV_PFIFO_MODE                                    0x00002504 /* RW-4R */
#define NV_PFIFO_MODE_CHANNEL_0                                 0:0 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_0_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_0_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_1                                 1:1 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_1_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_1_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_2                                 2:2 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_2_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_2_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_3                                 3:3 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_3_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_3_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_4                                 4:4 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_4_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_4_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_5                                 5:5 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_5_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_5_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_6                                 6:6 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_6_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_6_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_7                                 7:7 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_7_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_7_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_8                                 8:8 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_8_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_8_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_9                                 9:9 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_9_PIO                      0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_9_DMA                      0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_10                              10:10 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_10_PIO                     0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_10_DMA                     0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_11                              11:11 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_11_PIO                     0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_11_DMA                     0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_12                              12:12 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_12_PIO                     0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_12_DMA                     0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_13                              13:13 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_13_PIO                     0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_13_DMA                     0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_14                              14:14 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_14_PIO                     0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_14_DMA                     0x00000001 /* RW--V */
#define NV_PFIFO_MODE_CHANNEL_15                              15:15 /* RWIVF */
#define NV_PFIFO_MODE_CHANNEL_15_PIO                     0x00000000 /* RWI-V */
#define NV_PFIFO_MODE_CHANNEL_15_DMA                     0x00000001 /* RW--V */
#define NV_PFIFO_DMA                                     0x00002508 /* RW-4R */
#define NV_PFIFO_DMA_CHANNEL_0                                  0:0 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_0_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_0_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_1                                  1:1 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_1_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_1_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_2                                  2:2 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_2_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_2_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_3                                  3:3 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_3_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_3_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_4                                  4:4 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_4_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_4_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_5                                  5:5 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_5_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_5_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_6                                  6:6 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_6_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_6_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_7                                  7:7 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_7_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_7_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_8                                  8:8 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_8_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_8_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_9                                  9:9 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_9_NOT_PENDING               0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_9_PENDING                   0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_10                               10:10 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_10_NOT_PENDING              0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_10_PENDING                  0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_11                               11:11 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_11_NOT_PENDING              0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_11_PENDING                  0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_12                               12:12 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_12_NOT_PENDING              0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_12_PENDING                  0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_13                               13:13 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_13_NOT_PENDING              0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_13_PENDING                  0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_14                               14:14 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_14_NOT_PENDING              0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_14_PENDING                  0x00000001 /* RW--V */
#define NV_PFIFO_DMA_CHANNEL_15                               15:15 /* RWIVF */
#define NV_PFIFO_DMA_CHANNEL_15_NOT_PENDING              0x00000000 /* RWI-V */
#define NV_PFIFO_DMA_CHANNEL_15_PENDING                  0x00000001 /* RW--V */
#define NV_PFIFO_SIZE                                    0x0000250C /* RW-4R */
#define NV_PFIFO_SIZE_CHANNEL_0                                 0:0 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_0_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_0_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_1                                 1:1 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_1_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_1_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_2                                 2:2 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_2_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_2_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_3                                 3:3 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_3_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_3_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_4                                 4:4 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_4_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_4_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_5                                 5:5 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_5_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_5_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_6                                 6:6 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_6_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_6_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_7                                 7:7 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_7_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_7_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_8                                 8:8 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_8_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_8_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_9                                 9:9 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_9_124_BYTES                0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_9_512_BYTES                0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_10                              10:10 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_10_124_BYTES               0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_10_512_BYTES               0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_11                              11:11 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_11_124_BYTES               0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_11_512_BYTES               0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_12                              12:12 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_12_124_BYTES               0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_12_512_BYTES               0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_13                              13:13 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_13_124_BYTES               0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_13_512_BYTES               0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_14                              14:14 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_14_124_BYTES               0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_14_512_BYTES               0x00000001 /* RW--V */
#define NV_PFIFO_SIZE_CHANNEL_15                              15:15 /* RWIVF */
#define NV_PFIFO_SIZE_CHANNEL_15_124_BYTES               0x00000000 /* RWI-V */
#define NV_PFIFO_SIZE_CHANNEL_15_512_BYTES               0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PUSH0                            0x00003000 /* RW-4R */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE0_PUSH0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_PUSH0                            0x00003200 /* RW-4R */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_PUSH0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PUSH1                            0x00003004 /* RW-4R */
#define NV_PFIFO_CACHE0_PUSH1_CHID                              3:0 /* RWXUF */
#define NV_PFIFO_CACHE1_PUSH1                            0x00003204 /* RW-4R */
#define NV_PFIFO_CACHE1_PUSH1_CHID                              3:0 /* RWXUF */
#define NV_PFIFO_CACHE1_PUSH1_MODE                              8:8 /* RWIVF */
#define NV_PFIFO_CACHE1_PUSH1_MODE_PIO                   0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_PUSH1_MODE_DMA                   0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_PUSH                         0x00003220 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_PUSH_ACCESS                         0:0 /* RWIVF */
#define NV_PFIFO_CACHE1_DMA_PUSH_ACCESS_DISABLED         0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_DMA_PUSH_ACCESS_ENABLED          0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_PUSH_STATE                          4:4 /* R--VF */
#define NV_PFIFO_CACHE1_DMA_PUSH_STATE_IDLE              0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_DMA_PUSH_STATE_BUSY              0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_DMA_PUSH_BUFFER                         8:8 /* R--VF */
#define NV_PFIFO_CACHE1_DMA_PUSH_BUFFER_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_DMA_PUSH_BUFFER_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_DMA_PUSH_STATUS                       12:12 /* RWIVF */
#define NV_PFIFO_CACHE1_DMA_PUSH_STATUS_RUNNING          0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_DMA_PUSH_STATUS_SUSPENDED        0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH                        0x00003224 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG                          7:3 /* RWIUF */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_8_BYTES           0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_16_BYTES          0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_24_BYTES          0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_32_BYTES          0x00000003 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_40_BYTES          0x00000004 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_48_BYTES          0x00000005 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_56_BYTES          0x00000006 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_64_BYTES          0x00000007 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_72_BYTES          0x00000008 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_80_BYTES          0x00000009 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_88_BYTES          0x0000000A /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_96_BYTES          0x0000000B /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_104_BYTES         0x0000000C /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_112_BYTES         0x0000000D /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_120_BYTES         0x0000000E /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_128_BYTES         0x0000000F /* RWI-V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_136_BYTES         0x00000010 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_144_BYTES         0x00000011 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_152_BYTES         0x00000012 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_160_BYTES         0x00000013 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_168_BYTES         0x00000014 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_176_BYTES         0x00000015 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_184_BYTES         0x00000016 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_192_BYTES         0x00000017 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_200_BYTES         0x00000018 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_208_BYTES         0x00000019 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_216_BYTES         0x0000001A /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_224_BYTES         0x0000001B /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_232_BYTES         0x0000001C /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_240_BYTES         0x0000001D /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_248_BYTES         0x0000001E /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_TRIG_256_BYTES         0x0000001F /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE                        15:13 /* RWIUF */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_32_BYTES          0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_64_BYTES          0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_96_BYTES          0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_128_BYTES         0x00000003 /* RWI-V */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_160_BYTES         0x00000004 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_192_BYTES         0x00000005 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_224_BYTES         0x00000006 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_SIZE_256_BYTES         0x00000007 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS                    19:16 /* RWIUF */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_0             0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_1             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_2             0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_3             0x00000003 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_4             0x00000004 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_5             0x00000005 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_6             0x00000006 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_7             0x00000007 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_8             0x00000008 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_9             0x00000009 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_10            0x0000000A /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_11            0x0000000B /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_12            0x0000000C /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_13            0x0000000D /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_14            0x0000000E /* RW--V */
#define NV_PFIFO_CACHE1_DMA_FETCH_MAX_REQS_15            0x0000000F /* RW--V */
#define NV_PFIFO_CACHE1_DMA_PUT                          0x00003240 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_PUT_OFFSET                         28:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_GET                          0x00003244 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_GET_OFFSET                         28:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATE                        0x00003228 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_STATE_METHOD                       12:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATE_SUBCHANNEL                  15:13 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATE_METHOD_COUNT                28:18 /* RWIUF */
#define NV_PFIFO_CACHE1_DMA_STATE_METHOD_COUNT_0         0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_DMA_STATE_ERROR                       31:30 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_STATE_ERROR_NONE             0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_STATE_ERROR_NON_CACHE        0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_STATE_ERROR_RESERVED_CMD     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_STATE_ERROR_PROTECTION       0x00000003 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_INSTANCE                     0x0000322C /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_INSTANCE_ADDRESS                   15:0 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_CTL                          0x00003230 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_CTL_ADJUST                         11:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_CTL_PAGE_TABLE                    12:12 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_CTL_PAGE_TABLE_NOT_PRESENT   0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_CTL_PAGE_TABLE_PRESENT       0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_CTL_PAGE_ENTRY                    13:13 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_CTL_PAGE_ENTRY_NOT_LINEAR    0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_CTL_PAGE_ENTRY_LINEAR        0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_CTL_TARGET_NODE                   17:16 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_CTL_TARGET_NODE_PCI          0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_CTL_TARGET_NODE_AGP          0x00000003 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_CTL_AT_INFO                       31:31 /* RWIUF */
#define NV_PFIFO_CACHE1_DMA_CTL_AT_INFO_INVALID          0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_CTL_AT_INFO_VALID            0x00000001 /* RWI-V */
#define NV_PFIFO_CACHE1_DMA_LIMIT                        0x00003234 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_LIMIT_OFFSET                       28:2 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_TLB_TAG                      0x00003238 /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_TLB_TAG_ADDRESS                   28:12 /* RWXUF */
#define NV_PFIFO_CACHE1_DMA_TLB_TAG_STATE                       0:0 /* RWIUF */
#define NV_PFIFO_CACHE1_DMA_TLB_TAG_STATE_INVALID        0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_DMA_TLB_TAG_STATE_VALID          0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE                      0x0000323C /* RW-4R */
#define NV_PFIFO_CACHE1_DMA_TLB_PTE_FRAME_ADDRESS             31:12 /* RWXUF */
#define NV_PFIFO_CACHE0_PULL0                            0x00003050 /* RW-4R */
#define NV_PFIFO_CACHE0_PULL0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE0_PULL0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE0_PULL0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PULL0_HASH                              4:4 /* R-XVF */
#define NV_PFIFO_CACHE0_PULL0_HASH_SUCCEEDED             0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_PULL0_HASH_FAILED                0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_PULL0_DEVICE                            8:8 /* R-XVF */
#define NV_PFIFO_CACHE0_PULL0_DEVICE_HARDWARE            0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_PULL0_DEVICE_SOFTWARE            0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_PULL0_HASH_STATE                      12:12 /* R-XVF */
#define NV_PFIFO_CACHE0_PULL0_HASH_STATE_IDLE            0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_PULL0_HASH_STATE_BUSY            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_PULL0                            0x00003250 /* RW-4R */
#define NV_PFIFO_CACHE1_PULL0_ACCESS                            0:0 /* RWIVF */
#define NV_PFIFO_CACHE1_PULL0_ACCESS_DISABLED            0x00000000 /* RWI-V */
#define NV_PFIFO_CACHE1_PULL0_ACCESS_ENABLED             0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_PULL0_HASH                              4:4 /* R-XVF */
#define NV_PFIFO_CACHE1_PULL0_HASH_SUCCEEDED             0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_HASH_FAILED                0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_DEVICE                            8:8 /* R-XVF */
#define NV_PFIFO_CACHE1_PULL0_DEVICE_HARDWARE            0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_DEVICE_SOFTWARE            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_HASH_STATE                      12:12 /* R-XVF */
#define NV_PFIFO_CACHE1_PULL0_HASH_STATE_IDLE            0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_PULL0_HASH_STATE_BUSY            0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_PULL1                            0x00003054 /* RW-4R */
#define NV_PFIFO_CACHE0_PULL1_ENGINE                            1:0 /* RWXUF */
#define NV_PFIFO_CACHE0_PULL1_ENGINE_SW                  0x00000000 /* RW--V */
#define NV_PFIFO_CACHE0_PULL1_ENGINE_GRAPHICS            0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_PULL1_ENGINE_DVD                 0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_PULL1                            0x00003254 /* RW-4R */
#define NV_PFIFO_CACHE1_PULL1_ENGINE                            1:0 /* RWXUF */
#define NV_PFIFO_CACHE1_PULL1_ENGINE_SW                  0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_PULL1_ENGINE_GRAPHICS            0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_PULL1_ENGINE_DVD                 0x00000002 /* RW--V */
#define NV_PFIFO_CACHE0_HASH                             0x00003058 /* RW-4R */
#define NV_PFIFO_CACHE0_HASH_INSTANCE                          15:0 /* RWXUF */
#define NV_PFIFO_CACHE0_HASH_VALID                            16:16 /* RWXVF */
#define NV_PFIFO_CACHE1_HASH                             0x00003258 /* RW-4R */
#define NV_PFIFO_CACHE1_HASH_INSTANCE                          15:0 /* RWXUF */
#define NV_PFIFO_CACHE1_HASH_VALID                            16:16 /* RWXVF */
#define NV_PFIFO_CACHE0_STATUS                           0x00003014 /* R--4R */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_CACHE0_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS                           0x00003214 /* R--4R */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_CACHE1_STATUS1                          0x00003218 /* R--4R */
#define NV_PFIFO_CACHE1_STATUS1_RANOUT                          0:0 /* R-XVF */
#define NV_PFIFO_CACHE1_STATUS1_RANOUT_FALSE             0x00000000 /* R---V */
#define NV_PFIFO_CACHE1_STATUS1_RANOUT_TRUE              0x00000001 /* R---V */
#define NV_PFIFO_CACHE0_PUT                              0x00003010 /* RW-4R */
#define NV_PFIFO_CACHE0_PUT_ADDRESS                             2:2 /* RWXUF */
#define NV_PFIFO_CACHE1_PUT                              0x00003210 /* RW-4R */
#define NV_PFIFO_CACHE1_PUT_ADDRESS                             9:2 /* RWXUF */
#define NV_PFIFO_CACHE0_GET                              0x00003070 /* RW-4R */
#define NV_PFIFO_CACHE0_GET_ADDRESS                             2:2 /* RWXUF */
#define NV_PFIFO_CACHE1_GET                              0x00003270 /* RW-4R */
#define NV_PFIFO_CACHE1_GET_ADDRESS                             9:2 /* RWXUF */
#define NV_PFIFO_CACHE0_ENGINE                           0x00003080 /* RW-4R */
#define NV_PFIFO_CACHE0_ENGINE_0                                1:0 /* RWXUF */
#define NV_PFIFO_CACHE0_ENGINE_0_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_0_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_0_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_1                                5:4 /* RWXUF */
#define NV_PFIFO_CACHE0_ENGINE_1_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_1_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_1_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_2                                9:8 /* RWXUF */
#define NV_PFIFO_CACHE0_ENGINE_2_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_2_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_2_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_3                              13:12 /* RWXUF */
#define NV_PFIFO_CACHE0_ENGINE_3_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_3_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_3_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_4                              17:16 /* RWXUF */
#define NV_PFIFO_CACHE0_ENGINE_4_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_4_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_4_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_5                              21:20 /* RWXUF */
#define NV_PFIFO_CACHE0_ENGINE_5_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_5_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_5_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_6                              25:24 /* RWXUF */
#define NV_PFIFO_CACHE0_ENGINE_6_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_6_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_6_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_7                              29:28 /* RWXUF */
#define NV_PFIFO_CACHE0_ENGINE_7_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_7_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE0_ENGINE_7_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE                           0x00003280 /* RW-4R */
#define NV_PFIFO_CACHE1_ENGINE_0                                1:0 /* RWXUF */
#define NV_PFIFO_CACHE1_ENGINE_0_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_0_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_0_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_1                                5:4 /* RWXUF */
#define NV_PFIFO_CACHE1_ENGINE_1_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_1_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_1_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_2                                9:8 /* RWXUF */
#define NV_PFIFO_CACHE1_ENGINE_2_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_2_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_2_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_3                              13:12 /* RWXUF */
#define NV_PFIFO_CACHE1_ENGINE_3_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_3_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_3_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_4                              17:16 /* RWXUF */
#define NV_PFIFO_CACHE1_ENGINE_4_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_4_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_4_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_5                              21:20 /* RWXUF */
#define NV_PFIFO_CACHE1_ENGINE_5_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_5_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_5_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_6                              25:24 /* RWXUF */
#define NV_PFIFO_CACHE1_ENGINE_6_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_6_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_6_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_7                              29:28 /* RWXUF */
#define NV_PFIFO_CACHE1_ENGINE_7_SW                      0x00000000 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_7_GRAPHICS                0x00000001 /* RW--V */
#define NV_PFIFO_CACHE1_ENGINE_7_DVD                     0x00000002 /* RW--V */
#define NV_PFIFO_CACHE0_METHOD(i)                (0x00003100+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE0_METHOD__SIZE_1                            1 /*       */
#define NV_PFIFO_CACHE0_METHOD_ADDRESS                         12:2 /* RWXUF */
#define NV_PFIFO_CACHE0_METHOD_SUBCHANNEL                     15:13 /* RWXUF */
#define NV_PFIFO_CACHE1_METHOD(i)                (0x00003800+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE1_METHOD__SIZE_1                          128 /*       */
#define NV_PFIFO_CACHE1_METHOD_ADDRESS                         12:2 /* RWXUF */
#define NV_PFIFO_CACHE1_METHOD_SUBCHANNEL                     15:13 /* RWXUF */
#define NV_PFIFO_CACHE1_METHOD_ALIAS(i)          (0x00003C00+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE1_METHOD_ALIAS__SIZE_1                    128 /*       */
#define NV_PFIFO_CACHE0_DATA(i)                  (0x00003104+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE0_DATA__SIZE_1                              1 /*       */
#define NV_PFIFO_CACHE0_DATA_VALUE                             31:0 /* RWXVF */
#define NV_PFIFO_CACHE1_DATA(i)                  (0x00003804+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE1_DATA__SIZE_1                            128 /*       */
#define NV_PFIFO_CACHE1_DATA_VALUE                             31:0 /* RWXVF */
#define NV_PFIFO_CACHE1_DATA_ALIAS(i)            (0x00003C04+(i)*8) /* RW-4A */
#define NV_PFIFO_CACHE1_DATA_ALIAS__SIZE_1                      128 /*       */
#define NV_PFIFO_DEVICE(i)                       (0x00002800+(i)*4) /* R--4A */
#define NV_PFIFO_DEVICE__SIZE_1                                 128 /*       */
#define NV_PFIFO_DEVICE_CHID                                    3:0 /* R--UF */
#define NV_PFIFO_DEVICE_SWITCH                                24:24 /* R--VF */
#define NV_PFIFO_DEVICE_SWITCH_UNAVAILABLE               0x00000000 /* R---V */
#define NV_PFIFO_DEVICE_SWITCH_AVAILABLE                 0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS                           0x00002400 /* R--4R */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT                           0:0 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT_FALSE              0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_RANOUT_TRUE               0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK                         4:4 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK_NOT_EMPTY        0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_LOW_MARK_EMPTY            0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK                        8:8 /* R--VF */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK_NOT_FULL        0x00000000 /* R---V */
#define NV_PFIFO_RUNOUT_STATUS_HIGH_MARK_FULL            0x00000001 /* R---V */
#define NV_PFIFO_RUNOUT_PUT                              0x00002410 /* RW-4R */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS                            12:3 /* RWXUF */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_0                     8:3 /* RWXUF */
#define NV_PFIFO_RUNOUT_PUT_ADDRESS__SIZE_1                    12:3 /* RWXUF */
#define NV_PFIFO_RUNOUT_GET                              0x00002420 /* RW-4R */
#define NV_PFIFO_RUNOUT_GET_ADDRESS                            13:3 /* RWXUF */
/* dev_graphics.ref */
#define NV_PGRAPH                             0x00401FFF:0x00400000 /* RW--D */
#define NV_PGRAPH_DEBUG_0                                0x00400080 /* RW-4R */
#define NV_PGRAPH_DEBUG_0_STATE                                 0:0 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_STATE_NORMAL                   0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_STATE_RESET                    0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_FE_STATE                              1:1 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_FE_STATE_NORMAL                0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_FE_STATE_RESET                 0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_CACHE_STATE                           2:2 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_CACHE_STATE_NORMAL             0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_CACHE_STATE_RESET              0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_D3D_PIPE_STATE                        3:3 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_D3D_PIPE_STATE_NORMAL          0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_D3D_PIPE_STATE_RESET           0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_PREROP_STATE                          4:4 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_PREROP_STATE_NORMAL            0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_PREROP_STATE_RESET             0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_ROP_STATE                             5:5 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_ROP_STATE_NORMAL               0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_ROP_STATE_RESET                0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_RSTR_STATE                            6:6 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_RSTR_STATE_NORMAL              0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_RSTR_STATE_RESET               0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_LIGHT_STATE                           7:7 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_LIGHT_STATE_NORMAL             0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_LIGHT_STATE_RESET              0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_DMA_STATE                             8:8 /* CWIVF */
#define NV_PGRAPH_DEBUG_0_DMA_STATE_NORMAL               0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_0_DMA_STATE_RESET                0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_0_SPARE1                              12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_SPARE1_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_SPARE1_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_SPARE2                              13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_SPARE2_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_SPARE2_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_MINUSD5                             14:14 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_MINUSD5_DISABLED               0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_MINUSD5_ENABLED                0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_BLIT_DST_LIMIT                      15:15 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_BLIT_DST_LIMIT_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_BLIT_DST_LIMIT_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_LIMIT_CHECK                         16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_LIMIT_CHECK_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_LIMIT_CHECK_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_LIMIT_INT                           17:17 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_LIMIT_INT_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_LIMIT_INT_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_OVRFLW_INT                          18:18 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_OVRFLW_INT_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_OVRFLW_INT_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_2D                  20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_2D_DISABLED    0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_2D_ENABLED     0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_3D                  21:21 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_3D_DISABLED    0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_WRITE_ONLY_ROPS_3D_ENABLED     0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO                        24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_AUTO_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_Y                           25:25 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_Y_DECR                 0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_DRAWDIR_Y_INCR                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT                         28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_0_ALPHA_ABORT_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1                                0x00400084 /* RW-4R */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET                        0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET_NOT_LAST        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_VOLATILE_RESET_LAST            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY                          4:4 /* CWIVF */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY_IGNORE            0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_1_DMA_ACTIVITY_CANCEL            0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_1_PATCH_INV                             8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_PATCH_INV_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_PATCH_INV_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS                            12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TRI_OPTS_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_TRICLIP_OPTS                        13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_TRICLIP_OPTS_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_TRICLIP_OPTS_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_INSTANCE                            16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_INSTANCE_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_INSTANCE_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_CTX                                 20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_CTX_DISABLED                   0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_CTX_ENABLED                    0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_CACHE                               24:24 /* CWIVF */
#define NV_PGRAPH_DEBUG_1_CACHE_IGNORE                   0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_1_CACHE_FLUSH                    0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_1_CACHE_MODE                          25:25 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_CACHE_MODE_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_CACHE_MODE_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_ZCLAMP                              28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_ZCLAMP_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_ZCLAMP_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_UCLAMP                              29:29 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_UCLAMP_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_UCLAMP_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_1_RCLAMP                              30:30 /* RWIVF */
#define NV_PGRAPH_DEBUG_1_RCLAMP_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_1_RCLAMP_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2                                0x00400088 /* RW-4R */
#define NV_PGRAPH_DEBUG_2_PINGPONG                              0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_PINGPONG_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_PINGPONG_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE1                                4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE1_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE1_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE2                                5:5 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE2_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE2_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE3                                6:6 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE3_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE3_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE4                                7:7 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE4_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE4_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE5                                8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE5_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE5_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE6                                9:9 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE6_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE6_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE7                              10:10 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE7_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE7_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPARE8                              11:11 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPARE8_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPARE8_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_BILINEAR_3D                         12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_BILINEAR_3D_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_BILINEAR_3D_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D                      13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_ANISOTROPIC_3D_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_FOG_3D                              14:14 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_FOG_3D_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_FOG_3D_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_SPECULAR_3D                         15:15 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_SPECULAR_3D_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_SPECULAR_3D_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_ALPHA_3D                            16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_ALPHA_3D_DISABLED              0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_ALPHA_3D_ENABLED               0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_ZBUF_SEQ                            18:17 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_ZBUF_SEQ_CRZRWCW               0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_ZBUF_SEQ_ZRWCRW                0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_ZBUF_SEQ_AUTO                  0x00000002 /* RW--V */
#define NV_PGRAPH_DEBUG_2_COELESCE_D3D                        20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_COELESCE_D3D_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_COELESCE_D3D_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_COELESCE_2D                         22:22 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_COELESCE_2D_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_COELESCE_2D_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_FAST_VERTEX_LOAD                    23:23 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_FAST_VERTEX_LOAD1_DISABLED     0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_FAST_VERTEX_LOAD_ENABLED       0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_BLIT_MULTILINE                      24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_BLIT_MULTILINE_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_BLIT_MULTILINE_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET                      28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_2_VOLATILE_RESET_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3                                0x0040008C /* RW-4R */
#define NV_PGRAPH_DEBUG_3_CULLING                               0:0 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_CULLING_DISABLED               0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_CULLING_ENABLED                0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_CULLING_TYPE                          1:1 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_CULLING_TYPE_DX3               0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_CULLING_TYPE_DX5               0x00000001 /* RW--V */  
#define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH                      4:4 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH_DISABLED      0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_STRTCH_ENABLED       0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D                         5:5 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FAST_DATA_D3D_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_ZFLUSH                                7:7 /* CWIVF */
#define NV_PGRAPH_DEBUG_3_ZFLUSH_IGNORE                  0x00000000 /* CWI-V */
#define NV_PGRAPH_DEBUG_3_ZFLUSH_ACTIVATE                0x00000001 /* -W--T */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_PTZ                        8:8 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_PTZ_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_PTZ_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_D3D                        9:9 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_D3D_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_AUTOZFLUSH_D3D_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_PTZ                   10:10 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_PTZ_DISABLED     0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_PTZ_ENABLED      0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_D3D                   11:11 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_D3D_DISABLED     0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_SLOT_CONFLICT_D3D_ENABLED      0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_POSTDITHER_2D                       12:12 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_POSTDITHER_2D_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_POSTDITHER_2D_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_POSTDITHER_3D                       13:13 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_POSTDITHER_3D_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_POSTDITHER_3D_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_PREDITHER_2D                        14:14 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_PREDITHER_2D_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_PREDITHER_2D_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_PREDITHER_3D                        15:15 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_PREDITHER_3D_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_PREDITHER_3D_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FORCE_CREAD                         16:16 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FORCE_CREAD_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FORCE_CREAD_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FORCE_ZREAD                         17:17 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FORCE_ZREAD_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FORCE_ZREAD_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT                        18:18 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_EARLYZ_ABORT_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_TRIEND_FLUSH                        19:19 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_TRIEND_FLUSH_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_TRIEND_FLUSH_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK                          20:20 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL                     21:21 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL_DISABLED       0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_DATA_CHECK_FAIL_ENABLED        0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_FORMAT_CHECK                        22:22 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_FORMAT_CHECK_DISABLED          0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_FORMAT_CHECK_ENABLED           0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_DMA_CHECK                           23:23 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_DMA_CHECK_DISABLED             0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_DMA_CHECK_ENABLED              0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_RAMREADBACK                         24:24 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_RAMREADBACK_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_RAMREADBACK_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_DEBUG_3_STATE_CHECK                         28:28 /* RWIVF */
#define NV_PGRAPH_DEBUG_3_STATE_CHECK_DISABLED           0x00000000 /* RWI-V */
#define NV_PGRAPH_DEBUG_3_STATE_CHECK_ENABLED            0x00000001 /* RW--V */
#define NV_PGRAPH_INTR                                   0x00400100 /* RW-4R */
#define NV_PGRAPH_INTR_NOTIFY                                   0:0 /* RWIVF */
#define NV_PGRAPH_INTR_NOTIFY_NOT_PENDING                0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_NOTIFY_PENDING                    0x00000001 /* R---V */
#define NV_PGRAPH_INTR_NOTIFY_RESET                      0x00000001 /* -W--C */
#define NV_PGRAPH_INTR_MISSING_HW                               4:4 /* RWIVF */
#define NV_PGRAPH_INTR_MISSING_HW_NOT_PENDING            0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_MISSING_HW_PENDING                0x00000001 /* R---V */
#define NV_PGRAPH_INTR_MISSING_HW_RESET                  0x00000001 /* -W--C */
#define NV_PGRAPH_INTR_TLB_PRESENT_A                            8:8 /* RWIVF */
#define NV_PGRAPH_INTR_TLB_PRESENT_A_NOT_PENDING         0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_TLB_PRESENT_A_PENDING             0x00000001 /* R---V */
#define NV_PGRAPH_INTR_TLB_PRESENT_A_RESET               0x00000001 /* -W--C */
#define NV_PGRAPH_INTR_TLB_PRESENT_B                            9:9 /* RWIVF */
#define NV_PGRAPH_INTR_TLB_PRESENT_B_NOT_PENDING         0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_TLB_PRESENT_B_PENDING             0x00000001 /* R---V */
#define NV_PGRAPH_INTR_TLB_PRESENT_B_RESET               0x00000001 /* -W--C */
#define NV_PGRAPH_INTR_CONTEXT_SWITCH                         12:12 /* RWIVF */
#define NV_PGRAPH_INTR_CONTEXT_SWITCH_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_CONTEXT_SWITCH_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_INTR_CONTEXT_SWITCH_RESET              0x00000001 /* -W--C */
#define NV_PGRAPH_INTR_BUFFER_NOTIFY                          16:16 /* RWIVF */
#define NV_PGRAPH_INTR_BUFFER_NOTIFY_NOT_PENDING         0x00000000 /* R-I-V */
#define NV_PGRAPH_INTR_BUFFER_NOTIFY_PENDING             0x00000001 /* R---V */
#define NV_PGRAPH_INTR_BUFFER_NOTIFY_RESET               0x00000001 /* -W--C */
#define NV_PGRAPH_NSTATUS                                0x00400104 /* RW-4R */
#define NV_PGRAPH_NSTATUS_STATE_IN_USE                        11:11 /* RWIVF */
#define NV_PGRAPH_NSTATUS_STATE_IN_USE_NOT_PENDING       0x00000000 /* RWI-V */
#define NV_PGRAPH_NSTATUS_STATE_IN_USE_PENDING           0x00000001 /* RW--V */
#define NV_PGRAPH_NSTATUS_INVALID_STATE                       12:12 /* RWIVF */
#define NV_PGRAPH_NSTATUS_INVALID_STATE_NOT_PENDING      0x00000000 /* RWI-V */
#define NV_PGRAPH_NSTATUS_INVALID_STATE_PENDING          0x00000001 /* RW--V */
#define NV_PGRAPH_NSTATUS_BAD_ARGUMENT                        13:13 /* RWIVF */
#define NV_PGRAPH_NSTATUS_BAD_ARGUMENT_NOT_PENDING       0x00000000 /* RWI-V */
#define NV_PGRAPH_NSTATUS_BAD_ARGUMENT_PENDING           0x00000001 /* RW--V */
#define NV_PGRAPH_NSTATUS_PROTECTION_FAULT                    14:14 /* RWIVF */
#define NV_PGRAPH_NSTATUS_PROTECTION_FAULT_NOT_PENDING   0x00000000 /* RWI-V */
#define NV_PGRAPH_NSTATUS_PROTECTION_FAULT_PENDING       0x00000001 /* RW--V */
#define NV_PGRAPH_NSOURCE                                0x00400108 /* R--4R */
#define NV_PGRAPH_NSOURCE_NOTIFICATION                          0:0 /* R-IVF */
#define NV_PGRAPH_NSOURCE_NOTIFICATION_NOT_PENDING       0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_NOTIFICATION_PENDING           0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_DATA_ERROR                            1:1 /* R-IVF */
#define NV_PGRAPH_NSOURCE_DATA_ERROR_NOT_PENDING         0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_DATA_ERROR_PENDING             0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_PROTECTION_ERROR                      2:2 /* R-IVF */
#define NV_PGRAPH_NSOURCE_PROTECTION_ERROR_NOT_PENDING   0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_PROTECTION_ERROR_PENDING       0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_RANGE_EXCEPTION                       3:3 /* R-IVF */
#define NV_PGRAPH_NSOURCE_RANGE_EXCEPTION_NOT_PENDING    0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_RANGE_EXCEPTION_PENDING        0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_LIMIT_COLOR                           4:4 /* R-IVF */
#define NV_PGRAPH_NSOURCE_LIMIT_COLOR_NOT_PENDING        0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_LIMIT_COLOR_PENDING            0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_LIMIT_ZETA_                           5:5 /* R-IVF */
#define NV_PGRAPH_NSOURCE_LIMIT_ZETA_NOT_PENDING         0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_LIMIT_ZETA_PENDING             0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_ILLEGAL_MTHD                          6:6 /* R-IVF */
#define NV_PGRAPH_NSOURCE_ILLEGAL_MTHD_NOT_PENDING       0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_ILLEGAL_MTHD_PENDING           0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_DMA_R_PROTECTION                      7:7 /* R-IVF */
#define NV_PGRAPH_NSOURCE_DMA_R_PROTECTION_NOT_PENDING   0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_DMA_R_PROTECTION_PENDING       0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_DMA_W_PROTECTION                      8:8 /* R-IVF */
#define NV_PGRAPH_NSOURCE_DMA_W_PROTECTION_NOT_PENDING   0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_DMA_W_PROTECTION_PENDING       0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_FORMAT_EXCEPTION                      9:9 /* R-IVF */
#define NV_PGRAPH_NSOURCE_FORMAT_EXCEPTION_NOT_PENDING   0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_FORMAT_EXCEPTION_PENDING       0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_PATCH_EXCEPTION                     10:10 /* R-IVF */
#define NV_PGRAPH_NSOURCE_PATCH_EXCEPTION_NOT_PENDING    0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_PATCH_EXCEPTION_PENDING        0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_STATE_INVALID                       11:11 /* R-IVF */
#define NV_PGRAPH_NSOURCE_STATE_INVALID_NOT_PENDING      0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_STATE_INVALID_PENDING          0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_DOUBLE_NOTIFY                       12:12 /* R-IVF */
#define NV_PGRAPH_NSOURCE_DOUBLE_NOTIFY_NOT_PENDING      0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_DOUBLE_NOTIFY_PENDING          0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_NOTIFY_IN_USE                       13:13 /* R-IVF */
#define NV_PGRAPH_NSOURCE_NOTIFY_IN_USE_NOT_PENDING      0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_NOTIFY_IN_USE_PENDING          0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_METHOD_CNT                          14:14 /* R-IVF */
#define NV_PGRAPH_NSOURCE_METHOD_CNT_NOT_PENDING         0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_METHOD_CNT_PENDING             0x00000001 /* R---V */
#define NV_PGRAPH_NSOURCE_BFR_NOTIFICATION                    15:15 /* R-IVF */
#define NV_PGRAPH_NSOURCE_BFR_NOTIFICATION_NOT_PENDING   0x00000000 /* R-I-V */
#define NV_PGRAPH_NSOURCE_BFR_NOTIFICATION_PENDING       0x00000001 /* R---V */
#define NV_PGRAPH_INTR_EN                                0x00400140 /* RW-4R */
#define NV_PGRAPH_INTR_EN_NOTIFY                                0:0 /* RWIVF */
#define NV_PGRAPH_INTR_EN_NOTIFY_DISABLED                0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_NOTIFY_ENABLED                 0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_MISSING_HW                            4:4 /* RWIVF */
#define NV_PGRAPH_INTR_EN_MISSING_HW_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_MISSING_HW_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_TLB_PRESENT_A                         8:8 /* RWIVF */
#define NV_PGRAPH_INTR_EN_TLB_PRESENT_A_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_TLB_PRESENT_A_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_TLB_PRESENT_B                         9:9 /* RWIVF */
#define NV_PGRAPH_INTR_EN_TLB_PRESENT_B_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_TLB_PRESENT_B_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_CONTEXT_SWITCH                      12:12 /* RWIVF */
#define NV_PGRAPH_INTR_EN_CONTEXT_SWITCH_DISABLED        0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_CONTEXT_SWITCH_ENABLED         0x00000001 /* RW--V */
#define NV_PGRAPH_INTR_EN_BUFFER_NOTIFY                       16:16 /* RWIVF */
#define NV_PGRAPH_INTR_EN_BUFFER_NOTIFY_DISABLED         0x00000000 /* RWI-V */
#define NV_PGRAPH_INTR_EN_BUFFER_NOTIFY_ENABLED          0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1                            0x00400160 /* RW-4R */
#define NV_PGRAPH_CTX_SWITCH1_GRCLASS                           7:0 /* RWXVF */
#define NV_PGRAPH_CTX_SWITCH1_CHROMA_KEY                      12:12 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH1_CHROMA_KEY_DISABLE         0x00000000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_CHROMA_KEY_ENABLE          0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_USER_CLIP                       13:13 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH1_USER_CLIP_DISABLE          0x00000000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_USER_CLIP_ENABLE           0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_SWIZZLE                         14:14 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH1_SWIZZLE_DISABLE            0x00000000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_SWIZZLE_ENABLE             0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG                    17:15 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG_SRCCOPY_AND   0x00000000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG_ROP_AND       0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG_BLEND_AND     0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG_SRCCOPY       0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG_SRCCOPY_PRE   0x00000004 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_PATCH_CONFIG_BLEND_PRE     0x00000005 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_PATCH_STATUS                    24:24 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH1_PATCH_STATUS_INVALID       0x00000000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_PATCH_STATUS_VALID         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_CONTEXT_SURFACE                 25:25 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH1_CONTEXT_SURFACE_INVALID    0x00000000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_CONTEXT_SURFACE_VALID      0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH1_VOLATILE_RESET                  31:31 /* CWIVF */
#define NV_PGRAPH_CTX_SWITCH1_VOLATILE_RESET_IGNORE      0x00000000 /* CWI-V */
#define NV_PGRAPH_CTX_SWITCH1_VOLATILE_RESET_ENABLED     0x00000001 /* -W--T */
#define NV_PGRAPH_CTX_SWITCH2                            0x00400164 /* RW-4R */
#define NV_PGRAPH_CTX_SWITCH2_MONO_FORMAT                       1:0 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH2_MONO_FORMAT_INVALID              0x00 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_MONO_FORMAT_CGA6_M1              0x01 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_MONO_FORMAT_LE_M1                0x02 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT                     13:8 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_INVALID             0x00 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_Y8               0x01 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_X16A8Y8          0x02 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_X24Y8            0x03 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_A1R5G5B5         0x06 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_X1R5G5B5         0x07 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_X16A1R5G5B5      0x08 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_X17R5G5B5        0x09 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_R5G6B5           0x0A /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_A16R5G6B5        0x0B /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_X16R5G6B5        0x0C /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_A8R8G8B8         0x0D /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_X8R8G8B8         0x0E /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_Y16              0x0F /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_A16Y16           0x10 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_X16Y16           0x11 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_V8YB8U8YA8       0x12 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_YB8V8YA8U8       0x13 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_COLOR_FORMAT_LE_Y32              0x14 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH2_NOTIFY_INSTANCE                 31:16 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH2_NOTIFY_INSTANCE_INVALID        0x0000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH3                            0x00400168 /* RW-4R */
#define NV_PGRAPH_CTX_SWITCH3_DMA_INSTANCE_0                   15:0 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH3_DMA_INSTANCE_0_INVALID         0x0000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH3_DMA_INSTANCE_1                  31:16 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH3_DMA_INSTANCE_1_INVALID         0x0000 /* RW--V */
#define NV_PGRAPH_CTX_SWITCH4                            0x0040016C /* RW-4R */
#define NV_PGRAPH_CTX_SWITCH4_USER_INSTANCE                    15:0 /* RWXUF */
#define NV_PGRAPH_CTX_SWITCH4_USER_INSTANCE_INVALID          0x0000 /* RW--V */
#define NV_PGRAPH_CTX_CACHE1(i)                  (0x00400180+(i)*4) /* RW-4A */
#define NV_PGRAPH_CTX_CACHE1__SIZE_1                              8 /*       */
#define NV_PGRAPH_CTX_CACHE1_GRCLASS                            7:0 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_CHROMA_KEY                       12:12 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_USER_CLIP                        13:13 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_SWIZZLE                          14:14 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_PATCH_CONFIG                     19:15 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_SPARE1                           20:20 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_PATCH_STATUS                     24:24 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE1_CONTEXT_SURFACE                  25:25 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE2(i)                  (0x004001a0+(i)*4) /* RW-4A */
#define NV_PGRAPH_CTX_CACHE2__SIZE_1                              8 /*       */
#define NV_PGRAPH_CTX_CACHE2_MONO_FORMAT                        1:0 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE2_COLOR_FORMAT                      13:8 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE2_NOTIFY_INSTANCE                  31:16 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE3(i)                  (0x004001c0+(i)*4) /* RW-4A */
#define NV_PGRAPH_CTX_CACHE3__SIZE_1                              8 /*       */
#define NV_PGRAPH_CTX_CACHE3_DMA_INSTANCE_0                    15:0 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE3_DMA_INSTANCE_1                   31:16 /* RWXVF */
#define NV_PGRAPH_CTX_CACHE4(i)                  (0x004001e0+(i)*4) /* RW-4A */
#define NV_PGRAPH_CTX_CACHE4__SIZE_1                              8 /*       */
#define NV_PGRAPH_CTX_CACHE4_USER_INSTANCE                     15:0 /* RWXVF */
#define NV_PGRAPH_CTX_CONTROL                            0x00400170 /* RW-4R */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME                      1:0 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_33US          0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_262US         0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_2MS           0x00000002 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_MINIMUM_TIME_17MS          0x00000003 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_TIME                              8:8 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_TIME_EXPIRED               0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_TIME_NOT_EXPIRED           0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_CHID                            16:16 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_CHID_INVALID               0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_CHID_VALID                 0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_CHANGE                          20:20 /* R--VF */
#define NV_PGRAPH_CTX_CONTROL_CHANGE_UNAVAILABLE         0x00000000 /* R---V */
#define NV_PGRAPH_CTX_CONTROL_CHANGE_AVAILABLE           0x00000001 /* R---V */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING                       24:24 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING_IDLE             0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_SWITCHING_BUSY             0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_CONTROL_DEVICE                          28:28 /* RWIVF */
#define NV_PGRAPH_CTX_CONTROL_DEVICE_DISABLED            0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_CONTROL_DEVICE_ENABLED             0x00000001 /* RW--V */
#define NV_PGRAPH_CTX_USER                               0x00400174 /* RW-4R */
#define NV_PGRAPH_CTX_USER_SUBCH                              15:13 /* RWIVF */
#define NV_PGRAPH_CTX_USER_SUBCH_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_CTX_USER_CHID                               27:24 /* RWIVF */
#define NV_PGRAPH_CTX_USER_CHID_0                        0x00000000 /* RWI-V */
#define NV_PGRAPH_FIFO                                   0x00400720 /* RW-4R */
#define NV_PGRAPH_FIFO_ACCESS                                   0:0 /* RWIVF */
#define NV_PGRAPH_FIFO_ACCESS_DISABLED                   0x00000000 /* RW--V */
#define NV_PGRAPH_FIFO_ACCESS_ENABLED                    0x00000001 /* RWI-V */
#define NV_PGRAPH_FFINTFC_FIFO_0(i)              (0x00400730+(i)*4) /* RW-4A */
#define NV_PGRAPH_FFINTFC_FIFO_0__SIZE_1                          4 /*       */
#define NV_PGRAPH_FFINTFC_FIFO_0_TAG                            0:0 /* RWXVF */
#define NV_PGRAPH_FFINTFC_FIFO_0_TAG_MTHD                0x00000000 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_TAG_CHSW                0x00000001 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH                          3:1 /* RWXVF */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH_0                 0x00000000 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH_1                 0x00000001 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH_2                 0x00000002 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH_3                 0x00000003 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH_4                 0x00000004 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH_5                 0x00000005 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH_6                 0x00000006 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_SUBCH_7                 0x00000007 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_0_MTHD                          14:4 /* RWXVF */
#define NV_PGRAPH_FFINTFC_FIFO_0_MTHD_CTX_SWITCH         0x00000000 /* RW--V */
#define NV_PGRAPH_FFINTFC_FIFO_1(i)              (0x00400740+(i)*4) /* RW-4A */
#define NV_PGRAPH_FFINTFC_FIFO_1__SIZE_1                          4 /*       */
#define NV_PGRAPH_FFINTFC_FIFO_1_ARGUMENT                      31:0 /* RWXVF */
#define NV_PGRAPH_FFINTFC_FIFO_PTR                       0x00400750 /* RW-4R */
#define NV_PGRAPH_FFINTFC_FIFO_PTR_WRITE                        2:0 /* RWIVF */
#define NV_PGRAPH_FFINTFC_FIFO_PTR_WRITE_0               0x00000000 /* RWI-V */
#define NV_PGRAPH_FFINTFC_FIFO_PTR_READ                         6:4 /* RWIVF */
#define NV_PGRAPH_FFINTFC_FIFO_PTR_READ_0                0x00000000 /* RWI-V */
#define NV_PGRAPH_FFINTFC_ST2                            0x00400754 /* RW-4R */
#define NV_PGRAPH_FFINTFC_ST2_STATUS                            0:0 /* RWIVF */
#define NV_PGRAPH_FFINTFC_ST2_STATUS_INVALID             0x00000000 /* RWI-V */
#define NV_PGRAPH_FFINTFC_ST2_STATUS_VALID               0x00000001 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_MTHD                             11:1 /* RWIVF */
#define NV_PGRAPH_FFINTFC_ST2_MTHD_CTX_SWITCH            0x00000000 /* RWI-V */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH                           14:12 /* RWIVF */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH_0                    0x00000000 /* RWI-V */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH_1                    0x00000001 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH_2                    0x00000002 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH_3                    0x00000003 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH_4                    0x00000004 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH_5                    0x00000005 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH_6                    0x00000006 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_SUBCH_7                    0x00000007 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID                            18:15 /* RWIVF */
#define NV_PGRAPH_FFINTFC_ST2_CHID_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_1                     0x00000001 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_2                     0x00000002 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_3                     0x00000003 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_4                     0x00000004 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_5                     0x00000005 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_6                     0x00000006 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_7                     0x00000007 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_8                     0x00000008 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_9                     0x00000009 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_10                    0x0000000A /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_11                    0x0000000B /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_12                    0x0000000C /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_13                    0x0000000D /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_14                    0x0000000E /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_15                    0x0000000F /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_STATUS                     19:19 /* RWIVF */
#define NV_PGRAPH_FFINTFC_ST2_CHID_STATUS_INVALID        0x00000000 /* RWI-V */
#define NV_PGRAPH_FFINTFC_ST2_CHID_STATUS_VALID          0x00000001 /* RW--V */
#define NV_PGRAPH_FFINTFC_ST2_D                          0x00400758 /* RW-4R */
#define NV_PGRAPH_FFINTFC_ST2_D_ARGUMENT                       31:0 /* RWIVF */
#define NV_PGRAPH_FFINTFC_ST2_D_ARGUMENT_0               0x00000000 /* RWI-V */
#define NV_PGRAPH_STATUS                                 0x00400700 /* R--4R */
#define NV_PGRAPH_STATUS_STATE                                  0:0 /* R-IVF */
#define NV_PGRAPH_STATUS_STATE_IDLE                      0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_STATE_BUSY                      0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_XY_LOGIC                               4:4 /* R-IVF */
#define NV_PGRAPH_STATUS_XY_LOGIC_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_XY_LOGIC_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_FE                                     5:5 /* R-IVF */
#define NV_PGRAPH_STATUS_FE_IDLE                         0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_FE_BUSY                         0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_RASTERIZER                             6:6 /* R-IVF */
#define NV_PGRAPH_STATUS_RASTERIZER_IDLE                 0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_RASTERIZER_BUSY                 0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_NOTIFY                            8:8 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_NOTIFY_IDLE                0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_NOTIFY_BUSY                0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_REGISTER                        12:12 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_REGISTER_IDLE              0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_REGISTER_BUSY              0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_DMA                             16:16 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_DMA_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_DMA_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_DMA_ENGINE                           17:17 /* R-IVF */
#define NV_PGRAPH_STATUS_DMA_ENGINE_IDLE                 0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_DMA_ENGINE_BUSY                 0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_DMA_NOTIFY                           20:20 /* R-IVF */
#define NV_PGRAPH_STATUS_DMA_NOTIFY_IDLE                 0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_DMA_NOTIFY_BUSY                 0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_DMA_BUFFER_NOTIFY                    21:21 /* R-IVF */
#define NV_PGRAPH_STATUS_DMA_BUFFER_NOTIFY_IDLE          0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_DMA_BUFFER_NOTIFY_BUSY          0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_D3D                                  24:24 /* R-IVF */
#define NV_PGRAPH_STATUS_D3D_IDLE                        0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_D3D_BUSY                        0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_CACHE                                25:25 /* R-IVF */
#define NV_PGRAPH_STATUS_CACHE_IDLE                      0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_CACHE_BUSY                      0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_LIGHTING                             26:26 /* R-IVF */
#define NV_PGRAPH_STATUS_LIGHTING_IDLE                   0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_LIGHTING_BUSY                   0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PREROP                               27:27 /* R-IVF */
#define NV_PGRAPH_STATUS_PREROP_IDLE                     0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PREROP_BUSY                     0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_ROP                                  28:28 /* R-IVF */
#define NV_PGRAPH_STATUS_ROP_IDLE                        0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_ROP_BUSY                        0x00000001 /* R---V */
#define NV_PGRAPH_STATUS_PORT_USER                            29:29 /* R-IVF */
#define NV_PGRAPH_STATUS_PORT_USER_IDLE                  0x00000000 /* R-I-V */
#define NV_PGRAPH_STATUS_PORT_USER_BUSY                  0x00000001 /* R---V */
#define NV_PGRAPH_TRAPPED_ADDR                           0x00400704 /* R--4R */
#define NV_PGRAPH_TRAPPED_ADDR_MTHD                            12:2 /* R-XUF */
#define NV_PGRAPH_TRAPPED_ADDR_SUBCH                          15:13 /* R-XUF */
#define NV_PGRAPH_TRAPPED_ADDR_CHID                           27:24 /* R-XUF */
#define NV_PGRAPH_TRAPPED_DATA                           0x00400708 /* R--4R */
#define NV_PGRAPH_TRAPPED_DATA_VALUE                           31:0 /* R-XVF */
#define NV_PGRAPH_SURFACE                                0x0040070C /* RW-4R */
#define NV_PGRAPH_SURFACE_TYPE                                  1:0 /* RWIVF */
#define NV_PGRAPH_SURFACE_TYPE_INVALID                   0x00000000 /* RWI-V */
#define NV_PGRAPH_SURFACE_TYPE_NON_SWIZZLE               0x00000001 /* RW--V */
#define NV_PGRAPH_SURFACE_TYPE_SWIZZLE                   0x00000002 /* RW--V */
#define NV_PGRAPH_NOTIFY                                 0x00400714 /* RW-4R */
#define NV_PGRAPH_NOTIFY_BUFFER_REQ                             0:0 /* RWIVF */
#define NV_PGRAPH_NOTIFY_BUFFER_REQ_NOT_PENDING          0x00000000 /* RWI-V */
#define NV_PGRAPH_NOTIFY_BUFFER_REQ_PENDING              0x00000001 /* RW--V */
#define NV_PGRAPH_NOTIFY_BUFFER_STYLE                           8:8 /* RWIVF */
#define NV_PGRAPH_NOTIFY_BUFFER_STYLE_WRITE_ONLY         0x00000000 /* RWI-V */
#define NV_PGRAPH_NOTIFY_BUFFER_STYLE_WRITE_THEN_AWAKEN  0x00000001 /* RW--V */
#define NV_PGRAPH_NOTIFY_REQ                                  16:16 /* RWIVF */
#define NV_PGRAPH_NOTIFY_REQ_NOT_PENDING                 0x00000000 /* RWI-V */
#define NV_PGRAPH_NOTIFY_REQ_PENDING                     0x00000001 /* RW--V */
#define NV_PGRAPH_NOTIFY_STYLE                                20:20 /* RWIVF */
#define NV_PGRAPH_NOTIFY_STYLE_WRITE_ONLY                0x00000000 /* RWI-V */
#define NV_PGRAPH_NOTIFY_STYLE_WRITE_THEN_AWAKEN         0x00000001 /* RW--V */
#define NV_PGRAPH_BOFFSET(i)                     (0x00400640+(i)*4) /* RW-4A */
#define NV_PGRAPH_BOFFSET__SIZE_1                                 6 /*       */
#define NV_PGRAPH_BOFFSET_LINADRS                              23:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET_LINADRS_0                      0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET0                               0x00400640 /* RW-4R */
#define NV_PGRAPH_BOFFSET0__ALIAS_1            NV_PGRAPH_BOFFSET(0) /*       */
#define NV_PGRAPH_BOFFSET0_LINADRS                             23:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET0_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET1                               0x00400644 /* RW-4R */
#define NV_PGRAPH_BOFFSET1__ALIAS_1            NV_PGRAPH_BOFFSET(1) /*       */
#define NV_PGRAPH_BOFFSET1_LINADRS                             23:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET1_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET2                               0x00400648 /* RW-4R */
#define NV_PGRAPH_BOFFSET2__ALIAS_1            NV_PGRAPH_BOFFSET(2) /*       */
#define NV_PGRAPH_BOFFSET2_LINADRS                             23:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET2_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET3                               0x0040064C /* RW-4R */
#define NV_PGRAPH_BOFFSET3__ALIAS_1            NV_PGRAPH_BOFFSET(3) /*       */
#define NV_PGRAPH_BOFFSET3_LINADRS                             23:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET3_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET4                               0x00400650 /* RW-4R */
#define NV_PGRAPH_BOFFSET4__ALIAS_1            NV_PGRAPH_BOFFSET(4) /*       */
#define NV_PGRAPH_BOFFSET4_LINADRS                             23:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET4_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BOFFSET5                               0x00400654 /* RW-4R */
#define NV_PGRAPH_BOFFSET5__ALIAS_1            NV_PGRAPH_BOFFSET(5) /*       */
#define NV_PGRAPH_BOFFSET5_LINADRS                             23:0 /* RWIUF */
#define NV_PGRAPH_BOFFSET5_LINADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BBASE(i)                       (0x00400658+(i)*4) /* RW-4A */
#define NV_PGRAPH_BBASE__SIZE_1                                   6 /*       */
#define NV_PGRAPH_BBASE_LINADRS                                23:0 /* RWIUF */
#define NV_PGRAPH_BBASE_LINADRS_0                        0x00000000 /* RWI-V */
#define NV_PGRAPH_BBASE0                                 0x00400658 /* RW-4R */
#define NV_PGRAPH_BBASE0__ALIAS_1                NV_PGRAPH_BBASE(0) /*       */
#define NV_PGRAPH_BBASE0_LINADRS                               23:0 /* RWIUF */
#define NV_PGRAPH_BBASE0_LINADRS_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_BBASE1                                 0x0040065c /* RW-4R */
#define NV_PGRAPH_BBASE1__ALIAS_1                NV_PGRAPH_BBASE(1) /*       */
#define NV_PGRAPH_BBASE1_LINADRS                               23:0 /* RWIUF */
#define NV_PGRAPH_BBASE1_LINADRS_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_BBASE2                                 0x00400660 /* RW-4R */
#define NV_PGRAPH_BBASE2__ALIAS_1                NV_PGRAPH_BBASE(2) /*       */
#define NV_PGRAPH_BBASE2_LINADRS                               23:0 /* RWIUF */
#define NV_PGRAPH_BBASE2_LINADRS_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_BBASE3                                 0x00400664 /* RW-4R */
#define NV_PGRAPH_BBASE3__ALIAS_1                NV_PGRAPH_BBASE(3) /*       */
#define NV_PGRAPH_BBASE3_LINADRS                               23:0 /* RWIUF */
#define NV_PGRAPH_BBASE3_LINADRS_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_BBASE4                                 0x00400668 /* RW-4R */
#define NV_PGRAPH_BBASE4__ALIAS_1                NV_PGRAPH_BBASE(4) /*       */
#define NV_PGRAPH_BBASE4_LINADRS                               23:0 /* RWIUF */
#define NV_PGRAPH_BBASE4_LINADRS_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_BBASE5                                 0x0040066C /* RW-4R */
#define NV_PGRAPH_BBASE5__ALIAS_1                NV_PGRAPH_BBASE(5) /*       */
#define NV_PGRAPH_BBASE5_LINADRS                               23:0 /* RWIUF */
#define NV_PGRAPH_BBASE5_LINADRS_0                       0x00000000 /* RWI-V */
#define NV_PGRAPH_BPITCH(i)                      (0x00400670+(i)*4) /* RW-4A */
#define NV_PGRAPH_BPITCH__SIZE_1                                  5 /*       */
#define NV_PGRAPH_BPITCH_VALUE                                 12:0 /* RWIUF */
#define NV_PGRAPH_BPITCH_VALUE_0                         0x00000000 /* RWI-V */
#define NV_PGRAPH_BPITCH0                                0x00400670 /* RW-4R */
#define NV_PGRAPH_BPITCH0__ALIAS_1              NV_PGRAPH_BPITCH(0) /*       */
#define NV_PGRAPH_BPITCH0_VALUE                                12:0 /* RWIUF */
#define NV_PGRAPH_BPITCH0_VALUE_0                        0x00000000 /* RWI-V */
#define NV_PGRAPH_BPITCH1                                0x00400674 /* RW-4R */
#define NV_PGRAPH_BPITCH1__ALIAS_1              NV_PGRAPH_BPITCH(1) /*       */
#define NV_PGRAPH_BPITCH1_VALUE                                12:0 /* RWIUF */
#define NV_PGRAPH_BPITCH1_VALUE_0                        0x00000000 /* RWI-V */
#define NV_PGRAPH_BPITCH2                                0x00400678 /* RW-4R */
#define NV_PGRAPH_BPITCH2__ALIAS_1              NV_PGRAPH_BPITCH(2) /*       */
#define NV_PGRAPH_BPITCH2_VALUE                                12:0 /* RWIUF */
#define NV_PGRAPH_BPITCH2_VALUE_0                        0x00000000 /* RWI-V */
#define NV_PGRAPH_BPITCH3                                0x0040067C /* RW-4R */
#define NV_PGRAPH_BPITCH3__ALIAS_1              NV_PGRAPH_BPITCH(3) /*       */
#define NV_PGRAPH_BPITCH3_VALUE                                12:0 /* RWIUF */
#define NV_PGRAPH_BPITCH3_VALUE_0                        0x00000000 /* RWI-V */
#define NV_PGRAPH_BPITCH4                                0x00400680 /* RW-4R */
#define NV_PGRAPH_BPITCH4__ALIAS_1              NV_PGRAPH_BPITCH(4) /*       */
#define NV_PGRAPH_BPITCH4_VALUE                                12:0 /* RWIUF */
#define NV_PGRAPH_BPITCH4_VALUE_0                        0x00000000 /* RWI-V */
#define NV_PGRAPH_BLIMIT(i)                      (0x00400684+(i)*4) /* RW-4A */
#define NV_PGRAPH_BLIMIT__SIZE_1                                  6 /*       */
#define NV_PGRAPH_BLIMIT_VALUE                                 23:0 /* RWXUF */
#define NV_PGRAPH_BLIMIT_TYPE                                 31:31 /* RWIVF */
#define NV_PGRAPH_BLIMIT_TYPE_IN_MEMORY                  0x00000000 /* RW--V */
#define NV_PGRAPH_BLIMIT_TYPE_NULL                       0x00000001 /* RWI-V */
#define NV_PGRAPH_BLIMIT0                                0x00400684 /* RW-4R */
#define NV_PGRAPH_BLIMIT0__ALIAS_1              NV_PGRAPH_BLIMIT(0) /*       */
#define NV_PGRAPH_BLIMIT0_VALUE                                23:0 /* RWXUF */
#define NV_PGRAPH_BLIMIT0_TYPE                                31:31 /* RWIVF */
#define NV_PGRAPH_BLIMIT0_TYPE_IN_MEMORY                 0x00000000 /* RW--V */
#define NV_PGRAPH_BLIMIT0_TYPE_NULL                      0x00000001 /* RWI-V */
#define NV_PGRAPH_BLIMIT1                                0x00400688 /* RW-4R */
#define NV_PGRAPH_BLIMIT1__ALIAS_1              NV_PGRAPH_BLIMIT(1) /*       */
#define NV_PGRAPH_BLIMIT1_VALUE                                23:0 /* RWXUF */
#define NV_PGRAPH_BLIMIT1_TYPE                                31:31 /* RWIVF */
#define NV_PGRAPH_BLIMIT1_TYPE_IN_MEMORY                 0x00000000 /* RW--V */
#define NV_PGRAPH_BLIMIT1_TYPE_NULL                      0x00000001 /* RWI-V */
#define NV_PGRAPH_BLIMIT2                                0x0040068c /* RW-4R */
#define NV_PGRAPH_BLIMIT2__ALIAS_1              NV_PGRAPH_BLIMIT(2) /*       */
#define NV_PGRAPH_BLIMIT2_VALUE                                23:0 /* RWXUF */
#define NV_PGRAPH_BLIMIT2_TYPE                                31:31 /* RWIVF */
#define NV_PGRAPH_BLIMIT2_TYPE_IN_MEMORY                 0x00000000 /* RW--V */
#define NV_PGRAPH_BLIMIT2_TYPE_NULL                      0x00000001 /* RWI-V */
#define NV_PGRAPH_BLIMIT3                                0x00400690 /* RW-4R */
#define NV_PGRAPH_BLIMIT3__ALIAS_1              NV_PGRAPH_BLIMIT(3) /*       */
#define NV_PGRAPH_BLIMIT3_VALUE                                23:0 /* RWXUF */
#define NV_PGRAPH_BLIMIT3_TYPE                                31:31 /* RWIVF */
#define NV_PGRAPH_BLIMIT3_TYPE_IN_MEMORY                 0x00000000 /* RW--V */
#define NV_PGRAPH_BLIMIT3_TYPE_NULL                      0x00000001 /* RWI-V */
#define NV_PGRAPH_BLIMIT4                                0x00400694 /* RW-4R */
#define NV_PGRAPH_BLIMIT4__ALIAS_1              NV_PGRAPH_BLIMIT(4) /*       */
#define NV_PGRAPH_BLIMIT4_VALUE                                23:0 /* RWXUF */
#define NV_PGRAPH_BLIMIT4_TYPE                                31:31 /* RWIVF */
#define NV_PGRAPH_BLIMIT4_TYPE_IN_MEMORY                 0x00000000 /* RW--V */
#define NV_PGRAPH_BLIMIT4_TYPE_NULL                      0x00000001 /* RWI-V */
#define NV_PGRAPH_BLIMIT5                                0x00400698 /* RW-4R */
#define NV_PGRAPH_BLIMIT5__ALIAS_1              NV_PGRAPH_BLIMIT(5) /*       */
#define NV_PGRAPH_BLIMIT5_VALUE                                23:0 /* RWXUF */
#define NV_PGRAPH_BLIMIT5_TYPE                                31:31 /* RWIVF */
#define NV_PGRAPH_BLIMIT5_TYPE_IN_MEMORY                 0x00000000 /* RW--V */
#define NV_PGRAPH_BLIMIT5_TYPE_NULL                      0x00000001 /* RWI-V */
#define NV_PGRAPH_BSWIZZLE2                              0x0040069c /* RW-4R */
#define NV_PGRAPH_BSWIZZLE2_WIDTH                             19:16 /* RWIUF */
#define NV_PGRAPH_BSWIZZLE2_WIDTH_0                      0x00000000 /* RWI-V */
#define NV_PGRAPH_BSWIZZLE2_HEIGHT                            27:24 /* RWIUF */
#define NV_PGRAPH_BSWIZZLE2_HEIGHT_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BSWIZZLE5                              0x004006a0 /* RW-4R */
#define NV_PGRAPH_BSWIZZLE5_WIDTH                             19:16 /* RWIUF */
#define NV_PGRAPH_BSWIZZLE5_WIDTH_0                      0x00000000 /* RWI-V */
#define NV_PGRAPH_BSWIZZLE5_HEIGHT                            27:24 /* RWIUF */
#define NV_PGRAPH_BSWIZZLE5_HEIGHT_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_BPIXEL                                 0x00400724 /* RW-4R */
#define NV_PGRAPH_BPIXEL_DEPTH0                                 3:0 /* RWIVF */
#define NV_PGRAPH_BPIXEL_DEPTH0_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_BPIXEL_DEPTH0_Y8                       0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_X1R5G5B5_Z1R5G5B5        0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_X1R5G5B5_O1R5G5B5        0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_A1R5G5B5                 0x00000004 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_R5G6B5                   0x00000005 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_Y16                      0x00000006 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_X8R8G8B8_Z8R8G8B8        0x00000007 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_X8R8G8B8_O1Z7R8G8B8      0x00000008 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_X1A7R8G8B8_Z1A7R8G8B8    0x00000009 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_X1A7R8G8B8_O1A7R8G8B8    0x0000000a /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_X8R8G8B8_O8R8G8B8        0x0000000b /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_A8R8G8B8                 0x0000000c /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_Y32                      0x0000000d /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_V8YB8U8YA8               0x0000000e /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH0_YB8V8YA8U8               0x0000000f /* RW--V */ 
#define NV_PGRAPH_BPIXEL_DEPTH1                                 7:4 /* RWIVF */
#define NV_PGRAPH_BPIXEL_DEPTH1_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_BPIXEL_DEPTH1_Y8                       0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_X1R5G5B5_Z1R5G5B5        0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_X1R5G5B5_O1R5G5B5        0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_A1R5G5B5                 0x00000004 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_R5G6B5                   0x00000005 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_Y16                      0x00000006 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_X8R8G8B8_Z8R8G8B8        0x00000007 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_X8R8G8B8_O1Z7R8G8B8      0x00000008 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_X1A7R8G8B8_Z1A7R8G8B8    0x00000009 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_X1A7R8G8B8_O1A7R8G8B8    0x0000000a /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_X8R8G8B8_O8R8G8B8        0x0000000b /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_A8R8G8B8                 0x0000000c /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_Y32                      0x0000000d /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_V8YB8U8YA8               0x0000000e /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH1_YB8V8YA8U8               0x0000000f /* RW--V */ 
#define NV_PGRAPH_BPIXEL_DEPTH2                                11:8 /* RWIVF */
#define NV_PGRAPH_BPIXEL_DEPTH2_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_BPIXEL_DEPTH2_Y8                       0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_X1R5G5B5_Z1R5G5B5        0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_X1R5G5B5_O1R5G5B5        0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_A1R5G5B5                 0x00000004 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_R5G6B5                   0x00000005 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_Y16                      0x00000006 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_X8R8G8B8_Z8R8G8B8        0x00000007 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_X8R8G8B8_O1Z7R8G8B8      0x00000008 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_X1A7R8G8B8_Z1A7R8G8B8    0x00000009 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_X1A7R8G8B8_O1A7R8G8B8    0x0000000a /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_X8R8G8B8_O8R8G8B8        0x0000000b /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_A8R8G8B8                 0x0000000c /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_Y32                      0x0000000d /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_V8YB8U8YA8               0x0000000e /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH2_YB8V8YA8U8               0x0000000f /* RW--V */ 
#define NV_PGRAPH_BPIXEL_DEPTH3                               15:12 /* RWIVF */
#define NV_PGRAPH_BPIXEL_DEPTH3_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_BPIXEL_DEPTH3_Y8                       0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_X1R5G5B5_Z1R5G5B5        0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_X1R5G5B5_O1R5G5B5        0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_A1R5G5B5                 0x00000004 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_R5G6B5                   0x00000005 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_Y16                      0x00000006 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_X8R8G8B8_Z8R8G8B8        0x00000007 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_X8R8G8B8_O1Z7R8G8B8      0x00000008 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_X1A7R8G8B8_Z1A7R8G8B8    0x00000009 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_X1A7R8G8B8_O1A7R8G8B8    0x0000000a /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_X8R8G8B8_O8R8G8B8        0x0000000b /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_A8R8G8B8                 0x0000000c /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_Y32                      0x0000000d /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_V8YB8U8YA8               0x0000000e /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH3_YB8V8YA8U8               0x0000000f /* RW--V */ 
#define NV_PGRAPH_BPIXEL_DEPTH4                               19:16 /* RWIVF */
#define NV_PGRAPH_BPIXEL_DEPTH4_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_BPIXEL_DEPTH4_Y8                       0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_X1R5G5B5_Z1R5G5B5        0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_X1R5G5B5_O1R5G5B5        0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_A1R5G5B5                 0x00000004 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_R5G6B5                   0x00000005 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_Y16                      0x00000006 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_X8R8G8B8_Z8R8G8B8        0x00000007 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_X8R8G8B8_O1Z7R8G8B8      0x00000008 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_X1A7R8G8B8_Z1A7R8G8B8    0x00000009 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_X1A7R8G8B8_O1A7R8G8B8    0x0000000a /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_X8R8G8B8_O8R8G8B8        0x0000000b /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_A8R8G8B8                 0x0000000c /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_Y32                      0x0000000d /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_V8YB8U8YA8               0x0000000e /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH4_YB8V8YA8U8               0x0000000f /* RW--V */ 
#define NV_PGRAPH_BPIXEL_DEPTH5                               23:20 /* RWIVF */
#define NV_PGRAPH_BPIXEL_DEPTH5_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_BPIXEL_DEPTH5_Y8                       0x00000001 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_X1R5G5B5_Z1R5G5B5        0x00000002 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_X1R5G5B5_O1R5G5B5        0x00000003 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_A1R5G5B5                 0x00000004 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_R5G6B5                   0x00000005 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_Y16                      0x00000006 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_X8R8G8B8_Z8R8G8B8        0x00000007 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_X8R8G8B8_O1Z7R8G8B8      0x00000008 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_X1A7R8G8B8_Z1A7R8G8B8    0x00000009 /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_X1A7R8G8B8_O1A7R8G8B8    0x0000000a /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_X8R8G8B8_O8R8G8B8        0x0000000b /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_A8R8G8B8                 0x0000000c /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_Y32                      0x0000000d /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_V8YB8U8YA8               0x0000000e /* RW--V */
#define NV_PGRAPH_BPIXEL_DEPTH5_YB8V8YA8U8               0x0000000f /* RW--V */ 
#define NV_PGRAPH_LIMIT_VIOL_PIX                         0x00400610 /* RW-4R */
#define NV_PGRAPH_LIMIT_VIOL_PIX_ADRS                          23:0 /* RWIVF */
#define NV_PGRAPH_LIMIT_VIOL_PIX_ADRS_0                  0x00000000 /* RWI-V */
#define NV_PGRAPH_LIMIT_VIOL_PIX_BLIT                         29:29 /* RWIVF */
#define NV_PGRAPH_LIMIT_VIOL_PIX_BLIT_NO_VIOL            0x00000000 /* RWI-V */
#define NV_PGRAPH_LIMIT_VIOL_PIX_BLIT_VIOL               0x00000001 /* RW--V */
#define NV_PGRAPH_LIMIT_VIOL_PIX_LIMIT                        30:30 /* RWIVF */
#define NV_PGRAPH_LIMIT_VIOL_PIX_LIMIT_NO_VIOL           0x00000000 /* RWI-V */
#define NV_PGRAPH_LIMIT_VIOL_PIX_LIMIT_VIOL              0x00000001 /* RW--V */
#define NV_PGRAPH_LIMIT_VIOL_PIX_OVRFLW                       31:31 /* RWIVF */
#define NV_PGRAPH_LIMIT_VIOL_PIX_OVRFLW_NO_VIOL          0x00000000 /* RWI-V */
#define NV_PGRAPH_LIMIT_VIOL_PIX_OVRFLW_VIOL             0x00000001 /* RW--V */
#define NV_PGRAPH_LIMIT_VIOL_Z                           0x00400614 /* RW-4R */
#define NV_PGRAPH_LIMIT_VIOL_Z_ADRS                            23:0 /* RWIVF */
#define NV_PGRAPH_LIMIT_VIOL_Z_ADRS_0                    0x00000000 /* RWI-V */
#define NV_PGRAPH_LIMIT_VIOL_Z_LIMIT                          30:30 /* RWIVF */
#define NV_PGRAPH_LIMIT_VIOL_Z_LIMIT_NO_VIOL             0x00000000 /* RWI-V */
#define NV_PGRAPH_LIMIT_VIOL_Z_LIMIT_VIOL                0x00000001 /* RW--V */
#define NV_PGRAPH_LIMIT_VIOL_Z_OVRFLW                         31:31 /* RWIVF */
#define NV_PGRAPH_LIMIT_VIOL_Z_OVRFLW_NO_VIOL            0x00000000 /* RWI-V */
#define NV_PGRAPH_LIMIT_VIOL_Z_OVRFLW_VIOL               0x00000001 /* RW--V */
#define NV_PGRAPH_STATE                                  0x00400710 /* RW-4R */
#define NV_PGRAPH_STATE_BUFFER_0                                0:0 /* RWIVF */
#define NV_PGRAPH_STATE_BUFFER_0_INVALID                 0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_BUFFER_0_VALID                   0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_BUFFER_1                                1:1 /* RWIVF */
#define NV_PGRAPH_STATE_BUFFER_1_INVALID                 0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_BUFFER_1_VALID                   0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_BUFFER_2                                2:2 /* RWIVF */
#define NV_PGRAPH_STATE_BUFFER_2_INVALID                 0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_BUFFER_2_VALID                   0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_BUFFER_3                                3:3 /* RWIVF */
#define NV_PGRAPH_STATE_BUFFER_3_INVALID                 0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_BUFFER_3_VALID                   0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_BUFFER_4                                4:4 /* RWIVF */
#define NV_PGRAPH_STATE_BUFFER_4_INVALID                 0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_BUFFER_4_VALID                   0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_BUFFER_5                                5:5 /* RWIVF */
#define NV_PGRAPH_STATE_BUFFER_5_INVALID                 0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_BUFFER_5_VALID                   0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_PITCH_0                                 8:8 /* RWIVF */
#define NV_PGRAPH_STATE_PITCH_0_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PITCH_0_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_PITCH_1                                 9:9 /* RWIVF */
#define NV_PGRAPH_STATE_PITCH_1_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PITCH_1_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_PITCH_2                               10:10 /* RWIVF */
#define NV_PGRAPH_STATE_PITCH_2_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PITCH_2_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_PITCH_3                               11:11 /* RWIVF */
#define NV_PGRAPH_STATE_PITCH_3_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PITCH_3_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_PITCH_4                               12:12 /* RWIVF */
#define NV_PGRAPH_STATE_PITCH_4_INVALID                  0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PITCH_4_VALID                    0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_CHROMA_COLOR                          16:16 /* RWIVF */
#define NV_PGRAPH_STATE_CHROMA_COLOR_INVALID             0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_CHROMA_COLOR_VALID               0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_CHROMA_COLORFMT                       17:17 /* RWIVF */
#define NV_PGRAPH_STATE_CHROMA_COLORFMT_INVALID          0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_CHROMA_COLORFMT_VALID            0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_CPATTERN_COLORFMT                     20:20 /* RWIVF */
#define NV_PGRAPH_STATE_CPATTERN_COLORFMT_INVALID        0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_CPATTERN_COLORFMT_VALID          0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_CPATTERN_MONOFMT                      21:21 /* RWIVF */
#define NV_PGRAPH_STATE_CPATTERN_MONOFMT_INVALID         0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_CPATTERN_MONOFMT_VALID           0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_CPATTERN_SELECT                       22:22 /* RWIVF */
#define NV_PGRAPH_STATE_CPATTERN_SELECT_INVALID          0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_CPATTERN_SELECT_VALID            0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_PATTERN_COLOR0                        24:24 /* RWIVF */
#define NV_PGRAPH_STATE_PATTERN_COLOR0_INVALID           0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PATTERN_COLOR0_VALID             0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_PATTERN_COLOR1                        25:25 /* RWIVF */
#define NV_PGRAPH_STATE_PATTERN_COLOR1_INVALID           0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PATTERN_COLOR1_VALID             0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_PATTERN_PATT0                         26:26 /* RWIVF */
#define NV_PGRAPH_STATE_PATTERN_PATT0_INVALID            0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PATTERN_PATT0_VALID              0x00000001 /* RW--V */
#define NV_PGRAPH_STATE_PATTERN_PATT1                         27:27 /* RWIVF */
#define NV_PGRAPH_STATE_PATTERN_PATT1_INVALID            0x00000000 /* RWI-V */
#define NV_PGRAPH_STATE_PATTERN_PATT1_VALID              0x00000001 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX                            0x00400728 /* RW-4R */
#define NV_PGRAPH_CACHE_INDEX_BANK                              2:2 /* RWXVF */
#define NV_PGRAPH_CACHE_INDEX_BANK_10                    0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_BANK_32                    0x00000001 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS                             12:3 /* RWXVF */
#define NV_PGRAPH_CACHE_INDEX_ADRS_0                     0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_ADRS_1024                  0x00000400 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP                              14:13 /* RWXVF */
#define NV_PGRAPH_CACHE_INDEX_OP_WR_CACHE                0x00000000 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP_RD_CACHE                0x00000001 /* RW--V */
#define NV_PGRAPH_CACHE_INDEX_OP_RD_INDEX                0x00000002 /* RW--V */
#define NV_PGRAPH_CACHE_RAM                              0x0040072c /* RW-4R */
#define NV_PGRAPH_CACHE_RAM_VALUE                              31:0 /* RWXVF */
#define NV_PGRAPH_DMA_PITCH                              0x00400760 /* RW-4R */
#define NV_PGRAPH_DMA_PITCH_S0                                 15:0 /* RWXSF */
#define NV_PGRAPH_DMA_PITCH_S1                                31:16 /* RWXSF */
#define NV_PGRAPH_DVD_COLORFMT                           0x00400764 /* RW-4R */
#define NV_PGRAPH_DVD_COLORFMT_IMAGE                            5:0 /* RWNVF */
#define NV_PGRAPH_DVD_COLORFMT_IMAGE_FORMAT_INVALID            0x00 /* RWN-V */
#define NV_PGRAPH_DVD_COLORFMT_IMAGE_FORMAT_LE_V8YB8U8YA8      0x12 /* RW--V */
#define NV_PGRAPH_DVD_COLORFMT_IMAGE_FORMAT_LE_YB8V8YA8U8      0x13 /* RW--V */
#define NV_PGRAPH_DVD_COLORFMT_OVLY                             9:8 /* RWNVF */
#define NV_PGRAPH_DVD_COLORFMT_OVLY_FORMAT_INVALID             0x00 /* RWN-V */
#define NV_PGRAPH_DVD_COLORFMT_OVLY_FORMAT_LE_A8Y8U8V8         0x01 /* RW--V */
#define NV_PGRAPH_DVD_COLORFMT_OVLY_FORMAT_LE_A4V6YB6A4U6YA6   0x02 /* RW--V */
#define NV_PGRAPH_DVD_COLORFMT_OVLY_FORMAT_TRANSPARENT         0x03 /* RW--V */
#define NV_PGRAPH_SCALED_FORMAT                          0x00400768 /* RW-4R */
#define NV_PGRAPH_SCALED_FORMAT_ORIGIN                        17:16 /* RWIVF */
#define NV_PGRAPH_SCALED_FORMAT_ORIGIN_INVALID           0x00000000 /* RWI-V */
#define NV_PGRAPH_SCALED_FORMAT_ORIGIN_CENTER            0x00000001 /* RW--V */
#define NV_PGRAPH_SCALED_FORMAT_ORIGIN_CORNER            0x00000002 /* RW--V */
#define NV_PGRAPH_SCALED_FORMAT_INTERPOLATOR                  24:24 /* RWIVF */
#define NV_PGRAPH_SCALED_FORMAT_INTERPOLATOR_ZOH         0x00000000 /* RWI-V */
#define NV_PGRAPH_SCALED_FORMAT_INTERPOLATOR_FOH         0x00000001 /* RW--V */
#define NV_PGRAPH_PATT_COLOR0                            0x00400800 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR0_VALUE                            31:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLOR1                            0x00400804 /* RW-4R */
#define NV_PGRAPH_PATT_COLOR1_VALUE                            31:0 /* RWXUF */
#define NV_PGRAPH_PATT_COLORRAM(i)               (0x00400900+(i)*4) /* R--4A */
#define NV_PGRAPH_PATT_COLORRAM__SIZE_1                          64 /*       */
#define NV_PGRAPH_PATT_COLORRAM_VALUE                          23:0 /* R--UF */
#define NV_PGRAPH_PATTERN(i)                     (0x00400808+(i)*4) /* RW-4A */
#define NV_PGRAPH_PATTERN__SIZE_1                                 2 /*       */
#define NV_PGRAPH_PATTERN_BITMAP                               31:0 /* RWXVF */
#define NV_PGRAPH_PATTERN_SHAPE                          0x00400810 /* RW-4R */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE                           1:0 /* RWXVF */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_8X_8Y              0x00000000 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_64X_1Y             0x00000001 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_VALUE_1X_64Y             0x00000002 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_SELECT                          4:4 /* RWXVF */
#define NV_PGRAPH_PATTERN_SHAPE_SELECT_2COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_PATTERN_SHAPE_SELECT_FULLCOLOR         0x00000001 /* RW--V */
#define NV_PGRAPH_MONO_COLOR0                            0x00400600 /* RW-4R */
#define NV_PGRAPH_MONO_COLOR0_VALUE                            31:0 /* RWXUF */
#define NV_PGRAPH_ROP3                                   0x00400604 /* RW-4R */
#define NV_PGRAPH_ROP3_VALUE                                    7:0 /* RWXVF */
#define NV_PGRAPH_CHROMA                                 0x00400814 /* RW-4R */
#define NV_PGRAPH_CHROMA_VALUE                                 31:0 /* RWXUF */
#define NV_PGRAPH_BETA_AND                               0x00400608 /* RW-4R */
#define NV_PGRAPH_BETA_AND_VALUE_FRACTION                     30:23 /* RWXUF */
#define NV_PGRAPH_BETA_PREMULT                           0x0040060c /* RW-4R */
#define NV_PGRAPH_BETA_PREMULT_VALUE                           31:0 /* RWXUF */
#define NV_PGRAPH_CONTROL0                               0x00400818 /* RW-4R */
#define NV_PGRAPH_CONTROL0_ALPHAREF                             7:0 /* RWXUF */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC                           11:8 /* RWXVF */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC_NEVER               0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC_LESS                0x00000002 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC_EQUAL               0x00000003 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC_LESSEQUAL           0x00000004 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC_GREATER             0x00000005 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC_NOTEQUAL            0x00000006 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC_GREATEREQUAL        0x00000007 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHAFUNC_ALWAYS              0x00000008 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHATESTENABLE                    12:12 /* RWXVF */
#define NV_PGRAPH_CONTROL0_ALPHATESTENABLE_FALSE         0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHATESTENABLE_TRUE          0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZENABLE                            14:14 /* RWXVF */
#define NV_PGRAPH_CONTROL0_ZENABLE_FALSE                 0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZENABLE_TRUE                  0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZFUNC                              19:16 /* RWXVF */
#define NV_PGRAPH_CONTROL0_ZFUNC_NEVER                   0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZFUNC_LESS                    0x00000002 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZFUNC_EQUAL                   0x00000003 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZFUNC_LESSEQUAL               0x00000004 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZFUNC_GREATER                 0x00000005 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZFUNC_NOTEQUAL                0x00000006 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZFUNC_GREATEREQUAL            0x00000007 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZFUNC_ALWAYS                  0x00000008 /* RW--V */
#define NV_PGRAPH_CONTROL0_CULLMODE                           21:20 /* RWXVF */
#define NV_PGRAPH_CONTROL0_CULLMODE_NONE                 0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_CULLMODE_CW                   0x00000002 /* RW--V */
#define NV_PGRAPH_CONTROL0_CULLMODE_CCW                  0x00000003 /* RW--V */
#define NV_PGRAPH_CONTROL0_DITHERENABLE                       22:22 /* RWXVF */
#define NV_PGRAPH_CONTROL0_DITHERENABLE_FALSE            0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_DITHERENABLE_TRUE             0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_Z_PERSPECTIVE_ENABLE               23:23 /* RWXVF */
#define NV_PGRAPH_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE    0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE     0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZWRITEENABLE                       24:24 /* RWXVF */
#define NV_PGRAPH_CONTROL0_ZWRITEENABLE_FALSE            0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_ZWRITEENABLE_TRUE             0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_STENCIL_WRITE_ENABLE               25:25 /* RWXVF */
#define NV_PGRAPH_CONTROL0_STENCIL_WRITE_ENABLE_FALSE    0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_STENCIL_WRITE_ENABLE_TRUE     0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHA_WRITE_ENABLE                 26:26 /* RWXVF */
#define NV_PGRAPH_CONTROL0_ALPHA_WRITE_ENABLE_FALSE      0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_ALPHA_WRITE_ENABLE_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_RED_WRITE_ENABLE                   27:27 /* RWXVF */
#define NV_PGRAPH_CONTROL0_RED_WRITE_ENABLE_FALSE        0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_RED_WRITE_ENABLE_TRUE         0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_GREEN_WRITE_ENABLE                 28:28 /* RWXVF */
#define NV_PGRAPH_CONTROL0_GREEN_WRITE_ENABLE_FALSE      0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_GREEN_WRITE_ENABLE_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_BLUE_WRITE_ENABLE                  29:29 /* RWXVF */
#define NV_PGRAPH_CONTROL0_BLUE_WRITE_ENABLE_FALSE       0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL0_BLUE_WRITE_ENABLE_TRUE        0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_Z_FORMAT                           31:30 /* RWXVF */
#define NV_PGRAPH_CONTROL0_Z_FORMAT_FIXED                0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL0_Z_FORMAT_FLOAT                0x00000002 /* RW--V */
#define NV_PGRAPH_CONTROL1                               0x0040081c /* RW-4R */
#define NV_PGRAPH_CONTROL1_STENCIL_TEST_ENABLE                  0:0 /* RWXVF */
#define NV_PGRAPH_CONTROL1_STENCIL_TEST_ENABLE_FALSE     0x00000000 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_TEST_ENABLE_TRUE      0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC                         7:4 /* RWXVF */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC_NEVER            0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC_LESS             0x00000002 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC_EQUAL            0x00000003 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC_LESSEQUAL        0x00000004 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC_GREATER          0x00000005 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC_NOTEQUAL         0x00000006 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC_GREATEREQUAL     0x00000007 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_FUNC_ALWAYS           0x00000008 /* RW--V */
#define NV_PGRAPH_CONTROL1_STENCIL_REF                         15:8 /* RWXUF */
#define NV_PGRAPH_CONTROL1_STENCIL_MASK_READ                  23:16 /* RWXUF */
#define NV_PGRAPH_CONTROL1_STENCIL_MASK_WRITE                 31:24 /* RWXUF */
#define NV_PGRAPH_CONTROL2                               0x00400820 /* RW-4R */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL                      3:0 /* RWXVF */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL_KEEP          0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL_ZERO          0x00000002 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL_REPLACE       0x00000003 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL_INCRSAT       0x00000004 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL_DECRSAT       0x00000005 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL_INVERT        0x00000006 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL_INCR          0x00000007 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_FAIL_DECR          0x00000008 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL                     7:4 /* RWXVF */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL_KEEP         0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL_ZERO         0x00000002 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL_REPLACE      0x00000003 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL_INCRSAT      0x00000004 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL_DECRSAT      0x00000005 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL_INVERT       0x00000006 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL_INCR         0x00000007 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZFAIL_DECR         0x00000008 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS                    11:8 /* RWXVF */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS_KEEP         0x00000001 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS_ZERO         0x00000002 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS_REPLACE      0x00000003 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS_INCRSAT      0x00000004 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS_DECRSAT      0x00000005 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS_INVERT       0x00000006 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS_INCR         0x00000007 /* RW--V */
#define NV_PGRAPH_CONTROL2_STENCIL_OP_ZPASS_DECR         0x00000008 /* RW--V */
#define NV_PGRAPH_BLEND                                  0x00400824 /* RW-4R */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND                         3:0 /* -WXVF */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND_DECAL            0x00000001 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND_MODULATE         0x00000002 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND_DECALALPHA       0x00000003 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND_MODULATEALPHA    0x00000004 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND_DECALMASK        0x00000005 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND_MODULATEMASK     0x00000006 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND_COPY             0x00000007 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREMAPBLEND_ADD              0x00000008 /* -W--V */
#define NV_PGRAPH_BLEND_MASK_BIT                                5:4 /* -WXVF */
#define NV_PGRAPH_BLEND_MASK_BIT_LSB                     0x00000001 /* -W--V */
#define NV_PGRAPH_BLEND_MASK_BIT_MSB                     0x00000002 /* -W--V */
#define NV_PGRAPH_BLEND_SHADEMODE                               7:6 /* -WXVF */
#define NV_PGRAPH_BLEND_SHADEMODE_FLAT                   0x00000001 /* -W--V */
#define NV_PGRAPH_BLEND_SHADEMODE_GOURAUD                0x00000002 /* -W--V */
#define NV_PGRAPH_BLEND_SHADEMODE_PHONG                  0x00000003 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREPERSPECTIVE                      8:8 /* -WXVF */
#define NV_PGRAPH_BLEND_TEXTUREPERSPECTIVE_FALSE         0x00000000 /* -W--V */
#define NV_PGRAPH_BLEND_TEXTUREPERSPECTIVE_TRUE          0x00000001 /* -W--V */
#define NV_PGRAPH_BLEND_SPECULARENABLE                        12:12 /* -WXVF */
#define NV_PGRAPH_BLEND_SPECULARENABLE_FALSE             0x00000000 /* -W--V */
#define NV_PGRAPH_BLEND_SPECULARENABLE_TRUE              0x00000001 /* -W--V */
#define NV_PGRAPH_BLEND_FOGENABLE                             16:16 /* -WXVF */
#define NV_PGRAPH_BLEND_FOGENABLE_FALSE                  0x00000000 /* -W--V */
#define NV_PGRAPH_BLEND_FOGENABLE_TRUE                   0x00000001 /* -W--V */
#define NV_PGRAPH_BLEND_ALPHABLENDENABLE                      20:20 /* -WXVF */
#define NV_PGRAPH_BLEND_ALPHABLENDENABLE_FALSE           0x00000000 /* -W--V */
#define NV_PGRAPH_BLEND_ALPHABLENDENABLE_TRUE            0x00000001 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND                              27:24 /* -WXVF */
#define NV_PGRAPH_BLEND_SRCBLEND_ZERO                    0x00000001 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_ONE                     0x00000002 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_SRCCOLOR                0x00000003 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_INVSRCCOLOR             0x00000004 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_SRCALPHA                0x00000005 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_INVSRCALPHA             0x00000006 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_DESTALPHA               0x00000007 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_INVDESTALPHA            0x00000008 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_DESTCOLOR               0x00000009 /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_INVDESTCOLOR            0x0000000A /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_SRCALPHASAT             0x0000000B /* -W--V */
#define NV_PGRAPH_BLEND_SRCBLEND_INVSRCALPHASAT          0x0000000C /* ----V */
#define NV_PGRAPH_BLEND_SRCBLEND_BETA                    0x0000000D /* ----V */
#define NV_PGRAPH_BLEND_DESTBLEND                             31:28 /* -WXVF */
#define NV_PGRAPH_BLEND_DESTBLEND_ZERO                   0x00000001 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_ONE                    0x00000002 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_SRCCOLOR               0x00000003 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_INVSRCCOLOR            0x00000004 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_SRCALPHA               0x00000005 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_INVSRCALPHA            0x00000006 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_DESTALPHA              0x00000007 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_INVDESTALPHA           0x00000008 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_DESTCOLOR              0x00000009 /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_INVDESTCOLOR           0x0000000A /* -W--V */
#define NV_PGRAPH_BLEND_DESTBLEND_SRCALPHASAT            0x0000000B /* -W--V */
#define NV_PGRAPH_DPRAM_INDEX                            0x00400828 /* RW-4R */
#define NV_PGRAPH_DPRAM_INDEX_ADRS                              6:0 /* RWIVF */
#define NV_PGRAPH_DPRAM_INDEX_ADRS_0                     0x00000000 /* RWI-V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT                           10:8 /* RWIVF */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ADRS_0              0x00000000 /* RWI-V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ADRS_1              0x00000001 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_DATA_0              0x00000002 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_DATA_1              0x00000003 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_WE_0                0x00000004 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_WE_1                0x00000005 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ALPHA_0             0x00000006 /* RW--V */
#define NV_PGRAPH_DPRAM_INDEX_SELECT_ALPHA_1             0x00000007 /* RW--V */
#define NV_PGRAPH_DPRAM_DATA                             0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_DATA_VALUE                             31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ADRS_0                           0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_ADRS_0__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ADRS_0_VALUE                           19:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ADRS_1                           0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_ADRS_1__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ADRS_1_VALUE                           19:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_DATA_0                           0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_DATA_0__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_DATA_0_VALUE                           31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_DATA_1                           0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_DATA_1__ALIAS_1        NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_DATA_1_VALUE                           31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_WE_0                             0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_WE_0__ALIAS_1          NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_WE_0_VALUE                             23:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_WE_1                             0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_WE_1__ALIAS_1          NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_WE_1_VALUE                             23:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ALPHA_0                          0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_ALPHA_0__ALIAS_1       NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ALPHA_0_VALUE                          31:0 /* RWXVF */
#define NV_PGRAPH_DPRAM_ALPHA_1                          0x0040082c /* RW-4R */
#define NV_PGRAPH_DPRAM_ALPHA_1__ALIAS_1       NV_PGRAPH_DPRAM_DATA /*       */
#define NV_PGRAPH_DPRAM_ALPHA_1_VALUE                          31:0 /* RWXVF */
#define NV_PGRAPH_STORED_FMT                             0x00400830 /* RW-4R */
#define NV_PGRAPH_STORED_FMT_MONO0                              5:0 /* RWXVF */
#define NV_PGRAPH_STORED_FMT_PATT0                             13:8 /* RWXVF */
#define NV_PGRAPH_STORED_FMT_PATT1                            21:16 /* RWXVF */
#define NV_PGRAPH_STORED_FMT_CHROMA                           29:24 /* RWXVF */
#define NV_PGRAPH_FORMATS                                0x00400618 /* RW-4R */
#define NV_PGRAPH_FORMATS_ROP                                   2:0 /* R-XVF */
#define NV_PGRAPH_FORMATS_ROP_Y8                         0x00000000 /* -W--V */
#define NV_PGRAPH_FORMATS_ROP_RGB15                      0x00000001 /* -W--V */
#define NV_PGRAPH_FORMATS_ROP_RGB16                      0x00000002 /* -W--V */
#define NV_PGRAPH_FORMATS_ROP_Y16                        0x00000003 /* -W--V */
#define NV_PGRAPH_FORMATS_ROP_INVALID                    0x00000004 /* -W--V */
#define NV_PGRAPH_FORMATS_ROP_RGB24                      0x00000005 /* -W--V */
#define NV_PGRAPH_FORMATS_ROP_RGB30                      0x00000006 /* -W--V */
#define NV_PGRAPH_FORMATS_ROP_Y32                        0x00000007 /* -W--V */
#define NV_PGRAPH_FORMATS_SRC                                   9:4 /* R-XVF */
#define NV_PGRAPH_FORMATS_SRC_INVALID                    0x00000000 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_Y8                      0x00000001 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_X16A8Y8                 0x00000002 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_X24Y8                   0x00000003 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_A1R5G5B5                0x00000006 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_X1R5G5B5                0x00000007 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_X16A1R5G5B5             0x00000008 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_X17R5G5B5               0x00000009 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_R5G6B5                  0x0000000A /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_A16R5G6B5               0x0000000B /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_X16R5G6B5               0x0000000C /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_A8R8G8B8                0x0000000D /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_X8R8G8B8                0x0000000E /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_Y16                     0x0000000F /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_A16Y16                  0x00000010 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_X16Y16                  0x00000011 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_V8YB8U8YA8              0x00000012 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_YB8V8YA8U8              0x00000013 /* RW--V */
#define NV_PGRAPH_FORMATS_SRC_LE_Y32                     0x00000014 /* RW--V */
#define NV_PGRAPH_FORMATS_FB                                  15:12 /* R-XVF */
#define NV_PGRAPH_FORMATS_FB_INVALID                     0x00000000 /* RWI-V */
#define NV_PGRAPH_FORMATS_FB_Y8                          0x00000001 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_X1R5G5B5_Z1R5G5B5           0x00000002 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_X1R5G5B5_O1R5G5B5           0x00000003 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_A1R5G5B5                    0x00000004 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_R5G6B5                      0x00000005 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_Y16                         0x00000006 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_X8R8G8B8_Z8R8G8B8           0x00000007 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_X8R8G8B8_O1Z7R8G8B8         0x00000008 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_X1A7R8G8B8_Z1A7R8G8B8       0x00000009 /* RW--V */
#define NV_PGRAPH_FORMATS_FB_X1A7R8G8B8_O1A7R8G8B8       0x0000000a /* RW--V */
#define NV_PGRAPH_FORMATS_FB_X8R8G8B8_O8R8G8B8           0x0000000b /* RW--V */
#define NV_PGRAPH_FORMATS_FB_A8R8G8B8                    0x0000000c /* RW--V */
#define NV_PGRAPH_FORMATS_FB_Y32                         0x0000000d /* RW--V */
#define NV_PGRAPH_FORMATS_FB_V8YB8U8YA8                  0x0000000e /* RW--V */
#define NV_PGRAPH_FORMATS_FB_YB8V8YA8U8                  0x0000000f /* RW--V */ 
#define NV_PGRAPH_ABS_X_RAM(i)                   (0x00400400+(i)*4) /* RW-4A */
#define NV_PGRAPH_ABS_X_RAM__SIZE_1                              32 /*       */
#define NV_PGRAPH_ABS_X_RAM_VALUE                              31:0 /* RWXUF */
#define NV_PGRAPH_X_RAM_BPORT(i)                 (0x00400c00+(i)*4) /* R--4A */
#define NV_PGRAPH_X_RAM_BPORT__SIZE_1                            32 /*       */
#define NV_PGRAPH_X_RAM_BPORT_VALUE                            31:0 /* R--UF */
#define NV_PGRAPH_ABS_Y_RAM(i)                   (0x00400480+(i)*4) /* RW-4A */
#define NV_PGRAPH_ABS_Y_RAM__SIZE_1                              32 /*       */
#define NV_PGRAPH_ABS_Y_RAM_VALUE                              31:0 /* RWXUF */
#define NV_PGRAPH_Y_RAM_BPORT(i)                 (0x00400c80+(i)*4) /* R--4A */
#define NV_PGRAPH_Y_RAM_BPORT__SIZE_1                            32 /*       */
#define NV_PGRAPH_Y_RAM_BPORT_VALUE                            31:0 /* R--UF */
#define NV_PGRAPH_XY_LOGIC_MISC0                         0x00400514 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC0_COUNTER                       17:0 /* RWBUF */
#define NV_PGRAPH_XY_LOGIC_MISC0_COUNTER_0               0x00000000 /* RWB-V */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION                    20:20 /* RWVVF */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION_NONZERO       0x00000000 /* RWV-V */
#define NV_PGRAPH_XY_LOGIC_MISC0_DIMENSION_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC0_INDEX                        31:28 /* RWBUF */
#define NV_PGRAPH_XY_LOGIC_MISC0_INDEX_0                 0x00000000 /* RWB-V */
#define NV_PGRAPH_XY_LOGIC_MISC1                         0x00400518 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL                        0:0 /* RWNVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL_NEEDED          0x00000000 /* RWN-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_INITIAL_DONE            0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX                      4:4 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY                      5:5 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_XTRACLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX                    12:12 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX_UUMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX                    16:16 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX_UUMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_YIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA                    20:20 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA_CLIPMAX       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC1_SEL_XXTRA_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2                         0x0040051C /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF                        0:0 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF_DISABLE         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_HANDOFF_ENABLE          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX                      4:4 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPX_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY                      5:5 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY_NOTNULL       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_XTRACLIPY_NULL          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX                    12:12 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX                    16:16 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX_UCMAX         0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_YIMAX_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA                    20:20 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA_CLIPMAX       0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC2_SEL_XXTRA_IMAGEMAX      0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3                         0x00400520 /* RW-4R */
#define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0                     0:0 /* RWXVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0_NULL         0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_WDIMY_EQ_0_TRUE         0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY                   4:4 /* RWXVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY_NULL       0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WDIMY_TRUE       0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX                      8:8 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX_NULL          0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC3_RELOAD_WX_TRUE          0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG                     12:12 /* RWIVF */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG_NULL           0x00000000 /* RWI-V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_ALG_TRUE           0x00000001 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_DIMX                    22:16 /* RWXUF */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_DIMX_0             0x00000000 /* RW--V */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_WDIMX                   30:24 /* RWXUF */
#define NV_PGRAPH_XY_LOGIC_MISC3_TEXT_WDIMX_0            0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC                                 0x00400500 /* RW-4R */
#define NV_PGRAPH_X_MISC_BIT33_0                                0:0 /* RWNVF */
#define NV_PGRAPH_X_MISC_BIT33_0_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_X_MISC_BIT33_1                                1:1 /* RWNVF */
#define NV_PGRAPH_X_MISC_BIT33_1_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_X_MISC_BIT33_2                                2:2 /* RWNVF */
#define NV_PGRAPH_X_MISC_BIT33_2_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_X_MISC_BIT33_3                                3:3 /* RWNVF */
#define NV_PGRAPH_X_MISC_BIT33_3_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_X_MISC_RANGE_0                                4:4 /* RWNVF */
#define NV_PGRAPH_X_MISC_RANGE_0_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_X_MISC_RANGE_1                                5:5 /* RWNVF */
#define NV_PGRAPH_X_MISC_RANGE_1_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_X_MISC_RANGE_2                                6:6 /* RWNVF */
#define NV_PGRAPH_X_MISC_RANGE_2_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_X_MISC_RANGE_3                                7:7 /* RWNVF */
#define NV_PGRAPH_X_MISC_RANGE_3_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT                         29:28 /* RWXVF */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_EQ_0               0x00000000 /* RW--V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_LT_0               0x00000001 /* RW--V */
#define NV_PGRAPH_X_MISC_ADDER_OUTPUT_GT_0               0x00000002 /* RW--V */
#define NV_PGRAPH_Y_MISC                                 0x00400504 /* RW-4R */
#define NV_PGRAPH_Y_MISC_BIT33_0                                0:0 /* RWNVF */
#define NV_PGRAPH_Y_MISC_BIT33_0_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_Y_MISC_BIT33_1                                1:1 /* RWNVF */
#define NV_PGRAPH_Y_MISC_BIT33_1_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_Y_MISC_BIT33_2                                2:2 /* RWNVF */
#define NV_PGRAPH_Y_MISC_BIT33_2_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_Y_MISC_BIT33_3                                3:3 /* RWNVF */
#define NV_PGRAPH_Y_MISC_BIT33_3_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_Y_MISC_RANGE_0                                4:4 /* RWNVF */
#define NV_PGRAPH_Y_MISC_RANGE_0_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_Y_MISC_RANGE_1                                5:5 /* RWNVF */
#define NV_PGRAPH_Y_MISC_RANGE_1_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_Y_MISC_RANGE_2                                6:6 /* RWNVF */
#define NV_PGRAPH_Y_MISC_RANGE_2_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_Y_MISC_RANGE_3                                7:7 /* RWNVF */
#define NV_PGRAPH_Y_MISC_RANGE_3_0                       0x00000000 /* RWN-V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT                         29:28 /* RWXVF */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_EQ_0               0x00000000 /* RW--V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_LT_0               0x00000001 /* RW--V */
#define NV_PGRAPH_Y_MISC_ADDER_OUTPUT_GT_0               0x00000002 /* RW--V */
#define NV_PGRAPH_ABS_UCLIP_XMIN                         0x0040053C /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_XMIN_VALUE                         15:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP_XMAX                         0x00400544 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_XMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP_YMIN                         0x00400540 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_YMIN_VALUE                         15:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIP_YMAX                         0x00400548 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIP_YMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_XMIN                        0x00400560 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_XMIN_VALUE                        15:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_XMAX                        0x00400568 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_XMAX_VALUE                        17:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_YMIN                        0x00400564 /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_YMIN_VALUE                        15:0 /* RWXSF */
#define NV_PGRAPH_ABS_UCLIPA_YMAX                        0x0040056C /* RW-4R */
#define NV_PGRAPH_ABS_UCLIPA_YMAX_VALUE                        17:0 /* RWXSF */
#define NV_PGRAPH_SOURCE_COLOR                           0x0040050C /* RW-4R */
#define NV_PGRAPH_SOURCE_COLOR_VALUE                           31:0 /* RWNVF */
#define NV_PGRAPH_SOURCE_COLOR_VALUE_0                   0x00000000 /* RWN-V */
#define NV_PGRAPH_VALID1                                 0x00400508 /* RW-4R */
#define NV_PGRAPH_VALID1_VLD                                   22:0 /* RWNVF */
#define NV_PGRAPH_VALID1_VLD_0                           0x00000000 /* RWN-V */
#define NV_PGRAPH_VALID1_VLD_NOCLIP                       (0x1<<19) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_SRCCOLOR                     (0x1<<16) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTMOVE                      (0x1<<21) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTX01                        (0x3<<0) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTX02                        (0x7<<0) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTX03                        (0xf<<0) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTXCHAIN01                   (0x3<<4) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTXCHAIN02                   (0x7<<4) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTXCHAIN03                   (0xf<<4) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTY01                        (0x3<<8) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTY02                        (0x7<<8) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTY03                        (0xf<<8) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTYCHAIN01                  (0x3<<12) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTYCHAIN02                  (0x7<<12) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTYCHAIN03                  (0xf<<12) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_X_OFFSET                      (0x1<<0) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_XCHAIN_OFFSET                 (0x1<<4) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_Y_OFFSET                      (0x1<<8) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_YCHAIN_OFFSET                (0x1<<12) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTCOLOR0                    (0x1<<17) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTCOLOR1                    (0x1<<18) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTCLIP                      (0x1<<20) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTFONT                      (0x1<<22) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTOFFSET                    (0x1<<22) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTBPITCH                     (0x1<<2) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTBOFFSET                    (0x1<<3) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTDUDX                       (0x1<<4) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTDVDY                       (0x1<<5) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTPOINT                      (0x1<<8) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTSIZE                       (0x1<<9) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTPITCH                     (0x1<<10) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTSTART                     (0x1<<11) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTDUDX2                     (0x1<<12) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTDVDY2                     (0x1<<13) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTPOINT2                    (0x1<<14) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTSIZE2                     (0x1<<15) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTPITCH2                    (0x1<<16) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTSTART2                    (0x1<<17) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTOFFSIN                     (0x1<<0) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTOFFSOUT                    (0x1<<1) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTPITCHIN                    (0x1<<2) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTPITCHOUT                   (0x1<<3) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTLENGTH                     (0x1<<4) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTCOUNT                      (0x1<<5) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTFORMAT                     (0x1<<6) /* RW--V */
#define NV_PGRAPH_VALID1_VLD_GOTNOTIFY                     (0x1<<7) /* RW--V */
#define NV_PGRAPH_VALID1_CLIP_MIN                             28:28 /* RWIVF */
#define NV_PGRAPH_VALID1_CLIP_MIN_NO_ERROR               0x00000000 /* RWI-V */
#define NV_PGRAPH_VALID1_CLIP_MIN_ONLY                   0x00000001 /* RW--V */
#define NV_PGRAPH_VALID1_CLIPA_MIN                            29:29 /* RWIVF */
#define NV_PGRAPH_VALID1_CLIPA_MIN_NO_ERROR              0x00000000 /* RWI-V */
#define NV_PGRAPH_VALID1_CLIPA_MIN_ONLY                  0x00000001 /* RW--V */
#define NV_PGRAPH_VALID1_CLIP_MAX                             30:30 /* RWIVF */
#define NV_PGRAPH_VALID1_CLIP_MAX_NO_ERROR               0x00000000 /* RWI-V */
#define NV_PGRAPH_VALID1_CLIP_MAX_ONLY                   0x00000001 /* RW--V */
#define NV_PGRAPH_VALID1_CLIPA_MAX                            31:31 /* RWIVF */
#define NV_PGRAPH_VALID1_CLIPA_MAX_NO_ERROR              0x00000000 /* RWI-V */
#define NV_PGRAPH_VALID1_CLIPA_MAX_ONLY                  0x00000001 /* RW--V */
#define NV_PGRAPH_VALID2                                 0x00400578 /* RW-4R */
#define NV_PGRAPH_VALID2_VLD2                                  28:0 /* RWNVF */
#define NV_PGRAPH_VALID2_VLD2_0                          0x00000000 /* RWN-V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_COMBINE0A               (1<<28) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_COMBINE0C               (1<<27) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_COMBINE1A               (1<<26) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_COMBINE1C               (1<<25) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_COMBFACTOR              (1<<24) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_FILTER1                 (1<<23) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_OFFSET1                 (1<<22) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_FORMAT1                 (1<<21) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_BLEND                   (1<<20) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_CONTROL2                (1<<19) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_CONTROL1                (1<<18) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_CONTROL0                (1<<17) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_FILTER0                 (1<<16) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_FORMAT0                 (1<<15) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_OFFSET0                 (1<<14) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_FOGCOLOR                (1<<13) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_COLORKEY                (1<<12) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_V1                       (1<<9) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_U1                       (1<<8) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_V0                       (1<<7) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_U0                       (1<<6) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_X                        (1<<5) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_Y                        (1<<4) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_ZETA                     (1<<3) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_M                        (1<<2) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_COLOR                    (1<<1) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_GOT3D_SPECULAR                 (1<<0) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_DX3FULLVERTEX               (0x7f<<0) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_DX5FULLVERTEX               (0x7f<<0) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_DX6FULLVERTEX              (0x1ff<<0) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_DX3FULLSTATE               (0x3f<<13) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_DX5FULLSTATE              (0x1ff<<12) /* RW--V */
#define NV_PGRAPH_VALID2_VLD2_DX6FULLSTATE             (0xffff<<13) /* RW--V */
#define NV_PGRAPH_ABS_ICLIP_XMAX                         0x00400534 /* RW-4R */
#define NV_PGRAPH_ABS_ICLIP_XMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_ABS_ICLIP_YMAX                         0x00400538 /* RW-4R */
#define NV_PGRAPH_ABS_ICLIP_YMAX_VALUE                         17:0 /* RWXSF */
#define NV_PGRAPH_CLIPX_0                                0x00400524 /* RW-4R */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN                             1:0 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX                             3:2 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP0_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN                             5:4 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX                             7:6 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP1_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN                             9:8 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX                           11:10 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP2_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN                           13:12 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX                           15:14 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP3_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN                           17:16 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX                           19:18 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP4_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN                           21:20 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX                           23:22 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP5_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN                           25:24 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX                           27:26 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP6_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN                           29:28 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX                           31:30 /* RWNVF */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_0_CLIP7_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1                                0x00400528 /* RW-4R */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN                             1:0 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX                             3:2 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP8_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN                             5:4 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX                             7:6 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP9_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN                            9:8 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX                          11:10 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP10_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MIN                          13:12 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP11_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP11MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX                          15:14 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP11_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN                          17:16 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX                          19:18 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP12_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN                          21:20 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX                          23:22 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP13_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN                          25:24 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX                          27:26 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP14_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN                          29:28 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX                          31:30 /* RWNVF */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPX_1_CLIP15_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0                                0x0040052c /* RW-4R */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN                             1:0 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX                             3:2 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP0_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN                             5:4 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX                             7:6 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP1_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN                             9:8 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX                           11:10 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP2_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN                           13:12 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX                           15:14 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP3_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN                           17:16 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX                           19:18 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP4_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN                           21:20 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX                           23:22 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP5_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN                           25:24 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX                           27:26 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP6_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN                           29:28 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX                           31:30 /* RWNVF */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_0_CLIP7_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1                                0x00400530 /* RW-4R */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN                             1:0 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX                             3:2 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP8_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN                             5:4 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN_GT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN_LT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX                             7:6 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX_LT                   0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX_GT                   0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP9_MAX_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN                            9:8 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX                          11:10 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP10_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MIN                          13:12 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP11_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP11MIN_EQ                   0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX                          15:14 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP11_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN                          17:16 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX                          19:18 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP12_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN                          21:20 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX                          23:22 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP13_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN                          25:24 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX                          27:26 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP14_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN                          29:28 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN_GT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN_LT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MIN_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX                          31:30 /* RWNVF */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX_LT                  0x00000000 /* RW--V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX_GT                  0x00000001 /* RWN-V */
#define NV_PGRAPH_CLIPY_1_CLIP15_MAX_EQ                  0x00000002 /* RW--V */
#define NV_PGRAPH_MISC24_0                               0x00400510 /* RW-4R */
#define NV_PGRAPH_MISC24_0_VALUE                               23:0 /* RWXUF */
#define NV_PGRAPH_MISC24_1                               0x00400570 /* RW-4R */
#define NV_PGRAPH_MISC24_1_VALUE                               23:0 /* RWXUF */
#define NV_PGRAPH_MISC24_2                               0x00400574 /* RW-4R */
#define NV_PGRAPH_MISC24_2_VALUE                               23:0 /* RWXUF */
#define NV_PGRAPH_PASSTHRU_0                             0x0040057C /* RW-4R */
#define NV_PGRAPH_PASSTHRU_0_VALUE                             31:0 /* RWXUF */
#define NV_PGRAPH_PASSTHRU_1                             0x00400580 /* RW-4R */
#define NV_PGRAPH_PASSTHRU_1_VALUE                             31:0 /* RWXUF */
#define NV_PGRAPH_PASSTHRU_2                             0x00400584 /* RW-4R */
#define NV_PGRAPH_PASSTHRU_2_VALUE                             31:0 /* RWXUF */
#define NV_PGRAPH_U_RAM(i)                       (0x00400d00+(i)*4) /* RW-4A */
#define NV_PGRAPH_U_RAM__SIZE_1                                  16 /*       */
#define NV_PGRAPH_U_RAM_VALUE                                  31:6 /* RWXFF */
#define NV_PGRAPH_V_RAM(i)                       (0x00400d40+(i)*4) /* RW-4A */
#define NV_PGRAPH_V_RAM__SIZE_1                                  16 /*       */
#define NV_PGRAPH_V_RAM_VALUE                                  31:6 /* RWXFF */
#define NV_PGRAPH_M_RAM(i)                       (0x00400d80+(i)*4) /* RW-4A */
#define NV_PGRAPH_M_RAM__SIZE_1                                  16 /*       */
#define NV_PGRAPH_M_RAM_VALUE                                  31:6 /* RWXFF */
#define NV_PGRAPH_D3D_XY                                 0x004005c0 /* RW-4R */
#define NV_PGRAPH_D3D_XY_X_VALUE                               15:0 /* RWXSF */
#define NV_PGRAPH_D3D_XY_Y_VALUE                              31:16 /* RWXSF */
#define NV_PGRAPH_D3D_U0                                 0x004005c4 /* RW-4R */
#define NV_PGRAPH_D3D_U0_VALUE                                 31:6 /* RWXFF */
#define NV_PGRAPH_D3D_V0                                 0x004005c8 /* RW-4R */
#define NV_PGRAPH_D3D_V0_VALUE                                 31:6 /* RWXFF */
#define NV_PGRAPH_D3D_U1                                 0x004005cc /* RW-4R */
#define NV_PGRAPH_D3D_U1_VALUE                                 31:6 /* RWXFF */
#define NV_PGRAPH_D3D_V1                                 0x004005d0 /* RW-4R */
#define NV_PGRAPH_D3D_V1_VALUE                                 31:6 /* RWXFF */
#define NV_PGRAPH_D3D_ZETA                               0x004005d4 /* RW-4R */
#define NV_PGRAPH_D3D_ZETA_VALUE                               31:0 /* RWXFF */
#define NV_PGRAPH_D3D_RGB                                0x004005d8 /* RW-4R */
#define NV_PGRAPH_D3D_RGB_VALUE                                31:0 /* RWXUF */
#define NV_PGRAPH_D3D_S                                  0x004005dc /* RW-4R */
#define NV_PGRAPH_D3D_S_VALUE                                  31:0 /* RWXUF */
#define NV_PGRAPH_D3D_M                                  0x004005e0 /* RW-4R */
#define NV_PGRAPH_D3D_M_VALUE                                  31:6 /* RWXFF */
#define NV_PGRAPH_FORMAT0                                0x004005A8 /* RW-4R */
#define NV_PGRAPH_FORMAT0_CONTEXT_DMA                           1:1 /* RWXVF */
#define NV_PGRAPH_FORMAT0_CONTEXT_DMA_A                  0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_CONTEXT_DMA_B                  0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLORKEYENABLE                        2:2 /* RWXVF */
#define NV_PGRAPH_FORMAT0_COLORKEYENABLE_FALSE           0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLORKEYENABLE_TRUE            0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_ORIGIN_ZOH                            5:5 /* RWXVF */
#define NV_PGRAPH_FORMAT0_ORIGIN_ZOH_CENTER              0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_ORIGIN_ZOH_CORNER              0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_ORIGIN_FOH                            7:7 /* RWXVF */
#define NV_PGRAPH_FORMAT0_ORIGIN_FOH_CENTER              0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_ORIGIN_FOH_CORNER              0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLOR                                10:8 /* RWXVF */
#define NV_PGRAPH_FORMAT0_COLOR_LE_Y8                    0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLOR_LE_AY8                   0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLOR_LE_A1R5G5B5              0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLOR_LE_X1R5G5B5              0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLOR_LE_A4R4G4B4              0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLOR_LE_R5G6B5                0x00000005 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLOR_LE_A8R8G8B8              0x00000006 /* RW--V */
#define NV_PGRAPH_FORMAT0_COLOR_LE_X8R8G8B8              0x00000007 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS                       15:12 /* RWXVF */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_INVALID          0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_1                0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_2                0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_3                0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_4                0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_5                0x00000005 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_6                0x00000006 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_7                0x00000007 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_8                0x00000008 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_9                0x00000009 /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_10               0x0000000A /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_11               0x0000000B /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_12               0x0000000C /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_13               0x0000000D /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_14               0x0000000E /* RW--V */
#define NV_PGRAPH_FORMAT0_MIPMAP_LEVELS_15               0x0000000F /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U                         19:16 /* RWXVF */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_1                  0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_2                  0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_4                  0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_8                  0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_16                 0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_32                 0x00000005 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_64                 0x00000006 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_128                0x00000007 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_256                0x00000008 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_512                0x00000009 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_1024               0x0000000A /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_U_2048               0x0000000B /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V                         23:20 /* RWXVF */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_1                  0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_2                  0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_4                  0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_8                  0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_16                 0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_32                 0x00000005 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_64                 0x00000006 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_128                0x00000007 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_256                0x00000008 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_512                0x00000009 /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_1024               0x0000000A /* RW--V */
#define NV_PGRAPH_FORMAT0_BASE_SIZE_V_2048               0x0000000B /* RW--V */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSU                     26:24 /* RWXVF */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSU_WRAP           0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSU_MIRROR         0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSU_CLAMP          0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSU_BORDER         0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT0_WRAPU                               27:27 /* RWXVF */
#define NV_PGRAPH_FORMAT0_WRAPU_FALSE                    0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_WRAPU_TRUE                     0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSV                     30:28 /* RWXVF */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSV_WRAP           0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSV_MIRROR         0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSV_CLAMP          0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT0_TEXTUREADDRESSV_BORDER         0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT0_WRAPV                               31:31 /* RWXVF */
#define NV_PGRAPH_FORMAT0_WRAPV_FALSE                    0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT0_WRAPV_TRUE                     0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1                                0x004005AC /* RW-4R */
#define NV_PGRAPH_FORMAT1_CONTEXT_DMA                           1:1 /* RWXVF */
#define NV_PGRAPH_FORMAT1_CONTEXT_DMA_A                  0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_CONTEXT_DMA_B                  0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLORKEYENABLE                        2:2 /* RWXVF */
#define NV_PGRAPH_FORMAT1_COLORKEYENABLE_FALSE           0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLORKEYENABLE_TRUE            0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_ORIGIN_ZOH                            5:5 /* RWXVF */
#define NV_PGRAPH_FORMAT1_ORIGIN_ZOH_CENTER              0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_ORIGIN_ZOH_CORNER              0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_ORIGIN_FOH                            7:7 /* RWXVF */
#define NV_PGRAPH_FORMAT1_ORIGIN_FOH_CENTER              0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_ORIGIN_FOH_CORNER              0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLOR                                10:8 /* RWXVF */
#define NV_PGRAPH_FORMAT1_COLOR_LE_Y8                    0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLOR_LE_AY8                   0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLOR_LE_A1R5G5B5              0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLOR_LE_X1R5G5B5              0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLOR_LE_A4R4G4B4              0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLOR_LE_R5G6B5                0x00000005 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLOR_LE_A8R8G8B8              0x00000006 /* RW--V */
#define NV_PGRAPH_FORMAT1_COLOR_LE_X8R8G8B8              0x00000007 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS                       15:12 /* RWXVF */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_INVALID          0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_1                0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_2                0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_3                0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_4                0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_5                0x00000005 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_6                0x00000006 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_7                0x00000007 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_8                0x00000008 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_9                0x00000009 /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_10               0x0000000A /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_11               0x0000000B /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_12               0x0000000C /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_13               0x0000000D /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_14               0x0000000E /* RW--V */
#define NV_PGRAPH_FORMAT1_MIPMAP_LEVELS_15               0x0000000F /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U                         19:16 /* RWXVF */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_1                  0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_2                  0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_4                  0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_8                  0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_16                 0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_32                 0x00000005 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_64                 0x00000006 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_128                0x00000007 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_256                0x00000008 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_512                0x00000009 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_1024               0x0000000A /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_U_2048               0x0000000B /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V                         23:20 /* RWXVF */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_1                  0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_2                  0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_4                  0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_8                  0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_16                 0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_32                 0x00000005 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_64                 0x00000006 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_128                0x00000007 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_256                0x00000008 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_512                0x00000009 /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_1024               0x0000000A /* RW--V */
#define NV_PGRAPH_FORMAT1_BASE_SIZE_V_2048               0x0000000B /* RW--V */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSU                     26:24 /* RWXVF */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSU_WRAP           0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSU_MIRROR         0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSU_CLAMP          0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSU_BORDER         0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT1_WRAPU                               27:27 /* RWXVF */
#define NV_PGRAPH_FORMAT1_WRAPU_FALSE                    0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_WRAPU_TRUE                     0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSV                     30:28 /* RWXVF */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSV_WRAP           0x00000001 /* RW--V */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSV_MIRROR         0x00000002 /* RW--V */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSV_CLAMP          0x00000003 /* RW--V */
#define NV_PGRAPH_FORMAT1_TEXTUREADDRESSV_BORDER         0x00000004 /* RW--V */
#define NV_PGRAPH_FORMAT1_WRAPV                               31:31 /* RWXVF */
#define NV_PGRAPH_FORMAT1_WRAPV_FALSE                    0x00000000 /* RW--V */
#define NV_PGRAPH_FORMAT1_WRAPV_TRUE                     0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER0                                0x004005B0 /* RW-4R */
#define NV_PGRAPH_FILTER0_KERNEL_SIZE_X                         4:1 /* RWXUF */
#define NV_PGRAPH_FILTER0_KERNEL_SIZE_Y                        12:9 /* RWXUF */
#define NV_PGRAPH_FILTER0_MIPMAP_DITHER_ENABLE                15:15 /* RWXVF */
#define NV_PGRAPH_FILTER0_MIPMAP_DITHER_ENABLE_FALSE     0x00000000 /* RW--V */
#define NV_PGRAPH_FILTER0_MIPMAP_DITHER_ENABLE_TRUE      0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER0_MIPMAPLODBIAS                       23:16 /* RWXSF */
#define NV_PGRAPH_FILTER0_TEXTUREMIN                          26:24 /* RWXVF */
#define NV_PGRAPH_FILTER0_TEXTUREMIN_NEAREST             0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMIN_LINEAR              0x00000002 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMIN_MIPNEAREST          0x00000003 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMIN_MIPLINEAR           0x00000004 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMIN_LINEARMIPNEAREST    0x00000005 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMIN_LINEARMIPLINEAR     0x00000006 /* RW--V */
#define NV_PGRAPH_FILTER0_ANISOTROPIC_MIN_ENABLE              27:27 /* RWXVF */
#define NV_PGRAPH_FILTER0_ANISOTROPIC_MIN_ENABLE_FALSE   0x00000000 /* RW--V */
#define NV_PGRAPH_FILTER0_ANISOTROPIC_MIN_ENABLE_TRUE    0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMAG                          30:28 /* RWXVF */
#define NV_PGRAPH_FILTER0_TEXTUREMAG_NEAREST             0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMAG_LINEAR              0x00000002 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMAG_MIPNEAREST          0x00000003 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMAG_MIPLINEAR           0x00000004 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMAG_LINEARMIPNEAREST    0x00000005 /* RW--V */
#define NV_PGRAPH_FILTER0_TEXTUREMAG_LINEARMIPLINEAR     0x00000006 /* RW--V */
#define NV_PGRAPH_FILTER0_ANISOTROPIC_MAG_ENABLE              31:31 /* RWXVF */
#define NV_PGRAPH_FILTER0_ANISOTROPIC_MAG_ENABLE_FALSE   0x00000000 /* RW--V */
#define NV_PGRAPH_FILTER0_ANISOTROPIC_MAG_ENABLE_TRUE    0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER1                                0x004005B4 /* RW-4R */
#define NV_PGRAPH_FILTER1_KERNEL_SIZE_X                         4:1 /* RWXUF */
#define NV_PGRAPH_FILTER1_KERNEL_SIZE_Y                        12:9 /* RWXUF */
#define NV_PGRAPH_FILTER1_MIPMAP_DITHER_ENABLE                15:15 /* RWXVF */
#define NV_PGRAPH_FILTER1_MIPMAP_DITHER_ENABLE_FALSE     0x00000000 /* RW--V */
#define NV_PGRAPH_FILTER1_MIPMAP_DITHER_ENABLE_TRUE      0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER1_MIPMAPLODBIAS                       23:16 /* RWXSF */
#define NV_PGRAPH_FILTER1_TEXTUREMIN                          26:24 /* RWXVF */
#define NV_PGRAPH_FILTER1_TEXTUREMIN_NEAREST             0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMIN_LINEAR              0x00000002 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMIN_MIPNEAREST          0x00000003 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMIN_MIPLINEAR           0x00000004 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMIN_LINEARMIPNEAREST    0x00000005 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMIN_LINEARMIPLINEAR     0x00000006 /* RW--V */
#define NV_PGRAPH_FILTER1_ANISOTROPIC_MIN_ENABLE              27:27 /* RWXVF */
#define NV_PGRAPH_FILTER1_ANISOTROPIC_MIN_ENABLE_FALSE   0x00000000 /* RW--V */
#define NV_PGRAPH_FILTER1_ANISOTROPIC_MIN_ENABLE_TRUE    0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMAG                          30:28 /* RWXVF */
#define NV_PGRAPH_FILTER1_TEXTUREMAG_NEAREST             0x00000001 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMAG_LINEAR              0x00000002 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMAG_MIPNEAREST          0x00000003 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMAG_MIPLINEAR           0x00000004 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMAG_LINEARMIPNEAREST    0x00000005 /* RW--V */
#define NV_PGRAPH_FILTER1_TEXTUREMAG_LINEARMIPLINEAR     0x00000006 /* RW--V */
#define NV_PGRAPH_FILTER1_ANISOTROPIC_MAG_ENABLE              31:31 /* RWXVF */
#define NV_PGRAPH_FILTER1_ANISOTROPIC_MAG_ENABLE_FALSE   0x00000000 /* RW--V */
#define NV_PGRAPH_FILTER1_ANISOTROPIC_MAG_ENABLE_TRUE    0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA                          0x00400590 /* RW-4R */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_0                       0:0 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_0_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_0_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_0                      4:2 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_0_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_0_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_0_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_0_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_0_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_0_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_0_TEXTURELOD    0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_1                       8:8 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_1_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_1_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_1                    12:10 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_1_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_1_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_1_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_1_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_1_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_1_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_1_TEXTURELOD    0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_2                     16:16 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_2_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_2_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_2                    20:18 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_2_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_2_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_2_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_2_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_2_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_2_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_2_TEXTURELOD    0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_3                     24:24 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_3_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_INVERSE_3_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_3                    28:26 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_3_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_3_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_3_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_3_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_3_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_3_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_ARGUMENT_3_TEXTURELOD    0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_OPERATION                     31:29 /* RWXVF */
#define NV_PGRAPH_COMBINE0ALPHA_OPERATION_ADD            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_OPERATION_ADD2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_OPERATION_ADD4           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_OPERATION_ADDSIGNED      0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_OPERATION_MUX            0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_OPERATION_ADDCOMPLEMENT  0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0ALPHA_OPERATION_ADDSIGNED2     0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR                          0x00400594 /* RW-4R */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_0                       0:0 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_0_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_0_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_0                         1:1 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_0_COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_0_ALPHA            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_0                      4:2 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_0_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_0_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_0_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_0_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_0_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_0_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_0_TEXTURELOD    0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_1                       8:8 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_1_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_1_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_1                         9:9 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_1_COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_1_ALPHA            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_1                    12:10 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_1_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_1_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_1_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_1_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_1_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_1_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_1_TEXTURELOD    0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_2                     16:16 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_2_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_2_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_2                       17:17 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_2_COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_2_ALPHA            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_2                    20:18 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_2_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_2_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_2_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_2_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_2_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_2_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_2_TEXTURELOD    0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_3                     24:24 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_3_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_INVERSE_3_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_3                       25:25 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_3_COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ALPHA_3_ALPHA            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_3                    28:26 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_3_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_3_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_3_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_3_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_3_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_3_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_ARGUMENT_3_TEXTURELOD    0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_OPERATION                     31:29 /* RWXVF */
#define NV_PGRAPH_COMBINE0COLOR_OPERATION_ADD            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_OPERATION_ADD2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_OPERATION_ADD4           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_OPERATION_ADDSIGNED      0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_OPERATION_MUX            0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_OPERATION_ADDCOMPLEMENT  0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE0COLOR_OPERATION_ADDSIGNED2     0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA                          0x00400598 /* RW-4R */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_0                       0:0 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_0_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_0_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_0                      4:2 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_0_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_0_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_0_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_0_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_0_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_0_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_1                       8:8 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_1_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_1_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_1                    12:10 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_1_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_1_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_1_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_1_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_1_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_1_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_2                     16:16 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_2_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_2_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_2                    20:18 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_2_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_2_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_2_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_2_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_2_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_2_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_3                     24:24 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_3_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_INVERSE_3_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_3                    28:26 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_3_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_3_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_3_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_3_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_3_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_ARGUMENT_3_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_OPERATION                     31:29 /* RWXVF */
#define NV_PGRAPH_COMBINE1ALPHA_OPERATION_ADD            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_OPERATION_ADD2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_OPERATION_ADD4           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_OPERATION_ADDSIGNED      0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_OPERATION_MUX            0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_OPERATION_ADDCOMPLEMENT  0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1ALPHA_OPERATION_ADDSIGNED2     0x00000007 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR                          0x0040059C /* RW-4R */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_0                       0:0 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_0_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_0_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_0                         1:1 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_0_COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_0_ALPHA            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_0                      4:2 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_0_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_0_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_0_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_0_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_0_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_0_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_1                       8:8 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_1_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_1_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_1                         9:9 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_1_COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_1_ALPHA            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_1                    12:10 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_1_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_1_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_1_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_1_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_1_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_1_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_2                     16:16 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_2_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_2_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_2                       17:17 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_2_COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_2_ALPHA            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_2                    20:18 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_2_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_2_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_2_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_2_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_2_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_2_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_3                     24:24 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_3_NORMAL         0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_INVERSE_3_INVERSE        0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_3                       25:25 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_3_COLOR            0x00000000 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ALPHA_3_ALPHA            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_3                    28:26 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_3_ZERO          0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_3_FACTOR        0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_3_DIFFUSE       0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_3_INPUT         0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_3_TEXTURE0      0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_ARGUMENT_3_TEXTURE1      0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_OPERATION                     31:29 /* RWXVF */
#define NV_PGRAPH_COMBINE1COLOR_OPERATION_ADD            0x00000001 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_OPERATION_ADD2           0x00000002 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_OPERATION_ADD4           0x00000003 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_OPERATION_ADDSIGNED      0x00000004 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_OPERATION_MUX            0x00000005 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_OPERATION_ADDCOMPLEMENT  0x00000006 /* RW--V */
#define NV_PGRAPH_COMBINE1COLOR_OPERATION_ADDSIGNED2     0x00000007 /* RW--V */
#define NV_PGRAPH_DMA_START_0                            0x00401000 /* RW-4R */
#define NV_PGRAPH_DMA_START_0_VALUE                            31:0 /* RWXUF */
#define NV_PGRAPH_DMA_START_1                            0x00401004 /* RW-4R */
#define NV_PGRAPH_DMA_START_1_VALUE                            31:0 /* RWXUF */
#define NV_PGRAPH_DMA_LENGTH                             0x00401008 /* RW-4R */
#define NV_PGRAPH_DMA_LENGTH_VALUE                             21:0 /* RWXUF */
#define NV_PGRAPH_DMA_MISC                               0x0040100C /* RW-4R */
#define NV_PGRAPH_DMA_MISC_COUNT                               15:0 /* RWXUF */
#define NV_PGRAPH_DMA_MISC_FMT_SRC                            18:16 /* RWXVF */
#define NV_PGRAPH_DMA_MISC_FMT_DST                            22:20 /* RWXVF */
#define NV_PGRAPH_DMA_DATA_0                             0x00401020 /* RW-4R */
#define NV_PGRAPH_DMA_DATA_0_VALUE                             31:0 /* RWXUF */
#define NV_PGRAPH_DMA_DATA_1                             0x00401024 /* RW-4R */
#define NV_PGRAPH_DMA_DATA_1_VALUE                             31:0 /* RWXUF */
#define NV_PGRAPH_DMA_RM                                 0x00401030 /* RW-4R */
#define NV_PGRAPH_DMA_RM_ASSIST_A                               0:0 /* RWIVF */
#define NV_PGRAPH_DMA_RM_ASSIST_A_NOT_PENDING            0x00000000 /* R-I-V */
#define NV_PGRAPH_DMA_RM_ASSIST_A_PENDING                0x00000001 /* R---V */
#define NV_PGRAPH_DMA_RM_ASSIST_A_RESET                  0x00000001 /* -W--C */
#define NV_PGRAPH_DMA_RM_ASSIST_B                               1:1 /* RWIVF */
#define NV_PGRAPH_DMA_RM_ASSIST_B_NOT_PENDING            0x00000000 /* R-I-V */
#define NV_PGRAPH_DMA_RM_ASSIST_B_PENDING                0x00000001 /* R---V */
#define NV_PGRAPH_DMA_RM_ASSIST_B_RESET                  0x00000001 /* -W--C */
#define NV_PGRAPH_DMA_RM_WRITE_REQ                              4:4 /* CWIVF */
#define NV_PGRAPH_DMA_RM_WRITE_REQ_NOT_PENDING           0x00000000 /* CWI-V */
#define NV_PGRAPH_DMA_RM_WRITE_REQ_PENDING               0x00000001 /* -W--T */
#define NV_PGRAPH_DMA_A_XLATE_INST                       0x00401040 /* RW-4R */
#define NV_PGRAPH_DMA_A_XLATE_INST_VALUE                       15:0 /* RWXUF */
#define NV_PGRAPH_DMA_A_CONTROL                          0x00401044 /* RW-4R */
#define NV_PGRAPH_DMA_A_CONTROL_PAGE_TABLE                    12:12 /* RWIVF */
#define NV_PGRAPH_DMA_A_CONTROL_PAGE_TABLE_NOT_PRESENT   0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_A_CONTROL_PAGE_TABLE_PRESENT       0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_A_CONTROL_PAGE_ENTRY                    13:13 /* RWXVF */
#define NV_PGRAPH_DMA_A_CONTROL_PAGE_ENTRY_NOT_LINEAR    0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_A_CONTROL_PAGE_ENTRY_LINEAR        0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_A_CONTROL_TARGET_NODE                   17:16 /* RWXUF */
#define NV_PGRAPH_DMA_A_CONTROL_TARGET_NODE_NVM          0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_A_CONTROL_TARGET_NODE_PCI          0x00000002 /* RW--V */
#define NV_PGRAPH_DMA_A_CONTROL_TARGET_NODE_AGP          0x00000003 /* RW--V */
#define NV_PGRAPH_DMA_A_CONTROL_ADJUST                        31:20 /* RWXUF */
#define NV_PGRAPH_DMA_A_LIMIT                            0x00401048 /* RW-4R */
#define NV_PGRAPH_DMA_A_LIMIT_OFFSET                           31:0 /* RWXUF */
#define NV_PGRAPH_DMA_A_TLB_PTE                          0x0040104C /* RW-4R */
#define NV_PGRAPH_DMA_A_TLB_PTE_ACCESS                          1:1 /* RWXVF */
#define NV_PGRAPH_DMA_A_TLB_PTE_ACCESS_READ_ONLY         0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_A_TLB_PTE_ACCESS_READ_WRITE        0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_A_TLB_PTE_FRAME_ADDRESS                 31:12 /* RWXUF */
#define NV_PGRAPH_DMA_A_TLB_TAG                          0x00401050 /* RW-4R */
#define NV_PGRAPH_DMA_A_TLB_TAG_ADDRESS                       31:12 /* RWXUF */
#define NV_PGRAPH_DMA_A_ADJ_OFFSET                       0x00401054 /* RW-4R */
#define NV_PGRAPH_DMA_A_ADJ_OFFSET_VALUE                       31:0 /* RWXUF */
#define NV_PGRAPH_DMA_A_OFFSET                           0x00401058 /* RW-4R */
#define NV_PGRAPH_DMA_A_OFFSET_VALUE                           31:0 /* RWXUF */
#define NV_PGRAPH_DMA_A_SIZE                             0x0040105C /* RW-4R */
#define NV_PGRAPH_DMA_A_SIZE_VALUE                             24:0 /* RWXUF */
#define NV_PGRAPH_DMA_A_Y_SIZE                           0x00401060 /* RW-4R */
#define NV_PGRAPH_DMA_A_Y_SIZE_VALUE                           10:0 /* RWXUF */
#define NV_PGRAPH_DMA_B_XLATE_INST                       0x00401080 /* RW-4R */
#define NV_PGRAPH_DMA_B_XLATE_INST_VALUE                       15:0 /* RWXUF */
#define NV_PGRAPH_DMA_B_CONTROL                          0x00401084 /* RW-4R */
#define NV_PGRAPH_DMA_B_CONTROL_PAGE_TABLE                    12:12 /* RWIVF */
#define NV_PGRAPH_DMA_B_CONTROL_PAGE_TABLE_NOT_PRESENT   0x00000000 /* RWI-V */
#define NV_PGRAPH_DMA_B_CONTROL_PAGE_TABLE_PRESENT       0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_B_CONTROL_PAGE_ENTRY                    13:13 /* RWXVF */
#define NV_PGRAPH_DMA_B_CONTROL_PAGE_ENTRY_NOT_LINEAR    0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_B_CONTROL_PAGE_ENTRY_LINEAR        0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_B_CONTROL_TARGET_NODE                   17:16 /* RWXUF */
#define NV_PGRAPH_DMA_B_CONTROL_TARGET_NODE_NVM          0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_B_CONTROL_TARGET_NODE_PCI          0x00000002 /* RW--V */
#define NV_PGRAPH_DMA_B_CONTROL_TARGET_NODE_AGP          0x00000003 /* RW--V */
#define NV_PGRAPH_DMA_B_CONTROL_ADJUST                        31:20 /* RWXUF */
#define NV_PGRAPH_DMA_B_LIMIT                            0x00401088 /* RW-4R */
#define NV_PGRAPH_DMA_B_LIMIT_OFFSET                           31:0 /* RWXUF */
#define NV_PGRAPH_DMA_B_TLB_PTE                          0x0040108C /* RW-4R */
#define NV_PGRAPH_DMA_B_TLB_PTE_ACCESS                          1:1 /* RWXVF */
#define NV_PGRAPH_DMA_B_TLB_PTE_ACCESS_READ_ONLY         0x00000000 /* RW--V */
#define NV_PGRAPH_DMA_B_TLB_PTE_ACCESS_READ_WRITE        0x00000001 /* RW--V */
#define NV_PGRAPH_DMA_B_TLB_PTE_FRAME_ADDRESS                 31:12 /* RWXUF */
#define NV_PGRAPH_DMA_B_TLB_TAG                          0x00401090 /* RW-4R */
#define NV_PGRAPH_DMA_B_TLB_TAG_ADDRESS                       31:12 /* RWXUF */
#define NV_PGRAPH_DMA_B_ADJ_OFFSET                       0x00401094 /* RW-4R */
#define NV_PGRAPH_DMA_B_ADJ_OFFSET_VALUE                       31:0 /* RWXUF */
#define NV_PGRAPH_DMA_B_OFFSET                           0x00401098 /* RW-4R */
#define NV_PGRAPH_DMA_B_OFFSET_VALUE                           31:0 /* RWXUF */
#define NV_PGRAPH_DMA_B_SIZE                             0x0040109C /* RW-4R */
#define NV_PGRAPH_DMA_B_SIZE_VALUE                             24:0 /* RWXUF */
#define NV_PGRAPH_DMA_B_Y_SIZE                           0x004010A0 /* RW-4R */
#define NV_PGRAPH_DMA_B_Y_SIZE_VALUE                           10:0 /* RWXUF */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR                      1:0 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_ZOH_MS        0x00000000 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_ZOH           0x00000001 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_INTERPOLATOR_FOH           0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U                            5:4 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_CYLINDRICAL         0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_WRAP                0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_MIRROR              0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_U_CLAMP               0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V                            7:6 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_CYLINDRICAL         0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_WRAP                0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_MIRROR              0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_WRAP_V_CLAMP               0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT                      8:8 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT_LE_X8R8G8B8   0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_FORMAT_LE_A8R8G8B8   0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_SRCCOLOR                        11:10 /* -W-UF */
#define NV_PGRAPH_CONTROL_OUT_SRCCOLOR_NORMAL            0x00000000 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_SRCCOLOR_COLOR_INVERSE     0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_SRCCOLOR_ALPHA_INVERSE     0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_SRCCOLOR_ALPHA_ONE         0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_CULLING                         13:12 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_CULLING_ILLEGAL            0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_CULLING_NONE               0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_CULLING_COUNTERCLOCKWISE   0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_CULLING_CLOCKWISE          0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZBUFFER                         15:15 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ZBUFFER_SCREEN             0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ZBUFFER_LINEAR             0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE                    19:16 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_ILLEGAL       0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_FALSE         0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_LT            0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_EQ            0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_LE            0x00000004 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_GT            0x00000005 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_NE            0x00000006 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_GE            0x00000007 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_COMPARE_TRUE          0x00000008 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE                      22:20 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_NEVER           0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALPHA           0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALPHA_ZETA      0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ZETA            0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ZETA_WRITE_ALWAYS          0x00000004 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE                     26:24 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_NEVER          0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ALPHA          0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ALPHA_ZETA     0x00000002 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_COLOR_WRITE_ZETA           0x00000003 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_ROP                             28:28 /* -WIUF */
#define NV_PGRAPH_CONTROL_OUT_ROP_BLEND_AND              0x00000000 /* -WIUV */
#define NV_PGRAPH_CONTROL_OUT_ROP_ADD_WITH_SATURATION    0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_BETA                      29:29 /* -W-UF */
#define NV_PGRAPH_CONTROL_OUT_BLEND_BETA_SRCALPHA        0x00000000 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_BETA_DESTCOLOR       0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT0                    30:30 /* -W-UF */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT0_DESTCOLOR     0x00000000 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT0_ZERO          0x00000001 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT1                    31:31 /* -W-UF */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT1_SRCCOLOR      0x00000000 /* -W-UV */
#define NV_PGRAPH_CONTROL_OUT_BLEND_INPUT1_ZERO          0x00000001 /* -W-UV */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_KEY                          7:0 /* RWXUF */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE                     11:8 /* RWXVF */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_ILLEGAL       0x00000000 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_FALSE         0x00000001 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_LT            0x00000002 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_EQ            0x00000003 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_LE            0x00000004 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_GT            0x00000005 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_NE            0x00000006 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_GE            0x00000007 /* RW--V */
#define NV_PGRAPH_ALPHACNTRL_ALPHA_COMPARE_TRUE          0x00000008 /* RW--V */
/* dev_video.ref */
#define NV_PVIDEO                             0x006802FF:0x00680000 /* RW--D */
#define NV_PVIDEO_INTR_0                                 0x00680100 /* RWI4R */
#define NV_PVIDEO_INTR_0_NOTIFY                                 0:0 /* RWIVF */
#define NV_PVIDEO_INTR_0_NOTIFY_NOT_PENDING              0x00000000 /* R-I-V */
#define NV_PVIDEO_INTR_0_NOTIFY_PENDING                  0x00000001 /* R---V */
#define NV_PVIDEO_INTR_0_NOTIFY_RESET                    0x00000001 /* -W--V */
#define NV_PVIDEO_INTR_EN_0                              0x00680140 /* RWI4R */
#define NV_PVIDEO_INTR_EN_0_NOTIFY                              0:0 /* RWIVF */
#define NV_PVIDEO_INTR_EN_0_NOTIFY_DISABLED              0x00000000 /* RWI-V */
#define NV_PVIDEO_INTR_EN_0_NOTIFY_ENABLED               0x00000001 /* RW--V */
#define NV_PVIDEO_STEP_SIZE                              0x00680200 /* RW-4R */
#define NV_PVIDEO_STEP_SIZE_X                                  11:0 /* RWXVF */
#define NV_PVIDEO_STEP_SIZE_Y                                 27:16 /* RWXVF */
#define NV_PVIDEO_CONTROL_Y                              0x00680204 /* RW-4R */
#define NV_PVIDEO_CONTROL_Y_BLUR                                0:0 /* RW--F */
#define NV_PVIDEO_CONTROL_Y_BLUR_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_Y_BLUR_ON                      0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_Y_LINE                                4:4 /* RW--F */
#define NV_PVIDEO_CONTROL_Y_LINE_HALF                    0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_Y_LINE_FULL                    0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_X                              0x00680208 /* RW-4R */
#define NV_PVIDEO_CONTROL_X_WEIGHT                              0:0 /* RW--F */
#define NV_PVIDEO_CONTROL_X_WEIGHT_LIGHT                 0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_X_WEIGHT_HEAVY                 0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SHARPENING                          4:4 /* RW--F */
#define NV_PVIDEO_CONTROL_X_SHARPENING_OFF               0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SHARPENING_ON                0x00000001 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SMOOTHING                           8:8 /* RW--F */
#define NV_PVIDEO_CONTROL_X_SMOOTHING_OFF                0x00000000 /* RW--V */
#define NV_PVIDEO_CONTROL_X_SMOOTHING_ON                 0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF0_START                            0x0068020c /* RW-4R */
#define NV_PVIDEO_BUFF0_START_ADDRESS                          23:2 /* RW-UF */
#define NV_PVIDEO_BUFF1_START                            0x00680210 /* RW-4R */
#define NV_PVIDEO_BUFF1_START_ADDRESS                          23:2 /* RW-UF */
#define NV_PVIDEO_BUFF0_PITCH                            0x00680214 /* RW-4R */
#define NV_PVIDEO_BUFF0_PITCH_LENGTH                           13:4 /* RW-UF */
#define NV_PVIDEO_BUFF1_PITCH                            0x00680218 /* RW-4R */
#define NV_PVIDEO_BUFF1_PITCH_LENGTH                           13:4 /* RW-UF */
#define NV_PVIDEO_BUFF0_OFFSET                           0x0068021c /* RW-4R */
#define NV_PVIDEO_BUFF0_OFFSET_X                                0:0 /* RW--F */
#define NV_PVIDEO_BUFF0_OFFSET_Y                                5:4 /* RW--F */
#define NV_PVIDEO_BUFF0_OFFSET_Y_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_BUFF0_OFFSET_Y_QUARTER                 0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF0_OFFSET_Y_HALF                    0x00000002 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET                           0x00680220 /* RW-4R */
#define NV_PVIDEO_BUFF1_OFFSET_X                                0:0 /* RW--F */
#define NV_PVIDEO_BUFF1_OFFSET_Y                                5:4 /* RW--F */
#define NV_PVIDEO_BUFF1_OFFSET_Y_OFF                     0x00000000 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET_Y_QUARTER                 0x00000001 /* RW--V */
#define NV_PVIDEO_BUFF1_OFFSET_Y_HALF                    0x00000002 /* RW--V */
#define NV_PVIDEO_OE_STATE                               0x00680224 /* RW-4R */
#define NV_PVIDEO_OE_STATE_BUFF0_INTR_NOTIFY                    0:0 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF1_INTR_NOTIFY                    4:4 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF0_ERROR                          8:8 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF1_ERROR                        12:12 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF0_IN_USE                       16:16 /* RWXVF */
#define NV_PVIDEO_OE_STATE_BUFF1_IN_USE                       20:20 /* RWXVF */
#define NV_PVIDEO_OE_STATE_CURRENT_BUFFER                     24:24 /* RWXVF */
#define NV_PVIDEO_OE_STATE_CURRENT_BUFFER_0              0x00000000 /* RW--V */
#define NV_PVIDEO_OE_STATE_CURRENT_BUFFER_1              0x00000001 /* RW--V */
#define NV_PVIDEO_SU_STATE                               0x00680228 /* RW-4R */
#define NV_PVIDEO_SU_STATE_BUFF0_IN_USE                       16:16 /* RWXVF */
#define NV_PVIDEO_SU_STATE_BUFF1_IN_USE                       20:20 /* RWXVF */
#define NV_PVIDEO_RM_STATE                               0x0068022c /* RW-4R */
#define NV_PVIDEO_RM_STATE_BUFF0_INTR_NOTIFY                    0:0 /* RWXVF */
#define NV_PVIDEO_RM_STATE_BUFF1_INTR_NOTIFY                    4:4 /* RWXVF */
#define NV_PVIDEO_WINDOW_START                           0x00680230 /* RW-4R */
#define NV_PVIDEO_WINDOW_START_X                               10:0 /* RWXUF */
#define NV_PVIDEO_WINDOW_START_Y                              26:16 /* RWXUF */
#define NV_PVIDEO_WINDOW_SIZE                            0x00680234 /* RW-4R */
#define NV_PVIDEO_WINDOW_SIZE_X                                10:0 /* RWXUF */
#define NV_PVIDEO_WINDOW_SIZE_Y                               26:16 /* RWXUF */
#define NV_PVIDEO_FIFO_THRES                             0x00680238 /* RW-4R */
#define NV_PVIDEO_FIFO_THRES_SIZE                               7:3 /* RW--F */
#define NV_PVIDEO_FIFO_BURST                             0x0068023c /* RW-4R */
#define NV_PVIDEO_FIFO_BURST_LENGTH                             1:0 /* RW--F */
#define NV_PVIDEO_FIFO_BURST_LENGTH_32                   0x00000001 /* RW--V */
#define NV_PVIDEO_FIFO_BURST_LENGTH_64                   0x00000002 /* RW--V */
#define NV_PVIDEO_FIFO_BURST_LENGTH_128                  0x00000003 /* RW--V */
#define NV_PVIDEO_KEY                                    0x00680240 /* RW-4R */
#define NV_PVIDEO_KEY_INDEX                                     7:0 /* RW-VF */
#define NV_PVIDEO_KEY_565                                      15:0 /* RW-VF */
#define NV_PVIDEO_KEY_555                                      14:0 /* RW-VF */
#define NV_PVIDEO_KEY_888                                      23:0 /* RW-VF */
#define NV_PVIDEO_KEY_PACK                                    31:24 /* RW-VF */
#define NV_PVIDEO_OVERLAY                                0x00680244 /* RWI4R */
#define NV_PVIDEO_OVERLAY_VIDEO                                 0:0 /* RWI-F */
#define NV_PVIDEO_OVERLAY_VIDEO_OFF                      0x00000000 /* RWI-V */
#define NV_PVIDEO_OVERLAY_VIDEO_ON                       0x00000001 /* RW--V */
#define NV_PVIDEO_OVERLAY_KEY                                   4:4 /* RW--F */
#define NV_PVIDEO_OVERLAY_KEY_OFF                        0x00000000 /* RW--V */
#define NV_PVIDEO_OVERLAY_KEY_ON                         0x00000001 /* RW--V */
#define NV_PVIDEO_OVERLAY_FORMAT                                8:8 /* RW--F */
#define NV_PVIDEO_OVERLAY_FORMAT_CCIR                    0x00000000 /* RW--V */
#define NV_PVIDEO_OVERLAY_FORMAT_YUY2                    0x00000001 /* RW--V */
#define NV_PVIDEO_RED_CSC                                0x00680280 /* RW-4R */
#define NV_PVIDEO_RED_CSC_OFFSET                                7:0 /* RWX-F */
#define NV_PVIDEO_GREEN_CSC                              0x00680284 /* RW-4R */
#define NV_PVIDEO_GREEN_CSC_OFFSET                              7:0 /* RWX-F */
#define NV_PVIDEO_BLUE_CSC                               0x00680288 /* RW-4R */
#define NV_PVIDEO_BLUE_CSC_OFFSET                               7:0 /* RWX-F */
#define NV_PVIDEO_CSC_ADJUST                             0x0068028c /* RW-4R */
#define NV_PVIDEO_CSC_ADJUST_B_FLAG                             0:0 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_B_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_B_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_G_FLAG                             4:4 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_G_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_G_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_R_FLAG                             8:8 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_R_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_R_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_L_FLAG                           12:12 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_L_FLAG_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_L_FLAG_ON                   0x00000001 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_CHROMA                           16:16 /* RW--F */
#define NV_PVIDEO_CSC_ADJUST_CHROMA_OFF                  0x00000000 /* RW--V */
#define NV_PVIDEO_CSC_ADJUST_CHROMA_ON                   0x00000001 /* RW--V */
/* dev_vga.ref */
#define NV_PRMCIO                             0x00601FFF:0x00601000 /* RW--D */
#define NV_PRMCIO_INP0                                   0x006013c2 /* R--1R */
#define NV_PRMCIO_INP0__MONO                             0x006013ba /* R--1R */
#define NV_PRMCIO_INP0__COLOR                            0x006013da /* R--1R */
#define NV_PRMCIO_INP0__READ_MONO                        0x006013ca /* R--1R */
#define NV_PRMCIO_INP0__WRITE_MONO                       0x006013ba /* -W-1R */
#define NV_PRMCIO_INP0__WRITE_COLOR                      0x006013da /* -W-1R */
#define NV_PRMCIO_ARX                                    0x006013c0 /* RW-1R */
#define NV_PRMCIO_AR_PALETTE__WRITE                      0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_PALETTE__READ                       0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_MODE__WRITE                         0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_MODE__READ                          0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_MODE_INDEX                          0x00000010 /*       */
#define NV_PRMCIO_AR_OSCAN__WRITE                        0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_OSCAN__READ                         0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_OSCAN_INDEX                         0x00000011 /*       */
#define NV_PRMCIO_AR_PLANE__WRITE                        0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_PLANE__READ                         0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_PLANE_INDEX                         0x00000012 /*       */
#define NV_PRMCIO_AR_HPP__WRITE                          0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_HPP__READ                           0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_HPP_INDEX                           0x00000013 /*       */
#define NV_PRMCIO_AR_CSEL__WRITE                         0x006013c0 /* -W-1R */
#define NV_PRMCIO_AR_CSEL__READ                          0x006013c1 /* R--1R */
#define NV_PRMCIO_AR_CSEL_INDEX                          0x00000014 /*       */
#define NV_PRMCIO_CRX__MONO                              0x006013b4 /* RW-1R */
#define NV_PRMCIO_CRX__COLOR                             0x006013d4 /* RW-1R */
#define NV_PRMCIO_CR__MONO                               0x006013b5 /* RW-1R */
#define NV_PRMCIO_CR__COLOR                              0x006013d5 /* RW-1R */
#define NV_PRMCIO_CRE__MONO                              0x006013b5 /* RW-1R */
#define NV_PRMCIO_CRE__COLOR                             0x006013d5 /* RW-1R */
/* dev_vga.ref */
#define NV_PCRTC_INTR_0                                  0x00600100 /* RWI4R */
#define NV_PCRTC_INTR_0_VBLANK                                  0:0 /* RWI-F */
#define NV_PCRTC_INTR_0_VBLANK_NOT_PENDING               0x00000000 /* R-I-V */
#define NV_PCRTC_INTR_0_VBLANK_PENDING                   0x00000001 /* R---V */
#define NV_PCRTC_INTR_0_VBLANK_RESET                     0x00000001 /* -W--V */
#define NV_PCRTC_INTR_EN_0                               0x00600140 /* RWI4R */
#define NV_PCRTC_INTR_EN_0_VBLANK                               0:0 /* RWIVF */
#define NV_PCRTC_INTR_EN_0_VBLANK_DISABLED               0x00000000 /* RWI-V */
#define NV_PCRTC_INTR_EN_0_VBLANK_ENABLED                0x00000001 /* RW--V */
#define NV_PCRTC_START                                   0x00600800 /* RWI4R */
#define NV_PCRTC_START_ADDRESS                                 24:2 /* RWI-F */
#define NV_PCRTC_CONFIG                                  0x00600804 /* RWI4R */
#define NV_PCRTC_CONFIG_START_ADDRESS                           0:0 /* RWI-F */
#define NV_PCRTC_CONFIG_START_ADDRESS_VGA                0x00000000 /* RWI-V */
#define NV_PCRTC_CONFIG_START_ADDRESS_NON_VGA            0x00000001 /* RW--V */
#define NV_PCRTC_RASTER                                  0x00600808 /* R-I4R */
#define NV_PCRTC_RASTER_POSITION                               10:0 /* R---F */
#define NV_PCRTC_RASTER_SA_LOAD                               13:12 /* R---F */
#define NV_PCRTC_RASTER_SA_LOAD_DISPLAY                  0x00000000 /* R---V */
#define NV_PCRTC_RASTER_SA_LOAD_BEFORE                   0x00000001 /* R---V */
#define NV_PCRTC_RASTER_SA_LOAD_AFTER                    0x00000002 /* R---V */
#define NV_PCRTC_RASTER_VERT_BLANK                            16:16 /* R---F */
#define NV_PCRTC_RASTER_VERT_BLANK_ACTIVE                0x00000001 /* R---V */
#define NV_PCRTC_RASTER_VERT_BLANK_INACTIVE              0x00000000 /* R---V */
/* dev_vga.ref */
#define NV_CIO                                          0x3DF:0x3B0 /* ----D */
#define NV_CIO_INP0                                      0x000003c2 /* R--1R */
#define NV_CIO_INP0__MONO                                0x000003ba /* R--1R */
#define NV_CIO_INP0__COLOR                               0x000003da /* R--1R */
#define NV_CIO_INP0__READ_MONO                           0x000003ca /* R--1R */
#define NV_CIO_INP0__WRITE_MONO                          0x000003ba /* -W-1R */
#define NV_CIO_INP0__WRITE_COLOR                         0x000003da /* -W-1R */
#define NV_CIO_ARX                                       0x000003c0 /* RW-1R */
#define NV_CIO_AR_PALETTE__WRITE                         0x000003c0 /* -W-1R */
#define NV_CIO_AR_PALETTE__READ                          0x000003c1 /* R--1R */
#define NV_CIO_AR_MODE__WRITE                            0x000003c0 /* -W-1R */
#define NV_CIO_AR_MODE__READ                             0x000003c1 /* R--1R */
#define NV_CIO_AR_MODE_INDEX                             0x00000010 /*       */
#define NV_CIO_AR_OSCAN__WRITE                           0x000003c0 /* -W-1R */
#define NV_CIO_AR_OSCAN__READ                            0x000003c1 /* R--1R */
#define NV_CIO_AR_OSCAN_INDEX                            0x00000011 /*       */
#define NV_CIO_AR_PLANE__WRITE                           0x000003c0 /* -W-1R */
#define NV_CIO_AR_PLANE__READ                            0x000003c1 /* R--1R */
#define NV_CIO_AR_PLANE_INDEX                            0x00000012 /*       */
#define NV_CIO_AR_HPP__WRITE                             0x000003c0 /* -W-1R */
#define NV_CIO_AR_HPP__READ                              0x000003c1 /* R--1R */
#define NV_CIO_AR_HPP_INDEX                              0x00000013 /*       */
#define NV_CIO_AR_CSEL__WRITE                            0x000003c0 /* -W-1R */
#define NV_CIO_AR_CSEL__READ                             0x000003c1 /* R--1R */
#define NV_CIO_AR_CSEL_INDEX                             0x00000014 /*       */
#define NV_CIO_CRX__MONO                                 0x000003b4 /* RW-1R */
#define NV_CIO_CRX__COLOR                                0x000003d4 /* RW-1R */
#define NV_CIO_CR__MONO                                  0x000003b5 /* RW-1R */
#define NV_CIO_CR__COLOR                                 0x000003d5 /* RW-1R */
#define NV_CIO_CR_HDT_INDEX                              0x00000000 /*       */
#define NV_CIO_CR_HDE_INDEX                              0x00000001 /*       */
#define NV_CIO_CR_HBS_INDEX                              0x00000002 /*       */
#define NV_CIO_CR_HBE_INDEX                              0x00000003 /*       */
#define NV_CIO_CR_HBE_4_0                                       4:0 /* RW--F */
#define NV_CIO_CR_HRS_INDEX                              0x00000004 /*       */
#define NV_CIO_CR_HRE_INDEX                              0x00000005 /*       */
#define NV_CIO_CR_HRE_HBE_5                                     7:7 /* RW--F */
#define NV_CIO_CR_HRE_4_0                                       4:0 /* RW--F */
#define NV_CIO_CR_VDT_INDEX                              0x00000006 /*       */
#define NV_CIO_CR_OVL_INDEX                              0x00000007 /*       */
#define NV_CIO_CR_OVL_VDE_8                                     1:1 /* RW--F */
#define NV_CIO_CR_OVL_VDE_9                                     6:6 /* RW--F */
#define NV_CIO_CR_OVL_VDT_8                                     0:0 /* RW--F */
#define NV_CIO_CR_OVL_VDT_9                                     5:5 /* RW--F */
#define NV_CIO_CR_OVL_VBS_8                                     3:3 /* RW--F */
#define NV_CIO_CR_OVL_VRS_8                                     2:2 /* RW--F */
#define NV_CIO_CR_OVL_VRS_9                                     7:7 /* RW--F */
#define NV_CIO_CR_RSAL_INDEX                             0x00000008 /*       */
#define NV_CIO_CR_RSAL_PANNING                                  6:5 /* RW--F */
#define NV_CIO_CR_CELL_HT_INDEX                          0x00000009 /*       */
#define NV_CIO_CR_CELL_HT_SCANDBL                               7:7 /* RW--F */
#define NV_CIO_CR_CELL_HT_VBS_9                                 5:5 /* RW--F */
#define NV_CIO_CR_CURS_ST_INDEX                          0x0000000A /*       */
#define NV_CIO_CR_CURS_END_INDEX                         0x0000000B /*       */
#define NV_CIO_CR_SA_HI_INDEX                            0x0000000C /*       */
#define NV_CIO_CR_SA_LO_INDEX                            0x0000000D /*       */
#define NV_CIO_CR_TCOFF_HI_INDEX                         0x0000000E /*       */
#define NV_CIO_CR_TCOFF_LO_INDEX                         0x0000000F /*       */
#define NV_CIO_CR_VRS_INDEX                              0x00000010 /*       */
#define NV_CIO_CR_VRE_INDEX                              0x00000011 /*       */
#define NV_CIO_CR_VRE_3_0                                       3:0 /* RW--F */
#define NV_CIO_CR_VDE_INDEX                              0x00000012 /*       */
#define NV_CIO_CR_OFFSET_INDEX                           0x00000013 /*       */
#define NV_CIO_CR_ULINE_INDEX                            0x00000014 /*       */
#define NV_CIO_CR_VBS_INDEX                              0x00000015 /*       */
#define NV_CIO_CR_VBE_INDEX                              0x00000016 /*       */
#define NV_CIO_CR_MODE_INDEX                             0x00000017 /*       */
#define NV_CIO_CR_LCOMP_INDEX                            0x00000018 /*       */
#define NV_CIO_CR_GDATA_INDEX                            0x00000022 /*       */
#define NV_CIO_CR_ARFF_INDEX                             0x00000024 /*       */
#define NV_CIO_CR_ARX_INDEX                              0x00000026 /*       */
#define NV_CIO_CRE__MONO                                 0x000003b5 /* RW-1R */
#define NV_CIO_CRE__COLOR                                0x000003d5 /* RW-1R */
#define NV_CIO_CRE_RPC0_INDEX                            0x00000019 /*       */
#define NV_CIO_CRE_RPC0_START                                   4:0 /* RW--F */
#define NV_CIO_CRE_RPC0_OFFSET_10_8                             7:5 /* RW--F */
#define NV_CIO_CRE_RPC1_INDEX                            0x0000001A /*       */
#define NV_CIO_CRE_RPC1_LARGE                                  2:2 /* RW--F */
#define NV_CIO_CRE_FF_INDEX                              0x0000001B /*       */
#define NV_CIO_CRE_FF_BURST                                     2:0 /* RW--F */
#define NV_CIO_CRE_FF_BURST_8                            0x00000000 /* RW--V */
#define NV_CIO_CRE_FF_BURST_32                           0x00000001 /* RW--V */
#define NV_CIO_CRE_FF_BURST_64                           0x00000002 /* RW--V */
#define NV_CIO_CRE_FF_BURST_128                          0x00000003 /* RW--V */
#define NV_CIO_CRE_FF_BURST_256                          0x00000004 /* RW--V */
#define NV_CIO_CRE_ENH_INDEX                             0x0000001C /*       */
#define NV_CIO_CRE_PAGE0_INDEX                           0x0000001D /*       */
#define NV_CIO_CRE_PAGE1_INDEX                           0x0000001E /*       */
#define NV_CIO_SR_LOCK_INDEX                             0x0000001F /*       */
#define NV_CIO_SR_UNLOCK_RW_VALUE                            0x00000057 /*       */
#define NV_CIO_SR_UNLOCK_RO_VALUE                            0x00000075 /*       */
#define NV_CIO_SR_LOCK_VALUE                                 0x00000099 /*       */
#define NV_CIO_CRE_FFLWM__INDEX                          0x00000020 /*       */
#define NV_CIO_CRE_FFLWM_LWM                                    5:0 /* RW--F */
#define NV_CIO_CRE_FABID_INDEX                             0x00000025 /*       */
#define NV_CIO_CRE_LSR_INDEX                             0x00000025 /*       */
#define NV_CIO_CRE_LSR_VDE_10                                   1:1 /* RW--F */
#define NV_CIO_CRE_LSR_VDT_10                                   0:0 /* RW--F */
#define NV_CIO_CRE_LSR_HBE_6                                    4:4 /* RW--F */
#define NV_CIO_CRE_LSR_VBS_10                                   3:3 /* RW--F */
#define NV_CIO_CRE_LSR_VRS_10                                   2:2 /* RW--F */
#define NV_CIO_CRE_CHIP_ID_INDEX                        0x00000027 /*       */
#define NV_CIO_CRE_PIXEL_INDEX                           0x00000028 /*       */
#define NV_CIO_CRE_PIXEL_TV_ADJ                                 5:3 /* RW--F */
#define NV_CIO_CRE_PIXEL_FORMAT                                 1:0 /* RW--F */
#define NV_CIO_CRE_PIXEL_FORMAT_VGA                      0x00000000 /* RW--V */
#define NV_CIO_CRE_PIXEL_FORMAT_8BPP                     0x00000001 /* RW--V */
#define NV_CIO_CRE_PIXEL_FORMAT_16BPP                    0x00000002 /* RW--V */
#define NV_CIO_CRE_PIXEL_FORMAT_32BPP                    0x00000003 /* RW--V */
#define NV_CIO_CRE_PAGE_OVFL__INDEX                     0x00000029 /*       */
#define NV_CIO_CRE_OSCOL__INDEX                          0x0000002A /*       */
#define NV_CIO_CRE_SCRATCH0__INDEX                       0x0000002B /*       */
#define NV_CIO_CRE_SCRATCH1__INDEX                       0x0000002C /*       */
#define NV_CIO_CRE_HEB__INDEX                            0x0000002D /*       */
#define NV_CIO_CRE_HEB_SA_23                                    5:5 /* RW--F */
#define NV_CIO_CRE_HEB_ILC_8                                    4:4 /* RW--F */
#define NV_CIO_CRE_HEB_HRS_8                                    3:3 /* RW--F */
#define NV_CIO_CRE_HEB_HBS_8                                    2:2 /* RW--F */
#define NV_CIO_CRE_HEB_HDE_8                                    1:1 /* RW--F */
#define NV_CIO_CRE_HEB_HDT_8                                    0:0 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR2_INDEX                      0x0000002f /*       */
#define NV_CIO_CRE_HCUR_ADDR0_INDEX                      0x00000030 /*       */
#define NV_CIO_CRE_HCUR_ASI                                     7:7 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR0_ADR                               6:0 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR1_INDEX                      0x00000031 /*       */
#define NV_CIO_CRE_HCUR_ADDR1_ADR                               7:2 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR1_CUR_DBL                           1:1 /* RW--F */
#define NV_CIO_CRE_HCUR_ADDR1_ENABLE                            0:0 /* RW--F */
#define NV_CIO_CRE_VID_END0__INDEX                       0x00000032 /*       */
#define NV_CIO_CRE_VID_END_7_0                                  7:0 /* RW--F */
#define NV_CIO_CRE_VID_END1__INDEX                       0x00000033 /*       */
// NV5 specific
#define NV_CIO_CRE_LCD__INDEX                            0x00000033 /*       */
#define NV_CIO_CRE_VID_END_ENABLE                               4:4 /* RW--F */
#define NV_CIO_CRE_VID_END_10_8                                 2:0 /* RW--F */
#define NV_CIO_CRE_RL0__INDEX                            0x00000034 /*       */
#define NV_CIO_CRE_RL1__INDEX                            0x00000035 /*       */
#define NV_CIO_CRE_RMA__INDEX                            0x00000038 /*       */
#define NV_CIO_CRE_ILACE__INDEX                          0x00000039 /*       */
#define NV_CIO_CRE_SCRATCH2__INDEX                       0x0000003A /*       */
#define NV_CIO_CRE_SCRATCH3__INDEX                       0x0000003B /*       */
#define NV_CIO_CRE_SCRATCH4__INDEX                       0x0000003C /*       */
#define NV_CIO_CRE_TREG__INDEX                           0x0000003D /*       */
#define NV_CIO_CRE_TREG_HCNT                                    6:6 /* RW--F */
#define NV_CIO_CRE_TREG_VCNT                                    4:4 /* RW--F */
#define NV_CIO_CRE_TREG_SHADOW                                  0:0 /* RW--F */
#define NV_CIO_CRE_TREG_HCNT_INDEX                       0x00000000 /*       */
#define NV_CIO_CRE_TREG_VCNTA_INDEX                      0x00000006 /*       */
#define NV_CIO_CRE_TREG_VCNTB_INDEX                      0x00000007 /*       */
#define NV_CIO_CRE_DDC_STATUS__INDEX                     0x0000003E /*       */
#define NV_CIO_CRE_DDC_WR__INDEX                         0x0000003F /*       */
#define NV_CIO_CRE_PCI_TO__INDEX                          0x00000040 /*       */
#define NV_CIO_CRE_PCI_TO_DELAY                                  7:0 /* -W--F */

#define NV_CIO_CRE_H2OWNS                                0x00000044 /*       */
#define NV_CIO_CRE_H2OWNS_VGA                                   0:0 /* RW--F */
#define NV_CIO_CRE_H2OWNS_VGA_DEFAULT                    0x00000000 /* RWI-V */
#define NV_CIO_CRE_H2OWNS_VGA_DISABLE                    0x00000000 /* RW--V */
#define NV_CIO_CRE_H2OWNS_VGA_ENABLE                     0x00000001 /* RW--V */
#define NV_CIO_CRE_H2OWNS_DAC                                   1:1 /* RW--F */
#define NV_CIO_CRE_H2OWNS_DAC_DEFAULT                    0x00000000 /* RWI-V */
#define NV_CIO_CRE_H2OWNS_DAC_DISABLE                    0x00000000 /* RW--V */
#define NV_CIO_CRE_H2OWNS_DAC_ENABLE                     0x00000001 /* RW--V */
#define NV_CIO_CRE_H2OWNS_MIRROR                                2:2 /* RW--F */
#define NV_CIO_CRE_H2OWNS_MIRROR_DEFAULT                 0x00000000 /* RWI-V */
#define NV_CIO_CRE_H2OWNS_MIRROR_DISABLE                 0x00000000 /* RW--V */
#define NV_CIO_CRE_H2OWNS_MIRROR_ENABLE                  0x00000001 /* RW--V */

/* dev_vga.ref */
#define NV_VIO_MBEN                                      0x00000094 /* RW-1R */
#define NV_VIO_ADDEN                                     0x000046e8 /* RW-1R */
#define NV_VIO_VSE1                                      0x00000102 /* RW-1R */
#define NV_VIO_VSE2                                      0x000003c3 /* RW-1R */
#define NV_VIO_MISC__READ                                0x000003cc /* R--1R */
#define NV_VIO_MISC__WRITE                               0x000003c2 /* -W-1R */
#define NV_VIO_SRX                                       0x000003c4 /* RW-1R */
#define NV_VIO_SR_RESET                                  0x000003c5 /* RW-1R */
#define NV_VIO_SR_RESET_INDEX                            0x00000000 /*     V */
#define NV_VIO_SR_CLOCK                                  0x000003c5 /* RW-1R */
#define NV_VIO_SR_CLOCK_INDEX                            0x00000001 /*     V */
#define NV_VIO_SR_PLANE_MASK                             0x000003c5 /* RW-1R */
#define NV_VIO_SR_PLANE_MASK_INDEX                       0x00000002 /*     V */
#define NV_VIO_SR_CHAR_MAP                               0x000003c5 /* RW-1R */
#define NV_VIO_SR_CHAR_MAP_INDEX                         0x00000003 /*       */
#define NV_VIO_SR_MEM_MODE                               0x000003c5 /* RW-1R */
#define NV_VIO_SR_MEM_MODE_INDEX                         0x00000004 /*       */
#define NV_VIO_GRX                                       0x000003ce /* RW-1R */
#define NV_VIO_GX_SR                                     0x000003cf /* RW-1R */
#define NV_VIO_GX_SR_INDEX                               0x00000000 /*       */
#define NV_VIO_GX_SREN                                   0x000003cf /* RW-1R */
#define NV_VIO_GX_SREN_INDEX                             0x00000001 /*       */
#define NV_VIO_GX_CCOMP                                  0x000003cf /* RW-1R */
#define NV_VIO_GX_CCOMP_INDEX                            0x00000002 /*       */
#define NV_VIO_GX_ROP                                    0x000003cf /* RW-1R */
#define NV_VIO_GX_ROP_INDEX                              0x00000003 /*       */
#define NV_VIO_GX_READ_MAP                               0x000003cf /* RW-1R */
#define NV_VIO_GX_READ_MAP_INDEX                         0x00000004 /*       */
#define NV_VIO_GX_MODE                                   0x000003cf /* RW-1R */
#define NV_VIO_GX_MODE_INDEX                             0x00000005 /*       */
#define NV_VIO_GX_MISC                                   0x000003cf /* RW-1R */
#define NV_VIO_GX_MISC_INDEX                             0x00000006 /*       */
#define NV_VIO_GX_DONT_CARE                              0x000003cf /* RW-1R */
#define NV_VIO_GX_DONT_CARE_INDEX                        0x00000007 /*       */
#define NV_VIO_GX_BIT_MASK                               0x000003cf /* RW-1R */
#define NV_VIO_GX_BIT_MASK_INDEX                         0x00000008 /*       */
/* dev_vga.ref */
#define NV_PRMVIO                             0x000C7FFF:0x000C0000 /* RW--D */
#define NV_PRMVIO_MBEN                                   0x000C0094 /* RW-1R */
#define NV_PRMVIO_ADDEN                                  0x000C46e8 /* RW-1R */
#define NV_PRMVIO_VSE1                                   0x000C0102 /* RW-1R */
#define NV_PRMVIO_VSE2                                   0x000C03c3 /* RW-1R */
#define NV_PRMVIO_MISC__READ                             0x000C03cc /* R--1R */
#define NV_PRMVIO_MISC__WRITE                            0x000C03c2 /* -W-1R */
#define NV_PRMVIO_SRX                                    0x000C03c4 /* RW-1R */
#define NV_PRMVIO_SR_RESET                               0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_RESET_INDEX                         0x00000000 /*     V */
#define NV_PRMVIO_SR_CLOCK                               0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_CLOCK_INDEX                         0x00000001 /*     V */
#define NV_PRMVIO_SR_PLANE_MASK                          0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_PLANE_MASK_INDEX                    0x00000002 /*     V */
#define NV_PRMVIO_SR_CHAR_MAP                            0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_CHAR_MAP_INDEX                      0x00000003 /*       */
#define NV_PRMVIO_SR_MEM_MODE                            0x000C03c5 /* RW-1R */
#define NV_PRMVIO_SR_MEM_MODE_INDEX                      0x00000004 /*       */
#define NV_PRMVIO_GRX                                    0x000C03ce /* RW-1R */
#define NV_PRMVIO_GX_SR                                  0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_SR_INDEX                            0x00000000 /*       */
#define NV_PRMVIO_GX_SREN                                0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_SREN_INDEX                          0x00000001 /*       */
#define NV_PRMVIO_GX_CCOMP                               0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_CCOMP_INDEX                         0x00000002 /*       */
#define NV_PRMVIO_GX_ROP                                 0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_ROP_INDEX                           0x00000003 /*       */
#define NV_PRMVIO_GX_READ_MAP                            0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_READ_MAP_INDEX                      0x00000004 /*       */
#define NV_PRMVIO_GX_MODE                                0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_MODE_INDEX                          0x00000005 /*       */
#define NV_PRMVIO_GX_MISC                                0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_MISC_INDEX                          0x00000006 /*       */
#define NV_PRMVIO_GX_DONT_CARE                           0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_DONT_CARE_INDEX                     0x00000007 /*       */
#define NV_PRMVIO_GX_BIT_MASK                            0x000C03cf /* RW-1R */
#define NV_PRMVIO_GX_BIT_MASK_INDEX                      0x00000008 /*       */
/* dev_vga.ref */
#define NV_PRMVGA                             0x000BFFFF:0x000A0000 /* RW--D */
/* dev_media.ref */
#define NV_PME                                0x00200FFF:0x00200000 /* RW--D */
#define NV_PME_DEBUG_0                                   0x00200080 /* RWI4R */
#define NV_PME_DEBUG_0_DET_FIELD_SWITCH                         0:0 /* RWI-F */
#define NV_PME_DEBUG_0_DET_FIELD_SWITCH_DISABLED         0x00000000 /* RWI-V */
#define NV_PME_DEBUG_0_DET_FIELD_SWITCH_ENABLED          0x00000001 /* RW--V */
#define NV_PME_DEBUG_0_CAPTURE_00_FF                            4:4 /* RWI-F */
#define NV_PME_DEBUG_0_CAPTURE_00_FF_DISABLED            0x00000000 /* RWI-V */
#define NV_PME_DEBUG_0_CAPTURE_00_FF_ENABLED             0x00000001 /* RW--V */
#define NV_PME_DEBUG_1                                   0x00200084 /* RWI4R */
#define NV_PME_DEBUG_1_SEL                                      1:0 /* RWI-F */
#define NV_PME_DEBUG_1_SEL_VIPCLK                        0x00000000 /* RWI-V */
#define NV_PME_DEBUG_1_SEL_MCLK                          0x00000001 /* RW--V */
#define NV_PME_DEBUG_1_SEL_GLOB                          0x00000002 /* RW--V */
#define NV_PME_DEBUG_1_VIPCLK_SEL                               6:4 /* RWI-F */
#define NV_PME_DEBUG_1_VIPCLK_SEL_DEFAULT                0x00000000 /* RWI-V */
#define NV_PME_DEBUG_1_MCLK_SEL                                 9:8 /* RWI-F */
#define NV_PME_DEBUG_1_MCLK_SEL_DEFAULT                  0x00000000 /* RWI-V */
#define NV_PME_INTR_0                                    0x00200100 /* RWI4R */
#define NV_PME_INTR_0_IMAGE_NOTIFY                              0:0 /* RWIVF */
#define NV_PME_INTR_0_IMAGE_NOTIFY_NOT_PENDING           0x00000000 /* R-I-V */
#define NV_PME_INTR_0_IMAGE_NOTIFY_PENDING               0x00000001 /* R---V */
#define NV_PME_INTR_0_IMAGE_NOTIFY_RESET                 0x00000001 /* -W--V */
#define NV_PME_INTR_0_VBI_NOTIFY                                4:4 /* RWIVF */
#define NV_PME_INTR_0_VBI_NOTIFY_NOT_PENDING             0x00000000 /* R-I-V */
#define NV_PME_INTR_0_VBI_NOTIFY_PENDING                 0x00000001 /* R---V */
#define NV_PME_INTR_0_VBI_NOTIFY_RESET                   0x00000001 /* -W--V */
#define NV_PME_INTR_0_VID_NOTIFY                                8:8 /* RWIVF */
#define NV_PME_INTR_0_VID_NOTIFY_NOT_PENDING             0x00000000 /* R-I-V */
#define NV_PME_INTR_0_VID_NOTIFY_PENDING                 0x00000001 /* R---V */
#define NV_PME_INTR_0_VID_NOTIFY_RESET                   0x00000001 /* -W--V */
#define NV_PME_INTR_0_AUD_NOTIFY                              12:12 /* RWIVF */
#define NV_PME_INTR_0_AUD_NOTIFY_NOT_PENDING             0x00000000 /* R-I-V */
#define NV_PME_INTR_0_AUD_NOTIFY_PENDING                 0x00000001 /* R---V */
#define NV_PME_INTR_0_AUD_NOTIFY_RESET                   0x00000001 /* -W--V */
#define NV_PME_INTR_0_VMI                                     16:16 /* RWIVF */
#define NV_PME_INTR_0_VMI_NOT_PENDING                    0x00000000 /* R-I-V */
#define NV_PME_INTR_0_VMI_PENDING                        0x00000001 /* R---V */
#define NV_PME_INTR_0_VMI_RESET                          0x00000001 /* -W--V */
#define NV_PME_INTR_EN_0                                 0x00200140 /* RWI4R */
#define NV_PME_INTR_EN_0_IMAGE_NOTIFY                           0:0 /* RWIVF */
#define NV_PME_INTR_EN_0_IMAGE_NOTIFY_DISABLED           0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_IMAGE_NOTIFY_ENABLED            0x00000001 /* RW--V */
#define NV_PME_INTR_EN_0_VBI_NOTIFY                             4:4 /* RWIVF */
#define NV_PME_INTR_EN_0_VBI_NOTIFY_DISABLED             0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_VBI_NOTIFY_ENABLED              0x00000001 /* RW--V */
#define NV_PME_INTR_EN_0_VID_NOTIFY                             8:8 /* RWIVF */
#define NV_PME_INTR_EN_0_VID_NOTIFY_DISABLED             0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_VID_NOTIFY_ENABLED              0x00000001 /* RW--V */
#define NV_PME_INTR_EN_0_AUD_NOTIFY                           12:12 /* RWIVF */
#define NV_PME_INTR_EN_0_AUD_NOTIFY_DISABLED             0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_AUD_NOTIFY_ENABLED              0x00000001 /* RW--V */
#define NV_PME_INTR_EN_0_VMI                                  16:16 /* RWIVF */
#define NV_PME_INTR_EN_0_VMI_DISABLED                    0x00000000 /* RWI-V */
#define NV_PME_INTR_EN_0_VMI_ENABLED                     0x00000001 /* RW--V */
#define NV_PME_CONFIG_0                                  0x00200200 /* RWI4R */
#define NV_PME_CONFIG_0_BUS_MODE                                1:0 /* RWIVF */
#define NV_PME_CONFIG_0_BUS_MODE_DISABLED                0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_BUS_MODE_VMI                     0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_BUS_MODE_CCIR656                 0x00000002 /* RW--V */
#define NV_PME_CONFIG_0_IMAGE                                   4:4 /* RWIVF */
#define NV_PME_CONFIG_0_IMAGE_DISABLED                   0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_IMAGE_ENABLED                    0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_VBI_MODE                                9:8 /* RWIVF */
#define NV_PME_CONFIG_0_VBI_MODE_DISABLED                0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_VBI_MODE_1                       0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_VBI_MODE_2                       0x00000002 /* RW--V */
#define NV_PME_CONFIG_0_VID_CD                                12:12 /* RWIVF */
#define NV_PME_CONFIG_0_VID_CD_DISABLED                  0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_VID_CD_ENABLED                   0x00000001 /* RW--V */
#define NV_PME_CONFIG_0_AUD_CD                                16:16 /* RWIVF */
#define NV_PME_CONFIG_0_AUD_CD_DISABLED                  0x00000000 /* RWI-V */
#define NV_PME_CONFIG_0_AUD_CD_ENABLED                   0x00000001 /* RW--V */
#define NV_PME_CONFIG_1                                  0x00200204 /* RWI4R */
#define NV_PME_CONFIG_1_BUFFS                                   0:0 /* RWIVF */
#define NV_PME_CONFIG_1_BUFFS_PNVM                       0x00000000 /* RWI-V */
#define NV_PME_CONFIG_1_BUFFS_SYS                        0x00000001 /* RW--V */
#define NV_PME_CONFIG_1_HOST                                    4:4 /* RWIVF */
#define NV_PME_CONFIG_1_HOST_PCI                         0x00000000 /* RWI-V */
#define NV_PME_CONFIG_1_HOST_AGP                         0x00000001 /* RW--V */
#define NV_PME_NULL_DATA                                 0x00200208 /* RWI4R */
#define NV_PME_NULL_DATA_COMPARE                                0:0 /* RWIVF */
#define NV_PME_NULL_DATA_COMPARE_DISABLED                0x00000000 /* RWI-V */
#define NV_PME_NULL_DATA_COMPARE_ENABLED                 0x00000001 /* RW--V */
#define NV_PME_NULL_DATA_LINE_DETECT                            4:4 /* RWIVF */
#define NV_PME_NULL_DATA_LINE_DETECT_DISABLED            0x00000000 /* RWI-V */
#define NV_PME_NULL_DATA_LINE_DETECT_ENABLED             0x00000001 /* RW--V */
#define NV_PME_NULL_DATA_BYTE                                 31:24 /* RWXVF */
#define NV_PME_VID_BUFF0_START_SYS                       0x00200300 /* RWI4R */ 
#define NV_PME_VID_BUFF0_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_VID_BUFF1_START_SYS                       0x00200304 /* RWI4R */ 
#define NV_PME_VID_BUFF1_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_VID_BUFF0_START_PNVM                      0x00200308 /* RWI4R */ 
#define NV_PME_VID_BUFF0_START_PNVM_ADDRESS                    23:4 /* RWXUF */
#define NV_PME_VID_BUFF1_START_PNVM                      0x0020030c /* RWI4R */ 
#define NV_PME_VID_BUFF1_START_PNVM_ADDRESS                    23:4 /* RWXUF */
#define NV_PME_VID_BUFF0_LENGTH                          0x00200310 /* RWI4R */ 
#define NV_PME_VID_BUFF0_LENGTH_BITS                          15:12 /* RWXUF */
#define NV_PME_VID_BUFF1_LENGTH                          0x00200314 /* RWI4R */ 
#define NV_PME_VID_BUFF1_LENGTH_BITS                          15:12 /* RWXUF */
#define NV_PME_VID_ME_STATE                              0x00200318 /* RW-4R */
#define NV_PME_VID_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWIVF */
#define NV_PME_VID_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VID_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VID_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
#define NV_PME_VID_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
#define NV_PME_VID_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
#define NV_PME_VID_SU_STATE                              0x0020031c /* RW-4R */
#define NV_PME_VID_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VID_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VID_RM_STATE                              0x00200320 /* RW-4R */
#define NV_PME_VID_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_VID_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VID_RM_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_VID_RM_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_VID_CURRENT                               0x00200324 /* RWI4R */ 
#define NV_PME_VID_CURRENT_POS                                 15:2 /* RWXUF */
#define NV_PME_AUD_BUFF0_START_SYS                       0x00200340 /* RWI4R */ 
#define NV_PME_AUD_BUFF0_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_AUD_BUFF1_START_SYS                       0x00200344 /* RWI4R */ 
#define NV_PME_AUD_BUFF1_START_SYS_ADDRESS                     31:4 /* RWXUF */
#define NV_PME_AUD_BUFF0_START_PNVM                      0x00200348 /* RWI4R */ 
#define NV_PME_AUD_BUFF0_START_PNVM_ADDRESS                    23:4 /* RWXUF */
#define NV_PME_AUD_BUFF1_START_PNVM                      0x0020034c /* RWI4R */ 
#define NV_PME_AUD_BUFF1_START_PNVM_ADDRESS                    23:4 /* RWXUF */
#define NV_PME_AUD_BUFF0_LENGTH                          0x00200350 /* RWI4R */ 
#define NV_PME_AUD_BUFF0_LENGTH_BITS                          12:10 /* RWXUF */
#define NV_PME_AUD_BUFF1_LENGTH                          0x00200354 /* RWI4R */ 
#define NV_PME_AUD_BUFF1_LENGTH_BITS                          12:10 /* RWXUF */
#define NV_PME_AUD_ME_STATE                              0x00200358 /* RW-4R */
#define NV_PME_AUD_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWIVF */
#define NV_PME_AUD_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_AUD_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_AUD_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
#define NV_PME_AUD_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
#define NV_PME_AUD_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
#define NV_PME_AUD_SU_STATE                              0x0020035c /* RW-4R */
#define NV_PME_AUD_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_AUD_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_AUD_RM_STATE                              0x00200360 /* RW-4R */
#define NV_PME_AUD_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_AUD_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_AUD_RM_STATE_BUFF0_INTR_CHAINGAP                 8:8 /* RWXVF */
#define NV_PME_AUD_RM_STATE_BUFF1_INTR_CHAINGAP               12:12 /* RWXVF */
#define NV_PME_AUD_CURRENT                               0x00200364 /* RWI4R */ 
#define NV_PME_AUD_CURRENT_POS                                 12:2 /* RWXUF */
#define NV_PME_VBI_BUFF0_START                           0x00200380 /* RWI4R */ 
#define NV_PME_VBI_BUFF0_START_ADDRESS                         23:4 /* RWXUF */
#define NV_PME_VBI_BUFF1_START                           0x00200384 /* RWI4R */ 
#define NV_PME_VBI_BUFF1_START_ADDRESS                         23:4 /* RWXUF */
#define NV_PME_VBI_BUFF0_PITCH                           0x00200388 /* RWI4R */ 
#define NV_PME_VBI_BUFF0_PITCH_VALUE                           13:4 /* RWXUF */
#define NV_PME_VBI_BUFF1_PITCH                           0x0020038c /* RWI4R */ 
#define NV_PME_VBI_BUFF1_PITCH_VALUE                           13:4 /* RWXUF */
#define NV_PME_VBI_BUFF0_LENGTH                          0x00200390 /* RWI4R */ 
#define NV_PME_VBI_BUFF0_LENGTH_BITS                           19:4 /* RWXUF */
#define NV_PME_VBI_BUFF1_LENGTH                          0x00200394 /* RWI4R */ 
#define NV_PME_VBI_BUFF1_LENGTH_BITS                           19:4 /* RWXUF */
#define NV_PME_VBI_ME_STATE                              0x00200398 /* RW-4R */
#define NV_PME_VBI_ME_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF0_ERROR_CODE                   10:8 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF1_ERROR_CODE                  14:12 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VBI_ME_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VBI_ME_STATE_CURRENT_BUFFER                    24:24 /* RWXVF */
#define NV_PME_VBI_ME_STATE_CURRENT_BUFFER_0             0x00000000 /* RW--V */
#define NV_PME_VBI_ME_STATE_CURRENT_BUFFER_1             0x00000001 /* RW--V */
#define NV_PME_VBI_SU_STATE                              0x0020039c /* RW-4R */
#define NV_PME_VBI_SU_STATE_BUFF0_FIELD                         8:8 /* RWXVF */
#define NV_PME_VBI_SU_STATE_BUFF1_FIELD                       12:12 /* RWXVF */
#define NV_PME_VBI_SU_STATE_BUFF0_IN_USE                      16:16 /* RWXVF */
#define NV_PME_VBI_SU_STATE_BUFF1_IN_USE                      20:20 /* RWXVF */
#define NV_PME_VBI_RM_STATE                              0x002003a0 /* RW-4R */
#define NV_PME_VBI_RM_STATE_BUFF0_INTR_NOTIFY                   0:0 /* RWXVF */
#define NV_PME_VBI_RM_STATE_BUFF1_INTR_NOTIFY                   4:4 /* RWXVF */
#define NV_PME_VBI                                       0x002003a4 /* RWI4R */
#define NV_PME_VBI_START_LINE                                   4:0 /* RWX-F */
#define NV_PME_VBI_NUM_LINES                                  20:16 /* RWX-F */
#define NV_PME_IMAGE_BUFF0_START                         0x00200400 /* RWI4R */ 
#define NV_PME_IMAGE_BUFF0_START_ADDRESS                       23:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF1_START                         0x00200404 /* RWI4R */ 
#define NV_PME_IMAGE_BUFF1_START_ADDRESS                       23:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF0_PITCH                         0x00200408 /* RWI4R */ 
#define NV_PME_IMAGE_BUFF0_PITCH_VALUE                         13:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF1_PITCH                         0x0020040c /* RWI4R */ 
#define NV_PME_IMAGE_BUFF1_PITCH_VALUE                         13:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF0_LENGTH                        0x00200410 /* RWI4R */ 
#define NV_PME_IMAGE_BUFF0_LENGTH_BITS                         19:4 /* RWXUF */
#define NV_PME_IMAGE_BUFF1_LENGTH                        0x00200414 /* RWI4R */ 
#define NV_PME_IMAGE_BUFF1_LENGTH_BITS                         19:4 /* RWXUF */
#define NV_PME_IMAGE_ME_STATE                            0x00200418 /* RW-4R */
#define NV_PME_IMAGE_ME_STATE_BUFF0_INTR_NOTIFY                 0:0 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF1_INTR_NOTIFY                 4:4 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF0_ERROR_CODE                 10:8 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF1_ERROR_CODE                14:12 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF0_IN_USE                    16:16 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_BUFF1_IN_USE                    20:20 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER                  24:24 /* RWXVF */
#define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER_0           0x00000000 /* RW--V */
#define NV_PME_IMAGE_ME_STATE_CURRENT_BUFFER_1           0x00000001 /* RW--V */
#define NV_PME_IMAGE_SU_STATE                            0x0020041c /* RW-4R */
#define NV_PME_IMAGE_SU_STATE_BUFF0_FIELD                       8:8 /* RWXVF */
#define NV_PME_IMAGE_SU_STATE_BUFF1_FIELD                     12:12 /* RWXVF */
#define NV_PME_IMAGE_SU_STATE_BUFF0_IN_USE                    16:16 /* RWXVF */
#define NV_PME_IMAGE_SU_STATE_BUFF1_IN_USE                    20:20 /* RWXVF */
#define NV_PME_IMAGE_RM_STATE                            0x00200420 /* RW-4R */
#define NV_PME_IMAGE_RM_STATE_BUFF0_INTR_NOTIFY                 0:0 /* RWXVF */
#define NV_PME_IMAGE_RM_STATE_BUFF1_INTR_NOTIFY                 4:4 /* RWXVF */
#define NV_PME_IMAGE_BUFF0_SCALE_INCR                    0x00200424 /* RW-4R */
#define NV_PME_IMAGE_BUFF0_SCALE_INCR_Y                       26:16 /* RWXVF */
#define NV_PME_IMAGE_BUFF0_SCALE_INCR_X                        10:0 /* RWXVF */
#define NV_PME_IMAGE_BUFF1_SCALE_INCR                    0x00200428 /* RW-4R */
#define NV_PME_IMAGE_BUFF1_SCALE_INCR_Y                       26:16 /* RWXVF */
#define NV_PME_IMAGE_BUFF1_SCALE_INCR_X                        10:0 /* RWXVF */
#define NV_PME_IMAGE_Y_CROP                              0x0020042c /* RW-4R */
#define NV_PME_IMAGE_Y_CROP_STARTLINE                           8:0 /* RWXVF */
#define NV_PME_FIFO_LINE_START                           0x00200480 /* RW-4R */
#define NV_PME_FIFO_LINE_START_ADDRESS                         20:4 /* RWXVF */
#define NV_PME_FIFO_CURRENT                              0x00200484 /* RW-4R */
#define NV_PME_FIFO_CURRENT_ADDRESS                            20:2 /* RWXVF */
#define NV_PME_VMI_POLL                                  0x00200488 /* R--4R */
#define NV_PME_VMI_POLL_UNCD                                    0:0 /* R-IVF */
#define NV_PME_VMI_POLL_UNCD_NOT_PENDING                 0x00000000 /* R-I-V */
#define NV_PME_VMI_POLL_UNCD_PENDING                     0x00000001 /* R---V */
#define NV_PME_VMI_POLL_VIDCD                                   1:1 /* R-IVF */
#define NV_PME_VMI_POLL_VIDCD_NOT_PENDING                0x00000000 /* R-I-V */
#define NV_PME_VMI_POLL_VIDCD_PENDING                    0x00000001 /* R---V */
#define NV_PME_VMI_POLL_AUDCD                                   2:2 /* R-IVF */
#define NV_PME_VMI_POLL_AUDCD_NOT_PENDING                0x00000000 /* R-I-V */
#define NV_PME_VMI_POLL_AUDCD_PENDING                    0x00000001 /* R---V */
#define NV_PME_VMI_POLL_INT                                     3:3 /* R-IVF */
#define NV_PME_VMI_POLL_INT_NOT_PENDING                  0x00000000 /* R-I-V */
#define NV_PME_VMI_POLL_INT_PENDING                      0x00000001 /* R---V */
#define NV_PME_VMI_POLL_CPURDREC                                4:4 /* R-IVF */
#define NV_PME_VMI_POLL_CPURDREC_NOT_PENDING             0x00000000 /* R-I-V */
#define NV_PME_VMI_POLL_CPURDREC_PENDING                 0x00000001 /* R---V */
#define NV_PME_EXTERNAL(i)                       (0x00200600+(i)*4) /* RW-4A */
#define NV_PME_EXTERNAL_SIZE_1                                  256 /*       */  
#define NV_PME_EXTERNAL_DATA                                    7:0 /* RWXVF */
/* dev_framebuffer.ref */
#define NV_PFB                                0x00100FFF:0x00100000 /* RW--D */
#define NV_PFB_BOOT_0                                    0x00100000 /* RW-4R */
#define NV_PFB_BOOT_0_RAM_AMOUNT                                1:0 /* RW-VF */
#define NV_PFB_BOOT_0_RAM_AMOUNT_32MB                    0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_4MB                     0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_8MB                     0x00000002 /* RW--V */
#define NV_PFB_BOOT_0_RAM_AMOUNT_16MB                    0x00000003 /* RW--V */
#define NV_PFB_BOOT_0_RAM_WIDTH_128                             2:2 /* RW-VF */
#define NV_PFB_BOOT_0_RAM_WIDTH_128_OFF                  0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_WIDTH_128_ON                   0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_TYPE                                  4:3 /* RW-VF */
#define NV_PFB_BOOT_0_RAM_TYPE_256K                      0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_RAM_TYPE_512K_2BANK                0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_RAM_TYPE_512K_4BANK                0x00000002 /* RW--V */

// Added UMA support
#define NV_PFB_BOOT_0_UMA                                       8:8 /* RW-VF */
#define NV_PFB_BOOT_0_UMA_DISABLE                        0x00000000 /* RWI-V */
#define NV_PFB_BOOT_0_UMA_ENABLE                         0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE                                15:12 /* RW-VF */
#define NV_PFB_BOOT_0_UMA_SIZE_DEFAULT                   0x00000007 /* RWI-V */
#define NV_PFB_BOOT_0_UMA_SIZE_2M                        0x00000000 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_4M                        0x00000001 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_6M                        0x00000002 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_8M                        0x00000003 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_10M                       0x00000004 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_12M                       0x00000005 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_14M                       0x00000006 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_16M                       0x00000007 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_18M                       0x00000008 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_20M                       0x00000009 /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_22M                       0x0000000a /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_24M                       0x0000000b /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_26M                       0x0000000c /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_28M                       0x0000000d /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_30M                       0x0000000e /* RW--V */
#define NV_PFB_BOOT_0_UMA_SIZE_32M                       0x0000000f /* RW--V */

// Added NV10/NV11/NV15 support
#define NV_PFB_CSTATUS                                   0x0010020C /* R--4R */
#define NV_PFB_CSTATUS_RAMAMOUNT                              27:20 /* R--VF */
#define NV_PFB_CFG                                       0x00100200 /* RW-4R */
#define NV_PFB_CFG_BUS                                          5:4 /* RWIVF */
#define NV_PFB_CFG_BUS_64                                0x00000000 /* RWI-V */
#define NV_PFB_CFG_BUS_128                               0x00000001 /* RW--V */
#define NV_PFB_CFG_BUS_32                                0x00000002 /* RW--V */

#define NV_PFB_DEBUG_0                                   0x00100080 /* RW-4R */
#define NV_PFB_DEBUG_0_PAGE_MODE                                0:0 /* RWIVF */
#define NV_PFB_DEBUG_0_PAGE_MODE_ENABLED                 0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_PAGE_MODE_DISABLED                0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_REFRESH                                  4:4 /* RWIVF */
#define NV_PFB_DEBUG_0_REFRESH_ENABLED                   0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_REFRESH_DISABLED                  0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_REFRESH_COUNTX64                        13:8 /* RWIVF */
#define NV_PFB_DEBUG_0_REFRESH_COUNTX64_DEFAULT          0x00000010 /* RWI-V */
#define NV_PFB_DEBUG_0_REFRESH_SLOW_CLK                       14:14 /* RWIVF */
#define NV_PFB_DEBUG_0_REFRESH_SLOW_CLK_DISABLED         0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_REFRESH_SLOW_CLK_ENABLED          0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_CASOE                                  20:20 /* RWIVF */
#define NV_PFB_DEBUG_0_CASOE_ENABLED                     0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_CASOE_DISABLED                    0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_CKE_INVERT                             28:28 /* RWIVF */
#define NV_PFB_DEBUG_0_CKE_INVERT_OFF                    0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_CKE_INVERT_ON                     0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_REFINC                                 29:29 /* RWIVF */
#define NV_PFB_DEBUG_0_REFINC_DISABLED                   0x00000000 /* RW--V */
#define NV_PFB_DEBUG_0_REFINC_ENABLED                    0x00000001 /* RWI-V */
#define NV_PFB_DEBUG_0_SAVE_POWER                             30:30 /* RWIVF */
#define NV_PFB_DEBUG_0_SAVE_POWER_ON                     0x00000000 /* RWI-V */
#define NV_PFB_DEBUG_0_SAVE_POWER_OFF                    0x00000001 /* RW--V */
#define NV_PFB_GREEN_0                                   0x001000C0 /* RW-4R */
#define NV_PFB_GREEN_0_LEVEL                                    1:0 /* RWIVF */
#define NV_PFB_GREEN_0_LEVEL_VIDEO_ENABLED               0x00000000 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_VIDEO_DISABLED              0x00000001 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_TIMING_DISABLED             0x00000002 /* RW--V */
#define NV_PFB_GREEN_0_LEVEL_MEMORY_DISABLED             0x00000003 /* RWI-V */
#define NV_PFB_CONFIG_0                                  0x00100200 /* RW-4R */
#define NV_PFB_CONFIG_0_TYPE                                   14:0 /* RWIVF */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_FIXED_8BPP          0x00000120 /* RW--V */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_FIXED_16BPP         0x00000220 /* RW--V */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_FIXED_32BPP         0x00000320 /* RW--V */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_VAR_8BPP            0x00004120 /* RW--V */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_VAR_16BPP           0x00004220 /* RW--V */
#define NV_PFB_CONFIG_0_TYPE_OLD1024_VAR_32BPP           0x00004320 /* RW--V */
#define NV_PFB_CONFIG_0_TYPE_TETRIS                      0x00002000 /* RW--V */
#define NV_PFB_CONFIG_0_TYPE_NOTILING                    0x00001114 /* RWI-V */
#define NV_PFB_CONFIG_0_TETRIS_MODE                           17:15 /* RWI-F */
#define NV_PFB_CONFIG_0_TETRIS_MODE_PASS                 0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_1                    0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_2                    0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_3                    0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_4                    0x00000004 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_5                    0x00000005 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_6                    0x00000006 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_MODE_7                    0x00000007 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_SHIFT                          19:18 /* RWI-F */
#define NV_PFB_CONFIG_0_TETRIS_SHIFT_0                   0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TETRIS_SHIFT_1                   0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TETRIS_SHIFT_2                   0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_BANK_SWAP                             22:20 /* RWI-F */
#define NV_PFB_CONFIG_0_BANK_SWAP_OFF                    0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_BANK_SWAP_1M                     0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_BANK_SWAP_2M                     0x00000005 /* RW--V */
#define NV_PFB_CONFIG_0_BANK_SWAP_4M                     0x00000007 /* RW--V */
#define NV_PFB_CONFIG_0_UNUSED                                23:23 /* RW-VF */
#define NV_PFB_CONFIG_0_SCRAMBLE_EN                           29:29 /* RWIVF */
#define NV_PFB_CONFIG_0_SCRAMBLE_EN_INIT                 0x00000000 /* RW--V */
#define NV_PFB_CONFIG_0_SCRAMBLE_ACTIVE                  0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_PRAMIN_WR                             28:28 /* RWIVF */
#define NV_PFB_CONFIG_0_PRAMIN_WR_INIT                   0x00000000 /* RW--V */
#define NV_PFB_CONFIG_0_PRAMIN_WR_DISABLED               0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_PRAMIN_WR_MASK                        27:24 /* RWIVF */
#define NV_PFB_CONFIG_0_PRAMIN_WR_MASK_INIT              0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_PRAMIN_WR_MASK_CLEAR             0x0000000f /* RWI-V */
#define NV_PFB_CONFIG_1                                  0x00100204 /* RW-4R */
#define NV_PFB_CONFIG_1_CAS_LATENCY                             2:0 /* RWIVF */
#define NV_PFB_CONFIG_1_CAS_LATENCY_3                    0x00000003 /* RWI-V */
#define NV_PFB_CONFIG_1_CAS_LATENCY_2                    0x00000002 /* RW--V */
#define NV_PFB_CONFIG_1_CAS_LATENCY_4                    0x00000004 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_RAS                                 7:4 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_RAS_DEFAULT                  0x00000009 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_RAS_9CYCLES                  0x00000008 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_RAS_8CYCLES                  0x00000007 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_RAS_7CYCLES                  0x00000006 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_PCHG                               10:8 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_PCHG_DEFAULT                 0x00000002 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_PCHG_2CYCLES                 0x00000001 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_LOW                               14:12 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_LOW_DEFAULT                  0x00000006 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_LOW_7CYCLES                  0x00000007 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_LOW_5CYCLES                  0x00000005 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_LOW_4CYCLES                  0x00000004 /* RW--V */
#define NV_PFB_CONFIG_1_MRS_TO_RAS                            18:16 /* RWIUF */
#define NV_PFB_CONFIG_1_MRS_TO_RAS_DEFAULT               0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_MRS_TO_RAS_2CYCLES               0x00000002 /* RW--V */
#define NV_PFB_CONFIG_1_MRS_TO_RAS_0CYCLES               0x00000000 /* RW--V */
#define NV_PFB_CONFIG_1_WRITE_TO_READ                         22:20 /* RWIUF */
#define NV_PFB_CONFIG_1_WRITE_TO_READ_DEFAULT            0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_TO_CAS_M1                         26:24 /* RWIUF */
#define NV_PFB_CONFIG_1_RAS_TO_CAS_M1_DEFAULT            0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_RAS_TO_CAS_M1_2CYCLES            0x00000002 /* RW--V */
#define NV_PFB_CONFIG_1_RAS_TO_CAS_M1_0CYCLES            0x00000000 /* RW--V */
#define NV_PFB_CONFIG_1_READ_TO_WRITE                         30:28 /* RWIUF */
#define NV_PFB_CONFIG_1_READ_TO_WRITE_DEFAULT            0x00000004 /* RWI-V */
#define NV_PFB_CONFIG_1_READ_TO_WRITE_5CYCLES            0x00000005 /* RW--V */
#define NV_PFB_CONFIG_1_READ_TO_WRITE_3CYCLES            0x00000003 /* RW--V */
#define NV_PFB_CONFIG_1_READ_TO_WRITE_2CYCLES            0x00000002 /* RW--V */
#define NV_PFB_CONFIG_1_READ_TO_PCHG                          31:31 /* RWIUF */
#define NV_PFB_CONFIG_1_READ_TO_PCHG_ON                  0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_1_READ_TO_PCHG_OFF                 0x00000000 /* RW--V */
#define NV_PFB_RTL                                       0x00100300 /* RW-4R */
#define NV_PFB_RTL_H                                            0:0 /* RWIUF */
#define NV_PFB_RTL_H_DEFAULT                             0x00000000 /* RWI-V */
#define NV_PFB_RTL_MC                                           1:1 /* RWIUF */
#define NV_PFB_RTL_MC_DEFAULT                            0x00000000 /* RWI-V */
#define NV_PFB_RTL_V                                            2:2 /* RWIUF */
#define NV_PFB_RTL_V_DEFAULT                             0x00000000 /* RWI-V */
#define NV_PFB_RTL_G                                            3:3 /* RWIUF */
#define NV_PFB_RTL_G_DEFAULT                             0x00000000 /* RWI-V */
#define NV_PFB_RTL_GB                                           4:4 /* RWIUF */
#define NV_PFB_RTL_GB_DEFAULT                            0x00000000 /* RWI-V */
#define NV_PFB_SCRAMBLE(i)                     (0x00100400+((i)*4)) /* RW-4A */
#define NV_PFB_SCRAMBLE_SIZE_1                                    8 /*       */
#define NV_PFB_SCRAMBLE_w0                                      4:0 /* RWXUF */
#define NV_PFB_SCRAMBLE_w1                                     12:8 /* RWXUF */
#define NV_PFB_SCRAMBLE_w2                                    20:16 /* RWXUF */
#define NV_PFB_SCRAMBLE_w3                                    28:24 /* RWXUF */
#define NV_PFB_SCRAMBLE_EN                               0x00100420 /* RW-4R */
#define NV_PFB_SCRAMBLE_VALUE_0                          0x03020100 /* RW--V */
#define NV_PFB_SCRAMBLE_VALUE_1                          0x07060504 /* RW--V */
#define NV_PFB_SCRAMBLE_VALUE_2                          0x0b0a0908 /* RW--V */
#define NV_PFB_SCRAMBLE_VALUE_3                          0x0f0e0d0c /* RW--V */
#define NV_PFB_SCRAMBLE_VALUE_4                          0x13121110 /* RW--V */
#define NV_PFB_SCRAMBLE_VALUE_5                          0x17161514 /* RW--V */
#define NV_PFB_SCRAMBLE_VALUE_6                          0x1b1a1918 /* RW--V */
#define NV_PFB_SCRAMBLE_VALUE_7                          0x1f1e1d1c /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION                              5:0 /* RWIVF */
#define NV_PFB_CONFIG_0_RESOLUTION_320_PIXELS            0x0000000a /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_400_PIXELS            0x0000000d /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_480_PIXELS            0x0000000f /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_512_PIXELS            0x00000010 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_640_PIXELS            0x00000014 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_800_PIXELS            0x00000019 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_960_PIXELS            0x0000001e /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1024_PIXELS           0x00000020 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1152_PIXELS           0x00000024 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1280_PIXELS           0x00000028 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_1600_PIXELS           0x00000032 /* RW--V */
#define NV_PFB_CONFIG_0_RESOLUTION_DEFAULT               0x00000014 /* RWI-V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH                             9:8 /* RWIVF */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_8_BITS               0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_16_BITS              0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_32_BITS              0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_PIXEL_DEPTH_DEFAULT              0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING                                12:12 /* RWIVF */
#define NV_PFB_CONFIG_0_TILING_ENABLED                   0x00000000 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DISABLED                  0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG                          23:13 /* RWIVF */
#define NV_PFB_CONFIG_0_TILING_DEBUG_DISABLED            0x00000000 /* RW--V */
#define NV_PFB_CONFIG_0_TILE                                  14:12 /* RWIVF */
#define NV_PFB_CONFIG_0_TILE_OLD1024_FIXED               0x00000000 /* RW--V */
#define NV_PFB_CONFIG_0_TILE_OLD1024_VARIABLE            0x00000004 /* RW--V */
#define NV_PFB_CONFIG_0_TILE_TETRIS_ALLOW                0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILE_TETRIS_REDUNDANT            0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TILE_TETRIS_REDUNDANT2           0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_ON                       13:13 /* RWI-F */
#define NV_PFB_CONFIG_0_TILING_DEBUG_ON_ENABLED          0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_ON_DISABLED         0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TILESIZE                 14:14 /* RWI-F */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TILESIZE_FIXED      0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TILESIZE_VARIABLE   0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE              17:15 /* RWI-F */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_PASS    0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_1       0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_2       0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_3       0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_4       0x00000004 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_5       0x00000005 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_6       0x00000006 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_MODE_7       0x00000007 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT             19:18 /* RWI-F */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT_0      0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT_1      0x00000001 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_TETRIS_SHIFT_2      0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP                20:20 /* RWI-F */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_OFF       0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_ON        0x00000001 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB            22:21 /* RWI-F */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB_1M    0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB_2M    0x00000002 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_BANK_SWAP_MSB_4M    0x00000003 /* RW--V */
#define NV_PFB_CONFIG_0_TILING_DEBUG_UNUSED                   23:23 /* RW--F */
#define NV_PFB_CONFIG_1_SGRAM100                                3:3 /* RWIVF */
#define NV_PFB_CONFIG_1_SGRAM100_ENABLED                 0x00000000 /* RWI-V */
#define NV_PFB_CONFIG_1_SGRAM100_DISABLED                0x00000001 /* RW--V */
#define NV_PFB_DEBUG_0_CKE_ALWAYSON                           29:29 /* RWIVF */
#define NV_PFB_DEBUG_0_CKE_ALWAYSON_OFF                  0x00000000 /* RW--V */
#define NV_PFB_DEBUG_0_CKE_ALWAYSON_ON                   0x00000001 /* RWI-V */
/* dev_framebuffer.ref */
#define NV_PNVM                               0x01FFFFFF:0x01000000 /* RW--M */
#define NV_PNVM_DATA032(i)                       (0x01000000+(i)*4) /* RW-4A */
#define NV_PNVM_DATA032__SIZE_1                              524288 /*       */
#define NV_PNVM_DATA032_VALUE                                  31:0 /* RWXVF */
#define NV_PNVM_DATA024(i)           (0x01000000+((i)/2)*4+((i)%2)) /* RW-3A */
#define NV_PNVM_DATA024__SIZE_1                             1048576 /*       */
#define NV_PNVM_DATA024_VALUE                                  23:0 /* RWXVF */
#define NV_PNVM_DATA016(i)           (0x01000000+((i)/3)*4+((i)%3)) /* RW-2A */
#define NV_PNVM_DATA016__SIZE_1                             1572864 /*       */
#define NV_PNVM_DATA016_VALUE                                  15:0 /* RWXVF */
#define NV_PNVM_DATA008(i)                         (0x01000000+(i)) /* RW-1A */
#define NV_PNVM_DATA008__SIZE_1                             2097152 /*       */
#define NV_PNVM_DATA008_VALUE                                   7:0 /* RWXVF */
/* dev_framebuffer.ref */
#define NV_PRAMIN                             0x007FFFFF:0x00700000 /* RW--M */
#define NV_PRAMIN_DATA032(i)                     (0x00700000+(i)*4) /* RW-4A */
#define NV_PRAMIN_DATA032__SIZE_1                            524288 /*       */
#define NV_PRAMIN_DATA032_VALUE                                31:0 /* RWXVF */
#define NV_PRAMIN_DATA024(i)         (0x00700000+((i)/2)*4+((i)%2)) /* RW-3A */
#define NV_PRAMIN_DATA024__SIZE_1                           1048576 /*       */
#define NV_PRAMIN_DATA024_VALUE                                23:0 /* RWXVF */
#define NV_PRAMIN_DATA016(i)         (0x00700000+((i)/3)*4+((i)%3)) /* RW-2A */
#define NV_PRAMIN_DATA016__SIZE_1                           1572864 /*       */
#define NV_PRAMIN_DATA016_VALUE                                15:0 /* RWXVF */
#define NV_PRAMIN_DATA008(i)                       (0x00700000+(i)) /* RW-1A */
#define NV_PRAMIN_DATA008__SIZE_1                           2097152 /*       */
#define NV_PRAMIN_DATA008_VALUE                                 7:0 /* RWXVF */
/* dev_ram.ref */
#define NV_PRAMIN_CONTEXT_0                   ( 0*32+31):( 0*32+ 0) /*       */
#define NV_PRAMIN_CONTEXT_1                   ( 1*32+31):( 1*32+ 0) /*       */
#define NV_PRAMIN_CONTEXT_2                   ( 2*32+31):( 2*32+ 0) /*       */
#define NV_PRAMIN_CONTEXT_3                   ( 3*32+31):( 3*32+ 0) /*       */
#define NV_PRAMIN_RAMHT_0                     0x00710FFF:0x00710000 /* RW--M */
#define NV_PRAMIN_RAMFC_0                     0x007111FF:0x00711000 /* RW--M */
#define NV_PRAMIN_RAMRO_0                     0x007113FF:0x00711200 /* RW--M */
#define NV_PRAMIN_CTX_0(i)                    (0x00700000 + (i)*16) /* RW--M */
#define NV_PRAMIN_CTX_0__SIZE_1                             0x10000 /*       */
#define NV_PRAMIN_CTX_0_NVCLASS                                11:0 /* RWXUF */
#define NV_PRAMIN_CTX_0_CHROMA_KEY                            12:12 /* RWXUF */
#define NV_PRAMIN_CTX_0_CHROMA_KEY_DISABLE               0x00000000 /* RW--V */
#define NV_PRAMIN_CTX_0_CHROMA_KEY_ENABLE                0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_USER_CLIP                             13:13 /* RWXUF */
#define NV_PRAMIN_CTX_0_USER_CLIP_DISABLE                0x00000000 /* RW--V */
#define NV_PRAMIN_CTX_0_USER_CLIP_ENABLE                 0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_SWIZZLE                               14:14 /* RWXUF */
#define NV_PRAMIN_CTX_0_SWIZZLE_DISABLE                  0x00000000 /* RW--V */
#define NV_PRAMIN_CTX_0_SWIZZLE_ENABLE                   0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG                          17:15 /* RWXUF */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_SRCCOPY_AND         0x00000000 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_ROP_AND             0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_BLEND_AND           0x00000002 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_SRCCOPY             0x00000003 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_SRCCOPY_PRE         0x00000004 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_CONFIG_BLEND_PRE           0x00000005 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_STATUS                          24:24 /* RWXUF */
#define NV_PRAMIN_CTX_0_PATCH_STATUS_INVALID             0x00000000 /* RW--V */
#define NV_PRAMIN_CTX_0_PATCH_STATUS_VALID               0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE                       25:25 /* RWXUF */
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE_INVALID          0x00000000 /* RW--V */
#define NV_PRAMIN_CTX_0_CONTEXT_SURFACE_VALID            0x00000001 /* RW--V */
#define NV_PRAMIN_CTX_1(i)                    (0x00700004 + (i)*16) /* RW--M */
#define NV_PRAMIN_CTX_1__SIZE_1                             0x10000 /*       */
#define NV_PRAMIN_CTX_1_MONO_FORMAT                             7:0 /* RWXUF */
#define NV_PRAMIN_CTX_1_MONO_FORMAT_INVALID                    0x00 /* RWI-V */
#define NV_PRAMIN_CTX_1_MONO_FORMAT_CGA6_M1                    0x01 /* RW--V */
#define NV_PRAMIN_CTX_1_MONO_FORMAT_LE_M1                      0x02 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT                           15:8 /* RWXUF */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_INVALID                   0x00 /* RWI-V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_Y8                     0x01 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X16A8Y8                0x02 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X24Y8                  0x03 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_A1R5G5B5               0x06 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X1R5G5B5               0x07 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X16A1R5G5B5            0x08 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X17R5G5B5              0x09 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_R5G6B5                 0x0A /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_A16R5G6B5              0x0B /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X16R5G6B5              0x0C /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_A8R8G8B8               0x0D /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X8R8G8B8               0x0E /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_Y16                    0x0F /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_A16Y16                 0x10 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_X16Y16                 0x11 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_V8YB8U8YA8             0x12 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_YB8V8YA8U8             0x13 /* RW--V */
#define NV_PRAMIN_CTX_1_COLOR_FORMAT_LE_Y32                    0x14 /* RW--V */
#define NV_PRAMIN_CTX_1_NOTIFY_INSTANCE                       31:16 /* RWXUF */
#define NV_PRAMIN_CTX_1_NOTIFY_INSTANCE_INVALID              0x0000 /* RWI-V */
#define NV_PRAMIN_CTX_2(i)                    (0x00700008 + (i)*16) /* RW--M */
#define NV_PRAMIN_CTX_2__SIZE_1                             0x10000 /*       */
#define NV_PRAMIN_CTX_2_DMA_0_INSTANCE                         15:0 /* RWXUF */
#define NV_PRAMIN_CTX_2_DMA_0_INSTANCE_INVALID               0x0000 /* RWI-V */
#define NV_PRAMIN_CTX_2_DMA_1_INSTANCE                        31:16 /* RWXUF */
#define NV_PRAMIN_CTX_2_DMA_1_INSTANCE_INVALID               0x0000 /* RWI-V */
/* dev_ram.ref */
#define NV_FIFO_DMA_OPCODE                    ( 0*32+31):( 0*32+29) /* RWXUF */
#define NV_FIFO_DMA_OPCODE_METHOD                        0x00000000 /* ----- */
#define NV_FIFO_DMA_OPCODE_JUMP                          0x00000001 /* ----- */
#define NV_FIFO_DMA_METHOD_COUNT              ( 0*32+28):( 0*32+18) /* RWXUF */
#define NV_FIFO_DMA_METHOD_SUBCHANNEL         ( 0*32+15):( 0*32+13) /* RWXUF */
#define NV_FIFO_DMA_METHOD_ADDRESS            ( 0*32+12):( 0*32+ 2) /* RWXUF */
#define NV_FIFO_DMA_DATA                      ( 1*32+31):( 1*32+ 0) /* RWXUF */
#define NV_FIFO_DMA_JUMP_OFFSET                                28:2 /* RWXUF */
/* dev_framebuffer.ref */
#define NV_PDFB                               0x01FFFFFF:0x01000000 /* RW--D */
#define NV_PDFB_DATA032(i)                       (0x01000000+(i)*4) /* RW-4A */
#define NV_PDFB_DATA032__SIZE_1                              524288 /*       */
#define NV_PDFB_DATA032_VALUE                                  31:0 /* RWXVF */
#define NV_PDFB_DATA024(i)           (0x01000000+((i)/2)*4+((i)%2)) /* RW-3A */
#define NV_PDFB_DATA024__SIZE_1                             1048576 /*       */
#define NV_PDFB_DATA024_VALUE                                  23:0 /* RWXVF */
#define NV_PDFB_DATA016(i)           (0x01000000+((i)/3)*4+((i)%3)) /* RW-2A */
#define NV_PDFB_DATA016__SIZE_1                             1572864 /*       */
#define NV_PDFB_DATA016_VALUE                                  15:0 /* RWXVF */
#define NV_PDFB_DATA008(i)                         (0x01000000+(i)) /* RW-1A */
#define NV_PDFB_DATA008__SIZE_1                             2097152 /*       */
#define NV_PDFB_DATA008_VALUE                                   7:0 /* RWXVF */
/* dev_ram.ref */
#define NV_PRAM                               0x00006FFF:0x00006000 /* RW--D */
/* dev_ext_devices.ref */
#define NV_PEXTDEV                            0x00101FFF:0x00101000 /* RW--D */
#define NV_PEXTDEV_BOOT_0                                0x00101000 /* R--4R */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED                       0:0 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED_33MHZ          0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_SPEED_66MHZ          0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR                      1:1 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_NO_BIOS       0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_SUB_VENDOR_BIOS          0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE                        3:2 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_SGRAM_256K      0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_SGRAM_512K_2BANK 0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_SGRAM_512K_4BANK 0x00000002 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_TYPE_1024K_2BANK     0x00000003 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH                       4:4 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH_64             0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_RAM_WIDTH_128            0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE                        5:5 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_PCI             0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_BUS_TYPE_AGP             0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL                         6:6 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_13500K           0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_CRYSTAL_14318180         0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE                          8:7 /* R-XVF */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_SECAM             0x00000000 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_NTSC              0x00000001 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_PAL               0x00000002 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_TVMODE_DISABLED          0x00000003 /* R---V */
#define NV_PEXTDEV_BOOT_0_STRAP_OVERWRITE                     11:11 /* RWIVF */
#define NV_PEXTDEV_BOOT_0_STRAP_OVERWRITE_DISABLED       0x00000000 /* RWI-V */
#define NV_PEXTDEV_BOOT_0_STRAP_OVERWRITE_ENABLED        0x00000001 /* RW--V */
#define NV_PEXTDEV_NEW_BOOT_0                            0x00101000 /* RW-4R */
#define NV_PEXTDEV_NEW_BOOT_0_STRAP_VALUE                       8:0 /* RWIVF */
#define NV_PEXTDEV_NEW_BOOT_0_STRAP_OVERWRITE                 11:11 /* RWIVF */
#define NV_PEXTDEV_NEW_BOOT_0_STRAP_OVERWRITE_DISABLED   0x00000000 /* RWI-V */
#define NV_PEXTDEV_NEW_BOOT_0_STRAP_OVERWRITE_ENABLED    0x00000001 /* RW--V */
/* dev_ext_devices.ref */
#define NV_PDAC                               0x00680FFF:0x00680000 /* RW--D */
#define NV_PDAC_DATA(i)                          (0x00680000+(i)*4) /* RW-4A */
#define NV_PDAC_DATA__SIZE_1                                     16 /*       */
#define NV_PDAC_DATA_VALUE                                      7:0 /* RW-VF */
/* dev_ext_devices.ref */
/* dev_ext_devices.ref */
#define NV_PROM                               0x0030FFFF:0x00300000 /* RW--D */
#define NV_PROM_DATA(i)                            (0x00300000+(i)) /* RW-1A */
#define NV_PROM_DATA__SIZE_1                                  65536 /*       */
#define NV_PROM_DATA_VALUE                                      7:0 /* RW-VF */
/* dev_realmode.ref */
#define NV_PRM                                0x00005FFF:0x00004000 /* RW--D */
#define NV_PRM_INTR_0                                    0x00004100 /* RW-4R */
#define NV_PRM_INTR_0_TRACE_MPU401                              0:0 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_MPU401_NOT_PENDING           0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_MPU401_PENDING               0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_MPU401_RESET                 0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_FM                                  4:4 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_FM_NOT_PENDING               0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_FM_PENDING                   0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_FM_RESET                     0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL                          8:8 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL_NOT_PENDING       0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL_PENDING           0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_DIGITAL_RESET             0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_SB_MIXER                          12:12 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_SB_MIXER_NOT_PENDING         0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_MIXER_PENDING             0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_SB_MIXER_RESET               0x00000001 /* -W--V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW                          16:16 /* RWXVF */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_NOT_PENDING         0x00000000 /* R---V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_PENDING             0x00000001 /* R---V */
#define NV_PRM_INTR_0_TRACE_OVERFLOW_RESET               0x00000001 /* -W--V */
#define NV_PRM_INTR_EN_0                                 0x00004140 /* RW-4R */
#define NV_PRM_INTR_EN_0_TRACE_MPU401                           0:0 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_MPU401_DISABLED           0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_MPU401_ENABLED            0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_FM                               4:4 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_FM_DISABLED               0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_FM_ENABLED                0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL                       8:8 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL_DISABLED       0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_SB_DIGITAL_ENABLED        0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_SB_MIXER                       12:12 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_SB_MIXER_DISABLED         0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_SB_MIXER_ENABLED          0x00000001 /* RW--V */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW                       16:16 /* RWIVF */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW_DISABLED         0x00000000 /* RWI-V */
#define NV_PRM_INTR_EN_0_TRACE_OVERFLOW_ENABLED          0x00000001 /* RW--V */
#define NV_PRM_RAMRM                                     0x00004200 /* RW-4R */
#define NV_PRM_RAMRM_BASE_ADDRESS                             15:12 /* RWXVF */
#define NV_PRM_RAMRM_BASE_ADDRESS_2000                   0x00002000 /* RWI-V */
#define NV_PRM_TRACE                                     0x00004300 /* RW-4R */
#define NV_PRM_TRACE_IO_CAPTURE                                 1:0 /* RWIVF */
#define NV_PRM_TRACE_IO_CAPTURE_DISABLED                 0x00000000 /* RWI-V */
#define NV_PRM_TRACE_IO_CAPTURE_WRITES                   0x00000001 /* RW--V */
#define NV_PRM_TRACE_IO_CAPTURE_READS                    0x00000002 /* RW--V */
#define NV_PRM_TRACE_IO_CAPTURE_READS_WRITES             0x00000003 /* RW--V */
#define NV_PRM_TRACE_IO_WRITE                                   4:4 /* RWXVF */
#define NV_PRM_TRACE_IO_WRITE_NONE                       0x00000000 /* R---V */
#define NV_PRM_TRACE_IO_WRITE_OCCURED                    0x00000001 /* R---V */
#define NV_PRM_TRACE_IO_WRITE_RESET                      0x00000001 /* -W--V */
#define NV_PRM_TRACE_IO_READ                                    5:5 /* RWXVF */
#define NV_PRM_TRACE_IO_READ_NONE                        0x00000000 /* R---V */
#define NV_PRM_TRACE_IO_READ_OCCURED                     0x00000001 /* R---V */
#define NV_PRM_TRACE_IO_READ_RESET                       0x00000001 /* -W--V */
#define NV_PRM_TRACE_INDEX                               0x00004310 /* RW-4R */
#define NV_PRM_TRACE_INDEX_ADDRESS                              9:0 /* RWXUF */
#define NV_PRM_TRACE_INDEX_ADDRESS_0                     0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0                                  0x00004320 /* RW-4R */
#define NV_PRM_IGNORE_0_MPU401                                  1:0 /* RWXVF */
#define NV_PRM_IGNORE_0_MPU401_DISABLED                  0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401_WRITES                    0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401_READS                     0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_MPU401_READS_WRITES              0x00000003 /* RW--V */
#define NV_PRM_IGNORE_0_FM                                      5:4 /* RWXVF */
#define NV_PRM_IGNORE_0_FM_DISABLED                      0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_FM_WRITES                        0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_FM_READS                         0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_FM_READS_WRITES                  0x00000003 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL                              9:8 /* RWXVF */
#define NV_PRM_IGNORE_0_SB_DIGITAL_DISABLED              0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL_WRITES                0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL_READS                 0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_SB_DIGITAL_READS_WRITES          0x00000003 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER                              13:12 /* RWXVF */
#define NV_PRM_IGNORE_0_SB_MIXER_DISABLED                0x00000000 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER_WRITES                  0x00000001 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER_READS                   0x00000002 /* RW--V */
#define NV_PRM_IGNORE_0_SB_MIXER_READS_WRITES            0x00000003 /* RW--V */
/* dev_realmode.ref */
#define NV_PRMIO                              0x00007FFF:0x00007000 /* RW--D */
/* dev_realmode.ref */
/* dev_fifo.ref */
#define NV_USER                               0x00FFFFFF:0x00800000 /* RW--D */
#define NV_USER_OBJECT(i,j)     (0x00800000+(i)*0x10000+(j)*0x2000) /* -W-4A */
#define NV_USER_OBJECT__SIZE_1                                   16 /*       */
#define NV_USER_OBJECT__SIZE_2                                    8 /*       */
#define NV_USER_OBJECT_HANDLE                                  31:0 /* -W-VF */
#define NV_USER_FREE016(i,j)        (0x00800010+(i)*65536+(j)*8192) /* R--2A */
#define NV_USER_FREE016__SIZE_1                                  16 /*       */
#define NV_USER_FREE016__SIZE_2                                   8 /*       */
#define NV_USER_FREE016_COUNT_LO                                1:0 /* C--UF */
#define NV_USER_FREE016_COUNT_LO_0                       0x00000000 /* C---V */
#define NV_USER_FREE016_COUNT                                   9:2 /* R--UF */
#define NV_USER_FREE016_COUNT_HI                              15:10 /* C--UF */
#define NV_USER_FREE016_COUNT_HI_0                       0x00000000 /* C---V */
#define NV_USER_FREE032(i,j)        (0x00800010+(i)*65536+(j)*8192) /* R--4A */
#define NV_USER_FREE032__SIZE_1                                  16 /*       */
#define NV_USER_FREE032__SIZE_2                                   8 /*       */
#define NV_USER_FREE032_COUNT_LO                                1:0 /* C--UF */
#define NV_USER_FREE032_COUNT_LO_0                       0x00000000 /* C---V */
#define NV_USER_FREE032_COUNT                                   9:2 /* R--UF */
#define NV_USER_FREE032_COUNT_HI                              31:10 /* C--UF */
#define NV_USER_FREE032_COUNT_HI_0                       0x00000000 /* C---V */
#define NV_USER_ZERO016(i,j,k) (0x0800012+(i)*65536+(j)*8192+(k)*2) /* R--2A */
#define NV_USER_ZERO016__SIZE_1                                  16 /*       */
#define NV_USER_ZERO016__SIZE_2                                   8 /*       */
#define NV_USER_ZERO016__SIZE_3                                   7 /*       */
#define NV_USER_ZERO016_COUNT                                  15:0 /* C--UF */
#define NV_USER_ZERO016_COUNT_0                          0x00000000 /* C---V */
#define NV_USER_ZERO032(i,j,k) (0x0800014+(i)*65536+(j)*8192+(k)*4) /* R--4A */
#define NV_USER_ZERO032__SIZE_1                                  16 /*       */
#define NV_USER_ZERO032__SIZE_2                                   8 /*       */
#define NV_USER_ZERO032__SIZE_3                                   3 /*       */
#define NV_USER_ZERO032_COUNT                                  31:0 /* C--UF */
#define NV_USER_ZERO032_COUNT_0                          0x00000000 /* C---V */
#define NV_USER_DMA_PUT(i,j)    (0x00800040+(i)*0x10000+(j)*0x2000) /* -W-4A */
#define NV_USER_DMA_PUT_OFFSET                                 28:2 /* -WXUF */
#define NV_USER_DMA_GET(i,j)    (0x00800044+(i)*0x10000+(j)*0x2000) /* R--4A */
#define NV_USER_DMA_GET_OFFSET                                 28:2 /* R-XUF */
/* dev_misc.ref */
#define NV_USER_ADR_CHID                                      22:16 /*       */
#define NV_USER_ADR_SUBCHID                                   15:13 /*       */
#define NV_USER_ADR_METHOD                                     12:0 /*       */
#define NV_USER_DEVICE                                        22:16 /*       */
/* dev_timer.ref */
#define NV_PTIMER                             0x00009FFF:0x00009000 /* RW--D */
#define NV_PTIMER_INTR_0                                 0x00009100 /* RW-4R */
#define NV_PTIMER_INTR_0_ALARM                                  0:0 /* RWXVF */
#define NV_PTIMER_INTR_0_ALARM_NOT_PENDING               0x00000000 /* R---V */
#define NV_PTIMER_INTR_0_ALARM_PENDING                   0x00000001 /* R---V */
#define NV_PTIMER_INTR_0_ALARM_RESET                     0x00000001 /* -W--V */
#define NV_PTIMER_INTR_EN_0                              0x00009140 /* RW-4R */
#define NV_PTIMER_INTR_EN_0_ALARM                               0:0 /* RWIVF */
#define NV_PTIMER_INTR_EN_0_ALARM_DISABLED               0x00000000 /* RWI-V */
#define NV_PTIMER_INTR_EN_0_ALARM_ENABLED                0x00000001 /* RW--V */
#define NV_PTIMER_NUMERATOR                              0x00009200 /* RW-4R */
#define NV_PTIMER_NUMERATOR_VALUE                              15:0 /* RWIUF */
#define NV_PTIMER_NUMERATOR_VALUE_0                      0x00000000 /* RWI-V */
#define NV_PTIMER_DENOMINATOR                            0x00009210 /* RW-4R */
#define NV_PTIMER_DENOMINATOR_VALUE                            15:0 /* RWIUF */
#define NV_PTIMER_DENOMINATOR_VALUE_0                    0x00000000 /* RWI-V */
#define NV_PTIMER_TIME_0                                 0x00009400 /* RW-4R */
#define NV_PTIMER_TIME_0_NSEC                                  31:5 /* RWXUF */
#define NV_PTIMER_TIME_1                                 0x00009410 /* RW-4R */
#define NV_PTIMER_TIME_1_NSEC                                  28:0 /* RWXUF */
#define NV_PTIMER_ALARM_0                                0x00009420 /* RW-4R */
#define NV_PTIMER_ALARM_0_NSEC                                 31:5 /* RWXUF */
/* dev_realmode.ref */
#define NV_TRACE                              0x0000FFFF:0x00000000 /* RW--M */
#define NV_TRACE_DATA                         ( 0*32+ 7):( 0*32+ 0) /* RWXVF */
#define NV_TRACE_ACCESS                       ( 0*32+14):( 0*32+14) /* RWXVF */
#define NV_TRACE_ACCESS_WRITE                            0x00000000 /* RW--V */
#define NV_TRACE_ACCESS_READ                             0x00000001 /* RW--V */
#define NV_TRACE_TYPE                         ( 0*32+15):( 0*32+15) /* RWXVF */
#define NV_TRACE_TYPE_IO                                 0x00000000 /* RW--V */
#define NV_TRACE_TYPE_MEMORY                             0x00000001 /* RW--V */
#define NV_TRACE_ADDRESS                      ( 0*32+31):( 0*32+16) /* RWXUF */
/* dev_ram.ref */
#define NV_RAMHT__SIZE_0                      0x00000FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_1                      0x00001FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_2                      0x00003FFF:0x00000000 /* RW--M */
#define NV_RAMHT__SIZE_3                      0x00007FFF:0x00000000 /* RW--M */
#define NV_RAMHT_HANDLE                       ( 0*32+31):( 0*32+ 0) /* RWXVF */
#define NV_RAMHT_INSTANCE                     ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_RAMHT_ENGINE                       ( 1*32+17):( 1*32+16) /* RWXVF */
#define NV_RAMHT_ENGINE_SW                               0x00000000 /* RW--V */
#define NV_RAMHT_ENGINE_GRAPHICS                         0x00000001 /* RW--V */
#define NV_RAMHT_ENGINE_DVD                              0x00000002 /* RW--V */
#define NV_RAMHT_CHID                         ( 1*32+27):( 1*32+24) /* RWXUF */
#define NV_RAMHT_STATUS                       ( 1*32+31):( 1*32+31) /* RWXUF */
#define NV_RAMHT_STATUS_INVALID                          0x00000000 /* RW--V */
#define NV_RAMHT_STATUS_VALID                            0x00000001 /* RW--V */
/* dev_ram.ref */
#define NV_RAMRO__SIZE_0                      0x000001FF:0x00000000 /* RW--M */
#define NV_RAMRO__SIZE_1                      0x00001FFF:0x00000000 /* RW--M */
#define NV_RAMRO_METHOD                       ( 0*32+12):( 0*32+ 0) /* RWXUF */
#define NV_RAMRO_SUBCHANNEL                   ( 0*32+15):( 0*32+13) /* RWXUF */
#define NV_RAMRO_CHID                         ( 0*32+22):( 0*32+16) /* RWXUF */
#define NV_RAMRO_TYPE                         ( 0*32+23):( 0*32+23) /* RWXVF */
#define NV_RAMRO_TYPE_WRITE                              0x00000000 /* RW--V */
#define NV_RAMRO_TYPE_READ                               0x00000001 /* RW--V */
#define NV_RAMRO_BYTE_ENABLES                 ( 0*32+27):( 0*32+24) /* RWXVF */
#define NV_RAMRO_REASON                       ( 0*32+31):( 0*32+28) /* RWXVF */
#define NV_RAMRO_REASON_ILLEGAL_ACCESS                   0x00000000 /* RW--V */
#define NV_RAMRO_REASON_NO_CACHE_AVAILABLE               0x00000001 /* RW--V */
#define NV_RAMRO_REASON_CACHE_RAN_OUT                    0x00000002 /* RW--V */
#define NV_RAMRO_REASON_FREE_COUNT_OVERRUN               0x00000003 /* RW--V */
#define NV_RAMRO_REASON_CAUGHT_LYING                     0x00000004 /* RW--V */
#define NV_RAMRO_REASON_RESERVED_ACCESS                  0x00000005 /* RW--V */
#define NV_RAMRO_DATA                         ( 1*32+31):( 1*32+ 0) /* RWXVF */
/* dev_ram.ref */
#define NV_RAMFC__SIZE_0                      0x000001FF:0x00000000 /* RW--M */
#define NV_RAMFC_DMA_PUT                      ( 0*32+28):( 0*32+ 2) /* RWXUF */
#define NV_RAMFC_DMA_GET                      ( 1*32+28):( 1*32+ 2) /* RWXUF */
#define NV_RAMFC_DMA_INST                     ( 2*32+15):( 2*32+ 0) /* RWXUF */
#define NV_RAMFC_DMA_METHOD                   ( 3*32+12):( 3*32+ 2) /* RWXUF */
#define NV_RAMFC_DMA_SUBCHANNEL               ( 3*32+15):( 3*32+13) /* RWXUF */
#define NV_RAMFC_DMA_METHOD_COUNT             ( 3*32+28):( 3*32+18) /* RWXUF */
#define NV_RAMFC_DMA_FETCH_TRIG               ( 4*32+ 7):( 4*32+ 3) /* RWXUF */
#define NV_RAMFC_DMA_FETCH_SIZE               ( 4*32+15):( 4*32+13) /* RWXUF */
#define NV_RAMFC_DMA_FETCH_MAX_REQS           ( 4*32+19):( 4*32+16) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_0                 ( 5*32+ 1):( 5*32+ 0) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_1                 ( 5*32+ 5):( 5*32+ 4) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_2                 ( 5*32+ 9):( 5*32+ 8) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_3                 ( 5*32+13):( 5*32+12) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_4                 ( 5*32+17):( 5*32+16) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_5                 ( 5*32+21):( 5*32+20) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_6                 ( 5*32+25):( 5*32+24) /* RWXUF */
#define NV_RAMFC_ENGINE_SUB_7                 ( 5*32+29):( 5*32+28) /* RWXUF */
#define NV_RAMFC_ENGINE_SW                               0x00000000 /* RW--V */
#define NV_RAMFC_ENGINE_GRAPHICS                         0x00000001 /* RW--V */
#define NV_RAMFC_ENGINE_DVD                              0x00000002 /* RW--V */
#define NV_RAMFC_PULL1_ENGINE                 ( 6*32+ 1):( 6*32+ 0) /* RWXUF */
#define NV_RAMFC_PULL1_ENGINE_SW                         0x00000000 /* RW--V */
#define NV_RAMFC_PULL1_ENGINE_GRAPHICS                   0x00000001 /* RW--V */
#define NV_RAMFC_PULL1_ENGINE_DVD                        0x00000002 /* RW--V */
/* dev_ram.ref */
/* dev_ram.ref */
/* dev_ram.ref */
#define NV_RAMDVD_CTX_TABLE                   (63*32+31):( 0*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT(c,s) (((c)*4+((s)/2))*32+((s)%2)*16+15):(((c)*4+((s)/2))*32+((s)%2)*16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_0        ( 0*32+15):( 0*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_1        ( 0*32+31):( 0*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_2        ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_3        ( 1*32+31):( 1*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_4        ( 2*32+15):( 2*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_5        ( 2*32+31):( 2*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_6        ( 3*32+15):( 3*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_0_7        ( 3*32+31):( 3*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_0       (60*32+15):(60*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_1       (60*32+31):(60*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_2       (61*32+15):(61*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_3       (61*32+31):(61*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_4       (62*32+15):(62*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_5       (62*32+31):(62*32+16) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_6       (63*32+15):(63*32+ 0) /* RWXUF */
#define NV_RAMDVD_CTX_TABLE_OBJECT_15_7       (63*32+31):(63*32+16) /* RWXUF */
/* dev_ram.ref */
/* dev_ram.ref */
#define NV_DMA_CLASS                          ( 0*32+11):( 0*32+ 0) /* RWXUF */
#define NV_DMA_PAGE_TABLE                     ( 0*32+12):( 0*32+12) /* RWXVF */
#define NV_DMA_PAGE_TABLE_NOT_PRESENT                    0x00000000 /* RW--V */
#define NV_DMA_PAGE_TABLE_PRESENT                        0x00000001 /* RW--V */
#define NV_DMA_PAGE_ENTRY                     ( 0*32+13):( 0*32+13) /* RWXVF */
#define NV_DMA_PAGE_ENTRY_NOT_LINEAR                     0x00000000 /* RW--V */
#define NV_DMA_PAGE_ENTRY_LINEAR                         0x00000001 /* RW--V */
#define NV_DMA_TARGET_NODE                    ( 0*32+17):( 0*32+16) /* RWXVF */
#define NV_DMA_TARGET_NODE_NVM                           0x00000000 /* RW--V */
#define NV_DMA_TARGET_NODE_PCI                           0x00000002 /* RW--V */
#define NV_DMA_TARGET_NODE_AGP                           0x00000003 /* RW--V */
#define NV_DMA_ADJUST                         ( 0*32+31):( 0*32+20) /* RWXUF */
#define NV_DMA_LIMIT                          ( 1*32+31):( 1*32+ 0) /* RWXUF */
#define NV_DMA_ACCESS                         ( 2*32+ 1):( 2*32+ 1) /* RWXVF */
#define NV_DMA_ACCESS_READ_ONLY                          0x00000000 /* RW--V */
#define NV_DMA_ACCESS_READ_AND_WRITE                     0x00000001 /* RW--V */
#define NV_DMA_FRAME_ADDRESS                  ( 2*32+31):( 2*32+12) /* RWXUF */
/* dev_ram.ref */
#define NV_SUBCHAN_CTX_SWITCH                 ( 0*32+31):( 0*32+ 0) /* RWXUF */
#define NV_SUBCHAN_DMA_INSTANCE               ( 1*32+15):( 1*32+ 0) /* RWXUF */
#define NV_SUBCHAN_NOTIFY_INSTANCE            ( 1*32+31):( 1*32+16) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_INSTANCE            ( 2*32+15):( 2*32+ 0) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_LINEAR              ( 2*32+16):( 2*32+16) /* RWXUF */
#define NV_SUBCHAN_MEMFMT_LINEAR_OUT                     0x00000000 /* RW--V */
#define NV_SUBCHAN_MEMFMT_LINEAR_IN                      0x00000001 /* RW--V */

#endif /* _NV_REG_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nv1_32.h ===
#ifndef NV32_INCLUDED
#define NV32_INCLUDED
/***************************************************************************

  Copyright (C) 1995 NVidia Corporation.

  <nv32.h> defines a 32-bit wide naming convention for the functionality
  of NVidia's Unified Media Architecture (TM).

  Other header files:
     <nvwin32.h>  Contains the function prototypes for the few client
                  functions implemented by the Windows Resource Manager.
     <nvmacros.h> Defines macros that assemble 32-bit quantities for
                  assigning to the hardware from 16-bit coordinates,
                  24-bit RGB triples, etc.  Use of this is optional.
     <nvutypes.h> Declares structures that expose elements smaller than
                  32 bits wide ("NVidia unpacked types").  Use of this
                  is optional.
    Copyright 1995,1996 NVidia Corporation. All Rights Reserved.

 ***************************************************************************/

/***************************************************************************
 *                          Constants                                      *
 ***************************************************************************/

/***** Miscellaneous Sizes *****/
#define NV_GUARANTEED_FIFO_SIZE    0x007C
#define NV_NVIDIA_NAME_LIMIT       0x00000FFF

/***** Notification Styles *****/
/* This simply fills the NvNotification structure */
#define NV_NOTIFY_WONT_SLEEP       0x00000000
/* Other notification styles are operating-system dependent */

/***** Notification Reports *****/
#define NV_BUFFER_GAP              0x00000001

/***** Well-known Objects (besides classes) *****/
#define NV_NULL_OBJECT             0
#define NV_THE_CHIP_ID             0x0FFE
#define NV_ERROR_NOTIFIER          0x0FFD

/***** Errors *****/
#define NV_ERROR_TYPE_CONFLICT           1
#define NV_ERROR_OUT_OF_RANGE            2
#define NV_ERROR_NO_CONNECTION           3
#define NV_ERROR_NO_SUCH_OBJECT          4
#define NV_ERROR_NAME_IN_USE             5
#define NV_ERROR_OUT_OF_RESOURCES        6
#define NV_ERROR_TRANSLATION_VIOLATION   7
#define NV_ERROR_PROTECTION_VIOLATION    8
#define NV_ERROR_BUFFER_BUSY             9
#define NV_ERROR_ILLEGAL_ACCESS          10
#define NV_ERROR_BAD_COLORMAP_FORMAT     11
#define NV_ERROR_BAD_COLOR_FORMAT        12
#define NV_ERROR_BAD_MONOCHROME_FORMAT   13
#define NV_ERROR_BAD_PATTERN_SHAPE       14
#define NV_ERROR_BAD_SUBDIVIDE           15
#define NV_ERROR_NO_CURRENT_POINT        16
#define NV_ERROR_BAD_AUDIO_FORMAT        17
#define NV_ERROR_NO_DMA_TRANSLATION      18
#define NV_ERROR_INCOMPLETE_METHOD       19
#define NV_ERROR_RESERVED_ADDRESS        20
#define NV_ERROR_UNIMPLEMENTED_PATCH     21
#define NV_ERROR_OS_NAME_ERROR           22
#define NV_ERROR_INCOMPLETE_PATCH        23
#define NV_ERROR_BAD_GAME_PORT_FORMAT    24

/***** SetMonochromeFormat values *****/
#define NV_MONO_LE_M1_P32          0x00000000
#define NV_MONO_CGA6_M1_P32        0x00000001

/***** SetColorFormat values ******/
/*
 The format names precisely specify how the bits are arranged
 in a 32-bit write of a color or colors in that format in a
 little-endian system.  For example NV_COLOR_FORMAT_LE_X17R5G5B5
 means the upper 17 bits are ignored, then 5 bits each of
 Red, Green, and Blue intensity:

   3                             1 1
   1                             6 5                             0
  |X X X X X X X X X X X X X X X X X R R R R R G G G G G B B B B B|

 */
/* Unpacked color formats */
#define NV_COLOR_FORMAT_LE_X17R5G5B5       0x00000000
#define NV_COLOR_FORMAT_LE_X16A1R5G5B5     0x00100000
#define NV_COLOR_FORMAT_LE_X24Y8           0x00010000
/* Packed color formats -- more than one value per 32-bit write */
#define NV_COLOR_FORMAT_LE_X1R5G5B5_P2     0x01000000
#define NV_COLOR_FORMAT_LE_A1R5G5B5_P2     0x01100000
#define NV_COLOR_FORMAT_LE_Y8_P4           0x01010000
/* No difference between packed and unpacked */
#define NV_COLOR_FORMAT_LE_X8R8G8B8        0x00000001
#define NV_COLOR_FORMAT_LE_A8R8G8B8        0x00100001
#define NV_COLOR_FORMAT_LE_X2R10G10B10     0x00000002
#define NV_COLOR_FORMAT_LE_A2R10G10B10     0x00100002
#define NV_COLOR_FORMAT_LE_X16A8Y8         0x00110000
#define NV_COLOR_FORMAT_LE_X16Y16          0x00010001
#define NV_COLOR_FORMAT_LE_A16Y16          0x00110001


/***************************************************************************
 *                          Typedefs                                       *
 ***************************************************************************/

/* The initial typedefs declare the C type information for
 * the NV structures later in the file.
 */

/***** The fundamental types *****/
#undef U008
#undef V008
#undef U016
#undef V016
#undef S032
#undef U032
#undef V032

typedef unsigned char    U008;
typedef unsigned char    V008;
typedef unsigned short   U016;
typedef unsigned short   V016; /* "void": more than one value or sign N/A */
typedef long             S032;
typedef unsigned long    U032;
typedef unsigned long    V032; /* "void": more than one value or sign N/A */

/*
 * NV objects return information to applications via notification
 * structures in main memory.
 */
typedef volatile struct {
 struct
  tagNvTimeStamp {
  U032 nanoseconds[2];           /* Nanoseconds since Jan. 1, 1970 */
 } timeStamp;                  /*                                 0000-0007*/
 V032 otherInfo;               /* info reported depends on method 0008-000b*/
 V016 errorCode;               /* Zero means no error             000c-000d*/
 V008 reserved01[0x001];
 V008 inProgress;              /* Application sets, NV zeroes     000f-000f*/
} NvNotification;

/*
 *  The first 256 bytes of each subchannel.
 */
typedef volatile struct {
 V032 object;                  /* current object register         0000-0003*/
 V032 reserved01[0x003];
 U016 free;                    /* free count, only readable reg.  0010-0011*/
 U016 reserved02[0x001];
 U032 reserved03[0x003];
 struct
  tagNvPassword {
  V032 token[4];               /* Any value written here must "unlock" the */
 } password;                   /* chip, matching its ChipToken.   0020-002f*/
 V032 push;                    /* Any write saves channel state   0030-0033*/
 V032 pop;                     /* Any write restores channel state0034-0037*/
 V032 reserved04[0x032];
} NvControl;

/***************************************************************************
 *                           Classes                                       *
 ***************************************************************************/

/*
 * These structures indicate the precise offsets of hardware
 * registers corresponding to the methods of each class.  Since the
 * first 256 bytes of each subchannel is the NvControl registers,
 * the hexadecimal offsets in comments start at 0x100.
 */

/* General and Utility Classes */

/* class NV_CLASS */
#define NV_CLASS  1
typedef volatile struct tagNvClass {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 V032 Create;                  /* 32-bit name of new object       0300-0303*/
 V032 Destroy;                 /* 32-bit name of object           0304-0307*/
 V032 SetNameCtxDma;           /* NV_CONTEXT_DMA_FROM_MEMORY      0308-030b*/
 U032 SetNameStart;            /* offset within ctxdma in bytes   030c-030f*/
 U032 SetNameLength;           /* ASCII O/S name length in bytes  0310-0313*/
 V032 SetEnumerateCtxDma;      /* NV_CONTEXT_DMA_TO_MEMORY        0314-0317*/
 U032 SetEnumerateStart;       /* offset within ctxdma in bytes   0318-031b*/
 U032 SetEnumerateLength;      /* in bytes                        031c-031f*/
 U032 Enumerate;               /* index into instance list        0320-0323*/
 V032 reserved02[0x737];
} NvClass;

/* class NV_CONTEXT_DMA_FROM_MEMORY */
#define NV_CONTEXT_DMA_FROM_MEMORY  2
typedef volatile struct
 tagNvContextDmaFromMemory {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 struct
  tagNvSetDmaFromSpecifier {
  V032 address[2];               /* On X86, address[1] is the selector */
  U032 limit;                    /* size of data region in bytes - 1 */
 } SetDmaSpecifier;            /* memory region NV will read      0300-030b*/
 V032 reserved02[0x73d];
} NvContextDmaFromMemory;

/* class NV_CONTEXT_DMA_TO_MEMORY */
#define NV_CONTEXT_DMA_TO_MEMORY  3
typedef volatile struct
 tagNvContextDmaToMemory {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 struct
  tagNvSetDmaToSpecifier {
  V032 address[2];               /* On X86, address[1] is the selector */
  U032 limit;                    /* size of data region in bytes - 1   */
 } SetDmaSpecifier;            /* memory region NV will write     0300-030b*/
 V032 reserved02[0x73d];
} NvContextDmaToMemory;

/* class NV_TIMER */
#define NV_TIMER  4
typedef volatile struct
 tagNvTimer {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 struct
  tagNvSetAlarmTime {
  U032 nanoseconds[2];
 } SetAlarmTime;               /* nanoseconds since Jan. 1, 1970  0300-0307*/
 V032 SetAlarmNotifyCtxDma;    /* NV_CONTEXT_DMA_TO_MEMORY        0308-030b*/
 V032 SetAlarmNotify;          /* notification style, varies w/OS 030c-030f*/
 V032 reserved02[0x73c];
} NvTimer;

/* class NV_CHIP_ID */
#define NV_CHIP_ID  5
typedef volatile struct
 tagNvChipId {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 V032 SetChipTokenCtxDma;      /* DMA to memory for 64-bit token  0300-0303*/
 V032 reserved02[0x001];
 V032 GetChipToken;            /* any write triggers transfer     0308-030b*/
 V032 reserved03[0x73d];
} NvChipId;

/* class NV_CONTEXT_ORDINAL */
#define NV_CONTEXT_ORDINAL  6
typedef volatile struct
 tagNvContextOrdinal {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 U032 SetOrdinal;              /* zero or positive number         0300-0303*/
 V032 reserved02[0x73f];
} NvContextOrdinal;

/* class NV_NULL_CLASS */
#define NV_NULL_CLASS  48
typedef volatile struct
 tagNvNullClass {
 V032 reserved01[0x7c0];       /* has no methods */
} NvNullClass;

/***** Game Port Classes *****/

/* class NV_PATCHCORD_GAME_PORT */
#define NV_PATCHCORD_GAME_PORT  7
typedef volatile struct
 tagNvPatchcordGamePort {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 V032 Validate;                /* writing any value validates     0300-0303*/
 V032 reserved02[0x73f];
} NvPatchcordGamePort;

/* class NV_GAME_PORT_SOURCE */
#define NV_GAME_PORT_SOURCE  8
typedef volatile struct
 tagNvGamePortSource {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetGamePortOutput;       /* NV_PATCHCORD_GAME_PORT          0200-0203*/
 V032 reserved02[0x77f];
} NvGamePortSource;

/* class NV_GAME_PORT_TO_MEMORY */
#define NV_GAME_PORT_TO_MEMORY  9
typedef volatile struct
 tagNvGamePortToMemory {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetGamePortInput[56];    /* NV_GAME_PORT_PATCHCORD per chan 0200-02df*/
 V032 reserved02[0x008];
 struct
  tagNvSetStartTime {
  U032 nanoseconds[2];           /* nanoseconds since Jan. 1, 1970 */
 } SetStartTime;               /* 0 means immediate transfer      0300-0307*/
 V032 SetSampleRate;           /* U16.16 in Hertz (cycles/sec.)   0308-030b*/
 V032 SetGamePortFormat;       /* only valid is _LE_U016_LINEAR   030c-030f*/
 U032 SetNumberChannels;       /* 1 to 8 for NV game port on PC   0310-0313*/
 V032 reserved03[0x03b];
 V032 SetBufferCtxDma[2];      /* DMA to memory for the buffer(s) 0400-0407*/
 V032 reserved04[0x006];
 V032 SetBufferNotifyCtxDma[2];/* DMA to mem. for NvNotification  0420-0427*/
 V032 reserved05[0x006];
 U032 SetBufferStart[2];       /* offset within ctxdma in bytes   0440-0447*/
 V032 reserved06[0x006];
 U032 SetBufferLength[2];      /* in bytes                        0460-0467*/
 V032 reserved07[0x006];
 V032 SetBufferNotify[2];      /* indicates buff is ready to fill 0480-0487*/
 V032 reserved08[0x6de];
} NvGamePortToMemory;
/* values for SetGamePortFormat() */
#define NV_GAME_PORT_FORMAT_LE_U016_LINEAR 0x00000004

/***** Video Classes *****/

/* class NV_PATCHCORD_VIDEO */
#define NV_PATCHCORD_VIDEO  10
typedef volatile struct
 tagNvPatchcordVideo {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 V032 Validate;                /* writing any value validates     0300-0303*/
 V032 reserved02[0x73f];
} NvPatchcordVideo;

/* class NV_VIDEO_SINK */
#define NV_VIDEO_SINK  11
typedef volatile struct
 tagNvVideoSink {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetVideoInput[56];       /* NV_PATCHCORD_VIDEO              0200-02df*/
// V032 SetVideoInputNotifyCtxDma;/*
 V032 reserved02[0x748];
} NvVideoSink;

/* class NV_VIDEO_SWITCH */
#define NV_VIDEO_SWITCH  12
typedef volatile struct
 tagNvVideoSwitch {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetVideoOutput;          /* NV_PATCHCORD_VIDEO              0200-0203*/
 V032 SetVideoInput[56];       /* P_V's from I2V's or COLORMAPs   0204-02e3*/
 V032 reserved02[0x007];
 V032 SetCtxOrdinal;           /* NV_CONTEXT_ORDINAL              0300-0303*/
 V032 SetSwitchNotifyCtxDma[56];/* NvNotification for each switch 0304-03e3*/
 V032 reserved03[0x008];
 V032 SetSwitchNotify[56];      /* notifies when it switches away 0404-04e3*/
 V032 reserved04[0x6c7];
} NvVideoSwitch;

/* class NV_VIDEO_COLORMAP */
#define NV_VIDEO_COLORMAP  13
typedef volatile struct
 tagNvVideoColormap {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetVideoOutput;          /* NV_PATCHCORD_VIDEO              0200-0203*/
 V032 SetVideoInput;           /* NV_PATCHCORD_VIDEO              0204-0207*/
 V032 reserved02[0x03e];
 V032 SetColormapCtxDma;       /* NV_CONTEXT_DMA_FROM_MEMORY      0300-0303*/
 V032 SetColormapFormat;       /*                                 0304-0307*/
 U032 SetColormapStart;        /* offset in ctxdma in bytes       0308-030b*/
 U032 SetColormapLength;       /* in bytes                        030c-030f*/
 U032 ColormapDirtyStart;      /* start of region to update       0310-0313*/
 U032 ColormapDirtyLength;     /* in bytes, triggers asynch. xfer 0314-0317*/
 V032 reserved03[0x73a];
} NvVideoColormap;
/* values for NV_VIDEO_COLORMAP SetColormapFormat() */
#define NV_COLORMAP_X8R8G8B8       0x00000000
#define NV_COLORMAP_X2R10G10B10    0x00000001


/***** Image Classes *****/

/* class NV_PATCHCORD_IMAGE */
#define NV_PATCHCORD_IMAGE  14
typedef volatile struct
 tagNvPatchcordImage {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 V032 Validate;                /* validate connections downstream 0300-0303*/
 V032 reserved02[0x73f];
} NvPatchcordImage;

/* class NV_IMAGE_TO_VIDEO */
#define NV_IMAGE_TO_VIDEO  15
typedef volatile struct
 tagNvImageToVideo {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE to ROP/blend 0200-0203*/
 V032 SetVideoOutput;          /* NV_PATCHCORD_VIDEO              0204-0207*/
 V032 SetImageInput[56];       /* NV_PATCHCORD_IMAGEs             0208-02e7*/
 V032 reserved02[0x746];
} NvImageToVideo;

/* class NV_IMAGE_STENCIL */
#define NV_IMAGE_STENCIL  16
typedef volatile struct
 tagNvImageStencil {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 SetImageInput[2];        /* P_I, 1 is ImageBlackRectangle   0204-020b*/
 V032 reserved02[0x77d];
} NvImageStencil;

/* class NV_PATCHCORD_BETA */
#define NV_PATCHCORD_BETA  49
typedef volatile struct
 tagNvPatchcordBeta {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 V032 Validate;                /* writing any value validates     0300-0303*/
 V032 reserved02[0x73f];
} NvPatchcordBeta;

/* class NV_IMAGE_BLEND_AND */
#define NV_IMAGE_BLEND_AND  17
typedef volatile struct
 tagNvImageBlendAnd {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 SetBetaInput;            /* NV_PATCHCORD_BETA of Solid/QTMB 0204-0207*/
 V032 SetImageInput[2];        /* P_I, 1 is pattern or I2V        0208-020f*/
 V032 reserved02[0x77c];
} NvImageBlendAnd;

/* class NV_BETA_SOLID */
#define NV_BETA_SOLID  18
typedef volatile struct
 tagNvBetaSolid {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetBetaOutput;           /* NV_PATCHCORD_BETA               0200-0203*/
 V032 reserved02[0x03f];
 V032 SetBeta1d31;             /* S1.31 beta value                0300-0303*/
 V032 reserved03[0x73f];
} NvBetaSolid;

/* class NV_BETA_MAXIMUM */
#define NV_BETA_MAXIMUM  50
typedef volatile struct
 tagNvBetaMaximum {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetBetaOutput;           /* NV_PATCHCORD_BETA to blender    0200-0203*/
 V032 SetBetaInput[2];         /* NV_PATCHCORD_BETA, 1 from solid 0204-020b*/
 V032 reserved02[0x77d];
} NvBetaMaximum;

/* class NV_PATCHCORD_ROP */
#define NV_PATCHCORD_ROP  51
typedef volatile struct
 tagNvPatchcordRop {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 V032 Validate;                /* writing any value validates     0300-0303*/
 V032 reserved02[0x73f];
} NvPatchcordRop;

/* class NV_IMAGE_ROP_AND */
#define NV_IMAGE_ROP_AND  19
typedef volatile struct
 tagNvImageRopAnd {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 SetRopInput;             /* NV_PATCHCORD_ROP                0204-0207*/
 V032 SetImageInput[3];        /* 0 is I2V ImageOut, 2 is pattern 0208-0213*/
 V032 reserved02[0x77b];
} NvImageRopAnd;

/* class NV_ROP_SOLID */
#define NV_ROP_SOLID  20
typedef volatile struct
 tagRopSolid {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetRopOutput;            /* NV_PATCHCORD_ROP                0200-0203*/
 V032 reserved02[0x03f];
 V032 SetRop;                  /* 8-bit index to std. MS Win ROPs 0300-0303*/
 V032 reserved03[0x73f];
} NvRopSolid;

/* class NV_IMAGE_COLOR_KEY */
#define NV_IMAGE_COLOR_KEY  21
typedef volatile struct
 tagNvImageColorKey {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 SetImageInput[2];        /* P_I, 1 from ImageSolidColor     0204-020b*/
 V032 reserved02[0x77d];
} NvImageColorKey;

/* class NV_IMAGE_PLANE_SWITCH */
#define NV_IMAGE_PLANE_SWITCH  22
typedef volatile struct
 tagNvImagePlaneSwitch {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 SetImageInput[3];        /* PI, 1 from NV_IMAGE_SOLID ??    0204-020f*/
 V032 reserved02[0x77c];
} NvImagePlaneSwitch;

/***** Static Image Classes *****/

/* class NV_IMAGE_SOLID */
#define NV_IMAGE_SOLID  23
typedef volatile struct
 tagNvImageSolid {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* must be an unpacked format      0300-0303*/
 V032 SetColor;                /* color to fill the image         0304-0307*/
 V032 reserved03[0x73e];
} NvImageSolid;

/* class NV_IMAGE_PATTERN */
#define NV_IMAGE_PATTERN  24
typedef volatile struct
 tagNvImagePattern {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* must be an unpacked format      0300-0303*/
 V032 SetMonochromeFormat;     /* NV_MONO_{LE_M1_P32, CGA6_M1_P32}0304-0307*/
 V032 SetPatternShape;         /* NV_PATTERN_SHAPE_{8X8,64X1,1X64}0308-030b*/
 V032 reserved03[0x001];
 V032 SetColor0;               /* "background" color where pat=0  0310-0313*/
 V032 SetColor1;               /* "foreground" color where pat=1  0314-0317*/
 struct
  tagNvSetPattern {
  V032 monochrome[2];
 } SetPattern;                 /* 64 bits of pattern data         0318-031f*/
 V032 reserved04[0x738];
} NvImagePattern;
/* values for NV_IMAGE_PATTERN SetPatternShape() */
#define NV_PATTERN_SHAPE_8X8   0x00000000
#define NV_PATTERN_SHAPE_64X1  0x00000001
#define NV_PATTERN_SHAPE_1X64  0x00000002

/* class NV_IMAGE_BLACK_RECTANGLE */
#define NV_IMAGE_BLACK_RECTANGLE  25
typedef volatile struct
 tagNvImageBlackRectangle {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* P_I usually to NV_IMAGE_STENCIL 0200-0203*/
 V032 reserved02[0x03f];
 struct
  tagNvSetRectangle {
  V032 y_x;                      /* S16_S16 in pixels, 0 at top left 00-04*/
  V032 height_width;             /* U16_U16 in pixels                05-07*/
 } SetRectangle;               /* region in image where alpha=1   0300-0307*/
 V032 reserved03[0x73e];
} NvImageBlackRectangle;

/***** Solid Rendering Classes *****/

/* class NV_RENDER_SOLID_POINT */
#define NV_RENDER_SOLID_POINT  26
typedef volatile struct
 tagNvRenderSolidPoint {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* must be an unpacked format      0300-0303*/
 V032 Color;                   /*                                 0304-0307*/
 V032 reserved03[0x03e];
 V032 Point[32];               /* y_x S16_S16 in pixels           0400-047f*/
 struct
  tagNvPoint32 {
  S032 x;                        /* in pixels, 0 at left             00-03*/
  S032 y;                        /* in pixels, 0 at top              04-07*/
 } Point32[16];                /*                                 0480-04ff*/
 struct
  tagNvColorPoint {
  V032 color;                    /*                                  00-03*/
  V032 y_x;                      /* S16_S16 in pixels, 0 at top left 04-07*/
 } ColorPoint[16];             /*                                 0500-057f*/
 V032 reserved04[0x6a0];
} NvRenderSolidPoint;

/* class NV_RENDER_SOLID_LINE */
#define NV_RENDER_SOLID_LINE  27
typedef volatile struct
 tagNvRenderSolidLine {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* must be an unpacked format      0300-0303*/
 V032 Color;                   /*                                 0304-0307*/
 V032 reserved03[0x03e];
 struct
  tagNvLine {
  V032 y0_x0;                    /* S16_S16 in pixels, 0 at top left 00-03*/
  V032 y1_x1;                    /* S16_S16 in pixels, 0 at top left 04-07*/
 } Line[16];                   /*                                 0400-047f*/
 struct
  tagNvLine32 {
  S032 x0;                         /*                                 00-03*/
  S032 y0;                         /*                                 04-07*/
  S032 x1;                         /*                                 08-0b*/
  S032 y1;                         /*                                 0c-0f*/
 } Line32[8];                  /*                                 0480-04ff*/
 V032 PolyLine[32];            /*                                 0500-057f*/
 struct
  tagNvPolyLine32 {
  S032 x;                          /*                                 00-03*/
  S032 y;                          /*                                 04-07*/
 } PolyLine32[16];             /*                                 0580-05ff*/
 struct
  tagNvColorPolyLine {
  V032 color;                      /*                                 00-03*/
  V032 y_x;                      /* S16_S16 in pixels, 0 at top left 04-07*/
 } ColorPolyLine[16];          /*                                 0600-067f*/
 V032 reserved04[0x660];
} NvRenderSolidLine;

/* class NV_RENDER_SOLID_LIN */
#define NV_RENDER_SOLID_LIN  28
typedef volatile struct
 tagNvRenderSolidLin {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* must be an unpacked format      0300-0303*/
 V032 Color;                   /*                                 0304-0307*/
 V032 reserved03[0x03e];
 struct
  tagNvLin {
  V032 y0_x0;                    /* S16_S16 in pixels, 0 at top left 00-03*/
  V032 y1_x1;                    /* S16_S16 in pixels, 0 at top left 04-07*/
 } Lin[16];                    /*                                 0400-047f*/
 struct
  tagNvLin32 {
  S032 x0;                         /*                                 00-03*/
  S032 y0;                         /*                                 04-07*/
  S032 x1;                         /*                                 08-0b*/
  S032 y1;                         /*                                 0c-0f*/
 } Lin32[8];                   /*                                 0480-04ff*/
 V032 PolyLin[32];             /*                                 0500-057f*/
 struct
  tagNvPolyLin32 {
  S032 x;                          /*                                 00-03*/
  S032 y;                          /*                                 04-07*/
 } PolyLin32[16];              /*                                 0580-05ff*/
 struct
  tagNvColorPolyLin {
  V032 color;                      /*                                 00-03*/
  V032 y_x;                      /* S16_S16 in pixels, 0 at top left 04-07*/
 } ColorPolyLin[16];           /*                                 0600-067f*/
 V032 reserved04[0x660];
} NvRenderSolidLin;

/* class NV_RENDER_SOLID_TRIANGLE */
#define NV_RENDER_SOLID_TRIANGLE  29
typedef volatile struct
 tagNvRenderSolidTriangle {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /*                                 0300-0303*/
 V032 Color;                   /*                                 0304-0307*/
 V032 reserved03[0x002];
 struct
  tagNvTriangle {
  V032 y0_x0;                  /* S16_S16 in pixels, 0 = top left 0310-0313*/
  V032 y1_x1;                  /* S16_S16 in pixels, 0 = top left 0314-0317*/
  V032 y2_x2;                  /* S16_S16 in pixels, 0 = top left 0318-031b*/
 } Triangle;
 V032 reserved04[0x001];
 struct
  tagNvTriangle32 {
  S032 x0;                     /*                                 0320-0323*/
  S032 y0;                     /*                                 0324-0327*/
  S032 x1;                     /*                                 0328-032b*/
  S032 y1;                     /*                                 032c-032f*/
  S032 x2;                     /*                                 0330-0333*/
  S032 y2;                     /*                                 0334-0337*/
 } Triangle32;
 V032 reserved05[0x032];
 V032 Trimesh[32];             /*                                 0400-047f*/
 struct
  tagNvTrimesh32 {
  S032 x;                          /*                                 00-03*/
  S032 y;                          /*                                 04-07*/
 } Trimesh32[16];              /*                                 0480-04ff*/
 struct
  tagNvColorTriangle {
  V032 color;                    /*                                  00-03*/
  V032 y0_x0;                    /* S16_S16 in pixels, 0 at top left 04-07*/
  V032 y1_x1;                    /* S16_S16 in pixels, 0 at top left 08-0b*/
  V032 y2_x2;                    /* S16_S16 in pixels, 0 at top left 0c-0f*/
 } ColorTriangle[8];           /* Specify color and coordinates  0500-057f*/
 struct
  tagNvColorTrimesh {
  V032 color;                    /*                                 00-03*/
  V032 y_x;                      /* S16_S16 in pixels, 0 at top left 04-07*/
 } ColorTrimesh[16];           /* Specify color and next coordinate 0580-05ff*/
 V032 reserved06[0x680];
} NvRenderSolidTriangle;

/* class NV_RENDER_SOLID_RECTANGLE */
#define NV_RENDER_SOLID_RECTANGLE  30
typedef volatile struct
 tagNvRenderSolidRectangle {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /*                                 0300-0303*/
 V032 Color;                   /*                                 0304-0307*/
 V032 reserved03[0x03e];
 struct
  tagNvRectangle {
  V032 y_x;                      /* S16_S16 in pixels, 0 at top left 00-03*/
  V032 height_width;             /* U16_U16 in pixels                04-07*/
 } Rectangle[16];              /*                                 0400-047f*/
 V032 reserved04[0x6e0];
} NvRenderSolidRectangle;

/***** Image Rendering Classes *****/

/* class NV_IMAGE_BLIT */
#define NV_IMAGE_BLIT  31
typedef volatile struct
 tagNvImageBlit {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 SetImageInput;           /* NV_PATCHCORD_IMAGE              0204-0207*/
 V032 reserved02[0x03e];
 V032 ControlPointIn;          /* S16_S16 in pixels, u.r. of src  300-0303*/
 V032 ControlPointOut;         /* S16_16 in pixels, u.r. of dest  0304-0307*/
 V032 Size;                    /* U16_U16 in pixels               0308-030b*/
 V032 reserved03[0x73d];
} NvImageBlit;

/* class NV_IMAGE_FROM_MEMORY */
#define NV_IMAGE_FROM_MEMORY  32
typedef volatile struct
 tagNvImageFromMemory {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* cannot be an unpacked format    0300-0303*/
 V032 SetImageCtxDma;          /* NV_CONTEXT_DMA_FROM_MEMORY      0304-0307*/
 V032 Point;                   /* y_x S16_S16 in pixels           0308-030b*/
 V032 Size;                    /* height_width U16_U16 in pixels  030c-030f*/
 S032 ImagePitch;              /* gap in bytes between scan lines 0310-0313*/
 U032 ImageStart;              /* byte offset of top-left pixel   0314-0317*/
 V032 reserved03[0x73a];
} NvImageFromMemory;

/* class NV_IMAGE_FROM_CPU */
#define NV_IMAGE_FROM_CPU  33
typedef volatile struct
 tagNvImageFromCpu {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /*                                 0300-0303*/
 V032 Point;                   /* y_x S16_S16 in pixels           0304-0307*/
 V032 Size;                    /* height_width U16_U16 in pixels  0308-030b*/
 V032 SizeIn;                  /* height_width U16_U16 in pixels  030c-030f*/
 V032 reserved03[0x03c];
 V032 Color[32];               /*                                 0400-047f*/
 V032 reserved04[0x6e0];
} NvImageFromCpu;

/* class NV_IMAGE_MONOCHROME_FROM_CPU */
#define NV_IMAGE_MONOCHROME_FROM_CPU  34
typedef volatile struct
 tagNvImageMonochromeFromCpu {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /*                                 0300-0303*/
 V032 SetMonochromeFormat;     /*                                 0304-0307*/
 V032 Color0;                  /*                                 0308-030b*/
 V032 Color1;                  /*                                 030c-030f*/
 V032 Point;                   /*                                 0310-0313*/
 V032 Size;                    /*                                 0314-0317*/
 V032 SizeIn;                  /*                                 0318-031b*/
 V032 reserved03[0x039];
 V032 Monochrome[32];          /*                                 0400-047f*/
 V032 reserved04[0x6e0];
} NvImageMonochromeFromCpu;

/***** Texture Mapping Classes *****/

/* class NV_RENDER_TEXTURE_BILINEAR */
#define NV_RENDER_TEXTURE_BILINEAR  35
typedef volatile struct
 tagNvRenderTextureBilinear {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /*                                 0300-0303*/
 V032 SubdivideIn;             /*                                 0304-0307*/
 V032 reserved03[0x002];
 struct
  tagNvBiControlPointOut {
  V032 y0_x0;                  /* S16_S16 in pixels, 0 = top left 0310-0313*/
  V032 y1_x1;                  /* S16_S16 in pixels, 0 = top left 0314-0317*/
  V032 y2_x2;                  /* S16_S16 in pixels, 0 = top left 0318-031b*/
  V032 y3_x3;                  /* S16_S16 in pixels, 0 = top left 031c-031f*/
 } ControlPointOut;
 V032 reserved04[0x00c];
 struct
  tagNvBiControlPointOut12d4 {
  V032 y0_x0;                  /* S12.4_S1.d4 in pixels           0350-0353*/
  V032 y1_x1;                  /* S12.4_S12.4 in pixels           0354-0357*/
  V032 y2_x2;                  /* S12.4_S12.4 in pixels           0358-035b*/
  V032 y3_x3;                  /* S12.4_S12.4 in pixels           035c-035f*/
 } ControlPointOut12d4;
 V032 reserved05[0x028];
 V032 Color[32];               /*                                 0400-047f*/
 V032 reserved06[0x6e0];
} NvRenderTextureBilinear;
/*
 * Bit values for NV_RENDER_TEXTURE_BILINEAR and
 * NV_RENDER_TEXTURE_BILINEAR_BETA SubdivideIn()
 */
#define NV_BTM_SUBDIVIDE_HEIGHT_01_23_4    0x00000002
#define NV_BTM_SUBDIVIDE_HEIGHT_01_23_8    0x00000003
#define NV_BTM_SUBDIVIDE_HEIGHT_01_23_16   0x00000004
#define NV_BTM_SUBDIVIDE_HEIGHT_01_23_32   0x00000005
#define NV_BTM_SUBDIVIDE_HEIGHT_01_23_64   0x00000006
#define NV_BTM_SUBDIVIDE_HEIGHT_01_23_128  0x00000007
#define NV_BTM_SUBDIVIDE_HEIGHT_01_23_256  0x00000008
#define NV_BTM_SUBDIVIDE_WIDTH_02_13_4     0x00000020
#define NV_BTM_SUBDIVIDE_WIDTH_02_13_8     0x00000030
#define NV_BTM_SUBDIVIDE_WIDTH_02_13_16    0x00000040
#define NV_BTM_SUBDIVIDE_WIDTH_02_13_32    0x00000050
#define NV_BTM_SUBDIVIDE_WIDTH_02_13_64    0x00000060
#define NV_BTM_SUBDIVIDE_WIDTH_02_13_128   0x00000070
#define NV_BTM_SUBDIVIDE_WIDTH_02_13_256   0x00000080
#define NV_BTM_SUBDIVIDE_EDGE_01_1         0x00000000
#define NV_BTM_SUBDIVIDE_EDGE_01_2         0x00010000
#define NV_BTM_SUBDIVIDE_EDGE_01_4         0x00020000
#define NV_BTM_SUBDIVIDE_EDGE_01_8         0x00030000
#define NV_BTM_SUBDIVIDE_EDGE_01_16        0x00040000
#define NV_BTM_SUBDIVIDE_EDGE_01_32        0x00050000
#define NV_BTM_SUBDIVIDE_EDGE_01_64        0x00060000
#define NV_BTM_SUBDIVIDE_EDGE_01_128       0x00070000
#define NV_BTM_SUBDIVIDE_EDGE_01_256       0x00080000
#define NV_BTM_SUBDIVIDE_EDGE_23_1         0x00000000
#define NV_BTM_SUBDIVIDE_EDGE_23_2         0x00100000
#define NV_BTM_SUBDIVIDE_EDGE_23_4         0x00200000
#define NV_BTM_SUBDIVIDE_EDGE_23_8         0x00300000
#define NV_BTM_SUBDIVIDE_EDGE_23_16        0x00400000
#define NV_BTM_SUBDIVIDE_EDGE_23_32        0x00500000
#define NV_BTM_SUBDIVIDE_EDGE_23_64        0x00600000
#define NV_BTM_SUBDIVIDE_EDGE_23_128       0x00700000
#define NV_BTM_SUBDIVIDE_EDGE_23_256       0x00800000
#define NV_BTM_SUBDIVIDE_EDGE_02_1         0x00000000
#define NV_BTM_SUBDIVIDE_EDGE_02_2         0x01000000
#define NV_BTM_SUBDIVIDE_EDGE_02_4         0x02000000
#define NV_BTM_SUBDIVIDE_EDGE_02_8         0x03000000
#define NV_BTM_SUBDIVIDE_EDGE_02_16        0x04000000
#define NV_BTM_SUBDIVIDE_EDGE_02_32        0x05000000
#define NV_BTM_SUBDIVIDE_EDGE_02_64        0x06000000
#define NV_BTM_SUBDIVIDE_EDGE_02_128       0x07000000
#define NV_BTM_SUBDIVIDE_EDGE_02_256       0x08000000
#define NV_BTM_SUBDIVIDE_EDGE_13_1         0x00000000
#define NV_BTM_SUBDIVIDE_EDGE_13_2         0x10000000
#define NV_BTM_SUBDIVIDE_EDGE_13_4         0x20000000
#define NV_BTM_SUBDIVIDE_EDGE_13_8         0x30000000
#define NV_BTM_SUBDIVIDE_EDGE_13_16        0x40000000
#define NV_BTM_SUBDIVIDE_EDGE_13_32        0x50000000
#define NV_BTM_SUBDIVIDE_EDGE_13_64        0x60000000
#define NV_BTM_SUBDIVIDE_EDGE_13_128       0x70000000
#define NV_BTM_SUBDIVIDE_EDGE_13_256       0x80000000

/* class NV_RENDER_TEXTURE_QUADRATIC */
#define NV_RENDER_TEXTURE_QUADRATIC  36
typedef volatile struct
 tagNvRenderTextureQuadratic {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /*                                 0300-0303*/
 V032 SubdivideIn;             /*                                 0304-0307*/
 V032 reserved03[0x002];
 struct
  tagNvQuadControlPointOut {
  V032 y0_x0;                  /*                                 0310-0313*/
  V032 y1_x1;                  /*                                 0314-0317*/
  V032 y2_x2;                  /*                                 0318-031b*/
  V032 y3_x3;                  /*                                 031c-031f*/
  V032 y4_x4;                  /*                                 0320-0323*/
  V032 y5_x5;                  /*                                 0324-0327*/
  V032 y6_x6;                  /*                                 0328-032b*/
  V032 y7_x7;                  /*                                 032c-032f*/
  V032 y8_x8;                  /*                                 0330-0333*/
 } ControlPointOut;
 V032 reserved04[0x007];
 struct
  tagNvQuadControlPointOut12d4 {
  V032 y0_x0;                  /* S12.4_S12.4                     0350-0353*/
  V032 y1_x1;                  /* S12.4_S12.4                     0354-0357*/
  V032 y2_x2;                  /* S12.4_S12.4                     0358-035b*/
  V032 y3_x3;                  /* S12.4_S12.4                     035c-035f*/
  V032 y4_x4;                  /* S12.4_S12.4                     0360-0363*/
  V032 y5_x5;                  /* S12.4_S12.4                     0364-0367*/
  V032 y6_x6;                  /* S12.4_S12.4                     0368-036b*/
  V032 y7_x7;                  /* S12.4_S12.4                     036c-036f*/
  V032 y8_x8;                  /* S12.4_S12.4                     0370-0373*/
 } ControlPointOut12d4;
 V032 reserved05[0x023];
 V032 Color[32];               /*                                 0400-047f*/
 V032 reserved06[0x6e0];
} NvRenderTextureQuadratic;
/*
 * Bit values for NV_RENDER_TEXTURE_QUADRATIC and
 * NV_RENDER_TEXTURE_QUADRATIC_BETA SubdivideIn()
 */
#define NV_QTM_SUBDIVIDE_HEIGHT_02_68_4    0x00000002
#define NV_QTM_SUBDIVIDE_HEIGHT_02_68_8    0x00000003
#define NV_QTM_SUBDIVIDE_HEIGHT_02_68_16   0x00000004
#define NV_QTM_SUBDIVIDE_HEIGHT_02_68_32   0x00000005
#define NV_QTM_SUBDIVIDE_HEIGHT_02_68_64   0x00000006
#define NV_QTM_SUBDIVIDE_HEIGHT_02_68_128  0x00000007
#define NV_QTM_SUBDIVIDE_HEIGHT_02_68_256  0x00000008
#define NV_QTM_SUBDIVIDE_WIDTH_06_28_4     0x00000020
#define NV_QTM_SUBDIVIDE_WIDTH_06_28_8     0x00000030
#define NV_QTM_SUBDIVIDE_WIDTH_06_28_16    0x00000040
#define NV_QTM_SUBDIVIDE_WIDTH_06_28_32    0x00000050
#define NV_QTM_SUBDIVIDE_WIDTH_06_28_64    0x00000060
#define NV_QTM_SUBDIVIDE_WIDTH_06_28_128   0x00000070
#define NV_QTM_SUBDIVIDE_WIDTH_06_28_256   0x00000080
#define NV_QTM_SUBDIVIDE_EDGE_02_1         0x00000000
#define NV_QTM_SUBDIVIDE_EDGE_02_2         0x00010000
#define NV_QTM_SUBDIVIDE_EDGE_02_4         0x00020000
#define NV_QTM_SUBDIVIDE_EDGE_02_8         0x00030000
#define NV_QTM_SUBDIVIDE_EDGE_02_16        0x00040000
#define NV_QTM_SUBDIVIDE_EDGE_02_32        0x00050000
#define NV_QTM_SUBDIVIDE_EDGE_02_64        0x00060000
#define NV_QTM_SUBDIVIDE_EDGE_02_128       0x00070000
#define NV_QTM_SUBDIVIDE_EDGE_02_256       0x00080000
#define NV_QTM_SUBDIVIDE_EDGE_68_1         0x00000000
#define NV_QTM_SUBDIVIDE_EDGE_68_2         0x00100000
#define NV_QTM_SUBDIVIDE_EDGE_68_4         0x00200000
#define NV_QTM_SUBDIVIDE_EDGE_68_8         0x00300000
#define NV_QTM_SUBDIVIDE_EDGE_68_16        0x00400000
#define NV_QTM_SUBDIVIDE_EDGE_68_32        0x00500000
#define NV_QTM_SUBDIVIDE_EDGE_68_64        0x00600000
#define NV_QTM_SUBDIVIDE_EDGE_68_128       0x00700000
#define NV_QTM_SUBDIVIDE_EDGE_68_256       0x00800000
#define NV_QTM_SUBDIVIDE_EDGE_06_1         0x00000000
#define NV_QTM_SUBDIVIDE_EDGE_06_2         0x01000000
#define NV_QTM_SUBDIVIDE_EDGE_06_4         0x02000000
#define NV_QTM_SUBDIVIDE_EDGE_06_8         0x03000000
#define NV_QTM_SUBDIVIDE_EDGE_06_16        0x04000000
#define NV_QTM_SUBDIVIDE_EDGE_06_32        0x05000000
#define NV_QTM_SUBDIVIDE_EDGE_06_64        0x06000000
#define NV_QTM_SUBDIVIDE_EDGE_06_128       0x07000000
#define NV_QTM_SUBDIVIDE_EDGE_06_256       0x08000000
#define NV_QTM_SUBDIVIDE_EDGE_28_1         0x00000000
#define NV_QTM_SUBDIVIDE_EDGE_28_2         0x10000000
#define NV_QTM_SUBDIVIDE_EDGE_28_4         0x20000000
#define NV_QTM_SUBDIVIDE_EDGE_28_8         0x30000000
#define NV_QTM_SUBDIVIDE_EDGE_28_16        0x40000000
#define NV_QTM_SUBDIVIDE_EDGE_28_32        0x50000000
#define NV_QTM_SUBDIVIDE_EDGE_28_64        0x60000000
#define NV_QTM_SUBDIVIDE_EDGE_28_128       0x70000000
#define NV_QTM_SUBDIVIDE_EDGE_28_256       0x80000000

/* class NV_RENDER_TEXTURE_BILINEAR_BETA */
#define NV_RENDER_TEXTURE_BILINEAR_BETA  52
typedef volatile struct
 tagNvRenderTextureBilinearBeta {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 SetBetaOutput;           /* P_B to BetaMax or BlendAnd      0204-0207*/
 V032 reserved02[0x03e];
 V032 SetColorFormat;          /*                                 0300-0303*/
 V032 SubdivideIn;             /*                                 0304-0307*/
 V032 reserved03[0x002];
 struct
  tagNvBiBControlPointOut {
  V032 y0_x0;                  /*                                 0310-0313*/
  V032 y1_x1;                  /*                                 0314-0317*/
  V032 y2_x2;                  /*                                 0318-031b*/
  V032 y3_x3;                  /*                                 031c-031f*/
 } ControlPointOut;
 V032 reserved04[0x00c];
 struct
  tagNvBiBControlPointOut12d4 {
  V032 y0_x0;                  /* S12.4_S12.4                     0350-0353*/
  V032 y1_x1;                  /* S12.4_S12.4                     0354-0357*/
  V032 y2_x2;                  /* S12.4_S12.4                     0358-035b*/
  V032 y3_x3;                  /* S12.4_S12.4                     035c-035f*/
 } ControlPointOut12d4;
 V032 reserved05[0x008];
 struct
  tagNvBiBControlBetaOut {
  V032 beta1_beta0;            /* S1.15_S1.15 beta at CP1 and CP0 0380-0383*/
  V032 beta3_beta2;            /* S1.15_S1.15 beta at CP3 and CP2 0384-0387*/
 } ControlBetaOut;
 V032 reserved06[0x01e];
 V032 Color[32];               /*                                 0400-047f*/
 V032 reserved07[0x6e0];
} NvRenderTextureBilinearBeta;

/* class NV_RENDER_TEXTURE_QUADRATIC_BETA */
#define NV_RENDER_TEXTURE_QUADRATIC_BETA  53
typedef volatile struct
 tagNvRenderTextureQuadraticBeta {
 V032 SetNotifyCtxDma;         /*                                 0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 SetBetaOutput;           /* P_B to BetaMax or BlendAnd      0204-0207*/
 V032 reserved02[0x03e];
 V032 SetColorFormat;          /* NV_COLOR_FORMAT, must be packed 0300-0303*/
 V032 SubdivideIn;             /* NV_QTM_SUBDIVIDE OR'd values    0304-0307*/
 V032 reserved03[0x002];
 struct
  tagNvQuadBControlPointOut {
  V032 y0_x0;                  /*                                 0310-0313*/
  V032 y1_x1;                  /*                                 0314-0317*/
  V032 y2_x2;                  /*                                 0318-031b*/
  V032 y3_x3;                  /*                                 031c-031f*/
  V032 y4_x4;                  /*                                 0320-0323*/
  V032 y5_x5;                  /*                                 0324-0327*/
  V032 y6_x6;                  /*                                 0328-032b*/
  V032 y7_x7;                  /*                                 032c-032f*/
  V032 y8_x8;                  /*                                 0330-0333*/
 } ControlPointOut;
 V032 reserved04[0x007];
 struct
  tagNvQuadBControlPointOut12d4 {
  V032 y0_x0;                  /* S12.4_S12.4 in pixels           0350-0353*/
  V032 y1_x1;                  /* S12.4_S12.4 in pixels           0354-0357*/
  V032 y2_x2;                  /* S12.4_S12.4 in pixels           0358-035b*/
  V032 y3_x3;                  /* S12.4_S12.4 in pixels           035c-035f*/
  V032 y4_x4;                  /* S12.4_S12.4 in pixels           0360-0363*/
  V032 y5_x5;                  /* S12.4_S12.4 in pixels           0364-0367*/
  V032 y6_x6;                  /* S12.4_S12.4 in pixels           0368-036b*/
  V032 y7_x7;                  /* S12.4_S12.4 in pixels           036c-036f*/
  V032 y8_x8;                  /* S12.4_S12.4 in pixels           0370-0363*/
 } ControlPointOut12d4;
 V032 reserved05[0x003];
 struct
  tagNvQuadBControlBetaOut {
  V032 beta1_beta0;            /* S1.15_S1.15 beta at CP1 and CP0 0380-0383*/
  V032 beta3_beta2;            /* S1.15_S1.15 beta at CP3 and CP2 0384-0387*/
  V032 beta5_beta4;            /* S1.15_S1.15 beta at CP5 and CP4 0388-038b*/
  V032 beta7_beta6;            /* S1.15_S1.15 beta at CP7 and CP6 038c-038f*/
  V032 na_beta8;               /* <don't care>_S1.15 beta at CP9  0390-0393*/
 } ControlBetaOut;
 V032 reserved06[0x01b];
 V032 Color[32];               /* texel colors, must be packed    0400-047f*/
 V032 reserved07[0x6e0];
} NvRenderTextureQuadraticBeta;

/***** Image Readback Class *****/

/* class NV_IMAGE_TO_MEMORY */
#define NV_IMAGE_TO_MEMORY  37
typedef volatile struct
 tagNvImageToMemory {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageInput;           /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* cannot be an unpacked format    0300-0303*/
 V032 SetImageCtxDma;          /* NV_CONTEXT_DMA_TO_MEMORY        0304-0307*/
 V032 Point;                   /* y_x S16_S16 in pixels           0308-030b*/
 V032 Size;                    /* height_width U16_U16 in pixels  030c-030f*/
 S032 ImagePitch;              /* gap in bytes between scan lines 0310-0313*/
 U032 ImageStart;              /* byte offset of top-left pixel   0314-0317*/
 V032 reserved03[0x73a];
} NvImageToMemory;

/***** Audio Classes *****/

/* class NV_AUDIO_TO_MEMORY */
#define NV_AUDIO_TO_MEMORY  38
typedef volatile struct
 tagNvAudioToMemory {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetAudioInput[56];       /* NV_PATCHCORD_AUDIO per channel  0200-02df*/
 V032 reserved02[0x008];
 V032 SetStartCtxTime;         /* NV_CONTEXT_TIME, time 0=immed.  0300-0303*/
 V032 reserved03[0x001];
 V032 SetSampleRate;           /* U16.16 in Hertz (cycles/sec.)   0308-030b*/
 V032 SetAudioFormat;          /*                                 030c-030f*/
 U032 SetNumberChannels;       /* 2=stereo (L sample then R)      0310-0313*/
 V032 reserved04[0x03b];
 V032 SetBufferCtxDma[2];      /* DMA to memory for the buffer(s) 0400-0407*/
 V032 reserved05[0x006];
 V032 SetBufferNotifyCtxDma[2];/* DMA to mem. for NvNotification  0420-0427*/
 V032 reserved06[0x006];
 U032 SetBufferStart[2];       /* offset within ctxdma in bytes   0440-0447*/
 V032 reserved07[0x006];
 U032 SetBufferLength[2];      /* in bytes                        0460-0467*/
 V032 reserved08[0x006];
 V032 SetBufferNotify[2];      /* indicates buff is ready to fill 0480-0487*/
 V032 reserved09[0x6de];
} NvAudioToMemory;

/* values for SetAudioFormat() */
#define NV_AUDIO_FORMAT_LE_S016_LINEAR     0x00000000
#define NV_AUDIO_FORMAT_LE_V008_ULAW       0x00000001
#define NV_AUDIO_FORMAT_LE_V008_ALAW       0x00000002
#define NV_AUDIO_FORMAT_LE_U008_OFFSET     0x00000003

/* class NV_AUDIO_FROM_MEMORY */
#define NV_AUDIO_FROM_MEMORY  39
typedef volatile struct
 tagNvAudioFromMemory {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetAudioOutput[56];      /* NV_PATCHCORD_AUDIO per channel  0200-02df*/
 V032 reserved02[0x008];
 V032 SetStartCtxTime;         /* NV_CONTEXT_TIME, time 0=immed.  0300-0303*/
 V032 reserved03[0x001];
 V032 SetSampleRate;           /* U16.16 in Hertz (cycles/sec.)   0308-030b*/
 V032 SetAudioFormat;          /*                                 030c-030f*/
 U032 SetNumberChannels;       /* 2=stereo (L sample then R)      0310-0313*/
 V032 SetSampleRateAdjust;     /* U16.16 sample rate multiplier   0314-0317*/
 V032 reserved04[0x03a];
 V032 SetBufferCtxDma[2];      /* DMA to memory for the buffer(s) 0400-0407*/
 V032 reserved05[0x006];
 V032 SetBufferNotifyCtxDma[2];/* DMA to mem. for NvNotification  0420-0427*/
 V032 reserved06[0x006];
 U032 SetBufferStart[2];       /* offset within ctxdma in bytes   0440-0447*/
 V032 reserved07[0x006];
 U032 SetBufferLength[2];      /* in bytes                        0460-0467*/
 V032 reserved08[0x006];
 V032 SetBufferNotify[2];      /* indicates buf is ready to be read 0480-0487*/
 V032 reserved09[0x6de];
} NvAudioFromMemory;

/* class NV_AUDIO_NOTE_FROM_MEMORY */
#define NV_AUDIO_NOTE_FROM_MEMORY  40
typedef volatile struct
 tagNvAudioNoteFromMemory {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetAudioOutput[56];      /* NV_PATCHCORD_AUDIO per channel  0200-02df*/
 V032 reserved02[0x008];
 V032 SetStartCtxTime;         /* NV_CONTEXT_TIME, time 0=immed.  0300-0303*/
 V032 reserved03[0x001];
 V032 SetStopLoopingCtxTime;   /* no more looping after this time 0308-030b*/
 V032 reserved04[0x001];
 V032 SetSampleRate;           /* U16.16 in Hertz (cycles/sec.)   0310-0313*/
 V032 SetAudioFormat;          /*                                 0314-0317*/
 U032 SetNumberChannels;       /* 2=stereo (L sample then R)      0318-031b*/
 V032 SetSampleRateAdjust;     /* U16.16 sample rate multiplier   031c-031f*/
 V032 SetPortamento;           /* U16.16 10-90% ramp in millisec. 0320-0323*/
 U032 SetVibratoDepth;         /* U0.32 fraction                  0324-0327*/
 V032 SetVibratoFrequency;     /* U16.16 in Hertz (cycles/sec)    0328-032b*/
 V032 SetVibratoAttackCtxTime; /* NV_CONTEXT_TIME                 032c-032f*/
 V032 SetVibratoAttack;        /* U16.16 10-90% ramp in millisec. 0330-0333*/
 V032 reserved05[0x033];
 V032 SetBufferCtxDma;         /* NV_CONTEXT_DMA_FROM_MEMORY      0400-0403*/
 V032 SetBufferNotifyCtxDma;   /* NV_CONTEXT_DMA_TO_MEMORY        0404-0407*/
 U032 SetBufferStart;          /* offset within ctxdma in bytes   0408-040b*/
 U032 SetBufferLength;         /* in bytes                        040c-040f*/
 U032 SetBufferLoopStart;      /* offset in bytes of loop start   0410-0413*/
 U032 SetBufferLoopLength;     /* in bytes                        0414-0417*/
 V032 SetBufferNotify;         /* indicates buf is ready to read  0418-041b*/
 V032 reserved06[0x6f9];
} NvAudioNoteFromMemory;

/* class NV_AUDIO_MIXER */
#define NV_AUDIO_MIXER  41
typedef volatile struct
 tagNvAudioMixer {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetAudioOutput;          /* NV_PATCHCORD_AUDIO              0200-0203*/
 V032 SetAudioInput[56];       /* NV_PATCHCORD_AUDIO              0204-02e3*/
 V032 reserved02[0x007];
 V032 SetOutputGain;           /* U8.24 "master" volume           0300-0303*/
 V032 SetInputGain[56];        /* U8.24                           0303-03e3*/
 V032 reserved03[0x707];
} NvAudioMixer;

/* class NV_AUDIO_ENVELOPE */
#define NV_AUDIO_ENVELOPE  42
typedef volatile struct
 tagNvAudioEnvelope {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetAudioOutput;          /* NV_PATCHCORD_AUDIO              0200-0203*/
 V032 SetAudioInput;           /* NV_PATCHCORD_AUDIO              0204-0207*/
 V032 reserved02[0x03e];
 V032 SetAttack;               /* U16.16 10-90% ramp in millisec. 0300-0303*/
 V032 SetDecay;                /* U16.16 90-10% decay in msec.    0304-0307*/
 V032 SetSustain;              /* U16.16 90-10% decay in msec.    0308-030b*/
 V032 SetRelease;              /* U16.16 90-10% decay in msec.    030c-030f*/
 V032 SetAttackCtxTime;        /* NV_CONTEXT_TIME                 0310-0313*/
 V032 reserved03[0x001];
 V032 SetReleaseCtxTime;       /* NV_CONTEXT_TIME                 0318-031b*/
 V032 reserved04[0x001];
 U032 SetSustainLevel;         /* U0.32 fraction                  0320-0323*/
 V032 reserved05[0x737];
} NvAudioEnvelope;

/* class NV_AUDIO_TREMOLO */
#define NV_AUDIO_TREMOLO  43
typedef volatile struct
 tagNvAudioTremolo {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetAudioOutput;          /* NV_PATCHCORD_AUDIO              0200-0203*/
 V032 SetAudioInput;           /* NV_PATCHCORD_AUDIO              0204-0207*/
 V032 reserved02[0x03e];
 U032 SetTremoloDepth;         /* U0.32 proportion                0300-0303*/
 V032 SetTremoloFrequency;     /* U16.16 in Hertz (cycles/sec)    0304-0307*/
 V032 SetTremoloAttackCtxTime; /* NV_CONTEXT_TIME                 0308-030b*/
 V032 SetTremoloAttack;        /* U16.16 10-90% ramp in millisec. 030c-030f*/
 V032 reserved03[0x73c];
} NvAudioTremolo;

/* class NV_CONTEXT_TIME */
#define NV_CONTEXT_TIME  44
typedef volatile struct
 tagNvContextTime {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 struct
  tagNvSetTime {
  U032 nanoseconds[2];
 } SetTime;                    /* nanoseconds since Jan. 1, 1970  0300-0307*/
 V032 reserved02[0x73e];
} NvContextTime;

/* class NV_AUDIO_SINK */
#define NV_AUDIO_SINK  45
typedef volatile struct
 tagNvAudioSink {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetAudioInput[56];       /* NV_PATCHCORD_AUDIO              0200-02df*/
 V032 reserved02[0x748];
} NvAudioSink;

/* class NV_AUDIO_SOURCE */
#define NV_AUDIO_SOURCE  46
typedef volatile struct
 tagNvAudioSource {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetAudioOutput;          /* NV_PATCHCHORD_AUDIO             0200-0203*/
 V032 reserved02[0x77f];
} NvAudioSource;

/* class NV_PATCHCORD_AUDIO */
#define NV_PATCHCORD_AUDIO  47
typedef volatile struct
 tagNvPatchcordAudio {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 V032 Validate;                /* writing any value validates     0300-0303*/
 V032 reserved02[0x73f];
} NvPatchcordAudio;

/***************************************************************************
 *                   Subchannels within a Channel                          *
 ***************************************************************************/

/*
 * The first 256 bytes of each subchannel are the NvControl registers.
 * The interpretation of writes to offets in the rest of the
 * subchannel depends on the class of the object loaded in the
 * subchannel, so the rest of the NvSubchannel structure is a union
 * of the class structures.
 */
typedef struct
 tagNvSubchannel {
 NvControl                     control;
 union {
  NvClass                      nvClass;
  NvContextDmaFromMemory       contextDmaFromMemory;
  NvContextDmaToMemory         contextDmaToMemory;
  NvTimer                      timer;
  NvChipId                     chipId;
  NvContextOrdinal             contextOrdinal;
  NvNullClass                  nullClass;
  NvPatchcordGamePort          patchcordGamePort;
  NvGamePortSource             gamePortSource;
  NvGamePortToMemory           gamePortToMemory;
  NvPatchcordVideo             patchcordVideo;
  NvVideoSink                  videoSink;
  NvVideoSwitch                videoSwitch;
  NvVideoColormap              videoColormap;
  NvPatchcordImage             patchcordImage;
  NvImageToVideo               imageToVideo;
  NvImageStencil               imageStencil;
  NvPatchcordBeta              patchcordBeta;
  NvImageBlendAnd              imageBlendAnd;
  NvBetaSolid                  betaSolid;
  NvBetaMaximum                betaMaximum;
  NvPatchcordRop               patchcordRop;
  NvImageRopAnd                imageRopAnd;
  NvRopSolid                   ropSolid;
  NvImageColorKey              imageColorKey;
  NvImagePlaneSwitch           imagePlaneSwitch;
  NvImageSolid                 imageSolid;
  NvImagePattern               imagePattern;
  NvImageBlackRectangle        imageBlackRectangle;
  NvRenderSolidPoint           renderSolidPoint;
  NvRenderSolidLine            renderSolidLine;
  NvRenderSolidLin             renderSolidLin;
  NvRenderSolidTriangle        renderSolidTriangle;
  NvRenderSolidRectangle       renderSolidRectangle;
  NvImageBlit                  imageBlit;
  NvImageFromMemory            imageFromMemory;
  NvImageFromCpu               imageFromCpu;
  NvImageMonochromeFromCpu     imageMonochromeFromCpu;
  NvRenderTextureBilinear      renderTextureBilinear;
  NvRenderTextureQuadratic     renderTextureQuadratic;
  NvRenderTextureBilinearBeta  renderTextureBilinearBeta;
  NvRenderTextureQuadraticBeta renderTextureQuadraticBeta;
  NvImageToMemory              imageToMemory;
  NvAudioToMemory              audioToMemory;
  NvAudioFromMemory            audioFromMemory;
  NvAudioNoteFromMemory        audioNoteFromMemory;
  NvAudioMixer                 audioMixer;
  NvAudioEnvelope              audioEnvelope;
  NvAudioTremolo               audioTremolo;
  NvContextTime                contextTime;
  NvAudioSink                  audioSink;
  NvAudioSource                audioSource;
  NvPatchcordAudio             patchcordAudio;
 };
} NvSubchannel;

/*
 * There are 8 subchannels in one 64KByte channel.
 */
typedef struct
 tagNvChannel {
 NvSubchannel subchannel[8];
} NvChannel;

#endif /* NV32_INCLUDED */
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvalpha.h ===
//******************************************************************************
// 
// Copyright (c) 1992  Microsoft Corporation
// 
// Module Name:
// 
//     nvsubch.h
// 
// Abstract:
// 
//     This module contains the object subchannel definitions 
// 
// Environment:
// 
//     Kernel mode
// 
// Revision History:
// 
// 
//******************************************************************************

//******************************************************************************
// 
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
// 
//******************************************************************************

//******************************************************************************
// Values used to ENABLE and DISABLE color keying
//******************************************************************************

#define NV_ALPHA_1_32         0xff000000
#define NV_ALPHA_1_16         0x00008000
#define NV_ALPHA_1_08         0x0000ff00

#define NV_ALPHA_1_565        0xffff0000
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvdat.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     NVDAT.C
//
// Abstract:
//
//     This module contains all the global data used by the NV driver.
//
// Environment:
//
//     Kernel mode
//
// Revision History:
//
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************


#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"

#include "cmdcnst.h"

#if defined(ALLOC_PRAGMA)
#pragma data_seg("PAGE")
#endif

//
// This structure describes to which ports access is required.
//

VIDEO_ACCESS_RANGE VgaAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,                // 64-bit linear base address
                                                 // of range
    VGA_MAX_IO_PORT - VGA_BASE_IO_PORT + 1, // # of ports
    1,                                           // range is in I/O space
    1,                                           // range should be visible
    0                                            // range should be shareable
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    1,
    0
},
{
    0x000A0000, 0x00000000,
    0x00020000,
    0,
    1,
    0
},

//
// Linear frame buffer access range (uninitialized)
//

{
    0x00000000, 0x00000000,
    0x00000000,
    0,
    1,
    0
}
};




//******************************************************************************
//
// VGA Palette Access Range
//
//******************************************************************************

VIDEO_ACCESS_RANGE VgaPaletteAccessRange   =
    {
    0x3c8, 0x00000000,                           // 64-bit linear base address
                                                 // of range
    2,                                           // # of ports
    1,                                           // range is in I/O space
    1,                                           // range should be visible
    1                                            // range should be shareable
    };




//
// PUBLIC ACCESS RANGE OFFSETS
//
// This table contains the offsets from the start of the base physical address
//

RANGE_OFFSETS RangeOffsets[NV_NUM_RANGES];





//
// Validator Port list.
// This structure describes all the ports that must be hooked out of the V86
// emulator when a DOS app goes to full-screen mode.
// The structure determines to which routine the data read or written to a
// specific port should be sent.
//

//EMULATOR_ACCESS_ENTRY VgaEmulatorAccessEntries[] = {
//
//    //
//    // Traps for byte OUTs.
//    //
//
//    {
//        0x000003b0,                   // range start I/O address
//        0xC,                         // range length
//        Uchar,                        // access size to trap
//        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
//        FALSE,                        // does not support string accesses
//        (PVOID)VgaValidatorUcharEntry // routine to which to trap
//    },
//
//    {
//        0x000003c0,                   // range start I/O address
//        0x20,                         // range length
//        Uchar,                        // access size to trap
//        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS, // types of access to trap
//        FALSE,                        // does not support string accesses
//        (PVOID)VgaValidatorUcharEntry // routine to which to trap
//    },
//
//    //
//    // Traps for word OUTs.
//    //
//
//    {
//        0x000003b0,
//        0x06,
//        Ushort,
//        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
//        FALSE,
//        (PVOID)VgaValidatorUshortEntry
//    },
//
//    {
//        0x000003c0,
//        0x10,
//        Ushort,
//        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
//        FALSE,
//        (PVOID)VgaValidatorUshortEntry
//    },
//
//    //
//    // Traps for dword OUTs.
//    //
//
//    {
//        0x000003b0,
//        0x03,
//        Ulong,
//        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
//        FALSE,
//        (PVOID)VgaValidatorUlongEntry
//    },
//
//    {
//        0x000003c0,
//        0x08,
//        Ulong,
//        EMULATOR_READ_ACCESS | EMULATOR_WRITE_ACCESS,
//        FALSE,
//        (PVOID)VgaValidatorUlongEntry
//    }
//
//};


//
// Used to trap only the sequncer and the misc output registers
//

VIDEO_ACCESS_RANGE MinimalVgaValidatorAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1,
    1,
    1,        // <- enable range IOPM so that it is not trapped.
    0
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    1,
    0
},
{
    VGA_BASE_IO_PORT + MISC_OUTPUT_REG_WRITE_PORT, 0x00000000,
    0x00000001,
    1,
    0,
    0
},
{
    VGA_BASE_IO_PORT + SEQ_ADDRESS_PORT, 0x00000000,
    0x00000002,
    1,
    0,
    0
}
};

//
// Used to trap all registers
//

VIDEO_ACCESS_RANGE FullVgaValidatorAccessRange[] = {
{
    VGA_BASE_IO_PORT, 0x00000000,
    VGA_START_BREAK_PORT - VGA_BASE_IO_PORT + 1,
    1,
    0,        // <- disable range in the IOPM so that it is trapped.
    0
},
{
    VGA_END_BREAK_PORT, 0x00000000,
    VGA_MAX_IO_PORT - VGA_END_BREAK_PORT + 1,
    1,
    0,
    0
}
};

USHORT ET4K_1K_WIDE[] = {
    OW,                             // stretch scans to 1k
    CRTC_ADDRESS_PORT_COLOR,
    0x8013,

    EOD
};

// This is the only value that avoids broken rasters (at least they're not
// broken within the visible portion of the bitmap)
USHORT ET4K_1928_WIDE[] = {
    OW,                             // stretch scans to 1928
    CRTC_ADDRESS_PORT_COLOR,
    0xF113,

    EOD
};

//
// Memory map table -
//
// These memory maps are used to save and restore the physical video buffer.
//

MEMORYMAPS MemoryMaps[] = {

//               length      start
//               ------      -----
    {           0x08000,    0xB0000},   // all mono text modes (7)
    {           0x08000,    0xB8000},   // all color text modes (0, 1, 2, 3,
    {           0x10000,    0xA0000},   // all VGA graphics modes
};

//
// Video mode table - contains information and commands for initializing each
// mode. These entries must correspond with those in VIDEO_MODE_VGA. The first
// entry is commented; the rest follow the same format, but are not so
// heavily commented.
//

VIDEOMODE ModesVGA[] = {

//
// Standard VGA modes.
//

//
// Mode index 0
// Color text mode 3, 720x400, 9x16 char cell (VGA).
//

{
  VIDEO_MODE_COLOR,  // flags that this mode is a color mode, but not graphics
  4,                 // four planes
  1,                 // one bit of colour per plane
  80, 25,            // 80x25 text resolution
  720, 400,          // 720x400 pixels on screen
  160, 0x10000,      // 160 bytes per scan line, 64K of CPU-addressable bitmap
  0, 0,              // only support one frequency, non-interlaced
  NoBanking,         // no banking supported or needed in this mode
  MemMap_CGA,        // the memory mapping is the standard CGA memory mapping
                     //  of 32K at B8000
  FALSE,             // Mode is not available by default
  0x3,               // int 10 modesset value
  NULL,              // scan line stretching option
},

//
// Color text mode 3, 640x350, 8x14 char cell (EGA).
//

{ VIDEO_MODE_COLOR, 4, 1, 80, 25,
  640, 350, 160, 0x10000, 0, 0, NoBanking, MemMap_CGA,
  FALSE,
  0x3,
  NULL,
},

//
// Standard VGA Color graphics mode 0x12, 640x480 16 colors.
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 80, 30,
  640, 480, 80, 0x10000, 60, 0, NoBanking, MemMap_VGA,
  FALSE,
  0x12,
  NULL,
},

//
// Standard VGA Color graphics mode 0x12, 640x480 16 colors. 72Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 80, 30,
  640, 480, 80, 0x10000, 72, 0, NoBanking, MemMap_VGA,
  FALSE,
  0x12,
  NULL,
},

//
// Beginning of SVGA modes
//

//
// 800x600 16 colors.
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 100, 37,
  800, 600, 100, 0x10000, 60, 0, NoBanking, MemMap_VGA,
  FALSE,
  0x29,
  NULL,
},

//
// 800x600 16 colors. 72 hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 100, 37,
  800, 600, 100, 0x10000, 72, 0, NoBanking, MemMap_VGA,
  FALSE,
  0x29,
  NULL,
},

//
// 800x600 16 colors. 56 hz for 8514/a monitors... (fixed freq)
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 100, 37,
  800, 600, 100, 0x10000, 56, 0, NoBanking, MemMap_VGA,
  FALSE,
  0x29,
  NULL,
},

//
// 1024x768 non-interlaced 16 colors.
// Assumes 512K.
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 128, 48,
  1024, 768, 128, 0x20000, 60, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x37,
  NULL,
},

//
// 1024x768 non-interlaced 16 colors. 70hz
// Assumes 512K.
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 128, 48,
  1024, 768, 128, 0x20000, 70, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x37,
  NULL
},

//
// 1024x768 non-interlaced 16 colors. Interlaced (45 hz)
// Assumes 512K.
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 4, 1, 128, 48,
  1024, 768, 128, 0x20000, 45, 1, NormalBanking, MemMap_VGA,
  FALSE,
  0x37,
  NULL
},

//////////////////////////////////////////////////////////////////
// Non Planar Modes
//

//
// 640x480x256
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1K_WIDE
},

//
// 640x480x256 72 Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000, 72, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1K_WIDE
},

//
// 640x480x256 75 Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000, 75, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1K_WIDE
},

//
// 640x480x256 85 Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000, 85, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1K_WIDE
},

//
// 640x480x256 90 Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 480, 1024, 0x80000, 90, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1K_WIDE
},

// NOTE: 800x600 modes need 1Meg until we support broken rasters

//
// 800x600x256  56Hz
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  800, 600, 1024, 0x100000, 56, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x30,
  ET4K_1K_WIDE
},

//
// 800x600x256 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  800, 600, 1024, 0x100000, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x30,
  ET4K_1K_WIDE
},

//
// 800x600x256 72Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  800, 600, 1024, 0x100000, 72, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x30,
  ET4K_1K_WIDE
},

//
// 800x600x256  75Hz
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  800, 600, 1024, 0x100000, 75, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x30,
  ET4K_1K_WIDE
},

//
// 800x600x256  85Hz
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  800, 600, 1024, 0x100000, 85, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x30,
  ET4K_1K_WIDE
},

//
// 800x600x256  90Hz
//
{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  800, 600, 1024, 0x100000, 90, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x30,
  ET4K_1K_WIDE
},

//
// 1024x768x256 45Hz (Interlaced)
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1024, 768, 1024, 0x100000, 45, 1, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x38,
  NULL
},

//
// 1024x768x256 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1024, 768, 1024, 0x100000, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x38,
  NULL
},

//
// 1024x768x256 70Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1024, 768, 1024, 0x100000, 70, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x38,
  NULL
},

//
// 1024x768x256 72Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1024, 768, 1024, 0x100000, 72, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x38,
  NULL
},

//
// 1024x768x256 75Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1024, 768, 1024, 0x100000, 75, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x38,
  NULL
},

//
// 640x480x64K
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 1928, 0x100000, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1928_WIDE
},

//
// 640x480x64K 72Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 1928, 0x100000, 72, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1928_WIDE
},

//
// 640x480x64K 75Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 1928, 0x80000, 75, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1928_WIDE
},

//
// 640x480x64K 90Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 480, 1928, 0x80000, 90, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2E,
  ET4K_1928_WIDE
},

//
// 800x600x64K
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  800, 600, 800*2, 0x100000, 60, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},

//
// 800x600x64K 72Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  800, 600, 800*2, 0x100000, 72, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},

//
// 800x600x64K 75Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  800, 600, 800*2, 0x100000, 75, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},

//
// 800x600x64K 90Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  800, 600, 800*2, 0x100000, 90, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},

//
// 1024x768x64K
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  1024, 768, 1024*2, 0x200000, 60, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x38,
  NULL
},

//
// 1024x768x64K 70Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  1024, 768, 1024*2, 0x200000, 70, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x38,
  NULL
},

//
// 1024x768x64K 75Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  1024, 768, 1024*2, 0x200000, 75, 0, NormalBanking, MemMap_VGA,
  FALSE,
  0x38,
  NULL
},

//
// 1280x1024x256 45Hz (interlaced)
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1280, 1024, 1280, 0x200000, 45, 1, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x3F,
  NULL
},

//
// 1280x1024 8bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1280, 1024, 1280, 0x200000, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x3F,
  NULL
},

//
// 1280x1024 8bpp 70Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1280, 1024, 1280, 0x200000, 70, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x3F,
  NULL
},

//
// 1280x1024 8bpp 75Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  1280, 1024, 1280, 0x200000, 75, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x3F,
  NULL
},

//
// 640x480 24bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 640*3, 640*480*3, 60, 0, MemMgrBanking, MemMap_VGA,
  FALSE,
  0x2E,
  NULL
},

//
// 640x480 24bpp 75Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 640*3, 640*480*3, 75, 0, MemMgrBanking, MemMap_VGA,
  FALSE,
  0x2E,
  NULL
},

//
// 640x480 24bpp 90Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 480, 640*3, 640*480*3, 90, 0, MemMgrBanking, MemMap_VGA,
  FALSE,
  0x2E,
  NULL
},

//
// 800x600 24bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  800, 600, 800*3, 800*600*3, 60, 0, MemMgrBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},

//
// 800x600 24bpp 75Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  800, 600, 800*3, 800*600*3, 75, 0, MemMgrBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},

//
// 800x600 24bpp 90Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  800, 600, 800*3, 800*600*3, 90, 0, MemMgrBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},

#if 0
//
// 1024x768 24bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  1024, 768, 1024*3, 1024*768*3, 60, 0, MemMgrBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},

//
// 1024x768 24bpp 75Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  1024, 768, 1024*3, 1024*768*3, 75, 0, MemMgrBanking, MemMap_VGA,
  FALSE,
  0x30,
  NULL
},
#endif

//////////////////////////////////////////////////////////////////////
// DirectDraw modes
//

//
// 320x200 8bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  320, 200, 320, 320*200, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x13,
  NULL
},

//
// 320x200 16bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  320, 200, 320*2, 320*200*2, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x13,
  NULL
},

//
// 320x200 24bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  320, 200, 320*3, 320*200*3, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x13,
  NULL
},

//
// 320x240 8bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  320, 240, 320, 320*240, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x1e,
  NULL
},

//
// 320x240 16bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  320, 240, 320*2, 320*240*2, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x1e,
  NULL
},

//
// 320x240 24bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  320, 240, 320*3, 320*240*3, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x1e,
  NULL
},

//
// 512x384 8bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  512, 384, 512, 512*384, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x1f,
  NULL
},

//
// 512x384 16bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  512, 384, 512*2, 512*384*2, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x1f,
  NULL
},

//
// 512x384 24bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  512, 384, 512*3, 512*384*3, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x1f,
  NULL
},

//
// 640x400 8bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 8, 80, 30,
  640, 400, 640, 640*400, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2f,
  NULL
},

//
// 640x400 16bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 16, 80, 30,
  640, 400, 640*2, 640*400*2, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2f,
  NULL
},

//
// 640x400 24bpp 60Hz
//

{ VIDEO_MODE_COLOR+VIDEO_MODE_GRAPHICS, 1, 24, 80, 30,
  640, 400, 640*3, 640*400*3, 60, 0, PlanarHCBanking, MemMap_VGA,
  FALSE,
  0x2f,
  NULL
},

};

// TESTING VL  For now, just bring up 640x480 16bpp resolution
//
// ULONG NumVideoModes = sizeof(ModesVGA) / sizeof(VIDEOMODE);
//ULONG NumVideoModes = 1;

ULONG NumVideoModes = NUM_RESOLUTIONS * NUM_REFRESHES * NUM_DEPTHS;




//
//
// Data used to set the Graphics and Sequence Controllers to put the
// VGA into a planar state at A0000 for 64K, with plane 2 enabled for
// reads and writes, so that a font can be loaded, and to disable that mode.
//

// Settings to enable planar mode with plane 2 enabled.
//

USHORT EnableA000Data[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    1,
    0x0100,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0204,     // Read Map = plane 2
    0x0005, // Graphics Mode = read mode 0, write mode 0
    0x0406, // Graphics Miscellaneous register = A0000 for 64K, not odd/even,
            //  graphics mode
    OWM,
    SEQ_ADDRESS_PORT,
    3,
    0x0402, // Map Mask = write to plane 2 only
    0x0404, // Memory Mode = not odd/even, not full memory, graphics mode
    0x0300,  // end sync reset
    EOD
};

//
// Settings to disable the font-loading planar mode.
//

USHORT DisableA000Color[] = {
    OWM,
    SEQ_ADDRESS_PORT,
    1,
    0x0100,

    OWM,
    GRAPH_ADDRESS_PORT,
    3,
    0x0004, 0x1005, 0x0E06,

    OWM,
    SEQ_ADDRESS_PORT,
    3,
    0x0302, 0x0204, 0x0300,  // end sync reset
    EOD

};

#if defined(ALLOC_PRAGMA)
#pragma data_seg()
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvapi.h ===
// NV API definitions
#ifdef __cplusplus
extern "C" {
#endif // __cplusplus
typedef HANDLE NVDESCRIPTOR;
#define NV_DEVICE_NAME_LENGTH_MAX 127
#define NVARCH_INVALID_NVDESCRIPTOR 0
#define NVARCH_INVALID_CLIENT_HANDLE 0

// the following is used to open the RM -- this will go away when RM is in MP
#define NVAPI_IOCTL_OPEN    NV_IOCTL_CODE(0x0100)
#define NVAPI_IOCTL_CLOSE   NV_IOCTL_CODE(0x0101)
HANDLE  __cdecl NvOpen          (HANDLE);
VOID    __cdecl NvClose         (HANDLE);

// control codes
ULONG __cdecl NvAllocRoot       (HANDLE, ULONG, ULONG*);
ULONG __cdecl NvAllocDevice     (HANDLE, ULONG, ULONG, ULONG, PUCHAR);
ULONG __cdecl NvAllocContextDma (HANDLE, ULONG, ULONG, ULONG, ULONG, PVOID, ULONG);
ULONG __cdecl NvAllocChannelPio (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, PVOID*, ULONG);
ULONG __cdecl NvAllocChannelDma (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, ULONG, PVOID*);
ULONG __cdecl NvAllocEvent      (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, 
#ifdef _WIN64
                                 PVOID);
#else
                                 ULONG);
#endif
ULONG __cdecl NvAllocMemory     (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG, PVOID*, ULONG*);
ULONG __cdecl NvAllocObject     (HANDLE, ULONG, ULONG, ULONG, ULONG);
ULONG __cdecl NvAlloc           (HANDLE, ULONG, ULONG, ULONG, ULONG, PVOID);
ULONG __cdecl NvFree            (HANDLE, ULONG, ULONG, ULONG);
ULONG __cdecl NvDmaFlowControl  (HANDLE, ULONG, ULONG, ULONG, ULONG);
//ULONG     NvDmaPushMutexState (HANDLE, DWORD);
ULONG __cdecl NvArchHeap        (HANDLE, PVOID);
ULONG __cdecl NvConfigVersion   (HANDLE, ULONG, ULONG, ULONG*);
ULONG __cdecl NvConfigGet       (HANDLE, ULONG, ULONG, ULONG, ULONG*);
ULONG __cdecl NvConfigSet       (HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG*);
ULONG __cdecl NvConfigGetEx     (HANDLE, ULONG, ULONG, ULONG, PVOID, ULONG);
ULONG __cdecl NvConfigSetEx     (HANDLE, ULONG, ULONG, ULONG, PVOID, ULONG);
ULONG __cdecl NvConfigUpdate    (HANDLE, ULONG, ULONG, ULONG);
ULONG __cdecl NvGetDmaPushInfo  (HANDLE, ULONG, ULONG, ULONG, ULONG,ULONG);
ULONG         NvRmDebugControl  (HANDLE, ULONG, ULONG, PVOID);
ULONG __cdecl NvDirectMethodCall(HANDLE, ULONG, ULONG, ULONG, ULONG, ULONG);

#ifdef __cplusplus
}
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvntddctl.h ===
// display driver - to - miniport IOCTL's

// device type and base control code
#define FILE_DEVICE_NVRM 	0x00008000
#define NVRM_IOCTL_INDEX 	0x00000800
#define NV_IOCTL_CODE(f)		  	\
	CTL_CODE(                   	\
		FILE_DEVICE_NVRM+(f),   	\
		NVRM_IOCTL_INDEX,     		\
		METHOD_BUFFERED,        	\
		FILE_ANY_ACCESS         	\
	)

//
#define NVDD_IOCTL_CLOSE_RESOURCE_MANAGER	NV_IOCTL_CODE(0x0FFC)
#define NVDD_IOCTL_OPEN_RESOURCE_MANAGER	NV_IOCTL_CODE(0x0FFD)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvfloat.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     nvFloat.C
//
// Abstract:
//
//     Contains routines for protecting the Floating Point operations for the modeset code.
//     Note: 
//     - I had to create a seperate file for these routines since I could not include
//     ntddk.h in nv.c as that would lead to redifinition compiler errors in miniport.h
//     and video.h etc..
//     - We can not include nv.h in nvFloat due to conflict with ntddk.h. 
//     Hence no reference to HwDeviceExtension structure is allowed in this file.
//
// Environment:
//
//     kernel mode only
//
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include "ntddk.h"
#include "nvMultiMon.h"
#include "nvsvc_public.h"

//
// These definitions are not found in ntddk.h for NT4.0, so manually define them.
//
#if _WIN32_WINNT < 0x0500
      //
      // The non-volatile 387 state
      //
        
      typedef struct _KFLOATING_SAVE {
          ULONG   DoNotUse1;
          ULONG   DoNotUse2;
          ULONG   DoNotUse3;
          ULONG   DoNotUse4;
          ULONG   DoNotUse5;
          ULONG   DoNotUse6;
          ULONG   DoNotUse7;
          ULONG   DoNotUse8;
      } KFLOATING_SAVE, *PKFLOATING_SAVE;
  

      NTKERNELAPI
      KeSaveFloatingPointState (
         OUT PKFLOATING_SAVE     FloatSave
         );
      
      NTKERNELAPI
      KeRestoreFloatingPointState (
         IN PKFLOATING_SAVE      FloatSave
         );
#endif // #if _WIN32_WINNT < 0x0500

VOID InitializeFPCode(VOID **ppSave, VOID **pMutex);
VOID EnterFPCode(VOID *pSave, VOID *pMutex);
VOID ExitFPCode(VOID *pSave, VOID *pMutex);

//VOID CheckForcedResolution(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG ulWidth, ULONG ulHeight, ULONG ulDepth, ULONG ulRefreshRate, BOOLEAN SetBestResolution );
//
// moved to nv.c because I can't include nv.h here (since ntddk.h is included)  
//
// The build dependency tree is a mess!


//
// Exported event functions
//
VOID SignalModeSwitchEvent();
VOID SignalNVCplHotKeyEvent();
VOID InitNVSVCEvents();

//
// internal helper event function.
//
VOID HandleEvent(PCSZ pEventName, ULONG ulAction);


//
// Does a one time initialization to create the mutex and the floating point save buffer
// This function does the following
// - Initilize the mutex. Supported only for Win2K and later.
// - Initialize the buffer to save the FP state. 
//
VOID InitializeFPCode(VOID **ppSave, VOID **ppMutex)
{
    *ppSave = NULL;
    *ppMutex = NULL;

    // Allocate the FP state save area.
    // 0 is for nonpaged pool.
    *ppSave = ExAllocatePool(NonPagedPool, sizeof(KFLOATING_SAVE));

#ifdef ENABLE_FP_MUTEX
#if (_WIN32_WINNT >= 0x0500)
    // Initialize the fast mutex. These are defined only in win2K.
    *ppMutex = ExAllocatePool(NonPagedPool, sizeof(FAST_MUTEX));
    if (*ppMutex == NULL)
    {
        return;
    }
    ExInitializeFastMutex((FAST_MUTEX *)*ppMutex);
#endif
#endif ENABLE_FP_MUTEX
}

//
// Call this function before doing Floatng point operations. Every call to EnterFPMutex() _should_ be matched with
// a corresponding call to ExitFPMutex().
// - Acuires the mutex inorder to disable all interrupts so that this thread does not get time sliced by the OS scheduler.
// - Saves the FP state.
//
VOID EnterFPCode(VOID *pSave, VOID *pMutex)
{
    NTSTATUS Status;
    // First Disable the interrupts
    // For NT4.0, we use the brute force way of cli/sti.
    // For Win2K, we use fast mutexes.
#ifdef ENABLE_FP_MUTEX
#if (_WIN32_WINNT >= 0x0500)
    if (pMutex != NULL)
    {
        // Acquire the mutex now.
        ExAcquireFastMutex((FAST_MUTEX *)pMutex);
    }
#else
    //
    // NT 4.0 case
    // Note: Do not do any registry reads while interrupts are disabled as that causes NT4.0
    // to BSOD.
    //
     _asm
     {
        cli
     }
#endif (_WIN32_WINNT >= 0x0500)
#endif ENABLE_FP_MUTEX

    // If the FP state save area was not created, we do nothing and exit.
    if (pSave == NULL)
    {
        return;
    }

    // Now save the FP state.
    Status = KeSaveFloatingPointState((KFLOATING_SAVE *)pSave);

}


//
// Call this function before exiting Floatng point operations. Every call to EnterFPMutex() _should_ be matched with
// a corresponding call to ExitFPMutex().
// - Releases the mutex
// - Restores the FP state.
//
VOID ExitFPCode(VOID *pSave, VOID *pMutex)
{
    NTSTATUS Status;

    // If the FP state save area was created, we restore the Floating Point state.
    if (pSave != NULL)
    {
        Status = KeRestoreFloatingPointState((KFLOATING_SAVE *)pSave);
    }

    // Now enable the interrupts.
    // For NT4.0, we use the brute force way of cli/sti.
    // For Win2K, we use fast mutexes.
#ifdef ENABLE_FP_MUTEX
#if (_WIN32_WINNT >= 0x0500)
    if (pMutex != NULL)
    {
        // Release the mutex now.
        ExReleaseFastMutex((FAST_MUTEX *)pMutex);
    }
#else
    // NT 4.0 case
    // Note: Do not do any registry reads while interrupts are disabled as that causes NT4.0
    // to BSOD.
     _asm
     {
        sti
     }
#endif (_WIN32_WINNT >= 0x0500)
#endif ENABLE_FP_MUTEX

}


//
// Signals the "NVModeSwitchEvent" object to wake up the NVSVC to induce a modeset. The actual deviceMask
// to be used by the nvPanel will be returned in an escape callNV_ESC_INDUCE_MODESET
//
VOID SignalModeSwitchEvent()
{
    HandleEvent(NVSVC_EVENT_MODESWITCH_DRIVER, EVENT_ACTION_SIGNAL);
}

//
// Signals the "NVCplHotKeyEvent" object to let the control panel thread know that a 
// hotkey device switch has taken place.
//
VOID SignalNVCplHotKeyEvent()
{
    HandleEvent(NVCPL_EVENT_HOTKEY_DRIVER, EVENT_ACTION_SIGNAL);
}

//
// Create the events that NVSVC sleeps on and set them to cleared state. We need to
// explicitly clear the created event since they would be created with signalled state.
//
VOID InitNVSVCEvents()
{
    UNICODE_STRING EventUnicodeString;
    PKEVENT EventPtr = NULL;
    HANDLE  EventHandle;

    HandleEvent(NVSVC_EVENT_ICONBEGIN_DRIVER, EVENT_ACTION_CREATE);
    HandleEvent(NVSVC_EVENT_ICONEND_DRIVER, EVENT_ACTION_CREATE);
    HandleEvent(NVSVC_EVENT_MODESWITCH_DRIVER, EVENT_ACTION_CREATE);

    //
    // This event is _not_ used by NVSVC. It is used for a special case control panel thread. If the control
    // panel is already open, and the user preses a hotkey on laptops, control panel needs to know that
    // a hotkey device switch has happened. This is because if the same desktop mode is maintained after the 
    // device switch, the OS does not send a WM_DISPLAYCHANGE message to the control panel thread.
    //
    HandleEvent(NVCPL_EVENT_HOTKEY_DRIVER, EVENT_ACTION_CREATE);
}



//
// This helper function performs the specified operation on the requested named event.
// Arguements:
// pEventName:      In parameter: An event name such as  "\\BaseNamedObjects\\SomeEventName" passed as constant string. 
//                  These names are defined uniquely in either nvsvc_public.h or nvMultiMon.h
// ulAction:        In Parameter: 
//                  EVENT_ACTION_CREATE: creates the named event and sets it to cleared state.
//                  EVENT_ACTION_SIGNAL: signals the named event.
//                  EVENT_ACTION_CLEAR:  clears the named event.                        
// Return Value:    None
//
VOID HandleEvent(PCSZ pEventName, ULONG ulAction)
{
    ANSI_STRING sAnsiString;
    ULONG NameLength;
    UNICODE_STRING sEventUniCodeString;
    PKEVENT EventPtr = NULL;
    HANDLE  EventHandle;
    WCHAR   NameBuffer[NVSVC_EVENT_NAME_MAX_LENGTH];

    //
    // Sanity checks.
    //
    if (pEventName == NULL)
    {
        return;
    }
    NameLength = strlen(pEventName);
    if (NameLength > NVSVC_EVENT_NAME_MAX_LENGTH)
    {
        return;
    }
       
    //
    // convert the requested reguar string to an ansi string.
    //
    RtlInitAnsiString(&sAnsiString, pEventName);
    //
    // Allocate the buffer for the string for the unicode
    //
    sEventUniCodeString.Length = sEventUniCodeString.MaximumLength = sizeof(NameBuffer);
    sEventUniCodeString.Buffer = (PWSTR)NameBuffer;
    //
    // Convert the ansi string to a unicode string.
    //
    RtlAnsiStringToUnicodeString(&sEventUniCodeString, &sAnsiString, FALSE);
    //
    // Finally, get the event pointer and signal the event.
    //
    EventPtr = IoCreateSynchronizationEvent(&sEventUniCodeString, &EventHandle);
    if (EventPtr)
    {
        //
        // Perform the requested operation
        //
        switch (ulAction)
        {
        case EVENT_ACTION_CREATE:
            //
            // We need to clear because a newly created event gets born in a signalled state.
            //
            KeClearEvent(EventPtr);
            break;
        case EVENT_ACTION_CLEAR:
            KeClearEvent(EventPtr);
            break;
        case EVENT_ACTION_SIGNAL:
            KeSetEvent(EventPtr, 0, FALSE);
            break;
        default:
            break;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvmode.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     NVMODE.C
//
// Abstract:
//
//     This is the modeset code for the NV miniport driver.
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************


#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"

#include "ntddvdeo.h"
#include "video.h"

#include "nv.h"

// Bring this in to get the flat panel structs
#include "nvcm.h"
#include "cmdcnst.h"
#include "monitor.h"
#include "vesadata.h"
#include "nvMultiMon.h"

// modeset DLL definitions                    
#include "modeext.h"
void InitializeCommonModesetCode(PHW_DEVICE_EXTENSION HwDeviceExtension);
ULONG GetTimingDacCommonModesetCode(PHW_DEVICE_EXTENSION HwDeviceExtension, HEAD_RESOLUTION_INFO *pResolution, DAC_TIMING_VALUES * pTimingInfo);
extern int FindModeEntry (LPDISPDATA lpDispData,
    LPCHAR      lpEdidBuffer,
    ULONG       dwEdidSize,
    LPMODEINFO  lpModeDesc,
    LPMODEOUT   lpModeOut,
    LPMODEINFO  lpModeNew);

extern ULONG ConvertDeviceMaskToIndex(
    ULONG ulDeviceMask);
extern ULONG MaskToDeviceType( ULONG ulDeviceMask);
extern ULONG MaskToFindModeEntryDeviceType( ULONG ulDeviceMask);
extern ULONG MaskToTVFormat( ULONG ulDeviceMask);

extern VOID InitializeFPCode(VOID **ppSave, VOID **pMutex);
extern VOID EnterFPCode(VOID *pSave, VOID *pMutex);
extern VOID ExitFPCode(VOID *pSave, VOID *pMutex);



#define NV3_BYTE_ALIGNMENT_PAD   15L
#define NV4_BYTE_ALIGNMENT_PAD   31L
#define NV10_BYTE_ALIGNMENT_PAD  63L

#define IMAGE_PITCH_LIMIT       16320


//******************************************************************************
//
// Function Declarations
//
//******************************************************************************

VP_STATUS
NVQueryAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    ULONG_PTR* OutputSize
    );

VP_STATUS
NVQueryNumberOfAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    ULONG_PTR* OutputSize
    );

VP_STATUS
NVQueryCurrentMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    ULONG_PTR* OutputSize
    );

VOID
NVValidateModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension
    );

BOOL NVValidateDeviceMode(PHW_DEVICE_EXTENSION HwDeviceExtension, VALMODEXTR *vmx);

//******************************************************************************
//
// External Function Declarations
//
//******************************************************************************

extern BOOL RmConfigGetExKernel
(
    U032 deviceReference,
    U032 index,
    VOID* pParms,
    U032 parmSize
);

extern BOOL RmConfigGetKernel (U032, U032, U032*);

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,NVQueryAvailableModes)
#pragma alloc_text(PAGE,NVQueryNumberOfAvailableModes)
#pragma alloc_text(PAGE,NVQueryCurrentMode)
#pragma alloc_text(PAGE,NVValidateModes)
#endif

MODE_ENTRY FakeModes[] =  { {1,640,480,8 ,60},
                            {1,640,480,16,60},
                            {1,640,480,32,60},
                            {1,640,480,8 ,70},
                            {1,640,480,16,70},
                            {1,640,480,32,70},
                            {1,640,480,8 ,75},
                            {1,640,480,16,75},
                            {1,640,480,32,75},

                            {1,800,600,8 ,60},
                            {1,800,600,16,60},
                            {1,800,600,32,60},
                            {1,800,600,8 ,70},
                            {1,800,600,16,70},
                            {1,800,600,32,70},
                            {1,800,600,8 ,75},
                            {1,800,600,16,75},
                            {1,800,600,32,75},

                            {1,1024,768,8 ,60},
                            {1,1024,768,16,60},
                            {1,1024,768,32,60},
                            {1,1024,768,8 ,70},
                            {1,1024,768,16,70},
                            {1,1024,768,32,70},
                            {1,1024,768,8 ,75},
                            {1,1024,768,16,75},
                            {1,1024,768,32,75} };


//******************************************************************************
//
//  Function:  NVQueryAvailableModes()
//
//  Routine Description:
//
//      This routine returns the list of all available available modes on the
//      card.
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//      ModeInformation - Pointer to the output buffer supplied by the user.
//          This is where the list of all valid modes is stored.
//
//      ModeInformationSize - Length of the output buffer supplied by the user.
//
//      OutputSize - Pointer to a buffer in which to return the actual size of
//          the data in the buffer. If the buffer was not large enough, this
//          contains the minimum required buffer size.
//
//  Return Value:
//
//      ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
//          for the data being returned.
//
//      NO_ERROR if the operation completed successfully.
//
//******************************************************************************


VP_STATUS
NVQueryAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    ULONG_PTR* OutputSize
    )

{
    PVIDEO_MODE_INFORMATION videoModes = ModeInformation;
    ULONG i;
    PMODE_ENTRY ModeEntry;
    ULONG BytesPerPel;
    ULONG NumberOfModesBeforeMemRestrictions;
    
    
    //**************************************************************************
    // Find out the size of the data to be put in the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //**************************************************************************

    if (ModeInformationSize < (*OutputSize =
            HwDeviceExtension->NumAvailableModes *
            sizeof(VIDEO_MODE_INFORMATION)) ) {

        VideoDebugPrint((0,"NVQueryAvailableModes: ERROR_INSUFFICIENT_BUFFER\n"));
        return ERROR_INSUFFICIENT_BUFFER;

    }


    //**************************************************************************
    // During unattended install with an Intel 810 present,
    // we're going to return a 'fake' set of available modes.
    // We'll specify just enough modes to 'fake out' unattended install
    // to let it succeed.  We do this because we completely skipped
    // the ValidateModes() function.  We'll specify 9 modes, 3 refreshes each.
    // (640x480, 800x600, 1024x768 at 60hz,70hz,75hz)
    //**************************************************************************

    if (HwDeviceExtension->DeviceMappingFailed==TRUE)
        {

        if (ModeInformationSize < (*OutputSize = 9 * 3 * sizeof(VIDEO_MODE_INFORMATION)) ) 
            {
            VideoDebugPrint((0,"NVQueryAvailableModes: ERROR_INSUFFICIENT_BUFFER\n"));
            return ERROR_INSUFFICIENT_BUFFER;
            }


        //**************************************************************************
        // Point to fake mode table
        //**************************************************************************

        ModeEntry = (PMODE_ENTRY)&(FakeModes[0]);

        //**************************************************************************
        // Parse the fake mode table (27 modes), and return it to Win2k
        //**************************************************************************

        for (i = 0; i < 27 ; i++)

            {
            if ((ModeEntry[i].Depth == 15) || (ModeEntry[i].Depth == 16))
                BytesPerPel = 16/8;
            else
                BytesPerPel = (ModeEntry[i].Depth/8);

            videoModes->Length              = sizeof(VIDEO_MODE_INFORMATION);
            videoModes->ModeIndex           = i;
            videoModes->VisScreenWidth      = ModeEntry[i].Width;
            videoModes->ScreenStride        = ModeEntry[i].Width * BytesPerPel;
            videoModes->VisScreenHeight     = ModeEntry[i].Height;
            videoModes->NumberOfPlanes      = 1;

            if (ModeEntry[i].Depth == 15)
                videoModes->BitsPerPlane = 16;
            else
                videoModes->BitsPerPlane = ModeEntry[i].Depth;

            videoModes->Frequency           = ModeEntry[i].RefreshRate;
            videoModes->XMillimeter         = 320;  // temporary hardcoded constant
            videoModes->YMillimeter         = 240;  // temporary hardcoded constant
            videoModes->NumberRedBits       = 8;    // Do we have an 8 or 6 bit DAC?
            videoModes->NumberGreenBits     = 8;    // Do we have an 8 or 6 bit DAC?
            videoModes->NumberBlueBits      = 8;    // Do we have an 8 or 6 bit DAC?
            videoModes->AttributeFlags      = VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS;
            videoModes->AttributeFlags      |=  0;  // No interlacing today.

            videoModes->VideoMemoryBitmapWidth = ModeEntry[i].Width;
            videoModes->VideoMemoryBitmapHeight =
                   HwDeviceExtension->AdapterMemorySize / videoModes->ScreenStride;

            if (ModeEntry[i].Depth == 15)
                {
                videoModes->RedMask = 0x7c00;           // 5:5:5 format
                videoModes->GreenMask = 0x03e0;
                videoModes->BlueMask = 0x001f;
                }

            else if (ModeEntry[i].Depth == 16)
                {
                videoModes->RedMask = 0xf800;           // 5:6:5 format
                videoModes->GreenMask = 0x07e0;
                videoModes->BlueMask = 0x001f;
                }

            else if (ModeEntry[i].Depth == 32)

                {
                videoModes->RedMask =   0xff0000;
                videoModes->GreenMask = 0x00ff00;
                videoModes->BlueMask =  0x0000ff;
                }

            else

                {
                videoModes->RedMask = 0;
                videoModes->GreenMask = 0;
                videoModes->BlueMask = 0;
                videoModes->AttributeFlags |= VIDEO_MODE_PALETTE_DRIVEN |
                         VIDEO_MODE_MANAGED_PALETTE;
                }

            videoModes++;

            }

        return NO_ERROR;
        }


    //**************************************************************************
    // Get pointer to our mode data table
    //
    // NOTE: NV3 still uses the OLD style modeset code meaning:
    //
    //          1) The 'validated' modes are located in HwDeviceExtension->fbTimingTable
    //          2) The old modeset code (in modeset.c) is still being used.
    //             This code is no longer being maintained/updated.
    //             Available modes are 'fixed' , it's not as easy to
    //             to add/modify new modes using this old style modeset code.
    //
    //       NV4 (and better) now used the NEW style modeset code:
    //
    //          1) The 'validated' modes are located in HwDeviceExtension->ValidModeTable
    //          2) The mode gets set the the RM (via RmSetMode).  The RM also
    //             handles modeset code arbitration.  This is the same modeset
    //             code used by the Win9x driver, and is 'shared'.  It is much
    //             easier to add/modify new modes using this new style modeset code.
    //
    //**************************************************************************

    if (HwDeviceExtension->ulChipID  == NV3_DEVICE_NV3_ID)
        {        
        //**********************************************************************
        // NV3  (Old style modeset code)
        //**********************************************************************

        ModeEntry = (PMODE_ENTRY)&(HwDeviceExtension->fbTimingTable[0]);
        }
        
    else
        {
        //**********************************************************************
        // NV4 or better (New style modeset code)
        //**********************************************************************

        ModeEntry = (PMODE_ENTRY)&(HwDeviceExtension->ValidModeTable[0]);
        }
        


    if (HwDeviceExtension->ulChipID  == NV3_DEVICE_NV3_ID)

        {
        //**********************************************************************
        // NV3 still uses OLD style modeset code
        //
        // 'NumVideoModes' is a fixed value, and represents the number
        // of modes that were available before eliminating modes due
        // to the amount of memory on the card.
        //**********************************************************************

        NumberOfModesBeforeMemRestrictions = NumVideoModes;
        }
        
    else

        {
        //**********************************************************************
        // NV4 uses the NEW style modeset code.
        //
        // 'NumRegistryModes' represents the number of modes available
        // before eliminating modes due to the amount of memory on the card.
        // The DIFFERENCE is that this value depends on 
        //      1) What modes are listed in VESADATA.C (in GTFTimingTable) and
        //      2) What modes were specified in the REGISTRY
        //**********************************************************************

        NumberOfModesBeforeMemRestrictions = HwDeviceExtension->NumRegistryModes;
        }
        

    //**************************************************************************
    // For each mode supported by the card, store the mode characteristics
    // in the output buffer.
    //**************************************************************************


      for (i = 0; i < NumberOfModesBeforeMemRestrictions; i++)

        {
        //**********************************************************************
        // In ValidateModes, we check to see which ones are currently
        // available, depending on the amount of RAM currently present
        // on the adapter, etc....
        //**********************************************************************

        if (ModeEntry[i].ValidMode)
            {
            //******************************************************************
            // Handle 15bpp modes same as 16bpp modes
            //******************************************************************

            if ((ModeEntry[i].Depth == 15) || (ModeEntry[i].Depth == 16))
                BytesPerPel = 16/8;
            else
                BytesPerPel = (ModeEntry[i].Depth/8);


            videoModes->Length = sizeof(VIDEO_MODE_INFORMATION);
            videoModes->ModeIndex  = i;
            videoModes->VisScreenWidth = ModeEntry[i].Width;
            videoModes->ScreenStride = ModeEntry[i].Width * BytesPerPel;
            videoModes->VisScreenHeight = ModeEntry[i].Height;
            videoModes->NumberOfPlanes = 1;

            //******************************************************************
            // NV3: Only supports 555 format for 16bpp modes.  However, we return
            // 16bits of color even though we are really running in 15bit (555 mode)
            // (Display applet thinks we have 64k colors) Microsoft said this was ok
            // due to WHQL complications related to 15bpp modes.
            //
            // NV4:  Can support 555 and 565 modes for 16bpp
            // We'll eventually just support 565 modes (64k colors).
            //******************************************************************

            if (ModeEntry[i].Depth == 15)
                videoModes->BitsPerPlane = 16;
            else
                videoModes->BitsPerPlane = ModeEntry[i].Depth;

            videoModes->Frequency = ModeEntry[i].RefreshRate;
            videoModes->XMillimeter = 320;      // temporary hardcoded constant
            videoModes->YMillimeter = 240;      // temporary hardcoded constant
            videoModes->NumberRedBits = 8;      // Do we have an 8 or 6 bit DAC?
            videoModes->NumberGreenBits = 8;    // Do we have an 8 or 6 bit DAC?
            videoModes->NumberBlueBits = 8;     // Do we have an 8 or 6 bit DAC?
            videoModes->AttributeFlags = VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS;
            videoModes->AttributeFlags |=  0;   // No interlacing today.

            //******************************************************************
            // Calculate the VideoMemoryBitmapWidth
            // Since our hardware handles variable pitch, we don't ever
            // have offscreen memory on the 'right' side.
            // BitmapWidth will always equal the VisScreenWidth.
            //******************************************************************

            videoModes->VideoMemoryBitmapWidth = ModeEntry[i].Width;

            //******************************************************************
            // NOTE: AdapterMemorySize was adjusted in NVValidateModes
            //       to compensate for INSTANCE memory in offscreen memory.
            //       That is, Hash Table, Fifo Context, and Run Out information
            //       is stored in PRAMIN memory, which also exists in offscreen memory.
            //       We must make sure NO ONE (but the miniport) touches this offscreen memory.
            //
            //       In the display driver, ppdev->cyMemory = VideoMemoryBitmapHeight
            //       Direct Draw uses cyMemory to determine how much memory to 'Share'.
            //       Since these values are obtained from AdapterMemorySize,
            //       no additional adjustments are necessary here.
            //******************************************************************

            //******************************************************************
            // TOTAL number of vertical scanlines in video memory
            //******************************************************************

            videoModes->VideoMemoryBitmapHeight =
                   HwDeviceExtension->AdapterMemorySize / videoModes->ScreenStride;

            //******************************************************************
            // Color masks (specify 5:5:5 format for 16bpp on NV3 only)
            // NV4 supports 5:5:5 as well as 5:6:5
            //******************************************************************

            if (ModeEntry[i].Depth == 15)
                {
                videoModes->RedMask = 0x7c00;           // 5:5:5 format
                videoModes->GreenMask = 0x03e0;
                videoModes->BlueMask = 0x001f;
                }

            else if (ModeEntry[i].Depth == 16)
                {
                videoModes->RedMask = 0xf800;           // 5:6:5 format
                videoModes->GreenMask = 0x07e0;
                videoModes->BlueMask = 0x001f;
                }

            else if (ModeEntry[i].Depth == 24)

                {
                videoModes->RedMask =   0xff0000;
                videoModes->GreenMask = 0x00ff00;
                videoModes->BlueMask =  0x0000ff;
                }

            else if (ModeEntry[i].Depth == 32)

                {
                videoModes->RedMask =   0xff0000;
                videoModes->GreenMask = 0x00ff00;
                videoModes->BlueMask =  0x0000ff;
                }

            else

                {
                videoModes->RedMask = 0;
                videoModes->GreenMask = 0;
                videoModes->BlueMask = 0;
                videoModes->AttributeFlags |= VIDEO_MODE_PALETTE_DRIVEN |
                         VIDEO_MODE_MANAGED_PALETTE;
                }

            videoModes++;

            }

        }

        return NO_ERROR;

    } // end NVQueryAvailableModes()


//******************************************************************************
//
//  Function:   NVQueryNumberOfAvailableModes()
//
//  Routine Description:
//
//      This routine returns the number of available modes for this particular
//      video card.
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//      NumModes - Pointer to the output buffer supplied by the user. This is
//          where the number of modes is stored.
//
//      NumModesSize - Length of the output buffer supplied by the user.
//
//      OutputSize - Pointer to a buffer in which to return the actual size of
//          the data in the buffer.
//
//  Return Value:
//
//      ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
//          for the data being returned.
//
//      NO_ERROR if the operation completed successfully.
//
//******************************************************************************

VP_STATUS NVQueryNumberOfAvailableModes(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_NUM_MODES NumModes,
    ULONG NumModesSize,
    ULONG_PTR* OutputSize
    )

    {
        
    

    //**************************************************************************
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //**************************************************************************

    if (NumModesSize < (*OutputSize = sizeof(VIDEO_NUM_MODES)) ) {

        return ERROR_INSUFFICIENT_BUFFER;

    }

    //**************************************************************************
    // During unattended install with an Intel 810 present,
    // we're going to return a 'fake' set of available modes.
    // We'll specify just enough modes to 'fake out' unattended install
    // to let it succeed.  We do this because we completely skipped
    // the ValidateModes() function.  We'll specify 9 modes, 3 refreshes each.
    // (640x480, 800x600, 1024x768 at 60hz,70hz,75hz) for a total of 27 modes
    //**************************************************************************


    if (HwDeviceExtension->DeviceMappingFailed==TRUE)
        {
        NumModes->NumModes = 27;
        NumModes->ModeInformationLength = sizeof(VIDEO_MODE_INFORMATION);

        VideoDebugPrint((0,"Fake NumAvailableModes = %d\n", 27));
        return NO_ERROR;
        }


    //**************************************************************************
    // Store the number of modes into the buffer.
    // This number is determined in NVValidateModes, which gets called
    // by the function NV1IsPresent (which gets called by NVFindAdapter)
    //**************************************************************************

    NumModes->NumModes = HwDeviceExtension->NumAvailableModes;
    NumModes->ModeInformationLength = sizeof(VIDEO_MODE_INFORMATION);

    VideoDebugPrint((1,"NumAvailableModes = %d\n", HwDeviceExtension->NumAvailableModes));
    return NO_ERROR;

} // end VgaGetNumberOfAvailableModes()


//******************************************************************************
//
// Function: NVQueryCurrentMode()
//
// Routine Description:
//
//     This routine returns a description of the current video mode.
//
// Arguments:
//
//     HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//     ModeInformation - Pointer to the output buffer supplied by the user.
//         This is where the current mode information is stored.
//
//     ModeInformationSize - Length of the output buffer supplied by the user.
//
//     OutputSize - Pointer to a buffer in which to return the actual size of
//         the data in the buffer. If the buffer was not large enough, this
//         contains the minimum required buffer size.
//
// Return Value:
//
//     ERROR_INSUFFICIENT_BUFFER if the output buffer was not large enough
//         for the data being returned.
//
//     NO_ERROR if the operation completed successfully.
//
//******************************************************************************

VP_STATUS
NVQueryCurrentMode(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PVIDEO_MODE_INFORMATION ModeInformation,
    ULONG ModeInformationSize,
    ULONG_PTR* OutputSize
    )


    {
    ULONG BytesPerPel;


    //**************************************************************************
    // Find out the size of the data to be put in the the buffer and return
    // that in the status information (whether or not the information is
    // there). If the buffer passed in is not large enough return an
    // appropriate error code.
    //**************************************************************************

    if (ModeInformationSize < (*OutputSize = sizeof(VIDEO_MODE_INFORMATION)))
        {
        return ERROR_INSUFFICIENT_BUFFER;
        }

    //**************************************************************************
    // Return which chip is present (NV1 or NV3) in the
    // DriverSpecificAttributeFlags field. ulChipID gets determined
    // during NVFindAdapter()
    //
    // For NV5,NV5ULTRA, NV5VANTA, NV0A,NV10 we'll set the NV4 bit to also signify that
    // these chips are also NV4 COMPATIBLE'
    //**************************************************************************

    if (HwDeviceExtension->ulChipID == NV1_DEVICE_NV1_ID)
        ModeInformation->DriverSpecificAttributeFlags = CAPS_NV1_IS_PRESENT;
    else if (HwDeviceExtension->ulChipID == NV3_DEVICE_NV3_ID)
        ModeInformation->DriverSpecificAttributeFlags = CAPS_NV3_IS_PRESENT;
    else if (HwDeviceExtension->ulChipID == NV4_DEVICE_NV4_ID)
        ModeInformation->DriverSpecificAttributeFlags = CAPS_NV4_IS_PRESENT;

    //**************************************************************************
    // For NV5, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV5_DEVICE_NV5_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV5_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;

    //**************************************************************************
    // For NV5ULTRA, set the NV5ULTRA bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV5ULTRA_DEVICE_NV5ULTRA_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV5ULTRA_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;

    //**************************************************************************
    // For NV5VANTA, set the NV5VANTA bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV5VANTA_DEVICE_NV5VANTA_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV5VANTA_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;

    //**************************************************************************
    // For NV5MODEL64, set the NV5MODEL64 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV5MODEL64_DEVICE_NV5MODEL64_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV5MODEL64_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;

    //**************************************************************************
    // For NV0A, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV0A_DEVICE_NV0A_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV0A_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;

    //**************************************************************************
    // For NV10, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV10_DEVICE_NV10_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV10_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;

    //**************************************************************************
    // For NV10DDR, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV10DDR_DEVICE_NV10DDR_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV10DDR_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;
           
    //**************************************************************************
    // For NV10GL, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV10GL_DEVICE_NV10GL_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV10GL_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;
           
    //**************************************************************************
    // For NV11, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV11_DEVICE_NV11_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV11_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;

    //**************************************************************************
    // For NV11DDR, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV11DDR_DEVICE_NV11DDR_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV11DDR_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;
           
    //**************************************************************************
    // For NV11M, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV11M_DEVICE_NV11M_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV11M_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;
           
    //**************************************************************************
    // For NV11GL, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV11GL_DEVICE_NV11GL_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV11GL_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;
           
    //**************************************************************************
    // For CRUSH11, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV11_DEVICE_CRUSH11_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_CRUSH11_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;

    //**************************************************************************
    // For NV15, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV15_DEVICE_NV15_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV15_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;

    //**************************************************************************
    // For NV15DDR, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV15DDR_DEVICE_NV15DDR_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV15DDR_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;
           
    //**************************************************************************
    // For NV15BR, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV15BR_DEVICE_NV15BR_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV15BR_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;
           
    //**************************************************************************
    // For NV15GL, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV15GL_DEVICE_NV15GL_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV15GL_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;
           
    //**************************************************************************
    // For NV20, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV20_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;

    //**************************************************************************
    // For NV20_1, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_1_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV20_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;

    //**************************************************************************
    // For NV20_2, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_2_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV20_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;

    //**************************************************************************
    // For NV20_3, set the NV4 bit to signify NV4 compatibility !!
    //**************************************************************************

    else if (HwDeviceExtension->ulChipID == NV20_DEVICE_NV20_3_ID)
        ModeInformation->DriverSpecificAttributeFlags = ( CAPS_NV20_IS_PRESENT | CAPS_NV4_IS_PRESENT) ;

    else
        ModeInformation->DriverSpecificAttributeFlags = 0;

    //**************************************************************************
    // Handle 15bpp modes same as 16bpp modes
    //**************************************************************************

    if (HwDeviceExtension->CurrentMode->Depth == 15)
        BytesPerPel = 16/8;
    else
        BytesPerPel = (HwDeviceExtension->CurrentMode->Depth/8);


    //**************************************************************************
    // Store the characteristics of the current mode into the buffer.
    //**************************************************************************

    ModeInformation->Length = sizeof(VIDEO_MODE_INFORMATION);

    ModeInformation->ModeIndex = HwDeviceExtension->ModeIndex;
    if(HwDeviceExtension->DeskTopInfo.ulDesktopMode & NV_ENABLE_VIRTUAL_DESKTOP)
    {
        ModeInformation->VisScreenWidth =  HwDeviceExtension->DeskTopInfo.ulDesktopWidth; 
        ModeInformation->VisScreenHeight = HwDeviceExtension->DeskTopInfo.ulDesktopHeight;
    }
    else
    {
        ModeInformation->VisScreenWidth = HwDeviceExtension->CurrentMode->Width;
        ModeInformation->VisScreenHeight = HwDeviceExtension->CurrentMode->Height;
    }

    ModeInformation->ScreenStride = ModeInformation->VisScreenWidth * BytesPerPel;

    //**************************************************************************
    // Add alignment for all chips
    //**************************************************************************
    if (ModeInformation->DriverSpecificAttributeFlags & CAPS_NV3_IS_PRESENT)
    {
        ModeInformation->ScreenStride += NV3_BYTE_ALIGNMENT_PAD;
        ModeInformation->ScreenStride &= ~NV3_BYTE_ALIGNMENT_PAD;
    }
    else if ((ModeInformation->DriverSpecificAttributeFlags & CAPS_NV10_IS_PRESENT) ||      
        (ModeInformation->DriverSpecificAttributeFlags & CAPS_NV10DDR_IS_PRESENT) || 
        (ModeInformation->DriverSpecificAttributeFlags & CAPS_NV10GL_IS_PRESENT)  ||
        (ModeInformation->DriverSpecificAttributeFlags & CAPS_NV11_IS_PRESENT)    ||   
        (ModeInformation->DriverSpecificAttributeFlags & CAPS_NV11DDR_IS_PRESENT) ||   
        (ModeInformation->DriverSpecificAttributeFlags & CAPS_NV11M_IS_PRESENT)   ||   
        (ModeInformation->DriverSpecificAttributeFlags & CAPS_NV11GL_IS_PRESENT)  ||   
        (ModeInformation->DriverSpecificAttributeFlags & CAPS_CRUSH11_IS_PRESENT) ||   
        (ModeInformation->DriverSpecificAttributeFlags & CAPS_NV15_IS_PRESENT)    ||   
        (ModeInformation->DriverSpecificAttributeFlags & CAPS_NV15DDR_IS_PRESENT) ||   
        (ModeInformation->DriverSpecificAttributeFlags & CAPS_NV15BR_IS_PRESENT)  ||   
        (ModeInformation->DriverSpecificAttributeFlags & CAPS_NV15GL_IS_PRESENT)  ||   
        (ModeInformation->DriverSpecificAttributeFlags & CAPS_NV20_IS_PRESENT) )
    {
        ModeInformation->ScreenStride += NV10_BYTE_ALIGNMENT_PAD;
        ModeInformation->ScreenStride &= ~NV10_BYTE_ALIGNMENT_PAD;
    }
    else        
    {
        ModeInformation->ScreenStride += NV4_BYTE_ALIGNMENT_PAD;
        ModeInformation->ScreenStride &= ~NV4_BYTE_ALIGNMENT_PAD;
    }

    ModeInformation->NumberOfPlanes = 1;

    //**************************************************************************
    // NV3: Only supports 555 format for 16bpp modes.  However, we return
    // 16bits of color even though we are really running in 15bit (555 mode)
    // (Display applet thinks we have 64k colors) Microsoft said this was ok
    // due to WHQL complications related to 15bpp modes.
    //
    // NV4:  Can support 555 and 565 modes for 16bpp
    // We'll eventually just support 565 modes (64k colors).
    //**************************************************************************

    if (HwDeviceExtension->CurrentMode->Depth == 15)
        ModeInformation->BitsPerPlane  = 16;
    else
        ModeInformation->BitsPerPlane = HwDeviceExtension->CurrentMode->Depth;


    ModeInformation->Frequency = HwDeviceExtension->CurrentMode->RefreshRate;

    ModeInformation->XMillimeter = 320;        // temporary hardcoded constant
    ModeInformation->YMillimeter = 240;        // temporary hardcoded constant
    ModeInformation->NumberRedBits = 8;
    ModeInformation->NumberGreenBits = 8;
    ModeInformation->NumberBlueBits = 8;
    ModeInformation->AttributeFlags = VIDEO_MODE_COLOR | VIDEO_MODE_GRAPHICS;

   if (HwDeviceExtension->CurrentMode->Depth == 15)
       {
       ModeInformation->RedMask = 0x7c00;
       ModeInformation->GreenMask = 0x03e0;
       ModeInformation->BlueMask = 0x001f;
       }

   else if (HwDeviceExtension->CurrentMode->Depth == 16)
       {
       ModeInformation->RedMask = 0xf800;
       ModeInformation->GreenMask = 0x07e0;
       ModeInformation->BlueMask = 0x001f;
       }

   else if (HwDeviceExtension->CurrentMode->Depth == 24)

       {
       ModeInformation->RedMask =   0xff0000;
       ModeInformation->GreenMask = 0x00ff00;
       ModeInformation->BlueMask =  0x0000ff;
       }

   else if (HwDeviceExtension->CurrentMode->Depth == 32)

       {
       ModeInformation->RedMask =   0xff0000;
       ModeInformation->GreenMask = 0x00ff00;
       ModeInformation->BlueMask =  0x0000ff;
       }

   else        // 8bpp palette driven
       {
       ModeInformation->RedMask = 0;
       ModeInformation->GreenMask = 0;
       ModeInformation->BlueMask = 0;
       ModeInformation->AttributeFlags |= VIDEO_MODE_PALETTE_DRIVEN |
                VIDEO_MODE_MANAGED_PALETTE;
       }

   //**************************************************************************
   // Calculate the VideoMemoryBitmapWidth
   // Since our hardware handles variable pitch, we don't ever
   // have offscreen memory on the 'right' side.
   // BitmapWidth will always equal the VisScreenWidth.
   //**************************************************************************

    ModeInformation->VideoMemoryBitmapWidth = ModeInformation->VisScreenWidth;

   //**************************************************************************
   // NOTE: AdapterMemorySize was adjusted in NVValidateModes
   //       to compensate for INSTANCE memory in offscreen memory.
   //       That is, Hash Table, Fifo Context, and Run Out information
   //       is stored in PRAMIN memory, which also exists in offscreen memory.
   //       We must make sure NO ONE (but the miniport) touches this offscreen memory.
   //
   //       In the display driver (in Enable), ppdev->cyMemory = VideoMemoryBitmapHeight
   //       Direct Draw uses cyMemory to determine how much memory to 'Share'.
   //       Since these values are obtained from AdapterMemorySize,
   //       no additional adjustments are necessary here.
   //**************************************************************************

    ModeInformation->VideoMemoryBitmapHeight =
             HwDeviceExtension->AdapterMemorySize / ModeInformation->ScreenStride;

    if(HwDeviceExtension->ulForceSwCursor)
        ModeInformation->DriverSpecificAttributeFlags |= CAPS_SW_POINTER;

    return NO_ERROR;

    } // end NVQueryCurrentMode()


//******************************************************************************
//
//  Function:   NVValidateModes()
//
//  Routine Description:
//
//      Determines which modes are valid and which are not.
//
//  Arguments:
//
//      HwDeviceExtension - Pointer to the miniport driver's device extension.
//
//  Return Value:
//
//      None.
//
//******************************************************************************

VOID NVValidateModes(PHW_DEVICE_EXTENSION HwDeviceExtension)
    {

    ULONG i, AvailableAdapterMemorySize;
    PHWINFO NVInfo;
    PMODE_ENTRY ModeEntry;
    ULONG NumAvailableModesTmp = 0;
    ULONG ulMonitorType;
    NV_CFGEX_GET_SURFACE_DIMENSIONS_PARAMS nvPitch;

    HwDeviceExtension->NumAvailableModes = HwDeviceExtension->NumRegistryModes;
    HwDeviceExtension->NumAvailableModes1 = HwDeviceExtension->NumRegistryModes;
    
    //**********************************************************************
    // Get the amount of video memory on this card
    //**********************************************************************
    NVInfo = (PHWINFO)&(HwDeviceExtension->NvInfo);
    HwDeviceExtension->AdapterMemorySize = NVInfo->Framebuffer.RamSize - HwDeviceExtension->TotalInstanceMemory;
    AvailableAdapterMemorySize = HwDeviceExtension->AdapterMemorySize;
#if (_WIN32_WINNT >= 0x0500)
    if (HwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_ENABLE_DUALVIEW)
        AvailableAdapterMemorySize /= 2;
#endif

    ModeEntry = (PMODE_ENTRY)&(HwDeviceExtension->ValidModeTable[0]);

    for (i = 0; i < HwDeviceExtension->NumRegistryModes; i++)
    {
        nvPitch.Width = ModeEntry[i].Width;
        nvPitch.Height = ModeEntry[i].Height;
        nvPitch.Depth = ModeEntry[i].Depth;

        RmConfigGetExKernel(HwDeviceExtension->DeviceReference, NV_CFGEX_GET_SURFACE_DIMENSIONS, &nvPitch, sizeof(NV_CFGEX_GET_SURFACE_DIMENSIONS_PARAMS));

        //******************************************************************
        // Make the modes that fit in video memory valid. 
        //******************************************************************
    
        if (AvailableAdapterMemorySize >= nvPitch.Pitch * ModeEntry[i].Height)
        {
            //**************************************************************
            // Set the mode as available if it fits in memory
            //**************************************************************
                if(nvPitch.Pitch > IMAGE_PITCH_LIMIT)
                {
                    ModeEntry[i].ValidMode = FALSE;
                    VideoDebugPrint((0,"%dx%d mode[%d] disabled\n",
                        ModeEntry[i].Width,
                        ModeEntry[i].Height,
                        i));
                }
                else
                {
    
                    ModeEntry[i].ValidMode = TRUE;
                    NumAvailableModesTmp++;
    
                    VideoDebugPrint((2,"mode[%d] valid\n",i));
                    VideoDebugPrint((2,"         width(%d)\n",ModeEntry[i].Width));
                    VideoDebugPrint((2,"         height(%d)\n",ModeEntry[i].Height));
                    VideoDebugPrint((2,"         depth(%d)\n",ModeEntry[i].Depth));
                    VideoDebugPrint((2,"         refresh(%d)\n",ModeEntry[i].RefreshRate));
                    VideoDebugPrint((2,"         bytes needed(%d)\n",nvPitch.Pitch * ModeEntry[i].Height));
                    VideoDebugPrint((2,"         memory pres(%d)\n",HwDeviceExtension->AdapterMemorySize));
                }
        }
        else
            //**************************************************************
            // Mode not available on this adapter
            //**************************************************************
        {
            ModeEntry[i].ValidMode = FALSE;
        }

        switch(HwDeviceExtension->ulChipID)
        {
            case NV4_DEVICE_NV4_ID:               
            case NV5_DEVICE_NV5_ID:               
            case NV5ULTRA_DEVICE_NV5ULTRA_ID:
            case NV5VANTA_DEVICE_NV5VANTA_ID:     
            case NV5MODEL64_DEVICE_NV5MODEL64_ID: 
            case NV0A_DEVICE_NV0A_ID:             
            case NV10_DEVICE_NV10_ID:             
            case NV10DDR_DEVICE_NV10DDR_ID:       
            case NV10GL_DEVICE_NV10GL_ID:         
            case NV15_DEVICE_NV15_ID:
            case NV15DDR_DEVICE_NV15DDR_ID:
            case NV15BR_DEVICE_NV15BR_ID:
            case NV15GL_DEVICE_NV15GL_ID:
                // NV15 and older have HW look table to perform scaling for DFP
                // 1152x864 is not in the table.  Cannot support the mode
                // NV11 and later is not using table anymore and fully programmable
                RmConfigGetKernel(HwDeviceExtension->DeviceReference, NV_CFG_VIDEO_MONITOR_TYPE, &ulMonitorType);
                if (ulMonitorType == MONITOR_TYPE_FLAT_PANEL && ModeEntry[i].Width == 1152 &&  ModeEntry[i].Height == 864)
                {
                    ModeEntry[i].ValidMode = FALSE;
                }
                break;
            default:
            break;
        }

    }

    HwDeviceExtension->NumAvailableModes = NumAvailableModesTmp;

    } // nvValidateModes()


// NOTE: This function is no longer needed. It will be deleted once Sandy removes this call from ddVPP.c
// Determine if a mode is valid for a particular device
BOOL NVValidateDeviceMode(PHW_DEVICE_EXTENSION HwDeviceExtension, VALMODEXTR *vmx)
{

   PMODE_ENTRY SrcModes, DstModes;
   PMODE_ENTRY ModeEntry;
   PHWINFO     NVInfo;
   ULONG       AvailableAdapterMemorySize;
   ULONG       BytesPerPel;
   U032        memstatus;
   ULONG       i,index;
   BOOL        ModeValid;
   ULONG       refresh;
   BOOL        FoundDell1501FP = FALSE;
   ULONG       ulHead = 0;
   UCHAR       *pEDIDBuffer = HwDeviceExtension->EdidCollection->HeadMaps[ulHead]->EDIDBuffer;

   // @ Most of this code is sourced from NvValidateModes above
   // - Copy the modes in the ValidModeTable to our ValidDeviceModeTable
   DstModes = (PMODE_ENTRY)&(HwDeviceExtension->ValidDeviceModeTable[0]);
   SrcModes = (PMODE_ENTRY)&(HwDeviceExtension->ValidModeTable[0]);
   VideoPortMoveMemory(DstModes, SrcModes, sizeof(MODE_ENTRY) * HwDeviceExtension->NumRegistryModes);
   
   //**********************************************************************
   // Limit the modes according to how much video memory is available
   //**********************************************************************
   ModeEntry = DstModes;
   NVInfo = (PHWINFO)&(HwDeviceExtension->NvInfo);

   //**********************************************************************
   // Get the amount of video memory on this card
   //**********************************************************************
   AvailableAdapterMemorySize = NVInfo->Framebuffer.RamSize - HwDeviceExtension->TotalInstanceMemory;
#if (_WIN32_WINNT >= 0x0500)
   if (HwDeviceExtension->ulDualViewStatus & DUALVIEW_STATUS_ENABLE_DUALVIEW)
       AvailableAdapterMemorySize /= 2;
#endif
   
   //**********************************************************************
   // Now parse the modes to see which ones we can use ( Limit by memory first )
   //**********************************************************************
   for (i = 0; i < HwDeviceExtension->NumRegistryModes; i++)
    
      {
       //******************************************************************
       // Handle 15bpp modes same as 16bpp modes (sizewise they're the same)
       //******************************************************************
    
       if ((ModeEntry[i].Depth == 15) || (ModeEntry[i].Depth == 16))
            BytesPerPel = 16/8;
       else
            BytesPerPel = (ModeEntry[i].Depth/8);
    
       //******************************************************************
       // Make the modes that fit in video memory valid. 
       //******************************************************************
    
       if (AvailableAdapterMemorySize >= ModeEntry[i].Width * ModeEntry[i].Height * BytesPerPel )
                        
           {
           //**************************************************************
           // Set the mode as available if it fits in memory
           //**************************************************************
    
           ModeEntry[i].ValidMode = TRUE;
    
           VideoDebugPrint((2,"NVVDM: mode[%d] valid\n",i));
           VideoDebugPrint((2,"NVVDM:   width(%d)\n",ModeEntry[i].Width));
           VideoDebugPrint((2,"NVVDM:   height(%d)\n",ModeEntry[i].Height));
           VideoDebugPrint((2,"NVVDM:   depth(%d)\n",ModeEntry[i].Depth));
           VideoDebugPrint((2,"NVVDM:   refresh(%d)\n",ModeEntry[i].RefreshRate));
           VideoDebugPrint((2,"NVVDM:   bytes needed(%d)\n",ModeEntry[i].Width * ModeEntry[i].Height * BytesPerPel));
           VideoDebugPrint((2,"NVVDM:   memory pres(%d)\n",AvailableAdapterMemorySize));
           }

       else
    
           //**************************************************************
           // Mode not available on this adapter
           //**************************************************************
           {
           ModeEntry[i].ValidMode = FALSE;
           }
      }



   // @ Now that we know what is possible on the "adapter", lets find out whats possible on the requested display device

   // - Assume the requested mode is invalid on the requested device
   ModeValid = FALSE;
   
   // - Filter against requested device   
   switch( vmx->dwDeviceType ) {

      case  MONITOR_TYPE_VGA:
         // - Under NT4, we assume the monitor can do what the adapter can do for now
         //   Under W2K, we would filter again by the monitors caps here
         break;

      case  MONITOR_TYPE_FLAT_PANEL:
         {
            NV_CFGEX_GET_FLATPANEL_INFO_PARAMS fpp;
            unsigned long FPSizeX;
            unsigned long FPSizeY;
            BOOL  RmStatus;

            RmStatus = RmConfigGetExKernel(HwDeviceExtension->DeviceReference, 
                                           NV_CFGEX_GET_FLAT_PANEL_INFO, 
                                           (VOID *)&fpp,
                                           sizeof(NV_CFGEX_GET_FLATPANEL_INFO_PARAMS));

            // - Dynamically assign the width and height maximums  
            if(RmStatus) {
               // - We got something from the Rm, so use its width
               FPSizeX = fpp.FlatPanelSizeX;
               FPSizeY = fpp.FlatPanelSizeY;
            }
            else {
               // changed to match following mods by others 
               FPSizeX = HwDeviceExtension->MaxFlatPanelWidth;
               FPSizeY = HwDeviceExtension->MaxFlatPanelHeight;
            }

            // Look at EDID Detailed block 3 (starts at offset 0x36)
            // See if can find DELL 1501FP flat panel monitor
            if (VideoPortCompareMemory(&pEDIDBuffer[0x36+ (18*2) + 5], "DELL 1501FP", 11)  == 11)
            {
                FoundDell1501FP = TRUE;
            }

            for (i = 0; i < HwDeviceExtension->NumRegistryModes; i++)
    
                {
                if (ModeEntry[i].ValidMode)
    
                    {
                    //**********************************************************
                    // Remove any mode that doesn't have a refresh rate of 60hz.
                    // - EXCEPT for 320x200, and 640x400 which have refresh
                    //   rates at 70hz...these are required by whql)
                    // - EXCEPT DELL 1501FP multisync flat panel monitor
                    //   Limit DELL refresh rates to 75 hz
                    //**********************************************************

                    if (FoundDell1501FP == TRUE)

                        {
                        if ( (ModeEntry[i].Width  > FPSizeX)  ||
                             (ModeEntry[i].Height > FPSizeY)  || 
                             (ModeEntry[i].RefreshRate > 75)                               ||
                             ((ModeEntry[i].Width == 480) && ( ModeEntry[i].Height == 360))   ||
                             ((ModeEntry[i].Width == 1280) && ( ModeEntry[i].Height == 960))  ||
                             ((ModeEntry[i].Width == 960) && ( ModeEntry[i].Height == 720))   ||
                             ((ModeEntry[i].Width == 864) && ( ModeEntry[i].Height == 480))   ||
                             ((ModeEntry[i].Width == 856) && ( ModeEntry[i].Height == 480))   ||
                             ((ModeEntry[i].Width == 852) && ( ModeEntry[i].Height == 480))   ||
                             ((ModeEntry[i].Width == 848) && ( ModeEntry[i].Height == 480))   ||
                             ((ModeEntry[i].Width == 720) && ( ModeEntry[i].Height == 480))   )
    
    
                            {
                            ModeEntry[i].ValidMode = FALSE;
                            }

                        }
                        
                        
                    else
                    
                        {                        
                        if ( (ModeEntry[i].Width  > FPSizeX)  ||
                             (ModeEntry[i].Height > FPSizeY)  || 
                             ((ModeEntry[i].RefreshRate !=60) && 
                                   (!( (ModeEntry[i].RefreshRate == 70) && (ModeEntry[i].Width == 640) && (ModeEntry[i].Height == 400))) &&
                                   (!( (ModeEntry[i].RefreshRate == 70) && (ModeEntry[i].Width == 320) && (ModeEntry[i].Height == 200))))     ||
                             ((ModeEntry[i].Width == 480) && ( ModeEntry[i].Height == 360))   ||
                             ((ModeEntry[i].Width == 1280) && ( ModeEntry[i].Height == 960))  ||
                             ((ModeEntry[i].Width == 960) && ( ModeEntry[i].Height == 720))   ||
                             ((ModeEntry[i].Width == 864) && ( ModeEntry[i].Height == 480))   ||
                             ((ModeEntry[i].Width == 856) && ( ModeEntry[i].Height == 480))   ||
                             ((ModeEntry[i].Width == 852) && ( ModeEntry[i].Height == 480))   ||
                             ((ModeEntry[i].Width == 848) && ( ModeEntry[i].Height == 480))   ||
                             ((ModeEntry[i].Width == 720) && ( ModeEntry[i].Height == 480))   )
    
    
                            {
                            ModeEntry[i].ValidMode = FALSE;
                            }

                        }
    
                    }
    
                }
         }
         break;

      case  MONITOR_TYPE_NTSC:
      case  MONITOR_TYPE_PAL:
         // - For now, we use the TV modes filter from VnValidateModes above
         for(i = 0; i < HwDeviceExtension->NumRegistryModes; i++) {

             if(ModeEntry[i].ValidMode) {

                //**********************************************************
                // Remove all modes greater than width == 800, AND
                // any mode that doesn't have a refresh rate of 60hz.
                // (EXCEPT for 320x200, and 640x400 which have refresh
                // rates at 70hz...these are required by whql)
                //**********************************************************

                if ( (ModeEntry[i].Width > 800)  || 
                    ((ModeEntry[i].RefreshRate !=60) && 
                        (!( (ModeEntry[i].RefreshRate == 70) && (ModeEntry[i].Width == 640) && (ModeEntry[i].Height == 400))) &&
                        (!( (ModeEntry[i].RefreshRate == 70) && (ModeEntry[i].Width == 320) && (ModeEntry[i].Height == 200))))     ||
                    ((ModeEntry[i].Width == 480) && ( ModeEntry[i].Height == 360)) ) {

                    ModeEntry[i].ValidMode = FALSE;
                    }
    
                }
    
         }
         break;

      default:
         // - We dont know this device, so mark all modes invalid
         for(i = 0; i < HwDeviceExtension->NumRegistryModes; i++) {

           ModeEntry[i].ValidMode = FALSE;
         }
         break;

   }


   // - Adjust for the refresh type, if dwRefresh is 0, use 60Hz
   if(vmx->dwRefresh == 0) {
      refresh = 60;
   }
   else {
      refresh = vmx->dwRefresh;
   }


   // - Finally, see if requested mode is in the trimmed modes table
   for(i = 0; (ModeValid == FALSE) && (i < HwDeviceExtension->NumRegistryModes) ; i++) {

      if(ModeEntry[i].ValidMode) {

         if( ModeEntry[i].Width == vmx->dwHRes &&
             ModeEntry[i].Height == vmx->dwVRes &&
             ModeEntry[i].Depth == vmx->dwBpp &&
             ModeEntry[i].RefreshRate == refresh ) {

            // - We located the mode, so indicate valid and break out...
            ModeValid = TRUE;
            index = i;
         }
      }
   }


   if(ModeValid) {
      VideoDebugPrint((1,"NVVDM:   Requested mode is VALID...\n"));
      VideoDebugPrint((1,"NVVDM:    width(%d)\n",ModeEntry[index].Width));
      VideoDebugPrint((1,"NVVDM:    height(%d)\n",ModeEntry[index].Height));
      VideoDebugPrint((1,"NVVDM:    depth(%d)\n",ModeEntry[index].Depth));
      VideoDebugPrint((1,"NVVDM:    refresh(%d)\n",ModeEntry[index].RefreshRate));
   }
   else {
      VideoDebugPrint((1,"NVVDM:   Requested mode is INVALID...\n"));
   }


   // - Return the validity code derived above
   return(ModeValid);
}


//
// Does a one-time initialization of various fields required by the new common mode set code.
// Initilizes the pixelclockfrequency limits for 8/16/32 bpp for each head.
//
void InitializeCommonModesetCode(PHW_DEVICE_EXTENSION HwDeviceExtension)
{

    NV_CFGEX_DAC_PCLK_LIMIT_PARAMS ClkParams;
    ULONG ulHead;

    // Initilize the floating point save/restore code.
    InitializeFPCode(&HwDeviceExtension->pFPStateSave, &HwDeviceExtension->pFPMutex);

    for (ulHead = 0; ulHead < HwDeviceExtension->DeskTopInfo.ulNumberDacsOnBoard; ulHead++)
    {
        ClkParams.Head = ulHead;
        ClkParams.pclkLimit = 0;

        //
        // Check if CRT is connected for second head. Only then should we
        // use the pixel clock for the second head. Otherwise, we should use the pixel clock of
        // DAC 0 for both heads.
        //
        // if (ulHead == 1 && HwDeviceExtension->DeskTopInfo.ulDeviceType[ulHead] != MONITOR_TYPE_VGA) {
        // ClkParams.Head = 0;
        // }
            

        if (!RmConfigGetExKernel(HwDeviceExtension->DeviceReference, NV_CFGEX_DAC_PCLK_LIMIT_8BPP, (VOID *)&ClkParams, sizeof(NV_CFGEX_DAC_PCLK_LIMIT_PARAMS))) {
            VideoDebugPrint((0,"Oops!  RmConfigGetExKernel() failed NV_CFGEX_DAC_PCLK_LIMIT_8BPP for Head: 0x%x\n",ulHead));
            return;
        } else {
            HwDeviceExtension->maxPixelClockFrequency_8bpp[ulHead] = ClkParams.pclkLimit;
        }
        if (!RmConfigGetExKernel(HwDeviceExtension->DeviceReference, NV_CFGEX_DAC_PCLK_LIMIT_16BPP, (VOID *)&ClkParams, sizeof(NV_CFGEX_DAC_PCLK_LIMIT_PARAMS))) {
            VideoDebugPrint((0,"Oops!  RmConfigGetExKernel() failed NV_CFGEX_DAC_PCLK_LIMIT_16BPP for Head: 0x%x\n",ulHead));
            return;
        } else {
            HwDeviceExtension->maxPixelClockFrequency_16bpp[ulHead] = ClkParams.pclkLimit;
        }
        if (!RmConfigGetExKernel(HwDeviceExtension->DeviceReference, NV_CFGEX_DAC_PCLK_LIMIT_32BPP, (VOID *)&ClkParams, sizeof(NV_CFGEX_DAC_PCLK_LIMIT_PARAMS))) {
            VideoDebugPrint((0,"Oops!  RmConfigGetExKernel() failed NV_CFGEX_DAC_PCLK_LIMIT_32BPP for Head: 0x%x\n",ulHead));
            return;
        } else {
            HwDeviceExtension->maxPixelClockFrequency_32bpp[ulHead] = ClkParams.pclkLimit;
        }

        // sanity check
        if (HwDeviceExtension->maxPixelClockFrequency_8bpp[ulHead] == 0 || 
            HwDeviceExtension->maxPixelClockFrequency_16bpp[ulHead] == 0 || 
            HwDeviceExtension->maxPixelClockFrequency_32bpp[ulHead] == 0) {
             VideoDebugPrint((0,"oops! MaxPixelClockFreq is 0!!!. Returning\n"));
             return;
        }

        VideoDebugPrint((1,"Head: %d, Max8bppFreq (HZ): 0x%x\n",ulHead, HwDeviceExtension->maxPixelClockFrequency_8bpp[ulHead]));
        VideoDebugPrint((1,"Head: %d, Max16bppFreq (HZ): 0x%x\n",ulHead, HwDeviceExtension->maxPixelClockFrequency_16bpp[ulHead]));
        VideoDebugPrint((1,"Head: %d, Max32bppFreq (HZ): 0x%x\n",ulHead, HwDeviceExtension->maxPixelClockFrequency_32bpp[ulHead]));
    }
}

//
// uses the commond mode set code FindModeEntry() to get the monitor timings for the reqested resolution and head.
// If the ulOption flag is set to HEAD_RESOLUTION_OPTION_DONT_BACKOFF, then if the requested mode is not 
// supported in the EDID, ignores the EDID and returns the timing without backing off.
//
ULONG GetTimingDacCommonModesetCode(PHW_DEVICE_EXTENSION HwDeviceExtension, HEAD_RESOLUTION_INFO *pResolution, DAC_TIMING_VALUES * pTimingInfo)
{
    ULONG ulFrequencyHead;
    DISPDATA DispData;
    MODEINFO ModeDesc;
    MODEOUT  ModeOut;
    MODEINFO ModeNew;
    ULONG ulRet;
    ULONG ulHeadEDID;
    LPEDID_UNIT pEdidUnit;

    LPDISPDATA lpDispData;
    LPMODEINFO lpModeDesc;
    LPMODEOUT  lpModeOut;
    LPMODEINFO lpModeNew;

    lpDispData = &DispData;
    lpModeDesc = &ModeDesc;
    lpModeOut = &ModeOut;
    lpModeNew = &ModeNew;

    VideoDebugPrint((3,"Enter GetTimingDacCommonModesetCode()\n"));

    //
    // Check if CRT is connected for second head. Only then should we
    // use the pixel clock for the second head. Otherwise, we should use the pixel clock of
    // DAC 0 for both heads.
    //
    ulFrequencyHead = pResolution->ulHead;
    if (pResolution->ulHead == 1 && pResolution->ulDeviceType != MONITOR_TYPE_VGA) {
         ulFrequencyHead = 0;
    }

    
    ulHeadEDID = ConvertDeviceMaskToIndex(pResolution->ulDeviceMask);
    pEdidUnit  = HwDeviceExtension->EdidCollection->HeadMaps[ulHeadEDID];
    pResolution->ulDeviceType = MaskToDeviceType(pResolution->ulDeviceMask);
    
    lpDispData->lpBoardRegistryData = NULL;
    lpDispData->lpMonitorRegistryData = NULL;
    if (pEdidUnit->Valid)
    {
        lpDispData->dwMonitorInfType = PLUG_AND_PLAY_DEVICE;
    }
    else
    {
        lpDispData->dwMonitorInfType = UNKNOWN_DEVICE;
    }
    
    lpDispData->dwDeviceID = HwDeviceExtension->ulChipID;
    lpDispData->dwCRTCIndex = pResolution->ulHead;
    lpDispData->dwVideoMemoryInBytes = HwDeviceExtension->AdapterMemorySize;
    lpDispData->dwMaxDacSpeedInHertz8bpp= HwDeviceExtension->maxPixelClockFrequency_8bpp[ulFrequencyHead];
    lpDispData->dwMaxDacSpeedInHertz16bpp = HwDeviceExtension->maxPixelClockFrequency_16bpp[ulFrequencyHead];
    lpDispData->dwMaxDacSpeedInHertz32bpp = HwDeviceExtension->maxPixelClockFrequency_32bpp[ulFrequencyHead];
    lpDispData->dwMaxDfpScaledXResInPixels = HwDeviceExtension->MaxFlatPanelWidth;
    lpDispData->lpfnGetModeSize = 0;  // GK: WHat is this?
    lpDispData->dwContext1 = (PVOID)HwDeviceExtension;
    lpDispData->dwContext2 = (PVOID)0;
    lpDispData->dwMaxTVOutResolution = HwDeviceExtension->ulMaxTVOutResolution;

    lpModeDesc->dwXRes = pResolution->ulDisplayWidth;
    lpModeDesc->dwYRes = pResolution->ulDisplayHeight;

    if((pResolution->ulDeviceType == MONITOR_TYPE_FLAT_PANEL) && (HwDeviceExtension->ulDisableDfpModesGreaterThan))
    {
        ULONG ulWidth, ulHeight;

        // Registry key force to limit the resolution
        ulWidth = HwDeviceExtension->ulDisableDfpModesGreaterThan >> 16;
        ulHeight = HwDeviceExtension->ulDisableDfpModesGreaterThan & 0xFFFF;
        if ((pResolution->ulDisplayWidth > ulWidth) && (pResolution->ulDisplayHeight > ulHeight))
        { 
            lpModeDesc->dwXRes = ulWidth;
            lpModeDesc->dwYRes = ulHeight;
        }
    }

    lpModeDesc->dwBpp = pResolution->ulDisplayPixelDepth;
    lpModeDesc->dwRefreshRate = pResolution->ulDisplayRefresh;
    lpModeDesc->dwDevType = MaskToFindModeEntryDeviceType(pResolution->ulDeviceMask);
    lpModeDesc->dwTVFormat = pResolution->ulTVFormat;
    lpModeDesc->dwOriginalRefreshRate = pResolution->ulDisplayRefresh; 

    lpModeDesc->MIDevData.cType     = (CHAR)MaskToFindModeEntryDeviceType(pResolution->ulDeviceMask);
    lpModeDesc->MIDevData.cNumber   = (CHAR)MaskToDeviceType(pResolution->ulDeviceMask);
    lpModeDesc->MIDevData.cFormat   = (CHAR)pResolution->ulTVFormat;
    lpModeDesc->MIDevData.cReserved = 0x0;

    // Call the modeset DLL to see if this mode is valid.
    VideoDebugPrint((3,"Before: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
       lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
       lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));

    EnterFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);

    ulRet = FindModeEntry(lpDispData, pEdidUnit->EDIDBuffer, pEdidUnit->Size,
                          lpModeDesc, lpModeOut, lpModeNew);
    
    ExitFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);

    VideoDebugPrint((3,"ulRet: 0x%x\n",ulRet));
    VideoDebugPrint((3,"After: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
       lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
       lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));
    VideoDebugPrint((3,"After: lpModeNew: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
       lpModeNew->dwXRes, lpModeNew->dwYRes, lpModeNew->dwBpp, lpModeNew->dwRefreshRate, 
       lpModeNew->dwDevType, lpModeNew->dwOriginalRefreshRate));
    if (ulRet != 0)
    {
        VideoDebugPrint((3, "EDID does not support this requested mode: ulRet: 0x%x\n", ulRet));
        //
        // This should not happen on laptop systems. We should never ask the timings for an unsupported
        // mode as pan-scan is handled in the display driver.
        //
        if (HwDeviceExtension->ACPISystem)
        {
            VideoDebugPrint((1,"Laptop: Something wrong. Asking for unsupported physical mode timings"));
            VideoDebugPrint((1,"lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
               lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
               lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));
            VideoDebugPrint((1,"lpModeNew: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
               lpModeNew->dwXRes, lpModeNew->dwYRes, lpModeNew->dwBpp, lpModeNew->dwRefreshRate, 
               lpModeNew->dwDevType, lpModeNew->dwOriginalRefreshRate));
        }
        else
        {
            //
            // This is a desktop system. We now try without the EDID. We do this only if the
            // HEAD_RESOLUTION_OPTION_DONT_BACKOFF is set.
            //
            if (pResolution->ulOption & HEAD_RESOLUTION_OPTION_DONT_BACKOFF)
            {
                VideoDebugPrint((1,"Desktop: Getting timing without the EDID\n"));
                lpDispData->dwMonitorInfType = UNKNOWN_DEVICE;
                EnterFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);

                ulRet = FindModeEntry(lpDispData, NULL, 0,
                          lpModeDesc, lpModeOut, lpModeNew);
    
                ExitFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);

                VideoDebugPrint((1,"ulRet: 0x%x\n",ulRet));
                VideoDebugPrint((1,"After: lpModeDescr: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                   lpModeDesc->dwXRes, lpModeDesc->dwYRes, lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate, 
                   lpModeDesc->dwDevType, lpModeDesc->dwOriginalRefreshRate));
                VideoDebugPrint((1,"After: lpModeNew: %d, %d, %d bpp, %d HZ, 0x%x devType, %d HZ ori\n",
                   lpModeNew->dwXRes, lpModeNew->dwYRes, lpModeNew->dwBpp, lpModeNew->dwRefreshRate, 
                   lpModeNew->dwDevType, lpModeNew->dwOriginalRefreshRate));
            }
        }
    }
    VideoDebugPrint((3,"lpModeOut: 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x, 0x%x,0x%x, 0x%x, 0x%x, 0x%x,0x%x, 0x%x, 0x%x, 0x%x\n",
          lpModeOut->wXRes,
          lpModeOut->wYRes,
          lpModeOut->wHBlankStart,
          lpModeOut->wHBlankWidth,
          lpModeOut->wHSyncStart,
          lpModeOut->wHSyncWidth,
          lpModeOut->wVBlankStart,
          lpModeOut->wVBlankWidth,
          lpModeOut->wVSyncStart,
          lpModeOut->wVSyncWidth,
          lpModeOut->wHTotal,
          lpModeOut->wVTotal,
          lpModeOut->dwPixelClock,
          lpModeOut->dwFormat,
          lpModeOut->wRefreshRate,
          lpModeOut->dwPitchInBytes));

    // Copy the timing info into DAC_TIMING_VALUES
    pTimingInfo->HorizontalVisible = lpModeOut->wXRes;
    pTimingInfo->VerticalVisible = lpModeOut->wYRes;
    pTimingInfo->Refresh = lpModeOut->wRefreshRate;
    pTimingInfo->HorizontalTotal = lpModeOut->wHTotal;
    pTimingInfo->VerticalTotal = lpModeOut->wVTotal;
    pTimingInfo->HorizontalBlankStart = lpModeOut->wHBlankStart;
    pTimingInfo->VerticalBlankStart = lpModeOut->wVBlankStart;
    pTimingInfo->HorizontalRetraceStart = lpModeOut->wHSyncStart;
    pTimingInfo->VerticalRetraceStart = lpModeOut->wVSyncStart;
    pTimingInfo->HorizontalRetraceEnd = lpModeOut->wHSyncStart + lpModeOut->wHSyncWidth;
    pTimingInfo->VerticalRetraceEnd = lpModeOut->wVSyncStart + lpModeOut->wVSyncWidth;
    pTimingInfo->HorizontalBlankEnd = lpModeOut->wHBlankStart + lpModeOut->wHBlankWidth;
    pTimingInfo->VerticalBlankEnd = lpModeOut->wVBlankStart + lpModeOut->wVBlankWidth;
    pTimingInfo->PixelClock = lpModeOut->dwPixelClock;
    pTimingInfo->HSyncpolarity = (lpModeOut->dwFormat & 0x4);
    pTimingInfo->VSyncpolarity = (lpModeOut->dwFormat & 0x8);

    VideoDebugPrint((3,"Exit GetTimingDacCommonModesetCode()\n"));
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvpekmvt.c ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

//***************************************************************************
//  Module Name:
//
//      nvpekmvt.c
//
//  Abstract:
//
//      This module contains the callback to Kernel mode video transport services
//      Win2k
//
//  Environment:
//
//      Kernel mode
//
//***************************************************************************

#ifdef NVPE

#define INITGUID     // Instantiate GUID_DxApi
#include "dderror.h"
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"
#include "nv.h"
#include "nvpekmvt.h"


//
// Mark those routines that we can as pageable.  Remember that most
// "kernel-mode VPE" routines can be called at raised IRQL, which means
// that they must be kept non-paged.
//
// Note that these are the only two VPE miniport routines which may be
// pageable:
//

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,NVQueryInterface)
#pragma alloc_text(PAGE,GetIrqInfo)
#endif

// !!! Not hooking Lock is success, but not hooking SetPattern is failure?
// !!! Should dwFlags be ANDed or EQUALed?  (SkipNextField)
// !!! Should we mark the interrupt as unsharable?


/*++

Routine Description:

    On NT, the miniport always has to "manage the IRQ" (to borrow from the
    Win95 terminology).  Consequently, this routine simply tells DirectDraw
    what interrupts we support.

    It's actually pretty easy to enable interrupts, in part because you
    don't have to tell the system what interrupt vector you're using, as
    PNP already knows that.  However, you *do* have to check whether PNP
    successfully assigned you an interrupt vector, before you tell DirectDraw
    that you support interrupts.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetIrqInfo - Function parameters.

Return Value:

    DX_OK if successful.

--*/

DWORD kmvtGetIrqInfo(
    PVOID HwDeviceExtension,
    PVOID lpInput,
    PDDGETIRQINFO GetIrqInfo)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    DWORD status = DXERR_UNSUPPORTED;

    //
    // Sometimes, the motherboard BIOS or PNP may conspire to refuse to
    // allocate an interrupt to us.  So before we tell DirectDraw that
    // we support interrupts, we must first check if we've actually been
    // assigned one!
    //

//     if ((hwDeviceExtension->BusInterruptLevel != 0) ||
//        (hwDeviceExtension->BusInterruptVector != 0)) 
	{

        GetIrqInfo->dwFlags = IRQINFO_HANDLED;

        status = DX_OK;
	}

    return status;
}

/*++

Routine Description:

    This routine is the interrupt service routine for the kernel video
    driver.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

Return Value:

    TRUE if the interrupt is serviced; FALSE if it wasn't ours (this is done
    to support chained interrupts).

--*/

BOOLEAN kmvtInterrupt(PVOID HwDeviceExtension)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    // add your IRQ handling code here
	return FALSE;
}

/*++

Routine Description:

    This function notifies the miniport when it should enable or disable
    interrupts for VPE.  If an IRQ is not specified in this call, it
    should be disabled.

    On NT, since miniports always "manage the IRQ", we must call DirectDraw's
    IRQCallback routine from our HwInterrupt routine to notify DirectDraw
    whenever an interrupt occurs.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    EnableIrqInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD kmvtEnableIrq(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PDDENABLEIRQINFO EnableIrqInfo,
    PVOID lpOutput)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    //
    // First make sure we stash IRQCallback in our device extension before
    // enabling interrupts for the first time, otherwise we may call a NULL
    // pointer from our HwInterrupt routine!
    //
    // (Note that DirectDraw will give us a valid IRQCallback and lpIRQData
    // even when disabling interrupts, which means we won't crash if an
    // interrupt is taken between this point and the actual disabling of the
    // interrupt.)
    //

    hwDeviceExtension->IRQCallback = EnableIrqInfo->IRQCallback;
    hwDeviceExtension->pIRQData = EnableIrqInfo->lpIRQData;
	hwDeviceExtension->dwIRQSources = EnableIrqInfo->dwIRQSources;

    //
    // Clear any existing interrupts, turn off all interrupts by default,
    // and enable the new requested interrupts.
    //
    // NOTE: Be very careful if your driver uses interrupts for purposes
    //       other than VPE.  For example, if your display driver uses DMA,
    //       you probably won't want to clear the DMA interrupt flag here!
    //

    // Now enable the master interrupt switch.  Again, be careful if your
    // display driver uses interrupt for purposes other than VPE -- you
    // probably won't want to disable all video interrupts here like we
    // do!
    //
    // Note: DxEnableIrq is the only routine that may access the CRTC
    //       registers!  For more details, read the large note at the
    //       top of this file.
    //

    // If the vsync interrupt has been disabled, but a deferred overlay
    // offset is pending, flush it now.
    //

    return DX_OK;
}

/*++

Routine Description:

    This function flips the video port to the target surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FlipVideoPortInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD kmvtFlipVideoPort(
    PVOID HwDeviceExtension,
    PNVP_DDFLIPVIDEOPORTINFO pFlipVideoPort,
    PVOID lpOutput)
{
    return FlipVideoPort(HwDeviceExtension, pFlipVideoPort, lpOutput);
}

/*++

Routine Description:

    This function flips the overlay to the target surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FlipOverlayInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD kmvtFlipOverlay(
    PVOID HwDeviceExtension,
    PNVP_DDFLIPOVERLAYINFO pFlipOverlayInfo,
    PVOID lpOutput)
{
    return FlipOverlay(HwDeviceExtension, pFlipOverlayInfo, lpOutput);
}


/*++

Routine Description:

    This function is called when "bob" is used and a VPORT VSYNC occurs
    that does not cause a flip to occur (e.g., bobbing while interleaved).
    When bobbing, the overlay must adjust itself on every VSYNC, so this
    function notifies it of the VSYNCs that it doesn't already know about
    (e.g., VSYNCs that trigger a flip to occur).

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BobNextFieldInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD kmvtBobNextField(
    PVOID HwDeviceExtension,
    PNVP_DDBOBNEXTFIELDINFO pBobNextFieldInfo,
    PVOID lpOutput)
{
    return BobNextField(HwDeviceExtension, pBobNextFieldInfo, lpOutput);
}

/*++

Routine Description:

    This function is called when the client wants to switch from bob to
    weave.  The overlay flags indicate which state to use.  This is only
    called for interleaved surfaces.

    Note that when this is called, the specified surface may not be
    displaying the overlay (due to a flip).  Instead of failing the call,
    change the bob/weave state for the overlay that would be used if the
    overlay was flipped again to the specified surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    SetStateInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD kmvtSetState(
    PVOID HwDeviceExtension,
    PNVP_DDSETSTATEININFO pSetStateInInfo,
    PNVP_DDSETSTATEOUTINFO pSetStateOutInfo)
{
    return SetState(HwDeviceExtension, pSetStateInInfo, pSetStateOutInfo);
}


/*++

Routine Description:

    This function is called when the client wants to skip the next field,
    usually to undo a 3:2 pulldown but also for decreasing the frame
    rate.  The driver should not lose the VBI lines if dwVBIHeight contains
    a valid value.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    SkipNextFieldInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD kmvtSkipNextField(
    PVOID HwDeviceExtension,
    PNVP_DDSKIPNEXTFIELDINFO pSkipNextFieldInfo,
    PVOID lpOutput)
{
    return SkipNextField(HwDeviceExtension, pSkipNextFieldInfo, lpOutput);
}


/*++

Routine Description:

    This function returns the polarity of the current field being written
    to the specified video port.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetPolarityInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD kmvtGetPolarity(
    PVOID HwDeviceExtension,
    PDDGETPOLARITYININFO pGetPolarityInInfo,
    PDDGETPOLARITYOUTINFO pGetPolarityOutInfo)
{
    return GetPolarity(HwDeviceExtension, pGetPolarityInInfo, pGetPolarityOutInfo);
}

/*++

Routine Description:

    This function returns the current surface receiving data from the
    video port while autoflipping is taking place.  Only called when
    hardware autoflipping.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetCurrentAutoflipInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD kmvtGetCurrentAutoflip(
    PVOID HwDeviceExtension,
    PNVP_DDGETCURRENTAUTOFLIPININFO pGetCurrentAutoflipInInfo,
    PNVP_DDGETCURRENTAUTOFLIPOUTINFO pGetAutoFlipInfoOut)
{

    return GetCurrentAutoflip(HwDeviceExtension, pGetCurrentAutoflipInInfo, pGetAutoFlipInfoOut);
}


/*++

Routine Description:

    This function returns the current surface receiving data from the
    video port while autoflipping is taking place.  Only called when
    hardware autoflipping.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetPreviousAutoflipInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD kmvtGetPreviousAutoflip(
    PVOID HwDeviceExtension,
    PNVP_DDGETPREVIOUSAUTOFLIPININFO pGetAutoflipInInfo,
    PNVP_DDGETPREVIOUSAUTOFLIPOUTINFO pGetAutoFlipInfoOut)
{
    return GetPreviousAutoflip(HwDeviceExtension, pGetAutoflipInInfo, pGetAutoFlipInfoOut);
}


DWORD kmvtTransfer(
	PVOID pContext, 
	PNVP_DDTRANSFERININFO pInInfo, 
	PNVP_DDTRANSFEROUTINFO pOutInfo)
{
	return NVPTransfer(pContext, pInInfo, pOutInfo);
}

DWORD kmvtGetTransferStatus(
	PVOID pContext, 
	PVOID pNotUsed, 
	PNVP_DDGETTRANSFEROUTINFO pOutInfo)
{
	return NVPGetTransferStatus(pContext, NULL, pOutInfo);
}

DWORD kmvtLockSurface(
    PVOID HwDeviceExtension,
    PNVP_DDLOCKININFO pLockInfoIn, 
    PNVP_DDLOCKOUTINFO pLockInfoOut)
{
    return LockSurface(HwDeviceExtension, pLockInfoIn, pLockInfoOut);
}

DWORD kmvtNVPCallbackDxApi(PVOID *pContext, DWORD dwIRQSource)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION) pContext;
    PDX_IRQDATA pIRQData;
	
	// can we pass on the interrupt !
	if (pHwDevExt->IRQCallback)
	{
		pIRQData = (PDX_IRQDATA)(pHwDevExt->pIRQData);
		pIRQData->dwIrqFlags |= dwIRQSource;
		((PDX_IRQCALLBACK)(pHwDevExt->IRQCallback))(pIRQData);
	}

    return 0;
}

VOID
NVInterfaceReference(
    IN PVOID pContext)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION) pContext;

    //
    // Increment the I2C interface reference count
    //
    hwDeviceExtension->I2C_Reference_Count++;

    return;
}

VOID
NVInterfaceDereference(
    IN PVOID pContext)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = (PHW_DEVICE_EXTENSION) pContext;

    //
    // Decrement the I2C interface reference count
    //
    hwDeviceExtension->I2C_Reference_Count--;

    return;
}

/*++

Routine Description:

    Generic method for obtaining interfaces from the miniport.

    Among other things, it's used for exporting the DXAPI "kernel-mode
    VPE" interface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    QueryInterface - Pointer to structure that describes the requested
        interface.

Return Value:

    DX_OK if successful.

--*/
VP_STATUS NVQueryInterface(
    PVOID HwDeviceExtension,
    PQUERY_INTERFACE QueryInterface)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS status = NO_ERROR;
    ULONG HwID;

    if (IsEqualGUID(QueryInterface->InterfaceType, &GUID_DxApi)) 
    {
        PDXAPI_INTERFACE DxApiInterface;
        DxApiInterface = (PDXAPI_INTERFACE) QueryInterface->Interface;

        //
        // We are queried here for our "kernel-mode VPE" support only after
        // the display driver has already enabled VPE.  Consequently, we let
        // the display driver control what chips VPE is enabled on -- we
        // don't have to do that here.
        //

        DxApiInterface->Size    = sizeof(DXAPI_INTERFACE);
        DxApiInterface->Version = DXAPI_HALVERSION;
        DxApiInterface->Context = hwDeviceExtension;

        DxApiInterface->DxGetIrqInfo          = kmvtGetIrqInfo;
        DxApiInterface->DxEnableIrq           = kmvtEnableIrq;
        DxApiInterface->DxSkipNextField       = kmvtSkipNextField;
        DxApiInterface->DxBobNextField        = kmvtBobNextField;
        DxApiInterface->DxSetState            = kmvtSetState;
        DxApiInterface->DxFlipOverlay         = kmvtFlipOverlay;
        DxApiInterface->DxFlipVideoPort       = kmvtFlipVideoPort;
        DxApiInterface->DxGetPolarity         = kmvtGetPolarity;
        DxApiInterface->DxGetCurrentAutoflip  = kmvtGetCurrentAutoflip;
        DxApiInterface->DxGetPreviousAutoflip = kmvtGetPreviousAutoflip;
        DxApiInterface->DxTransfer            = kmvtTransfer;
        DxApiInterface->DxGetTransferStatus   = kmvtGetTransferStatus;
        DxApiInterface->DxLock                = kmvtLockSurface;
    }
    // I2c Interface
    else if (IsEqualGUID(QueryInterface->InterfaceType, &GUID_I2C_INTERFACE))
    {
        I2CINTERFACE *pI2cInterface;
        pI2cInterface = (I2CINTERFACE *) QueryInterface->Interface;

        if (QueryInterface->Size == sizeof(I2CINTERFACE))
        {    
            //
            // Check to see if we can convert PDO to hardware ID
            //
            if (hwDeviceExtension->pfnVideoPortGetAssociatedDeviceID)
            {
                //
                // Force hardware ID to use dynamic I2C port (0)
                // This allows dual heads to work properly
                //
                HwID = 0;
            }
            else    // Cannot get hardware ID value
            {
                //
                // Switch on the I2C Interface Version
                //
                switch(QueryInterface->Version)
                {
                    case 1:     /* Original I2C interface version */

                        //
                        // Force hardware ID to first external device (NVCAP_I2C_DEVICE_ID)
                        // i.e., assume I2C access is to external device (Secondary)
                        //
                        HwID = NVCAP_I2C_DEVICE_ID;
                        break;

                    case 2:     /* New I2C interface version */

                        //
                        // Check for special PDO value (0 or -1 is primary monitor)
                        //
                        if (((ULONG_PTR) QueryInterface->InterfaceSpecificData == 0) ||
                            ((ULONG_PTR) QueryInterface->InterfaceSpecificData == -1))
                        {
                            //
                            // Force hardware ID to first head DDC monitor
                            //
                            HwID = QUERY_MONITOR_ID;
                        }
                        else    // Regular PDO value
                        {
                            //
                            // Force hardware ID to first external device (NVCAP_I2C_DEVICE_ID)
                            // i.e., assume I2C access is to external device (Secondary)
                            //
                            HwID = NVCAP_I2C_DEVICE_ID;
                        }
                        break;

                    default:    /* Unknown I2C interface version */

                        VideoDebugPrint((1, "QueryInterface: I2C interface size incorrect!\n"));
                        status = ERROR_INVALID_PARAMETER;
                        break;
                }
            }
            //
            // Check for valid I2C interface
            //
            if (status == NO_ERROR)
            {
                //
                // Initialize the interface
                //
                pI2cInterface->_vddInterface.Size = sizeof(I2CINTERFACE);
                pI2cInterface->_vddInterface.Version = QueryInterface->Version;
                pI2cInterface->_vddInterface.Context = HwDeviceExtension;
                pI2cInterface->_vddInterface.InterfaceReference = NVInterfaceReference;
                pI2cInterface->_vddInterface.InterfaceDereference = NVInterfaceDereference;

                //
                // Switch on the I2C port number to use (0 = Dynamic)
                //
                switch(NVGetI2CPort(HwID))
                {
                    case I2C_ACCESS_DYNAMIC_PORT:

                        //
                        // Setup dynamic I2C port routines
                        //
                        pI2cInterface->i2cOpen = (I2COPEN) dynI2COpen;
                        pI2cInterface->i2cAccess = (I2CACCESS) dynI2CAccess;

                        break;

                    case I2C_ACCESS_PRIMARY_PORT:

                        //
                        // Setup primary I2C port routines
                        //
                        pI2cInterface->i2cOpen = (I2COPEN) priI2COpen;
                        pI2cInterface->i2cAccess = (I2CACCESS) priI2CAccess;

                        break;

                    case I2C_ACCESS_SECONDARY_PORT:

                        //
                        // Setup secondary I2C port routines
                        //
                        pI2cInterface->i2cOpen = (I2COPEN) secI2COpen;
                        pI2cInterface->i2cAccess = (I2CACCESS) secI2CAccess;

                        break;
                }
                //
                // Reference the interface before handing it out
                //
                pI2cInterface->_vddInterface.InterfaceReference(pI2cInterface->_vddInterface.Context);
            }
        }
        else    // Invalid I2C Interface Size
        {
            VideoDebugPrint((1, "QueryInterface: I2C interface size incorrect!\n"));
            status = ERROR_INVALID_PARAMETER;
        }
    }
    else
    {
        VideoDebugPrint((1, "QueryInteface: Unsupported Interface\n"));
        status = ERROR_INVALID_PARAMETER;
    }
    return status;
}

#endif // NVPE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvntver.h ===
// nvver.h
//      Versions of NV drivers
//
// Copyright (C) NVidia Corporation 1997.
// Portions Copyright 1993,1996 NVidia Corporation. All Rights Reserved.
//

//
// This is the version number for the build. This is the only string which needs
// to be modified to bump the version number.
//
#include "nvver.h"
#define NV_VER                      NV_VERSION_STRING

//
// Common strings used in all binaries.
//
#ifdef VER_COMPANYNAME_STR
#undef VER_COMPANYNAME_STR
#endif

//
// MS build/version number for WHQL compliance - NT4
//
#ifdef VER_PRODUCTBUILD_QFE
#undef VER_PRODUCTBUILD_QFE
#endif
#define VER_PRODUCTBUILD_QFE NV_DRIVER_VERSION

//
// MS build/version number for WHQL compliance - Win2K.
//
#if (_WIN32_WINNT > 0x0400)

#ifdef VER_PRODUCTBUILD
#undef VER_PRODUCTBUILD
#endif
#define VER_PRODUCTBUILD 01

#ifdef VER_PRODUCTBUILD_QFE
#undef VER_PRODUCTBUILD_QFE
#endif
#define VER_PRODUCTBUILD_QFE NV_DRIVER_VERSION

#ifdef VER_PRODUCTVERSION_STRING
#undef VER_PRODUCTVERSION_STRING
#endif
#define VER_PRODUCTVERSION_STRING "5.13"

#ifdef VER_PRODUCTVERSION
#undef VER_PRODUCTVERSION
#endif
#define VER_PRODUCTVERSION 5,13,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE

#ifdef VER_PRODUCTVERSION_W
#undef VER_PRODUCTVERSION_W
#endif
#define VER_PRODUCTVERSION_W (0x0513)

#ifdef VER_PRODUCTVERSION_DW
#undef VER_PRODUCTVERSION_DW
#endif
#define VER_PRODUCTVERSION_DW (0x05130000 | VER_PRODUCTBUILD)

#endif  //Win2K

#define VER_COMPANYNAME_STR         NV_COMPANY_NAME_STRING
#define VER_LEGALCOPYRIGHT_STR      "Copyright  NVIDIA Corp. 1996-2001"

//
// Strings used in the miniport driver.
//
#define NV_MINI_VER  NV_NTMINIVER
#define NV_MINI_NAME NV_NTMINIVER

//
// Strings used in the display driver.
//
#define NV_DISP_VER  NV_NTDISPVER
#define NV_DISP_NAME NV_NTDISPVER


//
// This hackery is only necessary for NT4, since the NT4 DDK version
// files expect VER_PRODUCTVERSION_STR to be the version number.
//
#if (_WIN32_WINNT < 0x0500)
#if     (VER_PRODUCTBUILD < 10)
#define VER_BPAD "000"
#elif   (VER_PRODUCTBUILD < 100)
#define VER_BPAD "00"
#elif   (VER_PRODUCTBUILD < 1000)
#define VER_BPAD "0"
#else
#define VER_BPAD
#endif

#define VER_PRODUCTVERSION_STRING "4.00"
#define VER_PRODUCTVERSION_STR2(x,y) VER_PRODUCTVERSION_STRING "." VER_BPAD #x "." #y
#define VER_PRODUCTVERSION_STR1(x,y) VER_PRODUCTVERSION_STR2(x, y)

#ifdef VER_PRODUCTVERSION_STR
#undef VER_PRODUCTVERSION_STR
#endif

#define VER_PRODUCTVERSION_STR VER_PRODUCTVERSION_STR1(VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvntioctl.h ===
// NT client IOCTLs

// NV graphics device driver string
#define NVRM_NAME_STRING L"\\Device\\nvgfx"
#define NVRM_LINK_STRING L"\\DosDevices\\nvgfx"

// device type and base control code
#define FILE_DEVICE_NVRM    0x00008000
#define NVRM_IOCTL_INDEX    0x00000800
#define NV_IOCTL_CODE(f)            \
    CTL_CODE(                       \
        FILE_DEVICE_NVRM+(f),       \
        NVRM_IOCTL_INDEX,           \
        METHOD_BUFFERED,            \
        FILE_ANY_ACCESS             \
    )

// control codes
#define IOCTL_NV01_ALLOC_ROOT           NV_IOCTL_CODE(NV01_ALLOC_ROOT)
#define IOCTL_NV01_ALLOC_DEVICE         NV_IOCTL_CODE(NV01_ALLOC_DEVICE)
#define IOCTL_NV01_ALLOC_CONTEXT_DMA    NV_IOCTL_CODE(NV01_ALLOC_CONTEXT_DMA)
#define IOCTL_NV01_ALLOC_CHANNEL_PIO    NV_IOCTL_CODE(NV01_ALLOC_CHANNEL_PIO)
#define IOCTL_NV03_ALLOC_CHANNEL_DMA    NV_IOCTL_CODE(NV03_ALLOC_CHANNEL_DMA)
#define IOCTL_NV01_ALLOC_MEMORY         NV_IOCTL_CODE(NV01_ALLOC_MEMORY)
#define IOCTL_NV01_ALLOC_OBJECT         NV_IOCTL_CODE(NV01_ALLOC_OBJECT)
#define IOCTL_NV01_ALLOC_EVENT          NV_IOCTL_CODE(NV01_ALLOC_EVENT)
#define IOCTL_NV04_ALLOC                NV_IOCTL_CODE(NV04_ALLOC)
#define IOCTL_NV01_FREE                 NV_IOCTL_CODE(NV01_FREE)
#define IOCTL_NV03_DMA_FLOW_CONTROL     NV_IOCTL_CODE(NV03_DMA_FLOW_CONTROL)
#define IOCTL_NV01_ARCH_HEAP            NV_IOCTL_CODE(NV01_ARCH_HEAP)
#define IOCTL_NV01_CONFIG_VERSION       NV_IOCTL_CODE(NV01_CONFIG_VERSION)
#define IOCTL_NV01_CONFIG_GET           NV_IOCTL_CODE(NV01_CONFIG_GET)
#define IOCTL_NV01_CONFIG_SET           NV_IOCTL_CODE(NV01_CONFIG_SET)
#define IOCTL_NV04_CONFIG_GET_EX        NV_IOCTL_CODE(NV04_CONFIG_GET_EX)
#define IOCTL_NV04_CONFIG_SET_EX        NV_IOCTL_CODE(NV04_CONFIG_SET_EX)
#define IOCTL_NV01_CONFIG_UPDATE        NV_IOCTL_CODE(NV01_CONFIG_UPDATE)
#define IOCTL_NV01_DEBUG_CONTROL        NV_IOCTL_CODE(NV01_DEBUG_CONTROL)
#define IOCTL_NV04_I2C_ACCESS           NV_IOCTL_CODE(NV04_I2C_ACCESS)
#define IOCTL_NV04_DIRECT_METHOD_CALL   NV_IOCTL_CODE(NV04_DIRECT_METHOD_CALL)

#define MAX_AGP_HEAP 0x02000000
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvpekmvt.h ===
/*
==============================================================================

    NVIDIA Corporation, (C) Copyright 
    1996,1997,1998,1999. All rights reserved.

    nvpekmvt.h

    Local definitions used by kernel mode video transport

    Dec 17, 1999

==============================================================================
*/

#ifndef _NVPEKMVT_H
#define _NVPEKMVT_H

typedef unsigned long	DWORD;

#include "dxmini.h"


#ifndef NTSTATUS
typedef LONG NTSTATUS;
#endif
#define PDEVICE_OBJECT	PVOID
#include "i2cgpio.h"

extern ULONG NVGetI2CPort (ULONG HwID);
extern ULONG NVGetI2CHead (ULONG HwID);

extern NTSTATUS dynI2COpen (PDEVICE_OBJECT pDev, ULONG acquire, PI2CControl pI2CCtrl);
extern NTSTATUS dynI2CAccess (PDEVICE_OBJECT pDev, PI2CControl pI2CCtrl);

extern NTSTATUS priI2COpen (PDEVICE_OBJECT pDev, ULONG acquire, PI2CControl pI2CCtrl);
extern NTSTATUS priI2CAccess (PDEVICE_OBJECT pDev, PI2CControl pI2CCtrl);

extern NTSTATUS secI2COpen (PDEVICE_OBJECT pDev, ULONG acquire, PI2CControl pI2CCtrl);
extern NTSTATUS secI2CAccess (PDEVICE_OBJECT pDev, PI2CControl pI2CCtrl);

/// redefinition/re-mapping of some KMVT data structures so that we can share same code with Win9x
typedef VOID (*PNVP_DX_IRQCALLBACK)(void);

typedef DDVIDEOPORTDATA              * PNVP_DDVIDEOPORTDATA;
typedef DDSKIPNEXTFIELDINFO          * PNVP_DDSKIPNEXTFIELDINFO;
typedef DDBOBNEXTFIELDINFO           * PNVP_DDBOBNEXTFIELDINFO;
typedef DDSETSTATEININFO             * PNVP_DDSETSTATEININFO;
typedef DDSETSTATEOUTINFO            * PNVP_DDSETSTATEOUTINFO;
typedef DDLOCKININFO                 * PNVP_DDLOCKININFO;
typedef DDLOCKOUTINFO                * PNVP_DDLOCKOUTINFO;
typedef DDFLIPOVERLAYINFO            * PNVP_DDFLIPOVERLAYINFO;
typedef DDFLIPVIDEOPORTINFO          * PNVP_DDFLIPVIDEOPORTINFO;
typedef DDGETPOLARITYININFO          * PNVP_DDGETPOLARITYININFO;
typedef DDGETPOLARITYOUTINFO         * PNVP_DDGETPOLARITYOUTINFO;
typedef DDGETCURRENTAUTOFLIPININFO   * PNVP_DDGETCURRENTAUTOFLIPININFO;
typedef DDGETCURRENTAUTOFLIPOUTINFO  * PNVP_DDGETCURRENTAUTOFLIPOUTINFO;
typedef DDGETPREVIOUSAUTOFLIPININFO  * PNVP_DDGETPREVIOUSAUTOFLIPININFO;
typedef DDGETPREVIOUSAUTOFLIPOUTINFO * PNVP_DDGETPREVIOUSAUTOFLIPOUTINFO;
typedef DDTRANSFERININFO             * PNVP_DDTRANSFERININFO;
typedef DDTRANSFEROUTINFO            * PNVP_DDTRANSFEROUTINFO;
typedef DDGETTRANSFERSTATUSOUTINFO   * PNVP_DDGETTRANSFEROUTINFO;

/////////////////
// prototypes
//
DWORD GetIrqInfo(
    PVOID HwDeviceExtension,
    PVOID lpInput,
    PDDGETIRQINFO GetIrqInfo);

VP_STATUS NVQueryInterface(
    PVOID HwDeviceExtension,
    PQUERY_INTERFACE QueryInterface);

/// external, defined in nvpecore.c
DWORD FlipVideoPort(
    PVOID HwDeviceExtension,
    PNVP_DDFLIPVIDEOPORTINFO pFlipVideoPort,
    PVOID lpOutput);
DWORD FlipOverlay(
    PVOID HwDeviceExtension,
    PNVP_DDFLIPOVERLAYINFO pFlipOverlayInfo,
    PVOID lpOutput);
DWORD BobNextField(
    PVOID HwDeviceExtension,
    PNVP_DDBOBNEXTFIELDINFO pBobNextFieldInfo,
    PVOID lpOutput);
DWORD SetState(
    PVOID HwDeviceExtension,
    PNVP_DDSETSTATEININFO pSetStateInInfo,
    PNVP_DDSETSTATEOUTINFO pSetStateOutInfo);
DWORD SkipNextField(
    PVOID HwDeviceExtension,
    PNVP_DDSKIPNEXTFIELDINFO pSkipNextFieldInfo,
    PVOID lpOutput);
DWORD GetPolarity(
    PVOID HwDeviceExtension,
    PDDGETPOLARITYININFO pGetPolarityInInfo,
    PDDGETPOLARITYOUTINFO pGetPolarityOutInfo);
DWORD GetCurrentAutoflip(
    PVOID HwDeviceExtension,
    PNVP_DDGETCURRENTAUTOFLIPININFO pGetCurrentAutoflipInInfo,
    PNVP_DDGETCURRENTAUTOFLIPOUTINFO pGetAutoFlipInfoOut);
DWORD GetPreviousAutoflip(
    PVOID HwDeviceExtension,
    PNVP_DDGETPREVIOUSAUTOFLIPININFO pGetAutoflipInInfo,
    PNVP_DDGETPREVIOUSAUTOFLIPOUTINFO pGetAutoFlipInfoOut);
DWORD NVPTransfer(
	PVOID pContext, 
	PNVP_DDTRANSFERININFO pInInfo, 
	PNVP_DDTRANSFEROUTINFO pOutInfo);
DWORD NVPGetTransferStatus(
	PVOID pContext, 
	PVOID pNotUsed, 
	PNVP_DDGETTRANSFEROUTINFO pOutInfo);

DWORD LockSurface(
    PVOID HwDeviceExtension,
    PNVP_DDLOCKININFO pLockInfoIn, 
    PNVP_DDLOCKOUTINFO pLockInfoOut);

#endif // _NVPEKMVT_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvpeos.c ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1999 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/

/*
==============================================================================

    NVIDIA Corporation, (C) Copyright 
    1993-1999. All rights reserved.

    nvpeos.c

    VPE kernel wrappers to OS or RM dependent services

    Dec 17, 1999

==============================================================================
*/
#ifdef NVPE

#ifdef _WIN32_WINNT
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"
#endif

#include "nvos.h"
#include "nvpeos.h"

#ifdef DBG
U032 DbgPrint(U008 *pchFormat, ...);
#endif // DBG

U032 osNVPAllocDmaBuffer(
	void *pContext, 
	U032 dwSize, 
	void **pBuffer)
{
	return (U032)VideoPortAllocateBuffer(pContext, dwSize, pBuffer);
}

void osNVPReleaseDmaBuffer(
	void *pContext, 
	void *pBuffer)
{
	VideoPortReleaseBuffer(pContext, pBuffer);
}

void osNVPClearEvent(void *hEvent)
{
	KeClearEvent(hEvent);
}

U032 osNVPSetEvent(void *hEvent)
{
	return KeSetEvent(hEvent, NULL, FALSE);
}

U032 rmNVPAllocContextDma(
    U032 hClient,
    U032 hDma,
    U032 hClass,
    U032 flags,
    U032 selector,
    U032 base,
    U032 limit)
{
	return RmAllocContextDma(hClient, hDma, hClass, flags, selector, base, limit);
}

U032 rmNVPAllocChannelDma(
	U032 hClient,
	U032 hDevice,
	U032 hDmaChannel,
	U032 hClass,
	U032 hErrorContext,
	U032 hDataContext,
	U032 offset,
	U032 *ppControl)
{
	return RmAllocChannelDma(hClient, hDevice, hDmaChannel, hClass, hErrorContext, hDataContext, offset, ppControl);
}

U032 rmNVPAllocObject(
	U032 hClient,
	U032 hChannel,
	U032 hObject,
	U032 hClass)
{
	return RmAllocObject(hClient, hChannel, hObject, hClass);

}

U032 rmNVPAllocEvent(
	NVOS10_PARAMETERS *pEvent)
{
	Nv01AllocEvent(pEvent);
	return 0;
}

U032 rmNVPAlloc(
    U032 hClient,
    U032 hChannel,
    U032 hObject,
    U032 hClass,
    PVOID pAllocParms)
{

    return RmAlloc(hClient, hChannel, hObject, hClass, pAllocParms);

}

U032 rmNVPFree(
	U032 hClient,
	U032 hParent,
	U032 hObject)
{
	return RmFree(hClient, hParent, hObject);
}

#ifdef DBG

VOID osDbgPrintString
(
    int debuglevel,
    char* string
)
{
    if (debuglevel >= cur_debuglevel)
    {
        // print formatted string, for checked build
        DbgPrint(string);
    }
}

VOID osDbgPrintStringValue
(
    int debuglevel,
    char *string,
    int value
)
{
    if (debuglevel >= cur_debuglevel)
    {
        // print string and hex value, for checked build
        DbgPrint("%s 0x%x\n", string, value);

    }
}

#endif // DBG

#endif // NVPE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvpeos.h ===
#ifndef _NVPEOS_H
#define _NVPEOS_H

///////////
// external services
//
extern void KeClearEvent(void *hEvent);
extern U032 KeSetEvent(void *hEvent, void *Increment, U032 Wait);
extern U032 RmAllocChannelDma(U032, U032, U032,	U032, U032,	U032, U032,	U032 *);
extern U032 RmAllocObject(U032, U032, U032, U032);
extern U032 RmFree(U032, U032, U032);
extern U032 RmAllocContextDma(U032, U032, U032, U032, U032, U032, U032);
extern U032 Nv01AllocEvent(NVOS10_PARAMETERS *);
extern U032 RmAlloc(U032, U032, U032, U032, VOID *);

#if DBG

extern int cur_debuglevel;

// Debug level values
#define DEBUGLEVEL_TRACEINFO    0     // For informational debug trace info
#define DEBUGLEVEL_SETUPINFO    1     // For informational debug setup info
#define DEBUGLEVEL_USERERRORS   2     // For debug info on app level errors
#define DEBUGLEVEL_WARNINGS     3     // For RM debug warning info
#define DEBUGLEVEL_ERRORS       4     // For RM debug error info

VOID osDbgPrintString(int, char*);
VOID osDbgPrintStringValue(int, char*, int);

#define DBG_PRINT_STRING(d,s)           osDbgPrintString((d),(s))
#define DBG_PRINT_STRING_VALUE(d,s,v)   osDbgPrintStringValue((d),(s),(v))

#else

#define DBG_PRINT_STRING(d,s)
#define DBG_PRINT_STRING_VALUE(d,s,v)

#endif // DBG

// local prototypes
U032 osNVPAllocDmaBuffer(void *pContext,U032 dwSize,void **pBuffer);
void osNVPReleaseDmaBuffer(void *pContext,void *pBuffer);
void osNVPClearEvent(void *hEvent);
U032 osNVPSetEvent(void *hEvent);
U032 rmNVPAllocContextDma(U032 hClient,U032 hDma,U032 hClass,U032 flags,U032 selector,U032 base,U032 limit);
U032 rmNVPAllocChannelDma(U032 hClient,U032 hDevice,U032 hDmaChannel,U032 hClass,U032 hErrorContext,U032 hDataContext,U032 offset,U032 *ppControl);
U032 rmNVPAllocObject(U032 hClient,U032 hChannel,U032 hObject,U032 hClass);
U032 rmNVPAllocEvent(NVOS10_PARAMETERS *pEvent);
U032 rmNVPFree(U032 hClient,U032 hParent,U032 hObject);
U032 rmNVPAlloc(U032 hClient, U032 hChannel, U032 hObject, U032 hClass, PVOID pAllocParms);

#endif // _NVPEOS_H
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvrm.h ===
#ifndef _NVRM_H_
#define _NVRM_H_
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/**************** Resource Manager Defines and Structures ******************\
*                                                                           *
* Module: NVRM.H                                                            *
*       Resource Manager defines and structures used throughout the code.   *
*                                                                           *
*****************************************************************************
*                                                                           *
* History:                                                                  *
*       David Schmenk (dschmenk)    11/22/93 - wrote it.                    *
*       David Schmenk (dschmenk)    07/06/94 - rewrote it.                  *
*                                                                           *
\***************************************************************************/

//---------------------------------------------------------------------------
//
//  Version number of files built using this header file.
//
//  The format of this is 0x00010206, where
//   - 0x0001 is the chip architecture
//   -   0x02 is the software release
//   -   0x06 is the minor revision
//
//---------------------------------------------------------------------------

#define NVRM_VERSION    0x00030200

//---------------------------------------------------------------------------
//  define some inline assembly instructions

#ifdef __WATCOMC__

void my_sti();
#pragma aux my_sti = \
    "pushf" \
    "sti";

void my_cli();
#pragma aux my_cli =  \
    "popf";

#else   // if not Watcom, its the Microsoft compiler

#define my_sti \
    _asm    pushf   \
    _asm    sti
#define my_cli \
    __asm   popf

#endif  // _WATCOMC_

//---------------------------------------------------------------------------
//
//  NVidia data types.
//
//---------------------------------------------------------------------------

#ifdef NTRM
#include <nvtypes.h>
#endif

#ifndef NVTYPES_INCLUDED
typedef unsigned char   U008;
typedef unsigned short  U016;
typedef unsigned long   U032;
typedef double          U064;

typedef unsigned char   V008;
typedef unsigned short  V016;
typedef unsigned long   V032;
typedef double          V064;

typedef signed char     S008;
typedef signed short    S016;
typedef signed long     S032;
typedef double          S064;
#endif
//
// Fixed point math types and macros.
//
typedef signed long     S016d016;
typedef unsigned long   U016d016;
typedef signed long     S008d024;
typedef unsigned long   U008d024;
typedef signed long     S012d020;
typedef unsigned long   U012d020;

#define FIX16_POINT             16
#define FIX16_SCALE             ((U032)1<<FIX16_POINT)
#define FIX16_INT_MASK          ((U032)~0<<FIX16_POINT)
#define FIX16_FRAC_MASK         (~FIX16_INT_MASK)
#define FIX16_INT(f)            ((f)>>FIX16_POINT)
#define FIX16_FRAC(f)           ((f)&FIX16_FRAC_MASK)
#define INT_FIX16(f)            ((f)<<FIX16_POINT)
#define FIX16(i)                (S016d016)((i)*FIX16_SCALE))
#define FIX16_MUL(f1,f2)        ((FIX16_INT(f1)*FIX16_INT(f2)<<FIX16_POINT)     \
                                +(FIX16_INT(f1)*FIX16_FRAC(f2))                 \
                                +(FIX16_FRAC(f1)*FIX16_INT(f2))                 \
                                +(FIX16_FRAC(f1)*FIX16_FRAC(f2)>>FIX16_POINT))
#define FIX16_DIV(f1,f2)        (((f1)<<(FIX16_POINT/2))/((f2)>>(FIX16_POINT/2)))
#define FIX16_DIVI(f1,f2)       ((f1)/((f2)>>(FIX16_POINT)))
#define FIX16_IDIV(f1,f2)       (((f1)<<(FIX16_POINT))/(f2))
#define FIX24_POINT             24
#define FIX24_SCALE             ((U032)1<<FIX24_POINT)
#define FIX24_INT_MASK          ((U032)~0<<FIX24_POINT)
#define FIX24_FRAC_MASK         (~FIX24_INT_MASK)
#define FIX24_TO_INT(f)         ((f)>>FIX24_POINT)
#define FIX24(i)                ((S008d024)((i)*FIX24_SCALE))
#define FIX24_MUL(f1,f2)        (((f1)>>(FIX24_POINT/2))*((f2)>>(FIX24_POINT/2)))
#define FIX24_DIV(f1,f2)        (((f1)<<(FIX24_POINT/2))/((f2)>>(FIX24_POINT/2)))
#define FIX24_DIVI(f1,f2)       ((f1)/((f2)>>(FIX24_POINT)))
#define FIX24_IDIV(f1,f2)       (((f1)<<(FIX24_POINT))/(f2))

//---------------------------------------------------------------------------
//
//  Common types.
//
//---------------------------------------------------------------------------

#ifndef VOID
#define VOID            void
#endif
#ifndef BOOL
#define BOOL            S032
#endif
#ifndef TRUE
#define TRUE            ~0
#endif
#ifndef FALSE
#define FALSE           0
#endif
#ifndef NULL
#define NULL            0L
#endif
    
//---------------------------------------------------------------------------
//
//  Error codes.
//
//---------------------------------------------------------------------------

//
// External codes.
//
#define NV_ERROR_1                      0x0100
#define NV_TYPE_CONFLICT                (0x01|NV_ERROR_1)
#define NV_OUT_OF_RANGE                 (0x02|NV_ERROR_1)
#define NV_NO_CONNECTION                (0x03|NV_ERROR_1)
#define NV_NO_SUCH_OBJECT               (0x04|NV_ERROR_1)
#define NV_NAME_IN_USE                  (0x05|NV_ERROR_1)
#define NV_OUT_OF_RESOURCES             (0x06|NV_ERROR_1)
#define NV_TRANSLATION_VIOLATION        (0x07|NV_ERROR_1)
#define NV_PROTECTION_VIOLATION         (0x08|NV_ERROR_1)
#define NV_BUFFER_BUSY                  (0x09|NV_ERROR_1)
#define NV_ILLEGAL_ACCESS               (0x0A|NV_ERROR_1)
#define NV_BAD_COLORMAP_FORMAT          (0x0B|NV_ERROR_1)
#define NV_BAD_COLOR_FORMAT             (0x0C|NV_ERROR_1)
#define NV_BAD_MONOCHROME_FORMAT        (0x0D|NV_ERROR_1)
#define NV_BAD_PATTERN_SHAPE            (0x0E|NV_ERROR_1)
#define NV_BAD_SUBDIVIDE                (0x0F|NV_ERROR_1)
#define NV_NO_CURRENT_POINT             (0x10|NV_ERROR_1)
#define NV_BAD_AUDIO_FORMAT             (0x11|NV_ERROR_1)
#define NV_NO_DMA_TRANSLATION           (0x12|NV_ERROR_1)
#define NV_INCOMPLETE_METHOD            (0x13|NV_ERROR_1)
#define NV_RESERVED_ADDRESS             (0x14|NV_ERROR_1)
#define NV_UNIMPLEMENTED_PATCH          (0x15|NV_ERROR_1)
#define NV_OS_NAME_ERROR                (0x16|NV_ERROR_1)
#define NV_INCOMPLETE_PATCH             (0x17|NV_ERROR_1)
#define NV_BUFFERGAP_ERROR              (0x18|NV_ERROR_1)
#define NV_FIFO_OVERFLOW                (0x19|NV_ERROR_1)
//
// Internal codes.
//
typedef U032 RM_STATUS;
#define NUM_RM_ERRORS                   22
#define RM_OK                           0x00000000
#define RM_ERROR                        0xFFFFFFFF
#define RM_WARN_NULL_OBJECT             (0x10000000|RM_OK)
#define RM_WARN_AUDIO_DISABLED          (0x20000000|RM_OK)
#define RM_WARN_GRAPHICS_DISABLED       (0x30000000|RM_OK)
#define RM_ERR_NO_FREE_MEM              (0x01000000|NV_OUT_OF_RESOURCES)
#define RM_ERR_MEM_NOT_FREED            (0x01010000|NV_OUT_OF_RESOURCES)
#define RM_ERR_PAGE_TABLE_NOT_AVAIL     (0x01020000|NV_OUT_OF_RESOURCES)
#define RM_ERR_NO_FREE_FIFOS            (0x02000000|NV_OUT_OF_RESOURCES)
#define RM_ERR_CANT_CREATE_CLASS_OBJS   (0x02010000|NV_OUT_OF_RESOURCES)
#define RM_ERR_BAD_OBJECT               (0x03000000|NV_NO_SUCH_OBJECT)
#define RM_ERR_INSERT_DUPLICATE_NAME    (0x03010000|NV_NAME_IN_USE)
#define RM_ERR_OBJECT_NOT_FOUND         (0x03020000|NV_NO_SUCH_OBJECT)
#define RM_ERR_CREATE_BAD_CLASS         (0x04000000|NV_NO_SUCH_OBJECT)
#define RM_ERR_DELETE_BAD_CLASS         (0x04010000|NV_NO_SUCH_OBJECT)
#define RM_ERR_FIFO_RUNOUT_OVERFLOW     (0x05000000|NV_FIFO_OVERFLOW)
#define RM_ERR_FIFO_BAD_ACCESS          (0x05010000|NV_RESERVED_ADDRESS)
#define RM_ERR_FIFO_OVERFLOW            (0x05020000|NV_FIFO_OVERFLOW)
#define RM_ERR_METHOD_ORDER             (0x06000000|NV_INCOMPLETE_METHOD)
#define RM_ERR_METHOD_COUNT             (0x06010000|NV_INCOMPLETE_METHOD)
#define RM_ERR_ILLEGAL_OBJECT           (0x06020000|NV_TYPE_CONFLICT)
#define RM_ERR_DMA_IN_USE               (0x07000000|NV_BUFFER_BUSY)
#define RM_ERR_BAD_DMA_SPECIFIER        (0x07010000|NV_TRANSLATION_VIOLATION)
#define RM_ERR_INVALID_XLATE            (0x07020000|NV_TRANSLATION_VIOLATION)
#define RM_ERR_INVALID_START_LENGTH     (0x07030000|NV_PROTECTION_VIOLATION)
#define RM_ERR_DMA_MEM_NOT_LOCKED       (0x07040000|NV_OUT_OF_RESOURCES)
#define RM_ERR_DMA_MEM_NOT_UNLOCKED     (0x07050000|NV_OUT_OF_RESOURCES)
#define RM_ERR_NOTIFY_IN_USE            (0x07060000|NV_BUFFER_BUSY)
#define RM_ERR_ILLEGAL_ADDRESS          (0x08000000|NV_ILLEGAL_ACCESS)
#define RM_ERR_BAD_ADDRESS              (0x08010000|NV_PROTECTION_VIOLATION)
#define RM_ERR_INVALID_COLOR_FORMAT     (0x09000000|NV_BAD_COLOR_FORMAT)
#define RM_ERR_INVALID_MONO_FORMAT      (0x09010000|NV_BAD_MONOCHROME_FORMAT)
#define RM_ERR_INVALID_AUDIO_FORMAT     (0x09020000|NV_BAD_AUDIO_FORMAT)
#define RM_ERR_INVALID_GAMEPORT_FORMAT  (0x09030000|NV_BAD_AUDIO_FORMAT)
#define RM_ERR_OBJECT_TYPE_MISMATCH     (0x0A000000|NV_TYPE_CONFLICT)
#define RM_ERR_NO_FREE_AUDIO_INSTANCES  (0x0B000000|NV_OUT_OF_RESOURCES)
#define RM_ERR_CODEC_INPUT_IN_USE       (0x0B010000|NV_OUT_OF_RESOURCES)
#define RM_ERR_AUDIO_DISABLED           (0x0B020000|NV_OUT_OF_RESOURCES)
#define RM_ERR_INCOMPLETE_PATCH         (0x0C000000|NV_INCOMPLETE_PATCH)
#define RM_ERR_INVALID_PATCH            (0x0C010000|NV_UNIMPLEMENTED_PATCH)
#define RM_ERR_PATCH_TOO_COMPLEX        (0x0C020000|NV_UNIMPLEMENTED_PATCH)
#define RM_ERR_MAX_PATCH_FANOUT         (0x0C030000|NV_UNIMPLEMENTED_PATCH)
#define RM_ERR_DEVICE_DISCONNECTED      (0x0C040000|NV_NO_CONNECTION)
#define RM_ERR_BUFFER_GAP               (0x0D000000|NV_BUFFER_GAP)
#define RM_ERR_INVALID_OS_NAME          (0x0E000000|NV_OS_NAME_ERROR)
#define RM_ERR_ILLEGAL_ACTION           (0x0E010000|NV_OS_NAME_ERROR)
// The DMA direction specified for the DMA object is not allowed in the
// specified address space.
#define RM_ERR_ILLEGAL_DIRECTION        (0x0E020000|NV_OS_NAME_ERROR)
#define RM_ERR_OUT_OF_TIMER_CALLBACKS   (0x0F000000|NV_OUT_OF_RESOURCES)
//
// NV Reference Manual register access definitions.
//
#define BIT(b)                  (1<<(b))
#define DEVICE_BASE(d)          (0?d)
#define DEVICE_EXTENT(d)        (1?d)
#define DRF_SHIFT(drf)          ((0?drf) % 32)
#define DRF_MASK(drf)           (0xFFFFFFFF>>(31-((1?drf) % 32)+((0?drf) % 32)))
#define DRF_DEF(d,r,f,c)        ((NV ## d ## r ## f ## c)<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_NUM(d,r,f,n)        (((n)&DRF_MASK(NV ## d ## r ## f))<<DRF_SHIFT(NV ## d ## r ## f))
#define DRF_VAL(d,r,f,v)        (((v)>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))
#define REG_WR_DRF_NUM(d,r,f,n) REG_WR32(NV ## d ## r, DRF_NUM(d,r,f,n))
#define REG_WR_DRF_DEF(d,r,f,c) REG_WR32(NV ## d ## r, DRF_DEF(d,r,f,c))
#define FLD_WR_DRF_NUM(d,r,f,n) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_NUM(d,r,f,n))
#define FLD_WR_DRF_DEF(d,r,f,c) REG_WR32(NV##d##r,(REG_RD32(NV##d##r)&~(DRF_MASK(NV##d##r##f)<<DRF_SHIFT(NV##d##r##f)))|DRF_DEF(d,r,f,c))
#define REG_RD_DRF(d,r,f)       (((REG_RD32(NV ## d ## r))>>DRF_SHIFT(NV ## d ## r ## f))&DRF_MASK(NV ## d ## r ## f))
//
// NV Reference Manual instance memory structure access definitions.
//
#define INST_WR32(i,o,d)        MEM_WR32(DEVICE_BASE(NV_PRAMIN)+((i)<<4)+(o),(d))
#define INST_RD32(i,o)          MEM_RD32(DEVICE_BASE(NV_PRAMIN)+((i)<<4)+(o))
#define SF_OFFSET(sf)           (((0?sf)/32)<<2)
#define SF_SHIFT(sf)            ((0?sf)&31)
#undef  SF_MASK
#define SF_MASK(sf)             (0xFFFFFFFF>>(31-(1?sf)+(0?sf)))
#define SF_DEF(s,f,c)           ((NV ## s ## f ## c)<<SF_SHIFT(NV ## s ## f))
#define SF_NUM(s,f,n)           (((n)&SF_MASK(NV ## s ## f))<<SF_SHIFT(NV ## s ## f))
#define SF_VAL(s,f,v)           (((v)>>SF_SHIFT(NV ## s ## f))&SF_MASK(NV ## s ## f))
#define RAM_WR_ISF_NUM(i,s,f,n) INST_WR32(i,SF_OFFSET(NV ## s ## f),SF_NUM(s,f,n))
#define RAM_WR_ISF_DEF(i,s,f,c) INST_WR32(i,SF_OFFSET(NV ## s ## f),SF_DEF(s,f,c))
#define FLD_WR_ISF_NUM(i,s,f,n) INST_WR32(i,SF_OFFSET(NV##s##f),(INST_RD32(i,SF_OFFSET(NV##s##f))&~(SF_MASK(NV##s##f)<<SF_SHIFT(NV##s##f)))|SF_NUM(s,f,n))
#define FLD_WR_ISF_DEF(i,s,f,c) INST_WR32(i,SF_OFFSET(NV##s##f),(INST_RD32(i,SF_OFFSET(NV##s##f))&~(SF_MASK(NV##s##f)<<SF_SHIFT(NV##s##f)))|SF_DEF(s,f,c))
#define RAM_RD_ISF(i,s,f)       (((INST_RD32(i,SF_OFFSET(NV ## s ## f)))>>SF_SHIFT(NV ## s ## f))&SF_MASK(NV ## s ## f))
//
// EEPROM access macros.
//
#define EEPROM_INDEX_RD08(ii, dd)   \
    {REG_WR32(NV_PEEPROM_CONTROL,DRF_NUM(_PEEPROM,_CONTROL,_ADDRESS,(ii))|DRF_DEF(_PEEPROM,_CONTROL,_COMMAND,_READ));\
    osDelay(1);\
    (dd)=REG_RD32(NV_PEEPROM_CONTROL)&0xFF;}
//
// DevInfo update/finish flags.
//
#define UPDATE_HWINFO_AUDIO_VOLUME             BIT(0)
#define FINISH_HWINFO_AUDIO_VOLUME             BIT(0)
#define UPDATE_HWINFO_AUDIO_NEAR_MARK          BIT(1)
#define FINISH_HWINFO_AUDIO_NEAR_MARK          BIT(1)
#define UPDATE_HWINFO_AUDIO_BLOCK_LENGTH       BIT(2)
#define FINISH_HWINFO_AUDIO_BLOCK_LENGTH       BIT(2)
#define UPDATE_HWINFO_DAC_CURSOR_POS           BIT(0)
#define FINISH_HWINFO_DAC_CURSOR_POS           BIT(0)
#define UPDATE_HWINFO_DAC_CURSOR_IMAGE         BIT(1)
#define FINISH_HWINFO_DAC_CURSOR_IMAGE         BIT(1)
#define UPDATE_HWINFO_DAC_CURSOR_COLOR         BIT(2)
#define FINISH_HWINFO_DAC_CURSOR_COLOR         BIT(2)
#define UPDATE_HWINFO_DAC_COLORMAP             BIT(3)
#define FINISH_HWINFO_DAC_COLORMAP             BIT(3)
#define UPDATE_HWINFO_DAC_CURSOR_ENABLE        BIT(4)
#define FINISH_HWINFO_DAC_CURSOR_ENABLE        BIT(4)
#define UPDATE_HWINFO_DAC_CURSOR_DISABLE       BIT(5)
#define FINISH_HWINFO_DAC_CURSOR_DISABLE       BIT(5)
#define UPDATE_HWINFO_DAC_CURSOR_TYPE          BIT(6)
#define FINISH_HWINFO_DAC_CURSOR_TYPE          BIT(6)
#define UPDATE_HWINFO_DAC_CURSOR_IMAGE_DELAYED BIT(7)
#define FINISH_HWINFO_DAC_CURSOR_IMAGE_DELAYED BIT(7)
#define UPDATE_HWINFO_DAC_DPML                 BIT(8)
#define FINISH_HWINFO_DAC_DPML                 BIT(8)
#define UPDATE_HWINFO_DAC_APLL                 BIT(9)
#define FINISH_HWINFO_DAC_APLL                 BIT(9)
#define UPDATE_HWINFO_DAC_VPLL                 BIT(10)
#define FINISH_HWINFO_DAC_VPLL                 BIT(10)
#define UPDATE_HWINFO_DAC_MPLL                 BIT(11)
#define FINISH_HWINFO_DAC_MPLL                 BIT(11)
#define UPDATE_HWINFO_CODEC_FREQUENCY          BIT(0)
#define FINISH_HWINFO_CODEC_FREQUENCY          BIT(0)
#define UPDATE_HWINFO_CODEC_SOURCE             BIT(1)
#define FINISH_HWINFO_CODEC_SOURCE             BIT(1)
#define UPDATE_HWINFO_CODEC_GAIN               BIT(2)
#define FINISH_HWINFO_CODEC_GAIN               BIT(2)
#define UPDATE_HWINFO_CODEC_PIN_CONTROL        BIT(3)
#define FINISH_HWINFO_CODEC_PIN_CONTROL        BIT(3)
#define UPDATE_HWINFO_BUFFER_FLIP              BIT(0)
#define FINISH_HWINFO_BUFFER_FLIP              BIT(0)
#define UPDATE_HWINFO_BUFFER_PARAMS            BIT(8)
#define FINISH_HWINFO_BUFFER_PARAMS            BIT(8)
#define UPDATE_HWINFO_DISPLAY_PARAMS           BIT(9)
#define FINISH_HWINFO_DISPLAY_PARAMS           BIT(9)
#define UPDATE_HWINFO_REFRESH_PARAMS           BIT(10)
#define FINISH_HWINFO_REFRESH_PARAMS           BIT(10)
#define UPDATE_HWINFO_GAMEPORT                 BIT(0)
#define FINISH_HWINFO_GAMEPORT                 BIT(0)
#define UPDATE_HWINFO_GAMEPORT_START_COUNT     BIT(1)
#define FINISH_HWINFO_GAMEPORT_START_COUNT     BIT(1)
#define UPDATE_HWINFO_GAMEPORT_GET_POSITION    BIT(2)
#define FINISH_HWINFO_GAMEPORT_GET_POSITION    BIT(2)
#define UPDATE_HWINFO_FIFO_LIE                 BIT(0)
#define FINISH_HWINFO_FIFO_LIE                 BIT(0)
#define FINISH_HWINFO_VGA_FIXUP                BIT(0)
#define UPDATE_HWINFO_DGP_3D_ENABLE            BIT(0)
#define FINISH_HWINFO_DGP_3D_ENABLE            BIT(0)
#define UPDATE_HWINFO_VIDEO_ENABLE             BIT(0)
#define FINISH_HWINFO_VIDEO_ENABLE             BIT(0)
#define UPDATE_HWINFO_VIDEO_START              BIT(1)
#define FINISH_HWINFO_VIDEO_START              BIT(1)
#define UPDATE_HWINFO_VIDEO_SIZE               BIT(2)
#define FINISH_HWINFO_VIDEO_SIZE               BIT(2)
#define UPDATE_HWINFO_VIDEO_SCALE              BIT(3)
#define FINISH_HWINFO_VIDEO_SCALE              BIT(3)
#define UPDATE_HWINFO_VIDEO_COLORKEY           BIT(4)
#define FINISH_HWINFO_VIDEO_COLORKEY           BIT(4)
//
// Notification otherInfo defines.
//
#define NOTIFY_INFO16_BUFFER_CHAIN_GAP  1
#define NOTIFY_INFO16_BUFFER_YANK       2
#define NOTIFY_INFO16_BUFFER_LOOP       3

//---------------------------------------------------------------------------
//
// 32 bit debug marker values.
//
//---------------------------------------------------------------------------

// Solaris machines are byte reversed from Intel machines
#ifdef SOLARIS
#define NV_MARKER1 (U032)(('N' << 24) | ('V' << 16) | ('R' << 8) | 'M')
#define NV_MARKER2 (U032)(('M' << 24) | ('R' << 16) | ('V' << 8) | 'N')
#else
#define NV_MARKER1 (U032)(('M' << 24) | ('R' << 16) | ('V' << 8) | 'N')
#define NV_MARKER2 (U032)(('N' << 24) | ('V' << 16) | ('R' << 8) | 'M')
#endif

//---------------------------------------------------------------------------
//
// DevInfo state values.
//
//---------------------------------------------------------------------------

//
// BUS type.
//
#define BUS_PCI                         1
#define BUS_VL                          2
#define BUS_NIRV                        3
#define BUS_AGP                         4
//
// Predefined GART offset in physical memory
//
#define AGP_APERTURE_SIZE               0x2000000       // 32 MB
#define AGP_APERTURE_PHYS_BASE          0xC0000000      // 3 gig
//
// Define the various NV chip ID's
//
#define NV3_REV_A_00                    0x00
#define NV3_REV_B_00                    0x10
#define NV3_REV_C_00                    0x20
//
// SEGA Game Port "DAC Hack" Gate Array ID's.
//
#define DGP_SGP                         1
#define DGP_ASGP                        2
//
// Define CODEC BIOS ID's
//
#define CODEC_AD1848                    0x00000000
#define CODEC_AD1845                    0x00000001
#define CODEC_AD1846                    0x00000002
#define CODEC_CS4248                    0x00000003
#define CODEC_CS4231A                   0x00000004
#define CODEC_ESS1688                   0x00000005
#define CODEC_ESS1788                   0x00000006
#define CODEC_ESS1888                   0x00000007
#define CODEC_ESS1868                   0x00000008
#define CODEC_ADREDCORAL                0x00000009
#define CODEC_OPTI                      0x0000000A
#define CODEC_YAC516                    0x0000000B
#define CODEC_CHRONTEL                  0x0000000C
#define CODEC_YAC701                    0x0000000D
#define CODEC_ID_MASK                   0x00003FFF
#define CODEC_NONE                      0xFFFFFFFF
//
// Define CODEC BIOS Frequency ID's.
//
#define CODEC_FREQ_11KHz                0x00000000
#define CODEC_FREQ_22KHz                0x00004000
#define CODEC_FREQ_44KHz                0x00008000
#define CODEC_FREQ_MASK                 0x0000C000
//
// Define the ever changing CODEC Interface Protocol values.
//
#define CODEC_IP_AD                     0x30
#define CODEC_IP_YAMAHA                 0x40
#define CODEC_IP_ESS                    0xC8
//
// CODEC values.
//
#define CODEC_22KHz                     0x56220000
#define CODEC_44KHz                     0xAC440000 
#define CODEC_48KHz                     0xBB800000
#define NUM_CODEC_INPUTS                4
#define CODEC_INPUT_LINE                0  
#define CODEC_INPUT_MIC                 1  
#define CODEC_INPUT_AUX                 2
#define CODEC_INPUT_AUX1                2
#define CODEC_INPUT_MIX                 3
#define CODEC_INPUT_AUX2                3
#define CODEC_PASSTHRU                  4
#define CODEC_INPUT_GAIN_0DB            0
#define CODEC_INPUT_GAIN_20DB           20
#define CODEC_OUTPUT_ATTEN_0DB          0
#define CODEC_OUTPUT_ATTEN_20DB         20
//
// Framebuffer values.
//
#define BUFFER_DRAM                     0
#define BUFFER_SGRAM                    1
#define BUFFER_DRAM_EDO                 0
#define BUFFER_DRAM_FPM                 1
#define BUFFER_HSYNC_NEGATIVE           0
#define BUFFER_HSYNC_POSITIVE           1
#define BUFFER_VSYNC_NEGATIVE           0
#define BUFFER_VSYNC_POSITIVE           1
#define BUFFER_CSYNC_DISABLED           0
#define BUFFER_CSYNC_ENABLED            1
//
// Dedicated privileged device ram size in bytes.
//
#define NV_PRAM_DEVICE_SIZE_12_KBYTES   0x3000  // 12KB
#define NV_PRAM_DEVICE_SIZE_20_KBYTES  0x5000   // 20KB
#define NV_PRAM_DEVICE_SIZE_36_KBYTES  0x9000   // 36KB             
#define NV_PRAM_DEVICE_SIZE_68_KBYTES  0x11000  // 68KB
//
// NV3's priviliged size, minus audio
//
#define NV_PRAM_DEVICE_SIZE_5_5_KBYTES   0x1600 // 5.5KB
#define NV_PRAM_DEVICE_SIZE_9_5_KBYTES   0x2600 // 9.5KB
#define NV_PRAM_DEVICE_SIZE_17_5_KBYTES  0x4600 // 17.5KB             
#define NV_PRAM_DEVICE_SIZE_33_5_KBYTES  0x8600 // 33.5KB
//
// Offscreen Instance Memory size.
//
#define NV_PRAM_MIN_SIZE_INSTANCE_MEM  0x1000   // 4KB
//
// New states for the SaveToEEPROMEnable flag in nvinfo.framebuffer
//
#define NV_CFG_DISABLE_NON_VOLATILE_STORAGE     0
#define NV_CFG_ENABLE_NON_VOLATILE_STORAGE      0x042
//
// DAC values.
//
#define DAC_CURSOR_DISABLED             0
#define DAC_CURSOR_THREE_COLOR          1
#define DAC_CURSOR_TWO_COLOR_XOR        2
#define DAC_CURSOR_TWO_COLOR            3
#define DAC_CURSOR_FULL_COLOR_XOR       4
#define DAC_CURSOR_FULL_COLOR           5

#define DAC_CURSOR_CACHE_ENTRY          0x80000000
#define DAC_CURSOR_CACHE_DISPLAY        0x40000000

#define MAX_CACHED_CURSORS              5

// For attempting to do Frame locking...

//#define FRAME_LOCK

#ifdef FRAME_LOCK
#define MAXROCKS    (256)
#define LOCKPARAM1  (18)
#define LOCKPARAM2  (4)
#define LOCKLOCATION (50)
#endif //FRAME_LOCK


#define NV3WDMHACK


#ifdef NV3WDMHACK

#define NVWDMHACKDELAY  (45)

#endif // NV3WDMHACK

//
// Video modes.
//
// (keep these around until all rm's os sections are updated)
//
#define NUM_VIDEO_DEPTHS                3
#define VIDEO_DEPTH_8BPP                8
#define VIDEO_DEPTH_15BPP               15
#define VIDEO_DEPTH_30BPP               30
#define NUM_RESOLUTIONS                 16
#define RESOLUTION_576X432              0
#define RESOLUTION_640X400              1
#define RESOLUTION_640X480              2
#define RESOLUTION_800X600              3
#define RESOLUTION_1024X768             4
#define RESOLUTION_1152X864             5
#define RESOLUTION_1280X1024            6
#define RESOLUTION_1600X1200            7
#define RESOLUTION_320X200              8
#define RESOLUTION_320X240              9
#define RESOLUTION_512X384              10
#define RESOLUTION_640X240              11
#define RESOLUTION_400X300              12
#define RESOLUTION_480X360              13
#define RESOLUTION_960X720              14
#define RESOLUTION_320X400              15
//
// Monitor types
//
#define NV_MONITOR_VGA                  0
#define NV_MONITOR_NTSC                 2
#define NV_MONITOR_PAL                  3

// Use the following for monitor types. The ones above are obsolete names.
#define MONITOR_TYPE_VGA                0
#define MONITOR_TYPE_NTSC               2
#define MONITOR_TYPE_PAL                3
#define MONITOR_TYPE_FLAT_PANEL         4

// Use the following for display types. The ones above are obsolete names.
#define DISPLAY_TYPE_MONITOR            0
#define DISPLAY_TYPE_TV                 1
#define DISPLAY_TYPE_DUALSURFACE        2
#define DISPLAY_TYPE_FLAT_PANEL         3


//
// Gamport Info Analog Data Array values.
//
#define NV_GPORT_X_AXIS                 0
#define NV_GPORT_Y_AXIS                 1
#define NV_GPORT_Z_AXIS                 2
#define NV_GPORT_PEDALS                 3
#define NV_GPORT_PEDALS_1               3
#define NV_GPORT_PEDALS_2               4
#define NV_GPORT_THROTTLE               5
#define NV_GPORT_THROTTLE_1             5
#define NV_GPORT_THROTTLE_2             6
//
// Gamport source values.
//
#define GPORT_INPUT_NULL                0x0000
#define GPORT_INPUT_POT                 0x0100
#define GPORT_INPUT_JOYSTICK            0x0200
#define GPORT_INPUT_PEDALS              0x0300
#define GPORT_INPUT_THROTTLE            0x0400
#define GPORT_INPUT_PAD                 0x0500
#define GPORT_INPUT_YOKE                0x0600
#define GPORT_INPUT_POTA                0x0700
#define GPORT_INPUT_GUN                 0x0800
#define GPORT_INPUT_INVALID             0xFF00
#define GPORT_INPUT_SOURCE_MASK         0xFF00
//
// Gamport source port values.
//
#define GPORT_INPUT_PORT_PLAYER1        0
#define GPORT_INPUT_PORT_PLAYER2        1
#define GPORT_INPUT_PORT_PLAYER3        2
#define GPORT_INPUT_PORT_PLAYER4        3
#define GPORT_INPUT_PORT_PLAYER5        4
#define GPORT_INPUT_PORT_PLAYER6        5
#define GPORT_INPUT_PORT_PLAYER7        6
#define GPORT_INPUT_PORT_PLAYER8        7
#define GPORT_INPUT_PORT_PLAYER9        8
#define GPORT_INPUT_PORT_PLAYER10       9
#define GPORT_INPUT_PORT_PLAYER11       10
#define GPORT_INPUT_PORT_PLAYER12       11
#define GPORT_INPUT_PORT_POT            12
#define GPORT_INPUT_PORT_MAX            12
#define GPORT_INPUT_PORT_MASK           0x00FF
//
// Gameport source channel values. 
//
#define GPORT_INPUT_BUTTONS             BIT(0)
#define GPORT_INPUT_X_AXIS              BIT(1)
#define GPORT_INPUT_Y_AXIS              BIT(2)
#define GPORT_INPUT_Z_AXIS              BIT(3)
#define GPORT_INPUT_X_POS               BIT(4)
#define GPORT_INPUT_Y_POS               BIT(5)

//---------------------------------------------------------------------------
//
//  Max number of FIFO channels used.
//
//---------------------------------------------------------------------------

#ifdef RM_MUT
#define NUM_FIFOS                       4
#else
#define NUM_FIFOS                       32
#endif

//---------------------------------------------------------------------------
//
//  Data structures.
//
//---------------------------------------------------------------------------

#include "all_incs.h"

// JJV-MM This is messy ... but it beats including nvhw.h
//
// Device register access array.
//
typedef union _def_HwReg
{
    volatile V008 Reg008[1];
    volatile V016 Reg016[1];
    volatile V032 Reg032[1];
} HWREG, * PHWREG;

//
// A hardware fifo hash table entry.
//
typedef struct _def_HashTableEntry
{
    V032 ht_ObjectHandle;
    V032 ht_Context;
} HASH_TABLE_ENTRY;
         
//
// Device state and configuration information.
//
typedef struct _def_hw_info
{
    struct _def_chip_info
    {
        U032 Size;
        char ID[32];
        U032 SavePmc;
        U032 SaveIntrEn0;
        U032 IntrEn0;
        U032 Implementation;
        U032 Revision;
        U032 Architecture;
        U032 Manufacturer;
        U032 Bus;
        U032 NVAGPEnabled;
        U032 CrystalFreq;
        U032 ChipToken[2];
        U032 ServiceCount;
        U032 ServiceTimeLo;
        U032 ServiceTimeHi;
        U032 ExceptionTimeLo;
        U032 ExceptionTimeHi;
        U032 osStartInterrupt;
    } Chip;
    struct _def_mapping_info
    {
        U032 Size;
        char ID[32];
        U032 PhysAddr;
        U032 PhysFbAddr;
        U032 IntLine;
        U032 IntPin;
        U032 AGPPhysStart;
        U032 AGPLinearStart;
        U032 AGPLimit;
        U032 UpdateFlags;
        U032 FinishFlags;
        //PHWREG nvAddr;                   //***
        //PHWREG romAddr;                  //***
        //PHWREG fbAddr;                   //***
        //PHWREG agpAddr;                  //***
        U032 nvPhys;                       //***
        U032 fbPhys;                       //***
        U032 nvIRQ;                        //***
        U032 dllIpcOffset;                 //***
        U032 dllIpcSelector;               //***
        U032 dllNotifyOffset;              //***
        U032 dllNotifySelector;            //***
                                           //***
        U032 ChipID;                       //***
        //U032 *ApertureTranslationTable;  //***
        U032 hpicIRQ;                      //***
        U032 hDev;                         //***
        U032 osDeviceHandle;               // JJV - This may be the same as the one above ???
    } Mapping;
    struct _def_pram_info
    {
        U032 Size;
        char ID[32];
        U032 ConfigReg;
        U032 HashDepth;
        U032 RunOutMask;
        U032 FreeInstSize;
        U032 FreeInstBase;
        U032 FreeInstMax;
        U032 CurrentSize;
        U032 AvailableSize[4];
        U032 PrivBase;
        U032 UpdateFlags;
        U032 FinishFlags;
        U032 HashTableAddr;
        U032 FifoRunoutAddr;
        U032 FifoContextAddr;
        U032 AudioScratchAddr;
        U032 AuthScratchAddr;
        U032 VideoDmaInstance;
    } Pram;        
    struct _def_dma_info
    {
    
        //PDMAOBJECT DmaList;              //***
        U032       dmaPushPutOffset;       //***
        U032       dmaPushGetOffset;       //***
        U032       dmaPushGetOffsetRead;   //***
        U032       dmaPushJumpOffset;      //***
        U032       dmaPushJumpOffsetSet;   //***
        //PDMAOBJECT VidDmaObject;         //***
    } Dma;        
    struct _def_fifo_info
    {
        U032 Size;
        char ID[32];
        U032 ServiceCount;
        U032 AllocateCount;
        U032 CacheDepth;
        U032 LieDepth;
        U032 RetryCount;
        U032 Count;
        U032 UpdateFlags;
        U032 FinishFlags;
        U032 DmaFetchAmount;       // Burst amount the DMA pusher should use
                                   // when reading into the FIFO
        U032 DmaWaterMark;         // Fifo level which will kick of the next
                                   // DMA burst
        U032 CurrentChID;
        //PFIFO   fifoTable;               //***
        U032    fifoAllocateCount;         //***
        //POBJECT *hashTable;              //***
    } Fifo;
    struct _def_master_info
    {
        U032 Size;
        char ID[32];
        U032 UpdateFlags;
        U032 FinishFlags;
    } Master;
    struct _def_framebuffer_info
    {
        U032 Size;
        char ID[32];
        U032 ConfigReg;
        U032 ConfigPageHeight;
        U032 RamSizeMb;
        U032 RamSize;
        U032 RamType;
        U032 RamTech;
        U032 DpmLevel;
        U032 Depth;
        U032 Resolution;
        U032 RefreshRate;
        U032 HorizFrontPorch;
        U032 HorizSyncWidth;
        U032 HorizBackPorch;
        U032 HorizDisplayWidth;
        U032 VertFrontPorch;
        U032 VertSyncWidth;
        U032 VertBackPorch;
        U032 VertDisplayWidth;
        U032 HSyncPolarity;
        U032 VSyncPolarity;
        U032 CSync;
        U032 Count;
        U032 ServiceCount;
        U032 ActiveCount;
        U032 ActiveMask;
        U032 Start[4];
        U032 Limit[4];
        U032 Current;
        U032 FlipUsageCount;
        U032 FlipTo;
        U032 FlipFrom;
        U032 VBlankToggle;
        U032 UpdateFlags;
        U032 FinishFlags;
        U032 MonitorType;
        U032 FilterEnable;
        U032 SaveToEEPROMEnable;
        U032 Underscan_x;
        U032 Underscan_y;
        U032 Scale_x;               
        U032 Scale_y;
        U032 Instance;
        U032 DmaInstance;
        //U008 *fbInstBitmap;              //***
        U032 fbSave[4];                    //***
    } Framebuffer;
    struct _def_graphics_info
    {
        U032 Size;
        char ID[32];
        U032 Debug0;
        U032 Debug1;
        U032 Debug2;
        U032 Debug3;
        U032 CurrentChID;
        U032 Count;
        U032 CanvasCount;
        U032 Enabled;
        U032 ServiceCount;
        U032 ComplexClipCount;
        U032 UpdateFlags;
        U032 FinishFlags;
        //PGRAPHICSCHANNEL  grTable;         //***
        //PCANVAS           grSysCanvas;     //***
        //PNODE             grCanvasTree;    //***
        //PVBLANKNOTIFY     grVBlankList[2]; //***
        U032              grSave[36];        //***
    } Graphics;
    struct _def_video_info
    {
        U032 Size;
        char ID[32];
        U032 CurrentChID;
        U032 ColorKeyEnabled;
        U032 ScaleFactor;   // 12.20
        U032 Enabled;
        U032 VideoStart;
        U032 VideoSize;
        U032 VideoScale;
        U032 VideoColorKey;
        U032 UpdateFlags;
        U032 FinishFlags;
#ifdef FRAME_LOCK
        // the rock under which we store information to try to genlock things
        U032 dwStartIt;
        S032 dwPhaseError;
        S032 dwlocError;
        U032 dwRockIndex;
        S032 dwRockStorage[MAXROCKS];
        U032 dwRockStorage2[MAXROCKS];
        U032 dwLastIt;
        
        S032 oldRaw;
        S032 oldLow;
        S032 oldReject;
        S032 oldOutput;
#endif // FRAME_LOCK

#ifdef  NV3WDMHACK
        // there are four sets of these, two each for Image and VBI
        U032                pVidToMemDelayParam0;
        U032                pVidToMemDelayParam1;
        U032                pVidToMemDelayParam2;
        U032                pVidToMemDelayParam3;
        U032                dwDelayCounter0;        // zero indicates not running, 1 starts running, N completes
        U032                dwDelayCounter1;        
        U032                dwDelayCounter2;        
        U032                dwDelayCounter3;    
        U032                dwHasInited;    
#endif //NV3WDMHACK
    } Video;
    struct _def_mediaport_info
    {
        U032 Size;
        char ID[32];
        U032 CurrentChID;
        U032 Enabled;
        U032 MPCPresent;
        //MEDIAPORTCONTEXT  mpContext[NUM_FIFOS];  //***
    } MediaPort;
    struct _def_dac_info
    {
        U032 Size;
        char ID[32];
        U032 InputWidth;
        U032 PClkVClkRatio;
        U032 VClk;
        U032 MClk;
        U032 PClk;
        U032 VPllM;
        U032 VPllN;
        U032 VPllO;
        U032 VPllP;
        U032 MPllM;
        U032 MPllN;
        U032 MPllO;
        U032 MPllP;
        U032 DpmLevel;
        S032 CursorPosX;
        S032 CursorPosY;
        U032 TVCursorMin;
        U032 TVCursorMax;
        U032 CursorWidth;
        U032 CursorHeight;
        U008 CursorImagePlane[2][32 * sizeof(U032)];
        U032 CursorType;
        U032 CursorColor1;
        U032 CursorColor2;
        U032 CursorColor3;
        U016 CursorColorImage[32][32];
#ifdef SW_CURSOR
        U008 CursorColorImage[32][32 * sizeof(U032)];
        S032 CursorSaveUnderPosX;
        S032 CursorSaveUnderPosY;
        U032 CursorSaveUnderWidth;
        U032 CursorSaveUnderHeight;
        U032 CursorSaveUnder[32][32];
        U032 CursorExclude;
        U032 CursorEmulation;
#endif // SW_CURSOR
        U032 Palette[272];
        U032 Gamma[272];
        U032 UpdateFlags;
        U032 FinishFlags;
        U032 CursorImageInstance;
        U016 CursorImageCache[32][32][MAX_CACHED_CURSORS]; // 32x32 words
        U032 CursorImageCacheInstance[MAX_CACHED_CURSORS];
        U032 CursorAddress[MAX_CACHED_CURSORS];
        // JJV - Cached cursor sum values.
        U032 CursorMaskCRC[MAX_CACHED_CURSORS];
        // JJV - Saved cursor for 8bpp.
        U008 SavedCursor[(32/8)*32 + 32*32];
        U032 CursorCachedExtra;
        U032 CursorCached;
        U032 CursorCacheCount;
        U032 CursorCacheEntry;
        U008 flickertoggle;                //***
        U008 dummy0;                       //Pads for the previous byte ***
        U008 dummy1;                       //Pads for the previous byte ***
        U008 dummy2;                       //Pads for the previous byte ***
        U032 filterCountdown;              //***
#ifdef NV3WDMHACK
        U032 dwImageCtxCount;
#endif
    } Dac;
    struct _def_dgp_chip_info
    {
        U032 Size;
        char ID[32];
        U032 Chip;
        U032 Enable3D;
        U032 Scale;
        U032 HorizDelay;
        U032 HorizOffset;
        U032 HorizScale;
        U032 VertOffset;
        U032 VertScale;
        U032 UpdateFlags;
        U032 FinishFlags;
        
    } Dgp;
    struct _def_timer_info
    {
        U032 Size;
        char ID[32];
        U032 Denominator;
        U032 Numerator;
        U032 ServiceCount;
        U032 UpdateFlags;
        U032 FinishFlags;
        //PTIMERCALLBACK    tmrCallbackList;     //***
        //PTIMERCALLBACK    tmrCallbackFreeList; //***
        //PTIMERCALLBACK    tmrCallbackTable;    //***
        U032              tmrSave[2];          //***
    } Timer;
    struct _def_vga_info
    {
        U032 Size;
        char ID[32];
        U032 Enabled;
#ifdef NV_VGA
        U032 GlobalEnable;
        U032 RomVersion;
        U032 RomFixupCode;
        U032 UpdateFlags;
        U032 FinishFlags;
#endif // NV_VGA
    } Vga;
    struct _def_classes_info
    {
        U032 Size;
        char ID[32];
        U032 UpdateFlags;
        U032 FinishFlags;
    } Classes;
    struct _def_stat_info
    {
        U032 Size;
        char ID[32];
        U032 AudioExceptionCount;
        U032 FifoExceptionCount;
        U032 FramebufferExceptionCount;
        U032 GraphicsExceptionCount;
        U032 TimerExceptionCount;
        U032 TotalExceptionCount;
        U032 IntTimeLo;
        U032 IntTimeHi;
        U032 ExecTimeLo;
        U032 ExecTimeHi;
        U032 MemAlloced;
        U032 MemLocked;
        U032 UpdateLo;
        U032 UpdateHi;
    } Statistics;
    struct _def_null_info
    {
        U032 Size;
        char ID[32];
    } Null;
    struct _def_obsolete_info
    {
      //U032  (*displayModeHook)(U032);   
      //SURFACEATTRIBUTES OverlaySurfaceAttribs[20];
      //SURFACEATTRIBUTES ImageSurfaceAttribs[20];
      //PVBLANKNOTIFY     class63VBlankList[2];
      U032              class63VBlankCount[2];
      
      U032              dwOvMaxBuffer;
      //PVIDEOFROMMEMOBJECT class63ActiveVideo[1];
      U032              dwSchedule_1_ToSurfaceEven;
      U032              dwSchedule_1_ToSurfaceOdd; 
      U032              dwSchedule_0_ToSurfaceEven;
      U032              dwSchedule_0_ToSurfaceOdd;
      //POBJECT           pHardwareObject;
      U032              global_dwVideoFormat;
      U032              dwDigitiserType;
      U032              dwImageCtxCount;
      U032              dwVbiCtxCount;
      U032              FLIP_OVERLAY_SURFACE_0;
      U032              FLIP_OVERLAY_SURFACE_1;
      U032              dwMasterSkipPattern;
      U032              dwTempSkipPattern;
      U032              dwMasterSkipBits;
      U032              dwIndexSkipBits;
      U032              dwImage0Skipped;
      U032              dwImage1Skipped;
      U032              dwOldLength0;
      U032              dwOldLength1;
      U032              dwXres; 
      U032              dwYres; 
      U032              dwIntMasterIndex; // used for interleave mode only
      U032              dwIntBuff0Index;
      U032              dwIntBuff1Index;
      U032              dwMaxBuffers;     // this will be changed for multiple buffer
      U032              dwVbiBufferNumber;
      U032              dwImageBufferNumber;
      //PPARALLELBUSOBJECT pNotifyObject;
      U008              iniFlag;
      U008              dummy3;
      U008              dummy4;
      U008              dummy5;
     #ifdef DEBUG
      U032              dwActiveObjects;
      U032              dwCreatedObjects;
      U032              dwDormantObjects;
      U032              dwVmiInterrupts;
      U032              dwImageInterrupts;
      U032              dwVbiInterrupts;
     #endif   
    }  Obsolete; 
} HWINFO, * PHWINFO;

typedef struct _def_rmInstance_info  *PNvDB, NvDB;

// This is the Master Structure for all of the system globals.
struct _def_rmInstance_info
{
  HWINFO              DBnvInfo;
  U032                *DBApertureTranslationTable;  //***
  POBJECT             *DBhashTable;                 //***
  U008                *DBfbInstBitmap;              //***
  PHWREG              DBnvAddr;                     //***
  PHWREG              DBromAddr;                    //***
  PHWREG              DBfbAddr;                     //***
  PHWREG              DBagpAddr;                    //***
  PHWREG              DBimAddr;                     //***
                                                    
  PFIFO               DBfifoTable;                  //***
  PDMAOBJECT          DBDmaList;                    //***
  PDMAOBJECT          DBVidDmaObject;               //***
  PGRAPHICSCHANNEL    DBgrTable;                    //***
  PCANVAS             DBgrSysCanvas;                //***
  PNODE               DBgrCanvasTree;               //***
  PVBLANKNOTIFY       DBgrVBlankList[2];            //***
  PTIMERCALLBACK      DBtmrCallbackList;            //***
  PTIMERCALLBACK      DBtmrCallbackFreeList;        //***
  PTIMERCALLBACK      DBtmrCallbackTable;           //***
  PVBLANKNOTIFY       DBclass63VBlankList[2];
  PVIDEOFROMMEMOBJECT DBclass63ActiveVideo[1];
  POBJECT             DBpHardwareObject;
  PPARALLELBUSOBJECT  DBpNotifyObject;
  U032                (*DBdisplayModeHook)(U032);   
  MEDIAPORTCONTEXT    DBmpContext[NUM_FIFOS];       //***
  SURFACEATTRIBUTES   DBOverlaySurfaceAttribs[20];
  SURFACEATTRIBUTES   DBImageSurfaceAttribs[20];
} ;

#ifndef JV
#define MAX_INSTANCE 8
#define TEST_DEVICE_NUM 0
extern  int   DeviceInstance;
extern  PNvDB NvDBPtr_Table[MAX_INSTANCE];
#endif // JV

// Multiple instance macros.
// This is on the Ugly side at the moment (Should be cleaned up soon)

//#define nvAddr                      NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.nvAddr
//#define romAddr                   NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.romAddr                  
//#define fbAddr                    NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.fbAddr                   
//#define agpAddr                   NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.agpAddr                  

#define nvPhys                    NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.nvPhys                   
#define fbPhys                    NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.fbPhys                   
#define nvIRQ                     NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.nvIRQ                    
#define dllIpcOffset              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.dllIpcOffset             
#define dllIpcSelector            NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.dllIpcSelector           
#define dllNotifyOffset           NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.dllNotifyOffset          
#define dllNotifySelector         NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.dllNotifySelector        

//#define nvInfoSelector            NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.nvInfoSelector           
//#define channelInfoSelector       NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.channelInfoSelector      
//#define clientInfoSelector        NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.clientInfoSelector       

#define ChipID                    NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.ChipID                   
//#define ApertureTranslationTable  NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.ApertureTranslationTable
#define hpicIRQ                   NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.hpicIRQ                  
#define hDev                      NvDBPtr_Table[DeviceInstance]->DBnvInfo.Mapping.hDev                  

#define osStartInterrupt          NvDBPtr_Table[DeviceInstance]->DBnvInfo.Chip.osStartInterrupt

//#define fifoTable                 NvDBPtr_Table[DeviceInstance]->DBnvInfo.Fifo.fifoTable
#define fifoAllocateCount         NvDBPtr_Table[DeviceInstance]->DBnvInfo.Fifo.fifoAllocateCount
//#define hashTable                 NvDBPtr_Table[DeviceInstance]->DBnvInfo.Fifo.hashTable
                                  
//#define mpContext                 NvDBPtr_Table[DeviceInstance]->DBnvInfo.MediaPort.mpContext
                                  
//#define grTable                   NvDBPtr_Table[DeviceInstance]->DBnvInfo.Graphics.grTable     
//#define grSysCanvas               NvDBPtr_Table[DeviceInstance]->DBnvInfo.Graphics.grSysCanvas 
//#define grCanvasTree              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Graphics.grCanvasTree
//#define grVBlankList              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Graphics.grVBlankList
#define grSave                    NvDBPtr_Table[DeviceInstance]->DBnvInfo.Graphics.grSave      

//#define fbInstBitmap              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Framebuffer.fbInstBitmap                    
#define fbSave                    NvDBPtr_Table[DeviceInstance]->DBnvInfo.Framebuffer.fbSave   

//#define tmrCallbackList           NvDBPtr_Table[DeviceInstance]->DBnvInfo.Timer.tmrCallbackList    
//#define tmrCallbackFreeList       NvDBPtr_Table[DeviceInstance]->DBnvInfo.Timer.tmrCallbackFreeList
//#define tmrCallbackTable          NvDBPtr_Table[DeviceInstance]->DBnvInfo.Timer.tmrCallbackTable   
#define tmrSave                   NvDBPtr_Table[DeviceInstance]->DBnvInfo.Timer.tmrSave            
                                  
//#define DmaList                   NvDBPtr_Table[DeviceInstance]->DBnvInfo.Dma.DmaList
#define dmaPushPutOffset          NvDBPtr_Table[DeviceInstance]->DBnvInfo.Dma.dmaPushPutOffset
#define dmaPushGetOffset          NvDBPtr_Table[DeviceInstance]->DBnvInfo.Dma.dmaPushGetOffset
#define dmaPushGetOffsetRead      NvDBPtr_Table[DeviceInstance]->DBnvInfo.Dma.dmaPushGetOffsetRead
#define dmaPushJumpOffset         NvDBPtr_Table[DeviceInstance]->DBnvInfo.Dma.dmaPushJumpOffset
#define dmaPushJumpOffsetSet      NvDBPtr_Table[DeviceInstance]->DBnvInfo.Dma.dmaPushJumpOffsetSet        
//#define VidDmaObject              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Dma.VidDmaObject                    
                                  
#define flickertoggle             NvDBPtr_Table[DeviceInstance]->DBnvInfo.Dac.flickertoggle  
#define filterCountdown           NvDBPtr_Table[DeviceInstance]->DBnvInfo.Dac.filterCountdown
#ifdef NV3WDMHACK
#define dwImageCtxCount           NvDBPtr_Table[DeviceInstance]->DBnvInfo.Dac.dwImageCtxCount
#endif
                                  
//#define displayModeHook             NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.displayModeHook
//#define OverlaySurfaceAttribs        NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.OverlaySurfaceAttribs      
//#define ImageSurfaceAttribs          NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.ImageSurfaceAttribs        

//#define class63VBlankList            NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.class63VBlankList          

#define class63VBlankCount           NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.class63VBlankCount         
#define dwOvMaxBuffer                NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwOvMaxBuffer

//#define class63ActiveVideo           NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.class63ActiveVideo         

#define dwSchedule_1_ToSurfaceEven   NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwSchedule_1_ToSurfaceEven 
#define dwSchedule_1_ToSurfaceOdd    NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwSchedule_1_ToSurfaceOdd  
#define dwSchedule_0_ToSurfaceEven   NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwSchedule_0_ToSurfaceEven 
#define dwSchedule_0_ToSurfaceOdd    NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwSchedule_0_ToSurfaceOdd  
     #ifdef DEBUG                                                                   
#define dwActiveObjects              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwActiveObjects            
#define dwCreatedObjects             NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwCreatedObjects           
#define dwDormantObjects             NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwDormantObjects           
#define dwVmiInterrupts              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwVmiInterrupts            
#define dwImageInterrupts            NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwImageInterrupts          
#define dwVbiInterrupts              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwVbiInterrupts            
     #endif                                                                         
//#define pHardwareObject              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.pHardwareObject            

#define global_dwVideoFormat         NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.global_dwVideoFormat
#define dwDigitiserType              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwDigitiserType            
#define dwImageCtxCount              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwImageCtxCount            
#define dwVbiCtxCount                NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwVbiCtxCount              
#define FLIP_OVERLAY_SURFACE_0       NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.FLIP_OVERLAY_SURFACE_0     
#define FLIP_OVERLAY_SURFACE_1       NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.FLIP_OVERLAY_SURFACE_1     
#define dwMasterSkipPattern          NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwMasterSkipPattern        
#define dwTempSkipPattern            NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwTempSkipPattern          
#define dwMasterSkipBits             NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwMasterSkipBits           
#define dwIndexSkipBits              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwIndexSkipBits            
#define dwImage0Skipped              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwImage0Skipped            
#define dwImage1Skipped              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwImage1Skipped            
#define dwOldLength0                 NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwOldLength0               
#define dwOldLength1                 NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwOldLength1               
#define dwXres                       NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwXres                     
#define dwYres                       NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwYres                     
#define dwIntMasterIndex             NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwIntMasterIndex           
#define dwIntBuff0Index              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwIntBuff0Index            
#define dwIntBuff1Index              NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwIntBuff1Index            
#define dwMaxBuffers                 NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwMaxBuffers               
#define dwVbiBufferNumber            NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwVbiBufferNumber          
#define dwImageBufferNumber          NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.dwImageBufferNumber        

//#define pNotifyObject                NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.pNotifyObject              
#define iniFlag                      NvDBPtr_Table[DeviceInstance]->DBnvInfo.Obsolete.iniFlag                    

#define OverlaySurfaceAttribs        NvDBPtr_Table[DeviceInstance]->DBOverlaySurfaceAttribs
#define ImageSurfaceAttribs          NvDBPtr_Table[DeviceInstance]->DBImageSurfaceAttribs

#define mpContext                    NvDBPtr_Table[DeviceInstance]->DBmpContext

#define displayModeHook              NvDBPtr_Table[DeviceInstance]->DBdisplayModeHook
#define fifoTable                    NvDBPtr_Table[DeviceInstance]->DBfifoTable
#define DmaList                      NvDBPtr_Table[DeviceInstance]->DBDmaList
#define VidDmaObject                 NvDBPtr_Table[DeviceInstance]->DBVidDmaObject
#define grTable                      NvDBPtr_Table[DeviceInstance]->DBgrTable
#define grSysCanvas                  NvDBPtr_Table[DeviceInstance]->DBgrSysCanvas
#define grCanvasTree                 NvDBPtr_Table[DeviceInstance]->DBgrCanvasTree
#define grVBlankList                 NvDBPtr_Table[DeviceInstance]->DBgrVBlankList
#define tmrCallbackList              NvDBPtr_Table[DeviceInstance]->DBtmrCallbackList
#define tmrCallbackFreeList          NvDBPtr_Table[DeviceInstance]->DBtmrCallbackFreeList
#define tmrCallbackTable             NvDBPtr_Table[DeviceInstance]->DBtmrCallbackTable
#define class63VBlankList            NvDBPtr_Table[DeviceInstance]->DBclass63VBlankList
#define class63ActiveVideo           NvDBPtr_Table[DeviceInstance]->DBclass63ActiveVideo
#define pHardwareObject              NvDBPtr_Table[DeviceInstance]->DBpHardwareObject
#define pNotifyObject                NvDBPtr_Table[DeviceInstance]->DBpNotifyObject

#define nvAddr                       NvDBPtr_Table[DeviceInstance]->DBnvAddr 
#define romAddr                      NvDBPtr_Table[DeviceInstance]->DBromAddr
#define fbAddr                       NvDBPtr_Table[DeviceInstance]->DBfbAddr 
#define agpAddr                      NvDBPtr_Table[DeviceInstance]->DBagpAddr
#define imAddr                       NvDBPtr_Table[DeviceInstance]->DBimAddr

#define ApertureTranslationTable     NvDBPtr_Table[DeviceInstance]->DBApertureTranslationTable
#define hashTable                    NvDBPtr_Table[DeviceInstance]->DBhashTable
#define fbInstBitmap                 NvDBPtr_Table[DeviceInstance]->DBfbInstBitmap

#define nvInfo                       NvDBPtr_Table[DeviceInstance]->DBnvInfo 


#endif // _NVRM_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvrmcomm.c ===
// this file contans the functions that implement display driver to RM comm

#include <ntddk.h>
#include <windef.h>
#undef WIN32
//#define NTMINIPORT
#include <nvos.h>
#include <nvntioctl.h>

typedef LONG VP_STATUS;
typedef struct _STATUS_BLOCK {
    VP_STATUS Status;
    ULONG Information;
} STATUS_BLOCK, *PSTATUS_BLOCK;
typedef struct _VIDEO_REQUEST_PACKET {
    ULONG IoControlCode;
    PSTATUS_BLOCK StatusBlock;
    PVOID InputBuffer;
    ULONG InputBufferLength;
    PVOID OutputBuffer;
    ULONG OutputBufferLength;
} VIDEO_REQUEST_PACKET, *PVIDEO_REQUEST_PACKET;

PFILE_OBJECT pRmFileObject;
PDEVICE_OBJECT pRmDeviceObject;

// for the new interface:
NVDESCRIPTOR fdNv;

BOOL NvRmOpen()
{
	NTSTATUS ntStatus = STATUS_SUCCESS;
	UNICODE_STRING rmUnicodeString;
	pRmFileObject = NULL;
	pRmDeviceObject = NULL;

	// open the resource manager
	//RtlInitUnicodeString(&rmUnicodeString, L"\\Device\\Nvrm");
	RtlInitUnicodeString(&rmUnicodeString, NVRM_NAME_STRING);
	ntStatus = IoGetDeviceObjectPointer(
		&rmUnicodeString,
	 	FILE_ALL_ACCESS,
		&pRmFileObject,
		&pRmDeviceObject
	);
	if (NT_SUCCESS(ntStatus))
	{
		ntStatus = ObReferenceObjectByPointer(
			pRmDeviceObject,
			FILE_ALL_ACCESS,
			NULL,
			KernelMode
		);
	}

	// for the new interface
	fdNv.pFileObject = pRmFileObject;
	fdNv.pDeviceObject = pRmDeviceObject;

	return (NT_SUCCESS(ntStatus)) ? TRUE : FALSE;

} // end of NvRmOpen()

BOOL NvRmClose()
{
	// close the RM by dereferencing both the device and file objects
	if (pRmDeviceObject)
		ObDereferenceObject(pRmDeviceObject);
	if (pRmFileObject)
		ObDereferenceObject(pRmFileObject);

	return TRUE;

} // end of NvRmClose()

BOOL NvRmIoControl(PVIDEO_REQUEST_PACKET RequestPacket)
{
    //PSTATUS_BLOCK StatusBlock;
	IO_STATUS_BLOCK status;
	PIRP pRmIrp;
	
	pRmIrp = IoBuildDeviceIoControlRequest(
		RequestPacket->IoControlCode,
		pRmDeviceObject,
		(PVOID)(*(DWORD *)(RequestPacket->InputBuffer)),
		RequestPacket->OutputBufferLength,
		(PVOID)(*(DWORD *)(RequestPacket->InputBuffer)),
		RequestPacket->OutputBufferLength,
		FALSE,
		NULL,
		&status
	);
	if (pRmIrp)
	{
		IoCallDriver(
			pRmDeviceObject,
			pRmIrp
		);
	}

	return TRUE;

} // end of NvRmIoControl()

BOOL NvrmIoctl(PVIDEO_REQUEST_PACKET RequestPacket)
{
    switch (RequestPacket->IoControlCode)
	{
	    case NV3_IOCTL_ALLOC_CHANNEL_DMA:
			Nv3AllocChannelDma(fdNv, (*(NVOS07_PARAMETERS **)(RequestPacket->InputBuffer)));
			break;

	    case NV3_IOCTL_DMA_FLOW_CONTROL:
			Nv3DmaFlowControl(fdNv, (*(NVOS08_PARAMETERS **)(RequestPacket->InputBuffer)));
			break;

		default:
			return FALSE;
	}
	return TRUE;

} // end of NvRmIoctl()


// end of nvrmcomm.c
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvsubch.h ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     nvsubch.h
//
// Abstract:
//
//     This module contains the object subchannel definitions
//
// Environment:
//
//     Kernel mode
//
// Revision History:
//
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#define CLIP_SUBCHANNEL                6
#define IMAGE_PATTERN_SUBCHANNEL       5
#define ROP_SOLID_SUBCHANNEL           4

#define RECTANGLE_SUBCHANNEL           3
#define LUT_CURSOR_DAC_SUBCHANNEL      3                
#define IMAGE_MONO_FROM_CPU_SUBCHANNEL 2
#define RECT_AND_TEXT_SUBCHANNEL       2
#define BLIT_SUBCHANNEL                1
#define IMAGE_FROM_CPU_SUBCHANNEL      0
#define DD_SPARE                       7
#define DD_ROP_RECT_AND_TEXT           2
#define DD_STRETCH                     DD_SPARE

#define SOLID_LIN_SUBCHANNEL           7
//******************************************************************************
// OpenGL SubChannel assignments for objects
//******************************************************************************

#define TRIANGLE_SUBCHANNEL            0
#define D3DTRIANGLE_SUBCHANNEL         0
#define CLEARZ_SUBCHANNEL              2
#define SRCIMAGE_IN_MEMORY_SUBCHANNEL  5
#define D3DTRIANGLE_SYSMEM_SUBCHANNEL  4
#define RENDER_SOLID_LIN_SUBCHANNEL    0

//******************************************************************************
// My 32-bit names for the STATIC image objects
//******************************************************************************

#define MY_IMAGE_SOLID                 0x99990001
#define MY_BLACK_RECTANGLE             0x99990002
#define MY_IMAGE_PATTERN               0x99990003
#define MY_ROP_SOLID                   0x99990004

//******************************************************************************
// My 32-bit names for RENDERING type objects
//******************************************************************************

#define MY_RENDER_SOLID_RECTANGLE      0x34000001
#define MY_RENDER_SOLID_TRIANGLE       0x34000002
#define MY_RENDER_SCRN_TO_SCRN_BLIT    0x34000003
#define MY_IMAGE_FROM_CPU_BLIT         0x34000004
#define MY_IMAGE_MONO_FROM_CPU_BLIT    0x34000005
#define MY_RENDER_D3D_TRIANGLE         0x34000006
#define MY_CLEARZ_RECTANGLE            0x34000007
#define MY_SRCIMAGE_IN_MEMORY          0x34000008
#define MY_DSTIMAGE_IN_MEMORY          0x34000009
#define MY_MEMORY_TO_MEMORY            0x3400000A
#define MY_RENDER_D3D_SYSMEM_TRIANGLE  0x3400000B
#define MY_RENDER_D3D_TRIANGLE_SYSMEM  MY_RENDER_D3D_SYSMEM_TRIANGLE
#define MY_RENDER_SOLID_LIN            0x3400000C
#define MY_STENCIL_TRIANGLE            0x3400000D
#define MY_STENCIL_LIN                 0x3400000E
#define MY_STENCIL_SYSMEM_TRIANGLE     0x3400000F

//****************************************************************************
// object id's (only used by Release driver)
//****************************************************************************
#define DD_IMAGE_FROM_CPU               0x000A0000
#define DD_IMAGE_BLIT                   0x000A0001
#define DD_IMAGE_MONO                   0x000A0002
#define DD_RENDER_SOLID_RECTANGLE       0x000A0003
//#define DD_ROP_SOLID                  0x000A0004 undefined for RIVA (jsw)
#define DD_ROP5_SOLID                   0x000A0004
#define DD_IMAGE_PATTERN                0x000A0005
#define DD_IMAGE_BLACK_RECTANGLE        0x000A0006
#define DD_IMAGE_SOLID                  0x000A0007
#define DD_RENDER_RECT_AND_TEXT         0x000A0008
#define DD_IMAGE_ROP_AND0               0x000A0010
#define DD_IMAGE_ROP_AND1               0x000A0011
#define DD_IMAGE_ROP_AND2               0x000A0012
#define DD_IMAGE_ROP_AND3               0x000A0013
#define DD_IMAGE_ROP_AND4               0x000A0014
#define DD_IMAGE_ROP_AND5               0x000A0015
#define DD_IMAGE_ROP_AND6               0x000A0016
#define DD_IMAGE_STENCIL0               0x000A0020
#define DD_IMAGE_STENCIL1               0x000A0021
#define DD_IMAGE_STENCIL2               0x000A0022
#define DD_IMAGE_STENCIL3               0x000A0023
#define DD_IMAGE_STENCIL4               0x000A0024
#define DD_IMAGE_STENCIL5               0x000A0025
#define DD_IMAGE_STENCIL6               0x000A0026
#define DD_IMAGE_COLOR_KEY0             0x000A0030
#define DD_IMAGE_COLOR_KEY1             0x000A0031
#define DD_IMAGE_COLOR_KEY2             0x000A0032
#define DD_IMAGE_COLOR_KEY3             0x000A0033
#define DD_IMAGE_COLOR_KEY4             0x000A0034
#define DD_IMAGE_COLOR_KEY5             0x000A0035
#define DD_IMAGE_COLOR_KEY6             0x000A0036
#define DD_IMAGE_TO_VIDEO               0x000A00E0
#define DD_VIDEO_SINK                   0x000A00F0
#define DD_PRIMARY_VIDEO_FROM_MEMORY    0x000A00F1
#define DD_PRIMARY_IMAGE_IN_MEMORY      0x000A00F2
#define DD_COLORMAP                     0x000A00F3
#define DD_SRC_IMAGE_IN_MEMORY          0x000A00F4
#define DD_ZETA_BUFFER                  0x000A00F5
#define DD_RENDER_D3D_TRIANGLE          0x000A00F6
#define DD_IMAGE_FROM_MEMORY            0x000A00F7
#define DD_ZBUFFER_IMAGE_IN_MEMORY      0x000A00F8
#define DD_IMAGE_ROP_AND_LIN            0x000A00F9
#define DD_P_V_SHARED_VIDEO_COLORMAP    0x000A00FA
#define DD_INDEXED_IMAGE_FROM_CPU       0x000A00FB
#define DD_INDEXED_IMAGE1_FROM_CPU      0x000A00FC
#define DD_INDEXED_IMAGE2_FROM_CPU      0x000A00FD
#define DD_INDEXED_IMAGE3_FROM_CPU      0x000A00FE
#define DD_INDEXED_IMAGE4_FROM_CPU      0x000A00FF
#define DD_INDEXED_IMAGE5_FROM_CPU      0x000A0100
#define DD_INDEXED_IMAGE6_FROM_CPU      0x000A0101
#define DD_INDEXED_IMAGE7_FROM_CPU      0x000A0102
#define DD_INDEXED_IMAGE8_FROM_CPU      0x000A0103
#define DD_INDEXED_IMAGE9_FROM_CPU      0x000A0104
#define DD_INDEXED_IMAGE10_FROM_CPU     0x000A0105
#define DD_INDEXED_IMAGE11_FROM_CPU     0x000A0106
#define DD_INDEXED_IMAGE12_FROM_CPU     0x000A0107
#define DD_INDEXED_IMAGE13_FROM_CPU     0x000A0108
#define DD_INDEXED_IMAGE14_FROM_CPU     0x000A0109
#define DD_INDEXED_IMAGE15_FROM_CPU     0x000A010A
#define DD_INDEXED_IMAGE16_FROM_CPU     0x000A010B
#define DD_SCALED_IMAGE_FROM_MEMORY     0x000A0110
#define DD_IMAGE_BLIT_COLORKEY          0x000A0111
#define DD_ALPHA_IMAGE_FROM_MEMORY      0x000A0112

// patchcord id's
#define DD_PATCHCORD_IMAGE_FROM_CPU     0x000B0000
#define DD_PATCHCORD_IMAGE_BLIT         0x000B0001
#define DD_PATCHCORD_IMAGE_MONO         0x000B0002
#define DD_PATCHCORD_IMAGE_SOLID_RECT   0x000B0003
#define DD_PATCHCORD_ROP5_SOLID         0x000B0004
#define DD_PATCHCORD_IMAGE_PATTERN      0x000B0005
#define DD_PATCHCORD_IMAGE_BLACK_RECT   0x000B0006
#define DD_PATCHCORD_IMAGE_SOLID        0x000B0007
#define DD_PATCHCORD_IMAGE_RECT_AND_TEXT 0x000B0008
#define DD_PATCHCORD_IMAGE_ROP_AND0     0x000B0010
#define DD_PATCHCORD_IMAGE_ROP_AND1     0x000B0011
#define DD_PATCHCORD_IMAGE_ROP_AND2     0x000B0012
#define DD_PATCHCORD_IMAGE_ROP_AND3     0x000B0013
#define DD_PATCHCORD_IMAGE_ROP_AND4     0x000B0014
#define DD_PATCHCORD_IMAGE_ROP_AND5     0x000B0015
#define DD_PATCHCORD_IMAGE_ROP_AND6     0x000B0016
#define DD_PATCHCORD_IMAGE_STENCIL0     0x000B0020
#define DD_PATCHCORD_IMAGE_STENCIL1     0x000B0021
#define DD_PATCHCORD_IMAGE_STENCIL2     0x000B0022
#define DD_PATCHCORD_IMAGE_STENCIL3     0x000B0023
#define DD_PATCHCORD_IMAGE_STENCIL4     0x000B0024
#define DD_PATCHCORD_IMAGE_STENCIL5     0x000B0025
#define DD_PATCHCORD_IMAGE_STENCIL6     0x000B0026
#define DD_PATCHCORD_IMAGE0             0x000B0030
#define DD_PATCHCORD_IMAGE1             0x000B0031
#define DD_PATCHCORD_IMAGE2             0x000B0032
#define DD_PATCHCORD_IMAGE3             0x000B0033
#define DD_PATCHCORD_IMAGE4             0x000B0034
#define DD_PATCHCORD_IMAGE5             0x000B0035
#define DD_PATCHCORD_IMAGE6             0x000B0036
#define DD_PATCHCORD_IMAGE_FEEDBACK     0x000B00E0
#define DD_PATCHCORD_VIDEO              0x000B00E1
#define DD_PATCHCORD_COLORMAP           0x000B00E2
#define DD_PATCHCORD_SRC_FEEDBACK       0x000B00E3
#define DD_PATCHCORD_ZETA_IN            0x000B00E4
#define DD_PATCHCORD_ZETA_OUT           0x000B00E5
#define DD_PATCHCORD_IMAGE_TRIANGLE     0x000B00E6
#define DD_PATCHCORD_CLEAR_ZBUFFER      0x000B00E7
#define DD_PATCHCORD_IMAGE_SYSMEM_TRIANGLE 0x000B00E8
#define DD_PATCHCORD_ZETA_OUT_SYSMEM    0x000B00E9
#define DD_PATCHCORD_IMAGE_LIN          0x000B00EA
#define DD_PATCHCORD_STENCIL_TRIANGLE   0x000B00EB
#define DD_PATCHCORD_STENCIL_LIN        0x000B00EC
#define DD_PATCHCORD_STENCIL_SYSMEM_TRIANGLE   0x000B00ED

#define DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY    0x00001004
#define NV_WIN_NOTIFIER_CONTEXT_DMA_TO_MEMORY       0x00001005
#define NV_WIN_COLORMAP_CONTEXT                     0x00001010
#define NV_WIN_COLORMAP_CONTEXT_1                   0x00001011
#define NV_WIN_COLORMAP_CONTEXT_2                   0x00001012
#define NV_WIN_COLORMAP_CONTEXT_3                   0x00001013
#define NV_WIN_CONTEXT_DMA_FROM_MEMORY              0x00001015
#define DD_CONTEXT_DMA_NOTIFIER_TRIANGLE            0x00001017
#define DD_NOTIFIER_CONTEXT_DMA_MEMORY_TO_MEMORY_FORMAT 0x00001021
#define DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM          0x00001022
#define DD_CONTEXT_DMA_SYSMEM_TEXTURE_BUFFER        0x00001023
#define DD_NOTIFIER_CONTEXT_DMA_SCALED_IMAGE        0x00001024
#define DD_FIFO_SYNC_NOTIFIER                       0x00001025
#define DD_MEMORY_TO_MEMORY_CONTEXT_DMA_NOTIFIER    0x00001026
#define DD_TEMP_BUFFER_CONTEXT_DMA                  0x00001027
#define NV_WIN_INDEXED_IMAGE_CONTEXT                0x00001028
#define NV_DD_PRIMARY_2D_NOTIFIER_CONTEXT_DMA_TO_MEMORY  0x00001029
#define NV_VIDEO_LUT_CURSOR_DAC                     0x00001030
#define NV_VIDEO_LUT_CURSOR_DAC_2                   0x00001031
#define NV_VIDEO_LUT_CURSOR_DAC_3                   0x00001032
#define NV_VIDEO_LUT_CURSOR_DAC_4                   0x00001033
#define NV_CONTEXT_DMA_CURSOR                       0x00001034
#define NV_CONTEXT_DMA_CURSOR_2                     0x00001035
#define NV_CONTEXT_DMA_VIDEO_LUT_CURSOR_DAC_NOTIFIER     0x00001036

//****************************************************************************
// Dma push specific names
//****************************************************************************

#define NV_CONTEXT_DMA_FROM_MEMORY_PUSHBUF    0x000C0000
#define NV_CONTEXT_DMA_PUSHBUF_ERROR_NOTIFIER 0x000C0001

//****************************************************************************
// Object Instance IDs used by the VPP code on NT4
//****************************************************************************
#define NV_VPP_CHANNEL_IID                              0xEE00A000

#define NV_VPP_3D_OBJECT_IID                            0xEE00A010
#define NV_VPP_DMA_WITHIN_VMEM_IID                      0xEE00A020
#define NV_VPP_DMA_FROM_VMEM_IID                        0xEE00A030
#define NV_VPP_DMA_TO_VMEM_IID                          0xEE00A040
#define NV_VPP_LUT_CURSOR_DAC_IID                       0xEE00A050 // 51,52,53 reserved for additional heads
#define NV_VPP_OVERLAY_NOTIFIER_IID                     0xEE00A060


#define NV_VPP_A_SUBCH                          0
#define NV_VPP_B_SUBCH                          1
#define NV_VPP_C_SUBCH                          2
#define NV_VPP_D_SUBCH                          3
#define NV_VPP_E_SUBCH                          4
#define NV_VPP_F_SUBCH                          5
#define NV_VPP_G_SUBCH                          6
#define NV_VPP_3D_OBJECT_SUBCH                          7


//***************************************************************************************
// NV object names used by the ddraw driver.
//***************************************************************************************
/* Windows 95 Direct Draw Object IDs */
#define NV_DD_DST_IMAGE_IN_MEMORY                               0x80023F00
#define NV_DD_P_I_DST_IMAGE_IN_MEMORY                           0x80023F01
#define NV_DD_SRC_IMAGE_IN_MEMORY                               0x80023F10
#define NV_DD_P_I_SRC_IMAGE_IN_MEMORY                           0x80023F11
#define NV_DD_ZETA_IMAGE_IN_MEMORY                              0x80023F20
#define NV_D3D_ZETA_BUFFER_IN_MEMORY                            0x80023F30
#define NV_D3D_P_Z_ZETA_BUFFER_IN_MEMORY                        0x80023F31

// ELAU from WIN9x
/* Video channel shared Display Driver and DDraw Object IDs */
#define NV_VIDEO_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY         0x00008008
#define NV_VIDEO_OVERLAY                                        0x00008030

#define NV_DD_CONTEXT_DMA_IN_MEMORY_VIDEO_MEM                   0x00002069
#define NV_DD_CONTEXT_DMA_FROM_SYSTEM_MEMORY                    0x00002070
#define NV_DD_WIN_COLORMAP_CONTEXT                              0x00002071
#define NV_DD_TO_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY             0x00002072

#define NV_DD_FLOATING_FORMAT_CONTEXT_DMA_FROM_SYSTEM_MEMORY    0x80021001
#define NV_DD_CONTEXT_DMA_FROM_VIDEO_MEMORY                     0x80021002
#define NV_DD_FLOATING0_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY     0x80021003
#define NV_DD_FLOATING1_UYVY_CONTEXT_DMA_FROM_SYSTEM_MEMORY     0x80021004
#define NV_DD_FLOATING0_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY     0x80021005
#define NV_DD_FLOATING1_YUYV_CONTEXT_DMA_FROM_SYSTEM_MEMORY     0x80021006
#define NV_DD_FLOATING0_Y420_CONTEXT_DMA_FROM_SYSTEM_MEMORY     0x80021007
#define NV_DD_FLOATING1_Y420_CONTEXT_DMA_FROM_SYSTEM_MEMORY     0x80021008
#define NV_DD_TEXTURE_CONTEXT_DMA_FROM_SYSTEM_MEMORY            0x80021009
#define NV_DD_FLOATING_TEXTURE_CONTEXT_DMA_FROM_SYSTEM_MEMORY   0x8002100A
#define NV_DD_TRIANGLE_CONTEXT_DMA_FROM_SYSTEM_MEMORY           0x8002100B
#define DD_CONTEXT_DMA_FLIP_NOTIFIER                            0x8002100B
#define NV_DD_CONTEXT_DMA_IN_MEMORY                             0x80021010
#define NV_DD_FLIP_PRIMARY_NOTIFIER_CONTEXT_DMA_TO_MEMORY       0x80021016
#define NV_DD_FLIP_OVERLAY_NOTIFIER_CONTEXT_DMA_TO_MEMORY       0x80021017
#define NV_DD_FLIP_VPORT_NOTIFIER_CONTEXT_DMA_TO_MEMORY         0x80021018
#define NV_DD_FROM_MEM_NOTIFIER_CONTEXT_DMA_TO_MEMORY           0x80021019
#define NV_DD_PUSHER_SYNC_NOTIFIER_CONTEXT_DMA_TO_MEMORY        0x8002101A
#define NV_DD_DUMMY_NOTIFIER_CONTEXT_DMA_TO_MEMORY              0x8002101B
#define NV_DD_CONTEXT_DMA_TO_VIDEO_MEMORY                       0x8002101C
#define NV_DD_VIDEO_MEM_TO_SYSTEM_MEM_FORMAT                    0x80021020
#define NV_DD_ROP5_SOLID                                        0x80021030
#define NV_DD_P_I_ROP5_SOLID                                    0x80021031
#define NV_DD_BETA_SOLID                                        0x80021040
#define NV_DD_P_B_BETA_SOLID                                    0x80021041
#define NV_DD_IMAGE_PATTERN                                     0x80021050
#define NV_DD_P_I_IMAGE_PATTERN                                 0x80021051
#define NV_DD_IMAGE_BLACK_RECTANGLE                             0x80021060
#define NV_DD_P_I_IMAGE_BLACK_RECTANGLE                         0x80021061
#define NV_DD_COLOR_KEY_IMAGE_SOLID                             0x80021070
#define NV_DD_P_I_COLOR_KEY_IMAGE_SOLID                         0x80021071
#define NV_DD_FROM_MEM_INDEXED_IMAGE_NOTIFIER_CONTEXT_DMA_TO_MEMORY   0x80021072
#define NV_DD_FROM_MEM_INDEXED_IMAGE1_NOTIFIER_CONTEXT_DMA_TO_MEMORY  0x80021073
#define NV_DD_FROM_MEM_INDEXED_IMAGE2_NOTIFIER_CONTEXT_DMA_TO_MEMORY  0x80021074
#define NV_DD_FROM_MEM_INDEXED_IMAGE3_NOTIFIER_CONTEXT_DMA_TO_MEMORY  0x80021075
#define NV_DD_FROM_MEM_INDEXED_IMAGE4_NOTIFIER_CONTEXT_DMA_TO_MEMORY  0x80021076
#define NV_DD_FROM_MEM_INDEXED_IMAGE5_NOTIFIER_CONTEXT_DMA_TO_MEMORY  0x80021077
#define NV_DD_FROM_MEM_INDEXED_IMAGE6_NOTIFIER_CONTEXT_DMA_TO_MEMORY  0x80021078
#define NV_DD_FROM_MEM_INDEXED_IMAGE7_NOTIFIER_CONTEXT_DMA_TO_MEMORY  0x80021079
#define NV_DD_FROM_MEM_INDEXED_IMAGE8_NOTIFIER_CONTEXT_DMA_TO_MEMORY  0x8002107A
#define NV_DD_FROM_MEM_INDEXED_IMAGE9_NOTIFIER_CONTEXT_DMA_TO_MEMORY  0x8002107B
#define NV_DD_FROM_MEM_INDEXED_IMAGE10_NOTIFIER_CONTEXT_DMA_TO_MEMORY 0x8002107C
#define NV_DD_FROM_MEM_INDEXED_IMAGE11_NOTIFIER_CONTEXT_DMA_TO_MEMORY 0x8002107D
#define NV_DD_FROM_MEM_INDEXED_IMAGE12_NOTIFIER_CONTEXT_DMA_TO_MEMORY 0x8002107E
#define NV_DD_FROM_MEM_INDEXED_IMAGE13_NOTIFIER_CONTEXT_DMA_TO_MEMORY 0x8002107F
#define NV_DD_FROM_MEM_INDEXED_IMAGE14_NOTIFIER_CONTEXT_DMA_TO_MEMORY 0x80021080
#define NV_DD_FROM_MEM_INDEXED_IMAGE15_NOTIFIER_CONTEXT_DMA_TO_MEMORY 0x80021081
#define NV_DD_FROM_MEM_INDEXED_IMAGE16_NOTIFIER_CONTEXT_DMA_TO_MEMORY 0x80021082

#define NV_DD_ROP_RECT_AND_TEXT_FROM_CPU                        0x80021100
#define NV_DD_P_I_ROP_RECT_AND_TEXT_FROM_CPU                    0x80021101
#define NV_DD_SYNC_RECT_AND_TEXT_FROM_CPU                       0x80021108
#define NV_DD_P_I_SYNC_RECT_AND_TEXT_FROM_CPU                   0x80021109
#define NV_DD_PUSHER_SYNC_RECT_AND_TEXT_FROM_CPU                0x8002110A
#define NV_DD_P_I_PUSHER_SYNC_RECT_AND_TEXT_FROM_CPU            0x8002110B
#define NV_DD_IMAGE_FROM_CPU                                    0x80021200
#define NV_DD_P_I_IMAGE_FROM_CPU                                0x80021201
#define NV_DD_IMAGE_BLEND_FROM_CPU                              0x80021300
#define NV_DD_P_I_IMAGE_BLEND_FROM_CPU                          0x80021301
#define NV_DD_STRETCHED_IMAGE_FROM_CPU                          0x80021400
#define NV_DD_P_I_STRETCHED_IMAGE_FROM_CPU                      0x80021401
#define NV_DD_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY               0x80021500
#define NV_DD_P_I_SCALED_RGB_IMAGE_FROM_SYSTEM_MEMORY           0x80021501
#define NV_DD_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY                0x80021510
#define NV_DD_P_I_SCALED_RGB_IMAGE_FROM_VIDEO_MEMORY            0x80021511
#define NV_DD_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY              0x80021520
#define NV_DD_P_I_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY          0x80021521
#define NV_DD_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY               0x80021530
#define NV_DD_P_I_SCALED_UYVY_IMAGE_FROM_VIDEO_MEMORY           0x80021531
#define NV_DD_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY              0x80021540
#define NV_DD_P_I_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY          0x80021541
#define NV_DD_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY               0x80021550
#define NV_DD_P_I_SCALED_YUYV_IMAGE_FROM_VIDEO_MEMORY           0x80021551
#define NV_DD_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY    0x80021560
#define NV_DD_P_I_FLOATING0_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY 0x80021561
#define NV_DD_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY    0x80021570
#define NV_DD_P_I_FLOATING1_SCALED_UYVY_IMAGE_FROM_SYSTEM_MEMORY 0x80021571
#define NV_DD_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY    0x80021580
#define NV_DD_P_I_FLOATING0_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY 0x80021581
#define NV_DD_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY    0x80021590
#define NV_DD_P_I_FLOATING1_SCALED_YUYV_IMAGE_FROM_SYSTEM_MEMORY 0x80021591
#define NV_DD_FLOATING0_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY    0x800215A0
#define NV_DD_P_I_FLOATING0_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY 0x800215A1
#define NV_DD_FLOATING1_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY    0x800215B0
#define NV_DD_P_I_FLOATING1_SCALED_Y420_IMAGE_FROM_SYSTEM_MEMORY 0x800215B1
#define NV_DD_STRETCHED_UV_IMAGE_FROM_CPU                       0x80021600
#define NV_DD_P_I_STRETCHED_UV_IMAGE_FROM_CPU                   0x80021601

#define NV_DD_IMAGE_BLIT                                        0x80021800
#define NV_DD_P_I_IMAGE_BLIT                                    0x80021801
#define NV_DD_ALT_IMAGE_FROM_CPU                                0x80021900
#define NV_DD_P_I_ALT_IMAGE_FROM_CPU                            0x80021901
#define NV_DD_RENDER_SOLID_ZETA_RECTANGLE                       0x80021A00
#define NV_DD_P_I_RENDER_SOLID_ZETA_RECTANGLE                   0x80021A01

#define NV_D3D_RENDER_TRIANGLE_ZETA                             0x80021B00
#define NV_D3D_P_I_RENDER_TRIANGLE_ZETA                         0x80021B01
#define NV_D3D_P_Z_RENDER_TRIANGLE_ZETA                         0x80021B02
#define NV_D3D_RENDER_TRIANGLE_ZETA_FROM_VIDEO_MEMORY           0x80021B03
#define NV_D3D_P_I_RENDER_TRIANGLE_ZETA_FROM_VIDEO_MEMORY       0x80021B04
#define NV_D3D_P_Z_RENDER_TRIANGLE_ZETA_FROM_VIDEO_MEMORY       0x80021B05
#define NV_D3D_FLOATING_RENDER_TRIANGLE_ZETA                    0x80021B06
#define NV_D3D_FLOATING_P_I_RENDER_TRIANGLE_ZETA                0x80021B07
#define NV_D3D_FLOATING_P_Z_RENDER_TRIANGLE_ZETA                0x80021B08

#define NV_DD_VIDEO_COLOR_KEY                                   0x80023FB0
#define NV_DD_YUV422_VIDEO_FROM_MEMORY                          0x80023F90
#define NV_DD_PRIMARY_VIDEO_FROM_MEMORY                         0x80023F80
#define NV_DD_P_V_PRIMARY_VIDEO_FROM_MEMORY                     0x80023F81
#define NV_DD_YUV422_VIDEO_FROM_MEMORY                          0x80023F90
#define NV_DD_P_V_YUV422_VIDEO_FROM_MEMORY                      0x80023F91
#define NV_DD_VIDEO_OVERLAY                                     0x80023F92
#define NV_DD_VIDEO_LUT_CURSOR_DAC                              0x80023F93
#define NV_DD_VIDEO_LUT_CURSOR_DAC_2                            0x80023F94
#define NV_DD_VIDEO_LUT_CURSOR_DAC_3                            0x80023F95
#define NV_DD_VIDEO_LUT_CURSOR_DAC_4                            0x80023F96
#define NV_DD_VIDEO_SCALER                                      0x80023FA0
#define NV_DD_P_V_VIDEO_SCALER                                  0x80023FA1
#define NV_DD_VIDEO_COLOR_KEY                                   0x80023FB0
#define NV_DD_P_V_VIDEO_COLOR_KEY                               0x80023FB1
#define NV_DD_SHARED_VIDEO_COLORMAP                             0x80023FC0
#define NV_DD_P_V_SHARED_VIDEO_COLORMAP                         0x80023FC1

#define NV_DD_SYSTEM_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT            0x80023FD0
#define NV_DD_SYSTEM_MEMORY_U_TO_VIDEO_MEMORY_FORMAT            0x80023FD1
#define NV_DD_SYSTEM_MEMORY_V_TO_VIDEO_MEMORY_FORMAT            0x80023FD2
#define NV_DD_SYSTEM_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT           0x80023FD3
#define NV_DD_VIDEO_MEMORY_Y_TO_VIDEO_MEMORY_FORMAT             0x80023FE0
#define NV_DD_VIDEO_MEMORY_U_TO_VIDEO_MEMORY_FORMAT             0x80023FE1
#define NV_DD_VIDEO_MEMORY_V_TO_VIDEO_MEMORY_FORMAT             0x80023FE2
#define NV_DD_VIDEO_MEMORY_UV_TO_VIDEO_MEMORY_FORMAT            0x80023FE3
#define NV_DD_VIDEO_SINK                                        0x80023FF0
#define NV_DD_CONTEXT_BETA                                      0x80023FF1
#define NV_DD_CONTEXT_BETA4                                     0x80023FF2
#define NV_DD_PRIMARY_SURFACE                                   0x80024000
#define NV_DD_SRC_SURFACE                                       0x80024001
#define NV_DD_IMAGE_SOLID                                       0x80024003
#define NV_DD_RENDER_RECT_AND_TEXT                              0x80024004
#define NV_DD_RENDER_SOLID_RECTANGLE                            0x80024005

// object handle definitions for the new architure
// values start after DMA pushbuf id's
#define DD_CLIENT_OBJECT_HANDLE                 0x000C0002
#ifndef NVD3D
#define DD_DEVICE_OBJECT_HANDLE                 0x000C0003
#else
//
// Use the same device handle as the DX6 driver.
//
#define DD_DEVICE_OBJECT_HANDLE                 0x00002002
#endif // #ifdef NVD3D
#define DD_PIO_CHANNEL_OBJECT_HANDLE            0x000C0004
#define DD_DMA_CHANNEL_OBJECT_HANDLE            0x000C0005
#define DD_FRAME_BUFFER_OBJECT_HANDLE           0x000C0006
#define DD_CURSOR_OBJECT_HANDLE                 0x000C0007
#define NV_DD_DDRAW_PIO_CHANNEL_OBJECT_HANDLE   0x000C0008
#define NV_AGP_PUSHBUF_OBJECT_HANDLE            0x000C0009
#define NV_SYS_PUSHBUF_OBJECT_HANDLE            0x000C000A
#define NV_NOTIFIERS_OBJECT_HANDLE              0x000C000B
#define NV_INDEXED_IMAGE_LUT_OBJECT_HANDLE      0x000C000C
#define NV_MEM_TO_MEM_BUFFER_OBJECT_HANDLE      0x000C000D
#define NV_CLUT_DATA_OBJECT_HANDLE              0x000C000E

//***************************************************************************
// Macros used to create NV objects via the IOCTLs.
//***************************************************************************
#define NV_CREATE_OBJECT_SETUP() \
    NvU32 createObjFail, createObjClass
#define NV_CREATE_OBJECT_INIT() createObjFail = 0
#define NV_CREATE_OBJECT_FAIL() createObjFail
#define NV_CREATE_OBJECT_CLASS() createObjClass

#define NV_CREATE_OBJECT_PIO1(CLASS1, OBJ) {                                 \
    NvU32 classes[] = {CLASS1};                                              \
    NvCreateObject(ppdev,FALSE, NULL, OBJ, &createObjClass, &createObjFail, 1, classes); \
}    

#define NV_CREATE_OBJECT_PIO2(CLASS1, CLASS2, OBJ) {                         \
    NvU32 classes[] = {CLASS1,CLASS2};                                       \
    NvCreateObject(ppdev,FALSE, NULL, OBJ, &createObjClass, &createObjFail, 2, classes); \
}    

#define NV_CREATE_OBJECT_PARM_PIO2(PARM, OBJ, CLASS1, CLASS2) {                             \
    NvU32 classes[] = {CLASS1,CLASS2};                                            \
    NvCreateObject(ppdev,FALSE, PARM, OBJ, &createObjClass, &createObjFail, 2, classes); \
}    

#define NV_CREATE_OBJECT_PARM_PIO3(PARM, OBJ, CLASS1, CLASS2, CLASS3) {                             \
    NvU32 classes[] = {CLASS1,CLASS2,CLASS3};                                            \
    NvCreateObject(ppdev,FALSE, PARM, OBJ, &createObjClass, &createObjFail, 3, classes); \
}    

#define NV_CREATE_DMA1(PARMS,OBJ,CLASS1) {                                          \
    NvU32 classes[] = {CLASS1};                                                     \
    NvCreateObject(ppdev,TRUE, PARMS, OBJ, &createObjClass, &createObjFail, 1, classes);    \
}
#define NV_CREATE_DMA2(PARMS,OBJ,CLASS1,CLASS2) {                                   \
    NvU32 classes[] = {CLASS1,CLASS2};                                              \
    NvCreateObject(ppdev,TRUE, PARMS, OBJ, &createObjClass, &createObjFail, 2, classes);    \
}
#define NV_CREATE_DMA3(PARMS,OBJ,CLASS1,CLASS2,CLASS3) {                            \
    NvU32 classes[] = {CLASS1,CLASS2,CLASS3};                                       \
    NvCreateObject(ppdev,TRUE, PARMS, OBJ, &createObjClass, &createObjFail, 3, classes);    \
}
#define NV_CREATE_DMA4(PARMS,OBJ,CLASS1,CLASS2,CLASS3,CLASS4) {                     \
    NvU32 classes[] = {CLASS1,CLASS2,CLASS3,CLASS4};                                \
    NvCreateObject(ppdev,TRUE, PARMS, OBJ, &createObjClass, &createObjFail, 4, classes);    \
}
#define NV_CREATE_DMA5(PARMS,OBJ,CLASS1,CLASS2,CLASS3,CLASS4,CLASS5) {              \
    NvU32 classes[] = {CLASS1,CLASS2,CLASS3,CLASS4,CLASS5};                         \
    NvCreateObject(ppdev,TRUE, PARMS, OBJ, &createObjClass, &createObjFail, 5, classes);    \
}

#define NV_CREATE_OBJECT_DMA1(OBJ,CLASS1) \
        NV_CREATE_DMA1(NULL,OBJ,CLASS1);
#define NV_CREATE_OBJECT_DMA2(OBJ,CLASS1,CLASS2) \
        NV_CREATE_DMA2(NULL,OBJ,CLASS1,CLASS2);
#define NV_CREATE_OBJECT_DMA3(OBJ,CLASS1,CLASS2,CLASS3) \
        NV_CREATE_DMA3(NULL,OBJ,CLASS1,CLASS2,CLASS3);
#define NV_CREATE_OBJECT_DMA4(OBJ,CLASS1,CLASS2,CLASS3,CLASS4) \
        NV_CREATE_DMA4(NULL,OBJ,CLASS1,CLASS2,CLASS3,CLASS4);
#define NV_CREATE_OBJECT_DMA5(OBJ,CLASS1,CLASS2,CLASS3,CLASS4,CLASS5) \
        NV_CREATE_DMA5(NULL,OBJ,CLASS1,CLASS2,CLASS3,CLASS4,CLASS5);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nv_ref.h ===
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/***************************************************************************\
*                                                                           *
*               Hardware Reference Manual extracted defines.                *
*                                                                           *
\***************************************************************************/
#ifndef _NV_REF_H_

#ifdef NV1_HW
//
// VGA hardware is supported on NV1
//
#define NV_VGA	1
//#include <nv1b_ref.h>
#include <nv1c_ref.h>
#endif
#ifdef NV2_HW
//
// NV2_REF.H Plus (defines which should be in NV2_REF.H)
// These defines are specific to NV2
//
#define NV_PCART_NVM_TRANSFER_SIZE_MAX	0x1000

#define NV_PGRAPH_CTX_SWITCH_COLOR_BUFFER_R5G5B5	0
#define NV_PGRAPH_CTX_SWITCH_COLOR_BUFFER_R8G8B8	1
#define NV_PGRAPH_CTX_SWITCH_COLOR_BUFFER_R10G10B10	2
#define NV_PGRAPH_CTX_SWITCH_COLOR_BUFFER_Y8	    3
#define NV_PGRAPH_CTX_SWITCH_COLOR_BUFFER_Y16	    4

//
// VGA hardware is not supported on NV2
//
#include <nv2_ref.h>
#endif

#ifdef NV3_HW
//
// VGA hardware is supported on NV1
//
#define NV_VGA	1
#include <nv3_ref.h>

#define NV_PFIFO_CACHE1_SIZE								  32
#else 
//
// NV2_REF.H Plus (defines which should be in NV2_REF.H)
// These defines are common to both NV1 and NV2
//
#define NV_PGRAPH_TRAPPED_ADDR_CLASS                          22:16
#define NV_PFIFO_CACHE1_SIZE								  32
#endif // NV3_HW


//*****************************************************************************
// 
// NV1/NV3/NV4/ conventions....
//
//   This modeset code was originally designed to be compiled for each
//   version of the chip (NV1/NV3/NV4).  However, this miniport was designed
//   to work with ALL versions of the chip.  That is, the original modeset
//   code had to be compiled for each chip.  But since this miniport
//   determines which chip it's running on at RUN time (i.e. we don't
//   compile several versions of the miniport) we need to use the following 
//   convention:
//
//      MODESET.C SHOULD ONLY CONTAIN NV3 SPECIFIC CODE
//      (OR CODE THAT HAS *NOT* CHANGED ACROSS CHIPS) !!
//
//   Mainly because NV_REF.H already includes NV3_REF.H.
//   For code which is different from NV3, that code
//   should exist separately in NV4.C/NV5.C/...etc...
//   
//   We'll follow the convention that the Miniport decides at runtime
//   which chip it's running on (i.e. only ONE miniport instead of 
//   compiling several versions for each type of chip).  
//
//*****************************************************************************


#ifdef BM_BUG
//
// There is a bug in the RevB hardware when bus mastering on certain chip sets.
// These macros enable & disable bus mastering around certain registers that
// could be corrupted by the bug.
//
extern unsigned long pciConfigMasterEnable;
extern unsigned long pciConfigMasterDisable;
extern unsigned long pciBusMasterBug;
#define BUG_BM_OFF()                                                        \
    if (pciBusMasterBug){                                                   \
        REG_WR32(NV_PBUS_PCI_NV_1, pciConfigMasterDisable);                 \
    }
#define BUG_BM_ON()                                                         \
    if (pciBusMasterBug){                                                   \
        REG_WR32(NV_PBUS_PCI_NV_1, pciConfigMasterEnable);                  \
    }
#else
#define BUG_BM_OFF()
#define BUG_BM_ON()
#endif // BM_BUG
#endif // _NV_REF_H_
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvrmcomm.h ===
// header file for nvrmcomm.c

BOOL NvRmOpen();
BOOL NvRmClose();
BOOL NvRmIoControl(PVIDEO_REQUEST_PACKET RequestPacket);
BOOL NvrmIoctl(PVIDEO_REQUEST_PACKET RequestPacket);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\tv.h ===
#ifndef _TV_H_
#define _TV_H_
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
/***************************************************************************\
*                                                                           *
* Module: TV.H                                                              *
*       The TV flicker filter constants are defined in this module.         *
*                                                                           *
*****************************************************************************
*/

//---------------------------------------------------------------------------
//
//  Defines.
//
//---------------------------------------------------------------------------

#define	MY_SCALED_IMAGE_CTX	0x97100200
#define	X_RES	(640)		// source x
#define	Y_RES	(480)		// source y
//#define DST_X_RES (640)		// destination x
//#define DST_Y_RES (480)		// destination y
#define DST_X_RES (620)		// destination x
#define DST_Y_RES (420)		// destination y
#endif // _TV_H#
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\nvsysmem.c ===
//******************************************************************************
//
// Copyright (c) 1992  Microsoft Corporation
//
// Module Name:
//
//     NVSYSMEM.C
//
// Abstract:
//
//     This is a few utility routines that map memory.
//
// Environment:
//
//     kernel mode only
//
// Notes:
//
// Revision History:
//
//******************************************************************************

//******************************************************************************
//
// Copyright (c) 1996,1997,1998  NVidia Corporation. All Rights Reserved
//
//******************************************************************************

#include <ntddk.h>
#include <windef.h>
// jsw...
//#undef WIN32

#include "nvos.h"
#include "dspioctl.h"

// polymorphic type stubs for NT4
#if (_WIN32_WINNT < 0x0500)
#define SIZE_T ULONG
#define ULONG_PTR ULONG
#endif // _WIN32_WINNT < 0x0500

// TO DO: temporary constant until a better place is found (from nvgfx.h)
#define ADDR_SPACE_IO           0x00
#define ADDR_SPACE_MEM          0x01
#define MEMORY_MAPPED_IO        0x00

// Taken from video.h
//
// Debugging statements. This will remove all the debug information from the
// "free" version.
//

#if DBG
#define VideoDebugPrint(arg) VideoPortDebugPrint arg
#else
#define VideoDebugPrint(arg)
#endif

VOID
VideoPortDebugPrint(
    ULONG DebugPrintLevel,
    PCHAR DebugMessage,
    ...
    );

static VOID *mapToUserSpace(int addrSpace, PHYSICAL_ADDRESS addr, int bytes);

//******************************************************************************
//
// Function: NVLockdownMemory()
//
// Routine Description:
//
//     Create MDL and lock down the pages for a user supplied memory address.
//
//     Support function for IOCTL_VIDEO_LOCK_DOWN_MEMORY.
//
// Arguments:
//
//     pLockdownMemory - Pointer to description of user memory to be locked down.
//
// Return Value:
//
//     None.
//
//******************************************************************************

void
NvLockdownMemory(
NV_LOCK_DOWN_MEMORY *pLockdownMemory)
{
    MDL *pMdl;
    PHYSICAL_ADDRESS pa;
    NTSTATUS status;
    PVOID systemAddress;
    ULONG offset;

    pLockdownMemory->pMdl = (PVOID)NULL;

    pMdl = IoAllocateMdl(PAGE_ALIGN(pLockdownMemory->virtualAddress),
                         pLockdownMemory->byteLength, // PAGE_SIZE, 
                         FALSE,
                         FALSE, 
                         NULL);

    if (pMdl)
    {
        try 
        {
            if ( (pMdl->MdlFlags & MDL_PAGES_LOCKED)==0)   
                MmProbeAndLockPages(pMdl, KernelMode, IoModifyAccess);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            status = GetExceptionCode();
            VideoDebugPrint((0, "Exception status = 0x%lx\n", (ULONG)status));
            IoFreeMdl (pMdl);
            pMdl = NULL;
        }

        pLockdownMemory->pMdl = (PVOID)pMdl;

        VideoDebugPrint((0, "pMdl = 0x%p\n", pMdl));
    }
}

//******************************************************************************
//
// Function: NVUnlockMemory()
//
// Routine Description:
//
//     Unlock memory and free associated MDL.
//
//     Support function for IOCTL_VIDEO_UNLOCK_MEMORY.
//
// Arguments:
//
//     pUnlockMemory - Pointer to description of user memory to be unlocked.
//
// Return Value:
//
//     None.
//
//******************************************************************************

void
NvUnlockMemory(
NV_UNLOCK_MEMORY *pUnlockMemory)
{
    NTSTATUS status;
    MDL *pMdl;

    pMdl = (MDL *)pUnlockMemory->pMdl;
    if (pMdl)
        {
        try 
            {
                MmUnlockPages(pMdl);
                IoFreeMdl(pMdl);
            }
            except(EXCEPTION_EXECUTE_HANDLER)
            {
                status = GetExceptionCode();
                VideoDebugPrint((0, "Exception status = 0x%lx\n", (ULONG)status));
            }
        }
}

//******************************************************************************
//
// Function: NVSystemMemoryShare()
//
// Routine Description:
//
//     Share a user process memory address with the display driver.  Lock down the
//     memory and then get a system address for it.  Fill in system memory structure
//     with new system memory address for later use by display driver.
//
//     Support function for IOCTL_VIDEO_SYSMEM_SHARE_MEMORY.
//
// Arguments:
//
//     pSysmemShareMemory - Pointer to description of user memory.
//
// Return Value:
//
//     None.
//
//******************************************************************************

void
NvSystemMemoryShare(
NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemory)
{
    MDL *pSystemMdl;
    PHYSICAL_ADDRESS pa;
    NTSTATUS status;
    PVOID systemAddress;
    ULONG_PTR offset;

    pSysmemShareMemory->pSystemMdl = (PVOID)NULL;
    pSysmemShareMemory->physicalAddress = 0;

    pSystemMdl = IoAllocateMdl(PAGE_ALIGN(pSysmemShareMemory->userVirtualAddress),
                               pSysmemShareMemory->byteLength,
                               FALSE,
                               FALSE, 
                               NULL);

    if (pSystemMdl)
    {
        try 
        {
            if ( (pSystemMdl->MdlFlags & MDL_PAGES_LOCKED)==0)   
                MmProbeAndLockPages(pSystemMdl, KernelMode, IoModifyAccess);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            status = GetExceptionCode();
            VideoDebugPrint((0, "Exception status = 0x%lx\n", (ULONG)status));
        }

        pSysmemShareMemory->pSystemMdl = (PVOID)pSystemMdl;
        pa = MmGetPhysicalAddress((PVOID)(PAGE_ALIGN(pSysmemShareMemory->userVirtualAddress)));

        offset = (ULONG_PTR)pSysmemShareMemory->userVirtualAddress & (PAGE_SIZE - 1);

        systemAddress = MmGetSystemAddressForMdl(pSystemMdl);

        pSysmemShareMemory->ddVirtualAddress = (PUCHAR)systemAddress + offset;
        pSysmemShareMemory->physicalAddress = pa.LowPart;

        VideoDebugPrint((0, "pSystemMdl = 0x%p\n", pSystemMdl));
        VideoDebugPrint((0, "physicalAddress = 0x%p\n", pSysmemShareMemory->physicalAddress));
    }
}


//******************************************************************************
//
// Function: NVSystemMemoryUnShare()
//
// Routine Description:
//
//     Unmap a previous shared address.  Unlock the pages.
//
//     Support function for IOCTL_VIDEO_SYSMEM_UNSHARE_MEMORY.
//
// Arguments:
//
//     pSysmemShareMemory - Pointer to description of user memory.
//
// Return Value:
//
//     None.
//
//******************************************************************************

void
NvSystemMemoryUnShare(
NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemory)
{
    if (pSysmemShareMemory && pSysmemShareMemory->pSystemMdl)
    {
        MDL *pSystemMdl = (MDL *)pSysmemShareMemory->pSystemMdl;

        VideoDebugPrint((0, "pSystemMdl = 0x%p\n", pSystemMdl));
        VideoDebugPrint((0, "physicalAddress = 0x%p\n", pSysmemShareMemory->physicalAddress));

        MmUnlockPages(pSystemMdl);
        IoFreeMdl(pSystemMdl);

        pSysmemShareMemory->pSystemMdl = (PVOID)NULL;
    }
}

//******************************************************************************
//
// Function: NVMapIntoUserSpace()
//
// Routine Description:
//
//     Map a give memory address into user address space.  The incoming address
//     should be a kernel mode address.  
//
//     Support function for IOCTL_VIDEO_MAP_TO_USER.
//
// Arguments:
//
//     pSysmemShareMemory - Pointer to description of user memory.
//
// Return Value:
//
//     None.
//
//******************************************************************************

void
NvMapIntoUserSpace(
NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemory)
{
    PHYSICAL_ADDRESS pa;
    MDL *pSystemMdl;
    NTSTATUS status;

    // we use MmMapLockedPages to map the requested area into user space.
    //
    // THIS IS THE RECOMMENDED WAY TO DO THIS AS DESCRIBED IN 
    // Q191/8/40 Share memory between UserMode and Kernel Mode
    //
    // if we ran NT4 less SP3 with a not page-aligned ddVirtualAddress, we may experience
    // different results. However all mem allocated by the display driver, is aligned
    // to a 32k boundary. So this is not problem so far.
    ASSERT(PAGE_ALIGN(pSysmemShareMemory->ddVirtualAddress) == pSysmemShareMemory->ddVirtualAddress);

    pSystemMdl = pSysmemShareMemory->pSystemMdl;

    if (!pSysmemShareMemory->bDontModifyMDL)
    {
        ASSERT(!pSystemMdl);
        pSysmemShareMemory->physicalAddress = 0;

        pSystemMdl = IoAllocateMdl(PAGE_ALIGN(pSysmemShareMemory->ddVirtualAddress),
                                pSysmemShareMemory->byteLength,
                                FALSE,
                                FALSE, 
                                NULL);
    }

    if (pSystemMdl != NULL)
    {
        try 
        {
            if ( (pSystemMdl->MdlFlags & MDL_PAGES_LOCKED)==0)   
                MmProbeAndLockPages(pSystemMdl, KernelMode, IoModifyAccess);
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            status = GetExceptionCode();
            VideoDebugPrint((0, "Exception status = 0x%lx\n", (ULONG)status));
        }

        //
        // Map display driver address into the address space of the current thread.
        //
        pa = MmGetPhysicalAddress((PVOID)(PAGE_ALIGN(pSysmemShareMemory->ddVirtualAddress)));
#if (_WIN32_WINNT >= 0x0500)
        // this method is used to map display driver allocated memory into user space -> MMCached
        // if this methods fails, the display driver has to handle this, no BUGCHECK
        // if we can map the pages and are within a modeswitch ... -> high prio
        // removes driver verifier message
        pSysmemShareMemory->userVirtualAddress = MmMapLockedPagesSpecifyCache(pSystemMdl, UserMode, MmCached, NULL, FALSE, HighPagePriority);
#else
        pSysmemShareMemory->userVirtualAddress = MmMapLockedPages(pSystemMdl, UserMode);
#endif
        pSysmemShareMemory->physicalAddress = pa.LowPart;
        pSysmemShareMemory->pSystemMdl = (PVOID)pSystemMdl;

        VideoDebugPrint((0, "mapped pSystemMdl = 0x%p\n", pSystemMdl));
        VideoDebugPrint((0, "mapped va = 0x%p\n", pSysmemShareMemory->userVirtualAddress));
    }
}

//******************************************************************************
//
// Function: NVUnmapFromUserSpace()
//
// Routine Description:
//
//     Unmap a previously mapped user address.
//
//     Support function for IOCTL_VIDEO_UNMAP_FROM_USER.
//
// Arguments:
//
//     pSysmemShareMemory - Pointer to description of user memory.
//
// Return Value:
//
//     None.
//
//******************************************************************************

void
NvUnmapFromUserSpace(
NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemory)
{
    NTSTATUS status;

    if (pSysmemShareMemory)
    {
        MDL *pSystemMdl = (MDL *)pSysmemShareMemory->pSystemMdl;

        VideoDebugPrint((0, "unmap pSystemMdl = 0x%p\n", pSystemMdl));
        VideoDebugPrint((0, "unmap va = 0x%p\n", pSysmemShareMemory->userVirtualAddress));

        // *remove usermode mapping*
        // if the usermode process crashed, this mapping does not exist anymore,
        // because windows already removed it. The code is protected against this.
        try 
        {
            ASSERT(pSystemMdl);
            if (MmIsAddressValid(pSysmemShareMemory->userVirtualAddress))
            {
                // unfortunately the check above does not gurantee that the address is valid
                // so try/exect will catch this.
                MmUnmapLockedPages(pSysmemShareMemory->userVirtualAddress, pSystemMdl);
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            status = GetExceptionCode();
            VideoDebugPrint((0, "Exception status = 0x%lx\n", (ULONG)status));
        }
        if (!pSysmemShareMemory->bDontModifyMDL)
        {
            try 
                {
                    ASSERT(pSystemMdl);
                    MmUnlockPages(pSystemMdl);
                    IoFreeMdl(pSystemMdl);
                }
            except(EXCEPTION_EXECUTE_HANDLER)
                {
                    status = GetExceptionCode();
                    VideoDebugPrint((0, "Exception status = 0x%lx\n", (ULONG)status));
                }
            pSysmemShareMemory->pSystemMdl = (PVOID)NULL;
        }
    }
}

//******************************************************************************
//
// Function: NVMapPhysIntoUserSpace()
//
// Routine Description:
//
//     Map a physical address and length into a user address space.
//
//     Support function for IOCTL_VIDEO_MAP_NV_PFIFO_USER.
//
// Arguments:
//
//     pa - physical address
//     byteLength - bytes in mapping
//     lowPart - 32-bit return address
//
// Return Value:
//
//     None.
//
//******************************************************************************

void
NVMapPhysIntoUserSpace(
PHYSICAL_ADDRESS pa,
LONG byteLength,
PVOID *userVirtualAddress)
{
    //
    // Map physical address into the address space of the current thread.
    //
    *userVirtualAddress = mapToUserSpace(ADDR_SPACE_MEM, pa, byteLength);
}

//******************************************************************************
//
// Function: NVUnmapPhysFromUserSpace()
//
// Routine Description:
//
//     Unmap a previously mapped user address.
//
//     Support function for IOCTL_VIDEO_UNMAP_NV_PFIFO_USER and
//                          IOCTL_VIDEO_UNMAP_NV_PBUS_USER
//
// Arguments:
//
//     pSysmemShareMemory - Pointer to description of user memory.
//
// Return Value:
//
//     None.
//
//******************************************************************************

void
NvUnmapPhysFromUserSpace(
NV_SYSMEM_SHARE_MEMORY *pSysmemShareMemory)
{
    NTSTATUS status;

    if (pSysmemShareMemory)
    {
        MDL *pSystemMdl = (MDL *)pSysmemShareMemory->pSystemMdl;

        VideoDebugPrint((0, "unmap physical pSystemMdl = 0x%p\n", pSystemMdl));
        VideoDebugPrint((0, "unmap physical va = 0x%p\n", pSysmemShareMemory->userVirtualAddress));

        try 
        {
            ZwUnmapViewOfSection((HANDLE)-1,          // current process handle
                                  (PVOID)pSysmemShareMemory->userVirtualAddress);
            if (!pSysmemShareMemory->bDontModifyMDL)
            {
                ASSERT(pSystemMdl);
                MmUnlockPages(pSystemMdl);
                IoFreeMdl(pSystemMdl);
            }
        }
        except(EXCEPTION_EXECUTE_HANDLER)
        {
            status = GetExceptionCode();
            VideoDebugPrint((0, "Exception status = 0x%lx\n", (ULONG)status));
        }

        pSysmemShareMemory->pSystemMdl = (PVOID)NULL;
    }
}

//******************************************************************************
//
// Function: mapToUserSpace()
//
// Routine Description:
//
//     Map a give memory address into user address space.  The incoming address
//     should be a kernel mode address.
//
//     Support function for IOCTL_VIDEO_MAP_TO_USER.
//
// Arguments:
//
//     pSysmemShareMemory - Pointer to description of user memory.
//
// Return Value:
//
//     None.
//
//******************************************************************************

static VOID *
mapToUserSpace(
    int addrSpace, 
    PHYSICAL_ADDRESS addr, 
    int bytes)
{
    UNICODE_STRING     physicalMemoryUnicodeString;
    OBJECT_ATTRIBUTES  objectAttributes;
    HANDLE             physicalMemoryHandle  = NULL;
    void              *physicalMemorySection = NULL;
    void              *virtualAddress;
    PHYSICAL_ADDRESS   viewBase; 
    SIZE_T             viewSize;
    ULONG              length;
    NTSTATUS ntStatus;

    RtlInitUnicodeString(&physicalMemoryUnicodeString, 
        L"\\Device\\PhysicalMemory"); 
    InitializeObjectAttributes(&objectAttributes, 
        &physicalMemoryUnicodeString, 
        OBJ_CASE_INSENSITIVE, 
        (HANDLE) NULL, 
        (PSECURITY_DESCRIPTOR) NULL); 
 
    ntStatus = ZwOpenSection(&physicalMemoryHandle, 
        SECTION_ALL_ACCESS, &objectAttributes); 
 
    if (!NT_SUCCESS(ntStatus)) { 
        VideoDebugPrint((0, "NV: mapToUser\n"));
        return NULL;
    }

    ntStatus = ObReferenceObjectByHandle(physicalMemoryHandle, 
        SECTION_ALL_ACCESS, (POBJECT_TYPE) NULL, 
        KernelMode, &physicalMemorySection, 
        (POBJECT_HANDLE_INFORMATION) NULL); 
 
    if (!NT_SUCCESS(ntStatus)) { 
        VideoDebugPrint((0, "NV: ObjREferenceObjectByHandle\n"));
        ZwClose(physicalMemoryHandle); 
        return NULL;
    } 

    length = bytes;
    // 
    // initialize view base that will receive the physical mapped 
    // address after the MapViewOfSection call. 
    // 
    viewBase = addr; 
    // 
    // Let ZwMapViewOfSection pick an address 
    // 
    virtualAddress = NULL;
    // 
    // Map the section 
    // 
    viewSize = length;
    ntStatus = ZwMapViewOfSection(
        physicalMemoryHandle, // section handle
        (HANDLE) -1,          // current process handle
        &virtualAddress,      // base address
        0L,                   // zero bits
        length,               // commit size
        &viewBase,            // section offset
        &viewSize,            // view size
        ViewUnmap,            // unmap for children processes
        0,                    // allocation type
        ((addrSpace == ADDR_SPACE_IO) ? (PAGE_READWRITE | PAGE_NOCACHE)
         : PAGE_READWRITE));  // page protection
 
    if (!NT_SUCCESS(ntStatus)) {
        VideoDebugPrint((0, "NV: ZwMapViewOfSection\n"));
        ZwClose(physicalMemoryHandle); 
        return NULL;
    }

    // 
    // Mapping the section above rounded the physical address down to the 
    // nearest 64 K boundary. Now return a virtual address that sits where 
    // we wnat by adding in the offset from the beginning of the section. 
    // 
    (PUCHAR)virtualAddress += addr.LowPart - viewBase.LowPart; 

    ZwClose(physicalMemoryHandle); 

    return virtualAddress;
} // end of mapToUser() 

ULONG NVObReferenceObjectByHandle(HANDLE hRing3, HANDLE* hRing0)
{
    return ObReferenceObjectByHandle(hRing3, 0, NULL, KernelMode, hRing0, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\oldnv332.h ===
/***************************************************************************\
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NOTICE TO USER:   The source code  is copyrighted under  U.S. and     *|
|*     international laws.  Users and possessors of this source code are     *|
|*     hereby granted a nonexclusive,  royalty-free copyright license to     *|
|*     use this code in individual and commercial software.                  *|
|*                                                                           *|
|*     Any use of this source code must include,  in the user documenta-     *|
|*     tion and  internal comments to the code,  notices to the end user     *|
|*     as follows:                                                           *|
|*                                                                           *|
|*       Copyright 1993-1998 NVIDIA, Corporation.  All rights reserved.      *|
|*                                                                           *|
|*     NVIDIA, CORPORATION MAKES NO REPRESENTATION ABOUT THE SUITABILITY     *|
|*     OF  THIS SOURCE  CODE  FOR ANY PURPOSE.  IT IS  PROVIDED  "AS IS"     *|
|*     WITHOUT EXPRESS OR IMPLIED WARRANTY OF ANY KIND.  NVIDIA, CORPOR-     *|
|*     ATION DISCLAIMS ALL WARRANTIES  WITH REGARD  TO THIS SOURCE CODE,     *|
|*     INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY, NONINFRINGE-     *|
|*     MENT,  AND FITNESS  FOR A PARTICULAR PURPOSE.   IN NO EVENT SHALL     *|
|*     NVIDIA, CORPORATION  BE LIABLE FOR ANY SPECIAL,  INDIRECT,  INCI-     *|
|*     DENTAL, OR CONSEQUENTIAL DAMAGES,  OR ANY DAMAGES  WHATSOEVER RE-     *|
|*     SULTING FROM LOSS OF USE,  DATA OR PROFITS,  WHETHER IN AN ACTION     *|
|*     OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION,  ARISING OUT OF     *|
|*     OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOURCE CODE.     *|
|*                                                                           *|
|*     U.S. Government  End  Users.   This source code  is a "commercial     *|
|*     item,"  as that  term is  defined at  48 C.F.R. 2.101 (OCT 1995),     *|
|*     consisting  of "commercial  computer  software"  and  "commercial     *|
|*     computer  software  documentation,"  as such  terms  are  used in     *|
|*     48 C.F.R. 12.212 (SEPT 1995)  and is provided to the U.S. Govern-     *|
|*     ment only as  a commercial end item.   Consistent with  48 C.F.R.     *|
|*     12.212 and  48 C.F.R. 227.7202-1 through  227.7202-4 (JUNE 1995),     *|
|*     all U.S. Government End Users  acquire the source code  with only     *|
|*     those rights set forth herein.                                        *|
|*                                                                           *|
 \***************************************************************************/


//******************************************************************************
// WARNING: !!!                                                     WARNING: !!!
//
//    In order to be able to use this same driver source with older nv3 chips and
//    resource manager, this file includes the following OBSOLETE structure
//    definitions. These structures are OBSOLETE and meant to be used with NV3 only.
//
//      NV_CLASS                            (Class 0x01)
//      NV_CONTEXT_DMA_FROM_MEMORY          (Class 0x02)
//      NV_CONTEXT_DMA_TO_MEMORY            (Class 0x03)
//      NV_PATCHCORD_VIDEO                  (Class 0x0a)
//      NV_VIDEO_SINK                       (Class 0x0b)
//      NV_VIDEO_COLOR_MAP                  (Class 0x0d)
//      NV_PATCHCORD_IMAGE                  (Class 0x0e)
//      NV_IMAGE_STENCIL                    (Class 0x10)
//      NV_IMAGE_ROP_AND                    (Class 0x13)
//      NV_IMAGE_COLOR_KEY                  (Class 0x15)
//      NV_IMAGE_SOLID                      (Class 0x17)
//      NV_IMAGE_PATTERN                    (Class 0x18)
//      NV_IMAGE_BLACK_RECTANGLE            (Class 0x19)
//      NV_RENDER_SOLID_LIN                 (Class 0x1c)
//      NV_RENDER_SOLID_RECTANGLE           (Class 0x1e)
//      NV_IMAGE_BLIT                       (Class 0x1f)
//      NV_IMAGE_FROM_CPU                   (Class 0x21)
//      NV_PATCHCORD_ROP                    (Class 0x33)
//      NV_MEMORY_TO_MEMORY_FORMAT          (Class 0x39)
//      NV_CONTEXT_DMA_IN_MEMORY            (Class 0x3d)
//      IMAGE_IN_MEMORY                     (Class 0x3e)
//      NV_VIDEO_FROM_MEMORY                (Class 0x3f)
//      NV_VIDEO_SCALER                     (Class 0x40)
//      NV_VIDEO_COLOR_KEY                  (Class 0x41)
//      NV_ROP5_SOLID                       (Class 0x43)
//      ZETA_BUFFER_IN_MEMORY               (Class 0x45)
//      NV_PATCHCORD_ZETA                   (Class 0x46)
//      NV_RENDER_D3D0_TRIANGLE_ZETA        (Class 0x48)
//      NV_RENDER_GDI0_RECTANGLE_AND_TEXT   (Class 0x4b)
//
//    The following NV3 VIDEO classes are still supported in NV4 but their
//    CLASS id numbers are DIFFERENT depending on which resman/chip you use !!!!
//    (resman.050 supports NV4 , resman.040 supports NV3)
//
//          RESMAN.050                                  RESMAN.040
//          ----------                                  ----------
//      NV4_VIDEO_COLOR_KEY (class 0xFF6) is same as NV_VIDEO_COLOR_KEY (class 0x41)
//      NV4_VIDEO_SCALER    (class 0xFF7) is same as NV_VIDEO_SCALER    (class 0x40)
//      NV4_VIDEO_COLORMAP  (class 0xFF9) is same as NV_VIDEO_COLORMAP  (class 0xd)
//
//
// WARNING: !!!                                                     WARNING: !!!
//******************************************************************************

#include <nvtypes.h>

//******************************************************************************
// The following classes are no longer supported beginning with NV4 !!!   |
//                                                                        |
// In order to be able to use this driver with the older nv3 chips      | | |
// and resource manager, we include the old obsolete structure           | |
// definitions in this separate header file.                              |
//
//******************************************************************************


/***** SetMonochromeFormat values *****/
#define NV_MONO_LE_M1_P32          0x00000000
#define NV_MONO_CGA6_M1_P32        0x00000001
#define NV_MONOCHROME_FORMAT_LE_M1_P32     0x00000000
#define NV_MONOCHROME_FORMAT_CGA6_M1_P32   0x00000001

//------------------------------------------------------------------------------
// SetColorFormat Values (old style global color format)
//
// The format names precisely specify how the bits are arranged
// in a 32-bit write of a color or colors in that format in a
// little-endian system.  For example NV_COLOR_FORMAT_LE_X17R5G5B5
// means the upper 17 bits are ignored, then 5 bits each of
// Red, Green, and Blue intensity:
//
//   3                             1 1
//   1                             6 5                             0
//  |X X X X X X X X X X X X X X X X X R R R R R G G G G G B B B B B|
//
//------------------------------------------------------------------------------

/* Unpacked color formats */
#define NV_COLOR_FORMAT_LE_X17R5G5B5       0x00000000
#define NV_COLOR_FORMAT_LE_X16A1R5G5B5     0x00100000
#define NV_COLOR_FORMAT_LE_X24Y8           0x00010000
/* Packed color formats -- more than one value per 32-bit write */
#define NV_COLOR_FORMAT_LE_X1R5G5B5_P2     0x01000000
#define NV_COLOR_FORMAT_LE_A1R5G5B5_P2     0x01100000
#define NV_COLOR_FORMAT_LE_Y8_P4           0x01010000
/* No difference between packed and unpacked */
#define NV_COLOR_FORMAT_LE_X8R8G8B8        0x00000001
#define NV_COLOR_FORMAT_LE_A8R8G8B8        0x00100001
#define NV_COLOR_FORMAT_LE_X2R10G10B10     0x00000002
#define NV_COLOR_FORMAT_LE_A2R10G10B10     0x00100002
#define NV_COLOR_FORMAT_LE_X16A8Y8         0x00110000
#define NV_COLOR_FORMAT_LE_X16Y16          0x00010001
#define NV_COLOR_FORMAT_LE_A16Y16          0x00110001

//------------------------------------------------------------------------------
// These defines are not present in the latest nv32.h file.
// So we'll include them here (so we can support old style pre-NV4 drivers).
//------------------------------------------------------------------------------

#define NV_IP_PATTERN_SHAPE_8X_8Y               (0x00000000)
#define NV_IP_PATTERN_SHAPE_64X_1Y              (0x00000001)
#define NV_IP_PATTERN_SHAPE_1X_64Y              (0x00000002)

//------------------------------------------------------------------------------
// Client sets NvNotification.status to NV_STATUS_IN_PROGRESS, NV
// sets to a different value when it notifies.
//------------------------------------------------------------------------------

#define NV_STATUS_IN_PROGRESS      255

//------------------------------------------------------------------------------
// The minimum depth of the NV chip's FIFO -- never wait for the free count
// to reach a value greater than NV_GUARANTEED_FIFO_SIZE (124 bytes)!
//------------------------------------------------------------------------------

#define NV_GUARANTEED_FIFO_SIZE                 (0x007C)

//------------------------------------------------------------------------------
// Obsolete classes (pre-NV4)
// We include them here so we can support old style pre-NV4 drivers, as we
// begin to transition to NV4.
//------------------------------------------------------------------------------

/* class NV_CLASS */
#define NV_CLASS  1
typedef volatile struct tagNvClass {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 V032 Create;                  /* 32-bit name of new object       0300-0303*/
 V032 Destroy;                 /* 32-bit name of object           0304-0307*/
 V032 SetNameCtxDma;           /* NV_CONTEXT_DMA_FROM_MEMORY      0308-030b*/
 U032 SetNameStart;            /* offset within ctxdma in bytes   030c-030f*/
 U032 SetNameLength;           /* ASCII O/S name length in bytes  0310-0313*/
 V032 SetEnumerateCtxDma;      /* NV_CONTEXT_DMA_TO_MEMORY        0314-0317*/
 U032 SetEnumerateStart;       /* offset within ctxdma in bytes   0318-031b*/
 U032 SetEnumerateLength;      /* in bytes                        031c-031f*/
 U032 Enumerate;               /* index into instance list        0320-0323*/
 V032 reserved02[0x737];
} NvClass;


/* class NV_CONTEXT_DMA_FROM_MEMORY */
#define NV_CONTEXT_DMA_FROM_MEMORY  2
typedef volatile struct tagNvContextDmaFromMemory {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 struct tagNvSetDmaFromSpecifier {
  V032 address[2];               /* On X86, address[1] is the selector */
  U032 limit;                    /* size of data region in bytes - 1 */
 } SetDmaSpecifier;            /* memory region NV will read      0300-030b*/
 V032 reserved02[0x73d];
} NvContextDmaFromMemory;

#define  NV01_CONTEXT_DMA             0x00000002


/* class NV_CONTEXT_DMA_TO_MEMORY */
#define NV_CONTEXT_DMA_TO_MEMORY  3
typedef volatile struct tagNvContextDmaToMemory {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 struct tagNvSetDmaToSpecifier {
  V032 address[2];               /* On X86, address[1] is the selector */
  U032 limit;                    /* size of data region in bytes - 1   */
 } SetDmaSpecifier;            /* memory region NV will write     0300-030b*/
 V032 reserved02[0x73d];
} NvContextDmaToMemory;


/* class NV_PATCHCORD_VIDEO */
#define NV_PATCHCORD_VIDEO  10
typedef volatile struct tagNvPatchcordVideo {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 V032 Validate;                /* writing any value validates     0300-0303*/
 V032 reserved02[0x73f];
} NvPatchcordVideo;


/* class NV_VIDEO_SINK */
#define NV_VIDEO_SINK  11
typedef volatile struct tagNvVideoSink {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetVideoInput[56];       /* NV_PATCHCORD_VIDEO              0200-02df*/
// V032 SetVideoInputNotifyCtxDma;/*
 V032 reserved02[0x748];
} NvVideoSink;

// Video Class supported in resman.040

/* class NV_VIDEO_COLORMAP */
#define NV_VIDEO_COLORMAP  13
typedef volatile struct tagNvVideoColorMap {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetVideoOutput;          /* NV_PATCHCORD_VIDEO              0200-0203*/
 V032 SetVideoInput;           /* NV_PATCHCORD_VIDEO              0204-0207*/
 V032 reserved02[0x03e];
 V032 SetColormapCtxDma;       /* NV_CONTEXT_DMA_FROM_MEMORY      0300-0303*/
 V032 SetColormapFormat;       /*                                 0304-0307*/
 U032 SetColormapStart;        /* offset in ctxdma in bytes       0308-030b*/
 U032 SetColormapLength;       /* in bytes                        030c-030f*/
 U032 ColormapDirtyStart;      /* start of region to update       0310-0313*/
 U032 ColormapDirtyLength;     /* in bytes, triggers asynch. xfer 0314-0317*/
 V032 reserved03[0x73a];
} NvVideoColorMap;
/* values for NV_VIDEO_COLORMAP SetColormapFormat() */
#define NV_COLORMAP_X8R8G8B8       0x00000000
#define NV_COLORMAP_X2R10G10B10    0x00000001


/* class NV_PATCHCORD_IMAGE */
#define NV_PATCHCORD_IMAGE  14
typedef volatile struct tagNvPatchcordImage {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 V032 Validate;                /* validate connections downstream 0300-0303*/
 V032 reserved02[0x73f];
} NvPatchcordImage;


/* class NV_IMAGE_STENCIL */
#define NV_IMAGE_STENCIL  16
typedef volatile struct tagNvImageStencil {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 SetImageInput[2];        /* P_I, 1 is ImageBlackRectangle   0204-020b*/
 V032 reserved02[0x77d];
} NvImageStencil;


/* class NV_IMAGE_ROP_AND */
#define NV_IMAGE_ROP_AND  19
typedef volatile struct tagNvImageRopAnd {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 SetRopInput;             /* NV_PATCHCORD_ROP                0204-0207*/
 V032 SetImageInput[3];        /* 0 is I2V ImageOut, 2 is pattern 0208-0213*/
 V032 reserved02[0x77b];
} NvImageRopAnd;


/* class NV_IMAGE_COLOR_KEY */
#define NV_IMAGE_COLOR_KEY  21
typedef volatile struct tagNvImageColorKey {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 SetImageInput[2];        /* P_I, 1 from ImageSolidColor     0204-020b*/
 V032 reserved02[0x77d];
} NvImageColorKey;


/* class NV_IMAGE_SOLID */
#define NV_IMAGE_SOLID  23
typedef volatile struct tagNvImageSolid {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* must be an unpacked format      0300-0303*/
 V032 SetColor;                /* color to fill the image         0304-0307*/
 V032 reserved03[0x73e];
} NvImageSolid;


/* class NV_IMAGE_PATTERN */
#define NV_IMAGE_PATTERN  24
typedef volatile struct tagNvImagePattern {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* Color 0/1, must be unpacked fmt 0300-0303*/
 V032 SetMonochromeFormat;     /* a NV_MONOCHROME_FORMAT_XX value 0304-0307*/
 V032 SetPatternShape;         /* NV_PATTERN_SHAPE_{8X8,64X1,1X64}0308-030b*/
 V032 reserved03[0x001];
 V032 SetColor0;               /* "background" color where pat=0  0310-0313*/
 V032 SetColor1;               /* "foreground" color where pat=1  0314-0317*/
 struct tagNvSetPattern {
  V032 monochrome[2];
 } SetPattern;                 /* 64 bits of pattern data         0318-031f*/
 V032 reserved04[0x738];
} NvImagePattern;
/* values for NV_IMAGE_PATTERN SetPatternShape() */
#define NV_PATTERN_SHAPE_8X8   0x00000000
#define NV_PATTERN_SHAPE_64X1  0x00000001
#define NV_PATTERN_SHAPE_1X64  0x00000002


/* class NV_IMAGE_BLACK_RECTANGLE */
#define NV_IMAGE_BLACK_RECTANGLE  25
typedef volatile struct tagNvImageBlackRectangle {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* P_I usually to NV_IMAGE_STENCIL 0200-0203*/
 V032 reserved02[0x03f];
 struct tagNvSetRectangle {
  V032 y_x;                      /* S16_S16 in pixels, 0 at top left 00-03*/
  V032 height_width;             /* U16_U16 in pixels                04-07*/
 } SetRectangle;               /* region in image where alpha=1   0300-0307*/
 V032 reserved03[0x73e];
} NvImageBlackRectangle;


/* class NV_RENDER_SOLID_LIN */
#define NV_RENDER_SOLID_LIN  28
typedef volatile struct tagNvRenderSolidLin {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* must be an unpacked format      0300-0303*/
 V032 Color;                   /*                                 0304-0307*/
 V032 reserved03[0x03e];
 struct tagNvLin {
  V032 y0_x0;                    /* S16_S16 in pixels, 0 at top left 00-03*/
  V032 y1_x1;                    /* S16_S16 in pixels, 0 at top left 04-07*/
 } Lin[16];                    /*                                 0400-047f*/
 struct tagNvLin32 {
  S032 x0;                         /*                                 00-03*/
  S032 y0;                         /*                                 04-07*/
  S032 x1;                         /*                                 08-0b*/
  S032 y1;                         /*                                 0c-0f*/
 } Lin32[8];                   /*                                 0480-04ff*/
 V032 PolyLin[32];             /*                                 0500-057f*/
 struct tagNvPolyLin32 {
  S032 x;                          /*                                 00-03*/
  S032 y;                          /*                                 04-07*/
 } PolyLin32[16];              /*                                 0580-05ff*/
 struct tagNvColorPolyLin {
  V032 color;                      /*                                 00-03*/
  V032 y_x;                      /* S16_S16 in pixels, 0 at top left 04-07*/
 } ColorPolyLin[16];           /*                                 0600-067f*/
 V032 reserved04[0x660];
} NvRenderSolidLin;


/* class NV_RENDER_SOLID_RECTANGLE */
#define NV_RENDER_SOLID_RECTANGLE  30
typedef volatile struct tagNvRenderSolidRectangle {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /*                                 0300-0303*/
 V032 Color;                   /*                                 0304-0307*/
 V032 reserved03[0x03e];
 struct tagNvRectangle {
  V032 y_x;                      /* S16_S16 in pixels, 0 at top left 00-03*/
  V032 height_width;             /* U16_U16 in pixels                04-07*/
 } Rectangle[16];              /*                                 0400-047f*/
 V032 reserved04[0x6e0];
} NvRenderSolidRectangle;


/* class NV_IMAGE_BLIT */
#define NV_IMAGE_BLIT  31
typedef volatile struct tagNvImageBlit {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 SetImageInput;           /* NV_PATCHCORD_IMAGE              0204-0207*/
 V032 reserved02[0x03e];
 V032 ControlPointIn;          /* S16_S16 in pixels, u.r. of src  0300-0303*/
 V032 ControlPointOut;         /* S16_16 in pixels, u.r. of dest  0304-0307*/
 V032 Size;                    /* U16_U16 in pixels               0308-030b*/
 V032 reserved03[0x73d];
} NvImageBlit;


/* class NV_IMAGE_FROM_CPU */
#define NV_IMAGE_FROM_CPU  33
typedef volatile struct tagNvImageFromCpu {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE              0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* must be a packed format         0300-0303*/
 V032 Point;                   /* y_x S16_S16 in pixels           0304-0307*/
 V032 Size;                    /* height_width U16_U16 in pixels  0308-030b*/
 V032 SizeIn;                  /* height_width U16_U16 in pixels  030c-030f*/
 V032 reserved03[0x03c];
 V032 Color[32];               /* packed pixel(s) to add to image 0400-047f*/
 V032 reserved04[0x6e0];
} NvImageFromCpu;


/* class NV_PATCHCORD_ROP */
#define NV_PATCHCORD_ROP  51
typedef volatile struct tagNvPatchcordRop {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY        0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS 0104-0107*/
 V032 reserved01[0x07e];
 V032 Validate;                /* writing any value validates     0300-0303*/
 V032 reserved02[0x73f];
} NvPatchcordRop;

/* class NV_STRETCHED_IMAGE_FROM_CPU */
#define NV_STRETCHED_IMAGE_FROM_CPU  54
typedef volatile struct {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS   0104-0107*/
 V032 StopTransfer;            /* writing any value stops transfer  0108-010b*/
 V032 reserved01[0x03d];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE                0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* must be a packed format           0300-0303*/
 V032 SizeIn;                  /* height_width U16_U16 in texels    0304-0307*/
 V032 DeltaDxDu;               /* dx/du S12.20                      0308-030b*/
 V032 DeltaDyDv;               /* dy/dv S12.20                      030c-030f*/
 struct {
  V032 y_x;                    /* S16_S16 in pixels, 0 at top left  0310-0313*/
  V032 height_width;           /* U16_U16 in pixels                 0314-0317*/
 } Clip;
 V032 Point12d4;               /* y_x S12.4_S12.4 in pixels         0318-031b*/
 V032 reserved03[0x039];
 V032 Color[1792];             /* packed pixel(s) of one scan line  0400-1fff*/
} NvStretchedImageFromCpu;

/* class NV_SCALED_IMAGE_FROM_MEMORY */
#define NV_SCALED_IMAGE_FROM_MEMORY  55
typedef volatile struct {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS   0104-0107*/
 V032 StopTransfer;            /* writing any value stops transfer  0108-010b*/
 V032 reserved01[0x03d];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE                0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* must be a packed format           0300-0303*/
 V032 SetImageCtxDma;          /* NV_CONTEXT_DMA_FROM_MEMORY        0304-0307*/
 struct {
  V032 y_x;                    /* S16_S16 in pixels, 0 at top left  0308-030b*/
  V032 height_width;           /* U16_U16 in pixels                 030c-030f*/
 } Clip;
 struct {
  V032 y_x;                    /* S16_S16 in pixels, 0 at top left  0310-0313*/
  V032 height_width;           /* U16_U16 in pixels                 0314-0317*/
 } RectangleOut;
 V032 DeltaDuDx;               /* du/dx S12.20                      0318-031b*/
 V032 DeltaDvDy;               /* dv/dy S12.20                      031c-031f*/
 V032 reserved03[0x038];
 struct {
  V032 size;                   /* height_width U16_U16 in texels    0400-0403*/
  U032 pitch;                  /* bytes between lines               0404-0407*/
  U032 offset;                 /* byte offset of top-left texel     0408-040b*/
  V032 point12d4;              /* v_u U12.4_U12.4 in texels         040c-040f*/
 } ImageIn;
 V032 reserved04[0x6fc];
} NvScaledImageFromMemory;
/* additional values for SetColorFormat() */
#define NV_COLOR_FORMAT_LE_V8Y8U8Y8   0x00020000  /* YUYV, YUY2, YUV2 */
#define NV_COLOR_FORMAT_LE_Y8V8Y8U8   0x00020001  /* UYVY, CCIR601    */

/* class NV_SCALED_YUV40_FROM_MEMORY */
#define NV_SCALED_YUV420_FROM_MEMORY  56
typedef volatile struct {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS   0104-0107*/
 V032 StopTransfer;            /* writing any value stops transfer  0108-010b*/
 V032 reserved01[0x03d];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE                0200-0203*/
 V032 reserved02[0x040];
 V032 SetImageCtxDma;          /* NV_CONTEXT_DMA_FROM_MEMORY        0304-0307*/
 struct {
  V032 y_x;                    /* S16_S16 in pixels, 0 at top left  0308-030b*/
  V032 height_width;           /* U16_U16 in pixels                 030c-030f*/
 } Clip;
 struct {
  V032 y_x;                    /* S16_S16 in pixels, 0 at top left  0310-0313*/
  V032 height_width;           /* U16_U16 in pixels                 0314-0317*/
 } RectangleOut;
 V032 DeltaDuDx;               /* du/dx S12.20                      0318-031b*/
 V032 DeltaDvDy;               /* dv/dy S12.20                      031c-031f*/
 V032 reserved03[0x038];
 struct {
  V032 size;                   /* height_width U16_U16 in texels    0400-0403*/
  V032 pitch;                  /* uv_y U16_U16 bytes between lines  0404-0407*/
  U032 offsety;                /* byte offset of top-left Y texel   0408-040b*/
  U032 offsetu;                /* byte offset of top-left U texel   040c-040f*/
  U032 offsetv;                /* byte offset of top-left V texel   0410-0413*/
  V032 point12d4;              /* v_u U12.4_U12.4 of Y in texels    0414-0417*/
 } ImageIn;
 V032 reserved04[0x6fa];
} NvScaledYuv420FromMemory;

/* class NV_MEMORY_TO_MEMORY_FORMAT */
#define NV_MEMORY_TO_MEMORY_FORMAT  57
typedef volatile struct {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS   0104-0107*/
 V032 StopTransfer;            /* writing any value stops transfer  0108-010b*/
 V032 reserved01[0x07d];
 V032 SetBufferInCtxDma;       /* NV_CONTEXT_DMA_FROM_MEMORY        0300-0303*/
 V032 SetBufferOutCtxDma;      /* NV_CONTEXT_DMA_TO_MEMORY          0304-0307*/
 V032 SetBufferNotifyCtxDma;   /* NV_CONTEXT_DMA_TO_MEMORY          0308-030b*/
 struct {
  U032 offsetin;               /* input  ctxdma offset in bytes     030c-030f*/
  U032 offsetout;              /* output ctxdma offset in bytes     0310-0313*/
  S032 pitchin;                /* delta in bytes between scan lines 0314-0317*/
  S032 pitchout;               /* delta in bytes between scan lines 0318-031b*/
  U032 linelengthin;           /* in bytes                          031c-031f*/
  U032 linecount;              /* in lines                          0320-0323*/
  V032 format;                 /* ORed NV_MTMF_FORMAT_*             0324-0327*/
  V032 notify;                 /* notification style, varies w/OS   0328-032b*/
 } BufferTransfer;
 V032 reserved02[0x735];
} NvMemoryToMemoryFormat;
/* values for BufferTransfer.format() */
#define NV_MTMF_FORMAT_INPUT_INC_1     0x00000001
#define NV_MTMF_FORMAT_INPUT_INC_2     0x00000002
#define NV_MTMF_FORMAT_INPUT_INC_4     0x00000004
#define NV_MTMF_FORMAT_OUTPUT_INC_1    0x00000100
#define NV_MTMF_FORMAT_OUTPUT_INC_2    0x00000200
#define NV_MTMF_FORMAT_OUTPUT_INC_4    0x00000400


/* class NV_CONTEXT_DMA_IN_MEMORY */
#define NV_CONTEXT_DMA_IN_MEMORY  61
typedef volatile struct tagNvContextDmaInMemory {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS   0104-0107*/
 V032 reserved01[0x07e];
 struct {
  V032 address[2];             /* On X86 address[1] is the selector 0300-0307*/
  U032 limit;                  /* size of data region in bytes - 1  0308-030b*/
 } SetDmaSpecifier;
 V032 reserved02[0x73d];
} NvContextDmaInMemory;


/* class NV_IMAGE_IN_MEMORY */
#define NV_IMAGE_IN_MEMORY  62
typedef volatile struct {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS   0104-0107*/
 V032 reserved01[0x03e];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE                0200-0203*/
 V032 SetImageInput[63];       /* NV_PATCHCORD_IMAGEs               0204-02ff*/
 V032 SetColorFormat;          /* must be a packed format           0300-0303*/
 V032 SetImageCtxDma;          /* NV_CONTEXT_DMA_IN_MEMORY          0304-0307*/
 S032 SetImagePitch;           /* gap in bytes between scan lines   0308-030b*/
 U032 SetImageOffset;          /* byte offset of top-left pixel     030c-030f*/
 V032 reserved02[0x73c];
} NvImageInMemory;
/* additional values for SetColorFormat() */
#define NV_COLOR_FORMAT_LE_Y16_P2   0x01010001


/* class NV_VIDEO_FROM_MEMORY */
#define NV_VIDEO_FROM_MEMORY  63
typedef volatile struct {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS   0104-0107*/
 V032 StopTransfer;            /* writing any value stops transfer  0108-010b*/
 V032 reserved01[0x03d];
 V032 SetVideoOutput;          /* NV_PATCHCORD_VIDEO                0200-0203*/
 V032 reserved02[0x03f];
 V032 SetImageCtxDma[2];       /* NV_CONTEXT_DMA_FROM_MEMORY        0300-0307*/
 V032 SetImageNotifyCtxDma[2]; /* NV_CONTEXT_DMA_TO_MEMORY          0308-030f*/
 struct {                      /*                                   0310-    */
  U032 offset;                 /* byte offset of top-left pixel       00-  03*/
  U032 pitch;                  /* bytes between lines                 04-  07*/
  V032 size;                   /* height_width U16_U16 in pixels      08-  0b*/
  V032 format;                 /* ORed NV_VFM_IMAGE_FORMAT_*          0c-  0f*/
  V032 notify;                 /* notification style, varies w/OS     10-  13*/
 } ImageScan[2];               /*                                       -0337*/
 V032 reserved03[0x732];
} NvVideoFromMemory;
/* values for ImageScan.format() */
#define NV_VFM_FORMAT_NEXT_FIELD_EVEN        0x00000000
#define NV_VFM_FORMAT_NEXT_FIELD_ODD         0x80000000
#define NV_VFM_FORMAT_COLOR_LE_Y8_P4         0x01010000
#define NV_VFM_FORMAT_COLOR_LE_X1R5G5B5_P2   0x01000000
#define NV_VFM_FORMAT_COLOR_LE_X8R8G8B8      0x00000001
#define NV_VFM_FORMAT_COLOR_LE_V8Y8U8Y8      0x00020000
#define NV_VFM_FORMAT_COLOR_LE_Y8V8Y8U8      0x00020001

// Video Class supported in resman.040

/* class NV_VIDEO_SCALER */
#define NV_VIDEO_SCALER  64
typedef volatile struct {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS   0104-0107*/
 V032 reserved01[0x03e];
 V032 SetVideoOutput;          /* NV_PATCHCORD_VIDEO                0200-0203*/
 V032 SetVideoInput;           /* NV_PATCHCORD_VIDEO                0204-0207*/
 V032 reserved02[0x03e];
 V032 SetDeltaDuDx;            /* du/dx S12.20                      0300-0303*/
 V032 SetDeltaDvDy;            /* dv/dy S12.20                      0304-0307*/
 V032 SetPoint;                /* y_x S16_S16 in pixels of origin   0308-030b*/
 V032 reserved03[0x73d];
} NvVideoScaler;


// Video Class supported in resman.040

/* class NV_VIDEO_COLOR_KEY */
#define NV_VIDEO_COLOR_KEY  65
typedef volatile struct {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS   0104-0107*/
 V032 reserved01[0x03e];
 V032 SetVideoOutput;          /* NV_PATCHCORD_VIDEO                0200-0203*/
 V032 SetVideoInput[3];        /* NV_PATCHCORD_VIDEO                0204-020f*/
 V032 reserved02[0x03c];
 V032 SetColorFormat;          /* must be an unpacked format        0300-0303*/
 V032 SetColorKey;             /* color to compare with             0304-0307*/
 V032 SetPoint;                /* y_x, S16_S16 in pixels, top left  0308-030b*/
 V032 SetSize;                 /* height_width, U16_U16 in pixels   030c-030f*/
 V032 reserved03[0x73c];
} NvVideoColorKey;

/* class NV_ROP5_SOLID */
#define NV_ROP5_SOLID  67
typedef volatile struct {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS   0104-0107*/
 V032 reserved01[0x03e];
 V032 SetRopOutput;            /* NV_PATCHCORD_ROP                  0200-0203*/
 V032 reserved02[0x03f];
 V032 SetRop5;                 /* 32-bit ROP5                       0300-0303*/
 V032 reserved03[0x73f];
} NvRop5Solid;


/* class NV_ZETA_BUFFER_IN_MEMORY */
#define NV_ZETA_BUFFER_IN_MEMORY  69
typedef volatile struct {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* NV_NOTIFY_* varies with OS        0104-0107*/
 V032 reserved01[0x03e];
 V032 SetZetaOutput;           /* NV_PATCHCORD_ZETA                 0200-0203*/
 V032 SetZetaInput[63];        /* NV_PATCHCORD_ZETAs                0204-02ff*/
 V032 SetZetaFormat;           /* NV_ZETA_FORMAT_* (packed)         0300-0303*/
 V032 SetZetaCtxDma;           /* NV_CONTEXT_DMA_IN_MEMORY          0304-0307*/
 S032 SetZetaPitch;            /* bytes, vertical zeta delta        0308-030b*/
 U032 SetZetaOffset;           /* byte offset of top-left zeta      030c-030f*/
 V032 reserved02[0x73c];
} NvZetaBufferInMemory;
/* additional values for SetColorFormat() */
#define NV_ZETA_FORMAT_LE_Z16_P2           0x00000000


/* class NV_PATCHCORD_ZETA */
#define NV_PATCHCORD_ZETA  70
typedef volatile struct {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS   0104-0107*/
 V032 reserved01[0x07e];
 V032 Validate;                /* writing any value validates       0300-0303*/
 V032 reserved02[0x73f];
} NvPatchcordZeta;


/* class NV_RENDER_D3D0_TRIANGLE_ZETA */
#define NV_RENDER_D3D0_TRIANGLE_ZETA  72
typedef volatile struct {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* NV_NOTIFY_* varies with OS        0104-0107*/
 V032 StopTransfer;            /* zero, stops transfer              0108-010b*/
 V032 InstantiatePatch;        /* zero, instantiates patch          010c-010f*/
 V032 reserved01[0x03c];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE                0200-0203*/
 V032 SetZetaOutput;           /* NV_PATCHCORD_ZETA                 0204-0207*/
 V032 SetZetaInput;            /* NV_PATCHCORD_ZETA                 0208-020b*/
 V032 reserved02[0x03d];
 V032 SetTextureCtxDma;        /* NV_CONTEXT_DMA_FROM_MEMORY        0300-0303*/
 U032 TextureOffset;           /* offset within ctxdma in bytes     0304-0307*/
 V032 TextureFormat;           /* NV_D3D0_TEXTURE_FORMAT_* OR'd     0308-030b*/
 V032 Filter;                  /* turbo_mipmap_spready_spreadx      030c-030f*/
 V032 FogColor;                /* X8R8G8B8 fog color                0310-0313*/
 V032 Control0;                /* NV_D3D0_CONTROL0_* OR'd           0314-0317*/
 V032 Control1;                /* NV_D3D0_CONTROL1_* OR'd           0318-031b*/
 V032 reserved03[0x339];
 struct {                      /* start of method in array          1000-    */
  V032 specular;               /* fog_i5-i0, U0d8_U004_..._U004       00-  03*/
  V032 color;                  /* X8R8G8B8 or A8R8G8B8, U0d8 chans    04-  07*/
  F032 x;                      /* screen x coordinate                 08-  0b*/
  F032 y;                      /* screen y coordinate                 0c-  0f*/
  F032 z;                      /* screen z coordinate                 10-  13*/
  F032 m;                      /* reciprocal homogenous W (m=1/W)     14-  17*/
  F032 u;                      /* texture u coordinate                18-  1b*/
  F032 v;                      /* texture v coordinate                1c-  1f*/
 } ControlPoint[128];          /* end of method in array                -1fff*/
} NvRenderD3D0TriangleZeta;
/* values for TextureFormat() */
#define NV_D3D0_TEXTURE_FORMAT_COLOR_KEY_COLOR_MASK   0x0000ffff
#define NV_D3D0_TEXTURE_FORMAT_COLOR_KEY_DISABLED     0x00000000
#define NV_D3D0_TEXTURE_FORMAT_COLOR_KEY_ENABLED      0x00010000
#define NV_D3D0_TEXTURE_FORMAT_COLOR_FORMAT_A1R5G5B5  0x00000000
#define NV_D3D0_TEXTURE_FORMAT_COLOR_FORMAT_X1R5G5B5  0x00100000
#define NV_D3D0_TEXTURE_FORMAT_COLOR_FORMAT_A4R4G4G4  0x00200000
#define NV_D3D0_TEXTURE_FORMAT_COLOR_FORMAT_R5G6B5    0x00300000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MIN_4X4           0x02000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MIN_8X8           0x03000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MIN_16X16         0x04000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MIN_32X32         0x05000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MIN_64X64         0x06000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MIN_128X128       0x07000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MIN_256X256       0x08000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MIN_512X512       0x09000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MIN_1024X1024     0x0a000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MIN_2048X2048     0x0b000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MAX_4X4           0x20000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MAX_8X8           0x30000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MAX_16X16         0x40000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MAX_32X32         0x50000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MAX_64X64         0x60000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MAX_128X128       0x70000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MAX_256X256       0x80000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MAX_512X512       0x90000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MAX_1024X1024     0xa0000000
#define NV_D3D0_TEXTURE_FORMAT_SIZE_MAX_2048X2048     0xb0000000
/* values for Control0() */
#define NV_D3D0_CONTROL0_INTERPOLATOR_ZOH             0x00000000
#define NV_D3D0_CONTROL0_INTERPOLATOR_ZOH_MS          0x00000001
#define NV_D3D0_CONTROL0_INTERPOLATOR_FOH             0x00000002
#define NV_D3D0_CONTROL0_WRAP_U_CYLINDRICAL           0x00000000
#define NV_D3D0_CONTROL0_WRAP_U_WRAP                  0x00000010
#define NV_D3D0_CONTROL0_WRAP_U_MIRROR                0x00000020
#define NV_D3D0_CONTROL0_WRAP_U_CLAMP                 0x00000030
#define NV_D3D0_CONTROL0_WRAP_V_CYLINDRICAL           0x00000000
#define NV_D3D0_CONTROL0_WRAP_V_WRAP                  0x00000040
#define NV_D3D0_CONTROL0_WRAP_V_MIRROR                0x00000080
#define NV_D3D0_CONTROL0_WRAP_V_CLAMP                 0x000000c0
#define NV_D3D0_CONTROL0_COLOR_FORMAT_LE_X8R8G8B8     0x00000000
#define NV_D3D0_CONTROL0_COLOR_FORMAT_LE_A8R8G8B8     0x00000100
#define NV_D3D0_CONTROL0_SRCCOLOR_NORMAL              0x00000000
#define NV_D3D0_CONTROL0_SRCCOLOR_COLOR_INVERSE       0x00000400
#define NV_D3D0_CONTROL0_SRCCOLOR_ALPHA_INVERSE       0x00000800
#define NV_D3D0_CONTROL0_SRCCOLOR_ALPHA_ONE           0x00000c00
#define NV_D3D0_CONTROL0_CULLING_NONE                 0x00001000
#define NV_D3D0_CONTROL0_CULLING_COUNTERCLOCKWISE     0x00002000
#define NV_D3D0_CONTROL0_CULLING_CLOCKWISE            0x00003000
#define NV_D3D0_CONTROL0_ZETA_BUFFER_SCREEN           0x00000000
#define NV_D3D0_CONTROL0_ZETA_BUFFER_LINEAR           0x00008000
#define NV_D3D0_CONTROL0_ZETA_COMPARE_FALSE           0x00010000
#define NV_D3D0_CONTROL0_ZETA_COMPARE_LT              0x00020000
#define NV_D3D0_CONTROL0_ZETA_COMPARE_EQ              0x00030000
#define NV_D3D0_CONTROL0_ZETA_COMPARE_LE              0x00040000
#define NV_D3D0_CONTROL0_ZETA_COMPARE_GT              0x00050000
#define NV_D3D0_CONTROL0_ZETA_COMPARE_NE              0x00060000
#define NV_D3D0_CONTROL0_ZETA_COMPARE_GE              0x00070000
#define NV_D3D0_CONTROL0_ZETA_COMPARE_TRUE            0x00080000
#define NV_D3D0_CONTROL0_ZETA_WRITE_NEVER             0x00000000
#define NV_D3D0_CONTROL0_ZETA_WRITE_ALPHA             0x00100000
#define NV_D3D0_CONTROL0_ZETA_WRITE_ALPHA_ZETA        0x00200000
#define NV_D3D0_CONTROL0_ZETA_WRITE_ZETA              0x00300000
#define NV_D3D0_CONTROL0_ZETA_WRITE_ALWAYS            0x00400000
#define NV_D3D0_CONTROL0_COLOR_WRITE_NEVER            0x00000000
#define NV_D3D0_CONTROL0_COLOR_WRITE_ALPHA            0x01000000
#define NV_D3D0_CONTROL0_COLOR_WRITE_ALPHA_ZETA       0x02000000
#define NV_D3D0_CONTROL0_COLOR_WRITE_ZETA             0x03000000
#define NV_D3D0_CONTROL0_COLOR_WRITE_ALWAYS           0x04000000
#define NV_D3D0_CONTROL0_ROP_BLEND_AND                0x00000000
#define NV_D3D0_CONTROL0_ROP_ADD_WITH_SATURATION      0x10000000
#define NV_D3D0_CONTROL0_BLEND_BETA_SRCALPHA          0x00000000
#define NV_D3D0_CONTROL0_BLEND_BETA_DESTCOLOR         0x20000000
#define NV_D3D0_CONTROL0_BLEND_INPUT0_DESTCOLOR       0x00000000
#define NV_D3D0_CONTROL0_BLEND_INPUT0_ZERO            0x40000000
#define NV_D3D0_CONTROL0_BLEND_INPUT1_SRCCOLOR        0x00000000
#define NV_D3D0_CONTROL0_BLEND_INPUT1_ZERO            0x80000000
/* values for Control1() */
#define NV_D3D0_CONTROL1_ALPHA_KEY_MASK               0x000000ff
#define NV_D3D0_CONTROL1_ALPHA_COMPARE_FALSE          0x00000100
#define NV_D3D0_CONTROL1_ALPHA_COMPARE_LT             0x00000200
#define NV_D3D0_CONTROL1_ALPHA_COMPARE_EQ             0x00000300
#define NV_D3D0_CONTROL1_ALPHA_COMPARE_LE             0x00000400
#define NV_D3D0_CONTROL1_ALPHA_COMPARE_GT             0x00000500
#define NV_D3D0_CONTROL1_ALPHA_COMPARE_NE             0x00000600
#define NV_D3D0_CONTROL1_ALPHA_COMPARE_GE             0x00000700
#define NV_D3D0_CONTROL1_ALPHA_COMPARE_TRUE           0x00000800


/* class NV_RENDER_GDI0_RECTANGLE_AND_TEXT */
#define NV_RENDER_GDI0_RECTANGLE_AND_TEXT  75
typedef volatile struct {
 V032 SetNotifyCtxDma;         /* NV_CONTEXT_DMA_TO_MEMORY          0100-0103*/
 V032 SetNotify;               /* notification style, varies w/OS   0104-0107*/
 V032 StopTransfer;            /* writing any value stops transfer  0108-010b*/
 V032 reserved01[0x03d];
 V032 SetImageOutput;          /* NV_PATCHCORD_IMAGE                0200-0203*/
 V032 reserved02[0x03f];
 V032 SetColorFormat;          /* unpacked RGB or Y                 0300-0303*/
 V032 SetMonochromeFormat;     /* NV_MONOCHROME_FORMAT_             0304-0307*/
 V032 reserved03[(0x03e)-1];
 V032 Color1A;                 /* rectangle color                   03fc-03ff*/
 struct {                      /*                                   0400-    */
  V032 x_y;                    /* S16_S16 in pixels, 0 at top left     0-   3*/
  V032 width_height;           /* U16_U16 in pixels                    4-   7*/
 } UnclippedRectangle[64];     /*                                       -05ff*/
 V032 reserved04[(0x080)-3];
 struct {
  V032 top_left;               /* S16_S16 in pixels, inclusive      07f4-07f7*/
  V032 bottom_right;           /* S16_S16 in pixels, exclusive      07f8-07fb*/
 } ClipB;
 V032 Color1B;                 /* rectangle color                   07fc-07ff*/
 struct {                      /*                                   0800-    */
  V032 top_left;               /* S16_S16 in pixels, inclusive         0-   3*/
  V032 bottom_right;           /* S16_S16 in pixels, exclusive         4-   7*/
 } ClippedRectangle[64];       /*                                       -09ff*/
 V032 reserved05[(0x080)-5];
 struct {
  V032 top_left;               /* S16_S16 in pixels, inclusive      0bec-0bef*/
  V032 bottom_right;           /* S16_S16 in pixels, exclusive      0bf0-0bf3*/
 } ClipC;
 V032 Color1C;                 /* color of 1 pixels                 0bf4-0bf7*/
 V032 SizeC;                   /* height_width U16_U16 in pixels    0bf8-0bfb*/
 V032 PointC;                  /* y_x S16_S16 in pixels             0bfc-0bff*/
 V032 MonochromeColor1C[128];  /* 32 monochrome pixels per write    0c00-0dff*/
 V032 reserved06[(0x080)-6];
 struct {
  V032 top_left;               /* S16_S16 in pixels, inclusive      0fe8-0feb*/
  V032 bottom_right;           /* S16_S16 in pixels, exclusive      0fec-0fef*/
 } ClipD;
 V032 Color1D;                 /* color of 1 pixels                 0ff0-0ff3*/
 V032 SizeInD;                 /* height_width U16_U16 in pixels    0ff4-0ff7*/
 V032 SizeOutD;                /* height_width U16_U16 in pixels    0ff8-0ffb*/
 V032 PointD;                  /* y_x S16_S16 in pixels             0ffc-0fff*/
 V032 MonochromeColor1D[128];  /* 32 monochrome pixels per write    1000-11ff*/
 V032 reserved07[(0x080)-7];
 struct {
  V032 top_left;               /* S16_S16 in pixels, inclusive      13e4-13e7*/
  V032 bottom_right;           /* S16_S16 in pixels, exclusive      13e8-13eb*/
 } ClipE;
 V032 Color0E;                 /* color of 0 pixels                 13ec-13ef*/
 V032 Color1E;                 /* color of 1 pixels                 13f0-13f3*/
 V032 SizeInE;                 /* height_width U16_U16 in pixels    13f4-13f7*/
 V032 SizeOutE;                /* height_width U16_U16 in pixels    13f8-13fb*/
 V032 PointE;                  /* y_x S16_S16 in pixels             13fc-13ff*/
 V032 MonochromeColor01E[128]; /* 32 monochrome pixels per write    1400-15ff*/
 V032 reserved08[0x280];
} NvRenderGdi0RectangleAndText;




//******************************************************************************
// The above classes are no longer supported beginning with NV4 !!!       |
//                                                                       | |
// In order to be able to use this driver with the older chips          | | |
// and resource manager, we include the old obsolete structure            |
// definitions.  That way, we don't have to include the old               |
// NV1 NV32.H file.  We only want one NV32.H file.
//******************************************************************************


//******************************************************************************
// Additional classes required for NV3 follow below:
//******************************************************************************


/* class NV01_IMAGE_PATTERN */
#define  NV01_IMAGE_PATTERN                              (0x00000018)
#define  NV1_IMAGE_PATTERN                               (0x00000018)
/* NvNotification[] elements */
#define NV018_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NV018_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NV018_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NV018_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NV018_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NV018_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NV018_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV018_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetImageOutput;          /* NV1_PATCHCORD_IMAGE               0200-0203*/
 V032 Reserved02[0x03f];
 V032 SetColorFormat;          /* NV018_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SetMonochromeFormat;     /* NV018_SET_MONOCHROME_FORMAT_*     0304-0307*/
 V032 SetMonochromeShape;      /* NV018_SET_MONOCHROME_SHAPE_*      0308-030b*/
 V032 Reserved03[0x001];
 V032 SetMonochromeColor0;     /* color of 0 pixels                 0310-0313*/
 V032 SetMonochromeColor1;     /* color of 1 pixels                 0314-0317*/
 V032 SetMonochromePattern0;   /* first  32 bits of pattern data    0318-031b*/
 V032 SetMonochromePattern1;   /* second 32 bits of pattern data    031c-031f*/
 V032 Reserved05[0x738];
} Nv018Typedef, Nv01ImagePattern;
#define Nv1ImagePattern                                  Nv01ImagePattern
#define nv1ImagePattern                                  nv01ImagePattern
#define NV018_TYPEDEF                                    nv01ImagePattern
/* dma method offsets, fields, and values */
#define NV018_SET_OBJECT                                           (0x00000000)
#define NV018_NO_OPERATION                                         (0x00000100)
#define NV018_NOTIFY                                               (0x00000104)
#define NV018_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV018_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV018_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV018_SET_COLOR_FORMAT                                     (0x00000300)
#define NV018_SET_COLOR_FORMAT_LE_X16A8Y8                          (0x00000001)
#define NV018_SET_COLOR_FORMAT_LE_X16A1R5G5B5                      (0x00000002)
#define NV018_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000003)
#define NV018_SET_MONOCHROME_FORMAT                                (0x00000304)
#define NV018_SET_MONOCHROME_FORMAT_CGA6_M1                        (0x00000001)
#define NV018_SET_MONOCHROME_FORMAT_LE_M1                          (0x00000002)
#define NV018_SET_MONOCHROME_SHAPE                                 (0x00000308)
#define NV018_SET_MONOCHROME_SHAPE_8X_8Y                           (0x00000000)
#define NV018_SET_MONOCHROME_SHAPE_64X_1Y                          (0x00000001)
#define NV018_SET_MONOCHROME_SHAPE_1X_64Y                          (0x00000002)
#define NV018_SET_MONOCHORME_COLOR0                                (0x00000310)
#define NV018_SET_MONOCHORME_COLOR1                                (0x00000314)
#define NV018_SET_MONOCHORME_PATTERN0                              (0x00000318)
#define NV018_SET_MONOCHORME_PATTERN1                              (0x0000031C)


/* class NV01_IMAGE_BLACK_RECTANGLE */
#define  NV01_IMAGE_BLACK_RECTANGLE                      (0x00000019)
#define  NV1_IMAGE_BLACK_RECTANGLE                       (0x00000019)
/* NvNotification[] elements */
#define NV019_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NV019_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NV019_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NV019_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NV019_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NV019_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NV019_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV019_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 Reserved01[0x01f];
 V032 SetImageOutput;          /* NV1_PATCHCORD_IMAGE               0200-0203*/
 V032 Reserved02[0x03f];
 V032 SetPoint;                /* y_x S16_S16                       0300-0303*/
 V032 SetSize;                 /* height_width U16_U16              0304-0307*/
 V032 Reserved03[0x73e];
} Nv019Typedef, Nv01ImageBlackRectangle;
#define Nv1ImageBlackRectangle                           Nv01ImageBlackRectangle
#define nv1ImageBlackRectangle                           nv01ImageBlackRectangle
#define NV019_TYPEDEF                                    nv01ImageBlackRectangle
/* dma method offsets, fields, and values */
#define NV019_SET_OBJECT                                           (0x00000000)
#define NV019_NO_OPERATION                                         (0x00000100)
#define NV019_NOTIFY                                               (0x00000104)
#define NV019_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV019_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV019_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV019_SET_POINT                                            (0x00000300)
#define NV019_SET_POINT_X                                          15:0
#define NV019_SET_POINT_Y                                          31:16
#define NV019_SET_SIZE                                             (0x00000304)
#define NV019_SET_SIZE_WIDTH                                       15:0
#define NV019_SET_SIZE_HEIGHT                                      31:16



/* class NV01_RENDER_SOLID_RECTANGLE */
#define  NV01_RENDER_SOLID_RECTANGLE                     (0x0000001E)
#define  NV1_RENDER_SOLID_RECTANGLE                      (0x0000001E)
/* NvNotification[] elements */
#define NV01E_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NV01E_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NV01E_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NV01E_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NV01E_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NV01E_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NV01E_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV01E_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 SetContextClipRectangle; /* NV1_IMAGE_BLACK_RECTANGLE         0184-0187*/
 V032 SetContextPattern;       /* NV1_IMAGE_PATTERN                 0188-018b*/
 V032 SetContextRop;           /* NV3_CONTEXT_ROP                   018c-018f*/
 V032 SetContextBeta1;         /* NV1_BETA_SOLID                    0190-0193*/
 V032 SetContextSurface;       /* NV3_CONTEXT_SURFACE_0             0194-0197*/
 V032 Reserved01[0x059];
 V032 SetOperation;            /* NV01E_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV01E_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Color;                   /* source color                      0304-0307*/
 V032 Reserved02[0x03e];
 struct {                      /* start of aliased methods in array 0400-    */
  V032 point;                  /* y_x S16_S16                          0-   3*/
  V032 size;                   /* height_width U16_U16                 4-   7*/
 } Rectangle[16];              /* end of method in array in array       -047f*/
 V032 Reserved03[0x6e0];
} Nv01eTypedef, Nv01RenderSolidRectangle;
#define Nv1RenderSolidRectangle                          Nv01RenderSolidRectangle
#define nv1RenderSolidRectangle                          nv01RenderSolidRectangle
#define NV01E_TYPEDEF                                    nv01RenderSolidRectangle
/* dma method offsets, fields, and values */
#define NV01E_SET_OBJECT                                           (0x00000000)
#define NV01E_NO_OPERATION                                         (0x00000100)
#define NV01E_NOTIFY                                               (0x00000104)
#define NV01E_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV01E_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV01E_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV01E_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000184)
#define NV01E_SET_CONTEXT_PATTERN                                  (0x00000188)
#define NV01E_SET_CONTEXT_ROP                                      (0x0000018C)
#define NV01E_SET_CONTEXT_BETA1                                    (0x00000190)
#define NV01E_SET_CONTEXT_SURFACE                                  (0x00000194)
#define NV01E_SET_OPERATION                                        (0x000002FC)
#define NV01E_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV01E_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV01E_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV01E_SET_COLOR_FORMAT                                     (0x00000300)
#define NV01E_SET_COLOR_FORMAT_LE_X24Y8                            (0x00000001)
#define NV01E_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV01E_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV01E_SET_COLOR_FORMAT_LE_X16Y16                           (0x00000004)
#define NV01E_COLOR                                                (0x00000304)
#define NV01E_RECTANGLE(a)                                         (0x00000400\
                                                                   +(a)*0x0008)
#define NV01E_RECTANGLE_POINT(a)                                   (0x00000400\
                                                                   +(a)*0x0008)
#define NV01E_RECTANGLE_POINT_X                                    15:0
#define NV01E_RECTANGLE_POINT_Y                                    31:16
#define NV01E_RECTANGLE_SIZE(a)                                    (0x00000404\
                                                                   +(a)*0x0008)
#define NV01E_RECTANGLE_SIZE_WIDTH                                 15:0
#define NV01E_RECTANGLE_SIZE_HEIGHT                                31:16


/* class NV01_IMAGE_BLIT */
#define  NV01_IMAGE_BLIT                                 (0x0000001F)
#define  NV1_IMAGE_BLIT                                  (0x0000001F)
/* NvNotification[] elements */
#define NV01F_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NV01F_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NV01F_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NV01F_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NV01F_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NV01F_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NV01F_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV01F_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 SetContextColorKey;      /* NV1_IMAGE_SOLID                   0184-0187*/
 V032 SetContextClipRectangle; /* NV1_IMAGE_BLACK_RECTANGLE         0188-018b*/
 V032 SetContextPattern;       /* NV1_IMAGE_PATTERN                 018c-018f*/
 V032 SetContextRop;           /* NV3_CONTEXT_ROP                   0190-0193*/
 V032 SetContextBeta1;         /* NV1_BETA_SOLID                    0194-0197*/
 V032 SetContextSurfaceSource; /* NV3_CONTEXT_SURFACE_1             0198-019b*/
 V032 SetContextSurfaceDestin; /* NV3_CONTEXT_SURFACE_0             019c-019f*/
 V032 Reserved01[0x057];
 V032 SetOperation;            /* NV01F_SET_OPERATION_*             02fc-02ff*/
 V032 ControlPointIn;          /* y_x U16_U16, pixels, top left src 0300-0303*/
 V032 ControlPointOut;         /* y_x S16_S16, pixels, top left dst 0304-0307*/
 V032 Size;                    /* height_width U16_U16 in pixels    0308-030b*/
 V032 Reserved02[0x73d];
} Nv01fTypedef, Nv01ImageBlit;
#define Nv1ImageBlit                                     Nv01ImageBlit
#define nv1ImageBlit                                     nv01ImageBlit
#define NV01F_TYPEDEF                                    nv01ImageBlit
/* dma method offsets, fields, and values */
#define NV01F_SET_OBJECT                                           (0x00000000)
#define NV01F_NO_OPERATION                                         (0x00000100)
#define NV01F_NOTIFY                                               (0x00000104)
#define NV01F_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV01F_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV01F_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV01F_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV01F_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV01F_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV01F_SET_CONTEXT_ROP                                      (0x00000190)
#define NV01F_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV01F_SET_CONTEXT_SURFACE_SOURCE                           (0x00000198)
#define NV01F_SET_CONTEXT_SURFACE_DESTIN                           (0x0000019C)
#define NV01F_SET_OPERATION                                        (0x000002FC)
#define NV01F_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV01F_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV01F_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV01F_CONTROL_POINT_IN                                     (0x00000300)
#define NV01F_CONTROL_POINT_IN_X                                   15:0
#define NV01F_CONTROL_POINT_IN_Y                                   31:16
#define NV01F_CONTROL_POINT_OUT                                    (0x00000304)
#define NV01F_CONTROL_POINT_OUT_X                                  15:0
#define NV01F_CONTROL_POINT_OUT_Y                                  31:16
#define NV01F_SIZE                                                 (0x00000308)
#define NV01F_SIZE_WIDTH                                           15:0
#define NV01F_SIZE_HEIGHT                                          31:16


/* class NV01_IMAGE_FROM_CPU */
#define  NV01_IMAGE_FROM_CPU                             (0x00000021)
#define  NV1_IMAGE_FROM_CPU                              (0x00000021)
/* NvNotification[] elements */
#define NV021_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NV021_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NV021_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NV021_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NV021_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NV021_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NV021_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV021_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 SetContextColorKey;      /* NV1_IMAGE_SOLID                   0184-0187*/
 V032 SetContextClipRectangle; /* NV1_IMAGE_BLACK_RECTANGLE         0188-018b*/
 V032 SetContextPattern;       /* NV1_IMAGE_PATTERN                 018c-018f*/
 V032 SetContextRop;           /* NV3_CONTEXT_ROP                   0190-0193*/
 V032 SetContextBeta1;         /* NV1_BETA_SOLID                    0194-0197*/
 V032 SetContextSurface;       /* NV3_CONTEXT_SURFACE_0             0198-019b*/
 V032 Reserved01[0x058];
 V032 SetOperation;            /* NV021_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV021_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Point;                   /* y_x S16_S16 in pixels             0304-0307*/
 V032 SizeOut;                 /* height_width U16_U16, pixels, dst 0308-030b*/
 V032 SizeIn;                  /* height_width U16_U16, pixels, src 030c-030f*/
 V032 Reserved02[0x03c];
 V032 Color[32];               /* packed pixel(s) to add to image   0400-047f*/
 V032 Reserved03[0x6e0];
} Nv021Typedef, Nv01ImageFromCpu;
#define Nv1ImageFromCpu                                  Nv01ImageFromCpu
#define nv1ImageFromCpu                                  nv01ImageFromCpu
#define NV021_TYPEDEF                                    nv01ImageFromCpu
/* dma method offsets, fields, and values */
#define NV021_SET_OBJECT                                           (0x00000000)
#define NV021_NO_OPERATION                                         (0x00000100)
#define NV021_NOTIFY                                               (0x00000104)
#define NV021_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV021_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV021_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV021_SET_CONTEXT_COLOR_KEY                                (0x00000184)
#define NV021_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV021_SET_CONTEXT_PATTERN                                  (0x0000018C)
#define NV021_SET_CONTEXT_ROP                                      (0x00000190)
#define NV021_SET_CONTEXT_BETA1                                    (0x00000194)
#define NV021_SET_CONTEXT_SURFACE                                  (0x00000198)
#define NV021_SET_OPERATION                                        (0x000002FC)
#define NV021_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV021_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV021_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV021_SET_COLOR_FORMAT                                     (0x00000300)
#define NV021_SET_COLOR_FORMAT_LE_Y8                               (0x00000001)
#define NV021_SET_COLOR_FORMAT_LE_A1R5G5B5                         (0x00000002)
#define NV021_SET_COLOR_FORMAT_LE_X1R5G5B5                         (0x00000003)
#define NV021_SET_COLOR_FORMAT_LE_A8R8G8B8                         (0x00000004)
#define NV021_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000005)
#define NV021_POINT                                                (0x00000304)
#define NV021_POINT_X                                              15:0
#define NV021_POINT_Y                                              31:16
#define NV021_SIZE_OUT                                             (0x00000308)
#define NV021_SIZE_OUT_WIDTH                                       15:0
#define NV021_SIZE_OUT_HEIGHT                                      31:16
#define NV021_SIZE_IN                                              (0x0000030C)
#define NV021_SIZE_IN_WIDTH                                        15:0
#define NV021_SIZE_IN_HEIGHT                                       31:16
#define NV021_COLOR(a)                                             (0x00000400\
                                                                   +(a)*0x0004)

/* class NV03_CONTEXT_ROP */
#define  NV03_CONTEXT_ROP                                (0x00000043)
#define  NV3_CONTEXT_ROP                                 (0x00000043)
/* NvNotification[] elements */
#define NV043_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NV043_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NV043_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NV043_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NV043_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NV043_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NV043_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV043_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 Reserved01[0x05f];
 V032 SetRop5;                 /* 32-bit ROP5                       0300-0303*/
 V032 Reserved02[0x73f];
} Nv043Typedef, Nv03ContextRop;
#define Nv3ContextRop                                    Nv03ContextRop
#define nv3ContextRop                                    nv03ContextRop
#define NV043_TYPEDEF                                    nv03ContextRop
/* dma method offsets, fields, and values */
#define NV043_SET_OBJECT                                           (0x00000000)
#define NV043_NO_OPERATION                                         (0x00000100)
#define NV043_NOTIFY                                               (0x00000104)
#define NV043_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV043_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV043_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV043_SET_ROP5                                             (0x00000300)



/* class NV03_DX3_TEXTURED_TRIANGLE */
#define  NV03_DX3_TEXTURED_TRIANGLE                      (0x00000048)
#define  NV3_DX3_TEXTURED_TRIANGLE                       (0x00000048)
/* NvNotification[] elements */
#define NV048_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NV048_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NV048_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NV048_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NV048_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NV048_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NV048_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV048_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 SetContextDmaTexture;    /* NV1_CONTEXT_DMA_FROM_MEMORY       0184-0187*/
 V032 SetContextClipRectangle; /* NV1_IMAGE_BLACK_RECTANGLE         0188-018b*/
 V032 SetContextSurfaceColor;  /* NV3_CONTEXT_SURFACE_2             018c-018f*/
 V032 SetContextSurfaceZeta;   /* NV3_CONTEXT_SURFACE_3             0190-0193*/
 V032 Reserved01[0x05c];
 U032 TextureOffset;           /* offset in bytes                   0304-0307*/
 V032 TextureFormat;           /* see text                          0308-030b*/
 V032 TextureFilter;           /* ignore_sizeAdjust_spreadY_spreadX 030c-030f*/
 V032 FogColor;                /* X8R8G8B8 fog color                0310-0313*/
 V032 Control0;                /* see text                          0314-0317*/
 V032 Control1;                /* alphafunc_alpharef V24_U8         0318-031b*/
 V032 Reserved02[0x339];
 struct {                      /* start of method in array          1000-    */
  V032 specular;               /* fog_i5-i0, U0d8_U4_U4_U4_U4_U4_U4   00-  03*/
  V032 color;                  /* X8R8G8B8 or A8R8G8B8                04-  07*/
  F032 sx;                     /* screen x coordinate                 08-  0b*/
  F032 sy;                     /* screen y coordinate                 0c-  0f*/
  F032 sz;                     /* screen z coordinate                 10-  13*/
  F032 rhw;                    /* reciprocal homogeneous W (1/W)      14-  17*/
  F032 tu;                     /* texture u coordinate                18-  1b*/
  F032 tv;                     /* texture v coordinate                1c-  1f*/
 } Tlvertex[128];              /* end of method in array                -1fff*/
} Nv048Typedef, Nv03Dx3TexturedTriangle;
#define Nv3Dx3TexturedTriangle                           Nv03Dx3TexturedTriangle
#define nv3Dx3TexturedTriangle                           nv03Dx3TexturedTriangle
#define NV048_TYPEDEF                                    nv03Dx3TexturedTriangle
/* dma method offsets, fields, and values */
#define NV048_SET_OBJECT                                           (0x00000000)
#define NV048_NO_OPERATION                                         (0x00000100)
#define NV048_NOTIFY                                               (0x00000104)
#define NV048_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV048_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV048_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV048_SET_CONTEXT_DMA_TEXTURE                              (0x00000184)
#define NV048_SET_CONTEXT_CLIP_RECTANGLE                           (0x00000188)
#define NV048_SET_CONTEXT_SURFACE_COLOR                            (0x0000018C)
#define NV048_SET_CONTEXT_SURFACE_ZETA                             (0x00000190)
#define NV048_TEXTURE_OFFSET                                       (0x00000304)
#define NV048_TEXTURE_FORMAT                                       (0x00000308)
#define NV048_TEXTURE_FORMAT_VALUE                                 15:0
#define NV048_TEXTURE_FORMAT_KEY                                   19:16
#define NV048_TEXTURE_FORMAT_KEY_DISABLED                          (0x00000000)
#define NV048_TEXTURE_FORMAT_KEY_ENABLED                           (0x00000001)
#define NV048_TEXTURE_FORMAT_COLOR                                 23:20
#define NV048_TEXTURE_FORMAT_COLOR_LE_A1R5G5B5                     (0x00000000)
#define NV048_TEXTURE_FORMAT_COLOR_LE_X1R5G5B5                     (0x00000001)
#define NV048_TEXTURE_FORMAT_COLOR_LE_A4R4G4B4                     (0x00000002)
#define NV048_TEXTURE_FORMAT_COLOR_LE_R5G6B5                       (0x00000003)
#define NV048_TEXTURE_FORMAT_SIZE_MIN                              27:24
#define NV048_TEXTURE_FORMAT_SIZE_MIN_4X4                          (0x00000002)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_8X8                          (0x00000003)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_16X16                        (0x00000004)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_32X32                        (0x00000005)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_64X64                        (0x00000006)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_128X128                      (0x00000007)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_256X256                      (0x00000008)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_512X512                      (0x00000009)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_1024X1024                    (0x0000000A)
#define NV048_TEXTURE_FORMAT_SIZE_MIN_2048X2048                    (0x0000000B)
#define NV048_TEXTURE_FORMAT_SIZE_MAX                              31:28
#define NV048_TEXTURE_FORMAT_SIZE_MAX_4X4                          (0x00000002)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_8X8                          (0x00000003)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_16X16                        (0x00000004)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_32X32                        (0x00000005)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_64X64                        (0x00000006)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_128X128                      (0x00000007)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_256X256                      (0x00000008)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_512X512                      (0x00000009)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_1024X1024                    (0x0000000A)
#define NV048_TEXTURE_FORMAT_SIZE_MAX_2048X2048                    (0x0000000B)
#define NV048_TEXTURE_FILTER                                       (0x0000030C)
#define NV048_TEXTURE_FILTER_SPREAD_X                              4:0
#define NV048_TEXTURE_FILTER_IGNORE0                               7:5
#define NV048_TEXTURE_FILTER_SPREAD_Y                              12:8
#define NV048_TEXTURE_FILTER_IGNORE1                               15:13
#define NV048_TEXTURE_FILTER_SIZE_ADJUST                           23:16
#define NV048_TEXTURE_FILTER_IGNORE2                               31:24
#define NV048_FOG_COLOR                                            (0x00000310)
#define NV048_CONTROL0                                             (0x00000314)
#define NV048_CONTROL0_INTERPOLATOR                                3:0
#define NV048_CONTROL0_INTERPOLATOR_ZOH_CORNER                     (0x00000000)
#define NV048_CONTROL0_INTERPOLATOR_ZOH_CENTER                     (0x00000001)
#define NV048_CONTROL0_INTERPOLATOR_FOH_CENTER                     (0x00000002)
#define NV048_CONTROL0_WRAP_U                                      5:4
#define NV048_CONTROL0_WRAP_U_CYLINDRICAL                          (0x00000000)
#define NV048_CONTROL0_WRAP_U_WRAP                                 (0x00000001)
#define NV048_CONTROL0_WRAP_U_MIRROR                               (0x00000002)
#define NV048_CONTROL0_WRAP_U_CLAMP                                (0x00000003)
#define NV048_CONTROL0_WRAP_V                                      7:6
#define NV048_CONTROL0_WRAP_V_CYLINDRICAL                          (0x00000000)
#define NV048_CONTROL0_WRAP_V_WRAP                                 (0x00000001)
#define NV048_CONTROL0_WRAP_V_MIRROR                               (0x00000002)
#define NV048_CONTROL0_WRAP_V_CLAMP                                (0x00000003)
#define NV048_CONTROL0_COLOR_FORMAT                                9:8
#define NV048_CONTROL0_COLOR_FORMAT_LE_X8R8G8B8                    (0x00000000)
#define NV048_CONTROL0_COLOR_FORMAT_LE_A8R8G8B8                    (0x00000001)
#define NV048_CONTROL0_SOURCE_COLOR                                11:10
#define NV048_CONTROL0_SOURCE_COLOR_NORMAL                         (0x00000000)
#define NV048_CONTROL0_SOURCE_COLOR_COLOR_INVERSE                  (0x00000001)
#define NV048_CONTROL0_SOURCE_COLOR_ALPHA_INVERSE                  (0x00000002)
#define NV048_CONTROL0_SOURCE_COLOR_ALPHA_ONE                      (0x00000003)
#define NV048_CONTROL0_CULLING                                     14:12
#define NV048_CONTROL0_CULLING_NONE                                (0x00000001)
#define NV048_CONTROL0_CULLING_COUNTERCLOCKWISE                    (0x00000002)
#define NV048_CONTROL0_CULLING_CLOCKWISE                           (0x00000003)
#define NV048_CONTROL0_Z_PERSPECTIVE_ENABLE                        15:15
#define NV048_CONTROL0_Z_PERSPECTIVE_ENABLE_FALSE                  (0x00000000)
#define NV048_CONTROL0_Z_PERSPECTIVE_ENABLE_TRUE                   (0x00000001)
#define NV048_CONTROL0_ZFUNC                                       19:16
#define NV048_CONTROL0_ZFUNC_NEVER                                 (0x00000001)
#define NV048_CONTROL0_ZFUNC_LESS                                  (0x00000002)
#define NV048_CONTROL0_ZFUNC_EQUAL                                 (0x00000003)
#define NV048_CONTROL0_ZFUNC_LESSEQUAL                             (0x00000004)
#define NV048_CONTROL0_ZFUNC_GREATER                               (0x00000005)
#define NV048_CONTROL0_ZFUNC_NOTEQUAL                              (0x00000006)
#define NV048_CONTROL0_ZFUNC_GREATEREQUAL                          (0x00000007)
#define NV048_CONTROL0_ZFUNC_ALWAYS                                (0x00000008)
#define NV048_CONTROL0_ZETA_WRITE                                  23:20
#define NV048_CONTROL0_ZETA_WRITE_NEVER                            (0x00000000)
#define NV048_CONTROL0_ZETA_WRITE_ALPHA                            (0x00000001)
#define NV048_CONTROL0_ZETA_WRITE_ALPHA_ZETA                       (0x00000002)
#define NV048_CONTROL0_ZETA_WRITE_ZETA                             (0x00000003)
#define NV048_CONTROL0_ZETA_WRITE_ALWAYS                           (0x00000004)
#define NV048_CONTROL0_COLOR_WRITE                                 27:24
#define NV048_CONTROL0_COLOR_WRITE_NEVER                           (0x00000000)
#define NV048_CONTROL0_COLOR_WRITE_ALPHA                           (0x00000001)
#define NV048_CONTROL0_COLOR_WRITE_ALPHA_ZETA                      (0x00000002)
#define NV048_CONTROL0_COLOR_WRITE_ZETA                            (0x00000003)
#define NV048_CONTROL0_COLOR_WRITE_ALWAYS                          (0x00000004)
#define NV048_CONTROL0_ROP                                         28:28
#define NV048_CONTROL0_ROP_BLEND_AND                               (0x00000000)
#define NV048_CONTROL0_ROP_ADD_WITH_SATURATION                     (0x00000001)
#define NV048_CONTROL0_BLEND_BETA                                  29:29
#define NV048_CONTROL0_BLEND_BETA_SRCALPHA                         (0x00000000)
#define NV048_CONTROL0_BLEND_BETA_DESTCOLOR                        (0x00000001)
#define NV048_CONTROL0_BLEND_INPUT0                                30:30
#define NV048_CONTROL0_BLEND_INPUT0_DESTCOLOR                      (0x00000000)
#define NV048_CONTROL0_BLEND_INPUT0_ZERO                           (0x00000001)
#define NV048_CONTROL0_BLEND_INPUT1                                31:31
#define NV048_CONTROL0_BLEND_INPUT1_SRCCOLOR                       (0x00000000)
#define NV048_CONTROL0_BLEND_INPUT1_ZERO                           (0x00000001)
#define NV048_CONTROL1                                             (0x00000318)
#define NV048_CONTROL1_ALPHAREF                                    7:0
#define NV048_CONTROL1_ALPHAFUNC                                   31:8
#define NV048_CONTROL1_ALPHAFUNC_NEVER                             (0x00000001)
#define NV048_CONTROL1_ALPHAFUNC_LESS                              (0x00000002)
#define NV048_CONTROL1_ALPHAFUNC_EQUAL                             (0x00000003)
#define NV048_CONTROL1_ALPHAFUNC_LESSEQUAL                         (0x00000004)
#define NV048_CONTROL1_ALPHAFUNC_GREATER                           (0x00000005)
#define NV048_CONTROL1_ALPHAFUNC_NOTEQUAL                          (0x00000006)
#define NV048_CONTROL1_ALPHAFUNC_GREATEREQUAL                      (0x00000007)
#define NV048_CONTROL1_ALPHAFUNC_ALWAYS                            (0x00000008)

#define NV048_TLVERTEX(a)                                          (0x00001000\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SPECULAR(a)                                 (0x00001000\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SPECULAR_I0                                 3:0
#define NV048_TLVERTEX_SPECULAR_I1                                 7:4
#define NV048_TLVERTEX_SPECULAR_I2                                 11:8
#define NV048_TLVERTEX_SPECULAR_I3                                 15:12
#define NV048_TLVERTEX_SPECULAR_I4                                 19:16
#define NV048_TLVERTEX_SPECULAR_I5                                 23:20
#define NV048_TLVERTEX_SPECULAR_FOG                                31:24
#define NV048_TLVERTEX_COLOR(a)                                    (0x00001004\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SX(a)                                       (0x00001008\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SY(a)                                       (0x0000100C\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_SZ(a)                                       (0x00001010\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_RHW(a)                                      (0x00001014\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_TU(a)                                       (0x00001018\
                                                                   +(a)*0x0020)
#define NV048_TLVERTEX_TV(a)                                       (0x0000101C\
                                                                   +(a)*0x0020)


/* class NV03_GDI_RECTANGLE_TEXT */
#define  NV03_GDI_RECTANGLE_TEXT                         (0x0000004B)
#define  NV3_GDI_RECTANGLE_TEXT                          (0x0000004B)
/* NvNotification[] elements */
#define NV04B_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NV04B_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NV04B_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NV04B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NV04B_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NV04B_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NV04B_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV04B_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 SetContextPattern;       /* NV1_IMAGE_PATTERN                 0184-0187*/
 V032 SetContextRop;           /* NV3_CONTEXT_ROP                   0188-018b*/
 V032 SetContextBeta1;         /* NV1_BETA_SOLID                    018c-018f*/
 V032 SetContextSurface;       /* NV3_CONTEXT_SURFACE_0             0190-0193*/
 V032 Reserved01[0x05a];
 V032 SetOperation;            /* NV04B_SET_OPERATION_*             02fc-02ff*/
 V032 SetColorFormat;          /* NV04B_SET_COLOR_FORMAT_*          0300-0303*/
 V032 SetMonochromeFormat;     /* NV04B_SET_MONOCHROME_FORMAT_*     0304-0307*/
 V032 Reserved02[0x03d];
 V032 Color1A;                 /* rectangle color                   03fc-03ff*/
 struct {                      /* start of aliased methods in array 0400-    */
  V032 point;                  /* x_y S16_S16 in pixels                0-   3*/
  V032 size;                   /* width_height U16_U16 in pixels       4-   7*/
 } UnclippedRectangle[64];     /* end of aliased methods in array       -05ff*/
 V032 Reserved03[0x07D];
 V032 ClipPoint0B;             /* top_left S16_S16 in pixels        07f4-07f7*/
 V032 ClipPoint1B;             /* bottom_right S16_S16 in pixels    07f8-07fb*/
 V032 Color1B;                 /* rectangle color                   07fc-07ff*/
 struct {                      /* start of aliased methods in array 0800-    */
  V032 point0;                 /* top_left S16_S16 in pixels           0-   3*/
  V032 point1;                 /* bottom_right S16_S16 in pixels       4-   7*/
 } ClippedRectangle[64];       /* end of aliased methods in array       -09ff*/
 V032 Reserved04[0x07B];
 V032 ClipPoint0C;             /* top_left S16_S16 in pixels        0bec-0bef*/
 V032 ClipPoint1C;             /* bottom_right S16_S16 in pixels    0bf0-0bf3*/
 V032 Color1C;                 /* color of 1 pixels                 0bf4-0bf7*/
 V032 SizeC;                   /* height_width U16_U16 in pixels    0bf8-0bfb*/
 V032 PointC;                  /* y_x S16_S16 in pixels             0bfc-0bff*/
 V032 MonochromeColor1C[128];  /* 32 monochrome pixels per write    0c00-0dff*/
 V032 Reserved05[0x07A];
 V032 ClipPoint0D;             /* top_left S16_S16 in pixels        0fe8-0feb*/
 V032 ClipPoint1D;             /* bottom_right S16_S16 in pixels    0fec-0fef*/
 V032 Color1D;                 /* color of 1 pixels                 0ff0-0ff3*/
 V032 SizeInD;                 /* height_width U16_U16 in pixels    0ff4-0ff7*/
 V032 SizeOutD;                /* height_width U16_U16 in pixels    0ff8-0ffb*/
 V032 PointD;                  /* y_x S16_S16 in pixels             0ffc-0fff*/
 V032 MonochromeColor1D[128];  /* 32 monochrome pixels per write    1000-11ff*/
 V032 Reserved06[0x079];
 V032 ClipPoint0E;             /* top_left S16_S16 in pixels        13e4-13e7*/
 V032 ClipPoint1E;             /* bottom_right S16_S16 in pixels    13e8-13eb*/
 V032 Color0E;                 /* color of 0 pixels                 13ec-13ef*/
 V032 Color1E;                 /* color of 1 pixels                 13f0-13f3*/
 V032 SizeInE;                 /* height_width U16_U16 in pixels    13f4-13f7*/
 V032 SizeOutE;                /* height_width U16_U16 in pixels    13f8-13fb*/
 V032 PointE;                  /* y_x S16_S16 in pixels             13fc-13ff*/
 V032 MonochromeColor01E[128]; /* 32 monochrome pixels per write    1400-15ff*/
 V032 Reserved07[0x280];
} Nv04bTypedef, Nv03GdiRectangleText;
#define Nv3GdiRectangleText                              Nv03GdiRectangleText
#define nv3GdiRectangleText                              nv03GdiRectangleText
#define NV04B_TYPEDEF                                    nv03GdiRectangleText
/* dma method offsets, fields, and values */
#define NV04B_SET_OBJECT                                           (0x00000000)
#define NV04B_NO_OPERATION                                         (0x00000100)
#define NV04B_NOTIFY                                               (0x00000104)
#define NV04B_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV04B_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV04B_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV04B_SET_CONTEXT_PATTERN                                  (0x00000184)
#define NV04B_SET_CONTEXT_ROP                                      (0x00000188)
#define NV04B_SET_CONTEXT_BETA1                                    (0x0000018C)
#define NV04B_SET_CONTEXT_SURFACE                                  (0x00000190)
#define NV04B_SET_OPERATION                                        (0x000002FC)
#define NV04B_SET_OPERATION_SRCCOPY_AND                            (0x00000000)
#define NV04B_SET_OPERATION_ROP_AND                                (0x00000001)
#define NV04B_SET_OPERATION_BLEND_AND                              (0x00000002)
#define NV04B_SET_COLOR_FORMAT                                     (0x00000300)
#define NV04B_SET_COLOR_FORMAT_LE_X24Y8                            (0x00000001)
#define NV04B_SET_COLOR_FORMAT_LE_X17R5G5B5                        (0x00000002)
#define NV04B_SET_COLOR_FORMAT_LE_X8R8G8B8                         (0x00000003)
#define NV04B_SET_MONOCHROME_FORMAT                                (0x00000304)
#define NV04B_SET_MONOCHROME_FORMAT_CGA6_M1                        (0x00000001)
#define NV04B_SET_MONOCHROME_FORMAT_LE_M1                          (0x00000002)
#define NV04B_COLOR1_A                                             (0x000003FC)
#define NV04B_UNCLIPPED_RECTANGLE(a)                               (0x00000400\
                                                                   +(a)*0x0008)
#define NV04B_UNCLIPPED_RECTANGLE_POINT(a)                         (0x00000400\
                                                                   +(a)*0x0008)
#define NV04B_UNCLIPPED_RECTANGLE_POINT_X                          15:0
#define NV04B_UNCLIPPED_RECTANGLE_POINT_Y                          31:16
#define NV04B_UNCLIPPED_RECTANGLE_SIZE(a)                          (0x00000404\
                                                                   +(a)*0x0008)
#define NV04B_UNCLIPPED_RECTANGLE_SIZE_WIDTH                       15:0
#define NV04B_UNCLIPPED_RECTANGLE_SIZE_HEIGHT                      31:16
#define NV04B_CLIP_POINT0_B                                        (0x000007F4)
#define NV04B_CLIP_POINT0_B_LEFT                                   15:0
#define NV04B_CLIP_POINT0_B_TOP                                    31:16
#define NV04B_CLIP_POINT1_B                                        (0x000007F8)
#define NV04B_CLIP_POINT1_B_RIGHT                                  15:0
#define NV04B_CLIP_POINT1_B_BOTTOM                                 31:16
#define NV04B_COLOR1_B                                             (0x000007FC)
#define NV04B_CLIPPED_RECTANGLE(a)                                 (0x00000800\
                                                                   +(a)*0x0008)
#define NV04B_CLIPPED_RECTANGLE_POINT0(a)                          (0x00000800\
                                                                   +(a)*0x0008)
#define NV04B_CLIPPED_RECTANGLE_POINT0_LEFT                        15:0
#define NV04B_CLIPPED_RECTANGLE_POINT0_TOP                         31:16
#define NV04B_CLIPPED_RECTANGLE_POINT1(a)                          (0x00000804\
                                                                   +(a)*0x0008)
#define NV04B_CLIPPED_RECTANGLE_POINT1_RIGHT                       15:0
#define NV04B_CLIPPED_RECTANGLE_POINT1_BOTTOM                      31:16
#define NV04B_CLIP_POINT0_C                                        (0x00000BEC)
#define NV04B_CLIP_POINT0_C_LEFT                                   15:0
#define NV04B_CLIP_POINT0_C_TOP                                    31:16
#define NV04B_CLIP_POINT1_C                                        (0x00000BF0)
#define NV04B_CLIP_POINT1_C_RIGHT                                  15:0
#define NV04B_CLIP_POINT1_C_BOTTOM                                 31:16
#define NV04B_COLOR1_C                                             (0x00000BF4)
#define NV04B_SIZE_C                                               (0x00000BF8)
#define NV04B_SIZE_C_WIDTH                                         15:0
#define NV04B_SIZE_C_HEIGHT                                        31:16
#define NV04B_POINT_C                                              (0x00000BFC)
#define NV04B_POINT_C_X                                            15:0
#define NV04B_POINT_C_Y                                            31:16
#define NV04B_MONOCHROME_COLOR1_C(a)                               (0x00000C00\
                                                                   +(a)*0x0004)
#define NV04B_CLIP_POINT0_D                                        (0x00000FE8)
#define NV04B_CLIP_POINT0_D_LEFT                                   15:0
#define NV04B_CLIP_POINT0_D_TOP                                    31:16
#define NV04B_CLIP_POINT1_D                                        (0x00000FEC)
#define NV04B_CLIP_POINT1_D_RIGHT                                  15:0
#define NV04B_CLIP_POINT1_D_BOTTOM                                 31:16
#define NV04B_COLOR1_D                                             (0x00000FF0)
#define NV04B_SIZE_IN_D                                            (0x00000FF4)
#define NV04B_SIZE_IN_D_WIDTH                                      15:0
#define NV04B_SIZE_IN_D_HEIGHT                                     31:16
#define NV04B_SIZE_OUT_D                                           (0x00000FF8)
#define NV04B_SIZE_OUT_D_WIDTH                                     15:0
#define NV04B_SIZE_OUT_D_HEIGHT                                    31:16
#define NV04B_POINT_D                                              (0x00000FFC)
#define NV04B_POINT_D_X                                            15:0
#define NV04B_POINT_D_Y                                            31:16
#define NV04B_MONOCHROME_COLOR1_D(a)                               (0x00001000\
                                                                   +(a)*0x0004)
#define NV04B_CLIP_POINT0_E                                        (0x000013E4)
#define NV04B_CLIP_POINT0_E_LEFT                                   15:0
#define NV04B_CLIP_POINT0_E_TOP                                    31:16
#define NV04B_CLIP_POINT1_E                                        (0x000013E8)
#define NV04B_CLIP_POINT1_E_RIGHT                                  15:0
#define NV04B_CLIP_POINT1_E_BOTTOM                                 31:16
#define NV04B_COLOR0_E                                             (0x000013EC)
#define NV04B_COLOR1_E                                             (0x000013F0)
#define NV04B_SIZE_IN_E                                            (0x000013F4)
#define NV04B_SIZE_IN_E_WIDTH                                      15:0
#define NV04B_SIZE_IN_E_HEIGHT                                     31:16
#define NV04B_SIZE_OUT_E                                           (0x000013F8)
#define NV04B_SIZE_OUT_E_WIDTH                                     15:0
#define NV04B_SIZE_OUT_E_HEIGHT                                    31:16
#define NV04B_POINT_E                                              (0x000013FC)
#define NV04B_POINT_E_X                                            15:0
#define NV04B_POINT_E_Y                                            31:16
#define NV04B_MONOCHROME_COLOR01_E(a)                              (0x00001400\
                                                                   +(a)*0x0004)

/* class NV03_CONTEXT_SURFACE_0 */
#define  NV03_CONTEXT_SURFACE_0                          (0x00000058)
#define  NV3_CONTEXT_SURFACE_0                           (0x00000058)
/* NvNotification[] elements */
#define NV058_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NV058_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NV058_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NV058_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NV058_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NV058_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NV058_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV058_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 SetContextDmaImage;      /* NV1_CONTEXT_DMA_IN_MEMORY         0184-0187*/
 V032 Reserved01[0x05e];
 V032 SetColorFormat;          /* NV058_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Reserved02[0x001];
 U032 SetImagePitch;           /* bytes, vertical pixel delta       0308-030b*/
 U032 SetImageOffset;          /* byte offset of top-left pixel     030c-030f*/
 V032 Reserved03[0x73c];
} Nv058Typedef, Nv03ContextSurface0;
#define Nv3ContextSurface0                               Nv03ContextSurface0
#define nv3ContextSurface0                               nv03ContextSurface0
#define NV058_TYPEDEF                                    nv03ContextSurface0
/* dma method offsets, fields, and values */
#define NV058_SET_OBJECT                                           (0x00000000)
#define NV058_NO_OPERATION                                         (0x00000100)
#define NV058_NOTIFY                                               (0x00000104)
#define NV058_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV058_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV058_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV058_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV058_SET_COLOR_FORMAT                                     (0x00000300)
#define NV058_SET_COLOR_FORMAT_LE_Y8                               (0x01010000)
#define NV058_SET_COLOR_FORMAT_LE_Y16                              (0x01010001)
#define NV058_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5                (0x01000000)
#define NV058_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8                (0x00000001)
#define NV058_SET_IMAGE_PITCH                                      (0x00000308)
#define NV058_SET_IMAGE_OFFSET                                     (0x0000030C)


/* class NV03_CONTEXT_SURFACE_1 */
#define  NV03_CONTEXT_SURFACE_1                          (0x00000059)
#define  NV3_CONTEXT_SURFACE_1                           (0x00000059)
/* NvNotification[] elements */
#define NV059_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NV059_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NV059_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NV059_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NV059_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NV059_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NV059_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV059_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 SetContextDmaImage;      /* NV1_CONTEXT_DMA_IN_MEMORY         0184-0187*/
 V032 Reserved01[0x05e];
 V032 SetColorFormat;          /* NV059_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Reserved02[0x001];
 U032 SetImagePitch;           /* bytes, vertical pixel delta       0308-030b*/
 U032 SetImageOffset;          /* byte offset of top-left pixel     030c-030f*/
 V032 Reserved03[0x73c];
} Nv059Typedef, Nv03ContextSurface1;
#define Nv3ContextSurface1                               Nv03ContextSurface1
#define nv3ContextSurface1                               nv03ContextSurface1
#define NV059_TYPEDEF                                    nv03ContextSurface1
/* dma method offsets, fields, and values */
#define NV059_SET_OBJECT                                           (0x00000000)
#define NV059_NO_OPERATION                                         (0x00000100)
#define NV059_NOTIFY                                               (0x00000104)
#define NV059_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV059_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV059_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV059_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV059_SET_COLOR_FORMAT                                     (0x00000300)
#define NV059_SET_COLOR_FORMAT_LE_Y8                               (0x01010000)
#define NV059_SET_COLOR_FORMAT_LE_Y16                              (0x01010001)
#define NV059_SET_COLOR_FORMAT_LE_X1R5G5B5_Z1R5G5B5                (0x01000000)
#define NV059_SET_COLOR_FORMAT_LE_X8R8G8B8_Z8R8G8B8                (0x00000001)
#define NV059_SET_IMAGE_PITCH                                      (0x00000308)
#define NV059_SET_IMAGE_OFFSET                                     (0x0000030C)


/* class NV03_CONTEXT_SURFACE_3 */
#define  NV03_CONTEXT_SURFACE_3                          (0x0000005B)
#define  NV3_CONTEXT_SURFACE_3                           (0x0000005B)
/* NvNotification[] elements */
#define NV05B_NOTIFIERS_NOTIFY                           (0)
/* NvNotification[] fields and values */
#define NV05B_NOTIFICATION_STATUS_IN_PROGRESS            (0x8000)
#define NV05B_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NV05B_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NV05B_NOTIFICATION_STATUS_ERROR_INVALID_STATE    (0x1000)
#define NV05B_NOTIFICATION_STATUS_ERROR_STATE_IN_USE     (0x0800)
#define NV05B_NOTIFICATION_STATUS_DONE_SUCCESS           (0x0000)
/* pio method data structure */
typedef volatile struct {
 V032 NoOperation;             /* ignored                           0100-0103*/
 V032 Notify;                  /* NV05B_NOTIFY_*                    0104-0107*/
 V032 Reserved00[0x01e];
 V032 SetContextDmaNotifies;   /* NV1_CONTEXT_DMA_TO_MEMORY         0180-0183*/
 V032 SetContextDmaImage;      /* NV1_CONTEXT_DMA_IN_MEMORY         0184-0187*/
 V032 Reserved01[0x05e];
 V032 SetColorFormat;          /* NV05B_SET_COLOR_FORMAT_*          0300-0303*/
 V032 Reserved02[0x001];
 U032 SetImagePitch;           /* bytes, vertical pixel delta       0308-030b*/
 U032 SetImageOffset;          /* byte offset of top-left pixel     030c-030f*/
 V032 Reserved03[0x73c];
} Nv05bTypedef, Nv03ContextSurface3;
#define Nv3ContextSurface3                               Nv03ContextSurface3
#define nv3ContextSurface3                               nv03ContextSurface3
#define NV05B_TYPEDEF                                    nv03ContextSurface3
/* dma method offsets, fields, and values */
#define NV05B_SET_OBJECT                                           (0x00000000)
#define NV05B_NO_OPERATION                                         (0x00000100)
#define NV05B_NOTIFY                                               (0x00000104)
#define NV05B_NOTIFY_WRITE_ONLY                                    (0x00000000)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_1                           (0x00000001)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_2                           (0x00000002)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_3                           (0x00000003)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_4                           (0x00000004)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_5                           (0x00000005)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_6                           (0x00000006)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_7                           (0x00000007)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_8                           (0x00000008)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_9                           (0x00000009)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_A                           (0x0000000A)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_B                           (0x0000000B)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_C                           (0x0000000C)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_D                           (0x0000000D)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_E                           (0x0000000E)
#define NV05B_NOTIFY_WRITE_THEN_AWAKEN_F                           (0x0000000F)
#define NV05B_SET_CONTEXT_DMA_NOTIFIES                             (0x00000180)
#define NV05B_SET_CONTEXT_DMA_IMAGE                                (0x00000184)
#define NV05B_SET_COLOR_FORMAT                                     (0x00000300)
#define NV05B_SET_COLOR_FORMAT_LE_W16_0                            (0x01010000)
#define NV05B_SET_COLOR_FORMAT_LE_W16_1                            (0x01010001)
#define NV05B_SET_COLOR_FORMAT_LE_W16_2                            (0x01000000)
#define NV05B_SET_COLOR_FORMAT_LE_W16_3                            (0x00000001)
#define NV05B_DUMMY                                                (0x00000308)
#define NV05B_SET_IMAGE_OFFSET                                     (0x0000030C)


 /***************************************************************************\
|*                                 Channels                                  *|
 \***************************************************************************/

/* class NV03_CHANNEL_PIO */
#define  NV03_CHANNEL_PIO                                (0x0000006A)
#define  NV3_CHANNEL_PIO                                 (0x0000006A)
/* NvNotification[] fields and values */
#define NV06A_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
#define NV06A_NOTIFICATION_STATUS_ERROR_BAD_ARGUMENT     (0x2000)
#define NV06A_NOTIFICATION_STATUS_ERROR_FLOW_CONTROL     (0x0200)
/* pio subchannel method data structure */
typedef volatile struct {
 V032 Reserved00[0x003];
 U016 Free;                    /* free count, read only             0010-0011*/
 U016 Zero[3];                 /* zeroes, read only                 0012-0017*/
 V032 Reserved01[0x03A];
} Nv03ControlPio;
#define Nv3ControlPio                                    Nv03ControlPio
typedef volatile struct {
 V032 SetObject;               /* handle of current object          0000-0003*/
 Nv03ControlPio control;       /* flow control                      0000-00ff*/
 union {                       /* start of class methods            0100-    */
  NvClass                   nvClass;
  NvContextDmaFromMemory    nvContextDmaFromMemory;
  NvContextDmaToMemory      nvContextDmaToMemory;
  NvPatchcordVideo          nvPatchcordVideo;
  NvVideoSink               nvVideoSink;
  NvVideoColorMap           nvVideoColorMap;            // Video Class supported in resman.040
  NvPatchcordImage          nvPatchcordImage;
  NvImageStencil            nvImageStencil;
  NvImageRopAnd             nvImageRopAnd;
  NvImageColorKey           nvImageColorKey;
  NvImageSolid              nvImageSolid;
  NvImagePattern            nvImagePattern;
  NvImageBlackRectangle     nvImageBlackRectangle;
  NvRenderSolidLin          nvRenderSolidLin;
  NvRenderSolidRectangle    nvRenderSolidRectangle;
  NvImageBlit               nvImageBlit;
  NvImageFromCpu            nvImageFromCpu;
  NvPatchcordRop            nvPatchcordRop;
  NvMemoryToMemoryFormat    nvMemoryToMemoryFormat;
  NvScaledImageFromMemory   nvScaledImageFromMemory;
  NvScaledYuv420FromMemory  nvScaledYuv420FromMemory;
  NvStretchedImageFromCpu   nvStretchedImageFromCpu;
  NvContextDmaInMemory      nvContextDmaInMemory;
  NvImageInMemory           nvImageInMemory;
  NvVideoFromMemory         nvVideoFromMemory;
  NvVideoScaler             nvVideoScaler;              // Video Class supported in resman.040
  NvVideoColorKey           nvVideoColorKey;            // Video Class supported in resman.040
  NvRop5Solid               nvRop5Solid;
  NvZetaBufferInMemory      nvZetaBufferInMemory;
  NvPatchcordZeta           nvPatchcordZeta;
  NvRenderD3D0TriangleZeta  nvRenderD3D0TriangleZeta;
  NvRenderGdi0RectangleAndText nvRenderGdi0RectangleAndText;

  Nv018Typedef NV018_TYPEDEF;
  Nv019Typedef NV019_TYPEDEF;
  Nv01eTypedef NV01E_TYPEDEF;
  Nv01fTypedef NV01F_TYPEDEF;
  Nv021Typedef NV021_TYPEDEF;
  Nv043Typedef NV043_TYPEDEF;
  Nv048Typedef NV048_TYPEDEF;
  Nv04bTypedef NV04B_TYPEDEF;
  Nv058Typedef NV058_TYPEDEF;
  Nv059Typedef NV059_TYPEDEF;
  Nv05bTypedef NV05B_TYPEDEF;


 } /* cls */;                  /* end of class methods                  -1fff*/
} Nv03SubchannelPio;
#define Nv3SubchannelPio                                 Nv03SubchannelPio
/* pio channel */
typedef volatile struct {      /* start of array of subchannels     0000-    */
 Nv03SubchannelPio subchannel[8];/*subchannel                       0000-1fff*/
} Nv03ChannelPio;              /* end of array of subchannels           -ffff*/
#define Nv3ChannelPio                                    Nv03ChannelPio
/* fields and values */
#define NV06A_FIFO_GUARANTEED_SIZE                       (0x007C)
#define NV06A_FIFO_EMPTY                                 (0x007C)


/* class NV03_CHANNEL_DMA */
#define  NV03_CHANNEL_DMA                                (0x0000006B)
/* NvNotification[] fields and values */
#define NV06B_NOTIFICATION_STATUS_ERROR_PROTECTION_FAULT (0x4000)
/* pio method data structure */
typedef volatile struct {
 V032 Reserved00[0x7c0];
} Nv06bTypedef, Nv03ChannelDma;
#define  NV06B_TYPEDEF                                   nv03ChannelDma



 /***************************************************************************\
|*                            Well Known Objects                             *|
 \***************************************************************************/


/* object NV01_NULL_OBJECT */
#define   NV01_NULL_OBJECT                               (0x00000000)
#define   NV1_NULL_OBJECT                                (0x00000000)



 /***************************************************************************\
|*                               Notification                                *|
 \***************************************************************************/


/***** NvNotification Structure *****/
/*
 * NV objects return information about method completion to clients via an
 * array of notification structures in main memory.
 *
 * The client sets the status field to NV???_NOTIFICATION_STATUS_IN_PROGRESS.
 * NV fills in the NvNotification[] data structure in the following order:
 * timeStamp, otherInfo32, otherInfo16, and then status.
 */


/* memory data structures */
typedef volatile struct {
 struct {                      /*                                   0000-    */
  U032 nanoseconds[2];         /* nanoseconds since Jan. 1, 1970       0-   7*/
 } timeStamp;                  /*                                       -0007*/
 V032 info32;                  /* info returned depends on method   0008-000b*/
 V016 info16;                  /* info returned depends on method   000c-000d*/
 V016 status;                  /* user sets bit 15, NV sets status  000e-000f*/
} NvNotification;
/* status values */

/************** WARNING Duplicated from nv32.h ******************************/

/* pio flow control data structure */
typedef volatile struct {
 NvV32 Ignored00[0x010];
 NvU32 Put;                     /* put offset, write only           0040-0043*/
 NvU32 Get;                     /* get offset, read only            0044-0047*/
 NvU32 Reference;               /* reference value, read only       0048-004b*/
 NvV32 Ignored01[0x7ed];
} Nv06eControl, Nv10ControlDma;




//****************************************************************************
// Macros relocated from DRIVER.H. They were moved here to avoid conflicts
// with D3d source files which had defined the same macros.
//****************************************************************************

#define NvGetFreeCount(NN, CH)\
                 (NN)->subchannel[CH].control.Free

/* class NV01_MEMORY_LOCAL_PRIVILEGED */
#define  NV01_MEMORY_LOCAL_PRIVILEGED                              (0x0000003F)
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\sgs_dac.h ===
//
// (C) Copyright NVIDIA Corporation Inc., 1995,1996. All rights reserved.
//
//
// SGS Thomson DAC registers.
//
//
// DAC microport registeres.
//
#define SGS_DAC_UPORT_WRITE_PAL_ADDR                    NV_PDAC_DATA(0)
#define SGS_DAC_UPORT_COLOR                             NV_PDAC_DATA(1)
#define SGS_DAC_UPORT_PIXEL_MASK                        NV_PDAC_DATA(2)
#define SGS_DAC_UPORT_READ_PAL_ADDR                     NV_PDAC_DATA(3)
#define SGS_DAC_UPORT_INDEX_LO                          NV_PDAC_DATA(4)
#define SGS_DAC_UPORT_INDEX_HI                          NV_PDAC_DATA(5)
#define SGS_DAC_UPORT_INDEX_DATA                        NV_PDAC_DATA(6)
#define SGS_DAC_UPORT_GAMEPORT                          NV_PDAC_DATA(7)
//
// Indexed registers.
//
#define SGS_DAC_VENDOR_ID                               0x0000
#define SGS_DAC_VENDOR_ID_SGS                           0x44
#define SGS_DAC_DEVICE_ID                               0x0001
#define SGS_DAC_DEVICE_ID_VAN_GOGH                      0x32
#define SGS_DAC_DEVICE_ID_VAN_DYKE                      0x64
#define SGS_DAC_REVISION_ID                             0x0002
#define SGS_DAC_CONFIG_0                                0x0004
#define SGS_DAC_CONFIG_0_VESA_CONNECTOR                 7:7
#define SGS_DAC_CONFIG_0_VESA_CONNECTOR_DISABLED        0x00
#define SGS_DAC_CONFIG_0_VESA_CONNECTOR_ENABLED         0x01
#define SGS_DAC_CONFIG_0_IDC_MODE                       6:6
#define SGS_DAC_CONFIG_0_IDC_MODE_DIRECT_COLOR          0x00
#define SGS_DAC_CONFIG_0_IDC_MODE_INDEX                 0x01
#define SGS_DAC_CONFIG_0_VGA_STATE                      5:5
#define SGS_DAC_CONFIG_0_VGA_STATE_READ_ADRESS          0x00
#define SGS_DAC_CONFIG_0_VGA_STATE_READ_STATE           0x01
#define SGS_DAC_CONFIG_0_PORT_WIDTH                     3:2
#define SGS_DAC_CONFIG_0_PORT_WIDTH_16BIT               0x00
#define SGS_DAC_CONFIG_0_PORT_WIDTH_32BIT               0x01
#define SGS_DAC_CONFIG_0_PORT_WIDTH_64BIT               0x02
#define SGS_DAC_CONFIG_0_PIXEL_DEPTH                    1:0
#define SGS_DAC_CONFIG_0_PIXEL_DEPTH_4BIT               0x00
#define SGS_DAC_CONFIG_0_PIXEL_DEPTH_8BIT               0x01
#define SGS_DAC_CONFIG_0_PIXEL_DEPTH_16BIT              0x02
#define SGS_DAC_CONFIG_0_PIXEL_DEPTH_32BIT              0x03
#define SGS_DAC_CONFIG_1                                0x0005
#define SGS_DAC_CONFIG_1_COMP_VOLTAGE                   7:7
#define SGS_DAC_CONFIG_1_COMP_VOLTAGE_NOT_EXCEEDED      0x00
#define SGS_DAC_CONFIG_1_COMP_VOLTAGE_EXCEEDED          0x01
#define SGS_DAC_CONFIG_1_BLANK_PEDASTAL                 6:6
#define SGS_DAC_CONFIG_1_BLANK_PEDASTAL_ADD_0_5_IRE     0x00
#define SGS_DAC_CONFIG_1_BLANK_PEDASTAL_ADD_7_5_IRE     0x01
#define SGS_DAC_CONFIG_1_REGISTER_INIT                  5:5
#define SGS_DAC_CONFIG_1_REGISTER_INIT_NORMAL           0x00
#define SGS_DAC_CONFIG_1_REGISTER_INIT_RESET            0x01
#define SGS_DAC_CONFIG_1_VCLK_DIRECTION                 4:4
#define SGS_DAC_CONFIG_1_VCLK_DIRECTION_OUTPUT          0x00
#define SGS_DAC_CONFIG_1_VCLK_DIRECTION_INPUT           0x01
#define SGS_DAC_CONFIG_1_VCLK_IMPEDENCE                 3:3
#define SGS_DAC_CONFIG_1_VCLK_IMPEDENCE_HIGH            0x00
#define SGS_DAC_CONFIG_1_VCLK_IMPEDENCE_LOW             0x01
#define SGS_DAC_CONFIG_1_VCLK_DIVIDE                    2:0
#define SGS_DAC_CONFIG_1_VCLK_DIVIDE_BY_1               0x00
#define SGS_DAC_CONFIG_1_VCLK_DIVIDE_BY_2               0x01
#define SGS_DAC_CONFIG_1_VCLK_DIVIDE_BY_4               0x02
#define SGS_DAC_CONFIG_1_VCLK_DIVIDE_BY_8               0x03
#define SGS_DAC_CONFIG_1_VCLK_DIVIDE_BY_16              0x04 
#define SGS_DAC_CONFIG_2                                0x0006
#define SGS_DAC_CONFIG_2_DDC_DATA_IN                    0:0
#define SGS_DAC_ACTIVE_PAL_ADDR                         0x0008
#define SGS_DAC_RGB_EXT_PAL_CTRL                        0x0009
#define SGS_DAC_RGB_EXT_PAL_CTRL_DAC_STATE              5:4
#define SGS_DAC_RGB_EXT_PAL_CTRL_DAC_STATE_WRITE        0x00
#define SGS_DAC_RGB_EXT_PAL_CTRL_DAC_STATE_READ         0x03
#define SGS_DAC_RGB_EXT_PAL_CTRL_INDEX_ACCESS           3:3
#define SGS_DAC_RGB_EXT_PAL_CTRL_INDEX_ACCESS_LOW       0x00
#define SGS_DAC_RGB_EXT_PAL_CTRL_INDEX_ACCESS_HIGH      0x01
#define SGS_DAC_RGB_EXT_PAL_CTRL_RGB_NEXT_ACCESS        2:0
#define SGS_DAC_RGB_EXT_PAL_CTRL_RGB_NEXT_ACCESS_RED    0x01
#define SGS_DAC_RGB_EXT_PAL_CTRL_RGB_NEXT_ACCESS_GREEN  0x02
#define SGS_DAC_RGB_EXT_PAL_CTRL_RGB_NEXT_ACCESS_BLUE   0x04
#define SGS_DAC_RED_PAL_DATA                            0x000A
#define SGS_DAC_GREEN_PAL_DATA                          0x000B
#define SGS_DAC_POWER_MGMNT_A                           0x000C
#define SGS_DAC_POWER_MGMNT_A_TEST_POINT_CTRL           7:7
#define SGS_DAC_POWER_MGMNT_A_TEST_POINT_CTRL_POWER     0x00
#define SGS_DAC_POWER_MGMNT_A_TEST_POINT_CTRL_NO_POWER  0x01
#define SGS_DAC_POWER_MGMNT_A_PIXEL_MUX                 6:6
#define SGS_DAC_POWER_MGMNT_A_PIXEL_MUX_POWER           0x00
#define SGS_DAC_POWER_MGMNT_A_PIXEL_MUX_NO_POWER        0x01
#define SGS_DAC_POWER_MGMNT_A_RAM                       5:5
#define SGS_DAC_POWER_MGMNT_A_RAM_POWER                 0x00
#define SGS_DAC_POWER_MGMNT_A_RAM_NO_POWER              0x01
#define SGS_DAC_POWER_MGMNT_A_POST_RAM                  4:4
#define SGS_DAC_POWER_MGMNT_A_POST_RAM_POWER            0x00
#define SGS_DAC_POWER_MGMNT_A_POST_RAM_NO_POWER         0x01
#define SGS_DAC_POWER_MGMNT_A_CHECKSUM                  3:3
#define SGS_DAC_POWER_MGMNT_A_CHECKSUM_POWER            0x00
#define SGS_DAC_POWER_MGMNT_A_CHECKSUM_NO_POWER         0x01
#define SGS_DAC_POWER_MGMNT_A_DAC                       2:2
#define SGS_DAC_POWER_MGMNT_A_DAC_POWER                 0x00
#define SGS_DAC_POWER_MGMNT_A_DAC_NO_POWER              0x01
#define SGS_DAC_POWER_MGMNT_A_INPUT_PINS                1:1
#define SGS_DAC_POWER_MGMNT_A_INPUT_PINS_POWER          0x00
#define SGS_DAC_POWER_MGMNT_A_INPUT_PINS_NO_POWER       0x01
#define SGS_DAC_POWER_MGMNT_A_FIFO                      0:0
#define SGS_DAC_POWER_MGMNT_A_FIFO_POWER                0x00
#define SGS_DAC_POWER_MGMNT_A_FIFO_NO_POWER             0x01
#define SGS_DAC_POWER_MGMNT_B                           0x000D
#define SGS_DAC_POWER_MGMNT_B_MUX_DPM                   6:6
#define SGS_DAC_POWER_MGMNT_B_MUX_DPM_DISABLED          0x00
#define SGS_DAC_POWER_MGMNT_B_MUX_DPM_ENABLED           0x01
#define SGS_DAC_POWER_MGMNT_B_CHANNEL_DPM               5:5
#define SGS_DAC_POWER_MGMNT_B_CHANNEL_DPM_DISABLED      0x00
#define SGS_DAC_POWER_MGMNT_B_CHANNEL_DPM_ENABLED       0x01
#define SGS_DAC_POWER_MGMNT_B_FIFO_DPM                  4:4
#define SGS_DAC_POWER_MGMNT_B_FIFO_DPM_DISABLED         0x00
#define SGS_DAC_POWER_MGMNT_B_FIFO_DPM_ENABLED          0x01
#define SGS_DAC_POWER_MGMNT_B_CRYSTAL                   3:3
#define SGS_DAC_POWER_MGMNT_B_CRYSTAL_POWER             0x00
#define SGS_DAC_POWER_MGMNT_B_CRYSTAL_NO_POWER          0x01
#define SGS_DAC_POWER_MGMNT_B_APPL                      2:2
#define SGS_DAC_POWER_MGMNT_B_APPL_POWER                0x00
#define SGS_DAC_POWER_MGMNT_B_APPL_NO_POWER             0x01
#define SGS_DAC_POWER_MGMNT_B_VPPL                      1:1
#define SGS_DAC_POWER_MGMNT_B_VPPL_POWER                0x00
#define SGS_DAC_POWER_MGMNT_B_VPPL_NO_POWER             0x01
#define SGS_DAC_POWER_MGMNT_B_MPPL                      0:0
#define SGS_DAC_POWER_MGMNT_B_MPPL_POWER                0x00
#define SGS_DAC_POWER_MGMNT_B_MPPL_NO_POWER             0x01
#define SGS_DAC_POWER_MGMNT_C                           0x000E
#define SGS_DAC_POWER_MGMNT_C_GAMEPORT                  1:1
#define SGS_DAC_POWER_MGMNT_C_GAMEPORT_POWER            0x00
#define SGS_DAC_POWER_MGMNT_C_GAMEPORT_NO_POWER         0x01
#define SGS_DAC_POWER_MGMNT_C_CURSOR                    0:0
#define SGS_DAC_POWER_MGMNT_C_CURSOR_POWER              0x00
#define SGS_DAC_POWER_MGMNT_C_CURSOR_NO_POWER           0x01
#define SGS_DAC_MPLL_M                                  0x0010
#define SGS_DAC_MPLL_N                                  0x0011
#define SGS_DAC_MPLL_O                                  0x0012
#define SGS_DAC_MPLL_P                                  0x0013
#define SGS_DAC_APLL_M                                  0x0014
#define SGS_DAC_APLL_N                                  0x0015
#define SGS_DAC_APLL_O                                  0x0016
#define SGS_DAC_APLL_P                                  0x0017
#define SGS_DAC_VPLL_M                                  0x0018
#define SGS_DAC_VPLL_N                                  0x0019
#define SGS_DAC_VPLL_O                                  0x001A
#define SGS_DAC_VPLL_P                                  0x001B
#define SGS_DAC_VBLANK_CTRL                             0x001C
#define SGS_DAC_VBLANK_CTRL_DETECTION                   1:1
#define SGS_DAC_VBLANK_CTRL_DETECTION_NORMAL            0x00
#define SGS_DAC_VBLANK_CTRL_DETECTION_INHIBIT           0x01
#define SGS_DAC_VBLANK_CTRL_CONDITION                   0:0
#define SGS_DAC_VBLANK_CTRL_CONDITION_NORMAL            0x00
#define SGS_DAC_VBLANK_CTRL_CONDITION_FORCE             0x01
#define SGS_DAC_CURSOR_CTRL                             0x0020
#define SGS_DAC_CURSOR_CTRL_DISPLAY                     1:0
#define SGS_DAC_CURSOR_CTRL_DISPLAY_DISABLED            0x00
#define SGS_DAC_CURSOR_CTRL_DISPLAY_THREE_COLOR         0x01
#define SGS_DAC_CURSOR_CTRL_DISPLAY_TWO_COLOR_XOR       0x02
#define SGS_DAC_CURSOR_CTRL_DISPLAY_TWO_COLOR           0x03
#define SGS_DAC_CURSOR_POS_X_LO                         0x0022
#define SGS_DAC_CURSOR_POS_X_HI                         0x0023
#define SGS_DAC_CURSOR_POS_Y_LO                         0x0024
#define SGS_DAC_CURSOR_POS_Y_HI                         0x0025
#define SGS_DAC_CHECKSUM_CTRL                           0x0030
#define SGS_DAC_CHECKSUM_CTRL_VALUE                     2:2
#define SGS_DAC_CHECKSUM_CTRL_VALUE_NOT_RESET           0x00
#define SGS_DAC_CHECKSUM_CTRL_VALUE_RESET               0x01
#define SGS_DAC_CHECKSUM_CTRL_COLOR                     1:0
#define SGS_DAC_CHECKSUM_CTRL_COLOR_BLUE                0x00
#define SGS_DAC_CHECKSUM_CTRL_COLOR_GREEN               0x01
#define SGS_DAC_CHECKSUM_CTRL_COLOR_RED                 0x02
#define SGS_DAC_CHECKSUM_HI                             0x0031
#define SGS_DAC_CHECKSUM_MID                            0x0032
#define SGS_DAC_CHECKSUM_LO                             0x0033
#define SGS_DAC_GAMEPORT_STATE                          0x003D
#define SGS_DAC_GAMEPORT_STATE_CAPTURE_PHASE            4:4
#define SGS_DAC_GAMEPORT_STATE_CAPTURE_PHASE_ANALOG     0x00
#define SGS_DAC_GAMEPORT_STATE_CAPTURE_PHASE_DIGITAL    0x01
#define SGS_DAC_GAMEPORT_STATE_COUNTER                  3:0
#define SGS_DAC_GAMEPORT_TYPE                           0x003E
#define SGS_DAC_GAMEPORT_TYPE_CHANNEL_7                 7:7
#define SGS_DAC_GAMEPORT_TYPE_CHANNEL_6                 6:6
#define SGS_DAC_GAMEPORT_TYPE_CHANNEL_5                 5:5
#define SGS_DAC_GAMEPORT_TYPE_CHANNEL_4                 4:4
#define SGS_DAC_GAMEPORT_TYPE_CHANNEL_3                 3:3
#define SGS_DAC_GAMEPORT_TYPE_CHANNEL_2                 2:2
#define SGS_DAC_GAMEPORT_TYPE_CHANNEL_1                 1:1
#define SGS_DAC_GAMEPORT_TYPE_CHANNEL_0                 0:0
#define SGS_DAC_GAMEPORT_TYPE_ANALOG                    0x00
#define SGS_DAC_GAMEPORT_TYPE_DIGITAL                   0x01
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT                  0x003F
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_CHANNEL_7        7:7
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_CHANNEL_6        6:6
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_CHANNEL_5        5:5
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_CHANNEL_4        4:4
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_CHANNEL_3        3:3
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_CHANNEL_2        2:2
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_CHANNEL_1        1:1
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_CHANNEL_0        0:0
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_NOT_PRESSED      0x00
#define SGS_DAC_GAMEPORT_DIGITAL_INPUT_PRESSED          0x01
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_0_LO              0x0040
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_0_HI              0x0041
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_1_LO              0x0042
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_1_HI              0x0043
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_2_LO              0x0044
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_2_HI              0x0045
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_3_LO              0x0046
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_3_HI              0x0047
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_4_LO              0x0048
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_4_HI              0x0049
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_5_LO              0x004A
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_5_HI              0x004B
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_6_LO              0x004C
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_6_HI              0x004D
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_7_LO              0x004E
#define SGS_DAC_GAMEPORT_ANALOG_INPUT_7_HI              0x004F
#define SGS_DAC_CURSOR_COLOR_1_RED                      0x0050
#define SGS_DAC_CURSOR_COLOR_1_GREEN                    0x0051
#define SGS_DAC_CURSOR_COLOR_1_BLUE                     0x0052
#define SGS_DAC_CURSOR_COLOR_2_RED                      0x0054
#define SGS_DAC_CURSOR_COLOR_2_GREEN                    0x0055
#define SGS_DAC_CURSOR_COLOR_2_BLUE                     0x0056
#define SGS_DAC_CURSOR_COLOR_3_RED                      0x0057
#define SGS_DAC_CURSOR_COLOR_3_GREEN                    0x0058
#define SGS_DAC_CURSOR_COLOR_3_BLUE                     0x0059
#define SGS_DAC_CURSOR_PLANE_0_WRITE_0                  0x0100
#define SGS_DAC_CURSOR_PLANE_0_WRITE_7F                 0x017F
#define SGS_DAC_CURSOR_PLANE_1_WRITE_0                  0x0180
#define SGS_DAC_CURSOR_PLANE_1_WRITE_7F                 0x01FF
#define SGS_DAC_CURSOR_PLANE_0_READ_0                   0x0500
#define SGS_DAC_CURSOR_PLANE_0_READ_7F                  0x057F
#define SGS_DAC_CURSOR_PLANE_1_READ_0                   0x0580
#define SGS_DAC_CURSOR_PLANE_1_READ_7F                  0x05FF
#define SGS_DAC_TESTPOINT_0_0                           0xF000
#define SGS_DAC_TESTPOINT_0_1                           0xF001
#define SGS_DAC_TESTPOINT_0_2                           0xF002
#define SGS_DAC_TESTPOINT_0_3                           0xF003
#define SGS_DAC_TESTPOINT_0_4                           0xF004
#define SGS_DAC_TESTPOINT_0_5                           0xF005
#define SGS_DAC_TESTPOINT_0_6                           0xF006
#define SGS_DAC_TESTPOINT_0_7                           0xF007
#define SGS_DAC_TESTPOINT_1_0                           0xF008
#define SGS_DAC_TESTPOINT_1_1                           0xF009
#define SGS_DAC_TESTPOINT_1_2                           0xF00A
#define SGS_DAC_TESTPOINT_1_3                           0xF00B
#define SGS_DAC_TESTPOINT_1_4                           0xF00C
#define SGS_DAC_TESTPOINT_1_5                           0xF00D
#define SGS_DAC_TESTPOINT_1_6                           0xF00E
#define SGS_DAC_TESTPOINT_1_7                           0xF00F
#define SGS_DAC_TESTPOINT_3_0                           0xF010
#define SGS_DAC_TESTPOINT_3_1                           0xF011
#define SGS_DAC_TESTPOINT_3_2                           0xF012
#define SGS_DAC_TESTPOINT_3_3                           0xF013
#define SGS_DAC_TESTPOINT_3_4                           0xF014
#define SGS_DAC_TESTPOINT_3_5                           0xF015
#define SGS_DAC_TESTPOINT_3_6                           0xF016
#define SGS_DAC_TESTPOINT_3_7                           0xF017
#define SGS_DAC_TESTPOINT_4_0                           0xF018
#define SGS_DAC_TESTPOINT_4_1                           0xF019
#define SGS_DAC_TESTPOINT_4_2                           0xF01A
#define SGS_DAC_TESTPOINT_4_3                           0xF01B
#define SGS_DAC_TESTPOINT_4_4                           0xF01C
#define SGS_DAC_TESTPOINT_4_5                           0xF01D
#define SGS_DAC_TESTPOINT_4_6                           0xF01E
#define SGS_DAC_TESTPOINT_4_7                           0xF01F
#define SGS_DAC_CURSOR_TEST_0                           0xF028
#define SGS_DAC_CURSOR_TEST_1                           0xF029
#define SGS_DAC_CURSOR_TEST_2                           0xF02A
#define SGS_DAC_CURSOR_TEST_3                           0xF02B
#define SGS_DAC_CURSOR_TEST_4                           0xF02C
#define SGS_DAC_CURSOR_TEST_5                           0xF02D
#define SGS_DAC_CURSOR_TEST_6                           0xF02E
#define SGS_DAC_CURSOR_TEST_7                           0xF02F
#define SGS_DAC_FIFO_TEST_0                             0xF030
#define SGS_DAC_FIFO_TEST_1                             0xF031
#define SGS_DAC_FIFO_TEST_2                             0xF032
#define SGS_DAC_FIFO_TEST_3                             0xF033
#define SGS_DAC_FIFO_TEST_4                             0xF034
#define SGS_DAC_FIFO_TEST_5                             0xF035
#define SGS_DAC_FIFO_TEST_6                             0xF036
#define SGS_DAC_FIFO_TEST_7                             0xF037
#define SGS_DAC_MPLL_TEST_0                             0xF038
#define SGS_DAC_MPLL_TEST_1                             0xF039
#define SGS_DAC_MPLL_TEST_2                             0xF03A
#define SGS_DAC_MPLL_TEST_3                             0xF03B
#define SGS_DAC_MPLL_TEST_4                             0xF03C
#define SGS_DAC_MPLL_TEST_5                             0xF03D
#define SGS_DAC_MPLL_TEST_6                             0xF03E
#define SGS_DAC_MPLL_TEST_7                             0xF03F
#define SGS_DAC_VPLL_TEST_0                             0xF040
#define SGS_DAC_VPLL_TEST_1                             0xF041
#define SGS_DAC_VPLL_TEST_2                             0xF042 
#define SGS_DAC_VPLL_TEST_3                             0xF043
#define SGS_DAC_VPLL_TEST_4                             0xF044
#define SGS_DAC_VPLL_TEST_5                             0xF045
#define SGS_DAC_VPLL_TEST_6                             0xF046
#define SGS_DAC_VPLL_TEST_7                             0xF047
#define SGS_DAC_GAMEPORT_TEST_0                         0xF048
#define SGS_DAC_GAMEPORT_TEST_1                         0xF049
#define SGS_DAC_GAMEPORT_TEST_2                         0xF04A
#define SGS_DAC_GAMEPORT_TEST_3                         0xF04B
#define SGS_DAC_GAMEPORT_TEST_4                         0xF04C
#define SGS_DAC_GAMEPORT_TEST_5                         0xF04D
#define SGS_DAC_GAMEPORT_TEST_6                         0xF04E
#define SGS_DAC_GAMEPORT_TEST_7                         0xF04F
#define SGS_DAC_TESTPOINT_CTRL                          0xF058
#define SGS_DAC_TESTPOINT_TIMER                         0xF059
#define SGS_DAC_TEST_CTRL                               0xF05A
#define SGS_DAC_MISC_TEST_STATE                         0xF05B
#define SGS_DAC_TEST_OUT_CTRL                           0xF05C
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\rm.h ===
/**************************************************************************************************************
*
*   File:  rm.h
*
*   Description:
*       Definitions for the use of and entry points into the resource manager library from the miniport.
*
**************************************************************************************************************/

// notify callback action
#define NV_OS_WRITE_THEN_AWAKEN     0x00000001

// power state definitions used by RmSet/GetPowerState() and RmGetCurrentPowerState()
#define NV_POWER_ADAPTER_STATE_0            0x00000001 // full on
#define NV_POWER_ADAPTER_STATE_1            0x00000002 // slowed clocks
#define NV_POWER_ADAPTER_STATE_2            0x00000004 // slowed clocks, mobile style *** not all devices supported ***
#define NV_POWER_ADAPTER_STATE_3            0x00000008 // very slow clocks, state saved (regs & instance memory)
#define NV_POWER_ADAPTER_STATE_4            0x00000010 // future lower adapter power state
#define NV_POWER_ADAPTER_STATE_5            0x00000020 // future lower adapter power state
#define NV_POWER_ADAPTER_STATE_6            0x00000040 // future lower adapter power state
#define NV_POWER_ADAPTER_STATE_7            0x00000080 // future lower adapter power state
#define NV_POWER_ADAPTER_FEATURE_CTXSAVED   0x00000100 // lowest power consumption state saves device context
#define NV_POWER_ADAPTER_STATE_HIBERNATE    0x00000200 // adapter hibernate
#define NV_POWER_ADAPTER_FEATURE_UNDEF_2    0x00000400 // future feature
#define NV_POWER_ADAPTER_FEATURE_UNDEF_3    0x00000800 // future feature
#define NV_POWER_ADAPTER_FEATURE_UNDEF_4    0x00001000 // future feature
#define NV_POWER_ADAPTER_FEATURE_UNDEF_5    0x00002000 // future feature
#define NV_POWER_ADAPTER_FEATURE_UNDEF_6    0x00004000 // future feature
#define NV_POWER_ADAPTER_FEATURE_UNDEF_7    0x00008000 // future feature
#define NV_POWER_MONITOR_STATE_0            0x00010000 // full on
#define NV_POWER_MONITOR_STATE_1            0x00020000 // no VSYNC nor HSYNC
#define NV_POWER_MONITOR_STATE_2            0x00040000 // future lower monitor power state 

#define NV_POWER_MONITOR_STATE_3            0x00080000 // future lower monitor power state
#define NV_POWER_MONITOR_STATE_4            0x00100000 // future lower monitor power state
#define NV_POWER_MONITOR_STATE_5            0x00200000 // future lower monitor power state
#define NV_POWER_MONITOR_STATE_6            0x00400000 // future lower monitor power state
#define NV_POWER_MONITOR_STATE_7            0x00800000 // future lower monitor power state
#define NV_POWER_MONITOR_STATE_HIBERNATE    0x01000000 // monitor hibernate
#define NV_POWER_UNDEF_1                    0x02000000 // future attribute
#define NV_POWER_UNDEF_2                    0x04000000 // future attribute
#define NV_POWER_UNDEF_3                    0x08000000 // future attribute
#define NV_POWER_UNDEF_4                    0x10000000 // future attribute
#define NV_POWER_UNDEF_5                    0x20000000 // future attribute
#define NV_POWER_UNDEF_6                    0x40000000 // future attribute
#define NV_POWER_UNDEF_7                    0x80000000 // future attribute

// prototype of callback fct -- the parameter is the device extension
typedef VOID (*MINIPORT_CALLBACK)(VOID*);

BOOL    RmInitRm            (VOID);
BOOL    RmInitNvMapping     (VOID*, U032, PHWREG, U032*);
BOOL    RmPostNvDevice      (U032, PHWREG, PHWREG);
BOOL    RmInitNvDevice      (U032, U032, PHWREG);
BOOL    RmInitNvHal         (U032);
BOOL    RmLoadState         (U032, U032, U032, U032, U032, BOOL);
BOOL    RmUnloadState       (U032);
BOOL    RmUpdateAGPConfig   (U032);
BOOL    RmSetMode           (U032,U032,U032,U032,U032,U032,U032,U032,U032,U032,U032,U032,U032,U032,U032,U032,U032,U032,U032,U032,U032);
BOOL    RmIsr               (U032);
BOOL    RmConfigGetKernel   (U032, U032, U032*);
BOOL    RmConfigGetExKernel (U032, U032, VOID*, U032);
BOOL    RmConfigSetKernel   (U032, U032, U032, U032*);
BOOL    RmConfigSetExKernel (U032, U032, VOID*, U032);
#if (_WIN32_WINNT >= 0x0500)
VOID    RmSetAgpServices    (U032, VOID*);
#endif
BOOL    RmPreModeSet        (U032, U032);
BOOL    RmPostModeSet       (U032, U032);

BOOL    RmSetDisplayPowerState      (U032, U032, BOOL);
BOOL    RmEnableHead                (U032, U032);
BOOL    RmSetPowerState             (U032 deviceReference, U032 head, U032 state);
BOOL    RmGetCurrentPowerState      (U032 deviceReference, U032 head, U032* pState);
BOOL    RmGetPowerCaps              (U032 deviceReference, U032 head, U032* pCaps);
BOOL    RmSetDriverHotkeyHandling   (U032 deviceReference, BOOL enabled);
VP_STATUS  RMVideoResetDevice       (U032 deviceReference);

VOID    Nv01AllocRoot       (NVOS01_PARAMETERS*);
VOID    Nv01AllocDevice     (NVOS06_PARAMETERS*);
VOID    Nv01AllocContextDma (NVOS03_PARAMETERS*);
VOID    Nv01AllocChannelPio (NVOS04_PARAMETERS*);
VOID    Nv03AllocChannelDma (NVOS07_PARAMETERS*);
VOID    Nv01AllocMemory     (NVOS02_PARAMETERS*);
VOID    Nv01AllocObject     (NVOS05_PARAMETERS*);
VOID    Nv01AllocEvent      (NVOS10_PARAMETERS*);
VOID    Nv04Alloc           (NVOS21_PARAMETERS*);
VOID    Nv01Free            (NVOS00_PARAMETERS*);
VOID    Nv03DmaFlowControl  (NVOS08_PARAMETERS*);
VOID    Nv03ArchHeap        (NVOS11_PARAMETERS*);
VOID    Nv01ConfigVersion   (NVOS12_PARAMETERS*);
VOID    Nv01ConfigGet       (NVOS13_PARAMETERS*);
VOID    Nv01ConfigSet       (NVOS14_PARAMETERS*);
VOID    Nv04ConfigGetEx     (NVOS_CONFIG_GET_EX_PARAMS*);
VOID    Nv04ConfigSetEx     (NVOS_CONFIG_SET_EX_PARAMS*);
VOID    Nv01ConfigUpdate    (NVOS15_PARAMETERS*);
VOID    Nv01DebugControl    (NVOS20_PARAMETERS*);
VOID    Nv04I2CAccess       (NVOS_I2C_ACCESS_PARAMS *);
VOID    Nv04DirectMethodCall(NVOS1D_PARAMETERS*);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\osapiNT.c ===
/*
    FILE:   osapi.c
    DATE:   4/8/99

    This file holds code for functions that are called back to by
    the generic modeset code.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "debug.h"
#include "nvreg.h"
#include "restime.h"
#include "osapi.h"
#include "utils.h"
#include "edid.h"
#include "gtfmath.h"
#include "dmt.h"

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"
#include "nv.h"

// Bring this in to get the flat panel structs
#include "nvcm.h"
#include "cmdcnst.h"
#include "monitor.h"
#include "vesadata.h"
#include "nvMultiMon.h"

extern VP_STATUS NVGetRegistryTwinviewInfo (
    PHW_DEVICE_EXTENSION hwDeviceExtension,
    NVTWINVIEWDATA      *pTwinviewInfo
    );

extern BOOLEAN   TwinViewDataOK(PHW_DEVICE_EXTENSION hwDeviceExtension, NVTWINVIEWDATA *pData);
VOID SetTimingOverRide(PHW_DEVICE_EXTENSION HwDeviceExtension);
ULONG GetBestResolution(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG ulEDIDIndex, ULONG ulHead, ULONG ulDeviceMask, MODE_ENTRY *pBestMode);
extern int CFUNC EdidFindLargestEdidMode (LPCHAR lpEdidBuffer, ULONG dwEdidSize,LPMODEINFO lpModeInfo);
extern VOID EnterFPCode(VOID *pSave, VOID *pMutex);
extern VOID ExitFPCode(VOID *pSave, VOID *pMutex);
extern ULONG GetTimingDacCommonModesetCode(PHW_DEVICE_EXTENSION HwDeviceExtension, HEAD_RESOLUTION_INFO *pResolution, DAC_TIMING_VALUES * pTimingInfo);

extern VP_STATUS
NVRegistryCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

extern VP_STATUS
NVReadMonitorTimingModeCallback(
    PVOID HwDeviceExtension,
    PVOID Context,
    PWSTR ValueName,
    PVOID ValueData,
    ULONG ValueLength
    );

//******************************************************************************
//
// External Function Declarations
//
//******************************************************************************

extern BOOL RmConfigGetExKernel
(
    U032 deviceReference,
    U032 index,
    VOID* pParms,
    U032 parmSize
);

extern BOOL RmConfigGetKernel (U032, U032, U032*);


// GK UNDO
float __fltused = 0.0;

// Hack. See the '4' below. Thats because the modeentry structure has 4 ULONG fields in it.
// Later we should dynamically malloc it. For now, we create a static global array.                                                                                                     
#define MAX_VALID_MODE_TABLE_DATA_WORDS_MODESET (MAX_STRING_REGISTRY_LINES * MAX_VALID_MODE_REFRESH_RATES * 4)

ULONG glpModeEntry[MAX_VALID_MODE_TABLE_DATA_WORDS_MODESET];


/*
    GetMasterModeList

    This routine returns a ptr to a an array of MODEENTRY
    structures which describe the list of available modes for
    the board specified. This routine needs to ALWAYS return
    some mode list. If you have to just return a list of safe
    modes like 640,480,8,60Hz.

    You can alloc memory for the mode list because you will be
    given a chance to free the ptr later.
*/
LPMODEENTRY CFUNC
GetMasterModeList (LPDISPDATA lpBoardData)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension;
    ULONG NumRegModes;
    PMODE_ENTRY SrcModeEntry;
    LPMODEENTRY DstModeEntry;
    LPMODEENTRY pRet;
    ULONG i;

    hwDeviceExtension = (PHW_DEVICE_EXTENSION)lpBoardData->dwContext1;
    NumRegModes = hwDeviceExtension->NumRegistryModes;
    SrcModeEntry = (PMODE_ENTRY)&(hwDeviceExtension->ValidModeTable[0]);
    DstModeEntry = (LPMODEENTRY)&glpModeEntry[0];

    
    //Copy the registry mode list into the modeset list.
    for (i=0; i < NumRegModes; i++)
    {
        if (SrcModeEntry->ValidMode)
        {
            // Do not pass spanning resolutions. Limit only to single resolutions.
            if (!MULTIMON_MODE(SrcModeEntry->Width, SrcModeEntry->Height))
            {
                DstModeEntry->dwXRes        = SrcModeEntry->Width;
                DstModeEntry->dwYRes        = SrcModeEntry->Height;
                DstModeEntry->dwBpp         = SrcModeEntry->Depth;
                DstModeEntry->dwRefreshRate = SrcModeEntry->RefreshRate;
                DstModeEntry++;
            }
        }
        SrcModeEntry++;
    }

    // The last entry needs to be zeroed out.
    DstModeEntry->dwXRes        = 0;
    DstModeEntry->dwYRes        = 0;
    DstModeEntry->dwBpp         = 0;
    DstModeEntry->dwRefreshRate = 0;

    // You can't return NULL -- this is just a template.
    pRet = (LPMODEENTRY)&glpModeEntry[0];
    return(pRet);
}


/*
    FreeMasterModeList

    This routine is called when the caller is done with the mode
    list it got earlier.
*/
int CFUNC
FreeMasterModeList (LPMODEENTRY lpModeList)
{
    return  (TRUE);
}

/*
    GetSafeModeList

    This routine just returns a few safe modes in the mode list.
    It always returns TRUE.
*/
int CFUNC GetSafeModeList (LPMODEENTRY lpModeList)
{
    return  (TRUE);
}


// Just in case we can't GlobalAlloc a list, we have a single entry one
// we can use here.
RESTIME     sRTList;

/*
    GetMasterRTList

    This routine returns a ptr to a an array of RESTIME
    structures which describe the list of R&T strings for
    the board specified. This routine needs to ALWAYS return
    some RT list. If you have to just return a blank list.

    You can alloc memory for the mode list because you will be
    given a chance to free the ptr later.
*/
LPRESTIME CFUNC
GetMasterRTList (LPDISPDATA lpBoardData)
{
    LPRESTIME   lpRTList;

    // Here is returning a blank list.
    lpRTList = &sRTList;
    lpRTList[0].dwXRes = 0;
    return  (lpRTList);
}


/*
    FreeMasterRTList

    This routine is called when the caller is done with the RTList.
*/
int CFUNC
FreeMasterRTList (LPRESTIME lpRTList)
{
    return  (TRUE);
}

/*
    GetTimingStandardOverride

    This routine gets any timing standard override for the board
    specified. It should return one of the constants defined in
    restime.h like DMTV_ID. A timing standard override is a
    timing standard that applies to all modes. Just something
    that the user might want to enforce.
*/
ULONG CFUNC
GetTimingStandardOverride (LPDISPDATA lpDispData)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension;
    ULONG ulHead;
    
    hwDeviceExtension = (PHW_DEVICE_EXTENSION)lpDispData->dwContext1;
    ulHead = lpDispData->dwCRTCIndex;

    return(hwDeviceExtension->ulTimingOverrideTwinViewInfo[ulHead]);
    
}


/*
    Function:   GetPitchAndSize

    Purpose:    This routine returns the pitch for a given mode.

    Arguments:  lpDispData  - identifies the specific board that we
                              want the active display port for.
                dwXRes      - The X res in pixels for the mode
                              should be returned.
                dwBpp       - the bits per pixel for the mode

    Returns:    The pitch in bytes
*/

ULONG CFUNC
GetPitchAndSize (LPDISPDATA lpDispData, ULONG dwXRes, ULONG dwYRes, ULONG dwBpp, ULONG *pdwPitch, ULONG *pdwSize)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension;
    NV_CFGEX_GET_SURFACE_DIMENSIONS_PARAMS nvPitch;
    ULONG PitchInBytes;

    hwDeviceExtension = (PHW_DEVICE_EXTENSION)lpDispData->dwContext1;

    nvPitch.Width = dwXRes;
    nvPitch.Height= dwYRes;
    nvPitch.Depth = dwBpp;

    RmConfigGetExKernel(hwDeviceExtension->DeviceReference, NV_CFGEX_GET_SURFACE_DIMENSIONS, &nvPitch, sizeof(NV_CFGEX_GET_SURFACE_DIMENSIONS_PARAMS));
    PitchInBytes = nvPitch.Pitch;

    *pdwPitch = nvPitch.Pitch;
    *pdwSize =  PitchInBytes * dwYRes;
            
    return(PitchInBytes);
}


/*
    Function:   GetMonitorInfRangeLimits

    Purpose:    This routine reads the "MaxResolution" key in the
                active monitor node in the registry to get the
                maximum resolution the monitor can do. It uses
                the maximum resolution itself (like "1600,1200")
                as another subkey under which is typically a
                monitor range limits string which looks like
                "30-95,60-120,-,+" where the first range is
                the horizontal limits inKHz and the second is
                the vertical range in hertz. The last two characters
                are horizontal and vertical sync polarities.
                This range limits string doesn't always exist.

    Arguments:
                lpDispData  - identifies the specific board that we
                              want the active display port for.
                lpML        - ptr to a monitor limits structure
                              that will be filled in with range
                              limits obtained or computed from
                              values stuffed in the registry
                              by the moitor .inf file.
                lpdwXRes    - ptr to a variable that will be set
                              to the maximum X-resolution found
                              for this monitor.
                lpdwYRes    - ptr to a variable that will be set
                              to the maximum Y-resolution found
                              for this monitor.

    Returns:    TRUE    then lpML, lpdwXRes, and lpdwYRes have been
                        filled in correctly.
                FALSE   then there was an error getting some value.
*/
int CFUNC
GetMonitorInfRangeLimits (
    LPDISPDATA      lpDispData,
    LPMONITORLIMITS lpML,
    ULONG           *lpdwXRes,
    ULONG           *lpdwYRes)
{
    return  (TRUE);
}


/*
    Function:   GetMonitorLimitMode

    Purpose:    This routine gets the mode which should be an
                upper bound for a monitor which has no edid and
                no .inf.

    Arguments:  lpDispData  - identifies the specific board that we
                              want the active display port for.
                lpModeInfo  - ptr to a place to store the limit mode

    Returns:    If this routine returns TRUE, then lpModeInfo was
                filled in with the limit mode. If this routine
                returns FALSE, then there is no limit mode.
*/
int CFUNC
GetMonitorLimitMode (LPDISPDATA lpDispData, LPMODEINFO lpModeInfo)
{
    return(FALSE);
}


/*
    Function:   GetAllowAllModesFlag

    Purpose:    WIN9X spacific function for testing only.
        This function get "AllowAllModes" registry key
        for specified DispData.

    Arguments:
                lpRegData  - identifies a specific board
    Returns:    "AllowAllModes" key value or FALSE.
*/
ULONG WINAPI GetAllowAllModesFlag(LPREGDATA lpRegData)
{
return(FALSE);
}


/*
    Function:   IsModeAcceptededByDriver

    Purpose:    This routine allows the display driver to perform any
                other restrictions on a potential mode that it wants to.
                This is the final step in the mode restriction. This
                routine has access to the output timing parameters
                so it can do all sorts of fun checking.

    Arguments:  lpDispData  - identifies the specific board that we
                              want the active display port for.
                lpModeOut   - the timing parameters for the mode
                              you may modify them in place if you
                              want them changed.
                lpEdidBuffer  ptr to the EDID
                dwEdidSize    size of the edid in bytes (0 if no edid)

    Returns:    TRUE    if this mode is allowed
                FALSE   if the mode should be rejected

                Note that it is possible to modify the timings in
                lpModeOut and still return TRUE. Your modified
                timings will be used. However, this capability
                should really only be used in exceptional cases.
                If there is some reason to be modifying timings,
                let's get it into the modeset dll rather than
                having the display driver under every OS do
                something special.
*/
ULONG CFUNC
IsModeAcceptedByDriver (LPDISPDATA lpDispData, LPMODEOUT lpModeOut,
                        LPCHAR lpEdidBuffer, ULONG dwEdidSize)
{
    return  (TRUE);
}


//
// First reads the "TwinViewInfo" registry to get the timing override.
// If there is no such registry entry, then reads the "DMTOVERRIDE" and "MonitorTiming" registry entries.
//
VOID SetTimingOverRide(PHW_DEVICE_EXTENSION HwDeviceExtension)
{
    NVTWINVIEWDATA pInfo;
    ULONG ulHead;
    VP_STATUS status;
    PHW_DEVICE_EXTENSION hwDeviceExtension;
    ULONG i;

    hwDeviceExtension = HwDeviceExtension;

    //**************************************************************************
    // Check to see if VESA DMT monitor timings should be used
    //**************************************************************************
    hwDeviceExtension->bUseDMT = FALSE;
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                       L"DMTOVERRIDE",
                                       FALSE,
                                       NVRegistryCallback,
                                       &(hwDeviceExtension->bUseDMT));


    //**************************************************************************
    // Check to see if there is a GTF method requested by the user instead ( DMTOVERRIDE has priority)
    //**************************************************************************
    hwDeviceExtension->bUseGTF = FALSE;

    // Try and get some kind of monitor timing selection
    status = VideoPortGetRegistryParameters(HwDeviceExtension,
                                           L"MonitorTiming",
                                           FALSE,
                                           NVReadMonitorTimingModeCallback,
                                           &(hwDeviceExtension->bUseGTF));


    // The DMT overide has priority
    if(HwDeviceExtension->bUseDMT) {
        HwDeviceExtension->bUseGTF = FALSE;
    }

    
    status = NVGetRegistryTwinviewInfo(HwDeviceExtension, &pInfo);
    if (status == NO_ERROR)
    {
        // See if the twinview data is valid.
        if (TwinViewDataOK(HwDeviceExtension, &pInfo))
        {

            for (i=0; i < HwDeviceExtension->DeskTopInfo.ulNumberDacsOnBoard; i++)
            {
                ulHead = pInfo.dwDeviceDisplay[i];

                switch (pInfo.NVTWINVIEWUNION.nvtwdevdata[ulHead].dwTimingOverRide)
                {
                case TIMING_OVERRIDE_GTF:
                    VideoDebugPrint((5,"GetTimingStandardOverride(): Forced to use GTF\n"));
                    HwDeviceExtension->ulTimingOverrideTwinViewInfo[ulHead] = GTFV_ID;
                    break;
                case TIMING_OVERRIDE_DMT:
                    VideoDebugPrint((5,"GetTimingStandardOverride(): Forced to use DMT\n"));
                    HwDeviceExtension->ulTimingOverrideTwinViewInfo[ulHead] = DMTV_ID;
                    break;
                case TIMING_OVERRIDE_AUTO:
                    HwDeviceExtension->ulTimingOverrideTwinViewInfo[ulHead] = NONE_ID;
                    break;
                default:
                    VideoDebugPrint((5,"Oops! GetTimingStandardOverride(): Invalid TimingOverride from registry: 0x%x\n",
                                     pInfo.NVTWINVIEWUNION.nvtwdevdata[ulHead].dwTimingOverRide));
                    HwDeviceExtension->ulTimingOverrideTwinViewInfo[ulHead] = NONE_ID;
                    break;
                }
            }
            return;
        }
    }

    for (i=0; i < NV_NO_DACS; i++)
    {

        // TwinViewInfo registry entry not found.
        // So look at the old registry entries.
        // Note: Not sure if we should honor the old registry entries. Check with Peter.
        if (hwDeviceExtension->bUseGTF)
        {
            VideoDebugPrint((5,"GetTimingStandardOverride(): Forced to use GTF\n"));
            HwDeviceExtension->ulTimingOverrideTwinViewInfo[i] = GTFV_ID;
        }
        else if (hwDeviceExtension->bUseDMT)
        {
            VideoDebugPrint((5,"GetTimingStandardOverride(): Forced to use DMT\n"));
            HwDeviceExtension->ulTimingOverrideTwinViewInfo[i] = DMTV_ID;
        }
        else
        {
            VideoDebugPrint((5,"GetTimingStandardOverride(): Forced to use NONE_ID\n"));
            HwDeviceExtension->ulTimingOverrideTwinViewInfo[i] = NONE_ID;
        }
    }
    return;
}

//
// Finds the best resolution for the device with the valid EDID index.
// Finds the largest resolution at 16bpp and the highest refresh rate at this resolution.
// Returns TRUE if it finds a best mode. Otherwise returns FALSE.
//
ULONG GetBestResolution(PHW_DEVICE_EXTENSION HwDeviceExtension, ULONG ulEDIDIndex, ULONG ulHead, ULONG ulDeviceMask, MODE_ENTRY *pBestMode)
{
    LPMODEINFO lpModeDesc;
    MODEINFO ModeDesc;
    HEAD_RESOLUTION_INFO sResolution;
    HEAD_RESOLUTION_INFO *pResolution;
    DAC_TIMING_VALUES * pTimingInfo;
    DAC_TIMING_VALUES   sTimingInfo;

    VideoDebugPrint((1,"GetBestResolution for index: %d\n", ulEDIDIndex));
    lpModeDesc = &ModeDesc;
    pTimingInfo = &sTimingInfo;
    pResolution = &sResolution;
    lpModeDesc->dwBpp = 32;
    lpModeDesc->dwRefreshRate = 60;

    EnterFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);
    EdidFindLargestEdidMode (HwDeviceExtension->EdidCollection->HeadMaps[ulEDIDIndex]->EDIDBuffer,
                             HwDeviceExtension->EdidCollection->HeadMaps[ulEDIDIndex]->Size, lpModeDesc);
    ExitFPCode(HwDeviceExtension->pFPStateSave, HwDeviceExtension->pFPMutex);

    if (lpModeDesc->dwXRes == 640 && lpModeDesc->dwYRes == 480)
    {
        // the common modeset code fell back to defaut res.
        VideoDebugPrint((1,"Failure: FindLargestEdidMode(): (%d, %d), %d bpp, %d Hz\n", 
            lpModeDesc->dwXRes,lpModeDesc->dwYRes,lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate));
        return(FALSE);
    }
    else
    {   
        // Print the mode info.
        VideoDebugPrint((1,"FindLargestEdidMode(): (%d, %d), %d bpp, %d Hz\n", 
            lpModeDesc->dwXRes,lpModeDesc->dwYRes,lpModeDesc->dwBpp, lpModeDesc->dwRefreshRate));

        // What we have now is the best possible mode using EDID only. Now we need to filter it against the other
        // parameters like video memory, pixel clock frequency etc..
        pResolution->ulHead = ulHead;
        pResolution->ulDeviceMask = ulDeviceMask;
        pResolution->ulDisplayWidth = lpModeDesc->dwXRes;
        pResolution->ulDisplayHeight = lpModeDesc->dwYRes;
        pResolution->ulDisplayPixelDepth = lpModeDesc->dwBpp;
        pResolution->ulDisplayRefresh = lpModeDesc->dwRefreshRate;
        pResolution->ulOption = 0;

        GetTimingDacCommonModesetCode(HwDeviceExtension, pResolution, pTimingInfo);

        // If the width, height and depth were maintained, then use the mode. Possibly, the refresh rate 
        // could have changed.
        if (pTimingInfo->HorizontalVisible == lpModeDesc->dwXRes &&
            pTimingInfo->VerticalVisible == lpModeDesc->dwYRes)
        {
            // Copy the info into the BestMode parameter.
            pBestMode->Width = (USHORT)lpModeDesc->dwXRes;
            pBestMode->Height = (USHORT)lpModeDesc->dwYRes;
            pBestMode->Depth = (USHORT)lpModeDesc->dwBpp;
            pBestMode->RefreshRate = (USHORT)pTimingInfo->Refresh;
            pBestMode->ValidMode = 1;
            VideoDebugPrint((1,"Success: GetTimingDac(): (%d, %d), %d bpp, %d Hz\n", 
                pTimingInfo->HorizontalVisible,pTimingInfo->VerticalVisible,
                lpModeDesc->dwBpp, pTimingInfo->Refresh));

            return(TRUE);
        }
        else
        {
            // Could not support the mode.
            VideoDebugPrint((1,"Failure: GetTimingDac(): (%d, %d), %d bpp, %d Hz\n", 
                pTimingInfo->HorizontalVisible,pTimingInfo->VerticalVisible,
                lpModeDesc->dwBpp, pTimingInfo->Refresh));
            return(FALSE);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\vpelocal.h ===
/*
==============================================================================

    NVIDIA Corporation, (C) Copyright 
    1996,1997,1998,1999. All rights reserved.

    vpelocal.h

    Local definitions used by vpe and kernel mode video transport

    Jun 08, 1999

==============================================================================
*/

#define INITGUID     // Instantiate GUID_DxApi

#include "dderror.h"
#include "devioctl.h"
#include "miniport.h"
#include "ntddvdeo.h"
#include "video.h"

typedef unsigned long   DWORD;
// Commented out benign redefinition// typedef int              BOOL;

#include "nv.h"
#include "nv32.h"
#include "nvos.h"

#include "dxmini.h"

#ifndef NTSTATUS
typedef LONG NTSTATUS;
#endif
#define PDEVICE_OBJECT  PVOID
#include "i2cgpio.h"

//// VPE/miniport interface 
#include "vpemini.h"

/////// VPP interface
//#include "nvreg.h"
//#include "ddvpp.h"
///////

#ifdef _TIMER_TEST
typedef struct _NVP_INIT_OBJECT
{
    Nv03ChannelPio *pChannel;
    U032 uTimerLo;
    U032 uTimerHi;
} NVP_INIT_OBJECT;
#endif

#define NVP_CLASS04D_MAX_NOTIFIERS          9
#define NVP_CLASS039_MAX_NOTIFIERS          2
#define NVP_CLASS07A_MAX_NOTIFIERS          3

#define NVP_VPP_TIME_OUT    10000

///////
/// BUGBUG: taken from dvp.h !!! 
#define DDVP_AUTOFLIP                   0x00000001l
#define DDVP_INTERLEAVE                 0x00000008l
#define DDVP_SKIPEVENFIELDS             0x00000080l
#define DDVP_SKIPODDFIELDS              0x00000100l
#define DDVPCONNECT_INVERTPOLARITY      0x00000004l
#define DDVPCONNECT_INTERLACED          0x00000020l

#define NV_VFM_FORMAT_BOBFROMINTERLEAVE 0x08000000l

/// equivalent in nvReg.h
#define VPP_ODD            0x001
#define VPP_EVEN           0x002
#define VPP_BOB            0x004
#define VPP_INTERLEAVED    0x008
#define VPP_PRESCALE       0x400

#define NV_PRESCALE_OVERLAY_X           1
#define NV_PRESCALE_OVERLAY_Y           2
#define NV_PRESCALE_OVERLAY_FIELD       4

#define IS_FIELD(f) ((f & (VPP_INTERLEAVED | VPP_BOB)) && (f & (VPP_ODD | VPP_EVEN)))

#ifndef NV_IN_PROGRESS
#define NV_IN_PROGRESS (0x8000)
#endif

#define NV_OVERLAY_BYTE_ALIGNMENT_PAD   63L
#define NV_OVERLAY_BYTE_ALIGNMENT       64L


#ifdef  asmMergeCoords
#undef  asmMergeCoords
#endif
#define asmMergeCoords(LOWWORD, HIWORD) \
        (long)(((long)HIWORD << 16) | (unsigned short)LOWWORD)

///////////
// external services
//
extern void KeClearEvent(void *hEvent);
extern U032 RmAllocChannelDma(U032, U032, U032, U032, U032, U032, U032, U032 *);
extern U032 RmAllocObject(U032, U032, U032, U032);
extern U032 RmFree(U032, U032, U032);
extern U032 RmAllocContextDma(U032, U032, U032, U032, U032, U032, U032);
//extern U032 RmAllocEvent(NVOS10_PARAMETERS *);
extern U032 Nv01AllocEvent(NVOS10_PARAMETERS *);
extern U032 RmInterrupt(NVOS09_PARAMETERS *);
extern NTSTATUS miniI2COpen (PDEVICE_OBJECT pDev, ULONG acquire, PI2CControl pI2CCtrl);
extern NTSTATUS miniI2CAccess (PDEVICE_OBJECT pDev, PI2CControl pI2CCtrl);
//#define _MEASURE_TIMING
#ifdef _MEASURE_TIMING
extern int osGetCurrentTime(U032 *year,U032 *month,U032 *day,U032 *hour,U032 *min,U032 *sec,U032 *msec);
#endif

#ifndef NvGetFreeCount
#if defined NV10 || defined NV4
#define NvGetFreeCount(NN, CH)\
         (NN)->subchannel[CH].control.Free
#else   /* !(NV10 || NV4) */
#define NvGetFreeCount(NN, CH)\
         (NN)->subchannel[CH].control.free
#endif  /* !(NV10 || NV4) */
#endif

//////////
// DMA channel macros
//
#define NVP_JUMP(ADDR)      (0x20000000 | (ADDR))
#define NVP_DECODER_SUBCHANNEL  0
#define NVP_M2M_SUBCHANNEL      1
#define NVP_DMAPUSH_WRITE1(SUBCH, METHOD_OFFSET, METHOD_VALUE)                          \
{\
    pVPEContext->nvDmaFifo[nvDmaCount++] = ((1 <<18) | ((SUBCH)<<13) | (METHOD_OFFSET)); \
    pVPEContext->nvDmaFifo[nvDmaCount++] = METHOD_VALUE;                                    \
}
// assuming the FIFO is at least twice (2x + 1) the size of NEEDED_DWORDS
#define NVP_DMAPUSH_CHECK_FREE_COUNT(NEEDED_DWORDS)     \
{   \
    if ((nvDmaCount + (NEEDED_DWORDS)) >= (pVPEContext->DmaPushBufTotalSize >> 2))  \
    {   \
        pVPEContext->nvDmaFifo[nvDmaCount] = 0x20000000;    \
        nvDmaCount = 0; \
        VideoDebugPrint((0,"VPEMINI: DMA wrap around...\n"));   \
    }   \
}

////////////
// local functions prototypes
//
void VideoField0Notify(PVOID pHwDeviceExtension);
void VideoField1Notify(PVOID pHwDeviceExtension);
void VBIField0Notify(PVOID pHwDeviceExtension);
void VBIField1Notify(PVOID pHwDeviceExtension);
void NVPProgVideoField(PNVP_CONTEXT pVPEContext, PNVP_SURFACE_INFO pSurface, int nFieldId, U032 dwSurfPitch, U032 dwInterleaveOffset, BOOL bGrab);
void NVPProgVBIField(PNVP_CONTEXT pVPEContext, PNVP_SURFACE_INFO pSurface, int nFieldId);
VP_STATUS NVPProcessState(PHW_DEVICE_EXTENSION pHwDevExt, int nFieldId, BOOL bVBIField);
VP_STATUS NVPScheduleOverlayFlip(PNVP_CONTEXT pVPEContext, PNVP_SURFACE_INFO pSurface, int  nImageId, U032 dwSrcPitch, U032 dwMoveDownOffset);
U032 NVPScaleDown(PNVP_CONTEXT pVPEContext, PNVP_OVERLAY pOvr, int nFieldId);
VP_STATUS DoProgressive(PNVP_CONTEXT pVPEContext, int nFieldId);
VP_STATUS DoWeave(PNVP_CONTEXT pVPEContext, int nFieldId);
VP_STATUS DoBob(PNVP_CONTEXT pVPEContext, int nFieldId);
VP_STATUS DoBobFromInterleaved(PNVP_CONTEXT pVPEContext, int nFieldId);
BOOL NVPGetSurface( PNVP_CONTEXT pVPEContext,U032 dwSurfOffset, PNVP_SURFACE_INFO *pSurface);
void NVPTransferNotify(PVOID pHwDevExtension);
DWORD NVPCheckTransferStatus(PHW_DEVICE_EXTENSION pHwDevExt);
DWORD NVPCancelTransfer(PNVP_CONTEXT pVPEContext, PDDTRANSFERININFO pInInfo);
DWORD NVPRemoveTransfer(PNVP_CONTEXT pVPEContext, int nTransferIdx);
DWORD NVPAddTransfer(PNVP_CONTEXT pVPEContext, PDDTRANSFERININFO pInInfo, BOOL bIsOddField);
DWORD NVPGetTransferStatus(PVOID pContext, PVOID pNotUsed, PDDGETTRANSFEROUTINFO pOutInfo);
DWORD NVPCheckForLaunch(PNVP_CONTEXT pVPEContext, PNVP_SURFACE_INFO pSurface);
DWORD NVPRecreateContext(PNVP_CONTEXT pVPEContext, PMDL pDestMDL);
DWORD NVPTransfer(PVOID pContext, PDDTRANSFERININFO pInInfo, PDDTRANSFEROUTINFO pOutInfo);
PVOID GetHwInfo(PVOID HwDevExt);
BOOL NVPPrescaleAndFlip(PNVP_CONTEXT pVPEContext, PNVP_OVERLAY pOverlayInfo, DWORD dwOffset, DWORD dwPitch, DWORD dwIndex, DWORD dwFlags);
VP_STATUS NVPFlipVideoPort(PHW_DEVICE_EXTENSION pHwDevExt, NVP_CMD_OBJECT *pCmdObj);

/////////////////
// prototypes
//
DWORD GetIrqInfo(
    PVOID HwDeviceExtension,
    PVOID lpInput,
    PDDGETIRQINFO GetIrqInfo);

VP_STATUS NVQueryInterface(
    PVOID HwDeviceExtension,
    PQUERY_INTERFACE QueryInterface);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\display\winnt4\miniport\nv_mini\vpemini.c ===
//***************************************************************************
//  Module Name:
//
//      vpemini.c
//
//  Abstract:
//
//      This module contains the miniport parts of the DXAPI "kernel-mode
//      VPE" interface for the .
//
//      The DirectDraw Video Port Extensions (VPE) are the services that
//      control hardware videoports, where video data is streamed into
//      off-screen memory from an external device such as a TV tuner or
//      MPEG decoder, and then displayed on the screen by a video overlay.
//
//      To support VPE, you'll need the following:
//
//          1. A 2-D driver with DirectDraw overlay support;
//          2. A video input device that interfaces with the videoport;
//          3. A bunch of VPE code in the display driver;
//          4. A bunch of VPE code here in the miniport.
//
//      The miniport code here comprises part of the DXAPI "kernel-mode
//      VPE" interface that can be called by other WDM drivers, such as
//      an MPEG driver.
//
// IMPORTANT NOTE ABOUT HARDWARE REQUIREMENTS:
//
//      Almost all of these miniport "kernel-mode VPE" routines may be
//      called asynchronously to what the display driver is currently
//      doing.  For example, a thread may be in the display driver in the
//      middle of programming an accelerated Blt at the exact moment that
//      the miniport gets called to do a videoport flip call.  Consequently,
//      your hardware MUST be able to handle these commands at any time
//      regardless of the state of the display driver.  So this means:
//
//          1. Your hardware has to be able to allow the programming of any
//             "kernel-mode VPE" command even while Blts or direct frame
//             buffer accesses or DMAs or whatever are occuring, without
//             hanging or incorrect drawing.
//
//          2. The registers used to program any of the "kernel-mode VPE"
//             services must be disjoint and separate from those used by
//             the display driver.  If you must program an indexed register
//             that is also used by the display driver (such as 0x3d4/0x3d5),
//             *YOU ARE PROBABLY TOAST*.  Both a thread in the display driver
//             and a thread calling these miniport services are preemptible,
//             meaning that even if you save and restore the index register,
//             there's no guarantee that the other thread won't wake up in
//             the middle and try to use the same (now incorrectly set)
//             register.
//
//      If your hardware does not guarantee both of the above, you CANNOT
//      support the "kernel-mode VPE" interface!  Go yell at your hardware
//      designers and get them to fix the hardware.  If both of the above
//      are not guaranteed, it's inevitable that your customers will randomly
//      hit system hangs and crashes while using VPE.  Your customers will
//      not be happy!
//
//      Also note that the likelihood of hitting a problem is significantly
//      increased when running on a multiple-processor machine.  Consequently,
//      you should try to test VPE on an MP machine while applications (such
//      as Winstone) are running in the background.
//
//      (Okay, okay, so I exaggerated a bit about pointer number 2.  You can
//      in fact use shared indexed registers in these VPE routines if you do
//      one of the following:
//
//          1. Disable VPE on multiple-processor machines.  (As of the time
//             of this writing, we haven't yet implemented a VideoPort or
//             Eng function that you can call to determine whether you're
//             running on a UP or MP machine, otherwise I would tell you
//             the name of the function to call.  But by the time you read
//             this, it will probably exist -- so have a look through the
//             VideoPort and Eng calls...)
//
//             You'll also have to save and restore the index register when
//             you're done.  Because a thread that calls a miniport function
//             is at raised IRQL, it may interrupt a thread in the display
//             driver at any point, but on a UP machine it's guaranteed that
//             the display driver thread will not interrupt the miniport
//             thread.
//
//          2. Use the CRTC register only in the DxEnableIrq routine --
//             DirectDraw automatically synchronizes with the display driver
//             before calling DxEnableIrq (this is not true for any other
//             Dx miniport calls).
//
// NOTE:
//
//      Most "kernel-mode VPE" routines can be called at raised IRQL, meaning
//      that they MUST be non-paged, and cannot call any pageable functions.
//
//  Environment:
//
//      Kernel mode
//
//  Copyright (c) 1997 Microsoft Corporation
//
//***************************************************************************

#ifdef NVPE

// Temporary fix for Compile error...ask!
#define NvGetFreeCount(NN, CH)\
                 (NN)->subchannel[CH].control.Free

#include "vpelocal.h"

//#define _NVP_DTRACE

#ifdef _NVP_DTRACE
#define DEFINE_GLOBALS
#include "dtrace.h"
#endif


////////// globals
BOOL g_bFlip = FALSE;

extern void KeClearEvent(void *hEvent);


//
// Mark those routines that we can as pageable.  Remember that most
// "kernel-mode VPE" routines can be called at raised IRQL, which means
// that they must be kept non-paged.
//
// Note that these are the only two VPE miniport routines which may be
// pageable:
//

#if defined(ALLOC_PRAGMA)
#pragma alloc_text(PAGE,NVQueryInterface)
#pragma alloc_text(PAGE,GetIrqInfo)
#endif

// !!! Not hooking Lock is success, but not hooking SetPattern is failure?
// !!! Should dwFlags be ANDed or EQUALed?  (SkipNextField)
// !!! Should we mark the interrupt as unsharable?


/*++

Routine Description:

    On NT, the miniport always has to "manage the IRQ" (to borrow from the
    Win95 terminology).  Consequently, this routine simply tells DirectDraw
    what interrupts we support.

    It's actually pretty easy to enable interrupts, in part because you
    don't have to tell the system what interrupt vector you're using, as
    PNP already knows that.  However, you *do* have to check whether PNP
    successfully assigned you an interrupt vector, before you tell DirectDraw
    that you support interrupts.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetIrqInfo - Function parameters.

Return Value:

    DX_OK if successful.

--*/

DWORD GetIrqInfo(
    PVOID HwDeviceExtension,
    PVOID lpInput,
    PDDGETIRQINFO GetIrqInfo)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    DWORD status = DXERR_UNSUPPORTED;

    //
    // Sometimes, the motherboard BIOS or PNP may conspire to refuse to
    // allocate an interrupt to us.  So before we tell DirectDraw that
    // we support interrupts, we must first check if we've actually been
    // assigned one!
    //

//     if ((hwDeviceExtension->BusInterruptLevel != 0) ||
//        (hwDeviceExtension->BusInterruptVector != 0)) 
	{

        GetIrqInfo->dwFlags = IRQINFO_HANDLED;

        status = DX_OK;
	}

    return status;
}

/*++

Routine Description:

    This routine is the interrupt service routine for the kernel video
    driver.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's adapter information.

Return Value:

    TRUE if the interrupt is serviced; FALSE if it wasn't ours (this is done
    to support chained interrupts).

--*/

BOOLEAN Interrupt(PVOID HwDeviceExtension)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    // add your IRQ handling code here
	return FALSE;
}

/*++

Routine Description:

    This function notifies the miniport when it should enable or disable
    interrupts for VPE.  If an IRQ is not specified in this call, it
    should be disabled.

    On NT, since miniports always "manage the IRQ", we must call DirectDraw's
    IRQCallback routine from our HwInterrupt routine to notify DirectDraw
    whenever an interrupt occurs.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    EnableIrqInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD EnableIrq(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    PDDENABLEIRQINFO EnableIrqInfo,
    PVOID lpOutput)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    //
    // First make sure we stash IRQCallback in our device extension before
    // enabling interrupts for the first time, otherwise we may call a NULL
    // pointer from our HwInterrupt routine!
    //
    // (Note that DirectDraw will give us a valid IRQCallback and lpIRQData
    // even when disabling interrupts, which means we won't crash if an
    // interrupt is taken between this point and the actual disabling of the
    // interrupt.)
    //

    hwDeviceExtension->IRQCallback = EnableIrqInfo->IRQCallback;
    hwDeviceExtension->pIRQData = EnableIrqInfo->lpIRQData;
	hwDeviceExtension->dwIRQSources = EnableIrqInfo->dwIRQSources;

    //
    // Clear any existing interrupts, turn off all interrupts by default,
    // and enable the new requested interrupts.
    //
    // NOTE: Be very careful if your driver uses interrupts for purposes
    //       other than VPE.  For example, if your display driver uses DMA,
    //       you probably won't want to clear the DMA interrupt flag here!
    //

    // Now enable the master interrupt switch.  Again, be careful if your
    // display driver uses interrupt for purposes other than VPE -- you
    // probably won't want to disable all video interrupts here like we
    // do!
    //
    // Note: DxEnableIrq is the only routine that may access the CRTC
    //       registers!  For more details, read the large note at the
    //       top of this file.
    //

    // If the vsync interrupt has been disabled, but a deferred overlay
    // offset is pending, flush it now.
    //

    return DX_OK;
}

/*++

Routine Description:

    This function flips the video port to the target surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FlipVideoPortInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD FlipVideoPort(
    PVOID HwDeviceExtension,
    PDDFLIPVIDEOPORTINFO FlipVideoPortInfo,
    PVOID lpOutput)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

    ULONG offset;

	VideoDebugPrint((0,"VPEMINI: FlipVideoPort()\n"));

    //
    // Get offset (from framebuffer) and add offset from surface:
    //

    offset = FlipVideoPortInfo->lpTargetSurface->dwSurfaceOffset
           + FlipVideoPortInfo->lpVideoPortData->dwOriginOffset;

    // flip the actual hw surface here

    return DX_OK;
}

/*++

Routine Description:

    This function flips the overlay to the target surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    FlipOverlayInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD FlipOverlay(
    PVOID HwDeviceExtension,
    PDDFLIPOVERLAYINFO pFlipOverlayInfo,
    PVOID lpOutput)
{
#if 0
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)HwDeviceExtension;
	DDSURFACEDATA* pCurSurf =	(DDSURFACEDATA*) pFlipOverlayInfo->lpCurrentSurface;
	DDSURFACEDATA* pTargSurf =	(DDSURFACEDATA*) pFlipOverlayInfo->lpTargetSurface;
	PNVP_CONTEXT pVPEContext;
	U032 dwFlags;
	NVP_OVERLAY pOvInfo;

	VideoDebugPrint((1,"VPEMINI: FlipOverlay()\n"));

	// get a pointer to the appropriate VPE context (assume VPE 0)
	pVPEContext = &(pHwDevExt->avpContexts[0]);

	pOvInfo = &(pVPEContext->nvpOverlay);

    // VPP flags
	dwFlags = VPP_PRESCALE;

	if (pTargSurf->dwOverlayFlags & DDOVER_INTERLEAVED)
	   dwFlags |= VPP_INTERLEAVED;

	if (pTargSurf->dwOverlayFlags & DDOVER_BOB)
	   dwFlags |= VPP_BOB;

    if (pFlipOverlayInfo->dwFlags & DDFLIP_ODD)
	   dwFlags |= VPP_ODD;
	else if (pFlipOverlayInfo->dwFlags & DDFLIP_EVEN)
	   dwFlags |= VPP_EVEN;


    // if not initialized 
/*
    NVP_CMD_OBJECT cmdObj;
	cmdObj.dwPortId = 0;
	cmdObj.dwChipId = pHwDevExt->ulChipID;
	cmdObj.dwDeviceId = ppdev->hDriver;
	cmdObj.hClient = ppdev->hClient;

    NVPInitialize(pHwDevExt, &cmdObj);
*/
    // initialize index 
    if (pVPEContext->nvpOverlay.dwOverlayBufferIndex == NVP_UNDEF)
        pVPEContext->nvpOverlay.dwOverlayBufferIndex = 0;

    // flip overlay here !
	if (NVPPrescaleAndFlip(pVPEContext, pOvInfo, pTargSurf->dwOverlayOffset, pTargSurf->lPitch, 0, dwFlags))
	    return DX_OK;

    return DXERR_GENERIC;
#else
	return DX_OK;
#endif
}


/*++

Routine Description:

    This function is called when "bob" is used and a VPORT VSYNC occurs
    that does not cause a flip to occur (e.g., bobbing while interleaved).
    When bobbing, the overlay must adjust itself on every VSYNC, so this
    function notifies it of the VSYNCs that it doesn't already know about
    (e.g., VSYNCs that trigger a flip to occur).

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    BobNextFieldInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD BobNextField(
    PVOID HwDeviceExtension,
    PDDBOBNEXTFIELDINFO BobNextFieldInfo,
    PVOID lpOutput)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

	VideoDebugPrint((2,"VPEMINI: BobNextField()\n"));

    return DX_OK;
}

/*++

Routine Description:

    This function is called when the client wants to switch from bob to
    weave.  The overlay flags indicate which state to use.  This is only
    called for interleaved surfaces.

    Note that when this is called, the specified surface may not be
    displaying the overlay (due to a flip).  Instead of failing the call,
    change the bob/weave state for the overlay that would be used if the
    overlay was flipped again to the specified surface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    SetStateInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD SetState(
    PVOID HwDeviceExtension,
    PDDSETSTATEININFO SetStateInInfo,
    PDDSETSTATEOUTINFO SetStateOutInfo)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

	VideoDebugPrint((0,"VPEMINI: SetState()\n"));

    return DX_OK;
}


/*++

Routine Description:

    This function is called when the client wants to skip the next field,
    usually to undo a 3:2 pulldown but also for decreasing the frame
    rate.  The driver should not lose the VBI lines if dwVBIHeight contains
    a valid value.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    SkipNextFieldInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD SkipNextField(
    PVOID HwDeviceExtension,
    PDDSKIPNEXTFIELDINFO SkipNextFieldInfo,
    PVOID lpOutput)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;

	VideoDebugPrint((0,"VPEMINI: SkipNextField()\n"));

    return DX_OK;
}


/*++

Routine Description:

    This function returns the polarity of the current field being written
    to the specified video port.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetPolarityInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/

DWORD GetPolarity(
    PVOID HwDeviceExtension,
    PDDGETPOLARITYININFO pGetPolarityInInfo,
    PDDGETPOLARITYOUTINFO pGetPolarityOutInfo)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION) HwDeviceExtension;
	PNVP_CONTEXT pVPEContext;

	VideoDebugPrint((3,"VPEMINI: GetPolarity()\n"));

	// get a handle to current VPE context (BUGBUG: assume index 0 for now !)
	pVPEContext = &(pHwDevExt->avpContexts[0]);

	// check video first !
	if (pVPEContext->nNumVidSurf)
	{
		// TRUE for Even, FALSE for Odd
		if (pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx].dwFieldType == NVP_FIELD_ODD)
			pGetPolarityOutInfo->bPolarity = FALSE;
		else
			pGetPolarityOutInfo->bPolarity = TRUE;
	}
	// vbi polarity 
	else if (pVPEContext->nNumVBISurf)
	{
		if (pVPEContext->aVBISurfaceInfo[pVPEContext->nVBISurfIdx].dwFieldType == NVP_FIELD_ODD)
			pGetPolarityOutInfo->bPolarity = FALSE;
		else
			pGetPolarityOutInfo->bPolarity = TRUE;
	}
	else
		return DXERR_GENERIC;

    return DX_OK;
}

/*++

Routine Description:

    This function returns the current surface receiving data from the
    video port while autoflipping is taking place.  Only called when
    hardware autoflipping.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetCurrentAutoflipInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD GetCurrentAutoflip(
    PVOID HwDeviceExtension,
    PDDGETCURRENTAUTOFLIPININFO pGetCurrentAutoflipInInfo,
    PDDGETCURRENTAUTOFLIPOUTINFO pGetAutoFlipInfoOut)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)HwDeviceExtension;
	PNVP_CONTEXT pVPEContext;
	NvNotification *avpNotifiers;
	int nNotifyIdx;

	VideoDebugPrint((3,"VPEMINI: GetCurrentAutoflip()\n"));

	// get a handle to current VPE context (BUGBUG: assume index 0 for now !)
	pVPEContext = &(pHwDevExt->avpContexts[0]);
	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

	pGetAutoFlipInfoOut->dwSurfaceIndex = NVP_UNDEF;
	// check out video 
	if (pVPEContext->nNumVidSurf)
	{
		nNotifyIdx = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx].dwFieldType);
		// check progress status of current surface
		if (avpNotifiers[nNotifyIdx].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)
			pGetAutoFlipInfoOut->dwSurfaceIndex = (ULONG)(pVPEContext->nVidSurfIdx);
		else
			// assume it is the next surface then !
			pGetAutoFlipInfoOut->dwSurfaceIndex = (ULONG)(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx].nNextSurfaceIdx);
	}

	pGetAutoFlipInfoOut->dwVBISurfaceIndex = NVP_UNDEF;
	// check out vbi
	if (pVPEContext->nNumVBISurf)
	{
		nNotifyIdx = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(pVPEContext->aVBISurfaceInfo[pVPEContext->nVBISurfIdx].dwFieldType);
		// check progress status of current surface
		if (avpNotifiers[nNotifyIdx].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)
			pGetAutoFlipInfoOut->dwVBISurfaceIndex = (ULONG)(pVPEContext->nVBISurfIdx);
		else
			// assume it is the next surface then !
			pGetAutoFlipInfoOut->dwVBISurfaceIndex = (ULONG)(pVPEContext->aVBISurfaceInfo[pVPEContext->nVBISurfIdx].nNextSurfaceIdx);
	}

    return DX_OK;
}


/*++

Routine Description:

    This function returns the current surface receiving data from the
    video port while autoflipping is taking place.  Only called when
    hardware autoflipping.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    GetPreviousAutoflipInfo - Function parameters.

Return Value:

    DX_OK if successful.  ERROR_INVALID_FUNCTION if the requested
    combination cannot be supported.

--*/
DWORD GetPreviousAutoflip(
    PVOID HwDeviceExtension,
    PDDGETPREVIOUSAUTOFLIPININFO pGetAutoflipInInfo,
    PDDGETPREVIOUSAUTOFLIPOUTINFO pGetAutoFlipInfoOut)
{
    PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)HwDeviceExtension;
	PNVP_CONTEXT pVPEContext;
	NvNotification *avpNotifiers;
	int nNotifyIdx;

	VideoDebugPrint((3,"VPEMINI: GetPreviousAutoflip()\n"));

	// get a handle to current VPE context (BUGBUG: assume index 0 for now !)
	pVPEContext = &(pHwDevExt->avpContexts[0]);
	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

	pGetAutoFlipInfoOut->dwSurfaceIndex = NVP_UNDEF;
	// check out video 
	if (pVPEContext->nNumVidSurf)
	{
		nNotifyIdx = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx].dwFieldType);
		// check progress status of current surface
		if (avpNotifiers[nNotifyIdx].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)
			// if in progress, return index of previous surface
			pGetAutoFlipInfoOut->dwSurfaceIndex = (ULONG)((pVPEContext->nVidSurfIdx == 0) ? (pVPEContext->nNumVidSurf - 1): (pVPEContext->nVidSurfIdx - 1));
		else
			// assume this is the "previous"ly autoflipped surface then !
			pGetAutoFlipInfoOut->dwSurfaceIndex = (ULONG)(pVPEContext->nVidSurfIdx);
	}

	pGetAutoFlipInfoOut->dwVBISurfaceIndex = NVP_UNDEF;
	// check out vbi
	if (pVPEContext->nNumVBISurf)
	{
		nNotifyIdx = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(pVPEContext->aVBISurfaceInfo[pVPEContext->nVBISurfIdx].dwFieldType);
		// check progress status of current surface
		if (avpNotifiers[nNotifyIdx].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)
			// if in progress, return index of previous surface
			pGetAutoFlipInfoOut->dwVBISurfaceIndex = (ULONG)((pVPEContext->nVBISurfIdx == 0) ? (pVPEContext->nNumVBISurf - 1): (pVPEContext->nVBISurfIdx - 1));
		else
			// assume this is the "previous"ly autoflipped surface then !
			pGetAutoFlipInfoOut->dwVBISurfaceIndex = (ULONG)(pVPEContext->nVBISurfIdx);
	}

    return DX_OK;
}


/*++

Routine Description:

    Generic method for obtaining interfaces from the miniport.

    Among other things, it's used for exporting the DXAPI "kernel-mode
    VPE" interface.

Arguments:

    HwDeviceExtension - Pointer to the miniport driver's device extension.

    QueryInterface - Pointer to structure that describes the requested
        interface.

Return Value:

    DX_OK if successful.

--*/
VP_STATUS NVQueryInterface(
    PVOID HwDeviceExtension,
    PQUERY_INTERFACE QueryInterface)
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    VP_STATUS status;

    status = DXERR_UNSUPPORTED;

    if (IsEqualGUID(QueryInterface->InterfaceType, &GUID_DxApi)) 
    {
	    PDXAPI_INTERFACE DxApiInterface;
        DxApiInterface = (PDXAPI_INTERFACE) QueryInterface->Interface;

        //
        // We are queried here for our "kernel-mode VPE" support only after
        // the display driver has already enabled VPE.  Consequently, we let
        // the display driver control what chips VPE is enabled on -- we
        // don't have to do that here.
        //

        DxApiInterface->Size    = sizeof(DXAPI_INTERFACE);
        DxApiInterface->Version = DXAPI_HALVERSION;
        DxApiInterface->Context = hwDeviceExtension;

        DxApiInterface->DxGetIrqInfo          = GetIrqInfo;
        DxApiInterface->DxEnableIrq           = EnableIrq;
        DxApiInterface->DxSkipNextField       = SkipNextField;
        DxApiInterface->DxBobNextField        = BobNextField;
        DxApiInterface->DxSetState            = SetState;
        DxApiInterface->DxFlipOverlay         = FlipOverlay;
        DxApiInterface->DxFlipVideoPort       = FlipVideoPort;
        DxApiInterface->DxGetPolarity         = GetPolarity;
        DxApiInterface->DxGetCurrentAutoflip  = GetCurrentAutoflip;
        DxApiInterface->DxGetPreviousAutoflip = GetPreviousAutoflip;
		DxApiInterface->DxTransfer			  = NVPTransfer;
		DxApiInterface->DxGetTransferStatus	  = NVPGetTransferStatus;

        status = DX_OK;
    }
	// I2c Interface
	else if (IsEqualGUID(QueryInterface->InterfaceType, &GUID_I2C_INTERFACE))
	{
		I2CINTERFACE *pI2cInterface;
        pI2cInterface = (I2CINTERFACE *) QueryInterface->Interface;


		//pI2cInterface->_vddInterface;
    	pI2cInterface->i2cOpen = (I2COPEN) miniI2COpen;
    	pI2cInterface->i2cAccess = (I2CACCESS) miniI2CAccess;

        status = DX_OK;
	}

    return status;
}

/*
==============================================================================
	
	NVP3Initialize

	Description:	Initializes the NV video port. Creates channels and DMA
					contexts. Create Video and VBI objects.
					NV3 version uses PIO channel

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVP3Initialize(
	PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext;
	NvNotification *avpNotifiers;
	NVOS10_PARAMETERS evParam;
	int nFreeCount;
	U032 status;
	NVOS09_PARAMETERS ntfParam;
	Nv03ChannelPio *pNVPChannel = (Nv03ChannelPio *) (pCmdObj->pChannel);

//////////// HACK
	g_bFlip = FALSE;
///////////

	VideoDebugPrint((3,"VPEMINI: NVP3Initialize()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);
	// initialize context
	pVPEContext->pNVPChannel = (ULONG) pNVPChannel;	// keep a copy of the pio channel pointer
	pVPEContext->nvDmaFifo = NULL;
	pVPEContext->dwDeviceId = pCmdObj->dwDeviceId;
	pVPEContext->hClient = pCmdObj->hClient;
	pVPEContext->pOverlayChannel = pCmdObj->pOvrChannel;
	pVPEContext->dwOvrSubChannel = pCmdObj->dwOvrSubChannel;
	pVPEContext->dwOverlayObjectID = pCmdObj->dwOverlayObjectID;
	pVPEContext->dwScalerObjectID = pCmdObj->dwScalerObjectID;
	pVPEContext->dwDVDSubPicObjectID = pCmdObj->dwDVDObjectID;
    pVPEContext->dwDVDObjectCtxDma = pCmdObj->dwDVDObjectCtxDma;
	pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat = pCmdObj->pNvPioFlipOverlayNotifierFlat;
	pVPEContext->nNumVidSurf = 0;
	pVPEContext->nNumVBISurf = 0;
	pVPEContext->dwVPState = NVP_STATE_STOPPED;
	pVPEContext->dwVPConFlags = pCmdObj->dwVPTypeFlags;
	pVPEContext->dwVPFlags = 0; //pCmdObj->dwVPInfoFlags;
	pVPEContext->nCurTransferIdx = NVP_EOQ;
	pVPEContext->nLastTransferIdx = NVP_EOQ;
	pVPEContext->nRecentTransferIdx = NVP_EOQ;
	pVPEContext->nNumTransfer = 0;
	pVPEContext->bxfContextCreated = FALSE;
	pVPEContext->bxfContextFlushed = FALSE;
	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

	// alloc external decoder object
	if (RmAllocObject(
				pCmdObj->hClient,
				NVP_VPE_CHANNEL,
	            NVP_EXTERNAL_DECODER_OBJECT,
				NV03_EXTERNAL_VIDEO_DECODER) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate External Decoder Object 0x%X\n", NVP_EXTERNAL_DECODER_OBJECT));
		return FALSE;
	}

	// allocate transfer object (used for vbi and video capture)
	if (RmAllocObject(
				pCmdObj->hClient,
				NVP_VPE_CHANNEL,
	            NVP_M2M_OBJECT,
				NV03_MEMORY_TO_MEMORY_FORMAT) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate Mem to mem transfer Object 0x%X\n", NVP_M2M_OBJECT));
		return FALSE;
	}

    // allocate the transfer FROM context
    if (RmAllocContextDma(
						pCmdObj->hClient,
                        NVP_M2M_FROM_CONTEXT,
                        NV01_CONTEXT_DMA_FROM_MEMORY,       //NV_CONTEXT_DMA_FROM_MEMORY ?
                        0, // (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
						0, // selector
                        (U032)pCmdObj->pFrameBuffer,
                        pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate notifiers for M2M transfer Object\n"));
        return FALSE;
	}

    // allocate a notify context for transfer object
    if (RmAllocContextDma(
    					pCmdObj->hClient,
                        NVP_M2M_NOTIFIER,
                        NV01_CONTEXT_DMA_FROM_MEMORY,
                        0, 	//(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0,  // selector
                        (U032)(pVPEContext->axfNotifiers),
                        (sizeof( NvNotification)*NVP_CLASS039_MAX_NOTIFIERS  - 1)) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate notifiers for M2M transfer Object\n"));
        return FALSE;
    }
	
	// allocate a notify context for external decoder
	if (RmAllocContextDma(
					pCmdObj->hClient,
	         		NVP_EXTERNAL_DECODER_NOTIFIER,
	         		NV01_CONTEXT_DMA_FROM_MEMORY,
	         		0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
					0, // selector
	         		(U032)(pVPEContext->avpNotifiers),
	         		(sizeof(NvNotification)*NVP_CLASS04D_MAX_NOTIFIERS - 1)) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate notifiers for external decoder object\n"));
		return FALSE;
	}

	// context DMA for video field0
	if (RmAllocContextDma(
				pCmdObj->hClient,
				NVP_VIDEO_FIELD0_BUFFER_CONTEXT,
				NV01_CONTEXT_DMA_FROM_MEMORY,
				0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
				0, // selector
				(U032) (pCmdObj->pFrameBuffer),
				pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate context DMA for video field0\n"));
		return FALSE;
	}

	// context DMA for video field1	
	if (RmAllocContextDma(
				pCmdObj->hClient,
				NVP_VIDEO_FIELD1_BUFFER_CONTEXT,
				NV01_CONTEXT_DMA_FROM_MEMORY,
				0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
				0, // selector
				(U032) (pCmdObj->pFrameBuffer),
	            pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate context DMA for video field1\n"));
		return FALSE;
	}
	
	// context DMA for video field0
	if (RmAllocContextDma(
				pCmdObj->hClient,
				NVP_VBI_FIELD0_BUFFER_CONTEXT,
				NV01_CONTEXT_DMA_FROM_MEMORY, //NV01_CONTEXT_DMA,
				0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
				0, // selector
				(U032) (pCmdObj->pFrameBuffer),
				pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate context DMA for VBI field0\n"));
		return FALSE;
	}

	// context DMA for video field1
	if (RmAllocContextDma(
				pCmdObj->hClient,
				NVP_VBI_FIELD1_BUFFER_CONTEXT,
				NV01_CONTEXT_DMA_FROM_MEMORY, //NV01_CONTEXT_DMA,
				0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
				0, // selector
				(U032) (pCmdObj->pFrameBuffer),
	            pCmdObj->dwFBLen - 1) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate context DMA for VBI field1\n"));
		return FALSE;
	}

	//CHECK_FREE_COUNT(pNVPChannel,10*5);
	nFreeCount = NvGetFreeCount(pNVPChannel, 0);
	while (nFreeCount < 13*4) 
	{
		//RmInterrupt(&ntfParam);
		nFreeCount = NvGetFreeCount(pNVPChannel, 0);
	}			
	pVPEContext->nFreeCount = nFreeCount - (13*4);

	avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

	// transfer object setup
    pNVPChannel->subchannel[5].SetObject  = NVP_M2M_OBJECT;
    pNVPChannel->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaNotifies = NVP_M2M_NOTIFIER;
    pNVPChannel->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferIn = NVP_M2M_FROM_CONTEXT;
	
	// make sure decoder object is in the channel....
	pNVPChannel->subchannel[0].SetObject = NVP_EXTERNAL_DECODER_OBJECT;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaNotifies = NVP_EXTERNAL_DECODER_NOTIFIER;

	// plug in our buffer contexts
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaImage[0] = NVP_VIDEO_FIELD0_BUFFER_CONTEXT;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaImage[1] = NVP_VIDEO_FIELD1_BUFFER_CONTEXT;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaVbi[0]   = NVP_VBI_FIELD0_BUFFER_CONTEXT;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetContextDmaVbi[1]   = NVP_VBI_FIELD1_BUFFER_CONTEXT;
	
	// NB: we don't want to launch any captures at this point

	// setup the transfer callback
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_M2M_OBJECT;
  	evParam.hObjectNew = NVP_M2M_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV039_NOTIFIERS_BUFFER_NOTIFY;
  	evParam.hEvent.low = (ULONG) NVPTransferNotify;
	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for m2m transfer 0\n"));
		return FALSE;
	}

	// setup fields callbacks
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
  	evParam.hObjectNew = NVP_VIDEO_FIELD0_BUFFER_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0);
  	evParam.hEvent.low = (ULONG) VideoField0Notify;

	// video field0
	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for video field 0\n"));
		return FALSE;
	}

	// video field1
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
  	evParam.hObjectNew = NVP_VIDEO_FIELD1_BUFFER_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1);
  	evParam.hEvent.low = (ULONG) VideoField1Notify;

	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for video field 1\n"));
		return FALSE;
	}

	// vbi field0
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
  	evParam.hObjectNew = NVP_VBI_FIELD0_BUFFER_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0);
  	evParam.hEvent.low = (ULONG) VBIField0Notify;

	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for VBI field 0\n"));
		return FALSE;
	}
			
	// vbi field1
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
  	evParam.hObjectNew = NVP_VBI_FIELD1_BUFFER_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1);
  	evParam.hEvent.low = (ULONG) VBIField1Notify;

	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for VBI field 1\n"));
		return FALSE;
	}

	return NO_ERROR;
}


/*
==============================================================================
	
	NVPInitialize

	Description:	Initializes the NV video port. Creates channels and DMA
					contexts. Create Video and VBI objects.
					DMA push buffer version (NV ver >= 0x04)

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPInitialize(
	PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext;
	NvNotification *avpNotifiers;
    NvNotification *aovNotifiers;
	U032 dwOvObj;
	NVOS10_PARAMETERS evParam;
	Nv4ControlDma *pDmaChannel;
	U032 nvDmaCount;
	U032 status;

	// NV3 specific code
	if (NVP_GET_CHIP_VER(pCmdObj->dwChipId) <= NVP_CHIP_VER_03)
		return NVP3Initialize(pHwDevExt, pCmdObj);

//////////// HACK
	g_bFlip = FALSE;
///////////

	VideoDebugPrint((3,"VPEMINI: NVPInitialize()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);
	// initialize context
	//pVPEContext->pNVPChannel = (ULONG) 0;
	pVPEContext->dwChipId = pCmdObj->dwChipId;
	pVPEContext->dwDeviceId = pCmdObj->dwDeviceId;
	pVPEContext->hClient = pCmdObj->hClient;
	pVPEContext->pOverlayChannel = pCmdObj->pOvrChannel;
	pVPEContext->dwOvrSubChannel = pCmdObj->dwOvrSubChannel;
	pVPEContext->dwOverlayObjectID = pCmdObj->dwOverlayObjectID;
	pVPEContext->dwScalerObjectID = pCmdObj->dwScalerObjectID;
	pVPEContext->dwDVDSubPicObjectID = pCmdObj->dwDVDObjectID;
    pVPEContext->dwDVDObjectCtxDma = pCmdObj->dwDVDObjectCtxDma;
	pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat = pCmdObj->pNvPioFlipOverlayNotifierFlat;
	pVPEContext->nNumVidSurf = 0;
	pVPEContext->nNumVBISurf = 0;
	pVPEContext->dwVPState = NVP_STATE_STOPPED;
	pVPEContext->dwVPConFlags = pCmdObj->dwVPTypeFlags;
	pVPEContext->dwVPFlags = 0; //pCmdObj->dwVPInfoFlags;
	pVPEContext->nCurTransferIdx = NVP_EOQ;
	pVPEContext->nLastTransferIdx = NVP_EOQ;
	pVPEContext->nRecentTransferIdx = NVP_EOQ;
	pVPEContext->nNumTransfer = 0;
	pVPEContext->bxfContextCreated = FALSE;
	pVPEContext->bxfContextFlushed = FALSE;
	pVPEContext->hVPSyncEvent = pCmdObj->hVPSyncEvent;

	pVPEContext->nvDmaFifo = NULL;
	pVPEContext->DmaPushBufTotalSize = 32*1024*4;	// 32k DWORDs
	if (VideoPortAllocateBuffer((PVOID)pHwDevExt, pVPEContext->DmaPushBufTotalSize, (PVOID *)&(pVPEContext->nvDmaFifo)) != NO_ERROR)
		return FALSE;

    if (RmAllocContextDma(  pCmdObj->hClient,
                            NVP_DMA_FROM_MEMORY_PUSHBUF,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_READ_ONLY,
							0, // selector
                            (U032)(pVPEContext->nvDmaFifo),
                            pVPEContext->DmaPushBufTotalSize - 1) != 0)
    {
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate Context Dma for PushBuffer Object\n"));
		return FALSE;
    }

    // Allocate the DMA push buffer ERROR notifier
    if (RmAllocContextDma(  pCmdObj->hClient,
                            NVP_DMA_PUSHBUF_ERROR_NOTIFIER,
                            NV01_CONTEXT_DMA,
                            NVOS03_FLAGS_ACCESS_WRITE_ONLY,
							0, // selector
                            (U032)(&(pVPEContext->DmaPushBufErrNotifier[0])),
                            sizeof(NvNotification) - 1) != 0)
    {
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate PushBuffer notifier\n"));
		return FALSE;
    }

	// allocate DMA channel here !
    if (RmAllocChannelDma(  pCmdObj->hClient,
                            pCmdObj->dwDeviceId,
                            NVP_VPE_CHANNEL,
                            NV4_CHANNEL_DMA,
                            NVP_DMA_PUSHBUF_ERROR_NOTIFIER,
                            NVP_DMA_FROM_MEMORY_PUSHBUF,
                            0,
                            (PVOID)&(pVPEContext->pDmaChannel)) != 0)
    {
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate Dma Channel 0x%X\n", NVP_VPE_CHANNEL));
		return FALSE;
    }

	// alloc external decoder object
	if (RmAllocObject(
				pCmdObj->hClient,
				NVP_VPE_CHANNEL,
	            NVP_EXTERNAL_DECODER_OBJECT,
				NV03_EXTERNAL_VIDEO_DECODER) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate External Decoder Object 0x%X\n", NVP_EXTERNAL_DECODER_OBJECT));
		return FALSE;
	}

	// allocate transfer object (used for vbi and video capture)
	if (RmAllocObject(
				pCmdObj->hClient,
				NVP_VPE_CHANNEL,
	            NVP_M2M_OBJECT,
				NV03_MEMORY_TO_MEMORY_FORMAT) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate Mem to mem transfer Object 0x%X\n", NVP_M2M_OBJECT));
		return FALSE;
	}

    dwOvObj = (pCmdObj->dwChipId < NV_DEVICE_VERSION_10) ? NV04_VIDEO_OVERLAY : NV10_VIDEO_OVERLAY;

	// alloc overlay object 
	if (RmAllocObject(
				pCmdObj->hClient,
				NVP_VPE_CHANNEL,
	            NVP_OVERLAY_OBJECT,
				dwOvObj) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate Overlay Object 0x%X\n", NVP_OVERLAY_OBJECT));
		return FALSE;
	}


	// alloc DVD subpicture object 
	if (RmAllocObject(
				pCmdObj->hClient,
				NVP_VPE_CHANNEL,
	            NVP_DVD_SUBPICTURE_OBJECT,
				NV4_DVD_SUBPICTURE) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate DVD subpicture Object 0x%X\n", NVP_DVD_SUBPICTURE_OBJECT));
		return FALSE;
	}

    // allocate the transfer FROM context
    if (RmAllocContextDma(
						pCmdObj->hClient,
                        NVP_M2M_FROM_CONTEXT,
                        NV01_CONTEXT_DMA_FROM_MEMORY,       //NV_CONTEXT_DMA_FROM_MEMORY ?
                        0, // (ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
						0, // selector
                        (U032)pCmdObj->pFrameBuffer,
                        pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate notifiers for M2M transfer Object\n"));
        return FALSE;
	}

    // allocate a notify context for transfer object
    if (RmAllocContextDma(
    					pCmdObj->hClient,
                        NVP_M2M_NOTIFIER,
                        NV01_CONTEXT_DMA_FROM_MEMORY,
                        0, 	//(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0,  // selector
                        (U032)(pVPEContext->axfNotifiers),
                        (sizeof( NvNotification)*NVP_CLASS039_MAX_NOTIFIERS  - 1)) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate notifiers for M2M transfer Object\n"));
        return FALSE;
    }
	
	// allocate a notify context for external decoder
	if (RmAllocContextDma(
					pCmdObj->hClient,
	         		NVP_EXTERNAL_DECODER_NOTIFIER,
	         		NV01_CONTEXT_DMA_FROM_MEMORY,
	         		0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
					0, // selector
	         		(U032)(pVPEContext->avpNotifiers),
	         		(sizeof(NvNotification)*NVP_CLASS04D_MAX_NOTIFIERS - 1)) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate notifiers for external decoder object\n"));
		return FALSE;
	}

	// context DMA for video field0
	if (RmAllocContextDma(
				pCmdObj->hClient,
				NVP_VIDEO_FIELD0_BUFFER_CONTEXT,
				NV01_CONTEXT_DMA_FROM_MEMORY,
				0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
				0, // selector
				(U032) (pCmdObj->pFrameBuffer),
				pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate context DMA for video field0\n"));
		return FALSE;
	}

	// context DMA for video field1	
	if (RmAllocContextDma(
				pCmdObj->hClient,
				NVP_VIDEO_FIELD1_BUFFER_CONTEXT,
				NV01_CONTEXT_DMA_FROM_MEMORY,
				0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
				0, // selector
				(U032) (pCmdObj->pFrameBuffer),
	            pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate context DMA for video field1\n"));
		return FALSE;
	}
	
	// context DMA for video field0
	if (RmAllocContextDma(
				pCmdObj->hClient,
				NVP_VBI_FIELD0_BUFFER_CONTEXT,
				NV01_CONTEXT_DMA_FROM_MEMORY, //NV01_CONTEXT_DMA,
				0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
				0, // selector
				(U032) (pCmdObj->pFrameBuffer),
				pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate context DMA for VBI field0\n"));
		return FALSE;
	}

	// context DMA for video field1
	if (RmAllocContextDma(
				pCmdObj->hClient,
				NVP_VBI_FIELD1_BUFFER_CONTEXT,
				NV01_CONTEXT_DMA_FROM_MEMORY, //NV01_CONTEXT_DMA,
				0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
				0, // selector
				(U032) (pCmdObj->pFrameBuffer),
	            pCmdObj->dwFBLen - 1) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate context DMA for VBI field1\n"));
		return FALSE;
	}

    // allocate a context for overlay object
    if (RmAllocContextDma(
    					pCmdObj->hClient,
                        NVP_OVERLAY_BUFFER_CONTEXT,
                        NV01_CONTEXT_DMA,
                        0, 	//(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0,  // selector
                        (U032) (pCmdObj->pFrameBuffer),
                        pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate dma context for overlay buffer0\n"));
        return FALSE;
    }

    // allocate a context for DVD subpicture object
    if (RmAllocContextDma(
    					pCmdObj->hClient,
                        NVP_DVD_SUBPICTURE_CONTEXT,
                        NV01_CONTEXT_DMA,
                        0, 	//(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
                        0,  // selector
                        (U032) (pCmdObj->pFrameBuffer),
                        pCmdObj->dwFBLen - 1) != 0)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate dma context for DVD subpicture Object\n"));
        return FALSE;
    }

	// allocate a notify context for overlay notifiers
	if (RmAllocContextDma(
					pCmdObj->hClient,
	         		NVP_OVERLAY_NOTIFIER,
	         		NV01_CONTEXT_DMA_FROM_MEMORY,
	         		0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
					0, // selector
	         		(U032)(pVPEContext->aovNotifiers),
	         		(sizeof(NvNotification)*NVP_CLASS07A_MAX_NOTIFIERS - 1)) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate notifiers for external decoder object\n"));
		return FALSE;
	}


    // reset media port notifiers
	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);
	avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
    // reset overlay notifiers
    aovNotifiers = (NvNotification *) (pVPEContext->aovNotifiers);
    aovNotifiers[NV07A_NOTIFIERS_SET_OVERLAY(0)].status = 0;
    aovNotifiers[NV07A_NOTIFIERS_SET_OVERLAY(1)].status = 0;

	pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat = (U032) (pVPEContext->aovNotifiers);

	// init Dma channel pointers
	pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    pDmaChannel->Put = 0;
    nvDmaCount = 0;

	// set m2m object context
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_OBJECT, NVP_M2M_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_CONTEXT_DMA_NOTIFIES, NVP_M2M_NOTIFIER);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_CONTEXT_DMA_BUFFER_IN, NVP_M2M_FROM_CONTEXT);

	// make sure decoder object is in the channel....
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_OBJECT , NVP_EXTERNAL_DECODER_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_NOTIFIES, NVP_EXTERNAL_DECODER_NOTIFIER);
	// plug in our buffer contexts
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_IMAGE(0), NVP_VIDEO_FIELD0_BUFFER_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_IMAGE(1), NVP_VIDEO_FIELD1_BUFFER_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_VBI(0), NVP_VBI_FIELD0_BUFFER_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_CONTEXT_DMA_VBI(1), NVP_VBI_FIELD1_BUFFER_CONTEXT);

    // set overlay contexts
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OBJECT, NVP_OVERLAY_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_CONTEXT_DMA_NOTIFIES, NVP_OVERLAY_NOTIFIER);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_CONTEXT_DMA_OVERLAY(0), NVP_OVERLAY_BUFFER_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_CONTEXT_DMA_OVERLAY(1), NVP_OVERLAY_BUFFER_CONTEXT);

    // same for DVD subpicture context
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_OBJECT, NVP_DVD_SUBPICTURE_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_CONTEXT_DMA_OVERLAY, NVP_DVD_SUBPICTURE_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_CONTEXT_DMA_IMAGE_IN, NVP_DVD_SUBPICTURE_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_CONTEXT_DMA_IMAGE_OUT, NVP_DVD_SUBPICTURE_CONTEXT);

	pVPEContext->nvDmaCount = nvDmaCount;
    pDmaChannel->Put = nvDmaCount << 2;

	// NB: we don't want to launch any captures at this point

	// setup the transfer callback
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_M2M_OBJECT;
  	evParam.hObjectNew = NVP_M2M_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV039_NOTIFIERS_BUFFER_NOTIFY;
  	evParam.hEvent.low = (ULONG) NVPTransferNotify;
	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for m2m transfer 0\n"));
		return FALSE;
	}

	// setup fields callbacks
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
  	evParam.hObjectNew = NVP_VIDEO_FIELD0_BUFFER_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0);
  	evParam.hEvent.low = (ULONG) VideoField0Notify;

	// video field0
	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for video field 0\n"));
		return FALSE;
	}

	// video field1
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
  	evParam.hObjectNew = NVP_VIDEO_FIELD1_BUFFER_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1);
  	evParam.hEvent.low = (ULONG) VideoField1Notify;

	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for video field 1\n"));
		return FALSE;
	}

	// vbi field0
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
  	evParam.hObjectNew = NVP_VBI_FIELD0_BUFFER_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0);
  	evParam.hEvent.low = (ULONG) VBIField0Notify;

	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for VBI field 0\n"));
		return FALSE;
	}
			
	// vbi field1
	evParam.hRoot = pCmdObj->hClient;
  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
  	evParam.hObjectNew = NVP_VBI_FIELD1_BUFFER_EVENT;
  	evParam.hClass = NV01_EVENT_KERNEL_CALLBACK;
  	evParam.index = NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1);
  	evParam.hEvent.low = (ULONG) VBIField1Notify;

	status = Nv01AllocEvent(&evParam);
	if (status)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot create callback for VBI field 1\n"));
		return FALSE;
	}

	// vsync event
	if (pCmdObj->hVPSyncEvent)
	{
	    // field 0
		evParam.hRoot = pCmdObj->hClient;
	  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
	  	evParam.hObjectNew = NVP_VSYNC_EVENT0;
	  	evParam.hClass = NV01_EVENT_WIN32_EVENT;
	  	evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0);
	  	evParam.hEvent.low = (ULONG) pCmdObj->hVPSyncEvent;

		status = Nv01AllocEvent(&evParam);
		if (status)
		{
	    	VideoDebugPrint((0,"VPEMINI: Cannot set event for video field 0\n"));
			return FALSE;
		}

        // field 1 (use same event for both fields)
		evParam.hRoot = pCmdObj->hClient;
	  	evParam.hObjectParent = NVP_EXTERNAL_DECODER_OBJECT;
	  	evParam.hObjectNew = NVP_VSYNC_EVENT1;
	  	evParam.hClass = NV01_EVENT_WIN32_EVENT;
	  	evParam.index = NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1);
	  	evParam.hEvent.low = (ULONG) pCmdObj->hVPSyncEvent;

		status = Nv01AllocEvent(&evParam);
		if (status)
		{
	    	VideoDebugPrint((0,"VPEMINI: Cannot set event for video field 0\n"));
			return FALSE;
		}

	}

	return NO_ERROR;
}

/*
==============================================================================
	
	NVPUninitialize

	Description:	Free channels, DMA contexts and objects created by a 
					previous call to NVPInitialize

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPUninitialize(
    PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext;

	VideoDebugPrint((3,"VPEMINI: NVPUninitialize()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

	// free allocated resources
	////////// shouldn't we wait for completion (either grab of transfer ?!)
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VIDEO_FIELD0_BUFFER_CONTEXT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VIDEO_FIELD1_BUFFER_CONTEXT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VBI_FIELD0_BUFFER_CONTEXT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VBI_FIELD1_BUFFER_CONTEXT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VBI_FIELD0_BUFFER_EVENT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VBI_FIELD1_BUFFER_EVENT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VIDEO_FIELD0_BUFFER_EVENT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VIDEO_FIELD1_BUFFER_EVENT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_EXTERNAL_DECODER_NOTIFIER);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_EXTERNAL_DECODER_OBJECT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_OVERLAY_BUFFER_CONTEXT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_DVD_SUBPICTURE_CONTEXT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_OVERLAY_NOTIFIER);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_OVERLAY_OBJECT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_DVD_SUBPICTURE_OBJECT);

	// free transfer object resources
	if (pVPEContext->bxfContextCreated)
		RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_M2M_CONTEXT);

	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_M2M_NOTIFIER);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_M2M_FROM_CONTEXT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_M2M_EVENT);
	RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_M2M_OBJECT);

	if (pVPEContext->hVPSyncEvent)
	{
		RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VSYNC_EVENT0);
		RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VSYNC_EVENT1);
		pVPEContext->hVPSyncEvent = 0;
	}

	if (pVPEContext->nvDmaFifo != NULL)
	{
		RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_VPE_CHANNEL);
		RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_DMA_FROM_MEMORY_PUSHBUF);
		RmFree(pCmdObj->hClient, pCmdObj->dwDeviceId, NVP_DMA_PUSHBUF_ERROR_NOTIFIER);
		VideoPortReleaseBuffer((PVOID)(pHwDevExt), (PVOID)(pVPEContext->nvDmaFifo));
	}

    pVPEContext->pOverlayChannel = 0;
    pVPEContext->nvDmaFifo = NULL;

    pVPEContext->nvpOverlay.dwOverlayBufferIndex = NVP_UNDEF;

	return NO_ERROR;
}

/*
==============================================================================
	
	NVPUpdate

	Description:	Updates the NV video port data.

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPUpdate(
    PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext;
	PNVP_OVERLAY pnvOverlay;
    int i;

	VideoDebugPrint((3,"VPEMINI: NVPUpdate()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

	pVPEContext->dwVPFlags = pCmdObj->dwVPInfoFlags;
	pVPEContext->pOverlayChannel = pCmdObj->pOvrChannel;

    if (pCmdObj->dwExtra422NumSurfaces > NVP_MAX_EXTRA422)
	{
		VideoDebugPrint((0,"VPEMINI: Error in 'NVPUpdate' >>> exceeded number of extra 422 surfaces \n"));
		return ERROR_INVALID_PARAMETER;
	}

	// get a pointer to the overlay object in VPE context
	pnvOverlay = &(pVPEContext->nvpOverlay);

	// update overlay info: extra 422 surfaces used for prescaling
	pnvOverlay->dwExtra422NumSurfaces = pCmdObj->dwExtra422NumSurfaces;
	pnvOverlay->dwExtra422Index = pCmdObj->dwExtra422Index;
	pnvOverlay->dwExtra422Pitch = pCmdObj->dwExtra422Pitch;            // extra surface pitch

    for (i = 0; i < (int)pCmdObj->dwExtra422NumSurfaces; i++)
	{
        pnvOverlay->aExtra422OverlayOffset[i] = pCmdObj->aExtra422OverlayOffset[i];	// extra memory space used for prescaling
    }

	// start video grabbing here if not already done in NVPStart
	if ((pVPEContext->nNumVidSurf > 0) && !(pVPEContext->dwVPState & NVP_STATE_STARTED_VIDEO))
	{
		// start VBI at the same time as video if vbi is not already enabled !
		if (pVPEContext->nNumVBISurf > 0)
		{
		    // is it already started, then no need to do it again...
		    if (!(pVPEContext->dwVPState & NVP_STATE_STARTED_VBI))
			{
				(pVPEContext->aVBISurfaceInfo[pVPEContext->nNumVBISurf - 1]).nNextSurfaceIdx = 0;
				pVPEContext->nNextVBISurfId = 1;
			}
			pVPEContext->dwVPState = (NVP_STATE_STARTED | NVP_STATE_STARTED_VIDEO | NVP_STATE_STARTED_VBI);
		}
		else
	    	pVPEContext->dwVPState = (NVP_STATE_STARTED | NVP_STATE_STARTED_VIDEO);
		 
		(pVPEContext->aVideoSurfaceInfo[pVPEContext->nNumVidSurf - 1]).nNextSurfaceIdx = 0;
		// kick off VP 
		pVPEContext->nNextVideoSurfId = 1;
        pnvOverlay->dwOverlayBufferIndex = NVP_UNDEF;
		// we OR 0x80 to tell function this is not a notifier calling !
		NVPProcessState(pHwDevExt, NVP_FIELD_EVEN | 0x80, FALSE);
		NVPProcessState(pHwDevExt, NVP_FIELD_ODD | 0x80, FALSE);
	}
	// start VBI grabbing here if not already done in NVPStart
    else if ((pVPEContext->nNumVBISurf > 0) && !(pVPEContext->dwVPState & NVP_STATE_STARTED_VBI))
	{
	    // if video already started, then only enable VBI state flag
        if (pVPEContext->dwVPState & NVP_STATE_STARTED_VIDEO)
		{
		    pVPEContext->dwVPState |= NVP_STATE_STARTED_VBI;
		}
		else
		{
			pVPEContext->dwVPState = (NVP_STATE_STARTED | NVP_STATE_STARTED_VBI);
			(pVPEContext->aVBISurfaceInfo[pVPEContext->nNumVBISurf - 1]).nNextSurfaceIdx = 0;
			pVPEContext->nNextVBISurfId = 1;
			// kick off VP 
			NVPProcessState(pHwDevExt, NVP_FIELD_EVEN, TRUE);
			NVPProcessState(pHwDevExt, NVP_FIELD_ODD, TRUE);
		}
	}

	return NO_ERROR;
}

/*
==============================================================================
	
	NVPStart

	Description:	Tells the NV video port to start grabbing video

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPStart(
    PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext;
	PNVP_OVERLAY pnvOverlay;
    int i;

	VideoDebugPrint((3,"VPEMINI: NVPStart()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

	// aleady started ?! it must be an UpdateVideo then...
	if (pVPEContext->dwVPState & NVP_STATE_STARTED)
		return NVPUpdate(pHwDevExt,	pCmdObj);

	// current
	pVPEContext->nVidSurfIdx = 0;
	pVPEContext->nVBISurfIdx = 0;
	// next in the list
	pVPEContext->nNextVideoSurfId = 0;
	pVPEContext->nNextVBISurfId = 0;

	// update overlay channel pointer ! 
	/////// NVPUpdate() must be the place for this !?
	pVPEContext->pOverlayChannel = pCmdObj->pOvrChannel;

	pVPEContext->dwVPState = NVP_STATE_STARTED;
	pVPEContext->dwVPFlags = pCmdObj->dwVPInfoFlags;
//	pVPEContext->aExtra422OverlayOffset[0] = pCmdObj->aExtra422OverlayOffset[0];
//	pVPEContext->aExtra422OverlayOffset[1] = pCmdObj->aExtra422OverlayOffset[1];

    if (pCmdObj->dwExtra422NumSurfaces > NVP_MAX_EXTRA422)
	{
		VideoDebugPrint((0,"VPEMINI: Error in 'NVPStart' >>> exceeded number of extra 422 surfaces \n"));
		return ERROR_INVALID_PARAMETER;
	}

	// get a pointer to the overlay object in VPE context
	pnvOverlay = &(pVPEContext->nvpOverlay);

	// update overlay info: extra 422 surfaces used for prescaling
	pnvOverlay->dwExtra422NumSurfaces = pCmdObj->dwExtra422NumSurfaces;
	pnvOverlay->dwExtra422Index = pCmdObj->dwExtra422Index;
	pnvOverlay->dwExtra422Pitch = pCmdObj->dwExtra422Pitch;            // extra surface pitch

    for (i = 0; i < (int)pCmdObj->dwExtra422NumSurfaces; i++)
	{
        pnvOverlay->aExtra422OverlayOffset[i] = pCmdObj->aExtra422OverlayOffset[i];	// extra memory space used for prescaling
    }

	// make a cyclic chain with surfaces 
	if (pVPEContext->nNumVidSurf > 0)
	{
		pVPEContext->dwVPState |= NVP_STATE_STARTED_VIDEO;
		(pVPEContext->aVideoSurfaceInfo[pVPEContext->nNumVidSurf - 1]).nNextSurfaceIdx = 0;
		// kick off VP 
		pVPEContext->nNextVideoSurfId = 1;
        pnvOverlay->dwOverlayBufferIndex = NVP_UNDEF;
		// before kicking off the media port, check out VBI setting
		if (pVPEContext->nNumVBISurf > 0)
		{
			pVPEContext->dwVPState |= NVP_STATE_STARTED_VBI;
			(pVPEContext->aVBISurfaceInfo[pVPEContext->nNumVBISurf - 1]).nNextSurfaceIdx = 0;
			pVPEContext->nNextVBISurfId = 1;
		}
		// we OR 0x80 to tell function this is not a notifier calling !
		NVPProcessState(pHwDevExt, NVP_FIELD_EVEN | 0x80, FALSE);
		NVPProcessState(pHwDevExt, NVP_FIELD_ODD | 0x80, FALSE);
	}
	else if (pVPEContext->nNumVBISurf > 0)
	{
		pVPEContext->dwVPState |= NVP_STATE_STARTED_VBI;
		(pVPEContext->aVBISurfaceInfo[pVPEContext->nNumVBISurf - 1]).nNextSurfaceIdx = 0;
		pVPEContext->nNextVBISurfId = 1;
		// kick off VP 
		NVPProcessState(pHwDevExt, NVP_FIELD_EVEN, TRUE);
		NVPProcessState(pHwDevExt, NVP_FIELD_ODD, TRUE);
	}

	return NO_ERROR;
}

/*
==============================================================================
	
	NVP3Stop

	Description:	Tells the NV video port to stop grabbing. PIO channel 
					version

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVP3Stop(
    PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	Nv03ChannelPio *pNVPChannel = (Nv03ChannelPio *) (pCmdObj->pChannel);
	PNVP_CONTEXT pVPEContext;
	NvNotification *avpNotifiers;
	NVOS09_PARAMETERS ntfParam;
	U032 i = 0;

	VideoDebugPrint((3,"VPEMINI: NVP3Stop()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);
	// aleady stopped ?!
	if (pVPEContext->dwVPState & NVP_STATE_STOPPED)
		return NO_ERROR;
	else
		pVPEContext->dwVPState = NVP_STATE_STOPPED;

	g_bFlip = FALSE;

	pVPEContext->pNVPChannel = (ULONG) pNVPChannel;	// get a copy of the pio channel pointer
	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

	// tell VP to stop grabbing !
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.StopTransferImage = 0;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.StopTransferVbi = 0;


// NO LONGER EXISTS IN OFFICIAL NVOS.H....ASK!!!

//	ntfParam.hObjectParent = pCmdObj->dwDeviceId;


#define NVP_NOTIFY_TIMEOUT 100000
	// wait for the last few notifies to show up...
	while ((((avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
	         (avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
		   ((avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) || 
		   (avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
		   (i < NVP_NOTIFY_TIMEOUT)))
	{
		i++;
		//RmInterrupt(&ntfParam);
	}

	// reset surfaces counters
	pVPEContext->nNumVBISurf = 0;
	pVPEContext->nNumVidSurf = 0;

	return NO_ERROR;
}


/*
==============================================================================
	
	NVPStop

	Description:	Tells the NV video port to stop grabbing

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPStop(
    PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext;
	NvNotification *avpNotifiers;
    Nv03ChannelPio *pOvChannel;
	Nv4ControlDma *pDmaChannel;
	U032 nvDmaCount;
    NvNotification *pPioFlipOverlayNotifier;
	U032 i;

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

    // overlay channel
    pOvChannel = (Nv03ChannelPio *) (pVPEContext->pOverlayChannel);	// get a pointer to the overlay channel

	// NV3 specific code
	if (NVP_GET_CHIP_VER(pVPEContext->dwChipId) <= NVP_CHIP_VER_03)
		return NVP3Stop(pHwDevExt, pCmdObj);

	VideoDebugPrint((3,"VPEMINI: NVPStop()\n"));

	// aleady stopped ?!
	if (pVPEContext->dwVPState & NVP_STATE_STOPPED)
		return NO_ERROR;
	else
		pVPEContext->dwVPState = NVP_STATE_STOPPED;

    // channel
	pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
	nvDmaCount = pVPEContext->nvDmaCount;

	// stop overlay engine
	if (pOvChannel && g_bFlip)
	{
	    g_bFlip = FALSE;

	    NVP_DMAPUSH_CHECK_FREE_COUNT(6);
        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OBJECT, NVP_OVERLAY_OBJECT); //pOverlayInfo->dwOverlayObjectID);
        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_STOP_OVERLAY(0), NV07A_STOP_OVERLAY_BETWEEN_BUFFERS);
        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_STOP_OVERLAY(1), NV07A_STOP_OVERLAY_BETWEEN_BUFFERS);
		pDmaChannel->Put = nvDmaCount << 2;
	    pVPEContext->nvDmaCount = nvDmaCount;

		// reset notifiers
        pPioFlipOverlayNotifier = (NvNotification *)pVPEContext->nvpOverlay.pNvPioFlipOverlayNotifierFlat;

        i = 0;
        while (((pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) || (pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) && (i < NVP_VPP_TIME_OUT))
            i++;

        // timed-out... 
        if (i >= NVP_VPP_TIME_OUT)
	        VideoDebugPrint((0,"VPEMINI: waiting for overlay flip notifiers timed-out....\n"));

        pPioFlipOverlayNotifier[1].status = 0;
        pPioFlipOverlayNotifier[2].status = 0;
    }

	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);

	// tell VP to stop grabbing !
	nvDmaCount = pVPEContext->nvDmaCount;
	NVP_DMAPUSH_CHECK_FREE_COUNT(6);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_OBJECT , NVP_EXTERNAL_DECODER_OBJECT);
	//if (pCmdObj->dwStopStrm & NVP_STOP_VIDEO)
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_STOP_TRANSFER_IMAGE , 0);
	//if (pCmdObj->dwStopStrm & NVP_STOP_VBI)
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_STOP_TRANSFER_VBI , 0);
    pDmaChannel->Put = nvDmaCount << 2;
	pVPEContext->nvDmaCount = nvDmaCount;

#define NVP_NOTIFY_TIMEOUT 100000
    i = 0;
	// wait for the last few notifies to show up...
	while ((((avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) ||
	         (avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
		   ((avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS) || 
		   (avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status == NV04D_NOTIFICATION_STATUS_IN_PROGRESS)) &&
		   (i < NVP_NOTIFY_TIMEOUT)))
	{
		i++;
		//RmInterrupt(&ntfParam);
	}

    // timed-out... 
    if (i >= NVP_NOTIFY_TIMEOUT)
        VideoDebugPrint((0,"VPEMINI: waiting for MediaPort notifiers timed-out....\n"));

	avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(0)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;
	avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(1)].status = 0; //NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

	// reset surfaces counters
	pVPEContext->nNumVBISurf = 0;
	pVPEContext->nNumVidSurf = 0;

    // clear/reset sync event 
	KeClearEvent((PVOID)pVPEContext->hVPSyncEvent);

	return NO_ERROR;
}

/*
==============================================================================
	
	NVPRegSurface

	Description:	register a DDraw surface. Insert in list and update 
					attributes

	Date:			Feb 18, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPRegSurface(
    PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext;
	PNVP_SURFACE_INFO pSurface;
	BOOL bVideoStarted, bVBIStarted;

	VideoDebugPrint((3,"VPEMINI: NVPRegSurface()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

    bVideoStarted = (pVPEContext->dwVPState & NVP_STATE_STARTED_VIDEO);
    bVBIStarted = (pVPEContext->dwVPState & NVP_STATE_STARTED_VBI);

	// update attributes of already existing surfaces ?!
	if (pCmdObj->bSurfUpdate)
	{
		// vbi surfaces ?!
		if (pCmdObj->bSurfVBI)
		{
			if (pCmdObj->dwSurfaceId < (ULONG)pVPEContext->nNumVBISurf)
			{
				pSurface = &(pVPEContext->aVBISurfaceInfo[pCmdObj->dwSurfaceId]);
				// check for mem offset in framebuffer !
				if (pSurface->pVidMem == pCmdObj->pSurfVidMem)
				{
				    pSurface->dwHeight = pCmdObj->dwVBIHeight;
				    pSurface->dwStartLine = pCmdObj->dwVBIStartLine; 		// startline for vbi

				}
				else
				{
					VideoDebugPrint((0,"VPEMINI: can't update VBI surface data !\n"));
					return ERROR_INVALID_PARAMETER;
				}

			}
			else
			{
				// new vbi surfaces
				pSurface = &(pVPEContext->aVBISurfaceInfo[pCmdObj->dwSurfaceId]);
				(pVPEContext->nNumVBISurf)++;
			    pSurface->pVidMem = pCmdObj->pSurfVidMem;				// Flat pointer to the surface
			    pSurface->dwOffset = pCmdObj->dwSurfOffset;         	// Offset from the base of the frame buffer
			    pSurface->dwPitch = pCmdObj->dwSurfPitch;
			    pSurface->dwHeight = pCmdObj->dwVBIHeight;
			    pSurface->dwStartLine = pCmdObj->dwVBIStartLine; 		// Programs Y-crop for image, and startline for vbi
			    pSurface->nNextSurfaceIdx = pCmdObj->dwSurfaceId + 1;	// the next surface idx in the chain
				pSurface->bIsFirstFieldCaptured = FALSE;				// reset value

			}
		}
		else	// video surface
		{
			if (pCmdObj->dwSurfaceId < (ULONG)pVPEContext->nNumVidSurf)
			{
				//////////
				///// I assume something changing in the following values only !
				pSurface = &(pVPEContext->aVideoSurfaceInfo[pCmdObj->dwSurfaceId]);
				if (pSurface->pVidMem == pCmdObj->pSurfVidMem)
				{
				    pSurface->dwHeight = pCmdObj->dwInHeight;
				    pSurface->dwWidth = pCmdObj->dwInWidth;            		// Ignored for VBI
				    pSurface->dwStartLine = pCmdObj->dwImageStartLine; 		// Programs Y-crop for image, and startline for vbi
				    pSurface->dwPreScaleSizeX = pCmdObj->dwPreWidth;    	// Ignored for VBI.. prescale size width
				    pSurface->dwPreScaleSizeY = pCmdObj->dwPreHeight;   	// Ignored for VBI.. prescale size height
				}
				else
				{
					VideoDebugPrint((0,"VPEMINI: can't update video surface data !\n"));
					return ERROR_INVALID_PARAMETER;
				}
			}
			else
			{
				// new video surfaces
				pSurface = &(pVPEContext->aVideoSurfaceInfo[pCmdObj->dwSurfaceId]);
				(pVPEContext->nNumVidSurf)++;
			    pSurface->pVidMem = pCmdObj->pSurfVidMem;				// Flat pointer to the surface
			    pSurface->dwOffset = pCmdObj->dwSurfOffset;         	// Offset from the base of the frame buffer
			    pSurface->dwPitch = pCmdObj->dwSurfPitch;
			    pSurface->dwHeight = pCmdObj->dwInHeight;
			    pSurface->dwWidth = pCmdObj->dwInWidth;            		// Ignored for VBI
			    pSurface->dwStartLine = pCmdObj->dwImageStartLine; 		// Programs Y-crop for image, and startline for vbi
			    pSurface->dwPreScaleSizeX = pCmdObj->dwPreWidth;    	// Ignored for VBI.. prescale size width
			    pSurface->dwPreScaleSizeY = pCmdObj->dwPreHeight;   	// Ignored for VBI.. prescale size height
			    pSurface->nNextSurfaceIdx = pCmdObj->dwSurfaceId + 1;	// the next surface idx in the chain
				pSurface->bIsFirstFieldCaptured = FALSE;				// reset value

			}
		}
	}
	else	// new surfaces !
	{
		if (pVPEContext->dwVPState & NVP_STATE_STARTED)
		{
			VideoDebugPrint((0,"VPEMINI: can't register new DD surfaces while Video Port is running !\n"));
			return ERROR_INVALID_PARAMETER;
		}

		// vbi surfaces ?!
		if (pCmdObj->bSurfVBI)
		{
			pSurface = &(pVPEContext->aVBISurfaceInfo[pCmdObj->dwSurfaceId]);
			(pVPEContext->nNumVBISurf)++;
		    pSurface->dwStartLine = pCmdObj->dwVBIStartLine; 		// startline for vbi
		}
		else	// video surface
		{
			pSurface = &(pVPEContext->aVideoSurfaceInfo[pCmdObj->dwSurfaceId]);
			(pVPEContext->nNumVidSurf)++;
		    pSurface->dwStartLine = pCmdObj->dwImageStartLine; 		// startline for video
		}

	    pSurface->pVidMem = pCmdObj->pSurfVidMem;				// Flat pointer to the surface
	    pSurface->dwOffset = pCmdObj->dwSurfOffset;         	// Offset from the base of the frame buffer
	    pSurface->dwPitch = pCmdObj->dwSurfPitch;
	    pSurface->dwHeight = pCmdObj->dwInHeight;
	    pSurface->dwWidth = pCmdObj->dwInWidth;            		// Ignored for VBI
	    pSurface->dwPreScaleSizeX = pCmdObj->dwPreWidth;    	// Ignored for VBI.. prescale size width
	    pSurface->dwPreScaleSizeY = pCmdObj->dwPreHeight;   	// Ignored for VBI.. prescale size height
	    pSurface->nNextSurfaceIdx = pCmdObj->dwSurfaceId + 1;	// the next surface idx in the chain
		pSurface->bIsFirstFieldCaptured = FALSE;				// reset value
	}

	return NO_ERROR;
}

/*
==============================================================================
	
	NVPUpdateOverlay

	Description:	update the overlay info structure

	Date:			Mar 01, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPUpdateOverlay(
    PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);
    Nv03ChannelPio *pChannel = (Nv03ChannelPio *) (pVPEContext->pOverlayChannel);	// get a pointer to the overlay channel;
	PNVP_OVERLAY pnvOverlay =  &(pVPEContext->nvpOverlay);
    NvNotification *pPioFlipOverlayNotifier;
	Nv4ControlDma *pDmaChannel;
	U032 nvDmaCount;
	int i = 0;

	VideoDebugPrint((3,"VPEMINI: NVPUpdateOverlay()\n"));

	if ((pCmdObj->dwOverlayDstWidth != 0) && (pCmdObj->dwOverlayDstHeight != 0))
	{
		// I must rather have a structure memcpy !
		pnvOverlay->dwOverlayFormat = pCmdObj->dwOverlayFormat;
		pnvOverlay->dwOverlaySrcX = pCmdObj->dwOverlaySrcX;
		pnvOverlay->dwOverlaySrcY = pCmdObj->dwOverlaySrcY;
		pnvOverlay->dwOverlaySrcPitch = pCmdObj->dwOverlaySrcPitch;
		pnvOverlay->dwOverlaySrcSize = pCmdObj->dwOverlaySrcSize;
		pnvOverlay->dwOverlaySrcWidth = pCmdObj->dwOverlaySrcWidth;
		pnvOverlay->dwOverlaySrcHeight = pCmdObj->dwOverlaySrcHeight;
		pnvOverlay->dwOverlayDstWidth = pCmdObj->dwOverlayDstWidth;
		pnvOverlay->dwOverlayDstHeight = pCmdObj->dwOverlayDstHeight;
		pnvOverlay->dwOverlayDstX = pCmdObj->dwOverlayDstX;
	    pnvOverlay->dwOverlayDstY = pCmdObj->dwOverlayDstY;
		pnvOverlay->dwOverlayDeltaX = pCmdObj->dwOverlayDeltaX;
		pnvOverlay->dwOverlayDeltaY = pCmdObj->dwOverlayDeltaY;
		pnvOverlay->dwOverlayColorKey = pCmdObj->dwOverlayColorKey;
		pnvOverlay->dwOverlayMode = pCmdObj->dwOverlayMode;
	    pnvOverlay->dwOverlayMaxDownScale = pCmdObj->dwOverlayMaxDownScale;

		VideoDebugPrint((3,"VPEMINI: overlay flipping enabled....\n"));
		g_bFlip = TRUE;
	}
	else
	{
		VideoDebugPrint((3,"VPEMINI: overlay flipping disabled....\n"));
		g_bFlip = FALSE;	// no autoflip !
		// stop overlay engine
		if (pChannel)
		{
		    // channel
			pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
			nvDmaCount = pVPEContext->nvDmaCount;

		    NVP_DMAPUSH_CHECK_FREE_COUNT(6);
	        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OBJECT, NVP_OVERLAY_OBJECT); //pOverlayInfo->dwOverlayObjectID);
	        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_STOP_OVERLAY(0), NV07A_STOP_OVERLAY_BETWEEN_BUFFERS);
	        NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_STOP_OVERLAY(1), NV07A_STOP_OVERLAY_BETWEEN_BUFFERS);
			pDmaChannel->Put = nvDmaCount << 2;
		    pVPEContext->nvDmaCount = nvDmaCount;

			// reset notifiers
            pPioFlipOverlayNotifier = (NvNotification *)pnvOverlay->pNvPioFlipOverlayNotifierFlat;

            while (((pPioFlipOverlayNotifier[1].status == NV_IN_PROGRESS) || (pPioFlipOverlayNotifier[2].status == NV_IN_PROGRESS)) && (i < NVP_VPP_TIME_OUT))
                i++;
            // timed-out... 
            if (i >= NVP_VPP_TIME_OUT)
		        VideoDebugPrint((0,"VPEMINI: waiting for overlay flip notifiers timed-out....\n"));

	        pPioFlipOverlayNotifier[1].status = 0;
            pPioFlipOverlayNotifier[2].status = 0;
		}
	}

	return NO_ERROR;
}

/*
==============================================================================
	
	NVPFlipVideoPort

	Description:	start capturing in specified surface 

	Date:			Mar 01, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPFlipVideoPort(
    PHW_DEVICE_EXTENSION pHwDevExt,
	NVP_CMD_OBJECT *pCmdObj)
{
	PNVP_CONTEXT pVPEContext;
	PNVP_SURFACE_INFO pSurface;
	NvNotification *avpNotifiers;
	int i;

	VideoDebugPrint((3,"VPEMINI: NVPFlipVideoPort()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[pCmdObj->dwPortId]);

	// NVP_UNDEF tells us to lookup the surface in list
	if (pCmdObj->dwSurfaceId == NVP_UNDEF)
	{
		for (i = 0; i < pVPEContext->nNumVidSurf; i++)
		{
				//////////
				///// I assume nothing changing in the surfaces values 
				pSurface = &(pVPEContext->aVideoSurfaceInfo[i]);
				if (pSurface->pVidMem == pCmdObj->pSurfVidMem)
				{
				    // clear/reset sync event 
					KeClearEvent((PVOID)pVPEContext->hVPSyncEvent);
					// found target surface, so update index of video surface we're currently capturing into
					pVPEContext->nVidSurfIdx = i;
					return NO_ERROR;
				}
		}
	}
	else
	{
		// check for weird values !
		if ((pCmdObj->dwSurfaceId >= 0) && 
			(pCmdObj->dwSurfaceId < pVPEContext->nNumVidSurf) && 
			(pVPEContext->aVideoSurfaceInfo[pCmdObj->dwSurfaceId].pVidMem == pCmdObj->pSurfVidMem))
		{
			    // clear/reset sync event 
				KeClearEvent((PVOID)pVPEContext->hVPSyncEvent);
				// update index of video surface we're currently capturing into
				pVPEContext->nVidSurfIdx = (int)(pCmdObj->dwSurfaceId);
				return NO_ERROR;
		}
	}

	////// if we got here, it means the target surface wasn't found in list... 
	// so add it at the end of the list  
	i = pVPEContext->nNumVidSurf;
	pSurface = &(pVPEContext->aVideoSurfaceInfo[i]);
	(pVPEContext->nNumVidSurf)++;
	pSurface->dwStartLine = pCmdObj->dwImageStartLine; 		// startline for video
    pSurface->pVidMem = pCmdObj->pSurfVidMem;				// Flat pointer to the surface
    pSurface->dwOffset = pCmdObj->dwSurfOffset;         	// Offset from the base of the frame buffer
    pSurface->dwPitch = pCmdObj->dwSurfPitch;
    pSurface->dwHeight = pCmdObj->dwInHeight;
    pSurface->dwWidth = pCmdObj->dwInWidth;            		// Ignored for VBI
    pSurface->dwPreScaleSizeX = pCmdObj->dwPreWidth;    	// Ignored for VBI.. prescale size width
    pSurface->dwPreScaleSizeY = pCmdObj->dwPreHeight;   	// Ignored for VBI.. prescale size height
    pSurface->nNextSurfaceIdx = 0;							// the next surface idx in the chain
	pSurface->bIsFirstFieldCaptured = FALSE;				// reset value
    // clear/reset sync event 
	KeClearEvent((PVOID)pVPEContext->hVPSyncEvent);
	// flip to surface !
	pVPEContext->nVidSurfIdx = i;							

	return NO_ERROR;
}

/*
==============================================================================
	
	NVP3ProgVideoField

	Description:	programs the vp to capture the specified video field

	Date:			Feb 19, 1999
	
	Author:			H. Azar

==============================================================================
*/
void NVP3ProgVideoField(
	PNVP_CONTEXT pVPEContext,
	PNVP_SURFACE_INFO pSurface,
	int nFieldId,
	U032 dwSurfPitch,
	U032 dwInterleaveOffset,
	BOOL bGrab)
{
	Nv03ChannelPio *pNVPChannel;
	NvNotification *avpNotifiers;
	int nFreeCount;
	NVOS09_PARAMETERS ntfParam;

	pSurface->dwFieldType = (ULONG)nFieldId;

	// get a pointer to the appropriate VPE context
	pNVPChannel = (Nv03ChannelPio *)(pVPEContext->pNVPChannel) ;	// get a copy of the pio channel pointer

#ifdef _NV_DPC
	//CHECK_FREE_COUNT(pNVPChannel,6*4);
	ntfParam.hObjectParent = pVPEContext->dwDeviceId;
	nFreeCount = pVPEContext->nFreeCount;
	while (nFreeCount < 7*4) 
	{
		//RmInterrupt(&ntfParam);
		nFreeCount = NvGetFreeCount(pNVPChannel, 0);
	}			
	pVPEContext->nFreeCount = nFreeCount - (7*4);
#endif

	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);
	// program the VP to grab in the next surface
	avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(nFieldId)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

	pNVPChannel->subchannel[0].SetObject = NVP_EXTERNAL_DECODER_OBJECT;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetImage[nFieldId].sizeIn  = (pSurface->dwWidth) | (pSurface->dwHeight << 16);
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetImage[nFieldId].sizeOut = (pSurface->dwPreScaleSizeX) | (pSurface->dwPreScaleSizeY << 16);

	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetImageStartLine = pSurface->dwStartLine;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetImage[nFieldId].offset  = pSurface->dwOffset + dwInterleaveOffset; 

	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetImage[nFieldId].format =
			(dwSurfPitch & 0xFFFF)  |
			((((nFieldId == NVP_FIELD_EVEN) ? NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD : NV04D_SET_IMAGE_FORMAT_FIELD_ODD_FIELD) << 16) & 0xFF0000) |
			((NV04D_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN << 24 ) & 0xFF000000);
}

/*
==============================================================================
	
	NVP3ProgVBIField

	Description:	programs the vp to capture the specified VBI field.
					PIO channel version.

	Date:			Feb 19, 1999
	
	Author:			H. Azar

==============================================================================
*/
void NVP3ProgVBIField(
	PNVP_CONTEXT pVPEContext,
	PNVP_SURFACE_INFO pSurface,
	int nFieldId)
{
	Nv03ChannelPio *pNVPChannel;
	int nFreeCount;
	NVOS09_PARAMETERS ntfParam;
	NvNotification *avpNotifiers;

	pSurface->dwFieldType = (ULONG)nFieldId;

	// get a pointer to the appropriate VPE context
	pNVPChannel = (Nv03ChannelPio *)(pVPEContext->pNVPChannel) ;	// get a copy of the pio channel pointer

#ifdef _NV_DPC
	//CHECK_FREE_COUNT(pNVPChannel,5*4);
	ntfParam.hObjectParent = pVPEContext->dwDeviceId;
	nFreeCount = pVPEContext->nFreeCount;
	while (nFreeCount < 5*4) 
	{
		//RmInterrupt(&ntfParam);
		nFreeCount = NvGetFreeCount(pNVPChannel, 0);
	}
	pVPEContext->nFreeCount = nFreeCount - (5*4);
#endif
	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);
	avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(nFieldId)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

	pNVPChannel->subchannel[0].SetObject = NVP_EXTERNAL_DECODER_OBJECT;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetVbi[nFieldId].size  = (pSurface->dwStartLine) | (pSurface->dwHeight << 16);
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetVbi[nFieldId].offset  = pSurface->dwOffset;
	pNVPChannel->subchannel[0].nv03ExternalVideoDecoder.SetVbi[nFieldId].format =
			(pSurface->dwPitch & 0xFFFF)  |
			((((nFieldId == NVP_FIELD_EVEN) ? NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD : NV04D_SET_VBI_FORMAT_FIELD_ODD_FIELD) << 16) & 0xFF0000) |
			((NV04D_SET_VBI_FORMAT_NOTIFY_WRITE_THEN_AWAKEN << 24) & 0xFF000000);
}

/*
==============================================================================
	
	NVPProgVideoField

	Description:	programs the vp to capture the specified video field

	Date:			Apr 19, 1999
	
	Author:			H. Azar

==============================================================================
*/
void NVPProgVideoField(
	PNVP_CONTEXT pVPEContext,
	PNVP_SURFACE_INFO pSurface,
	int nFieldId,
	U032 dwSurfPitch,
	U032 dwInterleaveOffset,
	BOOL bGrab)
{
	Nv4ControlDma *pDmaChannel;
	NvNotification *avpNotifiers;
	U032 dwFormat;
	U032 nvDmaCount;

	// NV3 specific code
	if (NVP_GET_CHIP_VER(pVPEContext->dwChipId) <= NVP_CHIP_VER_03)
	{
		NVP3ProgVideoField(pVPEContext, pSurface, nFieldId, dwSurfPitch, dwInterleaveOffset, bGrab);
		return;
	}

	// update type of field we're capturing
	pSurface->dwFieldType = (ULONG)nFieldId;

	pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;
	NVP_DMAPUSH_CHECK_FREE_COUNT(12);

	// reset notifier
	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);
	avpNotifiers[NV04D_NOTIFIERS_SET_IMAGE_FORMAT_NOTIFY(nFieldId)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

	// program the VP to grab in the next surface
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_OBJECT , NVP_EXTERNAL_DECODER_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_IMAGE_SIZE_IN(nFieldId), ((pSurface->dwWidth) | (pSurface->dwHeight << 16)));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_IMAGE_SIZE_OUT(nFieldId), ((pSurface->dwPreScaleSizeX) | (pSurface->dwPreScaleSizeY << 16)));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_IMAGE_START_LINE, pSurface->dwStartLine);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_IMAGE_OFFSET(nFieldId), (pSurface->dwOffset + dwInterleaveOffset));
	dwFormat = ((dwSurfPitch & 0xFFFF) |
				((((nFieldId == NVP_FIELD_EVEN) ? NV04D_SET_IMAGE_FORMAT_FIELD_EVEN_FIELD : NV04D_SET_IMAGE_FORMAT_FIELD_ODD_FIELD) << 16) & 0xFF0000) |
				((NV04D_SET_IMAGE_FORMAT_NOTIFY_WRITE_THEN_AWAKEN << 24 ) & 0xFF000000));

	NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_IMAGE_FORMAT(nFieldId), dwFormat);

    pDmaChannel->Put = nvDmaCount << 2;
	pVPEContext->nvDmaCount = nvDmaCount;
}

/*
==============================================================================
	
	NVPProgVBIField

	Description:	programs the vp to capture the specified VBI field

	Date:			Apr 22, 1999
	
	Author:			H. Azar

==============================================================================
*/
void NVPProgVBIField(
	PNVP_CONTEXT pVPEContext,
	PNVP_SURFACE_INFO pSurface,
	int nFieldId)
{
	Nv4ControlDma *pDmaChannel;
	NvNotification *avpNotifiers;
	U032 dwFormat;
	U032 nvDmaCount;

	// NV3 specific code
	if (NVP_GET_CHIP_VER(pVPEContext->dwChipId) <= NVP_CHIP_VER_03)
	{
		NVP3ProgVBIField(pVPEContext, pSurface, nFieldId);
		return;
	}

	// update type of field we're capturing
	pSurface->dwFieldType = (ULONG)nFieldId;

	pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;
	NVP_DMAPUSH_CHECK_FREE_COUNT(8);

	// reset notifier
	avpNotifiers = (NvNotification *) (pVPEContext->avpNotifiers);
	avpNotifiers[NV04D_NOTIFIERS_SET_VBI_FORMAT_NOTIFY(nFieldId)].status = NV04D_NOTIFICATION_STATUS_IN_PROGRESS;

	// program the VP to grab in the next surface
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_OBJECT , NVP_EXTERNAL_DECODER_OBJECT);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_VBI_SIZE(nFieldId), ((pSurface->dwStartLine) | (pSurface->dwHeight << 16)));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_VBI_OFFSET(nFieldId), pSurface->dwOffset);
	dwFormat = (pSurface->dwPitch & 0xFFFF)  |
			((((nFieldId == NVP_FIELD_EVEN) ? NV04D_SET_VBI_FORMAT_FIELD_EVEN_FIELD : NV04D_SET_VBI_FORMAT_FIELD_ODD_FIELD) << 16) & 0xFF0000) |
			((NV04D_SET_VBI_FORMAT_NOTIFY_WRITE_THEN_AWAKEN << 24) & 0xFF000000);
	NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV04D_SET_VBI_FORMAT(nFieldId), dwFormat);

    pDmaChannel->Put = nvDmaCount << 2;
	pVPEContext->nvDmaCount = nvDmaCount;
}


/*
==============================================================================
	
	NVPProcessState

	Description:	programs the video port grab in a surface and determines
					which surface is next.

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPProcessState(
	PHW_DEVICE_EXTENSION pHwDevExt,
	int nIndex,
	BOOL bVBIField)
{
	PNVP_CONTEXT pVPEContext;
	PNVP_SURFACE_INFO pSurface;
	int nFieldId = nIndex & 1;
	U032 status;
	BOOL bIRQCallback;

	VideoDebugPrint((3,"VPEMINI: NVPProcessState()\n"));

	// get a pointer to the appropriate VPE context
	pVPEContext = &(pHwDevExt->avpContexts[0]);

    // setting nIndex to greater than 1 (nField | any_value) means that the caller is NVPStart or NVPUpdate
	// so first time initialize the dwOverlayIndex to match up with the nFieldId (notifier)
    if ((pVPEContext->nvpOverlay.dwOverlayBufferIndex == NVP_UNDEF) && (nIndex <= 1))
       pVPEContext->nvpOverlay.dwOverlayBufferIndex = nFieldId;

	// calling IRQCallback must be done only at the end of video field or at end of vbi when
	// capturing vbi only 
	bIRQCallback = (!bVBIField) || (pVPEContext->nNumVidSurf == 0);
	// any transfer request of already captured vbi/video data ?!
	if (bIRQCallback)
		NVPCheckForLaunch(pVPEContext, NULL);


	if (pVPEContext->dwVPState != NVP_STATE_STOPPED)
    {
        if (pVPEContext->dwVPState & NVP_STATE_STARTED_VIDEO)
	    {
		    // program VBI here. This way VBI is synchronized with the video thus we eliminate the need 
		    // for a seperate VBI notifications routine unless we're streaming VBI only
		    if (!bVBIField)
			{
			    if (pVPEContext->dwVPState & NVP_STATE_STARTED_VBI)
				{
					pSurface = &(pVPEContext->aVBISurfaceInfo[pVPEContext->nNextVBISurfId]);
					// program the VP to grab in the next surface
					NVPProgVBIField(pVPEContext, pSurface, nFieldId);

					// next surface in the chain !
					pVPEContext->nVBISurfIdx = pVPEContext->nNextVBISurfId;
					pVPEContext->nNextVBISurfId = pSurface->nNextSurfaceIdx;
				}

				if (pVPEContext->dwVPConFlags & DDVPCONNECT_INTERLACED)
				{
					if (pVPEContext->dwVPFlags & DDVP_INTERLEAVE)
					{
						if (pVPEContext->nvpOverlay.dwOverlayMode & NV_VFM_FORMAT_BOBFROMINTERLEAVE)
						{
							// Bob from interleaved surfaces (skip even/odd included here too)
							DoBobFromInterleaved(pVPEContext, nFieldId);
						}
						else
						{
							// Weave
							DoWeave(pVPEContext, nFieldId);
						}
					}
					else
					{
						// Bob from non-interleaved (separate) surfaces (skip even/odd included here too)
						DoBob(pVPEContext, nFieldId);
					}
				}
				else
				{
					// Progressive 
					DoProgressive(pVPEContext, nFieldId);
				}
			}
		}
        else if (pVPEContext->dwVPState & NVP_STATE_STARTED_VBI)
		{
			pSurface = &(pVPEContext->aVBISurfaceInfo[pVPEContext->nNextVBISurfId]);
			// program the VP to grab in the next surface
			NVPProgVBIField(pVPEContext, pSurface, nFieldId);

			// next surface in the chain !
			pVPEContext->nVBISurfIdx = pVPEContext->nNextVBISurfId;
			pVPEContext->nNextVBISurfId = pSurface->nNextSurfaceIdx;
		}
    }

	//
	// calling IRQCallback must be done only at the end of video field or at end of vbi when
	// capturing vbi only 
	if (bIRQCallback)
	{
		// can we pass on the interrupt !
		if ((pHwDevExt->IRQCallback) && (pHwDevExt->dwIRQSources & DDIRQ_VPORT0_VSYNC))
		{
			PDX_IRQDATA pIRQData;
			pIRQData = (PDX_IRQDATA)(pHwDevExt->pIRQData);
			pIRQData->dwIrqFlags |= DDIRQ_VPORT0_VSYNC;
			((PDX_IRQCALLBACK)(pHwDevExt->IRQCallback))(pIRQData);
		}
	}

	return NO_ERROR;
}


/*
==============================================================================
	
	NVPEProcessCommand

	Description:	dispatches commands sent via IOCTL to the appropriate 
					NVP function

	Date:			Feb 03, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPEProcessCommand(
    PVOID pHwDeviceExtension,
    PVIDEO_REQUEST_PACKET pRequestPacket)
{
	U032 status = 0;
	NVP_CMD_OBJECT *pnvCmdObj;
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;

	VideoDebugPrint((3,"VPEMINI: NVPEProcessCommand()\n"));

	pnvCmdObj = (NVP_CMD_OBJECT *)(pRequestPacket->InputBuffer);
	// some arguments validation
	if ((pnvCmdObj->dwPortId < 0) || (pnvCmdObj->dwPortId >= NVP_MAX_VPORTS)) 
		return ERROR_INVALID_PARAMETER;

	// dispatch call
	switch (pnvCmdObj->dwSrvId)
	{
		case NVP_SRV_INITIALIZE:
			status = NVPInitialize(pHwDevExt, pnvCmdObj);
			break;
		case NVP_SRV_UNINITIALIZE:
			status = NVPUninitialize(pHwDevExt, pnvCmdObj);
			break;
		case NVP_SRV_START_VIDEO:
			status = NVPStart(pHwDevExt, pnvCmdObj);
			break;
		case NVP_SRV_STOP_VIDEO:
			status = NVPStop(pHwDevExt, pnvCmdObj);
			break;
		case NVP_SRV_UPDATE_VIDEO:
			status = NVPUpdate(pHwDevExt, pnvCmdObj);
			break;
		case NVP_SRV_REG_SURFACE:
			status = NVPRegSurface(pHwDevExt, pnvCmdObj);
			break;
		case NVP_SRV_UPDATE_OVERLAY:
			status = NVPUpdateOverlay(pHwDevExt, pnvCmdObj);
			break;
		case NVP_SRV_FLIP_VIDEOPORT:
			status = NVPFlipVideoPort(pHwDevExt, pnvCmdObj);
			break;
		default:
			VideoDebugPrint((0,"VPEMINI: invalid VPE command !\n"));
			return ERROR_INVALID_PARAMETER;
	}

	return status;
}

/*
==============================================================================
	
	VideoField0Notify

	Description:	callback function. Called after a video buffer gets filled

	Date:			Feb 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
void VideoField0Notify(PVOID pHwDeviceExtension)
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;

	NVPProcessState(pHwDevExt, 0, FALSE);
}

/*
==============================================================================
	
	VideoField1Notify

	Description:	callback function. Called after a vbi buffer gets filled

	Date:			Feb 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
void VideoField1Notify(PVOID pHwDeviceExtension)
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;

	NVPProcessState(pHwDevExt, 1, FALSE);
}


/*
==============================================================================
	
	VBIField0Notify

	Description:	callback function. Called after a vbi buffer gets filled

	Date:			Feb 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
void VBIField0Notify(PVOID pHwDeviceExtension)
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;

	NVPProcessState(pHwDevExt, 0, TRUE);
}

/*
==============================================================================
	
	VBIField1Notify

	Description:	callback function. Called after a vbi buffer gets filled

	Date:			Feb 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
void VBIField1Notify(PVOID pHwDeviceExtension)
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pHwDeviceExtension;

	NVPProcessState(pHwDevExt, 1, TRUE);
}


/*
==============================================================================
	
	NVPScheduleOverlayFlip

	Description:	program overlay object to flip surface

	Date:			Feb 25, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS NVPScheduleOverlayFlip(
	PNVP_CONTEXT pVPEContext,
	PNVP_SURFACE_INFO pSurface,
	int  nImageId,
	U032 dwSrcPitch,
	U032 dwMoveDownOffset)
{
	NVP_OVERLAY ovOverlayInfo;
	Nv03ChannelPio *pOvrChannel;
	U032 dwFlags = 0;
	U032 dwSubChn;
	U032 dwSrcDeltaY;
	U032 dwSrcOffset;

	if (!g_bFlip)
		return NO_ERROR;

	VideoDebugPrint((3,"VPEMINI: NVPScheduleOverlayFlip()\n"));


	dwFlags = VPP_PRESCALE;

	if (pVPEContext->dwVPFlags & DDVP_INTERLEAVE)
	   dwFlags |= VPP_INTERLEAVED;
	else 
	   dwFlags |= VPP_BOB;

	if (pVPEContext->nvpOverlay.dwOverlayMode & NV_VFM_FORMAT_BOBFROMINTERLEAVE)
	   dwFlags |= VPP_BOB;

    if (nImageId == NVP_FIELD_ODD)
	   dwFlags |= VPP_ODD;
	else if (nImageId == NVP_FIELD_EVEN)
	   dwFlags |= VPP_EVEN;
    
    NVPPrescaleAndFlip(
	    pVPEContext, 
	    &(pVPEContext->nvpOverlay), 
	    pSurface->dwOffset, 
	    pSurface->dwPitch, // source pitch
        nImageId,
        dwFlags);          // VPP flags

	return NO_ERROR;
}


/*
==============================================================================
	
	DoProgressive

	Description:	displays progressive video

	Date:			Mar 08, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS DoProgressive(
	PNVP_CONTEXT pVPEContext,
	int nFieldId)
{
	PNVP_SURFACE_INFO pSurface;
	int nTargetSurfId = pVPEContext->nVidSurfIdx;
	U032 dwSrcPitch;
	int nImage = nFieldId;

	pSurface = &(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx]);
		// if autoflip, CS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
	if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
		nTargetSurfId = pSurface->nNextSurfaceIdx;

	dwSrcPitch = pSurface->dwPitch;

	// Overlay Image n from CS
	NVPScheduleOverlayFlip(pVPEContext,	pSurface, nImage, dwSrcPitch, 0);

	pVPEContext->nVidSurfIdx = nTargetSurfId;

	// Grab Image n in TS
	pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfId]);
	NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, TRUE);

	return NO_ERROR;
}

/*
==============================================================================
	
	DoWeave

	Description:	use weave method to display video

	Date:			Mar 08, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS DoWeave(
	PNVP_CONTEXT pVPEContext,
	int nFieldId)
{
	PNVP_SURFACE_INFO pSurface;
	int nTargetSurfId = pVPEContext->nVidSurfIdx;
	U032 dwSrcPitch, dwOffset = 0;
	int nImage = nFieldId;

	pSurface = &(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx]);
	// if autoflip, TS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
	if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
		nTargetSurfId = pSurface->nNextSurfaceIdx;
	// double pitch (interleaved data)
	dwSrcPitch = 2*(pSurface->dwPitch);

	if (nFieldId == NVP_FIELD_ODD)
	{
		// Invert Polarity ?!
		if (pVPEContext->dwVPConFlags & DDVPCONNECT_INVERTPOLARITY)
		{
			// change vp grab offset one line down
			dwOffset = pSurface->dwPitch;
			// Shift Down Image destination by 1 line !
			/////// the following code uses an "undocumented feature" in the RM to achieve the 1 line shift down effect !
			//dwSrcPitch = (dwSrcPitch & 0xFFFFFFFC) | 0x2;
		}
	}
	else
	{
		// not Invert Polarity ?!
		if (!(pVPEContext->dwVPConFlags & DDVPCONNECT_INVERTPOLARITY))
		{
			// offset vp grab one line down
			dwOffset = pSurface->dwPitch;

			// Shift Down Image destination by 1 line !
			/////// the following code uses an "undocumented feature" in the RM to achieve the 1 line shift down effect !
			//dwSrcPitch = (dwSrcPitch & 0xFFFFFFFC) | 0x2;
		}
	}

	// whole frame captured ?!
	if (pSurface->bIsFirstFieldCaptured)
	{
		// Overlay Image n from CS
		NVPScheduleOverlayFlip(pVPEContext,	pSurface, NVP_UNDEF, pSurface->dwPitch, 0);
		// NVPScheduleOverlayFlip(pVPEContext, pSurface, nImage ^ 1, dwSrcPitch, dwOffset);

		pSurface->bIsFirstFieldCaptured = FALSE;	// reset flag (for the next time)

		// if autoflip, CS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
		if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
			pVPEContext->nVidSurfIdx = pSurface->nNextSurfaceIdx;
	}
	else
		pSurface->bIsFirstFieldCaptured = TRUE;	// set flag (for the next time)

	// Grab Image n in TS
	pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfId]);
	NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, dwOffset, TRUE);

	return NO_ERROR;
}

/*
==============================================================================
	
	DoBobFromInterleaved

	Description:	use bob from interleaved input to display video

	Date:			Mar 08, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS DoBobFromInterleaved(
	PNVP_CONTEXT pVPEContext,
	int nFieldId)
{
	PNVP_SURFACE_INFO pSurface;
	int nTargetSurfId = pVPEContext->nVidSurfIdx;
	U032 dwSrcPitch, dwOffset = 0;
	int nImage = nFieldId;

	// Current Surface (CS)
	pSurface = &(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx]);
	// NewPitch = OldPitch
	dwSrcPitch = pSurface->dwPitch;	// interleaved
	// if autoflip, TS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
	if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
		nTargetSurfId = pSurface->nNextSurfaceIdx;

#if 0
	if (pVPEContext->dwVPFlags & DDVP_SKIPEVENFIELDS)
	{
		if (nFieldId == NVP_FIELD_EVEN)
		{
			// VP minimum programming to issue an interrupt at end of field !
			NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, FALSE);
			return NO_ERROR;
		}
	}
	else if (pVPEContext->dwVPFlags & DDVP_SKIPODDFIELDS)
	{
		if (nFieldId == NVP_FIELD_ODD)
		{
			// VP minimum programming to issue an interrupt at end of field !
			NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, FALSE);
			return NO_ERROR;
		}
	}
	else
#endif
	{
		// double pitch (interleaved data)
		dwSrcPitch = 2*dwSrcPitch;
		if (nFieldId == NVP_FIELD_ODD)
		{
			// Invert Polarity ?!
			if (pVPEContext->dwVPConFlags & DDVPCONNECT_INVERTPOLARITY)
			{
				// change vp grab offset one line down
				dwOffset = pSurface->dwPitch;
			}
		}
		else
		{
			// Invert Polarity ?!
			// for the even field (bottom) shift down overlay destination if invert polarity flag is not set !
			if (!(pVPEContext->dwVPConFlags & DDVPCONNECT_INVERTPOLARITY))
			{
				dwOffset = pSurface->dwPitch;

			}
		}

	}

	if (!((pVPEContext->dwVPFlags & DDVP_SKIPEVENFIELDS) && (nFieldId == NVP_FIELD_EVEN)) &&
		!((pVPEContext->dwVPFlags & DDVP_SKIPODDFIELDS) && (nFieldId == NVP_FIELD_ODD)))
	{
		// Overlay Image n from CS
		NVPScheduleOverlayFlip(pVPEContext,	pSurface, nImage, dwSrcPitch, dwOffset);
		// NVPScheduleOverlayFlip(pVPEContext, pSurface, nImage ^ 1, dwSrcPitch, dwOffset);
	}

	// whole frame captured ?!
	if (pSurface->bIsFirstFieldCaptured)
	{
		pSurface->bIsFirstFieldCaptured = FALSE;	// reset (for the next time)
		// if autoflip, CS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
		if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
			pVPEContext->nVidSurfIdx = pSurface->nNextSurfaceIdx;
	}
	else
		pSurface->bIsFirstFieldCaptured = TRUE;	// for the next time

	// Grab Image n in TS
	pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfId]);
	NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, dwOffset, TRUE);

	return NO_ERROR;
}

/*
==============================================================================
	
	DoBob

	Description:	use bob from non-interleaved input to display video

	Date:			Mar 08, 1999
	
	Author:			H. Azar

==============================================================================
*/
VP_STATUS DoBob(
	PNVP_CONTEXT pVPEContext,
	int nFieldId)
{
	PNVP_SURFACE_INFO pSurface;
	int nTargetSurfId = pVPEContext->nVidSurfIdx;
	U032 dwSrcPitch;
	int nImage = nFieldId;

	pSurface = &(pVPEContext->aVideoSurfaceInfo[pVPEContext->nVidSurfIdx]);
	dwSrcPitch = pSurface->dwPitch;
#if 0
	if (pVPEContext->dwVPFlags & DDVP_SKIPEVENFIELDS)
	{
		if (nFieldId == NVP_FIELD_EVEN)
		{
			// VP minimum programming to issue an interrupt at end of field !
			// TS = next2(CS)
			nTargetSurfId = pVPEContext->aVideoSurfaceInfo[pSurface->nNextSurfaceIdx].nNextSurfaceIdx;
			pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfaceId]);
			NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, TRUE);
			return NO_ERROR;
		}
		else
			// TS = next(CS)
			nTargetSurfId = pSurface->nNextSurfaceIdx;
	}
	else if (pVPEContext->dwVPFlags & DDVP_SKIPODDFIELDS)
	{
		if (nFieldId == NVP_FIELD_ODD)
		{
			// VP minimum programming to issue an interrupt at end of field !
			nTargetSurfId = pVPEContext->aVideoSurfaceInfo[pSurface->nNextSurfaceIdx].nNextSurfaceIdx;
			pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfaceId]);
			NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, TRUE);
			return NO_ERROR;
		}
		else
			// TS = next(CS)
			nTargetSurfId = pSurface->nNextSurfaceIdx;
	}
	else
#endif
	{
		// if autoflip, TS = next2(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
		if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
			nTargetSurfId = pVPEContext->aVideoSurfaceInfo[pSurface->nNextSurfaceIdx].nNextSurfaceIdx;
	}

	if (!((pVPEContext->dwVPFlags & DDVP_SKIPEVENFIELDS) && (nFieldId == NVP_FIELD_EVEN)) &&
		!((pVPEContext->dwVPFlags & DDVP_SKIPODDFIELDS) && (nFieldId == NVP_FIELD_ODD)))
	{
		// Overlay Image n from CS
		NVPScheduleOverlayFlip(pVPEContext,	pSurface, nImage, dwSrcPitch, 0);
	}

	// if autoflip, CS = next(CS)    (otherwise stay within the same surface until VideoPortFlip is called !!!)
	if (pVPEContext->dwVPFlags & DDVP_AUTOFLIP)
		pVPEContext->nVidSurfIdx = pSurface->nNextSurfaceIdx;

	// Grab Image n in TS
	pSurface = &(pVPEContext->aVideoSurfaceInfo[nTargetSurfId]);
	NVPProgVideoField(pVPEContext, pSurface, nImage, dwSrcPitch, 0, TRUE);

	return NO_ERROR;
}

/*
==============================================================================
	
	NVPTransfer

	Description:	transfers content of video or vbi field to specified
					buffer (usually system memory buffer)

	Date:			Mar 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVPTransfer(
	PVOID pContext, 
	PDDTRANSFERININFO pInInfo, 
	PDDTRANSFEROUTINFO pOutInfo)
{
	PNVP_CONTEXT pVPEContext;
	PNVP_TRANSFER_BUFFER pTransfer;
	PNVP_SURFACE_INFO pSurface = NULL;
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pContext;
	BOOL bVal;
	int i;

	VideoDebugPrint((3,"VPEMINI: NVPTransfer()\n"));

	// get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
	pVPEContext = &(pHwDevExt->avpContexts[0]);

	if (pInInfo->dwTransferFlags & DDTRANSFER_NONLOCALVIDMEM)
		return DXERR_UNSUPPORTED;
	
	// we DO handle cancels for transfer buffers not "in progress" !
	if (pInInfo->dwTransferFlags & DDTRANSFER_CANCEL)
		return NVPCancelTransfer(pVPEContext, pInInfo);

	// determine polarity, TRUE for Even, FALSE for Odd !
	NVPGetSurface(pVPEContext, ((DDSURFACEDATA*) pInInfo->lpSurfaceData)->dwSurfaceOffset, &pSurface);
	if ((pSurface != NULL) && (pSurface->dwFieldType == NVP_FIELD_ODD))
		pOutInfo->dwBufferPolarity = FALSE;
	else
		pOutInfo->dwBufferPolarity = TRUE;
	
	// queue request
	if (NVPAddTransfer(pVPEContext, pInInfo, !(pOutInfo->dwBufferPolarity)))
		return DXERR_GENERIC;

	if (pVPEContext->nCurTransferIdx != -1)
	{
		pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);
		// Recreate context dma for MDL
		NVPRecreateContext(pVPEContext, (PMDL)(pTransfer->pDestMDL));
	}

	return DX_OK;
}

/*
==============================================================================
	
	NVPGetSurface

	Description:	looks for surface that has the specified offset. pSurface
					is set to NULL if no surface is found.


	Date:			Mar 18, 1999
	
	Author:			H. Azar

==============================================================================
*/
BOOL NVPGetSurface(
	PNVP_CONTEXT pVPEContext,
	U032 dwSurfOffset,
	PNVP_SURFACE_INFO *pSurface)
{
	int i;

	VideoDebugPrint((3,"VPEMINI: NVPGetSurface()\n"));

	*pSurface = NULL;

	// why VBI first ! well, this is most probably what we're transfering... kinda optimization !
	for (i = 0; i < pVPEContext->nNumVBISurf; i++)
	{
		if (pVPEContext->aVBISurfaceInfo[i].dwOffset == dwSurfOffset)
		{
			*pSurface = &(pVPEContext->aVBISurfaceInfo[i]);
			return FALSE;	// FALSE means VBI
		}
	}

	for (i = 0; i < pVPEContext->nNumVidSurf; i++)
	{
		if (pVPEContext->aVideoSurfaceInfo[i].dwOffset == dwSurfOffset)
		{
			*pSurface = &(pVPEContext->aVideoSurfaceInfo[i]);
			return TRUE;	// TRUE means VIDEO
		}
	}

	return FALSE;	// return something ! (pSurface is NULL anyway)
}

/*
==============================================================================
	
	NVP3RecreateContext

	Description:	if necessary, create context DMA for mem to mem object
					PIO channel version.

	Date:			Mar 18, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVP3RecreateContext(
	PNVP_CONTEXT pVPEContext,
	PMDL pDestMDL) 
{
	Nv03ChannelPio *pChan;
	NVOS09_PARAMETERS ntfParam;
	U032 dwStart;
	U032 dwLimit;
	int nFreeCount;

	pChan = (Nv03ChannelPio *)(pVPEContext->pNVPChannel);

	// first check to see if we can reuse the OLD context... since context creation is expensive.
	dwStart = (U032)(pDestMDL->lpMappedSystemVa);
	dwLimit = (pDestMDL->ByteCount) - 1;
	
	if (pVPEContext->bxfContextCreated)
	{
		// do not recreate if same context
		if ((dwStart == pVPEContext->dwTransferCtxStart) && (dwLimit == pVPEContext->dwTransferCtxSize))
			return DX_OK;
	}

#ifdef _NV_DPC
	// FIFO free count check up
	ntfParam.hObjectParent = pVPEContext->dwDeviceId;
	nFreeCount = pVPEContext->nFreeCount;
	while (nFreeCount < 4*4) 
	{
		//RmInterrupt(&ntfParam);
		nFreeCount = NvGetFreeCount(pChan, 5);
	}
	pVPEContext->nFreeCount = nFreeCount - (4*4);
#endif

	// free the old context first
	if (pVPEContext->bxfContextCreated)
	{
		pChan->subchannel[5].SetObject = NVP_M2M_OBJECT;
		pChan->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferOut = 0;
#ifdef _NV_DPC
		// Do a software method flush here
		ntfParam.hObjectParent = pVPEContext->dwDeviceId;
		nFreeCount = pVPEContext->nFreeCount;
		while (nFreeCount < NV06A_FIFO_GUARANTEED_SIZE) 
		{
			//RmInterrupt(&ntfParam);
			nFreeCount = NvGetFreeCount(pChan, 5);
		}
		pVPEContext->nFreeCount = nFreeCount - NV06A_FIFO_GUARANTEED_SIZE;
#endif
		RmFree(pVPEContext->hClient, pVPEContext->dwDeviceId, NVP_M2M_CONTEXT);

		pVPEContext->bxfContextCreated = FALSE;
	}
	
	// setup Notify Context
	if (RmAllocContextDma(
					pVPEContext->hClient,
	         		NVP_M2M_CONTEXT,
	         		NV01_CONTEXT_DMA_FROM_MEMORY,
	         		0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
					0, // selector
	         		dwStart,
	         		dwLimit) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate mem 2 mem context\n"));
		return DXERR_GENERIC;
	}

	// set context of M2M object
	pChan->subchannel[5].SetObject  = NVP_M2M_OBJECT;
	pChan->subchannel[5].nv03MemoryToMemoryFormat.SetContextDmaBufferOut = NVP_M2M_CONTEXT;

	pVPEContext->dwTransferCtxStart = dwStart;
	pVPEContext->dwTransferCtxSize = dwLimit;
	pVPEContext->bxfContextCreated = TRUE;

	return DX_OK;
}

/*
==============================================================================
	
	NVP3CheckForLaunch

	Description:	try to launch another mem transfer if engine not busy
					(PIO version)

	Date:			Mar 18, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVP3CheckForLaunch(
	PNVP_CONTEXT pVPEContext,
	PNVP_SURFACE_INFO pSurface)
{
	Nv03ChannelPio *pChan;
	PNVP_TRANSFER_BUFFER pTransfer;
	LPDDSURFACEDATA pSurfaceData;
	NVOS09_PARAMETERS ntfParam;
	NvNotification *aM2MNotifiers;
	PMDL pDestMDL;
	U032 dwOffsetStartByte;
	LONG lLength, lPitch, lCount;
	int nFreeCount;
	PNVP_SURFACE_INFO pSurf = NULL;

	VideoDebugPrint((3,"VPEMINI: NVP3CheckForLaunch()\n"));

	aM2MNotifiers = (NvNotification *)(pVPEContext->axfNotifiers);

	// is transfer in progress ?
	if ((aM2MNotifiers[NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV039_NOTIFICATION_STATUS_IN_PROGRESS) ||
		// or no transfer request !?
		(pVPEContext->nCurTransferIdx == -1))
		return DXERR_GENERIC;

	// get a pointer to the VP pio channel
	pChan = (Nv03ChannelPio *)(pVPEContext->pNVPChannel);
	// which surface are we transferring from ?
	pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);
	pSurfaceData = (LPDDSURFACEDATA) (pTransfer->pSurfaceData);
	if (pSurface == NULL)
	{
		NVPGetSurface(pVPEContext, pSurfaceData->dwSurfaceOffset, &pSurf);
		if (pSurf == NULL)
		{
			VideoDebugPrint((0,"VPEMINI: NVPCheckForLaunch() can't get pointer to surface\n"));
			return DXERR_GENERIC;
		}
	}
	else
		pSurf = pSurface;

	// Recreate context dma for MDL
	NVPRecreateContext(pVPEContext, (PMDL)(pTransfer->pDestMDL));
	
	// reset notifier status
	aM2MNotifiers[NV039_NOTIFIERS_BUFFER_NOTIFY].status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;

#ifdef _NV_DPC
	//CHECKFREECOUNT(pMyNvChan,9*4);
	ntfParam.hObjectParent = pVPEContext->dwDeviceId;
	nFreeCount = pVPEContext->nFreeCount;
	while (nFreeCount < 9*4) 
	{
		//RmInterrupt(&ntfParam);
		nFreeCount = NvGetFreeCount(pChan, 5);
	}
	pVPEContext->nFreeCount = nFreeCount - (9*4);
#endif

	// start at given line
	dwOffsetStartByte = pSurfaceData->dwSurfaceOffset + (pSurfaceData->lPitch * pTransfer->lStartLine);

	// lLength and lPitch might not be the same (case of interleaved fields !!!)
	lLength = (pSurfaceData->dwWidth)*(pSurfaceData->dwFormatBitCount >> 3);
	lPitch = pSurfaceData->lPitch;
			
	// SMAC@microsoft.com  :  Yes, you should transfer the end line.  
	// Therefore, if we only wanted you to transfer a single line, start line would equal end line.	
	lCount = (pTransfer->lEndLine - pTransfer->lStartLine + 1);
	if (pTransfer->dwTransferFlags & DDTRANSFER_INVERT)
	{
		// if we want to invert things, then we should 
		// negate the pitch and put the start offset at the end.
		
		dwOffsetStartByte = dwOffsetStartByte + lPitch * (lCount - 1);
		lPitch = -lPitch;
	}

	pDestMDL = (PMDL)(pTransfer->pDestMDL);
	if (pDestMDL->ByteCount < (ULONG)(lLength * lCount))
	{ 
		VideoDebugPrint((0,"VPEMINI: NVPCheckForLaunch() - Destination memory is not large enough to hold this image, truncating line count\n"));
	//	lCount = (pTransfer->pDestMDL->ByteCount + pTransfer->pDestMDL->ByteOffset) / lLength;
		lCount = pDestMDL->ByteCount / lLength;
	}

#ifdef _NV_DPC
	ntfParam.hObjectParent = pVPEContext->dwDeviceId;
	nFreeCount = pVPEContext->nFreeCount;
	while (nFreeCount < 8*4) 
	{
		//RmInterrupt(&ntfParam);
		nFreeCount = NvGetFreeCount(pChan, 5);
	}
	pVPEContext->nFreeCount = nFreeCount - (8*4);
#endif

	// set mem to mem transfer object !
	pChan->subchannel[NVP_M2M_SUBCHANNEL].SetObject = NVP_M2M_OBJECT;
	pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.OffsetIn	= dwOffsetStartByte;
	//pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.OffsetOut = (unsigned long)pTheTransfer->DestMDL->ByteOffset;
	pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.OffsetOut = 0;
	pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.PitchIn	= lPitch;	// use the pitch in so that we can do interleaved
	pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.PitchOut	= lLength;  // use line length on pitch out so that it squishes together
	pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.LineLengthIn = lLength; 
	
	pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.LineCount 	= lCount;
	pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.Format 		=  ( 1 | (1 << 8));
	pChan->subchannel[NVP_M2M_SUBCHANNEL].nv03MemoryToMemoryFormat.BufferNotify = NV039_NOTIFY_WRITE_THEN_AWAKEN_1;

	pTransfer->dwTransferStatus = NVP_TRANSFER_IN_PROGRESS;

	return DX_OK;
}

/*
==============================================================================
	
	NVPRecreateContext

	Description:	if necessary, create context DMA for mem to mem object
					(DMA version)

	Date:			Apr 22, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVPRecreateContext(
	PNVP_CONTEXT pVPEContext,
	PMDL pDestMDL) 
{
	U032 dwStart;
	U032 dwLimit;

	// NV3 specific code
	if (NVP_GET_CHIP_VER(pVPEContext->dwChipId) <= NVP_CHIP_VER_03)
		return NVP3RecreateContext(pVPEContext, pDestMDL);

	// first check to see if we can reuse the OLD context... since context creation is expensive.
	dwStart = (U032)(pDestMDL->lpMappedSystemVa);
	dwLimit = (pDestMDL->ByteCount) - 1;
	
	if (pVPEContext->bxfContextCreated)
	{
		// do not recreate if same context
		if ((dwStart == pVPEContext->dwTransferCtxStart) && (dwLimit == pVPEContext->dwTransferCtxSize))
			return DX_OK;
	}

	// free the old context first
	if (pVPEContext->bxfContextCreated)
	{
		// free m2m dma context
		RmFree(pVPEContext->hClient, pVPEContext->dwDeviceId, NVP_M2M_CONTEXT);

		pVPEContext->bxfContextCreated = FALSE;
	}
	
	// setup Notify Context
	if (RmAllocContextDma(
					pVPEContext->hClient,
	         		NVP_M2M_CONTEXT,
	         		NV01_CONTEXT_DMA_FROM_MEMORY,
	         		0, //(ALLOC_CTX_DMA_FLAGS_ACCESS_RD_WR | ALLOC_CTX_DMA_FLAGS_COHERENCY_UNCACHED),
					0, // selector
	         		dwStart,
	         		dwLimit) != 0) //ALLOC_CTX_DMA_STATUS_SUCCESS)
	{
    	VideoDebugPrint((0,"VPEMINI: Cannot allocate mem 2 mem context\n"));
		return DXERR_GENERIC;
	}

	pVPEContext->dwTransferCtxStart = dwStart;
	pVPEContext->dwTransferCtxSize = dwLimit;
	pVPEContext->bxfContextFlushed = FALSE;
	pVPEContext->bxfContextCreated = TRUE;

	return DX_OK;
}

/*
==============================================================================
	
	NVPCheckForLaunch

	Description:	try to launch another mem transfer if engine not busy
					(DMA version)

	Date:			Apr 22, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVPCheckForLaunch(
	PNVP_CONTEXT pVPEContext,
	PNVP_SURFACE_INFO pSurface)
{
	PNVP_TRANSFER_BUFFER pTransfer;
	LPDDSURFACEDATA pSurfaceData;
	NvNotification *aM2MNotifiers;
	PMDL pDestMDL;
	U032 dwOffsetStartByte;
	LONG lLength, lPitch, lCount;
	PNVP_SURFACE_INFO pSurf = NULL;
	Nv4ControlDma *pDmaChannel;
	U032 nvDmaCount;

	// NV3 specific code
	if (NVP_GET_CHIP_VER(pVPEContext->dwChipId) <= NVP_CHIP_VER_03)
		return NVP3CheckForLaunch(pVPEContext, pSurface);

//	VideoDebugPrint((3,"VPEMINI: NVPCheckForLaunch()\n"));

	aM2MNotifiers = (NvNotification *)(pVPEContext->axfNotifiers);

	// is transfer in progress ?
	if (aM2MNotifiers[NV039_NOTIFIERS_BUFFER_NOTIFY].status == NV039_NOTIFICATION_STATUS_IN_PROGRESS)
		return DXERR_GENERIC;

	// or no transfer request !?
	if ((pVPEContext->nCurTransferIdx == -1) || !(pVPEContext->bxfContextCreated))
	{
		return DXERR_GENERIC;
	}

	// which surface are we transferring from ?
	pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);
	pSurfaceData = (LPDDSURFACEDATA) (pTransfer->pSurfaceData);
	if (pSurface == NULL)
	{
		NVPGetSurface(pVPEContext, pSurfaceData->dwSurfaceOffset, &pSurf);
		if (pSurf == NULL)
		{
			VideoDebugPrint((0,"VPEMINI: NVPCheckForLaunch() can't get pointer to surface\n"));
			return DXERR_GENERIC;
		}
	}
	else
		pSurf = pSurface;

	// reset notifier status
	aM2MNotifiers[NV039_NOTIFIERS_BUFFER_NOTIFY].status = NV039_NOTIFICATION_STATUS_IN_PROGRESS;

	// start at given line
	dwOffsetStartByte = pSurfaceData->dwSurfaceOffset + (pSurfaceData->lPitch * pTransfer->lStartLine);

	// lLength and lPitch might not be the same (case of interleaved fields !!!)
	lLength = (pSurfaceData->dwWidth)*(pSurfaceData->dwFormatBitCount >> 3);
	lPitch = pSurfaceData->lPitch;
			
	// SMAC@microsoft.com  :  Yes, you should transfer the end line.  
	// Therefore, if we only wanted you to transfer a single line, start line would equal end line.	
	lCount = (pTransfer->lEndLine - pTransfer->lStartLine + 1);
	if (pTransfer->dwTransferFlags & DDTRANSFER_INVERT)
	{
		// if we want to invert things, then we should 
		// negate the pitch and put the start offset at the end.
		
		dwOffsetStartByte = dwOffsetStartByte + lPitch * (lCount - 1);
		lPitch = -lPitch;
	}

	pDestMDL = (PMDL)(pTransfer->pDestMDL);
	if (pDestMDL->ByteCount < (ULONG)(lLength * lCount))
	{ 
		VideoDebugPrint((0,"VPEMINI: NVPCheckForLaunch() - Destination memory is not large enough to hold this image, truncating line count\n"));
	//	lCount = (pTransfer->pDestMDL->ByteCount + pTransfer->pDestMDL->ByteOffset) / lLength;
		lCount = pDestMDL->ByteCount / lLength;
	}

	// get a pointer to the VPE dma channel
	pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;
	NVP_DMAPUSH_CHECK_FREE_COUNT(20);

	NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_OBJECT, NVP_M2M_OBJECT);
	NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_SET_CONTEXT_DMA_BUFFER_OUT, NVP_M2M_CONTEXT);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_OFFSET_IN, dwOffsetStartByte);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_OFFSET_OUT, 0);	//(unsigned long)pTransfer->DestMDL->ByteOffset
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_PITCH_IN, lPitch);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_PITCH_OUT, lLength);

    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_LINE_LENGTH_IN, lLength);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_LINE_COUNT, lCount);
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_FORMAT, ( 1 | (1 << 8)));
    NVP_DMAPUSH_WRITE1(NVP_M2M_SUBCHANNEL, NV039_BUFFER_NOTIFY, NV039_NOTIFY_WRITE_THEN_AWAKEN_1);

	pTransfer->dwTransferStatus = NVP_TRANSFER_IN_PROGRESS;
	// go !
    pDmaChannel->Put = nvDmaCount << 2;
	pVPEContext->nvDmaCount = nvDmaCount;

	return DX_OK;
}


/*
==============================================================================
	
	NVPGetTransferStatus

	Description:	returns status of buffer transfer (from video mem to 
					system mem)

	Date:			Mar 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVPGetTransferStatus(
	PVOID pContext, 
	PVOID pNotUsed, 
	PDDGETTRANSFEROUTINFO pOutInfo)
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION)pContext;
	PNVP_TRANSFER_BUFFER pTransfer;
	PNVP_CONTEXT pVPEContext;

//	VideoDebugPrint((3,"VPEMINI: NVPGetTransferStatus()\n"));

	// get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
	pVPEContext = &(pHwDevExt->avpContexts[0]);

	if (pVPEContext->nRecentTransferIdx == NVP_EOQ)
		return DXERR_GENERIC;

	pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nRecentTransferIdx]);

	if (pTransfer->dwTransferStatus == NVP_TRANSFER_DONE)
	{
		// return MS transfer ID
		pOutInfo->dwTransferID = pTransfer->dwTransferId;
		NVPRemoveTransfer(pVPEContext, pVPEContext->nRecentTransferIdx);

	}
	else 
		return DXERR_GENERIC;

	return DX_OK;
}

/*
==============================================================================
	
	NVPAddTransfer

	Description:	adds transfer buffer to queue

	Date:			Mar 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVPAddTransfer(
	PNVP_CONTEXT pVPEContext,
	PDDTRANSFERININFO pInInfo,
	BOOL bIsOddField)
{
	PNVP_TRANSFER_BUFFER pNewTransfer;
	int i = pVPEContext->nCurTransferIdx;

	VideoDebugPrint((3,"VPEMINI: NVPAddTransfer()\n"));

	if (pVPEContext->nNumTransfer >= NVP_MAX_TRANSFER_BUFFERS)
		return DXERR_GENERIC;
	
	while (i != NVP_EOQ)
	{
		if (pVPEContext->aTransferBuffers[i].dwTransferId == pInInfo->dwTransferID)
			// a transfer request with same ID is already queued !!!
			return DXERR_GENERIC;
		else 
			i = pVPEContext->aTransferBuffers[i].nNextTransferIdx;
	}

		
	// queue new transfer request !
	i = pVPEContext->nLastTransferIdx;
	pVPEContext->nLastTransferIdx = ++(pVPEContext->nLastTransferIdx) % NVP_MAX_TRANSFER_BUFFERS;
	pNewTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nLastTransferIdx]);
	if (i != NVP_EOQ)
		pVPEContext->aTransferBuffers[i].nNextTransferIdx = pVPEContext->nLastTransferIdx;
	pNewTransfer->nNextTransferIdx = NVP_EOQ;
	pNewTransfer->nPrevTransferIdx = i;
	(pVPEContext->nNumTransfer)++;
	if (pVPEContext->nCurTransferIdx == NVP_EOQ)
		pVPEContext->nCurTransferIdx = pVPEContext->nLastTransferIdx;

    // DDTRANSFER_HALFLINES indicates that, due to half line issues, the odd field contains an 
    // extra line of useless data at the top that the driver must account for
	if ((pInInfo->dwTransferFlags & DDTRANSFER_HALFLINES) && (bIsOddField))
	{
		pNewTransfer->lStartLine = (LONG)(pInInfo->dwStartLine) + 1;
		pNewTransfer->lEndLine = (LONG)(pInInfo->dwEndLine) + 1;
	} 
	else 
	{
		pNewTransfer->lStartLine = (LONG)(pInInfo->dwStartLine);
		pNewTransfer->lEndLine = (LONG)(pInInfo->dwEndLine);
	}

	// copy input data...
	pNewTransfer->pSurfaceData = (ULONG) (pInInfo->lpSurfaceData);
	pNewTransfer->dwTransferId = pInInfo->dwTransferID;
	pNewTransfer->dwTransferFlags = pInInfo->dwTransferFlags;
	pNewTransfer->pDestMDL = (ULONG) (pInInfo->lpDestMDL);
	pNewTransfer->dwTransferStatus = NVP_TRANSFER_QUEUED;

	return DX_OK;
}


/*
==============================================================================
	
	NVPCancelTransfer

	Description:	cancels transfer request before it gets processed 

	Date:			Mar 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVPCancelTransfer(
	PNVP_CONTEXT pVPEContext,
	PDDTRANSFERININFO pInInfo)
{
	PNVP_TRANSFER_BUFFER pTransfer = NULL;
	int i = pVPEContext->nCurTransferIdx;

	VideoDebugPrint((3,"VPEMINI: NVPCancelTransfer()\n"));

	// look for transfer in queue
	while (i != NVP_EOQ)
	{
		if (pVPEContext->aTransferBuffers[i].dwTransferId == pInInfo->dwTransferID)
		{
			pTransfer = &(pVPEContext->aTransferBuffers[i]);
			break;
		}
		i = pVPEContext->aTransferBuffers[i].nNextTransferIdx;
	}

	if ((pTransfer) && (pTransfer->dwTransferStatus == NVP_TRANSFER_QUEUED))
		return NVPRemoveTransfer(pVPEContext, i);
	else
		return DXERR_GENERIC;
}

/*
==============================================================================
	
	NVPRemoveTransfer

	Description:	removes transfer request from queue

	Date:			Mar 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVPRemoveTransfer(
	PNVP_CONTEXT pVPEContext,
	int nTransferIdx)
{
	PNVP_TRANSFER_BUFFER pTransfer = &(pVPEContext->aTransferBuffers[nTransferIdx]);

	VideoDebugPrint((3,"VPEMINI: NVPRemoveTransfer()\n"));

	// check limits
	if (nTransferIdx == pVPEContext->nCurTransferIdx)
		pVPEContext->nCurTransferIdx = pTransfer->nNextTransferIdx;
	else if (nTransferIdx == pVPEContext->nLastTransferIdx)
		pVPEContext->nLastTransferIdx = pTransfer->nPrevTransferIdx;
	// reset values
	pTransfer->dwTransferId = NVP_UNDEF;
	pTransfer->dwTransferStatus = NVP_TRANSFER_FREE;
	// re-map indices
	if (pTransfer->nPrevTransferIdx != NVP_EOQ)
	{
		pVPEContext->aTransferBuffers[pTransfer->nPrevTransferIdx].nNextTransferIdx = pTransfer->nNextTransferIdx;
		pTransfer->nPrevTransferIdx = NVP_EOQ;
	}
	if (pTransfer->nNextTransferIdx != NVP_EOQ)
	{
		pVPEContext->aTransferBuffers[pTransfer->nNextTransferIdx].nPrevTransferIdx = pTransfer->nPrevTransferIdx;
		pTransfer->nNextTransferIdx = NVP_EOQ;
	}

	// one down !
	(pVPEContext->nNumTransfer)--;

	return DX_OK;
}
	

/*
==============================================================================
	
	NVPCheckTransferStatus

	Description:	checks for transfer status. Calls MS callback. 

	Date:			Mar 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
DWORD NVPCheckTransferStatus(
	PHW_DEVICE_EXTENSION pHwDevExt)
{
	NvNotification *aM2MNotifiers;
	PNVP_CONTEXT pVPEContext;
	PDX_IRQDATA pIRQData;
	PNVP_TRANSFER_BUFFER pTransfer;
	U032 status;

	VideoDebugPrint((3,"VPEMINI: NVPCheckTransferStatus()\n"));

	// get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
	pVPEContext = &(pHwDevExt->avpContexts[0]);

	aM2MNotifiers = (NvNotification *)(pVPEContext->axfNotifiers);

	status = aM2MNotifiers[NV039_NOTIFIERS_BUFFER_NOTIFY].status;
	
	if (status == NV039_NOTIFICATION_STATUS_IN_PROGRESS)
		// still in progress
		return FALSE;
	else if (status == NV039_NOTIFICATION_STATUS_DONE_SUCCESS)
	{
		pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);

		// finished ok!
		if (pTransfer->dwTransferStatus == NVP_TRANSFER_IN_PROGRESS)
			pTransfer->dwTransferStatus = NVP_TRANSFER_DONE;

		pVPEContext->nRecentTransferIdx = pVPEContext->nCurTransferIdx;
	} 
	else
	{
		VideoDebugPrint((0,"VPEMINI: NVPCheckTransferStatus() - memory transfer failed error %d\n", status));

		pTransfer = &(pVPEContext->aTransferBuffers[pVPEContext->nCurTransferIdx]);

		// finished with an error !
		if (pTransfer->dwTransferStatus == NVP_TRANSFER_IN_PROGRESS)
			pTransfer->dwTransferStatus = NVP_TRANSFER_FAILURE;

	}

	// move to next transfer in queue (*** not sure whether I should do this even when an error had occured ?!?!?!?)
	pVPEContext->nCurTransferIdx = pTransfer->nNextTransferIdx;

	// we pass on the interrupt
	if (pHwDevExt->IRQCallback) //&& (pHwDevExt->dwIRQSources & DDIRQ_BUSMASTER))
	{
		pIRQData = (PDX_IRQDATA)(pHwDevExt->pIRQData);
		pIRQData->dwIrqFlags |= DDIRQ_BUSMASTER;
		((PDX_IRQCALLBACK)(pHwDevExt->IRQCallback))(pIRQData);
	}
	
	return DX_OK;
}

/*
==============================================================================
	
	NVPTransferNotify

	Description:	checks for transfer status. Calls MS callback. 

	Date:			Mar 16, 1999
	
	Author:			H. Azar

==============================================================================
*/
void NVPTransferNotify(
	PVOID pHwDevExtension)
{
	PHW_DEVICE_EXTENSION pHwDevExt = (PHW_DEVICE_EXTENSION) pHwDevExtension;
	PNVP_CONTEXT pVPEContext;

	// call MS callback if done with transfer
	if (NVPCheckTransferStatus(pHwDevExt) == DX_OK)
	{
		// get a pointer to the appropriate VPE context (BUGBUG: use index 0 for now !!!)
		pVPEContext = &(pHwDevExt->avpContexts[0]);
		//  transfer next in queue !
//		NVPCheckForLaunch(pVPEContext, NULL);
	}
}




//---------------------------------------------------------------------------
// vddPreScale
//      Prescales YUV422 surface.  The new width and height are returned.  If
//      this routine does the field prescaling, it flips off the field flags
//      to indicate that the flip should not bob.
//

BOOL NVPPreScale(
    PNVP_CONTEXT  pVPEContext, 
	PNVP_OVERLAY  pOverlayInfo,
    DWORD         dwSrcOffset, 
    DWORD         dwSrcPitch,
    DWORD         dwDstOffset, 
    DWORD         dwDstPitch,
    DWORD         *pWidth, 
    DWORD         *pHeight,
    DWORD         *pField)
{
    DWORD preScaleDeltaX;
    DWORD preScaleDeltaY;
    DWORD preScaleOverlay;
    DWORD dwDeltaX, dwDeltaY;
    DWORD dwOutSizeX, dwOutSizeY, dwOutFormat;
    DWORD dwInPitch, dwInOffset, dwInPoint, dwInSize;
    BOOL isField;
	Nv4ControlDma *pDmaChannel;
	U032 nvDmaCount;

    if (pOverlayInfo->dwOverlayDstWidth == 0 ||
        pOverlayInfo->dwOverlayDstHeight == 0)
        return FALSE;

    isField = IS_FIELD(*pField);

    if (pOverlayInfo->dwOverlayDstWidth <= 1) 
    {
        dwDeltaX = 0x100000;
	}
	else
	{
	    dwDeltaX = (pOverlayInfo->dwOverlaySrcWidth - 1) << 16;
	    dwDeltaX /= pOverlayInfo->dwOverlayDstWidth - 1;
	    dwDeltaX <<= 4;
	}

    if (pOverlayInfo->dwOverlayDstHeight <= 1) 
    {
        dwDeltaY = 0x100000;
	}
	else
	{
	    dwDeltaY = (pOverlayInfo->dwOverlaySrcHeight - 1) << 16; //(*pHeight - 1) << 16; //
	    // err on the side of caution, need to do this because of the 1/4 pixel offset
	    // ????? why is NV4 different from NV5?  NV4 HW must be a little wonky
	    if (pVPEContext->dwChipId <= NV_DEVICE_VERSION_4) {
	        dwDeltaY /= pOverlayInfo->dwOverlayDstHeight + 2;
	    } else {
	        dwDeltaY /= pOverlayInfo->dwOverlayDstHeight + 1;
	    }
	    dwDeltaY <<= 4;
    }

    preScaleOverlay = 0;

    if (pOverlayInfo->dwOverlaySrcWidth > (pOverlayInfo->dwOverlayDstWidth * pOverlayInfo->dwOverlayMaxDownScale)) 
    {
        // use X prescaler
        preScaleOverlay |= NV_PRESCALE_OVERLAY_X;
        dwOutSizeX = (pOverlayInfo->dwOverlayDstWidth + 2) & ~1;
        preScaleDeltaX = dwDeltaX;
        pOverlayInfo->dwOverlayDeltaX = 0x100000;
    } else {
        // use X overlay scaler
        dwOutSizeX = (*pWidth + 2) & ~1;
        preScaleDeltaX = 0x100000;
        pOverlayInfo->dwOverlayDeltaX = dwDeltaX;
    }

    if (pOverlayInfo->dwOverlaySrcHeight > (pOverlayInfo->dwOverlayDstHeight * pOverlayInfo->dwOverlayMaxDownScale))
	{
        // use Y prescaler
        preScaleOverlay |= NV_PRESCALE_OVERLAY_Y;
        dwOutSizeY = pOverlayInfo->dwOverlayDstHeight;
        preScaleDeltaY = dwDeltaY;
        pOverlayInfo->dwOverlayDeltaY = 0x100000;
    } 
    else 
    {
        // use Y overlay scaler
        dwOutSizeY = *pHeight;
        preScaleDeltaY = 0x100000;
        pOverlayInfo->dwOverlayDeltaY = dwDeltaY;
    }

    if ((pVPEContext->dwChipId < NV_DEVICE_VERSION_10) || (preScaleOverlay & NV_PRESCALE_OVERLAY_Y)) 
    {
        if (isField) 
        {
            preScaleOverlay |= NV_PRESCALE_OVERLAY_FIELD;
            if (*pField & VPP_INTERLEAVED)
                preScaleDeltaY >>= 1;
        }
    }

    if (preScaleOverlay == 0)
        return FALSE;

    dwInSize = asmMergeCoords(*pWidth, *pHeight);
    dwInPoint = 0;
    dwInPitch = dwSrcPitch;
    dwInOffset = dwSrcOffset;
    if (isField && (preScaleOverlay & NV_PRESCALE_OVERLAY_FIELD)) {
        if (*pField & VPP_INTERLEAVED) {
            dwInPitch <<= 1;
            *pHeight >>= 1;
            // if (*pField & VPP_ODD) {
            if (*pField & VPP_EVEN) {
                dwInOffset += dwSrcPitch;
            }
        }
        if (*pField & VPP_BOB) {
            // use -1/4, +1/4 biasing for bob fields
            // if (*pField & VPP_ODD) {
            if (*pField & VPP_EVEN) {
                dwInPoint = 0xFFFC0000;
            } else {
                dwInPoint = 0x00040000;
            }
        }
    }

//    if (dwFourCC == FOURCC_UYVY) {
        dwOutFormat = NV038_IMAGE_OUT_FORMAT_COLOR_LE_YB8V8YA8U8;
//    } else {
//        dwOutFormat = NV038_IMAGE_OUT_FORMAT_COLOR_LE_V8YB8U8YA8;
//    }

	pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;
	NVP_DMAPUSH_CHECK_FREE_COUNT(38);

	// program the VP to grab in the next surface
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_OBJECT , NVP_DVD_SUBPICTURE_OBJECT); // pVPEContext->dwDVDSubPicObjectID);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_OUT_POINT, 0);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_OUT_SIZE, (asmMergeCoords(dwOutSizeX, dwOutSizeY)));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_OUT_FORMAT, ((dwOutFormat << 16) | dwDstPitch));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_OUT_OFFSET, dwDstOffset);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_DELTA_DU_DX, preScaleDeltaX);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_DELTA_DV_DY, preScaleDeltaY);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_SIZE, dwInSize);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_FORMAT, ((dwOutFormat << 16) | dwInPitch));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_OFFSET, dwInOffset);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_IMAGE_IN_POINT, dwInPoint);

    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_DELTA_DU_DX, preScaleDeltaX);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_DELTA_DV_DY, preScaleDeltaY);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_SIZE, dwInSize);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_FORMAT, ((NV038_OVERLAY_FORMAT_COLOR_LE_TRANSPARENT << 16) | dwInPitch));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_OFFSET, dwInOffset);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_OVERLAY_POINT, 0);

    //NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_NOTIFY, NV038_NOTIFY_WRITE_THEN_AWAKEN);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_NO_OPERATION, 0);

    // this forces the H/W to serialize
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV038_SET_CONTEXT_DMA_OVERLAY, NVP_DVD_SUBPICTURE_CONTEXT);

//    NVP_DMAPUSH_START();
    pDmaChannel->Put = nvDmaCount << 2;
	pVPEContext->nvDmaCount = nvDmaCount;

    // return changes in state
    if (//(pDriverData->regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE) ||
        (preScaleOverlay & NV_PRESCALE_OVERLAY_FIELD)) {
        // with HQVUp, we no longer use the overlay to bob
        *pField &= ~(VPP_ODD | VPP_EVEN | VPP_BOB | VPP_INTERLEAVED);
    }

    *pHeight = dwOutSizeY;
    *pWidth  = dwOutSizeX;

    return TRUE;
}

//---------------------------------------------------------------------------
// vddFlip
//      Flip to surface.
//

BOOL NVPFlip(
    PNVP_CONTEXT  pVPEContext, 
	PNVP_OVERLAY  pOverlayInfo,
    DWORD         dwOffset,        // source surface offset 
    DWORD         dwPitch,         // source pitch
	DWORD         dwWidth,         // source width
	DWORD         dwHeight,        // source height
    DWORD         dwIndex,         // overlay buffer index
    DWORD         dwFlags)         // VPP flags
{
    NvNotification *pPioFlipOverlayNotifier = (NvNotification *)pOverlayInfo->pNvPioFlipOverlayNotifierFlat;
    DWORD dwPointIn, dwOverlayFormat, dwSizeIn;
    DWORD dwDeltaX, dwDeltaY;
	Nv4ControlDma *pDmaChannel;
	U032 nvDmaCount;

    dwPointIn = (dwOffset & NV_OVERLAY_BYTE_ALIGNMENT_PAD) << 3;  // << 3 insteed of << 4 because YUYV is 2 bytes wide
    dwSizeIn = asmMergeCoords((dwWidth & ~1), (dwHeight & ~1));
    dwSizeIn += dwPointIn;
    dwOffset &= ~NV_OVERLAY_BYTE_ALIGNMENT_PAD;

    // Remember this in case we get a SetOverlayPosition call
    //pOverlayInfo->dwOverlaySrcOffset = dwOffset;
    //pOverlayInfo->dwOverlaySrcPitch = dwPitch;

    dwDeltaX = pOverlayInfo->dwOverlayDeltaX;
    dwDeltaY = pOverlayInfo->dwOverlayDeltaY;

    if (IS_FIELD(dwFlags)) {
        if (dwFlags & VPP_INTERLEAVED) {
            // if (dwFlags & VPP_ODD) { 
            if (dwFlags & VPP_EVEN) {
                dwOffset += dwPitch;
            }
            dwPitch <<= 1;
            dwHeight >>= 1;
            dwDeltaY >>= 1;
        }
        if (dwFlags & VPP_BOB) {
            // if (dwFlags & VPP_ODD) {
            if (dwFlags & VPP_EVEN) {
                dwPointIn += 0xFFFC0000;
            } else {
                dwPointIn += 0x00040000;
            }
        }
    }

    // replace old surface pitch value with current pitch value
    dwOverlayFormat = pOverlayInfo->dwOverlayFormat;
    dwOverlayFormat &= 0xFFFF0000;
    dwOverlayFormat |= dwPitch;
    dwOverlayFormat |= (1 << 31);

/*

    if (pVPEContext->dwVPConnectFlags & NVP_CONNECT_HDTV) // progressive (non-interlaced) and 16bit VIP
        dwOverlayFormat |= (NV07A_SET_OVERLAY_FORMAT_MATRIX_ITURBT709 << 24);
*/
    if (dwIndex & 0x1) {
        pPioFlipOverlayNotifier[2].status = NV_IN_PROGRESS;
    } else {
        pPioFlipOverlayNotifier[1].status = NV_IN_PROGRESS;
    }

	// program overlay to flip
	pDmaChannel = (Nv4ControlDma *)(pVPEContext->pDmaChannel);
    nvDmaCount = pVPEContext->nvDmaCount;
	NVP_DMAPUSH_CHECK_FREE_COUNT(20);

	// program the VP to grab in the next surface
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OBJECT, NVP_OVERLAY_OBJECT); //pOverlayInfo->dwOverlayObjectID);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_SIZE_IN(dwIndex), dwSizeIn);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_SIZE_OUT(dwIndex), (asmMergeCoords(pOverlayInfo->dwOverlayDstWidth, pOverlayInfo->dwOverlayDstHeight)));
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_POINT_IN(dwIndex), dwPointIn);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_POINT_OUT(dwIndex), (asmMergeCoords(pOverlayInfo->dwOverlayDstX, pOverlayInfo->dwOverlayDstY)));

    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_OFFSET(dwIndex), dwOffset);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_COLORKEY(dwIndex), pOverlayInfo->dwOverlayColorKey);

    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_DU_DX(dwIndex), dwDeltaX);
    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_DV_DY(dwIndex), dwDeltaY);

    NVP_DMAPUSH_WRITE1(NVP_DECODER_SUBCHANNEL, NV07A_SET_OVERLAY_FORMAT(dwIndex), dwOverlayFormat);

//    NVP_DMAPUSH_START();
    pDmaChannel->Put = nvDmaCount << 2;
	pVPEContext->nvDmaCount = nvDmaCount;

    return TRUE;
}

//---------------------------------------------------------------------------
// vddPrescaleAndFlip
//
//      VPE implementation of selected parts of DDRAW's VPP pipe.  Only 
//      prescaling and flip are performed.
//

#define NEXT_SURFACE { \
            dwSrcOffset = dwDstOffset;  \
            dwSrcPitch = dwDstPitch;    \
            dwDstOffset = dwNextOffset; \
            dwDstPitch = dwNextPitch;   \
            dwNextOffset = dwSrcOffset; \
            dwNextPitch = dwSrcPitch;   \
            dwOpCount++;                \
        }

#define NV_WIN_DEVICE    0x00002002

BOOL NVPPrescaleAndFlip(
    PNVP_CONTEXT  pVPEContext, 
	PNVP_OVERLAY  pOverlayInfo,
    DWORD         dwOffset,        // source surface offset 
    DWORD         dwPitch,         // source pitch
    DWORD         dwOvIndex,         // overlay buffer index
    DWORD         dwFlags)         // VPP flags
{
	DWORD dwHeight, dwWidth, i = 0;
    DWORD dwSrcOffset, dwSrcPitch;
    DWORD dwDstOffset, dwDstPitch;
    DWORD dwNextOffset, dwNextPitch;
    DWORD dwOpCount;
    DWORD dwWorkSurfaces;
    BOOL  doXPreScale, doYPreScale, doPreScale;
    BOOL  isDownScale;
    DWORD dwRoundX, dwRoundY;
    DWORD vppExec;
    BOOL  isField;
    NvNotification *pPioFlipOverlayNotifier = (NvNotification *)pOverlayInfo->pNvPioFlipOverlayNotifierFlat;


#if 0 //#ifdef DEBUG
    char debugstr[256];

    debugstr[0] = '\0';
    if (dwFlags & VPP_ODD)          strcat(debugstr, "odd  ");
    if (dwFlags & VPP_EVEN)         strcat(debugstr, "even ");
    if (dwFlags & VPP_BOB)          strcat(debugstr, "bob ");
    if (dwFlags & VPP_INTERLEAVED)  strcat(debugstr, "int ");
    if (dwFlags & VPP_VIDEOPORT)    strcat(debugstr, "vp ");
    if (dwFlags & VPP_WAIT)         strcat(debugstr, "wait ");
    if (dwFlags & VPP_OPTIMIZEFLIP) strcat(debugstr, "opt ");
    strcat(debugstr, "REQ: ");
    if (dwFlags & VPP_CONVERT)      strcat(debugstr, "cvt ");
    if (dwFlags & VPP_SUBPICTURE)   strcat(debugstr, "sp ");
    if (dwFlags & VPP_PRESCALE)     strcat(debugstr, "ps ");
    if (dwFlags & VPP_COLOURCONTROL) strcat(debugstr, "cc ");
    if (dwFlags & VPP_TEMPORAL)     strcat(debugstr, "tf ");
    if (dwFlags & VPP_DEINTERLACE)  strcat(debugstr, "df ");
#endif

    //assert(pDriverData);

    // XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
    // find out if overlay hardware is busy, if so return "overlay busy" error code.
    // Perhaps check a "number of overlay buffers programmed" count.  When this count is less 
    // than 2, the overlay hardare is not busy and when it's equal to 2, the hardwar is busy. 
    // If it's not busy, then program it up here and increment the count.  Then use a kernel 
    // callback to decrement this count upon buffer complete.
    //
    
    DWORD dwIndex = pOverlayInfo->dwOverlayBufferIndex;

#ifdef _NVP_DTRACE
    DTRACE(0xdead0001);
    DTRACE_CYCLE_DELTA();
    DTRACE(dwOffset);
    DTRACE(dwIndex);

//    return TRUE;
#endif

/*
        while ((pPioFlipOverlayNotifier[dwIndex + 1].status == NV_IN_PROGRESS) && (i < VDD_VPP_TIME_OUT))
            i++;
        // timed-out... stop the appropriate buffer and return error
        if (i >= VDD_VPP_TIME_OUT)
*/
    // drop field if previous one is still being drawn (same overlay buffer) !
    if (pPioFlipOverlayNotifier[dwIndex + 1].status == NV_IN_PROGRESS)
        return 1;

    dwWorkSurfaces = pOverlayInfo->dwExtra422NumSurfaces;
    vppExec = 0;
    dwOpCount = 0;
    dwSrcOffset = dwOffset;
    dwSrcPitch = dwPitch;
    dwDstOffset = pOverlayInfo->aExtra422OverlayOffset[pOverlayInfo->dwExtra422Index];
    dwDstPitch = pOverlayInfo->dwExtra422Pitch;
    dwNextOffset = pOverlayInfo->aExtra422OverlayOffset[pOverlayInfo->dwExtra422Index + 1];
    dwNextPitch = pOverlayInfo->dwExtra422Pitch;

    isField = IS_FIELD(dwFlags);

    doXPreScale = (pOverlayInfo->dwOverlaySrcWidth > (pOverlayInfo->dwOverlayDstWidth * pOverlayInfo->dwOverlayMaxDownScale));
    doYPreScale = (pOverlayInfo->dwOverlaySrcHeight > (pOverlayInfo->dwOverlayDstHeight * pOverlayInfo->dwOverlayMaxDownScale));
  
    if (pVPEContext->dwChipId < NV_DEVICE_VERSION_10) {
        // NV4/5 also prescales:
        //  - all BOBed fields
        //  - vertical upscales when HQVUp is enabled
        doYPreScale = TRUE; //doYPreScale || isField; //|| (pOverlayInfo->regOverlayMode & NV4_REG_OVL_MODE_VUPSCALE)
    }

    doPreScale = (dwFlags & VPP_PRESCALE) &&
                 (doXPreScale || doYPreScale);

    isDownScale = FALSE;
    if (doPreScale) 
    {
        DWORD dwSrcArea, dwDstArea;

        dwSrcArea = pOverlayInfo->dwOverlaySrcHeight * pOverlayInfo->dwOverlaySrcWidth;
        if ((dwFlags & (VPP_ODD | VPP_EVEN)) && (dwFlags & VPP_INTERLEAVED)) 
        {
            // bob mode
			dwSrcArea >>= 1;
        }
        dwDstArea = pOverlayInfo->dwOverlayDstHeight * pOverlayInfo->dwOverlayDstWidth;
        if (dwSrcArea > dwDstArea) 
        {
            isDownScale = TRUE;
        }
    }

    if (dwWorkSurfaces < 2) {
        // no work surfaces, can't do anything
        doPreScale = FALSE;
    }

    // adjust for the subrectangle
    dwRoundX = pOverlayInfo->dwOverlaySrcX & 0x1;
    dwRoundY = pOverlayInfo->dwOverlaySrcY & 0x1;
    dwSrcOffset += (pOverlayInfo->dwOverlaySrcY & ~0x1) * dwSrcPitch;
    dwSrcOffset += (pOverlayInfo->dwOverlaySrcX & ~0x1) << 1;   // always YUV422
    dwWidth = pOverlayInfo->dwOverlaySrcSize & 0xFFFF;
    dwHeight = pOverlayInfo->dwOverlaySrcSize >> 16;
    if (dwWidth & 1)
        dwWidth += 1;
    if (dwRoundY)
        dwHeight += 1;

    // do the prescaling now
    if (doPreScale) 
    {
        if (NVPPreScale(pVPEContext, pOverlayInfo, 
                        dwSrcOffset, dwSrcPitch, dwDstOffset, dwDstPitch, &dwWidth, &dwHeight, 
                        &dwFlags)) {
            NEXT_SURFACE;
            vppExec |= VPP_PRESCALE;
        }
    }

    if (dwRoundY) 
    {
        dwSrcOffset += dwSrcPitch;
        dwHeight -= 1;
    }

//    if (dwRoundX)
//        dwWidth -= 1;

    // always do the flip, even if we are not flipping
    if (NVPFlip(pVPEContext, pOverlayInfo, dwSrcOffset,
                dwSrcPitch, dwWidth, dwHeight, dwIndex, dwFlags)) 
    {
        pOverlayInfo->dwOverlayBufferIndex ^= 1;
        if (dwWorkSurfaces == 0) 
        {
            pOverlayInfo->dwExtra422Index = 0;
        }
        else if (dwWorkSurfaces <= 3)
        {
            pOverlayInfo->dwExtra422Index = (pOverlayInfo->dwExtra422Index + 1) % dwWorkSurfaces;
        } 
        else 
        {
            pOverlayInfo->dwExtra422Index = (pOverlayInfo->dwExtra422Index + 2) % dwWorkSurfaces;
        }
    } 
    else 
    {
        return FALSE;
    }

    return TRUE;
}


#endif // #ifdef NVPE
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\CODE\digmode.h ===
/*
    FILE:   digmode.h
    DATE:   4/8/99

    This file contains the code for mode setting/determination
    ona CRT or FLAT PANEL. OS independent.
*/

extern int CFUNC FindDigModeEntry (LPCHAR lpEdidBuffer, ULONG dwEdidSize,
                        LPDISPDATA lpDispData, LPMODEINFO lpModeDesc,
                        LPMODEOUT lpModeOut, LPMODEENTRY lpModeList,
                        LPRESTIME lpRTList);
extern int CFUNC CheckTimingStandardOverride (LPCHAR lpEdidBuffer,
                        ULONG dwEdidSize, LPDISPDATA lpDispData,
                        LPMODEINFO lpModeDesc, LPMODEOUT lpModeOut);
extern int CFUNC BackOffDigModeEntry (LPMODEENTRY lpModeList,
                        LPMODEINFO lpModeDesc, LPMODEINFO lpModeOrig, int iRRFlag);
extern int CFUNC ProcessRTWithDigModeEntry (LPDISPDATA lpDispData,
                        LPCHAR lpEdidBuffer,
                        ULONG dwEdidSize, LPRESTIME lpRTList,
                        LPMODEINFO lpModeDesc, LPMODEOUT lpModeOut);
extern int CFUNC ModeWithinMonitorTimingLimits (LPDISPDATA lpDispData,
                        LPMODEOUT lpModeOut,
                        LPCHAR lpEdidBuffer, ULONG dwEdidSize);
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\CODE\digmode.c ===
/*
    FILE:   digmode.c
    DATE:   4/8/99

    This file contains the code for mode setting/determination
    ona CRT or FLAT PANEL.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "debug.h"
#include "restime.h"
#include "digmode.h"
#include "dmt.h"
#include "edid.h"
#include "gtf.h"
#include "gtfmath.h"
#include "osapi.h"

#define     BACKOFF_MODE        0x01
#define     GOT_TIMINGS         0x02
#define     RANGE_CHECK_MODE    0x04

/*==========================================================================
    Function:   FindDigModeEntry

    Purpose:    Finds a set of timings for a mode for a CRT or DFP
                that will work on the device.

    Arguments:
                lpEdidBuffer    ptr to an EDID (or NULL if no edid)
                dwEdidSize      length of edid in bytes (or 0 if no edid)
                lpDispData      ptr to DISPDATA struct descirbing board
                lpModeOrig      ptr to MODEINFO desribing requested mode
                lpModeOut       ptr to place to store timings for final
                                mode decided upon (not necessarily the
                                same mode as given by lpModeOrig)
                lpModeList      ptr to a MODEENTRY array -- master mode list
                lpRTList        ptr to a RESTIME array -- R&T list

    Returns:    some bitwise ORing of the flags in modeext.h
                MODE_EXACT_MATCH
                MODE_RESOLUTION_ADJUSTED
                MODE_PIXEL_DEPTH_ADJUSTED
                MODE_REFRESH_RATE_ADJUSTED

    Preserve:
===========================================================================*/
int CFUNC
FindDigModeEntry (
    LPCHAR      lpEdidBuffer,
    ULONG       dwEdidSize,
    LPDISPDATA  lpDispData,
    LPMODEINFO  lpModeOrig,
    LPMODEOUT   lpModeOut,
    LPMODEENTRY lpModeList,
    LPRESTIME   lpRTList)
{
    int             i, nFlag, nIndex, bDoneRT, iRRFlag;
    MODEINFO        ModeDesc, LimitMode, ModeDFP;
    RTMODE          sRTMode;
    ULONG           dwMonitorID, dwMemoryUsed, dwPitch, dwDirection;
    ULONG           dwDacSpeedInHertz, dwDacSpeedLimitInHertz;
    USHORT          wActFlags;
    ULONG           wAllowAllModes;

    // Put out a bit of useful logging information.
    DBG_PRINT0(DL_0, "\r\nEntering FindDigModeEntry.");

    // Make a copy so we can modify the mode as we go along without
    // changing the original requested mode.
    ModeDesc = lpModeOrig[0];

    wAllowAllModes = GetAllowAllModesFlag(lpDispData->lpBoardRegistryData);

    // Decrease refresh rate in BackOffDigModeEntry() by default.
    iRRFlag = 1;
    // Set positive direction
    dwDirection = 1;

  do
  {
    // We will be modifying this as we go along.
    wActFlags = RANGE_CHECK_MODE;

    /////////////////////////////////////////////////////////////////
    // First, see if this mode is in the master mode list
    DBG_PRINT0(DL_1, "\r\nSearching for Mode in Master Mode List.");
    DBG_PRINT1(DL_1, "\r\nXRes = %ld", ModeDesc.dwXRes);
    DBG_PRINT1(DL_1, "\r\nYRes = %ld", ModeDesc.dwYRes);
    DBG_PRINT1(DL_1, "\r\nBpp  = %ld", ModeDesc.dwBpp);
    DBG_PRINT1(DL_1, "\r\nRefR = %ld", ModeDesc.dwRefreshRate);
    if (!wAllowAllModes)
    {
        for (i = 0; lpModeList[i].dwXRes != 0; i++)
        {
            if  ((lpModeList[i].dwXRes == ModeDesc.dwXRes) &&
                 (lpModeList[i].dwYRes == ModeDesc.dwYRes) &&
                 (lpModeList[i].dwBpp  == ModeDesc.dwBpp)  &&
                 (lpModeList[i].dwRefreshRate  == ModeDesc.dwRefreshRate))
                break;
        }

        // Did we find the mode in the list?
        if  (lpModeList[i].dwXRes == 0)
        {
            DBG_PRINT0(DL_1, "\r\nFound Mode in Master List.");
            wActFlags |= BACKOFF_MODE;
        }
    }
    /////////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // NO EDID AND NO INF blocks certain modes
    if  (!(wAllowAllModes) && !(wActFlags & BACKOFF_MODE) && (dwEdidSize == 0) &&
          (lpDispData->dwMonitorInfType != SPECIFIC_DEVICE))
    {
        if  (ModeDesc.MIDevData.cType == DEVTYPE_CRT)
        {
            // If the CRT has no inf and no edid, then we
            // check the registry to see what the upper limit
            // should be in this situation.
            if  (GetMonitorLimitMode (lpDispData, &LimitMode))
            {
                if  ((ModeDesc.dwRefreshRate > LimitMode.dwRefreshRate) ||
                     (ModeDesc.dwXRes > LimitMode.dwXRes) ||
                     (ModeDesc.dwYRes > LimitMode.dwYRes))
                {
                    wActFlags |= BACKOFF_MODE;
                }
                else
                {
                    wActFlags &= ~RANGE_CHECK_MODE;
                }
            }
            else
            {
                wActFlags &= ~RANGE_CHECK_MODE;
            }
        }

        if  (ModeDesc.MIDevData.cType == DEVTYPE_DFP)
        {
            // If the DFP has no inf and no edid, then we block any
            // refreshrate higher than 60Hz and block all resolutions
            // higher than 1024x768.
            if  ((ModeDesc.dwRefreshRate > 60) ||
                 (ModeDesc.dwXRes > 1024) ||
                 (ModeDesc.dwYRes > 768))
            {
                wActFlags |= BACKOFF_MODE;
            }
            else
            {
                wActFlags &= ~RANGE_CHECK_MODE;
            }
        }
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // NO EDID AND YES INF means trust the INF on everything.
    if  (!(wAllowAllModes) && !(wActFlags & BACKOFF_MODE) && (dwEdidSize == 0) &&
          (lpDispData->dwMonitorInfType == SPECIFIC_DEVICE))
    {
        // Nothing to do here right now.
        // We just assume that whatever we are asked to set
        // can be done because Windows wouldn't call us with
        // some mode that is not in the .inf.
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // YES EDID AND NO INF means trust the EDID on everything.
    if  (!(wAllowAllModes) && !(wActFlags & BACKOFF_MODE) && (dwEdidSize != 0) &&
          (lpDispData->dwMonitorInfType != SPECIFIC_DEVICE))
    {
        // Nothing to do here right now.
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // YES EDID AND YES INF case. Edid range limits have top priority
    // and, if they exist, ModeWithinMonitorTimingLimits will check
    // against those later. If there are no range limits in the EDID,
    // then we will use the range string from the .inf file.
    if  (!(wAllowAllModes) && !(wActFlags & BACKOFF_MODE) && (dwEdidSize != 0) &&
          (lpDispData->dwMonitorInfType == SPECIFIC_DEVICE))
    {
        // Note that there is nothing to do here right now.
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////////
    // We need to block certain modes on DFPs.
    if  (!(wAllowAllModes) && !(wActFlags & BACKOFF_MODE) && (ModeDesc.MIDevData.cType == DEVTYPE_DFP))
    {
        // Block 480x360 and 960x720. DFPs often have trouble
        // with these modes.
        if  (((ModeDesc.dwXRes == 480) && (ModeDesc.dwYRes == 360)) ||
            ((ModeDesc.dwXRes == 960) && (ModeDesc.dwYRes == 720)))
            wActFlags |= BACKOFF_MODE;

        // HACK!!! We will fix this for real shortly, but this should
        // work for now.
        //
        // On DFPs, block any X,Y res that is bigger than the largest
        // mode in the EDID. Any mode that is smaller can still be
        // blocked by the pixel frequency range of the chip's DFP
        // scaler which is 8Mhz - 350Mhz.
        //
        // I'm not worried about any mode exceeding 350Mhz right now,
        // so I am going to omit the check for it. The check would
        // have to be put into ModeWithinMonitorTimingLimits() and
        // I'm trying to keep this hack localized.
        if  (dwEdidSize != 0)
        {
            EdidFindLargestEdidMode (lpEdidBuffer, dwEdidSize, &ModeDFP);
            if  ((ModeDesc.dwXRes > ModeDFP.dwXRes) ||
                 (ModeDesc.dwYRes > ModeDFP.dwYRes))
            {
                // Block modes that are larger than largest EDID mode.
                wActFlags |= BACKOFF_MODE;
            }
            else
            {
                // Let any smaller X,Y res go through. The refresh
                // rate is irrelevant right now, because the RM is
                // currently assuming fixed frequency DFPs at 60Hz.
                wActFlags &= ~RANGE_CHECK_MODE;
            }
        }
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // We need to block certain modes according to restriction
    // and timing strings.

    if  (!(wAllowAllModes) && !(wActFlags & BACKOFF_MODE))
    {
        // See if we find a matching R&T string
        sRTMode.dwXRes = ModeDesc.dwXRes;
        sRTMode.dwYRes = ModeDesc.dwYRes;
        sRTMode.dwBpp  = ModeDesc.dwBpp;
        sRTMode.dwRefreshRate = ModeDesc.dwRefreshRate;

        if  (dwEdidSize)
            dwMonitorID = EdidGetMonitorId (lpEdidBuffer, dwEdidSize);
        else
            dwMonitorID = UKWN_ID;

        for (nIndex = 0, bDoneRT = FALSE; !bDoneRT;)
        {
            nIndex = RTFindNextMatchingString (lpRTList, nIndex + 1,
                        lpDispData, &sRTMode, dwMonitorID);

            if  (nIndex != RTERR_NOT_FOUND)
            {
                DBG_PRINT1(DL_0, "\r\nFound R&T string matching board data # %ld", (ULONG) nIndex);

                // There was. Let's see what that tells us.
                nFlag = ProcessRTWithDigModeEntry (lpDispData,
                                lpEdidBuffer, dwEdidSize,
                                lpRTList + nIndex, &ModeDesc, lpModeOut);

                // > 0 means that the R&T string accepted the mode and
                // we have a set of timings in lpModeOut. We're done!
                if  (nFlag > 0)
                {
                    wActFlags |= GOT_TIMINGS;
                    bDoneRT = TRUE;
                }

                if  (nFlag == 2)
                    wActFlags &= ~RANGE_CHECK_MODE;

                // < 0 means that this mode was explicitly rejected by
                // the R&T string -- probably a NONE in the Timing
                // Standard field. We need to back off the mode.
                if  (nFlag < 0)
                {
                    wActFlags |= BACKOFF_MODE;
                    bDoneRT = TRUE;
                }
            }
            else
                bDoneRT = TRUE;
        }
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // At this point, check to see if we want to override any
    // timing standards that were already selected.
    if  (!(wActFlags & BACKOFF_MODE) && !(wActFlags & GOT_TIMINGS))
    {
        nFlag = CheckTimingStandardOverride (lpEdidBuffer, dwEdidSize,
                                    lpDispData, &ModeDesc, lpModeOut);
        if  (nFlag > 0)
        {
            wActFlags |= GOT_TIMINGS;
            DBG_PRINT0(DL_0, "\r\nOverride Timing Found!");
        }

        if  (nFlag == 2)
            wActFlags &= ~RANGE_CHECK_MODE;
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // If an R&T string established the timing parameters, we
    // would not have gotten here. So at this point, just use
    // the "normal" logic to get the timing parameters.

    if  ((!(wActFlags & BACKOFF_MODE)) && !(wActFlags & GOT_TIMINGS) && (dwEdidSize == 0))
    {
        if  (DmtFindMode (&ModeDesc, lpModeOut))
        {
            wActFlags |= GOT_TIMINGS;
            wActFlags |= RANGE_CHECK_MODE;
            DBG_PRINT0(DL_0, "\r\nDmt timing found.");
        }

        if  (!(wActFlags & GOT_TIMINGS))
        {
            if  (GtfFindMode (&ModeDesc, lpModeOut))
            {
                wActFlags |= GOT_TIMINGS;
                wActFlags |= RANGE_CHECK_MODE;
                DBG_PRINT0(DL_0, "\r\nGtf timing found.");
            }
        }
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    // If an R&T string established the timing parameters, we
    // would not have gotten here. So at this point, just use
    // the "normal" logic to get the timing parameters.

    if  ((!(wActFlags & BACKOFF_MODE)) && (!(wActFlags & GOT_TIMINGS)) && (dwEdidSize != 0))
    {
        if  (EdidFindDetailedMode (lpEdidBuffer, dwEdidSize, &ModeDesc, lpModeOut))
        {
            DBG_PRINT0(DL_0, "\r\nEdidDetailedTiming Found!");
            wActFlags = (wActFlags & ~RANGE_CHECK_MODE) | GOT_TIMINGS;
        }
        else if  (EdidFindStandardMode (lpEdidBuffer, dwEdidSize, &ModeDesc, lpModeOut))
        {
            DBG_PRINT0(DL_0, "\r\nEdidStandardTiming Found!");
            wActFlags = (wActFlags & ~RANGE_CHECK_MODE) | GOT_TIMINGS;
        }
        else if  (EdidFindEstablishedMode (lpEdidBuffer, dwEdidSize, &ModeDesc, lpModeOut))
        {
            DBG_PRINT0(DL_0, "\r\nEdidEstablishedTiming Found!");
            wActFlags = (wActFlags & ~RANGE_CHECK_MODE) | GOT_TIMINGS;
        }
        else if  ((EdidIsGtfMonitor (lpEdidBuffer, dwEdidSize)) && GtfFindMode (&ModeDesc, lpModeOut)
                  && (ModeDesc.dwXRes > 400) && (ModeDesc.dwYRes > 300))
        {
            wActFlags |= GOT_TIMINGS;
            DBG_PRINT0(DL_0, "\r\nGtf timing found.");
        }
        else if  (DmtFindMode (&ModeDesc, lpModeOut))
        {
            wActFlags |= GOT_TIMINGS;
            DBG_PRINT0(DL_0, "\r\nDmt timing found.");
        }
        else if  (GtfFindMode (&ModeDesc, lpModeOut))
        {
            wActFlags |= GOT_TIMINGS;
            DBG_PRINT0(DL_0, "\r\nGtf timing found.");
        }
    }
    /////////////////////////////////////////////////////////////

    /////////////////////////////////////////////////////////////
    if  (!(wActFlags & BACKOFF_MODE) && (wActFlags & GOT_TIMINGS))
    {
        if (!wAllowAllModes)
        {
            // We weren't explicitly asked to back off and we have some
            // timings, so range check them if requested.
            if  (!(wActFlags & RANGE_CHECK_MODE) ||
                (iRRFlag = ModeWithinMonitorTimingLimits (lpDispData, lpModeOut, lpEdidBuffer, dwEdidSize)) == 0)
            {
                // Now verify that there is enough memory and that
                // the DAC is fast enough to handle the mode.
                GetPitchAndSize (lpDispData, ModeDesc.dwXRes,
                                    ModeDesc.dwYRes, ModeDesc.dwBpp,
                                    &dwPitch, &dwMemoryUsed);
                dwDacSpeedInHertz = Multiply32By32 (lpModeOut->dwPixelClock, 10000);

                // Get the dac speed limit for the given pixel depth
                if  (ModeDesc.dwBpp == 8)
                    dwDacSpeedLimitInHertz = lpDispData->dwMaxDacSpeedInHertz8bpp;

                if  ((ModeDesc.dwBpp == 16) || (ModeDesc.dwBpp == 15))
                    dwDacSpeedLimitInHertz = lpDispData->dwMaxDacSpeedInHertz16bpp;

                if  ((ModeDesc.dwBpp == 32) || (ModeDesc.dwBpp == 24))
                    dwDacSpeedLimitInHertz = lpDispData->dwMaxDacSpeedInHertz32bpp;

                if  ((lpDispData->dwVideoMemoryInBytes >= dwMemoryUsed) &&
                     (dwDacSpeedLimitInHertz >= dwDacSpeedInHertz))
                    return  (GetModeFlags (lpModeOrig, &ModeDesc));
                else
                {
                    iRRFlag = 1;
                    wActFlags |= BACKOFF_MODE;
                }
            }
            else
            {
                if(iRRFlag < 0)
                    dwDirection = 0;

                wActFlags |= BACKOFF_MODE;
            }
        }
        else
            return  (GetModeFlags (lpModeOrig, &ModeDesc));
    }

    if  ((wActFlags & BACKOFF_MODE) || !(wActFlags & GOT_TIMINGS))
    {
        // If we are directed to backoff explicitly, or we didn't
        // find any timings, then go ahead and backoff.
        if  ((dwDirection == 0 && iRRFlag > 0) ||
            !BackOffDigModeEntry (lpModeList, &ModeDesc, lpModeOrig, iRRFlag))
        {
            // Just return safe settings if we couldn't back off
            return  (GetSafeTiming (&ModeDesc, lpModeOut));
        }
    }
    /////////////////////////////////////////////////////////////

  } while (TRUE);

}


/*==========================================================================
    Function:   CheckTimingStandardOverride

    Purpose:    Checks to see if we are supposed to use a particular
                timing standard (like DMT or GTF). If we are, sees if
                there is a set of timings to match the requested mode.

    Arguments:
                lpEdidBuffer    ptr to an EDID (or NULL if no edid)
                dwEdidSize      length of edid in bytes (or 0 if no edid)
                lpDispData      ptr to DISPDATA struct descirbing board
                lpModeDesc      ptr to MODEINFO desribing requested mode
                lpModeOut       ptr to place to store timings for
                                lpModeDesc mode if needed.

    Returns:    > 0     then a timing standard override was requested
                        and lpModeOut has the set of timings for the
                        mode passed in in lpModeDesc
                        if 1 then range check mode
                        if 2 then dont range check mode
                0       Either no timing standard override was requested
                        or one was but there was no set of timings in
                        that timing standard for the mode given by
                        lpModeDesc

    Preserve:
===========================================================================*/
int CFUNC
CheckTimingStandardOverride (
    LPCHAR      lpEdidBuffer,
    ULONG       dwEdidSize,
    LPDISPDATA  lpDispData,
    LPMODEINFO  lpModeDesc,
    LPMODEOUT   lpModeOut)
{
    ULONG   dwTimingStandard;
    MODEOUT sModeOutTemp;
    int     nRet;

    dwTimingStandard = GetTimingStandardOverride (lpDispData);

    if  (dwTimingStandard == DMTV_ID)
    {
        if  (DmtFindMode (lpModeDesc, lpModeOut))
        {
            nRet = 1;

            if  (dwEdidSize)
            {
                if  (EdidFindStandardMode (lpEdidBuffer, dwEdidSize,lpModeDesc,lpModeOut))
                    nRet = 2;
                
                if  (EdidFindEstablishedMode (lpEdidBuffer, dwEdidSize, lpModeDesc, lpModeOut))
                    nRet = 2;
            }
    
            DBG_PRINT0(DL_0, "\r\nDmt Timing Found!");
            return  (nRet);
        }
    }

    if  (dwTimingStandard == GTFV_ID)
    {
        if  (GtfFindMode (lpModeDesc, lpModeOut))
        {
            nRet = 1;

            if  (dwEdidSize &&
				EdidFindStandardMode (lpEdidBuffer, dwEdidSize, lpModeDesc, &sModeOutTemp) &&
                !DmtFindMode (lpModeDesc, &sModeOutTemp))
                    nRet = 2;

            DBG_PRINT0(DL_0, "\r\nGtf Timing Found!");
            return  (nRet);
        }
    }

    return  (FALSE);
}



/*==========================================================================
    Functiom:   ProcessRTWithDigModeEntry

    Purpose:    Checks to see if we are supposed to use a particular
                timing standard (like DMT or GTF). If we are, sees if
                there is a set of timings to match the requested mode.

    Arguments:
                lpEdidBuffer    ptr to an EDID (or NULL if no edid)
                dwEdidSize      length of edid in bytes (or 0 if no edid)
                lpRTList        ptr to RESTIME structure we are processing
                lpModeDesc      ptr to MODEINFO desribing requested mode
                lpModeOut       ptr to place to store timings for
                                lpModeDesc mode if needed.

    Returns:
        There are three return values possible.
        > 0     This indicates that the mode was accepted by the R&T
                string and a set of timings have been placed in
                lpModeOut.
                If 2 then mode must not be range checked
                if 1, then mode should be range checked
        = 0     This R&T string did not apply to the lpModeDesc.
        < 0     The lpModeDesc mode was rejected by the R&T string.

    Preserve:
===========================================================================*/
int CFUNC
ProcessRTWithDigModeEntry (
            LPDISPDATA  lpDispData,
            LPCHAR      lpEdidBuffer,
            ULONG       dwEdidSize,
            LPRESTIME   lpRTList,
            LPMODEINFO  lpModeDesc,
            LPMODEOUT   lpModeOut)
{
    int i;

    // R&T string applies to this mode.
    // Let's walk through the timing standards.
    for (i = 0; i < MAX_DOT_FIELDS; i++)
    {
        switch (lpRTList->dwTimingStandard[i])
        {
            case NONE_ID:
                // This mode is prohibited. Fail it.
                DBG_PRINT0(DL_0, "\r\nR&T string specifies NONE timing.");
                return  (-1);

            case EDID_ID:
                DBG_PRINT0(DL_0, "\r\nR&T string specifies EDID timing.");

                if  (dwEdidSize)
                {
                    // Use an EDID detailed timing if present
                    if  (EdidFindDetailedMode (lpEdidBuffer,
                            dwEdidSize, lpModeDesc, lpModeOut))
                    {
                        DBG_PRINT0(DL_0, "\r\nEdidDetailedTiming Found!");
                        return  (1);
                    }

                    if  (EdidFindStandardMode (lpEdidBuffer,
                            dwEdidSize, lpModeDesc, lpModeOut))
                    {
                        DBG_PRINT0(DL_0, "\r\nEdidStandardTiming Found!");
                        return  (1);
                    }

                    if  (EdidFindEstablishedMode (lpEdidBuffer,
                            dwEdidSize, lpModeDesc, lpModeOut))
                    {
                        DBG_PRINT0(DL_0, "\r\nEdidEstablishedTiming Found!");
                        return  (1);
                    }
                }
                break;

            case DMTV_ID:
            case DMTR_ID:
                // Use a DMT timing if present
                DBG_PRINT0(DL_0, "\r\nR&T string specifies DMT timing.");

                if  (DmtFindMode (lpModeDesc, lpModeOut))
                {
                    if  (lpRTList->dwTimingStandard[i] == DMTR_ID)
                    {
                        // If there is an EDID, then make sure we
                        // are within the monitor limits
                        if  (!ModeWithinMonitorTimingLimits (lpDispData,
                                            lpModeOut, lpEdidBuffer,
                                            dwEdidSize))
                        {
                            DBG_PRINT0(DL_0, "\r\nDmt Timing rejected by monitor limits!");
                            break;
                        }
                    }

                    DBG_PRINT0(DL_0, "\r\nDmt Timing Found!");
                    if  (lpRTList->dwTimingStandard[i] == DMTR_ID)
                        return  (1);
                    else
                        return  (2);
                }
                break;

            case GTFV_ID:
            case GTFR_ID:
                // Use GTF unless we couldn't get an
                // Edid or unless the Edid indicated
                // the monitor was not GTF.
                DBG_PRINT0(DL_0, "\r\nR&T string specifies GTF timing.");

                if  (!dwEdidSize)
                {
                    DBG_PRINT0(DL_0, "\r\nNo Edid: Cannot use GTFV timing.");
                    break;
                }

                if  (!EdidIsGtfMonitor (lpEdidBuffer, dwEdidSize))
                {
                    DBG_PRINT0(DL_0, "\r\nNot GTF monitor: Cannot use GTFV timing.");
                    break;
                }

            // Fall through to FGTF case
            case FGTF_ID:
            case FGTR_ID:
                // Use a GTF timing regardless
                DBG_PRINT0(DL_0, "\r\nR&T string specifies FGTF timing.");

                if  (GtfFindMode (lpModeDesc, lpModeOut))
                {
                    if  ((lpRTList->dwTimingStandard[i] == GTFR_ID) ||
                         (lpRTList->dwTimingStandard[i] == FGTR_ID))
                    {
                        // If there is an EDID, then make sure we
                        // are within the monitor limits
                        if  (!ModeWithinMonitorTimingLimits (lpDispData,
                                            lpModeOut, lpEdidBuffer,
                                            dwEdidSize))
                        {
                            DBG_PRINT0(DL_0, "\r\nGtf Timing rejected by monitor limits!");
                            break;
                        }
                    }

                    // If there is no edid, or there are no
                    // monitor limits, or the GTF mode is
                    // within the monitor limits, then we
                    // have found the mode and are done!
                    DBG_PRINT0(DL_0, "\r\nGtf Timing found!");
                    if  ((lpRTList->dwTimingStandard[i] == FGTR_ID) ||
                         (lpRTList->dwTimingStandard[i] == GTFR_ID))
                        return  (1);
                    else
                        return  (2);
                }
                break;

            case OEMX_ID:
            case OEMR_ID:
                // Use the OEM timing in the TimingParameters
                DBG_PRINT0(DL_0, "\r\nR&T string specifies OEM timing.");

                lpModeOut[0] = lpRTList->sModeOut;

                if  (lpRTList->dwTimingStandard[i] == OEMR_ID) 
                {
                    // If there is an EDID, then make sure we
                    // are within the monitor limits
                    if  (!ModeWithinMonitorTimingLimits (lpDispData,
                                        lpModeOut, lpEdidBuffer,
                                        dwEdidSize))
                    {
                        DBG_PRINT0(DL_0, "\r\nOem Timing rejected by monitor limits!");
                        break;
                    }
                }

                DBG_PRINT0(DL_0, "\r\nOem Timing Found!");
                if  (lpRTList->dwTimingStandard[i] == OEMR_ID)                
                    return  (1);
                else
                    return  (2);

            default:
                // Bad Timing Standard Encountered
                DBG_PRINT0(DL_0, "\r\nBad Timing Standard. Ignoring it.");
        }
    }

    return  (0);
}


/*==========================================================================
;
; Function: BackOffDigModeEntry
;
; Purpose:  This routine backs off the current mode, first by the
;           refresh rate. If it can't do that, then it restores the
;           original refresh rate and backs off on the spatial
;           resolution. If it can't do that, then it returns a failure
;           code.
;
; Arguments:
;       lpModeList  LPMODEENTRY ptr points to mode list used to
;                   fetch next lower refresh rate/resolution from
;       lpModeDesc  Description of mode from which we should back off.
;       lpModeOrig  This was the original mode that the user called
;                   the modeset DLL with originally. It can be used
;                   in the back off algorithm as well. For example
;                   when the refresh rate cannot be backed off
;                   anymore, it may be desirable to restore the
;                   original refresh rate the user requested and
;                   then back off the reolution one notch.
;
; Returns:      0   this indicates that there was no mode that could
;                   be backed off to. We are at the end of our rope.
;               1   then lpModeDesc has been modified to hold the new
;                   backed off mode.
;
; Preserve:     All registers
;==========================================================================*/
int CFUNC
BackOffDigModeEntry (
        LPMODEENTRY lpModeList,
        LPMODEINFO  lpModeDesc,
        LPMODEINFO  lpModeOrig,
    int         iRRFlag)
{
    if(iRRFlag < 0 && FindNextLargerRefreshRate (lpModeList, lpModeDesc))
    {
    DBG_PRINT0(DL_0, "\r\nBacking off to mode with a larger refresh rate.");
    }
    else if (iRRFlag > 0 && FindNextSmallerRefreshRate (lpModeList, lpModeDesc))
    {
    DBG_PRINT0(DL_0, "\r\nBacking off to mode with a lower refresh rate.");
    }
    else
    {
        // We couldn't find a the same resolution and pixel depth
        // with a lower refresh rate. This may happen, for example,
        // if we were already at 60Hz. Let's reset the refresh rate
        // to what was originally requested and find the next lower
        // spatial resolution resolution at the same pixel depth.
        lpModeDesc[0].dwRefreshRate = lpModeOrig[0].dwRefreshRate;

        if  (FindNextSmallerResolution (lpModeList, lpModeDesc))
        {
            DBG_PRINT0(DL_0, "\r\nBacking off to mode with a lower resolution.");
        }
        else
        {
            // OK, if this doesn't happen, then we had already
            // scanned down from the mode/refresh rate requested
            // through all all lower resolutions/refresh rates and
            // none of them were settable.
            // Inidicate that there are no more modes to try.
            return  (FALSE);
        }
    }

    return  (TRUE);
}


/*==========================================================================
    Function:   ModeWithinMonitorTimingLimits

    Purpose:    Checks to see if a given mode is within the timing
                limits for the monitor.

    Arguments:
                lpEdidBuffer    ptr to an EDID (or NULL if no edid)
                dwEdidSize      length of edid in bytes (or 0 if no edid)
                lpModeOut       timings to check

    Returns:    0   mode is within monitor limits
                #0   mode is not within limits
        ( > 0 - try to decrease refresh rate first )

    Preserve:
===========================================================================*/
int CFUNC
ModeWithinMonitorTimingLimits (
                LPDISPDATA  lpDispData,
                LPMODEOUT lpModeOut,
                LPCHAR    lpEdidBuffer,
                ULONG     dwEdidSize)
{
    ULONG           dwPixelClockInHertz;
    ULONG           dwHorzRate, dwMaxXRes, dwMaxYRes;
    USHORT          wGotRangeLimits;
    MONITORLIMITS   sML;

    // Assume that we don't find any range limits
    wGotRangeLimits = FALSE;

    if  (dwEdidSize == 0)
    {
        // No EDID ... if there is no INF, just say YES
        if  (lpDispData->dwMonitorInfType != SPECIFIC_DEVICE)
            return  (0);

        // Does the inf file have range limits?
        if  (GetMonitorInfRangeLimits (lpDispData, &sML, &dwMaxXRes, &dwMaxYRes))
            wGotRangeLimits = TRUE;
        else
            return  (0);
    }
    else
    {
        // There is an EDID ... Are there range limits?
        if  (EdidGetMonitorLimits (lpEdidBuffer, dwEdidSize, &sML))
        {
            // There are range limits, so don't use the .inf file
            wGotRangeLimits = TRUE;
        }
        else
        {
            // There are no range limits ... is there an .inf file?
            if  (lpDispData->dwMonitorInfType == SPECIFIC_DEVICE)
            {
                // Does the inf file have range limits?
                if  (GetMonitorInfRangeLimits (lpDispData, &sML, &dwMaxXRes, &dwMaxYRes))
                    wGotRangeLimits = TRUE;
                else
                    wGotRangeLimits = FALSE;
            }
        }
    }

    if  (!wGotRangeLimits)
    {
        // We didn't get range limits, but we wouldn't have gotten here,
        // if there had not been an EDID. SO, we must use the modes given
        // in the EDID to determine approximate range limits. We need to
        // find the standard, established or detailed mode that has the:
        // 1) largest pixel clock
        // 2) smallest pixel clock
        // 3) largest horizontal refresh rate
        // 4) smallest horizontal refresh rate
        // 5) largest vertical refresh rate
        // 6) smallest vertical refresh rate
        //
        // The particular mode in the EDID that gives each
        // of these values may be a different one.

        EdidBuildRangeLimits (lpEdidBuffer, dwEdidSize, &sML);
    }

    // First check the pixel clock
    dwPixelClockInHertz = Multiply32By32 (lpModeOut->dwPixelClock, 10000);
    if  (dwPixelClockInHertz > sML.dwMaxPixelClock)
        return  1;

    // If the maximum vertical is not zero, check the vertical
    // refresh rate directly. If the maximum vertical refresh rate
    // is zero, there are no limits so skip check.
    if (sML.dwMaxVert)
    {
        // If the minimum vertical is the same as the maximum vertical,
        // only check against the maximum vertical.
        if (sML.dwMinVert == sML.dwMaxVert)
        {
            if (lpModeOut->wRefreshRate > sML.dwMaxVert)
                return 1;
        }
        else
        {
            if  (lpModeOut->wRefreshRate < sML.dwMinVert)
        return -1;
            if  (lpModeOut->wRefreshRate > sML.dwMaxVert)
        return 1;
        }
    }

    // The horizontal refresh rate is the scan rate per frame.
    dwHorzRate = Divide32By32 (dwPixelClockInHertz + ((ULONG)lpModeOut->wHTotal / 2), (ULONG)lpModeOut->wHTotal);

    // Use integer part only
    dwHorzRate = Divide32By32(dwHorzRate , 1000) ;
    dwHorzRate = Multiply32By32(dwHorzRate , 1000) ;

    // If the maximum horizontal is not zero, check the horizontal
    // refresh rate directly. If the maximum horizontal refresh rate
    // is zero, there are no limits so skip check.
    if (sML.dwMaxHorz)
    {
        if (sML.dwMinHorz == sML.dwMaxHorz)
        {
            if  (dwHorzRate > sML.dwMaxHorz)
                return 1;
        }
        else
        {
            if  (dwHorzRate < sML.dwMinHorz)
                return -1;
        if  (dwHorzRate > sML.dwMaxHorz)
                return 1;
        }
    }

    return  0;
}
=== C:/Users/treeman/Desktop/windows nt source code\xbox\Microsoft Xbox (1.00.4400) [April 2002] [src]\private\ntos\video\nv20\drivers\modeset.mhd\CODE\EDID.C ===
/*
    FILE:   edid.c
    DATE:   4/8/99

    This file is the generic entry point for the edid modeset code.
*/

#include "cmntypes.h"
#include "modeext.h"
#include "modeset.h"
#include "debug.h"
#include "edid.h"
#include "dmt.h"
#include "gtf.h"
#include "gtfmath.h"
#include "restime.h"
#include "utils.h"

//*****************************************************************************
//
// EDID Established Timings
//
// These are the timings from the VESA Monitor Timing Specification
// (Version 1.0, Revision 0.8) which correspond to the modes in the
// Established Timings block of the EDID.
//
// Horizontal Visible, Vertical Visible
// Refresh (Hz * 100)
// Horizontal Total, Blank Start, Sync Start, Sync End, Blank End
// Vertical Total, Blank Start, Sync Start, Sync End, Blank End
// DotClock (MHz * 100)
// HSync polarity
// VSync polarity
//
// NOTE: GTF Timings dictate no borders, so Blank Start == Visible and
// Blank End == Total.
//

MODESTRUC sZeroMode[] =
{
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

MODESTRUC EDIDEstablishedTimingTbl[] =
{
    // Settings for 1280x1024:
    1280,1024,75, 1688,1280,1296,1440,1688,1066,1024,1025,1028,1066,13500,BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 1024x768:
    1024,768,75, 1312,1024,1040,1136,1312,800,768,769,772,800,7875,BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    1024,768,70, 1328,1024,1048,1184,1328,806,768,771,777,806,7500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    1024,768,60, 1344,1024,1048,1184,1344,806,768,771,777,806,6500,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,

    // Settings for 800x600:
    800,600,75, 1056,800,816,896,1056,625,600,601,604,625,4950,BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    800,600,72, 1040,800,856,976,1040,666,600,637,643,666,5000,BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    800,600,60, 1056,800,840,968,1056,628,600,601,605,628,4000,BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,
    800,600,56, 1024,800,824,896,1040,625,600,601,603,625,3600,BUFFER_HSYNC_POSITIVE,BUFFER_VSYNC_POSITIVE,

    // Settings for 640x480:
    640,480,75, 840,640,656,720,840,500,480,481,484,500,3150,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,
    640,480,72, 832,648,664,704,824,520,488,489,492,512,3150,BUFFER_HSYNC_NEGATIVE,BUFFER_VSYNC_NEGATIVE,

    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
};

MODESTRUC EDIDDetailedTimingTable[9] =
{
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

MODESTRUC EDIDEstablishedTimingTable[11] =
{
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

MODESTRUC EDIDStandardTimingTable[9] =
{
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};



/*
    Function:   EdidGetVersion

    Purpose:    Returns EDID version multiplied by 0x100 so 1.10 is 0x110.

    Arguments:  NONE

    Returns:    EDID version multiplied by 100 if one exists.
                FALSE if no valid EDID

    Preserve:
*/
int CFUNC
EdidGetVersion (LPCHAR lpEdidBuffer, ULONG dwEdidSize)
{
    int     nEdidVersion;

    // Edid Version is 1.x if the very first byte is a 0.
    if (lpEdidBuffer[0] == 0x00)
    {
        LPEDIDV1STRUC   lpV1;

        lpV1 = (LPEDIDV1STRUC) lpEdidBuffer;

        // For Version 1.x, first 8 bytes of EDID must be
        // 00h, FFh, FFh, FFh, FFh, FFh, FFh, 00h
        if  ((lpEdidBuffer[1] != 0x0FF) || (lpEdidBuffer[2] != 0x0FF) ||
             (lpEdidBuffer[3] != 0x0FF) || (lpEdidBuffer[4] != 0x0FF) ||
             (lpEdidBuffer[5] != 0x0FF) || (lpEdidBuffer[6] != 0x0FF) ||
             (lpEdidBuffer[7] != 0x000))
        {
            DBG_PRINT0(DL_1, "\r\nBad Edid Version 1.X");
            return  (FALSE);
        }

        nEdidVersion = (int) ((((USHORT) lpV1->bVersionNumber) << 8) +
                       ((USHORT) lpV1->bRevisionNumber));
    }
    else
    {
        if ((lpEdidBuffer[0] & 0xF0) == 0x20)     // Version 2.x?
        {
            nEdidVersion = (int) ((USHORT) lpEdidBuffer[0] << 4);
        }
        else                                    // Invalid Version number
        {
            DBG_PRINT0(DL_1, "\r\nBad Edid Version 2.X");
            return  (FALSE);
        }
    }

    DBG_PRINT1(DL_1, "\r\nEdid Version %x", nEdidVersion);
    return (nEdidVersion);
}


/*
    Function:   EdidFindNumTimingCodes

    Purpose:    Finds the number of luminance tables, size of luminance
                table, number of frequency ranges, number of detailed
                range limits, number of timing codes, and number of
                detailed timings. This is only valid for Version 2.x
                EDIDs.

    Arguments:  lpEdidBuffer    EDID data
                dwEdidSize      length of EDID
                lpTC            Ptr to array for Timing Code return values.

    Returns:    TRUE    timing codes were located and lpTC was fiiled in
                FALSE   no timing codes were found

    Preserve:
*/

int CFUNC
EdidFindNumTimingCodes (
    LPCHAR          lpEdidBuffer,
    ULONG           dwEdidSize,
    LPTIMINGCODES   lpTC)
{
    ULONG           dwInfo;
    USHORT          wLuminanceInfo;
    LPEDIDV2STRUC   lpV2 = (LPEDIDV2STRUC) lpEdidBuffer;

    dwInfo = (ULONG) lpV2->wTimingInfoMap;

    // Calculate Luminance Table. There is one table if bit 5 is set.
    if (dwInfo & 0x20)
    {
        lpTC->dwNumLuminanceTables = 1;

        // Let n = EdidBuffer[0x80] bits [4:0]
        // if EdidBuffer[0x80] bit 7 = 0
        //    then the size of the luminance table is n + 1
        // if EdidBuffer[0x80] bit 7 = 1
        //    then the size of the luminance table is 3n + 1
        wLuminanceInfo = (USHORT) lpV2->bTableDescriptors[0];
        if (wLuminanceInfo & 0x80)
            lpTC->dwSizeLuminanceTables =
                        (ULONG) (3 * (wLuminanceInfo & 0x1F) + 1);
        else
            lpTC->dwSizeLuminanceTables = (ULONG) (wLuminanceInfo + 1);
    }
    else
    {
        lpTC->dwNumLuminanceTables  = 0;
        lpTC->dwSizeLuminanceTables = 0;
    }

    lpTC->dwNumFreqRanges      = (dwInfo  >> 2) & 7;
    lpTC->dwNumRangeLimits     = dwInfo & 0x03;
    lpTC->dwNumTimingCodes     = (dwInfo >> (8 + 3)) & 0x1F;
    lpTC->dwNumDetailedTimings = (dwInfo >> 8) & 0x07;

    return  (TRUE);
}


/*
    Function:   EdidGetMonitorLimits

    Purpose:    Find the limits of operation by searching for a Monitor
                Descriptor Block with a Data Tag of FDh (Monitor Range
                Limits).

    Arguments:  EdidVersion     Version of EDID block.
                MonitorLimits   Ptr to array of monitor limits.

    Returns:    TRUE    Monitor Limits
                FALSE   No Monitor Limits

    Preserve:
*/

int CFUNC
EdidGetMonitorLimits (
    LPCHAR          lpEdidBuffer,
    ULONG           dwEdidSize,
    LPMONITORLIMITS lpML)
{
    int             i;
    int             nEdidVersion;
    TIMINGCODES     TimingCodes;
    ULONG           dwMinFrame, dwMaxFrame;
    ULONG           dwMinLine, dwMaxLine;
    ULONG           dwMinClock, dwMaxClock;

    nEdidVersion = EdidGetVersion (lpEdidBuffer, dwEdidSize);

    // If we couldn't figure out what version it was, then say that
    // there are no monitor range limits.
    if  (!nEdidVersion)
        return  (FALSE);

    if  (nEdidVersion < 0x200)
    {
        LPEDIDV1STRUC       lpV1 = (LPEDIDV1STRUC) lpEdidBuffer;
        LPMONITORDESCRITOR  lpMD = (LPMONITORDESCRITOR) lpV1->DetailedTimingDesc;

        // Start all the mins high and the maxs low, so they
        // will get changed when we find something more restrictive.
        lpML->dwMinHorz = 0x00;
        lpML->dwMaxHorz = 0x0FFFFFFFF;
        lpML->dwMinVert = 0x00;
        lpML->dwMaxVert = 0x0FFFFFFFF;

        // Start out with the maximum pixel clock being the largest
        // pixel clock found in all EDID timings.
        lpML->dwMaxPixelClock = EdidFindLargestPixelClock (lpEdidBuffer, dwEdidSize);
        lpML->dwMaxPixelClock = Multiply32By32 (lpML->dwMaxPixelClock, 10000);

        // There are 4 detailed timing descriptors in a version 1.X edid.
        // The detailed timing descriptor blocks do double duty as a
        // monitor range descriptor block when the first three bytes are 0,
        // and the fourth byte is FDh.
        for (i = 0; i < 4; i++, lpMD++)
        {
           // For Monitor Descriptor, the first 3 bytes must all be zero
           // and the monitor descriptor type must be a range limit.
           if   ((lpMD->wZeroFlag == 0) && (lpMD->bZeroFlag == 0) &&
                 (lpMD->bTypeDescriptorBlock == DT_MONITOR_RANGE_LIMITS))
           {
                dwMinLine  = Multiply32By32 (lpMD->bMinHorzRateInKHz, 1000);
                dwMaxLine  = Multiply32By32 (lpMD->bMaxHorzRateInKHz, 1000);
                dwMinFrame = (ULONG) lpMD->bMinVertRateInHz;
                dwMaxFrame = (ULONG) lpMD->bMaxVertRateInHz;

                // Now do an intersection
                if  (dwMinFrame > lpML->dwMinVert)
                    lpML->dwMinVert = dwMinFrame;

                if  (dwMaxFrame < lpML->dwMaxVert)
                    lpML->dwMaxVert = dwMaxFrame;

                if  (dwMinLine > lpML->dwMinHorz)
                    lpML->dwMinHorz = dwMinLine;

                if  (dwMaxLine < lpML->dwMaxHorz)
                    lpML->dwMaxHorz = dwMaxLine;

                // If the bMaxPixelClockInCKHz in the EDID range limits is
                // 0xFF, then the pixel clock is not specified.
                if (lpMD->bMaxPixelClockInCKHz != 0xFF)
                {
                    dwMaxClock = Multiply32By32 (lpMD->bMaxPixelClockInCKHz, 10000000);
                    if  (dwMaxClock > lpML->dwMaxPixelClock)
                        lpML->dwMaxPixelClock = dwMaxClock;
                }
                else
                {
                    MODEINFO    sMI;

                    // Find a pixel clock using largest mode from EDID. 
                    // GetMaximumRefreshRate fills out lpML->dwMaxPixelClock.
                    // 640 and 480 are being used for dwTargetXRes and
                    // dwTargetYRes respectively, but these parameters are
                    // irrelevant because we just want the pixel clock and
                    // not the refresh rate. Be sure to zero out
                    // lpML->dwMaxPixelClock, or GetMaximumRefreshRate will
                    // not a calculate a pixel clock.
                    sMI.dwRefreshRate = 0;
                    EdidFindLargestEdidMode (lpEdidBuffer, dwEdidSize, &sMI);

                    lpML->dwMaxPixelClock = 0;
                    GetMaximumRefreshRate (sMI.dwXRes, sMI.dwYRes,
                                           sMI.dwRefreshRate, lpML, 640, 480);

                }
            }
        }

        // If we didn't find any reasonable values, then outta here
        if  ((lpML->dwMinVert == 0x00) ||
             (lpML->dwMaxVert == 0x0FFFFFFFF))
        {
            return  (FALSE);
        }

        return  (TRUE);
    }


    if  (nEdidVersion >= 0x200)
    {
        LPEDIDV2STRUC           lpV2 = (LPEDIDV2STRUC) lpEdidBuffer;
        LPDISPLAYTIMINGRANGE    lpTR;
        LPDETAILEDTIMINGRANGE   lpDT;
        ULONG                   dwExtra;
        ULONG                   dwClockExtra;
        ULONG                   dwLargestHBlank, dwLargestVBlank;
        ULONG                   dwLargestHTotal, dwLargestVTotal;
        ULONG                   dwSmallestHBlank, dwSmallestVBlank;
        ULONG                   dwSmallestHTotal, dwSmallestVTotal;
        ULONG                   j, k;
        LPCHAR                  lpC;
        int                     nSum;

        EdidFindNumTimingCodes (lpEdidBuffer, dwEdidSize, &TimingCodes);

        // If there were no monitor range limits, then outta here
        if  ((TimingCodes.dwNumFreqRanges == 0) &&
             (TimingCodes.dwNumRangeLimits == 0))
            return  (FALSE);

        // There are two types of monitor range limits in a
        // version 2.XX EDID. The first is a simple min/max
        // horz frequemcy, min/max vertical frequency, and
        // min/max pixel clock. The second includes this
        // and also specifies min/max values for sync offsets,
        // sync pulse widths, blanking, image size, borders
        // interlaced/non-interlaced, and sync polarities.
        // In any case, what we want to do is return a
        // MONITORLIMITS structure that is the intersection
        // of any and all these. The point is that we assume
        // that all of them apply and hence we want to restrict
        // by every one of them. NOTE that MONITORLIMITS
        // doesn't deal with all the blanking, sync pulses,
        // etc in the more detailed type of range limit struct
        // in the EDID, so we will ignore that for now. All
        // we care about are the min and max for each of
        // pixel clock, horz freq and vert freq.

        // In version 2.XX of the EDID, there is a section which
        // can contain 5 different types of objects. The first,
        // if it exists, are luminance tables which we just skip over.

        i = (int) (TimingCodes.dwNumLuminanceTables *
                 TimingCodes.dwSizeLuminanceTables);

        // Start all the mins high and the maxs low, so they
        // will get changed when we find something more restrictive.
        lpML->dwMinHorz = 0x00;
        lpML->dwMaxHorz = 0x0FFFFFFFF;
        lpML->dwMinVert = 0x00;
        lpML->dwMaxVert = 0x0FFFFFFFF;
        lpML->dwMaxPixelClock = 0x0FFFFFFFF;

        // The next is the simple range limit structures
        // There can be more than one.
        for (j = 0; j < TimingCodes.dwNumFreqRanges; j++)
        {
            lpTR = (LPDISPLAYTIMINGRANGE) &(lpV2->bTableDescriptors[i]);
            lpC  = (LPCHAR) lpTR;

            // Be careful here. For fixed frequency devices, all these
            // fields are set to 0.
            for (nSum = 0, k = 0; k < 8; k++)
                nSum += (int) lpC[k];

            if  (nSum != 0)
            {
                dwExtra    = ((ULONG) lpTR->bLoHV);
                dwMinFrame = (((ULONG) lpTR->bHiMinVert) << 2) + ((dwExtra >> 6) & 0x03);
                dwMaxFrame = (((ULONG) lpTR->bHiMaxVert) << 2) + ((dwExtra >> 4) & 0x03);
                dwMinLine  = (((ULONG) lpTR->bHiMinHorz) << 2) + ((dwExtra >> 2) & 0x03);
                dwMinLine  = Multiply32By32 (dwMinLine, 1000);
                dwMaxLine  = (((ULONG) lpTR->bHiMaxHorz) << 2) + ((dwExtra >> 0) & 0x03);
                dwMaxLine  = Multiply32By32 (dwMaxLine, 1000);

                dwClockExtra = ((ULONG) lpTR->bHiMinMaxPixClock);
                dwMaxClock   = ((ULONG) lpTR->bLoMaxPixClock) + ((dwClockExtra & 0x0F) << 8);
                dwMaxClock   = Multiply32By32 (dwMaxClock, 1000000);

                // Now do an intersection
                if  (dwMinFrame > lpML->dwMinVert)
                    lpML->dwMinVert = dwMinFrame;

                if  (dwMaxFrame < lpML->dwMaxVert)
                    lpML->dwMaxVert = dwMaxFrame;

                if  (dwMinLine > lpML->dwMinHorz)
                    lpML->dwMinHorz = dwMinLine;

                if  (dwMaxLine < lpML->dwMaxHorz)
                    lpML->dwMaxHorz = dwMaxLine;

                if  (dwMaxClock < lpML->dwMaxPixelClock)
                    lpML->dwMaxPixelClock = dwMaxClock;
            }

            i += sizeof(DISPLAYTIMINGRANGE);
        }

        // Now, handle any of the more complicated monitor limit structs.
        for (j = 0; j < TimingCodes.dwNumRangeLimits; j++)
        {
            lpDT = (LPDETAILEDTIMINGRANGE) &(lpV2->bTableDescriptors[i]);

            dwMinClock = ((ULONG) lpDT->wMinPixelClock) * 10000;
            dwMaxClock = ((ULONG) lpDT->wMaxPixelClock) * 10000;

            // The highest vertical frequency is obtained by using
            // dividing the maximum pixel clock by the smallest
            // total pixel count.
            dwSmallestHBlank = ((ULONG) lpDT->bLowMinHBlank) +
                                ((((ULONG) lpDT->bHiMinHVBlank) & 0xF0) << 4);
            dwSmallestVBlank = ((ULONG) lpDT->bLowMinVBlank) +
                                ((((ULONG) lpDT->bHiMinHVBlank) & 0x0F) << 8);
            dwSmallestHTotal = dwSmallestHBlank + ((ULONG) lpDT->bLowHActive)
                                + ((((ULONG) lpDT->bHiHVActive) & 0xF0) << 4);
            dwSmallestVTotal = dwSmallestVBlank + ((ULONG) lpDT->bLowVActive)
                                + ((((ULONG) lpDT->bHiHVActive) & 0x0F) << 8);
            dwMaxFrame = dwMaxClock / (dwSmallestVTotal * dwSmallestHTotal);
            dwMaxLine  = dwMaxClock / dwSmallestHTotal;

            dwLargestHBlank = ((ULONG) lpDT->bLowMaxHBlank) +
                                ((((ULONG) lpDT->bHiMaxHVBlank) & 0xF0) << 4);
            dwLargestVBlank = ((ULONG) lpDT->bLowMaxVBlank) +
                                ((((ULONG) lpDT->bHiMaxHVBlank) & 0x0F) << 8);
            dwLargestHTotal = dwLargestHBlank + ((ULONG) lpDT->bLowHActive)
                                + ((((ULONG) lpDT->bHiHVActive) & 0xF0) << 4);
            dwLargestVTotal = dwLargestVBlank + ((ULONG) lpDT->bLowVActive)
                                + ((((ULONG) lpDT->bHiHVActive) & 0x0F) << 8);
            dwMinFrame = dwMinClock / (dwLargestVTotal * dwLargestHTotal);
            dwMinLine  = dwMinClock / dwLargestHTotal;

            // Now do an intersection
            if  (dwMinFrame > lpML->dwMinVert)
                lpML->dwMinVert = dwMinFrame;

            if  (dwMaxFrame < lpML->dwMaxVert)
                lpML->dwMaxVert = dwMaxFrame;

            if  (dwMinLine > lpML->dwMinHorz)
                lpML->dwMinHorz = dwMinLine;

            if  (dwMaxLine < lpML->dwMaxHorz)
                lpML->dwMaxHorz = dwMaxLine;

            if  (dwMaxClock < lpML->dwMaxPixelClock)
            {
                // Add about 5% to their max pixel clock because
                // if this is a fixed freq timing, will never match
                // it exactly.
                lpML->dwMaxPixelClock = (dwMaxClock * 21) / 20;
            }

            i += sizeof(DETAILEDTIMINGRANGE);
        }

        // If we didn't find any reasonable values, then outta here
        if  ((lpML->dwMinVert == 0x00) ||
             (lpML->dwMaxVert == 0x0FFFFFFFF))
        {
            return  (FALSE);
        }

        return  (TRUE);
    }

    return (FALSE);
}



/*
    Function:   EdidIsGtfMonitor

    Purpose:    Checks EDID block to see if display type supports GTF.

    Arguments:  lpEdidBuffer    The EDID
                dwEdidSize      EDID size in bytes

    Returns:    TRUE            Display type supports GTF.
                FALSE           Display type does not support GTF.

    Preserve:
*/

int CFUNC
EdidIsGtfMonitor (LPCHAR lpEdidBuffer, ULONG dwEdidSize)
{
    int             nEdidVersion;
    MONITORLIMITS   sML;

    // Get the EDID version
    nEdidVers