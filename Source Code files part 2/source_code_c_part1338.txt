EXPANDED_CATEGORY	((ULONG) 3)
#define TBL_COLLAPSED_CATEGORY	((ULONG) 4)

/* Table wait flag */

#define TBL_NOWAIT			((ULONG) 0x00000001)
/* alternative name for TBL_NOWAIT */
#define TBL_ASYNC			((ULONG) 0x00000001)
#define TBL_BATCH			((ULONG) 0x00000002)

/* FindRow */

#define DIR_BACKWARD		((ULONG) 0x00000001)

/* Table cursor states */

#define TBL_NOADVANCE		((ULONG) 0x00000001)

#define MAPI_IMAPITABLE_METHODS(IPURE)									\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(Advise)													\
		(THIS_	ULONG						ulEventMask,				\
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unadvise)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
	MAPIMETHOD(GetStatus)												\
		(THIS_	ULONG FAR *					lpulTableStatus,			\
				ULONG FAR *					lpulTableType) IPURE;		\
	MAPIMETHOD(SetColumns)												\
		(THIS_	LPSPropTagArray				lpPropTagArray,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(QueryColumns)											\
		(THIS_	ULONG						ulFlags,					\
				LPSPropTagArray FAR *		lpPropTagArray) IPURE;		\
	MAPIMETHOD(GetRowCount)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG FAR *					lpulCount) IPURE;			\
	MAPIMETHOD(SeekRow)													\
		(THIS_	BOOKMARK					bkOrigin,					\
				LONG						lRowCount,					\
				LONG FAR *					lplRowsSought) IPURE;		\
	MAPIMETHOD(SeekRowApprox)											\
		(THIS_	ULONG						ulNumerator,				\
				ULONG						ulDenominator) IPURE;		\
	MAPIMETHOD(QueryPosition)											\
		(THIS_	ULONG FAR *					lpulRow,					\
				ULONG FAR *					lpulNumerator,				\
				ULONG FAR *					lpulDenominator) IPURE;		\
	MAPIMETHOD(FindRow)													\
		(THIS_	LPSRestriction				lpRestriction,				\
				BOOKMARK					bkOrigin,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(Restrict)												\
		(THIS_	LPSRestriction				lpRestriction,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(CreateBookmark)											\
		(THIS_	BOOKMARK FAR *				lpbkPosition) IPURE;		\
	MAPIMETHOD(FreeBookmark)											\
		(THIS_	BOOKMARK					bkPosition) IPURE;			\
	MAPIMETHOD(SortTable)												\
		(THIS_	LPSSortOrderSet				lpSortCriteria,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(QuerySortOrder)											\
		(THIS_	LPSSortOrderSet FAR *		lppSortCriteria) IPURE;		\
	MAPIMETHOD(QueryRows)												\
		(THIS_	LONG						lRowCount,					\
				ULONG						ulFlags,					\
				LPSRowSet FAR *				lppRows) IPURE;				\
	MAPIMETHOD(Abort) (THIS) IPURE;										\
	MAPIMETHOD(ExpandRow)												\
		(THIS_	ULONG						cbInstanceKey,				\
				LPBYTE						pbInstanceKey,				\
				ULONG						ulRowCount,					\
				ULONG						ulFlags,					\
				LPSRowSet FAR *				lppRows,					\
				ULONG FAR *					lpulMoreRows) IPURE;		\
	MAPIMETHOD(CollapseRow)												\
		(THIS_	ULONG						cbInstanceKey,				\
				LPBYTE						pbInstanceKey,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulRowCount) IPURE;		\
	MAPIMETHOD(WaitForCompletion)										\
		(THIS_	ULONG						ulFlags,					\
				ULONG						ulTimeout,					\
				ULONG FAR *					lpulTableStatus) IPURE;		\
	MAPIMETHOD(GetCollapseState)										\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cbInstanceKey,				\
				LPBYTE						lpbInstanceKey,				\
				ULONG FAR *					lpcbCollapseState,			\
				LPBYTE FAR *				lppbCollapseState) IPURE;	\
	MAPIMETHOD(SetCollapseState)										\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cbCollapseState,			\
				LPBYTE						pbCollapseState,			\
				BOOKMARK FAR *				lpbkLocation) IPURE;		\

#undef		 INTERFACE
#define		 INTERFACE  IMAPITable
DECLARE_MAPI_INTERFACE_(IMAPITable, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPITABLE_METHODS(PURE)
};

/* IProfSect Interface ----------------------------------------------------- */

/* Standard section for public profile properties */

#define PS_PROFILE_PROPERTIES_INIT \
{ 	0x98, 0x15, 0xAC, 0x08, 0xAA, 0xB0, 0x10, 0x1A, \
	0x8C, 0x93, 0x08, 0x00, 0x2B, 0x2A, 0x56, 0xC2  }


#define MAPI_IPROFSECT_METHODS(IPURE)

#undef		 INTERFACE
#define		 INTERFACE  IProfSect
DECLARE_MAPI_INTERFACE_(IProfSect, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IPROFSECT_METHODS(PURE)
};

/* IMAPIStatus Interface --------------------------------------------------- */

/* Values for PR_RESOURCE_TYPE, _METHODS, _FLAGS */

#define MAPI_STORE_PROVIDER		((ULONG) 33)	/* Message Store */
#define MAPI_AB					((ULONG) 34)	/* Address Book */
#define MAPI_AB_PROVIDER		((ULONG) 35)	/* Address Book Provider */
#define MAPI_TRANSPORT_PROVIDER	((ULONG) 36)	/* Transport Provider */
#define MAPI_SPOOLER			((ULONG) 37)	/* Message Spooler */
#define MAPI_PROFILE_PROVIDER	((ULONG) 38)	/* Profile Provider */
#define MAPI_SUBSYSTEM			((ULONG) 39)	/* Overall Subsystem Status */
#define MAPI_HOOK_PROVIDER		((ULONG) 40)	/* Spooler Hook */

#define STATUS_VALIDATE_STATE	((ULONG) 0x00000001)
#define STATUS_SETTINGS_DIALOG	((ULONG) 0x00000002)
#define STATUS_CHANGE_PASSWORD	((ULONG) 0x00000004)
#define STATUS_FLUSH_QUEUES		((ULONG) 0x00000008)

#define STATUS_DEFAULT_OUTBOUND	((ULONG) 0x00000001)
#define STATUS_DEFAULT_STORE	((ULONG) 0x00000002)
#define STATUS_PRIMARY_IDENTITY	((ULONG) 0x00000004)
#define STATUS_SIMPLE_STORE		((ULONG) 0x00000008)
#define STATUS_XP_PREFER_LAST	((ULONG) 0x00000010)
#define STATUS_NO_PRIMARY_IDENTITY ((ULONG) 0x00000020)
#define STATUS_NO_DEFAULT_STORE	((ULONG) 0x00000040)
#define STATUS_TEMP_SECTION		((ULONG) 0x00000080)
#define STATUS_OWN_STORE		((ULONG) 0x00000100)
/****** HOOK_INBOUND			((ULONG) 0x00000200) Defined in MAPIHOOK.H */
/****** HOOK_OUTBOUND			((ULONG) 0x00000400) Defined in MAPIHOOK.H */
#define STATUS_NEED_IPM_TREE	((ULONG) 0x00000800)
#define	STATUS_PRIMARY_STORE	((ULONG) 0x00001000)
#define	STATUS_SECONDARY_STORE	((ULONG) 0x00002000)


/*
 * PR_STATUS_CODE bit. Low 16 bits for common values; High 16 bits
 * for provider type-specific values. (DCR 304)
 */

#define	STATUS_AVAILABLE		((ULONG) 0x00000001)
#define STATUS_OFFLINE			((ULONG) 0x00000002)
#define STATUS_FAILURE			((ULONG) 0x00000004)

/* Transport values of PR_STATUS_CODE */

#define STATUS_INBOUND_ENABLED	((ULONG) 0x00010000)
#define STATUS_INBOUND_ACTIVE	((ULONG) 0x00020000)
#define STATUS_INBOUND_FLUSH	((ULONG) 0x00040000)
#define STATUS_OUTBOUND_ENABLED	((ULONG) 0x00100000)
#define STATUS_OUTBOUND_ACTIVE	((ULONG) 0x00200000)
#define STATUS_OUTBOUND_FLUSH	((ULONG) 0x00400000)
#define	STATUS_REMOTE_ACCESS	((ULONG) 0x00800000)

/* ValidateState flags */

#define SUPPRESS_UI					((ULONG) 0x00000001)
#define	REFRESH_XP_HEADER_CACHE		((ULONG) 0x00010000)
#define	PROCESS_XP_HEADER_CACHE 	((ULONG) 0x00020000)
#define	FORCE_XP_CONNECT			((ULONG) 0x00040000)
#define FORCE_XP_DISCONNECT			((ULONG) 0x00080000)
#define CONFIG_CHANGED				((ULONG) 0x00100000)
#define ABORT_XP_HEADER_OPERATION	((ULONG) 0x00200000)
#define SHOW_XP_SESSION_UI			((ULONG) 0x00400000)

/* SettingsDialog flags */

#define UI_READONLY		((ULONG) 0x00000001)

/* FlushQueues flags */

#define FLUSH_UPLOAD		((ULONG) 0x00000002)
#define FLUSH_DOWNLOAD		((ULONG) 0x00000004)
#define FLUSH_FORCE			((ULONG) 0x00000008)
#define FLUSH_NO_UI			((ULONG) 0x00000010)
#define FLUSH_ASYNC_OK		((ULONG) 0x00000020)

#define MAPI_IMAPISTATUS_METHODS(IPURE)									\
	MAPIMETHOD(ValidateState)											\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(SettingsDialog)											\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(ChangePassword)											\
		(THIS_	LPTSTR						lpOldPass,					\
				LPTSTR						lpNewPass,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(FlushQueues)												\
		(THIS_	ULONG						ulUIParam,					\
				ULONG						cbTargetTransport,			\
				LPENTRYID					lpTargetTransport,			\
				ULONG						ulFlags) IPURE;				\

#undef		 INTERFACE
#define		 INTERFACE  IMAPIStatus
DECLARE_MAPI_INTERFACE_(IMAPIStatus, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMAPISTATUS_METHODS(PURE)
};

/* IMAPIContainer Interface ------------------------------------------------ */

/* Flags for OpenEntry() */

/****** MAPI_MODIFY				((ULONG) 0x00000001) above */
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
#define MAPI_BEST_ACCESS		((ULONG) 0x00000010)

/* GetContentsTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
/****** MAPI_ASSOCIATED			((ULONG) 0x00000040) below */

/* GetHierarchyTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */
#define CONVENIENT_DEPTH		((ULONG) 0x00000001)
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */

/* GetSearchCriteria */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */
#define SEARCH_RUNNING			((ULONG) 0x00000001)
#define SEARCH_REBUILD			((ULONG) 0x00000002)
#define SEARCH_RECURSIVE		((ULONG) 0x00000004)
#define SEARCH_FOREGROUND		((ULONG) 0x00000008)

/* SetSearchCriteria */
#define STOP_SEARCH				((ULONG) 0x00000001)
#define RESTART_SEARCH			((ULONG) 0x00000002)
#define RECURSIVE_SEARCH		((ULONG) 0x00000004)
#define SHALLOW_SEARCH			((ULONG) 0x00000008)
#define FOREGROUND_SEARCH		((ULONG) 0x00000010)
#define BACKGROUND_SEARCH		((ULONG) 0x00000020)

#define MAPI_IMAPICONTAINER_METHODS(IPURE)								\
	MAPIMETHOD(GetContentsTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(GetHierarchyTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(OpenEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulObjType,				\
				LPUNKNOWN FAR *				lppUnk) IPURE;				\
	MAPIMETHOD(SetSearchCriteria)										\
		(THIS_	LPSRestriction				lpRestriction,				\
				LPENTRYLIST					lpContainerList,			\
				ULONG						ulSearchFlags) IPURE;		\
	MAPIMETHOD(GetSearchCriteria)										\
		(THIS_	ULONG						ulFlags,					\
				LPSRestriction FAR *		lppRestriction,				\
				LPENTRYLIST FAR *			lppContainerList,			\
				ULONG FAR *					lpulSearchState)IPURE;		\

#undef		 INTERFACE
#define		 INTERFACE  IMAPIContainer
DECLARE_MAPI_INTERFACE_(IMAPIContainer, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMAPICONTAINER_METHODS(PURE)
};

/* IABContainer Interface -------------------------------------------------- */

/*
 *	IABContainer PR_CONTAINER_FLAGS values
 *	If AB_UNMODIFIABLE and AB_MODIFIABLE are both set, it means the container
 *	doesn't know if it's modifiable or not, and the client should
 *  try to modify the contents but we won't expect it to work.
 *	If the AB_RECIPIENTS flag is set and neither AB_MODIFIABLE or AB_UNMODIFIABLE
 *  bits are set, it is an error.
 */

typedef struct _flaglist
{
	ULONG cFlags;
	ULONG ulFlag[MAPI_DIM];
} FlagList, FAR * LPFlagList;


/*
 *  Container flags
 */
#define AB_RECIPIENTS			((ULONG) 0x00000001)
#define AB_SUBCONTAINERS		((ULONG) 0x00000002)
#define AB_MODIFIABLE			((ULONG) 0x00000004)
#define AB_UNMODIFIABLE			((ULONG) 0x00000008)
#define AB_FIND_ON_OPEN			((ULONG) 0x00000010)
#define AB_NOT_DEFAULT			((ULONG) 0x00000020)

/* CreateEntry() */

#define CREATE_CHECK_DUP_STRICT	((ULONG) 0x00000001)
#define CREATE_CHECK_DUP_LOOSE	((ULONG) 0x00000002)
#define CREATE_REPLACE			((ULONG) 0x00000004)

/* ResolveNames() - ulFlags */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* ResolveNames() - rgulFlags */
#define MAPI_UNRESOLVED			((ULONG) 0x00000000)
#define MAPI_AMBIGUOUS			((ULONG) 0x00000001)
#define MAPI_RESOLVED			((ULONG) 0x00000002)


#define MAPI_IABCONTAINER_METHODS(IPURE)								\
	MAPIMETHOD(CreateEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulCreateFlags,				\
				LPMAPIPROP FAR	*			lppMAPIPropEntry) IPURE;	\
	MAPIMETHOD(CopyEntries)												\
		(THIS_	LPENTRYLIST					lpEntries,					\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(DeleteEntries)											\
		(THIS_	LPENTRYLIST					lpEntries,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(ResolveNames)											\
		(THIS_	LPSPropTagArray				lpPropTagArray,				\
				ULONG						ulFlags,					\
				LPADRLIST					lpAdrList,					\
				LPFlagList					lpFlagList) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IABContainer
DECLARE_MAPI_INTERFACE_(IABContainer, IMAPIContainer)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMAPICONTAINER_METHODS(PURE)
	MAPI_IABCONTAINER_METHODS(PURE)
};

/* IMailUser Interface ----------------------------------------------------- */

/*  Any call which can create a one-off entryID (i.e. MAPISupport::CreateOneOff
    or IAdrBook::CreateOneOff) can encode the value for PR_SEND_RICH_INFO by
	passing in the following flag in the ulFlags parameter.  Setting this flag
	indicates that PR_SEND_RICH_INFO will be FALSE.
*/
#define MAPI_SEND_NO_RICH_INFO		((ULONG) 0x00010000)




/* Values of PR_NDR_DIAG_CODE */

#define MAPI_DIAG(_code)	((LONG) _code)

#define MAPI_DIAG_NO_DIAGNOSTIC						MAPI_DIAG( -1 )
#define MAPI_DIAG_OR_NAME_UNRECOGNIZED				MAPI_DIAG( 0 )
#define MAPI_DIAG_OR_NAME_AMBIGUOUS					MAPI_DIAG( 1 )
#define MAPI_DIAG_MTS_CONGESTED						MAPI_DIAG( 2 )
#define MAPI_DIAG_LOOP_DETECTED						MAPI_DIAG( 3 )
#define MAPI_DIAG_RECIPIENT_UNAVAILABLE				MAPI_DIAG( 4 )
#define MAPI_DIAG_MAXIMUM_TIME_EXPIRED				MAPI_DIAG( 5 )
#define MAPI_DIAG_EITS_UNSUPPORTED					MAPI_DIAG( 6 )
#define MAPI_DIAG_CONTENT_TOO_LONG					MAPI_DIAG( 7 )
#define MAPI_DIAG_IMPRACTICAL_TO_CONVERT			MAPI_DIAG( 8 )
#define MAPI_DIAG_PROHIBITED_TO_CONVERT				MAPI_DIAG( 9 )
#define MAPI_DIAG_CONVERSION_UNSUBSCRIBED			MAPI_DIAG( 10 )
#define MAPI_DIAG_PARAMETERS_INVALID				MAPI_DIAG( 11 )
#define MAPI_DIAG_CONTENT_SYNTAX_IN_ERROR			MAPI_DIAG( 12 )
#define MAPI_DIAG_LENGTH_CONSTRAINT_VIOLATD			MAPI_DIAG( 13 )
#define MAPI_DIAG_NUMBER_CONSTRAINT_VIOLATD			MAPI_DIAG( 14 )
#define MAPI_DIAG_CONTENT_TYPE_UNSUPPORTED			MAPI_DIAG( 15 )
#define MAPI_DIAG_TOO_MANY_RECIPIENTS				MAPI_DIAG( 16 )
#define MAPI_DIAG_NO_BILATERAL_AGREEMENT			MAPI_DIAG( 17 )
#define MAPI_DIAG_CRITICAL_FUNC_UNSUPPORTED			MAPI_DIAG( 18 )
#define MAPI_DIAG_CONVERSION_LOSS_PROHIB			MAPI_DIAG( 19 )
#define MAPI_DIAG_LINE_TOO_LONG						MAPI_DIAG( 20 )
#define MAPI_DIAG_PAGE_TOO_LONG						MAPI_DIAG( 21 )
#define MAPI_DIAG_PICTORIAL_SYMBOL_LOST				MAPI_DIAG( 22 )
#define MAPI_DIAG_PUNCTUATION_SYMBOL_LOST			MAPI_DIAG( 23 )
#define MAPI_DIAG_ALPHABETIC_CHARACTER_LOST			MAPI_DIAG( 24 )
#define MAPI_DIAG_MULTIPLE_INFO_LOSSES				MAPI_DIAG( 25 )
#define MAPI_DIAG_REASSIGNMENT_PROHIBITED			MAPI_DIAG( 26 )
#define MAPI_DIAG_REDIRECTION_LOOP_DETECTED			MAPI_DIAG( 27 )
#define MAPI_DIAG_EXPANSION_PROHIBITED				MAPI_DIAG( 28 )
#define MAPI_DIAG_SUBMISSION_PROHIBITED				MAPI_DIAG( 29 )
#define MAPI_DIAG_EXPANSION_FAILED					MAPI_DIAG( 30 )
#define MAPI_DIAG_RENDITION_UNSUPPORTED				MAPI_DIAG( 31 )
#define MAPI_DIAG_MAIL_ADDRESS_INCORRECT			MAPI_DIAG( 32 )
#define MAPI_DIAG_MAIL_OFFICE_INCOR_OR_INVD			MAPI_DIAG( 33 )
#define MAPI_DIAG_MAIL_ADDRESS_INCOMPLETE			MAPI_DIAG( 34 )
#define MAPI_DIAG_MAIL_RECIPIENT_UNKNOWN			MAPI_DIAG( 35 )
#define MAPI_DIAG_MAIL_RECIPIENT_DECEASED			MAPI_DIAG( 36 )
#define MAPI_DIAG_MAIL_ORGANIZATION_EXPIRED			MAPI_DIAG( 37 )
#define MAPI_DIAG_MAIL_REFUSED						MAPI_DIAG( 38 )
#define MAPI_DIAG_MAIL_UNCLAIMED					MAPI_DIAG( 39 )
#define MAPI_DIAG_MAIL_RECIPIENT_MOVED				MAPI_DIAG( 40 )
#define MAPI_DIAG_MAIL_RECIPIENT_TRAVELLING			MAPI_DIAG( 41 )
#define MAPI_DIAG_MAIL_RECIPIENT_DEPARTED			MAPI_DIAG( 42 )
#define MAPI_DIAG_MAIL_NEW_ADDRESS_UNKNOWN			MAPI_DIAG( 43 )
#define MAPI_DIAG_MAIL_FORWARDING_UNWANTED			MAPI_DIAG( 44 )
#define MAPI_DIAG_MAIL_FORWARDING_PROHIB			MAPI_DIAG( 45 )
#define MAPI_DIAG_SECURE_MESSAGING_ERROR			MAPI_DIAG( 46 )
#define MAPI_DIAG_DOWNGRADING_IMPOSSIBLE			MAPI_DIAG( 47 )

/* Values of PR_DELIVERY_POINT (MH_T_DELIVERY_POINT) */

#define MAPI_MH_DP_PUBLIC_UA						((ULONG) 0)
#define MAPI_MH_DP_PRIVATE_UA						((ULONG) 1)
#define MAPI_MH_DP_MS								((ULONG) 2)
#define MAPI_MH_DP_ML								((ULONG) 3)
#define MAPI_MH_DP_PDAU								((ULONG) 4)
#define MAPI_MH_DP_PDS_PATRON						((ULONG) 5)
#define MAPI_MH_DP_OTHER_AU							((ULONG) 6)


#define MAPI_IMAILUSER_METHODS(IPURE)

#undef		 INTERFACE
#define		 INTERFACE  IMailUser
DECLARE_MAPI_INTERFACE_(IMailUser, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMAILUSER_METHODS(PURE)
};

/* IDistList Interface ----------------------------------------------------- */

#define MAPI_IDISTLIST_METHODS(IPURE)									\
	MAPIMETHOD(CreateEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulCreateFlags,				\
				LPMAPIPROP FAR	*			lppMAPIPropEntry) IPURE;	\
	MAPIMETHOD(CopyEntries)												\
		(THIS_	LPENTRYLIST					lpEntries,					\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(DeleteEntries)											\
		(THIS_	LPENTRYLIST					lpEntries,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(ResolveNames)											\
		(THIS_	LPSPropTagArray				lpPropTagArray,				\
				ULONG						ulFlags,					\
				LPADRLIST					lpAdrList,					\
				LPFlagList					lpFlagList) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IDistList
DECLARE_MAPI_INTERFACE_(IDistList, IMAPIContainer)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMAPICONTAINER_METHODS(PURE)
	MAPI_IDISTLIST_METHODS(PURE)
};

/* IMAPIFolder Interface --------------------------------------------------- */

/* IMAPIFolder folder type (enum) */

#define FOLDER_ROOT				((ULONG) 0x00000000)
#define FOLDER_GENERIC			((ULONG) 0x00000001)
#define FOLDER_SEARCH			((ULONG) 0x00000002)

/* CreateMessage */
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
/****** MAPI_ASSOCIATED			((ULONG) 0x00000040) below */

/* CopyMessages */

#define MESSAGE_MOVE			((ULONG) 0x00000001)
#define MESSAGE_DIALOG			((ULONG) 0x00000002)
/****** MAPI_DECLINE_OK			((ULONG) 0x00000004) above */

/* CreateFolder */

#define OPEN_IF_EXISTS			((ULONG) 0x00000001)
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* DeleteFolder */

#define DEL_MESSAGES			((ULONG) 0x00000001)
#define FOLDER_DIALOG			((ULONG) 0x00000002)
#define DEL_FOLDERS				((ULONG) 0x00000004)

/* EmptyFolder */
#define DEL_ASSOCIATED			((ULONG) 0x00000008)

/* CopyFolder */

#define FOLDER_MOVE				((ULONG) 0x00000001)
/****** FOLDER_DIALOG			((ULONG) 0x00000002) above */
/****** MAPI_DECLINE_OK			((ULONG) 0x00000004) above */
#define COPY_SUBFOLDERS			((ULONG) 0x00000010)
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */


/* SetReadFlags */

/****** SUPPRESS_RECEIPT		((ULONG) 0x00000001) below */
/****** FOLDER_DIALOG			((ULONG) 0x00000002) above */
/****** CLEAR_READ_FLAG			((ULONG) 0x00000004) below */
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
/******	GENERATE_RECEIPT_ONLY	((ULONG) 0x00000010) below */
/****** CLEAR_RN_PENDING		((ULONG) 0x00000020) below */
/****** CLEAR_NRN_PENDING		((ULONG) 0x00000040) below */


/* GetMessageStatus */

#define MSGSTATUS_HIGHLIGHTED	((ULONG) 0x00000001)
#define MSGSTATUS_TAGGED		((ULONG) 0x00000002)
#define MSGSTATUS_HIDDEN		((ULONG) 0x00000004)
#define MSGSTATUS_DELMARKED		((ULONG) 0x00000008)

/* Bits for remote message status */

#define	MSGSTATUS_REMOTE_DOWNLOAD	((ULONG) 0x00001000)
#define	MSGSTATUS_REMOTE_DELETE		((ULONG) 0x00002000)

/* SaveContentsSort */

#define RECURSIVE_SORT			((ULONG) 0x00000002)

/* PR_STATUS property */

#define FLDSTATUS_HIGHLIGHTED	((ULONG) 0x00000001)
#define FLDSTATUS_TAGGED		((ULONG) 0x00000002)
#define FLDSTATUS_HIDDEN		((ULONG) 0x00000004)
#define FLDSTATUS_DELMARKED		((ULONG) 0x00000008)

#define MAPI_IMAPIFOLDER_METHODS(IPURE)									\
	MAPIMETHOD(CreateMessage)											\
		(THIS_	LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPMESSAGE FAR *				lppMessage) IPURE;			\
	MAPIMETHOD(CopyMessages)											\
		(THIS_	LPENTRYLIST					lpMsgList,					\
			   	LPCIID						lpInterface,				\
				LPVOID						lpDestFolder,				\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(DeleteMessages)											\
		(THIS_	LPENTRYLIST					lpMsgList,					\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(CreateFolder)											\
		(THIS_	ULONG						ulFolderType,				\
				LPTSTR						lpszFolderName,				\
				LPTSTR						lpszFolderComment,			\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPMAPIFOLDER FAR *			lppFolder) IPURE;			\
	MAPIMETHOD(CopyFolder)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
			   	LPCIID						lpInterface,				\
				LPVOID						lpDestFolder,				\
				LPTSTR						lpszNewFolderName,			\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(DeleteFolder)											\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(SetReadFlags)											\
		(THIS_	LPENTRYLIST					lpMsgList,					\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(GetMessageStatus)										\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulMessageStatus) IPURE;	\
	MAPIMETHOD(SetMessageStatus)										\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulNewStatus,				\
				ULONG						ulNewStatusMask,			\
				ULONG FAR *					lpulOldStatus) IPURE;		\
	MAPIMETHOD(SaveContentsSort)										\
		(THIS_	LPSSortOrderSet				lpSortCriteria,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(EmptyFolder)												\
		(THIS_	ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\

#undef		 INTERFACE
#define		 INTERFACE  IMAPIFolder
DECLARE_MAPI_INTERFACE_(IMAPIFolder, IMAPIContainer)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMAPICONTAINER_METHODS(PURE)
	MAPI_IMAPIFOLDER_METHODS(PURE)
};

/* IMsgStore Interface ----------------------------------------------------- */

/*  PR_STORE_SUPPORT_MASK bits */
#define STORE_ENTRYID_UNIQUE	((ULONG) 0x00000001)
#define STORE_READONLY			((ULONG) 0x00000002)
#define STORE_SEARCH_OK			((ULONG) 0x00000004)
#define STORE_MODIFY_OK			((ULONG) 0x00000008)
#define STORE_CREATE_OK			((ULONG) 0x00000010)
#define STORE_ATTACH_OK			((ULONG) 0x00000020)
#define STORE_OLE_OK			((ULONG) 0x00000040)
#define STORE_SUBMIT_OK			((ULONG) 0x00000080)
#define STORE_NOTIFY_OK			((ULONG) 0x00000100)
#define STORE_MV_PROPS_OK		((ULONG) 0x00000200)
#define STORE_CATEGORIZE_OK		((ULONG) 0x00000400)
#define STORE_RTF_OK			((ULONG) 0x00000800)
#define STORE_RESTRICTION_OK	((ULONG) 0x00001000)
#define STORE_SORT_OK			((ULONG) 0x00002000)
#define	STORE_PUBLIC_FOLDERS	((ULONG) 0x00004000)
#define	STORE_UNCOMPRESSED_RTF	((ULONG) 0x00008000)

/* PR_STORE_STATE bits, try not to collide with PR_STORE_SUPPORT_MASK */

#define STORE_HAS_SEARCHES		((ULONG) 0x01000000)


/* OpenEntry() */

/****** MAPI_MODIFY				((ULONG) 0x00000001) above */
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
/****** MAPI_BEST_ACCESS		((ULONG) 0x00000010) above */

/* SetReceiveFolder() */

/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* GetReceiveFolder() */

/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* GetReceiveFolderTable() */

/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */

/* StoreLogoff() */

#define	LOGOFF_NO_WAIT			((ULONG) 0x00000001)
#define	LOGOFF_ORDERLY			((ULONG) 0x00000002)
#define	LOGOFF_PURGE			((ULONG) 0x00000004)
#define LOGOFF_ABORT			((ULONG) 0x00000008)
#define LOGOFF_QUIET			((ULONG) 0x00000010)

#define LOGOFF_COMPLETE			((ULONG) 0x00010000)
#define	LOGOFF_INBOUND			((ULONG) 0x00020000)
#define LOGOFF_OUTBOUND			((ULONG) 0x00040000)
#define LOGOFF_OUTBOUND_QUEUE	((ULONG) 0x00080000)

/* SetLockState() */

#define MSG_LOCKED				((ULONG) 0x00000001)
#define MSG_UNLOCKED			((ULONG) 0x00000000)

/* Flag bits for PR_VALID_FOLDER_MASK */

#define	FOLDER_IPM_SUBTREE_VALID		((ULONG) 0x00000001)
#define	FOLDER_IPM_INBOX_VALID			((ULONG) 0x00000002)
#define	FOLDER_IPM_OUTBOX_VALID			((ULONG) 0x00000004)
#define	FOLDER_IPM_WASTEBASKET_VALID	((ULONG) 0x00000008)
#define	FOLDER_IPM_SENTMAIL_VALID		((ULONG) 0x00000010)
#define	FOLDER_VIEWS_VALID				((ULONG) 0x00000020)
#define	FOLDER_COMMON_VIEWS_VALID		((ULONG) 0x00000040)
#define	FOLDER_FINDER_VALID				((ULONG) 0x00000080)

#define MAPI_IMSGSTORE_METHODS(IPURE)									\
	MAPIMETHOD(Advise)													\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulEventMask,				\
				LPMAPIADVISESINK			lpAdviseSink,				\
				ULONG FAR *					lpulConnection) IPURE;		\
	MAPIMETHOD(Unadvise)												\
		(THIS_	ULONG						ulConnection) IPURE;		\
	MAPIMETHOD(CompareEntryIDs)											\
		(THIS_	ULONG						cbEntryID1,					\
				LPENTRYID					lpEntryID1,					\
				ULONG						cbEntryID2,					\
				LPENTRYID					lpEntryID2,					\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulResult) IPURE;			\
	MAPIMETHOD(OpenEntry)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulObjType,				\
				LPUNKNOWN FAR *				lppUnk) IPURE;				\
	MAPIMETHOD(SetReceiveFolder)										\
		(THIS_	LPTSTR						lpszMessageClass,			\
				ULONG						ulFlags,					\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(GetReceiveFolder)										\
		(THIS_	LPTSTR						lpszMessageClass,			\
				ULONG						ulFlags,					\
				ULONG FAR *					lpcbEntryID,				\
				LPENTRYID FAR *				lppEntryID,					\
				LPTSTR FAR *				lppszExplicitClass) IPURE;	\
	MAPIMETHOD(GetReceiveFolderTable)									\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(StoreLogoff)												\
		(THIS_	ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(AbortSubmit)												\
		(THIS_	ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(GetOutgoingQueue)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(SetLockState)											\
		(THIS_	LPMESSAGE					lpMessage,					\
				ULONG						ulLockState) IPURE;			\
	MAPIMETHOD(FinishedMsg)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID) IPURE;			\
	MAPIMETHOD(NotifyNewMail)											\
		(THIS_	LPNOTIFICATION				lpNotification) IPURE;		\

#undef		 INTERFACE
#define		 INTERFACE  IMsgStore
DECLARE_MAPI_INTERFACE_(IMsgStore, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMSGSTORE_METHODS(PURE)
};

/* IMessage Interface ------------------------------------------------------ */

/* SubmitMessage */

#define FORCE_SUBMIT				((ULONG) 0x00000001)

/* Flags defined in PR_MESSAGE_FLAGS */

#define MSGFLAG_READ			((ULONG) 0x00000001)
#define MSGFLAG_UNMODIFIED		((ULONG) 0x00000002)
#define MSGFLAG_SUBMIT			((ULONG) 0x00000004)
#define MSGFLAG_UNSENT			((ULONG) 0x00000008)
#define MSGFLAG_HASATTACH		((ULONG) 0x00000010)
#define MSGFLAG_FROMME			((ULONG) 0x00000020)
#define MSGFLAG_ASSOCIATED		((ULONG) 0x00000040)
#define MSGFLAG_RESEND			((ULONG) 0x00000080)
#define MSGFLAG_RN_PENDING		((ULONG) 0x00000100)
#define MSGFLAG_NRN_PENDING		((ULONG) 0x00000200)

/* Flags defined in PR_SUBMIT_FLAGS */

#define SUBMITFLAG_LOCKED		((ULONG) 0x00000001)
#define SUBMITFLAG_PREPROCESS	((ULONG) 0x00000002)

/* GetAttachmentTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* GetRecipientTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* ModifyRecipients */

/* ((ULONG) 0x00000001 is not a valid flag on ModifyRecipients. */
#define MODRECIP_ADD			((ULONG) 0x00000002)
#define MODRECIP_MODIFY			((ULONG) 0x00000004)
#define MODRECIP_REMOVE			((ULONG) 0x00000008)

/* SetReadFlag */

#define SUPPRESS_RECEIPT		((ULONG) 0x00000001)
#define CLEAR_READ_FLAG			((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) below */
#define	GENERATE_RECEIPT_ONLY	((ULONG) 0x00000010)
#define CLEAR_RN_PENDING		((ULONG) 0x00000020)
#define CLEAR_NRN_PENDING		((ULONG) 0x00000040)

/* DeleteAttach */

#define ATTACH_DIALOG			((ULONG) 0x00000001)

/* PR_SECURITY values */
#define SECURITY_SIGNED			((ULONG) 0x00000001)
#define SECURITY_ENCRYPTED		((ULONG) 0x00000002)

/* PR_PRIORITY values */
#define PRIO_URGENT				((long)  1)
#define PRIO_NORMAL				((long)  0)
#define PRIO_NONURGENT			((long) -1)

/* PR_SENSITIVITY values */
#define SENSITIVITY_NONE					((ULONG) 0x00000000)
#define SENSITIVITY_PERSONAL				((ULONG) 0x00000001)
#define SENSITIVITY_PRIVATE					((ULONG) 0x00000002)
#define SENSITIVITY_COMPANY_CONFIDENTIAL	((ULONG) 0x00000003)

/* PR_IMPORTANCE values */
#define IMPORTANCE_LOW			((long) 0)
#define IMPORTANCE_NORMAL		((long) 1)
#define IMPORTANCE_HIGH			((long) 2)

#define MAPI_IMESSAGE_METHODS(IPURE)									\
	MAPIMETHOD(GetAttachmentTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(OpenAttach)												\
		(THIS_	ULONG						ulAttachmentNum,			\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPATTACH FAR *				lppAttach) IPURE;			\
	MAPIMETHOD(CreateAttach)											\
		(THIS_	LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulAttachmentNum,			\
				LPATTACH FAR *				lppAttach) IPURE;			\
	MAPIMETHOD(DeleteAttach)											\
		(THIS_	ULONG						ulAttachmentNum,			\
				ULONG						ulUIParam,					\
				LPMAPIPROGRESS				lpProgress,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(GetRecipientTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(ModifyRecipients)										\
		(THIS_	ULONG						ulFlags,					\
				LPADRLIST					lpMods) IPURE;				\
	MAPIMETHOD(SubmitMessage)											\
		(THIS_	ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(SetReadFlag)												\
		(THIS_	ULONG						ulFlags) IPURE;				\

#undef		 INTERFACE
#define		 INTERFACE  IMessage
DECLARE_MAPI_INTERFACE_(IMessage, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IMESSAGE_METHODS(PURE)
};

/* IAttach Interface ------------------------------------------------------- */

/* IAttach attachment methods: PR_ATTACH_METHOD values */

#define NO_ATTACHMENT			((ULONG) 0x00000000)
#define ATTACH_BY_VALUE			((ULONG) 0x00000001)
#define ATTACH_BY_REFERENCE		((ULONG) 0x00000002)
#define ATTACH_BY_REF_RESOLVE	((ULONG) 0x00000003)
#define ATTACH_BY_REF_ONLY		((ULONG) 0x00000004)
#define ATTACH_EMBEDDED_MSG		((ULONG) 0x00000005)
#define ATTACH_OLE				((ULONG) 0x00000006)

#define MAPI_IATTACH_METHODS(IPURE)

#undef		 INTERFACE
#define		 INTERFACE  IAttach
DECLARE_MAPI_INTERFACE_(IAttach, IMAPIProp)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROP_METHODS(PURE)
	MAPI_IATTACH_METHODS(PURE)
};

/* --------------------------------- */
/* Address Book interface definition */

/* ADRPARM ulFlags - top 4 bits used for versioning */

#define GET_ADRPARM_VERSION(ulFlags)  (((ULONG)ulFlags) & 0xF0000000)
#define SET_ADRPARM_VERSION(ulFlags, ulVersion)  (((ULONG)ulVersion) | (((ULONG)ulFlags) & 0x0FFFFFFF))

/*  Current versions of ADRPARM  */
#define ADRPARM_HELP_CTX		((ULONG) 0x00000000)


/*  ulFlags   - bit fields */
#define DIALOG_MODAL			((ULONG) 0x00000001)
#define DIALOG_SDI				((ULONG) 0x00000002)
#define DIALOG_OPTIONS			((ULONG) 0x00000004)
#define ADDRESS_ONE				((ULONG) 0x00000008)
#define AB_SELECTONLY			((ULONG) 0x00000010)
#define AB_RESOLVE				((ULONG) 0x00000020)

/* --------------------------------- */
/*  PR_DISPLAY_TYPEs                 */
/*
 *  These standard display types are
 *  by default handled by MAPI.
 *  They have default icons associated
 *  with them.
 */

/*  For address book contents tables */
#define DT_MAILUSER			((ULONG) 0x00000000)
#define DT_DISTLIST			((ULONG) 0x00000001)
#define DT_FORUM			((ULONG) 0x00000002)
#define DT_AGENT			((ULONG) 0x00000003)
#define DT_ORGANIZATION		((ULONG) 0x00000004)
#define DT_PRIVATE_DISTLIST	((ULONG) 0x00000005)
#define DT_REMOTE_MAILUSER	((ULONG) 0x00000006)

/*  For address book hierarchy tables */
#define DT_MODIFIABLE		((ULONG) 0x00010000)
#define DT_GLOBAL			((ULONG) 0x00020000)
#define DT_LOCAL			((ULONG) 0x00030000)
#define DT_WAN				((ULONG) 0x00040000)
#define DT_NOT_SPECIFIC		((ULONG) 0x00050000)

/*  For folder hierarchy tables */
#define DT_FOLDER			((ULONG) 0x01000000)
#define DT_FOLDER_LINK		((ULONG) 0x02000000)
#define DT_FOLDER_SPECIAL	((ULONG) 0x04000000)

/*  Accelerator callback for DIALOG_SDI form of AB UI */
typedef BOOL (STDMETHODCALLTYPE ACCELERATEABSDI)(ULONG ulUIParam,
												LPVOID lpvmsg);
typedef ACCELERATEABSDI FAR * LPFNABSDI;

/*  Callback to application telling it that the DIALOG_SDI form of the */
/*  AB UI has been dismissed.  This is so that the above LPFNABSDI     */
/*  function doesn't keep being called.                                */
typedef void (STDMETHODCALLTYPE DISMISSMODELESS)(ULONG ulUIParam,
												LPVOID lpvContext);
typedef DISMISSMODELESS FAR * LPFNDISMISS;

/*
 * Prototype for the client function hooked to an optional button on
 * the address book dialog
 */

typedef SCODE (STDMETHODCALLTYPE FAR * LPFNBUTTON)(
	ULONG				ulUIParam,
	LPVOID				lpvContext,
	ULONG				cbEntryID,
	LPENTRYID			lpSelection,
	ULONG				ulFlags
);


/* Parameters for the address book dialog */
typedef struct _ADRPARM
{
	ULONG			cbABContEntryID;
	LPENTRYID		lpABContEntryID;
	ULONG			ulFlags;

	LPVOID			lpReserved;
	ULONG			ulHelpContext;
	LPTSTR			lpszHelpFileName;

	LPFNABSDI		lpfnABSDI;
	LPFNDISMISS		lpfnDismiss;
	LPVOID			lpvDismissContext;
	LPTSTR			lpszCaption;
	LPTSTR			lpszNewEntryTitle;
	LPTSTR			lpszDestWellsTitle;
	ULONG			cDestFields;
	ULONG			nDestFieldFocus;
	LPTSTR FAR *	lppszDestTitles;
	ULONG FAR *		lpulDestComps;
	LPSRestriction	lpContRestriction;
	LPSRestriction	lpHierRestriction;
} ADRPARM, FAR * LPADRPARM;


/* ------------ */
/* Random flags */

/* Flag for deferred error */
#define MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008)

/* Flag for creating and using Folder Associated Information Messages */
#define MAPI_ASSOCIATED			((ULONG) 0x00000040)

/* Flags for OpenMessageStore() */

#define MDB_NO_DIALOG			((ULONG) 0x00000001)
#define MDB_WRITE				((ULONG) 0x00000004)
/****** MAPI_DEFERRED_ERRORS	((ULONG) 0x00000008) above */
/****** MAPI_BEST_ACCESS		((ULONG) 0x00000010) above */
#define	MDB_TEMPORARY			((ULONG) 0x00000020)
#define MDB_NO_MAIL				((ULONG) 0x00000080)

/* Flags for OpenAddressBook */

#define AB_NO_DIALOG			((ULONG) 0x00000001)

/* IMAPIControl Interface -------------------------------------------------- */

/* Interface used in controls (particularly the button) defined by */
/* Display Tables. */

/*  Flags for GetState */

#define  MAPI_ENABLED		((ULONG) 0x00000000)
#define  MAPI_DISABLED		((ULONG) 0x00000001)

#define MAPI_IMAPICONTROL_METHODS(IPURE)								\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(Activate)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG						ulUIParam) IPURE;			\
	MAPIMETHOD(GetState)												\
		(THIS_	ULONG						ulFlags,					\
				ULONG FAR *					lpulState) IPURE;			\

#undef		 INTERFACE
#define		 INTERFACE  IMAPIControl
DECLARE_MAPI_INTERFACE_(IMAPIControl, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPICONTROL_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IMAPIControl, LPMAPICONTROL);

/* Display Tables ---------------------------------------------------------- */

/* Flags used in display tables - that is, PR_CONTROL_FLAGS */

#define DT_MULTILINE		((ULONG) 0x00000001)
#define DT_EDITABLE			((ULONG) 0x00000002)
#define DT_REQUIRED			((ULONG) 0x00000004)
#define DT_SET_IMMEDIATE	((ULONG) 0x00000008)
#define DT_PASSWORD_EDIT	((ULONG) 0x00000010)
#define DT_ACCEPT_DBCS		((ULONG) 0x00000020)
#define DT_SET_SELECTION	((ULONG) 0x00000040)

/* Display Table structures */

#define DTCT_LABEL			((ULONG) 0x00000000)
#define DTCT_EDIT			((ULONG) 0x00000001)
#define DTCT_LBX			((ULONG) 0x00000002)
#define DTCT_COMBOBOX		((ULONG) 0x00000003)
#define DTCT_DDLBX			((ULONG) 0x00000004)
#define DTCT_CHECKBOX		((ULONG) 0x00000005)
#define DTCT_GROUPBOX		((ULONG) 0x00000006)
#define DTCT_BUTTON			((ULONG) 0x00000007)
#define DTCT_PAGE			((ULONG) 0x00000008)
#define DTCT_RADIOBUTTON	((ULONG) 0x00000009)
#define DTCT_MVLISTBOX		((ULONG) 0x0000000B)
#define DTCT_MVDDLBX		((ULONG) 0x0000000C)

/* Labels */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLLABEL
{
	ULONG ulbLpszLabelName;
	ULONG ulFlags;
} DTBLLABEL, FAR * LPDTBLLABEL;
#define SizedDtblLabel(n,u) \
struct _DTBLLABEL_ ## u \
{ \
	DTBLLABEL	dtbllabel; \
	TCHAR		lpszLabelName[n]; \
} u


/*  Simple Text Edits  */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLEDIT
{
	ULONG ulbLpszCharsAllowed;
	ULONG ulFlags;
	ULONG ulNumCharsAllowed;
	ULONG ulPropTag;
} DTBLEDIT, FAR * LPDTBLEDIT;
#define SizedDtblEdit(n,u) \
struct _DTBLEDIT_ ## u \
{ \
	DTBLEDIT	dtbledit; \
	TCHAR		lpszCharsAllowed[n]; \
} u

/*  List Box  */
/* Valid ulFlags:
 */
#define MAPI_NO_HBAR		((ULONG) 0x00000001)
#define MAPI_NO_VBAR		((ULONG) 0x00000002)

typedef struct _DTBLLBX
{
	ULONG ulFlags;
	ULONG ulPRSetProperty;
	ULONG ulPRTableName;
} DTBLLBX, FAR * LPDTBLLBX;


/*  Combo Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLCOMBOBOX
{
	ULONG ulbLpszCharsAllowed;
	ULONG ulFlags;
	ULONG ulNumCharsAllowed;
	ULONG ulPRPropertyName;
	ULONG ulPRTableName;
} DTBLCOMBOBOX, FAR * LPDTBLCOMBOBOX;
#define SizedDtblComboBox(n,u) \
struct _DTBLCOMBOBOX_ ## u \
{ \
	DTBLCOMBOBOX	dtblcombobox; \
	TCHAR			lpszCharsAllowed[n]; \
} u


/*  Drop Down   */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLDDLBX
{
	ULONG ulFlags;
	ULONG ulPRDisplayProperty;
	ULONG ulPRSetProperty;
	ULONG ulPRTableName;
} DTBLDDLBX, FAR * LPDTBLDDLBX;


/*  Check Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLCHECKBOX
{
	ULONG ulbLpszLabel;
	ULONG ulFlags;
	ULONG ulPRPropertyName;
} DTBLCHECKBOX, FAR * LPDTBLCHECKBOX;
#define SizedDtblCheckBox(n,u) \
struct _DTBLCHECKBOX_ ## u \
{ \
	DTBLCHECKBOX	dtblcheckbox; \
	TCHAR		lpszLabel[n]; \
} u



/*  Group Box   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLGROUPBOX
{
	ULONG ulbLpszLabel;
	ULONG ulFlags;
} DTBLGROUPBOX, FAR * LPDTBLGROUPBOX;
#define SizedDtblGroupBox(n,u) \
struct _DTBLGROUPBOX_ ## u \
{ \
	DTBLGROUPBOX	dtblgroupbox; \
	TCHAR			lpszLabel[n]; \
} u

/*  Button control   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLBUTTON
{
	ULONG ulbLpszLabel;
	ULONG ulFlags;
	ULONG ulPRControl;
} DTBLBUTTON, FAR * LPDTBLBUTTON;
#define SizedDtblButton(n,u) \
struct _DTBLBUTTON_ ## u \
{ \
	DTBLBUTTON	dtblbutton; \
	TCHAR		lpszLabel[n]; \
} u

/*  Pages   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLPAGE
{
	ULONG ulbLpszLabel;
	ULONG ulFlags;
	ULONG ulbLpszComponent;
	ULONG ulContext;
} DTBLPAGE, FAR * LPDTBLPAGE;
#define SizedDtblPage(n,n1,u) \
struct _DTBLPAGE_ ## u \
{ \
	DTBLPAGE	dtblpage; \
	TCHAR		lpszLabel[n]; \
	TCHAR		lpszComponent[n1]; \
} u

/*  Radio button   */
/* Valid ulFlags:
 *   MAPI_UNICODE
 */
typedef struct _DTBLRADIOBUTTON
{
	ULONG ulbLpszLabel;
	ULONG ulFlags;
	ULONG ulcButtons;
	ULONG ulPropTag;
	long lReturnValue;
} DTBLRADIOBUTTON, FAR * LPDTBLRADIOBUTTON;
#define SizedDtblRadioButton(n,u) \
struct _DTBLRADIOBUTTON_ ## u \
{ \
	DTBLRADIOBUTTON dtblradiobutton; \
	TCHAR			lpszLabel[n]; \
} u


/*  MultiValued listbox */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLMVLISTBOX
{
	ULONG ulFlags;
	ULONG ulMVPropTag;
} DTBLMVLISTBOX, FAR * LPDTBLMVLISTBOX;


/*  MultiValued dropdown */
/* Valid ulFlags:
 *   none
 */
typedef struct _DTBLMVDDLBX
{
	ULONG ulFlags;
	ULONG ulMVPropTag;
} DTBLMVDDLBX, FAR * LPDTBLMVDDLBX;





/* IProviderAdmin Interface ---------------------------------------------- */

/* Flags for ConfigureMsgService */

#define UI_SERVICE					0x00000002
#define SERVICE_UI_ALWAYS  			0x00000002		/* Duplicate UI_SERVICE for consistency and compatibility */
#define SERVICE_UI_ALLOWED 			0x00000010
#define UI_CURRENT_PROVIDER_FIRST	0x00000004
/* MSG_SERVICE_UI_READ_ONLY 		0x00000008 - in MAPISPI.H */

/* GetProviderTable() */
/****** MAPI_UNICODE			((ULONG) 0x80000000) above */

/* Values for PR_RESOURCE_FLAGS in message service table */

#define MAPI_IPROVIDERADMIN_METHODS(IPURE)								\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(GetProviderTable)										\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(CreateProvider)											\
		(THIS_	LPTSTR						lpszProvider,				\
				ULONG						cValues,					\
				LPSPropValue				lpProps,					\
				ULONG						ulUIParam,					\
				ULONG						ulFlags,					\
				MAPIUID FAR *				lpUID) IPURE;				\
	MAPIMETHOD(DeleteProvider)											\
		(THIS_	LPMAPIUID					lpUID) IPURE;				\
	MAPIMETHOD(OpenProfileSection)										\
		(THIS_	LPMAPIUID					lpUID,						\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				LPPROFSECT FAR *			lppProfSect) IPURE;			\


#undef 		 INTERFACE
#define 	 INTERFACE	IProviderAdmin
DECLARE_MAPI_INTERFACE_(IProviderAdmin, IUnknown)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IPROVIDERADMIN_METHODS(PURE)
};



#ifdef	__cplusplus
}		/*	extern "C" */
#endif

#endif /* MAPIDEFS_H */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\mapistub\mapistub\mapi32.cpp ===
#pragma warning(disable: 4201)	// nameless struct/union
#pragma warning(disable: 4514)	// unreferenced inline function

#include <windows.h>
#include <winnls.h>
#include <winbase.h>

#include "mapi.h"
#include "mapix.h"
#include "_spooler.h"

extern "C"
{
#include "profspi.h"
}

#include "mapiform.h"
#include "mapidbg.h"
#include "_mapiu.h"
#include "tnef.h"

typedef void UNKOBJ_Vtbl;		// ???
#include "unkobj.h"

#include "mapival.h"
#include "imessage.h"
#include "_vbmapi.h"
#include "xcmc.h"

#include "msi.h"

#define OUTLOOKVERSION	0x80000402

#define ThunkLoadLibrary(dllName, bpNativeDll, bLoadAsX86, flags) ::LoadLibrary(dllName)

#define ThunkFreeLibrary(hModule, bNativeDll, bDetach)   ::FreeLibrary(hModule)

#define ThunkGetProcAddress(hModule, szFnName, bNativeDll, nParams) \
                ::GetProcAddress(hModule, szFnName)

#define ThunkGetModuleHandle(szLib)     GetModuleHandle(szLib)

struct FreeBufferBlocks		// fbb
{
	LPVOID pvBuffer;
	struct FreeBufferBlocks * pNext;
};

FreeBufferBlocks * g_pfbbHead = NULL;


// Copied from mapi.ortm\mapi\src\common\mapidbg.c (ericwong 06-18-98)

#if defined( _WINNT)

/*++

Routine Description:

    This routine returns if the service specified is running interactively
	(not invoked \by the service controller).

Arguments:

    None

Return Value:

    BOOL - TRUE if the service is an EXE.


Note:

--*/

BOOL WINAPI IsDBGServiceAnExe( VOID )
{
    HANDLE hProcessToken = NULL;
    DWORD groupLength = 50;

    PTOKEN_GROUPS groupInfo = (PTOKEN_GROUPS)LocalAlloc(0, groupLength);

    SID_IDENTIFIER_AUTHORITY siaNt = SECURITY_NT_AUTHORITY;
    PSID InteractiveSid = NULL;
    PSID ServiceSid = NULL;
    DWORD i;

	// Start with assumption that process is an EXE, not a Service.
	BOOL fExe = TRUE;


    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hProcessToken))
		goto ret;

    if (groupInfo == NULL)
		goto ret;

    if (!GetTokenInformation(hProcessToken, TokenGroups, groupInfo,
		groupLength, &groupLength))
	{
		if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
			goto ret;

		LocalFree(groupInfo);
		groupInfo = NULL;
	
		groupInfo = (PTOKEN_GROUPS)LocalAlloc(0, groupLength);
	
		if (groupInfo == NULL)
			goto ret;
	
		if (!GetTokenInformation(hProcessToken, TokenGroups, groupInfo,
			groupLength, &groupLength))
		{
			goto ret;
		}
    }

    //
    //	We now know the groups associated with this token.  We want to look to see if
    //  the interactive group is active in the token, and if so, we know that
    //  this is an interactive process.
    //
    //  We also look for the "service" SID, and if it's present, we know we're a service.
    //
    //	The service SID will be present iff the service is running in a
    //  user account (and was invoked by the service controller).
    //


    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_INTERACTIVE_RID, 0, 0,
		0, 0, 0, 0, 0, &InteractiveSid))
	{
		goto ret;
    }

    if (!AllocateAndInitializeSid(&siaNt, 1, SECURITY_SERVICE_RID, 0, 0, 0,
		0, 0, 0, 0, &ServiceSid))
	{
		goto ret;
    }

    for (i = 0; i < groupInfo->GroupCount ; i += 1)
	{
		SID_AND_ATTRIBUTES sanda = groupInfo->Groups[i];
		PSID Sid = sanda.Sid;
	
		//
		//	Check to see if the group we're looking at is one of
		//	the 2 groups we're interested in.
		//
	
		if (EqualSid(Sid, InteractiveSid))
		{
			//
			//	This process has the Interactive SID in its
			//  token.  This means that the process is running as
			//  an EXE.
			//
			goto ret;
		}
		else if (EqualSid(Sid, ServiceSid))
		{
			//
			//	This process has the Service SID in its
			//  token.  This means that the process is running as
			//  a service running in a user account.
			//
			fExe = FALSE;
			goto ret;
		}
    }

    //
    //	Neither Interactive or Service was present in the current users token,
    //  This implies that the process is running as a service, most likely
    //  running as LocalSystem.
    //
	fExe = FALSE;

ret:

	if (InteractiveSid)
		FreeSid(InteractiveSid);		/*lint !e534*/

	if (ServiceSid)
		FreeSid(ServiceSid);			/*lint !e534*/

	if (groupInfo)
		LocalFree(groupInfo);

	if (hProcessToken)
		CloseHandle(hProcessToken);

    return(fExe);
}

#else
BOOL WINAPI IsDBGServiceAnExe( VOID )
{
	return TRUE;
}
#endif

DWORD	verWinNT();	// Forward declaration

typedef struct {
	char *		sz1;
	char *		sz2;
	UINT		rgf;
	int			iResult;
} MBContext;


DWORD WINAPI MessageBoxFnThreadMain(MBContext *pmbc)
{
	// Need extra flag for NT service
	if (verWinNT() && !IsDBGServiceAnExe())
		pmbc->rgf |= MB_SERVICE_NOTIFICATION;

	pmbc->iResult = MessageBoxA(NULL, pmbc->sz1, pmbc->sz2,
		pmbc->rgf | MB_SETFOREGROUND);

	return 0;
}

int MessageBoxFn(char *sz1, char *sz2, UINT rgf)
{
	HANDLE		hThread;
	DWORD		dwThreadId;
	MBContext	mbc;

	mbc.sz1		= sz1;
	mbc.sz2		= sz2;
	mbc.rgf		= rgf;
	mbc.iResult = IDRETRY;

	hThread = CreateThread(NULL, 0,
		(PTHREAD_START_ROUTINE)MessageBoxFnThreadMain, &mbc, 0, &dwThreadId);

	if (hThread != NULL) {
		WaitForSingleObject(hThread, INFINITE);
		CloseHandle(hThread);
	}

	return(mbc.iResult);
}

#ifdef DEBUG

TCHAR g_szProcessName[MAX_PATH];


static char szCR[] = "\r";

void DebugOutputFn(const char *psz)
{
	OutputDebugStringA(psz);
	OutputDebugStringA(szCR);
}

int __cdecl DebugTrapFn(int fFatal, char *pszFile, int iLine, char *pszFormat, ...)
{
	char	sz[512];
	va_list	vl;

	int		id;

	DebugOutputFn("++++ MAPI Stub Debug Trap\n");

	va_start(vl, pszFormat);
	wvsprintfA(sz, pszFormat, vl);
	va_end(vl);

	wsprintfA(sz + lstrlenA(sz), "\n[File %s, Line %d]\n\n", pszFile, iLine);

	DebugOutputFn(sz);

	/* Hold down control key to prevent MessageBox */
	if ( GetAsyncKeyState(VK_CONTROL) >= 0 )
	{
		UINT uiFlags = MB_ABORTRETRYIGNORE;

		if (fFatal)
			uiFlags |= MB_DEFBUTTON1;
		else
			uiFlags |= MB_DEFBUTTON3;

		uiFlags |= MB_ICONSTOP | MB_TASKMODAL;

		id = MessageBoxFn(sz, "MAPI Stub Debug Trap", uiFlags);

		if (id == IDABORT)
		{
			*((LPBYTE)NULL) = 0;		/*lint !e413*/
		}
		else if (id == IDRETRY)
			DebugBreak();
	}

	return 0;
}


#endif




inline void MyStrCopy(LPSTR szDest, LPCSTR szSrc)
{
	while ('\0' != (*szDest++ = *szSrc++))
	{
	}
}



inline SIZE_T MyStrLen(LPCSTR szSrc)
{
	LPCSTR szRunner = szSrc;

	while (*szRunner++)
	{
	}

	return szRunner - szSrc;
}



LPCSTR FindFileNameWithoutPath(LPCSTR szPathName)
{
	// Find the name of the file without the path.  Do this by finding
	// the last occurrence of the path separator.

	LPCSTR szFileNameWithoutPath = szPathName;
	LPCSTR szRunner = szPathName;

	while ('\0' != *szRunner)
	{
		if (*szRunner == '\\')
		{
			szFileNameWithoutPath = szRunner + 1;
		}

		szRunner = CharNext(szRunner);
	}

	return szFileNameWithoutPath;
}


inline LPSTR FindFileNameWithoutPath(LPSTR szPathName)
{
	return (LPSTR) FindFileNameWithoutPath((LPCSTR) szPathName);
}


// Windows NT seems to have a bug in ::LoadLibrary().  If somebody calls ::LoadLibrary()
// with a long file name in the path, the Dll will get loaded fine.  However, if someone
// subsequently calls ::LoadLibrary() with the same file name and path, only this time the
// path is in shortened form, the Dll will be loaded again.  There will be two instances
// of the same Dll loaded in the same process.
//
// This is an effort to solve the problem.  However, this function will probably not solve
// the problem if the long/shortened file name is the name of the Dll itself and not just
// a folder in the path.
//
// Also, if two legitimately different Dlls have the same file name (different path), this
// will only load the first one.
//
// Finally, this adds an effort to make the search path behavior work the same between
// Windows NT and Windows 95.  If a DLL calls ::LoadLibrary(), Windows NT will look for a
// library in the same folder as the calling library (before looking in the same folder as
// the calling process's executable).  Windows 95 won't.


HINSTANCE MyLoadLibrary(LPCSTR szLibraryName, HINSTANCE hinstCallingLibrary)
{

    char szModuleFileName[MAX_PATH + 1];

    Assert(NULL != szLibraryName);

    LPCSTR szLibraryNameWithoutPath = FindFileNameWithoutPath(szLibraryName);


    HINSTANCE hinst = (HINSTANCE) ThunkGetModuleHandle(szLibraryNameWithoutPath);

    if (NULL != hinst)
    {
        // Ah ha!  The library is already loaded!

        if (0 == ::GetModuleFileName(hinst, szModuleFileName, sizeof(szModuleFileName)))
        {
            // Wait a minute.  We know that the library was already loaded.  Why would
            // this fail?  We'll just return NULL, as if ::LoadLibrary() had failed, and
            // the caller can call ::GetLastError() to figure out what happened.

            szLibraryName = NULL;
            hinst = NULL;
        }
        else
        {
            szLibraryName = szModuleFileName;
        }
    }
    else if ((NULL != hinstCallingLibrary && szLibraryName == szLibraryNameWithoutPath))
    {

        // If the specified library (szLibraryName) does not have a path, we try
        // to load it from the same directory as hinstCallingLibrary

        // For WX86, we also fall into this case if szLibraryName has a path
        // and it is either the system directory or the x86 system directory.

        // This is to cover the case when people manually add a DllPath or
        // DllPathEx key in the registry - most commonly for native Exchange,
        // which does not add these keys - and enter the full path name

        // CAUTION: For Wx86, szLibraryName might not be the same as
        // szLibraryNameWithoutPath; do not assume szLibraryName ==
        // szLibraryNameWithoutPath



        if (0 != ::GetModuleFileName(hinstCallingLibrary,
                                    szModuleFileName, sizeof(szModuleFileName)))
        {
            // Note that we get to this case most commonly if we are trying to
            // to load mapi32x.dll. In all other cases we have either called
            // GetModuleHandle in GetProxyDll() (for the omi9/omint cases) or
            // we have got a dll name for the default mail client from the
            // registry. Hopefully, all apps that write the registry key will
            // put the full path name of the dll there. (We do in RegisterMail-
            // Client.)

            LPSTR szEndOfCallerPath = FindFileNameWithoutPath(szModuleFileName);

            Assert(szEndOfCallerPath != szModuleFileName);

            *szEndOfCallerPath = '\0';

            if (MyStrLen(szLibraryNameWithoutPath) +
                            szEndOfCallerPath - szModuleFileName < sizeof(szModuleFileName))
            {
                MyStrCopy(szEndOfCallerPath, szLibraryNameWithoutPath);


#if DEBUG
                DebugOutputFn(" +++ LoadLibrary(\"");
                DebugOutputFn(szModuleFileName);
                DebugOutputFn("\");\n");
#endif

                hinst = ThunkLoadLibrary(szModuleFileName, bpNativeDll, FALSE,
                                             LOAD_WITH_ALTERED_SEARCH_PATH);

                if (NULL != hinst)
                {
                    szLibraryName = NULL;
                }

                // Following comment for WX86 only:
                //
                // If this load failed, hInst = NULL, we may have
                // just loaded mapistub (above) and should unload it
                // Its simpler to just leave it laoded till this dll
                // is unloaded.
            }
        }
    }


    if (NULL != szLibraryName)
    {

#if DEBUG
        DebugOutputFn(" +++ LoadLibrary(\"");
        DebugOutputFn(szLibraryName);
        DebugOutputFn("\");\n");
#endif

        if (szLibraryName != szLibraryNameWithoutPath)
        {
            char szLibraryPath[MAX_PATH];
            LPSTR szPathFile;

            // Get library path
            lstrcpy(szLibraryPath, szLibraryName);
            szPathFile = FindFileNameWithoutPath(szLibraryPath);
                                        // szPathFile = Pointer to first char
                                        // following last \ in szLibraryPath
            *szPathFile = '\0';

            // Required by JPN mapi32x.dll
            SetCurrentDirectory(szLibraryPath);
        }

        hinst = ThunkLoadLibrary(szLibraryName, bpNativeDll, FALSE,
                                            LOAD_WITH_ALTERED_SEARCH_PATH);
                // We always have to do a ::LoadLibrary(), even if it's already loaded,
                // so we can bump the reference count on the instance handle.
    }


#ifdef DEBUG

    if (NULL == hinst)
    {
        DWORD dwError = ::GetLastError();

        if (dwError)
        {
            TCHAR szMsg[512];

            wsprintf(szMsg, TEXT("(%s): LoadLibrary(%s) failed.  Error %lu (0x%lX)"),
                            g_szProcessName, szLibraryName, dwError, dwError);

            AssertSz(FALSE, szMsg);
        }
    }

#endif

    return hinst;
}


HMODULE hmodExtendedMAPI = NULL;
HMODULE hmodSimpleMAPI = NULL;

HINSTANCE hinstSelf = NULL;

CRITICAL_SECTION csGetProcAddress;
CRITICAL_SECTION csLinkedList;

extern "C" BOOL WINAPI DllMain(HINSTANCE hinst, ULONG ulReason, LPVOID Context)
{
	if (DLL_PROCESS_ATTACH == ulReason)
	{
		hinstSelf = hinst;

		InitializeCriticalSection(&csGetProcAddress);
		InitializeCriticalSection(&csLinkedList);

#ifdef DEBUG

		::GetModuleFileName(NULL, g_szProcessName, sizeof(g_szProcessName) / sizeof(TCHAR));

		DebugOutputFn(" *** DllMain(mapi32.dll (stub), DLL_PROCESS_ATTACH);\n");
		DebugOutputFn("         (\"");
		DebugOutputFn(g_szProcessName);
		DebugOutputFn("\")\n");

#endif
		::DisableThreadLibraryCalls(hinst);
			//	Disable DLL_THREAD_ATTACH calls to reduce working set.
	}
	else if (DLL_PROCESS_DETACH == ulReason)
	{
		Assert(NULL == g_pfbbHead);

                // Note: If Context is not NULL, the process is exiting

		if (NULL != hmodSimpleMAPI)
		{

#if DEBUG
			DebugOutputFn(" --- FreeLibrary(hmodSimpleMAPI);\n");
#endif

			ThunkFreeLibrary(hmodSimpleMAPI, bNativeSimpleMAPIDll,
                                         Context? TRUE : FALSE);
		}

		if (NULL != hmodExtendedMAPI)
		{

#if DEBUG
			DebugOutputFn(" --- FreeLibrary(hmodExtendedMAPI);\n");
#endif

			ThunkFreeLibrary(hmodExtendedMAPI,
                                         bNativeExtendedMAPIDll,
                                         Context? TRUE : FALSE);
		}

		DeleteCriticalSection(&csGetProcAddress);
		DeleteCriticalSection(&csLinkedList);

#ifdef DEBUG

		DebugOutputFn(" *** DllMain(mapi32.dll (stub), DLL_PROCESS_DETACH);\n");
		DebugOutputFn("         (\"");
		DebugOutputFn(g_szProcessName);
		DebugOutputFn("\")\n");

#endif
	}

	return TRUE;
}


// Copied from o9\dev\win32\h\mailcli.h (ericwong 4/16/98)

/*----------------------------------------------------------------------------
	verWinNT()
	Find out if we are running on NT (otherwise Win9x)
 ----------------------------------------------------------------------------*/
DWORD	verWinNT()
{
	static DWORD verWinNT = 0;
	static fDone = FALSE;
	OSVERSIONINFO osv;

	if (!fDone)
	{
		osv.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
		// GetVersionEx can only fail if dwOSVersionInfoSize is not set correctly
		::GetVersionEx(&osv);
		verWinNT = (osv.dwPlatformId == VER_PLATFORM_WIN32_NT) ?
			osv.dwMajorVersion : 0;
		fDone = TRUE;
	}
	return verWinNT;
}


typedef UINT (WINAPI MSIPROVIDEQUALIFIEDCOMPONENTA)(
	LPCSTR  szCategory,   // component category ID
	LPCSTR  szQualifier,  // specifies which component to access
	DWORD   dwInstallMode,// either of type INSTALLMODE or a combination of the REINSTALLMODE flags
	LPSTR   lpPathBuf,    // returned path, NULL if not desired
	DWORD * pcchPathBuf); // in/out buffer character count
typedef MSIPROVIDEQUALIFIEDCOMPONENTA FAR * LPMSIPROVIDEQUALIFIEDCOMPONENTA;

static const TCHAR s_szLcid[] = "Software\\";
static const TCHAR s_szPolicy[] = "Software\\Policy\\";

BOOL FDemandInstall
	(HINSTANCE hinstMSI,
	LPCSTR szCategory,
	DWORD dwLcid,
	LPSTR szPath,
	DWORD * pcchPath,
	BOOL fInstall
        )
{
	UINT uiT;
	TCHAR szQualifier[16];	// "{lcid}\{NT|95}"

	LPMSIPROVIDEQUALIFIEDCOMPONENTA pfnMsiProvideQualifiedComponentA;

	Assert(hinstMSI);

	// Get MsiProvideQualifiedComponent()
	pfnMsiProvideQualifiedComponentA = (LPMSIPROVIDEQUALIFIEDCOMPONENTA)
		ThunkGetProcAddress(hinstMSI, "MsiProvideQualifiedComponentA",
                                    bNativeDll, 5);
	if (!pfnMsiProvideQualifiedComponentA)
		return FALSE;

	szPath[0] = 0;
	szQualifier[0] = 0;

	// 1. Try "dddd\{NT|95}" qualifier
	wsprintf(szQualifier, "%lu\\%s", dwLcid, verWinNT() ? "NT" : "95");	// STRING_OK

	uiT = pfnMsiProvideQualifiedComponentA(
		szCategory,
		szQualifier,
		(DWORD) INSTALLMODE_EXISTING,
		szPath,
		pcchPath);

	if (uiT != ERROR_FILE_NOT_FOUND && uiT != ERROR_INDEX_ABSENT)
		goto Done;

	if (fInstall && uiT == ERROR_FILE_NOT_FOUND)
	{
		uiT = pfnMsiProvideQualifiedComponentA(
			szCategory,
			szQualifier,
			INSTALLMODE_DEFAULT,
			szPath,
			pcchPath);

		goto Done;
	}

	// 2. Try "dddd" qualifier
	wsprintf(szQualifier, "%lu", dwLcid);	// STRING_OK

	uiT = pfnMsiProvideQualifiedComponentA(
		szCategory,
		szQualifier,
		(DWORD) INSTALLMODE_EXISTING,
		szPath,
		pcchPath);

	if (uiT != ERROR_FILE_NOT_FOUND && uiT != ERROR_INDEX_ABSENT)
		goto Done;

	if (fInstall && uiT == ERROR_FILE_NOT_FOUND)
	{
		uiT = pfnMsiProvideQualifiedComponentA(
			szCategory,
			szQualifier,
			INSTALLMODE_DEFAULT,
			szPath,
			pcchPath);

		goto Done;
	}

Done:

	return (uiT != ERROR_INDEX_ABSENT);
}

extern "C" BOOL STDAPICALLTYPE FGetComponentPath
	(LPSTR szComponent,
	LPSTR szQualifier,
	LPSTR szDllPath,
	DWORD cchBufferSize,
	BOOL fInstall)
{
	szDllPath[0] = '\0';

	HINSTANCE hinstMSI = NULL;

	DWORD cb;
	LPTSTR szLcid = NULL;
	HKEY hkeyLcid = NULL;
	LPTSTR szPolicy = NULL;
	HKEY hkeyPolicy = NULL;
	BOOL fDone = FALSE;
	LPTSTR szName;
	DWORD dwLcid;

	hinstMSI = ThunkLoadLibrary("MSI.DLL", &bNativeDll, FALSE,
                                            LOAD_WITH_ALTERED_SEARCH_PATH);
	if (!hinstMSI)
		goto Done;

	// Use defaults if no szQualifier
	if (szQualifier == NULL || szQualifier[0] == '\0')
	{
		fDone = TRUE;

		// Use default user LCID
		if (FDemandInstall(hinstMSI, szComponent, GetUserDefaultLCID(),
				szDllPath, &cchBufferSize, fInstall))
			goto Done;

		// Use default system LCID
		if (FDemandInstall(hinstMSI, szComponent, GetSystemDefaultLCID(),
				szDllPath, &cchBufferSize, fInstall))
			goto Done;

		// Use English as last resort
		if (FDemandInstall(hinstMSI, szComponent, 1033,
				szDllPath, &cchBufferSize, fInstall))
			goto Done;

		fDone = FALSE;

		goto Done;
	}

	// Open the Policy key
	cb = (lstrlen(s_szPolicy) + lstrlen(szQualifier) + 1) * sizeof(TCHAR);
	szPolicy = (LPTSTR) HeapAlloc(GetProcessHeap(), 0, cb);
	if (szPolicy)
	{
		lstrcpy(szPolicy, s_szPolicy);
		lstrcat(szPolicy, szQualifier);
		RegOpenKeyEx(HKEY_CURRENT_USER, szPolicy, 0, KEY_READ, &hkeyPolicy);
	}

	// Open the Lcid key
	cb = (lstrlen(s_szLcid) + lstrlen(szQualifier) + 1) * sizeof(TCHAR);
	szLcid = (LPTSTR) HeapAlloc(GetProcessHeap(), 0, cb);
	if (szLcid)
	{
		lstrcpy(szLcid, s_szLcid);
		lstrcat(szLcid, szQualifier);
		RegOpenKeyEx(HKEY_CURRENT_USER, szLcid, 0, KEY_READ, &hkeyLcid);
	}

	// Get first registry value name
	szName = &szQualifier[lstrlen(szQualifier) + 1];

	// Loop till component found or we're out of registry value names
	while (szName[0] != '\0' && !fDone)
	{
		DWORD dwType, dwSize;

		dwSize = sizeof(dwLcid);

		if ((hkeyPolicy &&	/* Check Policy first */
				RegQueryValueEx(hkeyPolicy, szName, 0, &dwType,
					(LPBYTE) &dwLcid, &dwSize) == ERROR_SUCCESS &&
				dwType == REG_DWORD) ||
			(hkeyLcid &&	/* Then Lcid */
				RegQueryValueEx(hkeyLcid, szName, 0, &dwType,
					(LPBYTE) &dwLcid, &dwSize) == ERROR_SUCCESS &&
				dwType == REG_DWORD))
			fDone = FDemandInstall(hinstMSI, szComponent, dwLcid,
				szDllPath, &cchBufferSize, fInstall);

		szName = &szName[lstrlen(szName) + 1];	// Next registry value name
	}

Done:

	if (hkeyPolicy)
		RegCloseKey(hkeyPolicy);

	if (szPolicy)
		HeapFree(GetProcessHeap(), 0, (LPVOID) szPolicy);

	if (hkeyLcid)
		RegCloseKey(hkeyLcid);

	if (szLcid)
		HeapFree(GetProcessHeap(), 0, (LPVOID) szLcid);

	if (hinstMSI)
		ThunkFreeLibrary(hinstMSI, bNativeDll, 0);

	return fDone;
}


BOOL FAlwaysNeedsMSMAPI(LPSTR szDllPath, DWORD cbBufferSize)
{
	BOOL fNeedsMSMAPI = FALSE;

	HKEY hkeyRoot = NULL;

	LONG lResult = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE,
			TEXT("SOFTWARE\\Microsoft\\Windows Messaging Subsystem\\MSMapiApps"),
			0, KEY_READ, &hkeyRoot);

	if (ERROR_SUCCESS == lResult)
	{
		TCHAR szValueName[256];

		DWORD dwSize;
		DWORD dwIndex = 0;
		DWORD dwType;
		DWORD cbBuffer;

		do
		{
			dwSize = sizeof(szValueName) / sizeof(TCHAR);

			if (NULL == szDllPath)
			{
				// Office9 203539
				// Can be called just to check in-proc dlls
				lResult = ::RegEnumValue(hkeyRoot, dwIndex++,
								szValueName, &dwSize, NULL,
								&dwType, NULL, NULL);
			}
			else
			{
				// Reset buffer on each iteration
				szDllPath[0] = '\0';
				cbBuffer = cbBufferSize;

				lResult = ::RegEnumValue(hkeyRoot, dwIndex++,
								szValueName, &dwSize, NULL,
								&dwType, (LPBYTE) szDllPath, &cbBuffer);
			}

			if (ERROR_SUCCESS == lResult)
			{
				if (NULL != ThunkGetModuleHandle(szValueName))
				{
					fNeedsMSMAPI = TRUE;

					break;
				}
			}
		} while (ERROR_SUCCESS == lResult);

		::RegCloseKey(hkeyRoot);
	}

	return fNeedsMSMAPI;
}


// $NOTE (ericwong 7-15-98) Copied from mso9\office.cpp

/*---------------------------------------------------------------------------
	MsoSzFindSzInRegMultiSz
	
	Search a multi-string structure (matching the format used by REG_MULTI_SZ)
	for a string matching the provided string.
	
	ARGUMENTS
	
	cmszMultiSz		REG_MULTI_SZ string list
	cszSrchStr		String to search for
	lcidLocale		Locale to use when comparing strings
	
	RETURNS
	
	NULL on failure to find search string.
	Pointer to occurence of search string on success.
----------------------------------------------------------------- joeldow -*/
char* MsoSzFindSzInRegMultiSz(const char* cmszMultiSz, const char* cszSrchStr, LCID lcidLocale)
{
	DWORD 		dwMultiLen;								// Length of current member
	DWORD		dwSrchLen	= lstrlenA(cszSrchStr);	// Constant during search
//	const int	CSTR_EQUAL	= 2;						// per winnls.h
	
	while (*cmszMultiSz)							// Break on consecutive zero bytes
	{
		// Format is Str1[\0]Str2[\0]Str3[\0][\0]
		dwMultiLen = lstrlenA(cmszMultiSz);
		
		Assert(dwMultiLen > 0 /*, "String parsing logic problem" */);
		
		if (dwMultiLen == dwSrchLen &&
			CompareStringA(lcidLocale, 0, cmszMultiSz, dwMultiLen, cszSrchStr, dwSrchLen) == CSTR_EQUAL)
			return (char*)cmszMultiSz;
			
		cmszMultiSz += (dwMultiLen + 1);			// Modify index into constant, not constant...
	}
	
	return NULL;
}

/*---------------------------------------------------------------------------
	MsoFIsTerminalServer

	Are we running under Windows-Based Terminal Server (a.k.a. Hydra)?
	Hydra is a thin-client environment where low-end machines can run Win32
	apps.  All application logic runs on the server, and display bits and
	user input are transmitted through a LAN/dialup connection.

	Use this routine to fork behavior on animation/sound-intensive features
	(e.g., splashes) to minimize unnecessary bits forced across the network.
	
	Sermonette of the day:  If we do a good job supporting Office on $500
	WBTs, how many of our customers will choose NCs and second-rate
	productivity apps instead?
	
	NOTE:  This function does not use ORAPI because ORAPI doesn't currently
	support REG_MULTI_SZ's.  (It also has no need for policy or defaults.)
	Using ANSI registry calls because product information strings should be
	non-localized ANSI text.
----------------------------------------------------------------- joeldow -*/
// Activate this to allow testing of Hydra features on standard machine.
//#define TEST_EXCEPT
BOOL MsoFIsTerminalServerX(void)
{
	const char*		cszSrchStr		= "Terminal Server";	// STRING_OK
	const char*		cszKey			= "System\\CurrentControlSet\\Control\\ProductOptions";	// STRING_OK
	const char*		cszValue		= "ProductSuite";	// STRING_OK
	char*			pszSuiteList	= NULL;
#ifndef TEST_EXCEPT
	static BOOL		fIsHydra		= FALSE;	
	static BOOL		fHydraDetected	= FALSE;
#else
	static BOOL		fIsHydra		= TRUE;	
	static BOOL		fHydraDetected	= TRUE;
#endif	
	DWORD			dwSize			= 0;
	DWORD			dwSizeRead;
	HKEY			hkey			= NULL;
	DWORD			dwType;
	
	if (fHydraDetected)
		return fIsHydra;						// Get out cheap...
	
 	// On NTS5, the ProductSuite "Terminal Server" value will always be present.
	// Need to call NT5-specific API to get the right answer.
	if (verWinNT() > 4)
 	{
		OSVERSIONINFOEXA osVersionInfo = {0};
		DWORDLONG dwlConditionMask = 0;

		osVersionInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEXA);
		osVersionInfo.wSuiteMask = VER_SUITE_TERMINAL;

 	    VER_SET_CONDITION( dwlConditionMask, VER_SUITENAME, VER_AND );

// 	    fIsHydra = MsoFVerifyVersionInfo(
 	    fIsHydra = VerifyVersionInfo(
			&osVersionInfo,
			VER_SUITENAME,
			dwlConditionMask);
 	}
	// If the value we want exists and has a non-zero size...
	else if (verWinNT() == 4 &&
		RegOpenKeyA(HKEY_LOCAL_MACHINE, cszKey, &hkey) == ERROR_SUCCESS &&
		RegQueryValueExA(hkey, cszValue, NULL, &dwType, NULL, &dwSize) == ERROR_SUCCESS && dwSize > 0)
	{
		Assert(dwType == REG_MULTI_SZ /*, "Unexpected ProductSuite type in registry!" */);
			
		pszSuiteList = (char*) HeapAlloc(GetProcessHeap(), 0, dwSize);
		if (dwType == REG_MULTI_SZ && pszSuiteList)
		{
			dwSizeRead = dwSize;				// Needed for proper release of memory on error.
				
			if (RegQueryValueExA(hkey, cszValue, NULL, &dwType, (BYTE*)pszSuiteList, &dwSizeRead) == ERROR_SUCCESS)
			{
				Assert(dwSizeRead == dwSize);
					
				fIsHydra = MsoSzFindSzInRegMultiSz(pszSuiteList, cszSrchStr, CP_ACP) != NULL;
			}
			
			HeapFree(GetProcessHeap(), 0, (LPVOID) pszSuiteList);
		}			
	}

	if (hkey)
        RegCloseKey(hkey);		
	
	fHydraDetected = TRUE;						// only bother with all this once...
	
	return fIsHydra;
}

BOOL FGetMapiDll(HKEY hkeyRoot, LPSTR szDllPath, DWORD cbBufferSize, BOOL fSimple)
{
	szDllPath[0] = '\0';

	DWORD cbBufferSizeT;
	DWORD dwType;

	HKEY hkey = NULL;
	LONG lResult;

	// Open the key to find out what the default mail program is.

	lResult = ::RegOpenKeyEx(hkeyRoot,
						"Software\\Clients\\Mail", 0, KEY_READ, &hkey);

	if (ERROR_SUCCESS == lResult)
	{
		char szMailKey[MAX_PATH + 1] = "";
		char szDefaultMail[MAX_PATH + 1];

		// Office9 195750
		// Let HKLM\Software\Microsoft\Windows Messaging Subsystem\MSMapiApps
		// DLL reg values indicate mail client to which MAPI calls get sent.
		if (FAlwaysNeedsMSMAPI(szMailKey, sizeof(szMailKey)))
		{
			if (szMailKey[0] != '\0')
			{
				// Mail client supplied
				lstrcpy(szDefaultMail, szMailKey);
				lResult = ERROR_SUCCESS;
			}
			else
			{
				// No mail client, use mapi32x.dll
				lResult = ERROR_PATH_NOT_FOUND;
			}
		}
		else
		{
			DWORD dwSize = sizeof(szDefaultMail);

			// Find out what the default mail program is.

			lResult = ::RegQueryValueEx(hkey, NULL,	NULL, NULL, (LPBYTE) szDefaultMail, &dwSize);
		}

		if (ERROR_SUCCESS == lResult)
		{
			HKEY hkeyDefaultMail = NULL;

			// Open the key for the default mail program to see where the dll is.

			lResult = ::RegOpenKeyEx(hkey, szDefaultMail, 0, KEY_READ, &hkeyDefaultMail);

			if (ERROR_SUCCESS == lResult)
			{
				TCHAR szComponent[39] = {0};	// strlen(GUID)

				DWORD dwMSIInstallOnWTS;
				LPTSTR szMSIOfficeLCID = NULL;
				LPTSTR szMSIApplicationLCID = NULL;

				// Get MSIInstallOnWTS, 0 means don't demand-install on Hydra
				cbBufferSizeT = sizeof(dwMSIInstallOnWTS);
				lResult = ::RegQueryValueEx(hkeyDefaultMail,
								"MSIInstallOnWTS",
								NULL, &dwType, (LPBYTE) &dwMSIInstallOnWTS, &cbBufferSizeT);
				
				if (ERROR_SUCCESS == lResult && REG_DWORD == dwType)
				{
					// Use what is returned
				}
				else
				{
					dwMSIInstallOnWTS = 1;	// Default is TRUE
				}

				// Get MSIApplicationLCID
				lResult = ::RegQueryValueEx(hkeyDefaultMail,
								"MSIApplicationLCID",
								NULL, &dwType, NULL, &cbBufferSizeT);

				if (ERROR_SUCCESS == lResult && REG_MULTI_SZ == dwType)
				{
					szMSIApplicationLCID = (LPTSTR)
						HeapAlloc(GetProcessHeap(), 0, cbBufferSizeT);

					if (szMSIApplicationLCID)
					{
						lResult = ::RegQueryValueEx(hkeyDefaultMail,
										"MSIApplicationLCID",
										NULL, &dwType,
										(LPBYTE) szMSIApplicationLCID,
										&cbBufferSizeT);
						Assert(ERROR_SUCCESS == lResult && REG_MULTI_SZ == dwType);
					}
				}

				// Get MSIOfficeLCID
				lResult = ::RegQueryValueEx(hkeyDefaultMail,
								"MSIOfficeLCID",
								NULL, &dwType, NULL, &cbBufferSizeT);
				
				if (ERROR_SUCCESS == lResult && REG_MULTI_SZ == dwType)
				{
					szMSIOfficeLCID = (LPTSTR)
						HeapAlloc(GetProcessHeap(), 0, cbBufferSizeT);

					if (szMSIOfficeLCID)
					{
						lResult = ::RegQueryValueEx(hkeyDefaultMail,
										"MSIOfficeLCID",
										NULL, &dwType,
										(LPBYTE) szMSIOfficeLCID,
										&cbBufferSizeT);
						Assert(ERROR_SUCCESS == lResult && REG_MULTI_SZ == dwType);
					}
				}

				// Find out what the component is.
				cbBufferSizeT = sizeof(szComponent);
				lResult = ::RegQueryValueEx(hkeyDefaultMail,
								"MSIComponentID",
								NULL, &dwType, (LPBYTE) szComponent, &cbBufferSizeT);
				
				if (ERROR_SUCCESS == lResult && REG_SZ == dwType)
				{
					BOOL fInstall;

					// Office 9 does not permit demand-install on Hydra
					fInstall = dwMSIInstallOnWTS || !MsoFIsTerminalServerX();

					// First try Application's LCID(s)
					if (szMSIApplicationLCID &&
						FGetComponentPath(szComponent, szMSIApplicationLCID,
							szDllPath, cbBufferSize, fInstall))
						goto CloseDefaultMail;

					// Then try Office's LCID(s)
					if (szMSIOfficeLCID &&
						FGetComponentPath(szComponent, szMSIOfficeLCID,
							szDllPath, cbBufferSize, fInstall))
						goto CloseDefaultMail;

					// Finally try the defaults
					if (FGetComponentPath(szComponent, NULL,
							szDllPath, cbBufferSize, fInstall))
						goto CloseDefaultMail;
				}

				// Find out what the dll is.
				cbBufferSizeT = cbBufferSize;
				lResult = ::RegQueryValueEx(hkeyDefaultMail,
								fSimple ? "DLLPath" : "DLLPathEx",
								NULL, &dwType, (LPBYTE) szDllPath, &cbBufferSizeT);
				if (ERROR_SUCCESS != lResult)
				{
					szDllPath[0] = '\0';
				}
				else
					if(REG_EXPAND_SZ == dwType)
					{
						char szExpandedPath[MAX_PATH];
						if(ExpandEnvironmentStrings(szDllPath, szExpandedPath, MAX_PATH) > 0)
							lstrcpy(szDllPath, szExpandedPath);
					}
						
CloseDefaultMail:

				if (szMSIApplicationLCID)
					HeapFree(GetProcessHeap(), 0, (LPVOID) szMSIApplicationLCID);

				if (szMSIOfficeLCID)
					HeapFree(GetProcessHeap(), 0, (LPVOID) szMSIOfficeLCID);

				::RegCloseKey(hkeyDefaultMail);
			}
		}

		::RegCloseKey(hkey);
	}

	return ('\0' != szDllPath[0]);
}

// How to find the MAPI Dll:
//
// Go to HKLM\Software\Clients\Mail\(Default) to get the name of the
// default mail client.  Then go to
//     HKLM\Software\Clients\Mail\(Name of default mail client)\DLLPath
// to get the name of the dll.
// If the regkey doesn't exist, just use mapi32x.dll

void GetMapiDll(LPSTR szDllPath, DWORD cbBufferSize, BOOL fSimple)
{
	szDllPath[0] = '\0';

	// Office9 ?
	// Allow app (namely Platinum Server) to take unhandled extended MAPI
	// calls rather than send them to mapi32x.dll (system MAPI)
	if (!fSimple && !FAlwaysNeedsMSMAPI(NULL, 0))
	{
		DWORD dwError;
		HKEY hkeyMail;

		OFSTRUCT ofs;

		// Get HKLM\Software\Clients\Mail registry key
		dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
			TEXT("Software\\Clients\\Mail"), 0, KEY_READ, &hkeyMail);
		if (dwError == ERROR_SUCCESS)
		{
			DWORD dwType;
			DWORD cbBufferSizeT = cbBufferSize;

			// Get DLLPathEx registry value
			dwError = RegQueryValueEx(hkeyMail, TEXT("DLLPathEx"), NULL,
				&dwType, (LPBYTE) szDllPath, &cbBufferSizeT);
			if (dwError == ERROR_SUCCESS)
			{
				if (dwType == REG_EXPAND_SZ)
				{
					char szExpandedPath[MAX_PATH];

					if (ExpandEnvironmentStrings
							(szDllPath, szExpandedPath, MAX_PATH) > 0)
						lstrcpy(szDllPath, szExpandedPath);
				}
				else if (dwType == REG_SZ)
				{
					// OK, do nothing
				}
				else
				{
					// Empty string
					szDllPath[0] = '\0';
				}
			}

			RegCloseKey(hkeyMail);
		}

		// Bail if DLLPathEx retrieved and file exists
		if (('\0' != szDllPath[0]) &&
			(OpenFile(szDllPath, &ofs, OF_EXIST) != HFILE_ERROR))
			return;
	}

	// Office9 120315
	// Get MAPI-substitute from HKCU or HKLM
	if (FGetMapiDll(HKEY_CURRENT_USER, szDllPath, cbBufferSize, fSimple) ||
		FGetMapiDll(HKEY_LOCAL_MACHINE, szDllPath, cbBufferSize, fSimple))
		return;


	if ('\0' == szDllPath[0])
	{
		Assert(cbBufferSize >= 13);

		MyStrCopy(szDllPath, "mapi32x.dll");
	}

	Assert('\0' != szDllPath[0]);

}


BOOL FShowPreFirstRunMessage()
{
	static BOOL fPreFirstRun = FALSE;

	DWORD cbBufferSizeT;
	DWORD dwType;

	HKEY hkey = NULL;
	LONG lResult;

	// Office9 98186, 104097
	// Display message if PreFirstRun registry value present
	if (!fPreFirstRun)
	{
		lResult = ::RegOpenKeyEx(HKEY_LOCAL_MACHINE,
							"Software\\Clients\\Mail", 0, KEY_READ, &hkey);

		if (ERROR_SUCCESS == lResult)
		{
			LPTSTR szPreFirstRun = NULL;
			LPTSTR szText;
			LPTSTR szCaption;
			TCHAR * pch;
			BOOL fNoMailClient = FALSE;

			// Get the required buffer size
			cbBufferSizeT = 0;
			lResult = ::RegQueryValueEx(hkey,
							"PreFirstRun",
							NULL, NULL, NULL, &cbBufferSizeT);

			if (ERROR_SUCCESS != lResult)
			{
				// Office9 161532
				// Display message if NoMailClient registry value present
				cbBufferSizeT = 0;
				lResult = ::RegQueryValueEx(hkey,
								"NoMailClient",
								NULL, NULL, NULL, &cbBufferSizeT);

				if (ERROR_SUCCESS != lResult)
					goto Done;

				fNoMailClient = TRUE;
			}

			// Allocate buffer
			szPreFirstRun = (LPTSTR) HeapAlloc(GetProcessHeap(), 0, cbBufferSizeT);
			if (!szPreFirstRun)
				goto Done;

			// Get PreFirstRun warning
			lResult = ::RegQueryValueEx(hkey,
							fNoMailClient ? "NoMailClient" : "PreFirstRun",
							NULL, &dwType, (LPBYTE) szPreFirstRun, &cbBufferSizeT);

			if (ERROR_SUCCESS != lResult ||
				REG_SZ != dwType ||
				'\0' == szPreFirstRun[0])
				goto Done;

			// szPreFirstRun = "<text>{*<caption>}"
			szText = szPreFirstRun;

			// Find end of <text> to get <caption>
			pch = szPreFirstRun;
			while (*pch && *pch != '*')
				pch = CharNext(pch);

			// Handle no <caption>
			if (!*pch)
			{
				szCaption = NULL;
			}
			else	// Got '*'
			{
				szCaption = CharNext(pch);
				if (!*szCaption)
					szCaption = NULL;
			}
			*pch = '\0';

			// Display PreFirstRun warning
			MessageBoxFn(szText, szCaption, MB_TASKMODAL);

			// Only show PreFirstRun warning once
			fPreFirstRun = TRUE;

Done:

			// Free buffer
			if (szPreFirstRun)
				HeapFree(GetProcessHeap(), 0, (LPVOID) szPreFirstRun);

			::RegCloseKey(hkey);
		}
	}

	return fPreFirstRun;
}


HMODULE GetProxyDll(BOOL fSimple)
{
    char szLibrary[MAX_PATH + 1] = "";

    HMODULE * phmod = fSimple ? &hmodSimpleMAPI : &hmodExtendedMAPI;

    if (NULL == *phmod)
    {
        // We have a few special cases here.  We know that the omi and
        // msmapi32 dlls are both Simple and Extended MAPI dlls.  If an
        // application (like outlook!) has already loaded one of them,
        // we should just keep using it instead of going to the registry
        // and possibly getting the wrong dll.

        // Notice that we still call MyLoadLibrary() so we can get the
        // right dll (see MyLoadLibrary() for descriptions of OS bugs)
        // and so that the dll will be properly ref-counted.

        // Legacy MAPI apps like Outlook 97/98, Exchange 4.x/5.x and
        // Schedule+ should get their calls redirected to the system
        // mapi32x.dll. They're checked in FAlwaysNeedsMSMAPI().

		// 1. Handle MAPI calls from Outlook extensions
        if (ThunkGetModuleHandle("omi9.dll"))
        {
            *phmod = MyLoadLibrary("omi9.dll", hinstSelf);
        }
        else if (ThunkGetModuleHandle("omint.dll"))
        {
            *phmod = MyLoadLibrary("omint.dll", hinstSelf);
        }
        else if (ThunkGetModuleHandle("msmapi32.dll"))
        {
            *phmod = MyLoadLibrary("msmapi32.dll", hinstSelf);
        }

		// 2. Look in mail client key
        else
        {
			OFSTRUCT ofs;

            GetMapiDll(szLibrary, sizeof(szLibrary), fSimple);

			// NOTE 1:
			// Outlook 9 sets DLLPath=mapi32.dll for IE mailto: forms.
			// If Outlook is set as the default mail client before
			// First Run is finished (and MSIComponentID written),
			// the stub will read DLLPath instead and end up in an
			// infinite loop loading mapi32.dll (itself).

			// NOTE 2:
			// Windows 95 ships with mapi32.dll that gets renamed
			// mapi32x.dll when the stub is installed. That means
			// an extended MAPI call will always get routed to
			// mapi32x.dll if the default mail client does not
			// handle it, which brings up the Profile wizard with
			// an error saying mapisvc.inf is missing. If we're
			// going to route an extended MAPI call to "mapi32x.dll",
			// there must also be "mapisvc.inf" present.

			// NOTE 3:
			// To fix Office9 161532, I'll have to remove the fSimple
			// so no MAPI calls go to the original mapi32.dll unless
			// mapisvc.inf is present, indicating another mail client.

			// NOTE 4:
			// If a special dll is making the MAPI call and it's being
			// routed to mapi32x.dll, it's ok to forgo the mapisvc.inf
			// check. (Office9 203539, caused by Office9 195750)

			if (lstrcmp(szLibrary, "mapi32.dll") != 0 /* NOTE 1 */ &&
				(/* NOTE 2 */ /* NOTE 3 fSimple || */
				lstrcmp(szLibrary, "mapi32x.dll") != 0 ||
				(OpenFile("mapisvc.inf", &ofs, OF_EXIST) != HFILE_ERROR) ||
				/* NOTE 4 */ FAlwaysNeedsMSMAPI(NULL, 0)))
				*phmod = MyLoadLibrary(szLibrary, hinstSelf);

			if (!*phmod)
				FShowPreFirstRunMessage();
        }
    }

    return *phmod;
}




extern "C" DWORD STDAPICALLTYPE GetOutlookVersion(void)
{
	return OUTLOOKVERSION;
}


/*
 *	M A P I   S t u b   R e p a i r   T o o l
 *
 */

enum MAPI
{
	mapiNone,		// No mapi32.dll in system directory
	mapiNewStub,	// mapi32.dll is current stub
	mapiOldMS,		// mapi32.dll from Win 95, NT 4, Exchange 4.x 5.x
	mapiEudora,		// mapi32.dll from Eudora
	mapiNetscape,	// mapi32.dll from Netscape
	mapiMapi32x,	// mapi32x.dll is original mapi32.dll
	mapiMapi32OE,	// mapi32.oe is original mapi32.dll from Outlook 98
	mapiMSMapi32,	// msmapi32.dll is original mapi32.dll from Outlook 9
};

// Keep in sync with enum table above
static LPTSTR rgszDLL[] =
{
	TEXT(""),
	TEXT("\\mapistub.dll"),
	TEXT("\\mapi32.dll"),
	TEXT("\\eumapi32.dll"),
	TEXT("\\nsmapi32.dll"),
	TEXT("\\mapi32x.dll"),
	TEXT("\\mapi32.oe"),
	TEXT("\\msmapi32.dll"),
};

/*
 *	RegisterMailClient
 *
 *	HKLM\Software\Clients\Mail\<pszMailClient>
 *	HKLM\Software\Clients\Mail\<pszMailClient>::"" = <pszMailClient>
 *	HKLM\Software\Clients\Mail\<pszMailClient>::"DLLPath" = <szMAPI32XDLL>
 *	HKLM\Software\Clients\Mail\<pszMailClient>::"DLLPathEx" = <szMAPI32XDLL>
 *	HKLM\Software\Clients\Mail::"" = <pszMailClient> (default mail client)
 */

DWORD RegisterMailClient
	(LPTSTR pszMailClient,
	BOOL fSimpleMAPI,
	BOOL fExtendedMAPI,
	LPTSTR szMAPI32XDLL)
{
	DWORD dwError = ERROR_SUCCESS;

	HKEY hkeyDefaultMail = NULL;
	HKEY hkeyMailClient = NULL;
	DWORD dwDisposition;

	AssertSz(pszMailClient, "No registry key name");

	// Get mail clients registry key
	dwError = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
		TEXT("Software\\Clients\\Mail"), 0, NULL, 0, KEY_ALL_ACCESS, NULL,
		&hkeyDefaultMail, NULL);
	if (dwError != ERROR_SUCCESS)
		goto Error;

	// Create new registry key, ok to overwrite existing key
	dwError = RegCreateKeyEx(hkeyDefaultMail, pszMailClient, 0, NULL, 0,
		KEY_ALL_ACCESS, NULL, &hkeyMailClient, &dwDisposition);
	if (dwError != ERROR_SUCCESS)
		goto Error;

	// Set mail client name if there isn't already one
	if (dwDisposition == REG_CREATED_NEW_KEY)
		RegSetValueEx(hkeyMailClient, TEXT(""), 0, REG_SZ,
			(LPBYTE) pszMailClient, lstrlen(pszMailClient));

	// Set DLLPath
	if (fSimpleMAPI)
		RegSetValueEx(hkeyMailClient, TEXT("DLLPath"), 0, REG_SZ,
			(LPBYTE) szMAPI32XDLL, lstrlen(szMAPI32XDLL));

	// Set DLLPathEx
	if (fExtendedMAPI)
		RegSetValueEx(hkeyMailClient, TEXT("DLLPathEx"), 0, REG_SZ,
			(LPBYTE) szMAPI32XDLL, lstrlen(szMAPI32XDLL));

	// Set default mail client
	RegSetValueEx(hkeyDefaultMail, TEXT(""), 0, REG_SZ,
		(LPBYTE) pszMailClient, lstrlen(pszMailClient));

	// $REVIEW 3-4-98 Should I copy the protocols to HKCR?

Error:

	if (hkeyMailClient)
		RegCloseKey(hkeyMailClient);

	if (hkeyDefaultMail)
		RegCloseKey(hkeyDefaultMail);

	return dwError;
}


extern "C" typedef UINT (* PFN_GETSYSTEMDIRECTORY)(LPTSTR, UINT);
STDAPICALLTYPE FixMAPIPrivate(PFN_GETSYSTEMDIRECTORY GetSystemDirectory,
                              LPCTSTR szMAPIStubDirectory);

extern "C" DWORD STDAPICALLTYPE FixMAPI(void)
{

    DWORD dwError;

    TCHAR szMAPIStubDLL[MAX_PATH];

    // Both mapistub.dll and wimapi32.dll reside in the system directory

    if (!GetSystemDirectory(szMAPIStubDLL, sizeof(szMAPIStubDLL)))
    {
        return GetLastError();
    }

    dwError = FixMAPIPrivate(GetSystemDirectory, szMAPIStubDLL);

    return dwError;
}

/*
 *	FExchangeServerInstalled
 *
 *	Exchange Server is installed if the Services registry value exists
 *	under HKLM\Software\Microsoft\Exchange\Setup registry key
 */

BOOL FExchangeServerInstalled()
{
	DWORD dwError;
	HKEY hkeyServices = NULL;

	// Get HKLM\Software\Microsoft\Exchange\Setup registry key
	dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
		TEXT("Software\\Microsoft\\Exchange\\Setup"), 0, KEY_READ,
		&hkeyServices);
	if (dwError == ERROR_SUCCESS)
	{
		// Does Services registry value exist?
		dwError = RegQueryValueEx(hkeyServices,
			TEXT("Services"), NULL, NULL, NULL, NULL);
	}

	if (hkeyServices)
		RegCloseKey(hkeyServices);

	return (dwError == ERROR_SUCCESS);
}

/*
 *	FixMAPI
 *
 *	Part 1: Initialize paths to mapi files
 *	Part 2: Is mapi32.dll a mapiNone mapiNewStub mapiOldMS or ?
 *	Part 3: Move and copy various mapi files
 *	Part 4: Register mapi32x.dll and non-MS mapi32.dll
 *
 */

STDAPICALLTYPE FixMAPIPrivate(PFN_GETSYSTEMDIRECTORY pfGetSystemDirectory,
                              LPCTSTR szMAPIStubDirectory)
{
	DWORD dwError = ERROR_SUCCESS;

	TCHAR szSystemDir[MAX_PATH];	// Path to system directory
	TCHAR szMAPI32DLL[MAX_PATH];	// Path to mapi32.dll
	TCHAR szMAPIStubDLL[MAX_PATH];	// Path to mapistub.dll
	TCHAR szMAPI32OE[MAX_PATH];		// Path to mapi32.oe
	TCHAR szMSMAPI32DLL[MAX_PATH];	// Path to msmapi32.dll
	TCHAR szMAPI32XDLL[MAX_PATH];	// Path to mapi32x.dll
	TCHAR szNonMSDLL[MAX_PATH];		// Path to non-MS mapi32.dll

	MAPI mapi = mapiNone;

	HINSTANCE hinst;
	BOOL fSimpleMAPI = FALSE;
	BOOL fExtendedMAPI = FALSE;

	// Office9 119757, 120419
	// Don't install the stub if Exchange Server is installed
	if (FExchangeServerInstalled())
		goto Error;

	// *** PART 1: Initialize paths

	if (!(pfGetSystemDirectory(szSystemDir, sizeof(szSystemDir)) &&
		lstrcpy(szMAPI32DLL, szSystemDir) &&
		lstrcat(szMAPI32DLL, rgszDLL[mapiOldMS]) &&
		lstrcpy(szMAPIStubDLL, szMAPIStubDirectory) &&
		lstrcat(szMAPIStubDLL, rgszDLL[mapiNewStub]) &&
		lstrcpy(szMAPI32OE, szSystemDir) &&
		lstrcat(szMAPI32OE, rgszDLL[mapiMapi32OE]) &&
		lstrcpy(szMSMAPI32DLL, szSystemDir) &&
		lstrcat(szMSMAPI32DLL, rgszDLL[mapiMSMapi32]) &&
		lstrcpy(szMAPI32XDLL, szSystemDir) &&
		lstrcat(szMAPI32XDLL, rgszDLL[mapiMapi32x]) &&
		lstrcpy(szNonMSDLL, szSystemDir)))
	{
		dwError = GetLastError();
		goto Error;
	}

	// *** PART 2: Determine mapi32.dll type

	AssertSz(mapi == mapiNone, "mapi is undefined");

	// Does it exist?  No, go to Part3
	if (GetFileAttributes(szMAPI32DLL) == 0xFFFFFFFF)
		goto Part3;

	// Is it the stub?

        // Note for WX86: If whmapi32 links to mapi32 instead of
        // linking to mapistub, the following is relevant. It is
        // no longer needed (and the 4th argument to ThunkLoadLibrary
        // is no longer needed - it could always be
        // LOAD_WITH_ALTERED_SEARCH_PATH), but leave it in just in case
        // we need this in the future. Note that it does not hurt to
        // not resolve dll references for this load because we are
        // just going to do a GetProcAddress.
        //
        // If whmapi32 is linked to mapi32:
        //
        // If the mapi32 in the x86 system directory is wimapi,
        // the WX86 loader will fail to load it. wimapi32 links
        // whmapi32 which links mapi32. The loader resolves the
        // link to mapi32 as sys32x86\mapi32 (= wimapi32).
        // Apparently this is by design. The load fails.
        //
        // To work around this, we use the
        // DONT_RESOLVE_DLL_REFERENCES flag. This will allow us
        // to check if mapi32 is wimapi32 by doing a
        // GetProcAddress.

	hinst = ThunkLoadLibrary(szMAPI32DLL, &bNativeDll, FALSE,
                                 DONT_RESOLVE_DLL_REFERENCES);
	if (hinst)
	{
		mapi = mapiOldMS;

		// Only the stub has "GetOutlookVersion"
		if (GetProcAddress(hinst, TEXT("GetOutlookVersion")))
			mapi = mapiNewStub;

		// Check for Eudora mapi32.dll
		if (GetProcAddress(hinst, TEXT("IsEudoraMapiDLL")))
			mapi = mapiEudora;

		// Check for Netscape mapi32.dll
		if (GetProcAddress(hinst, TEXT("MAPIGetNetscapeVersion")))
			mapi = mapiNetscape;

		// Check for Simple MAPI
		if (GetProcAddress(hinst, TEXT("MAPILogon")))
			fSimpleMAPI = TRUE;

		// Check for Extended MAPI
		if (GetProcAddress(hinst, TEXT("MAPILogonEx")))
			fExtendedMAPI = TRUE;

		ThunkFreeLibrary(hinst, bNativeDll, 0);
	}

Part3:

	// *** PART 3: Restore files

	// Rename non-MS mapi32.dll, ok to overwrite existing dll
	if (mapi == mapiEudora || mapi == mapiNetscape)
	{
		if (!(lstrcat(szNonMSDLL, rgszDLL[mapi]) &&
			CopyFile(szMAPI32DLL, szNonMSDLL, FALSE)))
		{
			dwError = GetLastError();
			goto Error;
		}
	}

	// Deal with missing mapi32x.dll (OE case on non-NT5)
	if (mapi == mapiOldMS)
	{
		// Copy old mapi32.dll to mapi32x.dll
		DeleteFile(szMAPI32XDLL);
		if (!MoveFile(szMAPI32DLL, szMAPI32XDLL))
		{
			dwError = GetLastError();
			goto Error;
		}

		// Get rid of old stubs so they don't replace mapi32x.dll
		// if FixMAPI() is called again
		DeleteFile(szMAPI32OE);
		DeleteFile(szMSMAPI32DLL);
	}
	else	// Clean up after old stubs
	{
		OFSTRUCT ofs;

		// X5 78382
		// Outlook 98 OMI stub renamed original mapi32.dll as mapi32.oe
		if (OpenFile(szMAPI32OE, &ofs, OF_EXIST) != HFILE_ERROR)
		{
			// Copy old mapi32.oe to mapi32x.dll
			DeleteFile(szMAPI32XDLL);
			if (!MoveFile(szMAPI32OE, szMAPI32XDLL))
			{
				dwError = GetLastError();
				goto Error;
			}
		}

		// Office9 214650
		// Copy Outlook 98 OMI mode backup mapi32.dll as mapi32x.dll
		{
			DWORD dwError;
			HKEY hkeyInstall;
			TCHAR szDllPath[MAX_PATH] = {0};

			// Get HKLM\Software\Microsoft\Active Setup\OutlookInstallInfo
			dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
				TEXT("Software\\Microsoft\\Active Setup\\OutlookInstallInfo"),
				0, KEY_READ, &hkeyInstall);
			if (dwError == ERROR_SUCCESS)
			{
				DWORD dwType;
				DWORD cbBufferSize = sizeof(szDllPath);

				// Get Install Dir registry value
				dwError = RegQueryValueEx(hkeyInstall, TEXT("Install Dir"),
					NULL, &dwType, (LPBYTE) szDllPath, &cbBufferSize);
				if (dwError == ERROR_SUCCESS && dwType == REG_SZ)
				{
					lstrcat(szDllPath, TEXT("\\office\\outlook\\backups"));
					lstrcat(szDllPath, verWinNT() ? TEXT("\\nt") : TEXT("\\windows"));
					lstrcat(szDllPath, TEXT("\\mapi32.dll"));
				}
				else
				{
					szDllPath[0] = '\0';
				}

				RegCloseKey(hkeyInstall);
			}

			// Outlook 98 OMI copied original mapi32.dll to backup directory
			if (('\0' != szDllPath[0]) &&
				(OpenFile(szDllPath, &ofs, OF_EXIST) != HFILE_ERROR))
			{
				HINSTANCE hinst;
				BOOL fStub;

				// Office9 225191
				// Must check if the mapi32.dll backed up by Outlook 98
				// Internet-Only mode is a stub; don't copy as mapi32x.dll
				// if it is, otherwise the stub mapi32.dll will call the
				// STUB mapi32x.dll which calls itself over and over again.
				// (A stub can be present if you install Outlook 98 OMI mode
				// on W9x with IE5 or W98SP1/NT5 which include IE5.)
				hinst = ThunkLoadLibrary(szDllPath, &bNativeDll, FALSE,
					DONT_RESOLVE_DLL_REFERENCES);
				fStub = hinst && GetProcAddress(hinst, TEXT("GetOutlookVersion"));
				if (hinst)
					ThunkFreeLibrary(hinst, bNativeDll, 0);

				if (!fStub)
				{
					// Copy backup mapi32.dll to mapi32x.dll
					DeleteFile(szMAPI32XDLL);
					if (!MoveFile(szDllPath, szMAPI32XDLL))
					{
						dwError = GetLastError();
						goto Error;
					}
				}
			}
		}

		// Upgrade original mapi32.dll renamed by earlier mapistub.dll
		if (OpenFile(szMSMAPI32DLL, &ofs, OF_EXIST) != HFILE_ERROR)
		{
			// Copy old msmapi32.dll to mapi32x.dll
			DeleteFile(szMAPI32XDLL);
			if (!MoveFile(szMSMAPI32DLL, szMAPI32XDLL))
			{
				dwError = GetLastError();
				goto Error;
			}
		}
	}

	// Copy mapistub.dll to mapi32.dll even if mapi32.dll is the stub
	// (mapiNewStub) because we don't have the file version handy and
	// GetOutlookVersion() always returns 402 so it doesn't break
	// Outlook 98 Internet-only mode, which only works with version 402.
	if (!CopyFile(szMAPIStubDLL, szMAPI32DLL, FALSE))
	{
		dwError = GetLastError();
		goto Error;
	}

	// *** PART 4: Write registry settings

	// Register Eudora mapi32.dll
	if (mapi == mapiEudora)
		RegisterMailClient(TEXT("Eudora"),
			fSimpleMAPI, fExtendedMAPI, szNonMSDLL);

	// Register Netscape mapi32.dll
	if (mapi == mapiNetscape)
		RegisterMailClient(TEXT("Netscape Messenger"),
			fSimpleMAPI, fExtendedMAPI, szNonMSDLL);

Error:

	return dwError;
}



#define LINKAGE_EXTERN_C		extern "C"
#define LINKAGE_NO_EXTERN_C		/* */

#define ExtendedMAPI	FALSE
#define SimpleMAPI		TRUE

#if !defined (_X86_)

// Note: we continue to check for _ALPHA_ above so that if WX86 is nto defined,
// these #defines will be used

#define DEFINE_STUB_FUNCTION_V0(Simple, Linkage, Modifiers, FunctionName, Lookup)	\
																					\
	Linkage typedef void (Modifiers * FunctionName##FuncPtr)(void);					\
																					\
	Linkage void Modifiers FunctionName(void)										\
	{																				\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "										\
				"Entry point \"" #FunctionName "\" not found!");							\
		}																			\
		else																		\
		{																			\
			OMIStub##FunctionName();												\
		}																			\
	}


#define DEFINE_STUB_FUNCTION_0(Simple, Linkage, RetType, Modifiers,			\
		FunctionName, Lookup, Default)										\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(void);		\
																			\
	Linkage RetType Modifiers FunctionName(void)							\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName();									\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_V1(Simple, Linkage, Modifiers,					\
		FunctionName, Lookup, Param1Type)									\
																			\
	Linkage typedef void (Modifiers * FunctionName##FuncPtr)(Param1Type);	\
																			\
	Linkage void Modifiers FunctionName(Param1Type a)						\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
		}																	\
		else																\
		{																	\
			OMIStub##FunctionName(a);										\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_1(Simple, Linkage, RetType,					\
		Modifiers, FunctionName, Lookup, Param1Type, Default)				\
																			\
	Linkage typedef RetType													\
			(Modifiers * FunctionName##FuncPtr)(Param1Type);				\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a)					\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a);								\
		}																	\
	}

#define DEFINE_STUB_FUNCTION_USE_LOOKUP_1(Simple, Linkage, RetType,					\
		Modifiers, FunctionName, Lookup, Param1Type, Default)				\
																			\
	Linkage typedef RetType													\
			(Modifiers * FunctionName##FuncPtr)(Param1Type);				\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a)					\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a);								\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_V2(Simple, Linkage, Modifiers,					\
		FunctionName, Lookup, Param1Type, Param2Type)						\
																			\
	Linkage typedef void (Modifiers * FunctionName##FuncPtr)(				\
			Param1Type, Param2Type);										\
																			\
	Linkage void Modifiers FunctionName(Param1Type a, Param2Type b)			\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
		}																	\
		else																\
		{																	\
			OMIStub##FunctionName(a, b);									\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_2(Simple, Linkage, RetType, Modifiers,			\
		FunctionName, Lookup, Param1Type, Param2Type, Default)				\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type);										\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a, Param2Type b)		\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b);								\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_V3(Simple, Linkage, Modifiers,					\
		FunctionName, Lookup, Param1Type, Param2Type, Param3Type)			\
																			\
	Linkage typedef void (Modifiers * FunctionName##FuncPtr)(				\
			Param1Type, Param2Type, Param3Type);							\
																			\
	Linkage void Modifiers FunctionName(									\
			Param1Type a, Param2Type b, Param3Type c)						\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
		}																	\
		else																\
		{																	\
			OMIStub##FunctionName(a, b, c);									\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_3(Simple, Linkage, RetType, Modifiers,			\
		FunctionName, Lookup, Param1Type, Param2Type, Param3Type, Default)	\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type);							\
																			\
	Linkage RetType Modifiers FunctionName(									\
			Param1Type a, Param2Type b, Param3Type c)						\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c);							\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_4(Simple, Linkage,								\
		RetType, Modifiers, FunctionName, Lookup, Param1Type,				\
		Param2Type, Param3Type, Param4Type, Default)						\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type, Param4Type);				\
																			\
	Linkage RetType Modifiers FunctionName(									\
			Param1Type a, Param2Type b, Param3Type c, Param4Type d)			\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d);						\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_5(Simple, Linkage,								\
		RetType, Modifiers, FunctionName, Lookup,							\
		Param1Type, Param2Type, Param3Type,									\
		Param4Type, Param5Type, Default)									\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type, Param4Type, Param5Type);	\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a, Param2Type b,		\
			Param3Type c, Param4Type d, Param5Type e)						\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d, e);					\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_6(Simple, Linkage, RetType, Modifiers,			\
		FunctionName, Lookup, Param1Type, Param2Type,						\
		Param3Type, Param4Type, Param5Type, Param6Type, Default)			\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type,								\
			Param4Type, Param5Type, Param6Type);							\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a, Param2Type b,		\
			Param3Type c, Param4Type d, Param5Type e, Param6Type f)			\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d, e, f);					\
		}																	\
	}

#define DEFINE_STUB_FUNCTION_USE_LOOKUP_6(Simple, Linkage, RetType, Modifiers,			\
		FunctionName, Lookup, Param1Type, Param2Type,						\
		Param3Type, Param4Type, Param5Type, Param6Type, Default)			\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type,								\
			Param4Type, Param5Type, Param6Type);							\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a, Param2Type b,		\
			Param3Type c, Param4Type d, Param5Type e, Param6Type f)			\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d, e, f);					\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_V7(Simple, Linkage, Modifiers, FunctionName,	\
		Lookup, Param1Type, Param2Type, Param3Type, Param4Type,				\
		Param5Type, Param6Type, Param7Type)									\
																			\
	Linkage typedef void (Modifiers * FunctionName##FuncPtr)(				\
			Param1Type, Param2Type, Param3Type,								\
			Param4Type, Param5Type, Param6Type, Param7Type);				\
																			\
	Linkage void Modifiers FunctionName(Param1Type a,						\
			Param2Type b, Param3Type c, Param4Type d,						\
			Param5Type e, Param6Type f, Param7Type g)						\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
		}																	\
		else																\
		{																	\
			OMIStub##FunctionName(a, b, c, d, e, f, g);						\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_7(Simple, Linkage, RetType, Modifiers,			\
		FunctionName, Lookup, Param1Type, Param2Type, Param3Type,			\
		Param4Type, Param5Type, Param6Type, Param7Type, Default)			\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type, Param4Type,					\
			Param5Type, Param6Type, Param7Type);							\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a, Param2Type b,		\
			Param3Type c, Param4Type d, Param5Type e,						\
			Param6Type f, Param7Type g)										\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d, e, f, g);				\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_8(Simple, Linkage, RetType, Modifiers,				\
		FunctionName, Lookup, Param1Type, Param2Type, Param3Type,				\
		Param4Type, Param5Type, Param6Type, Param7Type, Param8Type, Default)	\
																				\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(				\
			Param1Type, Param2Type, Param3Type, Param4Type,						\
			Param5Type, Param6Type, Param7Type, Param8Type);					\
																				\
	Linkage RetType Modifiers FunctionName(Param1Type a,						\
			Param2Type b, Param3Type c, Param4Type d, Param5Type e,				\
			Param6Type f, Param7Type g, Param8Type h)							\
	{																			\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "									\
				"Entry point \"" #FunctionName "\" not found!");						\
																				\
			return Default;														\
		}																		\
		else																	\
		{																		\
			return OMIStub##FunctionName(a, b, c, d, e, f, g, h);				\
		}																		\
	}


#define DEFINE_STUB_FUNCTION_9(Simple, Linkage, RetType,					\
		Modifiers, FunctionName, Lookup, Param1Type, Param2Type,			\
		Param3Type, Param4Type, Param5Type, Param6Type,						\
		Param7Type, Param8Type, Param9Type, Default)						\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type,								\
			Param4Type, Param5Type, Param6Type,								\
			Param7Type, Param8Type, Param9Type);							\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a, Param2Type b,		\
			Param3Type c, Param4Type d, Param5Type e,						\
			Param6Type f, Param7Type g, Param8Type h, Param9Type i)			\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d, e, f, g, h, i);		\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_10(Simple, Linkage, RetType, Modifiers,		\
		FunctionName, Lookup, Param1Type, Param2Type, Param3Type,			\
		Param4Type, Param5Type, Param6Type, Param7Type,						\
		Param8Type, Param9Type, Param10Type, Default)						\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type,								\
			Param4Type, Param5Type, Param6Type,								\
			Param7Type, Param8Type, Param9Type, Param10Type);				\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a, Param2Type b,		\
			Param3Type c, Param4Type d, Param5Type e, Param6Type f,			\
			Param7Type g, Param8Type h, Param9Type i, Param10Type j)		\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d, e, f, g, h, i, j);		\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_11(Simple, Linkage, RetType, Modifiers,		\
		FunctionName, Lookup, Param1Type, Param2Type, Param3Type,			\
		Param4Type, Param5Type, Param6Type, Param7Type, Param8Type,			\
		Param9Type, Param10Type, Param11Type, Default)						\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type, Param4Type,					\
			Param5Type, Param6Type, Param7Type, Param8Type,					\
			Param9Type, Param10Type, Param11Type);							\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a,					\
			Param2Type b, Param3Type c, Param4Type d,						\
			Param5Type e, Param6Type f, Param7Type g,						\
			Param8Type h, Param9Type i, Param10Type j, Param11Type k)		\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #FunctionName);	\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #FunctionName "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d, e, f, g, h, i, j, k);	\
		}																	\
	}

#else // Intel

#define DEFINE_STUB_FUNCTION_V0(Simple, Linkage, Modifiers, FunctionName, Lookup)	\
																					\
	Linkage typedef void (Modifiers * FunctionName##FuncPtr)(void);					\
																					\
	Linkage void Modifiers FunctionName(void)										\
	{																				\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "										\
				"Entry point \"" #Lookup "\" not found!");							\
		}																			\
		else																		\
		{																			\
			OMIStub##FunctionName();												\
		}																			\
	}


#define DEFINE_STUB_FUNCTION_0(Simple, Linkage, RetType, Modifiers,			\
		FunctionName, Lookup, Default)										\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(void);		\
																			\
	Linkage RetType Modifiers FunctionName(void)							\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName();									\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_V1(Simple, Linkage, Modifiers,					\
		FunctionName, Lookup, Param1Type)									\
																			\
	Linkage typedef void (Modifiers * FunctionName##FuncPtr)(Param1Type);	\
																			\
	Linkage void Modifiers FunctionName(Param1Type a)						\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
		}																	\
		else																\
		{																	\
			OMIStub##FunctionName(a);										\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_1(Simple, Linkage, RetType,					\
		Modifiers, FunctionName, Lookup, Param1Type, Default)				\
																			\
	Linkage typedef RetType													\
			(Modifiers * FunctionName##FuncPtr)(Param1Type);				\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a)					\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a);								\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_V2(Simple, Linkage, Modifiers,					\
		FunctionName, Lookup, Param1Type, Param2Type)						\
																			\
	Linkage typedef void (Modifiers * FunctionName##FuncPtr)(				\
			Param1Type, Param2Type);										\
																			\
	Linkage void Modifiers FunctionName(Param1Type a, Param2Type b)			\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
		}																	\
		else																\
		{																	\
			OMIStub##FunctionName(a, b);									\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_2(Simple, Linkage, RetType, Modifiers,			\
		FunctionName, Lookup, Param1Type, Param2Type, Default)				\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type);										\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a, Param2Type b)		\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b);								\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_V3(Simple, Linkage, Modifiers,					\
		FunctionName, Lookup, Param1Type, Param2Type, Param3Type)			\
																			\
	Linkage typedef void (Modifiers * FunctionName##FuncPtr)(				\
			Param1Type, Param2Type, Param3Type);							\
																			\
	Linkage void Modifiers FunctionName(									\
			Param1Type a, Param2Type b, Param3Type c)						\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
		}																	\
		else																\
		{																	\
			OMIStub##FunctionName(a, b, c);									\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_3(Simple, Linkage, RetType, Modifiers,			\
		FunctionName, Lookup, Param1Type, Param2Type, Param3Type, Default)	\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type);							\
																			\
	Linkage RetType Modifiers FunctionName(									\
			Param1Type a, Param2Type b, Param3Type c)						\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c);							\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_4(Simple, Linkage,								\
		RetType, Modifiers, FunctionName, Lookup, Param1Type,				\
		Param2Type, Param3Type, Param4Type, Default)						\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type, Param4Type);				\
																			\
	Linkage RetType Modifiers FunctionName(									\
			Param1Type a, Param2Type b, Param3Type c, Param4Type d)			\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d);						\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_5(Simple, Linkage,								\
		RetType, Modifiers, FunctionName, Lookup,							\
		Param1Type, Param2Type, Param3Type,									\
		Param4Type, Param5Type, Default)									\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type, Param4Type, Param5Type);	\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a, Param2Type b,		\
			Param3Type c, Param4Type d, Param5Type e)						\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d, e);					\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_6(Simple, Linkage, RetType, Modifiers,			\
		FunctionName, Lookup, Param1Type, Param2Type,						\
		Param3Type, Param4Type, Param5Type, Param6Type, Default)			\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type,								\
			Param4Type, Param5Type, Param6Type);							\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a, Param2Type b,		\
			Param3Type c, Param4Type d, Param5Type e, Param6Type f)			\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d, e, f);					\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_V7(Simple, Linkage, Modifiers, FunctionName,	\
		Lookup, Param1Type, Param2Type, Param3Type, Param4Type,				\
		Param5Type, Param6Type, Param7Type)									\
																			\
	Linkage typedef void (Modifiers * FunctionName##FuncPtr)(				\
			Param1Type, Param2Type, Param3Type,								\
			Param4Type, Param5Type, Param6Type, Param7Type);				\
																			\
	Linkage void Modifiers FunctionName(Param1Type a,						\
			Param2Type b, Param3Type c, Param4Type d,						\
			Param5Type e, Param6Type f, Param7Type g)						\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
		}																	\
		else																\
		{																	\
			OMIStub##FunctionName(a, b, c, d, e, f, g);						\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_7(Simple, Linkage, RetType, Modifiers,			\
		FunctionName, Lookup, Param1Type, Param2Type, Param3Type,			\
		Param4Type, Param5Type, Param6Type, Param7Type, Default)			\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type, Param4Type,					\
			Param5Type, Param6Type, Param7Type);							\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a, Param2Type b,		\
			Param3Type c, Param4Type d, Param5Type e,						\
			Param6Type f, Param7Type g)										\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d, e, f, g);				\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_8(Simple, Linkage, RetType, Modifiers,				\
		FunctionName, Lookup, Param1Type, Param2Type, Param3Type,				\
		Param4Type, Param5Type, Param6Type, Param7Type, Param8Type, Default)	\
																				\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(				\
			Param1Type, Param2Type, Param3Type, Param4Type,						\
			Param5Type, Param6Type, Param7Type, Param8Type);					\
																				\
	Linkage RetType Modifiers FunctionName(Param1Type a,						\
			Param2Type b, Param3Type c, Param4Type d, Param5Type e,				\
			Param6Type f, Param7Type g, Param8Type h)							\
	{																			\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "									\
				"Entry point \"" #Lookup "\" not found!");						\
																				\
			return Default;														\
		}																		\
		else																	\
		{																		\
			return OMIStub##FunctionName(a, b, c, d, e, f, g, h);				\
		}																		\
	}


#define DEFINE_STUB_FUNCTION_9(Simple, Linkage, RetType,					\
		Modifiers, FunctionName, Lookup, Param1Type, Param2Type,			\
		Param3Type, Param4Type, Param5Type, Param6Type,						\
		Param7Type, Param8Type, Param9Type, Default)						\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type,								\
			Param4Type, Param5Type, Param6Type,								\
			Param7Type, Param8Type, Param9Type);							\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a, Param2Type b,		\
			Param3Type c, Param4Type d, Param5Type e,						\
			Param6Type f, Param7Type g, Param8Type h, Param9Type i)			\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d, e, f, g, h, i);		\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_10(Simple, Linkage, RetType, Modifiers,		\
		FunctionName, Lookup, Param1Type, Param2Type, Param3Type,			\
		Param4Type, Param5Type, Param6Type, Param7Type,						\
		Param8Type, Param9Type, Param10Type, Default)						\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type,								\
			Param4Type, Param5Type, Param6Type,								\
			Param7Type, Param8Type, Param9Type, Param10Type);				\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a, Param2Type b,		\
			Param3Type c, Param4Type d, Param5Type e, Param6Type f,			\
			Param7Type g, Param8Type h, Param9Type i, Param10Type j)		\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d, e, f, g, h, i, j);		\
		}																	\
	}


#define DEFINE_STUB_FUNCTION_11(Simple, Linkage, RetType, Modifiers,		\
		FunctionName, Lookup, Param1Type, Param2Type, Param3Type,			\
		Param4Type, Param5Type, Param6Type, Param7Type, Param8Type,			\
		Param9Type, Param10Type, Param11Type, Default)						\
																			\
	Linkage typedef RetType (Modifiers * FunctionName##FuncPtr)(			\
			Param1Type, Param2Type, Param3Type, Param4Type,					\
			Param5Type, Param6Type, Param7Type, Param8Type,					\
			Param9Type, Param10Type, Param11Type);							\
																			\
	Linkage RetType Modifiers FunctionName(Param1Type a,					\
			Param2Type b, Param3Type c, Param4Type d,						\
			Param5Type e, Param6Type f, Param7Type g,						\
			Param8Type h, Param9Type i, Param10Type j, Param11Type k)		\
	{																		\
		static FunctionName##FuncPtr OMIStub##FunctionName = NULL;					\
		static BOOL fGetProcAddress = FALSE;										\
																					\
TryAgain:																			\
																					\
		if (NULL == OMIStub##FunctionName)											\
		{																			\
			if (!fGetProcAddress)											\
			{																\
				EnterCriticalSection(&csGetProcAddress);					\
																			\
				OMIStub##FunctionName = (FunctionName##FuncPtr)				\
					::GetProcAddress(GetProxyDll(Simple), #Lookup);			\
				fGetProcAddress = TRUE;										\
																			\
				LeaveCriticalSection(&csGetProcAddress);					\
																			\
				goto TryAgain;												\
			}																\
																			\
			AssertSz(FALSE, "MAPI32 Stub:  "								\
				"Entry point \"" #Lookup "\" not found!");					\
																			\
			return Default;													\
		}																	\
		else																\
		{																	\
			return OMIStub##FunctionName(a, b, c, d, e, f, g, h, i, j, k);	\
		}																	\
	}


#endif





#if 1

LINKAGE_EXTERN_C typedef SCODE (STDMAPIINITCALLTYPE * ScSplEntryFuncPtr)(LPSPLDATA, LPVOID, ULONG, ULONG *);

LINKAGE_EXTERN_C SCODE STDMAPIINITCALLTYPE ScSplEntry(LPSPLDATA a, LPVOID b, ULONG c, ULONG * d)
{
	static ScSplEntryFuncPtr OMIStubScSplEntry = (ScSplEntryFuncPtr)
			::GetProcAddress(GetProxyDll(ExtendedMAPI), (LPCSTR) MAKEWORD(8, 0));

	if (NULL == OMIStubScSplEntry)
	{
		AssertSz(FALSE, "MAPI32 Stub:  "
			"Entry point \"ScSplEntry\" (ordinal #8) not found!");

		return MAPI_E_CALL_FAILED;
	}
	else
	{
		return OMIStubScSplEntry(a, b, c, d);
	}
}

#else

DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDMAPIINITCALLTYPE,
		ScSplEntry, ScSplEntry@16, LPSPLDATA, LPVOID, ULONG, ULONG *, MAPI_E_CALL_FAILED)

#endif


DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDMETHODCALLTYPE,
		HrGetOmiProvidersFlags, HrGetOmiProvidersFlags@8,
		LPMAPISESSION, ULONG *, MAPI_E_CALL_FAILED)


DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDMETHODCALLTYPE,
		HrSetOmiProvidersFlagsInvalid, HrSetOmiProvidersFlagsInvalid@4,
		LPMAPISESSION, MAPI_E_CALL_FAILED)


DEFINE_STUB_FUNCTION_5(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDMETHODCALLTYPE,
		MAPILogonEx, MAPILogonEx@20,
		ULONG_PTR, LPTSTR, LPTSTR, ULONG, LPMAPISESSION FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDMETHODCALLTYPE,
		MAPIAllocateBuffer, MAPIAllocateBuffer@8,
		ULONG, LPVOID FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDMETHODCALLTYPE,
		MAPIAllocateMore, MAPIAllocateMore@12,
		ULONG, LPVOID, LPVOID FAR *, (SCODE) MAPI_E_CALL_FAILED)


DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDMETHODCALLTYPE,
		MAPIAdminProfiles, MAPIAdminProfiles@8,
		ULONG, LPPROFADMIN FAR *, MAPI_E_CALL_FAILED)

// The LPVOID argument points to a MAPIINIT_0 struct ()declared in mapix.h)
// None of the members of the struct need thunking. The HANDLE member
// (hProfile) of the struct is NULL or the handle of a registry key; this is
// passed on to PrProviderInit as the last argument (see comments below just
// before PrProviderInit's defn) by ScInitMapiX which is called by
// MapiInitialize
//
// MapiInitialize also casts the LPVOID as an LPSPLINIT in certain cases;
// LPSPLINIT is declared in _spooler.h (a private header) and has MAPIINIT_0
// as its first member and a byt pointer as its only other member. So no
// issues here either.
//
// Aside: The call made to PrProviderInit from ScInitMapiX. If the mapi dll
// is the profile provider ScInitMapiX does the following:
//
//      hinstProfile = GetModuleHandle(szMAPIXDLL);
//      pfnInitProfile = PRProviderInit;
//      (*pfnInitProfile)(hinstProfile, ...);
//
// szMapiXDll is set to "MSMAPI32" if MSMAPI is defined, else to "MAPI32".
// MSMAPI is defined for builds in mapi\src\msmapi and is undefined for
// builds in mapi\src\mapi.
//
// If szMapiXDll is set to MSMAPI32, there are no issues. If it is set to
// "MAPI32" (which may be the case for older versions of the dll), there
// are potential problems because the PrProviderInit fn in the msmapi dll
// will be called directly but given the dll handle of the mapi32 (stub) dll
// and our thunk will not be called. As noted along with the comments for
// PrProviderInit, this could cause problems with the hook fns.
//

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		MAPIInitialize, MAPIInitialize@4,
		LPVOID, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_V0(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		MAPIUninitialize, MAPIUninitialize@0)

DEFINE_STUB_FUNCTION_9(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDMAPIINITCALLTYPE,
		PRProviderInit, PRProviderInit,
		HINSTANCE, LPMALLOC, LPALLOCATEBUFFER, LPALLOCATEMORE,
		LPFREEBUFFER, ULONG, ULONG, ULONG FAR *, LPPRPROVIDER FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_5(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		LaunchWizard, LaunchWizard@20,
		HWND, ULONG, LPCTSTR FAR *, ULONG, LPTSTR, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, PASCAL,
		DllGetClassObject, DllGetClassObject, REFCLSID, REFIID, LPVOID FAR *, E_UNEXPECTED)

DEFINE_STUB_FUNCTION_0(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, PASCAL,
		DllCanUnloadNow, DllCanUnloadNow, S_FALSE)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		MAPIOpenFormMgr, MAPIOpenFormMgr@8,
		LPMAPISESSION, LPMAPIFORMMGR FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		MAPIOpenLocalFormContainer, MAPIOpenLocalFormContainer@4,
		LPMAPIFORMCONTAINER FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE,
		STDAPICALLTYPE, ScInitMapiUtil, ScInitMapiUtil@4, ULONG, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_V0(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE, DeinitMapiUtil, DeinitMapiUtil@0)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE,
		STDAPICALLTYPE, ScGenerateMuid, ScGenerateMuid@4, LPMAPIUID, MAPI_E_CALL_FAILED)

// LPVOID arg is passed back to the callback function
DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrAllocAdviseSink, HrAllocAdviseSink@12, LPNOTIFCALLBACK, LPVOID,
		LPMAPIADVISESINK FAR *, MAPI_E_CALL_FAILED)

// ScAddAdviseList is NOT exported; see mapi.des
// Note that the LPUNKNOWN argument must be thunked but as what?
// For example, its Unadvise() and UlRelease() methods are called
// in IAB_Unadvise() (src\mapi\iadrbook.c). UlRelease()
// is implemented in src\common\runt.c. ScAddAdviseList is in
// src\common\advise.c.
//
// Just as well this function is not exported!
//
DEFINE_STUB_FUNCTION_6(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		ScAddAdviseList, ScAddAdviseList@24, LPVOID, LPADVISELIST FAR *,
		LPMAPIADVISESINK, ULONG, ULONG, LPUNKNOWN, MAPI_E_CALL_FAILED)

// ScDelAdviseList is NOT exported; see mapi.des
DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		ScDelAdviseList, ScDelAdviseList@8, LPADVISELIST, ULONG, MAPI_E_CALL_FAILED)

// ScFindAdviseList is NOT exported; see mapi.des
DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		ScFindAdviseList, ScFindAdviseList@12, LPADVISELIST, ULONG, LPADVISEITEM FAR *, MAPI_E_CALL_FAILED)

// DestroyAdviseList is NOT exported; see mapi.des
DEFINE_STUB_FUNCTION_V1(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		DestroyAdviseList, DestroyAdviseList@4, LPADVISELIST FAR *)

// This function merely returns MAPI_E_NO_SUPPORT and does not set the
//  LPMAPIPROGRESS FAR * argument to NULL. It is better not to thunk
// its arguments. See (src\common\advise.c for its implementation)
DEFINE_STUB_FUNCTION_5(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT,
		STDAPICALLTYPE, WrapProgress, WrapProgress@20, LPMAPIPROGRESS,
		ULONG, ULONG, ULONG, LPMAPIPROGRESS FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT,
		STDAPICALLTYPE, HrThisThreadAdviseSink, HrThisThreadAdviseSink@8,
		LPMAPIADVISESINK, LPMAPIADVISESINK FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrDispatchNotifications, HrDispatchNotifications@4, ULONG, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		ScBinFromHexBounded, ScBinFromHexBounded@12,
		LPTSTR, LPBYTE, ULONG, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL,
		STDAPICALLTYPE, FBinFromHex, FBinFromHex@8, LPTSTR, LPBYTE, FALSE)

DEFINE_STUB_FUNCTION_V3(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		HexFromBin, HexFromBin@12, LPBYTE, int, LPTSTR)

DEFINE_STUB_FUNCTION_10(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		BuildDisplayTable, BuildDisplayTable@40,
		LPALLOCATEBUFFER, LPALLOCATEMORE, LPFREEBUFFER, LPMALLOC,
		HINSTANCE, UINT, LPDTPAGE, ULONG, LPMAPITABLE *, LPTABLEDATA *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_V2(ExtendedMAPI, LINKAGE_EXTERN_C, PASCAL, SwapPlong, SwapPlong@8, void *, int)

DEFINE_STUB_FUNCTION_V2(ExtendedMAPI, LINKAGE_EXTERN_C, PASCAL, SwapPword, SwapPword@8, void *, int)

// LPVOID arg should be 0, but is ignored anyway
DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT,
		STDAPICALLTYPE, MAPIInitIdle, MAPIInitIdle@4, LPVOID, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_V0(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE, MAPIDeinitIdle, MAPIDeinitIdle@0)

DEFINE_STUB_FUNCTION_V1(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		InstallFilterHook, InstallFilterHook@4, BOOL)

// LPVOID arg is passed as argument to callback function
DEFINE_STUB_FUNCTION_5(ExtendedMAPI, LINKAGE_EXTERN_C, FTG, STDAPICALLTYPE,
		FtgRegisterIdleRoutine, FtgRegisterIdleRoutine@20,
		PFNIDLE, LPVOID, short, ULONG, USHORT, NULL)

DEFINE_STUB_FUNCTION_V2(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		EnableIdleRoutine, EnableIdleRoutine@8, FTG, BOOL)

DEFINE_STUB_FUNCTION_V1(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		DeregisterIdleRoutine, DeregisterIdleRoutine@4, FTG)

// LPVOID arg is passed as argument to callback function
DEFINE_STUB_FUNCTION_V7(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		ChangeIdleRoutine, ChangeIdleRoutine@28,
		FTG, PFNIDLE, LPVOID, short, ULONG, USHORT, USHORT)

// FDoNextIdleTask is NOT exported; see mapi.des
DEFINE_STUB_FUNCTION_0(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL,
		STDAPICALLTYPE, FDoNextIdleTask, FDoNextIdleTask@0, FALSE)

DEFINE_STUB_FUNCTION_0(ExtendedMAPI, LINKAGE_EXTERN_C, LPMALLOC,
		STDAPICALLTYPE, MAPIGetDefaultMalloc, MAPIGetDefaultMalloc@0, NULL)

DEFINE_STUB_FUNCTION_6(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		CreateIProp, CreateIProp@24,
		LPCIID, ALLOCATEBUFFER FAR *, ALLOCATEMORE FAR *,
		FREEBUFFER FAR *, LPVOID, LPPROPDATA FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_9(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		CreateTable, CreateTable@36,
		LPCIID, ALLOCATEBUFFER FAR *, ALLOCATEMORE FAR *,
		FREEBUFFER FAR *, LPVOID, ULONG, ULONG,
		LPSPropTagArray, LPTABLEDATA FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, int, WINAPI,
		MNLS_lstrlenW, MNLS_lstrlenW@4, LPCWSTR, 0)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, int, WINAPI,
		MNLS_lstrcmpW, MNLS_lstrcmpW@8, LPCWSTR, LPCWSTR, 0)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, LPWSTR,
		WINAPI, MNLS_lstrcpyW, MNLS_lstrcpyW@8, LPWSTR, LPCWSTR, NULL)

DEFINE_STUB_FUNCTION_6(ExtendedMAPI, LINKAGE_EXTERN_C, int, WINAPI,
		MNLS_CompareStringW, MNLS_CompareStringW@24,
		LCID, DWORD, LPCWSTR, int, LPCWSTR, int, 0)

DEFINE_STUB_FUNCTION_6(ExtendedMAPI, LINKAGE_EXTERN_C, int, WINAPI,
		MNLS_MultiByteToWideChar, MNLS_MultiByteToWideChar@24,
		UINT, DWORD, LPCSTR, int, LPWSTR, int, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_8(ExtendedMAPI, LINKAGE_EXTERN_C, int, WINAPI,
		MNLS_WideCharToMultiByte, MNLS_WideCharToMultiByte@32,
		UINT, DWORD, LPCWSTR, int, LPSTR, int, LPCSTR, BOOL FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL,
		WINAPI, MNLS_IsBadStringPtrW, MNLS_IsBadStringPtrW@8, LPCWSTR, UINT, TRUE)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL, STDAPICALLTYPE,
		FEqualNames, FEqualNames@8, LPMAPINAMEID, LPMAPINAMEID, FALSE)

DEFINE_STUB_FUNCTION_6(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		WrapStoreEntryID, WrapStoreEntryID@24,
		ULONG, LPTSTR, ULONG, LPENTRYID, ULONG *, LPENTRYID *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL, WINAPI,
		IsBadBoundedStringPtr, IsBadBoundedStringPtr@8,
		const void FAR *, UINT, FALSE)

DEFINE_STUB_FUNCTION_6(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrQueryAllRows, HrQueryAllRows@24, LPMAPITABLE, LPSPropTagArray,
		LPSRestriction, LPSSortOrderSet, LONG, LPSRowSet FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		ScCreateConversationIndex, ScCreateConversationIndex@16, ULONG, LPBYTE,
		ULONG FAR *, LPBYTE FAR *, MAPI_E_CALL_FAILED)

// The LPVOID arg is reallocated with the ALLOCATEMORE* arg, it is treated
// as a PVOID
DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		PropCopyMore, PropCopyMore@16,
		LPSPropValue, LPSPropValue, ALLOCATEMORE *, LPVOID, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG,
		STDAPICALLTYPE, UlPropSize, UlPropSize@4, LPSPropValue, 0)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL, STDAPICALLTYPE,
		FPropContainsProp, FPropContainsProp@12, LPSPropValue, LPSPropValue, ULONG, FALSE)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL, STDAPICALLTYPE,
		FPropCompareProp, FPropCompareProp@12, LPSPropValue, ULONG, LPSPropValue, FALSE)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, LONG, STDAPICALLTYPE,
		LPropCompareProp, LPropCompareProp@8, LPSPropValue, LPSPropValue, 0)

DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrAddColumns, HrAddColumns@16,
		LPMAPITABLE, LPSPropTagArray, LPALLOCATEBUFFER, LPFREEBUFFER, MAPI_E_CALL_FAILED)

typedef void (FAR * HrAddColumnsEx5ParamType)(LPSPropTagArray);

DEFINE_STUB_FUNCTION_5(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrAddColumnsEx, HrAddColumnsEx@20, LPMAPITABLE, LPSPropTagArray,
		LPALLOCATEBUFFER, LPFREEBUFFER, HrAddColumnsEx5ParamType, MAPI_E_CALL_FAILED)

const FILETIME ZERO_FILETIME = { 0, 0 };

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, FILETIME,
		STDAPICALLTYPE, FtMulDwDw, FtMulDwDw@8, DWORD, DWORD, ZERO_FILETIME)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, FILETIME,
		STDAPICALLTYPE, FtAddFt, FtAddFt@16, FILETIME, FILETIME, ZERO_FILETIME)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, FILETIME, STDAPICALLTYPE,
		FtAdcFt, FtAdcFt@20, FILETIME, FILETIME, WORD FAR *, ZERO_FILETIME)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, FILETIME,
		STDAPICALLTYPE, FtSubFt, FtSubFt@16, FILETIME, FILETIME, ZERO_FILETIME)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, FILETIME,
		STDAPICALLTYPE, FtMulDw, FtMulDw@12, DWORD, FILETIME, ZERO_FILETIME)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, FILETIME,
		STDAPICALLTYPE, FtNegFt, FtNegFt@8, FILETIME, ZERO_FILETIME)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, FILETIME, STDAPICALLTYPE,
		FtDivFtBogus, FtDivFtBogus@20, FILETIME, FILETIME, CHAR, ZERO_FILETIME)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG,
		STDAPICALLTYPE, UlAddRef, UlAddRef@4, LPVOID, 1)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG,
		STDAPICALLTYPE, UlRelease, UlRelease@4, LPVOID, 1)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, LPTSTR,
		STDAPICALLTYPE, SzFindCh, SzFindCh@8, LPCTSTR, USHORT, NULL)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, LPTSTR,
		STDAPICALLTYPE, SzFindLastCh, SzFindLastCh@8, LPCTSTR, USHORT, NULL)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, LPTSTR,
		STDAPICALLTYPE, SzFindSz, SzFindSz@8, LPCTSTR, LPCTSTR, NULL)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, unsigned int,
		STDAPICALLTYPE, UFromSz, UFromSz@4, LPCTSTR, 0)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrGetOneProp, HrGetOneProp@12,
		LPMAPIPROP, ULONG, LPSPropValue FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrSetOneProp, HrSetOneProp@8, LPMAPIPROP, LPSPropValue, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL,
		STDAPICALLTYPE, FPropExists, FPropExists@8, LPMAPIPROP, ULONG, FALSE)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, LPSPropValue, STDAPICALLTYPE,
		PpropFindProp, PpropFindProp@12, LPSPropValue, ULONG, ULONG, NULL)

DEFINE_STUB_FUNCTION_V1(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		FreePadrlist, FreePadrlist@4, LPADRLIST)

DEFINE_STUB_FUNCTION_V1(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		FreeProws, FreeProws@4, LPSRowSet)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrSzFromEntryID, HrSzFromEntryID@12, ULONG, LPENTRYID, LPTSTR FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrEntryIDFromSz, HrEntryIDFromSz@12,
		LPTSTR, ULONG FAR *, LPENTRYID FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_7(ExtendedMAPI, LINKAGE_NO_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrComposeEID, HrComposeEID@28, LPMAPISESSION, ULONG, LPBYTE,
		ULONG, LPENTRYID, ULONG FAR *, LPENTRYID FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_7(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrDecomposeEID, HrDecomposeEID@28, LPMAPISESSION, ULONG, LPENTRYID,
		ULONG FAR *, LPENTRYID FAR *, ULONG FAR *, LPENTRYID FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_6(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrComposeMsgID, HrComposeMsgID@24,
		LPMAPISESSION, ULONG, LPBYTE, ULONG, LPENTRYID, LPTSTR FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_6(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrDecomposeMsgID, HrDecomposeMsgID@24, LPMAPISESSION, LPTSTR,
		ULONG FAR *, LPENTRYID FAR *, ULONG FAR *, LPENTRYID FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_6(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT,
		STDMETHODCALLTYPE, OpenStreamOnFile, OpenStreamOnFile@24,
		LPALLOCATEBUFFER, LPFREEBUFFER, ULONG,
		LPTSTR, LPTSTR, LPSTREAM FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_7(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT,
		STDMETHODCALLTYPE, OpenTnefStream, OpenTnefStream@28, LPVOID, LPSTREAM,
		LPTSTR, ULONG, LPMESSAGE, WORD, LPITNEF FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_8(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDMETHODCALLTYPE,
		OpenTnefStreamEx, OpenTnefStreamEx@32, LPVOID, LPSTREAM, LPTSTR,
		ULONG, LPMESSAGE, WORD, LPADRBOOK, LPITNEF FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDMETHODCALLTYPE,
		GetTnefStreamCodepage, GetTnefStreamCodepage@12,
		LPSTREAM, ULONG FAR *, ULONG FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG,
		STDAPICALLTYPE, UlFromSzHex, UlFromSzHex@4, LPCTSTR, 0)

// The following UNKOBJ_* fns are not documented in the Jul 98 MSDN.
// LPUNKOBJ itself is declared in src\inc\unkobj.h (a private header file)
// These (and other) methods of UNKOBJ are in src\common\unkobj.c
//
// It appears that some MAPI interfaces are "derived" from UNKOBJ;
// for example, see CreateIProp() in src\mapi\iprop.c and CreateTable() in
// mapi\src\itable.c. The UNKOBJ_ScCO* functions do not use any methods of
// the LPUNKOBJ argument; the others use the Allocate, AllocateMore and Free
// functions that were sent in as arguments to CreateIProp() and CreateTable()
// (These function pointers are already thunked.)
//
// UNKOBJ_ScSzFromIdsAlloc loads a string resource from the mapi dll,
// allocating a buffer for the string
//
// All the functions below use data members in the UNKOBJ structure and so
// we cannot send a proxy in for the LPUNKOBJ argument. But we can't thunk
// it either because we do not know its IID.
//
// As a workaround, we call ResolveProxy. If the argument is a proxy,
// ResolveProxy will find the real interface pointer. If not, the argument
// must be a cross architecture interface pointer, i.e., the interface
// pointer must be the same architecture as the app (or else the app would
// have a proxy pointer) and the mapi dll must be of the opposite architecture
// (because we thunk only cross architecture calls). So we just fail the
// call in the thunk. (Note: the argument could also be an unthunked
// interface pointer of the same architecture as the mapi dll - and some
// other API failed to thunk the pointer when it was returned to the app.
// Hopefully, bugs of that nature will be caught during internal testing.)


DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		UNKOBJ_ScAllocate, UNKOBJ_ScAllocate@12,
		LPUNKOBJ, ULONG, LPVOID FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		UNKOBJ_ScAllocateMore, UNKOBJ_ScAllocateMore@16,
		LPUNKOBJ, ULONG, LPVOID, LPVOID FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_V2(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		UNKOBJ_Free, UNKOBJ_Free@8, LPUNKOBJ, LPVOID)

DEFINE_STUB_FUNCTION_V2(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		UNKOBJ_FreeRows, UNKOBJ_FreeRows@8, LPUNKOBJ, LPSRowSet)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		UNKOBJ_ScCOAllocate, UNKOBJ_ScCOAllocate@12,
		LPUNKOBJ, ULONG, LPVOID FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		UNKOBJ_ScCOReallocate, UNKOBJ_ScCOReallocate@12,
		LPUNKOBJ, ULONG, LPVOID FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_V2(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		UNKOBJ_COFree, UNKOBJ_COFree@8, LPUNKOBJ, LPVOID)

DEFINE_STUB_FUNCTION_5(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE,
		STDAPICALLTYPE, UNKOBJ_ScSzFromIdsAlloc, UNKOBJ_ScSzFromIdsAlloc@20,
		LPUNKOBJ, IDS, ULONG, int, LPTSTR FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		ScCountNotifications, ScCountNotifications@12,
		int, LPNOTIFICATION, ULONG FAR *, MAPI_E_CALL_FAILED)

// LPVOID arg ok; is a pointer to a NOTIFICATION struct which is filled in
// by the fn
DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		ScCopyNotifications, ScCopyNotifications@16,
		int, LPNOTIFICATION, LPVOID, ULONG FAR *, MAPI_E_CALL_FAILED)

// LPVOID args ok, pointers to NOTIFICAATION structs
DEFINE_STUB_FUNCTION_5(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE,
		STDAPICALLTYPE, ScRelocNotifications, ScRelocNotifications@20, int,
		LPNOTIFICATION, LPVOID, LPVOID, ULONG FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		ScCountProps, ScCountProps@12,
		int, LPSPropValue, ULONG FAR *, MAPI_E_CALL_FAILED)

// LPVOID arg ok; is a pointer to a SPropValue struct which is filled in
// by the fn
DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		ScCopyProps, ScCopyProps@16,
		int, LPSPropValue, LPVOID, ULONG FAR *, MAPI_E_CALL_FAILED)

// LPVOID args ok, pointers to SPropValue structs
DEFINE_STUB_FUNCTION_5(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		ScRelocProps, ScRelocProps@20,
		int, LPSPropValue, LPVOID, LPVOID, ULONG FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, LPSPropValue, STDAPICALLTYPE,
		LpValFindProp, LpValFindProp@12, ULONG, ULONG, LPSPropValue, NULL)

DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		ScDupPropset, ScDupPropset@16,
		int, LPSPropValue, LPALLOCATEBUFFER, LPSPropValue FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL,
		STDAPICALLTYPE, FBadRglpszA, FBadRglpszA@8, LPSTR FAR *, ULONG, TRUE)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL,
		STDAPICALLTYPE, FBadRglpszW, FBadRglpszW@8, LPWSTR FAR *, ULONG, TRUE)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL,
		STDAPICALLTYPE, FBadRowSet, FBadRowSet@4, LPSRowSet, TRUE)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL, STDAPICALLTYPE,
		FBadRglpNameID, FBadRglpNameID@8, LPMAPINAMEID FAR *, ULONG, TRUE)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG,
		STDAPICALLTYPE, FBadPropTag, FBadPropTag@4, ULONG, TRUE)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG,
		STDAPICALLTYPE, FBadRow, FBadRow@4, LPSRow, TRUE)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG,
		STDAPICALLTYPE, FBadProp, FBadProp@4, LPSPropValue, TRUE)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG,
		STDAPICALLTYPE, FBadColumnSet, FBadColumnSet@4, LPSPropTagArray, TRUE)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		RTFSync, RTFSync@12, LPMESSAGE, ULONG, BOOL FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		WrapCompressedRTFStream, WrapCompressedRTFStream@12,
		LPSTREAM, ULONG, LPSTREAM FAR *, MAPI_E_CALL_FAILED)

#if defined(_X86_) || defined( WIN16 )

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		__ValidateParameters, __ValidateParameters@8,
		METHODS, void *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		__CPPValidateParameters, __CPPValidateParameters@8,
		METHODS, const LPVOID, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		HrValidateParameters, HrValidateParameters@8,
		METHODS, LPVOID FAR *, MAPI_E_CALL_FAILED)

#else

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		__ValidateParameters, __ValidateParameters@8,
		METHODS, void *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT, STDAPICALLTYPE,
		__CPPValidateParameters, __CPPValidateParameters@8,
		METHODS, const LPVOID, MAPI_E_CALL_FAILED)

// STDAPIV HrValidateParametersValist( METHODS eMethod, va_list arglist )
DEFINE_STUB_FUNCTION_2(ExtendedMAPI, LINKAGE_EXTERN_C,
		HRESULT, STDAPIVCALLTYPE, HrValidateParametersValist,
		HrValidateParametersValist, METHODS, va_list, MAPI_E_CALL_FAILED)

// STDAPIV HrValidateParametersV( METHODS eMethod, ... )

LINKAGE_EXTERN_C HRESULT STDAPIVCALLTYPE HrValidateParametersV(METHODS eMethod, ...)
{
	va_list arg;

	va_start(arg, eMethod);

	HRESULT hr = HrValidateParametersValist(eMethod, arg);

	va_end(arg);

	return hr;
}

#endif // if defined(_X86_) || defined( WIN16 )

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG,
		STDAPICALLTYPE, FBadSortOrderSet, FBadSortOrderSet@4, LPSSortOrderSet, TRUE)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL,
		STDAPICALLTYPE, FBadEntryList, FBadEntryList@4, LPENTRYLIST, TRUE)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG,
		STDAPICALLTYPE, FBadRestriction, FBadRestriction@4, LPSRestriction, TRUE)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		ScUNCFromLocalPath, ScUNCFromLocalPath@12, LPSTR, LPSTR, UINT, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		ScLocalPathFromUNC, ScLocalPathFromUNC@12, LPSTR, LPSTR, UINT, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT,
		STDAPICALLTYPE, HrIStorageFromStream, HrIStorageFromStream@16,
		LPUNKNOWN, LPCIID, ULONG, LPSTORAGE FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_5(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT,
		STDAPICALLTYPE, HrValidateIPMSubtree, HrValidateIPMSubtree@20, LPMDB, ULONG,
		ULONG FAR *, LPSPropValue FAR *, LPMAPIERROR FAR *, MAPI_E_CALL_FAILED)

// Note on OpenIMsgSession(), CloseIMsgSession(), and OpenIMsgOnIStg()
// These three functions use LPMSGSESS. LPMSGSESS is typedef'd as
//    typedef struct _MSGSESS         FAR * LPMSGSESS;
// in imessage.h (a public header file), but struct _MSGSESS is declared
// only in a private header file, mapi\src\_imsg.h. LPMSGSESS is an
// interface pointer (see _imsg.h), but it appears to be opaque to clients
// of mapi32.dll. So we do not thunk it. Furthermore, although it is declared
// as an interface, it does not support IUnknown methods, see src\mapi\msgbase.c
// for the declaration of MS_Vtbl, which sets the fn pointers for QI,
// AddRef, etc to NULL.
//
// Note: we do not thunk the LPMSGSESS argument

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE, STDAPICALLTYPE,
		OpenIMsgSession, OpenIMsgSession@12,
		LPMALLOC, ULONG, LPMSGSESS FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_V1(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		CloseIMsgSession, CloseIMsgSession@4, LPMSGSESS)

DEFINE_STUB_FUNCTION_11(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE,
		STDAPICALLTYPE, OpenIMsgOnIStg, OpenIMsgOnIStg@44, LPMSGSESS, LPALLOCATEBUFFER,
		LPALLOCATEMORE, LPFREEBUFFER, LPMALLOC, LPVOID, LPSTORAGE,
		MSGCALLRELEASE FAR *, ULONG, ULONG, LPMESSAGE FAR *, MAPI_E_CALL_FAILED)

// Note on SetAttribIMsgOnIStg() and GetAttribIMsgOnIStg(). The first argument
// (LPVOID) is cast in these fns (see src\mapi\msgprop2.c) to PPROPOBJ which
// appears to be a private interface (declared in src\mapi\_imsg.h). The
// following are some ways the app gets one of these pointers - there may be
// others.
//
// src\mapi\msgbase.c creates these objects in PROPOBJ_Create; depending on
// an input argument, the object is one of an attachment, a recipient or a
// message. PROPOBJ_Create is called (indirectly, via ScOpenSubObject()) from
// IMessage::OpenAttach (Msg_OpenAttach() in msgmsg.c) which returns the
// PROPOBJ_Create'd object via its last argument - an LPATTACH *.
//
// PROPOBJ_Create is also called (again, indirectly, via ScOpenSubObject())
// from PROPOBJ_OpenProperty() (which is the implementation of
// IMAPIProp::OpenProperty and is in msgprop2.c) and the value it returns
// is returned to the caller as an IUnknown*. (PROPOBJ_Create is called only
// when ulPropTag is PT_OBJECT and the iid is IID_IMessage.)
//
// The issue is that these fns use data members in these objects (no methods
// though) and we should not pass in proxies. We have 3 alternatives:
//
//      - the app passes in proxies - we can get by with calling ResolveProxy
//        (Mapi creates the object and the app got it via an API that
//        thunked it.)
//
//      - the app passes in an unthunked pointer that it regards as opaque.
//        (which is possible because these interfaces are private) or an
//        unthunked poitner that it got from an API call that we've not
//        thunked (i.e., our bug). In this case we should pass the pointer
//        without any thunking.
//
//      - the app creates an interface and passes a pointer to it. This is
//        unlikely to work because these functions use data in the objects
//        that the app can't know about. (For this case, we have to thunk
//        the interface pointer and pass the proxy to mapi.)
//
// The Jul 98 MSDN's description of the arguments does not help in figuring
// out which of these cases are reasonable.
//
// We use the ResolveProxy workaround used for the UNKOBJ* fns above.
// Note: This ignores the second and third cases as possibilities.
//
// The other args to these fns do not require any thunking.

DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT,
		STDAPICALLTYPE, SetAttribIMsgOnIStg, SetAttribIMsgOnIStg@16, LPVOID, LPSPropTagArray,
		LPSPropAttrArray, LPSPropProblemArray FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, HRESULT,
		STDAPICALLTYPE, GetAttribIMsgOnIStg, GetAttribIMsgOnIStg@12, LPVOID,
		LPSPropTagArray, LPSPropAttrArray FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE,
		STDAPICALLTYPE, MapStorageSCode, MapStorageSCode@4, SCODE, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_V3(ExtendedMAPI, LINKAGE_EXTERN_C, STDAPICALLTYPE,
		EncodeID, EncodeID@12, LPBYTE, ULONG, LPTSTR)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, BOOL, STDAPICALLTYPE,
		FDecodeID, FDecodeID@12, LPTSTR, LPBYTE, ULONG FAR *, MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG,
		STDAPICALLTYPE, CchOfEncoding, CchOfEncoding@4, ULONG, 0)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG,
		STDAPICALLTYPE, CbOfEncoded, CbOfEncoded@4, LPTSTR, 0)



#if 1

LINKAGE_EXTERN_C typedef SCODE (STDMETHODCALLTYPE * ScMAPIXFromSMAPIFuncPtr)(
			LHANDLE, ULONG, LPCIID, LPMAPISESSION FAR *);

LINKAGE_EXTERN_C SCODE STDMETHODCALLTYPE ScMAPIXFromSMAPI(
		LHANDLE a, ULONG b, LPCIID c, LPMAPISESSION FAR * d)
{
	if (hmodSimpleMAPI != NULL && GetProxyDll(ExtendedMAPI) == hmodSimpleMAPI)
	{
		static ScMAPIXFromSMAPIFuncPtr OMIStubScMAPIXFromSMAPI =
				(ScMAPIXFromSMAPIFuncPtr) ::GetProcAddress(
					hmodExtendedMAPI, "ScMAPIXFromSMAPI");

		if (NULL == OMIStubScMAPIXFromSMAPI)
		{
			AssertSz(FALSE, "MAPI32 Stub:  "
				"Entry point \"ScMAPIXFromSMAPI\" not found!");

			return MAPI_E_CALL_FAILED;
		}
		else
		{
			return OMIStubScMAPIXFromSMAPI(a, b, c, d);
		}
	}
	else
	{
		AssertSz(FALSE, "MAPI32 Stub:  "
			"Can't get entry point \"ScMAPIXFromSMAPI\" when SimpleMAPI != ExtendedMAPI");

		return MAPI_E_CALL_FAILED;
	}
}

DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE,
		STDMETHODCALLTYPE, ScMAPIXFromCMC, ScMAPIXFromCMC, LHANDLE,
		ULONG, LPCIID, LPMAPISESSION FAR *, MAPI_E_CALL_FAILED)

#else

DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, SCODE,
		STDMETHODCALLTYPE, ScMAPIXFromSMAPI, ScMAPIXFromSMAPI, LHANDLE,
		ULONG, LPCIID, LPMAPISESSION FAR *, MAPI_E_CALL_FAILED)

#endif



// The BMAPI functions are generally wrappers for Simple MAPI functions.
// The LPVB_* arguments are for recipients, files and messages, and
// are generally analogs of Simple MAPI structs w/ strings replaced by BSTR.
// The LPSAFEARRAYs are generally arrays of the file, recipients, etc, structs.
// The LHANDLE argument is a Simple MAPI session handle.
// See src\mapi\_vbmapi.h for typedefs and bmapi.c, vb2c.c for function
// implementations.
//
// So for WX86 none of the arguments of these functions needs to be thunked

DEFINE_STUB_FUNCTION_7(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		BMAPISendMail, BMAPISendMail, LHANDLE, ULONG, LPVB_MESSAGE,
		LPSAFEARRAY *, LPSAFEARRAY *, ULONG, ULONG, (ULONG) MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_8(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		BMAPISaveMail, BMAPISaveMail, LHANDLE, ULONG, LPVB_MESSAGE,
		LPSAFEARRAY *, LPSAFEARRAY *, ULONG, ULONG, BSTR *, (ULONG) MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_8(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		BMAPIReadMail, BMAPIReadMail,
		LPULONG, LPULONG, LPULONG, LHANDLE, ULONG, BSTR *, ULONG, ULONG, (ULONG) MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_5(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		BMAPIGetReadMail, BMAPIGetReadMail,
		ULONG, LPVB_MESSAGE, LPSAFEARRAY *, LPSAFEARRAY *, LPVB_RECIPIENT, (ULONG) MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_7(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		BMAPIFindNext, BMAPIFindNext,
		LHANDLE, ULONG, BSTR *, BSTR *, ULONG, ULONG, BSTR *, (ULONG) MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_10(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		BMAPIAddress, BMAPIAddress,
		LPULONG, LHANDLE, ULONG, BSTR *, ULONG, BSTR *,
		LPULONG, LPSAFEARRAY *, ULONG, ULONG, (ULONG) MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_3(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		BMAPIGetAddress, BMAPIGetAddress, ULONG, ULONG, LPSAFEARRAY *, (ULONG) MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_5(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL, BMAPIDetails, BMAPIDetails,
		LHANDLE, ULONG, LPVB_RECIPIENT, ULONG, ULONG, (ULONG) MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_6(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		BMAPIResolveName, BMAPIResolveName,
		LHANDLE, ULONG, BSTR, ULONG, ULONG, LPVB_RECIPIENT, (ULONG) MAPI_E_CALL_FAILED)

// The cmc_* types are all composed of simple scalar types, ses xcmc.h

DEFINE_STUB_FUNCTION_6(ExtendedMAPI, LINKAGE_EXTERN_C, CMC_return_code, FAR PASCAL,
		cmc_act_on, cmc_act_on, CMC_session_id, CMC_message_reference FAR *,
		CMC_enum, CMC_flags, CMC_ui_id, CMC_extension FAR *, CMC_E_FAILURE)

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, CMC_return_code,
		FAR PASCAL, cmc_free, cmc_free, CMC_buffer, CMC_E_FAILURE)

DEFINE_STUB_FUNCTION_8(ExtendedMAPI, LINKAGE_EXTERN_C, CMC_return_code, FAR PASCAL,
		cmc_list, cmc_list, CMC_session_id, CMC_string, CMC_flags,
		CMC_message_reference FAR *, CMC_uint32 FAR *, CMC_ui_id,
		CMC_message_summary FAR * FAR *, CMC_extension FAR *, CMC_E_FAILURE)

DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, CMC_return_code, FAR PASCAL,
		cmc_logoff, cmc_logoff,
		CMC_session_id, CMC_ui_id, CMC_flags, CMC_extension FAR *, CMC_E_FAILURE)

DEFINE_STUB_FUNCTION_9(ExtendedMAPI, LINKAGE_EXTERN_C, CMC_return_code, FAR PASCAL,
		cmc_logon, cmc_logon, CMC_string, CMC_string, CMC_string,
		CMC_object_identifier, CMC_ui_id, CMC_uint16, CMC_flags,
		CMC_session_id FAR *, CMC_extension FAR *, CMC_E_FAILURE)

DEFINE_STUB_FUNCTION_7(ExtendedMAPI, LINKAGE_EXTERN_C, CMC_return_code, FAR PASCAL,
		cmc_look_up, cmc_look_up, CMC_session_id, CMC_recipient FAR *,
		CMC_flags, CMC_ui_id, CMC_uint32 FAR *,
		CMC_recipient FAR * FAR *, CMC_extension FAR *, CMC_E_FAILURE)

DEFINE_STUB_FUNCTION_4(ExtendedMAPI, LINKAGE_EXTERN_C, CMC_return_code, FAR PASCAL,
		cmc_query_configuration, cmc_query_configuration, CMC_session_id,
		CMC_enum, CMC_buffer, CMC_extension FAR *, CMC_E_FAILURE)

DEFINE_STUB_FUNCTION_6(ExtendedMAPI, LINKAGE_EXTERN_C, CMC_return_code, FAR PASCAL,
		cmc_read, cmc_read, CMC_session_id, CMC_message_reference FAR *,
		CMC_flags, CMC_message FAR * FAR *, CMC_ui_id, CMC_extension FAR *, CMC_E_FAILURE)

DEFINE_STUB_FUNCTION_5(ExtendedMAPI, LINKAGE_EXTERN_C, CMC_return_code, FAR PASCAL,
		cmc_send, cmc_send, CMC_session_id, CMC_message FAR *,
		CMC_flags, CMC_ui_id, CMC_extension FAR *, CMC_E_FAILURE)

DEFINE_STUB_FUNCTION_8(ExtendedMAPI, LINKAGE_EXTERN_C, CMC_return_code, FAR PASCAL,
		cmc_send_documents, cmc_send_documents,
		CMC_string, CMC_string, CMC_string, CMC_flags,
		CMC_string, CMC_string, CMC_string, CMC_ui_id, CMC_E_FAILURE)




#if !defined (_X86_)

DEFINE_STUB_FUNCTION_USE_LOOKUP_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG, STDAPICALLTYPE,
		ExtendedMAPIFreeBuffer, MAPIFreeBuffer,
		LPVOID, (ULONG) MAPI_E_CALL_FAILED)

#else

DEFINE_STUB_FUNCTION_1(ExtendedMAPI, LINKAGE_EXTERN_C, ULONG, STDAPICALLTYPE,
		ExtendedMAPIFreeBuffer, MAPIFreeBuffer@4,
		LPVOID, (ULONG) MAPI_E_CALL_FAILED)

#endif

#if !defined (_X86_)

DEFINE_STUB_FUNCTION_USE_LOOKUP_1(SimpleMAPI, LINKAGE_EXTERN_C, ULONG, STDAPICALLTYPE,
		SimpleMAPIFreeBuffer, MAPIFreeBuffer,
		LPVOID, (ULONG) MAPI_E_CALL_FAILED)

#else

DEFINE_STUB_FUNCTION_1(SimpleMAPI, LINKAGE_EXTERN_C, ULONG, STDAPICALLTYPE,
		SimpleMAPIFreeBuffer, MAPIFreeBuffer,
		LPVOID, (ULONG) MAPI_E_CALL_FAILED)

#endif


LINKAGE_EXTERN_C ULONG STDAPICALLTYPE AmbiguousMAPIFreeBuffer(LPVOID lpvBuffer)
{
	if (NULL != lpvBuffer)		// NULL pointers allowed by Extended MAPI
	{
		EnterCriticalSection(&csLinkedList);

		FreeBufferBlocks ** ppfb = &g_pfbbHead;

		while (NULL != *ppfb)
		{
			if ((**ppfb).pvBuffer == lpvBuffer)
			{
				// It's a Simple MAPI allocation

				// Get it out of the linked list now.

				FreeBufferBlocks * pfbThis = *ppfb;

				*ppfb = pfbThis->pNext;

				::GlobalFree(pfbThis);

				LeaveCriticalSection(&csLinkedList);

				return ::SimpleMAPIFreeBuffer(lpvBuffer);
			}

			ppfb = &(**ppfb).pNext;
		}

		LeaveCriticalSection(&csLinkedList);

		// Didn't find it, it must be Extended MAPI

		return ::ExtendedMAPIFreeBuffer(lpvBuffer);
	}

	return SUCCESS_SUCCESS;
}



static HRESULT AddToFreeBufferBlocks(LPVOID lpvBuffer)
{
	FreeBufferBlocks * pfbNew = (FreeBufferBlocks *)
			::GlobalAlloc(GMEM_FIXED, sizeof(FreeBufferBlocks));

	if (NULL == pfbNew)
	{
		return MAPI_E_NOT_ENOUGH_MEMORY;
	}

	EnterCriticalSection(&csLinkedList);

	pfbNew->pvBuffer = lpvBuffer;
	pfbNew->pNext = g_pfbbHead;

	g_pfbbHead = pfbNew;

	LeaveCriticalSection(&csLinkedList);

	return SUCCESS_SUCCESS;
}




// Simple MAPI: none of these functions' arguments needs to be thunked for Wx86


LINKAGE_EXTERN_C typedef ULONG (FAR PASCAL * MAPIAddressFuncPtr)(
		LHANDLE, ULONG_PTR, LPSTR, ULONG, LPSTR, ULONG,
		lpMapiRecipDesc, FLAGS, ULONG, LPULONG, lpMapiRecipDesc FAR *);

LINKAGE_EXTERN_C ULONG FAR PASCAL MAPIAddress(LHANDLE a,
			ULONG_PTR b, LPSTR c, ULONG d, LPSTR e, ULONG f, lpMapiRecipDesc g,
			FLAGS h, ULONG i, LPULONG j, lpMapiRecipDesc FAR * ppNeedToFreeBuffer)
{
	static MAPIAddressFuncPtr OMIStubMAPIAddress = (MAPIAddressFuncPtr)
				::GetProcAddress(GetProxyDll(SimpleMAPI), "MAPIAddress");

	if (NULL == OMIStubMAPIAddress)
	{
		AssertSz(FALSE, "MAPI32 Stub:  Entry point \"MAPIAddress\" not found!");

		return (ULONG) MAPI_E_CALL_FAILED;
	}
	else
	{
		Assert(NULL != ppNeedToFreeBuffer);

		ULONG ulResult = OMIStubMAPIAddress(a, b, c, d, e, f, g, h, i, j, ppNeedToFreeBuffer);

		if (NULL != *ppNeedToFreeBuffer)
		{
			if (SUCCESS_SUCCESS != AddToFreeBufferBlocks(*ppNeedToFreeBuffer))
			{
				::SimpleMAPIFreeBuffer(*ppNeedToFreeBuffer);

				*ppNeedToFreeBuffer = NULL;

				return (ULONG) MAPI_E_NOT_ENOUGH_MEMORY;
			}
		}

		return ulResult;
	}
}



LINKAGE_EXTERN_C typedef ULONG (FAR PASCAL * MAPIReadMailFuncPtr)(
		LHANDLE, ULONG_PTR, LPSTR, FLAGS, ULONG, lpMapiMessage FAR *);

LINKAGE_EXTERN_C ULONG FAR PASCAL MAPIReadMail(LHANDLE a, ULONG_PTR b,
		LPSTR c, FLAGS d, ULONG e, lpMapiMessage FAR * ppNeedToFreeBuffer)
{
	static MAPIReadMailFuncPtr OMIStubMAPIReadMail = (MAPIReadMailFuncPtr)
				::GetProcAddress(GetProxyDll(SimpleMAPI), "MAPIReadMail");

	if (NULL == OMIStubMAPIReadMail)
	{
		AssertSz(FALSE, "MAPI32 Stub:  Entry point \"MAPIReadMail\" not found!");

		return (ULONG) MAPI_E_CALL_FAILED;
	}
	else
	{
		Assert(NULL != ppNeedToFreeBuffer);

		ULONG ulResult = OMIStubMAPIReadMail(a, b, c, d, e, ppNeedToFreeBuffer);

		if (NULL != *ppNeedToFreeBuffer)
		{
			if (SUCCESS_SUCCESS != AddToFreeBufferBlocks(*ppNeedToFreeBuffer))
			{
				::SimpleMAPIFreeBuffer(*ppNeedToFreeBuffer);

				*ppNeedToFreeBuffer = NULL;

				return (ULONG) MAPI_E_NOT_ENOUGH_MEMORY;
			}
		}

		return ulResult;
	}
}



LINKAGE_EXTERN_C typedef ULONG (FAR PASCAL * MAPIResolveNameFuncPtr)(
		LHANDLE, ULONG_PTR, LPSTR, FLAGS, ULONG, lpMapiRecipDesc FAR *);

LINKAGE_EXTERN_C ULONG FAR PASCAL MAPIResolveName(LHANDLE a, ULONG_PTR b,
		LPSTR c, FLAGS d, ULONG e, lpMapiRecipDesc FAR * ppNeedToFreeBuffer)
{
	static MAPIResolveNameFuncPtr OMIStubMAPIResolveName = (MAPIResolveNameFuncPtr)
				::GetProcAddress(GetProxyDll(SimpleMAPI), "MAPIResolveName");

	if (NULL == OMIStubMAPIResolveName)
	{
		AssertSz(FALSE, "MAPI32 Stub:  Entry point \"MAPIResolveName\" not found!");

		return (ULONG) MAPI_E_CALL_FAILED;
	}
	else
	{
		Assert(NULL != ppNeedToFreeBuffer);

		ULONG ulResult = OMIStubMAPIResolveName(a, b, c, d, e, ppNeedToFreeBuffer);

		if (NULL != *ppNeedToFreeBuffer)
		{
			if (SUCCESS_SUCCESS != AddToFreeBufferBlocks(*ppNeedToFreeBuffer))
			{
				::SimpleMAPIFreeBuffer(*ppNeedToFreeBuffer);

				*ppNeedToFreeBuffer = NULL;

				return (ULONG) MAPI_E_NOT_ENOUGH_MEMORY;
			}
		}

		return ulResult;
	}
}


DEFINE_STUB_FUNCTION_5(SimpleMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		MAPISendDocuments, MAPISendDocuments,
		ULONG_PTR, LPSTR, LPSTR, LPSTR, ULONG, (ULONG) MAPI_E_CALL_FAILED)

#if !defined (_X86_)
DEFINE_STUB_FUNCTION_USE_LOOKUP_6(SimpleMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		SimpleMAPILogon, MAPILogon,
		ULONG, LPSTR, LPSTR, FLAGS, ULONG, LPLHANDLE, (ULONG) MAPI_E_CALL_FAILED)
#else
DEFINE_STUB_FUNCTION_6(SimpleMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		SimpleMAPILogon, MAPILogon,
		ULONG, LPSTR, LPSTR, FLAGS, ULONG, LPLHANDLE, (ULONG) MAPI_E_CALL_FAILED)
#endif

DEFINE_STUB_FUNCTION_4(SimpleMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		MAPILogoff, MAPILogoff, LHANDLE, ULONG_PTR, FLAGS, ULONG, (ULONG) MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_5(SimpleMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		MAPISendMail, MAPISendMail,
		LHANDLE, ULONG_PTR, lpMapiMessage, FLAGS, ULONG, (ULONG) MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_6(SimpleMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		MAPISaveMail, MAPISaveMail, LHANDLE, ULONG_PTR, lpMapiMessage,
		FLAGS, ULONG, LPSTR, (ULONG) MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_7(SimpleMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		MAPIFindNext, MAPIFindNext,
		LHANDLE, ULONG_PTR, LPSTR, LPSTR, FLAGS, ULONG, LPSTR, (ULONG) MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_5(SimpleMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		MAPIDeleteMail, MAPIDeleteMail,
		LHANDLE, ULONG_PTR, LPSTR, FLAGS, ULONG, (ULONG) MAPI_E_CALL_FAILED)

DEFINE_STUB_FUNCTION_5(SimpleMAPI, LINKAGE_EXTERN_C, ULONG, FAR PASCAL,
		MAPIDetails, MAPIDetails,
		LHANDLE, ULONG_PTR, lpMapiRecipDesc, FLAGS, ULONG, (ULONG) MAPI_E_CALL_FAILED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\mapistub\mapistub\mapinls.h ===
/*
 *	M A P I N L S . H
 *
 *	Internationalization Support Utilities
 *
 *  Copyright 1986-1999 Microsoft Corporation. All Rights Reserved.
 */

#ifndef _MAPINLS_H_
#define _MAPINLS_H_

#if _MSC_VER > 1000
#pragma once
#endif

#if defined (WIN32) && !defined (_WIN32)
#define _WIN32
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* We don't want to include windows.h in case that conflicts with an */
/* earlier inclusion of compobj.h */

#if !defined(WINAPI)
	#if defined(_WIN32) && (_MSC_VER >= 800)
		#define WINAPI				__stdcall
	#elif defined(WIN16)
		#define WINAPI				_far _pascal
	#else
		#define WINAPI				_far _pascal
	#endif
#endif

#if defined(DOS) || defined(_MAC)
#include <string.h>
#endif

#ifndef FAR
#define FAR
#endif

typedef unsigned char				    BYTE;
typedef unsigned short      			WORD;
typedef unsigned long       			DWORD;
typedef unsigned int	 				UINT;
typedef int		 						BOOL;

#ifndef __CHAR_DEFINED__
typedef char							CHAR;
#endif

#ifdef UNICODE
typedef WCHAR							TCHAR;
#else
typedef char							TCHAR;
#endif

#if !defined(_NATIVE_WCHAR_T_DEFINED)
typedef unsigned short WCHAR;
#endif

typedef WCHAR FAR *						LPWSTR;
typedef const WCHAR FAR *				LPCWSTR;
typedef CHAR FAR *						LPSTR;
typedef const CHAR FAR *				LPCSTR;
typedef TCHAR FAR *						LPTSTR;
typedef const TCHAR FAR *				LPCTSTR;
typedef DWORD 							LCID;
typedef const void FAR *				LPCVOID;

#ifndef _MAC
#ifndef LPOLESTR
#if !defined (_WIN32)

#define LPOLESTR        LPSTR
#define LPCOLESTR       LPCSTR
#define OLECHAR         char
#define OLESTR(str) 	str

#else  /* Win32 */

#define LPOLESTR        LPWSTR
#define LPCOLESTR       LPCWSTR
#define OLECHAR         WCHAR
#define OLESTR(str)     L##str

#endif /* !_WIN32 */
#endif /* LPOLESTR */
#endif /* _MAC */

#define NORM_IGNORECASE      			0x00000001     /* ignore case */
#define NORM_IGNORENONSPACE  			0x00000002     /* ignore diacritics */
#define NORM_IGNORESYMBOLS   			0x00000004     /* ignore symbols */

#if defined (_WIN32) /* from winnls.h */
#define NORM_IGNOREKANATYPE				0x00010000     /* ignore kanatype */
#define NORM_IGNOREWIDTH				0x00020000	   /* ignore width */
#elif defined (WIN16) /* from olenls.h */
#define NORM_IGNOREWIDTH				0x00000008		/* ignore width */
#define NORM_IGNOREKANATYPE				0x00000040		/* ignore kanatype */
#endif

#if defined(WIN16)

#define	lstrcpyA						lstrcpy
#define	lstrlenA						lstrlen
#define	lstrcmpA						lstrcmp
#define lstrcmpiA						lstrcmpi
#define	LoadStringA						LoadString
#define IsBadStringPtrA(a1, a2)			IsBadStringPtr(a1, a2)
#define	wvsprintfA						wvsprintf
#define	MessageBoxA						MessageBox
#define GetModuleHandleA				GetModuleHandle
#define CreateWindowA					CreateWindow
#define RegisterClassA					RegisterClass
#define	CharToOemBuff					AnsiToOemBuff
#define	CharToOem						AnsiToOem
#define	CharUpperBuff					AnsiUpperBuff
#define	CharUpper						AnsiUpper

#elif defined(DOS) || defined(_MAC)

#define	IsBadReadPtr(lp, cb)			(FALSE)
#define IsBadWritePtr(lp, cb)			(FALSE)
#define IsBadHugeReadPtr(lp, cb)		(FALSE)
#define IsBadHugeWritePtr(lp, cb)		(FALSE)
#define IsBadCodePtr(lpfn)				(FALSE)
#ifdef _MAC
#undef IsBadStringPtr
#endif
#define IsBadStringPtr(lpsz, cchMax)	(FALSE)
#define IsBadStringPtrA(lpsz, cchMax)	(FALSE)

#if defined(DOS)

#define	lstrcpyA						strcpy
#define	lstrlenA						strlen
#define	lstrcmpA						strcmp
#define lstrcmp							strcmp
#define lstrcmpi						strcmpi
#define lstrcpy							strcpy
#define lstrcat							strcat
#define lstrlen							strlen
#define wsprintf						sprintf

#endif
#endif

#if defined(DOS) || defined(WIN16)
/* Simulate effect of afx header */
#define __T(x)		x
#define _T(x)		__T(x)
#define TEXT		_T
#endif

#define CP_ACP		0		/* default to ANSI code page */
#define CP_OEMCP	1		/* default to OEM  code page */

LCID	WINAPI	MNLS_GetUserDefaultLCID(void);
UINT	WINAPI	MNLS_GetACP(void);
int		WINAPI	MNLS_CompareStringA(LCID Locale, DWORD dwCmpFlags,
					LPCSTR lpString1, int cchCount1, LPCSTR lpString2,
					int cchCount2);
int		WINAPI	MNLS_CompareStringW(LCID Locale, DWORD dwCmpFlags,
					LPCWSTR lpString1, int cchCount1, LPCWSTR lpString2,
					int cchCount2);
int		WINAPI	MNLS_MultiByteToWideChar(UINT uCodePage, DWORD dwFlags,
					LPCSTR lpMultiByteStr, int cchMultiByte,
					LPWSTR lpWideCharStr, int cchWideChar);
int		WINAPI	MNLS_WideCharToMultiByte(UINT uCodePage, DWORD dwFlags,
					LPCWSTR lpWideCharStr, int cchWideChar,
					LPSTR lpMultiByteStr, int cchMultiByte,
					LPCSTR lpDefaultChar, BOOL FAR *lpfUsedDefaultChar);
int		WINAPI	MNLS_lstrlenW(LPCWSTR lpString);
int		WINAPI	MNLS_lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2);
LPWSTR	WINAPI	MNLS_lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2);
BOOL	WINAPI	MNLS_IsBadStringPtrW(LPCWSTR lpsz, UINT ucchMax);

#if defined(_WIN32) && !defined(_WINNT) && !defined(_WIN95) && !defined(_MAC)
#define _WINNT
#endif

#if !defined(_WINNT) && !defined(_WIN95)
#define GetUserDefaultLCID		MNLS_GetUserDefaultLCID
#define GetACP					MNLS_GetACP
#define MultiByteToWideChar		MNLS_MultiByteToWideChar
#define WideCharToMultiByte		MNLS_WideCharToMultiByte
#define CompareStringA			MNLS_CompareStringA
#endif

#if !defined(MAPI_NOWIDECHAR)

#define lstrlenW				MNLS_lstrlenW
#define lstrcmpW				MNLS_lstrcmpW
#define lstrcpyW				MNLS_lstrcpyW
#define CompareStringW			MNLS_CompareStringW

#if defined(WIN16) || defined(_WINNT) || defined(_WIN95)
#define IsBadStringPtrW			MNLS_IsBadStringPtrW
#elif defined(_MAC)
#define IsBadStringPtrW(lpsz, cchMax)			(FALSE)
#else
#define IsBadStringPtrW			(FALSE)
#endif

#endif	/* ! MAPI_NOWIDECHAR */

#ifdef __cplusplus
}
#endif

#endif /* _MAPINLS_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\mapistub\mapistub\mapixrc.h ===
/*
 *
 * MAPIXRC.H
 *
 * Resource definitions for MAPI.DLL
 *
 * Copyright 1992-1995 Microsoft Corporation.  All Rights Reserved.
 *
 */

#ifndef _MAPIXRC_H_
#define	_MAPIXRC_H_

// reordered according to XPPERF recommendations

#define cchCompMax							100

//-------------------------------------------------------------
// MAPI Non Error messages 
//-------------------------------------------------------------

#define IDS_STATUS_BASE						0

/* Component name for GetLastError */

#define IDS_COMPONENTNAME					(IDS_STATUS_BASE + 0)

/* Default Status Strings for Status Table */

#define IDS_STATUS_AVAILABLE				(IDS_STATUS_BASE + 1)
#define IDS_STATUS_OFFLINE					(IDS_STATUS_BASE + 2)
#define IDS_STATUS_FAILURE					(IDS_STATUS_BASE + 3)
#define IDS_STATUS_UNKNOWN					(IDS_STATUS_BASE + 4)
#define IDS_STATUS_XP_ONLINE				(IDS_STATUS_BASE + 5)
#define IDS_STATUS_XP_UPLOADING				(IDS_STATUS_BASE + 6)
#define IDS_STATUS_XP_DOWNLOADING			(IDS_STATUS_BASE + 7)
#define IDS_STATUS_XP_INFLUSHING			(IDS_STATUS_BASE + 8)
#define IDS_STATUS_XP_OUTFLUSHING			(IDS_STATUS_BASE + 9)

// Address Book Status Object Display Name

#define IDS_AB_STATUS_DISPLAY				(IDS_STATUS_BASE + 10)

// Spooler Status Object Display Name

#define IDS_SPOOLER_STATUS_DISPLAY			(IDS_STATUS_BASE + 11)

/* ipmtree.c */

#define IDS_IPMTREE_BASE					(IDS_STATUS_BASE + 12)

#define IDS_IPMSubtreeName					(IDS_IPMTREE_BASE + 0)
#define IDS_WastebasketName					(IDS_IPMTREE_BASE + 1)
#define IDS_WastebasketComment				(IDS_IPMTREE_BASE + 2)
#define IDS_InboxName						(IDS_IPMTREE_BASE + 3)
#define IDS_InboxComment					(IDS_IPMTREE_BASE + 4)
#define IDS_OutboxName						(IDS_IPMTREE_BASE + 5)
#define IDS_OutboxComment					(IDS_IPMTREE_BASE + 6)
#define IDS_SentmailName					(IDS_IPMTREE_BASE + 7)
#define IDS_SentmailComment					(IDS_IPMTREE_BASE + 8)
#define IDS_ViewsName						(IDS_IPMTREE_BASE + 9)
#define IDS_CommonViewsName					(IDS_IPMTREE_BASE + 10)
#define IDS_FindersName						(IDS_IPMTREE_BASE + 11)


/* Strings found in AB UI */

#define IDS_AB_BASE							(IDS_IPMTREE_BASE + 12)

#define IDS_GENERIC_RECIP_DN				(IDS_AB_BASE + 0)
#define IDS_MESSAGE_OPTIONS					(IDS_AB_BASE + 1)
#define IDS_RECIPIENT_OPTIONS				(IDS_AB_BASE + 2)

#define IDS_READ_NOTIFICATION				(IDS_AB_BASE + 3)
#define IDS_RN_SUBJECT_PREFIX				(IDS_AB_BASE + 4)
#define IDS_NONREAD_NOTIFICATION			(IDS_AB_BASE + 5)
#define IDS_NRN_SUBJECT_PREFIX				(IDS_AB_BASE + 6)
#define IDS_REPORT_PREFIX_DELIMITER			(IDS_AB_BASE + 7)

// xDRs

#define IDS_XDR_BASE						(IDS_AB_BASE + 8)

#define IDS_DR_REP_TEXT_GENERIC				(IDS_XDR_BASE + 0)
#define IDS_NDR_REP_TEXT_GENERIC			(IDS_XDR_BASE + 1)
#define IDS_DR_SUBJECT_PREFIX				(IDS_XDR_BASE + 2)
#define IDS_NDR_SUBJECT_PREFIX				(IDS_XDR_BASE + 3)
#define IDS_XDR_SYSTEM_ADMIN_NAME			(IDS_XDR_BASE + 4)
#define	IDS_NDR_LACK_OF_RESPOSIBILITY		(IDS_XDR_BASE + 5)

// Wizard non error strings

#define IDS_WIZ_BASE						(IDS_XDR_BASE + 6)

#define IDS_APP_TITLE						(IDS_WIZ_BASE + 0)
#define IDS_MS_EXCHANGE        				(IDS_WIZ_BASE + 1)
#define IDS_STARTUP_GROUP      	 			(IDS_WIZ_BASE + 2)
#define IDS_BROWSE_PST_TITLE				(IDS_WIZ_BASE + 3)
#define IDS_BROWSE_PAB_TITLE				(IDS_WIZ_BASE + 4)
#define IDS_BROWSE_PST_FILTER  				(IDS_WIZ_BASE + 5)
#define IDS_BROWSE_PAB_FILTER  				(IDS_WIZ_BASE + 6)
#define IDS_BROWSE_ALL_FILTER  				(IDS_WIZ_BASE + 7)
#define IDS_BROWSE_PST_FILES				(IDS_WIZ_BASE + 8)
#define IDS_BROWSE_PAB_FILES				(IDS_WIZ_BASE + 9)
#define IDS_BROWSE_ALL_FILES				(IDS_WIZ_BASE + 10)
#define IDS_DEF_PROFNAME					(IDS_WIZ_BASE + 11)
#define IDS_PAB								(IDS_WIZ_BASE + 12)
#define IDS_PST								(IDS_WIZ_BASE + 13)
#define IDS_INC_PROFNAME					(IDS_WIZ_BASE + 14)
#define IDS_PASSWORDCAPTION	  				(IDS_WIZ_BASE + 15)
#define IDS_CREATE_MESSAGING_SERVICE		(IDS_WIZ_BASE + 16)
#define IDS_LOGOFF_TO_CREATE  				(IDS_WIZ_BASE + 17)
#define IDS_DELETE_MESSAGING_SERVICE		(IDS_WIZ_BASE + 18)
#define IDS_LOGOFF_TO_DELETE  				(IDS_WIZ_BASE + 19)

#define IDS_NOERROR_BASE					(IDS_WIZ_BASE + 20)

/* blddt.c */

#define IDS_GeneralPage						(IDS_NOERROR_BASE + 0)

/*	Dialog Box Captions */

#define IDS_ERRCAPTION						(IDS_NOERROR_BASE + 1)

/* Simple MAPI */

#define IDS_ADDRESSBOOK			   			(IDS_NOERROR_BASE + 2)
#define IDS_ATTACHFILES						(IDS_NOERROR_BASE + 3)

/* Bob fixup strings */

#define IDS_PST_DISPLAY_NAME				(IDS_NOERROR_BASE + 4)
#define IDS_PST_BAD_DISPLAY_NAME			(IDS_NOERROR_BASE + 5)

//-------------------------------------------------------------
// MAPI Error messages 
//-------------------------------------------------------------

#define IDS_ERROR_BASE						(IDS_NOERROR_BASE + 6)

#define IDS_PROP_INTERFACE_NOT_SUPPORTED	(IDS_ERROR_BASE + 0)
#define IDS_NO_CONTENTS_TABLE				(IDS_ERROR_BASE + 1)
#define IDS_UNKNOWN_AB_ENTRYID				(IDS_ERROR_BASE + 2)
#define IDS_UNKNOWN_ENTRYID					(IDS_ERROR_BASE + 3)
#define IDS_NO_PAB							(IDS_ERROR_BASE + 4)
#define IDS_NO_DEFAULT_DIRECTORY			(IDS_ERROR_BASE + 5)
#define IDS_NO_SEARCH_PATH					(IDS_ERROR_BASE + 6)
#define IDS_NO_HIERARCHY					(IDS_ERROR_BASE + 7)
#define IDS_SET_SEARCH_PATH					(IDS_ERROR_BASE + 8)
#define IDS_NO_NAME_CONTAINERS				(IDS_ERROR_BASE + 9)
#define IDS_NO_HIERARCHY_TABLE				(IDS_ERROR_BASE + 10)
#define IDS_STORE_NOT_LISTED				(IDS_ERROR_BASE + 11)
#define IDS_CANT_INIT_PROVIDER				(IDS_ERROR_BASE + 12)
#define IDS_CANT_ADD_STORE					(IDS_ERROR_BASE + 13)
#define IDS_CANT_LOGON_STORE				(IDS_ERROR_BASE + 14)
#define IDS_NO_ABPROVIDERS					(IDS_ERROR_BASE + 15)
#define IDS_NO_XPPROVIDERS					(IDS_ERROR_BASE + 16)
#define IDS_UNKNOWN_PROVIDER				(IDS_ERROR_BASE + 17)
#define IDS_NO_PROVIDER_INFO				(IDS_ERROR_BASE + 18)
#define IDS_WRONG_PROVIDER_VERSION			(IDS_ERROR_BASE + 19)
#define IDS_NEED_EMT_EMA_DN			   		(IDS_ERROR_BASE + 20)

#define IDS_ERROR1_BASE						(IDS_ERROR_BASE + 21)
														   
#define IDS_CANT_GET_RECIP_INFO				(IDS_ERROR1_BASE + 0)
#define IDS_OPTIONS_DATA_ERROR				(IDS_ERROR1_BASE + 1)
#define IDS_CANT_INIT_COMMON_DLG			(IDS_ERROR1_BASE + 2)
#define IDS_NO_SERVICE_ENTRY				(IDS_ERROR1_BASE + 3)
#define IDS_NO_SUCH_SERVICE					(IDS_ERROR1_BASE + 4)
#define IDS_ITABLE_ERROR					(IDS_ERROR1_BASE + 5)
#define IDS_PROF_ACCESS_DENIED				(IDS_ERROR1_BASE + 6)
#define IDS_NO_CONNECTION					(IDS_ERROR1_BASE + 7)
#define IDS_COREMOTE_ERROR					(IDS_ERROR1_BASE + 8)
#define IDS_OPENSTAT_ERROR					(IDS_ERROR1_BASE + 9)
#define IDS_MAPI_NOT_INITIALIZED			(IDS_ERROR1_BASE + 10)
#define IDS_NO_SERVICE						(IDS_ERROR1_BASE + 11)
#define IDS_NO_NEW_DEF      				(IDS_ERROR1_BASE + 12)
#define IDS_CANT_FIX_OLD_DEF				(IDS_ERROR1_BASE + 13)
#define IDS_NO_DLL							(IDS_ERROR1_BASE + 14)
#define IDS_NO_SERVICE_DLL					(IDS_ERROR1_BASE + 15)
#define IDS_DEADSPOOLER						(IDS_ERROR1_BASE + 16)
#define IDS_FAILEDSPOOLER					(IDS_ERROR1_BASE + 17)
#define IDS_LOGONINTERNAL					(IDS_ERROR1_BASE + 18)
#define IDS_NO_RECIP_OPTIONS				(IDS_ERROR1_BASE + 19)
#define IDS_NODEFSTORESUPPORT				(IDS_ERROR1_BASE + 20)
#define IDS_SERVICEONEINSTANCE				(IDS_ERROR1_BASE + 21)
#define IDS_TRANSPORT_BUSY					(IDS_ERROR1_BASE + 22)
#define IDS_NO_REQUIRED_PROPS				(IDS_ERROR1_BASE + 23)
#define IDS_ISTREAM_ERROR					(IDS_ERROR1_BASE + 24)
#define IDS_ERRADDIPMTREE					(IDS_ERROR1_BASE + 25)
#define IDS_EXPANDRECIP_EMPTY_DLS			(IDS_ERROR1_BASE + 26)
#define IDS_LOGON_TIMED_OUT					(IDS_ERROR1_BASE + 27)
#define IDS_SERVICE_DLL_NOT_FOUND			(IDS_ERROR1_BASE + 28)
#define IDS_VALIDATESTATE_ERROR				(IDS_ERROR1_BASE + 29)
#define IDS_NO_MSG_OPTIONS					(IDS_ERROR1_BASE + 30)
#define IDS_NOREGFILE						(IDS_ERROR1_BASE + 31)
#define IDS_REGLOADFAIL						(IDS_ERROR1_BASE + 32)
#define IDS_NORESTOREPRIV					(IDS_ERROR1_BASE + 33)
#define	IDS_NTERROR							(IDS_ERROR1_BASE + 34)
//	Spooler wrapper error strings

#define IDS_SPL_BASE						(IDS_ERROR1_BASE + 35)

#define IDS_WRAPPED_RESTRICTION				(IDS_SPL_BASE + 0) 
#define	IDS_WRAPPED_ATTACHMENT_RESOLVE		(IDS_SPL_BASE + 1) 
#define	IDS_WRAPPED_NO_ACCESS				(IDS_SPL_BASE + 2) 
#define	IDS_WRAPPED_RECIP_TABLE				(IDS_SPL_BASE + 3) 
#define IDS_WRAPPED_SORT					(IDS_SPL_BASE + 4)

#define IDS_DEADSPOOLER_CAPTION				(IDS_SPL_BASE + 5)

/*
 *	Resource IDs for MAPI default profile provider.
 *

/* Error messages */

#define IDS_PROFILE_BASE					(IDS_SPL_BASE + 6)

#define IDS_GETPROPLISTFAIL					(IDS_PROFILE_BASE + 0)
#define IDS_NOPROPERTIES					(IDS_PROFILE_BASE + 1)
#define IDS_SECTIONOPENREADONLY				(IDS_PROFILE_BASE + 2)
#define IDS_GETPROPFAIL						(IDS_PROFILE_BASE + 3)
#define IDS_INVALIDNAME						(IDS_PROFILE_BASE + 4)
#define IDS_INVALIDPASSWORD					(IDS_PROFILE_BASE + 5)
#define IDS_DUPPROFILE						(IDS_PROFILE_BASE + 6) 
#define IDS_NOPROFILE						(IDS_PROFILE_BASE + 7) 
#define IDS_NOPROFILESATALL					(IDS_PROFILE_BASE + 8) 
#define IDS_INTERNALLOGONFAIL				(IDS_PROFILE_BASE + 9) 
#define IDS_NOSECTION						(IDS_PROFILE_BASE + 10) 
#define IDS_LOGONFAIL						(IDS_PROFILE_BASE + 11) 


//	Profile wizard resource IDs
//	Error message strings

#define IDS_WIZ1_BASE						(IDS_PROFILE_BASE + 12)

#define IDS_FATAL							(IDS_WIZ1_BASE + 0)
#define IDS_DLG_FLD							(IDS_WIZ1_BASE + 1)
#define IDS_INVLD_WM						(IDS_WIZ1_BASE + 2)
#define IDS_INVLD_PROFNAME					(IDS_WIZ1_BASE + 3)
#define IDS_APPLICATION_FAILED 				(IDS_WIZ1_BASE + 4)
#define IDS_CREATE_DEFSRV					(IDS_WIZ1_BASE + 5)
#define IDS_CONFIG_DEFSRV					(IDS_WIZ1_BASE + 6)
#define IDS_CONFIG_CFGPROF					(IDS_WIZ1_BASE + 7)
#define IDS_PROPSAVE_SVC					(IDS_WIZ1_BASE + 8)
#define IDS_SRV_FLD							(IDS_WIZ1_BASE + 9)
#define IDS_RESOURCE_FLD					(IDS_WIZ1_BASE + 10)
#define IDS_SRVDLL_FLD						(IDS_WIZ1_BASE + 11)
#define IDS_MAPILOGON_FLD					(IDS_WIZ1_BASE + 12)
#define IDS_CRPROF_FLD						(IDS_WIZ1_BASE + 13)
#define IDS_PASS_FLD						(IDS_WIZ1_BASE + 14)
#define IDS_MMF_TOOMANY						(IDS_WIZ1_BASE + 15)
#define IDS_MMF_FLD							(IDS_WIZ1_BASE + 16)
#define IDS_PROF_EXIST						(IDS_WIZ1_BASE + 17)
#define IDS_NO_MEM							(IDS_WIZ1_BASE + 18)
#define IDS_DEFDIR_FLD						(IDS_WIZ1_BASE + 19)
#define IDS_CREATEPAB_FLD					(IDS_WIZ1_BASE + 20)
#define IDS_CONFIGPAB_FLD					(IDS_WIZ1_BASE + 21)
#define IDS_CONFIGPAB_FLD_POPUP 			(IDS_WIZ1_BASE + 22)
#define IDS_CREATEPST_FLD					(IDS_WIZ1_BASE + 23)
#define IDS_CONFIGPST_FLD					(IDS_WIZ1_BASE + 24)
#define IDS_CONFIGPST_FLD_POPUP 			(IDS_WIZ1_BASE + 25)
#define IDS_CREATEPST_NOTFOUND  			(IDS_WIZ1_BASE + 26)
#define IDS_CANCEL_ENSURE					(IDS_WIZ1_BASE + 27)
#define IDS_INVALID_SVC_ENTRY  				(IDS_WIZ1_BASE + 28)
#define IDS_INF_MISSING        				(IDS_WIZ1_BASE + 29)
#define IDS_2INSTANCE          				(IDS_WIZ1_BASE + 30)
#define IDS_WELCOME_MESSAGE    				(IDS_WIZ1_BASE + 31)

#define IDS_MAPI_BASE						(IDS_WIZ1_BASE + 32)

/* ITableData */

#define	IDS_OUT_OF_BOOKMARKS				(IDS_MAPI_BASE + 0) 
#define	IDS_CANT_CATEGORIZE					(IDS_MAPI_BASE + 1) 

/* TNEF */

#define	IDS_TNEF_UNTITLED_ATTACH			(IDS_MAPI_BASE + 2)
#define	IDS_TNEF_EMBEDDED_MESSAGE			(IDS_MAPI_BASE + 3)
#define	IDS_TNEF_TAG_EMBEDDED				(IDS_MAPI_BASE + 4)
#define	IDS_TNEF_TAG_OLE					(IDS_MAPI_BASE + 5)
#define	IDS_TNEF_TAG_UNKNOWN				(IDS_MAPI_BASE + 6)
#define IDS_TNEF_EMBEDDED_STRM_NAME			(IDS_MAPI_BASE + 7)
#define IDS_TNEF_OLE2_LINK					(IDS_MAPI_BASE + 8)
#define IDS_TNEF_TAG_IN						(IDS_MAPI_BASE + 9)

/* Message-on-storage */

#define IDS_BASE_IMSG						(IDS_MAPI_BASE + 10)

#define IDS_SUCCESS_IMSG					(IDS_BASE_IMSG + 0)
#define IDS_NOT_ENOUGH_MEMORY				(IDS_BASE_IMSG + 1)
#define IDS_NO_ACCESS						(IDS_BASE_IMSG + 2)
#define IDS_INVALID_PARAMETER				(IDS_BASE_IMSG + 3)
#define IDS_INTERFACE_NOT_SUPPORTED			(IDS_BASE_IMSG + 4)
#define IDS_INVALID_ENTRYID					(IDS_BASE_IMSG + 5)
#define IDS_CALL_FAILED						(IDS_BASE_IMSG + 6)
#define IDS_ERRORS_RETURNED					(IDS_BASE_IMSG + 7)
#define IDS_NO_SUPPORT		 				(IDS_BASE_IMSG + 8)
#define IDS_NOT_IN_QUEUE					(IDS_BASE_IMSG + 9)
#define IDS_UNABLE_TO_ABORT					(IDS_BASE_IMSG + 10)
#define IDS_NOT_FOUND						(IDS_BASE_IMSG + 11)
#define IDS_LOGON_FAILED					(IDS_BASE_IMSG + 12)
#define IDS_CORRUPT_STORE					(IDS_BASE_IMSG + 13)
#define IDS_BAD_VALUE						(IDS_BASE_IMSG + 14)
#define IDS_INVALID_OBJECT					(IDS_BASE_IMSG + 15)
#define IDS_NOT_ENOUGH_DISK					(IDS_BASE_IMSG + 16)
#define IDS_DISK_ERROR						(IDS_BASE_IMSG + 17)
#define IDS_NOINTERFACE						(IDS_BASE_IMSG + 18)
#define IDS_INVALIDARG						(IDS_BASE_IMSG + 19)
#define IDS_UNKNOWN_FLAGS					(IDS_BASE_IMSG + 20)

#define IDS_BASE_SMTPOPT					(IDS_BASE_IMSG + 21)

#define IDS_ENCODING_TITLE					(IDS_BASE_SMTPOPT + 0)
#define IDS_MESSAGE_ENCODING_TAG			(IDS_BASE_SMTPOPT + 1)


#define IDS_NOT_SUPPORTED					IDS_NO_SUPPORT
#define IDS_STDINVALIDPARAMETER				IDS_INVALID_PARAMETER
#define IDS_STDNOTIMPLEMENTED				IDS_NO_SUPPORT
#define IDS_STDINSUFFICIENTMEMORY			IDS_NOT_ENOUGH_MEMORY
#define IDS_STDNOTSUPPORTED					IDS_NO_SUPPORT
#define IDS_STDINTERNALERROR				IDS_CALL_FAILED

//----------------------------------------------------------
// Non String Defines
//----------------------------------------------------------

/* TNEF */

#define rsidAttachIcon 						451

/* dialog defines */

#define	IDD_ONEOFF_GENERAL_PAGE				600

/* control ids	*/
#define	IDC_STATIC							0xffff
#define	IDC_DISPLAY_NAME					601
#define	IDC_EMAIL_ADDRESS					602
#define	IDC_ADDRTYPE						603
#define IDC_SEND_TNEF						604

#ifdef MSMAPI
#define IDC_SEND_TNEF						604
#endif

// Progress dialog testing

#define IDD_PROGRESS						700
#define IDC_PROGRESS_PERCENT				701
#define IDC_PROGRESS_COUNT					703
#define IDC_PROGRESS_MIN					704
#define IDC_PROGRESS_MAX					705
#define IDC_PROGRESS_FLAGS					706
#define IDC_PROGRESS_FRAME					707

#define	IDD_FQ								800
#define ICO_FQ_MSMAIL						801

#define IDD_FQ_ANIMATED						810
#define AVI_FQ_RSRC							811
#define AVI_FQ_LOCN							812

/* Dialog items */

#define DLG_ChooseProfile			5200			/* dialogs */
#define DLG_Password				5201
#define DLG_UIMutex					5202

#define BMP_MSLogo					5210			/* pictures */
#define EDT_Bitmap					5211
#define ICO_Profile					5212

#define LBL_Password				5220			/* controls */
#define EDT_Password				5221
#define LBL_Profile					5222
#define LBX_Profile					5223
#define CHK_DefProfile				5224
#define CHK_LogonAll				5225
#define CHK_SavePassword			5226
#define GRP_Options					5227
#define PSH_Help					5228
#define PSH_Options					5229
#define LBL_Suitcase				5230
#define LBL_CreateProfile			5231
#define PSH_NewProfile				5232


//Definitions of IDs for Dialog controls.....ids below 400 have been 
//reserved for the Profile Wizard

#define IDD_1					2345
#define IDD_2					2346
#define IDD_CANCEL				(IDCANCEL)
#define IDD_BACK				125
#define IDD_NEXT				126
#define IDD_BITMAP				127
#define GRAPHIC_BITMAP			128

#define IDD_MISC_STATIC_1		150
#define IDD_STATIC_P1_1			151
#define IDD_STATIC_P1_2			152
#define IDD_STATIC_P1_3			153 
#define IDD_P1_RADIOBUT_MSXCHG_YES  154
#define IDD_P1_RADIOBUT_MSXCHG_NO   155

#define IDD_STATIC_P2_1			201   
#define IDD_CTL_P2_1			202
#define IDD_CTL_P2_2			203
#define IDD_CTL_P2_3			204
#define IDD_STATIC_P2_2			205   
				   
#define IDD_STATIC_PPAB			230
#define IDD_EDIT_PPAB_NAME		231
#define IDD_BROWSE_PPAB			232

#define IDD_STATIC_PPST			233
#define IDD_EDIT_PPST_NAME		234
#define IDD_BROWSE_PPST			235

#define IDD_STATIC_STARTUP      236
#define IDD_RADIOBUT_STARTUP_YES  237
#define IDD_RADIOBUT_STARTUP_NO   238

#define IDD_STATIC_P3_1			301  
#define IDD_STATIC_P3_2			302  
#define IDD_CTL_P3_1			303

#define IDD_STATIC_PC_1			321
#define IDD_OK					322
#define IDD_CTL_PC_LB			323

#define IDD_STATIC_PMMF_1		325
#define IDD_STATIC_PMMF_2		326
#define IDD_CTL_PMMF_1			327
#define IDD_CTL_PMMF_NOCONVERT	328
#define IDD_CTL_PMMF_CONVERT	329
#define IDD_CTL_PMMF_PASS		330
#define IDD_STATIC_PMMF_PASS	331
#define IDD_STATIC_PE_1			332
#define IDD_STATIC_PE_2			333
#define IDD_STATIC_PE_3			334
#define IDD_FINISH				335
#define IDD_STATIC_PMMF_3		336
#define IDD_CTL_PMMF_DETAILS	337
#define IDB_GRAPHIC				350

#define IDD_STATIC_DETAILS_1	400
#define IDD_STATIC_DETAILS_2	401
#define IDD_STATIC_DETAILS_3	402

//
//  Per recipient options
//
#define IDD_SMTPOPT_ENCODING	425


#define IDD_SMTPOPT_CARE		426


#define IDD_SMTPOPT_MIME		427
#define IDD_SMTPOPT_NonMIME		428
   
//  If we're in MIME
#define IDD_SMTPOPT_Text		429
#define IDD_SMTPOPT_HTML		430
#define IDD_SMTPOPT_Both		431
   
//  If we're in NonMime
#define IDD_SMTPOPT_BinHex		432

#define IDD_SMTPOPT_Body		433
#define IDD_SMTPOPT_Attach		434

#ifdef MSMAPI
#define	NFS_EDIT				0x0001
#define	NFS_STATIC				0x0002
#define	NFS_LISTCOMBO			0x0004
#define	NFS_BUTTON				0x0008
#define	NFS_ALL					0x0010
#endif

#endif	/* _MAPIXRC_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\mapistub\mapistub\mapiperf.h ===
/*
 -	M A P I P E R F . H
 -
 *	Purpose:
 *		This is the place to define data structures, macros, and functions
 *		used to improve the performance of WMS components.
 *
 *	Copyright Microsoft Corporation, 1993-1994.
 *
 */

#ifndef __MAPIPERF_H__
#define __MAPIPERF_H__
 
/*
 -	SEGMENT()
 -
 *	Purpose:
 *		This macro allows us to control whether code_seg()s get defined
 *		in a source module or not.  Currently, these are only defined on
 *		the Win16 platform.  On Windows 95 and NT this macro expands out to
 *		a #pragma comment(). The usage in a source module is:
 *
 *			#pragma SEGMENT(segment_name)
 *
 *			For Lego, the code_seg should never be used - TF
 */

/* #if defined(WIN16) && !defined(DEBUG)
#define SEGMENT(seg)			code_seg(#seg)
#else */
#define SEGMENT(seg)			comment(user,#seg)
/* #endif */

#if defined(WIN32) && !defined(MAC)
#define SHARED_BEGIN			data_seg(".SHARED")
#define SHARED1_BEGIN			data_seg(".SHARED1")
#define SHARED_END				data_seg()
#define VTBL_BEGIN				data_seg(".VTABLE")
#define VTBL_END				data_seg()
#define DATA1_BEGIN				data_seg(".data1","DATA")
#define DATA2_BEGIN				data_seg(".data2","DATA")
#define DATA3_BEGIN				data_seg(".data3","DATA")
#define DATA_END				data_seg()
#else
#define SHARED_BEGIN			comment(user,".shared")
#define SHARED1_BEGIN			comment(user,".shared1")
#define SHARED_END				comment(user,".shared")
#define VTBL_BEGIN				comment(user,".vtable")
#define VTBL_END				comment(user,".vtable")
#define DATA1_BEGIN				comment(user,".data1")
#define DATA2_BEGIN				comment(user,".data2")
#define DATA3_BEGIN				comment(user,".data3")
#define DATA_END				comment(user,".data end")
#endif

// $MAC - Mac needs 16 bit style memory management

#if defined(WIN32) && !defined(MAC)
#define STACK_ALLOC(Size, Ptr)	( Ptr = _alloca((size_t) Size), Ptr ? S_OK : MAPI_E_NOT_ENOUGH_MEMORY )
#define STACK_FREE(Ptr)
#else
#define STACK_ALLOC(Size, Ptr)	MAPIAllocateBuffer(Size, &Ptr)
#define STACK_FREE(Ptr)			if (Ptr) MAPIFreeBuffer(Ptr)
#endif

#ifndef MPPC
#define FASTCALL	__fastcall
#else
#define FASTCALL
#endif

#define MAPISetBufferNameFn(pv) \
	(!(pv) || !(*((ULONG *)(pv) - 2) & 0x40000000)) ? 0 : \
		(**((int (__cdecl ***)(void *, ...))((ULONG *)(pv) - 3))) \
			((void *)*((ULONG *)pv - 3), (ULONG *)pv - 4,

#if defined(DEBUG) && !defined(DOS)
#define MAPISetBufferName(pv,psz)					MAPISetBufferNameFn(pv) psz)
#define MAPISetBufferName1(pv,psz,a1)				MAPISetBufferNameFn(pv) psz,a1)
#define MAPISetBufferName2(pv,psz,a1,a2)			MAPISetBufferNameFn(pv) psz,a1,a2)
#define MAPISetBufferName3(pv,psz,a1,a2,a3) 		MAPISetBufferNameFn(pv) psz,a1,a2,a3)
#define MAPISetBufferName4(pv,psz,a1,a2,a3,a4) 		MAPISetBufferNameFn(pv) psz,a1,a2,a3,a4)
#define MAPISetBufferName5(pv,psz,a1,a2,a3,a4,a5) 	MAPISetBufferNameFn(pv) psz,a1,a2,a3,a4,a5)
#else
#define MAPISetBufferName(pv,psz)
#define MAPISetBufferName1(pv,psz,a1)
#define MAPISetBufferName2(pv,psz,a1,a2)
#define MAPISetBufferName3(pv,psz,a1,a2,a3)
#define MAPISetBufferName4(pv,psz,a1,a2,a3,a4)
#define MAPISetBufferName5(pv,psz,a1,a2,a3,a4,a5)
#endif

#endif /* __MAPIPERF_H__ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\mapistub\mapistub\unkobj.h ===
/*
 *	U N K O B J . H
 *
 * This is a generic definition of the IUnknown (plus GetLastError) part
 * of objects that are derived from IUnknown with GetLastError.
 *
 * Used in:
 * IPROP
 *
 */

#include <_glheap.h>


typedef struct _UNKOBJ FAR *	LPUNKOBJ;

/* The instance portion of UNKOBJ structure members.
 */
typedef struct _UNKINST
{
	LPALLOCATEBUFFER	lpfAllocateBuffer;
	LPALLOCATEMORE		lpfAllocateMore;
	LPFREEBUFFER		lpfFreeBuffer;
	LPMALLOC			lpmalloc;
	HINSTANCE			hinst;

} UNKINST, * PUNKINST;

typedef ULONG	IDS;

#ifndef BEGIN_INTERFACE
#define BEGIN_INTERFACE
#endif


/*============================================================================
 *
 *	UNKOBJ (IUnknown) Class
 */

#define	cchLastError	1024

#define MAPI_IMAPIUNKNOWN_METHODS(IPURE)								\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\

#undef	INTERFACE
#define	INTERFACE	struct _UNKOBJ

#undef	METHOD_PREFIX
#define	METHOD_PREFIX	UNKOBJ_

#undef	LPVTBL_ELEM
#define	LPVTBL_ELEM		lpvtbl

#undef	MAPIMETHOD_
#define	MAPIMETHOD_(type,method)	MAPIMETHOD_DECLARE(type,method,UNKOBJ_)
		MAPI_IUNKNOWN_METHODS(IMPL)
		MAPI_IMAPIUNKNOWN_METHODS(IMPL)
#undef	MAPIMETHOD_
#define	MAPIMETHOD_(type,method)	STDMETHOD_(type,method)

DECLARE_MAPI_INTERFACE(UNKOBJ_)
{
	BEGIN_INTERFACE
	MAPI_IUNKNOWN_METHODS(IMPL)
	MAPI_IMAPIUNKNOWN_METHODS(IMPL)
};

#define	UNKOBJ_MEMBERS					\
	ULONG				ulcbVtbl;		\
	ULONG				ulcRef;			\
	LPIID FAR *			rgpiidList;		\
	ULONG				ulcIID;			\
	CRITICAL_SECTION	csid;			\
	UNKINST *			pinst;			\
	HRESULT				hrLastError;	\
	IDS					idsLastError;	\
	HLH					lhHeap

typedef struct _UNKOBJ
{
	UNKOBJ_Vtbl FAR *	lpvtbl;
	UNKOBJ_MEMBERS;

} UNKOBJ;



__inline VOID
UNKOBJ_EnterCriticalSection( LPUNKOBJ lpunkobj )
{
	EnterCriticalSection(&lpunkobj->csid);
}

__inline VOID
UNKOBJ_LeaveCriticalSection( LPUNKOBJ lpunkobj )
{
	LeaveCriticalSection(&lpunkobj->csid);
}

__inline HRESULT
UNKOBJ_HrSetLastResult( LPUNKOBJ	lpunkobj,
						HRESULT		hResult,
						IDS			idsError )
{
	UNKOBJ_EnterCriticalSection(lpunkobj);
	lpunkobj->idsLastError = idsError;
    lpunkobj->hrLastError = hResult;
	UNKOBJ_LeaveCriticalSection(lpunkobj);

	return hResult;
}

__inline HRESULT
UNKOBJ_HrSetLastError( LPUNKOBJ	lpunkobj,
					   SCODE	sc,
					   IDS		idsError )
{
	UNKOBJ_EnterCriticalSection(lpunkobj);
	lpunkobj->idsLastError = idsError;
    lpunkobj->hrLastError = ResultFromScode(sc);
	UNKOBJ_LeaveCriticalSection(lpunkobj);

	return ResultFromScode(sc);
}

__inline VOID
UNKOBJ_SetLastError( LPUNKOBJ	lpunkobj,
					 SCODE		sc,
					 IDS		idsError )
{
	lpunkobj->idsLastError = idsError;
    lpunkobj->hrLastError = ResultFromScode(sc);
}

__inline VOID
UNKOBJ_SetLastErrorSc( LPUNKOBJ	lpunkobj,
					   SCODE	sc )
{
	lpunkobj->hrLastError = ResultFromScode(sc);
}

__inline VOID
UNKOBJ_SetLastErrorIds( LPUNKOBJ	lpunkobj,
						IDS			ids )
{
	lpunkobj->idsLastError = ids;
}

STDAPI_(SCODE)
UNKOBJ_Init( LPUNKOBJ			lpunkobj,
			 UNKOBJ_Vtbl FAR *	lpvtblUnkobj,
			 ULONG				ulcbVtbl,
			 LPIID FAR *		rgpiidList,
			 ULONG				ulcIID,
			 PUNKINST			punkinst );

STDAPI_(VOID)
UNKOBJ_Deinit( LPUNKOBJ lpunkobj );

STDAPI_(SCODE)
UNKOBJ_ScAllocate( LPUNKOBJ		lpunkobj,
				   ULONG		ulcb,
				   LPVOID FAR *	lppv );

STDAPI_(SCODE)
UNKOBJ_ScAllocateMore( LPUNKOBJ		lpunkobj,
					   ULONG		ulcb,
					   LPVOID		lpv,
					   LPVOID FAR *	lppv );

STDAPI_(VOID)
UNKOBJ_Free( LPUNKOBJ	lpunkobj,
			 LPVOID		lpv );

STDAPI_(VOID)
UNKOBJ_FreeRows( LPUNKOBJ	lpunkobj,
				 LPSRowSet	lprows );


STDAPI_(SCODE)
UNKOBJ_ScCOAllocate( LPUNKOBJ		lpunkobj,
				   ULONG		ulcb,
				   LPVOID FAR *	lppv );


STDAPI_(SCODE)
UNKOBJ_ScCOReallocate( LPUNKOBJ		lpunkobj,
					   ULONG		ulcb,
					   LPVOID FAR *	lplpv );

STDAPI_(VOID)
UNKOBJ_COFree( LPUNKOBJ	lpunkobj,
			 LPVOID		lpv );

 

STDAPI_(SCODE)
UNKOBJ_ScSzFromIdsAlloc( LPUNKOBJ		lpunkobj,
						 IDS			ids,
						 ULONG			ulFlags,
						 int			cchBuf,
						 LPTSTR FAR *	lpszBuf );

STDAPI_(SCODE)
UNKOBJ_ScSzFromIdsAllocMore( LPUNKOBJ		lpunkobj,
							 IDS			ids,
							 ULONG			ulFlags,
							 LPVOID			lpvBase,
							 int			cchBuf,
							 LPTSTR FAR *	lppszBuf );


/* These should be moved to a more useful (generic) location (mapidefs.h?).
 */

#ifdef WIN16

/* IsEqualGUID is used to eliminate dependency on compob(j/32).lib. This
 * is only necessary on WIN16 because all other platforms define this 
 * already. (see objbase.h)
 */
#define IsEqualGUID(a, b)			(memcmp((a), (b), sizeof(GUID)) == 0)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\mapistub\mapistub\profspi.h ===
/*
 *  P R O F S P I . H
 *	
 *	Service provider interface for MAPI Profile Providers.
 *	
 *  Copyright 1986-1996 Microsoft Corporation. All Rights Reserved.
 */

#ifndef PROFSPI_H
#define PROFSPI_H

#ifndef PROFILE_GUIDS_ONLY

#ifndef MAPISPI_H
#include <mapispi.h>
#endif


/* IMAPIProfile Interface -------------------------------------------------- */

#define MAPI_IMAPIPROFILE_METHODS(IPURE)								\
	MAPIMETHOD(OpenSection)												\
		(THIS_	LPMAPIUID					lpUID,						\
				ULONG						ulFlags,					\
				LPPROFSECT FAR *			lppProfSect) IPURE;			\
	MAPIMETHOD(DeleteSection)											\
		(THIS_	LPMAPIUID					lpUID) IPURE;				\

#undef		 INTERFACE
#define		 INTERFACE  IMAPIProfile
DECLARE_MAPI_INTERFACE_(IMAPIProfile, IUnknown)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPIPROFILE_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IMAPIProfile, LPMAPIPROF);

/* IPRProvider Interface Definition ---------------------------------------- */

/* For all methods */

/*#define MAPI_UNICODE			((ULONG) 0x80000000) in mapidefs.h */

/* For OpenProfile */

/* #define MAPI_LOGON_UI           0x00000001  Display logon UI          */
/* #define MAPI_EXPLICIT_PROFILE   0x00000010  Don't use default profile */
/* #define MAPI_USE_DEFAULT        0x00000040  Use default profile       */
/* #define MAPI_SERVICE_UI_ALWAYS  0x00002000  Do logon UI in all providers */
/* #define MAPI_PASSWORD_UI        0x00020000  Display password UI only  */

/* For DeleteProfile */
#define MAPI_DEFER_DELETE		0x00000001


#define MAPI_IPRPROVIDER_METHODS(IPURE)									\
	MAPIMETHOD(GetLastError)											\
		(THIS_	HRESULT						hResult,					\
				ULONG						ulFlags,					\
				LPMAPIERROR FAR *			lppMAPIError) IPURE;		\
	MAPIMETHOD(Shutdown)												\
		(THIS_	ULONG FAR *					lpulFlags) IPURE;			\
	MAPIMETHOD(OpenProfile)												\
		(THIS_	LPMAPISUP					lpMAPISup,					\
				LPTSTR FAR *				lppszProfileName,			\
				LPTSTR						lpszPassword,				\
				ULONG						ulSelectFlags,				\
				ULONG						ulUIParam,					\
				ULONG FAR *					lpulpcbSecurity,			\
				LPBYTE FAR *				lppbSecurity,				\
				ULONG FAR *					lpulSessionFlags,			\
				LPMAPIPROF FAR *			lppMAPIProf) IPURE;			\
	MAPIMETHOD(CreateProfile)											\
		(THIS_	LPTSTR						lpszProfileName,			\
				LPTSTR						lpszPassword,				\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(DeleteProfile)											\
		(THIS_	LPTSTR						lpszProfileName,			\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(ChangeProfilePassword)									\
		(THIS_	LPTSTR						lpszProfileName,			\
				LPTSTR						lpszOldPassword,			\
				LPTSTR						lpszNewPassword,			\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(GetProfileTable)											\
		(THIS_	ULONG						ulFlags,					\
				LPMAPITABLE FAR *			lppTable) IPURE;			\
	MAPIMETHOD(CopyProfile)												\
		(THIS_	LPTSTR						lpszOldProfileName,			\
				LPTSTR						lpszOldPassword,			\
				LPTSTR						lpszNewProfileName,			\
				ULONG						ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(RenameProfile)											\
		(THIS_	LPTSTR						lpszOldProfileName,			\
				LPTSTR						lpszOldPassword,			\
				LPTSTR						lpszNewProfileName,			\
				ULONG						ulUIParam,					\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(SetDefaultProfile)										\
		(THIS_	LPTSTR						lpszProfileName,			\
				ULONG						ulFlags) IPURE;				\
	MAPIMETHOD(ListDeferredDeletes)										\
		(THIS_	ULONG ulFlags,											\
				LPTSTR FAR *				lppszDeleted) IPURE;		\


#undef		 INTERFACE
#define		 INTERFACE  IPRProvider
DECLARE_MAPI_INTERFACE_(IPRProvider, IUnknown)
{
	BEGIN_INTERFACE	
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IPRPROVIDER_METHODS(PURE)
};

DECLARE_MAPI_INTERFACE_PTR(IPRProvider, LPPRPROVIDER);

/* Profile Provider Entry Point */

/* #define MAPI_NT_SERVICE	0x00010000	/* Allow logon from an NT service */

typedef HRESULT (STDMAPIINITCALLTYPE PRPROVIDERINIT)(
	HINSTANCE				hInstance,
	LPMALLOC				lpMalloc,			/* AddRef() if you keep it */
	LPALLOCATEBUFFER		lpAllocateBuffer,	/* -> AllocateBuffer */
	LPALLOCATEMORE			lpAllocateMore, 	/* -> AllocateMore   */
	LPFREEBUFFER			lpFreeBuffer, 		/* -> FreeBuffer     */
	ULONG					ulFlags,
	ULONG					ulMAPIVer,
	ULONG FAR *				lpulProviderVer,
	LPPRPROVIDER FAR *		lppPRProvider
);

PRPROVIDERINIT PRProviderInit;
typedef PRPROVIDERINIT FAR *LPPRPROVIDERINIT;

#endif	/* PROFILE_GUIDS_ONLY */

#if !defined(INITGUID) || defined(USES_IID_IPRProvider)
DEFINE_OLEGUID(IID_IPRProvider,			0x000203F6L, 0, 0);
#endif
#if !defined(INITGUID) || defined(USES_IID_IMAPIProfile)
DEFINE_OLEGUID(IID_IMAPIProfile,		0x000203F7L, 0, 0);
#endif

#endif	/* PROFSPI_H */

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\mapistub\mapistub\_mapiexp.h ===
#ifdef NEVER // comments for preprocessor but not to be passed to .def file
// EX_CDECL_NAME (exports CDECL by name)
// EX_STDAPI_NONDEC (exports STDAPI by nondecorated name if different from decorated)
// EX_STDAPI_DEC (exports STDAPI by decorated name)
// EX_STDAPI_ALLNON (exports STDAPI by nondecorated name)
// EX_WINAPI_NONDEC (exports WINAPI by nondecorated name if different from decorated)
// EX_WINAPI_DEC (exports WINAPI by decorated name)
// EX_WINAPI_ALLNON (exports WINAPI by nondecorated name)
#endif

#ifdef WIN32
#if !defined (_X86_)
#define EX_CDECL_NAME(szName)				szName
#define EX_STDAPI_NONDEC(szName,szSuffix)
#define EX_STDAPI_DEC(szName,szSuffix)		szName
#define EX_STDAPI_ALLNON(szName,szSuffix)	szName
#define EX_WINAPI_NONDEC(szName,szSuffix)
#define EX_WINAPI_DEC(szName,szSuffix)		szName
#define EX_WINAPI_ALLNON(szName,szSuffix)	szName
#else //Intel
#define EX_CDECL_NAME(szName)				szName
#define EX_STDAPI_NONDEC(szName,szSuffix)	szName = szName##@##szSuffix
#define EX_STDAPI_DEC(szName,szSuffix)		szName##@##szSuffix
#define EX_STDAPI_ALLNON(szName,szSuffix)	szName = szName##@##szSuffix
#define EX_WINAPI_NONDEC(szName,szSuffix)	szName = szName##@##szSuffix
#define EX_WINAPI_DEC(szName,szSuffix)		szName##@##szSuffix
#define EX_WINAPI_ALLNON(szName,szSuffix)	szName = szName##@##szSuffix
#endif // Intel vs nonIntel
#endif // Win32

#ifdef WIN16
#define EX_CDECL_NAME(szName)				_##szName
#define EX_STDAPI_NONDEC(szName,szSuffix)	szName = _##szName
#define EX_STDAPI_DEC(szName,szSuffix)		_##szName
#define EX_STDAPI_ALLNON(szName,szSuffix)	szName = _##szName
#define EX_WINAPI_NONDEC(szName,szSuffix)
#define EX_WINAPI_DEC(szName,szSuffix)		szName
#define EX_WINAPI_ALLNON(szName,szSuffix)	szName
#endif // Win16


#ifdef NEVER // comments for preprocessor but not to be passed to .def file
// The following macros expand out to include an ording in the export
// EX_CDECL_NAME_ORD (exports CDECL by name)
// EX_STDAPI_NONDEC_ORD (exports STDAPI by nondecorated name if different from decorated)
// EX_STDAPI_DEC_ORD (exports STDAPI by decorated name)
// EX_STDAPI_ALLNON_ORD (exports STDAPI by nondecorated name)
// EX_WINAPI_NONDEC_ORD (exports WINAPI by nondecorated name if different from decorated)
// EX_WINAPI_DEC_ORD (exports WINAPI by decorated name)
// EX_WINAPI_ALLNON_ORD (exports WINAPI by nondecorated name)
#endif

#ifdef WIN32
#if !defined (_X86_)
#define EX_CDECL_NAME_ORD(szName,ord)				szName	ord
#define EX_STDAPI_NONDEC_ORD(szName,szSuffix,ord)
#define EX_STDAPI_DEC_ORD(szName,szSuffix,ord)		szName	ord
#define EX_STDAPI_ALLNON_ORD(szName,szSuffix,ord)	szName	ord
#define EX_WINAPI_NONDEC_ORD(szName,szSuffix,ord)
#define EX_WINAPI_DEC_ORD(szName,szSuffix,ord)		szName	ord
#define EX_WINAPI_ALLNON_ORD(szName,szSuffix,ord)	szName	ord
#else //Intel
#define EX_CDECL_NAME_ORD(szName,ord)				szName	ord
#define EX_STDAPI_NONDEC_ORD(szName,szSuffix,ord)	szName = szName##@##szSuffix	ord
#define EX_STDAPI_DEC_ORD(szName,szSuffix,ord)		szName##@##szSuffix	ord
#define EX_STDAPI_ALLNON_ORD(szName,szSuffix,ord)	szName = szName##@##szSuffix	ord
#define EX_WINAPI_NONDEC_ORD(szName,szSuffix,ord)	szName = szName##@##szSuffix	ord
#define EX_WINAPI_DEC_ORD(szName,szSuffix,ord)		szName##@##szSuffix	ord
#define EX_WINAPI_ALLNON_ORD(szName,szSuffix,ord)	szName = szName##@##szSuffix	ord
#endif // Intel vs nonIntel
#endif // Win32

#ifdef WIN16
#define EX_CDECL_NAME_ORD(szName,ord)				_##szName	ord
#define EX_STDAPI_NONDEC_ORD(szName,szSuffix,ord)	szName = _##szName	ord
#define EX_STDAPI_DEC_ORD(szName,szSuffix,ord)		_##szName	ord
#define EX_STDAPI_ALLNON_ORD(szName,szSuffix,ord)	szName = _##szName	ord
#define EX_WINAPI_NONDEC_ORD(szName,szSuffix,ord)
#define EX_WINAPI_DEC_ORD(szName,szSuffix,ord)		szName	ord
#define EX_WINAPI_ALLNON_ORD(szName,szSuffix,ord)	szName	ord
#endif // Win16


#ifdef NEVER // comments for preprocessor but not to be passed to .def file
// GP_CDECL_NAME (GetProcAddress() string for exports CDECL by name)
// GP_STDAPI_NONDEC (GetProcAddress() string for exports STDAPI by nondecorated name)
// GP_STDAPI_DEC (GetProcAddress() string for exports STDAPI by decorated name)
// GP_STDAPI_ALLNON (GetProcAddress() string for exports STDAPI by nondecorated name)
// GP_WINAPI_NONDEC (GetProcAddress() string for exports WINAPI by nondecorated name)
// GP_WINAPI_DEC (GetProcAddress() string for exports WINAPI by decorated name)
// GP_WINAPI_ALLNON (GetProcAddress() string for exports WINAPI by nondecorated name)
#endif

#ifdef WIN32
#if !defined (_X86_)
#define GP_CDECL_NAME(szName)				# szName
#define GP_STDAPI_NONDEC(szName,szSuffix)	# szName
#define GP_STDAPI_DEC(szName,szSuffix)		# szName
#define GP_STDAPI_ALLNON(szName,szSuffix)	# szName
#define GP_WINAPI_NONDEC(szName,szSuffix)	# szName
#define GP_WINAPI_DEC(szName,szSuffix)		# szName
#define GP_WINAPI_ALLNON(szName,szSuffix)	# szName
#else //Intel
#define GP_CDECL_NAME(szName)				# szName
#define GP_STDAPI_NONDEC(szName,szSuffix)	# szName
#define GP_STDAPI_DEC(szName,szSuffix)		# szName "@" # szSuffix
#define GP_STDAPI_ALLNON(szName,szSuffix)	# szName
#define GP_WINAPI_NONDEC(szName,szSuffix)	# szName
#define GP_WINAPI_DEC(szName,szSuffix)		# szName "@" # szSuffix
#define GP_WINAPI_ALLNON(szName,szSuffix)	# szName
#endif // Intel vs nonIntel
#endif // Win32

#ifdef WIN16
#define GP_CDECL_NAME(szName)				"_" # szName
#define GP_STDAPI_NONDEC(szName,szSuffix)	# szName
#define GP_STDAPI_DEC(szName,szSuffix)		"_" # szName
#define GP_STDAPI_ALLNON(szName,szSuffix)	# szName
#define GP_WINAPI_NONDEC(szName,szSuffix)	# szName
#define GP_WINAPI_DEC(szName,szSuffix)		# szName
#define GP_WINAPI_ALLNON(szName,szSuffix)	# szName
#endif // Win16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\mapistub\mapistub\structs.h ===
/*
 *	STRUCTS.H
 *	
 *	Structures defining method parameters for validation sub-system
 */

#ifndef STRUCTS_H
#define STRUCTS_H

#if defined(_MIPS_) || defined(_PPC_) || defined(_ALPHA_) || defined(_MAC)
#define LARGE_INTEGER_ARG		LARGE_INTEGER
#define LARGE_INTEGER_ARG_2		LARGE_INTEGER
#define ULARGE_INTEGER_ARG		ULARGE_INTEGER
#define ULARGE_INTEGER_ARG_2	ULARGE_INTEGER
#else
#define LARGE_INTEGER_ARG		LPVOID	XXXX; LPVOID
#define LARGE_INTEGER_ARG_2		LPVOID	YYYY; LPVOID
#define ULARGE_INTEGER_ARG		LPVOID  XXXX; LPVOID
#define ULARGE_INTEGER_ARG_2	LPVOID  YYYY; LPVOID
#endif

/*
 * These structures represent the parameters for the appropriate functions as they
 * appear on the stack.  
 *
 * The WIN16 stack is laid out differently, and has the parameters in the reverse order.
 *
 * Our __ValidateParameters function decides passes a pointer to the stack at the start of 
 * the parameter list, and the type of the Validation routines parameter determines
 * what values it has to check.  These values do not change between platforms.
 *
 * If parameters to a method change, the structure must be updated to reflect the change.
 *
 * The names of the Typedefs are important as other things are generated based on these
 * names.
 *
 * Notes for WX86_MAPISTUB:
 *
 * The names of the *_Thunk variables are important too. See msvalidp.h for
 * their use. 
 *
 * We thunk only the IN arguments since the validation functions are intended
 * to be called at the start of the function; the output arguments have not 
 * yet been filled in. The validation functions are in msvalid.c; in general
 * they do not validate or refer to This, so we do not thunk it. See 
 * ..\mapistub\mapi32.cpp for details on thunking.
 *
 */

/* Keystroke Macros to convert method in MAPIDEFS.H to structure here 
 *
 * 1. Convert MAPIMETHOD(XXX) to typedef struct _tagXXX_Params (search for ')')
 * 2. For each line, find comma, replace with ; and delete to end of line
 * 3. Start on typedef line, read XXX, search for IPURE, replace preceding )
 *	  with ;, add new line, generate } XXX_params, FAR * LPXXXParams;
 * 4. Change (THIS_ to LPVOID This;, split line
 *
 */
 

/****************** IUnknown *********************/
typedef struct _tagIUnknown_QueryInterface_Params
{
				LPVOID						This;	
				REFIID						iidInterface;
				LPVOID						lppNewObject;
} IUnknown_QueryInterface_Params, FAR * LPIUnknown_QueryInterface_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IUnknown_QueryInterface_Thunk = NULL;

#endif

typedef struct _tagIUnknown_AddRef_Params
{
				LPVOID						This;	
} IUnknown_AddRef_Params, FAR * LPIUnknown_AddRef_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IUnknown_AddRef_Thunk = NULL;

#endif

typedef struct _tagIUnknown_Release_Params
{
				LPVOID						This;	
} IUnknown_Release_Params, FAR * LPIUnknown_Release_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IUnknown_Release_Thunk = NULL;

#endif


/* AddRef and Release take no parameters */ 
 
/***************** IMAPIProp *********************/

typedef struct _tagIMAPIProp_GetLastError_Params
{
				LPVOID						This;	
				HRESULT						hResult;
				ULONG						ulFlags;
				LPMAPIERROR FAR *			lppMAPIError;
} IMAPIProp_GetLastError_Params, FAR * LPIMAPIProp_GetLastError_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIProp_GetLastError_Thunk = NULL;

#endif

typedef struct _tagIMAPIProp_SaveChanges_Params
{
				LPVOID						This; 
				ULONG						ulFlags;
} IMAPIProp_SaveChanges_Params, FAR * LPIMAPIProp_SaveChanges_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIProp_SaveChanges_Thunk = NULL;

#endif


/* GetProps --------------------------------------------------------- */
typedef struct _tagIMAPIProp_GetProps_Params
{
	LPVOID				This;
	LPSPropTagArray		lpPropTagArray;
	ULONG				ulFlags;
	ULONG FAR *			lpcValues;
	LPSPropValue FAR *	lppPropArray;
} IMAPIProp_GetProps_Params, FAR * LPIMAPIProp_GetProps_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIProp_GetProps_Thunk = NULL;

#endif


typedef struct _tagIMAPIProp_GetPropList_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPSPropTagArray FAR *		lppPropTagArray;
} IMAPIProp_GetPropList_Params, FAR * LPIMAPIProp_GetPropList_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIProp_GetPropList_Thunk = NULL;

#endif
				
typedef struct _tagIMAPIProp_OpenProperty_Params
{
				LPVOID						This;	
				ULONG						ulPropTag;
				LPIID						lpiid;
				ULONG						ulInterfaceOptions;
				ULONG						ulFlags;
				LPUNKNOWN FAR *				lppUnk;
} IMAPIProp_OpenProperty_Params, FAR * LPIMAPIProp_OpenProperty_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIProp_OpenProperty_Thunk = NULL;

#endif

/* SetProps --------------------------------------------------------- */
typedef struct _tagIMAPIProp_SetProps_Params
{
	LPVOID				This;
	ULONG				cValues;
	LPSPropValue 		lpPropArray;
	LPSPropProblemArray FAR *	lppProblems;
} IMAPIProp_SetProps_Params, FAR * LPIMAPIProp_SetProps_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIProp_SetProps_Thunk = NULL;

#endif


typedef struct _tagIMAPIProp_DeleteProps_Params
{
				LPVOID						This;	
				LPSPropTagArray				lpPropTagArray;
				LPSPropProblemArray FAR *	lppProblems;
} IMAPIProp_DeleteProps_Params, FAR * LPIMAPIProp_DeleteProps_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIProp_DeleteProps_Thunk = NULL;

#endif
				
typedef struct _tagIMAPIProp_CopyTo_Params
{
				LPVOID						This;	
				ULONG						ciidExclude;
				LPIID						rgiidExclude;
				LPSPropTagArray				lpExcludeProps;
				ULONG						ulUIParam;
				LPMAPIPROGRESS 				lpProgress;
				LPIID						lpInterface;
				LPVOID						lpDestObj;
				ULONG						ulFlags;
				LPSPropProblemArray FAR *	lppProblems;
} IMAPIProp_CopyTo_Params, FAR * LPIMAPIProp_CopyTo_Params;

#if defined (WX86_MAPISTUB)

// @@@@ lpDestObj is an IN interface pointer?

Wx86MapiArgThunkInfo IMAPIProp_CopyTo_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 5, 0, &IID_IMAPIProgress},
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 7, 6, NULL},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMAPIProp_CopyTo_Thunk = IMAPIProp_CopyTo_ThunkArgs;

#endif
				
typedef struct _tagIMAPIProp_CopyProps_Params
{
				LPVOID						This;	
				LPSPropTagArray				lpIncludeProps;
				ULONG						ulUIParam;
				LPMAPIPROGRESS 				lpProgress;
				LPIID						lpInterface;
				LPVOID						lpDestObj;
				ULONG						ulFlags;
				LPSPropProblemArray FAR *	lppProblems;
} IMAPIProp_CopyProps_Params, FAR * LPIMAPIProp_CopyProps_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMAPIProp_CopyProps_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 3, 0, &IID_IMAPIProgress},
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 5, 4, NULL},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMAPIProp_CopyProps_Thunk = IMAPIProp_CopyProps_ThunkArgs;

#endif
				
typedef struct _tagIMAPIProp_GetNamesFromIDs_Params
{
				LPVOID						This;	
				LPSPropTagArray FAR *		lppPropTags;
				LPGUID						lpPropSetGuid;
				ULONG						ulFlags;
				ULONG FAR *					lpcPropNames;
				LPMAPINAMEID FAR * FAR *	lpppPropNames;
} IMAPIProp_GetNamesFromIDs_Params, FAR * LPIMAPIProp_GetNamesFromIDs_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIProp_GetNamesFromIDs_Thunk = NULL;

#endif
				
typedef struct _tagIMAPIProp_GetIDsFromNames_Params
{
				LPVOID						This;	
				ULONG						cPropNames;
				LPMAPINAMEID FAR *			lppPropNames;
				ULONG						ulFlags;
				LPSPropTagArray FAR *		lppPropTags;
} IMAPIProp_GetIDsFromNames_Params, FAR * LPIMAPIProp_GetIDsFromNames_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIProp_GetIDsFromNames_Thunk = NULL;

#endif


/********************* IMAPITable **************************************/

typedef struct _tagIMAPITable_GetLastError_Params
{
				LPVOID						This;	
				HRESULT						hResult;
				ULONG						ulFlags;
				LPMAPIERROR FAR *			lppMAPIError;
} IMAPITable_GetLastError_Params, FAR * LPIMAPITable_GetLastError_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_GetLastError_Thunk = NULL;

#endif

typedef struct _tagIMAPITable_Advise_Params
{
				LPVOID						This;	
				ULONG						ulEventMask;
				LPMAPIADVISESINK			lpAdviseSink;
				ULONG FAR *					lpulConnection;
} IMAPITable_Advise_Params, FAR * LPIMAPITable_Advise_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMAPITable_Advise_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 2, 0, &IID_IMAPIAdviseSink},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMAPITable_Advise_Thunk = IMAPITable_Advise_ThunkArgs;

#endif


typedef struct _tagIMAPITable_Unadvise_Params
{
				LPVOID						This;	
				ULONG						ulConnection;
} IMAPITable_Unadvise_Params, FAR * LPIMAPITable_Unadvise_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_Unadvise_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_GetStatus_Params
{
				LPVOID						This;	
				ULONG FAR *					lpulTableStatus;
				ULONG FAR *					lpulTableType;
} IMAPITable_GetStatus_Params, FAR * LPIMAPITable_GetStatus_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_GetStatus_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_SetColumns_Params
{
				LPVOID						This;	
				LPSPropTagArray				lpPropTagArray;
				ULONG						ulFlags;
} IMAPITable_SetColumns_Params, FAR * LPIMAPITable_SetColumns_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_SetColumns_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_QueryColumns_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPSPropTagArray FAR *		lpPropTagArray;
} IMAPITable_QueryColumns_Params, FAR * LPIMAPITable_QueryColumns_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_QueryColumns_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_GetRowCount_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				ULONG FAR *					lpulCount;
} IMAPITable_GetRowCount_Params, FAR * LPIMAPITable_GetRowCount_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_GetRowCount_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_SeekRow_Params
{
				LPVOID						This;	
				BOOKMARK					bkOrigin;
				LONG						lRowCount;
				LONG FAR *					lplRowsSought;
} IMAPITable_SeekRow_Params, FAR * LPIMAPITable_SeekRow_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_SeekRow_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_SeekRowApprox_Params
{
				LPVOID						This;	
				ULONG						ulNumerator;
				ULONG						ulDenominator;
} IMAPITable_SeekRowApprox_Params, FAR * LPIMAPITable_SeekRowApprox_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_SeekRowApprox_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_QueryPosition_Params
{
				LPVOID						This;	
				ULONG FAR *					lpulRow;
				ULONG FAR *					lpulNumerator;
				ULONG FAR *					lpulDenominator;
} IMAPITable_QueryPosition_Params, FAR * LPIMAPITable_QueryPosition_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_QueryPosition_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_FindRow_Params
{
				LPVOID						This;	
				LPSRestriction				lpRestriction;
				BOOKMARK					bkOrigin;
				ULONG						ulFlags;
} IMAPITable_FindRow_Params, FAR * LPIMAPITable_FindRow_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_FindRow_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_Restrict_Params
{
				LPVOID						This;	
				LPSRestriction				lpRestriction;
				ULONG						ulFlags;
} IMAPITable_Restrict_Params, FAR * LPIMAPITable_Restrict_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_Restrict_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_CreateBookmark_Params
{
				LPVOID						This;	
				BOOKMARK FAR *				lpbkPosition;
} IMAPITable_CreateBookmark_Params, FAR * LPIMAPITable_CreateBookmark_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_CreateBookmark_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_FreeBookmark_Params
{
				LPVOID						This;	
				BOOKMARK					bkPosition;
} IMAPITable_FreeBookmark_Params, FAR * LPIMAPITable_FreeBookmark_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_FreeBookmark_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_SortTable_Params
{
				LPVOID						This;	
				LPSSortOrderSet				lpSortCriteria;
				ULONG						ulFlags;
} IMAPITable_SortTable_Params, FAR * LPIMAPITable_SortTable_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_SortTable_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_QuerySortOrder_Params
{
				LPVOID						This;	
				LPSSortOrderSet FAR *		lppSortCriteria;
} IMAPITable_QuerySortOrder_Params, FAR * LPIMAPITable_QuerySortOrder_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_QuerySortOrder_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_QueryRows_Params
{
				LPVOID						This;	
				LONG						lRowCount;
				ULONG						ulFlags;
				LPSRowSet FAR *				lppRows;
} IMAPITable_QueryRows_Params, FAR * LPIMAPITable_QueryRows_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_QueryRows_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_Abort_Params
{
				LPVOID						This;
} IMAPITable_Abort_Params, FAR * LPIMAPITable_Abort_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_Abort_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_ExpandRow_Params
{
				LPVOID						This;	
				ULONG						cbInstanceKey;
				LPBYTE						pbInstanceKey;
				ULONG						ulRowCount;
				ULONG						ulFlags;
				LPSRowSet FAR *				lppRows;
				ULONG FAR *					lpulMoreRows;
} IMAPITable_ExpandRow_Params, FAR * LPIMAPITable_ExpandRow_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_ExpandRow_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_CollapseRow_Params
{
				LPVOID						This;	
				ULONG						cbInstanceKey;
				LPBYTE						pbInstanceKey;
				ULONG						ulFlags;
				ULONG FAR *					lpulRowCount;
} IMAPITable_CollapseRow_Params, FAR * LPIMAPITable_CollapseRow_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_CollapseRow_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_WaitForCompletion_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				ULONG						ulTimeout;
				ULONG FAR *					lpulTableStatus;
} IMAPITable_WaitForCompletion_Params, FAR * LPIMAPITable_WaitForCompletion_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_WaitForCompletion_Thunk = NULL;

#endif


typedef struct _tagIMAPITable_GetCollapseState_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				ULONG						cbInstanceKey;
				LPBYTE						lpbInstanceKey;
				ULONG FAR *					lpcbCollapseState;
				LPBYTE FAR *				lppbCollapseState;
} IMAPITable_GetCollapseState_Params, FAR * LPIMAPITable_GetCollapseState_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_GetCollapseState_Thunk = NULL;

#endif
				
typedef struct _tagIMAPITable_SetCollapseState_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				ULONG						cbCollapseState;
				LPBYTE						pbCollapseState;
				BOOKMARK FAR *				lpbkLocation;
} IMAPITable_SetCollapseState_Params, FAR * LPIMAPITable_SetCollapseState_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_SetCollapseState_Thunk = NULL;

#endif



/********************* IMAPIStatus *************************************/

typedef struct _tagIMAPIStatus_ValidateState_Params
{
				LPVOID						This;
				ULONG						ulUIParam;
				ULONG						ulFlags;
} IMAPIStatus_ValidateState_Params, FAR * LPIMAPIStatus_ValidateState_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIStatus_ValidateState_Thunk = NULL;

#endif
				
typedef struct _tagIMAPIStatus_SettingsDialog_Params
{
				LPVOID						This;
				ULONG						ulUIParam;
				ULONG						ulFlags;
} IMAPIStatus_SettingsDialog_Params, FAR * LPIMAPIStatus_SettingsDialog_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIStatus_SettingsDialog_Thunk = NULL;

#endif
				
typedef struct _tagIMAPIStatus_ChangePassword_Params
{
				LPVOID						This;
				LPTSTR						lpOldPass;
				LPTSTR						lpNewPass;
				ULONG						ulFlags;
} IMAPIStatus_ChangePassword_Params, FAR * LPIMAPIStatus_ChangePassword_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIStatus_ChangePassword_Thunk = NULL;

#endif
				
typedef struct _tagIMAPIStatus_FlushQueues_Params
{
				LPVOID						This;
				ULONG						ulUIParam;
				ULONG						cbTargetTransport;
				LPENTRYID					lpTargetTransport;
				ULONG						ulFlags;
} IMAPIStatus_FlushQueues_Params, FAR * LPIMAPIStatus_FlushQueues_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIStatus_FlushQueues_Thunk = NULL;

#endif


/******************** IMAPIContainer ***********************************/


typedef struct _tagIMAPIContainer_GetContentsTable_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPMAPITABLE FAR *			lppTable;
} IMAPIContainer_GetContentsTable_Params, FAR * LPIMAPIContainer_GetContentsTable_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIContainer_GetContentsTable_Thunk = NULL;

#endif


typedef struct _tagIMAPIContainer_GetHierarchyTable_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPMAPITABLE FAR *			lppTable;
} IMAPIContainer_GetHierarchyTable_Params, FAR * LPIMAPIContainer_GetHierarchyTable_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIContainer_GetHierarchyTable_Thunk = NULL;

#endif


typedef struct _tagIMAPIContainer_OpenEntry_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				LPIID						lpInterface;
				ULONG						ulFlags;
				ULONG FAR *					lpulObjType;
				LPUNKNOWN FAR *				lppUnk;
} IMAPIContainer_OpenEntry_Params, FAR * LPIMAPIContainer_OpenEntry_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIContainer_OpenEntry_Thunk = NULL;

#endif


typedef struct _tagIMAPIContainer_SetSearchCriteria_Params
{
				LPVOID						This;	
				LPSRestriction				lpRestriction;
				LPENTRYLIST					lpContainerList;
				ULONG						ulSearchFlags;
} IMAPIContainer_SetSearchCriteria_Params, FAR * LPIMAPIContainer_SetSearchCriteria_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIContainer_SetSearchCriteria_Thunk = NULL;

#endif


typedef struct _tagIMAPIContainer_GetSearchCriteria_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPSRestriction FAR *		lppRestriction;
				LPENTRYLIST FAR *			lppContainerList;
				ULONG FAR *					lpulSearchState;
} IMAPIContainer_GetSearchCriteria_Params, FAR * LPIMAPIContainer_GetSearchCriteria_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIContainer_GetSearchCriteria_Thunk = NULL;

#endif



/****************************** IABContainer *****************************/


typedef struct _tagIABContainer_CreateEntry_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulFlags;
				LPMAPIPROP FAR	*			lppMAPIPropEntry;
} IABContainer_CreateEntry_Params, FAR * LPIABContainer_CreateEntry_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IABContainer_CreateEntry_Thunk = NULL;

#endif


typedef struct _tagIABContainer_CopyEntries_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpEntries;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IABContainer_CopyEntries_Params, FAR * LPIABContainer_CopyEntries_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IABContainer_CopyEntries_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 3, 0, &IID_IMAPIProgress},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IABContainer_CopyEntries_Thunk = IABContainer_CopyEntries_ThunkArgs;

#endif


typedef struct _tagIABContainer_DeleteEntries_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpEntries;
				ULONG						ulFlags;
} IABContainer_DeleteEntries_Params, FAR * LPIABContainer_DeleteEntries_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IABContainer_DeleteEntries_Thunk = NULL;

#endif

typedef struct _tagIABContainer_ResolveNames_Params
{
				LPVOID						This;
				LPSPropTagArray				lpPropTagArray;
				ULONG						ulFlags;
				LPADRLIST					lpMods;
				LPFlagList					lpFlagList;
} IABContainer_ResolveNames_Params, FAR * LPIABContainer_ResolveNames_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IABContainer_ResolveNames_Thunk = NULL;

#endif

/*************************** IDistList ***********************************/


typedef struct _tagIDistList_CreateEntry_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulCreateFlags;
				LPMAPIPROP FAR	*			lppMAPIPropEntry;
} IDistList_CreateEntry_Params, FAR * LPIDistList_CreateEntry_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IDistList_CreateEntry_Thunk = NULL;

#endif


typedef struct _tagIDistList_CopyEntries_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpEntries;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IDistList_CopyEntries_Params, FAR * LPIDistList_CopyEntries_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IDistList_CopyEntries_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 3, 0, &IID_IMAPIProgress},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IDistList_CopyEntries_Thunk = IDistList_CopyEntries_ThunkArgs;

#endif


typedef struct _tagIDistList_DeleteEntries_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpEntries;
				ULONG						ulFlags;
} IDistList_DeleteEntries_Params, FAR * LPIDistList_DeleteEntries_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IDistList_DeleteEntries_Thunk = NULL;

#endif

typedef struct _tagIDistList_ResolveNames_Params
{
				LPVOID						This;
				LPSPropTagArray				lpPropTagArray;
				ULONG						ulFlags;
				LPADRLIST					lpMods;
				LPFlagList					lpFlagList;
} IDistList_ResolveNames_Params, FAR * LPIDistList_ResolveNames_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IDistList_ResolveNames_Thunk = NULL;

#endif

/**************************** IMAPIFolder *******************************/

typedef struct _tagIMAPIFolder_CreateMessage_Params
{
				LPVOID						This;	
				LPIID						lpInterface;
				ULONG						ulFlags;
				LPMESSAGE FAR *				lppMessage;
} IMAPIFolder_CreateMessage_Params, FAR * LPIMAPIFolder_CreateMessage_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIFolder_CreateMessage_Thunk = NULL;

#endif


typedef struct _tagIMAPIFolder_CopyMessages_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpMsgList;
			   	LPIID						lpInterface;
				LPVOID						lpDestFolder;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMAPIFolder_CopyMessages_Params, FAR * LPIMAPIFolder_CopyMessages_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMAPIFolder_CopyMessages_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 3, 2, &IID_IMAPIFolder},
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 5, 0, &IID_IMAPIProgress},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMAPIFolder_CopyMessages_Thunk = IMAPIFolder_CopyMessages_ThunkArgs;

#endif


typedef struct _tagIMAPIFolder_DeleteMessages_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpMsgList;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMAPIFolder_DeleteMessages_Params, FAR * LPIMAPIFolder_DeleteMessages_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMAPIFolder_DeleteMessages_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 3, 0, &IID_IMAPIProgress},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMAPIFolder_DeleteMessages_Thunk = IMAPIFolder_DeleteMessages_ThunkArgs;

#endif


typedef struct _tagIMAPIFolder_CreateFolder_Params
{
				LPVOID						This;	
				ULONG						ulFolderType;
				LPTSTR						lpszFolderName;
				LPTSTR						lpszFolderComment;
				LPIID						lpInterface;
				ULONG						ulFlags;
				LPMAPIFOLDER FAR *			lppFolder;
} IMAPIFolder_CreateFolder_Params, FAR * LPIMAPIFolder_CreateFolder_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIFolder_CreateFolder_Thunk = NULL;

#endif


typedef struct _tagIMAPIFolder_CopyFolder_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
			   	LPIID						lpInterface;
				LPVOID						lpDestFolder;
				LPTSTR						lpszNewFolderName;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMAPIFolder_CopyFolder_Params, FAR * LPIMAPIFolder_CopyFolder_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMAPIFolder_CopyFolder_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 4, 3, &IID_IMAPIFolder},
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 7, 0, &IID_IMAPIProgress},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMAPIFolder_CopyFolder_Thunk = IMAPIFolder_CopyFolder_ThunkArgs;

#endif


typedef struct _tagIMAPIFolder_DeleteFolder_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMAPIFolder_DeleteFolder_Params, FAR * LPIMAPIFolder_DeleteFolder_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMAPIFolder_DeleteFolder_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 4, 0, &IID_IMAPIProgress},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMAPIFolder_DeleteFolder_Thunk = IMAPIFolder_DeleteFolder_ThunkArgs;

#endif


typedef struct _tagIMAPIFolder_SetReadFlags_Params
{
				LPVOID						This;	
				LPENTRYLIST					lpMsgList;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMAPIFolder_SetReadFlags_Params, FAR * LPIMAPIFolder_SetReadFlags_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMAPIFolder_SetReadFlags_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 3, 0, &IID_IMAPIProgress},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMAPIFolder_SetReadFlags_Thunk = IMAPIFolder_SetReadFlags_ThunkArgs;

#endif


typedef struct _tagIMAPIFolder_GetMessageStatus_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulFlags;
				ULONG FAR *					lpulMessageStatus;
} IMAPIFolder_GetMessageStatus_Params, FAR * LPIMAPIFolder_GetMessageStatus_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIFolder_GetMessageStatus_Thunk = NULL;

#endif


typedef struct _tagIMAPIFolder_SetMessageStatus_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulNewStatus;
				ULONG						ulNewStatusMask;
				ULONG FAR *					lpulOldStatus;
} IMAPIFolder_SetMessageStatus_Params, FAR * LPIMAPIFolder_SetMessageStatus_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIFolder_SetMessageStatus_Thunk = NULL;

#endif


typedef struct _tagIMAPIFolder_SaveContentsSort_Params
{
				LPVOID						This;	
				LPSSortOrderSet				lpSortCriteria;
				ULONG						ulFlags;
} IMAPIFolder_SaveContentsSort_Params, FAR * LPIMAPIFolder_SaveContentsSort_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIFolder_SaveContentsSort_Thunk = NULL;

#endif


typedef struct _tagIMAPIFolder_EmptyFolder_Params
{
				LPVOID						This;	
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMAPIFolder_EmptyFolder_Params, FAR * LPIMAPIFolder_EmptyFolder_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMAPIFolder_EmptyFolder_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 2, 0, &IID_IMAPIProgress},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMAPIFolder_EmptyFolder_Thunk = IMAPIFolder_EmptyFolder_ThunkArgs;

#endif



/**************************** IMsgStore **********************************/

typedef struct _tagIMsgStore_Advise_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulEventMask;
				LPMAPIADVISESINK			lpAdviseSink;
				ULONG FAR *					lpulConnection;
} IMsgStore_Advise_Params, FAR * LPIMsgStore_Advise_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMsgStore_Advise_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 4, 0, &IID_IMAPIAdviseSink},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMsgStore_Advise_Thunk = IMsgStore_Advise_ThunkArgs;

#endif


typedef struct _tagIMsgStore_Unadvise_Params
{
				LPVOID						This;	
				ULONG						ulConnection;
} IMsgStore_Unadvise_Params, FAR * LPIMsgStore_Unadvise_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMsgStore_Unadvise_Thunk = NULL;

#endif


typedef struct _tagIMsgStore_CompareEntryIDs_Params
{
				LPVOID						This;	
				ULONG						cbEntryID1;
				LPENTRYID					lpEntryID1;
				ULONG						cbEntryID2;
				LPENTRYID					lpEntryID2;
				ULONG						ulFlags;
				ULONG FAR *					lpulResult;
} IMsgStore_CompareEntryIDs_Params, FAR * LPIMsgStore_CompareEntryIDs_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMsgStore_CompareEntryIDs_Thunk = NULL;

#endif

typedef struct _tagIMsgStore_OpenEntry_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				LPIID						lpInterface;
				ULONG						ulFlags;
				ULONG FAR *					lpulObjType;
				LPUNKNOWN FAR *				lppUnk;
} IMsgStore_OpenEntry_Params, FAR * LPIMsgStore_OpenEntry_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMsgStore_OpenEntry_Thunk = NULL;

#endif



typedef struct _tagIMsgStore_SetReceiveFolder_Params
{
				LPVOID						This;	
				LPTSTR						lpszMessageClass;
				ULONG						ulFlags;
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
} IMsgStore_SetReceiveFolder_Params, FAR * LPIMsgStore_SetReceiveFolder_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMsgStore_SetReceiveFolder_Thunk = NULL;

#endif


typedef struct _tagIMsgStore_GetReceiveFolder_Params
{
				LPVOID						This;	
				LPTSTR						lpszMessageClass;
				ULONG						ulFlags;
				ULONG FAR *					lpcbEntryID;
				LPENTRYID FAR *				lppEntryID;
				LPTSTR FAR *				lppszExplicitClass;
} IMsgStore_GetReceiveFolder_Params, FAR * LPIMsgStore_GetReceiveFolder_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMsgStore_GetReceiveFolder_Thunk = NULL;

#endif


typedef struct _tagIMsgStore_GetReceiveFolderTable_Params
{
				LPVOID						This;
				ULONG						ulFlags;
				LPMAPITABLE FAR *			lppTable;
} IMsgStore_GetReceiveFolderTable_Params, FAR * LPIMsgStore_GetReceiveFolderTable_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMsgStore_GetReceiveFolderTable_Thunk = NULL;

#endif


typedef struct _tagIMsgStore_StoreLogoff_Params
{
				LPVOID						This;	
				ULONG FAR *					lpulFlags;
} IMsgStore_StoreLogoff_Params, FAR * LPIMsgStore_StoreLogoff_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMsgStore_StoreLogoff_Thunk = NULL;

#endif


typedef struct _tagIMsgStore_AbortSubmit_Params
{
				LPVOID						This;	
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulFlags;
} IMsgStore_AbortSubmit_Params, FAR * LPIMsgStore_AbortSubmit_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMsgStore_AbortSubmit_Thunk = NULL;

#endif


typedef struct _tagIMsgStore_GetOutgoingQueue_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPMAPITABLE FAR *			lppTable;
} IMsgStore_GetOutgoingQueue_Params, FAR * LPIMsgStore_GetOutgoingQueue_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMsgStore_GetOutgoingQueue_Thunk = NULL;

#endif


typedef struct _tagIMsgStore_SetLockState_Params
{
				LPVOID						This;	
				LPMESSAGE					lpMessage;
				ULONG						ulLockState;
} IMsgStore_SetLockState_Params, FAR * LPIMsgStore_SetLockState_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMsgStore_SetLockState_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 1, 0, &IID_IMessage},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMsgStore_SetLockState_Thunk = IMsgStore_SetLockState_ThunkArgs;

#endif


typedef struct _tagIMsgStore_FinishedMsg_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
} IMsgStore_FinishedMsg_Params, FAR * LPIMsgStore_FinishedMsg_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMsgStore_FinishedMsg_Thunk = NULL;

#endif


typedef struct _tagIMsgStore_NotifyNewMail_Params
{
				LPVOID						This;	
				LPNOTIFICATION				lpNotification;
} IMsgStore_NotifyNewMail_Params, FAR * LPIMsgStore_NotifyNewMail_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMsgStore_NotifyNewMail_Thunk = NULL;

#endif



/*************************** IMessage ***********************************/

typedef struct _tagIMessage_GetAttachmentTable_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPMAPITABLE FAR *			lppTable;
} IMessage_GetAttachmentTable_Params, FAR * LPIMessage_GetAttachmentTable_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMessage_GetAttachmentTable_Thunk = NULL;

#endif


typedef struct _tagIMessage_OpenAttach_Params
{
				LPVOID						This;	
				ULONG						ulAttachmentNum;
				LPIID						lpInterface;
				ULONG						ulFlags;
				LPATTACH FAR *				lppAttach;
} IMessage_OpenAttach_Params, FAR * LPIMessage_OpenAttach_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMessage_OpenAttach_Thunk = NULL;

#endif


typedef struct _tagIMessage_CreateAttach_Params
{
				LPVOID						This;	
				LPIID						lpInterface;
				ULONG						ulFlags;
				ULONG FAR *					lpulAttachmentNum;
				LPATTACH FAR *				lppAttach;
} IMessage_CreateAttach_Params, FAR * LPIMessage_CreateAttach_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMessage_CreateAttach_Thunk = NULL;

#endif


typedef struct _tagIMessage_DeleteAttach_Params
{
				LPVOID						This;	
				ULONG						ulAttachmentNum;
				ULONG						ulUIParam;
				LPMAPIPROGRESS				lpProgress;
				ULONG						ulFlags;
} IMessage_DeleteAttach_Params, FAR * LPIMessage_DeleteAttach_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMessage_DeleteAttach_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 3, 0, &IID_IMAPIProgress},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMessage_DeleteAttach_Thunk = IMessage_DeleteAttach_ThunkArgs;

#endif


typedef struct _tagIMessage_GetRecipientTable_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPMAPITABLE FAR *			lppTable;
} IMessage_GetRecipientTable_Params, FAR * LPIMessage_GetRecipientTable_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMessage_GetRecipientTable_Thunk = NULL;

#endif


typedef struct _tagIMessage_ModifyRecipients_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
				LPADRLIST					lpMods;
} IMessage_ModifyRecipients_Params, FAR * LPIMessage_ModifyRecipients_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMessage_ModifyRecipients_Thunk = NULL;

#endif


typedef struct _tagIMessage_SubmitMessage_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
} IMessage_SubmitMessage_Params, FAR * LPIMessage_SubmitMessage_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMessage_SubmitMessage_Thunk = NULL;

#endif


typedef struct _tagIMessage_SetReadFlag_Params
{
				LPVOID						This;	
				ULONG						ulFlags;
} IMessage_SetReadFlag_Params, FAR * LPIMessage_SetReadFlag_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMessage_SetReadFlag_Thunk = NULL;

#endif


/************************ IABProvider ***********************************/

typedef struct _tagIABProvider_Shutdown_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
} IABProvider_Shutdown_Params, FAR * LPIABProvider_Shutdown_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IABProvider_Shutdown_Thunk = NULL;

#endif

typedef struct _tagIABProvider_Logon_Params
{
        		LPVOID						This;
        		LPMAPISUP                   lpMAPISup;
                ULONG                       ulUIParam;
                LPTSTR                      lpszProfileName;
                ULONG                       ulFlags;
				ULONG FAR *					lpulpcbSecurity;
				LPBYTE FAR *				lppbSecurity;
                LPMAPIERROR FAR *			lppMapiError;
                LPABLOGON FAR *             lppABLogon;
} IABProvider_Logon_Params, FAR * LPIABProvider_Logon_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IABProvider_Logon_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 1, 0, &IID_IMAPISup},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IABProvider_Logon_Thunk = IABProvider_Logon_ThunkArgs;

#endif


/************************* IABLogon *************************************/

typedef struct _tagIABLogon_GetLastError_Params
{
				LPVOID						This;
				HRESULT						hResult;
				ULONG						ulFlags;
				LPMAPIERROR FAR *			lppMAPIError;
} IABLogon_GetLastError_Params, FAR * LPIABLogon_GetLastError_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IABLogon_GetLastError_Thunk = NULL;

#endif

typedef struct _tagIABLogon_Logoff_Params
{
				LPVOID						This;
				ULONG						ulFlags;
} IABLogon_Logoff_Params, FAR * LPIABLogon_Logoff_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IABLogon_Logoff_Thunk = NULL;

#endif

typedef struct _tagIABLogon_OpenEntry_Params
{
        		LPVOID						This;
        		ULONG                       cbEntryID;
                LPENTRYID                   lpEntryID;
                LPIID                       lpInterface;
                ULONG                       ulFlags;
                ULONG FAR *                 lpulObjType;
				LPUNKNOWN FAR *				lppUnk;
} IABLogon_OpenEntry_Params, FAR * LPIABLogon_OpenEntry_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IABLogon_OpenEntry_Thunk = NULL;

#endif

typedef struct _tagIABLogon_CompareEntryIDs_Params
{
        		LPVOID						This;
        		ULONG                       cbEntryID1;
                LPENTRYID                   lpEntryID1;
                ULONG                       cbEntryID2;
                LPENTRYID                   lpEntryID2;
                ULONG                       ulFlags;
                ULONG FAR *                 lpulResult;
} IABLogon_CompareEntryIDs_Params, FAR * LPIABLogon_CompareEntryIDs_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IABLogon_CompareEntryIDs_Thunk = NULL;

#endif

typedef struct _tagIABLogon_Advise_Params
{
        		LPVOID						This;
        		ULONG                       cbEntryID;
                LPENTRYID                   lpEntryID;
                ULONG                       ulEventMask;
				LPMAPIADVISESINK			lpAdviseSink;
				ULONG FAR *					lpulConnection;
} IABLogon_Advise_Params, FAR * LPIABLogon_Advise_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IABLogon_Advise_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 4, 0, &IID_IMAPIAdviseSink},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IABLogon_Advise_Thunk = IABLogon_Advise_ThunkArgs;

#endif

typedef struct _tagIABLogon_Unadvise_Params
{
				LPVOID						This;
				ULONG						ulConnection;
} IABLogon_Unadvise_Params, FAR * LPIABLogon_Unadvise_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IABLogon_Unadvise_Thunk = NULL;

#endif


typedef struct _tagIABLogon_OpenStatusEntry_Params
{
        		LPVOID						This;
        		LPIID                       lpInterface;
                ULONG                       ulFlags;
                ULONG FAR *                 lpulObjType;
                LPMAPISTATUS FAR *          lppEntry;
} IABLogon_OpenStatusEntry_Params, FAR * LPIABLogon_OpenStatusEntry_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IABLogon_OpenStatusEntry_Thunk = NULL;

#endif

typedef struct _tagIABLogon_OpenTemplateID_Params
{
        		LPVOID						This;
        		ULONG                       cbTemplateID;
                LPENTRYID                   lpTemplateID;
                ULONG                       ulTemplateFlags;
                LPMAPIPROP                  lpMAPIPropData;
                LPIID                       lpInterface;
                LPMAPIPROP FAR *            lppMAPIPropNew;
                LPMAPIPROP                  lpMAPIPropSibling;
} IABLogon_OpenTemplateID_Params, FAR * LPIABLogon_OpenTemplateID_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IABLogon_OpenTemplateID_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 4, 0, &IID_IMAPIProp},
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 7, 0, &IID_IMAPIProp},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IABLogon_OpenTemplateID_Thunk = IABLogon_OpenTemplateID_ThunkArgs;

#endif

typedef struct _tagIABLogon_GetOneOffTable_Params
{
        		LPVOID						This;
				ULONG						ulFlags;
        		LPMAPITABLE FAR *           lppTable;
} IABLogon_GetOneOffTable_Params, FAR * LPIABLogon_GetOneOffTable_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IABLogon_GetOneOffTable_Thunk = NULL;

#endif

typedef struct _tagIABLogon_PrepareRecips_Params
{
				LPVOID						This;
				ULONG						ulFlags;
				LPSPropTagArray				lpPropTagArray;
				LPADRLIST					lpRecipList;
} IABLogon_PrepareRecips_Params, FAR * LPIABLogon_PrepareRecips_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IABLogon_PrepareRecips_Thunk = NULL;

#endif


/*********************** IXPProvider ************************************/

typedef struct _tagIXPProvider_Shutdown_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
} IXPProvider_Shutdown_Params, FAR * LPIXPProvider_Shutdown_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IXPProvider_Shutdown_Thunk = NULL;

#endif

typedef struct _tagIXPProvider_TransportLogon_Params
{
				LPVOID						This;
				LPMAPISUP					lpMAPISup;
				ULONG						ulUIParam;
				LPTSTR						lpszProfileName;
				ULONG FAR *					lpulFlags;
                LPMAPIERROR FAR *			lppMapiError;
				LPXPLOGON FAR *				lppXPLogon;
} IXPProvider_TransportLogon_Params, FAR * LPIXPProvider_TransportLogon_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IXPProvider_TransportLogon_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 1, 0, &IID_IMAPISup},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IXPProvider_TransportLogon_Thunk = IXPProvider_TransportLogon_ThunkArgs;

#endif


/************************ IXPLogon **************************************/

typedef struct _tagIXPLogon_AddressTypes_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
				ULONG FAR *					lpcAdrType;
				LPTSTR FAR * FAR *			lpppAdrTypeArray;
				ULONG FAR *					lpcMAPIUID;
				LPMAPIUID FAR * FAR *		lpppUIDArray;
} IXPLogon_AddressTypes_Params, FAR * LPIXPLogon_AddressTypes_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IXPLogon_AddressTypes_Thunk = NULL;

#endif

typedef struct _tagIXPLogon_RegisterOptions_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
				ULONG FAR *					lpcOptions;
				LPOPTIONDATA FAR *			lppOptions;
} IXPLogon_RegisterOptions_Params, FAR * LPIXPLogon_RegisterOptions_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IXPLogon_RegisterOptions_Thunk = NULL;

#endif

typedef struct _tagIXPLogon_TransportNotify_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
				LPVOID FAR *				lppvData;
} IXPLogon_TransportNotify_Params, FAR * LPIXPLogon_TransportNotify_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IXPLogon_TransportNotify_Thunk = NULL;

#endif

typedef struct _tagIXPLogon_Idle_Params
{
				LPVOID						This;
				ULONG						ulFlags;
} IXPLogon_Idle_Params, FAR * LPIXPLogon_Idle_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IXPLogon_Idle_Thunk = NULL;

#endif

typedef struct _tagIXPLogon_TransportLogoff_Params
{
				LPVOID						This;
				ULONG						ulFlags;
} IXPLogon_TransportLogoff_Params, FAR * LPIXPLogon_TransportLogoff_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IXPLogon_TransportLogoff_Thunk = NULL;

#endif

typedef struct _tagIXPLogon_SubmitMessage_Params
{
				LPVOID						This;
				ULONG						ulFlags;
				LPMESSAGE					lpMessage;
				ULONG FAR *					lpulMsgRef;
				ULONG FAR *					lpulReturnParm;
} IXPLogon_SubmitMessage_Params, FAR * LPIXPLogon_SubmitMessage_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IXPLogon_SubmitMessage_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 2, 0, &IID_IMessage},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IXPLogon_SubmitMessage_Thunk = IXPLogon_SubmitMessage_ThunkArgs;

#endif

typedef struct _tagIXPLogon_EndMessage_Params
{
				LPVOID						This;
				ULONG						ulMsgRef;
				ULONG FAR *					lpulFlags;
} IXPLogon_EndMessage_Params, FAR * LPIXPLogon_EndMessage_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IXPLogon_EndMessage_Thunk = NULL;

#endif

typedef struct _tagIXPLogon_Poll_Params
{
				LPVOID						This;
				ULONG FAR *					lpulIncoming;
} IXPLogon_Poll_Params, FAR * LPIXPLogon_Poll_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IXPLogon_Poll_Thunk = NULL;

#endif

typedef struct _tagIXPLogon_StartMessage_Params
{
				LPVOID						This;
				ULONG						ulFlags;
				LPMESSAGE					lpMessage;
				ULONG FAR *					lpulMsgRef;
} IXPLogon_StartMessage_Params, FAR * LPIXPLogon_StartMessage_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IXPLogon_StartMessage_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 2, 0, &IID_IMessage},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IXPLogon_StartMessage_Thunk = IXPLogon_StartMessage_ThunkArgs;

#endif

typedef struct _tagIXPLogon_OpenStatusEntry_Params
{
        		LPVOID						This;
        		LPIID                       lpInterface;
                ULONG                       ulFlags;
                ULONG FAR *                 lpulObjType;
                LPMAPISTATUS FAR *          lppEntry;
} IXPLogon_OpenStatusEntry_Params, FAR * LPIXPLogon_OpenStatusEntry_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IXPLogon_OpenStatusEntry_Thunk = NULL;

#endif

typedef struct _tagIXPLogon_ValidateState_Params
{
				LPVOID						This;
				ULONG						ulUIParam;
				ULONG						ulFlags;
} IXPLogon_ValidateState_Params, FAR * LPIXPLogon_ValidateState_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IXPLogon_ValidateState_Thunk = NULL;

#endif

typedef struct _tagIXPLogon_FlushQueues_Params
{
				LPVOID						This;
				ULONG						ulUIParam;
				ULONG						cbTargetTransport;
				LPENTRYID					lpTargetTransport;
				ULONG						ulFlags;
} IXPLogon_FlushQueues_Params, FAR * LPIXPLogon_FlushQueues_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IXPLogon_FlushQueues_Thunk = NULL;

#endif


/*********************** IMSProvider ************************************/

typedef struct _tagIMSProvider_Shutdown_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
} IMSProvider_Shutdown_Params, FAR * LPIMSProvider_Shutdown_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMSProvider_Shutdown_Thunk = NULL;

#endif
		
typedef struct _tagIMSProvider_Logon_Params
{
				LPVOID						This;
				LPMAPISUP					lpMAPISup;
				ULONG						ulUIParam;
				LPTSTR						lpszProfileName;
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulFlags;
				LPIID						lpInterface;
				ULONG FAR *					lpcbSpoolSecurity;
				LPBYTE FAR *				lppbSpoolSecurity;
                LPMAPIERROR FAR *			lppMapiError;
				LPMSLOGON FAR *				lppMSLogon;
				LPMDB FAR *					lppMDB;
} IMSProvider_Logon_Params, FAR * LPIMSProvider_Logon_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMSProvider_Logon_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 1, 0, &IID_IMAPISup},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMSProvider_Logon_Thunk = IMSProvider_Logon_ThunkArgs;

#endif
				
typedef struct _tagIMSProvider_SpoolerLogon_Params
{
				LPVOID						This;
				LPMAPISUP					lpMAPISup;
				ULONG						ulUIParam;
				LPTSTR						lpszProfileName;
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulFlags;
				LPIID						lpInterface;
				ULONG						cbSpoolSecurity;
				LPBYTE						lpbSpoolSecurity;
				LPMAPIERROR FAR *			lppMapiError;
				LPMSLOGON FAR *				lppMSLogon;
				LPMDB FAR *					lppMDB;
} IMSProvider_SpoolerLogon_Params, FAR * LPIMSProvider_SpoolerLogon_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMSProvider_SpoolerLogon_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 1, 0, &IID_IMAPISup},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMSProvider_SpoolerLogon_Thunk = IMSProvider_SpoolerLogon_ThunkArgs;

#endif
				
typedef struct _tagIMSProvider_CompareStoreIDs_Params
{
				LPVOID						This;
				ULONG						cbEntryID1;
				LPENTRYID					lpEntryID1;
				ULONG						cbEntryID2;
				LPENTRYID					lpEntryID2;
				ULONG						ulFlags;
				ULONG FAR *					lpulResult;
} IMSProvider_CompareStoreIDs_Params, FAR * LPIMSProvider_CompareStoreIDs_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMSProvider_CompareStoreIDs_Thunk = NULL;

#endif


/*************************** IMSLogon **********************************/

typedef struct _tagIMSLogon_GetLastError_Params
{
				LPVOID						This;
				HRESULT						hResult;
				ULONG						ulFlags;
				LPMAPIERROR FAR *			lppMAPIError;
} IMSLogon_GetLastError_Params, FAR * LPIMSLogon_GetLastError_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMSLogon_GetLastError_Thunk = NULL;

#endif

typedef struct _tagIMSLogon_Logoff_Params
{
				LPVOID						This;
				ULONG FAR *					lpulFlags;
} IMSLogon_Logoff_Params, FAR * LPIMSLogon_Logoff_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMSLogon_Logoff_Thunk = NULL;

#endif

typedef struct _tagIMSLogon_OpenEntry_Params
{
				LPVOID						This;
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				LPIID						lpInterface;
				ULONG						ulFlags;
				ULONG FAR *					lpulObjType;
				LPUNKNOWN FAR *				lppUnk;
} IMSLogon_OpenEntry_Params, FAR * LPIMSLogon_OpenEntry_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMSLogon_OpenEntry_Thunk = NULL;

#endif

typedef struct _tagIMSLogon_CompareEntryIDs_Params
{
				LPVOID						This;
				ULONG						cbEntryID1;
				LPENTRYID					lpEntryID1;
				ULONG						cbEntryID2;
				LPENTRYID					lpEntryID2;
				ULONG						ulFlags;
				ULONG FAR *					lpulResult;
} IMSLogon_CompareEntryIDs_Params, FAR * LPIMSLogon_CompareEntryIDs_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMSLogon_CompareEntryIDs_Thunk = NULL;

#endif

typedef struct _tagIMSLogon_Advise_Params
{
				LPVOID						This;
				ULONG						cbEntryID;
				LPENTRYID					lpEntryID;
				ULONG						ulEventMask;
				LPMAPIADVISESINK			lpAdviseSink;
				ULONG FAR *					lpulConnection;
} IMSLogon_Advise_Params, FAR * LPIMSLogon_Advise_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo IMSLogon_Advise_ThunkArgs[] = {
    {Wx86MapiArgThunkInfo::InIf, (PVOID*) 4, 0, &IID_IMAPIAdviseSink},
    {Wx86MapiArgThunkInfo::Unused, 0, 0, NULL}
};

Wx86MapiArgThunkInfo* IMSLogon_Advise_Thunk = IMSLogon_Advise_ThunkArgs;

#endif

typedef struct _tagIMSLogon_Unadvise_Params
{
				LPVOID						This;
				ULONG						ulConnection;
} IMSLogon_Unadvise_Params, FAR * LPIMSLogon_Unadvise_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMSLogon_Unadvise_Thunk = NULL;

#endif

typedef struct _tagIMSLogon_OpenStatusEntry_Params
{
				LPVOID						This;
				LPIID						lpInterface;
				ULONG						ulFlags;
				ULONG FAR *					lpulObjType;
				LPVOID FAR *				lppEntry;
} IMSLogon_OpenStatusEntry_Params, FAR * LPIMSLogon_OpenStatusEntry_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMSLogon_OpenStatusEntry_Thunk = NULL;

#endif


/*************************** IMAPIControl ******************************/

typedef struct _tagIMAPIControl_GetLastError_Params
{
				LPVOID						This;
				HRESULT						hResult;
				ULONG						ulFlags;
				LPMAPIERROR FAR *			lppMAPIError;
} IMAPIControl_GetLastError_Params, FAR * LPIMAPIControl_GetLastError_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIControl_GetLastError_Thunk = NULL;

#endif
				
				
typedef struct _tagIMAPIControl_Activate_Params
{
				LPVOID						This;
				ULONG						ulFlags;
				ULONG						ulUIParam;
} IMAPIControl_Activate_Params, FAR * LPIMAPIControl_Activate_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIControl_Activate_Thunk = NULL;

#endif
				
				
typedef struct _tagIMAPIControl_GetState_Params
{
				LPVOID						This;
				ULONG						ulFlags;
				ULONG FAR *					lpulState;
} IMAPIControl_GetState_Params, FAR * LPIMAPIControl_GetState_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIControl_GetState_Thunk = NULL;

#endif


/**************************** IStream *********************************/


typedef struct _tagIStream_Read_Params
{
				LPVOID						This;
				VOID HUGEP *				pv;
				ULONG						cb;
				ULONG FAR *					pcbRead;
} IStream_Read_Params, FAR * LPIStream_Read_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IStream_Read_Thunk = NULL;

#endif

typedef struct _tagIStream_Write_Params
{
				LPVOID						This;
				VOID const HUGEP *			pv;
				ULONG						cb;
				ULONG FAR *					pcbWritten;
} IStream_Write_Params, FAR * LPIStream_Write_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IStream_Write_Thunk = NULL;

#endif

typedef struct _tagIStream_Seek_Params
{
				LPVOID						This;
				LARGE_INTEGER_ARG			dlibMove;
				DWORD						dwOrigin;
				ULARGE_INTEGER FAR *		plibNewPosition;
} IStream_Seek_Params, FAR * LPIStream_Seek_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IStream_Seek_Thunk = NULL;

#endif

typedef struct _tagIStream_SetSize_Params
{
				LPVOID						This;
				ULARGE_INTEGER_ARG			libNewSize;
} IStream_SetSize_Params, FAR * LPIStream_SetSize_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IStream_SetSize_Thunk = NULL;

#endif

typedef struct _tagIStream_CopyTo_Params
{
				LPVOID						This;
				IStream FAR *				pstm;
				ULARGE_INTEGER				cb;
				ULARGE_INTEGER FAR *		pcbRead;
				ULARGE_INTEGER FAR *		pcbWritten;
} IStream_CopyTo_Params, FAR * LPIStream_CopyTo_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IStream_CopyTo_Thunk = NULL;

#endif

typedef struct _tagIStream_Commit_Params
{
				LPVOID						This;
				DWORD						grfCommitFlags;
} IStream_Commit_Params, FAR * LPIStream_Commit_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IStream_Commit_Thunk = NULL;

#endif

typedef struct _tagIStream_Revert_Params
{
				LPVOID						This;
} IStream_Revert_Params, FAR * LPIStream_Revert_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IStream_Revert_Thunk = NULL;

#endif

typedef struct _tagIStream_LockRegion_Params
{
				LPVOID						This;
				ULARGE_INTEGER_ARG			libOffset;
				ULARGE_INTEGER_ARG_2		cb;
				DWORD						dwLockType;
} IStream_LockRegion_Params, FAR * LPIStream_LockRegion_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IStream_LockRegion_Thunk = NULL;

#endif

typedef struct _tagIStream_UnlockRegion_Params
{
				LPVOID						This;
				ULARGE_INTEGER_ARG			libOffset;
				ULARGE_INTEGER_ARG_2		cb;
				DWORD						dwLockType;
} IStream_UnlockRegion_Params, FAR * LPIStream_UnlockRegion_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IStream_UnlockRegion_Thunk = NULL;

#endif

typedef struct _tagIStream_Stat_Params
{
				LPVOID						This;
				STATSTG FAR *				pstatstg;
				DWORD						grfStatFlag;
} IStream_Stat_Params, FAR * LPIStream_Stat_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IStream_Stat_Thunk = NULL;

#endif

typedef struct _tagIStream_Clone_Params
{
				LPVOID						This;
				IStream FAR * FAR *			ppstm;
} IStream_Clone_Params, FAR * LPIStream_Clone_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IStream_Clone_Thunk = NULL;

#endif

/************************* IMAPIAdviseSink *****************************/

typedef struct _tagIMAPIAdviseSink_OnNotify_Params
{
				LPVOID						This;
				ULONG						cNotif;
				LPNOTIFICATION				lpNotifications;
} IMAPIAdviseSink_OnNotify_Params, FAR * LPIMAPIAdviseSink_OnNotify_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPIAdviseSink_OnNotify_Thunk = NULL;

#endif

/************************* IMAPITable **********************************/
typedef struct _tagIMAPITable_SortTableEx_Params
{
				LPVOID						This;	
				LPSSortOrderSet				lpSortCriteria;
				ULONG						ulFlags;
} IMAPITable_SortTableEx_Params, FAR * LPIMAPITable_SortTableEx_Params;

#if defined (WX86_MAPISTUB)

Wx86MapiArgThunkInfo* IMAPITable_SortTableEx_Thunk = NULL;

#endif

/************************** Provider INIT ******************************/

//
//typedef HRESULT (STDMAPIINITCALLTYPE MSPROVIDERINIT)(
//	HINSTANCE				hInstance,
//	LPMALLOC				lpMalloc,			/* AddRef() if you keep it */
//	LPALLOCATEBUFFER		lpAllocateBuffer,	/* -> AllocateBuffer */
//	LPALLOCATEMORE			lpAllocateMore, 	/* -> AllocateMore   */
//	LPFREEBUFFER			lpFreeBuffer, 		/* -> FreeBuffer     */
//	ULONG					ulFlags,
//	ULONG					ulMAPIVer,
//	ULONG FAR *				lpulProviderVer,
//	LPMSPROVIDER FAR *		lppMSProvider
//);
//
//typedef HRESULT (STDMAPIINITCALLTYPE XPPROVIDERINIT)(
//	HINSTANCE			hInstance,
//	LPMALLOC			lpMalloc,
//	LPALLOCATEBUFFER	lpAllocateBuffer,
//	LPALLOCATEMORE 		lpAllocateMore,
//	LPFREEBUFFER 		lpFreeBuffer,
//	ULONG				ulFlags,
//	ULONG				ulMAPIVer,
//	ULONG FAR *			lpulProviderVer,
//	LPXPPROVIDER FAR *	lppXPProvider);
//
//
//typedef HRESULT (STDMAPIINITCALLTYPE ABPROVIDERINIT)(
//	HINSTANCE			hInstance,
//	LPMALLOC			lpMalloc,
//	LPALLOCATEBUFFER	lpAllocateBuffer,
//	LPALLOCATEMORE 		lpAllocateMore,
//	LPFREEBUFFER 		lpFreeBuffer,
//    ULONG				ulFlags,
//    ULONG				ulMAPIVer,
//    ULONG FAR *			lpulProviderVer,
//    LPABPROVIDER FAR *	lppABProvider
//);


//typedef SCODE (STDMAPIINITCALLTYPE OPTIONCALLBACK)(
//			HINSTANCE		hInst,
//			LPMALLOC		lpMalloc,
//			ULONG			ulFlags,
//			ULONG			cbOptionData,
//			LPBYTE			lpbOptionData,
//			LPMAPISUP		lpMAPISup,
//			LPMAPIPROP		lpDataSource,
//			LPMAPIPROP FAR *lppWrappedSource,
//			LPTSTR FAR *	lppszErrorMsg,
//			LPTSTR FAR *	lppszErrorComponent,
//			ULONG FAR *		lpulErrorContext);



#endif /* STRUCTS_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\mapistub\mapistub\_glheap.h ===
/*
 * glheap.h
 *
 * Implementation of global and local heaps
 *
 * Copyright (C) 1994 Microsoft Corporation
 */

#ifndef __GLHEAP_H_
#define __GLHEAP_H_

#ifdef __cplusplus
extern "C" {
#endif

/* Windows 95 Implementation -------------------------------------------------- */

#ifdef CHICAGO

#define GH_POINTERS_VALID

typedef DWORD			GHNAME, * PGHNAME,	** PPGHNAME;
typedef DWORD			GHID,	* PGHID,	** PPGHID;
typedef struct GHDR		GHDR,	* PGHDR,	** PPGHDR;
typedef struct GH		GH,  	* PGH,		** PPGH;
typedef PGH				_HGH;
typedef HANDLE			_HLH;

struct GHDR {
	PGHDR			pghdrNext;		// Pointer to next heap
	HANDLE			hHeap;			// Handle to the heap
	GHNAME			ghname;			// Name of the heap
	GHID			ghidRoot;		// Client root heap block
	ULONG			cRef;			// Number of active clients
};

struct GH {
	HANDLE			hHeap;			// Handle to the heap
	HANDLE			hMutex;			// Handle to mutex for this heap
	PGHDR			pghdr;			// Pointer to the heap header block
	#ifdef DEBUG
	UINT			cMutex;			// Mutex entry count
	#endif
};

__inline void HeapFreeZ(HANDLE hHeap, LPVOID pv)
{
	if (pv)
		HeapFree(hHeap, 0, pv);
}

_HGH	WINAPI _GH_Open(BOOL fCreate, GHNAME ghname, DWORD dwMaxHeap);
void	WINAPI _GH_Close(_HGH hgh);
#define _GH_GetRoot(hgh)			((hgh)->pghdr->ghidRoot)
#define _GH_SetRoot(hgh, ghid)		((hgh)->pghdr->ghidRoot = (ghid))
#define _GH_GetName(hgh)			((hgh)->pghdr->ghname)
#define _GH_GetPv(hgh, ghid)		((LPVOID)(ghid))
#define _GH_GetId(hgh, pv)			((GHID)(pv))
#define _GH_GetSize(hgh, ghid)		HeapSize((hgh)->hHeap, 0, (LPVOID)(ghid))
#define _GH_Alloc(hgh, cb)			((GHID)HeapAlloc((hgh)->hHeap, 0, cb))
#define _GH_Realloc(hgh, ghid, cb)	((GHID)HeapReAlloc((hgh)->hHeap, 0, (LPVOID)(ghid), cb))
#define _GH_Free(hgh, ghid)			HeapFreeZ((hgh)->hHeap, (LPVOID)(ghid))

#ifdef DEBUG
BOOL	WINAPI _GH_WaitForMutex(_HGH hgh, ULONG ulTimeout);
void	WINAPI _GH_ReleaseMutex(_HGH hgh);
#else
#define	_GH_WaitForMutex(hgh, ulT)	GH_WaitForSingleObject(hgh->hMutex, ulT)
#ifdef __cplusplus
#define _GH_ReleaseMutex(hgh)		::ReleaseMutex((hgh)->hMutex)
#else
#define _GH_ReleaseMutex(hgh)		ReleaseMutex((hgh)->hMutex)
#endif
#endif

#define	_LH_Open(dwMaxHeap)			HeapCreate(0, 0, dwMaxHeap)
#define _LH_Close(hlh)				HeapDestroy(hlh)
#define _LH_Alloc(hlh, cb)			HeapAlloc(hlh, 0, cb)
#define _LH_Realloc(hlh, pv, cb)	HeapReAlloc(hlh, 0, pv, cb)
#define _LH_GetSize(hlh, pv)		HeapSize(hlh, 0, pv)
#define _LH_Free(hlh, pv)			HeapFreeZ(hlh, pv)

#endif

/* Win16 Implementation ---------------------------------------------------- */

#ifdef WIN16

#define GH_POINTERS_VALID

typedef __segment		HPH,	* PHPH,		** PPHPH;
typedef DWORD			HPID,	* PHPID,	** PPHPID;
typedef DWORD			GHNAME, * PGHNAME,	** PPGHNAME;
typedef HPID			GHID,	* PGHID,	** PPGHID;
typedef HPH				_HGH;
typedef HPH				_HLH;

typedef struct HP {
	HPH				hphRoot;		// Pointer to root heap
	HPH				hphPrev;		// Pointer to the previous heap (fShared)
	HPH				hphNext;		// Pointer to next heap (fShared)
	HPH				hphChild;		// Pointer to extended heaps
	BOOL			fShared;		// TRUE if heap is shared across processes
	GHNAME			ghname;			// Name of the shared heap (fShared)
	GHID			ghidRoot;		// Client root heap block
	DWORD			dwCurHeap;		// Current size of the heap
	DWORD			dwMaxHeap;		// Maximum size of the heap
	UINT			cRef;			// Number of active clients
	UINT			cbHeap;			// Size of this heap
	UINT			cbFree;			// Maximum contiguous free bytes in heap
} HP, * PHP;

#define HphToPhp(hph)				((PHP)((ULONG)(hph) << 16))
#define HP_CREATE					0x0001
#define HP_SHARED					0x0002

HPH		WINAPI HP_Open(UINT uiFlags, GHNAME ghname, DWORD dwMaxHeap);
void	WINAPI HP_Close(HPH hph);
HPID	WINAPI HP_Alloc(HPH hph, UINT cb);
HPID	WINAPI HP_Realloc(HPH hph, HPID hpid, UINT cb);
void	WINAPI HP_Free(HPH hph, HPID hpid);
#define	HP_GetSize(hgh, hpid)		(*((UINT *)(hpid) - 2))

#define _GH_Open(fCreate, ghname, dwMaxHeap) \
			HP_Open(HP_SHARED | !!(fCreate), ghname, dwMaxHeap)
#define	_GH_Close(hgh)				HP_Close(hgh)
#define _GH_GetRoot(hgh)			(HphToPhp(hgh)->ghidRoot)
#define _GH_SetRoot(hgh, ghid)		(HphToPhp(hgh)->ghidRoot = (ghid))
#define _GH_GetName(hgh)			(HphToPhp(hgh)->ghname)
#define _GH_GetPv(hgh, ghid)		((LPVOID)(ghid))
#define _GH_GetId(hgh, pv)			((GHID)(pv))
#define _GH_GetSize(hgh, ghid)		HP_GetSize(hgh, ghid)
#define _GH_Alloc(hgh, cb)			((GHID)HP_Alloc(hgh, cb))
#define _GH_Realloc(hgh, ghid, cb)	((GHID)HP_Realloc(hgh, ghid, cb))
#define _GH_Free(hgh, ghid)			HP_Free(hgh, ghid)
#define _GH_WaitForMutex(hgh, ul)	(TRUE)
#define _GH_ReleaseMutex(hgh)

#define	_LH_Open(dwMaxHeap)			HP_Open(HP_CREATE, 0, dwMaxHeap)
#define	_LH_Close(hlh)				HP_Close(hlh)
#define _LH_Alloc(hlh, cb)			((LPVOID)HP_Alloc(hlh, cb))
#define _LH_Realloc(hlh, pv, cb)	((LPVOID)HP_Realloc(hlh, (HPID)(pv), cb))
#define _LH_GetSize(hlh, pv)		HP_GetSize(hlh, pv)
#define _LH_Free(hlh, pv)			HP_Free(hlh, (HPID)(pv))

#endif

/* NT Implementation ------------------------------------------------------- */

#if defined(WIN32) && !defined(CHICAGO) && !defined(MAC)

typedef DWORD			GHNAME, * PGHNAME,	** PPGHNAME;
typedef DWORD			GHID,	* PGHID,	** PPGHID;
typedef struct GROOT	GROOT,	* PGROOT,	** PPGROOT;
typedef struct GH		GH,		* PGH,		** PPGH;
typedef struct GHBLK	GHBLK,	* PGHBLK;
typedef PGH				_HGH;
typedef HANDLE			_HLH;

struct GHBLK {
	DWORD			dwSig;			//	Signature for block validation
	WORD			cb;				//	size of the data
	WORD			ibPrev;			//	offset of previous block
};

struct GROOT
{
	GHBLK			blk;			// Block header
	GHNAME			ghname;			// Name of the heap
	GHID			ghidRoot;		// Client root heap block
	DWORD			dwCurHeap;		// Current size of the heap
	DWORD			dwMaxHeap;		// Maximum size of the heap
	WORD			rgcbFree[1];	// Maximum contiguous free bytes per page
};

struct GH
{
	PGROOT			pgroot;			// Pointer to the first byte of the heap
	HANDLE			hMutex;			// Handle to public mutex for this heap
	HANDLE			hMutexHeap;		// Handle to private mutex for this heap
	HANDLE			hMapping;		// Handle to file mapping object
	#ifdef DEBUG
	UINT			cMutex;			// Mutex entry count
	#endif
};

typedef struct GH_SECURITY_ATTRIBUTES {
	SECURITY_ATTRIBUTES		sa;
	BYTE					rgbSd[SECURITY_DESCRIPTOR_MIN_LENGTH];
} GH_SECURITY_ATTRIBUTES, * PGH_SECURITY_ATTRIBUTES;

BOOL	WINAPI GH_InitializeSecurityAttributes(PGH_SECURITY_ATTRIBUTES pghsa);

__inline void HeapFreeZ(HANDLE hHeap, LPVOID pv)
{
	if (pv)
		HeapFree(hHeap, 0, pv);
}

_HGH	WINAPI _GH_Open(BOOL fCreate, GHNAME ghname, DWORD dwMaxHeap);
void	WINAPI _GH_Close(_HGH hgh);
GHID	WINAPI _GH_Alloc(_HGH hgh, UINT cb);
GHID	WINAPI _GH_Realloc(_HGH hgh, GHID ghid, UINT cb);
void	WINAPI _GH_Free(_HGH hgh, GHID ghid);

#define _GH_GetPv(hgh, ghid)		((LPVOID)((BYTE *)(hgh)->pgroot + (ghid)))
#define _GH_GetId(hgh, pv)			((GHID)((BYTE *)(pv) - (BYTE *)(hgh)->pgroot))
#define _GH_GetSize(hgh, ghid)		((UINT)(((GHBLK *)_GH_GetPv(hgh, ghid) - 1)->cb))
#define _GH_GetRoot(hgh)			((hgh)->pgroot->ghidRoot)
#define _GH_SetRoot(hgh, ghid)		((hgh)->pgroot->ghidRoot = (ghid))
#define _GH_GetName(hgh)			((hgh)->pgroot->ghname)

#ifdef DEBUG
BOOL	WINAPI _GH_WaitForMutex(_HGH hgh, ULONG ulTimeout);
void	WINAPI _GH_ReleaseMutex(_HGH hgh);
#else
#define _GH_WaitForMutex(hgh, ul)	GH_WaitForSingleObject((hgh)->hMutex, ul)
#ifdef __cplusplus
#define _GH_ReleaseMutex(hgh)		::ReleaseMutex((hgh)->hMutex)
#else
#define _GH_ReleaseMutex(hgh)		ReleaseMutex((hgh)->hMutex)
#endif
#endif

typedef HANDLE (WINAPI MHEAPCREATE)(
	ULONG	cHeaps,
	DWORD	dwFlags,
	DWORD	dwInitialSize,
	DWORD	dwMaxSize);

typedef BOOL (WINAPI MHEAPDESTROY)(VOID);

typedef LPVOID (WINAPI MHEAPALLOC)(
	DWORD	dwSize);

typedef LPVOID (WINAPI MHEAPREALLOC)(
	LPVOID	pvOld,
	DWORD	dwSize);

typedef BOOL (WINAPI MHEAPFREE)(
	LPVOID	pvFree);

typedef DWORD (WINAPI MHEAPSIZE)(
	LPVOID	pvSize);

typedef MHEAPCREATE  FAR *LPMHEAPCREATE;
typedef MHEAPDESTROY FAR *LPMHEAPDESTROY;
typedef MHEAPALLOC   FAR *LPMHEAPALLOC;
typedef MHEAPREALLOC FAR *LPMHEAPREALLOC;
typedef MHEAPFREE    FAR *LPMHEAPFREE;
typedef MHEAPSIZE    FAR *LPMHEAPSIZE;

HANDLE WINAPI LH_ExtHeapCreate(
	DWORD	dwFlags,
	DWORD	dwInitialSize,
	DWORD	dwMaxSize);

BOOL WINAPI LH_ExtHeapDestroy(
    HANDLE  hHeap);

LPVOID WINAPI LH_ExtHeapAlloc(
    HANDLE  hHeap,
	DWORD	dwFlags,
	DWORD	dwSize);

LPVOID WINAPI LH_ExtHeapReAlloc(
    HANDLE  hHeap,
	DWORD	dwFlags,
	LPVOID	pvOld,
	DWORD	dwSize);

BOOL WINAPI LH_ExtHeapFree(
    HANDLE  hHeap,
	DWORD	dwFlags,
	LPVOID	pvFree);

DWORD WINAPI LH_ExtHeapSize(
    HANDLE  hHeap,
	DWORD	dwFlags,
	LPVOID	pvSize);

#define	_LH_Open(dwMaxHeap)			LH_ExtHeapCreate(0, 0, dwMaxHeap)
#define _LH_Close(_hlh)				LH_ExtHeapDestroy(_hlh)
#define _LH_Alloc(_hlh, cb)			LH_ExtHeapAlloc(_hlh, 0, cb)
#define _LH_Realloc(_hlh, pv, cb)	LH_ExtHeapReAlloc(_hlh, 0, pv, cb)
#define _LH_GetSize(_hlh, pv)		LH_ExtHeapSize(_hlh, 0, pv)
#define _LH_Free(_hlh, pv)			LH_ExtHeapFree(_hlh, 0, pv)

#ifndef DEBUG
HANDLE WINAPI LH_ExtHlh(VOID);

#define _LH_Hlh()                   LH_ExtHlh()
#endif

VOID WINAPI InitMemoryMgmt(VOID);
VOID WINAPI UninitMemoryMgmt(VOID);

#endif	/* WIN32 */

/* Mac Implementation ------------------------------------------------------ */

#ifdef MAC

#include <macname1.h>
#include <macos\Memory.h>
#include <macname2.h>

#define GH_POINTERS_VALID

typedef DWORD			GHNAME, * PGHNAME,	** PPGHNAME;
typedef DWORD			GHID,	* PGHID,	** PPGHID;
typedef struct GH		GH,		* PGH,		** PPGH;
typedef PGH				_HGH;
typedef HANDLE			_HLH;

typedef struct tag_SBlock {
	Handle				h;
	Ptr					ptr;
	Handle				hblk;
	struct tag_SBlock	*next;
} Block, *BlkPtr, **BlkHandle;

struct GH {
	Handle			hgh;			// Handle to 'heap' for [disposal]
	GHNAME			ghname;			// Name of the heap
	ULONG			cRef;			// Number of active clients
	GHID			ghidRoot;		// Client root heap block [a holder]
	BlkPtr			pblk;			// Ptr to first client block
	PGH				next;			// Pointer to next shared heap
};

#define	_GH_WaitForMutex(hgh, ul)	(TRUE)
#define _GH_ReleaseMutex(hgh)
#define _GH_GetRoot(pgh)			((pgh)->ghidRoot)
#define _GH_SetRoot(pgh, ghid)		((pgh)->ghidRoot = ghid)
#define _GH_GetName(pgh)			((pgh)->ghname)
#define _GH_GetPv(pgh, ghid)		((LPVOID)(ghid))
#define _GH_GetId(pgh, pv)			((GHID)(pv))

PGH		WINAPI _GH_Open(BOOL fCreate, GHNAME ghname, DWORD dwMaxHeap);
void	WINAPI _GH_Close(PGH pgh);
GHID	WINAPI _GH_Alloc(PGH pgh, UINT cb);
UINT 	WINAPI _GH_GetSize(PGH pgh, GHID ghid);
GHID	WINAPI _GH_Realloc(PGH pgh, GHID ghid, UINT cb);
void	WINAPI _GH_Free(PGH pgh, GHID ghid);

// -------------------------------
#ifndef __TEXTUTILS__
extern pascal void  NumToString(long theNum, Str255 theString);
#endif

typedef struct tag_LBlock {
	Ptr					ptr;
	struct tag_LBlock	*next;
} LBlock, *LBlkPtr;

typedef struct tag_LHeap {
	LBlkPtr				plb;	// Ptr to first local block
	struct tag_LHeap	*next;	// Ptr to next heap
} LHeap, *LHeapPtr;

LPVOID	WINAPI _LH_Open(DWORD dwMaxHeap);
void	WINAPI _LH_Close(LPVOID pvhlh);
LPVOID	WINAPI _LH_Alloc(LPVOID pvhlh, UINT cb);
LPVOID	WINAPI _LH_Realloc(LPVOID pvhlh, LPVOID pv, UINT cb);
UINT	WINAPI _LH_GetSize(LPVOID pvhlh, LPVOID pv);
void	WINAPI _LH_Free(LPVOID pvhlh, LPVOID pv);

#endif /* MAC */

/* DOS Implementation ------------------------------------------------------ */

#ifdef DOS

typedef DWORD			GHID,	* PGHID,	** PPGHID;
typedef LPMALLOC		_HLH;

__inline LPVOID _LH_Alloc(_HLH hlh, UINT cb)
{
#ifdef __cplusplus
	return((hlh)->Alloc(cb));
#else
	return((hlh)->lpVtbl->Alloc(hlh, cb));
#endif
}

__inline LPVOID _LH_Realloc(_HLH hlh, LPVOID pv, UINT cb)
{
#ifdef __cplusplus
	return(hlh->Realloc(pv, cb));
#else
	return(hlh->lpVtbl->Realloc(hlh, pv, cb));
#endif
}

__inline void _LH_Free(_HLH hlh, LPVOID pv)
{
#ifdef __cplusplus
	hlh->Free(pv);
#else
	hlh->lpVtbl->Free(hlh, pv);
#endif
}

__inline UINT _LH_GetSize(_HLH hlh, LPVOID pv)
{
#ifdef __cplusplus
	return((UINT)hlh->GetSize(pv));
#else
	return((UINT)hlh->lpVtbl->GetSize(hlh, pv));
#endif
}

#endif

// LH External API ------------------------------------------------------------

#if defined(DEBUG) && (defined(WIN16) || defined(WIN32))
#define	IFHEAPNAME(x)	x

typedef struct LH *	HLH;

HLH		WINAPI LH_Open(DWORD dwMaxHeap);
void	WINAPI LH_Close(HLH hlh);
LPVOID	WINAPI LH_Alloc(HLH hlh, UINT cb);
LPVOID	WINAPI LH_Realloc(HLH hlh, LPVOID pv, UINT cb);
UINT	WINAPI LH_GetSize(HLH hlh, LPVOID pv);
void	WINAPI LH_Free(HLH hlh, LPVOID pv);
BOOL	WINAPI LH_DidAlloc(HLH hlh, LPVOID pv);

void __cdecl LH_SetHeapNameFn(HLH hlh, char *pszFormat, ...);
void __cdecl LH_SetNameFn(HLH hlh, LPVOID pv, char *pszFormat, ...);

char *	WINAPI LH_GetName(HLH hlh, LPVOID pv);

#else
#define	IFHEAPNAME(x)	0

typedef _HLH	HLH;

#define	LH_Open(dwMaxHeap)						_LH_Open(dwMaxHeap)
#define LH_Close(hlh)							_LH_Close(hlh)
#define LH_Alloc(hlh, cb)						_LH_Alloc(hlh, cb)
#define LH_Realloc(hlh, pv, cb)					_LH_Realloc(hlh, pv, cb)
#define LH_GetSize(hlh, pv)						_LH_GetSize(hlh, pv)
#define LH_Free(hlh, pv)						_LH_Free(hlh, pv)
#define LH_Hlh()                                _LH_Hlh()

#endif

#define LH_SetHeapName(hlh,psz)					IFHEAPNAME(LH_SetHeapNameFn(hlh,psz))
#define LH_SetHeapName1(hlh,psz,a1)				IFHEAPNAME(LH_SetHeapNameFn(hlh,psz,a1))
#define LH_SetHeapName2(hlh,psz,a1,a2)			IFHEAPNAME(LH_SetHeapNameFn(hlh,psz,a1,a2))
#define LH_SetHeapName3(hlh,psz,a1,a2,a3)		IFHEAPNAME(LH_SetHeapNameFn(hlh,psz,a1,a2,a3))
#define LH_SetHeapName4(hlh,psz,a1,a2,a3,a4)	IFHEAPNAME(LH_SetHeapNameFn(hlh,psz,a1,a2,a3,a4))
#define LH_SetHeapName5(hlh,psz,a1,a2,a3,a4,a5)	IFHEAPNAME(LH_SetHeapNameFn(hlh,psz,a1,a2,a3,a4,a5))

#define LH_SetName(hlh,pv,psz)					IFHEAPNAME(LH_SetNameFn(hlh,pv,psz))
#define LH_SetName1(hlh,pv,psz,a1)				IFHEAPNAME(LH_SetNameFn(hlh,pv,psz,a1))
#define LH_SetName2(hlh,pv,psz,a1,a2)			IFHEAPNAME(LH_SetNameFn(hlh,pv,psz,a1,a2))
#define LH_SetName3(hlh,pv,psz,a1,a2,a3)		IFHEAPNAME(LH_SetNameFn(hlh,pv,psz,a1,a2,a3))
#define LH_SetName4(hlh,pv,psz,a1,a2,a3,a4)		IFHEAPNAME(LH_SetNameFn(hlh,pv,psz,a1,a2,a3,a4))
#define LH_SetName5(hlh,pv,psz,a1,a2,a3,a4,a5)	IFHEAPNAME(LH_SetNameFn(hlh,pv,psz,a1,a2,a3,a4,a5))


// GH External API ------------------------------------------------------------

#if !defined(DOS)

typedef _HGH	HGH;

#define	GH_Open(fCreate, ghname, dwMaxHeap)		_GH_Open(fCreate, ghname, \
															dwMaxHeap)
#define	GH_Close(hgh)							_GH_Close(hgh)
#define GH_GetRoot(hgh)							_GH_GetRoot(hgh)
#define GH_SetRoot(hgh, ghid)					_GH_SetRoot(hgh, ghid)
#define GH_GetName(hgh)							_GH_GetName(hgh)
#define GH_GetPv(hgh, ghid)						_GH_GetPv(hgh, ghid)
#define GH_GetId(hgh, pv)						_GH_GetId(hgh, pv)
#define GH_GetSize(hgh, ghid)					_GH_GetSize(hgh, ghid)
#define GH_Alloc(hgh, cb)						_GH_Alloc(hgh, cb)
#define GH_Realloc(hgh, ghid, cb)				_GH_Realloc(hgh, ghid, cb)
#define GH_Free(hgh, ghid)						_GH_Free(hgh, ghid)
#define	GH_WaitForMutex(hgh, ulT)				_GH_WaitForMutex(hgh, ulT)
#define GH_ReleaseMutex(hgh)					_GH_ReleaseMutex(hgh)
#define GH_GetObjectName(pszName, ghname, bTag) _GH_GetObjectName(pszName, \
														ghname, bTag);
#define GH_WaitForSingleObject(hMutex, ulTO)	_GH_WaitForSingleObject(hMutex,\
														ulTO)
#endif

#ifdef	WIN32
#if defined(_WINNT)
#define GH_NAME_CCH			25
#else
#define GH_NAME_CCH			17
#endif
#define GH_NAME_MUTEX_1		'*'		/* reserved for internal use */
#define GH_NAME_MUTEX_2		'+'		/* reserved for internal use */
#define GH_NAME_MUTEX_3		'^'
#define GH_NAME_FILE_MAPPING	'!'
void	WINAPI _GH_GetObjectName(CHAR *pszName, GHNAME ghname, BYTE bTag);

BOOL	WINAPI _GH_WaitForSingleObject(HANDLE hMutex, ULONG ulTimeout);
#endif


// ----------------------------------------------------------------------------

#ifdef __cplusplus
}
#endif

#endif	// __GLHEAP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\mapistub\mapistub\xcmc.h ===
/*BEGIN CMC INTERFACE */

#ifndef _XCMC_H
#define _XCMC_H

#ifdef __cplusplus
extern "C" {
#endif

/*BASIC DATA TYPES*/
#ifndef DIFFERENT_PLATFORM
typedef char                CMC_sint8;
typedef short               CMC_sint16;
typedef long int            CMC_sint32;
typedef unsigned short int  CMC_uint16;
typedef unsigned long int   CMC_uint32;
typedef void far *          CMC_buffer;
typedef char far *          CMC_string;
#endif

typedef CMC_uint16          CMC_boolean;
typedef CMC_sint32          CMC_enum;
typedef CMC_uint32          CMC_return_code;
typedef CMC_uint32          CMC_flags;
typedef CMC_string          CMC_object_identifier;

#define CMC_FALSE   ((CMC_boolean)0)
#define CMC_TRUE    ((CMC_boolean)1)

/*DATA STRUCTURES*/

/*COUNTED STRING*/
typedef struct {
    CMC_uint32          length;
    char                string[1];
} CMC_counted_string;

/*SESSION ID*/
typedef CMC_uint32      CMC_session_id;

/*TIME*/
/* unusedX fields needed to align struct on 4-byte boundary */
typedef struct {
    CMC_sint8           second;
    CMC_sint8           minute;
    CMC_sint8           hour;
    CMC_sint8           day;
    CMC_sint8           month;
    CMC_sint8           year;
    CMC_sint8           isdst;
    CMC_sint8           unused1;
    CMC_sint16          tmzone;
    CMC_sint16          unused2;
} CMC_time;

#define CMC_NO_TIMEZONE                     ((CMC_sint16) 0x8000)

typedef CMC_uint32          CMC_ui_id;

/*EXTENSION*/
typedef struct {
    CMC_uint32              item_code;
    CMC_uint32              item_data;
    CMC_buffer              item_reference;
    CMC_flags               extension_flags;
} CMC_extension;

/* EXTENSION FLAGS */
#define CMC_EXT_REQUIRED                    ((CMC_flags) 0x00010000)
#define CMC_EXT_OUTPUT                      ((CMC_flags) 0x00020000)
#define CMC_EXT_LAST_ELEMENT                ((CMC_flags) 0x80000000)
#define CMC_EXT_RSV_FLAG_MASK               ((CMC_flags) 0xFFFF0000)
#define CMC_EXT_ITEM_FLAG_MASK              ((CMC_flags) 0x0000FFFF)

/*ATTACHMENT*/
typedef struct {
    CMC_string              attach_title;
    CMC_object_identifier   attach_type;
    CMC_string              attach_filename;
    CMC_flags               attach_flags;
    CMC_extension FAR       *attach_extensions;
} CMC_attachment;

/* ATTACHMENT FLAGS */
#define CMC_ATT_APP_OWNS_FILE               ((CMC_flags) 1)
#define CMC_ATT_LAST_ELEMENT                ((CMC_flags) 0x80000000)

#define CMC_ATT_OID_BINARY                  "? ? ? ? ? ?"
#define CMC_ATT_OID_TEXT                    "? ? ? ? ? ?"

/*MESSAGE REFERENCE*/
typedef CMC_counted_string  CMC_message_reference;

/*RECIPIENT*/
typedef struct {
    CMC_string              name;
    CMC_enum                name_type;
    CMC_string              address;
    CMC_enum                role;
    CMC_flags               recip_flags;
    CMC_extension FAR       *recip_extensions;
} CMC_recipient;

/* NAME TYPES */
#define CMC_TYPE_UNKNOWN                    ((CMC_enum) 0)
#define CMC_TYPE_INDIVIDUAL                 ((CMC_enum) 1)
#define CMC_TYPE_GROUP                      ((CMC_enum) 2)

/* ROLES */
#define CMC_ROLE_TO                         ((CMC_enum) 0)
#define CMC_ROLE_CC                         ((CMC_enum) 1)
#define CMC_ROLE_BCC                        ((CMC_enum) 2)
#define CMC_ROLE_ORIGINATOR                 ((CMC_enum) 3)
#define CMC_ROLE_AUTHORIZING_USER           ((CMC_enum) 4)

/* RECIPIENT FLAGS */
#define CMC_RECIP_IGNORE                    ((CMC_flags) 1)
#define CMC_RECIP_LIST_TRUNCATED            ((CMC_flags) 2)
#define CMC_RECIP_LAST_ELEMENT              ((CMC_flags) 0x80000000)

/*MESSAGE*/
typedef struct {
    CMC_message_reference FAR   *message_reference;
    CMC_string              message_type;
    CMC_string              subject;
    CMC_time                time_sent;
    CMC_string              text_note;
    CMC_recipient FAR       *recipients;
    CMC_attachment FAR      *attachments;
    CMC_flags               message_flags;
    CMC_extension FAR       *message_extensions;
} CMC_message;

/* MESSAGE FLAGS */
#define CMC_MSG_READ                        ((CMC_flags) 1)
#define CMC_MSG_TEXT_NOTE_AS_FILE           ((CMC_flags) 2)
#define CMC_MSG_UNSENT                      ((CMC_flags) 4)
#define CMC_MSG_LAST_ELEMENT                ((CMC_flags) 0x80000000)

/*MESSAGE SUMMARY*/
typedef struct {
    CMC_message_reference FAR   *message_reference;
    CMC_string              message_type;
    CMC_string              subject;
    CMC_time                time_sent;
    CMC_uint32              byte_length;
    CMC_recipient FAR       *originator;
    CMC_flags               summary_flags;
    CMC_extension FAR       *message_summary_extensions;
} CMC_message_summary;

/* MESSAGE SUMMARY FLAGS */
#define CMC_SUM_READ                        ((CMC_flags) 1)
#define CMC_SUM_UNSENT                      ((CMC_flags) 2)
#define CMC_SUM_LAST_ELEMENT                ((CMC_flags) 0x80000000)

/*CMC FUNCTIONS */

/*CROSS FUNCTION FLAGS */
#define CMC_ERROR_UI_ALLOWED                ((CMC_flags) 0x01000000)
#define CMC_LOGON_UI_ALLOWED                ((CMC_flags) 0x02000000)
#define CMC_COUNTED_STRING_TYPE             ((CMC_flags) 0x04000000)

/*SEND*/
CMC_return_code FAR PASCAL
cmc_send(
    CMC_session_id          session,
    CMC_message FAR         *message,
    CMC_flags               send_flags,
    CMC_ui_id               ui_id,
    CMC_extension FAR       *send_extensions
);

#define CMC_SEND_UI_REQUESTED               ((CMC_flags) 1)

/*SEND DOCUMENT*/
CMC_return_code FAR PASCAL
cmc_send_documents(
    CMC_string              recipient_addresses,
    CMC_string              subject,
    CMC_string              text_note,
    CMC_flags               send_doc_flags,
    CMC_string              file_paths,
    CMC_string              file_names,
    CMC_string              delimiter,
    CMC_ui_id               ui_id
);

#define CMC_FIRST_ATTACH_AS_TEXT_NOTE       ((CMC_flags) 2)

/*ACT ON*/
CMC_return_code FAR PASCAL
cmc_act_on(
    CMC_session_id          session,
    CMC_message_reference FAR   *message_reference,
    CMC_enum                operation,
    CMC_flags               act_on_flags,
    CMC_ui_id               ui_id,
    CMC_extension FAR       *act_on_extensions
);

#define CMC_ACT_ON_EXTENDED                 ((CMC_enum) 0)
#define CMC_ACT_ON_DELETE                   ((CMC_enum) 1)

/*LIST*/
CMC_return_code FAR PASCAL
cmc_list(
    CMC_session_id          session,
    CMC_string              message_type,
    CMC_flags               list_flags,
    CMC_message_reference FAR   *seed,
    CMC_uint32 FAR          *count,
    CMC_ui_id               ui_id,
    CMC_message_summary FAR * FAR *result,
    CMC_extension FAR       *list_extensions
);

#define CMC_LIST_UNREAD_ONLY                ((CMC_flags) 1)
#define CMC_LIST_MSG_REFS_ONLY              ((CMC_flags) 2)
#define CMC_LIST_COUNT_ONLY                 ((CMC_flags) 4)

#define CMC_LENGTH_UNKNOWN          0xFFFFFFFF

/*READ*/
CMC_return_code FAR PASCAL
cmc_read(
    CMC_session_id          session,
    CMC_message_reference FAR   *message_reference,
    CMC_flags               read_flags,
    CMC_message FAR * FAR   *message,
    CMC_ui_id               ui_id,
    CMC_extension FAR       *read_extensions
);

#define CMC_DO_NOT_MARK_AS_READ             ((CMC_flags) 1)
#define CMC_MSG_AND_ATT_HDRS_ONLY           ((CMC_flags) 2)
#define CMC_READ_FIRST_UNREAD_MESSAGE       ((CMC_flags) 4)

/*LOOK UP*/
CMC_return_code FAR PASCAL
cmc_look_up(
    CMC_session_id          session,
    CMC_recipient FAR       *recipient_in,
    CMC_flags               look_up_flags,
    CMC_ui_id               ui_id,
    CMC_uint32 FAR          *count,
    CMC_recipient FAR * FAR *recipient_out,
    CMC_extension FAR       *look_up_extensions
);

#define CMC_LOOKUP_RESOLVE_PREFIX_SEARCH    ((CMC_flags) 1)
#define CMC_LOOKUP_RESOLVE_IDENTITY         ((CMC_flags) 2)
#define CMC_LOOKUP_RESOLVE_UI               ((CMC_flags) 4)
#define CMC_LOOKUP_DETAILS_UI               ((CMC_flags) 8)
#define CMC_LOOKUP_ADDRESSING_UI            ((CMC_flags) 16)

/*FREE*/
CMC_return_code FAR PASCAL
cmc_free(
    CMC_buffer              memory
);

/* LOGOFF */
CMC_return_code FAR PASCAL
cmc_logoff(
    CMC_session_id          session,
    CMC_ui_id               ui_id,
    CMC_flags               logoff_flags,
    CMC_extension FAR       *logoff_extensions
);

#define CMC_LOGOFF_UI_ALLOWED               ((CMC_flags) 1)

/* LOGON */
CMC_return_code FAR PASCAL
cmc_logon(
    CMC_string              service,
    CMC_string              user,
    CMC_string              password,
    CMC_object_identifier   character_set,
    CMC_ui_id               ui_id,
    CMC_uint16              caller_cmc_version,
    CMC_flags               logon_flags,
    CMC_session_id FAR      *session,
    CMC_extension FAR       *logon_extensions
);

#define CMC_VERSION         ((CMC_uint16) 100)

/* QUERY CONFIGURATION */
CMC_return_code FAR PASCAL
cmc_query_configuration(
    CMC_session_id          session,
    CMC_enum                item,
    CMC_buffer              reference,
    CMC_extension FAR       *config_extensions
);

/*QUERY CONFIGURATION ENUMS */
#define CMC_CONFIG_CHARACTER_SET            ((CMC_enum) 1)
#define CMC_CONFIG_LINE_TERM                ((CMC_enum) 2)
#define CMC_CONFIG_DEFAULT_SERVICE          ((CMC_enum) 3)
#define CMC_CONFIG_DEFAULT_USER             ((CMC_enum) 4)
#define CMC_CONFIG_REQ_PASSWORD             ((CMC_enum) 5)
#define CMC_CONFIG_REQ_SERVICE              ((CMC_enum) 6)
#define CMC_CONFIG_REQ_USER                 ((CMC_enum) 7)
#define CMC_CONFIG_UI_AVAIL                 ((CMC_enum) 8)
#define CMC_CONFIG_SUP_NOMKMSGREAD          ((CMC_enum) 9)
#define CMC_CONFIG_SUP_COUNTED_STR          ((CMC_enum) 10)
#define CMC_CONFIG_VER_IMPLEM               ((CMC_enum) 11)
#define CMC_CONFIG_VER_SPEC                 ((CMC_enum) 12)

/* CONFIG LINE TERM ENUM */
#define CMC_LINE_TERM_CRLF                  ((CMC_enum) 0)
#define CMC_LINE_TERM_CR                    ((CMC_enum) 1)
#define CMC_LINE_TERM_LF                    ((CMC_enum) 2)

/* CONFIG REQUIRED LOGON PARAMETER ENUM */
#define CMC_REQUIRED_NO                     ((CMC_enum) 0)
#define CMC_REQUIRED_YES                    ((CMC_enum) 1)
#define CMC_REQUIRED_OPT                    ((CMC_enum) 2)

/* DEFINED OBJECT ID'S FOR CHARACTER SETS */
#define CMC_CHAR_CP437                      "1 2 840 113556 3 2 437"
#define CMC_CHAR_CP850                      "1 2 840 113556 3 2 850"
#define CMC_CHAR_CP1252                     "1 2 840 113556 3 2 1252"
#define CMC_CHAR_ISTRING                    "1 2 840 113556 3 2 0"
#define CMC_CHAR_UNICODE                    "1 2 840 113556 3 2 1"

/* RETURN CODE FLAGS */
#define CMC_ERROR_DISPLAYED                 ((CMC_return_code) 0x00008000)
#define CMC_ERROR_RSV_MASK                  ((CMC_return_code) 0x0000FFFF)
#define CMC_ERROR_IMPL_MASK                 ((CMC_return_code) 0xFFFF0000)

/* RETURN CODES */
#define CMC_SUCCESS                         ((CMC_return_code) 0)

#define CMC_E_AMBIGUOUS_RECIPIENT           ((CMC_return_code) 1)
#define CMC_E_ATTACHMENT_NOT_FOUND          ((CMC_return_code) 2)
#define CMC_E_ATTACHMENT_OPEN_FAILURE       ((CMC_return_code) 3)
#define CMC_E_ATTACHMENT_READ_FAILURE       ((CMC_return_code) 4)
#define CMC_E_ATTACHMENT_WRITE_FAILURE      ((CMC_return_code) 5)
#define CMC_E_COUNTED_STRING_UNSUPPORTED    ((CMC_return_code) 6)
#define CMC_E_DISK_FULL                     ((CMC_return_code) 7)
#define CMC_E_FAILURE                       ((CMC_return_code) 8)
#define CMC_E_INSUFFICIENT_MEMORY           ((CMC_return_code) 9)
#define CMC_E_INVALID_CONFIGURATION         ((CMC_return_code) 10)
#define CMC_E_INVALID_ENUM                  ((CMC_return_code) 11)
#define CMC_E_INVALID_FLAG                  ((CMC_return_code) 12)
#define CMC_E_INVALID_MEMORY                ((CMC_return_code) 13)
#define CMC_E_INVALID_MESSAGE_PARAMETER     ((CMC_return_code) 14)
#define CMC_E_INVALID_MESSAGE_REFERENCE     ((CMC_return_code) 15)
#define CMC_E_INVALID_PARAMETER             ((CMC_return_code) 16)
#define CMC_E_INVALID_SESSION_ID            ((CMC_return_code) 17)
#define CMC_E_INVALID_UI_ID                 ((CMC_return_code) 18)
#define CMC_E_LOGON_FAILURE                 ((CMC_return_code) 19)
#define CMC_E_MESSAGE_IN_USE                ((CMC_return_code) 20)
#define CMC_E_NOT_SUPPORTED                 ((CMC_return_code) 21)
#define CMC_E_PASSWORD_REQUIRED             ((CMC_return_code) 22)
#define CMC_E_RECIPIENT_NOT_FOUND           ((CMC_return_code) 23)
#define CMC_E_SERVICE_UNAVAILABLE           ((CMC_return_code) 24)
#define CMC_E_TEXT_TOO_LARGE                ((CMC_return_code) 25)
#define CMC_E_TOO_MANY_FILES                ((CMC_return_code) 26)
#define CMC_E_TOO_MANY_RECIPIENTS           ((CMC_return_code) 27)
#define CMC_E_UNABLE_TO_NOT_MARK_AS_READ    ((CMC_return_code) 28)
#define CMC_E_UNRECOGNIZED_MESSAGE_TYPE     ((CMC_return_code) 29)
#define CMC_E_UNSUPPORTED_ACTION            ((CMC_return_code) 30)
#define CMC_E_UNSUPPORTED_CHARACTER_SET     ((CMC_return_code) 31)
#define CMC_E_UNSUPPORTED_DATA_EXT          ((CMC_return_code) 32)
#define CMC_E_UNSUPPORTED_FLAG              ((CMC_return_code) 33)
#define CMC_E_UNSUPPORTED_FUNCTION_EXT      ((CMC_return_code) 34)
#define CMC_E_UNSUPPORTED_VERSION           ((CMC_return_code) 35)
#define CMC_E_USER_CANCEL                   ((CMC_return_code) 36)
#define CMC_E_USER_NOT_LOGGED_ON            ((CMC_return_code) 37)

#ifdef __cplusplus
}       /* extern "C" */
#endif

#endif  /* _XCMC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\mapistub\mapistub\msvalidp.h ===
/*
 *	MSVALIDP.H
 *
 *	Header file listing methods to be validated
 *
 *      This file is included by ..\mapistub\mapi32.cpp to thunk extended
 *      MAPI calls such as HrValidateParameters
 *
 *      NOTE: This file also defines a static function GetArguments for
 *      non-INTEL platforms. This function is required in mapistub and
 *      it is safer to maintain it in one place.
 *
 */

#ifndef _MSVALIDP_H
#define _MSVALIDP_H

#ifdef __cplusplus
extern "C" {
#endif

/* Data tables in code segments makes the ValidateParameters dispatch quicker
   in 16bit, and geting strings out of the data segment saves space in Debug */
#ifdef WIN16
#define BASED_CODE			__based(__segname("_CODE"))
#define BASED_STACK			__based(__segname("_STACK"))
#else
#define BASED_CODE
#define BASED_STACK
#endif

#define TABLE_SORT_OLD			0
#define TABLE_SORT_EXTENDED		1

#if defined(_X86_) || defined( WIN16 )
#define _INTEL_
#endif

#define VALIDATE_CALLTYPE		static int NEAR
typedef int (NEAR * ValidateProc)(void BASED_STACK *);


/* Structures to overlay on stack frame to give us access to the parameters */
/* Structure names MUST be in the form 'Method_Params' and 'LPMethod_Params' for the
   following macros to work correctly */

#include "structs.h"

#define MAX_ARG			16    // Max number of args of functions to be
                                      // validated

/* Copied from edkmdb.h */
#define SHOW_SOFT_DELETES		((ULONG) 0x00000002)

/* Function declarations ------------------------------------------------------------------------ */


#if !defined (WX86_MAPISTUB)

#define MAKE_VALIDATE_FUNCTION(Method, Interface)	VALIDATE_CALLTYPE	Interface##_##Method##_Validate(void BASED_STACK *)

/* Empty function for non-debug 'validation' */

#else

#define MAKE_VALIDATE_FUNCTION(Method, Interface)	

#endif // WX86_MAPISTUB

// #ifndef DEBUG
#if !defined (DEBUG) || defined (WX86_MAPISTUB)
VALIDATE_CALLTYPE	DoNothing_Validate(void BASED_STACK *);
#endif

/* IUnknown */
MAKE_VALIDATE_FUNCTION(QueryInterface, IUnknown);
MAKE_VALIDATE_FUNCTION(AddRef, IUnknown);		   /* For completness */
MAKE_VALIDATE_FUNCTION(Release, IUnknown);		   /* For completness */

/* IMAPIProp */
MAKE_VALIDATE_FUNCTION(GetLastError, IMAPIProp);
MAKE_VALIDATE_FUNCTION(SaveChanges, IMAPIProp);
MAKE_VALIDATE_FUNCTION(GetProps, IMAPIProp);
MAKE_VALIDATE_FUNCTION(GetPropList, IMAPIProp);
MAKE_VALIDATE_FUNCTION(OpenProperty, IMAPIProp);
MAKE_VALIDATE_FUNCTION(SetProps, IMAPIProp);
MAKE_VALIDATE_FUNCTION(DeleteProps, IMAPIProp);
MAKE_VALIDATE_FUNCTION(CopyTo, IMAPIProp);
MAKE_VALIDATE_FUNCTION(CopyProps, IMAPIProp);
MAKE_VALIDATE_FUNCTION(GetNamesFromIDs, IMAPIProp);
MAKE_VALIDATE_FUNCTION(GetIDsFromNames, IMAPIProp);

/* IMAPITable */
MAKE_VALIDATE_FUNCTION(GetLastError, IMAPITable);
MAKE_VALIDATE_FUNCTION(Advise, IMAPITable);
MAKE_VALIDATE_FUNCTION(Unadvise, IMAPITable);
MAKE_VALIDATE_FUNCTION(GetStatus, IMAPITable);
MAKE_VALIDATE_FUNCTION(SetColumns, IMAPITable);
MAKE_VALIDATE_FUNCTION(QueryColumns, IMAPITable);
MAKE_VALIDATE_FUNCTION(GetRowCount, IMAPITable);
MAKE_VALIDATE_FUNCTION(SeekRow, IMAPITable);
MAKE_VALIDATE_FUNCTION(SeekRowApprox, IMAPITable);
MAKE_VALIDATE_FUNCTION(QueryPosition, IMAPITable);
MAKE_VALIDATE_FUNCTION(FindRow, IMAPITable);
MAKE_VALIDATE_FUNCTION(Restrict, IMAPITable);
MAKE_VALIDATE_FUNCTION(CreateBookmark, IMAPITable);
MAKE_VALIDATE_FUNCTION(FreeBookmark, IMAPITable);
MAKE_VALIDATE_FUNCTION(SortTable, IMAPITable);
MAKE_VALIDATE_FUNCTION(QuerySortOrder, IMAPITable);
MAKE_VALIDATE_FUNCTION(QueryRows, IMAPITable);
MAKE_VALIDATE_FUNCTION(Abort, IMAPITable);
MAKE_VALIDATE_FUNCTION(ExpandRow, IMAPITable);
MAKE_VALIDATE_FUNCTION(CollapseRow, IMAPITable);
MAKE_VALIDATE_FUNCTION(WaitForCompletion, IMAPITable);
MAKE_VALIDATE_FUNCTION(GetCollapseState, IMAPITable);
MAKE_VALIDATE_FUNCTION(SetCollapseState, IMAPITable);

/* IMAPIStatus */
MAKE_VALIDATE_FUNCTION(ValidateState, IMAPIStatus);
MAKE_VALIDATE_FUNCTION(SettingsDialog, IMAPIStatus);
MAKE_VALIDATE_FUNCTION(ChangePassword, IMAPIStatus);
MAKE_VALIDATE_FUNCTION(FlushQueues, IMAPIStatus);

/* IMAPIContainer */
MAKE_VALIDATE_FUNCTION(GetContentsTable, IMAPIContainer);
MAKE_VALIDATE_FUNCTION(GetHierarchyTable, IMAPIContainer);
MAKE_VALIDATE_FUNCTION(OpenEntry, IMAPIContainer);
MAKE_VALIDATE_FUNCTION(SetSearchCriteria, IMAPIContainer);
MAKE_VALIDATE_FUNCTION(GetSearchCriteria, IMAPIContainer);

/* IABContainer */
MAKE_VALIDATE_FUNCTION(CreateEntry, IABContainer);
MAKE_VALIDATE_FUNCTION(CopyEntries, IABContainer);
MAKE_VALIDATE_FUNCTION(DeleteEntries, IABContainer);
MAKE_VALIDATE_FUNCTION(ResolveNames, IABContainer);

/* IDistList */
MAKE_VALIDATE_FUNCTION(CreateEntry, IDistList);
MAKE_VALIDATE_FUNCTION(CopyEntries, IDistList);
MAKE_VALIDATE_FUNCTION(DeleteEntries, IDistList);
MAKE_VALIDATE_FUNCTION(ResolveNames, IDistList);

/* IMAPIFolder */
MAKE_VALIDATE_FUNCTION(CreateMessage, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(CopyMessages, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(DeleteMessages, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(CreateFolder, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(CopyFolder, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(DeleteFolder, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(SetReadFlags, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(GetMessageStatus, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(SetMessageStatus, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(SaveContentsSort, IMAPIFolder);
MAKE_VALIDATE_FUNCTION(EmptyFolder, IMAPIFolder);

/* IMsgStore */
MAKE_VALIDATE_FUNCTION(Advise, IMsgStore);
MAKE_VALIDATE_FUNCTION(Unadvise, IMsgStore);
MAKE_VALIDATE_FUNCTION(CompareEntryIDs, IMsgStore);
MAKE_VALIDATE_FUNCTION(OpenEntry, IMsgStore);
MAKE_VALIDATE_FUNCTION(SetReceiveFolder, IMsgStore);
MAKE_VALIDATE_FUNCTION(GetReceiveFolder, IMsgStore);
MAKE_VALIDATE_FUNCTION(GetReceiveFolderTable, IMsgStore);
MAKE_VALIDATE_FUNCTION(StoreLogoff, IMsgStore);
MAKE_VALIDATE_FUNCTION(AbortSubmit, IMsgStore);
MAKE_VALIDATE_FUNCTION(GetOutgoingQueue, IMsgStore);
MAKE_VALIDATE_FUNCTION(SetLockState, IMsgStore);
MAKE_VALIDATE_FUNCTION(FinishedMsg, IMsgStore);
MAKE_VALIDATE_FUNCTION(NotifyNewMail, IMsgStore);

/* IMessage */
MAKE_VALIDATE_FUNCTION(GetAttachmentTable, IMessage);
MAKE_VALIDATE_FUNCTION(OpenAttach, IMessage);
MAKE_VALIDATE_FUNCTION(CreateAttach, IMessage);
MAKE_VALIDATE_FUNCTION(DeleteAttach, IMessage);
MAKE_VALIDATE_FUNCTION(GetRecipientTable, IMessage);
MAKE_VALIDATE_FUNCTION(ModifyRecipients, IMessage);
MAKE_VALIDATE_FUNCTION(SubmitMessage, IMessage);
MAKE_VALIDATE_FUNCTION(SetReadFlag, IMessage);


/* IABProvider */
MAKE_VALIDATE_FUNCTION(Shutdown, IABProvider);
MAKE_VALIDATE_FUNCTION(Logon, IABProvider);

/* IABLogon */
MAKE_VALIDATE_FUNCTION(GetLastError, IABLogon);
MAKE_VALIDATE_FUNCTION(Logoff, IABLogon);
MAKE_VALIDATE_FUNCTION(OpenEntry, IABLogon);
MAKE_VALIDATE_FUNCTION(CompareEntryIDs, IABLogon);
MAKE_VALIDATE_FUNCTION(Advise, IABLogon);
MAKE_VALIDATE_FUNCTION(Unadvise, IABLogon);
MAKE_VALIDATE_FUNCTION(OpenStatusEntry, IABLogon);
MAKE_VALIDATE_FUNCTION(OpenTemplateID, IABLogon);
MAKE_VALIDATE_FUNCTION(GetOneOffTable, IABLogon);
MAKE_VALIDATE_FUNCTION(PrepareRecips, IABLogon);

/* IXPProvider */
MAKE_VALIDATE_FUNCTION(Shutdown, IXPProvider);
MAKE_VALIDATE_FUNCTION(TransportLogon, IXPProvider);

/* IXPLogon */
MAKE_VALIDATE_FUNCTION(AddressTypes, IXPLogon);
MAKE_VALIDATE_FUNCTION(RegisterOptions, IXPLogon);
MAKE_VALIDATE_FUNCTION(TransportNotify, IXPLogon);
MAKE_VALIDATE_FUNCTION(Idle, IXPLogon);
MAKE_VALIDATE_FUNCTION(TransportLogoff, IXPLogon);
MAKE_VALIDATE_FUNCTION(SubmitMessage, IXPLogon);
MAKE_VALIDATE_FUNCTION(EndMessage, IXPLogon);
MAKE_VALIDATE_FUNCTION(Poll, IXPLogon);
MAKE_VALIDATE_FUNCTION(StartMessage, IXPLogon);
MAKE_VALIDATE_FUNCTION(OpenStatusEntry, IXPLogon);
MAKE_VALIDATE_FUNCTION(ValidateState, IXPLogon);
MAKE_VALIDATE_FUNCTION(FlushQueues, IXPLogon);

/* IMSProvider */
MAKE_VALIDATE_FUNCTION(Shutdown, IMSProvider);
MAKE_VALIDATE_FUNCTION(Logon, IMSProvider);
MAKE_VALIDATE_FUNCTION(SpoolerLogon, IMSProvider);
MAKE_VALIDATE_FUNCTION(CompareStoreIDs, IMSProvider);

/* IMSLogon */
MAKE_VALIDATE_FUNCTION(GetLastError, IMSLogon);
MAKE_VALIDATE_FUNCTION(Logoff, IMSLogon);
MAKE_VALIDATE_FUNCTION(OpenEntry, IMSLogon);
MAKE_VALIDATE_FUNCTION(CompareEntryIDs, IMSLogon);
MAKE_VALIDATE_FUNCTION(Advise, IMSLogon);
MAKE_VALIDATE_FUNCTION(Unadvise, IMSLogon);
MAKE_VALIDATE_FUNCTION(OpenStatusEntry, IMSLogon);

/* IMAPIControl */
MAKE_VALIDATE_FUNCTION(GetLastError, IMAPIControl);
MAKE_VALIDATE_FUNCTION(Activate, IMAPIControl);
MAKE_VALIDATE_FUNCTION(GetState, IMAPIControl);

/* IStream */
MAKE_VALIDATE_FUNCTION(Read, IStream);
MAKE_VALIDATE_FUNCTION(Write, IStream);
MAKE_VALIDATE_FUNCTION(Seek, IStream);
MAKE_VALIDATE_FUNCTION(SetSize, IStream);
MAKE_VALIDATE_FUNCTION(CopyTo, IStream);
MAKE_VALIDATE_FUNCTION(Commit, IStream);
MAKE_VALIDATE_FUNCTION(Revert, IStream);
MAKE_VALIDATE_FUNCTION(LockRegion, IStream);
MAKE_VALIDATE_FUNCTION(UnlockRegion, IStream);
MAKE_VALIDATE_FUNCTION(Stat, IStream);
MAKE_VALIDATE_FUNCTION(Clone, IStream);

/* IMAPIAdviseSink */
MAKE_VALIDATE_FUNCTION(OnNotify, IMAPIAdviseSink);

/* IMAPITable */
MAKE_VALIDATE_FUNCTION(SortTableEx, IMAPITable);

/* Table of validation functions and Offsets of the This member of the Params structure --------- */
typedef struct _tagMethodEntry
{
	ValidateProc		pfnValidation;			// Validation function for this method
#if !defined(_INTEL_) || defined(DEBUG)
	UINT				cParameterSize;			// Expected size of parameters for stack validation
#endif
#if defined (WX86_MAPISTUB)
        Wx86MapiArgThunkInfo*  pThunk;
#endif
} METHODENTRY;


#if !defined(_INTEL_) || defined(DEBUG)

#if !defined (WX86_MAPISTUB)

#define MAKE_PERM_ENTRY(Method, Interface)	 { Interface##_##Method##_Validate, sizeof(Interface##_##Method##_Params) }

#else

#define MAKE_PERM_ENTRY(Method, Interface)	 { DoNothing_Validate, sizeof(Interface##_##Method##_Params), Interface##_##Method##_Thunk }

#endif // WX86_MAPISTUB

#else
#define MAKE_PERM_ENTRY(Method, Interface)	 { Interface##_##Method##_Validate }
#endif

#if defined(DEBUG) && !defined(WX86_MAPISTUB)
#define MAKE_TEMP_ENTRY(Method, Interface)	 { Interface##_##Method##_Validate, sizeof(Interface##_##Method##_Params) }
#else
#define MAKE_TEMP_ENTRY(Method, Interface)	 { DoNothing_Validate }
#endif


METHODENTRY BASED_CODE meMethodTable[] =
{
/* IUnknown */
	MAKE_PERM_ENTRY(QueryInterface, IUnknown),
	MAKE_PERM_ENTRY(AddRef, IUnknown),
	MAKE_PERM_ENTRY(Release, IUnknown),

/* IMAPIProp */
	MAKE_PERM_ENTRY(GetLastError, IMAPIProp),
	MAKE_PERM_ENTRY(SaveChanges, IMAPIProp),
	MAKE_PERM_ENTRY(GetProps, IMAPIProp),
	MAKE_PERM_ENTRY(GetPropList, IMAPIProp),
	MAKE_PERM_ENTRY(OpenProperty, IMAPIProp),
	MAKE_PERM_ENTRY(SetProps, IMAPIProp),
	MAKE_PERM_ENTRY(DeleteProps, IMAPIProp),
	MAKE_PERM_ENTRY(CopyTo, IMAPIProp),
	MAKE_PERM_ENTRY(CopyProps, IMAPIProp),
	MAKE_PERM_ENTRY(GetNamesFromIDs, IMAPIProp),
	MAKE_PERM_ENTRY(GetIDsFromNames, IMAPIProp),

/* IMAPITable */
	MAKE_PERM_ENTRY(GetLastError, IMAPITable),
	MAKE_PERM_ENTRY(Advise, IMAPITable),
	MAKE_PERM_ENTRY(Unadvise, IMAPITable),
	MAKE_PERM_ENTRY(GetStatus, IMAPITable),
	MAKE_PERM_ENTRY(SetColumns, IMAPITable),
	MAKE_PERM_ENTRY(QueryColumns, IMAPITable),
	MAKE_PERM_ENTRY(GetRowCount, IMAPITable),
	MAKE_PERM_ENTRY(SeekRow, IMAPITable),
	MAKE_PERM_ENTRY(SeekRowApprox, IMAPITable),
	MAKE_PERM_ENTRY(QueryPosition, IMAPITable),
	MAKE_PERM_ENTRY(FindRow, IMAPITable),
	MAKE_PERM_ENTRY(Restrict, IMAPITable),
	MAKE_PERM_ENTRY(CreateBookmark, IMAPITable),
	MAKE_PERM_ENTRY(FreeBookmark, IMAPITable),
	MAKE_PERM_ENTRY(SortTable, IMAPITable),
	MAKE_PERM_ENTRY(QuerySortOrder, IMAPITable),
	MAKE_PERM_ENTRY(QueryRows, IMAPITable),
	MAKE_PERM_ENTRY(Abort, IMAPITable),
	MAKE_PERM_ENTRY(ExpandRow, IMAPITable),
	MAKE_PERM_ENTRY(CollapseRow, IMAPITable),
	MAKE_PERM_ENTRY(WaitForCompletion, IMAPITable),
	MAKE_PERM_ENTRY(GetCollapseState, IMAPITable),
	MAKE_PERM_ENTRY(SetCollapseState, IMAPITable),

/* IMAPIContainer */
	MAKE_PERM_ENTRY(GetContentsTable, IMAPIContainer),
	MAKE_PERM_ENTRY(GetHierarchyTable, IMAPIContainer),
	MAKE_PERM_ENTRY(OpenEntry, IMAPIContainer),
	MAKE_PERM_ENTRY(SetSearchCriteria, IMAPIContainer),
	MAKE_PERM_ENTRY(GetSearchCriteria, IMAPIContainer),

/* IABContainer */
	MAKE_PERM_ENTRY(CreateEntry, IABContainer),
	MAKE_PERM_ENTRY(CopyEntries, IABContainer),
	MAKE_PERM_ENTRY(DeleteEntries, IABContainer),
	MAKE_PERM_ENTRY(ResolveNames, IABContainer),

/* IDistList same as IABContainer */
	MAKE_PERM_ENTRY(CreateEntry, IDistList),
	MAKE_PERM_ENTRY(CopyEntries, IDistList),
	MAKE_PERM_ENTRY(DeleteEntries, IDistList),
	MAKE_PERM_ENTRY(ResolveNames, IDistList),

/* IMAPIFolder */
	MAKE_PERM_ENTRY(CreateMessage, IMAPIFolder),
	MAKE_PERM_ENTRY(CopyMessages, IMAPIFolder),
	MAKE_PERM_ENTRY(DeleteMessages, IMAPIFolder),
	MAKE_PERM_ENTRY(CreateFolder, IMAPIFolder),
	MAKE_PERM_ENTRY(CopyFolder, IMAPIFolder),
	MAKE_PERM_ENTRY(DeleteFolder, IMAPIFolder),
	MAKE_PERM_ENTRY(SetReadFlags, IMAPIFolder),
	MAKE_PERM_ENTRY(GetMessageStatus, IMAPIFolder),
	MAKE_PERM_ENTRY(SetMessageStatus, IMAPIFolder),
	MAKE_PERM_ENTRY(SaveContentsSort, IMAPIFolder),
	MAKE_PERM_ENTRY(EmptyFolder, IMAPIFolder),

/* IMsgStore */
	MAKE_PERM_ENTRY(Advise, IMsgStore),
	MAKE_PERM_ENTRY(Unadvise, IMsgStore),
	MAKE_PERM_ENTRY(CompareEntryIDs, IMsgStore),
	MAKE_PERM_ENTRY(OpenEntry, IMsgStore),
	MAKE_PERM_ENTRY(SetReceiveFolder, IMsgStore),
	MAKE_PERM_ENTRY(GetReceiveFolder, IMsgStore),
	MAKE_PERM_ENTRY(GetReceiveFolderTable, IMsgStore),
	MAKE_PERM_ENTRY(StoreLogoff, IMsgStore),
	MAKE_PERM_ENTRY(AbortSubmit, IMsgStore),
	MAKE_PERM_ENTRY(GetOutgoingQueue, IMsgStore),
	MAKE_PERM_ENTRY(SetLockState, IMsgStore),
	MAKE_PERM_ENTRY(FinishedMsg, IMsgStore),
	MAKE_PERM_ENTRY(NotifyNewMail, IMsgStore),

/* IMessage */
	MAKE_PERM_ENTRY(GetAttachmentTable, IMessage),
	MAKE_PERM_ENTRY(OpenAttach, IMessage),
	MAKE_PERM_ENTRY(CreateAttach, IMessage),
	MAKE_PERM_ENTRY(DeleteAttach, IMessage),
	MAKE_PERM_ENTRY(GetRecipientTable, IMessage),
	MAKE_PERM_ENTRY(ModifyRecipients, IMessage),
	MAKE_PERM_ENTRY(SubmitMessage, IMessage),
	MAKE_PERM_ENTRY(SetReadFlag, IMessage),


/* IABProvider */
	MAKE_TEMP_ENTRY(Shutdown, IABProvider),
	MAKE_TEMP_ENTRY(Logon, IABProvider),

/* IABLogon */
	MAKE_TEMP_ENTRY(GetLastError, IABLogon),
	MAKE_TEMP_ENTRY(Logoff, IABLogon),
	MAKE_TEMP_ENTRY(OpenEntry, IABLogon),
	MAKE_TEMP_ENTRY(CompareEntryIDs, IABLogon),
	MAKE_TEMP_ENTRY(Advise, IABLogon),
	MAKE_TEMP_ENTRY(Unadvise, IABLogon),
	MAKE_TEMP_ENTRY(OpenStatusEntry, IABLogon),
	MAKE_TEMP_ENTRY(OpenTemplateID, IABLogon),
	MAKE_TEMP_ENTRY(GetOneOffTable, IABLogon),
	MAKE_TEMP_ENTRY(PrepareRecips, IABLogon),

/* IXPProvider */
	MAKE_TEMP_ENTRY(Shutdown, IXPProvider),
	MAKE_TEMP_ENTRY(TransportLogon, IXPProvider),

/* IXPLogon */
	MAKE_TEMP_ENTRY(AddressTypes, IXPLogon),
	MAKE_TEMP_ENTRY(RegisterOptions, IXPLogon),
	MAKE_TEMP_ENTRY(TransportNotify, IXPLogon),
	MAKE_TEMP_ENTRY(Idle, IXPLogon),
	MAKE_TEMP_ENTRY(TransportLogoff, IXPLogon),
	MAKE_TEMP_ENTRY(SubmitMessage, IXPLogon),
	MAKE_TEMP_ENTRY(EndMessage, IXPLogon),
	MAKE_TEMP_ENTRY(Poll, IXPLogon),
	MAKE_TEMP_ENTRY(StartMessage, IXPLogon),
	MAKE_TEMP_ENTRY(OpenStatusEntry, IXPLogon),
	MAKE_TEMP_ENTRY(ValidateState, IXPLogon),
	MAKE_TEMP_ENTRY(FlushQueues, IXPLogon),

/* IMSProvider */
	MAKE_TEMP_ENTRY(Shutdown, IMSProvider),
	MAKE_TEMP_ENTRY(Logon, IMSProvider),
	MAKE_TEMP_ENTRY(SpoolerLogon, IMSProvider),
	MAKE_TEMP_ENTRY(CompareStoreIDs, IMSProvider),

/* IMSLogon */
	MAKE_TEMP_ENTRY(GetLastError, IMSLogon),
	MAKE_TEMP_ENTRY(Logoff, IMSLogon),
	MAKE_TEMP_ENTRY(OpenEntry, IMSLogon),
	MAKE_TEMP_ENTRY(CompareEntryIDs, IMSLogon),
	MAKE_TEMP_ENTRY(Advise, IMSLogon),
	MAKE_TEMP_ENTRY(Unadvise, IMSLogon),
	MAKE_TEMP_ENTRY(OpenStatusEntry, IMSLogon),

/* IMAPIControl */
	MAKE_PERM_ENTRY(GetLastError, IMAPIControl),
	MAKE_PERM_ENTRY(Activate, IMAPIControl),
	MAKE_PERM_ENTRY(GetState, IMAPIControl),

/* IMAPIStatus */
	MAKE_PERM_ENTRY(ValidateState, IMAPIStatus),
	MAKE_PERM_ENTRY(SettingsDialog, IMAPIStatus),
	MAKE_PERM_ENTRY(ChangePassword, IMAPIStatus),
	MAKE_PERM_ENTRY(FlushQueues, IMAPIStatus),

/* IStream */
	MAKE_PERM_ENTRY(Read, IStream),
	MAKE_PERM_ENTRY(Write, IStream),
	MAKE_PERM_ENTRY(Seek, IStream),
	MAKE_PERM_ENTRY(SetSize, IStream),
	MAKE_PERM_ENTRY(CopyTo, IStream),
	MAKE_PERM_ENTRY(Commit, IStream),
	MAKE_PERM_ENTRY(Revert, IStream),
	MAKE_PERM_ENTRY(LockRegion, IStream),
	MAKE_PERM_ENTRY(UnlockRegion, IStream),
	MAKE_PERM_ENTRY(Stat, IStream),
	MAKE_PERM_ENTRY(Clone, IStream),

/* IMAPIAdviseSink */
	MAKE_PERM_ENTRY(OnNotify, IMAPIAdviseSink),

/* IMAPITable */	
	MAKE_PERM_ENTRY(SortTableEx, IMAPITable),

};

#if !defined(_INTEL_)

#define FSPECIALMETHOD(m)	(  m == IStream_Seek \
							|| m == IStream_SetSize \
							|| m == IStream_CopyTo \
							|| m == IStream_LockRegion \
							|| m == IStream_UnlockRegion \
							)

static void GetArguments(METHODS eMethod, va_list arglist, LPVOID *rgArg)
{
	// Handle methods whose arguments can be of a size other than that of
	// an LPVOID. Each argument is grabbed off of the list and laid out
	// into the validation structure for the method overlayed on top of
	// the argument buffer passed in.

	AssertSz(FIsAligned(rgArg), "GetArguments: Unaligned argument buffer passed in");

	switch( eMethod )
	{
		case IStream_Seek:
		{
			LPIStream_Seek_Params	p = (LPIStream_Seek_Params) rgArg;

			p->This 			= 	va_arg(arglist, LPVOID);
			p->dlibMove  		= 	va_arg(arglist, LARGE_INTEGER);
			p->dwOrigin 		= 	va_arg(arglist, DWORD);
			p->plibNewPosition 	= 	va_arg(arglist, ULARGE_INTEGER FAR *);

			AssertSz( (MAX_ARG * sizeof(LPVOID)) >= ( (p+1) - p ),
					  "Method being validated overflowed argument buffer");
			break;
		}

		case IStream_SetSize:
		{
			LPIStream_SetSize_Params	p = (LPIStream_SetSize_Params) rgArg;

			p->This 			= 	va_arg(arglist, LPVOID);
			p->libNewSize		= 	va_arg(arglist, ULARGE_INTEGER);

			AssertSz( (MAX_ARG * sizeof(LPVOID)) >= ( (p+1) - p ),
					  "Method being validated overflowed argument buffer");
			break;
		}

		case IStream_CopyTo:
		{
			LPIStream_CopyTo_Params	p = (LPIStream_CopyTo_Params) rgArg;

			p->This 			= 	va_arg(arglist, LPVOID);
			p->pstm 			= 	va_arg(arglist, IStream FAR *);
			p->cb 		 		= 	va_arg(arglist, ULARGE_INTEGER);
			p->pcbRead 			= 	va_arg(arglist, ULARGE_INTEGER FAR *);
			p->pcbWritten 		= 	va_arg(arglist, ULARGE_INTEGER FAR *);

			AssertSz( (MAX_ARG * sizeof(LPVOID)) >= ( (p+1) - p ),
					  "Method being validated overflowed argument buffer");
			break;
		}

		case IStream_LockRegion:
		{
			LPIStream_LockRegion_Params	p = (LPIStream_LockRegion_Params) rgArg;

			p->This 			= 	va_arg(arglist, LPVOID);
			p->libOffset  		= 	va_arg(arglist, ULARGE_INTEGER);
			p->cb 				= 	va_arg(arglist, ULARGE_INTEGER);
			p->dwLockType 		= 	va_arg(arglist, DWORD);

			AssertSz( (MAX_ARG * sizeof(LPVOID)) >= ( (p+1) - p ),
					  "Method being validated overflowed argument buffer");
			break;
		}

		case IStream_UnlockRegion:
		{
			LPIStream_UnlockRegion_Params	p = (LPIStream_UnlockRegion_Params) rgArg;

			p->This 			= 	va_arg(arglist, LPVOID);
			p->libOffset 	 	= 	va_arg(arglist, ULARGE_INTEGER);
			p->cb 				= 	va_arg(arglist, ULARGE_INTEGER);
			p->dwLockType 		= 	va_arg(arglist, DWORD);

			AssertSz( (MAX_ARG * sizeof(LPVOID)) >= ( (p+1) - p ),
					  "Method being validated overflowed argument buffer");
			break;
		}

		default:

			AssertSz(FALSE, "Custom argument handling for call being validated NYI");
			break;
	}
}

#if defined (WX86_MAPISTUB)

// Handle methods whose arguments can be of a size other than that of
// an LPVOID. This should be updated along with GetArguments

#define Wx86MapiCallHrValidateParametersV(eMethod, rgArg, hr) \
    switch( eMethod ) \
    { \
        case IStream_Seek: \
        { \
            hr = HrValidateParametersV(eMethod, rgArg[0],  \
                                       *((ULARGE_INTEGER *) &rgArg[1]), \
                                       rgArg[3], rgArg[4]); \
            break; \
        } \
 \
        case IStream_SetSize: \
        { \
            hr = HrValidateParametersV(eMethod, rgArg[0],  \
                                       *((ULARGE_INTEGER *) &rgArg[1])); \
            break; \
        } \
 \
        case IStream_CopyTo: \
        { \
            hr = HrValidateParametersV(eMethod, rgArg[0], rgArg[1], \
                                       *((ULARGE_INTEGER *) &rgArg[2]), \
                                       rgArg[4], rgArg[5]); \
            break; \
        } \
 \
        case IStream_LockRegion: \
        { \
            hr = HrValidateParametersV(eMethod, rgArg[0],  \
                                       *((ULARGE_INTEGER *) &rgArg[1]), \
                                       *((ULARGE_INTEGER *) &rgArg[3]), \
                                       rgArg[5]); \
            break; \
        } \
 \
        case IStream_UnlockRegion: \
        { \
            hr = HrValidateParametersV(eMethod, rgArg[0],  \
                                       *((ULARGE_INTEGER *) &rgArg[1]), \
                                       *((ULARGE_INTEGER *) &rgArg[3]), \
                                       rgArg[5]); \
            break; \
        } \
 \
        default: \
 \
            AssertSz(FALSE, \
                    "Custom parameter passing for call being validated NYI"); \
            break; \
    }
#endif // WX86_MAPISTUB

#endif // _INTEL_


#ifdef __cplusplus
}
#endif

#endif // _MSVALIDP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\mapistub\mapistub\_mapiu.h ===
/*
 *      _ M A P I U . H
 *      
 *      Non-public MACROs and FUNCTIONs which may be used by MAPI
 *
 *      Used in conjunction with routines found in MAPIU.DLL.
 *      
 *      Copyright 1992-93 Microsoft Corporation.  All Rights Reserved.
 */

#ifndef _MAPIU_H
#define _MAPIU_H

#ifdef __cplusplus
extern "C" {
#endif

#ifndef MAPIUTIL_H
#include        <mapiutil.h>
#endif
#include        <stddef.h>

/* Declarations for Global data defined by MAPIU
 */

#if defined(WIN32) && !defined(MAC)
#ifndef DATA1_BEGIN
#include "mapiperf.h"
#endif
#pragma DATA1_BEGIN
extern CRITICAL_SECTION csUnkobjInit;
#pragma DATA_END
#endif

extern TCHAR    szEmpty[];

/* Macros provided by MAPIU
 */
#ifndef CharSizeOf
#define CharSizeOf(x)   (sizeof(x) / sizeof(TCHAR))
#endif

//      Alignment

#define AlignN(n, x)            (((x)+(1<<(n))-1) & ~((1<<(n))-1))
#define Align2(x)                       AlignN(1,(x))
#define Align4(x)                       AlignN(2,(x))
#define Align8(x)                       AlignN(3,(x))

#if defined (_MIPS_) || defined (_ALPHA_) || defined (_PPC_)
#define AlignNatural(cb)                        Align8(cb)
#elif defined (WIN32)
#define AlignNatural(cb)                        Align4(cb)
#else // defined (WIN16)
#define AlignNatural(cb)                        Align2(cb)
#endif

#define FIsAligned(p)                           (AlignNatural((ULONG)((LPVOID)p)) == (ULONG)((LPVOID)p))
#define FIsAlignedCb(cb)                        (AlignNatural((ULONG)(cb)) == (ULONG)(cb))

/* Prototypes for private math functions
 */
STDAPI_(DWORD)
DwDivFtDw( FILETIME ftDividend, DWORD dwDivisor);

VOID
VSzFromIDS(ULONG ulIDS, UINT uncchBuffer, LPWSTR lpszBuffer, ULONG ulFlags);

/* Prototype for LoadString wrapper
 * Utility to allocate memory and loadstring and string IDS, ANSI/UNICODE.
 */ 
 
#define MAX_CCH_IDS             256
SCODE ScStringFromIDS( LPALLOCATEBUFFER lpMapiAllocBuffer, ULONG ulFlags, UINT ids, 
                LPTSTR * lppszIDS );

/* Prototypes for Message and Dialog Box utilities.
 */
SCODE
ScMessageBoxIDS( ULONG  ulUIParam,
                                 UINT   idsCaption,
                                 UINT   idsMessage,
                                 UINT   uMBType);

/* Prototypes for MAPI status utilities.
 */
BOOL
FProfileLoggedOn( LPSTR szProfileName);

/* Prototypes for functions used to validate complex parameters.
 */

#ifndef __cplusplus
#define FBadIfacePtr(param, iface)                                      \
                (       IsBadReadPtr((param), sizeof(iface))    \
                 ||     IsBadReadPtr((param)->lpVtbl, sizeof(iface##Vtbl)))
#else
#define FBadIfacePtr(param, iface)      (FALSE)
#endif

/*
 *      FBadDelPTA
 *
 *      Returns TRUE if the given Prop Tag Array is readable and contains only
 *      prop tags which are valid for a DeleteProps (or related) call.
 */
STDAPI_(BOOL)
FBadDelPTA(LPSPropTagArray lpPropTagArray);


/*
 *      IListedPropID
 *
 *  Purpose
 *              If a tag with ID == PROP_ID(ulPropTag) is listed in lptaga then
 *              the index of tag is returned.  If the tag is not in lptaga then
 *              -1 is returned.
 *
 *      Arguments
 *              ulPropTag       Property tag to locate.
 *              lptaga          Property tag array to search.
 *
 *      Returns         TRUE or FALSE
 */
_inline LONG
IListedPropID( ULONG                    ulPropTag,
                           LPSPropTagArray      lptaga)
{
        ULONG FAR       *lpulPTag;

        /* No tag is contained in a NULL list of tags.
         */
    if (!lptaga)
        {
                return -1;
        }

        /* Mutate ulPropTag to just a PROP_ID.
         */
    ulPropTag = PROP_ID(ulPropTag);

        for ( lpulPTag = lptaga->aulPropTag + lptaga->cValues
                ; --lpulPTag >= lptaga->aulPropTag
                ; )
        {
                /* Compare PROP_ID's.
                 */
                if (PROP_ID(*lpulPTag) == ulPropTag)
                {
                        return (LONG)(lpulPTag - lptaga->aulPropTag);
                }
        }

        return -1;
}

/*
 *      FListedPropID
 *
 *  Purpose
 *              Determine if a tag with ID == PROP_ID(ulPropTag) is listed in lptaga.
 *
 *      Arguments
 *              ulPropTag       Property tag to locate.
 *              lptaga          Property tag array to search.
 *
 *      Returns         TRUE or FALSE
 */
_inline BOOL
FListedPropID( ULONG                    ulPropTag,
                           LPSPropTagArray      lptaga)
{
        ULONG FAR       *lpulPTag;

        /* No tag is contained in a NULL list of tags.
         */
    if (!lptaga)
        {
                return FALSE;
        }

        /* Mutate ulPropTag to just a PROP_ID.
         */
    ulPropTag = PROP_ID(ulPropTag);

        for ( lpulPTag = lptaga->aulPropTag + lptaga->cValues
                ; --lpulPTag >= lptaga->aulPropTag
                ; )
        {
                /* Compare PROP_ID's.
                 */
                if (PROP_ID(*lpulPTag) == ulPropTag)
                {
                        return TRUE;
                }
        }

        return FALSE;
}

/*
 *      FListedPropTAG
 *
 *  Purpose
 *              Determine if a the given ulPropTag is listed in lptaga.
 *
 *      Arguments
 *              ulPropTag       Property tag to locate.
 *              lptaga          Property tag array to search.
 *
 *      Returns         TRUE or FALSE
 */
_inline BOOL
FListedPropTAG( ULONG                   ulPropTag,
                                LPSPropTagArray lptaga)
{
        ULONG FAR       *lpulPTag;

        /* No tag is contained in a NULL list of tags.
         */
    if (!lptaga)
        {
                return FALSE;
        }

        /* Compare the entire prop tag to be sure both ID and TYPE match
         */
        for ( lpulPTag = lptaga->aulPropTag + lptaga->cValues
                ; --lpulPTag >= lptaga->aulPropTag
                ; )
        {
                /* Compare PROP_ID's.
                 */
                if (PROP_ID(*lpulPTag) == ulPropTag)
                {
                        return TRUE;
                }
        }

        return FALSE;
}


/*
 *      AddProblem
 *
 *  Purpose
 *              Adds a problem to the next available entry of a pre-allocated problem
 *              array.
 *              The pre-allocated problem array must be big enough to have another
 *              problem added.  The caller is responsible for making sure this is
 *              true.
 *
 *      Arguments
 *              lpProblems      Pointer to pre-allocated probelem array.
 *              ulIndex         Index into prop tag/value array of the problem property.
 *              ulPropTag       Prop tag of property which had the problem.
 *              scode           Error code to list for the property.
 *
 *      Returns         TRUE or FALSE
 */
_inline VOID
AddProblem( LPSPropProblemArray lpProblems,
                        ULONG                           ulIndex,
                        ULONG                           ulPropTag,
                        SCODE                           scode)
{
        if (lpProblems)
        {
                Assert( !IsBadWritePtr( lpProblems->aProblem + lpProblems->cProblem
                          , sizeof(SPropProblem)));
                lpProblems->aProblem[lpProblems->cProblem].ulIndex = ulIndex;
                lpProblems->aProblem[lpProblems->cProblem].ulPropTag = ulPropTag;
                lpProblems->aProblem[lpProblems->cProblem].scode = scode;
                lpProblems->cProblem++;
        }
}

__inline BOOL
FIsExcludedIID( LPCIID lpiidToCheck, LPCIID rgiidExclude, ULONG ciidExclude)
{
        /* Check the obvious (no exclusions).
         */
        if (!ciidExclude || !rgiidExclude)
        {
                return FALSE;
        }

        /* Check each iid in the list of exclusions.
         */
        for (; ciidExclude; rgiidExclude++, ciidExclude--)
        {
//              if (IsEqualGUID( lpiidToCheck, rgiidExclude))
                if (!memcmp( lpiidToCheck, rgiidExclude, sizeof(MAPIUID)))
                {
                        return TRUE;
                }
        }

        return FALSE;
}


/*
 *      Error/Warning Alert Message Boxes
 */
int                     AlertIdsCtx( HWND hwnd,
                                                 HINSTANCE hinst,
                                                 UINT idsMsg,
                                                 LPSTR szComponent,
                                                 ULONG ulContext,
                                                 ULONG ulLow,
                                                 UINT fuStyle);

__inline int
AlertIds(HWND hwnd, HINSTANCE hinst, UINT idsMsg, UINT fuStyle)
{
        return AlertIdsCtx(hwnd, hinst, idsMsg, NULL, 0, 0, fuStyle);
}

int                     AlertSzCtx( HWND hwnd,
                                                LPSTR szMsg,
                                                LPSTR szComponent,
                                                ULONG ulContext,
                                                ULONG ulLow,
                                                UINT fuStyle);

__inline int
AlertSz(HWND hwnd, LPSTR szMsg, UINT fuStyle)
{
        return AlertSzCtx(hwnd, szMsg, NULL, 0, 0, fuStyle);
}




/*  Encoding and decoding strings */
STDAPI_(void)                   EncodeID(LPBYTE lpb, ULONG cb, LPTSTR lpsz);
STDAPI_(BOOL)                   FDecodeID(LPTSTR lpsz, LPBYTE lpb, ULONG FAR *lpcb);
STDAPI_(ULONG)                  CchOfEncoding(ULONG cb);
STDAPI_(ULONG)                  CbOfEncoded(LPTSTR lpsz);
STDAPI_(int)                    CchEncodedLine(int cb);


/*  Idle engine routines */

#ifdef  DEBUG

/*
 *      DumpIdleTable
 *
 *              Used for debugging only.  Writes information in the PGD(hftgIdle)
 *              table to COM1.
 */

STDAPI_(void)
DumpIdleTable (void);

#endif
/*
 *      FDoNextIdleTask
 *
 *              Dispatches the first eligible idle function, according to
 *              its simple scheduling algorithm.
 */

STDAPI_(BOOL) FDoNextIdleTask (void);

/* C runtime substitutes */

typedef int (__cdecl FNSGNCMP)(const void FAR *lpv1, const void FAR *lpv2);
typedef FNSGNCMP FAR *PFNSGNCMP;

FNSGNCMP                                SgnCmpPadrentryByType;

BOOL FRKFindSubpb(LPBYTE pbTarget, ULONG cbTarget, LPBYTE pbPattern, ULONG cbPattern);
BOOL FRKFindSubpsz(LPSTR pszTarget, ULONG cbTarget, LPSTR pszPattern, ULONG cbPattern, ULONG ulFuzzyLevel);
LPSTR LpszRKFindSubpsz(LPSTR pszTarget, ULONG cbTarget, LPSTR pszPattern, ULONG cbPattern, ULONG ulFuzzyLevel);

STDAPI_(void)                   ShellSort(LPVOID lpv, UINT cv,                  /* qsort */
                                                LPVOID lpvT, UINT cb, PFNSGNCMP fpCmp);


/*  Advise list maintainence utilities  */
/*
 *      Structure and functions for maintaining a list of advise sinks,
 *      together with the keys used to release them.
 */

typedef struct
{
        LPMAPIADVISESINK        lpAdvise;
        ULONG                           ulConnection;
        ULONG                           ulType;
        LPUNKNOWN                       lpParent;
} ADVISEITEM, FAR *LPADVISEITEM;

typedef struct
{
        ULONG                           cItemsMac;
        ULONG                           cItemsMax;
        #if defined(WIN32) && !defined(MAC)
        CRITICAL_SECTION FAR * lpcs;
        #endif
        ADVISEITEM                      rgItems[1];
} ADVISELIST, FAR *LPADVISELIST;

#define CbNewADVISELIST(_citems) \
        (offsetof(ADVISELIST, rgItems) + (_citems) * sizeof(ADVISEITEM))
#define CbADVISELIST(_plist) \
        (offsetof(ADVISELIST, rgItems) + (_plist)->cItemsMax * sizeof(ADVISEITEM))

STDAPI_(SCODE)
ScAddAdviseList(        LPVOID lpvReserved,
                                        LPADVISELIST FAR *lppList,
                                        LPMAPIADVISESINK lpAdvise,
                                        ULONG ulConnection,
                                        ULONG ulType,
                                        LPUNKNOWN lpParent);

STDAPI_(SCODE)
ScDelAdviseList(        LPADVISELIST lpList,
                                        ULONG ulConnection);
STDAPI_(SCODE)
ScFindAdviseList(       LPADVISELIST lpList,
                                        ULONG ulConnection,
                                        LPADVISEITEM FAR *lppItem);
STDAPI_(void)
DestroyAdviseList(      LPADVISELIST FAR *lppList);

// prototype for routine that detects whether calling apps is
// an interactive EXE or a service.

#if defined( _WINNT )
BOOL WINAPI IsServiceAnExe( VOID );
#endif

// prototype for internal routine that computes the size required 
// to hold a given propval array based on specified alignment

SCODE ScCountPropsEx( int cprop,
                      LPSPropValue rgprop,
                      ULONG ulAlign,
                      ULONG FAR *pcb );

/*  Option data handling routines */
#ifdef MAPISPI_H

STDAPI_(SCODE)
ScCountOptionData(LPOPTIONDATA lpOption, ULONG FAR *lpcb);

STDAPI_(SCODE)
ScCopyOptionData(LPOPTIONDATA lpOption, LPVOID lpvDst, ULONG FAR *lpcb);

STDAPI_(SCODE)
ScRelocOptionData(LPOPTIONDATA lpOption,
                LPVOID lpvBaseOld, LPVOID lpvBaseNew, ULONG FAR *lpcb);

#endif  /* MAPISPI_H */


#ifdef __cplusplus
}
#endif


#endif  // _MAPIU_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\mapistub\mapistub\_smerror.h ===
/*
 *	_SMERROR.H
 *	
 *	This file contains all of the status codes defined for Capone.
 *	This file also contains masks for all of the facilities that
 *	don't include a facility ID in their status codes.
 */
#ifndef _SMERROR_H_
#define _SMERROR_H_

#ifdef _MSC_VER
#	if defined (WIN32) 
#		ifndef _OLEERROR_H_
#			include <objerror.h>
#		endif
#		ifndef _OBJBASE_H_
#			include <objbase.h>
#		endif
#	else
#		ifndef _COMPOBJ_H_
#			include <compobj.h>
#		endif		
#	endif
#endif

#ifndef __SCODE_H__
#include <scode.h>
#endif

/*
 *	C o n s t a n t s
 */

// Error string limits
#define cchContextMax			128
#define cchProblemMax			300
#define cchComponentMax			128
#define cchScodeMax				64
#define	cchErrorMax				(cchContextMax + cchProblemMax + cchComponentMax + cchScodeMax)

// Scode sources
#define FACILITY_MAIL			(0x0100)
#define FACILITY_MAPI			(0x0200)
#define FACILITY_WIN			(0x0300)
#define FACILITY_MASK			(0x0700)

// Scode masks
#define scmskMail				(MAKE_SCODE(0, FACILITY_MAIL, 0))
#define scmskMapi				(MAKE_SCODE(0, FACILITY_MAPI, 0))
#define scmskWin				(MAKE_SCODE(0, FACILITY_WIN, 0))
#define scmskMask				(MAKE_SCODE(0, FACILITY_MASK, 0))

// Critical error flag
#define CRITICAL_FLAG			((SCODE) 0x00008000)


/*
 *	T y p e s
 */


// Error context filled in by PushErrctx (not by caller!)
typedef struct _errctx
{
	UINT str;							// String resource ID
	struct _errctx * perrctxPrev;		// Previous error context
}
ERRCTX;


/*
 *	M a c r o s
 */


// Scode manipulation
#define StrFromScode(_sc) \
	((UINT) ((_sc) & (0x00007fffL)))
#define FCriticalScode(_sc) \
	((_sc) & CRITICAL_FLAG)
#define FMailScode(_sc) \
	(((_sc) & scmskMask) == scmskMail)
#define FMapiScode(_sc) \
	(((_sc) & scmskMask) == scmskMapi)
#define FWinScode(_sc) \
	(((_sc) & scmskMask) == scmskWin)
#define FGenericScode(_sc) \
	(((_sc) & scmskMask) == 0)

// Scode constructors
#define MAKE_NOTE_S_SCODE(_str) \
	MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_MAIL, (_str))
#define MAKE_NOTE_E_SCODE(_str) \
	MAKE_SCODE(SEVERITY_ERROR, FACILITY_MAIL, (_str))
#define MAKE_NOTE_X_SCODE(_str) \
	MAKE_SCODE(SEVERITY_ERROR, FACILITY_MAIL, (_str) | CRITICAL_FLAG)

// Windows errors
#define ScWin(_sc) \
	((SCODE) ((_sc) | scmskWin))
#define ScWinN(_n) \
	(MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN, (ULONG) (_n)))
#ifdef WIN32
#define ScWinLastError() \
	MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN, GetLastError())
#else
#define ScWinLastError() \
	MAKE_SCODE(SEVERITY_ERROR, FACILITY_WIN, 0)
#endif
#define GetWinError(_sc) \
	_sc = ScWinLastError()

// MAPI errors
#define ScMapi(_sc) \
	((SCODE) ((_sc) | scmskMapi))
#define	MarkMAPIError(_sc) \
	_sc |= scmskMapi


/*
 *	E r r o r   S t r i n g s
 */

#define STR_ErrorCaptionMail			(IDS_SIMPLE_MAPI_SEND + 61)

#define	ERRSTR_Start					(IDS_SIMPLE_MAPI_SEND + 62)

#define STR_CriticalErrorText			ERRSTR_Start+0
#define STR_MailComponentName			ERRSTR_Start+1		


/*
 *	E r r o r   C o n t e x t s
 *
 */

// Note
#define STR_CtxMailSend					ERRSTR_Start+2		
#define STR_CtxFormatFont				ERRSTR_Start+3		
#define STR_CtxFileClose				ERRSTR_Start+4		

// Attachments							 
#define STR_CtxInsertFile				ERRSTR_Start+5			
#define STR_CtxLoadAttachments			ERRSTR_Start+6
#define STR_CtxWriteAttachments			ERRSTR_Start+7
#define STR_CtxInsertAttach				ERRSTR_Start+31

// Clipboard
#define STR_CtxClipboard				ERRSTR_Start+30

/*
 *	E r r o r   M e s s a g e s
 *
 */

#define STR_ErrMemory					ERRSTR_Start+8				

// Note
#define STR_ErrCantCloseObject			ERRSTR_Start+9
#define STR_ErrClipboardChanged			ERRSTR_Start+10	
#define STR_ErrCantCreateObject			ERRSTR_Start+11
#define STR_ErrOleUIFailed				ERRSTR_Start+12
#define STR_ErrNoClientSite				ERRSTR_Start+13
#define STR_ErrNoStorage				ERRSTR_Start+14

// Attachments
#define	STR_ErrStreamInFile				ERRSTR_Start+15		
#define	STR_ErrStreamOutFile			ERRSTR_Start+16
#define STR_ErrUnknownStorage			ERRSTR_Start+17
#define STR_ErrCreateTempFile			ERRSTR_Start+18
#define STR_ErrCantAttachDir			ERRSTR_Start+19	
#define	STR_ErrStreamInFileLocked		ERRSTR_Start+20
#define	STR_ErrCantDoVerb				ERRSTR_Start+21		
#define STR_ErrMacBin					ERRSTR_Start+22
#define STR_ErrAttachEncoding			ERRSTR_Start+23
#define STR_FileAttStillOpen			ERRSTR_Start+24
#define STR_TempFileGone				ERRSTR_Start+25
#define STR_NoDragDropDir				ERRSTR_Start+26
#define STR_ErrorLoadAttach				ERRSTR_Start+27

#define STR_ErrNoAccess					ERRSTR_Start+35	
#define STR_ErrMediumFull				ERRSTR_Start+36	
#define STR_ErrGenericFailNoCtx			ERRSTR_Start+37	
#define STR_ErrGenericFail				ERRSTR_Start+38	

#define STR_ErrNoHelp					IDS_E_NO_HELP

// Display strings
//
#define	STR_FileAttShortName			ERRSTR_Start+40			
#define	STR_FileAttFullName				ERRSTR_Start+41	

/*
 *	N o t e  S c o d e s
 *
 *	Use MAKE_NOTE_S_SCODE for success scodes, MAKE_NOTE_E_SCODE for regular
 *	errors, and MAKE_NOTE_X_SCODE for critical [stop sign] errors.
 *	Define nondisplayable errors incrementally, and displayable errors 
 *	using their string.  Don't overlap E and S scodes.
 */


// No strings attached
//
#define NOTE_E_REPORTED				MAKE_NOTE_E_SCODE(0)

// Address book
//
#define NOTE_E_MEMORY				MAKE_NOTE_X_SCODE(STR_ErrMemory)

// Note
//
#define NOTE_E_CANTCLOSEOBJECT		MAKE_NOTE_E_SCODE(STR_ErrCantCloseObject)
#define NOTE_E_CLIPBOARDCHANGED		MAKE_NOTE_E_SCODE(STR_ErrClipboardChanged)
#define NOTE_E_CANTCREATEOBJECT		MAKE_NOTE_E_SCODE(STR_ErrCantCreateObject)
#define NOTE_E_OLEUIFAILED			MAKE_NOTE_E_SCODE(STR_ErrOleUIFailed)
#define NOTE_E_NOCLIENTSITE			MAKE_NOTE_E_SCODE(STR_ErrNoClientSite)
#define NOTE_E_NOSTORAGE			MAKE_NOTE_E_SCODE(STR_ErrNoStorage)

// Attachments
//
#define	NOTE_E_STREAMINFILE			MAKE_NOTE_E_SCODE(STR_ErrStreamInFile)
#define	NOTE_E_STREAMOUTFILE		MAKE_NOTE_E_SCODE(STR_ErrStreamOutFile)
#define	NOTE_E_UNKNOWNSTORAGE		MAKE_NOTE_E_SCODE(STR_ErrUnknownStorage)
#define	NOTE_E_CREATETEMPFILE		MAKE_NOTE_E_SCODE(STR_ErrCreateTempFile)
#define	NOTE_E_CANTATTACHDIR		MAKE_NOTE_E_SCODE(STR_ErrCantAttachDir)
#define	NOTE_E_STREAMINFILELOCKED	MAKE_NOTE_E_SCODE(STR_ErrStreamInFileLocked)
#define	NOTE_E_CANTDOVERB			MAKE_NOTE_E_SCODE(STR_ErrCantDoVerb)
#define NOTE_E_ERRMACBIN			MAKE_NOTE_E_SCODE(STR_ErrMacBin)
#define NOTE_E_ERRATTACHENCODING	MAKE_NOTE_E_SCODE(STR_ErrAttachEncoding)

#define NOTE_E_GENERAL				MAKE_NOTE_E_SCODE(STR_ErrGenericFail)
#define NOTE_E_NOHELP				MAKE_NOTE_E_SCODE(STR_ErrNoHelp)
#define NOTE_E_NOACCESS				MAKE_NOTE_E_SCODE(STR_ErrNoAccess)
#define NOTE_E_MEDIUMFULL			MAKE_NOTE_E_SCODE(STR_ErrMediumFull)

#define MAPI_E_UNRESOLVED_RECIPS	MAKE_NOTE_E_SCODE(IDS_E_UNRESOLVED_RECIPS)

// LPMAPIERROR ulLowLevelError values
//
#define	ulExtensionError			1000

// end of _smerror.h
//
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\mapistub\mapistub\_spooler.h ===
/*
 *	_ S P O O L E R . H
 *
 *	Common Spooler Definitions for use in the MAPI and SPOOLER Subsytems
 *	Copyright 1992-1995 Microsoft Corporation.	All Rights Reserved.
 */

//	Spooler event (reserved in mapidefs.h) */
//
#define	fnevSpooler		((ULONG)0x40000000)

//	Spooler flag for calling into MapiInitialize()
//
#define MAPI_SPOOLER_INIT	0x40000000	/* reserved in MAPIX.H */

//	Spooler startup security information
//
#define cbSplSecurity	(sizeof(ULONG) * 4)		// spooler security data

//	Magic flags for StoreLogoffTransports() that
//	are required for LocalReplication usage
//
//	IMPORTANT!  These are defined this way for a reason.
//	We do not want to have to doc this behavior!  We do
//	not want to have to support this in the future.  We
//	do not want to give anybody an idea that there may be
//	something hidden behind reserved bits in MAPIDEFS.H.
//
//	To this end, these reserved bits are not even defined
//	as reserved bits in MAPIDEFS.H.  Should we need to move
//	them over, then we will.  But otherwise, they stay here.
//
//	These bits are the control bits for a hack to help the
//	local rep crew temorarily disable a store for spooler
//	processing.
//
//	When the spooler gets a StoreLogoffTransports() call with
//	the LOGOFF_SUSPEND bit set, any sending on that store is
//	aborted, and the outgoing queue is thrown out.  If the store
//	was the default store, then the spooler will disable all the
//	transports as well.
//
//	When the resume is received, the store is reactivated
//	the outgoing queue is reacquired.  We make no assumption
//	about any hold-overs from the old OQ to the new one.
//
//	Now you are starting to see why we really do not want to
//	doc this "subtle-nuance" to the StoreLogoffTransports()
//	api.
//
#define	LOGOFF_RESERVED1		((ULONG) 0x00001000) /* Reserved for future use */
#define LOGOFF_RESERVED2		((ULONG) 0x00002000) /* Reserved for future use */
#define	LOGOFF_SUSPEND			LOGOFF_RESERVED1
#define LOGOFF_RESUME			LOGOFF_RESERVED2

//	Biggest size we expect from a resource string
//
#define RES_MAX	255

typedef struct _HEARTBEAT
{
	UINT				cBeats;
	DWORD				dwTimeout;
#if defined(WIN32) && !defined(MAC)
	HANDLE				htSpl;
	HANDLE				hevt;
	CRITICAL_SECTION	cs;
#endif
#ifdef	WIN16
	HHOOK				hhkFilter;
#endif
#if defined(WIN16) || defined(MAC)
	BOOL				fInHeartbeat;
	DWORD				dwHeartbeat;
	UINT				cBeatsCur;
#endif
#ifdef MAC
	HHOOK				hhkKbdFilter;
	HHOOK				hhkMouseFilter;
#endif

} HEARTBEAT, FAR * LPHEARTBEAT;

typedef struct _GOQ GOQ, FAR * LPGOQ;
typedef struct _SPLDATA
{
	ULONG				cbSize;
	BYTE				rgbSecurity[cbSplSecurity];
	HINSTANCE			hInstMapiX;
	HINSTANCE			hInstSpooler;
	HWND				hwndPrev;
	HWND				hwndSpooler;
	LPCLASSFACTORY		lpclsfct;
	HEARTBEAT			hb;
	LPGOQ				lpgoq;
	TCHAR				rgchClassName[RES_MAX+1];
	TCHAR				rgchWindowTitle[RES_MAX+1];
	ULONG				dwTckLast;
	ULONG				dwTckValidate;
	ULONG				ulFlags;
	ULONG				ulNotif;
	ULONG				ulSplSrvc;
	ULONG				ulStatus;

#if defined(WIN32) && !defined(MAC)
	CRITICAL_SECTION	csOQ;
	UINT				lcInitHiPriority;
	UINT				uBasePriority;
	HWND				hwndStub;
#endif
#if defined(WIN16) || defined (MAC)
	DWORD				dwTckLastFilterMsg;
#endif
#ifdef	DEBUG
	BOOL				fHeartbeat:1;
	BOOL				fHooks:1;
	BOOL				fInbound:1;
	BOOL				fOutbound:1;
	BOOL				fOutQueue:1;
	BOOL				fPPs:1;
	BOOL				fService:1;
	BOOL				fVerbose:1;
	BOOL				fYield:1;
#endif

} SPLDATA, FAR * LPSPLDATA;

typedef struct _SPOOLERINIT
{
	MAPIINIT_0	mi;
	LPBYTE		lpbSecurity;
	
} SPLINIT, FAR * LPSPLINIT;


//	Values used for SPLENTRY
//
#define SPL_AUTOSTART	((UINT)1)
#define SPL_EXCHANGE	((UINT)4)

#define SPLENTRYORDINAL	((UINT)8)
#define SPL_VERSION		((ULONG)0x00010001)

typedef SCODE (STDMAPIINITCALLTYPE FAR * LPSPLENTRY)(
	LPSPLDATA		lpSpoolerData,
	LPVOID			lpvReserved,
	ULONG			ulSpoolerVer,
	ULONG FAR *		lpulMAPIVer
);


//	Values used for uSpooler in the shared memory block
//	SPL_NONE -		No spooler is running or trying to run
//	SPL_AUTOSTARTED -	Spooler process has been launched by MAPI but
//						not yet Initialized itself.
//	SPL_INITIALIZED -	Spooler has initialized itself but is not yet
//						running the message pump.
//	SPL_RUNNING -	Spooler is running its message pump.
//	SPL_EXITING -	Spooler process is shutting down
//
#define SPL_NONE			((UINT)0)
#define SPL_AUTOSTARTED		((UINT)1)
#define SPL_INITIALIZED		((UINT)2)
#define SPL_RUNNING			((UINT)3)
#define SPL_EXITING			((UINT)4)

/*
 *	IMAPISpoolerService Interface ---------------------------------------------
 *
 *	MAPI Spooler OLE Remotely Activated Service Interface
 */
DECLARE_MAPI_INTERFACE_PTR(IMAPISpoolerService, LPSPOOLERSERVICE);
#define MAPI_IMAPISPOOLERSERVICE_METHODS(IPURE)							\
	MAPIMETHOD(OpenStatusEntry)											\
		(THIS_	LPMAPIUID					lpSessionUid,				\
				ULONG						cbEntryID,					\
				LPENTRYID					lpEntryID,					\
				LPCIID						lpInterface,				\
				ULONG						ulFlags,					\
				ULONG FAR *					lpulObjType,				\
				LPMAPIPROP FAR *			lppMAPIPropEntry) IPURE;	\

#undef		 INTERFACE
#define		 INTERFACE	IMAPISpoolerService
DECLARE_MAPI_INTERFACE_(IMAPISpoolerService, IUnknown)
{
	MAPI_IUNKNOWN_METHODS(PURE)
	MAPI_IMAPISPOOLERSERVICE_METHODS(PURE)
};

HRESULT HrCreateSplServCF (LPCLASSFACTORY FAR * lppClassFactory);
HRESULT NewSPLSERV (LPSPOOLERSERVICE FAR * lppSPLSERV);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\mapistub\mapistub\_vbmapi.h ===
// Structures and Functions used by BMAPI and VB2C

#define RECIPIENT   	((USHORT)0x0001)
#define FILE        	((USHORT)0x0002)
#define MESSAGE     	((USHORT)0x0004)
#define SAFEARRAY		((USHORT)0x1000)

#if defined (WIN32)
#ifndef BMAPI_ENTRY                         		 // PFP
  #define BMAPI_ENTRY  ULONG FAR PASCAL    // define BMAPI_ENTRY  PFP
#endif                                      		 // PFP
#else
#ifndef BMAPI_ENTRY                         		 // PFP
  #define BMAPI_ENTRY  ULONG __export FAR PASCAL    // define BMAPI_ENTRY  PFP
#endif                                      		 // PFP
#endif

//#ifndef LHANDLE
//  #define LHANDLE ULONG
//#endif

#ifndef ERR
  #define ERR 	USHORT
#endif


#if defined (WIN32)
//-----------------------------------------------------------------------
// WIN32 definitions of 32 bit VB interface function support
//-----------------------------------------------------------------------
typedef struct
{
	ULONG	ulReserved;
	BSTR 	bstrSubject;
	BSTR 	bstrNoteText;
	BSTR 	bstrMessageType;
	BSTR 	bstrDate;
	BSTR 	bstrConversationID;
	ULONG 	flFlags;
	ULONG 	nRecipCount;
	ULONG 	nFileCount;
} VB_Message,FAR *lpVB_Message;

typedef VB_Message VB_MESSAGE;
typedef VB_Message FAR *LPVB_MESSAGE;


typedef struct
{
	ULONG 	ulReserved;
	ULONG 	ulRecipClass;
	BSTR 	bstrName;
	BSTR 	bstrAddress;
	ULONG 	ulEIDSize;
	BSTR 	bstrEID;
} VB_Recip,FAR *lpVB_Recip;

typedef VB_Recip VB_RECIPIENT;
typedef VB_Recip FAR *LPVB_RECIPIENT;


typedef struct
{
	ULONG 	ulReserved;
	ULONG 	flFlags;
	ULONG 	nPosition;
	BSTR 	bstrPathName;
	BSTR 	bstrFileName;
	BSTR 	bstrFileType;
} VB_File, FAR *lpVB_File;

// OLEAUT32.DLL loadlib and getprocaddress support

// WINOLEAUTAPI_(void) SysFreeString(BSTR);
typedef VOID (STDAPICALLTYPE *LPFNSYSFREESTRING)
	( BSTR bstr );

// WINOLEAUTAPI_(unsigned int) SysStringByteLen(BSTR bstr);
typedef UINT (STDAPICALLTYPE *LPFNSYSSTRINGBYTELEN)
	(BSTR bstr);

// WINOLEAUTAPI_(BSTR) SysAllocStringByteLen(const char FAR* psz, unsigned int len);
typedef BSTR (STDAPICALLTYPE *LPFNSYSALLOCSTRINGBYTELEN)
	(const char *psz, UINT len );

// WINOLEAUTAPI_(BSTR) SysAllocString(const OLECHAR FAR*);
typedef BSTR (STDAPICALLTYPE *LPFNSYSALLOCSTRING)
	(const OLECHAR * szwString);

// WINOLEAUTAPI_(int)  SysReAllocString(BSTR FAR*, const OLECHAR FAR*);
typedef INT (STDAPICALLTYPE *LPFNSYSREALLOCSTRING)
	(BSTR * lpBstr, const OLECHAR * szwString);

// WINOLEAUTAPI_(unsigned int) SysStringLen(BSTR);
typedef UINT (STDAPICALLTYPE *LPFNSYSSTRINGLEN)
	(BSTR bstr);

// WINOLEAUTAPI SafeArrayAccessData(SAFEARRAY FAR* psa, void HUGEP* FAR* ppvData);
typedef HRESULT (STDAPICALLTYPE *LPFNSAFEARRAYACCESSDATA)
	(struct tagSAFEARRAY *psa, void **ppvData);

// WINOLEAUTAPI SafeArrayUnaccessData(SAFEARRAY FAR* psa);
typedef HRESULT (STDAPICALLTYPE *LPFNSAFEARRAYUNACCESSDATA)
	(struct tagSAFEARRAY *psa);

extern LPFNSYSFREESTRING 			lpfnSysFreeString;
extern LPFNSYSSTRINGBYTELEN 		lpfnSysStringByteLen;
extern LPFNSYSALLOCSTRINGBYTELEN	lpfnSysAllocStringByteLen;
extern LPFNSYSALLOCSTRING			lpfnSysAllocString;
extern LPFNSYSREALLOCSTRING			lpfnSysReAllocString;
extern LPFNSYSSTRINGLEN				lpfnSysStringLen;
extern LPFNSAFEARRAYACCESSDATA		lpfnSafeArrayAccessData;
extern LPFNSAFEARRAYUNACCESSDATA	lpfnSafeArrayUnaccessData;

#undef SysFreeString
#undef SysStringByteLen
#undef SysAllocStringByteLen
#undef SysAllocString
#undef SysReAllocString
#undef SysStringLen
#undef SafeArrayAccessData
#undef SafeArrayUnaccessData

#define SysFreeString			(*lpfnSysFreeString)
#define SysStringByteLen 		(*lpfnSysStringByteLen)
#define SysAllocStringByteLen	(*lpfnSysAllocStringByteLen)
#define SysAllocString			(*lpfnSysAllocString)
#define SysReAllocString		(*lpfnSysReAllocString)
#define SysStringLen			(*lpfnSysStringLen)
#define SafeArrayAccessData		(*lpfnSafeArrayAccessData)
#define SafeArrayUnaccessData	(*lpfnSafeArrayUnaccessData)

#else	// !WIN32

//-----------------------------------------------------------------------
// VB 3.0 definitions for 16 bit VB interface support
//-----------------------------------------------------------------------
typedef struct
{
	ULONG ulReserved;
	HLSTR hlstrSubject;
	HLSTR hlstrNoteText;
	HLSTR hlstrMessageType;
	HLSTR hlstrDate;
	HLSTR hlstrConversationID;
	ULONG flFlags;
	ULONG nRecipCount;
	ULONG nFileCount;
} VB_Message,FAR *lpVB_Message;

typedef VB_Message VB_MESSAGE;
typedef VB_Message FAR *LPVB_MESSAGE;


typedef struct
{
	ULONG ulReserved;
	ULONG ulRecipClass;
	HLSTR hlstrName;
	HLSTR hlstrAddress;
	ULONG ulEIDSize;
	HLSTR hlstrEID;
} VB_Recip,FAR *lpVB_Recip;

typedef VB_Recip VB_RECIPIENT;
typedef VB_Recip FAR *LPVB_RECIPIENT;


typedef struct
{
	ULONG ulReserved;
	ULONG flFlags;
	ULONG nPosition;
	HLSTR hlstrPathName;
	HLSTR hlstrFileName;
	HLSTR hlstrFileType;
} VB_File, FAR *lpVB_File;
#endif	// WIN32

typedef VB_File 			VB_FILE;
typedef VB_File FAR *		LPVB_FILE;

typedef MapiMessage 		VB_MAPI_MESSAGE;
typedef MapiMessage FAR *	LPMAPI_MESSAGE;
typedef LPMAPI_MESSAGE FAR *LPPMAPI_MESSAGE;


typedef MapiRecipDesc 		MAPI_RECIPIENT;
typedef MapiRecipDesc FAR *	LPMAPI_RECIPIENT;
typedef LPMAPI_RECIPIENT FAR *LPPMAPI_RECIPIENT;

typedef MapiFileDesc 		MAPI_FILE;
typedef MapiFileDesc FAR *	LPMAPI_FILE;
typedef LPMAPI_FILE FAR *	LPPMAPI_FILE;

typedef HANDLE FAR *		LPHANDLE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\msasn1\berdecod.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

#ifdef ENABLE_BER

#include <math.h>

static const char bitmsk2[] =
{
    (const char) 0x00,
    (const char) 0x80,
    (const char) 0xc0,
    (const char) 0xe0,
    (const char) 0xf0,
    (const char) 0xf8,
    (const char) 0xfc,
    (const char) 0xfe
};


/* decode bit string value */
int _BERDecBitString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *val, ASN1uint32_t fNoCopy)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1bitstring_t b;
    ASN1decoding_t dd;
    ASN1octet_t *di;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                val->length = 0;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (_BERDecBitString(dd, 0x3, &b, fNoCopy))
                        {
                            if (b.length)
                            {
                                if (fNoCopy)
                                {
                                    *val = b;
                                    break; // break out the loop because nocopy cannot have multiple constructed streams
                                }

                                /* resize value */
                                val->value = (ASN1octet_t *)DecMemReAlloc(dd, val->value,
                                    (val->length + b.length + 7) / 8);
                                if (val->value)
                                {
                                    /* concat bit strings */
                                    ASN1bitcpy(val->value, val->length, b.value, 0, b.length);
                                    val->length += b.length;
                                    if (val->length & 7)
                                        val->value[val->length / 8] &= bitmsk2[val->length & 7];

                                    /* free unused bit string */
                                    DecMemFree(dec, b.value);
                                }
                                else
                                {
                                    return 0;
                                }
                            }
                        }
                    } // while
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                if (!len)
                {
                    val->length = 0;
                    val->value = NULL;
                    return 1;
                }
                else
                {
                    if (*dec->pos < 8)
                    {
                        len--; // skip over the initial octet; len is now the actual length of octets
                        val->length = len * 8 - *dec->pos++;
                        if (fNoCopy)
                        {
                            val->value = dec->pos;
                            dec->pos += len;
                            return 1;
                        }
                        else
                        {
                            if (val->length)
                            {
                                val->value = (ASN1octet_t *)DecMemAlloc(dec, (val->length + 7) / 8);
                                if (val->value)
                                {
                                    CopyMemory(val->value, dec->pos, len);
                                    if (val->length & 7)
                                        val->value[len - 1] &= bitmsk2[val->length & 7];
                                    dec->pos += len;
                                    return 1;
                                }
                            }
                            else
                            {
                                val->value = NULL;
                                return 1;
                            }
                        }
                    }
                    else
                    {
                        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                    }
                }
            }
        }
    }
    return 0;
}

/* decode bit string value, making copy */
int ASN1BERDecBitString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *val)
{
    return _BERDecBitString(dec, tag, val, FALSE);
}

/* decode bit string value, no copy */
int ASN1BERDecBitString2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bitstring_t *val)
{
    return _BERDecBitString(dec, tag, val, TRUE);
}

/* decode string value */
int ASN1BERDecCharString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1charstring_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1charstring_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                val->length = 0;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (ASN1BERDecCharString(dd, 0x4, &c))
                        {
                            if (c.length)
                            {
                                /* resize value */
                                val->value = (char *)DecMemReAlloc(dd, val->value,
                                    val->length + c.length);
                                if (val->value)
                                {
                                    /* concat strings */
                                    CopyMemory(val->value + val->length, c.value, c.length);
                                    val->length += c.length;

                                    /* free unused string */
                                    DecMemFree(dec, c.value);
                                }
                                else
                                {
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            return 0;
                        }
                    } // while
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                val->length = len;
                if (len)
                {
                    val->value = (char *)DecMemAlloc(dec, len+1);
                    if (val->value)
                    {
                        CopyMemory(val->value, dec->pos, len);
                        dec->pos += len;
                        val->value[len] = 0;
                        return 1;
                    }
                }
                else
                {
                    val->value = NULL;
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode 16 bit string value */
int ASN1BERDecChar16String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1char16string_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1char16string_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t i;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                val->length = 0;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (ASN1BERDecChar16String(dd, 0x4, &c))
                        {
                            if (c.length)
                            {
                                /* resize value */
                                val->value = (ASN1char16_t *)DecMemReAlloc(dd, val->value,
                                    (val->length + c.length) * sizeof(ASN1char16_t));
                                if (val->value)
                                {
                                    /* concat strings */
                                    CopyMemory(val->value + val->length, c.value,
                                        c.length * sizeof(ASN1char16_t));
                                    val->length += c.length;

                                    /* free unused string */
                                    DecMemFree(dec, c.value);
                                }
                                else
                                {
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            return 0;
                        }
                    }
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                DecAssert(dec, 2 * sizeof(ASN1octet_t) == sizeof(ASN1char16_t));
                len = len >> 1; // divided by 2
                val->length = len;
                if (len)
                {
                    val->value = (ASN1char16_t *)DecMemAlloc(dec, (len+1) * sizeof(ASN1char16_t));
                    if (val->value)
                    {
                        for (i = 0; i < len; i++)
                        {
                            val->value[i] = (*dec->pos << 8) | dec->pos[1];
                            dec->pos += 2;
                        }
                        val->value[len] = 0;
                        return 1;
                    }
                }
                else
                {
                    val->value = NULL;
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode 32 bit string value */
int ASN1BERDecChar32String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1char32string_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1char32string_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t i;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                val->length = 0;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (ASN1BERDecChar32String(dd, 0x4, &c))
                        {
                            if (c.length)
                            {
                                /* resize value */
                                val->value = (ASN1char32_t *)DecMemReAlloc(dd, val->value,
                                    (val->length + c.length) * sizeof(ASN1char32_t));
                                if (val->value)
                                {
                                    /* concat strings */
                                    CopyMemory(val->value + val->length, c.value,
                                        c.length * sizeof(ASN1char32_t));
                                    val->length += c.length;

                                    /* free unused string */
                                    DecMemFree(dec, c.value);
                                }
                                else
                                {
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            return 0;
                        }
                    }
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                DecAssert(dec, 4 * sizeof(ASN1octet_t) == sizeof(ASN1char32_t));
                len = len >> 2; // divided by 4
                val->length = len;
                if (len)
                {
                    val->value = (ASN1char32_t *)DecMemAlloc(dec, (len+1) * sizeof(ASN1char32_t));
                    if (val->value)
                    {
                        for (i = 0; i < len; i++)
                        {
                            val->value[i] = (*dec->pos << 24) | (dec->pos[1] << 16) |
                                (dec->pos[2] << 8) | dec->pos[3];;
                            dec->pos += 4;
                        }
                        val->value[len] = 0;
                        return 1;
                    }
                }
                else
                {
                    val->value = NULL;
                    return 1;
                }
            }
        }
    }
    return 0;
}

#ifdef ENABLE_GENERALIZED_CHAR_STR
/* decode character string value */
int ASN1BERDecCharacterString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1characterstring_t *val)
{
    ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t) dec;
    ASN1uint32_t constructed, len, infinite;
    ASN1uint32_t index;
    ASN1characterstring_identification_t *identification;
    ASN1decoding_t dd, dd2, dd3;
    ASN1octet_t *di, *di2, *di3;

    /* skip tag */
    if (!ASN1BERDecTag(dec, tag, &constructed))
        return 0;

    if (constructed)
    {
        /* constructed? CS-A encoded: */
        /* get length */
        if (!ASN1BERDecLength(dec, &len, &infinite))
            return 0;

        /* start decoding of constructed value */
        if (! _BERDecConstructed(dec, len, infinite, &dd, &di))
            return 0;
        if (!ASN1BERDecU32Val(dd, 0x80000000, &index))
            return 0;
        if (index != d->parent->csilength)
        {
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd2, &di2))
            return 0;
        if (!ASN1BERDecPeekTag(dd2, &tag))
            return 0;
        switch (tag)
        {
        case 0x80000000:
            val->identification.o =
                ASN1characterstring_identification_syntaxes_o;
            if (!ASN1BERDecExplicitTag(dd2, 0x80000000, &dd3, &di3))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000000,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000001,
                &val->identification.u.syntaxes.transfer))
                return 0;
            if (!ASN1BERDecEndOfContents(dd2, dd3, di3))
                return 0;
            break;
        case 0x80000001:
            val->identification.o = ASN1characterstring_identification_syntax_o;
            if (!ASN1BERDecObjectIdentifier(dd2, 0x80000001,
                &val->identification.u.syntax))
                return 0;
            break;
        case 0x80000002:
            val->identification.o =
                ASN1characterstring_identification_presentation_context_id_o;
            if (!ASN1BERDecU32Val(dd2, 0x80000002,
                &val->identification.u.presentation_context_id))
                return 0;
            break;
        case 0x80000003:
            val->identification.o =
                ASN1characterstring_identification_context_negotiation_o;
            if (!ASN1BERDecExplicitTag(dd2, 0x80000003, &dd3, &di3))
                return 0;
            if (!ASN1BERDecU32Val(dd3, 0x80000000, &val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000001,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            if (!ASN1BERDecEndOfContents(dd2, dd3, di3))
                return 0;
            break;
        case 0x80000004:
            val->identification.o =
                ASN1characterstring_identification_transfer_syntax_o;
            if (!ASN1BERDecObjectIdentifier(dd2, 0x80000004,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case 0x80000005:
            val->identification.o = ASN1characterstring_identification_fixed_o;
            if (!ASN1BERDecNull(dd2, 0x80000005))
                return 0;
            break;
        default:
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        if (!ASN1BERDecEndOfContents(dd, dd2, di2))
            return 0;
        if (!ASN1DecAddCharacterStringIdentification(d->parent,
            &val->identification))
            return 0;
        val->data_value.o = ASN1characterstring_data_value_encoded_o;
        if (!ASN1BERDecOctetString(dd, 0x80000003,
            &val->data_value.u.encoded))
            return 0;
        if (!ASN1BERDecEndOfContents(dec, dd, di))
            return 0;
    }
    else
    {
        /* primitive? CS-B encoded */
        /* get length */
        if (!ASN1BERDecLength(dec, &len, NULL))
            return 0;

        /* then copy value */
        if (!len)
        {
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        val->data_value.o = ASN1characterstring_data_value_encoded_o;
        val->data_value.u.encoded.length = len - 1;
        val->data_value.u.encoded.value = (ASN1octet_t *)DecMemAlloc(dec, len - 1);
        if (!val->data_value.u.encoded.value)
        {
            return 0;
        }
        index = *dec->pos++;
        CopyMemory(val->data_value.u.encoded.value, dec->pos, len - 1);
        identification = ASN1DecGetCharacterStringIdentification(d->parent,
            index);
        if (!identification)
            return 0;
        val->identification.o = identification->o;
        switch (identification->o)
        {
        case ASN1characterstring_identification_syntaxes_o:
            if (!ASN1DecDupObjectIdentifier(dec, 
                &val->identification.u.syntaxes.abstract,
                &identification->u.syntaxes.abstract))
                return 0;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntaxes.transfer,
                &identification->u.syntaxes.transfer))
                return 0;
            break;
        case ASN1characterstring_identification_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntax,
                &identification->u.syntax))
                return 0;
            break;
        case ASN1characterstring_identification_presentation_context_id_o:
            val->identification.u.presentation_context_id =
                identification->u.presentation_context_id;
            break;
        case ASN1characterstring_identification_context_negotiation_o:
            val->identification.u.context_negotiation.presentation_context_id =
                identification->u.context_negotiation.presentation_context_id;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.context_negotiation.transfer_syntax,
                &identification->u.context_negotiation.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_transfer_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.transfer_syntax,
                &identification->u.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_fixed_o:
            break;
        }
    }
    return 1;
}
#endif // ENABLE_GENERALIZED_CHAR_STR

#ifdef ENABLE_DOUBLE
/* decode real value */
int ASN1BERDecDouble(ASN1decoding_t dec, ASN1uint32_t tag, double *val)
{
    ASN1uint32_t head;
    ASN1int32_t exponent;
    ASN1uint32_t baselog2;
    ASN1uint32_t len;
    ASN1uint32_t i;
    ASN1octet_t *p, *q;
    double v;
    char buf[256], *b;

    /* skip tag */
    if (!ASN1BERDecTag(dec, tag, NULL))
        return 0;

    /* get length */
    if (!ASN1BERDecLength(dec, &len, NULL))
        return 0;

    /* null length is 0.0 */
    if (!len)
    {
        *val = 0.0;
    }
    else
    {
        p = q = dec->pos;
        dec->pos += len;
        head = *p++;

        /* binary encoding? */
        if (head & 0x80)
        {
            /* get base */
            switch (head & 0x30)
            {
            case 0:
                /* base 2 */
                baselog2 = 1;
                break;
            case 0x10:
                /* base 8 */
                baselog2 = 3;
                break;
            case 0x20:
                /* base 16 */
                baselog2 = 4;
                break;
            default:
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }

            /* get exponent */
            switch (head & 0x03)
            {
            case 0:
                /* 8 bit exponent */
                exponent = (ASN1int8_t)*p++;
                break;
            case 1:
                /* 16 bit exponent */
                exponent = (ASN1int16_t)((*p << 8) | p[1]);
                p += 2;
                break;
            case 2:
                /* 24 bit exponent */
                exponent = ((*p << 16) | (p[1] << 8) | p[2]);
                if (exponent & 0x800000)
                    exponent -= 0x1000000;
                break;
            default:
                /* variable length exponent */
                exponent = (p[1] & 0x80) ? -1 : 0;
                for (i = 1; i <= *p; i++)
                    exponent = (exponent << 8) | p[i];
                p += *p + 1;
                break;
            }

            /* calculate remaining length */
            len -= (ASN1uint32_t) (p - q);

            /* get mantissa */
            v = 0.0;
            for (i = 0; i < len; i++)
                v = v * 256.0 + *p++;

            /* scale mantissa */
            switch (head & 0x0c)
            {
            case 0x04:
                /* scaling factor 1 */
                v *= 2.0;
                break;
            case 0x08:
                /* scaling factor 2 */
                v *= 4.0;
                break;
            case 0x0c:
                /* scaling factor 3 */
                v *= 8.0;
                break;
            }

            /* check sign */
            if (head & 0x40)
                v = -v;

            /* calculate value */
            *val = ldexp(v, exponent * baselog2);
        }
        else
        /* special real values? */
        if (head & 0x40)
        {
            switch (head)
            {
            case 0x40:
                /* PLUS-INFINITY */
                *val = ASN1double_pinf();
                break;
            case 0x41:
                /* MINUS-INFINITY */
                *val = ASN1double_minf();
                break;
            default:
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
        /* decimal encoding */
        else
        {
            CopyMemory(buf, p, len - 1);
            buf[len - 1] = 0;
            b = strchr(buf, ',');
            if (b)
                *b = '.';
            *val = strtod((char *)buf, &b);
            if (*b)
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
    }
    return 1;
}
#endif // ENABLE_DOUBLE

#ifdef ENABLE_REAL
int ASN1BERDecReal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1real_t *val)
{
    ASN1uint32_t head;
    ASN1int32_t ex;
    // ASN1intx_t exponent;
    ASN1uint32_t baselog2;
    ASN1uint32_t len;
    ASN1uint32_t i;
    ASN1octet_t *p, *q;
    double v;
    ASN1intx_t help;

    if (!ASN1BERDecTag(dec, tag, NULL))
        return 0;
    if (!ASN1BERDecLength(dec, &len, NULL))
        return 0;

    // *val = 0.0;
    DecAssert(dec, 0 == (int) eReal_Normal);
    ZeroMemory(val, sizeof(*val));
    if (len)
    {
        p = q = dec->pos;
        dec->pos += len;
        head = *p++;

        /* binary encoding? */
        if (head & 0x80)
        {
            val->type = eReal_Normal;

            /* get base */
            switch (head & 0x30)
            {
            case 0:
                /* base 2 */
                baselog2 = 1;
                break;
            case 0x10:
                /* base 8 */
                baselog2 = 3;
                break;
            case 0x20:
                /* base 16 */
                baselog2 = 4;
                break;
            default:
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }

            /* get exponent */
            switch (head & 0x03)
            {
            case 0:
                /* 8 bit exponent */
                ex = (ASN1int8_t)*p++;
                ASN1intx_setint32(&val->exponent, ex);
                break;
            case 1:
                /* 16 bit exponent */
                ex = (ASN1int16_t)((*p << 8) | p[1]);
                p += 2;
                // ASN1intx_setint32_t(&exponent, ex);
                ASN1intx_setint32(&val->exponent, ex);
                break;
            case 2:
                /* 24 bit exponent */
                ex = ((*p << 16) | (p[1] << 8) | p[2]);
                if (ex & 0x800000)
                    ex -= 0x1000000;
                // ASN1intx_setint32_t(&exponent, ex);
                ASN1intx_setint32(&val->exponent, ex);
                break;
            default:
                /* variable length exponent */
                val->exponent.length = *p;
                val->exponent.value = (ASN1octet_t *)DecMemAlloc(dec, *p);
                if (!val->exponent.value)
                {
                    return 0;
                }
                CopyMemory(val->exponent.value, p + 1, *p);
                p += *p + 1;
                break;
            }

            /* calculate remaining length */
            len -= (p - q);
            if (!len)
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }

            /* get mantissa */
            val->mantissa.length = (*p & 0x80) ? len + 1 : len;
            val->mantissa.value = (ASN1octet_t *)DecMemAlloc(dec, val->mantissa.length);
            if (!val->mantissa.value)
            {
                return 0;
            }
            val->mantissa.value[0] = 0;
            CopyMemory(val->mantissa.value + val->mantissa.length - len, p, len);

            /* scale mantissa */
            switch (head & 0x0c)
            {
            case 0x04:
                /* scaling factor 1 */
                ASN1intx_muloctet(&help, &val->mantissa, 2);
                ASN1intx_free(&val->mantissa);
                val->mantissa = help;
                break;
            case 0x08:
                /* scaling factor 2 */
                ASN1intx_muloctet(&help, &val->mantissa, 4);
                ASN1intx_free(&val->mantissa);
                val->mantissa = help;
                break;
            case 0x0c:
                /* scaling factor 3 */
                ASN1intx_muloctet(&help, &val->mantissa, 8);
                ASN1intx_free(&val->mantissa);
                val->mantissa = help;
                break;
            }

            /* check sign */
            if (head & 0x40)
            {
                ASN1intx_neg(&help, &val->mantissa);
                ASN1intx_free(&val->mantissa);
                val->mantissa = help;
            }
        }
        else
        /* special real values? */
        if (head & 0x40)
        {
            switch (head)
            {
            case 0x40:
                /* PLUS-INFINITY */
                val->type = eReal_PlusInfinity;
                break;
            case 0x41:
                /* MINUS-INFINITY */
                val->type = eReal_MinusInfinity;
                break;
            default:
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
        /* decimal encoding */
        else
        {
            char *b;
            char buf[256];

            DecAssert(dec, (head & 0xc0) == 0xc0); 
            CopyMemory(buf, p, len - 1);
            buf[len - 1] = 0;
            ex = 0;
            b = strchr(buf, ',');
            if (b)
            {
                // move the decimal point to the right
                ex -= lstrlenA(b+1);
                lstrcpyA(b, b+1);
            }
            // skip leading zeros
            for (b = &buf[0]; '0' == *b; b++)
                ;
            val->type = eReal_Normal;
            val->base = 10;
            ASN1intx_setint32(&val->exponent, ex);
            /*XXX*/
            // missing code here!!!
            // need to set val->mantissa through the decimal digits string
            DecAssert(dec, 0);
            return 0;
        }
    }
    return 1;
}
#endif // ENABLE_REAL

#ifdef ENABLE_EMBEDDED_PDV
/* decode embedded pdv value */
int ASN1BERDecEmbeddedPdv(ASN1decoding_t dec, ASN1uint32_t tag, ASN1embeddedpdv_t *val)
{
    ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t) dec;
    ASN1uint32_t constructed, len, infinite;
    ASN1uint32_t index;
    ASN1embeddedpdv_identification_t *identification;
    ASN1decoding_t dd, dd2, dd3;
    ASN1octet_t *di, *di2, *di3;

    /* skip tag */
    if (!ASN1BERDecTag(dec, tag, &constructed))
        return 0;

    if (constructed)
    {
        /* constructed? EP-A encoded: */
        /* get length */
        if (!ASN1BERDecLength(dec, &len, &infinite))
            return 0;

        /* then start decoding of constructed value */
        if (! _BERDecConstructed(dec, len, infinite, &dd, &di))
            return 0;
        if (!ASN1BERDecU32Val(dd, 0x80000000, &index))
            return 0;
        if (index != d->parent->epilength)
        {
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        if (!ASN1BERDecExplicitTag(dd, 0x80000001, &dd2, &di2))
            return 0;
        if (!ASN1BERDecPeekTag(dd2, &tag))
            return 0;
        switch (tag)
        {
        case 0x80000000:
            val->identification.o = ASN1embeddedpdv_identification_syntaxes_o;
            if (!ASN1BERDecExplicitTag(dd2, 0x80000000, &dd3, &di3))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000000,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000001,
                &val->identification.u.syntaxes.transfer))
                return 0;
            if (!ASN1BERDecEndOfContents(dd2, dd3, di3))
                return 0;
            break;
        case 0x80000001:
            val->identification.o = ASN1embeddedpdv_identification_syntax_o;
            if (!ASN1BERDecObjectIdentifier(dd2, 0x80000001,
                &val->identification.u.syntax))
                return 0;
            break;
        case 0x80000002:
            val->identification.o =
                ASN1embeddedpdv_identification_presentation_context_id_o;
            if (!ASN1BERDecU32Val(dd2, 0x80000002,
                &val->identification.u.presentation_context_id))
                return 0;
            break;
        case 0x80000003:
            val->identification.o =
                ASN1embeddedpdv_identification_context_negotiation_o;
            if (!ASN1BERDecExplicitTag(dd2, 0x80000003, &dd3, &di3))
                return 0;
            if (!ASN1BERDecU32Val(dd3, 0x80000000, &val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1BERDecObjectIdentifier(dd3, 0x80000001,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            if (!ASN1BERDecEndOfContents(dd2, dd3, di3))
                return 0;
            break;
        case 0x80000004:
            val->identification.o =
                ASN1embeddedpdv_identification_transfer_syntax_o;
            if (!ASN1BERDecObjectIdentifier(dd2, 0x80000004,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case 0x80000005:
            val->identification.o = ASN1embeddedpdv_identification_fixed_o;
            if (!ASN1BERDecNull(dd2, 0x80000005))
                return 0;
            break;
        default:
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        if (!ASN1BERDecEndOfContents(dd, dd2, di2))
            return 0;
        if (!ASN1DecAddEmbeddedPdvIdentification(d->parent,
            &val->identification))
            return 0;
        val->data_value.o = ASN1embeddedpdv_data_value_encoded_o;
        if (!ASN1BERDecBitString(dd, 0x80000003,
            &val->data_value.u.encoded))
            return 0;
        if (!ASN1BERDecEndOfContents(dec, dd, di))
            return 0;
    }
    else
    {
        /* primitive? EP-B encoded: */
        if (!ASN1BERDecLength(dec, &len, NULL))
            return 0;

        /* then copy value */
        if (!len)
        {
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }
        val->data_value.o = ASN1embeddedpdv_data_value_encoded_o;
        val->data_value.u.encoded.length = 8 * (len - 1);
        val->data_value.u.encoded.value = (ASN1octet_t *)DecMemAlloc(dec, len - 1);
        if (!val->data_value.u.encoded.value)
        {
            return 0;
        }
        index = *dec->pos++;
        CopyMemory(val->data_value.u.encoded.value, dec->pos, len - 1);
        identification = ASN1DecGetEmbeddedPdvIdentification(d->parent, index);
        if (!identification)
            return 0;
        val->identification.o = identification->o;
        switch (identification->o)
        {
        case ASN1embeddedpdv_identification_syntaxes_o:
            if (!ASN1DecDupObjectIdentifier(dec, 
                &val->identification.u.syntaxes.abstract,
                &identification->u.syntaxes.abstract))
                return 0;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntaxes.transfer,
                &identification->u.syntaxes.transfer))
                return 0;
            break;
        case ASN1embeddedpdv_identification_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntax,
                &identification->u.syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_presentation_context_id_o:
            val->identification.u.presentation_context_id =
                identification->u.presentation_context_id;
            break;
        case ASN1embeddedpdv_identification_context_negotiation_o:
            val->identification.u.context_negotiation.presentation_context_id =
                identification->u.context_negotiation.presentation_context_id;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.context_negotiation.transfer_syntax,
                &identification->u.context_negotiation.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_transfer_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.transfer_syntax,
                &identification->u.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_fixed_o:
            break;
        }
    }
    return 1;
}
#endif // ENABLE_EMBEDDED_PDV

#ifdef ENABLE_EXTERNAL
/* decode external value */
int ASN1BERDecExternal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1external_t *val)
{
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1objectidentifier_t id;
    ASN1octetstring_t os;

    /* decode explicit tag */
    if (!ASN1BERDecExplicitTag(dec, tag | 0x20000000, &dd, &di))
        return 0;

    /* peek tag of choice alternative */
    if (!ASN1BERDecPeekTag(dd, &tag))
        return 0;

    /* decode alternative */
    if (tag == 0x6)
    {
        if (!ASN1BERDecObjectIdentifier(dd, 0x6, &id))
            return 0;
        if (!ASN1BERDecPeekTag(dd, &tag))
            return 0;
        if (tag == 0x2)
        {
            val->identification.o =
                ASN1external_identification_context_negotiation_o;
            val->identification.u.context_negotiation.transfer_syntax = id;
            if (!ASN1BERDecU32Val(dd, 0x2, &val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1BERDecPeekTag(dd, &tag))
                return 0;
        }
        else
        {
            val->identification.o = ASN1external_identification_syntax_o;
            val->identification.u.syntax = id;
        }
    }
    else
    if (tag == 0x2)
    {
        val->identification.o =
            ASN1external_identification_presentation_context_id_o;
        if (!ASN1BERDecU32Val(dd, 0x2,
            &val->identification.u.presentation_context_id))
            return 0;
        if (!ASN1BERDecPeekTag(dd, &tag))
            return 0;
    }
    else
    {
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
        return 0;
    }

    /* decode optional data value descriptor if present */
    if (tag == 0x7)
    {
        if (!ASN1BERDecZeroCharString(dd, 0x7, &val->data_value_descriptor))
            return 0;
        if (!ASN1BERDecPeekTag(dd, &tag))
            return 0;
    }
    else
    {
        val->data_value_descriptor = NULL;
    }

    /* decode data value alternative */
    switch (tag)
    {
    case 0:
        val->data_value.o = ASN1external_data_value_notation_o;
        if (!ASN1BERDecOpenType(dd, &val->data_value.u.notation))
            return 0;
        break;
    case 1:
        val->data_value.o = ASN1external_data_value_encoded_o;
        if (!ASN1BERDecOctetString(dd, 0x4, &os))
            return 0;
        val->data_value.u.encoded.value = os.value;
        val->data_value.u.encoded.length = os.length * 8;
        break;
    case 2:
        val->data_value.o = ASN1external_data_value_encoded_o;
        if (!ASN1BERDecBitString(dd, 0x3, &val->data_value.u.encoded))
            return 0;
        break;
    default:
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
        return 0;
    }

    /* end of constructed (explicit tagged) value */
    if (!ASN1BERDecEndOfContents(dec, dd, di))
        return 0;

    return 1;
}
#endif // ENABLE_EXTERNAL

/* decode generalized time value */
int ASN1BERDecGeneralizedTime(ASN1decoding_t dec, ASN1uint32_t tag, ASN1generalizedtime_t *val)
{
    ASN1ztcharstring_t time;
    if (ASN1BERDecZeroCharString(dec, tag, &time))
    {
        int rc = ASN1string2generalizedtime(val, time);
        DecMemFree(dec, time);
        if (rc)
        {
            return 1;
        }
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
    }
    return 0;
}

/* decode multibyte string value */
int ASN1BERDecZeroMultibyteString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztcharstring_t *val)
{
    return ASN1BERDecZeroCharString(dec, tag, val);
}

int ASN1BERDecMultibyteString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1charstring_t *val)
{
    return ASN1BERDecCharString(dec, tag, val);
}

/* decode null value */
int ASN1BERDecNull(ASN1decoding_t dec, ASN1uint32_t tag)
{
    ASN1uint32_t len;
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            if (! len)
            {
                return 1;
            }
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
        }
    }
    return 0;
}

/* decode object identifier value */
int ASN1BERDecObjectIdentifier(ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier_t *val)
{
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len, i, v;
        ASN1octet_t *data, *p;
        ASN1uint32_t nelem;
        ASN1objectidentifier_t q;

        if (ASN1BERDecLength(dec, &len, NULL))
        {
            data = dec->pos;
            dec->pos += len;
            nelem = 1;
            for (i = 0, p = data; i < len; i++, p++)
            {
                if (!(*p & 0x80))
                    nelem++;
            }
            *val = q = DecAllocObjectIdentifier(dec, nelem);
            if (q)
            {
                v = 0;
                for (i = 0, p = data; i < len; i++, p++)
                {
                    v = (v << 7) | (*p & 0x7f);
                    if (!(*p & 0x80))
                    {
                        if (q == *val)
                        { // first id
                            q->value = v / 40;
                            if (q->value > 2)
                                q->value = 2;
                            q->next->value = v - 40 * q->value;
                            q = q->next->next;
                        }
                        else
                        {
                            q->value = v;
                            q = q->next;
                        }
                        v = 0;
                    }
                }
                return 1;
            }
        }
    }
    return 0;
}

/* decode object identifier value */
int ASN1BERDecObjectIdentifier2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1objectidentifier2_t *val)
{
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len, i, v;
        ASN1octet_t *data, *p;
        ASN1objectidentifier_t q;

        if (ASN1BERDecLength(dec, &len, NULL))
        {
            if (len <= 16) // lonchanc: hard-coded value 16 to be consistent with ASN1objectidentifier2_t
            {
                data = dec->pos;
                dec->pos += len;
                val->count = 0;
                v = 0;
                for (i = 0, p = data; i < len; i++, p++)
                {
                    v = (v << 7) | (*p & 0x7f);
                    if (!(*p & 0x80))
                    {
                        if (! val->count)
                        { // first id
                            val->value[0] = v / 40;
                            if (val->value[0] > 2)
                                val->value[0] = 2;
                            val->value[1] = v - 40 * val->value[0];
                            val->count = 2;
                        }
                        else
                        {
                            val->value[val->count++] = v;
                        }
                        v = 0;
                    }
                }
                return 1;
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_LARGE);
            }
        }
    }
    return 0;
}

/* decode integer into signed 8 bit value */
int ASN1BERDecS8Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int8_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            if (1 == len)
            {
                *val = *dec->pos++;
                return 1;
            }
            ASN1DecSetError(dec, (len < 1) ? ASN1_ERR_CORRUPT : ASN1_ERR_LARGE);
        }
    }
    return 0;
}

/* decode integer into signed 16 bit value */
int ASN1BERDecS16Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int16_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            switch (len)
            {
            case 1:
                *val = *dec->pos++;
                break;
            case 2:
                *val = (*dec->pos << 8) | dec->pos[1];
                dec->pos += 2;
                break;
            default:
                ASN1DecSetError(dec, (len < 1) ? ASN1_ERR_CORRUPT : ASN1_ERR_LARGE);
                return 0;
            }
            return 1;
        }
    }
    return 0;
}

const ASN1int32_t c_nSignMask[] = { 0xFFFFFF00, 0xFFFF0000, 0xFF000000, 0 };

/* decode integer into signed 32 bit value */
int ASN1BERDecS32Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1int32_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            int fSigned = 0x80 & *dec->pos;

            /* get value */
            switch (len)
            {
            case 1:
                *val = *dec->pos++;
                break;
            case 2:
                *val = (*dec->pos << 8) | dec->pos[1];
                dec->pos += 2;
                break;
            case 3:
                *val = (*dec->pos << 16) | (dec->pos[1] << 8) | dec->pos[2];
                dec->pos += 3;
                break;
            case 4:
                *val = (*dec->pos << 24) | (dec->pos[1] << 16) |
                    (dec->pos[2] << 8) | dec->pos[3];
                dec->pos += 4;
                break;
            default:
                ASN1DecSetError(dec, (len < 1) ? ASN1_ERR_CORRUPT : ASN1_ERR_LARGE);
                return 0;
            }
            if (fSigned)
            {
                *val |= c_nSignMask[len-1];
            }
            return 1;
        }
    }
    return 0;
}

/* decode integer into intx value */
int ASN1BERDecSXVal(ASN1decoding_t dec, ASN1uint32_t tag, ASN1intx_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            if (len >= 1)
            {
                val->length = len;
                val->value = (ASN1octet_t *)DecMemAlloc(dec, len);
                if (val->value)
                {
                    CopyMemory(val->value, dec->pos, len);
                    dec->pos += len;
                    return 1;
                }
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            }
        }
    }
    return 0;
}

/* decode integer into unsigned 8 bit value */
int ASN1BERDecU8Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint8_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            switch (len)
            {
            case 1:
                *val = *dec->pos++;
                return 1;
            case 2:
                if (0 == *dec->pos)
                {
                    *val = dec->pos[1];
                    dec->pos += 2;
                    return 1;
                }
                // intentionally fall through
            default:
                ASN1DecSetError(dec, (len < 1) ? ASN1_ERR_CORRUPT : ASN1_ERR_LARGE);
                break;
            }
        }
    }
    return 0;
}

/* decode integer into unsigned 16 bit value */
int ASN1BERDecU16Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint16_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            switch (len)
            {
            case 1:
                *val = *dec->pos++;
                return 1;
            case 2:
                *val = (*dec->pos << 8) | dec->pos[1];
                dec->pos += 2;
                return 1;
            case 3:
                if (0 == *dec->pos)
                {
                    *val = (dec->pos[1] << 8) | dec->pos[2];
                    dec->pos += 3;
                    return 1;
                }
                // intentionally fall through
            default:
                ASN1DecSetError(dec, (len < 1) ? ASN1_ERR_CORRUPT : ASN1_ERR_LARGE);
                break;
            }
        }
    }
    return 0;
}

/* decode utc time value */
int ASN1BERDecUTCTime(ASN1decoding_t dec, ASN1uint32_t tag, ASN1utctime_t *val)
{
    ASN1ztcharstring_t time;
    if (ASN1BERDecZeroCharString(dec, tag, &time))
    {
        int rc = ASN1string2utctime(val, time);
        DecMemFree(dec, time);
        if (rc)
        {
            return 1;
        }
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
    }
    return 0;
}

/* decode zero terminated string value */
int ASN1BERDecZeroCharString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztcharstring_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1ztcharstring_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t lv, lc;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                *val = NULL;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (ASN1BERDecZeroCharString(dd, 0x4, &c))
                        {
                            lv = My_lstrlenA(*val);
                            lc = My_lstrlenA(c);
                            if (lc)
                            {
                                /* resize value */
                                *val = (char *)DecMemReAlloc(dd, *val, lv + lc + 1);
                                if (*val)
                                {
                                    /* concat strings */
                                    CopyMemory(*val + lv, c, lc + 1);

                                    /* free unused string */
                                    DecMemFree(dec, c);
                                }
                                else
                                {
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            return 0;
                        }
                    } // while
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                *val = (char *)DecMemAlloc(dec, len + 1);
                if (*val)
                {
                    CopyMemory(*val, dec->pos, len);
                    (*val)[len] = 0;
                    dec->pos += len;
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode zero terminated 16 bit string value */
int ASN1BERDecZeroChar16String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztchar16string_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1ztchar16string_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t i;
    ASN1uint32_t lv, lc;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                *val = NULL;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        if (ASN1BERDecZeroChar16String(dd, 0x4, &c))
                        {
                            lv = ASN1str16len(*val);
                            lc = ASN1str16len(c);
                            if (lc)
                            {
                                /* resize value */
                                *val = (ASN1char16_t *)DecMemReAlloc(dd, *val, (lv + lc + 1) * sizeof(ASN1char16_t));
                                if (*val)
                                {
                                    /* concat strings */
                                    CopyMemory(*val + lv, c, (lc + 1) * sizeof(ASN1char16_t));

                                    /* free unused string */
                                    DecMemFree(dec, c);
                                }
                                else
                                {
                                    return 0;
                                }
                            }
                        }
                        else
                        {
                            return 0;
                        }
                    } // while
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
            else
            {
                /* primitive? then copy value */
                *val = (ASN1char16_t *)DecMemAlloc(dec, (len + 1) * sizeof(ASN1char16_t));
                if (*val)
                {
                    for (i = 0; i < len; i++)
                    {
                        (*val)[i] = (*dec->pos << 8) | dec->pos[1];
                        dec->pos += 2;
                    }
                    (*val)[len] = 0;
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode zero terminated 32 bit string value */
int ASN1BERDecZeroChar32String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1ztchar32string_t *val)
{
    ASN1uint32_t constructed, len, infinite;
    ASN1ztchar32string_t c;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1uint32_t i;
    ASN1uint32_t lv, lc;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (constructed)
            {
                /* constructed? then start decoding of constructed value */
                *val = (ASN1char32_t *)DecMemAlloc(dec, sizeof(ASN1char32_t));
                if (*val)
                {
                    **val = 0;
                    if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                    {
                        while (ASN1BERDecNotEndOfContents(dd, di))
                        {
                            if (ASN1BERDecZeroChar32String(dd, 0x4, &c))
                            {
                                lv = ASN1str32len(*val);
                                lc = ASN1str32len(c);
                                if (lc)
                                {
                                    /* resize value */
                                    *val = (ASN1char32_t *)DecMemReAlloc(dd, *val, (lv + lc + 1) * sizeof(ASN1char32_t));
                                    if (*val)
                                    {
                                        /* concat strings */
                                        CopyMemory(*val + lv, c, (lc + 1) * sizeof(ASN1char32_t));

                                        /* free unused string */
                                        DecMemFree(dec, c);
                                    }
                                }
                            }
                            else
                            {
                                return 0;
                            }
                        }
                        return ASN1BERDecEndOfContents(dec, dd, di);
                    }
                }
            }
            else
            {
                /* primitive? then copy value */
                *val = (ASN1char32_t *)DecMemAlloc(dec, (len + 1) * sizeof(ASN1char32_t));
                if (*val)
                {
                    for (i = 0; i < len; i++)
                    {
                        (*val)[i] = (*dec->pos << 24) | (dec->pos[1] << 16) |
                                    (dec->pos[2] << 8) | dec->pos[3];;
                        dec->pos += 4;
                    }
                    (*val)[len] = 0;
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* skip a value */
int ASN1BERDecSkip(ASN1decoding_t dec)
{
    ASN1uint32_t tag;
    ASN1uint32_t constructed, len, infinite;
    ASN1decoding_t dd;
    ASN1octet_t *di;

    /* set warning flag */
    ASN1DecSetError(dec, ASN1_WRN_EXTENDED);

    /* read tag */
    if (ASN1BERDecPeekTag(dec, &tag))
    {
        if (ASN1BERDecTag(dec, tag, &constructed))
        {
            if (constructed)
            {
                /* constructed? then get length */
                if (ASN1BERDecLength(dec, &len, &infinite))
                {
                    if (!infinite)
                    {
                        /* skip value */
                        dec->pos += len;
                        // remove the above warning set previously
                        ASN1DecSetError(dec, ASN1_SUCCESS);
                        return 1;
                    } 

                    /* start skipping of constructed value */
                    if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                    {
                        while (ASN1BERDecNotEndOfContents(dd, di))
                        {
                            if (ASN1BERDecSkip(dd))
                            {
                                continue;
                            }
                            return 0;
                        }
                        if (ASN1BERDecEndOfContents(dec, dd, di))
                        {
                            // remove the above warning set previously
                            ASN1DecSetError(dec, ASN1_SUCCESS);
                            return 1;
                        }
                        return 0;
                    }
                }
            }
            else
            {
                /* primitive? then get length */
                if (ASN1BERDecLength(dec, &len, NULL))
                {
                    /* skip value */
                    dec->pos += len;
                    // remove the above warning set previously
                    ASN1DecSetError(dec, ASN1_SUCCESS);
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode an open type value */
int _BERDecOpenType(ASN1decoding_t dec, ASN1open_t *val, ASN1uint32_t fNoCopy)
{
    ASN1uint32_t tag;
    ASN1uint32_t constructed, len, infinite;
    ASN1decoding_t dd;
    ASN1octet_t *di;
    ASN1octet_t *p;

    p = dec->pos;

    /* skip tag */
    if (ASN1BERDecPeekTag(dec, &tag))
    {
        if (ASN1BERDecTag(dec, tag, &constructed))
        {
            if (constructed)
            {
                /* constructed? then get length */
                if (ASN1BERDecLength(dec, &len, &infinite))
                {
                    if (!infinite)
                    {
                        /* skip value */
                        dec->pos += len;
                        goto MakeCopy;
                    } 

                    /* start decoding of constructed value */
                    if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                    {
                        while (ASN1BERDecNotEndOfContents(dd, di))
                        {
                            if (ASN1BERDecSkip(dd))
                            {
                                continue;
                            }
                            return 0;
                        }
                        if (ASN1BERDecEndOfContents(dec, dd, di))
                        {
                            goto MakeCopy;
                        }
                    }
                }
                return 0;
            }
            else
            {
                /* primitive? then get length */
                if (ASN1BERDecLength(dec, &len, NULL))
                {
                    /* skip value */
                    dec->pos += len;
                }
                else
                {
                    return 0;
                }
            }

        MakeCopy:

            // clean up unused fields
            // val->decoded = NULL;
            // val->userdata = NULL;

            /* copy skipped value */
            val->length = (ASN1uint32_t) (dec->pos - p);
            if (fNoCopy)
            {
                val->encoded = p;
                return 1;
            }
            else
            {
                val->encoded = (ASN1octet_t *)DecMemAlloc(dec, val->length);
                if (val->encoded)
                {
                    CopyMemory(val->encoded, p, val->length);
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* decode an open type value, making a copy */
int ASN1BERDecOpenType(ASN1decoding_t dec, ASN1open_t *val)
{
    return _BERDecOpenType(dec, val, FALSE);
}

/* decode an open type value, no copy */
int ASN1BERDecOpenType2(ASN1decoding_t dec, ASN1open_t *val)
{
    return _BERDecOpenType(dec, val, TRUE);
}

/* finish decoding */
int ASN1BERDecFlush(ASN1decoding_t dec)
{
    /* calculate length */
    dec->len = (ASN1uint32_t) (dec->pos - dec->buf);

    /* set WRN_NOEOD if data left */
    if (dec->len >= dec->size)
    {
        DecAssert(dec, dec->len == dec->size);
        return 1;
    }
    ASN1DecSetError(dec, ASN1_WRN_NOEOD);
    return 1;
}

#endif // ENABLE_BER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\msasn1\char.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"


/* check if a 16 bit character is a space */
int ASN1is16space(ASN1char16_t c)
{
    return c == ' ' || c == '\t' || c == '\b' || c == '\f' || c == '\r' ||
	c == '\n' || c == '\v';
}

/* get length of a 16 bit string */
// lonchanc: lstrlenW()
int ASN1str16len(ASN1char16_t *p)
{
    
    int len;

    for (len = 0; *p; p++)
        len++;
    return len;
}

int My_lstrlenA(char *p)
{
    return (NULL != p) ? lstrlenA(p) : 0;
}

int My_lstrlenW(WCHAR *p)
{
    return (NULL != p) ? lstrlenW(p) : 0;
}

/* check if a 32 bit character is a space */
int ASN1is32space(ASN1char32_t c)
{
    return c == ' ' || c == '\t' || c == '\b' || c == '\f' || c == '\r' ||
            c == '\n' || c == '\v';
}

/* get length of a 32 bit string */
int ASN1str32len(ASN1char32_t *p)
{
    int len;

    for (len = 0; *p; p++)
        len++;
    return len;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\msasn1\bit.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"


static const ASN1uint8_t
c_aBitMask[] = {
    0x00, 0x01, 0x03, 0x07, 0x0f, 0x1f, 0x3f, 0x7f, 0xff
};

static const ASN1uint8_t
c_aBitMask2[] = {
    0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe, 0xff
};

static const ASN1uint8_t
c_aBitMask4[] = {
    0xff, 0x7f, 0x3f, 0x1f, 0x0f, 0x07, 0x03, 0x01, 0x00
};

static const ASN1int32_t
c_aBitMask5[] = {
    (ASN1int32_t)0xffffffff, (ASN1int32_t)0xfffffffe,
    (ASN1int32_t)0xfffffffc, (ASN1int32_t)0xfffffff8,
    (ASN1int32_t)0xfffffff0, (ASN1int32_t)0xffffffe0,
    (ASN1int32_t)0xffffffc0, (ASN1int32_t)0xffffff80,
    (ASN1int32_t)0xffffff00, (ASN1int32_t)0xfffffe00,
    (ASN1int32_t)0xfffffc00, (ASN1int32_t)0xfffff800,
    (ASN1int32_t)0xfffff000, (ASN1int32_t)0xffffe000,
    (ASN1int32_t)0xffffc000, (ASN1int32_t)0xffff8000,
    (ASN1int32_t)0xffff0000, (ASN1int32_t)0xfffe0000,
    (ASN1int32_t)0xfffc0000, (ASN1int32_t)0xfff80000,
    (ASN1int32_t)0xfff00000, (ASN1int32_t)0xffe00000,
    (ASN1int32_t)0xffc00000, (ASN1int32_t)0xff800000,
    (ASN1int32_t)0xff000000, (ASN1int32_t)0xfe000000,
    (ASN1int32_t)0xfc000000, (ASN1int32_t)0xf8000000,
    (ASN1int32_t)0xf0000000, (ASN1int32_t)0xe0000000,
    (ASN1int32_t)0xc0000000, (ASN1int32_t)0x80000000,
    (ASN1int32_t)0x00000000
};

static const ASN1uint8_t
c_aBitCount[] = {
    0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
    4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
};

/* copy nbits bits from src/srcbit into dst/dstbit;
   src points to first octet containing bits to be copied
   srcbit names the first bit within the first octet to be copied (0=msb, 7=lsb)
   dst points to first octet to copy into
   dstbit names the first bit within the first octet to copy into (0=msb, 7=lsb)
   nbits is the number of bits to copy;
   assumes that bits of broken octet at dst/dstbit are cleared;
   bits of last octet behind dst/dstbit+nbits-1 will be cleared
*/
void ASN1bitcpy(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xsrcbit, xdstbit;

    if (!nbits)
        return;

    if (dstbit >= 8) {
        dst += dstbit / 8;
        dstbit &= 7;
    }
    if (srcbit >= 8) {
        src += srcbit / 8;
        srcbit &= 7;
    }

    /* check if we have to fill broken first octet */
    if (dstbit) {
        xdstbit = 8 - dstbit;

        /* enough bits to fill up broken octet? */
        if (nbits >= xdstbit) {
            if (srcbit < dstbit) {
                *dst++ |= (*src >> (dstbit - srcbit)) & c_aBitMask[xdstbit];
                nbits -= xdstbit;
                srcbit += xdstbit;
                dstbit = 0;
            } else if (srcbit == dstbit) {
                *dst++ |= *src++ & c_aBitMask[xdstbit];
                nbits -= xdstbit;
                srcbit = 0;
                dstbit = 0;
            } else {
                *dst++ |= ((*src & c_aBitMask[8 - srcbit]) << (srcbit - dstbit)) |
                    (src[1] >> (8 - (srcbit - dstbit)));
                nbits -= xdstbit;
                src++;
                srcbit -= dstbit;
                dstbit = 0;
            }

        /* less bits to fill than needed to fill up the broken octet */
        } else {
            if (srcbit <= dstbit) {
                *dst |= ((*src >> (8 - srcbit - nbits)) & c_aBitMask[nbits]) <<
                    (xdstbit - nbits);
            } else {
                *dst++ |= ((*src & c_aBitMask[8 - srcbit]) << (srcbit - dstbit)) |
                    ((src[1] >> (16 - srcbit - nbits)) << (xdstbit - nbits));
            }
            return;
        }
    }

    /* fill up complete octets */
    if (nbits >= 8) {
        if (!srcbit) {
            CopyMemory(dst, src, nbits / 8);
            dst += nbits / 8;
            src += nbits / 8;
            nbits &= 7;
        } else {
            xsrcbit = 8 - srcbit;
            do {
                *dst++ = (*src << srcbit) | (src[1] >> (xsrcbit));
                src++;
                nbits -= 8;
            } while (nbits >= 8);
        }
    }

    /* fill bits into last octet */
    if (nbits)
        {
                *dst = (*src << srcbit) & c_aBitMask2[nbits];
                // lonchanc: made the following fix for the case that
                // src bits across byte boundary.
                if (srcbit + nbits > 8)
                {
                        xsrcbit = nbits - (8 - srcbit);
                        src++;
                        *dst |= ((*src & c_aBitMask2[xsrcbit]) >> (8 - srcbit));
                }
        }
}

/* clear nbits bits at dst/dstbit;
   bits of last octet behind dst/dstbit+nbits-1 will be cleared
*/
void ASN1bitclr(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xdstbit;

    if (!nbits)
        return;

    if (dstbit >= 8) {
        dst += dstbit / 8;
        dstbit &= 7;
    }

    /* clear broken ASN1octet first */
    if (dstbit) {
        xdstbit = 8 - dstbit;
        *dst &= c_aBitMask2[xdstbit];
        if (xdstbit < nbits) {
            dst++;
            nbits -= xdstbit;
        } else {
            return;
        }
    }

    /* clear remaining bits */
    ZeroMemory(dst, (nbits + 7) / 8);
}

/* clear nbits bits at dst/dstbit;
   bits of last octet behind dst/dstbit+nbits-1 will be cleared
*/
void ASN1bitset(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xdstbit;

    if (!nbits)
        return;

    if (dstbit >= 8) {
        dst += dstbit / 8;
        dstbit &= 7;
    }

    /* set broken ASN1octet first */
    if (dstbit) {
        xdstbit = 8 - dstbit;
        if (xdstbit < nbits) {
            *dst |= c_aBitMask4[xdstbit];
            dst++;
            nbits -= xdstbit;
        } else {
            *dst |= c_aBitMask4[nbits] << (xdstbit - nbits);
            return;
        }
    }

    /* set complete octets */
    if (nbits >= 8) {
        memset(dst, 0xff, nbits / 8);
        dst += nbits / 8;
        nbits &= 7;
    }

    /* set remaining bits */
    if (nbits)
        *dst |= c_aBitMask4[nbits] << (8 - nbits);
}

/* write nbits bits of val at dst/dstbit;
   assumes that bits of broken octet at dst/dstbit are cleared;
   bits of last octet behind dst/dstbit+nbits-1 will be cleared
*/
void ASN1bitput(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t val, ASN1uint32_t nbits)
{
    ASN1uint32_t xdstbit;

    if (!nbits)
        return;

    if (dstbit >= 8) {
        dst += dstbit / 8;
        dstbit &= 7;
    }
    xdstbit = 8 - dstbit;

    /* fill up broken octet first */
    if (dstbit) {
        if (xdstbit <= nbits) {
            *dst++ |= val >> (nbits -= xdstbit);
        } else {
            *dst |= (val & c_aBitMask[nbits]) << (xdstbit - nbits);
            return;
        }
    }

    /* copy complete octets */
    while (nbits >= 8)
        *dst++ = (ASN1octet_t) (val >> (nbits -= 8));

    /* copy left bits */
    if (nbits)
        *dst = (ASN1octet_t) ((val & c_aBitMask[nbits]) << (8 - nbits));
}

/* read nbits bits of val at src/srcbit */
// lonchanc: the return value is independent of big or little endian
// because we use shift left within a long integer.
ASN1uint32_t ASN1bitgetu(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xsrcbit;
    ASN1uint32_t ret;

    if (!nbits)
        return 0;

    if (srcbit >= 8) {
        src += srcbit / 8;
        srcbit &= 7;
    }
    xsrcbit = 8 - srcbit;
    ret = 0;

    /* get bits from broken octet first */
    if (srcbit) {
        if (xsrcbit <= nbits) {
            ret = (*src++ & c_aBitMask[xsrcbit]) << (nbits -= xsrcbit);
        } else {
            return (*src >> (xsrcbit - nbits)) & c_aBitMask[nbits];
        }
    }

    /* get complete octets */
    while (nbits >= 8)
        ret |= *src++ << (nbits -= 8);

    /* get left bits */
    if (nbits)
        ret |= ((*src) >> (8 - nbits)) & c_aBitMask[nbits];
    return ret;
}

/* read nbits bits of val at src/srcbit */
ASN1int32_t ASN1bitget(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xsrcbit;
    ASN1int32_t ret;

    if (!nbits)
        return 0;

    if (srcbit >= 8) {
        src += srcbit / 8;
        srcbit &= 7;
    }
    xsrcbit = 8 - srcbit;
    if (*src & (0x80 >> srcbit))
        ret = c_aBitMask5[nbits];
    else
        ret = 0;

    /* get bits from broken octet first */
    if (srcbit) {
        if (xsrcbit <= nbits) {
            ret = *src++ << (nbits -= xsrcbit);
        } else {
            return (*src >> (xsrcbit - nbits)) & c_aBitMask[nbits];
        }
    }

    /* get complete octets */
    while (nbits >= 8)
        ret |= *src++ << (nbits -= 8);

    /* get left bits */
    if (nbits)
        ret |= ((*src) >> (8 - nbits)) & c_aBitMask[nbits];
    return ret;
}

/* get number of set bits in nbits bits at src/srcbit */
ASN1uint32_t ASN1bitcount(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits)
{
    ASN1uint32_t xsrcbit;
    ASN1uint32_t ret;

    if (!nbits)
        return 0;

    if (srcbit >= 8) {
        src += srcbit / 8;
        srcbit &= 7;
    }
    xsrcbit = 8 - srcbit;

    /* count bits from broken octet first */
    if (srcbit) {
        if (xsrcbit <= nbits) {
            ret = c_aBitCount[*src++ & c_aBitMask4[srcbit]];
            nbits -= xsrcbit;
        } else {
            return c_aBitCount[(*src >> (xsrcbit - nbits)) & c_aBitMask[nbits]];
        }
    } else {
        ret = 0;
    }

    /* count bits in complete octets */
    while (nbits >= 8)
	{
        ret += c_aBitCount[*src++];
		nbits -= 8;
	}

    /* count left bits */
    if (nbits)
        ret += c_aBitCount[(*src) & c_aBitMask2[nbits]];
    return ret;
}

/* write noctets of val at dst */
void ASN1octetput(ASN1octet_t *dst, ASN1uint32_t val, ASN1uint32_t noctets)
{
    switch (noctets) {
    case 4:
        *dst++ = (ASN1octet_t)(val >> 24);
        /*FALLTHROUGH*/
    case 3:
        *dst++ = (ASN1octet_t)(val >> 16);
        /*FALLTHROUGH*/
    case 2:
        *dst++ = (ASN1octet_t)(val >> 8);
        /*FALLTHROUGH*/
    case 1:
        *dst++ = (ASN1octet_t)(val);
        break;
    default:
    break;
        MyAssert(0);
        /*NOTREACHED*/
    }
}

/* read noctets of val at dst */
ASN1uint32_t ASN1octetget(ASN1octet_t *src, ASN1uint32_t noctets)
{
    switch (noctets) {
    case 4:
        return (*src << 24) | (src[1] << 16) | (src[2] << 8) | src[3];
    case 3:
        return (*src << 16) | (src[1] << 8) | src[2];
    case 2:
        return (*src << 8) | src[1];
    case 1:
        return *src;
    default:
        MyAssert(0);
        return(0);
        /*NOTREACHED*/
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\msasn1\cintern.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "cintern.h"

/* external use only, allocate memory for decoding */
LPVOID ASN1DecAlloc(ASN1decoding_t dec, ASN1uint32_t size)
{
    return DecMemAlloc(dec, size);
}

/* external use only, reallocate memory for decoding */
LPVOID ASN1DecRealloc(ASN1decoding_t dec, LPVOID ptr, ASN1uint32_t size)
{
    return DecMemReAlloc(dec, ptr, size);
}

/* external use only, free a memory block */
void ASN1Free(LPVOID ptr)
{
    MemFree(ptr);
}

// lonchanc: we need to re-visit this approach of aborting a decoding
/* abort decoding, free any memory allocated for decoding */
void ASN1DecAbort(ASN1decoding_t dec)
{
    ASN1INTERNdecoding_t d = ((ASN1INTERNdecoding_t)dec)->parent;

#ifdef ENABLE_EXTRA_INFO
    /* clear the lists */
    d->memlength = d->epilength = d->csilength = 0;
    d->memsize = d->episize = d->csisize = 0;
    MemFree(d->mem);
    MemFree(d->epi);
    MemFree(d->csi);
    d->mem = NULL;
    d->epi = NULL;
    d->csi = NULL;
#endif // ENABLE_EXTRA_INFO
}

// lonchanc: we need to re-visit this approach of aborting a decoding
/* finish decoding */
void ASN1DecDone(ASN1decoding_t dec)
{
    ASN1INTERNdecoding_t d = ((ASN1INTERNdecoding_t)dec)->parent;

#ifdef ENABLE_EXTRA_INFO
    /* clear the lists */
    d->memlength = d->epilength = d->csilength = 0;
    d->memsize = d->episize = d->csisize = 0;
    MemFree(d->mem);
    MemFree(d->epi);
    MemFree(d->csi);
    d->mem = NULL;
    d->epi = NULL;
    d->csi = NULL;
#endif // ENABLE_EXTRA_INFO
}

// lonchanc: we need to re-visit this approach of aborting a decoding
/* abort encoding, free any memory allocated for encoding */
void ASN1EncAbort(ASN1encoding_t enc)
{
    ASN1INTERNencoding_t e = ((ASN1INTERNencoding_t)enc)->parent;

#ifdef ENABLE_EXTRA_INFO
    /* clear the lists */
    e->memlength = e->epilength = e->csilength = 0;
    e->memsize = e->episize = e->csisize = 0;
    MemFree(e->mem);
    MemFree(e->epi);
    MemFree(e->csi);
    e->mem = NULL;
    e->epi = NULL;
    e->csi = NULL;
#endif // ENABLE_EXTRA_INFO
}

// lonchanc: we need to re-visit this approach of aborting a decoding
/* finish encoding */
void ASN1EncDone(ASN1encoding_t enc)
{
    ASN1INTERNencoding_t e = ((ASN1INTERNencoding_t)enc)->parent;

#ifdef ENABLE_EXTRA_INFO
    /* clear the lists */
    e->memlength = e->epilength = e->csilength = 0;
    e->memsize = e->episize = e->csisize = 0;
    MemFree(e->mem);
    MemFree(e->epi);
    MemFree(e->csi);
    e->mem = NULL;
    e->epi = NULL;
    e->csi = NULL;
#endif // ENABLE_EXTRA_INFO
}


/* search the identification of an embedded pdv */
#ifdef ENABLE_EMBEDDED_PDV
int ASN1EncSearchEmbeddedPdvIdentification(ASN1INTERNencoding_t e, ASN1embeddedpdv_identification_t *identification, ASN1uint32_t *index, ASN1uint32_t *flag)
{
    ASN1embeddedpdv_identification_t **id;

    /* search identification in indentification list */
    /* if found then reset flag (to indicate EP-B encoding) and return */
    for (*index = 0, id = e->epi; *index < e->epilength; (*index)++, id++) {
        if ((*id)->o == identification->o) {
            switch ((*id)->o) {
            case ASN1embeddedpdv_identification_syntaxes_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.syntaxes.abstract,
                    &identification->u.syntaxes.abstract) &&
                    !ASN1objectidentifier_cmp(&(*id)->u.syntaxes.transfer,
                    &identification->u.syntaxes.transfer)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1embeddedpdv_identification_syntax_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.syntax,
                    &identification->u.syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1embeddedpdv_identification_presentation_context_id_o:
                if ((*id)->u.presentation_context_id ==
                    identification->u.presentation_context_id) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1embeddedpdv_identification_context_negotiation_o:
                if ((*id)->u.context_negotiation.presentation_context_id ==
                    identification->u.context_negotiation.
                    presentation_context_id &&
                    !ASN1objectidentifier_cmp(
                    &(*id)->u.context_negotiation.transfer_syntax,
                    &identification->u.context_negotiation.transfer_syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1embeddedpdv_identification_transfer_syntax_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.transfer_syntax,
                    &identification->u.transfer_syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1embeddedpdv_identification_fixed_o:
                *flag = 0;
                return 1;
            default:
                e->parent->info.err = ASN1_ERR_CORRUPT;
                return 0;
            }
        }
    }
    /* identification not found */

    /* add it into indentification array */
    if (e->epilength >= e->episize) {
        e->episize = e->episize ? 4 * e->episize : 16;
        e->epi = (ASN1embeddedpdv_identification_t **)MemReAlloc(e->epi,
            e->episize * sizeof(ASN1embeddedpdv_identification_t *), _ModName((ASN1encoding_t) e));
        if (!e->epi)
        {
            ASN1EncSetError((ASN1encoding_t) e, ASN1_ERR_MEMORY);
            return 0;
        }
    }
    e->epi[e->epilength++] = identification;

    /* return flag for EP-A encoding */
    *flag = 1;
    return 1;
}
#endif // ENABLE_EMBEDDED_PDV

/* search the identification of an character string */
#ifdef ENABLE_GENERALIZED_CHAR_STR
int ASN1EncSearchCharacterStringIdentification(ASN1INTERNencoding_t e, ASN1characterstring_identification_t *identification, ASN1uint32_t *index, ASN1uint32_t *flag)
{
    ASN1characterstring_identification_t **id;

    /* search identification in indentification list */
    /* if found then reset flag (to indicate CS-B encoding) and return */
    for (*index = 0, id = e->csi; *index < e->csilength; (*index)++, id++) {
        if ((*id)->o == identification->o) {
            switch ((*id)->o) {
            case ASN1characterstring_identification_syntaxes_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.syntaxes.abstract,
                    &identification->u.syntaxes.abstract) &&
                    !ASN1objectidentifier_cmp(&(*id)->u.syntaxes.transfer,
                    &identification->u.syntaxes.transfer)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1characterstring_identification_syntax_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.syntax,
                    &identification->u.syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1characterstring_identification_presentation_context_id_o:
                if ((*id)->u.presentation_context_id ==
                    identification->u.presentation_context_id) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1characterstring_identification_context_negotiation_o:
                if ((*id)->u.context_negotiation.presentation_context_id ==
                    identification->u.context_negotiation.
                    presentation_context_id &&
                    !ASN1objectidentifier_cmp(
                    &(*id)->u.context_negotiation.transfer_syntax,
                    &identification->u.context_negotiation.transfer_syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1characterstring_identification_transfer_syntax_o:
                if (!ASN1objectidentifier_cmp(&(*id)->u.transfer_syntax,
                    &identification->u.transfer_syntax)) {
                    *flag = 0;
                    return 1;
                }
                break;
            case ASN1characterstring_identification_fixed_o:
                *flag = 0;
                return 1;
            default:
                e->parent->info.err = ASN1_ERR_CORRUPT;
                return 0;
            }
        }
    }
    /* identification not found */

    /* add it into indentification array */
    if (e->csilength >= e->csisize) {
        e->csisize = e->csisize ? 4 * e->csisize : 16;
        e->csi = (ASN1characterstring_identification_t **)MemReAlloc(e->csi,
            e->csisize * sizeof(ASN1characterstring_identification_t *), _ModName((ASN1encoding_t) e));
        if (!e->csi)
        {
            ASN1EncSetError((ASN1encoding_t) e, ASN1_ERR_MEMORY);
            return 0;
        }
    }
    e->csi[e->csilength++] = identification;

    /* return flag for CS-A encoding */
    *flag = 1;
    return 1;
}
#endif // ENABLE_GENERALIZED_CHAR_STR

/* allocate and copy an object identifier */
#if defined(ENABLE_GENERALIZED_CHAR_STR) || defined(ENABLE_EMBEDDED_PDV)
int ASN1DecDupObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t *dst, ASN1objectidentifier_t *src)
{
    ASN1INTERNdecoding_t d = ((ASN1INTERNdecoding_t)dec)->parent;
    ASN1uint32_t l = GetObjectIdentifierCount(*src);
    *dst = DecAllocObjectIdentifier(dec, l);
    if (! *dst)
    {
        ASN1DecSetError((ASN1decoding_t) d, ASN1_ERR_MEMORY);
        return 0;
    }
    CopyObjectIdentifier(*dst, *src);
    return 1;
}
#endif // defined(ENABLE_GENERALIZED_CHAR_STR) || defined(ENABLE_EMBEDDED_PDV)

/* add an embedded pdv identification to the list of identifications */
#ifdef ENABLE_EMBEDDED_PDV
int ASN1DecAddEmbeddedPdvIdentification(ASN1INTERNdecoding_t d, ASN1embeddedpdv_identification_t *identification)
{
    if (d->epilength >= d->episize) {
        d->episize = d->episize ? 4 * d->episize : 16;
        d->epi = (ASN1embeddedpdv_identification_t **)MemReAlloc(d->epi,
            d->episize * sizeof(ASN1embeddedpdv_identification_t *), _ModName((ASN1decoding_t) d));
        if (!d->epi)
        {
            ASN1DecSetError((ASN1decoding_t) d, ASN1_ERR_MEMORY);
            return 0;
        }
    }
    d->epi[d->epilength++] = identification;
    return 1;
}
#endif // ENABLE_EMBEDDED_PDV

/* get an embedded pdv identification from the list of identifications */
#ifdef ENABLE_EMBEDDED_PDV
ASN1embeddedpdv_identification_t *ASN1DecGetEmbeddedPdvIdentification(ASN1INTERNdecoding_t d, ASN1uint32_t index)
{
    if (index >= d->epilength)
    {
        ASN1DecSetError((ASN1decoding_t) d, ASN1_ERR_CORRUPT);
        return NULL;
    }
    return d->epi[index];
}
#endif // ENABLE_EMBEDDED_PDV

/* add a character string identification to the list of identifications */
#ifdef ENABLE_GENERALIZED_CHAR_STR
int ASN1DecAddCharacterStringIdentification(ASN1INTERNdecoding_t d, ASN1characterstring_identification_t *identification)
{
    if (d->csilength >= d->csisize) {
        d->csisize = d->csisize ? 4 * d->csisize : 16;
        d->csi = (ASN1characterstring_identification_t **)MemReAlloc(d->csi,
            d->csisize * sizeof(ASN1characterstring_identification_t *), _ModName((ASN1decoding_t) d));
        if (!d->csi)
        {
            ASN1DecSetError((ASN1decoding_t) d, ASN1_ERR_MEMORY);
            return 0;
        }
    }
    d->csi[d->csilength++] = identification;
    return 1;
}
#endif // ENABLE_GENERALIZED_CHAR_STR

/* get a character string identification from the list of identifications */
#ifdef ENABLE_GENERALIZED_CHAR_STR
ASN1characterstring_identification_t *ASN1DecGetCharacterStringIdentification(ASN1INTERNdecoding_t d, ASN1uint32_t index)
{
    if (index >= d->csilength)
    {
        ASN1DecSetError((ASN1decoding_t) d, ASN1_ERR_CORRUPT);
        return NULL;
    }
    return d->csi[index];
}
#endif // ENABLE_GENERALIZED_CHAR_STR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\msasn1\berencod.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

#ifdef ENABLE_BER

#include <float.h>
#include <math.h>

#if HAS_IEEEFP_H
// #include <ieeefp.h>
#elif HAS_FLOAT_H
// #include <float.h>
#endif

static const char bitmsk2[] =
{
    (const char) 0x00,
    (const char) 0x80,
    (const char) 0xc0,
    (const char) 0xe0,
    (const char) 0xf0,
    (const char) 0xf8,
    (const char) 0xfc,
    (const char) 0xfe
};


/* encode a string value */
int ASN1BEREncCharString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        if (ASN1BEREncLength(enc, len))
        {
            CopyMemory(enc->pos, val, len);
            enc->pos += len;
            return 1;
        }
    }
    return 0;
}

/* encode a string value (CER) */
int ASN1CEREncCharString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char_t *val)
{
    ASN1uint32_t n;

    if (len <= 1000)
    {
        /* encode tag */
        if (ASN1BEREncTag(enc, tag))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, len))
            {
                CopyMemory(enc->pos, val, len);
                enc->pos += len;
                return 1;
            }
        }
    }
    else
    {
        ASN1uint32_t nLenOff;
        /* encode value as constructed, using segments of 1000 octets */
        if (ASN1BEREncExplicitTag(enc, tag, &nLenOff))
        {
            while (len)
            {
                n = len > 1000 ? 1000 : len;
                if (ASN1BEREncTag(enc, 0x4))
                {
                    if (ASN1BEREncLength(enc, n))
                    {
                        CopyMemory(enc->pos, val, n);
                        enc->pos += n;
                        val += n;
                        len -= n;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            }
            return ASN1BEREncEndOfContents(enc, nLenOff);
        }
    }
    return 0;
}

/* encode a 16 bit string value */
int ASN1BEREncChar16String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char16_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        if (ASN1BEREncLength(enc, len * sizeof(ASN1char16_t)))
        {
            while (len--)
            {
                *enc->pos++ = (ASN1octet_t)(*val >> 8);
                *enc->pos++ = (ASN1octet_t)(*val);
                val++;
            }
        }
        return 1;
    }
    return 0;
}

/* encode a 16 bit string value (CER) */
int ASN1CEREncChar16String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char16_t *val)
{
    ASN1uint32_t n;

    if (len <= 1000 / sizeof(ASN1char16_t))
    {
        /* encode tag */
        if (ASN1BEREncTag(enc, tag))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, len * sizeof(ASN1char16_t)))
            {
                while (len--)
                {
                    *enc->pos++ = (ASN1octet_t)(*val >> 8);
                    *enc->pos++ = (ASN1octet_t)(*val);
                    val++;
                }
                return 1;
            }
        }
    }
    else
    {
        ASN1uint32_t nLenOff;
        /* encode value as constructed, using segments of 1000 octets */
        if (ASN1BEREncExplicitTag(enc, tag, &nLenOff))
        {
            while (len)
            {
                n = len > 1000 / sizeof(ASN1char16_t) ?
                    1000 / sizeof(ASN1char16_t) : len;
                if (ASN1BEREncTag(enc, 0x4))
                {
                    if (ASN1BEREncLength(enc, n))
                    {
                        while (len--)
                        {
                            *enc->pos++ = (ASN1octet_t)(*val >> 8);
                            *enc->pos++ = (ASN1octet_t)(*val);
                            val++;
                        }
                        len -= n;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            }
            return ASN1BEREncEndOfContents(enc, nLenOff);
        }
    }
    return 0;
}

/* encode a 32 bit string value */
int ASN1BEREncChar32String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char32_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        if (ASN1BEREncLength(enc, len * sizeof(ASN1char32_t)))
        {
            while (len--)
            {
                *enc->pos++ = (ASN1octet_t)(*val >> 24);
                *enc->pos++ = (ASN1octet_t)(*val >> 16);
                *enc->pos++ = (ASN1octet_t)(*val >> 8);
                *enc->pos++ = (ASN1octet_t)(*val);
                val++;
            }
            return 1;
        }
    }
    return 0;
}

/* encode a 32 bit string value (CER) */
int ASN1CEREncChar32String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1char32_t *val)
{
    ASN1uint32_t n;

    if (len <= 1000 / sizeof(ASN1char32_t))
    {
        /* encode tag */
        if (ASN1BEREncTag(enc, tag))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, len * sizeof(ASN1char32_t)))
            {
                while (len--)
                {
                    *enc->pos++ = (ASN1octet_t)(*val >> 24);
                    *enc->pos++ = (ASN1octet_t)(*val >> 16);
                    *enc->pos++ = (ASN1octet_t)(*val >> 8);
                    *enc->pos++ = (ASN1octet_t)(*val);
                    val++;
                }
                return 1;
            }
        }
    }
    else
    {
        ASN1uint32_t nLenOff;
        /* encode value as constructed, using segments of 1000 octets */
        if (ASN1BEREncExplicitTag(enc, tag, &nLenOff))
        {
            while (len)
            {
                n = len > 1000 / sizeof(ASN1char32_t) ?
                    1000 / sizeof(ASN1char32_t) : len;
                if (ASN1BEREncTag(enc, 0x4))
                {
                    if (ASN1BEREncLength(enc, n))
                    {
                        while (len--)
                        {
                            *enc->pos++ = (ASN1octet_t)(*val >> 24);
                            *enc->pos++ = (ASN1octet_t)(*val >> 16);
                            *enc->pos++ = (ASN1octet_t)(*val >> 8);
                            *enc->pos++ = (ASN1octet_t)(*val);
                            val++;
                        }
                        len -= n;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            } // while
            return ASN1BEREncEndOfContents(enc, nLenOff);
        }
    }
    return 0;
}

/* encode a bit string value */
int ASN1BEREncBitString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    ASN1uint32_t noctets = (len + 7) / 8;

    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        if (ASN1BEREncLength(enc, noctets + 1))
        {
            ASN1uint32_t cUnusedBits = (7 - ((len + 7) & 7));
            *enc->pos++ = (ASN1octet_t) cUnusedBits;
            CopyMemory(enc->pos, val, noctets);
            enc->pos += noctets;
            EncAssert(enc, noctets >= 1);
            if (cUnusedBits)
            {
                EncAssert(enc, 8 >= cUnusedBits);
                *(enc->pos - 1) &= bitmsk2[8 - cUnusedBits];
            }
            return 1;
        }
    }
    return 0;
}

/* encode a bit string value (CER) */
int ASN1CEREncBitString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    ASN1uint32_t noctets;
    ASN1uint32_t n;

    noctets = (len + 7) / 8;
    if (noctets + 1 <= 1000)
    {
        /* encode tag */
        if (ASN1BEREncTag(enc, tag))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, noctets + 1))
            {
                *enc->pos++ = (ASN1octet_t) (7 - ((len + 7) & 7));
                CopyMemory(enc->pos, val, noctets);
                enc->pos += noctets;
                return 1;
            }
        }
    }
    else
    {
        ASN1uint32_t nLenOff;
        /* encode value as constructed, using segments of 1000 octets */
        if (ASN1BEREncExplicitTag(enc, tag, &nLenOff))
        {
            while (noctets)
            {
                n = len > 999 ? 999 : len;
                if (ASN1BEREncTag(enc, 0x3))
                {
                    if (ASN1BEREncLength(enc, n + 1))
                    {
                        *enc->pos++ = (ASN1octet_t) (n < len ? 0 : 7 - ((len + 7) & 7));
                        CopyMemory(enc->pos, val, n);
                        enc->pos += n;
                        val += n;
                        noctets -= n;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            } // while
            return ASN1BEREncEndOfContents(enc, nLenOff);
        }
    }
    return 0;
}

#ifdef ENABLE_GENERALIZED_CHAR_STR
/* encode a character string value */
int ASN1BEREncCharacterString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1characterstring_t *val)
{
    ASN1uint32_t index;
    ASN1uint32_t flag;

    /* search identification */
    if (!ASN1EncSearchCharacterStringIdentification(((ASN1INTERNencoding_t) enc)->parent,
        &val->identification, &index, &flag))
        return 0;
    if (index > 255)
        flag = 1;

    if (flag)
    {
        ASN1uint32_t nLenOff_, nLenOff0, nLenOff1;

        /* CS-A encoding: */
        /* encode as constructed value */
        if (!ASN1BEREncExplicitTag(enc, tag, &nLenOff_))
            return 0;

        /* encode index */
        if (!ASN1BEREncU32(enc, 0x80000000, index))
            return 0;

        /* encode tag of identification */
        if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
            return 0;

        /* encode identification */
        switch (val->identification.o)
        {
        case ASN1characterstring_identification_syntaxes_o:
            if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff1))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000000,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.syntaxes.transfer))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff1))
                return 0;
            break;
        case ASN1characterstring_identification_syntax_o:
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.syntax))
                return 0;
            break;
        case ASN1characterstring_identification_presentation_context_id_o:
            if (!ASN1BEREncU32(enc, 0x80000002,
                val->identification.u.presentation_context_id))
                return 0;
            break;
        case ASN1characterstring_identification_context_negotiation_o:
            if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff1))
                return 0;
            if (!ASN1BEREncU32(enc, 0x80000000, val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff1))
                return 0;
            break;
        case ASN1characterstring_identification_transfer_syntax_o:
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000004,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_fixed_o:
            if (!ASN1BEREncNull(enc, 0x80000005))
                return 0;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }

        /* end of identification */
        if (!ASN1BEREncEndOfContents(enc, nLenOff0))
            return 0;

        /* encode data value */
        switch (val->data_value.o)
        {
        case ASN1characterstring_data_value_notation_o:
            if (!ASN1BEREncOctetString(enc, 0x80000002,
                val->data_value.u.notation.length,
                val->data_value.u.notation.encoded))
                return 0;
            break;
        case ASN1characterstring_data_value_encoded_o:
            if (!ASN1BEREncOctetString(enc, 0x80000002,
                val->data_value.u.encoded.length,
                val->data_value.u.encoded.value))
                return 0;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }

        /* end of character string */
        if (!ASN1BEREncEndOfContents(enc, nLenOff_))
            return 0;
    }
    else
    {
        /* CS-B encoding: */
        /* encode tag */
        if (!ASN1BEREncTag(enc, tag))
            return 0;

        /* encode data value */
        switch (val->data_value.o)
        {
        case ASN1characterstring_data_value_notation_o:
            if (!ASN1BEREncLength(enc,
                val->data_value.u.notation.length + 1))
                return 0;
            *enc->pos++ = (ASN1octet_t) index;
            CopyMemory(enc->pos, val->data_value.u.notation.encoded,
                val->data_value.u.notation.length);
            enc->pos += val->data_value.u.notation.length;
            break;
        case ASN1characterstring_data_value_encoded_o:
            if (!ASN1BEREncLength(enc,
                val->data_value.u.encoded.length + 1))
                return 0;
            *enc->pos++ = (ASN1octet_t) index;
            CopyMemory(enc->pos, val->data_value.u.encoded.value,
                val->data_value.u.encoded.length);
            enc->pos += val->data_value.u.encoded.length;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }
    }
    return 1;
}
#endif // ENABLE_GENERALIZED_CHAR_STR

#ifdef ENABLE_DOUBLE
/* encode a real value */
int ASN1BEREncDouble(ASN1encoding_t enc, ASN1uint32_t tag, double d)
{
    double mantissa;
    int exponent;
    ASN1uint32_t nmoctets;
    ASN1uint32_t neoctets;
    ASN1octet_t head;
    ASN1uint32_t sign;
    ASN1uint32_t len;
    ASN1octet_t mASN1octets[16]; /* should be enough */
    ASN1octet_t eASN1octets[16]; /* should be enough */

    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* check for PLUS_INFINITY */
        if (ASN1double_ispinf(d))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, 1))
            {
                /* encode value */
                *enc->pos++ = 0x40;
                return 1;
            }
        }
        else
        /* check for MINUS_INFINITY */
        if (ASN1double_isminf(d))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, 1))
            {
                /* encode value */
                *enc->pos++ = 0x41;
                return 1;
            }
        }
        else
        /* check for bad real value */
        if (finite(d))
        {
            /* encode normal real value */

            /* split into mantissa and exponent */
            mantissa = frexp(d, &exponent);

            /* check for zero value */
            if (mantissa == 0.0 && exponent == 0)
            {
                /* encode zero length */
                return ASN1BEREncLength(enc, 0);
            }

            /* get sign bit */
            if (mantissa < 0.0)
            {
                sign = 1;
                mantissa = -mantissa;
            }
            else
            {
                sign = 0;
            }

            /* encode mantissa */
            nmoctets = 0;
            while (mantissa != 0.0 && nmoctets < sizeof(mASN1octets))
            {
                mantissa *= 256.0;
                exponent -= 8;
                mASN1octets[nmoctets++] = (int)mantissa;
                mantissa -= (double)(int)mantissa;
            }

            /* encode exponent and create head octet of encoded value */
            head = (ASN1octet_t) (0x80 | (sign << 6));
            if (exponent <= 0x7f && exponent >= -0x80)
            {
                eASN1octets[0] = (ASN1octet_t)(exponent);
                neoctets = 1;
            }
            else
            if (exponent <= 0x7fff && exponent >= -0x8000)
            {
                eASN1octets[0] = (ASN1octet_t)(exponent >> 8);
                eASN1octets[1] = (ASN1octet_t)(exponent);
                neoctets = 2;
                head |= 0x01;
            }
            else
            if (exponent <= 0x7fffff && exponent >= -0x800000)
            {
                eASN1octets[0] = (ASN1octet_t)(exponent >> 16);
                eASN1octets[1] = (ASN1octet_t)(exponent >> 8);
                eASN1octets[2] = (ASN1octet_t)(exponent);
                neoctets = 3;
                head |= 0x02;
            }
            else
            {
                eASN1octets[0] = 4; /* XXX does not work if ASN1int32_t != int */
                eASN1octets[1] = (ASN1octet_t)(exponent >> 24);
                eASN1octets[2] = (ASN1octet_t)(exponent >> 16);
                eASN1octets[3] = (ASN1octet_t)(exponent >> 8);
                eASN1octets[4] = (ASN1octet_t)(exponent);
                neoctets = 5;
                head |= 0x03;
            }

            /* encode length into first octet */
            len = 1 + neoctets + nmoctets;
            if (ASN1BEREncLength(enc, len))
            {
                /* put head octet, mantissa and exponent */
                *enc->pos++ = head;
                CopyMemory(enc->pos, eASN1octets, neoctets);
                enc->pos += neoctets;
                CopyMemory(enc->pos, mASN1octets, nmoctets);
                enc->pos += nmoctets;
                return 1;
            }
        }
        else
        {
            ASN1EncSetError(enc, ASN1_ERR_BADREAL);
        }
    }
    /* finished */
    return 0;
}
#endif // ENABLE_DOUBLE

#ifdef ENABLE_REAL
/* encode a real value */
int ASN1BEREncReal(ASN1encoding_t enc, ASN1uint32_t tag, ASN1real_t *val)
{
    ASN1intx_t mantissa;
    ASN1intx_t exponent;
    ASN1intx_t help;
    ASN1uint32_t nmoctets;
    ASN1uint32_t neoctets;
    ASN1octet_t head;
    ASN1uint32_t sign;
    ASN1uint32_t len;
    ASN1octet_t mASN1octets[256]; /* should be enough */
    ASN1octet_t eASN1octets[256]; /* should be enough */

    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* check for PLUS_INFINITY */
        if (val->type == eReal_PlusInfinity)
        {
            /* encode length */
            if (ASN1BEREncLength(enc, 1))
            {
                /* encode value */
                *enc->pos++ = 0x40;
                return 1;
            }
        }
        else
        /* check for MINUS_INFINITY */
        if (val->type == eReal_MinusInfinity)
        {
            /* encode length */
            if (ASN1BEREncLength(enc, 1))
            {
                /* encode value */
                *enc->pos++ = 0x41;
                return 1;
            }
        }
        /* encode normal real value */
        else
        {
            /* check for zero value */
            if (!ASN1intx_cmp(&val->mantissa, &ASN1intx_0))
            {
                /* encode zero length */
                return ASN1BEREncLength(enc, 0);
            }

            /* get sign bit */
            if (val->mantissa.value[0] > 0x7f)
            {
                sign = 1;
                ASN1intx_neg(&mantissa, &val->mantissa);
            }
            else
            {
                sign = 0;
                if (! ASN1intx_dup(&mantissa, &val->mantissa))
                {
                    return 0;
                }
            }
            if (! ASN1intx_dup(&exponent, &val->exponent))
            {
                return 0;
            }

            /* encode mantissa */
            nmoctets = ASN1intx_uoctets(&mantissa);
            if (nmoctets < 256)
            {
                CopyMemory(mASN1octets,
                    mantissa.value + mantissa.length - nmoctets,
                    nmoctets);
                ASN1intx_setuint32(&help, 8 * nmoctets);
                ASN1intx_sub(&exponent, &exponent, &help);
                ASN1intx_free(&mantissa);
                ASN1intx_free(&help);

                /* encode exponent and create head octet of encoded value */
                neoctets = ASN1intx_octets(&exponent);
                if (neoctets < 256)
                {
                    CopyMemory(mASN1octets,
                        val->exponent.value + val->exponent.length - neoctets,
                        neoctets);
                    ASN1intx_free(&exponent);
                    head = (ASN1octet_t) (0x80 | (sign << 6) | (neoctets - 1));

                    /* encode length into first octet */
                    len = 1 + neoctets + nmoctets;
                    if (ASN1BEREncLength(enc, len))
                    {
                        /* put head octet, mantissa and exponent */
                        *enc->pos++ = head;
                        CopyMemory(enc->pos, eASN1octets, neoctets);
                        enc->pos += neoctets;
                        CopyMemory(enc->pos, mASN1octets, nmoctets);
                        enc->pos += nmoctets;
                        return 1;
                    }
                }
                else
                {
                    ASN1intx_free(&exponent);
                    ASN1EncSetError(enc, ASN1_ERR_LARGE);
                }
            }
            else
            {
                ASN1intx_free(&mantissa);
                ASN1intx_free(&help);
                ASN1EncSetError(enc, ASN1_ERR_LARGE);
            }
        }
    }
    /* finished */
    return 0;
}
#endif // ENABLE_REAL

#ifdef ENABLE_EMBEDDED_PDV
/* encode an embedded pdv value */
int ASN1BEREncEmbeddedPdv(ASN1encoding_t enc, ASN1uint32_t tag, ASN1embeddedpdv_t *val)
{
    ASN1uint32_t index;
    ASN1uint32_t flag;

    /* search identification */
    if (!ASN1EncSearchEmbeddedPdvIdentification(((ASN1INTERNencoding_t) enc)->parent,
        &val->identification, &index, &flag))
        return 0;
    if (index > 255 ||
            (val->data_value.o == ASN1embeddedpdv_data_value_encoded_o &&
        (val->data_value.u.encoded.length & 7))) {
        flag = 1;
    }
        
    if (flag)
    {
        ASN1uint32_t nLenOff_, nLenOff0, nLenOff1;

        /* EP-A encoding: */
        /* encode as construct value */
        if (!ASN1BEREncExplicitTag(enc, tag, &nLenOff_))
            return 0;

        /* encode index */
        if (!ASN1BEREncU32(enc, 0x80000000, index))
            return 0;

        /* encode tag of identification */
        if (!ASN1BEREncExplicitTag(enc, 0x80000001, &nLenOff0))
            return 0;

        /* encode identification */
        switch (val->identification.o)
        {
        case ASN1embeddedpdv_identification_syntaxes_o:
            if (!ASN1BEREncExplicitTag(enc, 0x80000000, &nLenOff1))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000000,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.syntaxes.transfer))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff1))
                return 0;
            break;
        case ASN1embeddedpdv_identification_syntax_o:
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_presentation_context_id_o:
            if (!ASN1BEREncU32(enc, 0x80000002,
                val->identification.u.presentation_context_id))
                return 0;
            break;
        case ASN1embeddedpdv_identification_context_negotiation_o:
            if (!ASN1BEREncExplicitTag(enc, 0x80000003, &nLenOff1))
                return 0;
            if (!ASN1BEREncU32(enc, 0x80000000, val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000001,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff1))
                return 0;
            break;
        case ASN1embeddedpdv_identification_transfer_syntax_o:
            if (!ASN1BEREncObjectIdentifier(enc, 0x80000004,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_fixed_o:
            if (!ASN1BEREncNull(enc, 0x80000005))
                return 0;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }

        /* end of identification */
        if (!ASN1BEREncEndOfContents(enc, nLenOff0))
            return 0;

        /* encode data value */
        switch (val->data_value.o)
        {
        case ASN1embeddedpdv_data_value_notation_o:
            if (!ASN1BEREncBitString(enc, 0x80000002,
                val->data_value.u.notation.length * 8,
                val->data_value.u.notation.encoded))
                return 0;
            break;
        case ASN1embeddedpdv_data_value_encoded_o:
            if (!ASN1BEREncBitString(enc, 0x80000002,
                val->data_value.u.encoded.length,
                val->data_value.u.encoded.value))
                return 0;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }

        /* end of embedded pdv */
        if (!ASN1BEREncEndOfContents(enc, nLenOff_))
            return 0;
    }
    else
    {
        /* EP-B encoding: */
        /* encode tag */
        if (!ASN1BEREncTag(enc, tag))
            return 0;

        /* encode data value */
        switch (val->data_value.o)
        {
        case ASN1embeddedpdv_data_value_notation_o:
            if (!ASN1BEREncLength(enc,
                val->data_value.u.notation.length + 1))
                return 0;
            *enc->pos++ = (ASN1octet_t) index;
            CopyMemory(enc->pos, val->data_value.u.notation.encoded,
                val->data_value.u.notation.length);
            enc->pos += val->data_value.u.notation.length;
            break;
        case ASN1embeddedpdv_data_value_encoded_o:
            if (!ASN1BEREncLength(enc,
                val->data_value.u.encoded.length / 8 + 1))
                return 0;
            *enc->pos++ = (ASN1octet_t) index;
            CopyMemory(enc->pos, val->data_value.u.encoded.value,
                val->data_value.u.encoded.length / 8);
            enc->pos += val->data_value.u.encoded.length / 8;
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }
    }
    return 1;
}
#endif // ENABLE_EMBEDDED_PDV


#ifdef ENABLE_EXTERNAL
/* encode an external value */
int ASN1BEREncExternal(ASN1encoding_t enc, ASN1uint32_t tag, ASN1external_t *val)
{
    ASN1uint32_t t;
    ASN1uint32_t nLenOff_, nLenOff0;

    if (!val->data_value_descriptor)
        val->o[0] &= ~0x80;

    /* encode tag */
    if (!ASN1BEREncExplicitTag(enc, tag, &nLenOff_))
        return 0;

    /* encode identification */
    switch (val->identification.o) {
    case ASN1external_identification_syntax_o:
        if (!ASN1BEREncObjectIdentifier(enc, 0x6,
            &val->identification.u.syntax))
            return 0;
        break;
    case ASN1external_identification_presentation_context_id_o:
        if (!ASN1BEREncU32(enc, 0x2,
            val->identification.u.presentation_context_id))
            return 0;
        break;
    case ASN1external_identification_context_negotiation_o:
        if (!ASN1BEREncObjectIdentifier(enc, 0x6,
            &val->identification.u.context_negotiation.transfer_syntax))
            return 0;
        if (!ASN1BEREncU32(enc, 0x2,
            val->identification.u.context_negotiation.presentation_context_id))
            return 0;
        break;
    default:
        ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
        return 0;
    }

    /* encode data value descriptor if present */
    if (val->o[0] & 0x80) {
        t = My_lstrlenA(val->data_value_descriptor);
        if (!ASN1BEREncCharString(enc, 0x7, t, val->data_value_descriptor))
            return 0;
    }

    /* encode data value */
    switch (val->data_value.o)
    {
    case ASN1external_data_value_notation_o:
        if (!ASN1BEREncExplicitTag(enc, 0, &nLenOff0))
            return 0;
        if (!ASN1BEREncOpenType(enc, &val->data_value.u.notation))
            return 0;
        if (!ASN1BEREncEndOfContents(enc, nLenOff0))
            return 0;
        break;
    case ASN1external_data_value_encoded_o:
        if (!(val->data_value.u.encoded.length & 7))
        {
            if (!ASN1BEREncExplicitTag(enc, 1, &nLenOff0))
                return 0;
            if (!ASN1BEREncOctetString(enc, 0x4,
                val->data_value.u.encoded.length / 8,
                val->data_value.u.encoded.value))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff0))
                return 0;
        }
        else
        {
            if (!ASN1BEREncExplicitTag(enc, 2, &nLenOff0))
                return 0;
            if (!ASN1BEREncBitString(enc, 0x3,
                val->data_value.u.encoded.length,
                val->data_value.u.encoded.value))
                return 0;
            if (!ASN1BEREncEndOfContents(enc, nLenOff0))
                return 0;
        }
        break;
    default:
        ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
        return 0;
    }

    /* end of external value */
    return ASN1BEREncEndOfContents(enc, nLenOff_);
}
#endif // ENABLE_EXTERNAL

/* encode a generalized time value */
int ASN1BEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1generalizedtime_t *val)
{
    char time[32];
    ASN1generalizedtime2string(time, val);
    return ASN1BEREncCharString(enc, tag, My_lstrlenA(time), time);
}

/* encode a generalized time value (CER) */
int ASN1CEREncGeneralizedTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1generalizedtime_t *val)
{
    char time[32];
    ASN1generalizedtime2string(time, val);
    return ASN1CEREncCharString(enc, tag, My_lstrlenA(time), time);
}

/* encode a signed integer value */
int ASN1BEREncS32(ASN1encoding_t enc, ASN1uint32_t tag, ASN1int32_t val)
{
    if (ASN1BEREncTag(enc, tag))
    {
        if (val >= -0x8000 && val < 0x8000)
        {
            if (val >= -0x80 && val < 0x80)
            {
                if (ASN1BEREncLength(enc, 1))
                {
                    *enc->pos++ = (ASN1octet_t)(val);
                    return 1;
                }
            }
            else
            {
                if (ASN1BEREncLength(enc, 2))
                {
                    *enc->pos++ = (ASN1octet_t)(val >> 8);
                    *enc->pos++ = (ASN1octet_t)(val);
                    return 1;
                }
            }
        }
        else
        {
            if (val >= -0x800000 && val < 0x800000)
            {
                if (ASN1BEREncLength(enc, 3))
                {
                    *enc->pos++ = (ASN1octet_t)(val >> 16);
                    *enc->pos++ = (ASN1octet_t)(val >> 8);
                    *enc->pos++ = (ASN1octet_t)(val);
                    return 1;
                }
            }
            else
            {
                if (ASN1BEREncLength(enc, 4))
                {
                    *enc->pos++ = (ASN1octet_t)(val >> 24);
                    *enc->pos++ = (ASN1octet_t)(val >> 16);
                    *enc->pos++ = (ASN1octet_t)(val >> 8);
                    *enc->pos++ = (ASN1octet_t)(val);
                    return 1;
                }
            }
        }
    }
    return 0;
}

/* encode a intx_t integer value */
int ASN1BEREncSX(ASN1encoding_t enc, ASN1uint32_t tag, ASN1intx_t *val)
{
    ASN1uint32_t cb;
    ASN1octet_t *p;

    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        // strip out leading 0 and ff.
        for (cb = val->length, p = val->value; cb > 1; cb--, p++)
        {
			// break if not 00 nor FF
            if (*p && *p != 0xFF)
            {
                break;
            }
			// break if 00 FF
			if ((! *p) && (*(p+1) & 0x80))
			{
				break;
			}
			// break if FF 7F
			if (*p == 0xFF && (!(*(p+1) & 0x80)))
			{
				break;
			}
        }

        /* encode length */
        if (ASN1BEREncLength(enc, cb))
        {
            /* copy value */
            CopyMemory(enc->pos, p, cb);
            enc->pos += cb;
            return 1;
        }
    }
    return 0;
}

/* encode a multibyte string value */
int ASN1BEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1ztcharstring_t val)
{
    return ASN1BEREncCharString(enc, tag, My_lstrlenA(val), val);
}

int ASN1BEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1charstring_t *val)
{
    return ASN1BEREncCharString(enc, tag, val->length, val->value);
}

/* encode a multibyte string value (CER) */
int ASN1CEREncZeroMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1ztcharstring_t val)
{
    return ASN1CEREncCharString(enc, tag, My_lstrlenA(val), val);
}

int ASN1CEREncMultibyteString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1charstring_t *val)
{
    return ASN1CEREncCharString(enc, tag, val->length, val->value);
}

/* encode a null value */
int ASN1BEREncNull(ASN1encoding_t enc, ASN1uint32_t tag)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode zero length */
        return ASN1BEREncLength(enc, 0);
    }
    return 0;
}

// encode an oid node s to buffer pointed by p
ASN1octet_t *_BEREncOidNode(ASN1octet_t *p, ASN1uint32_t s)
{
    if (s < 0x80)
    {
        *p++ = (ASN1octet_t)(s);
    }
    else
    if (s < 0x4000)
    {
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    else
    if (s < 0x200000)
    {
        *p++ = (ASN1octet_t)((s >> 14) | 0x80);
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    else
    if (s < 0x10000000)
    {
        *p++ = (ASN1octet_t)((s >> 21) | 0x80);
        *p++ = (ASN1octet_t)((s >> 14) | 0x80);
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    else
    {
        *p++ = (ASN1octet_t)((s >> 28) | 0x80);
        *p++ = (ASN1octet_t)((s >> 21) | 0x80);
        *p++ = (ASN1octet_t)((s >> 14) | 0x80);
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    return p;
}

/* encode an object identifier value */
int ASN1BEREncObjectIdentifier(ASN1encoding_t enc, ASN1uint32_t tag, ASN1objectidentifier_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        ASN1objectidentifier_t obj = *val;
        ASN1uint32_t i, s, l, *v;
        ASN1octet_t *data, *p;

        l = GetObjectIdentifierCount(obj);
        if (l)
        {
            /* convert object identifier to octets */
            p = data = (ASN1octet_t *)MemAlloc(l * 5, _ModName(enc)); /* max. 5 octets/subelement */
            if (p)
            {
                int rc;
                for (i = 0; i < l; i++)
                {
                    s = obj->value;
                    obj = obj->next;
                    if (!i && l > 1)
                    {
                        s = s * 40 + obj->value;
                        obj = obj->next;
                        i++;
                    }
                    p = _BEREncOidNode(p, s);
                } // for

                /* encode length */
                rc = ASN1BEREncLength(enc, (ASN1uint32_t) (p - data));
                if (rc)
                {
                    /* copy value */
                    CopyMemory(enc->pos, data, p - data);
                    enc->pos += p - data;
                }
                MemFree(data);
                return rc;
            }
            ASN1EncSetError(enc, ASN1_ERR_MEMORY);
            return 0;
        } // if (l)
        /* encode zero length */
        return ASN1BEREncLength(enc, 0);
    }
    return 0;
}

/* encode an object identifier value */
int ASN1BEREncObjectIdentifier2(ASN1encoding_t enc, ASN1uint32_t tag, ASN1objectidentifier2_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        ASN1uint32_t i, s;
        ASN1octet_t *data, *p;

        if (val->count)
        {
            /* convert object identifier to octets */
            p = data = (ASN1octet_t *)MemAlloc(val->count * 5, _ModName(enc)); /* max. 5 octets/subelement */
            if (p)
            {
                int rc;
                for (i = 0; i < val->count; i++)
                {
                    s = val->value[i];
                    if (!i && val->count > 1)
                    {
                        i++;
                        s = s * 40 + val->value[i];
                    }
                    p = _BEREncOidNode(p, s);
                } // for

                /* encode length */
                rc = ASN1BEREncLength(enc, (ASN1uint32_t) (p - data));
                if (rc)
                {
                    /* copy value */
                    CopyMemory(enc->pos, data, p - data);
                    enc->pos += p - data;
                }
                MemFree(data);
                return rc;
            }
            ASN1EncSetError(enc, ASN1_ERR_MEMORY);
            return 0;
        } // if (l)
        /* encode zero length */
        return ASN1BEREncLength(enc, 0);
    }
    return 0;
}

/* encode an octet string value (CER) */
int ASN1CEREncOctetString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    ASN1uint32_t n;

    if (len <= 1000)
    {
        /* encode tag */
        if (ASN1BEREncTag(enc, tag))
        {
            /* encode length */
            if (ASN1BEREncLength(enc, len))
            {
                /* copy value */
                CopyMemory(enc->pos, val, len);
                enc->pos += len;
                return 1;
            }
        }
    }
    else
    {
        ASN1uint32_t nLenOff;
        /* encode value as constructed, using segments of 1000 octets */
        if (ASN1BEREncExplicitTag(enc, tag, &nLenOff))
        {
            while (len)
            {
                n = len > 1000 ? 1000 : len;
                if (ASN1BEREncTag(enc, 0x4))
                {
                    if (ASN1BEREncLength(enc, n))
                    {
                        CopyMemory(enc->pos, val, n);
                        enc->pos += n;
                        val += n;
                        len -= n;
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            }
            return ASN1BEREncEndOfContents(enc, nLenOff);
        }
    }
    return 0;
}

/* encode an open type value */
int ASN1BEREncOpenType(ASN1encoding_t enc, ASN1open_t *val)
{
    if (ASN1BEREncCheck(enc, val->length))
    {
        /* copy value */
        CopyMemory(enc->pos, val->encoded, val->length);
        enc->pos += val->length;
        return 1;
    }
    return 0;
}

/* remove trailing zero bits from bit string */
int ASN1BEREncRemoveZeroBits(ASN1uint32_t *nbits, ASN1octet_t *val)
{
    ASN1uint32_t n;
    int i;

    /* get value */
    n = *nbits;

    /* let val point to last ASN1octet used */
    val += (n - 1) / 8;

    /* check if broken ASN1octet consist out of zero bits */
    if ((n & 7) && !(*val & bitmsk2[n & 7]))
    {
        n &= ~7;
        val--;
    }

    /* scan complete ASN1octets (memcchr missing ...) */
    if (!(n & 7))
    {
        while (n && !*val)
        {
            n -= 8;
            val--;
        }
    }

    /* scan current ASN1octet bit after bit */
    if (n)
    {
        for (i = (n - 1) & 7; i >= 0; i--)
        {
            if (*val & (0x80 >> i))
                break;
            n--;
        }
    }

    /* return real bitstring len */
    *nbits = n;
    return 1;
}

/* encode an utc time value */
int ASN1BEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1utctime_t *val)
{
    char time[32];
    ASN1utctime2string(time, val);
    return ASN1BEREncCharString(enc, tag, My_lstrlenA(time), time);
}

/* encode an utc time value (CER) */
int ASN1CEREncUTCTime(ASN1encoding_t enc, ASN1uint32_t tag, ASN1utctime_t *val)
{
    char time[32];
    ASN1utctime2string(time, val);
    return ASN1CEREncCharString(enc, tag, My_lstrlenA(time), time);
}

/* end of encoding */
int ASN1BEREncFlush(ASN1encoding_t enc)
{
    /* allocate at least one octet */
    if (enc->buf)
    {
        /* fill in zero-octet if encoding is empty bitstring */
        if (enc->buf == enc->pos)
            *enc->pos++ = 0;

        /* calculate length */
        enc->len = (ASN1uint32_t) (enc->pos - enc->buf);
        return 1;
    }
    return ASN1BEREncCheck(enc, 1);
}

#endif // ENABLE_BER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\msasn1\cintern.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifndef _ASN1_CINTERN_H_
#define _ASN1_CINTERN_H_


typedef struct ASN1INTERNencoding_s *ASN1INTERNencoding_t;
typedef struct ASN1INTERNdecoding_s *ASN1INTERNdecoding_t;

// lonchanc: this is really bad to duplicate the definitions of ASN1encoding_s
// and ASN1decoding_s here. We sould simply use them as components in
// the following ASN1INTERNencoding_s and ASN1INTERNdecoding_s.

struct ASN1INTERNencoding_s {

    // public view of encoding structure
    struct ASN1encoding_s       info;

    // private portion of encoding structure
    ASN1INTERNencoding_t        parent;
    ASN1INTERNencoding_t        child;

#ifdef ENABLE_EXTRA_INFO
    ASN1uint32_t				memlength;
    ASN1uint32_t				memsize;
    void**					    mem;
    ASN1uint32_t				epilength;
    ASN1uint32_t				episize;
    ASN1embeddedpdv_identification_t**		epi;
    ASN1uint32_t				csilength;
    ASN1uint32_t				csisize;
    ASN1characterstring_identification_t**	csi;
#endif // ENABLE_EXTRA_INFO
};

struct ASN1INTERNdecoding_s {

    // public view of decoding structure
    struct ASN1decoding_s       info;

    // private portion of decoding structure
    ASN1INTERNdecoding_t        parent;
    ASN1INTERNdecoding_t        child;

#ifdef ENABLE_EXTRA_INFO
    ASN1uint32_t				memlength;
    ASN1uint32_t				memsize;
    void**					    mem;
    ASN1uint32_t				epilength;
    ASN1uint32_t				episize;
    ASN1embeddedpdv_identification_t**		epi;
    ASN1uint32_t				csilength;
    ASN1uint32_t				csisize;
    ASN1characterstring_identification_t**	csi;
#endif // ENABLE_EXTRA_INFO

    // decoded into an external buffer
    ASN1uint32_t                fExtBuf;
    void*                       lpOrigExtBuf;    // original buffer pointer
    ASN1uint32_t                cbOrigExtBufSize;// original buffer size
    ASN1uint8_t*                lpRemExtBuf;     // remaining buffer pointer
    ASN1uint32_t                cbRemExtBufSize; // remaining buffer size
    ASN1uint32_t                cbLinearBufSize; // linear buffer size to hold the data
};

extern ASN1_PUBLIC void ASN1API ASN1DecAbort(ASN1decoding_t dec);
extern ASN1_PUBLIC void ASN1API ASN1DecDone(ASN1decoding_t dec);
extern ASN1_PUBLIC void ASN1API ASN1EncAbort(ASN1encoding_t enc);
extern ASN1_PUBLIC void ASN1API ASN1EncDone(ASN1encoding_t enc);

#ifdef ENABLE_GENERALIZED_CHAR_STR
int ASN1EncSearchCharacterStringIdentification(ASN1INTERNencoding_t e, ASN1characterstring_identification_t *identification, ASN1uint32_t *index, ASN1uint32_t *flag);
int ASN1DecAddCharacterStringIdentification(ASN1INTERNdecoding_t d, ASN1characterstring_identification_t *identification);
ASN1characterstring_identification_t *ASN1DecGetCharacterStringIdentification(ASN1INTERNdecoding_t d, ASN1uint32_t index);
#endif // ENABLE_GENERALIZED_CHAR_STR

#ifdef ENABLE_EMBEDDED_PDV
int ASN1EncSearchEmbeddedPdvIdentification(ASN1INTERNencoding_t e, ASN1embeddedpdv_identification_t *identification, ASN1uint32_t *index, ASN1uint32_t *flag);
int ASN1DecAddEmbeddedPdvIdentification(ASN1INTERNdecoding_t d, ASN1embeddedpdv_identification_t *identification);
ASN1embeddedpdv_identification_t *ASN1DecGetEmbeddedPdvIdentification(ASN1INTERNdecoding_t d, ASN1uint32_t index);
#endif // ENABLE_EMBEDDED_PDV

int ASN1DecDupObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t *dst, ASN1objectidentifier_t *src);

ASN1uint32_t GetObjectIdentifierCount(ASN1objectidentifier_t val);
ASN1uint32_t CopyObjectIdentifier(ASN1objectidentifier_t dst, ASN1objectidentifier_t src);
ASN1objectidentifier_t DecAllocObjectIdentifier(ASN1decoding_t dec, ASN1uint32_t cObjIds);
void DecFreeObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t p);


/* ------ perencod.c ------ */

int ASN1EncCheck(ASN1encoding_t enc, ASN1uint32_t noctets);
__inline int ASN1PEREncCheck(ASN1encoding_t enc, ASN1uint32_t noctets)
{
    return ASN1EncCheck(enc, noctets);
}
__inline int ASN1BEREncCheck(ASN1encoding_t enc, ASN1uint32_t noctets)
{
    return ASN1EncCheck(enc, noctets);
}

/* ------ bit.c ------ */

int ASN1is32space(ASN1char32_t);
int ASN1str32len(ASN1char32_t *);
int ASN1is16space(ASN1char16_t);
int ASN1str16len(ASN1char16_t *);
int My_lstrlenA(char *p);
int My_lstrlenW(WCHAR *p);
void ASN1bitcpy(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits);
void ASN1bitclr(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t nbits);
void ASN1bitset(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t nbits);
void ASN1bitput(ASN1octet_t *dst, ASN1uint32_t dstbit, ASN1uint32_t val, ASN1uint32_t nbits);
ASN1uint32_t ASN1bitgetu(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits);
ASN1int32_t ASN1bitget(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits);
ASN1uint32_t ASN1bitcount(ASN1octet_t *src, ASN1uint32_t srcbit, ASN1uint32_t nbits);
void ASN1octetput(ASN1octet_t *dst, ASN1uint32_t val, ASN1uint32_t noctets);
ASN1uint32_t ASN1octetget(ASN1octet_t *src, ASN1uint32_t noctets);


#endif /* _ASN1_CINTERN_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\msasn1\ident.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

/* copyright identifier */
const char ident1[] = "$Copyright: ASN.1 Compiler V0.9 $";
const char ident2[] = "$Copyright: Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. $";
const char ident3[] = "$Copyright: Copyright (C) Microsoft Corporation, 1997. All rights reserved. $";
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\msasn1\compare.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

#if defined(ENABLE_COMPARE) || defined(ENABLE_BER)

/* compare two object identifiers; return 0 iff equal */
int ASN1objectidentifier_cmp(ASN1objectidentifier_t *v1, ASN1objectidentifier_t *v2)
{
    ASN1uint32_t l, l1, l2, i;
    ASN1objectidentifier_t p1 = *v1;
    ASN1objectidentifier_t p2 = *v2;

    l1 = GetObjectIdentifierCount(p1);
    l2 = GetObjectIdentifierCount(p2);
    l = (l1 > l2) ? l2 : l1; // min(l1,l2)
    for (i = 0; i < l; i++) {
        if (p1->value != p2->value)
            return p1->value - p2->value;
        p1 = p1->next;
        p2 = p2->next;
    }
    return l1 - l2;
}

int ASN1objectidentifier2_cmp(ASN1objectidentifier2_t *v1, ASN1objectidentifier2_t *v2)
{
    ASN1uint16_t len, i;

    len = (v1->count > v2->count) ? v2->count : v1->count; // min(l1,l2)
    for (i = 0; i < len; i++)
    {
        if (v1->value[i] != v2->value[i])
        {
            return ((int) v1->value[i] - (int) v2->value[i]);
        }
    }
    return ((int) v1->count - (int) v2->count);
}

static const ASN1uint8_t c_aBitMask2[] = {
    0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe
};

/* compare two bit strings; return 0 iff equal */
int ASN1bitstring_cmp(ASN1bitstring_t *v1, ASN1bitstring_t *v2, int ignorezero)
{
    ASN1uint32_t l, l1, l2;
    ASN1octet_t o1, o2;
    int ret;

    l1 = v1->length;
    l2 = v2->length;
    l = l1;
    if (l > l2)
        l = l2;

    if (ignorezero) {
        if (l1 > l)
            ASN1PEREncRemoveZeroBits(&l1, v1->value, l);
        if (l2 > l)
            ASN1PEREncRemoveZeroBits(&l2, v2->value, l);
    }
    
    if (l > 7) {
        ret = memcmp(v1->value, v2->value, l / 8);
        if (ret)
            return ret;
    }

    if (l & 7) {
        o1 = v1->value[l / 8] & c_aBitMask2[l & 7];
        o2 = v2->value[l / 8] & c_aBitMask2[l & 7];
        ret = o1 - o2;
        if (ret)
            return ret;
    }

    return l1 - l2;
}

/* compare two octet strings; return 0 iff equal */
int ASN1octetstring_cmp(ASN1octetstring_t *v1, ASN1octetstring_t *v2)
{
    ASN1uint32_t l, l1, l2;
    int ret;

    l1 = v1->length;
    l2 = v2->length;
    l = l1;
    if (l > l2)
        l = l2;

    if (l) {
        ret = memcmp(v1->value, v2->value, l);
        if (ret)
            return ret;
    }

    return l1 - l2;
}


#ifdef ENABLE_EXTERNAL

/* compare two external; return 0 iff equal */
int ASN1external_cmp(ASN1external_t *v1, ASN1external_t *v2)
{
    int ret;

    if ((ret = (v1->identification.o - v2->identification.o)))
        return ret;
    switch (v1->identification.o) {
    case ASN1external_identification_syntax_o:
        if ((ret = ASN1objectidentifier_cmp(&v1->identification.u.syntax,
            &v2->identification.u.syntax)))
            return ret;
        break;
    case ASN1external_identification_presentation_context_id_o:
        if ((ret = (v1->identification.u.presentation_context_id -
            v2->identification.u.presentation_context_id)))
            return ret;
        break;
    case ASN1external_identification_context_negotiation_o:
        if ((ret = (
            v1->identification.u.context_negotiation.presentation_context_id -
            v2->identification.u.context_negotiation.presentation_context_id)))
            return ret;
        if ((ret = ASN1objectidentifier_cmp(
            &v1->identification.u.context_negotiation.transfer_syntax,
            &v2->identification.u.context_negotiation.transfer_syntax)))
            return ret;
        break;
    }
    if (ASN1BITTEST(v1->o, ASN1external_data_value_descriptor_o)) {
        if (ASN1BITTEST(v2->o, ASN1external_data_value_descriptor_o)) {
            if ((ret = ASN1ztcharstring_cmp(
                v1->data_value_descriptor, v2->data_value_descriptor)))
                return ret;
        } else {
            return 1;
        }
    } else {
        return 1;
    }
    if ((ret = (v1->data_value.o - v2->data_value.o)))
        return ret;
    switch (v1->data_value.o) {
    case ASN1external_data_value_notation_o:
        if ((ret = ASN1open_cmp(&v1->data_value.u.notation,
            &v2->data_value.u.notation)))
            return ret;
        break;
    case ASN1external_data_value_encoded_o:
        if ((ret = ASN1bitstring_cmp(&v1->data_value.u.encoded,
            &v2->data_value.u.encoded, 0)))
            return ret;
        break;
    }
    return 0;
}

#endif // ENABLE_EXTERNAL

#ifdef ENABLE_REAL

/* compare two reals; return 0 iff equal */
int ASN1real_cmp(ASN1real_t *v1, ASN1real_t *v2)
{
    ASN1intx_t e, e1, e2, m1, m2, h;
    int ret = 0;

    ZeroMemory(&e1, sizeof(e1));
    ZeroMemory(&e2, sizeof(e2));
    ZeroMemory(&m1, sizeof(m1));
    ZeroMemory(&m2, sizeof(m2));

    if (v1->type == eReal_PlusInfinity || v2->type == eReal_MinusInfinity)
        return 1;
    if (v2->type == eReal_PlusInfinity || v1->type == eReal_MinusInfinity)
        return -1;
    if (v1->type != eReal_Normal || v2->type != eReal_Normal)
        return 0;

    switch (v1->base) {
    case 2:
        if (! ASN1intx_dup(&e1, &v1->exponent))
        {
            ret = -1;
            goto MyExit;
        }
        break;
    case 8:
        ASN1intx_muloctet(&e1, &v1->exponent, 3);
        break;
    case 16:
        ASN1intx_muloctet(&e1, &v1->exponent, 4);
        break;
    }
    switch (v2->base) {
    case 2:
        if (! ASN1intx_dup(&e2, &v2->exponent))
        {
            ret = 1;
            goto MyExit;
        }
        break;
    case 8:
        ASN1intx_muloctet(&e2, &v2->exponent, 3);
        break;
    case 16:
        ASN1intx_muloctet(&e2, &v2->exponent, 4);
        break;
    }
    if (! ASN1intx_dup(&m1, &v1->mantissa))
    {
        ret = -1;
        goto MyExit;
    }
    if (! ASN1intx_dup(&m2, &v2->mantissa))
    {
        ret = 1;
        goto MyExit;
    }
    ASN1intx_sub(&e, &e1, &e2);
    for (;;) {
        ret = ASN1intx_cmp(&e, &ASN1intx_0);
        if (!ret)
            break;
        if (ret > 0) {
            ASN1intx_muloctet(&h, &m1, 2);
            ASN1intx_free(&m1);
            m1 = h;
            ASN1intx_dec(&e);
        } else {
            ASN1intx_muloctet(&h, &m2, 2);
            ASN1intx_free(&m2);
            m2 = h;
            ASN1intx_inc(&e);
        }
    }
// lonchanc: what happened to the memory allocated for e,
// should we call ASN1intx_free(&e)?
    ret = ASN1intx_cmp(&m1, &m2);

MyExit:

    ASN1intx_free(&m1);
    ASN1intx_free(&m2);
    ASN1intx_free(&e1);
    ASN1intx_free(&e2);
    return ret;
}

#endif // ENABLE_REAL

/* compare two doubles; return 0 iff equal */
int ASN1double_cmp(double d1, double d2)
{
    return d1 < d2 ? -1 : d1 > d2 ? 1 : 0;
}

#ifdef ENABLE_EMBEDDED_PDV

/* compare two embedded pdvs; return 0 iff equal */
int ASN1embeddedpdv_cmp(ASN1embeddedpdv_t *v1, ASN1embeddedpdv_t *v2)
{
    int ret;

    if ((ret = (v1->identification.o - v2->identification.o)))
        return ret;
    switch (v1->identification.o) {
    case ASN1embeddedpdv_identification_syntaxes_o:
        if ((ret = ASN1objectidentifier_cmp(
            &v1->identification.u.syntaxes.abstract,
            &v2->identification.u.syntaxes.abstract)))
            return ret;
        if ((ret = ASN1objectidentifier_cmp(
            &v1->identification.u.syntaxes.transfer,
            &v2->identification.u.syntaxes.transfer)))
            return ret;
        break;
    case ASN1embeddedpdv_identification_syntax_o:
        if ((ret = ASN1objectidentifier_cmp(&v1->identification.u.syntax,
            &v2->identification.u.syntax)))
            return ret;
        break;
    case ASN1embeddedpdv_identification_presentation_context_id_o:
        if ((ret = (v1->identification.u.presentation_context_id -
            v2->identification.u.presentation_context_id)))
            return ret;
        break;
    case ASN1embeddedpdv_identification_context_negotiation_o:
        if ((ret = (
            v1->identification.u.context_negotiation.presentation_context_id -
            v2->identification.u.context_negotiation.presentation_context_id)))
            return ret;
        if ((ret = ASN1objectidentifier_cmp(
            &v1->identification.u.context_negotiation.transfer_syntax,
            &v2->identification.u.context_negotiation.transfer_syntax)))
            return ret;
        break;
    case ASN1embeddedpdv_identification_transfer_syntax_o:
        if ((ret = ASN1objectidentifier_cmp(
            &v1->identification.u.transfer_syntax,
            &v2->identification.u.transfer_syntax)))
            return ret;
        break;
    case ASN1embeddedpdv_identification_fixed_o:
        break;
    }
    if ((ret = (v1->data_value.o - v2->data_value.o)))
        return ret;
    switch (v1->data_value.o) {
    case ASN1embeddedpdv_data_value_notation_o:
        if ((ret = ASN1open_cmp(&v1->data_value.u.notation,
            &v2->data_value.u.notation)))
            return ret;
        break;
    case ASN1embeddedpdv_data_value_encoded_o:
        if ((ret = ASN1bitstring_cmp(&v1->data_value.u.encoded,
            &v2->data_value.u.encoded, 0)))
            return ret;
        break;
    }
    return 0;
}

#endif // ENABLE_EMBEDDED_PDV


/* compare two zero-terminated strings; return 0 iff equal */
int ASN1ztcharstring_cmp(ASN1ztcharstring_t v1, ASN1ztcharstring_t v2)
{
    if (v1 && v2)
    {
        return lstrcmpA(v1, v2);
    }
    return v1 ? 1 : -1;
}

/* compare two zero-terminated 16 bit strings; return 0 iff equal */
int ASN1ztchar16string_cmp(ASN1ztchar16string_t v1, ASN1ztchar16string_t v2)
{
    for (;;) {
        if (!*v1 || !*v2 || *v1 != *v2)
            return *v1 - *v2;
        v1++;
        v2++;
    }
}

/* compare two zero-terminated 32 bit strings; return 0 iff equal */
int ASN1ztchar32string_cmp(ASN1ztchar32string_t v1, ASN1ztchar32string_t v2)
{
    for (;;) {
        if (!*v1 || !*v2 || *v1 != *v2)
            return *v1 - *v2;
        v1++;
        v2++;
    }
}

/* compare two strings; return 0 iff equal */
int ASN1charstring_cmp(ASN1charstring_t *v1, ASN1charstring_t *v2)
{
    ASN1uint32_t i, l;

    l = v1->length;
    if (v2->length > l)
        l = v2->length;
    for (i = 0; i < l; i++) {
        if (v1->value[i] != v2->value[i])
            return v1->value[i] - v2->value[i];
    }
    return v1->length - v2->length;
}

/* compare two 16 bit strings; return 0 iff equal */
int ASN1char16string_cmp(ASN1char16string_t *v1, ASN1char16string_t *v2)
{
    ASN1uint32_t i, l;

    l = v1->length;
    if (v2->length > l)
        l = v2->length;
    for (i = 0; i < l; i++) {
        if (v1->value[i] != v2->value[i])
            return v1->value[i] - v2->value[i];
    }
    return v1->length - v2->length;
}

/* compare two 32 bit strings; return 0 iff equal */
int ASN1char32string_cmp(ASN1char32string_t *v1, ASN1char32string_t *v2)
{
    ASN1uint32_t i, l;

    l = v1->length;
    if (v2->length > l)
        l = v2->length;
    for (i = 0; i < l; i++) {
        if (v1->value[i] != v2->value[i])
            return v1->value[i] - v2->value[i];
    }
    return v1->length - v2->length;
}

#ifdef ENABLE_GENERALIZED_CHAR_STR

/* compare two character strings; return 0 iff equal */
int ASN1characterstring_cmp(ASN1characterstring_t *v1, ASN1characterstring_t *v2)
{
    int ret;

    if ((ret = (v1->identification.o - v2->identification.o)))
        return ret;
    switch (v1->identification.o) {
    case ASN1characterstring_identification_syntaxes_o:
        if ((ret = ASN1objectidentifier_cmp(
            &v1->identification.u.syntaxes.abstract,
            &v2->identification.u.syntaxes.abstract)))
            return ret;
        if ((ret = ASN1objectidentifier_cmp(
            &v1->identification.u.syntaxes.transfer,
            &v2->identification.u.syntaxes.transfer)))
            return ret;
        break;
    case ASN1characterstring_identification_syntax_o:
        if ((ret = ASN1objectidentifier_cmp(&v1->identification.u.syntax,
            &v2->identification.u.syntax)))
            return ret;
        break;
    case ASN1characterstring_identification_presentation_context_id_o:
        if ((ret = (v1->identification.u.presentation_context_id -
            v2->identification.u.presentation_context_id)))
            return ret;
        break;
    case ASN1characterstring_identification_context_negotiation_o:
        if ((ret = (
            v1->identification.u.context_negotiation.presentation_context_id -
            v2->identification.u.context_negotiation.presentation_context_id)))
            return ret;
        if ((ret = ASN1objectidentifier_cmp(
            &v1->identification.u.context_negotiation.transfer_syntax,
            &v2->identification.u.context_negotiation.transfer_syntax)))
            return ret;
        break;
    case ASN1characterstring_identification_transfer_syntax_o:
        if ((ret = ASN1objectidentifier_cmp(
            &v1->identification.u.transfer_syntax,
            &v2->identification.u.transfer_syntax)))
            return ret;
        break;
    case ASN1characterstring_identification_fixed_o:
        break;
    }
    if ((ret = (v1->data_value.o - v2->data_value.o)))
        return ret;
    switch (v1->data_value.o) {
    case ASN1characterstring_data_value_notation_o:
        if ((ret = ASN1open_cmp(&v1->data_value.u.notation,
            &v2->data_value.u.notation)))
            return ret;
        break;
    case ASN1characterstring_data_value_encoded_o:
        if ((ret = ASN1octetstring_cmp(&v1->data_value.u.encoded,
            &v2->data_value.u.encoded)))
            return ret;
        break;
    }
    return 0;
}

#endif // ENABLE_GENERALIZED_CHAR_STR

/* compare two utc times; return 0 iff equal */
int ASN1utctime_cmp(ASN1utctime_t *v1, ASN1utctime_t *v2)
{
    if (v1->universal != v2->universal || v1->diff != v2->diff)
        return 1;
    if (v1->year != v2->year)
        return v1->year - v2->year;
    if (v1->month != v2->month)
        return v1->month - v2->month;
    if (v1->day != v2->day)
        return v1->day - v2->day;
    if (v1->hour != v2->hour)
        return v1->hour - v2->hour;
    if (v1->minute != v2->minute)
        return v1->minute - v2->minute;
    return v1->second - v2->second;
}

/* compare two generalized times; return 0 iff equal */
int ASN1generalizedtime_cmp(ASN1generalizedtime_t *v1, ASN1generalizedtime_t *v2)
{
    if (v1->universal != v2->universal || v1->diff != v2->diff)
        return 1;
    if (v1->year != v2->year)
        return v1->year - v2->year;
    if (v1->month != v2->month)
        return v1->month - v2->month;
    if (v1->day != v2->day)
        return v1->day - v2->day;
    if (v1->hour != v2->hour)
        return v1->hour - v2->hour;
    if (v1->minute != v2->minute)
        return v1->minute - v2->minute;
    if (v1->second != v2->second)
        return v1->second - v2->second;
    return v1->millisecond - v2->millisecond;
}

/* compare two open type values; return 0 iff equal */
int ASN1open_cmp(ASN1open_t *v1, ASN1open_t *v2)
{
    ASN1octetstring_t ostr1, ostr2;
    ostr1.length = v1->length;
    ostr1.value = v1->encoded;
    ostr2.length = v2->length;
    ostr2.value = v2->encoded;
    return ASN1octetstring_cmp(&ostr1, &ostr2);
}

/* compare two sequence of values with length-pointer representation */
/* return 0 iff equal */
int ASN1sequenceoflengthpointer_cmp(ASN1uint32_t l1, void *v1, ASN1uint32_t l2, void *v2, ASN1uint32_t size, int (*cmpfn)(void *v1, void *v2))
{
    int ret;
    ASN1octet_t *p1, *p2;

    if ((ret = (l1 - l2)))
        return ret;
    for (p1 = (ASN1octet_t *)v1, p2 = (ASN1octet_t *)v2; l1--;
        p1 += size, p2 += size) {
        if ((ret = cmpfn(p1, p2)))
            return ret;
    }
    return 0;
}

/* compare two sequence of values with singly-linked-list representation */
/* return 0 iff equal */
int ASN1sequenceofsinglylinkedlist_cmp(void *v1, void *v2, ASN1uint32_t off, int (*cmpfn)(void *, void *))
{
    int ret;
    ASN1octet_t *p1, *p2;

    for (p1 = (ASN1octet_t *)v1, p2 = (ASN1octet_t *)v2; p1 && p2;
        p1 = *(ASN1octet_t **)p1, p2 = *(ASN1octet_t **)p2) {
        if ((ret = cmpfn(p1 + off, p2 + off)))
            return ret;
    }
    return 0;
}

/* compare two sequence of values with doubly-linked-list representation */
/* return 0 iff equal */
int ASN1sequenceofdoublylinkedlist_cmp(void *v1, void *v2, ASN1uint32_t off, int (*cmpfn)(void *, void *))
{
    int ret;
    ASN1octet_t *p1, *p2;

    for (p1 = (ASN1octet_t *)v1, p2 = (ASN1octet_t *)v2; p1 && p2;
        p1 = *(ASN1octet_t **)p1, p2 = *(ASN1octet_t **)p2) {
        if ((ret = cmpfn(p1 + off, p2 + off)))
            return ret;
    }
    return 0;
}

/* compare two set of values with length-pointer representation */
/* return 0 iff equal */
int ASN1setoflengthpointer_cmp(ASN1uint32_t l1, void *v1, ASN1uint32_t l2, void *v2, ASN1uint32_t size, int (*cmpfn)(void *v1, void *v2))
{
    int ret;
    ASN1octet_t *p1, *p2, *found, *f;
    ASN1uint32_t l;

    if ((ret = (l1 - l2)))
        return ret;
    if (!l1)
        return 0;
    found = (ASN1octet_t *)MemAlloc(l1, UNKNOWN_MODULE);
    if (found)
    {
        memset(found, 0, l1);
        for (p1 = (ASN1octet_t *)v1; l1--; p1 += size) {
            for (p2 = (ASN1octet_t *)v2, l = l2, f = found; l; p2 += size, f++, l--) {
                if (!*f && !cmpfn(p1, p2)) {
                    *f = 1;
                    break;
                }
            }
            if (!l) {
                MemFree(found);
                return 1;
            }
        }
        MemFree(found);
    }
    return 0;
}

/* compare two set of values with singly-linked-list representation */
/* return 0 iff equal */
int ASN1setofsinglylinkedlist_cmp(void *v1, void *v2, ASN1uint32_t off, int (*cmpfn)(void *, void *))
{
    int ret;
    ASN1octet_t *p1, *p2, *found, *f;
    ASN1uint32_t l1, l2;

    for (p1 = (ASN1octet_t *)v1, l1 = 0; p1; p1 = *(ASN1octet_t **)p1)
        l1++;
    for (p2 = (ASN1octet_t *)v2, l2 = 0; p2; p2 = *(ASN1octet_t **)p2)
        l2++;
    if ((ret = (l1 - l2)))
        return ret;
    if (!l1)
        return 0;
    found = (ASN1octet_t *)MemAlloc(l1, UNKNOWN_MODULE);
    if (found)
    {
        memset(found, 0, l1);
        for (p1 = (ASN1octet_t *)v1; p1; p1 = *(ASN1octet_t **)p1) {
            for (p2 = (ASN1octet_t *)v2, f = found; p2; p2 = *(ASN1octet_t **)p2, f++) {
                if (!*f && !cmpfn(p1 + off, p2 + off)) {
                    *f = 1;
                    break;
                }
            }
            if (!p2) {
                MemFree(found);
                return 1;
            }
        }
        MemFree(found);
    }
    return 0;
}

/* compare two set of values with doubly-linked-list representation */
/* return 0 iff equal */
int ASN1setofdoublylinkedlist_cmp(void *v1, void *v2, ASN1uint32_t off, int (*cmpfn)(void *, void *))
{
    int ret;
    ASN1octet_t *p1, *p2, *found, *f;
    ASN1uint32_t l1, l2;

    for (p1 = (ASN1octet_t *)v1, l1 = 0; p1; p1 = *(ASN1octet_t **)p1)
        l1++;
    for (p2 = (ASN1octet_t *)v2, l2 = 0; p2; p2 = *(ASN1octet_t **)p2)
        l2++;
    if ((ret = (l1 - l2)))
        return ret;
    if (!l1)
        return 0;
    found = (ASN1octet_t *)MemAlloc(l1, UNKNOWN_MODULE);
    if (found)
    {
        memset(found, 0, l1);
        for (p1 = (ASN1octet_t *)v1; p1; p1 = *(ASN1octet_t **)p1) {
            for (p2 = (ASN1octet_t *)v2, f = found; p2; p2 = *(ASN1octet_t **)p2, f++) {
                if (!*f && !cmpfn(p1 + off, p2 + off)) {
                    *f = 1;
                    break;
                }
            }
            if (!p2) {
                MemFree(found);
                return 1;
            }
        }
        MemFree(found);
    }
    return 0;
}

#endif // defined(ENABLE_COMPARE) || defined(ENABLE_BER)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\msasn1\intx.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

// lonchanc: we seem to have a significant amount of memory leak
// while dealing with real number and unlimited integers.
// we definitely want to re-visit all the following routines carefully
// in the future.
// moreover, we need to make sure all the memory allocation and free
// are either using encoding and decoding memory manager or kernel one.
// need to make sure we do not mix them together.

#include "precomp.h"


/* builtin intx values */
ASN1octet_t ASN1intx_0_[] = { 0 };
ASN1intx_t ASN1intx_0 = { 1, ASN1intx_0_ };
ASN1octet_t ASN1intx_1_[] = { 1 };
ASN1intx_t ASN1intx_1 = { 1, ASN1intx_1_ };
ASN1octet_t ASN1intx_2_[] = { 2 };
ASN1intx_t ASN1intx_2 = { 1, ASN1intx_2_ };
ASN1octet_t ASN1intx_16_[] = { 16 };
ASN1intx_t ASN1intx_16 = { 1, ASN1intx_16_ };
ASN1octet_t ASN1intx_256_[] = { 1, 0 };
ASN1intx_t ASN1intx_256 = { 2, ASN1intx_256_ };
ASN1octet_t ASN1intx_64K_[] = { 1, 0, 0 };
ASN1intx_t ASN1intx_64K = { 3, ASN1intx_64K_ };
ASN1octet_t ASN1intx_1G_[] = { 64, 0, 0, 0 };
ASN1intx_t ASN1intx_1G = { 4, ASN1intx_1G_ };

/* add two intx values */
void ASN1intx_add(ASN1intx_t *dst, ASN1intx_t *arg1, ASN1intx_t *arg2)
{
    ASN1octet_t *v;
    int l;
    int s1, s2;
    int o1, o2;
    int i;
    int c;
    int w;

    /* get signs */
    s1 = arg1->value[0] > 0x7f ? 0xff : 0x00;
    s2 = arg2->value[0] > 0x7f ? 0xff : 0x00;

    /* result length will be <= l */
    l = arg1->length > arg2->length ? arg1->length + 1 : arg2->length + 1;

    /* offset into values */
    o1 = l - arg1->length;
    o2 = l - arg2->length;

    /* allocate result */
    v = (ASN1octet_t *)MemAlloc(l, UNKNOWN_MODULE);
    if (v)
    {
        /* clear carry bit */
        c = 0;

        /* add octet by octet */
        for (i = l - 1; i >= 0; i--) {
            w = (i >= o1 ? arg1->value[i - o1] : s1) + (i >= o2 ? arg2->value[i - o2] : s2) + c;
            v[i] = (ASN1octet_t)w;
            c = w > 0xff;
        }

        /* octets which may shall dropped */
        w = v[0] > 0x7f ? 0xff : 0x00;

        /* count octets that shall be dropped */
        for (i = 0; i < l - 1; i++) {
            if (v[i] != w)
                break;
        }
        if ((v[i] ^ w) & 0x80)
            i--;

        /* allocate and copy result */
        dst->length = l - i;
        dst->value = (ASN1octet_t *)MemAlloc(l - i, UNKNOWN_MODULE);
        if (dst->value)
        {
            CopyMemory(dst->value, v + i, l - i);
        }
        MemFree(v);
    }
}

/* substract two intx values */
void ASN1intx_sub(ASN1intx_t *dst, ASN1intx_t *arg1, ASN1intx_t *arg2)
{
    ASN1octet_t *v;
    int l;
    int s1, s2;
    int o1, o2;
    int i;
    int c;
    int w;

    /* get signs */
    s1 = arg1->value[0] > 0x7f ? 0xff : 0x00;
    s2 = arg2->value[0] > 0x7f ? 0xff : 0x00;

    /* result length will be <= l */
    l = arg1->length > arg2->length ? arg1->length + 1 : arg2->length + 1;

    /* offset into values */
    o1 = l - arg1->length;
    o2 = l - arg2->length;

    /* allocate result */
    v = (ASN1octet_t *)MemAlloc(l, UNKNOWN_MODULE);
    if (v)
    {
        /* clear borrow bit */
        c = 0;

        /* substract octet by octet */
        for (i = l - 1; i >= 0; i--) {
            w = (i >= o1 ? arg1->value[i - o1] : s1) - (i >= o2 ? arg2->value[i - o2] : s2) - c;
            v[i] = (ASN1octet_t)w;
            c = w < 0;
        }

        /* octets which may shall dropped */
        w = v[0] > 0x7f ? 0xff : 0x00;

        /* count octets that shall be dropped */
        for (i = 0; i < l - 1; i++) {
            if (v[i] != w)
                break;
        }
        if ((v[i] ^ w) & 0x80)
            i--;

    // lonchanc: do we forget to free dst->value???
    // in case that dst and arg1 are identical. for instance, 
    // ASN1BEREncReal() calls ASN1intx_sub(&exponent, &exponent, &help);
        /* allocate and copy result */
        dst->length = l - i;
        dst->value = (ASN1octet_t *)MemAlloc(l - i, UNKNOWN_MODULE);
        if (dst->value)
        {
            CopyMemory(dst->value, v + i, l - i);
        }
        MemFree(v);
    }
}

/* add one octet to an intx */
#ifdef ENABLE_ALL
void ASN1intx_addoctet(ASN1intx_t *dst, ASN1intx_t *arg1, ASN1octet_t arg2)
{
    ASN1octet_t *v;
    int l;
    int i;
    int c;
    int w;

    /* result length will be <= l */
    l = arg1->length + 1;

    /* allocate result */
    v = (ASN1octet_t *)MemAlloc(l, UNKNOWN_MODULE);
    if (v)
    {
        /* add octet by octet */
        c = arg2;
        for (i = l - 2; i >= 0; i--) {
            w = arg1->value[i] + c;
            v[i + 1] = (ASN1octet_t)w;
            c = (w > 0xff);
        }
        v[0] = arg1->value[0] > 0x7f ? (ASN1octet_t)(0xff + c) : (ASN1octet_t)c;

        /* octets which may shall dropped */
        w = v[0] > 0x7f ? 0xff : 0x00;

        /* count octets that shall be dropped */
        for (i = 0; i < l - 1; i++) {
            if (v[i] != w)
                break;
        }
        if ((v[i] ^ w) & 0x80)
            i--;

        /* allocate and copy result */
        dst->length = l - i;
        dst->value = (ASN1octet_t *)MemAlloc(l - i, UNKNOWN_MODULE);
        if (dst->value)
        {
            CopyMemory(dst->value, v + i, l - i);
        }
        MemFree(v);
    }
}
#endif // ENABLE_ALL

/* substract one octet to an intx */
#ifdef ENABLE_ALL
void ASN1intx_suboctet(ASN1intx_t *dst, ASN1intx_t *arg1, ASN1octet_t arg2)
{
    ASN1octet_t *v;
    int l;
    int i;
    int c;
    int w;

    /* result length will be <= l */
    l = arg1->length + 1;

    /* allocate result */
    v = (ASN1octet_t *)MemAlloc(l, UNKNOWN_MODULE);
    if (v)
    {
        /* substract octet by octet */
        c = arg2;
        for (i = l - 2; i >= 0; i--) {
            w = arg1->value[i] - c;
            v[i + 1] = (ASN1octet_t)w;
            c = (w < 0);
        }
        v[0] = arg1->value[0] > 0x7f ? (ASN1octet_t)(0xff - c) : (ASN1octet_t)c;

        /* octets which may shall dropped */
        w = v[0] > 0x7f ? 0xff : 0x00;

        /* count octets that shall be dropped */
        for (i = 0; i < l - 1; i++) {
            if (v[i] != w)
                break;
        }
        if ((v[i] ^ w) & 0x80)
            i--;

        /* allocate and copy result */
        dst->length = l - i;
        dst->value = (ASN1octet_t *)MemAlloc(l - i, UNKNOWN_MODULE);
        if (dst->value)
        {
            CopyMemory(dst->value, v + i, l - i);
        }
        MemFree(v);
    }
}
#endif // ENABLE_ALL

/* multiply intx by an octet */
void ASN1intx_muloctet(ASN1intx_t *dst, ASN1intx_t *arg1, ASN1octet_t arg2)
{
    ASN1octet_t *v;
    int l;
    int c;
    int i;
    int w;

    /* result length will be <= l */
    l = arg1->length + 1;

    /* allocate result */
    v = (ASN1octet_t *)MemAlloc(l, UNKNOWN_MODULE);
    if (v)
    {
        /* multiply octet by octet */
        c = 0;
        for (i = l - 2; i >= 0; i--) {
            w = arg1->value[i] * arg2 + c;
            v[i + 1] = (ASN1octet_t)w;
            c = w >> 8;
        }
        v[0] = (ASN1octet_t)(arg1->value[0] > 0x7f ? 0xff * arg2 + c : c);

        /* octets which may shall dropped */
        w = v[0] > 0x7f ? 0xff : 0x00;

        /* count octets that shall be dropped */
        for (i = 0; i < l - 1; i++) {
            if (v[i] != w)
                break;
        }
        if ((v[i] ^ w) & 0x80)
            i--;

        /* allocate and copy result */
        dst->length = l - i;
        dst->value = (ASN1octet_t *)MemAlloc(l - i, UNKNOWN_MODULE);
        if (dst->value)
        {
            CopyMemory(dst->value, v + i, l - i);
        }
        MemFree(v);
    }
}

/* increment an intx */
#ifdef ENABLE_ALL
void ASN1intx_inc(ASN1intx_t *val)
{
    ASN1octet_t *v;
    int l;
    int i;
    int w;

    /* result length will be <= l */
    l = val->length + 1;

    /* allocate result */
    v = (ASN1octet_t *)MemAlloc(l, UNKNOWN_MODULE);
    if (v)
    {
        /* copy value */
        CopyMemory(v + 1, val->value, l - 1);
        MemFree(val->value);
        v[0] = v[1] > 0x7f ? 0xff : 0x00;

        /* increment value */
        for (i = l - 1; i >= 0; i--) {
            if (++v[i])
                break;
        }

        /* octets which may shall dropped */
        w = v[0] > 0x7f ? 0xff : 0x00;

        /* count octets that shall be dropped */
        for (i = 0; i < l - 1; i++) {
            if (v[i] != w)
                break;
        }
        if ((v[i] ^ w) & 0x80)
            i--;

        /* allocate and copy result */
        val->length = l - i;
        val->value = (ASN1octet_t *)MemAlloc(l - i, UNKNOWN_MODULE);
        if (val->value)
        {
            CopyMemory(val->value, v + i, l - i);
        }
        MemFree(v);
    }
}
#endif // ENABLE_ALL

/* decrement an intx */
#ifdef ENABLE_ALL
void ASN1intx_dec(ASN1intx_t *val)
{
    ASN1octet_t *v;
    int l;
    int i;
    int w;

    /* result length will be <= l */
    l = val->length + 1;

    /* allocate result */
    v = (ASN1octet_t *)MemAlloc(l, UNKNOWN_MODULE);
    if (v)
    {
        /* copy value */
        CopyMemory(v + 1, val->value, l - 1);
        MemFree(val->value);
        v[0] = v[1] > 0x7f ? 0xff : 0x00;

        /* decrement value */
        for (i = l - 1; i >= 0; i--) {
            if (v[i]--)
                break;
        }

        /* octets which may shall dropped */
        w = v[0] > 0x7f ? 0xff : 0x00;

        /* count octets that shall be dropped */
        for (i = 0; i < l - 1; i++) {
            if (v[i] != w)
                break;
        }
        if ((v[i] ^ w) & 0x80)
            i--;

        /* allocate and copy result */
        val->length = l - i;
        val->value = (ASN1octet_t *)MemAlloc(l - i, UNKNOWN_MODULE);
        if (val->value)
        {
            CopyMemory(val->value, v + i, l - i);
        }
        MemFree(v);
    }
}
#endif // ENABLE_ALL

/* negate an intx value */
#ifdef ENABLE_ALL
void ASN1intx_neg(ASN1intx_t *dst, ASN1intx_t *arg)
{
    ASN1uint32_t i;

    /* duplicate value */
    if (ASN1intx_dup(dst, arg))
    {
        /* ones complement */
        for (i = 0; i < dst->length; i++)
            dst->value[i] = ~dst->value[i];
        
        /* and increment */
        ASN1intx_inc(dst);
    }
}
#endif // ENABLE_ALL

/* returns floor(log2(arg - 1)) */
#ifdef ENABLE_ALL
ASN1uint32_t ASN1intx_log2(ASN1intx_t *arg)
{
    ASN1uint32_t i;
    ASN1intx_t v;
    ASN1uint32_t n;

    if (ASN1intx_dup(&v, arg))
    {
        ASN1intx_dec(&v);
        if (v.value[0] > 0x7f) {
            ASN1intx_free(&v);
            return 0;
        }
        for (i = 0; i < v.length; i++) {
            if (v.value[i])
                break;
        }
        if (i >= v.length) {
            n = 0;
        } else if (v.value[i] > 0x7f) {
            n = 8 * (v.length - i - 1) + 8;
        } else if (v.value[i] > 0x3f) {
            n = 8 * (v.length - i - 1) + 7;
        } else if (v.value[i] > 0x1f) {
            n = 8 * (v.length - i - 1) + 6;
        } else if (v.value[i] > 0x0f) {
            n = 8 * (v.length - i - 1) + 5;
        } else if (v.value[i] > 0x07) {
            n = 8 * (v.length - i - 1) + 4;
        } else if (v.value[i] > 0x03) {
            n = 8 * (v.length - i - 1) + 3;
        } else if (v.value[i] > 0x01) {
            n = 8 * (v.length - i - 1) + 2;
        } else {
            n = 8 * (v.length - i - 1) + 1;
        }
        ASN1intx_free(&v);
        return n;
    }
    return 0;
}
#endif // ENABLE_ALL

/* returns floor(log2(arg - 1)) */
#ifdef ENABLE_ALL
ASN1uint32_t ASN1uint32_log2(ASN1uint32_t arg)
{
    ASN1uint32_t i;

    arg--;
    for (i = 32; i != 0; i--) {
        if (arg & (1 << (i - 1)))
            break;
    }
    return i;
}
#endif // ENABLE_ALL

/* returns floor(log256(arg - 1)) */
#ifdef ENABLE_ALL
ASN1uint32_t ASN1intx_log256(ASN1intx_t *arg)
{
    ASN1uint32_t i;
    ASN1intx_t v;

    if (ASN1intx_dup(&v, arg))
    {
        ASN1intx_dec(&v);
        if (v.value[0] > 0x7f) {
            ASN1intx_free(&v);
            return 0;
        }
        for (i = 0; i < v.length; i++) {
            if (v.value[i])
                break;
        }
        ASN1intx_free(&v);
        return v.length - i;
    }
    return 0;
}
#endif // ENABLE_ALL

/* returns floor(log256(arg - 1)) */
#ifdef ENABLE_ALL
ASN1uint32_t ASN1uint32_log256(ASN1uint32_t arg)
{
    if (arg > 0x10000) {
        if (arg > 0x1000000)
            return 4;
        return 3;
    }
    if (arg > 0x100)
        return 2;
    if (arg > 1)
        return 1;
    return 0;
}
#endif // ENABLE_ALL

/* compare two intx values; return 0 iff equal */
#ifdef ENABLE_ALL
ASN1int32_t ASN1intx_cmp(ASN1intx_t *arg1, ASN1intx_t *arg2)
{
    int s1, s2;
    int o1, o2;
    int l;
    int i;
    int d;

    s1 = arg1->value[0] > 0x7f ? 0xff : 0x00;
    s2 = arg2->value[0] > 0x7f ? 0xff : 0x00;
    if (s1 != s2)
        return s1 == 0xff ? -1 : 1;
    l = arg1->length > arg2->length ? arg1->length : arg2->length;
    o1 = l - arg1->length;
    o2 = l - arg2->length;
    for (i = 0; i < l; i++) {
        d = (i >= o1 ? arg1->value[i - o1] : s1) - (i >= o2 ? arg2->value[i - o2] : s2);
        if (d)
            return d;
    }
    return 0;
}
#endif // ENABLE_ALL

/* create an intx value from an uint32 value */
#ifdef ENABLE_ALL
void ASN1intx_setuint32(ASN1intx_t *dst, ASN1uint32_t val)
{
    ASN1octet_t o[5], *v = o;
    int n = 5;
    v[0] = 0;
    v[1] = (ASN1octet_t)(val >> 24);
    v[2] = (ASN1octet_t)(val >> 16);
    v[3] = (ASN1octet_t)(val >> 8);
    v[4] = (ASN1octet_t)(val);
    while (n > 1 && !*v && v[1] <= 0x7f) {
        n--;
        v++;
    }
    dst->length = n;
    dst->value = (ASN1octet_t *)MemAlloc(n, UNKNOWN_MODULE);
    if (dst->value)
    {
        CopyMemory(dst->value, v, n);
    }
}
#endif // ENABLE_ALL

/* create an intx value from an int32 value */
#ifdef ENABLE_ALL
void ASN1intx_setint32(ASN1intx_t *dst, ASN1int32_t val)
{
    ASN1octet_t o[5], *v = o;
    int n = 5;
    v[0] = (ASN1octet_t)(val < 0 ? 0xff : 0x00);
    v[1] = (ASN1octet_t)(val >> 24);
    v[2] = (ASN1octet_t)(val >> 16);
    v[3] = (ASN1octet_t)(val >> 8);
    v[4] = (ASN1octet_t)(val);
    while (n > 1 && ((!*v && v[1] <= 0x7f) || (*v == 0xff && v[1] > 0x7f))) {
        n--;
        v++;
    }
    dst->length = n;
    dst->value = (ASN1octet_t *)MemAlloc(n, UNKNOWN_MODULE);
    if (dst->value)
    {
        CopyMemory(dst->value, v, n);
    }
}
#endif // ENABLE_ALL

/* copy constructor */
ASN1int32_t ASN1intx_dup(ASN1intx_t *dst, ASN1intx_t *val)
{
    dst->length = val->length;
    dst->value = (ASN1octet_t *)MemAlloc(val->length, UNKNOWN_MODULE);
    if (dst->value)
    {
        CopyMemory(dst->value, val->value, val->length);
        return 1;
    }

    // fail to allocate memory
    dst->length = 0;
    return 0;
}

/* free an intx value */
void ASN1intx_free(ASN1intx_t *val)
{
    if (val)
    {
        MemFree(val->value);
    }
}

#ifdef HAS_SIXTYFOUR_BITS
/* convert an intx value to a uint64 value */
#ifdef ENABLE_ALL
ASN1uint64_t ASN1intx2uint64(ASN1intx_t *val)
{
    switch (val->length) {
    case 1:
        return (ASN1uint64_t)val->value[val->length - 1];
    case 2:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8));
    case 3:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16));
    case 4:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 4] << 24));
    case 5:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32));
    case 6:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40));
    case 7:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40) |
            ((ASN1uint64_t)val->value[val->length - 7] << 48));
    default:
        return (ASN1uint64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40) |
            ((ASN1uint64_t)val->value[val->length - 7] << 48) |
            ((ASN1uint64_t)val->value[val->length - 8] << 56));
    }
}
#endif // ENABLE_ALL
#endif

/* check if intx value is a uint64 value */
#ifdef ENABLE_ALL
int ASN1intxisuint64(ASN1intx_t *val)
{
    if (val->value[0] > 0x7f)
        return 0;
    return ASN1intx_uoctets(val) <= 8;
}
#endif // ENABLE_ALL

#ifdef HAS_SIXTYFOUR_BITS
/* convert an intx value to a int64 value */
#ifdef ENABLE_ALL
ASN1int64_t ASN1intx2int64(ASN1intx_t *val)
{
    switch (val->length) {
    case 1:
        return (ASN1int64_t)(ASN1int8_t)val->value[val->length - 1];
    case 2:
        return (ASN1int64_t)(ASN1int16_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8));
    case 3:
        return (ASN1int64_t)(ASN1int32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 3] > 0x7f ?
            0xffffffffff000000LL : 0));
    case 4:
        return (ASN1int64_t)(ASN1int32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 4] << 24));
    case 5:
        return (ASN1int64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 5] > 0x7f ?
            0xffffff0000000000LL : 0));
    case 6:
        return (ASN1int64_t)(val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40) |
            ((ASN1uint64_t)val->value[val->length - 6] > 0x7f ?
            0xffff000000000000LL : 0));
    case 7:
        return (ASN1int64_t)((ASN1uint64_t)val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40) |
            ((ASN1uint64_t)val->value[val->length - 7] << 48) |
            ((ASN1uint64_t)val->value[val->length - 7] > 0x7f ?
            0xff00000000000000LL : 0));
    default:
        return (ASN1int64_t)((ASN1uint64_t)val->value[val->length - 1] |
            ((ASN1uint64_t)val->value[val->length - 2] << 8) |
            ((ASN1uint64_t)val->value[val->length - 3] << 16) |
            ((ASN1uint64_t)val->value[val->length - 4] << 24) |
            ((ASN1uint64_t)val->value[val->length - 5] << 32) |
            ((ASN1uint64_t)val->value[val->length - 6] << 40) |
            ((ASN1uint64_t)val->value[val->length - 7] << 48) |
            ((ASN1uint64_t)val->value[val->length - 8] << 56));
    }
}
#endif // USE_ASN1intx2int64
#endif

/* check if intx value is an int64 value */
#ifdef USE_ASN1intxisint64
int
ASN1intxisint64(ASN1intx_t *val)
{
    return ASN1intx_octets(val) <= 8;
}
#endif // USE_ASN1intxisint64

/* convert intx value to uint32 value */
#ifdef ENABLE_ALL
ASN1uint32_t ASN1intx2uint32(ASN1intx_t *val)
{
    switch (val->length) {
    case 1:
        return (ASN1uint32_t)val->value[val->length - 1];
    case 2:
        return (ASN1uint32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8));
    case 3:
        return (ASN1uint32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16));
    default:
        return (ASN1uint32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 4] << 24));
    }
}
#endif // ENABLE_ALL

/* check if intx value is an uint32 value */
#ifdef ENABLE_ALL
int ASN1intxisuint32(ASN1intx_t *val)
{
    if (val->value[0] > 0x7f)
        return 0;
    return ASN1intx_uoctets(val) <= 4;
}
#endif // ENABLE_ALL

/* convert intx value to int32 value */
ASN1int32_t ASN1intx2int32(ASN1intx_t *val)
{
    switch (val->length) {
    case 1:
        return (ASN1int32_t)(ASN1int8_t)val->value[val->length - 1];
    case 2:
        return (ASN1int32_t)(ASN1int16_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8));
    case 3:
        return (ASN1int32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 3] > 0x7f ?
            0xff000000 : 0));
    default:
        return (ASN1int32_t)(val->value[val->length - 1] |
            ((ASN1uint32_t)val->value[val->length - 2] << 8) |
            ((ASN1uint32_t)val->value[val->length - 3] << 16) |
            ((ASN1uint32_t)val->value[val->length - 4] << 24));
    }
}

/* check if intx value is an int32 value */
#ifdef ENABLE_ALL
int ASN1intxisint32(ASN1intx_t *val)
{
    return ASN1intx_octets(val) <= 4;
}
#endif // ENABLE_ALL

/* convert intx value to uint16 value */
#ifdef ENABLE_ALL
ASN1uint16_t ASN1intx2uint16(ASN1intx_t *val)
{
    if (val->length == 1)
        return (ASN1uint16_t)val->value[val->length - 1];
    return (ASN1uint16_t)(val->value[val->length - 1] |
        ((ASN1uint32_t)val->value[val->length - 2] << 8));
}
#endif // ENABLE_ALL

/* check if intx value is an uint16 value */
#ifdef ENABLE_ALL
int ASN1intxisuint16(ASN1intx_t *val)
{
    if (val->value[0] > 0x7f)
        return 0;
    return ASN1intx_uoctets(val) <= 2;
}
#endif // ENABLE_ALL

/* convert intx value to int16 value */
#ifdef ENABLE_ALL
ASN1int16_t ASN1intx2int16(ASN1intx_t *val)
{
    if (val->length == 1)
        return (ASN1int16_t)(ASN1int8_t)val->value[val->length - 1];
    return (ASN1int16_t)(val->value[val->length - 1] |
        ((ASN1uint32_t)val->value[val->length - 2] << 8));
}
#endif // ENABLE_ALL

/* check if intx value is an int16 value */
#ifdef ENABLE_ALL
int ASN1intxisint16(ASN1intx_t *val)
{
    return ASN1intx_octets(val) <= 2;
}
#endif // ENABLE_ALL

/* convert intx value to uint8 value */
#ifdef ENABLE_ALL
ASN1uint8_t ASN1intx2uint8(ASN1intx_t *val)
{
    return (ASN1uint8_t)val->value[val->length - 1];
}
#endif // ENABLE_ALL

/* check if intx value is an uint8 value */
#ifdef ENABLE_ALL
int ASN1intxisuint8(ASN1intx_t *val)
{
    if (val->value[0] > 0x7f)
        return 0;
    return ASN1intx_uoctets(val) <= 1;
}
#endif // ENABLE_ALL

/* convert intx value to int8 value */
#ifdef ENABLE_ALL
ASN1int8_t ASN1intx2int8(ASN1intx_t *val)
{
    return (ASN1int8_t)val->value[val->length - 1];
}
#endif // ENABLE_ALL

/* check if intx value is an int8 value */
#ifdef ENABLE_ALL
int ASN1intxisint8(ASN1intx_t *val)
{
    return ASN1intx_octets(val) <= 1;
}
#endif // ENABLE_ALL

/* count octets for a signed encoding of an intx value */
#ifdef ENABLE_ALL
ASN1uint32_t ASN1intx_octets(ASN1intx_t *val)
{
    ASN1uint32_t i;
    ASN1uint32_t s;

    s = val->value[0] > 0x7f ? 0xff : 0x00;
    for (i = 0; i < val->length; i++) {
        if (val->value[i] != s)
            break;
    }
    if (i && ((val->value[i] ^ s) & 0x80))
        i--;
    return val->length - i;
}
#endif // ENABLE_ALL

/* count octets for unsigned encoding of an unsigned intx value */
ASN1uint32_t ASN1intx_uoctets(ASN1intx_t *val)
{
    ASN1uint32_t i;

    for (i = 0; i < val->length; i++) {
        if (val->value[i])
            break;
    }
    return val->length - i;
}

/* count octets for signed encoding of an uint32 value */
#ifdef ENABLE_ALL
ASN1uint32_t ASN1uint32_octets(ASN1uint32_t val)
{
    if (val >= 0x8000) {
        if (val >= 0x800000) {
            return ((val >= 0x80000000) ? 5 : 4);
        }
        return 3;
    }
    return ((val >= 0x80) ? 2 : 1);
}
#endif // ENABLE_ALL

/* count octets for unsigned encoding of an uint32 value */
ASN1uint32_t ASN1uint32_uoctets(ASN1uint32_t val)
{
    if (val >= 0x10000) {
        return ((val >= 0x1000000) ? 4 : 3);
    }
    return ((val >= 0x100) ? 2 : 1);
}

/* count octets for signed encoding of an int32 value */
ASN1uint32_t ASN1int32_octets(ASN1int32_t val)
{
    if (val >= 0) {
        if (val >= 0x8000) {
            return ((val >= 0x800000) ? 4 : 3);
        }
        return ((val >= 0x80) ? 2 : 1);
    }
    if (val < -0x8000) {
        return ((val < -0x800000) ? 4 : 3);
    }
    return ((val < -0x80) ? 2 : 1);
}

/* convert an intx value into a double */
#ifdef ENABLE_ALL
double ASN1intx2double(ASN1intx_t *val)
{
    double ret;
    ASN1uint32_t i;

    if (val->value[0] > 0x7f)
        ret = (double)(val->value[0] - 0x100);
    else
        ret = (double)val->value[0];
    for (i = 1; i < val->length; i++) {
        ret = ret * 256.0 + (double)val->value[i];
    }
    return ret;
}
#endif // ENABLE_ALL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\msasn1\libasn1.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation 1997-1998, All rights reserved. */

#ifndef __LIB_ASN1_H__
#define __LIB_ASN1_H__

#include <msasn1.h>
#include <msper.h>
#include <msber.h>

#ifdef __cplusplus
extern "C" {
#endif

// THE FOLLOWING IS FROM MS_CORE.H

/*
 * This file contains operating system specific defines:
 *
 * Dynamic link library support:
 * Define DllExport as declspec for exported functions and
 * DllImport as declspec for imported functions.
 *
 * Floating point encoding support:
 * For encoding floating point values either
 * - finite()+isinf()+copysign()+frexp() or
 * - finite()+fpclass()+FP_PINF+FP_NINF+frexp()
 * is needed. Define HAS_ISINF for the former case or HAS_FPCLASS for
 * the latter case.
 * Define HAS_IEEEFP_H for inclusion of <ieeefp.h> or HAS_FLOAT_H for
 * inclusion of <float.h> if required.
 *
 * Integer type support
 * [u]int{8,16,32}_t must specify an integral (unsigned iff u-prefixed)
 * type of the specified size (in bits).
 */

/* MS-Windows 95/MS-Windows NT */
#define THIRTYTWO_BITS  1
// #define HAS_SIXTYFOUR_BITS 1
#define HAS_FLOAT_H     1
#define HAS_FPCLASS     1
#define fpclass(_d)     _fpclass(_d)
#define finite(_d)      _finite(_d)
#define isnan(_d)       _isnan(_d)
#define FP_PINF         _FPCLASS_PINF
#define FP_NINF         _FPCLASS_NINF
// #define HAS_STRICMP     1
#define DBL_PINF        {0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x7f}
#define DBL_MINF        {0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0xff}



extern ASN1intx_t ASN1intx_0, ASN1intx_1, ASN1intx_2, ASN1intx_16, ASN1intx_256, ASN1intx_64K, ASN1intx_1G;
extern void ASN1API ASN1intx_addoctet(ASN1intx_t *, ASN1intx_t *, ASN1octet_t);
extern void ASN1API ASN1intx_suboctet(ASN1intx_t *, ASN1intx_t *, ASN1octet_t);
extern void ASN1API ASN1intx_muloctet(ASN1intx_t *, ASN1intx_t *, ASN1octet_t);
extern void ASN1API ASN1intx_inc(ASN1intx_t *);
extern void ASN1API ASN1intx_dec(ASN1intx_t *);
extern void ASN1API ASN1intx_neg(ASN1intx_t *, ASN1intx_t *);
extern ASN1uint32_t ASN1API ASN1intx_log2(ASN1intx_t *);
extern ASN1uint32_t ASN1API ASN1intx_log256(ASN1intx_t *);
extern ASN1int32_t ASN1API ASN1intx_cmp(ASN1intx_t *, ASN1intx_t *);
extern ASN1int32_t ASN1API ASN1intx_dup(ASN1intx_t *, ASN1intx_t *);
// extern void ASN1API ASN1intx_free(ASN1intx_t *);
extern void ASN1API ASN1intx_setuint32(ASN1intx_t *, ASN1uint32_t);
extern void ASN1API ASN1intx_setint32(ASN1intx_t *, ASN1int32_t);
extern int  ASN1API ASN1intxisuint64(ASN1intx_t *);
extern int  ASN1API ASN1intxisint64(ASN1intx_t *);
extern int  ASN1API ASN1intxisuint32(ASN1intx_t *);
extern int  ASN1API ASN1intxisint32(ASN1intx_t *);
extern int  ASN1API ASN1intxisuint16(ASN1intx_t *);
extern int  ASN1API ASN1intxisint16(ASN1intx_t *);
extern int  ASN1API ASN1intxisuint8(ASN1intx_t *);
extern int  ASN1API ASN1intxisint8(ASN1intx_t *);
#ifdef HAS_SIXTYFOUR_BITS
extern ASN1uint64_t ASN1API ASN1intx2uint64(ASN1intx_t *);
extern ASN1int64_t ASN1API ASN1intx2int64(ASN1intx_t *);
#endif
extern ASN1uint32_t ASN1API ASN1intx2uint32(ASN1intx_t *);
extern ASN1int32_t ASN1API ASN1intx2int32(ASN1intx_t *);
extern ASN1uint16_t ASN1API ASN1intx2uint16(ASN1intx_t *);
extern ASN1int16_t ASN1API ASN1intx2int16(ASN1intx_t *);
extern ASN1uint8_t ASN1API ASN1intx2uint8(ASN1intx_t *);
extern ASN1int8_t ASN1API ASN1intx2int8(ASN1intx_t *);
extern ASN1uint32_t ASN1API ASN1intx_octets(ASN1intx_t *);
extern ASN1uint32_t ASN1API ASN1uint32_log2(ASN1uint32_t);
extern ASN1uint32_t ASN1API ASN1uint32_log256(ASN1uint32_t);
extern ASN1uint32_t ASN1API ASN1uint32_octets(ASN1uint32_t);
extern ASN1uint32_t ASN1API ASN1uint32_uoctets(ASN1uint32_t);
extern ASN1uint32_t ASN1API ASN1int32_octets(ASN1int32_t);
extern double ASN1API ASN1intx2double(ASN1intx_t *);
extern double ASN1API ASN1real2double(ASN1real_t *);
extern double ASN1API ASN1double_minf();
extern double ASN1API ASN1double_pinf();
extern int ASN1API ASN1double_isminf(double);
extern int ASN1API ASN1double_ispinf(double);
extern int ASN1API ASN1generalizedtime2string(char *, ASN1generalizedtime_t *);
extern int ASN1API ASN1utctime2string(char *, ASN1utctime_t *);
extern int ASN1API ASN1string2generalizedtime(ASN1generalizedtime_t *, char *);
extern int ASN1API ASN1string2utctime(ASN1utctime_t *, char *);

/* ------ Comparison APIs ------ */

extern int ASN1API ASN1ztchar32string_cmp(ASN1ztchar32string_t, ASN1ztchar32string_t);
extern int ASN1API ASN1double_cmp(double, double);
extern int ASN1API ASN1real_cmp(ASN1real_t *, ASN1real_t *);
extern int ASN1API ASN1external_cmp(ASN1external_t *, ASN1external_t *);
extern int ASN1API ASN1embeddedpdv_cmp(ASN1embeddedpdv_t *, ASN1embeddedpdv_t *);
extern int ASN1API ASN1characterstring_cmp(ASN1characterstring_t *, ASN1characterstring_t *);
extern int ASN1API ASN1sequenceoflengthpointer_cmp(ASN1uint32_t, void *, ASN1uint32_t, void *, ASN1uint32_t, int (*)(void *, void *));
extern int ASN1API ASN1sequenceofsinglylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));
extern int ASN1API ASN1sequenceofdoublylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));
extern int ASN1API ASN1setoflengthpointer_cmp(ASN1uint32_t, void *, ASN1uint32_t, void *, ASN1uint32_t, int (*)(void *, void *));
extern int ASN1API ASN1setofsinglylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));
extern int ASN1API ASN1setofdoublylinkedlist_cmp(void *, void *, ASN1uint32_t, int (*)(void *, void *));



#define ASN1BITSET(_val, _bitnr) \
    ((_val)[(_bitnr) >> 3] |= 0x80 >> ((_bitnr) & 7))
#define ASN1BITCLR(_val, _bitnr) \
    ((_val)[(_bitnr) >> 3] &= ~(0x80 >> ((_bitnr) & 7)))
#define ASN1BITTEST(_val, _bitnr) \
    ((_val)[(_bitnr) >> 3] & (0x80 >> ((_bitnr) & 7)))
    



// internal functions
int _BERDecConstructed(ASN1decoding_t dec, ASN1uint32_t len, ASN1uint32_t infinite, ASN1decoding_t *dd, ASN1octet_t **di);


#ifdef __cplusplus
}
#endif

#endif // __LIB_ASN1_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\msasn1\ms_core.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

//--------------------------------------------------------------------------
//
// Module Name:  ms_core.h
//
// Brief Description:
//      This module contains the engine for the Microsoft
//      ASN.1 encoder and decoder.
//
// History:
//      10/15/97    Lon-Chan Chu (lonchanc)
//          Created.
//
// Copyright (c) 1997 Microsoft Corporation
//
//--------------------------------------------------------------------------

#include "precomp.h"


int APIENTRY
DllMain ( HINSTANCE hInstance, DWORD dwReason, LPVOID plReserved )
{
    switch (dwReason)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hInstance);
        break;

    case DLL_PROCESS_DETACH:
        #ifdef ENABLE_MEMORY_TRACKING
        DbgMemTrackFinalCheck();
        #endif // ENABLE_MEMORY_TRACKING
        break;

    default:
        break;
    }

    return TRUE;
}


ASN1error_e ASN1EncSetError(ASN1encoding_t enc, ASN1error_e err)
{
    ASN1INTERNencoding_t e = (ASN1INTERNencoding_t) enc;
    EncAssert(enc, ASN1_SUCCESS <= err);
    while (e)
    {
        e->info.err = err;
        if (e == e->parent)
        {
            break;
        }
        e = e->parent;
    }
    return err;
}

ASN1error_e ASN1DecSetError(ASN1decoding_t dec, ASN1error_e err)
{
    ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t) dec;
    DecAssert(dec, ASN1_SUCCESS <= err);
    while (d)
    {
        d->info.err = err;
        if (d == d->parent)
        {
            break;
        }
        d = d->parent;
    }
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\msasn1\ms_ut.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#ifndef _MS_UT_H_
#define _MS_UT_H_

#define ARRAY_SIZE(arr)             (sizeof(arr) / sizeof(arr[0]))
// #define FIELD_OFFSET(type, field)   ((long)&(((type *)0)->field))   // from winnt.h
#define PARAMS_SIZE_N_ARRARY(arr)   ARRAY_SIZE(arr), arr

#define LPVOID_ADD(ptr,inc)  (LPVOID) ((ASN1octet_t *) (ptr) + (ASN1uint32_t) (inc))
#define LPVOID_SUB(ptr,dec)  (LPVOID) ((ASN1octet_t *) (ptr) - (ASN1uint32_t) (inc))

#define LPVOID_NEXT(ptr)     *(LPVOID FAR *) (ptr)

// the following constants is for calculating decoded data structure size
// we are conservative here and try to be 4-byte aligned due to Alpha platform.

#define ASN1_SIZE_ALIGNED(n)    (n) = ((((n) + 3) >> 2) << 2)

#ifdef ENABLE_BER
int My_memcmp(ASN1octet_t *pBuf1, ASN1uint32_t cbBuf1Size, ASN1octet_t *pBuf2, ASN1uint32_t cbBuf2Size);
#endif // ENABLE_BER

#define UNKNOWN_MODULE                  0

#ifdef ENABLE_MEMORY_TRACKING

void   DbgMemTrackFinalCheck ( void );
LPVOID DbgMemAlloc ( UINT cbSize, ASN1uint32_t nModuleName, LPSTR pszFileName, UINT nLineNumber );
void   DbgMemFree ( LPVOID ptr );
LPVOID DbgMemReAlloc ( LPVOID ptr, UINT cbSize, ASN1uint32_t nModuleName, LPSTR pszFileName, UINT nLineNumber );

#define MemAlloc(cb,modname)            DbgMemAlloc((cb), modname, __FILE__, __LINE__)
#define MemFree(lp)                     DbgMemFree((lp))
#define MemReAlloc(lp,cb,modname)       DbgMemReAlloc((lp), (cb), modname, __FILE__, __LINE__)

#define _ModName(enc_dec)               (enc_dec)->module->nModuleName

LPVOID DbgDecMemAlloc   ( ASN1decoding_t dec, ASN1uint32_t cbSize,  LPSTR pszFileName, ASN1uint32_t nLineNumber);
LPVOID DbgDecMemReAlloc ( ASN1decoding_t dec, LPVOID lpData, ASN1uint32_t cbSize, LPSTR pszFileName, ASN1uint32_t nLineNumber);

#define DecMemAlloc(dec,cb)             DbgDecMemAlloc((dec), (cb), __FILE__, __LINE__)
#define DecMemReAlloc(dec,lp,cb)        DbgDecMemReAlloc((dec), (lp), (cb), __FILE__, __LINE__)

#define EncMemAlloc(enc,cb)             DbgMemAlloc((cb), _ModName(enc), __FILE__, __LINE__)
#define EncMemReAlloc(enc,lp,cb)        DbgMemReAlloc((lp), (cb), _ModName(enc), __FILE__, __LINE__)

#else // ! ENABLE_MEMORY_TRACKING

#define MemAllocEx(dec,cb,fZero)        LocalAlloc((fZero)?LPTR:LMEM_FIXED, (cb))
#define MemAlloc(cb,modname)            LocalAlloc(LPTR,(cb))
#define MemFree(lp)                     LocalFree(lp)
#define MemReAllocEx(dec,lp,cb,fZero)   ((lp) ? \
            LocalReAlloc((lp),(cb),(fZero)?LMEM_MOVEABLE|LMEM_ZEROINIT:LMEM_MOVEABLE) : \
            LocalAlloc((fZero)?LPTR:LMEM_FIXED, (cb)))
#define MemReAlloc(lp,cb,modname)       ((lp) ? \
            LocalReAlloc((lp),(cb),LMEM_MOVEABLE|LMEM_ZEROINIT) : \
            LocalAlloc(LPTR, (cb)))

#define _ModName(enc_dec)                   

LPVOID DecMemAlloc   ( ASN1decoding_t dec, ASN1uint32_t cbSize );
LPVOID DecMemReAlloc ( ASN1decoding_t dec, LPVOID lpData, ASN1uint32_t cbSize );

#define EncMemAlloc(enc,cb)             MemAlloc((cb),0)
#define EncMemReAlloc(enc,lp,cb)        MemReAlloc((lp),(cb),0)

#endif // ! ENABLE_MEMORY_TRACKING

void   DecMemFree    ( ASN1decoding_t dec, LPVOID lpData );

#define EncMemFree(enc,lpData)              MemFree(lpData)

int IsDigit(char p);
unsigned int  DecimalStringToUINT(char * pcszString, ASN1uint32_t cch);
void * ms_bSearch (
        const void *key,
        const void *base,
        size_t num,
        size_t width,
        int (__cdecl *compare)(const void *, const void *)
        );

#define MyAssert(f)         
#ifdef _DEBUG
    void MyDebugBreak(void);
    __inline void EncAssert(ASN1encoding_t enc, int val)
    {
        if ((! (enc->dwFlags & ASN1FLAGS_NOASSERT)) && (! (val)))
        {
            MyDebugBreak();
        }
    }
    __inline void DecAssert(ASN1decoding_t dec, int val)
    {
        if ((! (dec->dwFlags & ASN1FLAGS_NOASSERT)) && (! (val)))
        {
            MyDebugBreak();
        }
    }
#else
    #define EncAssert(enc,f)   
    #define DecAssert(dec,f)   
#endif // _DEBUG

#endif // _MS_UT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\msasn1\ms_per.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

//--------------------------------------------------------------------------
//
// Module Name:  ms_per.c
//
// Brief Description:
//      This module contains the routines for the Microsoft
//      ASN.1 encoder and decoder.
//
// History:
//      10/15/97    Lon-Chan Chu (lonchanc)
//          Created.
//
// Copyright (c) 1997 Microsoft Corporation
//
//--------------------------------------------------------------------------

#include "precomp.h"

#define MLZ_FILE_ZONE   ZONE_MSPER


int ASN1PEREncInteger(ASN1encoding_t enc, ASN1int32_t val)
{
    ASN1uint32_t l = ASN1int32_octets(val);
    ASN1PEREncAlignment(enc);
    if (ASN1PEREncBitVal(enc, 8, l))
    {
        return ASN1PEREncBitVal(enc, l * 8, val);
    }
    return 0;
}

int ASN1PERDecInteger(ASN1decoding_t dec, ASN1int32_t *val)
{
    ASN1uint32_t l;
    ASN1PERDecAlignment(dec);
    if (ASN1PERDecFragmentedLength(dec, &l))
    {
        return ASN1PERDecS32Val(dec, l * 8, val);
    }
    return 0;
}

int ASN1PEREncUnsignedInteger(ASN1encoding_t enc, ASN1uint32_t val)
{
    ASN1uint32_t l = ASN1uint32_uoctets(val);
    ASN1PEREncAlignment(enc);
    if (ASN1PEREncBitVal(enc, 8, l))
    {
        return ASN1PEREncBitVal(enc, l * 8, val);
    }
    return 0;
}

int ASN1PERDecUnsignedInteger(ASN1decoding_t dec, ASN1uint32_t *val)
{
    ASN1uint32_t l;
    ASN1PERDecAlignment(dec);
    if (ASN1PERDecFragmentedLength(dec, &l))
    {
        return ASN1PERDecU32Val(dec, l * 8, val);
    }
    return 0;
}

int ASN1PEREncUnsignedShort(ASN1encoding_t enc, ASN1uint32_t val)
{
    ASN1PEREncAlignment(enc);
    return ASN1PEREncBitVal(enc, 16, val);
}

int ASN1PERDecUnsignedShort(ASN1decoding_t dec, ASN1uint16_t *val)
{
    ASN1PERDecAlignment(dec);
    return ASN1PERDecU16Val(dec, 16, val);
}

int ASN1PEREncBoolean(ASN1encoding_t enc, ASN1bool_t val)
{
    return ASN1PEREncBitVal(enc, 1, val ? 1 : 0);
}

int ASN1PERDecBoolean(ASN1decoding_t dec, ASN1bool_t *val)
{
    DecAssert(dec, sizeof(ASN1bool_t) == sizeof(ASN1uint8_t));
    *val = 0; // in case we change the boolean type
    return ASN1PERDecU8Val(dec, 1, val);
}

__inline int _EncExtensionBitClear(ASN1encoding_t enc)
{
    return ASN1PEREncBitVal(enc, 1, 0);
}

int ASN1PEREncExtensionBitClear(ASN1encoding_t enc)
{
    return _EncExtensionBitClear(enc);
}

__inline int _EncExtensionBitSet(ASN1encoding_t enc)
{
    return ASN1PEREncBitVal(enc, 1, 1);
}

int ASN1PEREncExtensionBitSet(ASN1encoding_t enc)
{
    return _EncExtensionBitSet(enc);
}

int ASN1PERDecSkipNormallySmallExtensionFragmented(ASN1decoding_t dec)
{
    ASN1uint32_t e, i;
    if (ASN1PERDecSkipNormallySmallExtension(dec, &e))
    {
        for (i = 0; i < e; i++)
        {
            if (ASN1PERDecSkipFragmented(dec, 8))
            {
                continue;
            }
            return 0;
        }
        return 1;
    }
    return 0;
}

int ASN1PEREncSimpleChoice(ASN1encoding_t enc, ASN1choice_t ChoiceVal, ASN1int32_t cChoiceBits)
{
    if (ChoiceVal >= ASN1_CHOICE_BASE)
    {
        ChoiceVal -= ASN1_CHOICE_BASE;
        return (cChoiceBits ? ASN1PEREncBitVal(enc, cChoiceBits, ChoiceVal) : 1);
    }
    EncAssert(enc, FALSE);
    return 0;
}

int ASN1PERDecSimpleChoice(ASN1decoding_t dec, ASN1choice_t *pChoiceVal, ASN1int32_t cChoiceBits)
{
    DecAssert(dec, cChoiceBits <= sizeof(ASN1choice_t) * 8);
    *pChoiceVal = ASN1_CHOICE_BASE; // default choice
    if (cChoiceBits)
    {
        if (ASN1PERDecU16Val(dec, cChoiceBits, pChoiceVal))
        {
            *pChoiceVal += ASN1_CHOICE_BASE;
        }
        else
        {
            return 0;
        }
    }
    return 1;
}

int ASN1PEREncSimpleChoiceEx(ASN1encoding_t enc, ASN1choice_t ChoiceVal, ASN1int32_t cChoiceBits)
{
    if (ChoiceVal >= ASN1_CHOICE_BASE)
    {
        ChoiceVal -= ASN1_CHOICE_BASE;
        if (_EncExtensionBitClear(enc))
        {
            return (cChoiceBits ? ASN1PEREncBitVal(enc, cChoiceBits, ChoiceVal) : 1);
        }
    }
    else
    {
        EncAssert(enc, 0);
    }
    return 0;
}

int ASN1PERDecSimpleChoiceEx(ASN1decoding_t dec, ASN1choice_t *pChoiceVal, ASN1int32_t cChoiceBits)
{
    ASN1uint32_t x;
    DecAssert(dec, cChoiceBits <= sizeof(ASN1choice_t) * 8);
    if (ASN1PERDecExtensionBit(dec, &x))
    {
        if (!x)
        {
            *pChoiceVal = ASN1_CHOICE_BASE; // default choice
            if (cChoiceBits)
            {
                if (ASN1PERDecU16Val(dec, cChoiceBits, pChoiceVal))
                {
                    *pChoiceVal += ASN1_CHOICE_BASE;
                    return 1;
                }
                return 0;
            }
            return 1;
        }

        *pChoiceVal = ASN1_CHOICE_EXTENSION; // extension choice
        return ASN1PERDecSkipNormallySmall(dec);
    }
    return 0;
}

int ASN1PEREncComplexChoice(ASN1encoding_t enc, ASN1choice_t ChoiceVal, ASN1int32_t cChoiceBits, ASN1choice_t ExtensionChoice)
{
    if (ChoiceVal >= ASN1_CHOICE_BASE)
    {
        ChoiceVal -= ASN1_CHOICE_BASE;
        if (ChoiceVal < ExtensionChoice) // lonchanc: no equal sign
        {
            if (_EncExtensionBitClear(enc))
            {
                if (cChoiceBits)
                {
                    return ASN1PEREncBitVal(enc, cChoiceBits, ChoiceVal);
                }
                return 1;
            }
        }
        else
        {
            if (_EncExtensionBitSet(enc))
            {
                return ASN1PEREncNormallySmall(enc, ChoiceVal - ExtensionChoice);
            }
        }
    }
    else
    {
        EncAssert(enc, 0);
    }
    return 0;
}

int ASN1PERDecComplexChoice(ASN1decoding_t dec, ASN1choice_t *pChoiceVal, ASN1int32_t cChoiceBits, ASN1choice_t ExtensionChoice)
{
    ASN1uint32_t x;
    DecAssert(dec, cChoiceBits <= sizeof(ASN1choice_t) * 8);
    if (ASN1PERDecExtensionBit(dec, &x))
    {
        if (!x)
        {
            *pChoiceVal = ASN1_CHOICE_BASE; // default choice
            if (cChoiceBits)
            {
                if (ASN1PERDecU16Val(dec, cChoiceBits, pChoiceVal))
                {
                    *pChoiceVal += ASN1_CHOICE_BASE;
                    return 1;
                }
                return 0;
            }
            return 1;
        }

        if (ASN1PERDecN16Val(dec, pChoiceVal))
        {
            *pChoiceVal += ExtensionChoice + ASN1_CHOICE_BASE;
            return 1;
        }
    }
    return 0;
}

int ASN1PEREncOctetString_NoSize(ASN1encoding_t enc, ASN1octetstring_t *pOctetStr)
{
    return ASN1PEREncFragmented(enc, pOctetStr->length, pOctetStr->value, 8);
}

int ASN1PERDecOctetString_NoSize(ASN1decoding_t dec, ASN1octetstring_t *pOctetStr)
{
    return ASN1PERDecFragmented(dec, &(pOctetStr->length), &(pOctetStr->value), 8);
}

int _PEREncOctetString2
(
    ASN1encoding_t      enc,
    ASN1uint32_t        length,
    ASN1octet_t        *value,
    ASN1uint32_t        nSizeLowerBound,
    ASN1uint32_t        nSizeUpperBound,
    ASN1uint32_t        cSizeBits
)
{
    // fixed size array?
    if (nSizeLowerBound == nSizeUpperBound)
    {
        ASN1uint32_t nSizeLimit = nSizeLowerBound;
        EncAssert(enc, cSizeBits == 0);
        EncAssert(enc, nSizeLimit < 64 * 1024);
        if (length == nSizeLimit)
        {
            if (nSizeLimit > 2)
            {
                ASN1PEREncAlignment(enc);
            }
            return ASN1PEREncBits(enc, nSizeLimit * 8, value);
        }
        EncAssert(enc, 0);
        return 0;
    }

    // ranged size array
    EncAssert(enc, cSizeBits);
    EncAssert(enc, nSizeLowerBound < nSizeUpperBound);
    if (nSizeLowerBound <= length && length <= nSizeUpperBound)
    {
        if (nSizeUpperBound - nSizeLowerBound < 255) // lonchanc: inherited from TELES
        {
            if (ASN1PEREncBitVal(enc, cSizeBits, length - nSizeLowerBound))
            {
                ASN1PEREncAlignment(enc);
            }
            else
            {
                return 0;
            }
        }
        else
        {
            EncAssert(enc, cSizeBits % 8 == 0);
            ASN1PEREncAlignment(enc);
            if (!ASN1PEREncBitVal(enc, cSizeBits, length - nSizeLowerBound))
                return 0;
        }
        return ASN1PEREncBits(enc, length * 8, value);
    }
    EncAssert(enc, 0);
    return 0;
}

int ASN1PEREncOctetString_FixedSize(ASN1encoding_t enc, ASN1octetstring2_t *pOctetStr, ASN1uint32_t nSizeLimit)
{
    return _PEREncOctetString2(enc, pOctetStr->length, &(pOctetStr->value[0]), nSizeLimit, nSizeLimit, 0);
}

int ASN1PEREncOctetString_FixedSizeEx(ASN1encoding_t enc, ASN1octetstring_t *pOctetStr, ASN1uint32_t nSizeLimit)
{
    return _PEREncOctetString2(enc, pOctetStr->length, pOctetStr->value, nSizeLimit, nSizeLimit, 0);
}

int ASN1PEREncOctetString_VarSize(ASN1encoding_t enc, ASN1octetstring2_t *pOctetStr, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits)
{
    return _PEREncOctetString2(enc, pOctetStr->length, &(pOctetStr->value[0]), nSizeLowerBound, nSizeUpperBound, cSizeBits);
}

int ASN1PEREncOctetString_VarSizeEx(ASN1encoding_t enc, ASN1octetstring_t *pOctetStr, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits)
{
    return _PEREncOctetString2(enc, pOctetStr->length, pOctetStr->value, nSizeLowerBound, nSizeUpperBound, cSizeBits);
}


int _PERDecOctetString2
(
    ASN1decoding_t      dec,
    ASN1uint32_t       *length,
    ASN1octet_t       **value,
    ASN1uint32_t        nSizeLowerBound,
    ASN1uint32_t        nSizeUpperBound,
    ASN1uint32_t        cSizeBits
)
{
    // fixed size array?
    if (nSizeLowerBound == nSizeUpperBound)
    {
        ASN1uint32_t nSizeLimit = nSizeLowerBound;
        DecAssert(dec, cSizeBits == 0);
        DecAssert(dec, nSizeLimit < 64 * 1024);
        *length = nSizeLimit;
        if (nSizeLimit > 2)
        {
            ASN1PERDecAlignment(dec);
        }
        if (NULL == *value)
        {
            // must be unbounded
            *value = (ASN1octet_t *) DecMemAlloc(dec, nSizeLimit + 1);
            if (NULL == *value)
            {
                return 0;
            }
        }
        return ASN1PERDecExtension(dec, nSizeLimit * 8, *value);
    }

    // ranged size array
    DecAssert(dec, cSizeBits);
    DecAssert(dec, nSizeLowerBound < nSizeUpperBound);
    if (nSizeUpperBound - nSizeLowerBound < 255) // lonchanc: inherited from TELES
    {
        if (ASN1PERDecU32Val(dec, cSizeBits, length))
        {
            *length += nSizeLowerBound;
            ASN1PERDecAlignment(dec);
        }
        else
        {
            return 0;
        }
    }
    else
    {
        DecAssert(dec, cSizeBits % 8 == 0);
        ASN1PERDecAlignment(dec);
        if (ASN1PERDecU32Val(dec, cSizeBits, length))
        {
            *length += nSizeLowerBound;
        }
        else
        {
            return 0;
        }
    }
    if (*length <= nSizeUpperBound)
    {
        if (NULL == *value)
        {
            *value = (ASN1octet_t *) DecMemAlloc(dec, *length + 1);
            if (NULL == *value)
            {
                return 0;
            }
        }
        return ASN1PERDecExtension(dec, *length * 8, *value);
    }
    DecAssert(dec, 0);
    return 0;

}

int ASN1PERDecOctetString_FixedSize(ASN1decoding_t dec, ASN1octetstring2_t *pOctetStr, ASN1uint32_t nSizeLimit)
{
    ASN1octet_t *pData = &(pOctetStr->value[0]);
    return _PERDecOctetString2(dec, &(pOctetStr->length), &pData, nSizeLimit, nSizeLimit, 0);
}

int ASN1PERDecOctetString_FixedSizeEx(ASN1decoding_t dec, ASN1octetstring_t *pOctetStr, ASN1uint32_t nSizeLimit)
{
    pOctetStr->value = NULL;
    return _PERDecOctetString2(dec, &(pOctetStr->length), &(pOctetStr->value), nSizeLimit, nSizeLimit, 0);
}

int ASN1PERDecOctetString_VarSize(ASN1decoding_t dec, ASN1octetstring2_t *pOctetStr, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits)
{
    ASN1octet_t *pData = &(pOctetStr->value[0]);
    return _PERDecOctetString2(dec, &(pOctetStr->length), &pData, nSizeLowerBound, nSizeUpperBound, cSizeBits);
}

int ASN1PERDecOctetString_VarSizeEx(ASN1decoding_t dec, ASN1octetstring_t *pOctetStr, ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits)
{
    pOctetStr->value = NULL;
    return _PERDecOctetString2(dec, &(pOctetStr->length), &(pOctetStr->value), nSizeLowerBound, nSizeUpperBound, cSizeBits);
}



int ASN1PEREncSeqOf_NoSize(ASN1encoding_t enc, ASN1iterator_t **val, ASN1iterator_encfn pfnIterator)
{
    ASN1uint32_t t;
    ASN1iterator_t *f;
    ASN1uint32_t i;
    ASN1uint32_t j, n = 0x4000;
    EncAssert(enc, NULL != pfnIterator);
    for (t = 0, f = *val; f; f = f->next)
        t++;
    f = *val;
    for (i = 0; i < t;)
    {
        if (ASN1PEREncFragmentedLength(&n, enc, t - i))
        {
            for (j = 0; j < n; i++, j++)
            {
                if (((*pfnIterator)(enc, f)))
                {
                    f = f->next;
                    continue;
                }
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }

    return ((n < 0x4000) ? 1 : ASN1PEREncFragmentedLength(&n, enc, 0));
}

int ASN1PERDecSeqOf_NoSize(ASN1decoding_t dec, ASN1iterator_t **val, ASN1iterator_decfn pfnIterator, ASN1uint32_t cbElementSize)
{
    ASN1iterator_t **f;
    ASN1uint32_t l;
    ASN1uint32_t i;
    ASN1uint32_t n;
    DecAssert(dec, NULL != pfnIterator);
    f = val;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            for (i = 0; i < n; i++)
            {
                if (NULL != (*f = (ASN1iterator_t *)DecMemAlloc(dec, cbElementSize)))
                {
                    if ((*pfnIterator)(dec, *f))
                    {
                        f = &(*f)->next;
                        continue;
                    }
                }
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);
    *f = NULL;
    return 1;
}

int ASN1PEREncSeqOf_VarSize(ASN1encoding_t enc, ASN1iterator_t **val, ASN1iterator_encfn pfnIterator,
        ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits)
{
    ASN1uint32_t t;
    ASN1iterator_t *f;
    for (t = 0, f = *val; f; f = f->next)
        t++;
    if (nSizeLowerBound <= t && t <= nSizeUpperBound)
    {
        if (nSizeUpperBound - nSizeLowerBound + 1 >= 256)
        {
            ASN1PEREncAlignment(enc);
        }
        if (ASN1PEREncBitVal(enc, cSizeBits, t - nSizeLowerBound))
        {
            for (f = *val; f; f = f->next)
            {
                if (((*pfnIterator)(enc, f)))
                {
                    continue;
                }
                return 0;
            }
            return 1;
        }
    }
    else
    {
        EncAssert(enc, 0);
    }
    return 0;
}

int ASN1PERDecSeqOf_VarSize(ASN1decoding_t dec, ASN1iterator_t **val, ASN1iterator_decfn pfnIterator, ASN1uint32_t cbElementSize,
        ASN1uint32_t nSizeLowerBound, ASN1uint32_t nSizeUpperBound, ASN1uint32_t cSizeBits)
{
    ASN1iterator_t **f;
    ASN1uint32_t l, i;

    if (nSizeUpperBound - nSizeLowerBound + 1 >= 256)
    {
        ASN1PERDecAlignment(dec);
    }
    if (ASN1PERDecU32Val(dec, cSizeBits, &l))
    {
        l += nSizeLowerBound;
        DecAssert(dec, l <= nSizeUpperBound);
        f = val;
        for (i = 0; i < l; i++)
        {
            if (NULL != (*f = (ASN1iterator_t *)DecMemAlloc(dec, cbElementSize)))
            {
                if ((*pfnIterator)(dec, *f))
                {
                    f = &(*f)->next;
                    continue;
                }
            }
            return 0;
        }
        *f = NULL;
        return 1;
    }
    return 0;
}

void ASN1PERFreeSeqOf(ASN1iterator_t **val, ASN1iterator_freefn pfnIterator)
{
    if (val)
    {
        ASN1iterator_t *f, *ff;
        for (f = *val; f; f = ff)
        {
            ff = f->next;
            if (pfnIterator)
            {
                (*pfnIterator)(f);
            }
            MemFree(f);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\msasn1\ms_utf8.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

#ifdef ENABLE_BER

extern ASN1int32_t _WideCharToUTF8(WCHAR *, ASN1int32_t, ASN1char_t *, ASN1int32_t);
extern ASN1int32_t _UTF8ToWideChar(ASN1char_t *, ASN1int32_t, WCHAR *, ASN1int32_t);


int ASN1BEREncUTF8String(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t length, WCHAR *value)
{
    if (value && length)
    {
        // first, get the size of the dest UTF8 string
        ASN1int32_t cbStrSize = _WideCharToUTF8(value, length, NULL, 0);
        if (cbStrSize)
        {
            ASN1char_t *psz = (ASN1char_t *) EncMemAlloc(enc, cbStrSize);
            if (psz)
            {
                int rc;
                ASN1int32_t cbStrSize2 = _WideCharToUTF8(value, length, psz, cbStrSize);
                EncAssert(enc, cbStrSize2);
                EncAssert(enc, cbStrSize == cbStrSize2);
                rc = ASN1BEREncOctetString(enc, tag, cbStrSize2, psz);
                EncMemFree(enc, psz);
                return rc;
            }
        }
        else
        {
            ASN1EncSetError(enc, ASN1_ERR_UTF8);
        }
    }
    else
    {
        return ASN1BEREncOctetString(enc, tag, 0, NULL);
    }
    return 0;
}

int ASN1BERDecUTF8String(ASN1decoding_t dec, ASN1uint32_t tag, ASN1wstring_t *val)
{
    ASN1octetstring_t ostr;
    if (ASN1BERDecOctetString(dec, tag, &ostr))
    {
        if (ostr.length)
        {
            ASN1int32_t cchWideChar = _UTF8ToWideChar(ostr.value, ostr.length, NULL, 0);
            if (cchWideChar)
            {
                val->value = (WCHAR *) DecMemAlloc(dec, sizeof(WCHAR) * cchWideChar);
                if (val->value)
                {
                    val->length = _UTF8ToWideChar(ostr.value, ostr.length, val->value, cchWideChar);
                    DecAssert(dec, val->length);
                    DecAssert(dec, cchWideChar == (ASN1int32_t) val->length);
                    ASN1octetstring_free(&ostr);
                    return 1;
                }
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_UTF8);
            }
            ASN1octetstring_free(&ostr);
        }
        else
        {
            val->length = 0;
            val->value = NULL;
            return 1;
        }
    }
    return 0;
}


#if 1


//
//  Constant Declarations.
//

#define ASCII                 0x007f

#define SHIFT_IN              '+'     // beginning of a shift sequence
#define SHIFT_OUT             '-'     // end       of a shift sequence

#define UTF8_2_MAX            0x07ff  // max UTF8 2-byte sequence (32 * 64 = 2048)
#define UTF8_1ST_OF_2         0xc0    // 110x xxxx
#define UTF8_1ST_OF_3         0xe0    // 1110 xxxx
#define UTF8_1ST_OF_4         0xf0    // 1111 xxxx
#define UTF8_TRAIL            0x80    // 10xx xxxx

#define HIGHER_6_BIT(u)       ((u) >> 12)
#define MIDDLE_6_BIT(u)       (((u) & 0x0fc0) >> 6)
#define LOWER_6_BIT(u)        ((u) & 0x003f)

#define BIT7(a)               ((a) & 0x80)
#define BIT6(a)               ((a) & 0x40)

#define HIGH_SURROGATE_START  0xd800
#define HIGH_SURROGATE_END    0xdbff
#define LOW_SURROGATE_START   0xdc00
#define LOW_SURROGATE_END     0xdfff


////////////////////////////////////////////////////////////////////////////
//
//  UTF8ToUnicode
//
//  Maps a UTF-8 character string to its wide character string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ASN1int32_t _UTF8ToWideChar
(
    /* in */    ASN1char_t         *lpSrcStr,
    /* in */    ASN1int32_t         cchSrc,
    /* out */   WCHAR              *lpDestStr,
    /* in */    ASN1int32_t         cchDest
)
{
    int nTB = 0;                   // # trail bytes to follow
    int cchWC = 0;                 // # of Unicode code points generated
    LPCSTR pUTF8 = lpSrcStr;
    DWORD dwSurrogateChar;         // Full surrogate char
    BOOL bSurrogatePair = FALSE;   // Indicate we'r collecting a surrogate pair
    char UTF8;

    while ((cchSrc--) && ((cchDest == 0) || (cchWC < cchDest)))
    {
        //
        //  See if there are any trail bytes.
        //
        if (BIT7(*pUTF8) == 0)
        {
            //
            //  Found ASCII.
            //
            if (cchDest)
            {
                lpDestStr[cchWC] = (WCHAR)*pUTF8;
            }
            bSurrogatePair = FALSE;
            cchWC++;
        }
        else if (BIT6(*pUTF8) == 0)
        {
            //
            //  Found a trail byte.
            //  Note : Ignore the trail byte if there was no lead byte.
            //
            if (nTB != 0)
            {
                //
                //  Decrement the trail byte counter.
                //
                nTB--;

                if (bSurrogatePair)
                {
                    dwSurrogateChar <<= 6;
                    dwSurrogateChar |= LOWER_6_BIT(*pUTF8);

                    if (nTB == 0)
                    {
                        if (cchDest)
                        {
                            if ((cchWC + 1) < cchDest)
                            {
                                lpDestStr[cchWC]   = (WCHAR)
                                                     (((dwSurrogateChar - 0x10000) >> 10) + HIGH_SURROGATE_START);

                                lpDestStr[cchWC+1] = (WCHAR)
                                                     ((dwSurrogateChar - 0x10000)%0x400 + LOW_SURROGATE_START);
                            }
                        }

                        cchWC += 2;
                        bSurrogatePair = FALSE;
                    }
                }
                else
                {
                    //
                    //  Make room for the trail byte and add the trail byte
                    //  value.
                    //
                    if (cchDest)
                    {
                        lpDestStr[cchWC] <<= 6;
                        lpDestStr[cchWC] |= LOWER_6_BIT(*pUTF8);
                    }

                    if (nTB == 0)
                    {
                        //
                        //  End of sequence.  Advance the output counter.
                        //
                        cchWC++;
                    }
                }
            }
            else
            {
                // error - not expecting a trail byte
                bSurrogatePair = FALSE;
            }
        }
        else
        {
            //
            //  Found a lead byte.
            //
            if (nTB > 0)
            {
                //
                //  Error - previous sequence not finished.
                //
                nTB = 0;
                bSurrogatePair = FALSE;
                cchWC++;
            }
            else
            {
                //
                //  Calculate the number of bytes to follow.
                //  Look for the first 0 from left to right.
                //
                UTF8 = *pUTF8;
                while (BIT7(UTF8) != 0)
                {
                    UTF8 <<= 1;
                    nTB++;
                }

                //
                // If this is a surrogate unicode pair
                //
                if (nTB == 4)
                {
                    dwSurrogateChar = UTF8 >> nTB;
                    bSurrogatePair = TRUE;
                }

                //
                //  Store the value from the first byte and decrement
                //  the number of bytes to follow.
                //
                if (cchDest)
                {
                    lpDestStr[cchWC] = UTF8 >> nTB;
                }
                nTB--;
            }
        }

        pUTF8++;
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of Unicode characters written.
    //
    return (cchWC);
}


////////////////////////////////////////////////////////////////////////////
//
//  UnicodeToUTF8
//
//  Maps a Unicode character string to its UTF-8 string counterpart.
//
//  02-06-96    JulieB    Created.
////////////////////////////////////////////////////////////////////////////

ASN1int32_t _WideCharToUTF8
(
    /* in */    WCHAR              *lpSrcStr,
    /* in */    ASN1int32_t         cchSrc,
    /* out */   ASN1char_t         *lpDestStr,
    /* in */    ASN1int32_t         cchDest
)
{
    LPCWSTR lpWC = lpSrcStr;
    int     cchU8 = 0;                // # of UTF8 chars generated
    DWORD   dwSurrogateChar;
    WCHAR   wchHighSurrogate = 0;
    BOOL    bHandled;

    while ((cchSrc--) && ((cchDest == 0) || (cchU8 < cchDest)))
    {
        bHandled = FALSE;

        //
        // Check if high surrogate is available
        //
        if ((*lpWC >= HIGH_SURROGATE_START) && (*lpWC <= HIGH_SURROGATE_END))
        {
            if (cchDest)
            {
                // Another high surrogate, then treat the 1st as normal
                // Unicode character.
                if (wchHighSurrogate)
                {
                    if ((cchU8 + 2) < cchDest)
                    {
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
                    }
                    else
                    {
                        // not enough buffer
                        cchSrc++;
                        break;
                    }
                }
            }
            else
            {
                cchU8 += 3;
            }
            wchHighSurrogate = *lpWC;
            bHandled = TRUE;
        }

        if (!bHandled && wchHighSurrogate)
        {
            if ((*lpWC >= LOW_SURROGATE_START) && (*lpWC <= LOW_SURROGATE_END))
            {
                 // wheee, valid surrogate pairs

                 if (cchDest)
                 {
                     if ((cchU8 + 3) < cchDest)
                     {
                         dwSurrogateChar = (((wchHighSurrogate-0xD800) << 10) + (*lpWC - 0xDC00) + 0x10000);

                         lpDestStr[cchU8++] = (UTF8_1ST_OF_4 |
                                               (unsigned char)(dwSurrogateChar >> 18));           // 3 bits from 1st byte

                         lpDestStr[cchU8++] =  (UTF8_TRAIL |
                                                (unsigned char)((dwSurrogateChar >> 12) & 0x3f)); // 6 bits from 2nd byte

                         lpDestStr[cchU8++] = (UTF8_TRAIL |
                                               (unsigned char)((dwSurrogateChar >> 6) & 0x3f));   // 6 bits from 3rd byte

                         lpDestStr[cchU8++] = (UTF8_TRAIL |
                                               (unsigned char)(0x3f & dwSurrogateChar));          // 6 bits from 4th byte
                     }
                     else
                     {
                        // not enough buffer
                        cchSrc++;
                        break;
                     }
                 }
                 else
                 {
                     // we already counted 3 previously (in high surrogate)
                     cchU8 += 1;
                 }

                 bHandled = TRUE;
            }
            else
            {
                 // Bad Surrogate pair : ERROR
                 // Just process wchHighSurrogate , and the code below will
                 // process the current code point
                 if (cchDest)
                 {
                     if ((cchU8 + 2) < cchDest)
                     {
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
                     }
                     else
                     {
                        // not enough buffer
                        cchSrc++;
                        break;
                     }
                 }
            }

            wchHighSurrogate = 0;
        }

        if (!bHandled)
        {
            if (*lpWC <= ASCII)
            {
                //
                //  Found ASCII.
                //
                if (cchDest)
                {
                    lpDestStr[cchU8] = (char)*lpWC;
                }
                cchU8++;
            }
            else if (*lpWC <= UTF8_2_MAX)
            {
                //
                //  Found 2 byte sequence if < 0x07ff (11 bits).
                //
                if (cchDest)
                {
                    if ((cchU8 + 1) < cchDest)
                    {
                        //
                        //  Use upper 5 bits in first byte.
                        //  Use lower 6 bits in second byte.
                        //
                        lpDestStr[cchU8++] = UTF8_1ST_OF_2 | (*lpWC >> 6);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(*lpWC);
                    }
                    else
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                else
                {
                    cchU8 += 2;
                }
            }
            else
            {
                //
                //  Found 3 byte sequence.
                //
                if (cchDest)
                {
                    if ((cchU8 + 2) < cchDest)
                    {
                        //
                        //  Use upper  4 bits in first byte.
                        //  Use middle 6 bits in second byte.
                        //  Use lower  6 bits in third byte.
                        //
                        lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(*lpWC);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(*lpWC);
                        lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(*lpWC);
                    }
                    else
                    {
                        //
                        //  Error - buffer too small.
                        //
                        cchSrc++;
                        break;
                    }
                }
                else
                {
                    cchU8 += 3;
                }
            }
        }

        lpWC++;
    }

    //
    // If the last character was a high surrogate, then handle it as a normal
    // unicode character.
    //
    if ((cchSrc < 0) && (wchHighSurrogate != 0))
    {
        if (cchDest)
        {
            if ((cchU8 + 2) < cchDest)
            {
                lpDestStr[cchU8++] = UTF8_1ST_OF_3 | HIGHER_6_BIT(wchHighSurrogate);
                lpDestStr[cchU8++] = UTF8_TRAIL    | MIDDLE_6_BIT(wchHighSurrogate);
                lpDestStr[cchU8++] = UTF8_TRAIL    | LOWER_6_BIT(wchHighSurrogate);
            }
            else
            {
                cchSrc++;
            }
        }
    }

    //
    //  Make sure the destination buffer was large enough.
    //
    if (cchDest && (cchSrc >= 0))
    {
        SetLastError(ERROR_INSUFFICIENT_BUFFER);
        return (0);
    }

    //
    //  Return the number of UTF-8 characters written.
    //
    return (cchU8);
}



#else

//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1995 - 1997
//
//  File:       utf8.cpp
//
//  Contents:   WideChar to/from UTF8 APIs
//
//  Functions:  WideCharToUTF8
//              UTF8ToWideChar
//
//  History:    19-Feb-97   philh   created
//--------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//  Maps a wide-character (Unicode) string to a new UTF-8 encoded character
//  string.
//
//  The wide characters are mapped as follows:
//
//  Start   End     Bits    UTF-8 Characters
//  ------  ------  ----    --------------------------------
//  0x0000  0x007F  7       0x0xxxxxxx
//  0x0080  0x07FF  11      0x110xxxxx 0x10xxxxxx
//  0x0800  0xFFFF  16      0x1110xxxx 0x10xxxxxx 0x10xxxxxx
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, WideCharToMultiByte.
//
//  Note, starting with NT 4.0, WideCharToMultiByte supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
ASN1int32_t _WideCharToUTF8
(
    /* in */    WCHAR              *lpWideCharStr,
    /* in */    ASN1int32_t         cchWideChar,
    /* out */   ASN1char_t         *lpUTF8Str,
    /* in */    ASN1int32_t         cchUTF8
)
{
    if (cchUTF8 >= 0)
    {
        ASN1int32_t cchRemainUTF8 = cchUTF8;

        if (cchWideChar < 0)
        {
            cchWideChar = My_lstrlenW(lpWideCharStr) + 1;
        }

        while (cchWideChar--)
        {
            WCHAR wch = *lpWideCharStr++;
            if (wch <= 0x7F)
            {
                // 7 bits
                cchRemainUTF8--;
                if (cchRemainUTF8 >= 0)
                {
                    *lpUTF8Str++ = (ASN1char_t) wch;
                }
            }
            else
            if (wch <= 0x7FF)
            {
                // 11 bits
                cchRemainUTF8 -= 2;
                if (cchRemainUTF8 >= 0)
                {
                    *lpUTF8Str++ = (ASN1char_t) (0xC0 | ((wch >> 6) & 0x1F));
                    *lpUTF8Str++ = (ASN1char_t) (0x80 | (wch & 0x3F));
                }
            }
            else
            {
                // 16 bits
                cchRemainUTF8 -= 3;
                if (cchRemainUTF8 >= 0)
                {
                    *lpUTF8Str++ = (ASN1char_t) (0xE0 | ((wch >> 12) & 0x0F));
                    *lpUTF8Str++ = (ASN1char_t) (0x80 | ((wch >> 6) & 0x3F));
                    *lpUTF8Str++ = (ASN1char_t) (0x80 | (wch & 0x3F));
                }
            }
        }

        if (cchRemainUTF8 >= 0)
        {
            return (cchUTF8 - cchRemainUTF8);
        }
        else
        if (cchUTF8 == 0)
        {
            return (-cchRemainUTF8);
        }
    }
    return 0;
}

//+-------------------------------------------------------------------------
//  Maps a UTF-8 encoded character string to a new wide-character (Unicode)
//  string.
// 
//  See CertWideCharToUTF8 for how the UTF-8 characters are mapped to wide
//  characters.
//
//  The parameter and return value semantics are the same as for the
//  Win32 API, MultiByteToWideChar.
//
//  If the UTF-8 characters don't contain the expected high order bits,
//  ERROR_INVALID_PARAMETER is set and 0 is returned.
//
//  Note, starting with NT 4.0, MultiByteToWideChar supports CP_UTF8. CP_UTF8
//  isn't supported on Win95.
//--------------------------------------------------------------------------
ASN1int32_t _UTF8ToWideChar
(
    /* in */    ASN1char_t         *lpUTF8Str,
    /* in */    ASN1int32_t         cchUTF8,
    /* out */   WCHAR              *lpWideCharStr,
    /* in */    ASN1int32_t         cchWideChar
)
{
    if (cchWideChar >= 0)
    {
        ASN1int32_t cchRemainWideChar = cchWideChar;

        if (cchUTF8 < 0)
        {
            cchUTF8 = My_lstrlenA(lpUTF8Str) + 1;
        }

        while (cchUTF8--)
        {
            ASN1char_t ch = *lpUTF8Str++;
            WCHAR wch;
            ASN1char_t ch2, ch3;

            if (0 == (ch & 0x80))
            {
                // 7 bits, 1 byte
                wch = (WCHAR) ch;
            }
            else
            if (0xC0 == (ch & 0xE0))
            {
                // 11 bits, 2 bytes
                if (--cchUTF8 >= 0)
                {
                    ch2 = *lpUTF8Str++;
                    if (0x80 == (ch2 & 0xC0))
                    {
                        wch = (((WCHAR) ch  & 0x1F) << 6) |
                               ((WCHAR) ch2 & 0x3F);
                    }
                    else
                    {
                        goto MyExit;
                    }
                }
                else
                {
                    goto MyExit;
                }
            }
            else
            if (0xE0 == (ch & 0xF0))
            {
                // 16 bits, 3 bytes
                cchUTF8 -= 2;
                if (cchUTF8 >= 0)
                {
                    ch2 = *lpUTF8Str++;
                    ch3 = *lpUTF8Str++;
                    if (0x80 == (ch2 & 0xC0) && 0x80 == (ch3 & 0xC0))
                    {
                        wch = (((WCHAR) ch  & 0x0F) << 12) |
                              (((WCHAR) ch2 & 0x3F) <<  6) |
                               ((WCHAR) ch3 & 0x3F);
                    }
                    else
                    {
                        goto MyExit;
                    }
                }
                else
                {
                    goto MyExit;
                }
            }
            else
            {
                goto MyExit;
            }

            if (--cchRemainWideChar >= 0)
            {
                *lpWideCharStr++ = wch;
            }
        }

        if (cchRemainWideChar >= 0)
        {
            return (cchWideChar - cchRemainWideChar);
        }
        else
        if (cchWideChar == 0)
        {
            return (-cchRemainWideChar);
        }
    }
MyExit:
    return 0;
}

#endif // 1

#endif // ENABLE_BER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\msasn1\ms_ut.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

#ifdef _DEBUG
void MyDebugBreak(void)
{
    // to correct the misleading stack dump
    DebugBreak();
}
#endif // _DEBUG

// Memory manager for decoder
#ifdef ENABLE_MEMORY_TRACKING
LPVOID DbgDecMemAlloc ( ASN1decoding_t dec, ASN1uint32_t cbSize, LPSTR pszFileName, ASN1uint32_t nLineNumber )
#else
LPVOID DecMemAlloc ( ASN1decoding_t dec, ASN1uint32_t cbSize )
#endif
{
    LPVOID lp = NULL;
    ASN1INTERNdecoding_t lpInfo = (ASN1INTERNdecoding_t) dec;
    // make sure the size is 4-byte aligned
    ASN1_SIZE_ALIGNED(cbSize);
    // accumulate the total size
    lpInfo->cbLinearBufSize += cbSize;
    // allocate the buffer
    if (lpInfo->fExtBuf)
    {
        if (lpInfo->cbRemExtBufSize >= cbSize)
        {
            lp = lpInfo->lpRemExtBuf;
            lpInfo->lpRemExtBuf += cbSize;
            lpInfo->cbRemExtBufSize -= cbSize;
        }
        else
        {
            DecAssert(dec, FALSE);
        }
    }
    else
    {
#ifdef ENABLE_MEMORY_TRACKING
        lp = DbgMemAlloc(cbSize, _ModName(dec), pszFileName, nLineNumber);
#else
        lp = MemAllocEx(dec, cbSize, TRUE); // zero memory
#endif
    }
    // make sure to propagate error
    if (lp == NULL)
    {
        ASN1DecSetError(dec, ASN1_ERR_MEMORY);
    }
    return lp;
}

void DecMemFree ( ASN1decoding_t dec, LPVOID lpData )
{
    if (! ((ASN1INTERNdecoding_t) dec)->fExtBuf)
    {
        MemFree(lpData);
    }
}

#ifdef ENABLE_MEMORY_TRACKING
LPVOID DbgDecMemReAlloc ( ASN1decoding_t dec, LPVOID lpData, ASN1uint32_t cbSize, LPSTR pszFileName, ASN1uint32_t nLineNumber )
#else
LPVOID DecMemReAlloc ( ASN1decoding_t dec, LPVOID lpData, ASN1uint32_t cbSize )
#endif
{
    LPVOID lp = NULL;
    // make sure the size is 4-byte aligned
    ASN1_SIZE_ALIGNED(cbSize);
    // accumulate the total size
    ((ASN1INTERNdecoding_t) dec)->cbLinearBufSize += cbSize;
    // allocate the buffer
    if (((ASN1INTERNdecoding_t) dec)->fExtBuf)
    {
        if (lpData == NULL)
        {
            lp = DecMemAlloc(dec, cbSize);
        }
        else
        {
            DecAssert(dec, FALSE);
        }
    }
    else
    {
#ifdef ENABLE_MEMORY_TRACKING
        lp = DbgMemReAlloc(lpData, cbSize, _ModName(dec), pszFileName, nLineNumber);
#else
        lp = MemReAllocEx(dec, lpData, cbSize, TRUE); // zero memory
#endif
    }
    // make sure to propagate error
    if (lp == NULL)
    {
        ASN1DecSetError(dec, ASN1_ERR_MEMORY);
    }
    return lp;
}



/***
*char *ms_bSearch() - do a binary search on an array
*
*Purpose:
*       Does a binary search of a sorted array for a key.
*
*Entry:
*       const char *key    - key to search for
*       const char *base   - base of sorted array to search
*       unsigned int num   - number of elements in array
*       unsigned int width - number of bytes per element
*       int (*compare)()   - pointer to function that compares two array
*               elements, returning neg when #1 < #2, pos when #1 > #2, and
*               0 when they are equal. Function is passed pointers to two
*               array elements.
*
*Exit:
*       if key is found:
*               returns pointer to occurrence of key in array
*       if key is not found:
*               returns NULL
*
*Exceptions:
*
*******************************************************************************/

void * ms_bSearch (
        const void *key,
        const void *base,
        size_t num,
        size_t width,
        int (__cdecl *compare)(const void *, const void *)
        )
{
        char *lo = (char *)base;
        char *hi = (char *)base + (num - 1) * width;
        char *mid;
        unsigned int half;
        int result;

        while (lo <= hi)
                if (half = num / 2)
                {
                        mid = lo + (num & 1 ? half : (half - 1)) * width;
                        if (!(result = (*compare)(key,mid)))
                                return(mid);
                        else if (result < 0)
                        {
                                hi = mid - width;
                                num = num & 1 ? half : half-1;
                        }
                        else    {
                                lo = mid + width;
                                num = half;
                        }
                }
                else if (num)
                        return((*compare)(key,lo) ? NULL : lo);
                else
                        break;

        return(NULL);
}


int IsDigit(char p)
{
      return ((p >= ('0')) && (p <=('9'))) ? 1 : 0 ;
}



// BUGBUG - This is a copy of the same routine in nmutil
// BUGBUG - Remove this when we convert our files to CPP and use nmutil
/*  D E C I M A L  S T R I N G  T O  U  I  N  T  */
/*-------------------------------------------------------------------------
    %%Function: DecimalStringToUINT
    
-------------------------------------------------------------------------*/
unsigned int  DecimalStringToUINT(char * pcszString, ASN1uint32_t cch)
{
	unsigned int uRet = 0;
	char * pszStr =  pcszString;
	while (cch-- && ('\0') != pszStr[0])
	{
		uRet = (10 * uRet) + (int) (pszStr[0] - ('0'));
		pszStr++; // NOTE: DBCS characters are not allowed!
	}
	return uRet;
}


#ifdef ENABLE_BER
int My_memcmp(ASN1octet_t *pBuf1, ASN1uint32_t cbBuf1Size, ASN1octet_t *pBuf2, ASN1uint32_t cbBuf2Size)
{
    int diff;
    ASN1uint32_t cbMinBufSize = (cbBuf1Size < cbBuf2Size) ? cbBuf1Size : cbBuf2Size;
    while (cbMinBufSize--)
    {
        diff = (int) (ASN1uint32_t) *pBuf1++ - (int) (ASN1uint32_t) *pBuf2++;
        if (0 != diff)
        {
            return diff;
        }
    }
    return ((int) cbBuf1Size - (int) cbBuf2Size);
}
#endif // ENABLE_BER


// THE FOLLOWING IS FROM ILS.DLL MEMORY TRACKING

#ifdef ENABLE_MEMORY_TRACKING

#ifndef _DEBUG
void MyDebugBreak(void)
{
    // to correct the misleading stack dump
    DebugBreak();
}
#endif // _DEBUG

#define KEEP_FREE_MEM

#define DBG_NAME_LENGTH     16
typedef struct tagMemTag
{
    DWORD           dwSignature;
    BOOL            fActive;
    ASN1uint32_t    nModuleName;
    CHAR            szFileName[DBG_NAME_LENGTH];
    UINT            nLineNumber;
    UINT            cbSize;
    struct tagMemTag *next;
}
    MEM_TAG;

static MEM_TAG *s_pDbgActiveMemPool = NULL;
#ifdef KEEP_FREE_MEM
static MEM_TAG *s_pDbgFreeMemPool = NULL;
#define FREE_BYTE   ((BYTE) 0xAB)
#define TAIL_BYTE   ((BYTE) 0xEF)
#define TAIL_SIZE   8
#endif
#define CLEAN_BYTE  ((BYTE) 0xCD)
static UINT   s_cDbgActiveMemAlloc = 0;
static UINT   s_cbDbgActiveMem = 0;
const DWORD MEM_TAG_SIGNATURE = 0x12345678UL;

static BOOL s_fDbgInitCritSect = FALSE;
static CRITICAL_SECTION s_DbgCritSect;

void DbgMemTrackReverseList(void)
{
    EnterCriticalSection(&s_DbgCritSect);
    if (NULL != s_pDbgActiveMemPool && NULL != s_pDbgActiveMemPool->next)
    {
        MEM_TAG *p, *q, *r;;

        for (q = (p = s_pDbgActiveMemPool)->next, r = q; // make sure r is not null in the beginning
             NULL != r;
             p = q, q = r)
        {
            r = q->next;
            q->next = p;
        }

        s_pDbgActiveMemPool->next = NULL;
        s_pDbgActiveMemPool = p;
    }
    LeaveCriticalSection(&s_DbgCritSect);
}

#define DBG_MEM_TRACK_DUMP_ALL      ((ASN1uint32_t) -1)

void ASN1DbgMemTrackDumpCurrent ( ASN1uint32_t nModuleName )
{
    MEM_TAG *p;
    int i;
    char szMod[8];
    char szBuf[128];
    EnterCriticalSection(&s_DbgCritSect);
    for (p = s_pDbgActiveMemPool, i = 0; p; p = p->next, i++)
    {
        if (nModuleName == DBG_MEM_TRACK_DUMP_ALL || p->nModuleName == nModuleName)
        {
            ZeroMemory(szMod, sizeof(szMod));
            CopyMemory(szMod, &p->nModuleName, sizeof(ASN1uint32_t));
            wsprintfA(szBuf, "ASN1: mem leak [%u]: mod=%s, file=%s, line=%u, size=%u, ptr=0x%lx\r\n",
                        i, szMod, p->szFileName, p->nLineNumber, p->cbSize, (ASN1uint32_t) (p+1));
            OutputDebugStringA(szBuf);
        }
    }
    LeaveCriticalSection(&s_DbgCritSect);
}

void DbgMemTrackFinalCheck ( void )
{
    DbgMemTrackReverseList();
    ASN1DbgMemTrackDumpCurrent(DBG_MEM_TRACK_DUMP_ALL);
    if (NULL != s_pDbgActiveMemPool ||
        0 != s_cDbgActiveMemAlloc ||
        0 != s_cbDbgActiveMem)
    {
        MyDebugBreak();
    }

    if (s_fDbgInitCritSect)
    {
        DeleteCriticalSection(&s_DbgCritSect);
        s_fDbgInitCritSect = FALSE;
    }
}

static void _GetFileName ( LPSTR pszTarget, LPSTR pszSrc )
{
    LPSTR psz = pszSrc;
    while (*psz != '\0')
    {
        if (*psz++ == '\\')
        {
            pszSrc = psz;
        }
    }
    lstrcpynA(pszTarget, pszSrc, DBG_NAME_LENGTH);
}

static BOOL _IsFilledMemory ( LPBYTE lpb, UINT cbSize, BYTE bPattern )
{
    while (cbSize--)
    {
        if (*lpb++ != bPattern)
            return FALSE;
    }
    return TRUE;
}

LPVOID DbgMemAlloc ( UINT cbSize, ASN1uint32_t nModuleName, LPSTR pszFileName, UINT nLineNumber )
{
    MEM_TAG *p;
    UINT cbToAlloc;

    if (! s_fDbgInitCritSect)
    {
        InitializeCriticalSection(&s_DbgCritSect);
        s_fDbgInitCritSect = TRUE;
    }

    cbToAlloc = sizeof(MEM_TAG) + cbSize;

    EnterCriticalSection(&s_DbgCritSect);

#ifdef KEEP_FREE_MEM
    // add the tail size
    cbToAlloc += TAIL_SIZE;

    // any heap corruption in free pool
    {
        const int c_cKept = 32;
        MEM_TAG *q = s_pDbgFreeMemPool;
        int i;
        for (i = 0; i < c_cKept; i++)
        {
            if (q == NULL)
                break;

            if (! _IsFilledMemory((LPBYTE) (q+1), q->cbSize, FREE_BYTE))
            {
                MyDebugBreak();
            }

            if (! _IsFilledMemory(((LPBYTE) (q+1)) + q->cbSize, TAIL_SIZE, TAIL_BYTE))
            {
                MyDebugBreak();
            }

            if (c_cKept == i)
            {
                MEM_TAG *x = q->next, *y;
                q->next = NULL;
                while (x)
                {
                    y = x->next;
                    LocalFree(x);
                    x = y;
                }
                break;
            }

            q = q->next;
        }
    }
#endif

    
    p = (MEM_TAG *) LocalAlloc(LPTR, cbToAlloc);
    if (p != NULL)
    {
        p->dwSignature = MEM_TAG_SIGNATURE;
        p->nModuleName = nModuleName;
        p->fActive = TRUE;
        _GetFileName(p->szFileName, pszFileName);
        p->nLineNumber = nLineNumber;
        p->cbSize = cbSize;
        p->next = s_pDbgActiveMemPool;
        s_pDbgActiveMemPool = p;
        s_cDbgActiveMemAlloc++;
        s_cbDbgActiveMem += p->cbSize;
#ifdef KEEP_FREE_MEM
        FillMemory((LPVOID) ((LPBYTE) (p+1) + p->cbSize), TAIL_SIZE, TAIL_BYTE);
#endif
        p++;

        // lonchanc; do not fill in some garbage, we must provide same semantics
        // for decoded buffers. all zeroed out.
        // fill in some garbage
        // FillMemory((LPVOID) p, cbSize, CLEAN_BYTE);
    }

    LeaveCriticalSection(&s_DbgCritSect);

    return (LPVOID) p;
}

void DbgMemFree ( LPVOID ptr )
{
    if (ptr != NULL)
    {
        MEM_TAG *p = (MEM_TAG *) ptr;
        MEM_TAG *q, *q0;
        p--;
        if (! IsBadWritePtr(p, sizeof(MEM_TAG)) &&
            p->dwSignature == MEM_TAG_SIGNATURE)
        {
            if (! p->fActive)
            {
                //
                // This memory has been freed already.
                //
                MyDebugBreak();
                return;
            }

            EnterCriticalSection(&s_DbgCritSect);
            for (q = s_pDbgActiveMemPool; q != NULL; q = (q0 = q)->next)
            {
                if (q == p)
                {
                    if (q == s_pDbgActiveMemPool)
                    {
                        s_pDbgActiveMemPool = p->next;
                    }
                    else
                    {
                        q0->next = p->next;
                    }
                    s_cDbgActiveMemAlloc--;
                    s_cbDbgActiveMem -= p->cbSize;
                    p->fActive = FALSE;

                    if (! _IsFilledMemory(((LPBYTE) (p+1)) + p->cbSize, TAIL_SIZE, TAIL_BYTE))
                    {
                        MyDebugBreak();
                    }
#ifdef KEEP_FREE_MEM
                    // put in the free pool
                    p->next = s_pDbgFreeMemPool;
                    s_pDbgFreeMemPool = p;
                    FillMemory(p+1, p->cbSize, FREE_BYTE);
#endif
                    break;
                }
            }
            LeaveCriticalSection(&s_DbgCritSect);
        }
        else
        {
            p++;
            MyDebugBreak();
        }
#ifndef KEEP_FREE_MEM
        LocalFree(p);
#endif
    }
}

LPVOID DbgMemReAlloc ( LPVOID ptr, UINT cbSize, ASN1uint32_t nModuleName, LPSTR pszFileName, UINT nLineNumber )
{
    MEM_TAG *p;
    void *q;

    if (ptr == NULL)
        return DbgMemAlloc(cbSize, nModuleName, pszFileName, nLineNumber);

    p = (MEM_TAG *) ptr;
    p--;

    if (IsBadWritePtr(p, sizeof(MEM_TAG)) ||
        p->dwSignature != MEM_TAG_SIGNATURE)
    {
        MyDebugBreak();
        return LocalReAlloc(ptr, cbSize, LMEM_MOVEABLE|LMEM_ZEROINIT);
    }

    q = DbgMemAlloc(cbSize, nModuleName, pszFileName, nLineNumber);
    if (q != NULL)
    {
        CopyMemory(q, ptr, p->cbSize);
        DbgMemFree(ptr);
    }

    return q;
}

#endif // ENABLE_MEMORY_TRACKING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\msasn1\nm_ber.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"


// THE FOLLOWING IS FROM BERENCOD.C

/* get the expected length based on the table */
ASN1uint32_t _BERGetLength(ASN1uint32_t val, const ASN1uint32_t Tbl[], ASN1uint32_t cItems)
{
    ASN1uint32_t i;
    for (i = 0; i < cItems; i++)
    {
        if (val < Tbl[i])
            return i+1;
    }
    return cItems+1;
}

static const ASN1uint32_t c_TagTable[] = { 31, 0x80, 0x4000, 0x200000, 0x10000000 };

/* encode a tag */
int ASN1BEREncTag(ASN1encoding_t enc, ASN1uint32_t tag)
{
    ASN1uint32_t tagclass, tagvalue, cbTagLength;

    tagclass = (tag >> 24) & 0xe0;
    tagvalue = tag & 0x1fffffff;

    cbTagLength = _BERGetLength(tagvalue, c_TagTable, ARRAY_SIZE(c_TagTable));
    if (ASN1BEREncCheck(enc, cbTagLength))
    {
        if (cbTagLength == 1)
        {
            *enc->pos++ = (ASN1octet_t)(tagclass | tagvalue);
        }
        else
        {
            *enc->pos++ = (ASN1octet_t)(tagclass | 0x1f);
            switch (cbTagLength)
            {
            case 6:
                *enc->pos++ = (ASN1octet_t)((tagvalue >> 28) | 0x80);
                // lonchanc: intentionally fall through
            case 5:
                *enc->pos++ = (ASN1octet_t)((tagvalue >> 21) | 0x80);
                // lonchanc: intentionally fall through
            case 4:
                *enc->pos++ = (ASN1octet_t)((tagvalue >> 14) | 0x80);
                // lonchanc: intentionally fall through
            case 3:
                *enc->pos++ = (ASN1octet_t)((tagvalue >> 7) | 0x80);
                // lonchanc: intentionally fall through
            case 2:
                *enc->pos++ = (ASN1octet_t)(tagvalue & 0x7f);
                break;
            }
        }
        return 1;
    }
    return 0;
}

/* put the length value */
void _BERPutLength(ASN1encoding_t enc, ASN1uint32_t len, ASN1uint32_t cbLength)
{
    if (cbLength > 1)
    {
        *enc->pos++ = (ASN1octet_t) (0x7f + cbLength); // 0x80 + cbLength - 1;
    }

    switch (cbLength)
    {
    case 5:
        *enc->pos++ = (ASN1octet_t)(len >> 24);
        // lonchanc: intentionally fall through
    case 4:
        *enc->pos++ = (ASN1octet_t)(len >> 16);
        // lonchanc: intentionally fall through
    case 3:
        *enc->pos++ = (ASN1octet_t)(len >> 8);
        // lonchanc: intentionally fall through
    default: // case 2: case 1:
        *enc->pos++ = (ASN1octet_t)len;
        break;
    }
}

static const ASN1uint32_t c_LengthTable[] = { 0x80, 0x100, 0x10000, 0x1000000 };

/* encode length */
int ASN1BEREncLength(ASN1encoding_t enc, ASN1uint32_t len)
{
    ASN1uint32_t cbLength = _BERGetLength(len, c_LengthTable, ARRAY_SIZE(c_LengthTable));

    if (ASN1BEREncCheck(enc, cbLength + len))
    {
        _BERPutLength(enc, len, cbLength);
        return 1;
    }
    return 0;
}

/* encode an octet string value */
int ASN1BEREncOctetString(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t len, ASN1octet_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        if (ASN1BEREncLength(enc, len))
        {
            /* copy value */
            CopyMemory(enc->pos, val, len);
            enc->pos += len;
            return 1;
        }
    }
    return 0;
}

/* encode a boolean value */
int ASN1BEREncBool(ASN1encoding_t enc, ASN1uint32_t tag, ASN1bool_t val)
{
    if (ASN1BEREncTag(enc, tag))
    {
        if (ASN1BEREncLength(enc, 1))
        {
            *enc->pos++ = val ? 0xFF : 0;
            return 1;
        }
    }
    return 0;
}

static const c_U32LengthTable[] = { 0x80, 0x8000, 0x800000, 0x80000000 };

/* encode a unsigned integer value */
int ASN1BEREncU32(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t val)
{
    EncAssert(enc, tag != 0x01);
    if (ASN1BEREncTag(enc, tag))
    {
        ASN1uint32_t cbLength;
        cbLength = _BERGetLength(val, c_U32LengthTable, ARRAY_SIZE(c_U32LengthTable));
        if (ASN1BEREncLength(enc, cbLength))
        {
            switch (cbLength)
            {
            case 5:
                *enc->pos++ = 0;
                // lonchanc: intentionally fall through
            case 4:
                *enc->pos++ = (ASN1octet_t)(val >> 24);
                // lonchanc: intentionally fall through
            case 3:
                *enc->pos++ = (ASN1octet_t)(val >> 16);
                // lonchanc: intentionally fall through
            case 2:
                *enc->pos++ = (ASN1octet_t)(val >> 8);
                // lonchanc: intentionally fall through
            case 1:
                *enc->pos++ = (ASN1octet_t)(val);
                break;
            }
            return 1;
        }
    }
    return 0;
}


// THE FOLLOWING IS FROM BERDECOD.C


/* check if len octets are left in decoding stream */
int ASN1BERDecCheck(ASN1decoding_t dec, ASN1uint32_t len)
{
    if (dec->pos + len <= dec->buf + dec->size)
    {
        return 1;
    }

    ASN1DecSetError(dec, ASN1_ERR_EOD);
    return 0;
}

int _BERDecPeekCheck(ASN1decoding_t dec, ASN1uint32_t len)
{
    return ((dec->pos + len <= dec->buf + dec->size) ? 1 : 0);
}

/* start decoding of a constructed value */
int _BERDecConstructed(ASN1decoding_t dec, ASN1uint32_t len, ASN1uint32_t infinite, ASN1decoding_t *dd, ASN1octet_t **ppBufEnd)
{
    // safety net
    DecAssert(dec, NULL != dd);
    *dd = dec;

#if 0 // NO_NESTED_DECODING
    // lonchanc: this does not work because open type can be the last component and
    // the open type decoder needs to peek a tag. as a result, we may peek the tag
    // outside the buffer boundary.
    if (ppBufEnd && (! infinite))
    {
        *ppBufEnd = dec->pos + len;
        return 1;
    }
#endif

    /* initialize a new decoding stream as child of running decoding stream */
    if (ASN1_CreateDecoder(dec->module, dd,
        dec->pos, infinite ? dec->size - (ASN1uint32_t) (dec->pos - dec->buf) : len, dec) >= 0)
    {
        /* set pointer to end of decoding stream if definite length case selected */
        *ppBufEnd = infinite ? NULL : (*dd)->buf + (*dd)->size;
        return 1;
    }
    return 0;
}

/* decode a tag value; return constructed bit if desired */
int ASN1BERDecTag(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint32_t *constructed)
{
    ASN1uint32_t tagvalue, tagclass, c;

    /* get tag class and value */
    if (ASN1BERDecCheck(dec, 1))
    {
        tagclass = *dec->pos & 0xe0;
        tagvalue = *dec->pos++ & 0x1f;
        if (tagvalue == 0x1f)
        {
            tagvalue = 0;
            do {
                if (ASN1BERDecCheck(dec, 1))
                {
                    c = *dec->pos++;
                    if (! (tagvalue & 0xe0000000))
                    {
                        tagvalue = (tagvalue << 7) | (c & 0x7f);
                    }
                    else
                    {
                        ASN1DecSetError(dec, ASN1_ERR_BADTAG);
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            } while (c & 0x80);
        }

        /* extract constructed bit if wanted */
        if (constructed)
        {
            *constructed = tagclass & 0x20;
            tagclass &= ~0x20;
        }

        /* check if tag equals desires */
        if (tag == ((tagclass << 24) | tagvalue))
        {
            return 1;
        }

        ASN1DecSetError(dec, ASN1_ERR_BADTAG);
    }
    return 0;
}

/* decode length */
int ASN1BERDecLength(ASN1decoding_t dec, ASN1uint32_t *len, ASN1uint32_t *infinite)
{
    // default is definite length
    if (infinite)
    {
        *infinite = 0;
    }

    /* get length and infinite flag */
    if (ASN1BERDecCheck(dec, 1))
    {
        ASN1uint32_t l = *dec->pos++;
        if (l < 0x80)
        {
            *len = l;
        }
        else
        if (l == 0x80)
        {
            *len = 0;
            if (infinite)
            {
                *infinite = 1;
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
        else
        if (l <= 0x84)
        {
            ASN1uint32_t i = l - 0x80;
            if (ASN1BERDecCheck(dec, i))
            {
                l = 0;
                switch (i)
                {
                case 4:
                    l = *dec->pos++ << 24;
                    /*FALLTHROUGH*/
                case 3:
                    l |= *dec->pos++ << 16;
                    /*FALLTHROUGH*/
                case 2:
                    l |= *dec->pos++ << 8;
                    /*FALLTHROUGH*/
                case 1:
                    l |= *dec->pos++;
                    break;
                }
                *len = l;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }

        /* check if enough octets left if length is known */
        if (!infinite || !*infinite)
        {
            return ASN1BERDecCheck(dec, *len);
        }
        return 1;
    }

    return 0;
}

/* decode an explicit tag */
int ASN1BERDecExplicitTag(ASN1decoding_t dec, ASN1uint32_t tag, ASN1decoding_t *dd, ASN1octet_t **ppBufEnd)
{
    ASN1uint32_t len, infinite, constructed;

    // safety net
    if (dd)
    {
        *dd = dec;
    }

    /* skip the constructed tag */
    if (ASN1BERDecTag(dec, tag | 0x20000000, NULL))
    {
        /* get the length */
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            /* start decoding of constructed value */
            if (! dd)
            {
                *ppBufEnd = infinite ? NULL : dec->pos + len;
                return 1;
            }
            return _BERDecConstructed(dec, len, infinite, dd, ppBufEnd);
        }
    }
    return 0;
}

/* decode octet string value */
int _BERDecOctetString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val, ASN1uint32_t fNoCopy)
{
    ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t)dec;
    ASN1uint32_t constructed, len, infinite;
    ASN1decoding_t dd;
    ASN1octet_t *di;

    if (ASN1BERDecTag(dec, tag, &constructed))
    {
        if (ASN1BERDecLength(dec, &len, &infinite))
        {
            if (! constructed)
            {
                val->length = len;
                if (fNoCopy)
                {
                    val->value = dec->pos;
                    dec->pos += len;
                    return 1;
                }
                else
                {
                    if (len)
                    {
                        val->value = (ASN1octet_t *)DecMemAlloc(dec, len);
                        if (val->value)
                        {
                            CopyMemory(val->value, dec->pos, len);
                            dec->pos += len;
                            return 1;
                        }
                    }
                    else
                    {
                        val->value = NULL;
                        return 1;
                    }
                }
            }
            else
            {
                ASN1octetstring_t o;
                val->length = 0;
                val->value = NULL;
                if (_BERDecConstructed(dec, len, infinite, &dd, &di))
                {
                    while (ASN1BERDecNotEndOfContents(dd, di))
                    {
                        o.length = 0;
                        o.value = NULL;
                        if (_BERDecOctetString(dd, 0x4, &o, fNoCopy))
                        {
                            if (o.length)
                            {
                                if (fNoCopy)
                                {
                                    *val = o;
                                    break; // break out the loop because nocopy cannot have multiple constructed streams
                                }

                                /* resize value */
                                val->value = (ASN1octet_t *)DecMemReAlloc(dd, val->value,
                                                                val->length + o.length);
                                if (val->value)
                                {
                                    /* concat octet strings */
                                    CopyMemory(val->value + val->length, o.value, o.length);
                                    val->length += o.length;

                                    /* free unused octet string */
                                    DecMemFree(dec, o.value);
                                }
                                else
                                {
                                    return 0;
                                }
                            }
                        }
                    }
                    return ASN1BERDecEndOfContents(dec, dd, di);
                }
            }
        }
    }
    return 0;
}

/* decode octet string value, making copy */
int ASN1BERDecOctetString(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val)
{
    return _BERDecOctetString(dec, tag, val, FALSE);
}

/* decode octet string value, no copy */
int ASN1BERDecOctetString2(ASN1decoding_t dec, ASN1uint32_t tag, ASN1octetstring_t *val)
{
    return _BERDecOctetString(dec, tag, val, TRUE);
}

/* peek the following tag without advancing the read position */
int ASN1BERDecPeekTag(ASN1decoding_t dec, ASN1uint32_t *tag)
{
    ASN1uint32_t tagvalue, tagclass, c;
    ASN1octet_t *p;

    *tag = 0; // invalid tag
    if (_BERDecPeekCheck(dec, 1))
    {
        p = dec->pos;

        /* get tagclass without primitive/constructed bit */
        tagclass = *dec->pos & 0xc0;

        /* get tag value */
        tagvalue = *dec->pos++ & 0x1f;
        if (tagvalue == 0x1f)
        {
            tagvalue = 0;
            do {
                if (_BERDecPeekCheck(dec, 1))
                {
                    c = *dec->pos++;
                    if (! (tagvalue & 0xe0000000))
                    {
                        tagvalue = (tagvalue << 7) | (c & 0x7f);
                    }
                    else
                    {
                        ASN1DecSetError(dec, ASN1_ERR_BADTAG);
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            } while (c & 0x80);
        }

        /* return tag */
        *tag = ((tagclass << 24) | tagvalue);

        /* reset decoding position */
        dec->pos = p;
        return 1;
    }
    return 0;
}

/* decode boolean into ASN1boot_t */
int ASN1BERDecBool(ASN1decoding_t dec, ASN1uint32_t tag, ASN1bool_t *val)
{
    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        /* get length */
        ASN1uint32_t len;
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            if (len >= 1)
            {
                DecAssert(dec, len == 1);
                *val = *dec->pos ? 1 : 0;
                dec->pos += len; // self defensive
                return 1;
            }
        }
    }
    return 0;
}

/* decode integer into unsigned 32 bit value */
int ASN1BERDecU32Val(ASN1decoding_t dec, ASN1uint32_t tag, ASN1uint32_t *val)
{
    ASN1uint32_t len;

    /* skip tag */
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        /* get length */
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            /* get value */
            if (len >= 1)
            {
                switch (len)
                {
                case 1:
                    *val = *dec->pos++;
                    break;
                case 2:
                    *val = (*dec->pos << 8) | dec->pos[1];
                    dec->pos += 2;
                    break;
                case 3:
                    *val = (*dec->pos << 16) | (dec->pos[1] << 8) | dec->pos[2];
                    dec->pos += 3;
                    break;
                case 4:
                    *val = (*dec->pos << 24) | (dec->pos[1] << 16) |
                        (dec->pos[2] << 8) | dec->pos[3];
                    dec->pos += 4;
                    break;
                case 5:
                    if (! *dec->pos)
                    {
                        *val = (dec->pos[1] << 24) | (dec->pos[2] << 16) |
                            (dec->pos[3] << 8) | dec->pos[4];
                        dec->pos += 5;
                        break;
                    }
                    // intentionally fall through
                default:
                    ASN1DecSetError(dec, ASN1_ERR_LARGE);
                    return 0;
                }
                return 1;
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
    }
    return 0;
}

int ASN1BERDecEndOfContents(ASN1decoding_t dec, ASN1decoding_t dd, ASN1octet_t *pBufEnd)
{
    ASN1error_e err = ASN1_ERR_CORRUPT;

    if (! dd)
    {
        dd = dec;
    }

    DecAssert(dec, NULL != dd);

    if (pBufEnd)
    {
        /* end of definite length case: */
        /* check if decoded up to end of contents */
        if (dd->pos == pBufEnd)
        {
            dec->pos = pBufEnd;
            err = ASN1_SUCCESS;
        }
    }
    else
    {
        /* end of infinite length case: */
        /* expect end-of-contents octets */
        if (ASN1BERDecCheck(dd, 2))
        {
            if (0 == dd->pos[0] && 0 == dd->pos[1])
            {
                dd->pos += 2;
                if (dd != dec)
                {
                    /* finit child decoding stream and update parent decoding stream */
                    dec->pos = dd->pos;
                }
                err = ASN1_SUCCESS;
            }
        }
        else
        {
            err = ASN1_ERR_EOD;
        }
    }

    if (dd && dd != dec)
    {
        ASN1_CloseDecoder(dd);
    }

    if (ASN1_SUCCESS == err)
    {
        return 1;
    }

    ASN1DecSetError(dec, err);
    return 0;
}

/* check if end of contents (of a constructed value) has been reached */
int ASN1BERDecNotEndOfContents(ASN1decoding_t dec, ASN1octet_t *pBufEnd)
{
    return (pBufEnd ?
                (dec->pos < pBufEnd) :
                (ASN1BERDecCheck(dec, 2) && (dec->pos[0] || dec->pos[1])));
}


#ifdef ENABLE_BER

typedef struct
{
    ASN1octet_t        *pBuf;
    ASN1uint32_t        cbBufSize;
}
    CER_BLK_BUF;

typedef struct
{
    ASN1blocktype_e     eBlkType;
    ASN1encoding_t      encPrimary;
    ASN1encoding_t      encSecondary;
    ASN1uint32_t        nMaxBlkSize;
    ASN1uint32_t        nCurrBlkSize;
    CER_BLK_BUF        *aBlkBuf;
}
    CER_BLOCK;

#define MAX_INIT_BLK_SIZE   16

int ASN1CEREncBeginBlk(ASN1encoding_t enc, ASN1blocktype_e eBlkType, void **ppBlk_)
{
    CER_BLOCK *pBlk = (CER_BLOCK *) EncMemAlloc(enc, sizeof(CER_BLOCK));
    if (NULL != pBlk)
    {
        EncAssert(enc, ASN1_DER_SET_OF_BLOCK == eBlkType);
        pBlk->eBlkType = eBlkType;
        pBlk->encPrimary = enc;
        pBlk->encSecondary = NULL;
        pBlk->nMaxBlkSize = MAX_INIT_BLK_SIZE;
        pBlk->nCurrBlkSize = 0;
        pBlk->aBlkBuf = (CER_BLK_BUF *)EncMemAlloc(enc, MAX_INIT_BLK_SIZE * sizeof(CER_BLK_BUF));
        if (NULL != pBlk->aBlkBuf)
        {
            *ppBlk_ = (void *) pBlk;
            return 1;
        }
        EncMemFree(enc, pBlk);
    }
    return 0;
}

int ASN1CEREncNewBlkElement(void *pBlk_, ASN1encoding_t *enc2)
{
    CER_BLOCK *pBlk = (CER_BLOCK *) pBlk_;
    if (NULL == pBlk->encSecondary)
    {
        if (ASN1_SUCCESS == ASN1_CreateEncoder(pBlk->encPrimary->module,
                                               &(pBlk->encSecondary),
                                               NULL, 0, pBlk->encPrimary))
        {
            pBlk->encSecondary->eRule = pBlk->encPrimary->eRule;
            *enc2 = pBlk->encSecondary;
            return 1;
        }
    }
    else
    {
        ASN1INTERNencoding_t e = (ASN1INTERNencoding_t) (*enc2 = pBlk->encSecondary);

        ZeroMemory(e, sizeof(*e));
        e->info.magic = MAGIC_ENCODER;
        // e->info.err = ASN1_SUCCESS;
        // e->info.pos = e->info.buf = NULL;
        // e->info.size = e->info.len = e->info.bit = 0;
        // e->info.dwFlags = 0;
        e->info.module = pBlk->encPrimary->module;
        e->info.eRule = pBlk->encPrimary->eRule;

        ((ASN1INTERNencoding_t) pBlk->encPrimary)->child = e;
        e->parent = (ASN1INTERNencoding_t) pBlk->encPrimary;
        // e->child = NULL;

        // e->mem = NULL;
        // e->memlength = 0;
        // e->memsize = 0;
        // e->epi = NULL;
        // e->epilength = 0;
        // e->episize = 0;
        // e->csi = NULL;
        // e->csilength = 0;
        // e->csisize = 0;

        if (ASN1BEREncCheck((ASN1encoding_t) e, 1))
        {
            // lonchanc: make sure the first byte is zeroed out, which
            // is required for h245.
            e->info.buf[0] = '\0';
            return 1;
        }
    }

    *enc2 =  NULL;
    return 0;
}

int ASN1CEREncFlushBlkElement(void *pBlk_)
{
    CER_BLOCK *pBlk = (CER_BLOCK *) pBlk_;
    ASN1encoding_t enc = pBlk->encSecondary;
    ASN1uint32_t i;

    if (ASN1BEREncFlush(enc))
    {
        // make sure we have enough space...
        if (pBlk->nCurrBlkSize >= pBlk->nMaxBlkSize)
        {
            CER_BLK_BUF *aBlkBuf = (CER_BLK_BUF *)EncMemAlloc(pBlk->encPrimary, (pBlk->nMaxBlkSize << 1) * sizeof(CER_BLK_BUF));
            if (NULL != aBlkBuf)
            {
                CopyMemory(aBlkBuf, pBlk->aBlkBuf, pBlk->nMaxBlkSize * sizeof(CER_BLK_BUF));
                EncMemFree(pBlk->encPrimary, pBlk->aBlkBuf);
                pBlk->aBlkBuf = aBlkBuf;
                pBlk->nMaxBlkSize <<= 1;
            }
            else
            {
                return 0;
            }
        }

        if (pBlk->encPrimary->eRule & (ASN1_BER_RULE_DER | ASN1_BER_RULE_CER))
        {
            // we need to sort these octet strings
            for (i = 0; i < pBlk->nCurrBlkSize; i++)
            {
                if (0 >= My_memcmp(enc->buf, enc->len, pBlk->aBlkBuf[i].pBuf, pBlk->aBlkBuf[i].cbBufSize))
                {
                    ASN1uint32_t cnt = pBlk->nCurrBlkSize - i;
                    ASN1uint32_t j;
                    for (j = pBlk->nCurrBlkSize; cnt--; j--)
                    {
                        pBlk->aBlkBuf[j] = pBlk->aBlkBuf[j-1];
                    }
                    // i is the place to hold the new one
                    break;
                }
            }
        }
        else
        {
            EncAssert(enc, ASN1_BER_RULE_BER == pBlk->encPrimary->eRule);
            i = pBlk->nCurrBlkSize;
        }

        // remeber the new one.
        pBlk->aBlkBuf[i].pBuf = enc->buf;
        pBlk->aBlkBuf[i].cbBufSize = enc->len;
        pBlk->nCurrBlkSize++;
        
        // clean up the encoder structure
        enc->buf = enc->pos = NULL;
        enc->size = enc->len = 0;
        return 1;
    }
    return 0;
}

int ASN1CEREncEndBlk(void *pBlk_)
{
    CER_BLOCK *pBlk = (CER_BLOCK *) pBlk_;
    ASN1encoding_t enc = pBlk->encPrimary;
    ASN1uint32_t cbTotalSize = 0;
    ASN1uint32_t i;
    int fRet = 0;

    // calculate the total size for all the buffers.
    for (i = 0; i < pBlk->nCurrBlkSize; i++)
    {
        cbTotalSize += pBlk->aBlkBuf[i].cbBufSize;
    }

    if (ASN1BEREncCheck(enc, cbTotalSize))
    {
        for (i = 0; i < pBlk->nCurrBlkSize; i++)
        {
            ASN1uint32_t cbBufSize = pBlk->aBlkBuf[i].cbBufSize;
            CopyMemory(enc->pos, pBlk->aBlkBuf[i].pBuf, cbBufSize);
            enc->pos += cbBufSize;
        }
        fRet = 1;
    }

    // free these block buffers.
    for (i = 0; i < pBlk->nCurrBlkSize; i++)
    {
        EncMemFree(enc, pBlk->aBlkBuf[i].pBuf);
    }

    // free the block buffer array
    EncMemFree(enc, pBlk->aBlkBuf);

	// free the secondary encoder structure
	ASN1_CloseEncoder(pBlk->encSecondary);

    // free the block structure itself.
    EncMemFree(enc, pBlk);

    return fRet;
}

#endif // ENABLE_BER

/* encode explicit tag */
int ASN1BEREncExplicitTag(ASN1encoding_t enc, ASN1uint32_t tag, ASN1uint32_t *pnLenOff)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag | 0x20000000))
    {
        /* encode infinite length */
        if (ASN1BEREncCheck(enc, 1))
        {
            if (ASN1_BER_RULE_CER != enc->eRule)
            {
                // BER and DER always use definite length form.
                /* return the place to hold the length */
                *pnLenOff = (ASN1uint32_t) (enc->pos++ - enc->buf);
            }
            else
            {
                // CER sub-rule always use indefinite length form.
                *enc->pos++ = 0x80;
                *pnLenOff = 0;
            }
            return 1;
        }
    }
    return 0;
}

/* encode definite length */
int ASN1BEREncEndOfContents(ASN1encoding_t enc, ASN1uint32_t nLenOff)
{
    if (ASN1_BER_RULE_CER != enc->eRule)
    {
        ASN1octet_t *pbLen = enc->buf + nLenOff;
        ASN1uint32_t len = (ASN1uint32_t) (enc->pos - pbLen - 1);
        ASN1uint32_t cbLength = _BERGetLength(len, c_LengthTable, ARRAY_SIZE(c_LengthTable));

        ASN1uint32_t i;

        if (cbLength == 1)
        {
            *pbLen = (ASN1octet_t) len;
            return 1;
        }

        // we have to move the octets upward by cbLength-1
        // --cbLength;
        if (ASN1BEREncCheck(enc, cbLength-1))
        {
            // update pbLen because enc->buf may change due to realloc.
            pbLen = enc->buf + nLenOff;

            // move memory
            MoveMemory(pbLen + cbLength, pbLen + 1, len);

            // put the length
            enc->pos = pbLen;
            _BERPutLength(enc, len, cbLength);
            EncAssert(enc, enc->pos == pbLen + cbLength);

            // set up new position pointer.
            // now enc->pos is at the beginning of contents.
            enc->pos += len;
            return 1;
        }
    }
    else
    {
        EncAssert(enc, 0 == nLenOff);
        if (ASN1BEREncCheck(enc, 2))
        {
            *enc->pos++ = 0;
            *enc->pos++ = 0;
            return 1;
        }
    }
    return 0;
}


// The following is for CryptoAPI

#ifdef ENABLE_BER

#include <stdlib.h>

 // max num of octets, ceiling of 64 / 7, is 10
#define MAX_BYTES_PER_NODE      10

ASN1uint32_t _BEREncOidNode64(ASN1encoding_t enc, unsigned __int64 n64, ASN1octet_t *pOut)
{
    ASN1uint32_t Low32, i, cb;
    ASN1octet_t aLittleEndian[MAX_BYTES_PER_NODE];

    ZeroMemory(aLittleEndian, sizeof(aLittleEndian));
    for (i = 0; n64 != 0; i++)
    {
        Low32 = *(ASN1uint32_t *) &n64;
        aLittleEndian[i] = (ASN1octet_t) (Low32 & 0x7f);
        n64 = Int64ShrlMod32(n64, 7);
    }
    cb = i ? i : 1; // at least one byte for zero value
    EncAssert(enc, cb <= MAX_BYTES_PER_NODE);
    for (i = 0; i < cb; i++)
    {
        EncAssert(enc, 0 == (0x80 & aLittleEndian[cb - i - 1]));
        *pOut++ = (ASN1octet_t) (0x80 | aLittleEndian[cb - i - 1]);
    }
    *(pOut-1) &= 0x7f;
    return cb;
}

int ASN1BERDotVal2Eoid(ASN1encoding_t enc, char *pszDotVal, ASN1encodedOID_t *pOut)
{
    ASN1uint32_t cNodes, cbMaxSize, cb1, cb2;
    char *psz;

    // calculate how many nodes, at least 1.
    for (cNodes = 0, psz = pszDotVal; NULL != psz; cNodes++)
    {
        psz = strchr(psz, '.');
        if (psz)
        {
            psz++;
        }
    }

    // calculate how many bytes should be allocated
    cb1 = My_lstrlenA(pszDotVal);
    cb2 = cNodes * MAX_BYTES_PER_NODE;
    cbMaxSize = (cb1 > cb2) ? cb1 : cb2;

    // allocate buffer
    pOut->length = 0; // safety net
    pOut->value = (ASN1octet_t *) EncMemAlloc(enc, cbMaxSize);
    if (pOut->value)
    {
        ASN1octet_t *p = pOut->value;
        ASN1uint32_t i;
        unsigned __int64 n64;
        psz = pszDotVal;
        for (i = 0; i < cNodes; i++)
        {
            EncAssert(enc, NULL != psz);
            n64 = (unsigned __int64) _atoi64(psz);
            psz = strchr(psz, '.') + 1;
            if (0 == i && cNodes > 1)
            {
                i++;
                n64 = n64 * 40 + (unsigned __int64) _atoi64(psz);
                psz = strchr(psz, '.') + 1;
            }

            p += _BEREncOidNode64(enc, n64, p);
        }
        pOut->length = (ASN1uint16_t) (p - pOut->value);
        EncAssert(enc, pOut->length <= cbMaxSize);
        return 1;
    }
    pOut->length = 0;
    return 0;
}


ASN1uint32_t _BERDecOidNode64(unsigned __int64 *pn64, ASN1octet_t *pIn)
{
    ASN1uint32_t c;
    *pn64 = 0;
    for (c = 1; TRUE; c++)
    {
        *pn64 = Int64ShllMod32(*pn64, 7) + (unsigned __int64) (*pIn & 0x7f);
        if (!(*pIn++ & 0x80))
        {
            return c;
        }
    }
    return 0;
}
    
int ASN1BEREoid2DotVal(ASN1decoding_t dec, ASN1encodedOID_t *pIn, char **ppszDotVal)
{
    ASN1octet_t *p;
    ASN1uint32_t i, cNodes, cb, n32;
    unsigned __int64 n64;
    char *psz;
    char szBuf[256]; // should be large enough

    // null out return value
    *ppszDotVal = NULL;

    if (NULL == dec)
    {
        return 0;
    }

    // calculate how many nodes
    cNodes = 0;
    for (p = pIn->value, i = 0; i < pIn->length; p++, i++)
    {
        if (!(*p & 0x80))
        {
            cNodes++;
        }
    }

    if (cNodes++) // first encoded node consists of two nodes
    {
        // decode nodes one by one
        psz = &szBuf[0];
        p = pIn->value;
        for (i = 0; i < cNodes; i++)
        {
            p += _BERDecOidNode64(&n64, p);
            if (!i)
            { // first node
                n32 = (ASN1uint32_t) (n64 / 40);
                if (n32 > 2)
                {
                    n32 = 2;
                }
                n64 -= (unsigned __int64) (40 * n32);
                i++; // first encoded node actually consists of two nodes
                _ultoa(n32, psz, 10);
                psz += lstrlenA(psz);
                *psz++ = '.';
            }
            _ui64toa(n64, psz, 10);
            psz += lstrlenA(psz);
            *psz++ = '.';
        }
        DecAssert(dec, psz > &szBuf[0]);
        *(psz-1) = '\0';

        // duplicate the string
        cb = (ASN1uint32_t) (psz - &szBuf[0]);
        *ppszDotVal = (char *) DecMemAlloc(dec, cb);
        if (*ppszDotVal)
        {
            CopyMemory(*ppszDotVal, &szBuf[0], cb);
            return 1;
        }
    }
    return 0;
}


/* encode an object identifier value */
int ASN1BEREncEoid(ASN1encoding_t enc, ASN1uint32_t tag, ASN1encodedOID_t *val)
{
    /* encode tag */
    if (ASN1BEREncTag(enc, tag))
    {
        /* encode length */
        int rc = ASN1BEREncLength(enc, val->length);
        if (rc)
        {
            /* copy value */
            CopyMemory(enc->pos, val->value, val->length);
            enc->pos += val->length;
        }
        return rc;
    }
    return 0;
}

/* decode object identifier value */
int ASN1BERDecEoid(ASN1decoding_t dec, ASN1uint32_t tag, ASN1encodedOID_t *val)
{
    val->length = 0; // safety net
    if (ASN1BERDecTag(dec, tag, NULL))
    {
        ASN1uint32_t len;
        if (ASN1BERDecLength(dec, &len, NULL))
        {
            val->length = (ASN1uint16_t) len;
            if (len)
            {
                val->value = (ASN1octet_t *) DecMemAlloc(dec, len);
                if (val->value)
                {
                    CopyMemory(val->value, dec->pos, len);
                    dec->pos += len;
                    return 1;
                }
            }
            else
            {
                val->value = NULL;
                return 1;
            }
        }
    }
    return 0;
}


void ASN1BEREoid_free(ASN1encodedOID_t *val)
{
    if (val)
    {
        MemFree(val->value);
    }
}


#endif // ENABLE_BER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\msasn1\perdecod.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

// lonchanc: things to optimize
// (1) merge ASN1PERDecCharString() and ASN1PERDecZeroCharString().
// (2) merge ASN1PERDecChar16String() and ASN1PERDecZeroChar16String().
// (3) merge ASN1PERDecChar32String() and ASN1PERDecZeroChar32String().
// (4) merge ASN1PERDecTableCharString() and ASN1PERDecZeroTableCharString().
// (5) merge ASN1PERDecTableChar16String() and ASN1PERDecZeroTableChar16String().
// (6) merge ASN1PERDecTableChar32String() and ASN1PERDecZeroTableChar32String().
// (7) merge ASN1PERDecFragmentedCharString() and ASN1PERDecFragmentedZeroCharString().
// (8) merge ASN1PERDecFragmentedChar16String() and ASN1PERDecFragmentedZeroChar16String().
// (9) merge ASN1PERDecFragmentedChar32String() and ASN1PERDecFragmentedZeroChar32String().
// (10) merge ASN1PERDecFragmentedTableCharString() and ASN1PERDecFragmentedZeroTableCharString().
// (11) merge ASN1PERDecFragmentedTableChar16String() and ASN1PERDecFragmentedZeroTableChar16String().
// (12) merge ASN1PERDecFragmentedTableChar32String() and ASN1PERDecFragmentedZeroTableChar32String().

#include "precomp.h"

#include <math.h>
#include "cintern.h"

void PerDecAdvance(ASN1decoding_t dec, ASN1uint32_t nbits)
{
    dec->pos += ((dec->bit + nbits) >> 3);
    dec->bit = (dec->bit + nbits) & 7;
}

static const ASN1uint8_t c_aBitMask3[] =
{
    0x00, 0xfe, 0xfc, 0xf8, 0xf0, 0xe0, 0xc0, 0x80
};

/* check if sufficient data is in decoding buffer */
int ASN1PERDecCheck(ASN1decoding_t dec, ASN1uint32_t nbits)
{
    if ((dec->pos - dec->buf) * 8 + dec->bit + nbits <= dec->size * 8)
    {
        return 1;
    }
    ASN1DecSetError(dec, ASN1_ERR_EOD);
    return 0;
}

/* compare function for binary search in stringtable */
static int __cdecl ASN1CmpStringTableEntriesByIndex(const void *a1, const void *a2)
{
    ASN1stringtableentry_t *c1 = (ASN1stringtableentry_t *)a1;
    ASN1stringtableentry_t *c2 = (ASN1stringtableentry_t *)a2;

    if (c1->value > c2->value + (c2->upper - c2->lower))
        return 1;
    if (c2->value > c1->value + (c1->upper - c1->lower))
        return -1;
    return 0;
}

/* skip nbits bits */
int ASN1PERDecSkipBits(ASN1decoding_t dec, ASN1uint32_t nbits)
{
    ASN1uint32_t n;

    /* check if enough bits present */
    if (ASN1PERDecCheck(dec, nbits))
    {
        /* skip bits */
        n = dec->bit + nbits;
        dec->pos += n / 8;
        dec->bit = n & 7;
        return 1;
    }
    return 0;
}

/* skip a fragmented value */
int ASN1PERDecSkipFragmented(ASN1decoding_t dec, ASN1uint32_t itemsize)
{
    ASN1uint32_t n, m;

    /* skip a fragments one by one */
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            m = n * itemsize;
            if (ASN1PERDecCheck(dec, m))
            {
                dec->pos += m / 8;
                dec->bit = m & 7;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);
    return 1;
}

/* decode one bit */
int ASN1PERDecBit(ASN1decoding_t dec, ASN1uint32_t *val)
{
    if (ASN1PERDecCheck(dec, 1))
    {
        *val = (*dec->pos >> (7 - dec->bit)) & 1;
        if (dec->bit < 7)
        {
            dec->bit++;
        }
        else
        {
            dec->bit = 0;
            dec->pos++;
        }
        return 1;
    }
    return 0;
}

/* decode unsigned 32 bit integer value */
int ASN1PERDecU32Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1uint32_t *val)
{
    if (ASN1PERDecCheck(dec, nbits))
    {
        if (nbits <= 32)
        {
            *val = ASN1bitgetu(dec->pos, dec->bit, nbits);
            PerDecAdvance(dec, nbits);
            return 1;
        }
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
    }
    return 0;
}

/* decode unsigned 16 bit integer value */
int ASN1PERDecU16Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1uint16_t *val)
{
    if (ASN1PERDecCheck(dec, nbits))
    {
        if (nbits <= 16)
        {
            *val = (ASN1uint16_t) ASN1bitgetu(dec->pos, dec->bit, nbits);
            PerDecAdvance(dec, nbits);
            return 1;
        }
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
    }
    return 0;
}

/* decode unsigned 8 bit integer value */
int ASN1PERDecU8Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1uint8_t *val)
{
    if (ASN1PERDecCheck(dec, nbits))
    {
        if (nbits <= 8)
        {
            *val = (ASN1uint8_t) ASN1bitgetu(dec->pos, dec->bit, nbits);
            PerDecAdvance(dec, nbits);
            return 1;
        }
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
    }
    return 0;
}

/* decode unsigned intx_t integer value */
int ASN1PERDecUXVal(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1intx_t *val)
{
    if (ASN1PERDecCheck(dec, nbits))
    {
        val->length = (*dec->pos & (0x80 >> dec->bit)) ? (nbits + 7) / 8 : (nbits + 7 + 1) / 8;
        if (NULL != (val->value = (ASN1octet_t *)DecMemAlloc(dec, val->length)))
        {
            val->value[0] = 0;
            ASN1bitcpy(val->value, val->length * 8 - nbits, dec->pos, dec->bit, nbits);
            PerDecAdvance(dec, nbits);
            return 1;
        }
    }
    return 0;
}

/* decode signed 32 bit integer value */
int ASN1PERDecS32Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1int32_t *val)
{
    if (ASN1PERDecCheck(dec, nbits))
    {
        if (nbits <= 32)
        {
            *val = ASN1bitget(dec->pos, dec->bit, nbits);
            PerDecAdvance(dec, nbits);
            return 1;
        }
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
    }
    return 0;
}

/* decode signed 16 bit value */
#ifdef ENABLE_ALL
int ASN1PERDecS16Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1int16_t *val)
{
    if (ASN1PERDecCheck(dec, nbits))
    {
        if (nbits <= 16)
        {
            *val = (ASN1int16_t) ASN1bitget(dec->pos, dec->bit, nbits);
            PerDecAdvance(dec, nbits);
            return 1;
        }
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode signed 8 bit value */
#ifdef ENABLE_ALL
int ASN1PERDecS8Val(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1int8_t *val)
{
    if (ASN1PERDecCheck(dec, nbits))
    {
        if (nbits <= 8)
        {
            *val = (ASN1int8_t) ASN1bitget(dec->pos, dec->bit, nbits);
            PerDecAdvance(dec, nbits);
            return 1;
        }
        ASN1DecSetError(dec, ASN1_ERR_LARGE);
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode signed intx_t value */
#ifdef ENABLE_ALL
int ASN1PERDecSXVal(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1intx_t *val)
{
    if (ASN1PERDecCheck(dec, nbits))
    {
        val->length = (nbits + 7) / 8;
        if (NULL != (val->value = (ASN1octet_t *)DecMemAlloc(dec, val->length)))
        {
            val->value[0] = (*dec->pos & (0x80 >> dec->bit)) ? c_aBitMask3[nbits & 7] : 0;
            ASN1bitcpy(val->value, val->length * 8 - nbits, dec->pos, dec->bit, nbits);
            PerDecAdvance(dec, nbits);
            return 1;
        }
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode length of a fragment */
int ASN1PERDecFragmentedLength(ASN1decoding_t dec, ASN1uint32_t *nitems)
{
    ASN1PERDecAlignment(dec);
    
    if (ASN1PERDecCheck(dec, 8))
    {
        ASN1uint32_t n = *dec->pos++;
        if (n < 0x80)
        {
            *nitems = n;
        }
        else
        if (n < 0xc0)
        {
            if (ASN1PERDecCheck(dec, 8))
            {
                *nitems = ((n & 0x3f) << 8) | *dec->pos++;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            *nitems = 0x4000 * (n & 0x3f);
        }
        return 1;
    }
    return 0;
}

/* decode a fragment */
int ASN1PERDecFragmented(ASN1decoding_t dec, ASN1uint32_t *nitems, ASN1octet_t **val, ASN1uint32_t itemsize)
{
    ASN1uint32_t n, m, l;
    *nitems = 0;
    *val = 0;
    m = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            l = n * itemsize;
            if (ASN1PERDecCheck(dec, l))
            {
                *nitems += n;
                if (NULL != (*val = (ASN1octet_t *)DecMemReAlloc(dec, *val, (m + l + 7) / 8)))
                {
                    ASN1bitcpy(*val, m, dec->pos, dec->bit, l);
                    PerDecAdvance(dec, l);
                    m += l;
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);
    return 1;
}

/* end of decoding */
int ASN1PERDecFlush(ASN1decoding_t dec)
{
    /* complete broken byte */
    ASN1PERDecAlignment(dec);

    /* get zero-octet if encoding is empty bitstring */
    if (dec->buf == dec->pos)
    {
        if (ASN1PERDecCheck(dec, 8))
        {
            if (*dec->pos == 0)
            {
                dec->pos++;
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }

    /* calculate length */
    dec->len = (ASN1uint32_t) (dec->pos - dec->buf);

    /* set WRN_NOEOD if data left */
    if (dec->len >= dec->size)
    {
        return 1;
    }
    ASN1DecSetError(dec, ASN1_WRN_NOEOD);
    return 1;
}

/* skip up to octet boundary */
void ASN1PERDecAlignment(ASN1decoding_t dec)
{
    if (dec->bit)
    {
        dec->bit = 0;
        dec->pos++;
    }
}

/* decode normally small 32 bit integer */
#ifdef ENABLE_ALL
int ASN1PERDecN32Val(ASN1decoding_t dec, ASN1uint32_t *val)
{
    ASN1uint32_t n;

    /* is normally small really small? */
    if (ASN1PERDecBit(dec, &n))
    {
        if (!n)
        {
            return ASN1PERDecU32Val(dec, 6, val);
        }

        /* large */
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (n <= 4)
            {
                if (n)
                {
                    if (ASN1PERDecCheck(dec, n * 8))
                    {
                        *val = ASN1octetget(dec->pos, n);
                        dec->pos += n;
                        return 1;
                    }
                    return 0;
                }
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_LARGE);
            }
        }
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode normally small 16 bit integer */
int ASN1PERDecN16Val(ASN1decoding_t dec, ASN1uint16_t *val)
{
    ASN1uint32_t n;

    /* is normally small really small? */
    if (ASN1PERDecBit(dec, &n))
    {
        if (!n)
        {
            return ASN1PERDecU16Val(dec, 6, val);
        }

        /* large */
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (n <= 2)
            {
                if (n)
                {
                    if (ASN1PERDecCheck(dec, n * 8))
                    {
                        *val = (ASN1uint16_t) ASN1octetget(dec->pos, n);
                        dec->pos += n;
                        return 1;
                    }
                    return 0;
                }
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_LARGE);
            }
        }
    }
    return 0;
}

/* decode normally small 8 bit integer */
#ifdef ENABLE_ALL
int ASN1PERDecN8Val(ASN1decoding_t dec, ASN1uint8_t *val)
{
    ASN1uint32_t n;

    /* is normally small really small? */
    if (ASN1PERDecBit(dec, &n))
    {
        if (!n)
        {
            return ASN1PERDecU8Val(dec, 6, val);
        }

        /* large */
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (n)
            {
                if (n <= 1)
                {
                    if (ASN1PERDecCheck(dec, n * 8))
                    {
                        *val = (ASN1uint8_t) ASN1octetget(dec->pos, n);
                        dec->pos += n;
                        return 1;
                    }
                    return 0;
                }
                ASN1DecSetError(dec, ASN1_ERR_LARGE);
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            }
        }
    }
    return 0;
}
#endif // ENABLE_ALL

/* skip normally small integer */
int ASN1PERDecSkipNormallySmall(ASN1decoding_t dec)
{
    ASN1uint32_t n;

    /* is normally small really small? */
    if (ASN1PERDecBit(dec, &n))
    {
        if (!n)
        {
            return ASN1PERDecSkipBits(dec, 6);
        }

        /* large */
        return ASN1PERDecSkipFragmented(dec, 8);
    }
    return 0;
}

/* decode extension bits with normally small length */
int ASN1PERDecNormallySmallExtension(ASN1decoding_t dec, ASN1uint32_t *nextensions, ASN1uint32_t nbits, ASN1octet_t *val)
{
    ASN1uint32_t n, m;

    *nextensions = 0;
    memset(val, 0, (nbits + 7) / 8);

    /* is normally small length really small? */
    if (ASN1PERDecBit(dec, &n))
    {
        if (n)
        {
            /* no, get extension bits as fragments */
            m = 0;
            do {
                if (ASN1PERDecFragmentedLength(dec, &n))
                {
                    if (!n)
                        break;
                    if (ASN1PERDecCheck(dec, n))
                    {
                        if (n <= nbits)
                        {
                            ASN1bitcpy(val, m, dec->pos, 0, n);
                            m += n;
                            nbits -= n;
                        }
                        else
                        if (nbits)
                        {
                            ASN1bitcpy(val, m, dec->pos, 0, nbits);
                            *nextensions += ASN1bitcount(dec->pos, nbits, n - nbits);
                            nbits = 0;
                        }
                        else
                        {
                            *nextensions += ASN1bitcount(dec->pos, 0, n);
                        }
                        PerDecAdvance(dec, n);
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            } while (n >= 0x4000);
            return 1;
        }

        /* yes, get length of extension bit string */
        if (ASN1PERDecU32Val(dec, 6, &n))
        {
            n++;

            /* copy extension bits */
            if (ASN1PERDecCheck(dec, n))
            {
                if (n <= nbits)
                {
                    ASN1bitcpy(val, 0, dec->pos, dec->bit, n);
                }
                else
                {
                    ASN1bitcpy(val, 0, dec->pos, dec->bit, nbits);
                    *nextensions = ASN1bitcount(dec->pos, dec->bit + nbits, n - nbits);
                }
                PerDecAdvance(dec, n);
                return 1;
            }
        }
    }
    return 0;
}

/* skip extension bits with normally small length */
int ASN1PERDecSkipNormallySmallExtension(ASN1decoding_t dec, ASN1uint32_t *nextensions)
{
    ASN1uint32_t n;

    *nextensions = 0;

    /* is normally small length really small? */
    if (ASN1PERDecBit(dec, &n))
    {
        if (n)
        {
            /* no, get extension bits as fragments */
            do {
                if (ASN1PERDecFragmentedLength(dec, &n))
                {
                    if (!n)
                        break;
                    if (ASN1PERDecCheck(dec, n))
                    {
                        *nextensions += ASN1bitcount(dec->pos, 0, n);
                        PerDecAdvance(dec, n);
                    }
                    else
                    {
                        return 0;
                    }
                }
                else
                {
                    return 0;
                }
            } while (n >= 0x4000);
            return 1;
        }

        /* yes, get length of extension bit string */
        if (ASN1PERDecU32Val(dec, 6, &n))
        {
            n++;
            if (ASN1PERDecCheck(dec, n))
            {
                *nextensions = ASN1bitcount(dec->pos, dec->bit, n);
                PerDecAdvance(dec, n);
                return 1;
            }
        }
    }
    return 0;
}

/* decode bit string of optionals of sequence/set */
// lonchanc: decode octet string with length constraint.
int ASN1PERDecExtension(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1octet_t *val)
{
    if (ASN1PERDecCheck(dec, nbits))
    {
        ASN1bitcpy(val, 0, dec->pos, dec->bit, nbits);
        PerDecAdvance(dec, nbits);
        return 1;
    }
    return 0;
}

/* decode bit string */
int ASN1PERDecBits(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1octet_t **val)
{
    if (NULL != (*val = (ASN1octet_t *)DecMemAlloc(dec, (nbits + 7) / 8)))
    {
        if (ASN1PERDecCheck(dec, nbits))
        {
            ASN1bitcpy(*val, 0, dec->pos, dec->bit, nbits);
            PerDecAdvance(dec, nbits);
            return 1;
        }
    }
    return 0;
}

/* decode real value */
int ASN1PERDecDouble(ASN1decoding_t dec, double *val)
{
    ASN1uint32_t head;
    ASN1int32_t exponent;
    ASN1uint32_t baselog2;
    ASN1uint32_t len;
    ASN1uint32_t i;
    ASN1octet_t *p, *q;
    double v;
    char buf[256], *b;

    if (ASN1PERDecFragmentedLength(dec, &len))
    {
        if (len < 0x4000)
        {
            if (len)
            {
                p = q = dec->pos;
                dec->pos += len;
                head = *p++;

                /* binary encoding? */
                if (head & 0x80)
                {
                    /* get base */
                    switch (head & 0x30)
                    {
                    case 0:
                        /* base 2 */
                        baselog2 = 1;
                        break;
                    case 0x10:
                        /* base 8 */
                        baselog2 = 3;
                        break;
                    case 0x20:
                        /* base 16 */
                        baselog2 = 4;
                        break;
                    default:
                        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                        return 0;
                    }

                    /* get exponent */
                    switch (head & 0x03)
                    {
                    case 0:
                        /* 8 bit exponent */
                        exponent = (ASN1int8_t)*p++;
                        break;
                    case 1:
                        /* 16 bit exponent */
                        exponent = (ASN1int16_t)((*p << 8) | p[1]);
                        p += 2;
                        break;
                    case 2:
                        /* 24 bit exponent */
                        exponent = ((*p << 16) | (p[1] << 8) | p[2]);
                        if (exponent & 0x800000)
                            exponent -= 0x1000000;
                        break;
                    default:
                        /* variable length exponent */
                        exponent = (p[1] & 0x80) ? -1 : 0;
                        for (i = 1; i <= *p; i++)
                            exponent = (exponent << 8) | p[i];
                        p += *p + 1;
                        break;
                    }

                    /* calculate remaining length */
                    len -= (ASN1uint32_t) (p - q);

                    /* get mantissa */
                    v = 0.0;
                    for (i = 0; i < len; i++)
                        v = v * 256.0 + *p++;

                    /* scale mantissa */
                    switch (head & 0x0c)
                    {
                    case 0x04:
                        /* scaling factor 1 */
                        v *= 2.0;
                        break;
                    case 0x08:
                        /* scaling factor 2 */
                        v *= 4.0;
                        break;
                    case 0x0c:
                        /* scaling factor 3 */
                        v *= 8.0;
                        break;
                    }

                    /* check sign */
                    if (head & 0x40)
                        v = -v;

                    /* calculate value */
                    *val = ldexp(v, exponent * baselog2);

                /* special real values? */
                }
                else
                if (head & 0x40)
                {
                    switch (head)
                    {
                    case 0x40:
                        /* PLUS-INFINITY */
                        *val = ASN1double_pinf();
                        break;
                    case 0x41:
                        /* MINUS-INFINITY */
                        *val = ASN1double_minf();
                        break;
                    default:
                        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                        return 0;
                    }
                
                /* decimal encoding */
                }
                else
                {
                    CopyMemory(buf, p, len - 1);
                    buf[len - 1] = 0;
                    b = strchr(buf, ',');
                    if (b)
                        *b = '.';
                    *val = strtod((char *)buf, &b);
                    if (*b)
                    {
                        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                        return 0;
                    }
                }
            }
            else
            {
                *val = 0.0;
            }
            return 1;
        }
        else
        {
            ASN1DecSetError(dec, ASN1_ERR_LARGE);
        }
    }
    return 0;
}

/* decode external value */
#ifdef ENABLE_EXTERNAL
int ASN1PERDecExternal(ASN1decoding_t dec, ASN1external_t *val)
{
    ASN1uint32_t l, u;

    /* get optional bits */
    if (ASN1PERDecU32Val(dec, 3, &u))
    {
        /* get identification */
        switch (u & 6)
        {
        case 4:
            val->identification.o = ASN1external_identification_syntax_o;
            if (!ASN1PERDecObjectIdentifier(dec, &val->identification.u.syntax))
                return 0;
            break;
        case 2:
            val->identification.o =
                ASN1external_identification_presentation_context_id_o;
            if (!ASN1PERDecFragmentedLength(dec, &l))
                return 0;
            if (!ASN1PERDecU32Val(dec, l * 8,
                &val->identification.u.presentation_context_id))
                return 0;
            break;
        case 6:
            val->identification.o =
                ASN1external_identification_context_negotiation_o;
            if (!ASN1PERDecObjectIdentifier(dec,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            if (!ASN1PERDecFragmentedLength(dec, &l))
                return 0;
            if (!ASN1PERDecU32Val(dec, l * 8,
                &val->identification.u.context_negotiation.presentation_context_id))
                return 0;
            break;
        default:
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }

        /* get value descriptor */
        val->o[0] = (ASN1octet_t) ((u & 1) << 7);
        if (u & 1)
        {
            if (!ASN1PERDecFragmentedZeroCharString(dec, &val->data_value_descriptor, 8))
                return 0;
        }
        else
        {
            val->data_value_descriptor = NULL;
        }

        /* get value */
        if (ASN1PERDecU32Val(dec, 2, &u))
        {
            switch (u)
            {
            case 0:
                val->data_value.o = ASN1external_data_value_notation_o;
                return ASN1PERDecFragmented(dec,
                            &val->data_value.u.notation.length,
                            (ASN1octet_t **) &val->data_value.u.notation.encoded, 8);
                break;
            case 1:
                val->data_value.o = ASN1external_data_value_encoded_o;
                if (ASN1PERDecFragmented(dec,
                            &val->data_value.u.encoded.length,
                            &val->data_value.u.encoded.value, 8))
                {
                    val->data_value.u.encoded.length *= 8;
                    return 1;
                }
                break;
            case 2:
                val->data_value.o = ASN1external_data_value_encoded_o;
                return ASN1PERDecFragmented(dec,
                            &val->data_value.u.encoded.length,
                            &val->data_value.u.encoded.value, 1);
                break;
            default:
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            }
        }
    }
    return 0;
}
#endif // ENABLE_EXTERNAL

/* decode an embedded pdv value */
#ifdef ENABLE_EMBEDDED_PDV
int ASN1PERDecEmbeddedPdv(ASN1decoding_t dec, ASN1embeddedpdv_t *val)
{
    ASN1uint32_t flag;
    ASN1uint32_t index;
    ASN1uint32_t l;
    ASN1embeddedpdv_identification_t *identification;

    /* get EP-A/EP-B encoding bit */
    if (!ASN1PERDecBit(dec, &flag))
        return 0;

    /* get index value */
    if (!ASN1PERDecN32Val(dec, &index))
        return 0;

    if (flag)
    {
        /* EP-A encoding */

        /* get identification */
        if (!ASN1PERDecU8Val(dec, 3, &val->identification.o))
            return 0;
        switch (val->identification.o)
        {
        case ASN1embeddedpdv_identification_syntaxes_o:
            if (!ASN1PERDecObjectIdentifier(dec,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1PERDecObjectIdentifier(dec,
                &val->identification.u.syntaxes.transfer))
                return 0;
            break;
        case ASN1embeddedpdv_identification_syntax_o:
            if (!ASN1PERDecObjectIdentifier(dec,
                &val->identification.u.syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_presentation_context_id_o:
            if (!ASN1PERDecFragmentedLength(dec, &l))
                return 0;
            if (!ASN1PERDecU32Val(dec, l * 8,
                &val->identification.u.presentation_context_id))
                return 0;
            break;
        case ASN1embeddedpdv_identification_context_negotiation_o:
            if (!ASN1PERDecFragmentedLength(dec, &l))
                return 0;
            if (!ASN1PERDecU32Val(dec, l * 8, &val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1PERDecObjectIdentifier(dec,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_transfer_syntax_o:
            if (!ASN1PERDecObjectIdentifier(dec,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_fixed_o:
            break;
        default:
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }

        /* save identification */
        if (!ASN1DecAddEmbeddedPdvIdentification(((ASN1INTERNdecoding_t) dec)->parent,
                                                 &val->identification))
            return 0;
    }
    else
    {
        /* EP-B encoding */

        /* get identification */
        identification = ASN1DecGetEmbeddedPdvIdentification(((ASN1INTERNdecoding_t) dec)->parent, index);
        if (!identification)
            return 0;
        val->identification.o = identification->o;
        switch (identification->o)
        {
        case ASN1embeddedpdv_identification_syntaxes_o:
            if (!ASN1DecDupObjectIdentifier(dec, 
                &val->identification.u.syntaxes.abstract,
                &identification->u.syntaxes.abstract))
                return 0;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntaxes.transfer,
                &identification->u.syntaxes.transfer))
                return 0;
            break;
        case ASN1embeddedpdv_identification_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntax,
                &identification->u.syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_presentation_context_id_o:
            val->identification.u.presentation_context_id =
                identification->u.presentation_context_id;
            break;
        case ASN1embeddedpdv_identification_context_negotiation_o:
            val->identification.u.context_negotiation.presentation_context_id =
                identification->u.context_negotiation.presentation_context_id;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.context_negotiation.transfer_syntax,
                &identification->u.context_negotiation.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_transfer_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.transfer_syntax,
                &identification->u.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_fixed_o:
            break;
        }
    }

    /* get value */
    ASN1PERDecAlignment(dec);
    val->data_value.o = ASN1embeddedpdv_data_value_encoded_o;
    return ASN1PERDecFragmented(dec,
                    &val->data_value.u.encoded.length,
                    &val->data_value.u.encoded.value, 1);
}
#endif // ENABLE_EMBEDDED_PDV

/* decode an optimized embedded pdv value */
#ifdef ENABLE_EMBEDDED_PDV
int ASN1PERDecEmbeddedPdvOpt(ASN1decoding_t dec, ASN1embeddedpdv_t *val, ASN1objectidentifier_t *abstract, ASN1objectidentifier_t *transfer)
{
    /* set identification */
    if (abstract && transfer)
    {
        val->identification.o = ASN1embeddedpdv_identification_syntaxes_o;
        if (!ASN1DecDupObjectIdentifier(dec, 
            &val->identification.u.syntaxes.abstract, abstract))
            return 0;
        if (!ASN1DecDupObjectIdentifier(dec,
            &val->identification.u.syntaxes.transfer, transfer))
            return 0;
    }
    else
    {
        val->identification.o = ASN1embeddedpdv_identification_fixed_o;
    }

    /* get value */
    val->data_value.o = ASN1embeddedpdv_data_value_encoded_o;
    return ASN1PERDecFragmented(dec,
                    &val->data_value.u.encoded.length,
                    &val->data_value.u.encoded.value, 1);
}
#endif // ENABLE_EMBEDDED_PDV

/* decode character string */
#ifdef ENABLE_GENERALIZED_CHAR_STR
int ASN1PERDecCharacterString(ASN1decoding_t dec, ASN1characterstring_t *val)
{
    ASN1uint32_t flag;
    ASN1uint32_t index;
    ASN1uint32_t l;
    ASN1characterstring_identification_t *identification;

    /* get CS-A/CS-B encoding bit */
    if (!ASN1PERDecBit(dec, &flag))
        return 0;

    /* get index value */
    if (!ASN1PERDecN32Val(dec, &index))
        return 0;

    if (flag)
    {
        /* CS-A encoding */

        /* get identification */
        if (!ASN1PERDecU8Val(dec, 3, &val->identification.o))
            return 0;
        switch (val->identification.o)
        {
        case ASN1characterstring_identification_syntaxes_o:
            if (!ASN1PERDecObjectIdentifier(dec,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1PERDecObjectIdentifier(dec,
                &val->identification.u.syntaxes.transfer))
                return 0;
            break;
        case ASN1characterstring_identification_syntax_o:
            if (!ASN1PERDecObjectIdentifier(dec,
                &val->identification.u.syntax))
                return 0;
            break;
        case ASN1characterstring_identification_presentation_context_id_o:
            if (!ASN1PERDecFragmentedLength(dec, &l))
                return 0;
            if (!ASN1PERDecU32Val(dec, l * 8,
                &val->identification.u.presentation_context_id))
                return 0;
            break;
        case ASN1characterstring_identification_context_negotiation_o:
            if (!ASN1PERDecFragmentedLength(dec, &l))
                return 0;
            if (!ASN1PERDecU32Val(dec, l * 8, &val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1PERDecObjectIdentifier(dec,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_transfer_syntax_o:
            if (!ASN1PERDecObjectIdentifier(dec,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_fixed_o:
            break;
        default:
            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
            return 0;
        }

        /* save identification */
        if (!ASN1DecAddCharacterStringIdentification((ASN1INTERNdecoding_t) dec, &val->identification))
            return 0;

    }
    else
    {
        /* CS-B encoding */

        /* get identification */
        identification = ASN1DecGetCharacterStringIdentification((ASN1INTERNdecoding_t) dec, index);
        if (!identification)
            return 0;
        val->identification.o = identification->o;
        switch (identification->o)
        {
        case ASN1characterstring_identification_syntaxes_o:
            if (!ASN1DecDupObjectIdentifier(dec, 
                &val->identification.u.syntaxes.abstract,
                &identification->u.syntaxes.abstract))
                return 0;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntaxes.transfer,
                &identification->u.syntaxes.transfer))
                return 0;
            break;
        case ASN1characterstring_identification_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.syntax,
                &identification->u.syntax))
                return 0;
            break;
        case ASN1characterstring_identification_presentation_context_id_o:
            val->identification.u.presentation_context_id =
                identification->u.presentation_context_id;
            break;
        case ASN1characterstring_identification_context_negotiation_o:
            val->identification.u.context_negotiation.presentation_context_id =
                identification->u.context_negotiation.presentation_context_id;
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.context_negotiation.transfer_syntax,
                &identification->u.context_negotiation.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_transfer_syntax_o:
            if (!ASN1DecDupObjectIdentifier(dec,
                &val->identification.u.transfer_syntax,
                &identification->u.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_fixed_o:
            break;
        }
    }

    /* get value */
    ASN1PERDecAlignment(dec);
    val->data_value.o = ASN1characterstring_data_value_encoded_o;
    return ASN1PERDecFragmented(dec,
                    &val->data_value.u.encoded.length,
                    &val->data_value.u.encoded.value, 8);
}
#endif // ENABLE_GENERALIZED_CHAR_STR

/* decode an optimized character string value */
#ifdef ENABLE_GENERALIZED_CHAR_STR
int ASN1PERDecCharacterStringOpt(ASN1decoding_t dec, ASN1characterstring_t *val, ASN1objectidentifier_t *abstract, ASN1objectidentifier_t *transfer)
{
    /* set identification */
    if (abstract && transfer)
    {
        val->identification.o = ASN1characterstring_identification_syntaxes_o;
        if (!ASN1DecDupObjectIdentifier(dec, 
            &val->identification.u.syntaxes.abstract, abstract))
            return 0;
        if (!ASN1DecDupObjectIdentifier(dec,
            &val->identification.u.syntaxes.transfer, transfer))
            return 0;
    }
    else
    {
        val->identification.o = ASN1characterstring_identification_fixed_o;
    }

    /* get value */
    val->data_value.o = ASN1characterstring_data_value_encoded_o;
    return ASN1PERDecFragmented(dec,
                    &val->data_value.u.encoded.length,
                    &val->data_value.u.encoded.value, 8);
}
#endif // ENABLE_GENERALIZED_CHAR_STR

/* decode a multibyte string */
#ifdef ENABLE_ALL
int ASN1PERDecMultibyteString(ASN1decoding_t dec, ASN1char_t **val)
{
    return ASN1PERDecFragmentedZeroCharString(dec, val, 8);
}
#endif // ENABLE_ALL

/* decode a string */
int ASN1PERDecCharStringNoAlloc(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits)
{
    ASN1char_t *p = val;

    if (ASN1PERDecCheck(dec, nchars * nbits))
    {
        if (nbits == 8)
        {
            ASN1bitcpy((ASN1octet_t *)p, 0, dec->pos, dec->bit, nchars * 8);
            PerDecAdvance(dec, nchars * 8);
            return 1;
        }
        while (nchars--)
        {
            *p++ = (ASN1char_t) ASN1bitgetu(dec->pos, dec->bit, nbits);
            PerDecAdvance(dec, nbits);
        }
        return 1;
    }
    return 0;
}

#ifdef ENABLE_ALL
int ASN1PERDecCharString(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t **val, ASN1uint32_t nbits)
{
    if (ASN1PERDecCheck(dec, nchars * nbits))
    {
        *val = (ASN1char_t *)DecMemAlloc(dec, nchars);
        return ((*val) ? ASN1PERDecCharStringNoAlloc(dec, nchars, *val, nbits) : 0);
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode a 16 bit string */
int ASN1PERDecChar16String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char16_t **val, ASN1uint32_t nbits)
{
    ASN1char16_t *p;

    if (ASN1PERDecCheck(dec, nchars * nbits))
    {
        p = *val = (ASN1char16_t *)DecMemAlloc(dec, nchars * sizeof(ASN1char16_t));
        if (p)
        {
            if (!dec->bit && nbits == 16)
            {
                while (nchars--)
                {
                    *p++ = (dec->pos[0] << 8) | dec->pos[1];
                    dec->pos += 2;
                }
                return 1;
            }
            while (nchars--)
            {
                *p++ = (ASN1char16_t) ASN1bitgetu(dec->pos, dec->bit, nbits);
                PerDecAdvance(dec, nbits);
            }
            return 1;
        }
    }
    return 0;
}

/* decode a 32 bit string */
#ifdef ENABLE_ALL
int ASN1PERDecChar32String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char32_t **val, ASN1uint32_t nbits)
{
    ASN1char32_t *p;

    if (ASN1PERDecCheck(dec, nchars * nbits))
    {
        p = *val = (ASN1char32_t *)DecMemAlloc(dec, nchars * sizeof(ASN1char32_t));
        if (p)
        {
            if (!dec->bit && nbits == 32)
            {
                while (nchars--)
                {
                    *p++ = (dec->pos[0] << 24) | (dec->pos[1] << 16) |
                        (dec->pos[2] << 8) | dec->pos[3];
                    dec->pos += 4;
                }
                return 1;
            }
            while (nchars--)
            {
                *p++ = ASN1bitgetu(dec->pos, dec->bit, nbits);
                PerDecAdvance(dec, nbits);
            }
            return 1;
        }
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode a zero-terminated string */
int ASN1PERDecZeroCharStringNoAlloc(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits)
{
    ASN1char_t *p = val;

    if (ASN1PERDecCheck(dec, nchars * nbits))
    {
        if (nbits == 8)
        {
            ASN1bitcpy((ASN1octet_t *)p, 0, dec->pos, dec->bit, nchars * 8);
            PerDecAdvance(dec, nchars * 8);
            p[nchars] = 0;
            return 1;
        }
        while (nchars--)
        {
            *p++ = (ASN1char_t) ASN1bitgetu(dec->pos, dec->bit, nbits);
            PerDecAdvance(dec, nbits);
        }
        *p = 0;
        return 1;
    }
    return 0;
}

#ifdef ENABLE_ALL
int ASN1PERDecZeroCharString(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t **val, ASN1uint32_t nbits)
{
    if (ASN1PERDecCheck(dec, nchars * nbits))
    {
        *val = (ASN1char_t *)DecMemAlloc(dec, nchars + 1);
        return ((*val) ? ASN1PERDecZeroCharStringNoAlloc(dec, nchars, *val, nbits) : 0);
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode a zero-terminated 16 bit string */
#ifdef ENABLE_ALL
int ASN1PERDecZeroChar16String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char16_t **val, ASN1uint32_t nbits)
{
    ASN1char16_t *p;

    if (ASN1PERDecCheck(dec, nchars * nbits))
    {
        p = *val = (ASN1char16_t *)DecMemAlloc(dec, (nchars + 1) * sizeof(ASN1char16_t));
        if (p)
        {
            if (!dec->bit && nbits == 16)
            {
                while (nchars--)
                {
                    *p++ = (dec->pos[0] << 8) | dec->pos[1];
                    dec->pos += 2;
                }
                *p = 0;
                return 1;
            }
            while (nchars--)
            {
                *p++ = (ASN1char16_t) ASN1bitgetu(dec->pos, dec->bit, nbits);
                PerDecAdvance(dec, nbits);
            }
            *p = 0;
            return 1;
        }
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode a zero-terminated 32 bit string */
#ifdef ENABLE_ALL
int ASN1PERDecZeroChar32String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char32_t **val, ASN1uint32_t nbits)
{
    ASN1char32_t *p;

    if (ASN1PERDecCheck(dec, nchars * nbits))
    {
        p = *val = (ASN1char32_t *)DecMemAlloc(dec, (nchars + 1) * sizeof(ASN1char32_t));
        if (p)
        {
            if (!dec->bit && nbits == 32)
            {
                while (nchars--)
                {
                    *p++ = (dec->pos[0] << 24) | (dec->pos[1] << 16) |
                        (dec->pos[2] << 8) | dec->pos[3];
                    dec->pos += 4;
                }
                *p = 0;
                return 1;
            }
            while (nchars--)
            {
                *p++ = ASN1bitgetu(dec->pos, dec->bit, nbits);
                PerDecAdvance(dec, nbits);
            }
            *p = 0;
            return 1;
        }
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode a table string */
#ifdef ENABLE_ALL
int ASN1PERDecTableCharStringNoAlloc(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1char_t *p = val;
    ASN1stringtableentry_t chr, *entry;

    if (ASN1PERDecCheck(dec, nchars * nbits))
    {
        chr.lower = chr.upper = 0;
        while (nchars--)
        {
            chr.value = ASN1bitgetu(dec->pos, dec->bit, nbits);
            PerDecAdvance(dec, nbits);
            entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                table->length, sizeof(ASN1stringtableentry_t),
                ASN1CmpStringTableEntriesByIndex);
            if (entry)
            {
                *p++ = (ASN1char_t) (entry->lower + (chr.value - entry->value));
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
        return 1;
    }
    return 0;
}
#endif // ENABLE_ALL

#ifdef ENABLE_ALL
int ASN1PERDecTableCharString(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1stringtableentry_t chr, *entry;

    if (ASN1PERDecCheck(dec, nchars * nbits))
    {
        *val = (ASN1char_t *)DecMemAlloc(dec, nchars);
        return ((*val) ? ASN1PERDecTableCharStringNoAlloc(dec, nchars, *val, nbits, table) : 0);
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode a 16 bit table string */
int ASN1PERDecTableChar16String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char16_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1char16_t *p;
    ASN1stringtableentry_t chr, *entry;

    if (ASN1PERDecCheck(dec, nchars * nbits))
    {
        *val = p = (ASN1char16_t *)DecMemAlloc(dec, nchars * sizeof(ASN1char16_t));
        if (p)
        {
            chr.lower = chr.upper = 0;
            while (nchars--)
            {
                chr.value = ASN1bitgetu(dec->pos, dec->bit, nbits);
                PerDecAdvance(dec, nbits);
                entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                    table->length, sizeof(ASN1stringtableentry_t),
                    ASN1CmpStringTableEntriesByIndex);
                if (entry)
                {
                    *p++ = (ASN1char16_t) (entry->lower + (chr.value - entry->value));
                }
                else
                {
                    ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                    return 0;
                }
            }
            return 1;
        }
    }
    return 0;
}

/* decode a 32 bit table string */
#ifdef ENABLE_ALL
int ASN1PERDecTableChar32String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char32_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1char32_t *p;
    ASN1stringtableentry_t chr, *entry;

    if (ASN1PERDecCheck(dec, nchars * nbits))
    {
        *val = p = (ASN1char32_t *)DecMemAlloc(dec, nchars * sizeof(ASN1char32_t));
        if (p)
        {
            chr.lower = chr.upper = 0;
            while (nchars--)
            {
                chr.value = ASN1bitgetu(dec->pos, dec->bit, nbits);
                PerDecAdvance(dec, nbits);
                entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                    table->length, sizeof(ASN1stringtableentry_t),
                    ASN1CmpStringTableEntriesByIndex);
                if (entry)
                {
                    *p++ = entry->lower + (chr.value - entry->value);
                }
                else
                {
                    ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                    return 0;
                }
            }
            return 1;
        }
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode a zero-terminated table string */
int ASN1PERDecZeroTableCharStringNoAlloc(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1char_t *p = val;
    ASN1stringtableentry_t chr, *entry;

    chr.lower = chr.upper = 0;
    while (nchars--)
    {
        if (ASN1PERDecU32Val(dec, nbits, &chr.value))
        {
            entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                table->length, sizeof(ASN1stringtableentry_t),
                ASN1CmpStringTableEntriesByIndex);
            if (entry)
            {
                *p++ = (ASN1char_t) (entry->lower + (chr.value - entry->value));
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }
    *p = 0;
    return 1;
}

/* decode a zero-terminated table string */
#ifdef ENABLE_ALL
int ASN1PERDecZeroTableCharString(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1char_t *p;
    ASN1stringtableentry_t chr, *entry;

    *val = (ASN1char_t *)DecMemAlloc(dec, nchars + 1);
    return ((*val) ? ASN1PERDecZeroTableCharStringNoAlloc(dec, nchars, *val, nbits, table) : 0);
}
#endif // ENABLE_ALL

/* decode a zero-terminated 16 bit table string */
#ifdef ENABLE_ALL
int ASN1PERDecZeroTableChar16String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char16_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1char16_t *p;
    ASN1stringtableentry_t chr, *entry;

    *val = p = (ASN1char16_t *)DecMemAlloc(dec, (nchars + 1) * sizeof(ASN1char16_t));
    if (p)
    {
        chr.lower = chr.upper = 0;
        while (nchars--)
        {
            if (ASN1PERDecU32Val(dec, nbits, &chr.value))
            {
                entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                    table->length, sizeof(ASN1stringtableentry_t),
                    ASN1CmpStringTableEntriesByIndex);
                if (entry)
                {
                    *p++ = (ASN1char16_t) (entry->lower + (chr.value - entry->value));
                }
                else
                {
                    ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        *p = 0;
        return 1;
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode a zero-terminated 32 bit table string */
#ifdef ENABLE_ALL
int ASN1PERDecZeroTableChar32String(ASN1decoding_t dec, ASN1uint32_t nchars, ASN1char32_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1char32_t *p;
    ASN1stringtableentry_t chr, *entry;

    *val = p = (ASN1char32_t *)DecMemAlloc(dec, (nchars + 1) * sizeof(ASN1char32_t));
    if (p)
    {
        chr.lower = chr.upper = 0;
        while (nchars--)
        {
            if (ASN1PERDecU32Val(dec, nbits, &chr.value))
            {
                entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                    table->length, sizeof(ASN1stringtableentry_t),
                    ASN1CmpStringTableEntriesByIndex);
                if (entry)
                {
                    *p++ = entry->lower + (chr.value - entry->value);
                }
                else
                {
                    ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        *p = 0;
        return 1;
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode an object identifier */
int ASN1PERDecObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t *val)
{
    ASN1uint32_t len, i, v;
    ASN1octet_t *data, *p;
    ASN1uint32_t nelem;
    ASN1objectidentifier_t q;

    if (ASN1PERDecFragmented(dec, &len, &data, 8))
    {
        int rc = 0;
        nelem = 1;
        for (i = 0, p = data; i < len; i++, p++)
        {
            if (!(*p & 0x80))
                nelem++;
        }
        *val = q = DecAllocObjectIdentifier(dec, nelem);
        if (q)
        {
            v = 0;
            for (i = 0, p = data; i < len; i++, p++)
            {
                v = (v << 7) | (*p & 0x7f);
                if (!(*p & 0x80))
                {
                    if (q == *val)
                    { // first id
                        q->value = v / 40;
                        if (q->value > 2)
                            q->value = 2;
                        q->next->value = v - 40 * q->value;
                        q = q->next->next;
                    }
                    else
                    {
                        q->value = v;
                        q = q->next;
                    }
                    v = 0;
                }
            }
            rc = 1;
        }
        DecMemFree(dec, data);
        return rc;
    }
    return 0;
}

/* decode an object identifier */
int ASN1PERDecObjectIdentifier2(ASN1decoding_t dec, ASN1objectidentifier2_t *val)
{
    ASN1uint32_t len, i, v;
    ASN1octet_t *data, *p;
    ASN1uint32_t nelem;
    ASN1objectidentifier_t q;

    int rc = 0;
    if (ASN1PERDecFragmented(dec, &len, &data, 8))
    {
        if (len <= 16) // lonchanc: hard-coded value 16 to be consistent with ASN1objectidentifier2_t
        {
            val->count = 0;
            v = 0;
            for (i = 0, p = data; i < len; i++, p++)
            {
                v = (v << 7) | (*p & 0x7f);
                if (!(*p & 0x80))
                {
                    if (! val->count)
                    { // first id
                        val->value[0] = v / 40;
                        if (val->value[0] > 2)
                            val->value[0] = 2;
                        val->value[1] = v - 40 * val->value[0];
                        val->count = 2;
                    }
                    else
                    {
                        val->value[val->count++] = v;
                    }
                    v = 0;
                }
            }

            // success
            rc = 1;
        }
        else
        {
            ASN1DecSetError(dec, ASN1_ERR_LARGE);
        }

        DecMemFree(dec, data);
    }
    return rc;
}

/* decode a fragmented signed intx value */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedIntx(ASN1decoding_t dec, ASN1intx_t *val)
{
    return ASN1PERDecFragmented(dec, &val->length, &val->value, 8);
}
#endif // ENABLE_ALL

/* decode a fragmented unsigned intx value */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedUIntx(ASN1decoding_t dec, ASN1intx_t *val)
{
    if (ASN1PERDecFragmented(dec, &val->length, &val->value, 8))
    {
        if (val->length && val->value[0] > 0x7f)
        {
            ASN1octet_t *p;
            if (NULL != (p = (ASN1octet_t *)DecMemAlloc(dec, val->length + 1)))
            {
                *p = 0;
                CopyMemory(p + 1, val->value, val->length);
                DecMemFree(dec, val->value);
                val->value = p;
                val->length++;
                return 1;
            }
            return 0;
        }
        return 1;
    }
    return 0;
}
#endif // ENABLE_ALL

/* decode fragmented extension bits */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedExtension(ASN1decoding_t dec, ASN1uint32_t nbits, ASN1octet_t *val)
{
    ASN1uint32_t m, n;

    m = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (m + n <= nbits)
            {
                if (ASN1PERDecCheck(dec, n))
                {
                    ASN1bitcpy(val, m, dec->pos, dec->bit, n);
                    PerDecAdvance(dec, n);
                    m += n;
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);
    return 1;
}
#endif // ENABLE_ALL

/* decode a fragmented string */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedCharString(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char_t **val, ASN1uint32_t nbits)
{
    ASN1uint32_t m, n, i;
    ASN1char_t *p;

    *val = 0;
    m = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            if (ASN1PERDecCheck(dec, n * nbits))
            {
                if (NULL != (*val = (ASN1char_t *)DecMemReAlloc(dec, *val, m + n)))
                {
                    p = *val + m;
                    m += n;
                    if (nbits == 8)
                    {
                        ASN1bitcpy((ASN1octet_t *)p, 0, dec->pos, dec->bit, n * 8);
                        PerDecAdvance(dec, n * 8);
                    }
                    else
                    {
                        for (i = n; i; i--)
                        {
                            *p++ = (ASN1char_t) ASN1bitgetu(dec->pos, dec->bit, nbits);
                            PerDecAdvance(dec, nbits);
                        }
                    }
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);
    *nchars = m;
    return 1;
}
#endif // ENABLE_ALL

/* decode a fragmented 16 bit string */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedChar16String(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char16_t **val, ASN1uint32_t nbits)
{
    ASN1uint32_t m, n, i;
    ASN1char16_t *p;

    *val = 0;
    m = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            if (ASN1PERDecCheck(dec, n * nbits))
            {
                if (NULL != (*val = (ASN1char16_t *)DecMemReAlloc(dec, *val, (m + n) * sizeof(ASN1char16_t))))
                {
                    p = *val + m;
                    m += n;
                    if (!dec->bit && nbits == 16)
                    {
                        for (i = n; i; i--)
                        {
                            *p++ = (dec->pos[0] << 8) | dec->pos[1];
                            dec->pos += 2;
                        }
                    }
                    else
                    {
                        for (i = n; i; i--)
                        {
                            *p++ = (ASN1char16_t) ASN1bitgetu(dec->pos, dec->bit, nbits);
                            PerDecAdvance(dec, nbits);
                        }
                    }
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);
    *nchars = m;
    return 1;
}
#endif // ENABLE_ALL

/* decode a fragmented 32 bit string */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedChar32String(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char32_t **val, ASN1uint32_t nbits)
{
    ASN1uint32_t m, n, i;
    ASN1char32_t *p;

    *val = 0;
    m = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            if (ASN1PERDecCheck(dec, n * nbits))
            {
                if (NULL != (*val = (ASN1char32_t *)DecMemReAlloc(dec, *val, (m + n) * sizeof(ASN1char32_t))))
                {
                    p = *val + m;
                    m += n;
                    if (!dec->bit && nbits == 32)
                    {
                        for (i = n; i; i--)
                        {
                            *p++ = (dec->pos[0] << 24) | (dec->pos[1] << 16) |
                                (dec->pos[2] << 8) | dec->pos[3];
                            dec->pos += 4;
                        }
                    }
                    else
                    {
                        for (i = n; i; i--)
                        {
                            *p++ = ASN1bitgetu(dec->pos, dec->bit, nbits);
                            PerDecAdvance(dec, nbits);
                        }
                    }
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);
    *nchars = m;
    return 1;
}
#endif // ENABLE_ALL

/* decode a fragmented zero-terminated string */
int ASN1PERDecFragmentedZeroCharString(ASN1decoding_t dec, ASN1char_t **val, ASN1uint32_t nbits)
{
    ASN1uint32_t m, n, i;
    ASN1char_t *p;

    *val = 0;
    m = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            if (ASN1PERDecCheck(dec, n * nbits))
            {
                if (NULL != (*val = (ASN1char_t *)DecMemReAlloc(dec, *val, m + n + 1)))
                {
                    p = *val + m;
                    m += n;
                    if (nbits == 8)
                    {
                        ASN1bitcpy((ASN1octet_t *)p, 0, dec->pos, dec->bit, n * 8);
                        PerDecAdvance(dec, n * 8);
                    }
                    else
                    {
                        for (i = n; i; i--)
                        {
                            *p++ = (ASN1char_t) ASN1bitgetu(dec->pos, dec->bit, nbits);
                            PerDecAdvance(dec, nbits);
                        }
                    }
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);

    if (!*val)
        *val = (ASN1char_t *)DecMemAlloc(dec, 1);
    if (*val)
        (*val)[m] = 0;
    return 1;
}


/* decode a fragmented zero-terminated 16 bit string */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedZeroChar16String(ASN1decoding_t dec, ASN1char16_t **val, ASN1uint32_t nbits)
{
    ASN1uint32_t m, n, i;
    ASN1char16_t *p;

    *val = 0;
    m = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            if (ASN1PERDecCheck(dec, n * nbits))
            {
                if (NULL != (*val = (ASN1char16_t *)DecMemReAlloc(dec, *val, (m + n + 1) * sizeof(ASN1char16_t))))
                {
                    p = *val + m;
                    m += n;
                    if (!dec->bit && nbits == 16)
                    {
                        for (i = n; i; i--)
                        {
                            *p++ = (dec->pos[0] << 8) | dec->pos[1];
                            dec->pos += 2;
                        }
                    }
                    else
                    {
                        for (i = n; i; i--)
                        {
                            *p++ = (ASN1char16_t) ASN1bitgetu(dec->pos, dec->bit, nbits);
                            PerDecAdvance(dec, nbits);
                        }
                    }
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);

    if (!*val)
        *val = (ASN1char16_t *)DecMemAlloc(dec, sizeof(ASN1char16_t));
    if (*val)
        (*val)[m] = 0;
    return 1;
}
#endif // ENABLE_ALL

/* decode a fragmented zero-terminated 32 bit string */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedZeroChar32String(ASN1decoding_t dec, ASN1char32_t **val, ASN1uint32_t nbits)
{
    ASN1uint32_t m, n, i;
    ASN1char32_t *p;

    *val = 0;
    m = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            if (ASN1PERDecCheck(dec, n * nbits))
            {
                if (NULL != (*val = (ASN1char32_t *)DecMemReAlloc(dec, *val, (m + n + 1) * sizeof(ASN1char32_t))))
                {
                    p = *val + m;
                    m += n;
                    if (!dec->bit && nbits == 32)
                    {
                        for (i = n; i; i--)
                        {
                            *p++ = (dec->pos[0] << 24) | (dec->pos[1] << 16) |
                                   (dec->pos[2] << 8) | dec->pos[3];
                            dec->pos += 4;
                        }
                    }
                    else
                    {
                        for (i = n; i; i--)
                        {
                            *p++ = ASN1bitgetu(dec->pos, dec->bit, nbits);
                            PerDecAdvance(dec, nbits);
                        }
                    }
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);

    if (!*val)
        *val = (ASN1char32_t *)DecMemAlloc(dec, sizeof(ASN1char32_t));
    if (*val)
        (*val)[m] = 0;
    return 1;
}
#endif // ENABLE_ALL

/* decode a fragmented table string */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedTableCharString(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1uint32_t m, n, i;
    ASN1stringtableentry_t chr, *entry;
    ASN1char_t *p;

    *val = 0;
    m = 0;
    chr.lower = chr.upper = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            if (ASN1PERDecCheck(dec, n * nbits))
            {
                if (NULL != (*val = (ASN1char_t *)DecMemReAlloc(dec, *val, m + n)))
                {
                    p = *val + m;
                    m += n;
                    for (i = n; i; i--)
                    {
                        chr.value = ASN1bitgetu(dec->pos, dec->bit, nbits);
                        PerDecAdvance(dec, nbits);
                        entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                            table->length, sizeof(ASN1stringtableentry_t),
                            ASN1CmpStringTableEntriesByIndex);
                        if (entry)
                        {
                            *p++ = (ASN1char_t) (entry->lower + (chr.value - entry->value));
                        }
                        else
                        {
                            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                            return 0;
                        }
                    }
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);
    *nchars = m;
    return 1;
}
#endif // ENABLE_ALL

/* decode a fragmented 16 bit table string */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedTableChar16String(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char16_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1uint32_t m, n, i;
    ASN1stringtableentry_t chr, *entry;
    ASN1char16_t *p;

    *val = 0;
    m = 0;
    chr.lower = chr.upper = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            if (ASN1PERDecCheck(dec, n * nbits))
            {
                if (NULL != (*val = (ASN1char16_t *)DecMemReAlloc(dec, *val, (m + n) * sizeof(ASN1char16_t))))
                {
                    p = *val + m;
                    m += n;
                    for (i = n; i; i--)
                    {
                        chr.value = ASN1bitgetu(dec->pos, dec->bit, nbits);
                        PerDecAdvance(dec, nbits);
                        entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                            table->length, sizeof(ASN1stringtableentry_t),
                            ASN1CmpStringTableEntriesByIndex);
                        if (entry)
                        {
                            *p++ = (ASN1char16_t) (entry->lower + (chr.value - entry->value));
                        }
                        else
                        {
                            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                            return 0;
                        }
                    }
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);
    *nchars = m;
    return 1;
}
#endif // ENABLE_ALL

/* decode a fragmented 32 bit table string */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedTableChar32String(ASN1decoding_t dec, ASN1uint32_t *nchars, ASN1char32_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1uint32_t m, n, i;
    ASN1stringtableentry_t chr, *entry;
    ASN1char32_t *p;

    *val = 0;
    m = 0;
    chr.lower = chr.upper = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            if (ASN1PERDecCheck(dec, n * nbits))
            {
                if (NULL != (*val = (ASN1char32_t *)DecMemReAlloc(dec, *val, (m + n) * sizeof(ASN1char32_t))))
                {
                    p = *val + m;
                    m += n;
                    for (i = n; i; i--)
                    {
                        chr.value = ASN1bitgetu(dec->pos, dec->bit, nbits);
                        PerDecAdvance(dec, nbits);
                        entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                            table->length, sizeof(ASN1stringtableentry_t),
                            ASN1CmpStringTableEntriesByIndex);
                        if (entry)
                        {
                            *p++ = entry->lower + (chr.value - entry->value);
                        }
                        else
                        {
                            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                            return 0;
                        }
                    }
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);
    *nchars = m;
    return 1;
}
#endif // ENABLE_ALL

/* decode a fragmented zero-terminated table string */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedZeroTableCharString(ASN1decoding_t dec, ASN1char_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1uint32_t m, n, i;
    ASN1stringtableentry_t chr, *entry;
    ASN1char_t *p;

    *val = 0;
    m = 0;
    chr.lower = chr.upper = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            if (ASN1PERDecCheck(dec, n * nbits))
            {
                if (NULL != (*val = (ASN1char_t *)DecMemReAlloc(dec, *val, m + n + 1)))
                {
                    p = *val + m;
                    m += n;
                    for (i = n; i; i--)
                    {
                        chr.value = ASN1bitgetu(dec->pos, dec->bit, nbits);
                        PerDecAdvance(dec, nbits);
                        entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                            table->length, sizeof(ASN1stringtableentry_t),
                            ASN1CmpStringTableEntriesByIndex);
                        if (entry)
                        {
                            *p++ = (ASN1char_t) (entry->lower + (chr.value - entry->value));
                        }
                        else
                        {
                            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                            return 0;
                        }
                    }
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);

    if (!*val)
        *val = (ASN1char_t *)DecMemAlloc(dec, 1);
    if (*val)
        (*val)[m] = 0;
    return 1;
}
#endif // ENABLE_ALL

/* decode a fragmented zero-terminated 16 bit table string */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedZeroTableChar16String(ASN1decoding_t dec, ASN1char16_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1uint32_t m, n, i;
    ASN1stringtableentry_t chr, *entry;
    ASN1char16_t *p;

    *val = 0;
    m = 0;
    chr.lower = chr.upper = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            if (ASN1PERDecCheck(dec, n * nbits))
            {
                if (NULL != (*val = (ASN1char16_t *)DecMemReAlloc(dec, *val, (m + n + 1) * sizeof(ASN1char16_t))))
                {
                    p = *val + m;
                    m += n;
                    for (i = n; i; i--)
                    {
                        chr.value = ASN1bitgetu(dec->pos, dec->bit, nbits);
                        PerDecAdvance(dec, nbits);
                        entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                            table->length, sizeof(ASN1stringtableentry_t),
                            ASN1CmpStringTableEntriesByIndex);
                        if (entry)
                        {
                            *p++ = (ASN1char16_t) (entry->lower + (chr.value - entry->value));
                        }
                        else
                        {
                            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                            return 0;
                        }
                    }
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);

    if (!*val)
        *val = (ASN1char16_t *)DecMemAlloc(dec, sizeof(ASN1char16_t));
    if (*val)
        (*val)[m] = 0;
    return 1;
}
#endif // ENABLE_ALL

/* decode a fragmented zero-terminated 32 bit table string */
#ifdef ENABLE_ALL
int ASN1PERDecFragmentedZeroTableChar32String(ASN1decoding_t dec, ASN1char32_t **val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1uint32_t m, n, i;
    ASN1stringtableentry_t chr, *entry;
    ASN1char32_t *p;

    *val = 0;
    m = 0;
    chr.lower = chr.upper = 0;
    do {
        if (ASN1PERDecFragmentedLength(dec, &n))
        {
            if (!n)
                break;
            if (ASN1PERDecCheck(dec, n * nbits))
            {
                if (NULL != (*val = (ASN1char32_t *)DecMemReAlloc(dec, *val, (m + n + 1) * sizeof(ASN1char32_t))))
                {
                    p = *val + m;
                    m += n;
                    for (i = n; i; i--)
                    {
                        chr.value = ASN1bitgetu(dec->pos, dec->bit, nbits);
                        PerDecAdvance(dec, nbits);
                        entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                            table->length, sizeof(ASN1stringtableentry_t),
                            ASN1CmpStringTableEntriesByIndex);
                        if (entry)
                        {
                            *p++ = entry->lower + (chr.value - entry->value);
                        }
                        else
                        {
                            ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                            return 0;
                        }
                    }
                }
                else
                {
                    return 0;
                }
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    } while (n >= 0x4000);

    if (!*val)
        *val = (ASN1char32_t *)DecMemAlloc(dec, sizeof(ASN1char32_t));
    if (*val)
        (*val)[m] = 0;
    return 1;
}
#endif // ENABLE_ALL

/* decode a generalized time */
int ASN1PERDecGeneralizedTime(ASN1decoding_t dec, ASN1generalizedtime_t *val, ASN1uint32_t nbits)
{
    ASN1ztcharstring_t time;
    if (ASN1PERDecFragmentedZeroCharString(dec, &time, nbits))
    {
        int rc = ASN1string2generalizedtime(val, time);
        DecMemFree(dec, time);
        if (rc)
        {
            return 1;
        }
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
    }
    return 0;
}

/* decode a utc time */
#ifdef ENABLE_ALL
int ASN1PERDecUTCTime(ASN1decoding_t dec, ASN1utctime_t *val, ASN1uint32_t nbits)
{
    ASN1ztcharstring_t time;
    if (ASN1PERDecFragmentedZeroCharString(dec, &time, nbits))
    {
        int rc = ASN1string2utctime(val, time);
        DecMemFree(dec, time);
        if (rc)
        {
            return 1;
        }
        ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
    }
    return 0;
}
#endif // ENABLE_ALL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\msasn1\perfn.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"
#include "cintern.h"

#ifdef TEST_CODER
typedef struct ASN1testcoder_s
{
    struct ASN1INTERNencoding_s     e;
    struct ASN1INTERNdecoding_s     d;
}   *ASN1testcoder_t;
#define ASN1_TEST_CODER_SIZE    (sizeof(struct ASN1testcoder_s))
int TestEnc_InitCoder(ASN1INTERNencoding_t e, ASN1module_t mod);
int TestDec_InitCoder(ASN1INTERNdecoding_t d, ASN1module_t mod);
int TestEnc_Compare(ASN1INTERNencoding_t e, ASN1uint32_t id, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize);
int TestDec_Compare(ASN1INTERNdecoding_t d, ASN1uint32_t id, void *valref, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize);
#else
#define ASN1_TEST_CODER_SIZE    0
#endif


/* init an ASN1encoding_t */
ASN1error_e ASN1_CreateEncoder
(
    ASN1module_t        mod,
    ASN1encoding_t     *enc,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1encoding_t      pParent
)
{
    if (NULL != mod && NULL != enc)
    {
        ASN1INTERNencoding_t    e;

        *enc = NULL;

        /* construct ASN1encoding_t */
        e = (ASN1INTERNencoding_t)MemAlloc(sizeof(*e) + ASN1_TEST_CODER_SIZE, mod->nModuleName);
        if (NULL != e)
        {
            ZeroMemory(e, sizeof(*e) + ASN1_TEST_CODER_SIZE);
            e->info.magic = MAGIC_ENCODER;
            e->info.err = ASN1_SUCCESS;
            // e->info.pos = e->info.buf = NULL;
            // e->info.size = e->info.len = e->info.bit = 0;
            e->info.dwFlags = mod->dwFlags;
            e->info.module = mod;
            // e->child = NULL;

            /* set buffer if given */
            if (NULL != pbBuf && cbBufSize)
            {
                e->info.dwFlags |= ASN1ENCODE_SETBUFFER;
                e->info.pos = e->info.buf = pbBuf;
                e->info.size = cbBufSize;
            }

            /* set parent if parented, otherwise, initialized to itself */
            if (NULL != pParent)
            {
                e->parent = (ASN1INTERNencoding_t) pParent;
                e->info.eRule = pParent->eRule;
            }
            else
            {
                e->parent = e;
                e->info.eRule = mod->eRule;
            }

            // e->mem = NULL;
            // e->memlength = 0;
            // e->memsize = 0;
            // e->epi = NULL;
            // e->epilength = 0;
            // e->episize = 0;
            // e->csi = NULL;
            // e->csilength = 0;
            // e->csisize = 0;

            if (! (e->info.dwFlags & ASN1ENCODE_SETBUFFER) && (NULL != pParent))
            {
                // lonchanc: make sure we have a minimum 256 bytes available.
                BOOL fRet = FALSE;
                if (ASN1_PER_RULE & e->info.eRule)
                {
                    // this is required for h245.
                    fRet = ASN1PEREncCheck((ASN1encoding_t) e, 1);
                }
#ifdef ENABLE_BER
                else
                if (ASN1_BER_RULE & e->info.eRule)
                {
                    // this is required for h245.
                    fRet = ASN1BEREncCheck((ASN1encoding_t) e, 1);
                }
#endif // ENABLE_BER
                else
                {
                    EncAssert((ASN1encoding_t) e, 0);
                    MemFree(e);
                    return ASN1_ERR_RULE;
                }
                if (fRet)
                {
                    // lonchanc: make sure the first byte is zeroed out, which
                    // is required for h245.
                    e->info.buf[0] = '\0';
                }
                else
                {
                    MemFree(e);
                    return ASN1_ERR_MEMORY;
                }
            }

#if defined(TEST_CODER) && defined(_DEBUG)
            TestEnc_InitCoder(e, mod);
#endif // defined(TEST_CODER) && defined(_DEBUG)

            if (NULL != pParent)
            {
                EncAssert((ASN1encoding_t) e, NULL == ((ASN1INTERNencoding_t) pParent)->child);
                ((ASN1INTERNencoding_t) pParent)->child = e;
            }

            *enc = (ASN1encoding_t) e;
            return ASN1_SUCCESS;
        }
        else
        {
            return ASN1_ERR_MEMORY;
        }
    }

    return ASN1_ERR_BADARGS;
}

/* encode a value */
ASN1error_e ASN1_Encode
(
    ASN1encoding_t      enc,
    void               *value,
    ASN1uint32_t        id,
    ASN1uint32_t        flags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
)
{
    if (NULL != enc)
    {
        ASN1INTERNencoding_t    e = (ASN1INTERNencoding_t)enc;

        /* check magic numbers */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        /* clear error */
        ASN1EncSetError(enc, ASN1_SUCCESS);

        /* new buffer given? */
        if (flags & ASN1ENCODE_SETBUFFER)
        {
            e->info.dwFlags |= ASN1ENCODE_SETBUFFER;
            enc->pos = enc->buf = pbBuf;
            enc->size = cbBufSize;
            enc->len = enc->bit = 0;
        }
        /* use a new buffer? */
        else if ((e->info.dwFlags | flags) & ASN1ENCODE_ALLOCATEBUFFER)
        {
            e->info.dwFlags &= ~ASN1ENCODE_SETBUFFER;
            enc->pos = enc->buf = NULL;
            enc->size = enc->len = enc->bit = 0;
        }
        /* reuse buffer? */
        else if ((flags & ASN1ENCODE_REUSEBUFFER) || !((e->info.dwFlags | flags) & ASN1ENCODE_APPEND))
        {
            EncAssert(enc, NULL != enc->buf);
            enc->pos = enc->buf;
            enc->bit = enc->len = 0;
        }
        /* otherwise append to buffer */

        /* check id number */
        if (id < enc->module->cPDUs)
        {
            if (ASN1_PER_RULE & enc->eRule)
            {
                /* encode value */
                ASN1PerEncFun_t pfnPER;
                if (NULL != (pfnPER = enc->module->PER.apfnEncoder[id]))
                {
                    if ((*pfnPER)(enc, value))
                    {
                        ASN1PEREncFlush(enc);
                    }
                    else
                    {
                        // the error code must be an error
                        if (ASN1_SUCCEEDED(e->parent->info.err))
                        {
                            // cannot return here immediately because we need to do cleanup
                            ASN1EncSetError(enc, ASN1_ERR_CORRUPT);
                        }
                    }
                }
                else
                {
                    return ASN1EncSetError(enc, ASN1_ERR_BADPDU);
                }
            }
#ifdef ENABLE_BER
            else
            if (ASN1_BER_RULE & enc->eRule)
            {
                /* encode value */
                ASN1BerEncFun_t pfnBER;
                if (NULL != (pfnBER = enc->module->BER.apfnEncoder[id]))
                {
                    if ((*pfnBER)(enc, 0, value)) // lonchanc: tag is 0 to make it compiled
                    {
                        ASN1BEREncFlush(enc);
                    }
                    else
                    {
                        // the error code must be an error
                        if (ASN1_SUCCEEDED(e->parent->info.err))
                        {
                            // cannot return here immediately because we need to do cleanup
                            ASN1EncSetError(enc, ASN1_ERR_CORRUPT);
                        }
                    }
                }
                else
                {
                    return ASN1EncSetError(enc, ASN1_ERR_BADPDU);
                }
            }
#endif // ENABLE_BER
            else
            {
                return ASN1EncSetError(enc, ASN1_ERR_RULE);
            }

            /* call abort/done function for non-parented encoding stream */
            if (ASN1_SUCCEEDED(e->parent->info.err))
            {
                // not parented
                if (e == e->parent)
                {
#if defined(TEST_CODER) && defined(_DEBUG)
                    if (ASN1_PER_RULE & enc->eRule)
                    {
                        if (! TestEnc_Compare(e, id, enc->buf + enc->cbExtraHeader, enc->len - enc->cbExtraHeader))
                        {
                            MyDebugBreak();
                        }
                    }
#ifdef ENABLE_BER
                    else
                    if (ASN1_BER_RULE & enc->eRule)
                    {
                        if (! TestEnc_Compare(e, id, enc->buf + enc->cbExtraHeader, enc->len - enc->cbExtraHeader))
                        {
                            MyDebugBreak();
                        }
                    }
#endif // ENABLE_BER
#endif
                    ASN1EncDone(enc);
                }
            }
            else
            {
                ASN1INTERNencoding_t child, child2;

                // not parented
                if (e == e->parent)
                {
                    ASN1EncAbort(enc);
                }

                // clean up...
                if ((e->info.dwFlags | flags) & ASN1ENCODE_ALLOCATEBUFFER)
                {
                    ASN1_FreeEncoded(enc, enc->buf);
                    enc->pos = enc->buf = NULL;
                    enc->size = enc->len = enc->bit = 0;
                }
                for (child = e->child; child; child = child2)
                {
                    child2 = child->child;
                    // make sure it does not touch its parent which may already be freed
                    child->parent = child;
                    ASN1_CloseEncoder2((ASN1encoding_t) child);
                }
                e->child = NULL;
            }

            /* return error code */
            return e->parent->info.err;
        }
        else
        {
            return ASN1EncSetError(enc, ASN1_ERR_BADPDU);
        }
    }

    return ASN1_ERR_BADARGS;
}

/* control function for encoding */
ASN1error_e ASN1_SetEncoderOption
(
    ASN1encoding_t      enc,
    ASN1optionparam_t  *pOptParam
)
{
    if (NULL != enc && NULL != pOptParam)
    {
        ASN1INTERNencoding_t e = (ASN1INTERNencoding_t)enc;
        ASN1error_e rc = ASN1_SUCCESS;

        /* check magic number */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        switch (pOptParam->eOption)
        {
        case ASN1OPT_CHANGE_RULE:
            enc->eRule = pOptParam->eRule;
            break;

        case ASN1OPT_NOT_REUSE_BUFFER:
            e->info.dwFlags &= ~ASN1ENCODE_SETBUFFER;
            enc->buf = enc->pos = NULL;
            enc->size = enc->bit = enc->len = 0;
            break;

        case ASN1OPT_REWIND_BUFFER:
            enc->pos = enc->buf;
            enc->bit = enc->len = 0;
            break;

        default:
            rc = ASN1_ERR_BADARGS;
            break;
        }

        return ASN1EncSetError(enc, rc);
    }

    return ASN1_ERR_BADARGS;
}

ASN1error_e ASN1_GetEncoderOption
(
    ASN1encoding_t      enc,
    ASN1optionparam_t  *pOptParam
)
{
    if (NULL != enc && NULL != pOptParam)
    {
        ASN1INTERNencoding_t e = (ASN1INTERNencoding_t)enc;
        ASN1error_e rc = ASN1_SUCCESS;

        /* check magic number */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        switch (pOptParam->eOption)
        {
        case ASN1OPT_GET_RULE:
            pOptParam->eRule = enc->eRule;
            break;

        default:
            rc = ASN1_ERR_BADARGS;
            break;
        }

        return ASN1EncSetError(enc, rc);
    }

    return ASN1_ERR_BADARGS;
}


/* destroy encoding stream */
void ASN1_CloseEncoder
(
    ASN1encoding_t      enc
)
{
    if (NULL != enc)
    {
        ASN1INTERNencoding_t e = (ASN1INTERNencoding_t)enc;

        /* check magic number */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        if (e != e->parent)
        {
            EncAssert(enc, e == e->parent->child);
            e->parent->child = NULL;
        }

        /* free encoding stream */
        MemFree(e);
    }
}

/* destroy encoding stream */
void ASN1_CloseEncoder2
(
    ASN1encoding_t      enc
)
{
    if (NULL != enc)
    {
        /* check magic number */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        EncMemFree(enc, enc->buf);

        ASN1_CloseEncoder(enc);
    }
}

/* init an ASN1decoding_t */
ASN1error_e ASN1_CreateDecoder
(
    ASN1module_t        mod,
    ASN1decoding_t     *dec,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1decoding_t      pParent
)
{
    return ASN1_CreateDecoderEx(mod, dec, pbBuf, cbBufSize, pParent, ASN1FLAGS_NONE);
}

ASN1error_e ASN1_CreateDecoderEx
(
    ASN1module_t        mod,
    ASN1decoding_t     *dec,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize,
    ASN1decoding_t      pParent,
    ASN1uint32_t        dwFlags
)
{
    if (NULL != mod && NULL != dec)
    {
        ASN1INTERNdecoding_t d;

        *dec = NULL;

        /* construct ASN1decoding_t */
        d = (ASN1INTERNdecoding_t)MemAlloc(sizeof(*d) + ASN1_TEST_CODER_SIZE, mod->nModuleName);
        if (NULL != d)
        {
            ZeroMemory(d, sizeof(*d) + ASN1_TEST_CODER_SIZE);
            d->info.magic = MAGIC_DECODER;
            d->info.err = ASN1_SUCCESS;
            d->info.dwFlags = mod->dwFlags;
            d->info.module = mod;
            // d->child = NULL;

            /* set parent if parented */
            if (NULL != pParent)
            {
                DecAssert((ASN1decoding_t) d, NULL == ((ASN1INTERNdecoding_t) pParent)->child);
                ((ASN1INTERNdecoding_t) pParent)->child = d;
                d->parent = (ASN1INTERNdecoding_t) pParent;
                d->info.eRule = pParent->eRule;
            }
            else
            /* initialize otherwise */
            {
                d->parent = d;
                d->info.eRule = mod->eRule;
            }

            /* set buffer if given */
            // lonchanc: it is ok to have a zero buffer size here
            if (NULL != pbBuf)
            {
                d->info.dwFlags |= ASN1DECODE_SETBUFFER;
                d->info.buf = d->info.pos = pbBuf;
                d->info.size = cbBufSize;
                // d->info.len = d->info.bit = 0;
                if ((dwFlags & ASN1DECODE_AUTOFREEBUFFER)
                    && !d->parent->fExtBuf)
                {
                    // dbarlow: It's possible the buffer isn't really
                    //          allocated, but instead came from the
                    //          parent's Extension buffer.
                    d->info.dwFlags |= ASN1DECODE_AUTOFREEBUFFER;
                }
            }
            // else
            // {
                  // d->info.buf = d->info.pos = NULL;
                  // d->info.size = d->info.len = d->info.bit = 0;
            // }

            // d->mem = NULL;
            // d->memlength = 0;
            // d->memsize = 0;
            // d->epi = NULL;
            // d->epilength = 0;
            // d->episize = 0;
            // d->csi = NULL;
            // d->csilength = 0;
            // d->csisize = 0;

#if defined(TEST_CODER) && defined(_DEBUG)
            TestDec_InitCoder(d, mod);
#endif // defined(TEST_CODER) && defined(_DEBUG)

            *dec = (ASN1decoding_t) d;
            return ASN1_SUCCESS;
        }
        else
        {
            if (dwFlags & ASN1DECODE_AUTOFREEBUFFER)
            {
                // dbarlow: It's possible the buffer isn't really
                //          allocated, but instead came from the
                //          parent's Extension buffer.
                d = (ASN1INTERNdecoding_t)pParent;
                if ((NULL == d) || !d->fExtBuf)
                {
                    MemFree(pbBuf);
                }
            }
            return ASN1_ERR_MEMORY;
        }
    }

    return ASN1_ERR_BADARGS;
}

/* decode a value */
ASN1error_e ASN1_Decode
(
    ASN1decoding_t      dec,
    void              **valref,
    ASN1uint32_t        id,
    ASN1uint32_t        flags,
    ASN1octet_t        *pbBuf,
    ASN1uint32_t        cbBufSize
)
{
    if (NULL != dec && NULL != valref)
    {
        ASN1INTERNdecoding_t    d = (ASN1INTERNdecoding_t)dec;

        /* check magic numbers */
        DecAssert(dec, MAGIC_DECODER == dec->magic);

        /* clear error */
        ASN1DecSetError(dec, ASN1_SUCCESS);

        /* new buffer given? */
        if (flags & ASN1DECODE_SETBUFFER)
        {
            if (NULL != pbBuf && 0 != cbBufSize)
            {
                dec->pos = dec->buf = pbBuf;
                dec->size = cbBufSize;
                dec->bit = dec->len = 0;
            }
            else
            {
                return ASN1DecSetError(dec, ASN1_ERR_BADARGS);
            }
        }
        /* rewind buffer? */
        else if ((flags & ASN1DECODE_REWINDBUFFER) ||
                 !((d->info.dwFlags | flags ) & ASN1DECODE_APPENDED))
        {
            dec->pos = dec->buf;
            dec->bit = dec->len = 0;
        }
        /* otherwise continue reading from last buffer */

        /* check id number */
        if (id < dec->module->cPDUs)
        {
            ASN1uint32_t cbTopLevelStruct;

            /* clear length of linear buffer required */
            d->cbLinearBufSize = 0;

            /* double check for the availability of destination buffer */
            if (d->lpOrigExtBuf == NULL || d->cbOrigExtBufSize == 0)
            {
                d->fExtBuf = FALSE;
            }

            cbTopLevelStruct = dec->module->acbStructSize[id];
            if (NULL != (*valref = DecMemAlloc(dec, cbTopLevelStruct)))
            {
                if (ASN1_PER_RULE & dec->eRule)
                {
                    ASN1PerDecFun_t pfnPER;
                    /* decode value */
                    if (NULL != (pfnPER = dec->module->PER.apfnDecoder[id]))
                    {
                        if ((*pfnPER)(dec, *valref))
                        {
                            ASN1PERDecFlush(dec);
                        }
                        else
                        {
                            // the error code must be an error
                            if (ASN1_SUCCEEDED(d->parent->info.err))
                            {
                                // cannot return here immediately because we need to do cleanup
                                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                            }
                        }
                    }
                    else
                    {
                        return ASN1DecSetError(dec, ASN1_ERR_BADPDU);
                    }
                }
#ifdef ENABLE_BER
                else
                if (ASN1_BER_RULE & dec->eRule)
                {
                    ASN1BerDecFun_t pfnBER;
                    /* decode value */
                    if (NULL != (pfnBER = dec->module->BER.apfnDecoder[id]))
                    {
                        if ((*pfnBER)(dec, 0, *valref)) // lonchanc: tag is 0 to make it compiled
                        {
                            ASN1BERDecFlush(dec);
                        }
                        else
                        {
                            // the error code must be an error
                            if (ASN1_SUCCEEDED(d->parent->info.err))
                            {
                                // cannot return here immediately because we need to do cleanup
                                ASN1DecSetError(dec, ASN1_ERR_CORRUPT);
                            }
                        }
                    }
                    else
                    {
                        return ASN1DecSetError(dec, ASN1_ERR_BADPDU);
                    }
                }
#endif // ENABLE_BER
                else
                {
                    return ASN1DecSetError(dec, ASN1_ERR_RULE);
                }

                /* call abort/done function for non-parented decoding stream */
                if (ASN1_SUCCEEDED(d->parent->info.err))
                {
                    // not parented
                    if (d == d->parent)
                    {
#if defined(TEST_CODER) && defined(_DEBUG)
                        if (ASN1_PER_RULE & dec->eRule)
                        {
                            if (! TestDec_Compare(d, id, *valref, dec->buf, dec->len))
                            {
                                MyDebugBreak();
                            }
                        }
#ifdef ENABLE_BER
                        else
                        if (ASN1_BER_RULE & dec->eRule)
                        {
                            if (! TestDec_Compare(d, id, *valref, dec->buf, dec->len))
                            {
                                MyDebugBreak();
                            }
                        }
#endif // ENABLE_BER
#endif
                        ASN1DecDone(dec);
                    }
                }
                else
                {
                    ASN1INTERNdecoding_t child, child2;

                    // not parented
                    if (d == d->parent)
                    {
                        ASN1DecAbort(dec);
                    }

                    // clean up...
                    ASN1_FreeDecoded(dec ,*valref, id);
                    *valref = NULL;
                    for (child = d->child; child; child = child2)
                    {
                        child2 = child->child;
                        // make sure it does not touch its parent which may already be freed
                        child->parent = child;
                        ASN1_CloseDecoder((ASN1decoding_t) child);
                    }
                    d->child = NULL;
                }

                /* return error code */
                return d->parent->info.err;
            }
            else
            {
                return ASN1_ERR_MEMORY;
            }
        }
        else
        {
            return ASN1DecSetError(dec, ASN1_ERR_BADPDU);
        }
    }

    return ASN1_ERR_BADARGS;
}

/* control function for decoding */
ASN1error_e ASN1_SetDecoderOption
(
    ASN1decoding_t      dec,
    ASN1optionparam_t  *pOptParam
)
{
    if (NULL != dec)
    {
        ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t)dec;
        ASN1error_e rc = ASN1_SUCCESS;

        /* check magic number */
        DecAssert(dec, MAGIC_DECODER == dec->magic);

        switch (pOptParam->eOption)
        {
        case ASN1OPT_CHANGE_RULE:
            dec->eRule = pOptParam->eRule;
            break;

        case ASN1OPT_SET_DECODED_BUFFER:
            if (NULL != pOptParam->Buffer.pbBuf && 0 != pOptParam->Buffer.cbBufSize)
            {
                d->fExtBuf = TRUE;
                d->lpOrigExtBuf = pOptParam->Buffer.pbBuf;
                d->cbOrigExtBufSize = pOptParam->Buffer.cbBufSize;
                d->lpRemExtBuf = d->lpOrigExtBuf;
                d->cbRemExtBufSize = d->cbOrigExtBufSize;
            }
            else
            {
                rc = ASN1_ERR_BADARGS;
            }
            break;

        case ASN1OPT_DEL_DECODED_BUFFER:
            d->fExtBuf = FALSE;
            d->lpOrigExtBuf = NULL;
            d->cbOrigExtBufSize = 0;
            d->lpRemExtBuf = NULL;
            d->cbRemExtBufSize = 0;
            break;

        default:
            rc = ASN1_ERR_BADARGS;
            break;
        }

        return ASN1DecSetError(dec, rc);
    }

    return ASN1_ERR_BADARGS;
}


/* control function for decoding */
ASN1error_e ASN1_GetDecoderOption
(
    ASN1decoding_t      dec,
    ASN1optionparam_t  *pOptParam
)
{
    if (NULL != dec)
    {
        ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t)dec;
        ASN1error_e rc = ASN1_SUCCESS;

        /* check magic number */
        DecAssert(dec, MAGIC_DECODER == dec->magic);

        switch (pOptParam->eOption)
        {
        case ASN1OPT_GET_RULE:
            pOptParam->eRule = dec->eRule;
            break;

        case ASN1OPT_GET_DECODED_BUFFER_SIZE:
            pOptParam->cbRequiredDecodedBufSize = d->cbLinearBufSize;
            break;

        default:
            rc = ASN1_ERR_BADARGS;
            break;
        }

        return ASN1DecSetError(dec, rc);
    }

    return ASN1_ERR_BADARGS;
}


/* destroy decoding stream */
void ASN1_CloseDecoder
(
    ASN1decoding_t      dec
)
{
    if (NULL != dec)
    {
        ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t)dec;

        /* check magic number */
        DecAssert(dec, MAGIC_DECODER == dec->magic);

        if (d != d->parent)
        {
            DecAssert(dec, d == d->parent->child);
            d->parent->child = NULL;
        }

        if ((NULL != d->info.buf)
            && (d->info.dwFlags & ASN1DECODE_AUTOFREEBUFFER))
            MemFree(d->info.buf);

        /* free decoding stream */
        MemFree(d);
    }
}

/* free an encoded value */
void ASN1_FreeEncoded
(
    ASN1encoding_t      enc,
    void               *val
)
{
    if (NULL != enc)
    {
        /* check magic number */
        EncAssert(enc, MAGIC_ENCODER == enc->magic);

        EncMemFree(enc, val);
    }
}

/* free a unencoded value */
void ASN1_FreeDecoded
(
    ASN1decoding_t      dec,
    void               *val,
    ASN1uint32_t        id
)
{
    if (NULL != dec)
    {
        ASN1INTERNdecoding_t d = (ASN1INTERNdecoding_t)dec;

        /* check magic number */
        DecAssert(dec, MAGIC_DECODER == dec->magic);

        // same behavior of LocalFree
        if (val != NULL)
        {
            if (id != ASN1DECFREE_NON_PDU_ID)
            {
                ASN1FreeFun_t       pfnFreeMemory;

                /* free value */
                if (id < dec->module->cPDUs)
                {
                    if (NULL != (pfnFreeMemory = dec->module->apfnFreeMemory[id]))
                    {
                        (*pfnFreeMemory)(val);
                    }
                }
                else
                {
                    return;
                }
            }

            // free the top-level structure
            DecMemFree(dec, val);
        }
    }
}


ASN1module_t ASN1_CreateModule
(
    ASN1uint32_t            version,
    ASN1encodingrule_e      eEncodingRule,
    ASN1uint32_t            dwFlags,
    ASN1uint32_t            cPDUs,
    const ASN1GenericFun_t  apfnEncoder[],
    const ASN1GenericFun_t  apfnDecoder[],
    const ASN1FreeFun_t     apfnFreeMemory[],
    const ASN1uint32_t      acbStructSize[],
    ASN1magic_t             nModuleName
)
{
    ASN1module_t module = NULL;

    /* compiler output and library version match together? */
    if (
        // version <= ASN1_THIS_VERSION &&
        NULL != apfnEncoder             &&
        NULL != apfnDecoder             &&
        NULL != apfnFreeMemory          &&
        NULL != acbStructSize)
    {
        if (NULL != (module = (ASN1module_t)MemAlloc(sizeof(*module), nModuleName)))
        {
            module->nModuleName = nModuleName;
            module->eRule = eEncodingRule;
            module->dwFlags = dwFlags;
            module->cPDUs = cPDUs;

            module->apfnFreeMemory = apfnFreeMemory;
            module->acbStructSize = acbStructSize;

            if (ASN1_PER_RULE & eEncodingRule)
            {
                module->PER.apfnEncoder = (const ASN1PerEncFun_t *) apfnEncoder;
                module->PER.apfnDecoder = (const ASN1PerDecFun_t *) apfnDecoder;
            }
#ifdef ENABLE_BER
            else
            if (ASN1_BER_RULE & eEncodingRule)
            {
                module->BER.apfnEncoder = (const ASN1BerEncFun_t *) apfnEncoder;
                module->BER.apfnDecoder = (const ASN1BerDecFun_t *) apfnDecoder;
            }
#endif // ENABLE_BER
        }
    }
    return module;
}


void ASN1_CloseModule(ASN1module_t pModule)
{
    MemFree(pModule);
}



#ifdef TEST_CODER

static int MyMemCmp(ASN1octet_t *p1, ASN1octet_t *p2, ASN1uint32_t c)
{
    BYTE diff;
    while (c--)
    {
        if ((diff = *p1++ - *p2++) != 0)
            return (int) diff;
    }
    return 0;
}

__inline ASN1INTERNencoding_t TestEnc_GetEnc(ASN1INTERNencoding_t e)
    { return &(((ASN1testcoder_t) (e+1))->e); }
__inline ASN1INTERNdecoding_t TestEnc_GetDec(ASN1INTERNencoding_t e)
    { return &(((ASN1testcoder_t) (e+1))->d); }
__inline ASN1INTERNencoding_t TestDec_GetEnc(ASN1INTERNdecoding_t d)
    { return &(((ASN1testcoder_t) (d+1))->e); }
__inline ASN1INTERNdecoding_t TestDec_GetDec(ASN1INTERNdecoding_t d)
    { return &(((ASN1testcoder_t) (d+1))->d); }

static void Test_InitEnc(ASN1INTERNencoding_t e, ASN1module_t mod, ASN1encodingrule_e eRule)
{
    ZeroMemory(e, sizeof(*e));
    e->info.magic = MAGIC_ENCODER;
    e->info.err = ASN1_SUCCESS;
    e->info.module = mod;
    e->info.eRule = eRule;
    e->parent = e;
    e->child = NULL;
}

static void Test_InitDec(ASN1INTERNdecoding_t d, ASN1module_t mod, ASN1encodingrule_e eRule)
{
    ZeroMemory(d, sizeof(*d));
    d->info.magic = MAGIC_DECODER;
    d->info.err = ASN1_SUCCESS;
    d->info.module = mod;
    d->info.eRule = eRule;
    d->parent = d;
    d->child = NULL;
}

static int TestEnc_InitCoder(ASN1INTERNencoding_t e, ASN1module_t mod)
{
    ASN1INTERNencoding_t ee = TestEnc_GetEnc(e);
    ASN1INTERNdecoding_t ed = TestEnc_GetDec(e);
    Test_InitEnc(ee, mod, e->info.eRule);
    Test_InitDec(ed, mod, e->info.eRule);
    return 1;
}

static int TestDec_InitCoder(ASN1INTERNdecoding_t d, ASN1module_t mod)
{
    ASN1INTERNencoding_t de = TestDec_GetEnc(d);
    ASN1INTERNdecoding_t dd = TestDec_GetDec(d);
    Test_InitEnc(de, mod, d->info.eRule);
    Test_InitDec(dd, mod, d->info.eRule);
    return 1;
}

static int Test_Encode(ASN1INTERNencoding_t e, void *value, ASN1uint32_t id)
{
    ASN1encoding_t enc = (ASN1encoding_t) e;

    /* clear error */
    ASN1EncSetError(enc, ASN1_SUCCESS);

    // clean buffer
    enc->pos = enc->buf;
    enc->bit = enc->len = 0;

    if (ASN1_PER_RULE & enc->eRule)
    {
        /* encode value */
        ASN1PerEncFun_t pfnPER;
        if (NULL != (pfnPER = enc->module->PER.apfnEncoder[id]))
        {
            if ((*pfnPER)(enc, value))
            {
                ASN1PEREncFlush(enc);
            }
        }
        else
        {
            return ASN1EncSetError(enc, ASN1_ERR_BADPDU);
        }
    }
#ifdef ENABLE_BER
    else
    if (ASN1_BER_RULE & enc->eRule)
    {
        /* encode value */
        ASN1BerEncFun_t pfnBER;
        if (NULL != (pfnBER = enc->module->BER.apfnEncoder[id]))
        {
            if ((*pfnBER)(enc, 0, value)) // lonchanc: tag is 0 to make it compiled
            {
                ASN1BEREncFlush(enc);
            }
        }
        else
        {
            return ASN1EncSetError(enc, ASN1_ERR_BADPDU);
        }
    }
#endif // ENABLE_BER
    else
    {
        return ASN1EncSetError(enc, ASN1_ERR_RULE);
    }

    /* call abort/done function for non-parented encoding stream */
    if (e->parent->info.err >= 0)
    {
        if (e == e->parent)
        {
            ASN1EncDone(enc);
        }
    }
    else
    {
        ASN1INTERNencoding_t child, child2;

        if (e == e->parent)
        {
            ASN1EncAbort(enc);
        }

        // clean up...
        ASN1_FreeEncoded(enc, enc->buf);
        enc->pos = enc->buf = NULL;
        enc->size = enc->len = enc->bit = 0;
        for (child = e->child; child; child = child2)
        {
            child2 = child->child;
            // make sure it does not touch its parent which may already be freed
            child->parent = child;
            ASN1_CloseEncoder((ASN1encoding_t) child);
        }
        e->child = NULL;
    }

    /* return error code */
    return e->parent->info.err;
}

static int Test_Decode(ASN1INTERNdecoding_t d, void ** valref, ASN1uint32_t id, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize)
{
    ASN1decoding_t dec = (ASN1decoding_t) d;
    ASN1uint32_t cbTopLevelStruct;

    /* clear error */
    ASN1DecSetError(dec, ASN1_SUCCESS);

    // set up buffer containing encoded data
    dec->pos = dec->buf = pbBuf;
    dec->size = cbBufSize;
    dec->bit = dec->len = 0;

    /* clear length of linear buffer required */
    d->cbLinearBufSize = 0;
    d->fExtBuf = FALSE;

    cbTopLevelStruct = dec->module->acbStructSize[id];
    if (NULL != (*valref = DecMemAlloc(dec, cbTopLevelStruct)))
    {
        if (ASN1_PER_RULE & dec->eRule)
        {
            ASN1PerDecFun_t pfnPER;
            /* decode value */
            if (NULL != (pfnPER = dec->module->PER.apfnDecoder[id]))
            {
                if ((*pfnPER)(dec, *valref))
                {
                    ASN1PERDecFlush(dec);
                }
            }
            else
            {
                return ASN1DecSetError(dec, ASN1_ERR_BADPDU);
            }
        }
#ifdef ENABLE_BER
        else
        if (ASN1_BER_RULE & dec->eRule)
        {
            ASN1BerDecFun_t pfnBER;
            /* decode value */
            if (NULL != (pfnBER = dec->module->BER.apfnDecoder[id]))
            {
                if ((*pfnBER)(dec, 0, *valref))
                {
                    ASN1BERDecFlush(dec);
                }
            }
            else
            {
                return ASN1DecSetError(dec, ASN1_ERR_BADPDU);
            }
        }
#endif // ENABLE_BER
        else
        {
            return ASN1DecSetError(dec, ASN1_ERR_RULE);
        }

        /* call abort/done function for non-parented decoding stream */
        if (d->parent->info.err >= 0)
        {
            // not parented
            if (d == d->parent)
            {
                ASN1DecDone(dec);
            }
        }
        else
        {
            ASN1INTERNdecoding_t child, child2;

            // not parented
            if (d == d->parent)
            {
                ASN1DecAbort(dec);
            }

            // clean up...
            ASN1_FreeDecoded(dec ,*valref, id);
            *valref = NULL;
            for (child = d->child; child; child = child2)
            {
                child2 = child->child;
                // make sure it does not touch its parent which may already be freed
                child->parent = child;
                ASN1_CloseDecoder((ASN1decoding_t) child);
            }
            d->child = NULL;
        }
    }
    else
    {
        return ASN1_ERR_MEMORY;
    }

    /* return error code */
    return d->parent->info.err;
}

static void Test_CleanEnc(ASN1INTERNencoding_t e)
{
    if (e->info.buf)
    {
        EncMemFree((ASN1encoding_t) e, e->info.buf);
    }
    Test_InitEnc(e, e->info.module, e->info.eRule);
}

static void Test_CleanDec(ASN1INTERNdecoding_t d)
{
    Test_InitDec(d, d->info.module, d->info.eRule);
}

static int TestEnc_Compare(ASN1INTERNencoding_t e, ASN1uint32_t id, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize)
{
    ASN1INTERNencoding_t ee = TestEnc_GetEnc(e);
    ASN1INTERNdecoding_t ed = TestEnc_GetDec(e);
    int ret;
    void *val = NULL;
    int fRet = 0;

    ee->info.eRule = e->info.eRule;
    ed->info.eRule = e->info.eRule;

    ret = Test_Decode(ed, &val, id, pbBuf, cbBufSize);
    if (ret == ASN1_SUCCESS)
    {
        ret = Test_Encode(ee, val, id);
        if (ret == ASN1_SUCCESS)
        {
            if (ee->info.len == cbBufSize)
            {
                fRet = (MyMemCmp(pbBuf, ee->info.buf, cbBufSize) == 0);
            }
        }
    }

    if (val)
    {
        ASN1_FreeDecoded((ASN1decoding_t) ed, val, id);
    }

    Test_CleanEnc(ee);
    Test_CleanDec(ed);

    return fRet;
}

static int TestDec_Compare(ASN1INTERNdecoding_t d, ASN1uint32_t id, void *val, ASN1octet_t *pbBuf, ASN1uint32_t cbBufSize)
{
    ASN1INTERNencoding_t de = TestDec_GetEnc(d);
    int ret;
    int fRet = 0;

    de->info.eRule = d->info.eRule;

    ret = Test_Encode(de, val, id);
    if (ret == ASN1_SUCCESS)
    {
        if (de->info.len == cbBufSize)
        {
            fRet = (MyMemCmp(pbBuf, de->info.buf, cbBufSize) == 0);
        }
    }

    Test_CleanEnc(de);

    return fRet;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\msasn1\perencod.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include "precomp.h"

#include <math.h>
#include "cintern.h"

#if HAS_IEEEFP_H
#include <ieeefp.h>
#elif HAS_FLOAT_H
#include <float.h>
#endif

#define ENCODE_BUFFER_INCREMENT     1024

void PerEncAdvance(ASN1encoding_t enc, ASN1uint32_t nbits)
{
    enc->pos += ((enc->bit + nbits) >> 3);
    enc->bit = (enc->bit + nbits) & 7;
}

static const ASN1uint8_t c_aBitMask2[] =
{
    0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe
};

/* compare two string table entries */
/* return 0 if a1 == a2, 1 if a1 > a2 and -1 if a1 < a2 */
static int __cdecl ASN1CmpStringTableEntries(const void *a1, const void *a2)
{
    ASN1stringtableentry_t *c1 = (ASN1stringtableentry_t *)a1;
    ASN1stringtableentry_t *c2 = (ASN1stringtableentry_t *)a2;

    if (c1->upper < c2->lower)
        return -1;
    return ((c1->lower > c2->upper) ? 1 : 0);
}

/* check for space in buffer for PER and BER. */
int ASN1EncCheck(ASN1encoding_t enc, ASN1uint32_t noctets)
{
    // any additional space required?
    if (noctets)
    {
        // buffer exists?
        if (NULL != enc->buf)
        {
            // buffer large enough?
            if (enc->size - (enc->pos - enc->buf) - ((enc->bit != 0) ? 1 : 0) >= noctets)
            {
                return 1;
            }

            // static buffer overflow?
            if (enc->dwFlags & ASN1ENCODE_SETBUFFER)
            {
                ASN1EncSetError(enc, ASN1_ERR_OVERFLOW);
                return 0;
            }
            else
            {
                // round up to next 256 byte boundary and resize buffer
                ASN1octet_t *oldbuf = enc->buf;
                // enc->size = ((noctets + (enc->pos - oldbuf) + (enc->bit != 0) - 1) | 255) + 1;
                if (ASN1_PER_RULE & enc->eRule)
                {
                    enc->size += max(noctets,  ENCODE_BUFFER_INCREMENT);
                }
                else
                {
                    enc->size += max(noctets, enc->size);
                }
                enc->buf = (ASN1octet_t *)EncMemReAlloc(enc, enc->buf, enc->size);
                if (NULL != enc->buf)
                {
                    enc->pos = enc->buf + (enc->pos - oldbuf);
                }
                else
                {
                    ASN1EncSetError(enc, ASN1_ERR_MEMORY);
                    return 0;
                }
            }
        }
        else
        {
            // no buffer exists, allocate new one.
            // round up to next 256 byte boundary and allocate buffer
            // enc->size = ((noctets - 1) | 255) + 1;
            enc->size = max(noctets + enc->cbExtraHeader, ENCODE_BUFFER_INCREMENT);
            enc->buf = EncMemAlloc(enc, enc->size);
            if (NULL != enc->buf)
            {
                enc->pos = (ASN1octet_t *) (enc->buf + enc->cbExtraHeader);
            }
            else
            {
                enc->pos = NULL;
                ASN1EncSetError(enc, ASN1_ERR_MEMORY);
                return 0;
            }
        }
    }

    return 1;
}

/* encode a zero octet string of length nbits */
int ASN1PEREncZero(ASN1encoding_t enc, ASN1uint32_t nbits)
{
    /* nothing to encode? */
    if (nbits)
    {
        /* get enough space in buffer */
        if (ASN1PEREncCheck(enc, (nbits + enc->bit + 7) / 8))
        {
            /* clear bits */
            ASN1bitclr(enc->pos, enc->bit, nbits);
            PerEncAdvance(enc, nbits);
            return 1;
        }
        return 0;
    }    
    return 1;
}

/* encode a bit */
int ASN1PEREncBit(ASN1encoding_t enc, ASN1uint32_t val)
{
    /* get enough space in buffer */
    if (ASN1PEREncCheck(enc, 1))
    {
        /* put one bit */
        if (val)
        {
            *enc->pos |= 0x80 >> enc->bit;
        }
        if (enc->bit < 7)
        {
            enc->bit++;
        }
        else
        {
            enc->bit = 0;
            enc->pos++;
        }
        return 1;
    }
    return 0;
}

/* encode an integer value into a bit field of given size */
int ASN1PEREncBitVal(ASN1encoding_t enc, ASN1uint32_t nbits, ASN1uint32_t val)
{
    /* nothing to encode? */
    if (nbits)
    {
        /* get enough space in buffer */
        if (ASN1PEREncCheck(enc, (nbits + enc->bit + 7) / 8))
        {
            /* put bits */
            ASN1bitput(enc->pos, enc->bit, val, nbits);
            PerEncAdvance(enc, nbits);
            return 1;
        }
        return 0;
    }
    return 1;
}

/* encode an integer value of intx type into a bit field of given size */
int ASN1PEREncBitIntx(ASN1encoding_t enc, ASN1uint32_t nbits, ASN1intx_t *val)
{
    /* nothing to encode? */
    if (nbits)
    {
        /* get enough space in buffer */
        if (ASN1PEREncCheck(enc, (nbits + enc->bit + 7) / 8))
        {
            /* stuff sign bits into if value encoding is too small */
            if (nbits > 8 * val->length)
            {
                if (val->value[0] > 0x7f)
                    ASN1bitset(enc->pos, enc->bit, nbits - 8 * val->length);
                else
                    ASN1bitclr(enc->pos, enc->bit, nbits - 8 * val->length);
                PerEncAdvance(enc, nbits - 8 * val->length);
                nbits = 8 * val->length;
            }

            /* copy bits of value */
            ASN1bitcpy(enc->pos, enc->bit, val->value, 8 * val->length - nbits, nbits);
            PerEncAdvance(enc, nbits);
            return 1;
        }
        return 0;
    }
    return 1;
}

/* encode a bit field of given size */
int ASN1PEREncBits(ASN1encoding_t enc, ASN1uint32_t nbits, ASN1octet_t *val)
{
    /* nothing to encode? */
    if (nbits)
    {
        /* get enough space in buffer */
        if (ASN1PEREncCheck(enc, (nbits + enc->bit + 7) / 8))
        {
            /* copy bits */
            ASN1bitcpy(enc->pos, enc->bit, val, 0, nbits);
            PerEncAdvance(enc, nbits);
            return 1;
        }
        return 0;
    }
    return 1;
}

/* encode a normally small integer value */
int ASN1PEREncNormallySmall(ASN1encoding_t enc, ASN1uint32_t val)
{
    ASN1uint32_t noctets;

    /* is normally small ASN1really small? */
    if (val < 64)
    {
        return ASN1PEREncBitVal(enc, 7, val);
    }

    /* large */
    if (ASN1PEREncBitVal(enc, 1, 1))
    {
        ASN1PEREncAlignment(enc);

        noctets = ASN1uint32_uoctets(val);
        if (ASN1PEREncCheck(enc, noctets + 1))
        {
            EncAssert(enc, noctets < 256);
            *enc->pos++ = (ASN1octet_t) noctets;
            ASN1octetput(enc->pos, val, noctets);
            enc->pos += noctets;
            return 1;
        }
    }
    return 0;
}

/* encode a bit field with a normally small length */
int ASN1PEREncNormallySmallBits(ASN1encoding_t enc, ASN1uint32_t nbits, ASN1octet_t *val)
{
    /* is normally small really small? */
    if (nbits <= 64)
    {
        if (ASN1PEREncBitVal(enc, 7, nbits - 1))
        {
            return ASN1PEREncBits(enc, nbits, val);
        }
    }
    /* large */
    else
    {
        if (ASN1PEREncBitVal(enc, 1, 1))
        {
            return ASN1PEREncFragmented(enc, nbits, val, 1);
        }
    }
    return 0;
}

/* encode an octet string of given length */
#ifdef ENABLE_ALL
int ASN1PEREncOctets(ASN1encoding_t enc, ASN1uint32_t noctets, ASN1octet_t *val)
{
    /* nothing to encode? */
    if (noctets)
    {
        /* get enough space in buffer */
        if (ASN1PEREncCheck(enc, noctets + (enc->bit != 0)))
        {
            ASN1bitcpy(enc->pos, enc->bit, val, 0, noctets * 8);
            PerEncAdvance(enc, noctets * 8);
            return 1;
        }
        return 0;
    }
    return 1;
}
#endif // ENABLE_ALL

/* encode a string of given length and fixed character size */
int ASN1PEREncCharString(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits)
{
    /* nothing to encode? */
    if (nchars)
    {
        /* get enough space in buffer */
        if (ASN1PEREncCheck(enc, (nbits * nchars + enc->bit + 7) / 8))
        {
            /* same src and dst charsize? then do it simple (and fast!) */
            if (nbits == 8)
            {
                ASN1bitcpy(enc->pos, enc->bit, (ASN1octet_t *)val, 0, nchars * 8);
                PerEncAdvance(enc, nchars * 8);
                return 1;
            }

            /* copy characters one by one */
            while (nchars--)
            {
                ASN1bitput(enc->pos, enc->bit, *val++, nbits);
                PerEncAdvance(enc, nbits);
            }
            return 1;
        }
        return 0;
    }
    return 1;
}

/* encode a 16 bit string of given length and fixed character size */
int ASN1PEREncChar16String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char16_t *val, ASN1uint32_t nbits)
{
    /* nothing to encode? */
    if (nchars)
    {
        /* octet aligned and same src and dst charsize?
           then do it simple (and fast!) */
        if (!enc->bit && nbits == 16)
        {
            if (ASN1PEREncCheck(enc, nchars * 2))
            {
                while (nchars--)
                {
                    *enc->pos++ = (ASN1octet_t)(*val >> 8);
                    *enc->pos++ = (ASN1octet_t)(*val);
                    val++;
                }
                return 1;
            }
            return 0;
        }

        /* get enough space in buffer */
        if (ASN1PEREncCheck(enc, (nbits * nchars + enc->bit + 7) / 8))
        {
            /* copy characters one by one */
            while (nchars--)
            {
                ASN1bitput(enc->pos, enc->bit, *val++, nbits);
                PerEncAdvance(enc, nbits);
            }
            return 1;
        }
        return 0;
    }
    return 1;
}

/* encode a 32 bit string of given length and fixed character size */
#ifdef ENABLE_ALL
int ASN1PEREncChar32String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char32_t *val, ASN1uint32_t nbits)
{
    /* nothing to encode? */
    if (nchars)
    {
        /* octet aligned and same src and dst charsize?
           then do it simple (and fast!) */
        if (!enc->bit && nbits == 32)
        {
            if (ASN1PEREncCheck(enc, nchars * 4))
            {
                while (nchars--)
                {
                    *enc->pos++ = (ASN1octet_t)(*val >> 24);
                    *enc->pos++ = (ASN1octet_t)(*val >> 16);
                    *enc->pos++ = (ASN1octet_t)(*val >> 8);
                    *enc->pos++ = (ASN1octet_t)(*val);
                    val++;
                }
                return 1;
            }
            return 0;
        }

        /* get enough space in buffer */
        if (ASN1PEREncCheck(enc, (nbits * nchars + enc->bit + 7) / 8))
        {
            /* copy characters */
            while (nchars--)
            {
                ASN1bitput(enc->pos, enc->bit, *val++, nbits);
                PerEncAdvance(enc, nbits);
            }
            return 1;
        }
        return 0;
    }
    return 1;
}
#endif // ENABLE_ALL

/* encode a table string of given length and fixed character size */
int ASN1PEREncTableCharString(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    /* nothing to encode? */
    if (nchars)
    {
        /* get enough space in buffer */
        if (ASN1PEREncCheck(enc, (nbits * nchars + enc->bit + 7) / 8))
        {
            /* copy characters one by one */
            while (nchars--)
            {
                ASN1stringtableentry_t chr, *entry;
                chr.lower = chr.upper = (unsigned char)*val++;
                entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                    table->length, sizeof(ASN1stringtableentry_t),
                    ASN1CmpStringTableEntries);
                ASN1bitput(enc->pos, enc->bit,
                    entry ? entry->value + (chr.lower - entry->lower) : 0, nbits);
                PerEncAdvance(enc, nbits);
            }
            return 1;
        }
        return 0;
    }
    return 1;
}

/* encode a 16 bit table string of given length and fixed character size */
int ASN1PEREncTableChar16String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char16_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    /* nothing to encode? */
    if (nchars)
    {
        /* get enough space in buffer */
        if (ASN1PEREncCheck(enc, (nbits * nchars + enc->bit + 7) / 8))
        {
            /* copy characters one by one */
            while (nchars--)
            {
                ASN1stringtableentry_t chr, *entry;
                chr.lower = chr.upper = *val++;
                entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                    table->length, sizeof(ASN1stringtableentry_t),
                    ASN1CmpStringTableEntries);
                ASN1bitput(enc->pos, enc->bit,
                    entry ? entry->value + (chr.lower - entry->lower) : 0, nbits);
                PerEncAdvance(enc, nbits);
            }
            return 1;
        }
        return 0;
    }
    return 1;
}

/* encode a 32 bit table string of given length and fixed character size */
#ifdef ENABLE_ALL
int ASN1PEREncTableChar32String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char32_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    /* nothing to encode? */
    if (nchars)
    {
        /* get enough space in buffer */
        if (ASN1PEREncCheck(enc, (nbits * nchars + enc->bit + 7) / 8))
        {
            /* copy characters one by one */
            while (nchars--)
            {
                ASN1stringtableentry_t chr, *entry;
                chr.lower = chr.upper = *val++;
                entry = (ASN1stringtableentry_t *)ms_bSearch(&chr, table->values,
                    table->length, sizeof(ASN1stringtableentry_t),
                    ASN1CmpStringTableEntries);
                ASN1bitput(enc->pos, enc->bit,
                    entry ? entry->value + (chr.lower - entry->lower) : 0, nbits);
                PerEncAdvance(enc, nbits);
            }
            return 1;
        }
        return 0;
    }
    return 1;
}
#endif // ENABLE_ALL


/* encode a fragmented string of given length and fixed character size */
int ASN1PEREncFragmentedCharString(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits)
{
    ASN1uint32_t n = 0x4000;

    /* encode fragments */
    while (nchars)
    {
        if (ASN1PEREncFragmentedLength(&n, enc, nchars))
        {
            if (ASN1PEREncCharString(enc, n, val, nbits))
            {
                nchars -= n;
                val += n;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }

    /* add zero length octet if last fragment contained more than 16K chars */
    return ((n < 0x4000) ? 1 : ASN1PEREncFragmentedLength(&n, enc, 0));
}

/* encode a fragmented 16 bit string of given length and fixed character size */
#ifdef ENABLE_ALL
int ASN1PEREncFragmentedChar16String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char16_t *val, ASN1uint32_t nbits)
{
    ASN1uint32_t n = 0x4000;

    /* encode fragments */
    while (nchars)
    {
        if (ASN1PEREncFragmentedLength(&n, enc, nchars))
        {
            if (ASN1PEREncChar16String(enc, n, val, nbits))
            {
                nchars -= n;
                val += n;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }

    /* add zero length octet if last fragment contained more than 16K chars */
    return ((n < 0x4000) ? 1 : ASN1PEREncFragmentedLength(&n, enc, 0));
}
#endif // ENABLE_ALL

/* encode a fragmented 32 bit string of given length and fixed character size */
#ifdef ENABLE_ALL
int ASN1PEREncFragmentedChar32String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char32_t *val, ASN1uint32_t nbits)
{
    ASN1uint32_t n = 0x4000;

    /* encode fragments */
    while (nchars)
    {
        if (ASN1PEREncFragmentedLength(&n, enc, nchars))
        {
            if (ASN1PEREncChar32String(enc, n, val, nbits))
            {
                nchars -= n;
                val += n;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }

    /* add zero length octet if last fragment contained more than 16K chars */
    return ((n < 0x4000) ? 1 : ASN1PEREncFragmentedLength(&n, enc, 0));
}
#endif // ENABLE_ALL

/* encode a fragmented table string of given length and fixed character size */
#ifdef ENABLE_ALL
int ASN1PEREncFragmentedTableCharString(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1uint32_t n = 0x4000;

    /* encode fragments */
    while (nchars)
    {
        if (ASN1PEREncFragmentedLength(&n, enc, nchars))
        {
            if (ASN1PEREncTableCharString(enc, n, val, nbits, table))
            {
                nchars -= n;
                val += n;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }

    /* add zero length octet if last fragment contained more than 16K chars */
    return ((n < 0x4000) ? 1 : ASN1PEREncFragmentedLength(&n, enc, 0));
}
#endif // ENABLE_ALL

/* encode a fragmented 16 bit table string of given length and fixed */
/* character size */
#ifdef ENABLE_ALL
int ASN1PEREncFragmentedTableChar16String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char16_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1uint32_t n = 0x4000;

    /* encode fragments */
    while (nchars)
    {
        if (ASN1PEREncFragmentedLength(&n, enc, nchars))
        {
            if (ASN1PEREncTableChar16String(enc, n, val, nbits, table))
            {
                nchars -= n;
                val += n;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }

    /* add zero length octet if last fragment contained more than 16K chars */
    return ((n < 0x4000) ? 1 : ASN1PEREncFragmentedLength(&n, enc, 0));
}
#endif // ENABLE_ALL

/* encode a fragmented 32 bit table string of given length and fixed */
/* character size */
#ifdef ENABLE_ALL
int ASN1PEREncFragmentedTableChar32String(ASN1encoding_t enc, ASN1uint32_t nchars, ASN1char32_t *val, ASN1uint32_t nbits, ASN1stringtable_t *table)
{
    ASN1uint32_t n = 0x4000;

    /* encode fragments */
    while (nchars)
    {
        if (ASN1PEREncFragmentedLength(&n, enc, nchars))
        {
            if (ASN1PEREncTableChar32String(enc, n, val, nbits, table))
            {
                nchars -= n;
                val += n;
            }
            else
            {
                return 0;
            }
        }
        else
        {
            return 0;
        }
    }

    /* add zero length octet if last fragment contained more than 16K chars */
    return ((n < 0x4000) ? 1 : ASN1PEREncFragmentedLength(&n, enc, 0));
}
#endif // ENABLE_ALL

#if 0
#ifdef ENABLE_ALL
int ASN1PEREncCheckTableCharString(ASN1uint32_t nchars, ASN1char_t *val, ASN1stringtable_t *table)
{
    ASN1stringtableentry_t chr;

    /* check if every char is in given string table */
    while (nchars--) {
        chr.lower = chr.upper = (unsigned char)*val++;
        if (!ms_bSearch(&chr, table->values,
            table->length, sizeof(ASN1stringtableentry_t),
            ASN1CmpStringTableEntries))
            return 0;
    }
    return 1;
}
#endif // ENABLE_ALL

#ifdef ENABLE_ALL
int ASN1PEREncCheckTableChar16String(ASN1uint32_t nchars, ASN1char16_t *val, ASN1stringtable_t *table)
{
    ASN1stringtableentry_t chr;

    /* check if every char is in given string table */
    while (nchars--) {
        chr.lower = chr.upper = *val++;
        if (!ms_bSearch(&chr, table->values,
            table->length, sizeof(ASN1stringtableentry_t),
            ASN1CmpStringTableEntries))
            return 0;
    }
    return 1;
}
#endif // ENABLE_ALL

#ifdef ENABLE_ALL
int ASN1PEREncCheckTableChar32String(ASN1uint32_t nchars, ASN1char32_t *val, ASN1stringtable_t *table)
{
    ASN1stringtableentry_t chr;

    /* check if every char is in given string table */
    while (nchars--) {
        chr.lower = chr.upper = *val++;
        if (!ms_bSearch(&chr, table->values,
            table->length, sizeof(ASN1stringtableentry_t),
            ASN1CmpStringTableEntries))
            return 0;
    }
    return 1;
}
#endif // ENABLE_ALL
#endif // 0

/* remove trailing zero bits of a bit string */
#ifdef ENABLE_ALL
int ASN1PEREncRemoveZeroBits(ASN1uint32_t *nbits, ASN1octet_t *val, ASN1uint32_t minlen)
{
    ASN1uint32_t n;
    int i;

    /* get value */
    n = *nbits;

    /* nothing to scan? */
    if (n > minlen)
    {
        /* let val point to last ASN1octet used */
        val += (n - 1) / 8;

        /* check if broken ASN1octet consist out of zero bits */
        if ((n & 7) && !(*val & c_aBitMask2[n & 7])) {
            n &= ~7;
            val--;
        }

        /* scan complete ASN1octets (memrchr missing ...) */
        if (!(n & 7)) {
            while (n > minlen && !*val) {
                n -= 8;
                val--;
            }
        }

        /* scan current octet bit after bit */
        if (n > minlen) {
            for (i = (n - 1) & 7; i >= 0; i--) {
                if (*val & (0x80 >> i))
                    break;
                n--;
            }
        }

        /* return real bitstring len */
        *nbits = n < minlen ? minlen : n;
    }
    return 1;
}
#endif // ENABLE_ALL

/* encode a fragmented integer of intx type */
#ifdef ENABLE_ALL
int ASN1PEREncFragmentedIntx(ASN1encoding_t enc, ASN1intx_t *val)
{
    ASN1uint32_t noctets;
    ASN1uint32_t n = 0x4000;
    ASN1octet_t *v;
    ASN1uint32_t val1, val2;

    /* get length */
    noctets = val->length;

    /* get value */
    v = val->value;

    /* required size:
         noctets                        for data itself
       + noctets / 0x10000                for 64K-fragment size prefixes
       + ((noctets & 0xc000) > 0)        for last 16K..48K-fragment size prefix
       + 1                                for size prefix of remaining <128 octets
       + ((noctets & 0x3fff) >= 0x80)        for additional octet if rem. data >= 128
    */
    val1 = ((noctets & 0xc000) > 0) ? 1 : 0;
    val2 = ((noctets & 0x3fff) >= 0x80) ? 1 : 0;
    if (ASN1PEREncCheck(enc, noctets + noctets / 0x10000 + val1 + 1 + val2))
    {
        /* encode fragments */
        while (noctets)
        {
            if (ASN1PEREncFragmentedLength(&n, enc, noctets))
            {
                CopyMemory(enc->pos, v, n);
                enc->pos += n;
                noctets -= n;
                v += n;
            }
            else
            {
                return 0;
            }
        }

        /* add zero length octet if last fragment contained more than 16K octets */
        return ((n < 0x4000) ? 1 : ASN1PEREncFragmentedLength(&n, enc, 0));
    }
    return 0;
}
#endif // ENABLE_ALL

/* encode a fragmented unsigned integer of intx type */
#ifdef ENABLE_ALL
int ASN1PEREncFragmentedUIntx(ASN1encoding_t enc, ASN1intx_t *val)
{
    ASN1uint32_t noctets;
    ASN1uint32_t n = 0x4000;
    ASN1octet_t *v;
    ASN1uint32_t val1, val2;

    /* get length */
    noctets = ASN1intx_uoctets(val);

    /* get value */
    v = val->value + val->length - noctets;

    /* required size:
         noctets                        for data itself
       + noctets / 0x10000                for 64K-fragment size prefixes
       + ((noctets & 0xc000) > 0)        for last 16K..48K-fragment size prefix
       + 1                                for size prefix of remaining <128 octets
       + ((noctets & 0x3fff) >= 0x80)        for additional octet if rem. data >= 128
    */
    val1 = ((noctets & 0xc000) > 0) ? 1 : 0;
    val2 = ((noctets & 0x3fff) >= 0x80) ? 1 : 0;
    if (ASN1PEREncCheck(enc, noctets + noctets / 0x10000 + val1 + 1 + val2))
    {
        /* encode fragments */
        while (noctets)
        {
            if (ASN1PEREncFragmentedLength(&n, enc, noctets))
            {
                CopyMemory(enc->pos, v, n);
                enc->pos += n;
                noctets -= n;
                v += n;
            }
            else
            {
                return 0;
            }
        }

        /* add zero length octet if last fragment contained more than 16K octets */
        return ((n < 0x4000) ? 1 : ASN1PEREncFragmentedLength(&n, enc, 0));
    }
    return 0;
}
#endif // ENABLE_ALL

/* encode a fragment length */
int ASN1PEREncFragmentedLength(ASN1uint32_t *len, ASN1encoding_t enc, ASN1uint32_t nitems)
{
    /* always ASN1octet aligned */
    ASN1PEREncAlignment(enc);

    /* fragmented encoding:
     *
     * - nitems < 0x80:
     *     octet #1:
     *         bit 8:    0,
     *         bit 7..1: nitems
     *     octet #2..:
     *         nitems items
     * - 0x80 <= nitems < 0x4000:
     *           octet #1:
     *         bit 8..7: 10,
     *         bit 6..1: bit 14..9 of nitems
     *     octet #2:
     *         bit 8..1: bit 8..1 of nitems
     *     octet #3..:
     *         nitems items
     * - 0x4000 <= nitems < 0x10000:
     *     octet #1:
     *         bit 8..7: 11,
     *         bit 6..1: nitems / 0x4000
     *     octet #2..:
     *         (nitems & 0xc000) items
     * - 0x10000 <= nitems:
     *     octet #1:
     *         bit 8..1: 11000100
     *     octet #2..:
     *         0x10000 items
     */
    if (nitems < 0x80)
    {
        if (ASN1PEREncCheck(enc, 1))
        {
            *enc->pos++ = (ASN1octet_t)nitems;
            *len = nitems;
            return 1;
        }
    }
    else
    if (nitems < 0x4000)
    {
        if (ASN1PEREncCheck(enc, 2))
        {
            *enc->pos++ = (ASN1octet_t)(0x80 | (nitems >> 8));
            *enc->pos++ = (ASN1octet_t)nitems;
            *len = nitems;
            return 1;
        }
    }
    else
    if (nitems < 0x10000)
    {
        if (ASN1PEREncCheck(enc, 1))
        {
            *enc->pos++ = (ASN1octet_t)(0xc0 | (nitems >> 14));
            *len = nitems & 0xc000;
            return 1;
        }
    }
    else
    {
        if (ASN1PEREncCheck(enc, 1))
        {
            *enc->pos++ = (ASN1octet_t)0xc4;
            *len = 0x10000;
            return 1;
        }
    }
    return 0;
}

/* encode a fragment bit string containing nitems of size itemsize */
int ASN1PEREncFragmented(ASN1encoding_t enc, ASN1uint32_t nitems, ASN1octet_t *val, ASN1uint32_t itemsize)
{
    ASN1uint32_t n = 0x4000;
    ASN1uint32_t noctets = (nitems * itemsize + 7) / 8;

    /* required size:
       + noctets                        for data itself
       + nitems / 0x10000                for 64K-fragment size prefixes
       + ((nitems & 0xc000) > 0)        for last 16K..48K-fragment size prefix
       + 1                                for size prefix of remaining <128 ASN1octets
       + ((nitems & 0x3fff) >= 0x80)        for additional ASN1octet if rem. data >= 128
    */
    if (ASN1PEREncCheck(enc, noctets + nitems / 0x10000 + ((nitems & 0xc000) > 0) + 1 + ((nitems & 0x3fff) >= 0x80)))
    {
        /* encode fragments */
        while (nitems)
        {
            if (ASN1PEREncFragmentedLength(&n, enc, nitems))
            {
                ASN1bitcpy(enc->pos, 0, val, 0, n * itemsize);
                PerEncAdvance(enc, n * itemsize);
                nitems -= n;
                val += n * itemsize / 8;
            }
            else
            {
                return 0;
            }
        }

        /* add zero length octet if last fragment contained more than 16K items */
        return ((n < 0x4000) ? 1 : ASN1PEREncFragmentedLength(&n, enc, 0));
    }
    return 0;
}

int ASN1PEREncFlushFragmentedToParent(ASN1encoding_t enc)
{
    // make sure it is parented
    EncAssert(enc, ((ASN1INTERNencoding_t)enc)->parent != (ASN1INTERNencoding_t)enc);

    if (ASN1PEREncFlush(enc))
    {
        if (ASN1PEREncFragmented((ASN1encoding_t) ((ASN1INTERNencoding_t)enc)->parent,
                                 enc->len, enc->buf, 8))
        {
            // reset the buffer, i.e. keep enc->buf and enc->size
            enc->pos = enc->buf;
            enc->len = enc->bit = 0;
            return 1;
        }
    }
    return 0;
}

ASN1octet_t * _PEREncOidNode(ASN1octet_t *p, ASN1uint32_t s)
{
    if (s < 0x80)
    {
        *p++ = (ASN1octet_t)(s);
    }
    else
    if (s < 0x4000)
    {
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    else
    if (s < 0x200000)
    {
        *p++ = (ASN1octet_t)((s >> 14) | 0x80);
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    else
    if (s < 0x10000000)
    {
        *p++ = (ASN1octet_t)((s >> 21) | 0x80);
        *p++ = (ASN1octet_t)((s >> 14) | 0x80);
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    else
    {
        *p++ = (ASN1octet_t)((s >> 28) | 0x80);
        *p++ = (ASN1octet_t)((s >> 21) | 0x80);
        *p++ = (ASN1octet_t)((s >> 14) | 0x80);
        *p++ = (ASN1octet_t)((s >> 7) | 0x80);
        *p++ = (ASN1octet_t)(s & 0x7f);
    }
    return p;
}

/* encode an object identifier */
int ASN1PEREncObjectIdentifier(ASN1encoding_t enc, ASN1objectidentifier_t *val)
{
    ASN1objectidentifier_t obj = *val;
    ASN1uint32_t l = GetObjectIdentifierCount(obj);
    if (l)
    {
        ASN1uint32_t i, s;
        ASN1octet_t *data, *p;
        int rc;

        /* convert object identifier to octets */
        p = data = (ASN1octet_t *)MemAlloc(l * 5, _ModName(enc)); /* max. 5 octets/subelement */
        if (p)
        {
            for (i = 0; i < l; i++)
            {
                s = obj->value;
                obj = obj->next;
                if (!i && l > 1)
                {
                    s = s * 40 + obj->value;
                    obj = obj->next;
                    i++;
                }
                p = _PEREncOidNode(p, s);
            }

            /* encode octet string as fragmented octet string */
            rc = ASN1PEREncFragmented(enc, (ASN1uint32_t) (p - data), data, 8);
            MemFree(data);
            return rc;
        }

        ASN1EncSetError(enc, ASN1_ERR_MEMORY);
        return 0;
    }

    /* encode zero length */
    return ASN1PEREncFragmented(enc, 0, NULL, 8);
}

/* encode an object identifier */
int ASN1PEREncObjectIdentifier2(ASN1encoding_t enc, ASN1objectidentifier2_t *val)
{
    if (val->count)
    {
        ASN1uint32_t i, s;
        ASN1octet_t *data, *p;
        int rc;

        /* convert object identifier to octets */
        p = data = (ASN1octet_t *)MemAlloc(val->count * 5, _ModName(enc)); /* max. 5 octets/subelement */
        if (p)
        {
            for (i = 0; i < val->count; i++)
            {
                s = val->value[i];
                if (!i && val->count > 1)
                {
                    i++;
                    s = s * 40 + val->value[i];
                }
                p = _PEREncOidNode(p, s);
            }

            /* encode octet string as fragmented octet string */
            rc = ASN1PEREncFragmented(enc, (ASN1uint32_t) (p - data), data, 8);
            MemFree(data);
            return rc;
        }

        ASN1EncSetError(enc, ASN1_ERR_MEMORY);
        return 0;
    }

    /* encode zero length */
    return ASN1PEREncFragmented(enc, 0, NULL, 8);
}

/* encode real value with double representation */
int ASN1PEREncDouble(ASN1encoding_t enc, double dbl)
{
    double mantissa;
    int exponent;
    ASN1octet_t mASN1octets[16]; /* should be enough */
    ASN1uint32_t nmASN1octets;
    ASN1octet_t eASN1octets[16]; /* should be enough */
    ASN1uint32_t neASN1octets;
    ASN1octet_t head;
    ASN1uint32_t sign;
    ASN1uint32_t len;
    ASN1uint32_t n;

    /* always octet aligned */
    ASN1PEREncAlignment(enc);

    /* check for PLUS_INFINITY */
    if (ASN1double_ispinf(dbl))
    {
        if (ASN1PEREncCheck(enc, 2))
        {
            *enc->pos++ = 1;
            *enc->pos++ = 0x40;
            return 1;
        }
    }
    else
    /* check for MINUS_INFINITY */
    if (ASN1double_isminf(dbl))
    {
        if (ASN1PEREncCheck(enc, 2))
        {
            *enc->pos++ = 1;
            *enc->pos++ = 0x41;
            return 1;
        }
    }
    else
    /* check for bad real value */
    if (finite(dbl))
    {
        /* encode normal real value */

        /* split into mantissa and exponent */
        mantissa = frexp(dbl, &exponent);

        /* check for zero value */
        if (mantissa == 0.0 && exponent == 0)
        {
            if (ASN1PEREncCheck(enc, 1))
            {
                *enc->pos++ = 0;
                return 1;
            }
        }
        else
        {
            /* get sign bit */
            if (mantissa < 0.0)
            {
                sign = 1;
                mantissa = -mantissa;
            }
            else
            {
                sign = 0;
            }

            /* encode mantissa */
            nmASN1octets = 0;
            while (mantissa != 0.0 && nmASN1octets < sizeof(mASN1octets))
            {
                mantissa *= 256.0;
                exponent -= 8;
                mASN1octets[nmASN1octets++] = (int)mantissa;
                mantissa -= (double)(int)mantissa;
            }

            /* encode exponent and create head octet of encoded value */
            head = (ASN1octet_t) (0x80 | (sign << 6));
            if (exponent <= 0x7f && exponent >= -0x80)
            {
                eASN1octets[0] = (ASN1octet_t)(exponent);
                neASN1octets = 1;
            }
            else
            if (exponent <= 0x7fff && exponent >= -0x8000)
            {
                eASN1octets[0] = (ASN1octet_t)(exponent >> 8);
                eASN1octets[1] = (ASN1octet_t)(exponent);
                neASN1octets = 2;
                head |= 0x01;
            }
            else
            if (exponent <= 0x7fffff && exponent >= -0x800000)
            {
                eASN1octets[0] = (ASN1octet_t)(exponent >> 16);
                eASN1octets[1] = (ASN1octet_t)(exponent >> 8);
                eASN1octets[2] = (ASN1octet_t)(exponent);
                neASN1octets = 3;
                head |= 0x02;
            }
            else
            {
                eASN1octets[0] = 4; /* XXX does not work if int32_t != int */
                eASN1octets[1] = (ASN1octet_t)(exponent >> 24);
                eASN1octets[2] = (ASN1octet_t)(exponent >> 16);
                eASN1octets[3] = (ASN1octet_t)(exponent >> 8);
                eASN1octets[4] = (ASN1octet_t)(exponent);
                neASN1octets = 5;
                head |= 0x03;
            }

            /* encode length into first octet */
            len = 1 + neASN1octets + nmASN1octets;
            if (ASN1PEREncFragmentedLength(&n, enc, len))
            {
                /* check for space for head octet, mantissa and exponent */
                if (ASN1PEREncCheck(enc, len))
                {
                    /* put head octet, mantissa and exponent */
                    *enc->pos++ = head;
                    CopyMemory(enc->pos, eASN1octets, neASN1octets);
                    enc->pos += neASN1octets;
                    CopyMemory(enc->pos, mASN1octets, nmASN1octets);
                    enc->pos += nmASN1octets;
                    return 1;
                }
            }
        }
    }
    else
    {
        ASN1EncSetError(enc, ASN1_ERR_BADREAL);
    }
    /* finished */
    return 0;
}

/* encode an external value */
#ifdef ENABLE_EXTERNAL
int ASN1PEREncExternal(ASN1encoding_t enc, ASN1external_t *val)
{
    ASN1uint32_t t, l;

    if (!val->data_value_descriptor)
        val->o[0] &= ~0x80;

    /* encode identification */
    switch (val->identification.o)
    {
    case ASN1external_identification_syntax_o:
        if (!ASN1PEREncBitVal(enc, 3, 4 | !!val->data_value_descriptor))
            return 0;
        if (!ASN1PEREncObjectIdentifier(enc, &val->identification.u.syntax))
            return 0;
        break;
    case ASN1external_identification_presentation_context_id_o:
        if (!ASN1PEREncBitVal(enc, 3, 2 | !!val->data_value_descriptor))
            return 0;
        ASN1PEREncAlignment(enc);
        l = ASN1uint32_uoctets(val->identification.u.presentation_context_id);
        if (!ASN1PEREncBitVal(enc, 8, l))
            return 0;
        if (!ASN1PEREncBitVal(enc, l * 8,
            val->identification.u.presentation_context_id))
            return 0;
        break;
    case ASN1external_identification_context_negotiation_o:
        if (!ASN1PEREncBitVal(enc, 3, 6 | !!val->data_value_descriptor))
            return 0;
        if (!ASN1PEREncObjectIdentifier(enc, &val->identification.u.context_negotiation.transfer_syntax))
            return 0;
        ASN1PEREncAlignment(enc);
        l = ASN1uint32_uoctets(
            val->identification.u.context_negotiation.presentation_context_id);
        if (!ASN1PEREncBitVal(enc, 8, l))
            return 0;
        if (!ASN1PEREncBitVal(enc, l * 8,
            val->identification.u.context_negotiation.presentation_context_id))
            return 0;
        break;
    default:
        ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
        return 0;
    }

    /* encode value descriptor */
    if (val->o[0] & 0x80)
    {
        t = My_lstrlenA(val->data_value_descriptor);
        if (!ASN1PEREncFragmentedCharString(enc, t,
            val->data_value_descriptor, 8))
            return 0;
    }

    /* encode value */
    switch (val->data_value.o)
    {
    case ASN1external_data_value_notation_o:
        if (!ASN1PEREncBitVal(enc, 2, 0))
            return 0;
        if (!ASN1PEREncFragmented(enc,
            val->data_value.u.notation.length,
            val->data_value.u.notation.encoded, 8))
            return 0;
        break;
    case ASN1external_data_value_encoded_o:
        if (!(val->data_value.u.encoded.length & 7))
        {
            if (!ASN1PEREncBitVal(enc, 2, 1))
                return 0;
            if (!ASN1PEREncFragmented(enc, val->data_value.u.encoded.length / 8,
                val->data_value.u.encoded.value, 8))
                return 0;
        }
        else
        {
            if (!ASN1PEREncBitVal(enc, 2, 2))
                return 0;
            if (!ASN1PEREncFragmented(enc, val->data_value.u.encoded.length,
                val->data_value.u.encoded.value, 1))
                return 0;
        }
        break;
    default:
        ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
        return 0;
    }

    return 1;
}
#endif // ENABLE_EXTERNAL

/* encode an embedded pdv value */
#ifdef ENABLE_EMBEDDED_PDV
int ASN1PEREncEmbeddedPdv(ASN1encoding_t enc, ASN1embeddedpdv_t *val)
{
    ASN1uint32_t l;
    ASN1uint32_t index;
    ASN1uint32_t flag;

    /* search identification */
    if (!ASN1EncSearchEmbeddedPdvIdentification(((ASN1INTERNencoding_t) enc)->parent,
        &val->identification, &index, &flag))
        return 0;

    /* encode EP-A/EP-B flag */
    if (!ASN1PEREncBitVal(enc, 1, flag))
        return 0;

    /* encode index of identification */
    if (!ASN1PEREncNormallySmall(enc, index))
        return 0;

    if (flag)
    {
        /* EP-A encoding: */

        /* encode identification */
        if (!ASN1PEREncBitVal(enc, 3, val->identification.o))
            return 0;
        switch (val->identification.o)
        {
        case ASN1embeddedpdv_identification_syntaxes_o:
            if (!ASN1PEREncObjectIdentifier(enc,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1PEREncObjectIdentifier(enc,
                &val->identification.u.syntaxes.transfer))
                return 0;
            break;
        case ASN1embeddedpdv_identification_syntax_o:
            if (!ASN1PEREncObjectIdentifier(enc, &val->identification.u.syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_presentation_context_id_o:
            ASN1PEREncAlignment(enc);
            l = ASN1uint32_uoctets(
                val->identification.u.presentation_context_id);
            if (!ASN1PEREncBitVal(enc, 8, l))
                return 0;
            if (!ASN1PEREncBitVal(enc, l * 8,
                val->identification.u.presentation_context_id))
                return 0;
            break;
        case ASN1embeddedpdv_identification_context_negotiation_o:
            ASN1PEREncAlignment(enc);
            l = ASN1uint32_uoctets(val->
                identification.u.context_negotiation.presentation_context_id);
            if (!ASN1PEREncBitVal(enc, 8, l))
                return 0;
            if (!ASN1PEREncBitVal(enc, l * 8, val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1PEREncObjectIdentifier(enc,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_transfer_syntax_o:
            if (!ASN1PEREncObjectIdentifier(enc,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case ASN1embeddedpdv_identification_fixed_o:
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }
    }

    /* encode value */
    ASN1PEREncAlignment(enc);
    switch (val->data_value.o)
    {
    case ASN1embeddedpdv_data_value_notation_o:
        if (!ASN1PEREncFragmented(enc,
            val->data_value.u.notation.length,
            val->data_value.u.notation.encoded, 1))
            return 0;
        break;
    case ASN1embeddedpdv_data_value_encoded_o:
        if (!ASN1PEREncFragmented(enc,
            val->data_value.u.encoded.length,
            val->data_value.u.encoded.value, 1))
            return 0;
        break;
    default:
        ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
        return 0;
    }

    return 1;
}
#endif // ENABLE_EMBEDDED_PDV

/* encode an optimized embedded pdv value */
#ifdef ENABLE_EMBEDDED_PDV
int ASN1PEREncEmbeddedPdvOpt(ASN1encoding_t enc, ASN1embeddedpdv_t *val)
{
    /* encode data value */
    switch (val->data_value.o)
    {
    case ASN1embeddedpdv_data_value_notation_o:
        if (!ASN1PEREncFragmented(enc,
            val->data_value.u.notation.length,
            val->data_value.u.notation.encoded, 1))
            return 0;
        break;
    case ASN1embeddedpdv_data_value_encoded_o:
        if (!ASN1PEREncFragmented(enc,
            val->data_value.u.encoded.length,
            val->data_value.u.encoded.value, 1))
            return 0;
        break;
    default:
        ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
        return 0;
    }

    return 1;
}
#endif // ENABLE_EMBEDDED_PDV

/* encode a character string */
#ifdef ENABLE_GENERALIZED_CHAR_STR
int ASN1PEREncCharacterString(ASN1encoding_t enc, ASN1characterstring_t *val)
{
    ASN1uint32_t l;
    ASN1uint32_t index;
    ASN1uint32_t flag;

    /* search identification */
    if (!ASN1EncSearchCharacterStringIdentification(((ASN1INTERNencoding_t) enc)->parent,
        &val->identification, &index, &flag))
        return 0;

    /* encode CS-A/CS-B flag */
    if (!ASN1PEREncBitVal(enc, 1, flag))
        return 0;

    /* encode index of identification */
    if (!ASN1PEREncNormallySmall(enc, index))
        return 0;

    if (flag)
    {
        /* CS-A encoding: */

        /* encode identification */
        if (!ASN1PEREncBitVal(enc, 3, val->identification.o))
            return 0;
        switch (val->identification.o) {
        case ASN1characterstring_identification_syntaxes_o:
            if (!ASN1PEREncObjectIdentifier(enc,
                &val->identification.u.syntaxes.abstract))
                return 0;
            if (!ASN1PEREncObjectIdentifier(enc,
                &val->identification.u.syntaxes.transfer))
                return 0;
            break;
        case ASN1characterstring_identification_syntax_o:
            if (!ASN1PEREncObjectIdentifier(enc, &val->identification.u.syntax))
                return 0;
            break;
        case ASN1characterstring_identification_presentation_context_id_o:
            ASN1PEREncAlignment(enc);
            l = ASN1uint32_uoctets(
                val->identification.u.presentation_context_id);
            if (!ASN1PEREncBitVal(enc, 8, l))
                return 0;
            if (!ASN1PEREncBitVal(enc, l * 8,
                val->identification.u.presentation_context_id))
                return 0;
            break;
        case ASN1characterstring_identification_context_negotiation_o:
            ASN1PEREncAlignment(enc);
            l = ASN1uint32_uoctets(val->
                identification.u.context_negotiation.presentation_context_id);
            if (!ASN1PEREncBitVal(enc, 8, l))
                return 0;
            if (!ASN1PEREncBitVal(enc, l * 8, val->
                identification.u.context_negotiation.presentation_context_id))
                return 0;
            if (!ASN1PEREncObjectIdentifier(enc,
                &val->identification.u.context_negotiation.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_transfer_syntax_o:
            if (!ASN1PEREncObjectIdentifier(enc,
                &val->identification.u.transfer_syntax))
                return 0;
            break;
        case ASN1characterstring_identification_fixed_o:
            break;
        default:
            ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
            return 0;
        }
    }

    /* encode value */
    ASN1PEREncAlignment(enc);
    switch (val->data_value.o)
    {
    case ASN1characterstring_data_value_notation_o:
        if (!ASN1PEREncFragmented(enc,
            val->data_value.u.notation.length,
            val->data_value.u.notation.encoded, 8))
            return 0;
        break;
    case ASN1characterstring_data_value_encoded_o:
        if (!ASN1PEREncFragmented(enc,
            val->data_value.u.encoded.length,
            val->data_value.u.encoded.value, 8))
            return 0;
        break;
    default:
        ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
        return 0;
    }

    return 1;
}
#endif // ENABLE_GENERALIZED_CHAR_STR

/* encode an optimized character string value */
#ifdef ENABLE_GENERALIZED_CHAR_STR
int ASN1PEREncCharacterStringOpt(ASN1encoding_t enc, ASN1characterstring_t *val)
{
    switch (val->data_value.o)
    {
    case ASN1characterstring_data_value_notation_o:
        return ASN1PEREncFragmented(enc,
            val->data_value.u.notation.length,
            val->data_value.u.notation.encoded, 8);
        break;
    case ASN1characterstring_data_value_encoded_o:
        return ASN1PEREncFragmented(enc,
            val->data_value.u.encoded.length,
            val->data_value.u.encoded.value, 8);
        break;
    }

    ASN1EncSetError(enc, ASN1_ERR_INTERNAL);
    return 0;
}
#endif // ENABLE_GENERALIZED_CHAR_STR

/* encode a multibyte string */
#ifdef ENABLE_ALL
int ASN1PEREncMultibyteString(ASN1encoding_t enc, ASN1char_t *val)
{
    return ASN1PEREncFragmented(enc, My_lstrlenA(val), (ASN1octet_t *)val, 8);
}
#endif // ENABLE_ALL

/* encode a generalized time */
int ASN1PEREncGeneralizedTime(ASN1encoding_t enc, ASN1generalizedtime_t *val, ASN1uint32_t nbits)
{
    char time[32];
    if (ASN1generalizedtime2string(time, val))
    {
        return ASN1PEREncFragmentedCharString(enc, My_lstrlenA(time), time, nbits);
    }
    return 0;
}

/* encode a utc time */
#ifdef ENABLE_ALL
int ASN1PEREncUTCTime(ASN1encoding_t enc, ASN1utctime_t *val, ASN1uint32_t nbits)
{
    char time[32];
    if (ASN1utctime2string(time, val))
    {
        return ASN1PEREncFragmentedCharString(enc, My_lstrlenA(time), time, nbits);
    }
    return 0;
}
#endif // ENABLE_ALL

/* end of encoding */
int ASN1PEREncFlush(ASN1encoding_t enc)
{
    /* complete broken octet */
    ASN1PEREncAlignment(enc);

    /* allocate at least one octet */
    if (enc->buf)
    {
        /* fill in zero-octet if encoding is empty bitstring */
        if (enc->buf == enc->pos)
            *enc->pos++ = 0;

        /* calculate length */
        enc->len = (ASN1uint32_t) (enc->pos - enc->buf);

        return 1;
    }

    return ASN1PEREncCheck(enc, 1);
}

/* encode an octet alignment */
void ASN1PEREncAlignment(ASN1encoding_t enc)
{
    /* complete broken octet */
    if (enc->bit)
    {
        enc->pos++;
        enc->bit = 0;
    }
}

/* compare two encodings */
#ifdef ENABLE_ALL
int ASN1PEREncCmpEncodings(const void *p1, const void *p2)
{
    ASN1INTERNencoding_t e1 = (ASN1INTERNencoding_t)p1;
    ASN1INTERNencoding_t e2 = (ASN1INTERNencoding_t)p2;
    ASN1uint32_t l1, l2;
    int r;

    l1 = (ASN1uint32_t) (e1->info.pos - e1->info.buf) + ((e1->info.bit > 0) ? 1 : 0);
    l2 = (ASN1uint32_t) (e2->info.pos - e2->info.buf) + ((e2->info.bit > 0) ? 1 : 0);
    r = memcmp(e1->info.buf, e2->info.buf, l1 < l2 ? l1 : l2);
    if (!r)
        r = l1 - l2;
    return r;
}
#endif // ENABLE_ALL

/* check a bit field for present optionals */
int ASN1PEREncCheckExtensions(ASN1uint32_t nbits, ASN1octet_t *val)
{
    while (nbits >= 8)
    {
        if (*val)
            return 1;
        val++;
        nbits -= 8;
    }
    if (nbits)
    {
        return ((*val & c_aBitMask2[nbits]) ? 1 : 0);
    }
    return 0;
}

/* encode an open type value */
#ifdef ENABLE_ALL
int ASN1PEREncOpenType(ASN1encoding_t enc, ASN1open_t *val)
{
    return ASN1PEREncFragmented(enc, val->length, (ASN1octet_t *)val->encoded, 8);
}
#endif // ENABLE_ALL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\msasn1\precomp.h ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

#include <windows.h>

#define ASN1LIB
#define MULTI_LEVEL_ZONES


#ifdef ENABLE_ALL
#define ENABLE_BER
#define ENABLE_DOUBLE
#define ENABLE_UTF8
// #define ENABLE_REAL
// #define ENABLE_GENERALIZED_CHAR_STR
// #define ENABLE_EXTERNAL
// #define ENABLE_EMBEDDED_PDV
#define ENABLE_COMPARE
#endif


#include "libasn1.h"

#if ! defined(_DEBUG) && defined(TEST_CODER)
#undef TEST_CODER
#endif

#include "cintern.h"
#include "ms_ut.h"

// making a magic number
#define MAKE_STAMP_ID(a,b,c,d)     MAKELONG(MAKEWORD(a,b),MAKEWORD(c,d))

/* magic number for ASN1encoding_t */
#define MAGIC_ENCODER       MAKE_STAMP_ID('E','N','C','D')

/* magic number for ASN1decoding_t */
#define MAGIC_DECODER       MAKE_STAMP_ID('D','E','C','D')
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\ascom.inc ===
##############################################################################
#                                                                            #
#   Microsoft Confidential                                                   #
#   Copyright (C) Microsoft Corporation 1991-97                              #
#   All Rights Reserved.                                                     #
#                                                                            #
##############################################################################
# Changes:                                                                   #
#                                                                            #
#   15Oct96 NFC SFR0563     Set MSC_WARNING_LEVEL to level 3.                #
#   05Feb97 TH  SFR1441     Turn off DCL network layer for App Serving       #
#   07Feb97 OBK SFR1434     Merge SFR1338/1380: Allow for unaligned accesses #
#                                                                            #
##############################################################################


!include $(DEVROOT)\common.inc

INCLUDES=..\h;$(INCLUDES)

########################################################################################
# We cannot compile for WINVER=0x500 due to driver compat issues
########################################################################################

WIN32_DEFINE=-DWIN32=200 -D_CHICAGO_=200 -D_WIN32_WINDOWS=0x040a -D_WIN32_WINNT=0x0400 -D_WIN32_IE=0x0401
C_DEFINES       = $(C_DEFINES) -DSTRICT -DWIN32 -D_WIN32 -DOS_WINDOWS -DWIN_95_32_BIT


!IF "$(PROCESSOR_ARCHITECTURE)" == "ALPHA"
C_DEFINES = $(C_DEFINES) -DDC_NO_UNALIGNED
!ENDIF
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\as16\as16.h ===
// --------------------------------------------------------------------------
//
//  AS16.H
//  
//  Defines for 16-bit patching dll, the vestigial pieces of the dclwin95
//  code we still need in the 32-bit port.
//
//  NOTE ON VARIABLE NAMING CONVENTION:
//      c_ is codeseg   (constant)
//      s_ is local     (writeable, static to file)
//      g_ is global    (writeable, accessed by any file)
//
// --------------------------------------------------------------------------
#ifndef _H_AS16
#define _H_AS16


#define DLL_PROCESS_DETACH      0
#define DLL_PROCESS_ATTACH      1

#define FAR_NULL                ((void FAR*)0L)

#define CODESEG                 _based(_segname("_CODE"))


//
// SYSTEM & APP SHARING HEADERS
//
#include <dcg.h>
#include <ut.h>
#include <dcs.h>
#include <osi.h>
#include <shm.h>
#include <sbc.h>
#include <oe.h>
#include <ssi.h>
#include <host.h>
#include <im.h>
#include <usr.h>
#include <asthk.h>


//
// WINDOWS FUNCTIONS
//

int MyStrcmp(LPCSTR lp1, LPCSTR lp2);


/////////////////////////////////////////////////////////////////////////////
// KERNEL
/////////////////////////////////////////////////////////////////////////////


// Pointer mapping 16<->32
LPVOID  WINAPI MapSL(LPVOID lp16BitPtr);
LPVOID  WINAPI MapLS(LPVOID lp32BitPtr);
void    WINAPI UnMapLS(LPVOID lp16BitMappedPtr);
DWORD   WINAPI GetModuleHandle32(LPSTR);
DWORD   WINAPI GetProcAddress32(DWORD, LPSTR);
HANDLE  WINAPI GetExePtr(HANDLE);

HINSTANCE  WINAPI MapInstance32(DWORD);      // Our wrapper around MaphInstLS

// GetCodeInfo() flags
#define NSTYPE      0x0007
#define NSCODE      0x0000
#define NSDATA      0x0001
#define NSITER      0x0008
#define NSMOVE      0x0010
#define NSSHARE     0x0020
#define HSPRELOAD   0x0040
#define NSERONLY    0x0080
#define NSRELOC     0x0100
#define NSDPL       0x0C00
#define NSDISCARD   0x1000
#define NS286DOS    0xCE06
#define NSALLOCED   0x0002
#define NSLOADED    0x0004
#define NSCOMPR     0x0200
#define NSUSESDATA  0x0400
#define NSKCACHED   0x0800
#define NSUSE32     0x2000
#define NSWINCODE   0x4000
#define NSINROM     0x8000

// Process info
#define GPD_PPI                 0
#define GPD_FLAGS               -4
#define GPD_PARENT              -8
#define GPD_STARTF_FLAGS        -12
#define GPD_STARTF_POS          -16
#define GPD_STARTF_SIZE         -20
#define GPD_STARTF_SHOWCMD      -24
#define GPD_STARTF_HOTKEY       -28
#define GPD_STARTF_SHELLDATA    -32
#define GPD_CURR_PROCESS_ID     -36
#define GPD_CURR_THREAD_ID      -40
#define GPD_EXP_WINVER          -44
#define	GPD_EXP_WINVER          -44
#define GPD_HINST               -48
#define GPD_HUTSTATE		    -52
#define GPD_COMPATFLAGS         -56


// 
// GPD_FLAGS
//
#define GPF_DEBUG_PROCESS       0x00000001
#define GPF_WIN16_PROCESS       0x00000008
#define GPF_DOS_PROCESS         0x00000010
#define GPF_CONSOLE_PROCESS     0x00000020
#define GPF_SERVICE_PROCESS     0x00000100

//
// GPD_STARTF_FLAGS
//
#define STARTF_USESHOWWINDOW    0x00000001
#define STARTF_USESIZE          0x00000002
#define STARTF_USEPOSITION      0x00000004
#define STARTF_FORCEONFEEDBACK  0x00000040
#define STARTF_FORCEOFFFEEDBACK 0x00000080
#define STARTF_USEHOTKEY        0x00000200  
#define STARTF_HASSHELLDATA     0x00000400  

DWORD WINAPI GetProcessDword(DWORD idProcess, int iIndex);
BOOL  WINAPI SetProcessDword(DWORD idProcess, int iIndex, DWORD dwValue);


void WINAPI _EnterWin16Lock(void);
void WINAPI _LeaveWin16Lock(void);


//
// Special krnl386 routine to map unicode to ansi.  We only need thunk for
// converting back.
//
int   WINAPI UniToAnsi(LPWSTR lpwszSrc, LPSTR lpszDst, int cch);

//
// kernel32.dll routine to map back to unicode from ansi.
//
typedef LONG (WINAPI * ANSITOUNIPROC)(DWORD codePage, DWORD dwFlags,
    LPCSTR lpMb, LONG cchMb, LPWSTR lpUni, LONG cchUni);

int AnsiToUni(LPSTR lpMb, int cchMb, LPWSTR lpUni, int cchUni);



//
// dwMask is bitfields, where 1 means that parameter should be thunked as 
// a pointer.  0x00000001 means the 1st param, 0x00000002 means the 2nd, 
// and so on.
//
// The caller is responsible for making sure that the 32-bit address is
// valid to call.
//
DWORD FAR _cdecl CallProcEx32W(DWORD numParams, DWORD dwMask, DWORD lpfn32, ...);


/////////////////////////////////////////////////////////////////////////////
// GDI
/////////////////////////////////////////////////////////////////////////////

//
// Useful DIB def
//
typedef struct tagDIB4
{
    BITMAPINFOHEADER    bi;
    DWORD               ct[16];
} DIB4;


BOOL    WINAPI MakeObjectPrivate(HANDLE, BOOL);

UINT    WINAPI CreateSpb(HDC, int, int);
BOOL    WINAPI SysDeleteObject(HANDLE);
HRGN    WINAPI GetClipRgn(HDC);

UINT    WINAPI Death(HDC);
UINT    WINAPI Resurrection(HDC, DWORD, DWORD, DWORD);
void    WINAPI RealizeDefaultPalette(HDC);
DWORD   WINAPI GDIRealizePalette(HDC);


extern DWORD FAR FT_GdiFThkThkConnectionData[];

typedef BOOL (WINAPI* REALPATBLTPROC)(HDC, int, int, int, int, DWORD);
typedef BOOL (WINAPI* TEXTOUTWPROC)(HDC, int, int, LPCWSTR, int);
typedef BOOL (WINAPI* EXTTEXTOUTWPROC)(HDC, int, int, UINT, LPCRECT, LPCWSTR, UINT, LPINT);
typedef BOOL (WINAPI* POLYLINETOPROC)(HDC, LPCPOINT, int);
typedef BOOL (WINAPI* POLYPOLYLINEPROC)(DWORD, HDC, LPCPOINT, LPINT, int);


typedef BOOL (WINAPI* SETCURSORPROC)(LPCURSORSHAPE lpcurs);
typedef BOOL (WINAPI* SAVEBITSPROC)(LPRECT lprcSave, UINT uCmd);


/////////////////////////////////////////////////////////////////////////////
// USER
/////////////////////////////////////////////////////////////////////////////


#define WOAHACK_CHECKALTKEYSTATE        1
#define WOAHACK_IGNOREALTKEYDOWN        2
#define WOAHACK_DISABLEREPAINTSCREEN    3
#define WOAHACK_LOSINGDISPLAYFOCUS      4
#define WOAHACK_GAININGDISPLAYFOCUS     5
#define WOAHACK_IAMAWINOLDAPPSORTOFGUY  6
#define WOAHACK_SCREENSAVER             7


BOOL  WINAPI RealGetCursorPos(LPPOINT);
void  WINAPI PostPostedMessages(void);
void  WINAPI DispatchInput(void);
LONG  WINAPI WinOldAppHackoMatic(LONG flags);

typedef DWORD (WINAPI* GETWINDOWTHREADPROCESSIDPROC)(HWND, LPDWORD);
typedef LONG  (WINAPI* CDSEXPROC)(LPCSTR, LPDEVMODE, HWND, DWORD, LPVOID);

typedef struct tagCWPSTRUCT
{
    LPARAM  lParam;
    WPARAM  wParam;
    UINT    message;
    HWND    hwnd;
} CWPSTRUCT, FAR* LPCWPSTRUCT;

//
// Cursor stuff
//
#define BitmapWidth(cx, bits)\
    ((((cx)*(bits) + 0x0F) & ~0x0F) >> 3)

#define BitmapSize(cx, cy, planes, bits)\
    (BitmapWidth(cx, bits) * (cy) * (planes))



extern DWORD FAR FT_UsrFThkThkConnectionData[];

void    PostMessageNoFail(HWND, UINT, WPARAM, LPARAM);


//
// Mouse_ and Keybd_ Event stuf
//

//
// For keyboard events, the app API and USER intterrupt flags are different.
// For mouse events, they are the same.
//
#define KEYEVENTF_EXTENDEDKEY   0x0001 
#define KEYEVENTF_KEYUP         0x0002

#define USERKEYEVENTF_EXTENDEDKEY   0x0100
#define USERKEYEVENTF_KEYUP         0x8000

#define MOUSEEVENTF_MOVE        0x0001
#define MOUSEEVENTF_LEFTDOWN    0x0002
#define MOUSEEVENTF_LEFTUP      0x0004
#define MOUSEEVENTF_RIGHTDOWN   0x0008
#define MOUSEEVENTF_RIGHTUP     0x0010
#define MOUSEEVENTF_MIDDLEDOWN  0x0020
#define MOUSEEVENTF_MIDDLEUP    0x0040
#define MOUSEEVENTF_WHEEL       0x0800
#define MOUSEEVENTF_ABSOLUTE    0x8000

void FAR    mouse_event(void);
void FAR    ASMMouseEvent(void);
void        CallMouseEvent(UINT regAX, UINT regBX, UINT regCX, UINT regDX,
                UINT regSI, UINT regDI);

void FAR    keybd_event(void);
void FAR    ASMKeyboardEvent(void);
void        CallKeyboardEvent(UINT regAX, UINT regBX, UINT regSI, UINT regDI);


//
// Signals
//

#define SIG_PRE_FORCE_LOCK      0x0003
#define SIG_POST_FORCE_LOCK     0x0004

BOOL WINAPI SignalProc32(DWORD dwSignal, DWORD dwID, DWORD dwFlags, WORD hTask16);

//
// PATCHING
//


#define OPCODE32_PUSH           0x68
#define OPCODE32_CALL           0xE8
#define OPCODE32_MOVCL          0xB1
#define OPCODE32_MOVCX          0xB966
#define OPCODE32_JUMP4          0xE9

#define OPCODE_MOVAX            0xB8
#define OPCODE_FARJUMP16        0xEA
#define OPCODE32_16OVERRIDE     0x66

#define CB_PATCHBYTES16         5
#define CB_PATCHBYTES32         6
#define CB_PATCHBYTESMAX        max(CB_PATCHBYTES16, CB_PATCHBYTES32)

typedef struct tagFN_PATCH
{
    BYTE    rgbOrg[CB_PATCHBYTESMAX];   // Original function bytes
    BYTE    rgbPatch[CB_PATCHBYTESMAX]; // Patch bytes

    UINT    wSegOrg;                // Original code segment (we fix it)
    UINT    fActive:1;              // Patch has been activated
    UINT    fEnabled:1;             // Patch is currently enabled
    UINT    fSharedAlias:1;         // Don't free selector on destroy
    UINT    fInterruptable:1;       // Interrupt handler
    UINT    f32Bit:1;               // 32-bit code segment
    LPBYTE  lpCodeAlias;            // We keep an alias around to quickly enable/disable
} FN_PATCH, FAR* LPFN_PATCH;


#define ENABLE_OFF      0x0000      // disable end
#define ENABLE_ON       0x0001      // enable start
#define ENABLE_FORCALL  0x8000      // disable/enable for org call
#define ENABLE_MASK     0x8001

#define PATCH_ACTIVATE      (ENABLE_ON)
#define PATCH_DEACTIVATE    (ENABLE_OFF)
#define PATCH_ENABLE        (ENABLE_ON | ENABLE_FORCALL)
#define PATCH_DISABLE       (ENABLE_OFF | ENABLE_FORCALL)


//
// NOTE:  If the function being patched can be called at interrupt time,
// the caller must make sure the jump to function can handle it.
//
// When your patch is called you:
//      * disable your patch with ENABLE_CALLOFF
//      * call the original function
//      * enable your patch with ENABLE_CALLON
//
UINT    CreateFnPatch(LPVOID lpfnToPatch, LPVOID lpfnJumpTo, LPFN_PATCH lpbPatch, UINT selCodeAlias);
void    DestroyFnPatch(LPFN_PATCH lpbPatch);
void    EnableFnPatch(LPFN_PATCH lpbPatch, UINT flags);

BOOL    GetGdi32OnlyExport(LPSTR lpszExport, UINT cbJmpOffset, FARPROC FAR* lplpfn16);
BOOL    GetUser32OnlyExport(LPSTR lpszExport, FARPROC FAR* lplpfn16);
BOOL    Get32BitOnlyExport(DWORD lpfn32, UINT cbJmpOffset, LPDWORD lpThunkTable, FARPROC FAR * lplpfn16);

LPCURSORSHAPE  XformCursorBits(LPCURSORSHAPE lpOrg);


// #define OTRACE      WARNING_OUT
#define OTRACE   TRACE_OUT

#include <globals.h>

#endif // !_H_AS16
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\common.inc ===
#
# COMMON.INC
# Common build rules for NT/Win95 app sharing dll
#
# Copyright(c) Microsoft 1998-
#

nmas.rc:        ..\cpi32\nmas.rc
                del nmas.rc
                copy ..\cpi32\nmas.rc

cpi32dll.cpp:   ..\cpi32\cpi32dll.cpp
                del cpi32dll.cpp
                copy ..\cpi32\cpi32dll.cpp
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\msasn1\types.c ===
/* Copyright (C) Boris Nikolaus, Germany, 1996-1997. All rights reserved. */
/* Copyright (C) Microsoft Corporation, 1997-1998. All rights reserved. */

// lonchanc: when we call any routine in this file, we must use kernel memory,
// otheriwse, the client app should free the buffer in its entirety
// rather than free the structure piece by piece.

#include "precomp.h"

#include <math.h>
#include "ms_ut.h"

#if HAS_IEEEFP_H
#include <ieeefp.h>
#elif HAS_FLOAT_H
#include <float.h>
#endif

const ASN1octet_t ASN1double_pinf_octets[] = DBL_PINF;
const ASN1octet_t ASN1double_minf_octets[] = DBL_MINF;

/* get a positive infinite double value */
double ASN1double_pinf()
{
    double val;
    MyAssert(sizeof(val) == sizeof(ASN1double_pinf_octets));
    CopyMemory(&val, ASN1double_pinf_octets, sizeof(ASN1double_pinf_octets));
    return val;
}

/* get a negative infinite double value */
double ASN1double_minf()
{
    double val;
    MyAssert(sizeof(val) == sizeof(ASN1double_minf_octets));
    CopyMemory(&val, ASN1double_minf_octets, sizeof(ASN1double_minf_octets));
    return val;
}

/* check if double is plus infinity */
int ASN1double_ispinf(double d)
{
#if HAS_FPCLASS
    return !finite(d) && fpclass(d) == FP_PINF;
#elif HAS_ISINF
    return !finite(d) && isinf(d) && copysign(1.0, d) > 0.0;
#else
#error "cannot encode NaN fp values"
#endif
}

/* check if double is minus infinity */
int ASN1double_isminf(double d)
{
#if HAS_FPCLASS
    return !finite(d) && fpclass(d) == FP_NINF;
#elif HAS_ISINF
    return !finite(d) && isinf(d) && copysign(1.0, d) < 0.0;
#else
#error "cannot encode NaN fp values"
#endif
}

/* convert a real value into a double */
#ifdef ENABLE_REAL
double ASN1real2double(ASN1real_t *val)
{
    ASN1intx_t exp;
    ASN1int32_t e;
    double m;

    switch (val->type) {
    case eReal_Normal:
        m = ASN1intx2double(&val->mantissa);
        if (val->base == 10) {
            return m * pow(10.0, (double)ASN1intx2int32(&val->exponent));
        } else {
            if (val->base == 2) {
                if (! ASN1intx_dup(&exp, &val->exponent))
                {
                    return 0.0;
                }
            } else if (val->base == 8) {
                ASN1intx_muloctet(&exp, &val->exponent, 3);
            } else if (val->base == 16) {
                ASN1intx_muloctet(&exp, &val->exponent, 4);
            } else {
                return 0.0;
            }
            e = ASN1intx2int32(&exp);
            ASN1intx_free(&exp);
            return ldexp(m, e);
        }
    case eReal_PlusInfinity:
        return ASN1double_pinf();
    case eReal_MinusInfinity:
        return ASN1double_minf();
    default:
        return 0.0;
    }
}
#endif // ENABLE_REAL

/* free a real value */
#ifdef ENABLE_REAL
void ASN1real_free(ASN1real_t *val)
{
    ASN1intx_free(&val->mantissa);
    ASN1intx_free(&val->exponent);
}
#endif // ENABLE_REAL

/* free a bitstring value */
void ASN1bitstring_free(ASN1bitstring_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}

/* free an octet string value */
void ASN1octetstring_free(ASN1octetstring_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}

/* free an object identifier value */
void ASN1objectidentifier_free(ASN1objectidentifier_t *val)
{
    if (val)
    {
        // lonchanc: we allocate the entire object identifer as a chunk.
        // as a result, we free it only once as a chunk.
        MemFree(*val);
    }
}

/* free a string value */
#ifdef ENABLE_BER
void ASN1charstring_free(ASN1charstring_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}
#endif // ENABLE_BER

/* free a 16 bit string value */
void ASN1char16string_free(ASN1char16string_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}

/* free a 32 bit string value */
#ifdef ENABLE_BER
void ASN1char32string_free(ASN1char32string_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}
#endif // ENABLE_BER

/* free a zero-terminated string value */
void ASN1ztcharstring_free(ASN1ztcharstring_t val)
{
    MemFree(val);
}

/* free a zero-terminated 16 bit string value */
#ifdef ENABLE_BER
void ASN1ztchar16string_free(ASN1ztchar16string_t val)
{
    MemFree(val);
}
#endif // ENABLE_BER

/* free a zero-terminated 32 bit string value */
#ifdef ENABLE_BER
void ASN1ztchar32string_free(ASN1ztchar32string_t val)
{
    MemFree(val);
}
#endif // ENABLE_BER

/* free an external value */
#ifdef ENABLE_EXTERNAL
void ASN1external_free(ASN1external_t *val)
{
    if (val)
    {
        switch (val->identification.o)
        {
        case ASN1external_identification_syntax_o:
            ASN1objectidentifier_free(&val->identification.u.syntax);
            break;
        case ASN1external_identification_presentation_context_id_o:
            break;
        case ASN1external_identification_context_negotiation_o:
            ASN1objectidentifier_free(
                &val->identification.u.context_negotiation.transfer_syntax);
            break;
        }
        ASN1ztcharstring_free(val->data_value_descriptor);
        switch (val->data_value.o)
        {
        case ASN1external_data_value_notation_o:
            ASN1open_free(&val->data_value.u.notation);
            break;
        case ASN1external_data_value_encoded_o:
            ASN1bitstring_free(&val->data_value.u.encoded);
            break;
        }
    }
}
#endif // ENABLE_EXTERNAL

/* free an embedded pdv value */
#ifdef ENABLE_EMBEDDED_PDV
void ASN1embeddedpdv_free(ASN1embeddedpdv_t *val)
{
    if (val)
    {
        switch (val->identification.o)
        {
        case ASN1embeddedpdv_identification_syntaxes_o:
            ASN1objectidentifier_free(&val->identification.u.syntaxes.abstract);
            ASN1objectidentifier_free(&val->identification.u.syntaxes.transfer);
            break;
        case ASN1embeddedpdv_identification_syntax_o:
            ASN1objectidentifier_free(&val->identification.u.syntax);
            break;
        case ASN1embeddedpdv_identification_presentation_context_id_o:
            break;
        case ASN1embeddedpdv_identification_context_negotiation_o:
            ASN1objectidentifier_free(
                &val->identification.u.context_negotiation.transfer_syntax);
            break;
        case ASN1embeddedpdv_identification_transfer_syntax_o:
            ASN1objectidentifier_free(&val->identification.u.transfer_syntax);
            break;
        case ASN1embeddedpdv_identification_fixed_o:
            break;
        }
        switch (val->data_value.o)
        {
        case ASN1embeddedpdv_data_value_notation_o:
            ASN1open_free(&val->data_value.u.notation);
            break;
        case ASN1embeddedpdv_data_value_encoded_o:
            ASN1bitstring_free(&val->data_value.u.encoded);
            break;
        }
    }
}
#endif // ENABLE_EMBEDDED_PDV

/* free a character string value */
#ifdef ENABLE_GENERALIZED_CHAR_STR
void ASN1characterstring_free(ASN1characterstring_t *val)
{
    if (val)
    {
        switch (val->identification.o)
        {
        case ASN1characterstring_identification_syntaxes_o:
            ASN1objectidentifier_free(&val->identification.u.syntaxes.abstract);
            ASN1objectidentifier_free(&val->identification.u.syntaxes.transfer);
            break;
        case ASN1characterstring_identification_syntax_o:
            ASN1objectidentifier_free(&val->identification.u.syntax);
            break;
        case ASN1characterstring_identification_presentation_context_id_o:
            break;
        case ASN1characterstring_identification_context_negotiation_o:
            ASN1objectidentifier_free(
                &val->identification.u.context_negotiation.transfer_syntax);
            break;
        case ASN1characterstring_identification_transfer_syntax_o:
            ASN1objectidentifier_free(&val->identification.u.transfer_syntax);
            break;
        case ASN1characterstring_identification_fixed_o:
            break;
        }
        switch (val->data_value.o)
        {
        case ASN1characterstring_data_value_notation_o:
            ASN1open_free(&val->data_value.u.notation);
            break;
        case ASN1characterstring_data_value_encoded_o:
            ASN1octetstring_free(&val->data_value.u.encoded);
            break;
        }
    }
}
#endif // ENABLE_GENERALIZED_CHAR_STR

/* free an open type value */
#ifdef ENABLE_BER
void ASN1open_free(ASN1open_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->encoded);
    }
}
#endif // ENABLE_BER

#ifdef ENABLE_BER
void ASN1utf8string_free(ASN1wstring_t *val)
{
    if (val)
    {
        // lonchanc: no need to check length because zeroed decoded buffers.
        MemFree(val->value);
    }
}
#endif // ENABLE_BER

/* convert a generalized time value into a string */
int ASN1generalizedtime2string(char *dst, ASN1generalizedtime_t *val)
{
    if (dst && val)
    {
        wsprintfA(dst, "%04d%02d%02d%02d%02d%02d",
            val->year, val->month, val->day,
            val->hour, val->minute, val->second);
        if (val->millisecond) {
            if (!(val->millisecond % 100))
                wsprintfA(dst + 14, ".%01d", val->millisecond / 100);
            else if (!(val->millisecond % 10))
                wsprintfA(dst + 14, ".%02d", val->millisecond / 10);
            else
                wsprintfA(dst + 14, ".%03d", val->millisecond);
        }
        if (val->universal)
            lstrcpyA(dst + lstrlenA(dst), "Z");
        else if (val->diff > 0) {
            if (val->diff % 60) {
                wsprintfA(dst + lstrlenA(dst), "+%04d",
                    100 * (val->diff / 60) + (val->diff % 60));
            } else {
                wsprintfA(dst + lstrlenA(dst), "+%02d",
                    val->diff / 60);
            }
        } else if (val->diff < 0) {
            if (val->diff % 60) {
                wsprintfA(dst + lstrlenA(dst), "-%04d",
                    -100 * (val->diff / 60) - (val->diff % 60));
            } else {
                wsprintfA(dst + My_lstrlenA(dst), "-%02d",
                    -val->diff / 60);
            }
        }
        return 1;
    }
    return 0;
}

/* convert a utc time value into a string */
#ifdef ENABLE_BER
int ASN1utctime2string(char *dst, ASN1utctime_t *val)
{
    if (dst && val)
    {
        wsprintfA(dst, "%02d%02d%02d%02d%02d%02d",
            val->year, val->month, val->day,
            val->hour, val->minute, val->second);
        if (val->universal)
            lstrcpyA(dst + lstrlenA(dst), "Z");
        else if (val->diff > 0) {
            if (val->diff % 60) {
                wsprintfA(dst + lstrlenA(dst), "+%04d",
                    100 * (val->diff / 60) + (val->diff % 60));
            } else {
                wsprintfA(dst + lstrlenA(dst), "+%02d",
                    val->diff / 60);
            }
        } else if (val->diff < 0) {
            if (val->diff % 60) {
                wsprintfA(dst + lstrlenA(dst), "-%04d",
                    -100 * (val->diff / 60) - (val->diff % 60));
            } else {
                wsprintfA(dst + lstrlenA(dst), "-%02d",
                    -val->diff / 60);
            }
        }
        return 1;
    }
    return 0;
}
#endif // ENABLE_BER

/* scan the fraction of a number */
static double scanfrac(char *p, char **e)
{
    double ret = 0.0, d = 1.0;

    while (IsDigit(*p)) {
        d /= 10.0;
        ret += (*p++ - '0') * d;
    }
    *e = p;
    return ret;
}

/* convert a string into a generalized time value */
int ASN1string2generalizedtime(ASN1generalizedtime_t *dst, char *val)
{
    if (dst && val)
    {
        int year, month, day, hour, minute, second, millisecond, diff, universal;
        char *p;
        double f;

        millisecond = second = minute = universal = diff = 0;
        if (My_lstrlenA(val) < 10)
            return 0;
            year = DecimalStringToUINT(val, 4);
            month = DecimalStringToUINT((val+4), 2);
            day = DecimalStringToUINT((val+6), 2);
            hour = DecimalStringToUINT((val+8), 2);
    //  if (sscanf(val, "%04d%02d%02d%02d", &year, &month, &day, &hour) != 4)
    //        return 0;
        p = val + 10;
        if (*p == '.' || *p == ',') {
            p++;
            f = scanfrac(p, &p);
            minute = (int)(f *= 60);
            f -= minute;
            second = (int)(f *= 60);
            f -= second;
            millisecond = (int)(f *= 1000);
        } else if (IsDigit(*p)) {
            minute = DecimalStringToUINT(p, 2);
    //        if (sscanf(p, "%02d", &minute) != 1)
    //            return 0;
            p += 2;
            if (*p == '.' || *p == ',') {
                p++;
                f = scanfrac(p, &p);
                second = (int)(f *= 60);
                f -= second;
                millisecond = (int)(f *= 1000);
            } else if (IsDigit(*p)) {
                    second = DecimalStringToUINT(p, 2);
    //            if (sscanf(p, "%02d", &second) != 1)
    //                return 0;
                p += 2;
                if (*p == '.' || *p == ',') {
                    p++;
                    f = scanfrac(p, &p);
                    millisecond = (int)(f *= 1000);
                }
            }
        }
        if (*p == 'Z') {
            universal = 1;
            p++;
        } else if (*p == '+') {
            f = scanfrac(p + 1, &p);
            diff = (int)(f * 100) * 60 + (int)(f * 10000) % 100;
        } else if (*p == '-') {
            f = scanfrac(p + 1, &p);
            diff = -((int)(f * 100) * 60 + (int)(f * 10000) % 100);
        }
        if (*p)
            return 0;
        dst->year = (ASN1uint16_t)year;
        dst->month = (ASN1uint8_t)month;
        dst->day = (ASN1uint8_t)day;
        dst->hour = (ASN1uint8_t)hour;
        dst->minute = (ASN1uint8_t)minute;
        dst->second = (ASN1uint8_t)second;
        dst->millisecond = (ASN1uint16_t)millisecond;
        dst->universal = (ASN1bool_t)universal;
        dst->diff = (ASN1uint16_t)diff;
        return 1;
    }
    return 0;
}

/* convert a string into a utc time value */
#ifdef ENABLE_BER
int ASN1string2utctime(ASN1utctime_t *dst, char *val)
{
    if (dst && val)
    {
        char *p;
        double f;

        if (My_lstrlenA(val) < 10)
            return 0;

        p = val;
        dst->year = (ASN1uint8_t) DecimalStringToUINT(p, 2);
        p += 2;
        dst->month = (ASN1uint8_t) DecimalStringToUINT(p, 2);
        p += 2;
        dst->day = (ASN1uint8_t) DecimalStringToUINT(p, 2);
        p += 2;
        dst->hour = (ASN1uint8_t) DecimalStringToUINT(p, 2);
        p += 2;
        dst->minute = (ASN1uint8_t) DecimalStringToUINT(p, 2);
        p += 2;

    //    if (sscanf(val, "%02d%02d%02d%02d%02d",
    //        &year, &month, &day, &hour, &minute) != 5)
    //        return 0;
        if (IsDigit(*p))
        {
            dst->second = (ASN1uint8_t) DecimalStringToUINT(p, 2);
    //        if (sscanf(p, "%02d", &second) != 1)
    //            return 0;
            p += 2;
        }
        else
        {
            dst->second = 0;
        }

        dst->universal = 0;
        dst->diff = 0;

        if (*p == 'Z') {
            dst->universal = 1;
            p++;
        } else if (*p == '+') {
            f = scanfrac(p + 1, &p);
            dst->diff = (int)(f * 100) * 60 + (int)(f * 10000) % 100;
        } else if (*p == '-') {
            f = scanfrac(p + 1, &p);
            dst->diff = -((int)(f * 100) * 60 + (int)(f * 10000) % 100);
        }
        return ((*p) ? 0 : 1);
    }
    return 0;
}
#endif // ENABLE_BER


ASN1uint32_t GetObjectIdentifierCount(ASN1objectidentifier_t val)
{
    ASN1uint32_t cObjIds = 0;
    while (val)
    {
        cObjIds++;
        val = val->next;
    }
    return cObjIds;
}

ASN1uint32_t CopyObjectIdentifier(ASN1objectidentifier_t dst, ASN1objectidentifier_t src)
{
    while (dst && src)
    {
        dst->value = src->value;
        dst = dst->next;
        src = src->next;
    }
    return ((! dst) && (! src));
}

ASN1objectidentifier_t DecAllocObjectIdentifier(ASN1decoding_t dec, ASN1uint32_t cObjIds)
{
    ASN1objectidentifier_t p, q;
    ASN1uint32_t i;
    p = (ASN1objectidentifier_t) DecMemAlloc(dec, cObjIds * sizeof(struct ASN1objectidentifier_s));
    if (p)
    {
        for (q = p, i = 0; i < cObjIds-1; i++)
        {
            q->value = 0;
            q->next = (ASN1objectidentifier_t) ((char *) q + sizeof(struct ASN1objectidentifier_s));
            q = q->next;
        }
        q->next = NULL;
    }
    return p;
}

void DecFreeObjectIdentifier(ASN1decoding_t dec, ASN1objectidentifier_t p)
{
    DecMemFree(dec, p);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\as16\asthkls.asm ===
page	,132

;Thunk Compiler Version 1.8  Dec 14 1994 14:53:05
;File Compiled Thu Apr 01 11:42:56 1999

;Command Line: d:\projects\cayman\dev\bin\misc\i386\thunk.exe -t thk -o asthkls.asm ..\thk\asthkls.thk 

	TITLE	$asthkls.asm

	.386
	OPTION READONLY
	OPTION OLDSTRUCTS

IFNDEF IS_16
IFNDEF IS_32
%out command line error: specify one of -DIS_16, -DIS_32
.err
ENDIF  ;IS_32
ENDIF  ;IS_16


IFDEF IS_32
IFDEF IS_16
%out command line error: you can't specify both -DIS_16 and -DIS_32
.err
ENDIF ;IS_16
;************************* START OF 32-BIT CODE *************************


	.model FLAT,STDCALL


;-- Import common flat thunk routines (in k32)

externDef AllocMappedBuffer	:near32
externDef FreeMappedBuffer		:near32
externDef MapHInstLS	:near32
externDef MapHInstLS_PN	:near32
externDef MapHInstSL	:near32
externDef MapHInstSL_PN	:near32
externDef FT_PrologPrime	:near32
externDef FT_Prolog	:near32
externDef FT_Thunk	:near32
externDef QT_Thunk	:near32
externDef QT_ThunkPrime	:near32
externDef FT_Exit0	:near32
externDef FT_Exit4	:near32
externDef FT_Exit8	:near32
externDef FT_Exit12	:near32
externDef FT_Exit16	:near32
externDef FT_Exit20	:near32
externDef FT_Exit24	:near32
externDef FT_Exit28	:near32
externDef FT_Exit32	:near32
externDef FT_Exit36	:near32
externDef FT_Exit40	:near32
externDef FT_Exit44	:near32
externDef FT_Exit48	:near32
externDef FT_Exit52	:near32
externDef FT_Exit56	:near32
externDef SMapLS	:near32
externDef SUnMapLS	:near32
externDef SMapLS_IP_EBP_8	:near32
externDef SUnMapLS_IP_EBP_8	:near32
externDef SMapLS_IP_EBP_12	:near32
externDef SUnMapLS_IP_EBP_12	:near32
externDef SMapLS_IP_EBP_16	:near32
externDef SUnMapLS_IP_EBP_16	:near32
externDef SMapLS_IP_EBP_20	:near32
externDef SUnMapLS_IP_EBP_20	:near32
externDef SMapLS_IP_EBP_24	:near32
externDef SUnMapLS_IP_EBP_24	:near32
externDef SMapLS_IP_EBP_28	:near32
externDef SUnMapLS_IP_EBP_28	:near32
externDef SMapLS_IP_EBP_32	:near32
externDef SUnMapLS_IP_EBP_32	:near32
externDef SMapLS_IP_EBP_36	:near32
externDef SUnMapLS_IP_EBP_36	:near32
externDef SMapLS_IP_EBP_40	:near32
externDef SUnMapLS_IP_EBP_40	:near32

MapLS	PROTO NEAR STDCALL :DWORD
UnMapLS	PROTO NEAR STDCALL :DWORD
MapSL	PROTO NEAR STDCALL p32:DWORD

;***************** START OF KERNEL32-ONLY SECTION ******************
; Hacks for kernel32 initialization.

IFDEF FT_DEFINEFTCOMMONROUTINES

	.data
public FT_thkTargetTable	;Flat address of target table in 16-bit module.

public FT_thkChecksum32
FT_thkChecksum32	dd	016bddh


ENDIF ;FT_DEFINEFTCOMMONROUTINES
;***************** END OF KERNEL32-ONLY SECTION ******************



	.code 

;************************* COMMON PER-MODULE ROUTINES *************************

	.data
;---------------------------------------------------------------
;Flat address of target table in 16-bit module name.
;Filled in by the initial handshaking routine: FT_thkConnectToFlatThkPeer
;---------------------------------------------------------------
FT_thkTargetTable	dd	0	;Flat address of target table in 16-bit module.


	.code 

FT_thkDynaName	db	'FT_thkThkConnectionData',0

;------------------------------------------------------------
;FT_thkConnectToFlatThkPeer:;
; The 32-bit dll must call this routine once at initialization
; time. It will load the 16-bit library and fetch the pointers
; needed to make the flat thunk run.
;
; Calling sequence:
;
;   FT_thkConnectToFlatThkPeer	proto	near stdcall, dll16:dword, dll32:dword
;
;   Name16     db   'mumble16.dll',0   ;Name of 16-bit library
;   Name32     db   'mumble32.dll',0   ;Name of 32-bit library
;
;              invoke FT_thkConnectToFlatThkPeer offset Name16, offset Name32
;              or   eax,eax
;              jz   failed
;              ;success
;
;------------------------------------------------------------
public FT_thkConnectToFlatThkPeer@8
FT_thkConnectToFlatThkPeer@8:
extern ThunkInitLSF@20:near32
	pop	edx	;Pop return address
	push	offset 016bddh	;Checksum
	push	offset FT_thkDynaName	;Symbol exported from peer.
	push	offset FT_thkTargetTable	;Address of destination.
	push	edx
	jmp	ThunkInitLSF@20
		





pfnQT_Thunk_thk	dd offset QT_Thunk_thk
pfnFT_Prolog_thk	dd offset FT_Prolog_thk
	.data
QT_Thunk_thk	db	0ebh, 30
	db	30 dup(0cch)	;Patch space.
	db	0e8h,0,0,0,0	;CALL NEAR32 $
	db	58h	;POP EAX
	db	2dh,32+5,0,0,0	;SUB EAX, IMM32
	db	0bah	;MOV EDX, IMM32
	dd	offset FT_thkTargetTable - offset QT_Thunk_thk
	db	068h	;PUSH IMM32
	dd	offset QT_ThunkPrime
	db	0c3h	;RETN

FT_Prolog_thk	db	0ebh, 30
	db	30 dup(0cch)	;Patch space.
	db	0e8h,0,0,0,0	;CALL NEAR32 $
	db	5ah	;POP EDX
	db	81h,0eah, 32+5,0,0,0	;SUB EDX, IMM32
	db	52h	;PUSH EDX
	db	068h	;PUSH IMM32
	dd	offset FT_thkTargetTable - offset FT_Prolog_thk
	db	068h	;PUSH IMM32
	dd	offset FT_PrologPrime
	db	0c3h	;RETN


	.code 




ebp_top		equ	<[ebp + 8]>	;First api parameter
ebp_retval	equ	<[ebp + -64]>	;Api return value
FT_ESPFIXUP	macro	dwSpOffset
	or	dword ptr [ebp + -20], 1 SHL ((dwSpOffset) SHR 1)
endm


ebp_qttop	equ	<[ebp + 8]>


include fltthk.inc	;Support definitions
include asthkls.inc



;************************ START OF THUNK BODIES************************




;
public OSILoad16@4
OSILoad16@4:
	FAPILOG16	270
	mov	cl,11
; OSILoad16(16) = OSILoad16(32) {}
;
; dword ptr [ebp+8]:  phInstance
;
public IIOSILoad16@4
IIOSILoad16@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	SMapLS_IP_EBP_8
	push	eax
	call	dword ptr [pfnQT_Thunk_thk]
	call	SUnMapLS_IP_EBP_8
	leave
	retn	4





;
public OSIInit16@36
OSIInit16@36:
	FAPILOG16	256
	mov	cl,10
; OSIInit16(16) = OSIInit16(32) {}
;
; dword ptr [ebp+8]:  version
; dword ptr [ebp+12]:  hwnd
; dword ptr [ebp+16]:  atom
; dword ptr [ebp+20]:  ppShared
; dword ptr [ebp+24]:  ppoaShared
; dword ptr [ebp+28]:  pimShared
; dword ptr [ebp+32]:  psbcEnabled
; dword ptr [ebp+36]:  psbcShunt
; dword ptr [ebp+40]:  pBitmasks
;
public IIOSIInit16@36
IIOSIInit16@36:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;version: dword->dword
	push	word ptr [ebp+12]	;hwnd: dword->word
	push	word ptr [ebp+16]	;atom: dword->word
	call	SMapLS_IP_EBP_20
	push	eax
	call	SMapLS_IP_EBP_24
	push	eax
	call	SMapLS_IP_EBP_28
	push	eax
	call	SMapLS_IP_EBP_32
	push	eax
	call	SMapLS_IP_EBP_36
	push	eax
	call	SMapLS_IP_EBP_40
	push	eax
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	call	SUnMapLS_IP_EBP_20
	call	SUnMapLS_IP_EBP_24
	call	SUnMapLS_IP_EBP_28
	call	SUnMapLS_IP_EBP_32
	call	SUnMapLS_IP_EBP_36
	call	SUnMapLS_IP_EBP_40
	leave
	retn	36





;
public OSITerm16@4
OSITerm16@4:
	FAPILOG16	242
	mov	cl,9
; OSITerm16(16) = OSITerm16(32) {}
;
; dword ptr [ebp+8]:  fUnloading
;
public IIOSITerm16@4
IIOSITerm16@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;fUnloading: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn	4





;
public OSIFunctionRequest16@12
OSIFunctionRequest16@12:
	FAPILOG16	217
	mov	cl,8
; OSIFunctionRequest16(16) = OSIFunctionRequest16(32) {}
;
; dword ptr [ebp+8]:  escape
; dword ptr [ebp+12]:  lpvEsc
; dword ptr [ebp+16]:  cbEsc
;
public IIOSIFunctionRequest16@12
IIOSIFunctionRequest16@12:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	dword ptr [ebp+8]	;escape: dword->dword
	call	SMapLS_IP_EBP_12
	push	eax
	push	dword ptr [ebp+16]	;cbEsc: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	call	SUnMapLS_IP_EBP_12
	leave
	retn	12





;
public OSIStartWindowTracking16@0
OSIStartWindowTracking16@0:
	FAPILOG16	188
	mov	cl,7
; OSIStartWindowTracking16(16) = OSIStartWindowTracking16(32) {}
;
;
public IIOSIStartWindowTracking16@0
IIOSIStartWindowTracking16@0:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn





;
public OSIStopWindowTracking16@0
OSIStopWindowTracking16@0:
	FAPILOG16	160
	mov	cl,6
; OSIStopWindowTracking16(16) = OSIStopWindowTracking16(32) {}
;
;
public IIOSIStopWindowTracking16@0
IIOSIStopWindowTracking16@0:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn





;
public OSIShareWindow16@16
OSIShareWindow16@16:
	FAPILOG16	139
	mov	cl,5
; OSIShareWindow16(16) = OSIShareWindow16(32) {}
;
; dword ptr [ebp+8]:  hwnd
; dword ptr [ebp+12]:  uType
; dword ptr [ebp+16]:  fRedraw
; dword ptr [ebp+20]:  fUpdate
;
public IIOSIShareWindow16@16
IIOSIShareWindow16@16:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hwnd: dword->word
	push	word ptr [ebp+12]	;uType: dword->word
	push	word ptr [ebp+16]	;fRedraw: dword->word
	push	word ptr [ebp+20]	;fUpdate: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn	16





;
public OSIIsWindowScreenSaver16@4
OSIIsWindowScreenSaver16@4:
	FAPILOG16	87
	mov	cl,3
; OSIIsWindowScreenSaver16(16) = OSIIsWindowScreenSaver16(32) {}
;
; dword ptr [ebp+8]:  hwnd
;
public IIOSIIsWindowScreenSaver16@4
IIOSIIsWindowScreenSaver16@4:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;hwnd: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn	4





;
public OSIInstallControlledHooks16@8
OSIInstallControlledHooks16@8:
	FAPILOG16	55
	mov	cl,2
	jmp	IIOSIInstallControlledHooks16@8
public OSIUnshareWindow16@8
OSIUnshareWindow16@8:
	FAPILOG16	116
	mov	cl,4
; OSIInstallControlledHooks16(16) = OSIInstallControlledHooks16(32) {}
;
; dword ptr [ebp+8]:  fInstall
; dword ptr [ebp+12]:  fDesktop
;
public IIOSIInstallControlledHooks16@8
IIOSIInstallControlledHooks16@8:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;fInstall: dword->word
	push	word ptr [ebp+12]	;fDesktop: dword->word
	call	dword ptr [pfnQT_Thunk_thk]
	cwde
	leave
	retn	8





;
public OSIInjectMouseEvent16@20
OSIInjectMouseEvent16@20:
	FAPILOG16	29
	mov	cl,1
; OSIInjectMouseEvent16(16) = OSIInjectMouseEvent16(32) {}
;
; dword ptr [ebp+8]:  param1
; dword ptr [ebp+12]:  param2
; dword ptr [ebp+16]:  param3
; dword ptr [ebp+20]:  param4
; dword ptr [ebp+24]:  param5
;
public IIOSIInjectMouseEvent16@20
IIOSIInjectMouseEvent16@20:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;param1: dword->word
	push	word ptr [ebp+12]	;param2: dword->word
	push	word ptr [ebp+16]	;param3: dword->word
	push	word ptr [ebp+20]	;param4: dword->word
	push	dword ptr [ebp+24]	;param5: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn	20





;
public OSIInjectKeyboardEvent16@16
OSIInjectKeyboardEvent16@16:
	FAPILOG16	0
	mov	cl,0
; OSIInjectKeyboardEvent16(16) = OSIInjectKeyboardEvent16(32) {}
;
; dword ptr [ebp+8]:  param1
; dword ptr [ebp+12]:  param2
; dword ptr [ebp+16]:  param3
; dword ptr [ebp+20]:  param4
;
public IIOSIInjectKeyboardEvent16@16
IIOSIInjectKeyboardEvent16@16:
	push	ebp
	mov	ebp,esp
	push	ecx
	sub	esp,60
	push	word ptr [ebp+8]	;param1: dword->word
	push	word ptr [ebp+12]	;param2: dword->word
	push	word ptr [ebp+16]	;param3: dword->word
	push	dword ptr [ebp+20]	;param4: dword->dword
	call	dword ptr [pfnQT_Thunk_thk]
	leave
	retn	16




;-----------------------------------------------------------
ifdef DEBUG
FT_ThunkLogNames label byte
	db	'[F] OSIInjectKeyboardEvent16',0
	db	'[F] OSIInjectMouseEvent16',0
	db	'[F] OSIInstallControlledHooks16',0
	db	'[F] OSIIsWindowScreenSaver16',0
	db	'[F] OSIUnshareWindow16',0
	db	'[F] OSIShareWindow16',0
	db	'[F] OSIStopWindowTracking16',0
	db	'[F] OSIStartWindowTracking16',0
	db	'[F] OSIFunctionRequest16',0
	db	'[F] OSITerm16',0
	db	'[F] OSIInit16',0
	db	'[F] OSILoad16',0
endif ;DEBUG
;-----------------------------------------------------------



ELSE
;************************* START OF 16-BIT CODE *************************




	OPTION SEGMENT:USE16
	.model LARGE,PASCAL


	.code	



externDef OSIInjectKeyboardEvent16:far16
externDef OSIInjectMouseEvent16:far16
externDef OSIInstallControlledHooks16:far16
externDef OSIIsWindowScreenSaver16:far16
externDef OSIUnshareWindow16:far16
externDef OSIShareWindow16:far16
externDef OSIStopWindowTracking16:far16
externDef OSIStartWindowTracking16:far16
externDef OSIFunctionRequest16:far16
externDef OSITerm16:far16
externDef OSIInit16:far16
externDef OSILoad16:far16


FT_thkTargetTable label word
	dw	offset OSIInjectKeyboardEvent16
	dw	   seg OSIInjectKeyboardEvent16
	dw	offset OSIInjectMouseEvent16
	dw	   seg OSIInjectMouseEvent16
	dw	offset OSIInstallControlledHooks16
	dw	   seg OSIInstallControlledHooks16
	dw	offset OSIIsWindowScreenSaver16
	dw	   seg OSIIsWindowScreenSaver16
	dw	offset OSIUnshareWindow16
	dw	   seg OSIUnshareWindow16
	dw	offset OSIShareWindow16
	dw	   seg OSIShareWindow16
	dw	offset OSIStopWindowTracking16
	dw	   seg OSIStopWindowTracking16
	dw	offset OSIStartWindowTracking16
	dw	   seg OSIStartWindowTracking16
	dw	offset OSIFunctionRequest16
	dw	   seg OSIFunctionRequest16
	dw	offset OSITerm16
	dw	   seg OSITerm16
	dw	offset OSIInit16
	dw	   seg OSIInit16
	dw	offset OSILoad16
	dw	   seg OSILoad16


; The following symbol must be exported in the .def file.
public	FT_thkThkConnectionData
FT_thkThkConnectionData label dword
	dd	016bddh	;Checksum
	dw	offset FT_thkTargetTable
	dw	seg    FT_thkTargetTable



ENDIF
END
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\as16\ba.c ===
//
// BA.C
// Bounds Accumulator
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>


//
// BA_DDProcessRequest()
// Handles BA escapes
//


BOOL BA_DDProcessRequest
(
    UINT        fnEscape,
    LPOSI_ESCAPE_HEADER pResult,
    DWORD       cbResult
)
{
    BOOL                    rc = TRUE;
    LPBA_BOUNDS_INFO        pBoundsInfo;
    UINT                    i;
    RECT                    rect;

    DebugEntry(BA_DDProcessRequest);

    switch (fnEscape)
    {
        case BA_ESC_GET_BOUNDS:
        {
            //
            // The share core is calling us to get the current bounds
            // (presumably to try to send them).  While the share core is
            // processing the bounds, we reset the bounds, but take a copy
            // first to use for spoiling orders by SDA.  When the share
            // core has completed processing the bounds, it will call us
            // again with a BA_ESC_RETURN_BOUNDS escape (even if it has
            // sent all the bounds).
            //
            // So, we have to:
            //  - return the bounds to the share core
            //  - set up the spoiling rects to be these bounds
            //  - clear our main bounds.
            //

            //
            // This will copy the current bounds to the caller's buffer and
            // clear our current bounds.
            // NOTE:  We keep these in globals because the caller will shortly
            // call us to return any unsent bounds rects.
            //
            BA_CopyBounds(g_baSpoilingRects, &g_baNumSpoilingRects, TRUE);

            //
            // Return the bounds info to the share core
            //
            if (g_baNumSpoilingRects)
            {
                TRACE_OUT(( "Returning %d rects to share core", g_baNumSpoilingRects));
            }

            pBoundsInfo = (LPBA_BOUNDS_INFO)pResult;
            pBoundsInfo->numRects = g_baNumSpoilingRects;

            for (i = 0; i < g_baNumSpoilingRects; i++)
            {
                RECT_TO_RECTL(&g_baSpoilingRects[i], &pBoundsInfo->rects[i]);
            }
        }
        break;

        case BA_ESC_RETURN_BOUNDS:
        {
            //
            // The share core has completed its processing of the bounds
            // which we passed on the BA_ESC_GET_BOUNDS escape.  We have to
            // reset the spoiling rectangles and add any bounds which the
            // share core failed to process into our current bounds.
            //

            //
            // To reset the spoiling bounds we just have to reset the
            // number of bounds.
            //
            g_baNumSpoilingRects = 0;

            //
            // Now add the share core's bounds into our current bounds
            //
            pBoundsInfo = (LPBA_BOUNDS_INFO)pResult;

            if (pBoundsInfo->numRects)
            {
                TRACE_OUT(( "Received %d rects from share core",
                             pBoundsInfo->numRects));
            }

            for (i = 0 ; i < pBoundsInfo->numRects ; i++)
            {
                RECTL_TO_RECT(&pBoundsInfo->rects[i], &rect);

                TRACE_OUT(( "Rect %d, {%d, %d, %d, %d}",
                     i, rect.left, rect.top, rect.right, rect.bottom));

                BA_AddScreenData(&rect);
            }
        }
        break;

        default:
        {
            ERROR_OUT(( "Unrecognised BA escape"));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(BA_DDProcessRequest, rc);
    return(rc);
}



//
// BA_DDInit - see ba.h for description.
//
void BA_DDInit(void)
{
    DebugEntry(BA_Init);

    BA_ResetBounds();

    DebugExitVOID(BA_Init);
}




//
// This gets a current version of our bound rect list, and clears it 
// afterwards if requested.
//
void BA_CopyBounds
(
    LPRECT  pRects,
    LPUINT  pNumRects,
    BOOL    fReset
)
{
    UINT    i;
#ifdef DEBUG
    UINT    cRects = 0;
#endif

    DebugEntry(BA_CopyBounds);

    *pNumRects = g_baRectsUsed;

    //
    // A return with *pNumRects as zero is an OK return - it just says
    // no bounds have been accumulated since the last call.
    //
    if ( *pNumRects != 0)
    {
        //
        // We can return the bounds in any order - we don't care how we
        // order the SDA rectangles.
        //
        // Also note that we must compare BA_NUM_RECTS + 1 sets of
        // rectangles because that's the number actually used by the add
        // rectangle code and while it guarantees that it will only use
        // BA_NUM_RECTS rectangles, it does not guarantee that the last
        // element in the array is the merge rectangle.
        //
        for (i = 0; i <= BA_NUM_RECTS; i++)
        {
            if (g_baBounds[i].InUse)
            {
                TRACE_OUT(("Found rect: {%04d,%04d,%04d,%04d}",
                    g_baBounds[i].Coord.left, g_baBounds[i].Coord.top,
                    g_baBounds[i].Coord.right, g_baBounds[i].Coord.bottom));

                *pRects = g_baBounds[i].Coord;
                pRects++;
#ifdef DEBUG
                cRects++;
#endif
            }
        }

        //
        // Check for self-consistency
        //
        ASSERT(cRects == *pNumRects);

        if (fReset)
            BA_ResetBounds();
    }

    DebugExitVOID(BACopyBounds);
}

//
//
// BA_AddScreenData(..)
//
// Adds the specified rectangle to the current Screen Data Area.
//
// Called by the GDI interception code for orders that it cannot send as
// orders.
//
// NOTE that the rectangle is inclusive coords
//
//
void BA_AddScreenData(LPRECT pRect)
{
    RECT  preRects[BA_NUM_RECTS];
    RECT  postRects[BA_NUM_RECTS];
    UINT  numPreRects;
    UINT  numPostRects;
    UINT  i;

    DebugEntry(BA_AddScreenData);

    //
    // Check that the caller has passed a valid rectangle.  If not, do a
    // trace alert, and then return immediately (as an invalid rectangle
    // shouldn't contribute to the accumulated bounds) - but report an OK
    // return code, so we keep running.
    //
    if ((pRect->right < pRect->left) ||
        (pRect->bottom < pRect->top) )
    {
        //
        // NOTE:  This will happen when the visrgn of a DC clips out the
        // output, so the drawing bounds are empty, but the output 
        // 'succeeded'.  BUT WE SHOULD NEVER GET A RECT THAT IS LESS THAN
        // EMPTY--if so, it means the right/left or bottom/top coords got
        // mistakenly flipped.
        //
        ASSERT(pRect->right >= pRect->left-1);
        ASSERT(pRect->bottom >= pRect->top-1);
        DC_QUIT;
    }

    if ((g_oaFlow == OAFLOW_SLOW) && g_baSpoilByNewSDAEnabled)
    {
        //
        // We are spoiling existing orders by new SDA, so query the current
        // bounds.
        //
        BA_CopyBounds(preRects, &numPreRects, FALSE);
    }

    //
    // Add the rect to the bounds.
    //
    if (BAAddRect(pRect, 0))
    {
        if ((pRect->right > pRect->left) && (pRect->bottom > pRect->top))
        {
            LPBA_FAST_DATA  lpbaFast;

            lpbaFast = BA_FST_START_WRITING;

            SHM_CheckPointer(lpbaFast);
            lpbaFast->totalSDA += COM_SizeOfRectInclusive(pRect);

            TRACE_OUT(("Added rect to bounds, giving %ld of SD", lpbaFast->totalSDA));

            //
            // This is where the Win95 product would make a call to
            // DCS_TriggerEarlyTimer
            //

            BA_FST_STOP_WRITING;
        }

        if ((g_oaFlow == OAFLOW_SLOW) && g_baSpoilByNewSDAEnabled)
        {
            //
            // Adding the new rectangle changed the existing bounds so
            // query the new bounds
            //
            BA_CopyBounds(postRects, &numPostRects, FALSE);

            //
            // Try to spoil existing orders using each of the rectangles
            // which have changed.
            //
            for (i = 0; i < numPostRects; i++)
            {
                if ( (i > numPreRects)                          ||
                     (postRects[i].left   != preRects[i].left)  ||
                     (postRects[i].right  != preRects[i].right) ||
                     (postRects[i].top    != preRects[i].top)   ||
                     (postRects[i].bottom != preRects[i].bottom) )
                {
                    OA_DDSpoilOrdersByRect(&postRects[i]);
                }
            }
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(BA_AddScreenData);
}



//
//
// BA_QuerySpoilingBounds() - see ba.h
//
//
void BA_QuerySpoilingBounds(LPRECT pRects, LPUINT pNumRects)
{
    DebugEntry(BA_QuerySpoilingBounds);

    //
    // Just have to return the number of spoiling rectangles, and the
    // rectangles themselves.  No rectangles is perfectly valid.
    //
    TRACE_OUT(( "Num rects %d", g_baNumSpoilingRects));

    *pNumRects = g_baNumSpoilingRects;
    hmemcpy(pRects, g_baSpoilingRects, g_baNumSpoilingRects*sizeof(RECT));

    DebugExitVOID(BA_QuerySpoilingBounds);
}



void BA_ResetBounds(void)
{
    UINT i;

    DebugEntry(BA_ResetBounds);

    //
    // Clear the bounds - reset the number we are using, mark all slots as
    // free, and clean the list.
    //
    for ( i = 0; i <= BA_NUM_RECTS; i++ )
    {
        g_baBounds[i].InUse = FALSE;
        g_baBounds[i].iNext = BA_INVALID_RECT_INDEX;
    }

    g_baFirstRect = BA_INVALID_RECT_INDEX;
    g_baLastRect  = BA_INVALID_RECT_INDEX;
    g_baRectsUsed = 0;

    DebugExitVOID(BA_ResetBounds);
}





//
// Name:        BAOverlap
//
// Description: Detects overlap between two rectangles.
//
//              - check for no overlap using loose test that lets through
//                adjacent/overlapping merges
//              - check for adjacent/overlapping merges
//              - check for no overlap (using strict test)
//              - use outcodes to check internal edge cases
//              - use outcodes to check external edge cases
//
//              If at each stage the check detects that the two rectangles
//              meet the criteria, the function returns the appropriate
//              return or outcode combination.
//
//              Note that all rectangle coordinates are inclusive, ie
//              a rectangle of 0,0,0,0 has an area of 1 pel.
//
//              This function does not alter either of the rectangles.
//
// Params (IN): pRect1 - first rectangle
//              pRect2 - second rectangle
//
// Returns:     One of the overlap return codes or outcode combinations
//              defined above.
//
//
int BAOverlap(LPRECT pRect1, LPRECT pRect2 )
{
    int ExternalEdges;
    int ExternalCount;
    int InternalEdges;
    int InternalCount;

    //
    // Check for no overlap.
    //
    // Note that this test is looser than strict no overlap, and will let
    // through rectangles that do not overlap, but just abutt by one pel -
    // so that we get a chance to detect adjacent merges.
    //
    // So (for example) for the following:
    //
    // - it detects no overlap when there is at least 1 pel between rects
    //
    //                  10,10        52,10
    //                   +----------++----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------++----------+
    //                          50,50         100,50
    //
    // - it allows rectangles through when they abutt and are mergable
    //
    //                  10,10        51,10
    //                   +----------++----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------++----------+
    //                          50,50         100,50
    //
    // - it allows rectangles through when they abutt, even where they are
    //   not mergable
    //
    //                  10,10
    //                   +----------+51,15
    //                   |          |+----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||          |
    //                   |          ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------+|          |
    //                          50,50+----------+
    //                                        100,55
    //
    // - it allows rectangles through when they overlap in some way
    //
    //                          40,0
    //                           +------------+
    //                  10,10    |            |
    //                   +-------+--+         |
    //                   |       |  |         |
    //                   |       |  | Rect 2  |
    //                   |       |  |         |
    //                   |Rect 1 |  |         |
    //                   |       |  |         |
    //                   |       +--+---------+
    //                   |          |        90,40
    //                   +----------+
    //                          50,50
    //
    //
    if (!((pRect1->left <= pRect2->right + 1) &&
          (pRect1->top <= pRect2->bottom + 1) &&
          (pRect1->right >= pRect2->left - 1) &&
          (pRect1->bottom >= pRect2->top - 1)   ))
    {
        return(OL_NONE);
    }

    //
    // Check for adjoining/overlapping rectangles which can be merged.
    //
    // These tests detect (for example for the XMAX variant), where:
    //
    // - the rectangles abutt and can be merged
    //
    //                  10,10        51,10
    //                   +----------++----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------++----------+
    //                          50,50         100,50
    //
    // - the rectangles overlap and can be merged
    //
    //                  10,10   40,10
    //                   +-------+--+------+
    //                   |       |  |      |
    //                   |       |  |      |
    //                   |       |  |      |
    //                   |Rect 1 |  |Rect 2|
    //                   |       |  |      |
    //                   |       |  |      |
    //                   |       |  |      |
    //                   +-------+--+------+
    //                              50,50  90,50
    //
    // - the rectangles abutt and cannot be merged - this case is detected
    //   by the strict overlap case below
    //
    //                  10,10
    //                   +----------+51,15
    //                   |          |+----------+
    //                   |          ||          |
    //                   |          ||          |
    //                   |  Rect 1  ||          |
    //                   |          ||  Rect 2  |
    //                   |          ||          |
    //                   |          ||          |
    //                   +----------+|          |
    //                          50,50+----------+
    //                                        100,55
    //
    // - the rectangles overlap and cannot be merged - this case is
    //   detected by the outcode tests below
    //
    //                          40,0
    //                           +------------+
    //                  10,10    |            |
    //                   +-------+--+         |
    //                   |       |  |         |
    //                   |       |  | Rect 2  |
    //                   |       |  |         |
    //                   |Rect 1 |  |         |
    //                   |       |  |         |
    //                   |       +--+---------+
    //                   |          |        90,40
    //                   +----------+
    //                          50,50
    //
    // - rectangle 2 is enclosed in rectangle 1 and should not be merged -
    //   this case is detected by the outcode tests below.
    //
    //                  10,10   40,10
    //                   +-------+------+-----+
    //                   |       |      |     |
    //                   |       |      |     |
    //                   |       |      |     |
    //                   |Rect 1 |Rect 2|     |
    //                   |       |      |     |
    //                   |       |      |     |
    //                   |       |      |     |
    //                   +-------+------+-----+
    //                               60,50   90,50
    //                               Rect2   Rect1
    //
    //
    if ( (pRect1->left <= pRect2->right + 1) &&
         (pRect1->left >  pRect2->left    ) &&
         (pRect1->right >  pRect2->right    ) &&
         (pRect1->top == pRect2->top    ) &&
         (pRect1->bottom == pRect2->bottom    )   )
    {
        return(OL_MERGE_XMIN);
    }

    if ( (pRect1->top <= pRect2->bottom + 1) &&
         (pRect1->top >  pRect2->top    ) &&
         (pRect1->bottom >  pRect2->bottom    ) &&
         (pRect1->left == pRect2->left    ) &&
         (pRect1->right == pRect2->right    )   )
    {
        return(OL_MERGE_YMIN);
    }

    if ( (pRect1->right >= pRect2->left - 1) &&
         (pRect1->right <  pRect2->right    ) &&
         (pRect1->left <  pRect2->left    ) &&
         (pRect1->top == pRect2->top    ) &&
         (pRect1->bottom == pRect2->bottom    )   )
    {
        return(OL_MERGE_XMAX);
    }

    if ( (pRect1->bottom >= pRect2->top - 1) &&
         (pRect1->bottom <  pRect2->bottom    ) &&
         (pRect1->top <  pRect2->top    ) &&
         (pRect1->left == pRect2->left    ) &&
         (pRect1->right == pRect2->right    )   )
    {
        return(OL_MERGE_YMAX);
    }

    //
    // Check for no overlap.
    // Note that this test is a stricter version than the earlier one, so
    // that we now only continue testing rectangles that do genuinely
    // overlap.
    //
    if (!((pRect1->left <= pRect2->right) &&
          (pRect1->top <= pRect2->bottom) &&
          (pRect1->right >= pRect2->left) &&
          (pRect1->bottom >= pRect2->top)   ))
    {
        return(OL_NONE);
    }

    //
    // Use outcodes for Internal edge cases, as follows:
    //
    // EE_XMIN - rect1 xmin is enclosed within rect2
    // EE_YMIN - rect1 ymin is enclosed within rect2
    // EE_XMAX - rect1 xmax is enclosed within rect2
    // EE_YMAX - rect1 ymax is enclosed within rect2
    //
    // If 3 or more bits are set then rect1 is enclosed either partially or
    // completely within rect2 as follows (see individual switch cases for
    // diagrams).
    //
    // OL_ENCLOSED           = EE_XMIN | EE_YMIN | EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSED_XMIN = EE_XMIN | EE_YMIN |           EE_YMAX
    // OL_PART_ENCLOSED_YMIN = EE_XMIN | EE_YMIN | EE_XMAX
    // OL_PART_ENCLOSED_XMAX =           EE_YMIN | EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSED_YMAX = EE_XMIN |           EE_XMAX | EE_YMAX
    //
    // In practice, if 3 or more bits are set, the negative of the outcode
    // value is retruned to ensure that it is distinct from the external
    // edge outcode returns (see below).
    //
    //
    InternalCount = 0;
    InternalEdges = 0;
    if ( pRect1->left >= pRect2->left && pRect1->left <= pRect2->right)
    {
        InternalEdges |= EE_XMIN;
        InternalCount ++;
    }
    if ( pRect1->top >= pRect2->top && pRect1->top <= pRect2->bottom)
    {
        InternalEdges |= EE_YMIN;
        InternalCount ++;
    }
    if ( pRect1->right >= pRect2->left && pRect1->right <= pRect2->right)
    {
        InternalEdges |= EE_XMAX;
        InternalCount ++;
    }
    if ( pRect1->bottom >= pRect2->top && pRect1->bottom <= pRect2->bottom)
    {
        InternalEdges |= EE_YMAX;
        InternalCount ++;
    }

    if ( InternalCount >= 3)
    {
        return(-InternalEdges);
    }

    //
    // Use outcodes for External edge cases as follows.
    //
    // EE_XMIN - rect1 xmin is left of rect2 xmin
    // EE_YMIN - rect1 ymin is above rect2 ymin
    // EE_XMAX - rect1 xmax is right of rect2 xmax
    // EE_YMAX - rect1 ymax is below rect2 ymax
    //
    // These are the classic "line" outcodes.
    //
    // If 2 or more bits are set then rect1 overlaps rect2 as follows (see
    // individual switch cases for diagrams).
    //
    // OL_ENCLOSES           = EE_XMIN | EE_YMIN | EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSES_XMIN =           EE_YMIN | EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSES_XMAX = EE_XMIN | EE_YMIN |           EE_YMAX
    // OL_PART_ENCLOSES_YMIN = EE_XMIN |           EE_XMAX | EE_YMAX
    // OL_PART_ENCLOSES_YMAX = EE_XMIN | EE_YMIN | EE_XMAX
    // OL_SPLIT_X            =           EE_YMIN |           EE_YMAX
    // OL_SPLIT_Y            = EE_XMIN |           EE_XMAX
    // OL_SPLIT_XMIN_YMIN    =                     EE_XMAX | EE_YMAX
    // OL_SPLIT_XMAX_YMIN    = EE_XMIN |                     EE_YMAX
    // OL_SPLIT_XMIN_YMAX    =           EE_YMIN | EE_XMAX
    // OL_SPLIT_XMAX_YMAX    = EE_XMIN | EE_YMIN
    //
    // The accumulated outcode value is returned.
    //
    //
    ExternalEdges = 0;
    ExternalCount = 0;
    if ( pRect1->left <= pRect2->left )
    {
        ExternalEdges |= EE_XMIN;
        ExternalCount ++;
    }
    if ( pRect1->top <= pRect2->top )
    {
        ExternalEdges |= EE_YMIN;
        ExternalCount ++;
    }
    if ( pRect1->right >= pRect2->right )
    {
        ExternalEdges |= EE_XMAX;
        ExternalCount ++;
    }
    if ( pRect1->bottom >= pRect2->bottom )
    {
        ExternalEdges |= EE_YMAX;
        ExternalCount ++;
    }
    if (ExternalCount >= 2)
    {
        return(ExternalEdges);
    }

    //
    // If get here then we failed to detect a valid case.
    //
    WARNING_OUT(( "Unrecognised Overlap: (%d,%d,%d,%d),(%d,%d,%d,%d)",
            pRect1->left, pRect1->top, pRect1->right, pRect1->bottom,
            pRect2->left, pRect2->top, pRect2->right, pRect2->bottom ));
    return(OL_NONE);
}



//
// Name:        BAAddRectList
//
// Description: Adds a rectangle to the list of accumulated rectangles.
//
//              - find a free slot in the array
//              - add slot record to list
//              - fill slot record with rect and mark as in use.
//
// Params (IN): pRect - rectangle to add
//
// Returns:
//
//
void BAAddRectList(LPRECT pRect)
{
    UINT     i;
    BOOL     fFoundFreeSlot;

    DebugEntry(BAAddRectList);

    //
    // Find a free slot in the array.  Note that the loop searches to
    // BA_NUM_RECTS+1, because:
    //
    // - the array is defined as having one more slot than BA_NUM_RECTS
    //
    // - we may need to add a rect in that slot when BA_NUM_RECTS are
    //   in use prior to a forced merge.
    //
    fFoundFreeSlot = FALSE;
    for ( i = 0; i <= BA_NUM_RECTS; i++ )
    {
        if (!g_baBounds[i].InUse)
        {
            fFoundFreeSlot = TRUE;
            break;
        }
    }

    if (!fFoundFreeSlot)
    {
        WARNING_OUT(( "No space in array for rect (%d,%d,%d,%d)",
                   pRect->left,
                   pRect->top,
                   pRect->right,
                   pRect->bottom));

        for ( i = 0; i <= BA_NUM_RECTS; i++ )
        {
            WARNING_OUT((
                     "Entry %i:Next(%lx),(%d,%d,%d,%d),Index(%d),InUse(%d)",
                       g_baBounds[i].iNext,
                       g_baBounds[i].Coord.left,
                       g_baBounds[i].Coord.top,
                       g_baBounds[i].Coord.right,
                       g_baBounds[i].Coord.bottom,
                       i,
                       g_baBounds[i].InUse));
        }

        DC_QUIT;
    }

    //
    // If first rect, then set up list.
    // If not, add to tail of list.
    //
    if (g_baRectsUsed == 0)
    {
        g_baFirstRect = i;
        g_baLastRect = i;
    }
    else
    {
        g_baBounds[g_baLastRect].iNext = i;
        g_baLastRect = i;
    }
    g_baBounds[i].iNext = BA_INVALID_RECT_INDEX;

    //
    // Fill in slot and mark as in use.
    //
    g_baBounds[i].InUse = TRUE;
    g_baBounds[i].Coord = *pRect;

    //
    // Increment number of rectangles.
    //
    TRACE_OUT(( "Add Rect  : ix - %d, (%d,%d,%d,%d)", i,
                    pRect->left,pRect->top,pRect->right,pRect->bottom));
    g_baRectsUsed++;

DC_EXIT_POINT:
    DebugExitVOID(BAAddRectList);
}


//
// Name:        BA_RemoveRectList
//
// Description: Removes a rectangle from the list of accumulated
//              rectangles.
//
//              - find the rectangle in the list
//              - unlink it from the list and mark the slot as free
//
// Params (IN): pRect - rectangle to remove
//
// Returns:
//
//
void BA_RemoveRectList(LPRECT pRect)
{
    UINT      i;
    UINT      j;

    DebugEntry(BA_RemoveRectList);

    //
    // If rectangle to remove is first...
    // Remove it by adjusting first pointer and mark as free.
    // Note that the check for tail adjustment has to be done before we
    // change first.
    //
    if ( g_baBounds[g_baFirstRect].Coord.left == pRect->left &&
         g_baBounds[g_baFirstRect].Coord.top == pRect->top &&
         g_baBounds[g_baFirstRect].Coord.right == pRect->right &&
         g_baBounds[g_baFirstRect].Coord.bottom == pRect->bottom   )
    {
        TRACE_OUT(( "Remove first"));
        if (g_baFirstRect == g_baLastRect)
        {
            g_baLastRect = BA_INVALID_RECT_INDEX;
        }
        g_baBounds[g_baFirstRect].InUse = FALSE;
        g_baFirstRect = g_baBounds[g_baFirstRect].iNext;
    }

    //
    // If rectangle to remove is not first...
    // Find it in list, remove it by adjusting previous pointer and mark it
    // as free.
    // Note that the check for tail adjustment has to be done before we
    // change the previous pointer.
    //
    else
    {
        TRACE_OUT(( "Remove not first"));
        for ( j = g_baFirstRect;
              g_baBounds[j].iNext != BA_INVALID_RECT_INDEX;
              j = g_baBounds[j].iNext )
        {
            if ( (g_baBounds[g_baBounds[j].iNext].Coord.left == pRect->left) &&
                 (g_baBounds[g_baBounds[j].iNext].Coord.top == pRect->top) &&
                 (g_baBounds[g_baBounds[j].iNext].Coord.right == pRect->right) &&
                 (g_baBounds[g_baBounds[j].iNext].Coord.bottom == pRect->bottom) )
            {
                break;
            }
        }

        if (j == BA_INVALID_RECT_INDEX)
        {
            WARNING_OUT(( "Couldn't remove rect (%d,%d,%d,%d)",
                       pRect->left,
                       pRect->top,
                       pRect->right,
                       pRect->bottom ));

            for ( i = 0; i <= BA_NUM_RECTS; i++ )
            {
                WARNING_OUT((
                       "Entry %i:Next(%lx),(%d,%d,%d,%d),Index(%d),InUse(%d)",
                           g_baBounds[i].iNext,
                           g_baBounds[i].Coord.left,
                           g_baBounds[i].Coord.top,
                           g_baBounds[i].Coord.right,
                           g_baBounds[i].Coord.bottom,
                           i,
                           g_baBounds[i].InUse));
            }
            return;
        }

        if (g_baBounds[j].iNext == g_baLastRect )
        {
             g_baLastRect = j;
        }
        g_baBounds[g_baBounds[j].iNext].InUse = FALSE;
        g_baBounds[j].iNext = g_baBounds[g_baBounds[j].iNext].iNext;
    }

    //
    // One less rect...
    //
    g_baRectsUsed--;
    DebugExitVOID(BA_RemoveRectList);
}


//
// Name:        BAAddRect
//
// Description: Accumulates rectangles.
//
//              This is a complex routine, with the essential algorithm
//              as follows.
//
//              - Start with the supplied rectangle as the candidate
//                rectangle.
//
//              - Compare the candidate against each of the existing
//                accumulated rectangles.
//
//              - If some form of overlap is detected between the
//                candidate and an existing rectangle, this may result in
//                one of the following (see the cases of the switch for
//                details):
//
//                - adjust the candidate or the existing rectangle or both
//                - merge the candidate into the existing rectangle
//                - discard the candidate as it is enclosed by an existing
//                  rectangle.
//
//              - If the merge or adjustment results in a changed
//                candidate, restart the comparisons from the beginning of
//                the list with the changed candidate.
//
//              - If the adjustment results in a split (giving two
//                candidate rectangles), invoke this routine recursively
//                with one of the two candidates as its candidate.
//
//              - If no overlap is detected against the existing rectangles,
//                add the candidate to the list of accumulated rectangles.
//
//              - If the add results in more than BA_NUM_RECTS
//                accumulated rectangles, do a forced merge of two of the
//                accumulate rectangles (which include the newly added
//                candidate) - choosing the two rectangles where the merged
//                rectangle results in the smallest increase in area over
//                the two non-merged rectangles.
//
//              - After a forced merge, restart the comparisons from the
//                beginning of the list with the newly merged rectangle as
//                the candidate.
//
//              For a particular call, this process will continue until
//              the candidate (whether the supplied rectangle, an adjusted
//              version of that rectangle, or a merged rectangle):
//
//              - does not find an overlap among the rectangles in the list
//                and does not cause a forced merge
//              - is discarded becuase it is enclosed within one of the
//                rectangles in the list.
//
//              Note that all rectangle coordinates are inclusive, ie
//              a rectangle of 0,0,0,0 has an area of 1 pel.
//
// Params (IN): pCand - new candidate rectangle
//              level - recursion level
//
// Returns:  TRUE if rectandle was spoilt due to a complete overlap.
//
//
BOOL BAAddRect
(
    LPRECT  pCand,
    int     level
)
{
    LONG    bestMergeIncrease;
    LONG    mergeIncrease;
    UINT    iBestMerge1;
    UINT    iBestMerge2;
    UINT    iExist;
    UINT    iTmp;
    BOOL    fRectToAdd;
    BOOL    fRectMerged;
    BOOL    fResetRects;
    RECT    rectNew;
    UINT    iLastMerge;
    int     OverlapType;
    BOOL    rc = TRUE;

    DebugEntry(BAAddRect);

    //
    // Increase the level count in case we recurse.
    //
    level++;

    //
    // Start off by assuming the candidate rectangle will be added to the
    // accumulated list of rectangles, and that no merges will occur.
    //
    fRectToAdd  = TRUE;
    fRectMerged = FALSE;

    //
    // Loop until no merges occur.
    //
    do
    {
        TRACE_OUT(( "Candidate rect: (%d,%d,%d,%d)",
                    pCand->left,pCand->top,pCand->right,pCand->bottom));

        //
        // Compare the current candidate rectangle against the rectangles
        // in the current accumulated list.
        //
        iExist = g_baFirstRect;

        while (iExist != BA_INVALID_RECT_INDEX)
        {
            //
            // Assume that the comparisons will run through the whole list.
            //
            fResetRects = FALSE;

            //
            // If the candidate and the existing rectangle are the same
            // then ignore.  This occurs when an existing rectangle is
            // replaced by a candidate and the comparisons are restarted
            // from the front of the list - whereupon at some point the
            // candidate will be compared with itself.
            //
            if ( &g_baBounds[iExist].Coord == pCand )
            {
                iExist = g_baBounds[iExist].iNext;
                continue;
            }

            //
            // Switch on the overlap type (see Overlap routine).
            //
            OverlapType = BAOverlap(&(g_baBounds[iExist].Coord), pCand);
            switch (OverlapType)
            {

                case OL_NONE:
                    //
                    // No overlap.
                    //
                    break;

                case OL_MERGE_XMIN:
                    //
                    // - either the candidate abutts the existing rectangle
                    //   on the left
                    //
                    //              10,10        51,10
                    //               +----------++----------+
                    //               |          ||          |
                    //               |          ||          |
                    //               |          ||          |
                    //               |  Cand    ||  Exist   |
                    //               |          ||          |
                    //               |          ||          |
                    //               |          ||          |
                    //               +----------++----------+
                    //                      50,50         100,50
                    //
                    // - or the candidate overlaps the existing on the left
                    //   and can be merged
                    //
                    //              10,10   40,10
                    //               +-------+--+------+
                    //               |       |  |      |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               | Cand  |  |Exist |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               +-------+--+------+
                    //                          50,50  90,50
                    //
                    // If the candidate is the original, merge the
                    // candidate into the existing, and make the existing
                    // the new candidate.
                    //
                    // If this is a merge of two existing rectangles (ie
                    // the candidate is the result of a merge), merge the
                    // overlapping existing into the candidate (the last
                    // merged) and remove the existing.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord.left = pCand->left;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        pCand->right = g_baBounds[iExist].Coord.right;
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;


                case OL_MERGE_XMAX:
                    //
                    // - either the candidate abutts the existing rectangle
                    //   on the right
                    //
                    //              10,10        51,10
                    //               +----------++----------+
                    //               |          ||          |
                    //               |          ||          |
                    //               |          ||          |
                    //               |  Exist   ||  Cand    |
                    //               |          ||          |
                    //               |          ||          |
                    //               |          ||          |
                    //               +----------++----------+
                    //                      50,50         100,50
                    //
                    // - or the candidate overlaps the existing on the right
                    //   and can be merged
                    //
                    //              10,10   40,10
                    //               +-------+--+------+
                    //               |       |  |      |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               | Exist |  | Cand |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               |       |  |      |
                    //               +-------+--+------+
                    //                          50,50  90,50
                    //
                    // If the candidate is the original, merge the
                    // candidate into the existing, and make the existing
                    // the new candidate.
                    //
                    // If this is a merge of two existing rectangles (ie
                    // the candidate is the result of a merge), merge the
                    // overlapping existing into the candidate (the last
                    // merged) and remove the existing.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord.right = pCand->right;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        pCand->left = g_baBounds[iExist].Coord.left;
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;

                case OL_MERGE_YMIN:
                    //
                    // - either the candidate abutts the existing rectangle
                    //   on the top
                    //
                    //              10,10
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,50
                    //            10,51+---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,100
                    //
                    // - or the candidate overlaps the existing on the top
                    //   and can be merged
                    //
                    //              10,10
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 |         |
                    //      Exist 10,40+---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,60 Cand
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,100
                    //
                    // If the candidate is the original, merge the
                    // candidate into the existing, and make the existing
                    // the new candidate.
                    //
                    // If this is a merge of two existing rectangles (ie
                    // the candidate is the result of a merge), merge the
                    // overlapping existing into the candidate (the last
                    // merged) and remove the existing.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord.top = pCand->top;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        pCand->bottom = g_baBounds[iExist].Coord.bottom;
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;

                case OL_MERGE_YMAX:
                    //
                    // - either the candidate abutts the existing rectangle
                    //   from below
                    //
                    //              10,10
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,50
                    //            10,51+---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,100
                    //
                    // - or the candidate overlaps the existing from below
                    //   and can be merged
                    //
                    //              10,10
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 |         |
                    //       Cand 10,40+---------+
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,60 Exist
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 |         |
                    //                 |         |
                    //                 +---------+50,100
                    //
                    // If the candidate is the original, merge the
                    // candidate into the existing, and make the existing
                    // the new candidate.
                    //
                    // If this is a merge of two existing rectangles (ie
                    // the candidate is the result of a merge), merge the
                    // overlapping existing into the candidate (the last
                    // merged) and remove the existing.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord.bottom = pCand->bottom;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        pCand->top = g_baBounds[iExist].Coord.top;
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;

                case OL_ENCLOSED:
                    //
                    // The existing is enclosed by the candidate.
                    //
                    //              100,100
                    //              +----------------------+
                    //              |        Cand          |
                    //              |                      |
                    //              |    130,130           |
                    //              |    +------------+    |
                    //              |    |            |    |
                    //              |    |            |    |
                    //              |    |   Exist    |    |
                    //              |    |            |    |
                    //              |    +------------+    |
                    //              |             170,170  |
                    //              |                      |
                    //              +----------------------+
                    //                                   200,200
                    //
                    // If the candidate is the original, replace the
                    // existing by the candidate, and make the new existing
                    // the new candidate.
                    //
                    // If the candidate is an existing rectangle, remove
                    // the other existing rectangle.
                    //
                    // For both, start the comparisons again with the new
                    // candidate.
                    //
                    if ( fRectToAdd )
                    {
                        g_baBounds[iExist].Coord   = *pCand;
                        pCand      = &(g_baBounds[iExist].Coord);
                        fRectToAdd = FALSE;
                        iLastMerge = iExist;
                    }
                    else
                    {
                        BA_RemoveRectList(&(g_baBounds[iExist].Coord));
                    }

                    fResetRects = TRUE;
                    break;

                case OL_PART_ENCLOSED_XMIN:
                    //
                    // The existing is partially enclosed by the candidate
                    // - but not on the right.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |        Cand          |
                    //           |                      |
                    //           |    130,130           |
                    //           |    +-----------------+---+
                    //           |    |                 |   |
                    //           |    |                 |   |
                    //           |    |   Exist         |   |
                    //           |    |                 |   |
                    //           |    +-----------------+---+
                    //           |                      |  220,170
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the existing rectangle to be the non-
                    // overlapped portion.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |                      |
                    //           |                      |201,130
                    //           |                      |+--+
                    //           |                      ||E |
                    //           |                      ||x |
                    //           |        Cand          ||i |
                    //           |                      ||s |
                    //           |                      ||t |
                    //           |                      ||  |
                    //           |                      |+--+
                    //           |                      |  220,170
                    //           +----------------------+
                    //                                200,200
                    //
                    // Note that this does not restart the comparisons.
                    //
                    g_baBounds[iExist].Coord.left = pCand->right + 1;
                    break;

                case OL_PART_ENCLOSED_XMAX:
                    //
                    // The existing is partially enclosed by the candidate
                    // - but not on the left.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |        Cand          |
                    //   70,130  |                      |
                    //     +-----+---------------+      |
                    //     |     |               |      |
                    //     |     |               |      |
                    //     |     |        Exist  |      |
                    //     |     |               |      |
                    //     +-----+---------------+      |
                    //           |           170,170    |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the existing rectangle to be the non-
                    // overlapped portion.
                    //
                    //           100,100
                    //           +----------------------+
                    //    70,130 |                      |
                    //     +----+|                      |
                    //     | E  ||                      |
                    //     | x  ||                      |
                    //     | i  ||        Cand          |
                    //     | s  ||                      |
                    //     | t  ||                      |
                    //     |    ||                      |
                    //     +----+|                      |
                    //     99,170|                      |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Note that this does not restart the comparisons.
                    //
                    g_baBounds[iExist].Coord.right = pCand->left - 1;
                    break;

                case OL_PART_ENCLOSED_YMIN:
                    //
                    // The existing is partially enclosed by the candidate
                    // - but not on the bottom.
                    //
                    //     100,100
                    //           +----------------------+
                    //           |        Cand          |
                    //           | 130,130              |
                    //           |     +--------+       |
                    //           |     |        |       |
                    //           |     |  Exist |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           +-----+--------+-------+
                    //                 |        |     200,200
                    //                 |        |
                    //                 |        |
                    //                 +--------+170,230
                    //
                    // Adjust the existing rectangle to be the non-
                    // overlapped portion.
                    //
                    //
                    //     100,100
                    //           +----------------------+
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |        Cand          |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           +----------------------+
                    //          130,201+---------+   200,200
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //                 +---------+170,230
                    //
                    // Note that this does not restart the comparisons.
                    //
                    g_baBounds[iExist].Coord.top = pCand->bottom + 1;
                    break;

                case OL_PART_ENCLOSED_YMAX:
                    //
                    // The existing is partially enclosed by the candidate
                    // - but not on the top.
                    //
                    //               70,130
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //     100,100     |         |
                    //           +-----+---------+------+
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     |  Exist  |      |
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     +---------+      |
                    //           |           170,170    |
                    //           |                      |
                    //           |        Cand          |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the existing rectangle to be the non-
                    // overlapped portion.
                    //
                    //               70,130
                    //                 +---------+
                    //                 |         |
                    //                 |  Exist  |
                    //                 |         |
                    //     100,100     +---------+170,99
                    //           +----------------------+
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |        Cand          |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Note that this does not restart the comparisons.
                    //
                    g_baBounds[iExist].Coord.bottom = pCand->top - 1;
                    break;

                case OL_ENCLOSES:
                    //
                    // The existing encloses the candidate.
                    //
                    //              100,100
                    //              +----------------------+
                    //              |        Exist         |
                    //              |                      |
                    //              |    130,130           |
                    //              |    +------------+    |
                    //              |    |            |    |
                    //              |    |            |    |
                    //              |    |   Cand     |    |
                    //              |    |            |    |
                    //              |    |            |    |
                    //              |    +------------+    |
                    //              |             170,170  |
                    //              |                      |
                    //              +----------------------+
                    //                                   200,200
                    //
                    // Just discard the candidate by exiting.
                    //
                    //
                    //
                    // Return FALSE indicating that the rectangle is
                    // already catered for by the existing bounds
                    //
                    rc= FALSE;
                    DC_QUIT;
                    break;

                case OL_PART_ENCLOSES_XMIN:
                    //
                    // The existing partially encloses the candidate - but
                    // not on the left.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |        Exist         |
                    //   70,130  |                      |
                    //     +-----+---------------+      |
                    //     |     |               |      |
                    //     |     |        Cand   |      |
                    //     |     |               |      |
                    //     +-----+---------------+      |
                    //           |           170,170    |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the candidate rectangle to be the non-
                    // overlapped portion.
                    //
                    //           100,100
                    //           +----------------------+
                    //    70,130 |                      |
                    //     +----+|                      |
                    //     |    ||                      |
                    //     | C  ||                      |
                    //     | a  ||                      |
                    //     | n  ||        Exist         |
                    //     | d  ||                      |
                    //     |    ||                      |
                    //     +----+|                      |
                    //     99,170|                      |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Because this affects the candidate, restart the
                    // comparisons to check for overlaps between the
                    // adjusted candidate and other existing rectangles.
                    //
                    //
                    pCand->right = g_baBounds[iExist].Coord.left - 1;

                    fResetRects = TRUE;
                    break;

                case OL_PART_ENCLOSES_XMAX:
                    //
                    // The existing partially encloses the candidate - but
                    // not on the right.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |        Exist         |
                    //           |                      |
                    //           |    130,130           |
                    //           |    +-----------------+---+
                    //           |    |                 |   |
                    //           |    |                 |   |
                    //           |    |   Cand          |   |
                    //           |    |                 |   |
                    //           |    +-----------------+---+
                    //           |                      |  220,170
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the candidate rectangle to be the non-
                    // overlapped portion.
                    //
                    //           100,100
                    //           +----------------------+
                    //           |                      |201,130
                    //           |                      |+--+
                    //           |                      ||  |
                    //           |                      ||C |
                    //           |        Exist         ||a |
                    //           |                      ||n |
                    //           |                      ||d |
                    //           |                      ||  |
                    //           |                      |+--+
                    //           |                      |  220,170
                    //           +----------------------+
                    //                                200,200
                    //
                    // Because this affects the candidate, restart the
                    // comparisons to check for overlaps between the
                    // adjusted candidate and other existing rectangles.
                    //
                    //
                    pCand->left = g_baBounds[iExist].Coord.right + 1;

                    fResetRects = TRUE;
                    break;

                case OL_PART_ENCLOSES_YMIN:
                    //
                    // The existing partially encloses the candidate - but
                    // not on the top.
                    //
                    //               70,130
                    //                 +---------+
                    //                 |         |
                    //                 |         |
                    //     100,100     |         |
                    //           +-----+---------+------+
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     |  Cand   |      |
                    //           |     |         |      |
                    //           |     |         |      |
                    //           |     +---------+      |
                    //           |           170,170    |
                    //           |                      |
                    //           |        Exist         |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Adjust the candidate rectangle to be the non-
                    // overlapped portion.
                    //
                    //
                    //               70,130
                    //                 +---------+
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //     100,100     +---------+170,99
                    //           +----------------------+
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |        Exist         |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           +----------------------+
                    //                                200,200
                    //
                    // Because this affects the candidate, restart the
                    // comparisons to check for overlaps between the
                    // adjusted candidate and other existing rectangles.
                    //
                    //
                    pCand->bottom = g_baBounds[iExist].Coord.top - 1;

                    fResetRects = TRUE;
                    break;

                case OL_PART_ENCLOSES_YMAX:
                    //
                    // The existing partially encloses the candidate - but
                    // not on the bottom.
                    //
                    //     100,100
                    //           +----------------------+
                    //           |        Exist         |
                    //           |                      |
                    //           | 130,130              |
                    //           |     +--------+       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |  Cand  |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           |     |        |       |
                    //           +-----+--------+-------+
                    //                 |        |     200,200
                    //                 |        |
                    //                 |        |
                    //                 +--------+170,230
                    //
                    // Adjust the candidate rectangle to be the non-
                    // overlapped portion.
                    //
                    //
                    //     100,100
                    //           +----------------------+
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |        Exist         |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           |                      |
                    //           +----------------------+
                    //          130,201+---------+   200,200
                    //                 |         |
                    //                 |  Cand   |
                    //                 |         |
                    //                 +---------+170,230
                    //
                    // Because this affects the candidate, restart the
                    // comparisons to check for overlaps between the
                    // adjusted candidate and other existing rectangles.
                    //
                    //
                    pCand->top = g_baBounds[iExist].Coord.bottom + 1;

                    fResetRects = TRUE;
                    break;

                case OL_SPLIT_X:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //               100,100
                    //                 +--------+
                    //                 |        |
                    //        70,130   |  Exist |
                    //           +-----+--------+------+
                    //           |     |        |      |
                    //           |     |        |      |
                    //           | Cand|        |      |
                    //           |     |        |      |
                    //           |     |        |      |
                    //           +-----+--------+------+180,160
                    //                 |        |
                    //                 |        |
                    //                 +--------+150,200
                    //
                    // Need to split candidate into left and right halves.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the left and a new rectangle on
                    // the right. Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //               100,100
                    //                 +--------+
                    //                 |        |
                    //        70,130   |        |151,130
                    //           +----+|        |+-----+
                    //           |    ||        ||     |
                    //           |    ||        ||     |
                    //           |Cand|| Exist  || New |
                    //           |    ||        ||     |
                    //           |    ||        ||     |
                    //           +----+|        |+-----+
                    //           99,160|        |     180,160
                    //                 |        |
                    //                 +--------+150,200
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //
                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = g_baBounds[iExist].Coord.right + 1;
                        rectNew.right  = pCand->right;
                        rectNew.top    = pCand->top;
                        rectNew.bottom = pCand->bottom;
                        pCand->right   = g_baBounds[iExist].Coord.left - 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_Y:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //               100,100
                    //                 +--------+
                    //                 |        |
                    //        70,130   |  Cand  |
                    //           +-----+--------+------+
                    //           |     |        |      |
                    //           |     |        |      |
                    //           |Exist|        |      |
                    //           |     |        |      |
                    //           |     |        |      |
                    //           +-----+--------+------+180,160
                    //                 |        |
                    //                 |        |
                    //                 +--------+150,200
                    //
                    // Need to split candidate into top and bottom halves.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the top and a new rectangle on
                    // the bottom.  Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //               100,100
                    //                 +--------+
                    //                 |  Cand  |
                    //        70,130   +--------+150,129
                    //           +---------------------+
                    //           |                     |
                    //           |                     |
                    //           |                     |
                    //           |                     |
                    //           |                     |
                    //           +---------------------+180,160
                    //          100,161+--------+
                    //                 |  New   |
                    //                 +--------+150,200
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = pCand->left;
                        rectNew.right  = pCand->right;
                        rectNew.top    = g_baBounds[iExist].Coord.bottom + 1;
                        rectNew.bottom = pCand->bottom;
                        pCand->bottom  = g_baBounds[iExist].Coord.top - 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_XMIN_YMIN:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //          100,100
                    //              +---------------+
                    //              |   Cand        |
                    //              |               |
                    //              |               |
                    //              |      150,150  |
                    //              |       +-------+-----+
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              +-------+-------+     |
                    //                      |    200,200  |
                    //                      |             |
                    //                      |    Exist    |
                    //                      |             |
                    //                      +-------------+
                    //                                 250,250
                    //
                    // Need to split candidate into top and left pieces.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the left and a new rectangle on
                    // the top.  Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //          100,100     151,100
                    //              +-------+-------+
                    //              |       |       |
                    //              |       |  New  |
                    //              |       |       |
                    //              |       |       |200,149
                    //              |       +-------+-----+
                    //              | Cand  |150,150      |
                    //              |       |             |
                    //              |       |             |
                    //              |       |             |
                    //              |       |    Exist    |
                    //              +-------+             |
                    //               150,200|             |
                    //                      |             |
                    //                      |             |
                    //                      |             |
                    //                      +-------------+
                    //                                 250,250
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //

                    if ( g_baRectsUsed < BA_NUM_RECTS )
                    {
                        rectNew.left   = g_baBounds[iExist].Coord.left;
                        rectNew.right  = pCand->right;
                        rectNew.top    = pCand->top;
                        rectNew.bottom = g_baBounds[iExist].Coord.top - 1;
                        pCand->right   = g_baBounds[iExist].Coord.left - 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_XMAX_YMIN:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //                  150,100
                    //                     +---------------+
                    //                     |               |
                    //                     |       Cand    |
                    //          100,150    |               |
                    //              +------+--------+      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      +--------+------+
                    //              |               |   250,200
                    //              |  Exist        |
                    //              |               |
                    //              +---------------+
                    //                           200,250
                    //
                    // Need to split candidate into top and right pieces.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the right and a new rectangle
                    // on the top.  Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //                  150,100     201,100
                    //                     +--------+------+
                    //                     |  New   |      |
                    //                     |        |      |
                    //          100,150    | 200,149|      |
                    //              +------+--------+      |
                    //              |               | Cand |
                    //              |               |      |
                    //              |               |      |
                    //              |               |      |
                    //              |     Exist     |      |
                    //              |               |      |
                    //              |               +------+
                    //              |               |   250,200
                    //              |               |
                    //              |               |
                    //              +---------------+
                    //                           200,250
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = pCand->left;
                        rectNew.right  = g_baBounds[iExist].Coord.right;
                        rectNew.top    = pCand->top;
                        rectNew.bottom = g_baBounds[iExist].Coord.top - 1;
                        pCand->left    = g_baBounds[iExist].Coord.right + 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_XMIN_YMAX:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //                  150,100
                    //                     +---------------+
                    //                     |               |
                    //                     |      Exist    |
                    //          100,150    |               |
                    //              +------+--------+      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      |        |      |
                    //              |      +--------+------+
                    //              |               |   250,200
                    //              |  Cand         |
                    //              |               |
                    //              +---------------+
                    //                           200,250
                    //
                    // Need to split candidate into left and bottom pieces.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the left and a new rectangle on
                    // the bottom.  Call this routine recursively to handle
                    // the new rectangle.
                    //
                    //                  150,100
                    //                     +---------------+
                    //                     |               |
                    //                     |               |
                    //          100,150    |               |
                    //              +------+               |
                    //              |      |               |
                    //              |      |               |
                    //              |      |               |
                    //              |      |               |
                    //              | Cand |               |
                    //              |      |               |
                    //              |      +--------+------+
                    //              |      |151,200 |   250,200
                    //              |      |        |
                    //              |      |  New   |
                    //              +------+--------+
                    //                  149,250   200,250
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = g_baBounds[iExist].Coord.left;
                        rectNew.right  = pCand->right;
                        rectNew.top    = g_baBounds[iExist].Coord.bottom + 1;
                        rectNew.bottom = pCand->bottom;
                        pCand->right   = g_baBounds[iExist].Coord.left - 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                case OL_SPLIT_XMAX_YMAX:
                    //
                    // The existing overlaps the candicate, but neither can
                    // be merged or adjusted.
                    //
                    //          100,100
                    //              +---------------+
                    //              |   Exist       |
                    //              |               |
                    //              |               |
                    //              |      150,150  |
                    //              |       +-------+-----+
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              |       |       |     |
                    //              +-------+-------+     |
                    //                      |    200,200  |
                    //                      |             |
                    //                      |    Cand     |
                    //                      |             |
                    //                      +-------------+
                    //                                 250,250
                    //
                    // Need to split candidate into bottom and right pieces.
                    //
                    // Only do a split if there is spare room in the list -
                    // because both the split rectangles may need to be
                    // added to the list.
                    //
                    // If there is spare room, split the candidate into a
                    // smaller candidate on the right and a new rectangle
                    // on the bottom.  Call this routine recursively to
                    // handle the new rectangle.
                    //
                    //          100,100
                    //              +---------------+
                    //              |               |
                    //              |               |
                    //              |               |
                    //              |               |201,150
                    //              |    Exist      +-----+
                    //              |               |     |
                    //              |               |     |
                    //              |               |     |
                    //              |               |Cand |
                    //              |        200,200|     |
                    //              +-------+-------+     |
                    //               150,201|       |     |
                    //                      |       |     |
                    //                      |  New  |     |
                    //                      |       |     |
                    //                      +-------+-----+
                    //                         200,250  250,250
                    //
                    // After the recursion, because the candidate has
                    // changed, restart the comparisons to check for
                    // overlaps between the adjusted candidate and other
                    // existing rectangles.
                    //
                    //

                    if ((g_baRectsUsed < BA_NUM_RECTS) &&
                        (level < ADDR_RECURSE_LIMIT))
                    {
                        rectNew.left   = pCand->left;
                        rectNew.right  = g_baBounds[iExist].Coord.right;
                        rectNew.top    = g_baBounds[iExist].Coord.bottom + 1;
                        rectNew.bottom = pCand->bottom;
                        pCand->left    = g_baBounds[iExist].Coord.right + 1;

                        TRACE_OUT(( "*** RECURSION ***"));
                        BAAddRect(&rectNew, level);
                        TRACE_OUT(( "*** RETURN    ***"));

                        if (!fRectToAdd && !g_baBounds[iLastMerge].InUse)
                        {
                            TRACE_OUT(( "FINISHED - %d", iLastMerge));
                            DC_QUIT;
                        }

                        fResetRects = TRUE;
                    }
                    break;

                default:
                    //
                    // This should not happen.
                    //
                    ERROR_OUT(( "Unrecognised overlap case-%d",OverlapType));
                    break;
            }

            iExist = (fResetRects) ? g_baFirstRect :
                                     g_baBounds[iExist].iNext;
        }


        //
        // Arriving here means that no overlap was found between the
        // candidate and the existing rectangles.
        //
        // - If the candidate is the original rectangle, add it to the
        //   list.
        // - If the candidate is an existing rectangle, it is already in
        //   the list.
        //
        if ( fRectToAdd )
        {
            BAAddRectList(pCand);
        }


        //
        // The compare and add processing above is allowed to add a
        // rectangle to the list when there are already BA_NUM_RECTS
        // (eg. when doing a split or when there is no overlap at all with
        // the existing rectangles) - and there is an extra slot for that
        // purpose.
        //
        // If we now have more than BA_NUM_RECTS rectangles, do a
        // forced merge, so that the next call to this routine has a spare
        // slot.
        //
        //
        fRectMerged = ( g_baRectsUsed > BA_NUM_RECTS );
        if ( fRectMerged )
        {
            //
            // Start looking for merged rectangles.
            //
            // For each rectangle in the list, compare it with the others,
            // and Determine cost of merging.
            //
            // We want to merge the two rectangles with the minimum
            // area difference, ie that will produce a merged
            // rectangle that covers the least superfluous screen
            // area.
            //
            // Note that we calculate the areas of the rectangles here
            // (rather than on the fly as they are created/ manipulated in
            // the loop), as the statistics show that forced merges occur
            // very much less frequently than non-forced manipulations (ie
            // splits, adds etc.
            //
            //
            bestMergeIncrease = 0x7FFFFFFF;

            for ( iExist = g_baFirstRect;
                  iExist != BA_INVALID_RECT_INDEX;
                  iExist = g_baBounds[iExist].iNext )
            {
                g_baBounds[iExist].Area =
                    COM_SizeOfRectInclusive(&g_baBounds[iExist].Coord);
            }

#ifdef _DEBUG
            iBestMerge1 = BA_INVALID_RECT_INDEX;
            iBestMerge2 = BA_INVALID_RECT_INDEX;
#endif
            for ( iExist = g_baFirstRect;
                  iExist != BA_INVALID_RECT_INDEX;
                  iExist = g_baBounds[iExist].iNext )
            {
                for ( iTmp = g_baBounds[iExist].iNext;
                      iTmp != BA_INVALID_RECT_INDEX;
                      iTmp = g_baBounds[iTmp].iNext )
                {
                    rectNew.left = min( g_baBounds[iExist].Coord.left,
                                           g_baBounds[iTmp].Coord.left );
                    rectNew.top = min( g_baBounds[iExist].Coord.top,
                                          g_baBounds[iTmp].Coord.top );
                    rectNew.right = max( g_baBounds[iExist].Coord.right,
                                            g_baBounds[iTmp].Coord.right );
                    rectNew.bottom = max( g_baBounds[iExist].Coord.bottom,
                                             g_baBounds[iTmp].Coord.bottom );

                    mergeIncrease = COM_SizeOfRectInclusive(&rectNew) -
                        g_baBounds[iExist].Area - g_baBounds[iTmp].Area;

                    if (bestMergeIncrease > mergeIncrease)
                    {
                        iBestMerge1 = iExist;
                        iBestMerge2 = iTmp;
                        bestMergeIncrease = mergeIncrease;
                    }
                }
            }

            ASSERT(iBestMerge1 != BA_INVALID_RECT_INDEX);
            ASSERT(iBestMerge2 != BA_INVALID_RECT_INDEX);

            //
            // Now do the merge.
            //
            // We recalculate the size of the merged rectangle here -
            // alternatively we could remember the size of the best so far
            // in the loop above.  The trade off is between calculating
            // twice or copying at least once but probably more than once
            // as we find successively better merges.
            //
            TRACE_OUT(("BestMerge1 %d, {%d,%d,%d,%d}", iBestMerge1,
                       g_baBounds[iBestMerge1].Coord.left,
                       g_baBounds[iBestMerge1].Coord.top,
                       g_baBounds[iBestMerge1].Coord.right,
                       g_baBounds[iBestMerge1].Coord.bottom ));

            TRACE_OUT(("BestMerge2 %d, {%d,%d,%d,%d}", iBestMerge2,
                       g_baBounds[iBestMerge2].Coord.left,
                       g_baBounds[iBestMerge2].Coord.top,
                       g_baBounds[iBestMerge2].Coord.right,
                       g_baBounds[iBestMerge2].Coord.bottom ));

            g_baBounds[iBestMerge1].Coord.left =
                            min( g_baBounds[iBestMerge1].Coord.left,
                                    g_baBounds[iBestMerge2].Coord.left );
            g_baBounds[iBestMerge1].Coord.top =
                            min( g_baBounds[iBestMerge1].Coord.top,
                                    g_baBounds[iBestMerge2].Coord.top );
            g_baBounds[iBestMerge1].Coord.right =
                            max( g_baBounds[iBestMerge1].Coord.right,
                                    g_baBounds[iBestMerge2].Coord.right );
            g_baBounds[iBestMerge1].Coord.bottom =
                            max( g_baBounds[iBestMerge1].Coord.bottom,
                                    g_baBounds[iBestMerge2].Coord.bottom );

            //
            // Remove the second best merge.
            //
            BA_RemoveRectList(&(g_baBounds[iBestMerge2].Coord));

            //
            // The best merged rectangle becomes the candidate, and we fall
            // back to the head of the comparison loop to start again.
            //
            pCand      = &(g_baBounds[iBestMerge1].Coord);
            iLastMerge = iBestMerge1;
            fRectToAdd = FALSE;
        }

    } while ( fRectMerged );

DC_EXIT_POINT:
    DebugExitBOOL(BAAddRect, rc);
    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\as16\globals.c ===
//
// GLOBALS.C
// Global Variable Storage/Init
//
// Copyright(c) Microsoft 1997-
//


#include <as16.h>

#include <datainit.h>
#include <globals.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\as16\cm.c ===
//
// CM.C
// Cursor Manager
//
// Copyright(c) 1997-
//

#include <as16.h>


//
// CM_DDProcessRequest()
// Handles CM escapes
//

BOOL CM_DDProcessRequest
(
    UINT    fnEscape,
    LPOSI_ESCAPE_HEADER     pResult,
    DWORD   cbResult
)
{
    BOOL        rc;

    DebugEntry(CM_DDProcessRequest);

    switch (fnEscape)
    {
        case CM_ESC_XFORM:
        {
            ASSERT(cbResult == sizeof(CM_DRV_XFORM_INFO));
            ((LPCM_DRV_XFORM_INFO)pResult)->result =
                    CMDDSetTransform((LPCM_DRV_XFORM_INFO)pResult);
            rc = TRUE;
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized CM_ escape"));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(CM_DDProcessRequest, rc);
    return(rc);
}



//
// CM_DDInit()
// 
BOOL CM_DDInit(HDC hdcScreen)
{
    BOOL    rc = FALSE;
    HGLOBAL hg;
    LPBYTE  lpfnPatch;

    DebugEntry(CM_DDInit);

    //
    // Get the size of the cursor
    //
    g_cxCursor = GetSystemMetrics(SM_CXCURSOR);
    g_cyCursor = GetSystemMetrics(SM_CYCURSOR);

    //
    // Create our work bit buffers
    //

    g_cmMonoByteSize = BitmapSize(g_cxCursor, g_cyCursor, 1, 1);
    g_cmColorByteSize = BitmapSize(g_cxCursor, g_cyCursor,
            g_osiScreenPlanes, g_osiScreenBitsPlane);

    // This will hold a color cursor, mono is always <= to this
    hg = GlobalAlloc(GMEM_FIXED | GMEM_SHARE, sizeof(CURSORSHAPE) +
        g_cmMonoByteSize + g_cmColorByteSize);
    g_cmMungedCursor = MAKELP(hg, 0);

    // Always alloc mono Xform
    hg = GlobalAlloc(GMEM_FIXED | GMEM_SHARE, 2 * g_cmMonoByteSize);
    g_cmXformMono = MAKELP(hg, 0);

    if (!SELECTOROF(g_cmMungedCursor) || !SELECTOROF(g_cmXformMono))
    {
        ERROR_OUT(("Couldn't allocate cursor xform buffers"));
        DC_QUIT;
    }

    lpfnPatch = (LPBYTE)g_lpfnSetCursor;

    // If color cursors supported, alloc color image bits, again 2x the size
    if (GetDeviceCaps(hdcScreen, CAPS1) & C1_COLORCURSOR)
    {
        hg = GlobalAlloc(GMEM_FIXED | GMEM_SHARE, 2 * g_cmColorByteSize);
        if (!hg)
        {
            ERROR_OUT(("Couldn't allocate color cursor xform buffer"));
            DC_QUIT;
        }

        g_cmXformColor = MAKELP(hg, 0);
    }
    else
    {
        //
        // Older drivers (VGA and SUPERVGA e.g.) hook int2f and read their
        // DS from the SetCursor ddi prolog code, in many places.  Therefore,
        // if we patch over this instruction, they will blow up.  For these
        // drivers, we patch 3 bytes after the start, which leaves
        //      mov  ax, DGROUP
        // intact and is harmless.  When we call the original routine, we call
        // back to the beginning, which will set up ax again before the body
        // of the ddi code.
        //
        // NOTE:
        // We use the color cursor caps for this detection.  DRIVERVERSION
        // doesn't work, VGA et al. got restamped in Win95.  This is the 
        // most reliable way to decide if this is an older driver or not.
        //
        // NOTE 2:
        // We still want to decode this routine to see if it is of the form
        // mov ax, xxxx.  If not, patch at the front anyway, or we'll write
        // possibly into the middle of an instruction.
        //
        if (*lpfnPatch == OPCODE_MOVAX)
            lpfnPatch = lpfnPatch + 3;
    }

    if (!CreateFnPatch(lpfnPatch, DrvSetPointerShape, &g_cmSetCursorPatch, 0))
    {
        ERROR_OUT(("Couldn't get cursor routines"));
        DC_QUIT;
    }

    g_cmSetCursorPatch.fInterruptable = TRUE;

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(CM_DDInit, rc);
    return(rc);
}



//
// CM_DDTerm()
//
void CM_DDTerm(void)
{
    DebugEntry(CM_DDTerm);

    //
    // Clean up our patches
    //
    DestroyFnPatch(&g_cmSetCursorPatch);

    g_cmXformOn = FALSE;
    g_cmCursorHidden = FALSE;
        
    //
    // Free our memory blocks.
    //
    if (SELECTOROF(g_cmXformColor))
    {
        GlobalFree((HGLOBAL)SELECTOROF(g_cmXformColor));
        g_cmXformColor = NULL;
    }

    if (SELECTOROF(g_cmXformMono))
    {
        GlobalFree((HGLOBAL)SELECTOROF(g_cmXformMono));
        g_cmXformMono = NULL;
    }

    if (SELECTOROF(g_cmMungedCursor))
    {
        GlobalFree((HGLOBAL)SELECTOROF(g_cmMungedCursor));
        g_cmMungedCursor = NULL;
    }

    DebugExitVOID(CM_DDTerm);
}



//
// CMDDSetTransform()
//
BOOL CMDDSetTransform(LPCM_DRV_XFORM_INFO pResult)
{
    BOOL    rc = FALSE;
    LPBYTE  lpAND;

    DebugEntry(CMDDSetTransform);

    //
    // Turn off transform
    //
    // Do this first--that way if an interrupt comes in, we won't apply
    // some half-copied xform to the cursor.  This can only happen for
    // an anicur.  We jiggle the cursor below, which will reset the
    // xform if necessary.
    //
    g_cmXformOn = FALSE;

    //
    // If AND bitmap is NULL, we are turning the transform off.  We also
    // do this if we can't get a 16:16 pointer to this memory
    //
    if (pResult->pANDMask == 0)
    {
        TRACE_OUT(("Clear transform"));
        rc = TRUE;
    }
    else
    {
        ASSERT(pResult->width == g_cxCursor);
        ASSERT(pResult->height == g_cyCursor);
        
        lpAND = MapLS(pResult->pANDMask);
        if (!SELECTOROF(lpAND))
        {
            ERROR_OUT(("Couldn't get AND mask pointer"));
            DC_QUIT;
        }

        hmemcpy(g_cmXformMono, lpAND, 2 * g_cmMonoByteSize);
        UnMapLS(lpAND);

        if (SELECTOROF(g_cmXformColor))
        {
            HBITMAP hbmMono = NULL;
            HBITMAP hbmMonoOld;
            HBITMAP hbmColorOld;
            HBITMAP hbmColor = NULL;
            HDC     hdcMono = NULL;
            HDC     hdcColor = NULL;

            //
            // Get color expanded version of the mask & image.
            // We do this blting the mono bitmap into a color one, then
            // getting the color bits.
            //
            hdcColor = CreateCompatibleDC(g_osiScreenDC);
            hbmColor = CreateCompatibleBitmap(g_osiScreenDC, g_cxCursor,
                2*g_cyCursor);

            if (!hdcColor || !hbmColor)
                goto ColorError;

            hbmColorOld = SelectBitmap(hdcColor, hbmColor);

            hdcMono = CreateCompatibleDC(hdcColor);
            hbmMono = CreateBitmap(g_cxCursor, 2*g_cyCursor, 1, 1,
                g_cmXformMono);
            hbmMonoOld = SelectBitmap(hdcMono, hbmMono);

            if (!hdcMono || !hbmMono)
                goto ColorError;

            //
            // The defaults should be black & white for the text/back
            // colors, since we just created these DCs
            //
            ASSERT(GetBkColor(hdcColor) == RGB(255, 255, 255));
            ASSERT(GetTextColor(hdcColor) == RGB(0, 0, 0));

            ASSERT(GetBkColor(hdcMono) == RGB(255, 255, 255));
            ASSERT(GetTextColor(hdcMono) == RGB(0, 0, 0));

            BitBlt(hdcColor, 0, 0, g_cxCursor, 2*g_cyCursor, hdcMono,
                0, 0, SRCCOPY);

            GetBitmapBits(hbmColor, 2*g_cmColorByteSize, g_cmXformColor);

            g_cmXformOn = TRUE;

ColorError:
            if (hbmColor)
            {
                SelectBitmap(hdcColor, hbmColorOld);
                DeleteBitmap(hbmColor);
            }
            if (hdcColor)
            {
                DeleteDC(hdcColor);
            }

            if (hbmMono)
            {
                SelectBitmap(hdcMono, hbmMonoOld);
                DeleteBitmap(hbmMono);
            }
            if (hdcMono)
            {
                DeleteDC(hdcMono);
            }
        }
        else
            g_cmXformOn = TRUE;

        rc = (g_cmXformOn != 0);
    }


DC_EXIT_POINT:
    //
    // Jiggle the cursor to get it to redraw with the new transform
    //
    CMDDJiggleCursor();

    DebugExitBOOL(CMDDSetTransform, rc);
    return(rc);
}



//
// CM_DDViewing()
//
// We install our hooks & jiggle the cursor, if starting.
// We remove our hooks, if stopping.
//
void CM_DDViewing(BOOL fViewers)
{
    DebugEntry(CM_DDViewing);

    //
    // SetCursor() can be called at interrupt time for animated cursors.
    // Fortunately, we don't have to really pagelock the data segments
    // we touch.  Animated cursors aren't allowed when you page through DOS.
    // When paging in protected mode, the guts of Windows can handle
    // page-ins during 16-bit ring3 reflected interrupts.  Therfore
    // GlobalFix() works just fine.
    //
    if (fViewers)
    {
        // Do this BEFORE enabling patch
        GlobalFix(g_hInstAs16);
        GlobalFix((HGLOBAL)SELECTOROF((LPBYTE)DrvSetPointerShape));

        GlobalFix((HGLOBAL)SELECTOROF(g_cmMungedCursor));
        GlobalFix((HGLOBAL)SELECTOROF(g_cmXformMono));

        if (SELECTOROF(g_cmXformColor))
            GlobalFix((HGLOBAL)SELECTOROF(g_cmXformColor));

    }

    //
    // This enable will disable interrupts while copying bytes back and
    // forth.  Animated cursors draw at interrupt time, and one could
    // come in while we're in the middle of copying the patch.  The code
    // would blow up on half-copied instructions.
    //
    EnableFnPatch(&g_cmSetCursorPatch, (fViewers ? PATCH_ACTIVATE : PATCH_DEACTIVATE));

    if (!fViewers)
    {
        // Do this AFTER disabling patch
        if (SELECTOROF(g_cmXformColor))
            GlobalUnfix((HGLOBAL)SELECTOROF(g_cmXformColor));
        
        GlobalUnfix((HGLOBAL)SELECTOROF(g_cmXformMono));
        GlobalUnfix((HGLOBAL)SELECTOROF(g_cmMungedCursor));

        GlobalUnfix((HGLOBAL)SELECTOROF((LPBYTE)DrvSetPointerShape));
        GlobalUnfix(g_hInstAs16);
    }
    else
    {
        //
        // Jiggle the cursor to get the current image
        //
        CMDDJiggleCursor();
    }

    DebugExitVOID(CM_DDViewing);
}


//
// CMDDJiggleCursor()
// This causes the cursor to redraw with/without our tag.
//
void CMDDJiggleCursor(void)
{
    DebugEntry(CMDDJiggleCursor);

    if (g_asSharedMemory)
    {
        //
        // Toggle full screen via WinOldAppHackOMatic().  This is the most
        // innocuous way I can come up with to force USER to refresh the
        // cursor with all the right parameters.
        //
        // If a full screen dos box is currently up, we don't need to do
        // anything--the user doesn't have a cursor, and the cursor will
        // refesh when we go back to windows mode anyway.
        //
        // Sometimes 16-bit code is beautiful!   We own the win16lock,
        // so the two function calls below are atomic, and we know USER
        // won't do any calculation that would check the fullscreen state
        // while we're in the middle.
        //
        if (!g_asSharedMemory->fullScreen)
        {
            WinOldAppHackoMatic(WOAHACK_LOSINGDISPLAYFOCUS);
            WinOldAppHackoMatic(WOAHACK_GAININGDISPLAYFOCUS);
        }
    }

    DebugExitVOID(CMDDJiggleCursor);
}



//
// DrvSetPointerShape()
// This is the intercept for the display driver's SetCursor routine.
// 
// NOTE THAT THIS CAN BE CALLED AT INTERRUPT TIME FOR ANIMATED CURSORS.
//
// While we can access our data (interrupt calls only happen when NOT
// paging thru DOS, and protected mode paging can take pagefaults in ring3
// reflected interrupt code), we can not call kernel routines that might
// access non-fixed things.
// 
// THIS MEANS NO DEBUG TRACING AT ALL IN THIS FUNCTION.  AND NO CALLS TO
// HMEMCPY.
//
// We must preserve EDX.  Memphis display drivers get passed an instance
// value from USER in this register.  We only trash DX, so that's all we
// need to save.
//
#pragma optimize("gle", off)
BOOL WINAPI DrvSetPointerShape(LPCURSORSHAPE lpcur)
{
    UINT    dxSave;
    BOOL    rc;
    UINT    i;
    LPDWORD lpDst;
    LPDWORD lpSrc;
    LPCURSORSHAPE   lpcurNew;
    LPCM_FAST_DATA  lpcmShared;

    _asm    mov dxSave, dx

    //
    // Call the original entry point in the driver with the xformed bits
    // NOTE:  
    // For VGA/SUPERVGA et al, we patch at SetCursor+3 to leave the
    //      move ax, dgroup instruction intact.  We call through the org
    //      routine to get ax reset up.
    //

    EnableFnPatch(&g_cmSetCursorPatch, PATCH_DISABLE);

    lpcurNew = XformCursorBits(lpcur);

    _asm    mov dx, dxSave
    rc  = g_lpfnSetCursor(lpcurNew);

    EnableFnPatch(&g_cmSetCursorPatch, PATCH_ENABLE);

    //
    // Did it succeed?
    //
    if (!rc)
        DC_QUIT;


    //
    // Hiding the cursor is done on Win95 by calling with NULL
    //
    if (!SELECTOROF(lpcur))
    {
        if (!g_cmCursorHidden)
        {
            CM_SHM_START_WRITING;
            g_asSharedMemory->cmCursorHidden = TRUE;
            CM_SHM_STOP_WRITING;

            g_cmCursorHidden = TRUE;
        }
    }
    else
    {
        // Set the bits first, THEN show the cursor to avoid flicker
        lpcmShared = CM_SHM_START_WRITING;

        //
        // NOTE:  if this isn't the right size or a recognizable color
        // format, set a NULL cursor.  This should never happen, but Win95's
        // own display driver has checks for it, and if it does we'll blue
        // screen if we do nothing.
        //
        if ((lpcur->cx != g_cxCursor)   ||
            (lpcur->cy != g_cyCursor)   ||
            ((lpcur->BitsPixel != 1) && (lpcur->BitsPixel != g_osiScreenBitsPlane)) ||
            ((lpcur->Planes != 1) && (lpcur->Planes != g_osiScreenPlanes)))
        {
            // Set 'null' cursor
            lpcmShared->cmCursorShapeData.hdr.cPlanes = 0xFF;
            lpcmShared->cmCursorShapeData.hdr.cBitsPerPel = 0xFF;
            goto CursorDone;
        }

        lpcmShared->cmCursorShapeData.hdr.ptHotSpot.x = lpcur->xHotSpot;
        lpcmShared->cmCursorShapeData.hdr.ptHotSpot.y = lpcur->yHotSpot;
        lpcmShared->cmCursorShapeData.hdr.cx          = lpcur->cx;
        lpcmShared->cmCursorShapeData.hdr.cy          = lpcur->cy;
        lpcmShared->cmCursorShapeData.hdr.cPlanes     = lpcur->Planes;
        lpcmShared->cmCursorShapeData.hdr.cBitsPerPel = lpcur->BitsPixel;
        lpcmShared->cmCursorShapeData.hdr.cbRowWidth  = lpcur->cbWidth;

        //
        // Can't call hmemcpy at interrupt time.  So we copy a DWORD
        // at a time.
        //
        // LAURABU:  NM 2.0 did this too.  But maybe we should right this
        // in ASM for speed...
        //
        i = BitmapSize(lpcur->cx, lpcur->cy, 1, 1) +
            BitmapSize(lpcur->cx, lpcur->cy, lpcur->Planes, lpcur->BitsPixel);
        i >>= 2;

        lpDst = (LPDWORD)lpcmShared->cmCursorShapeData.data;
        lpSrc = (LPDWORD)(lpcur+1);

        while (i-- > 0)
        {
            *(lpDst++) = *(lpSrc++);
        }

        if ((lpcur->Planes == 1) && (lpcur->BitsPixel == 1))
        {
            //
            // Mono color table
            //
            lpcmShared->colorTable[0].peRed         = 0;
            lpcmShared->colorTable[0].peGreen       = 0;
            lpcmShared->colorTable[0].peBlue        = 0;
            lpcmShared->colorTable[0].peFlags       = 0;

            lpcmShared->colorTable[1].peRed         = 255;
            lpcmShared->colorTable[1].peGreen       = 255;
            lpcmShared->colorTable[1].peBlue        = 255;
            lpcmShared->colorTable[1].peFlags       = 0;
        }
        else if (g_osiScreenBPP <= 8)
        {
            UINT    iBase;

            //
            // Color cursors for this depth only use VGA colors.  So fill
            // in LOW 8 and HIGH 8, skip rest.  There will be garbage in
            // the middle 256-16 colors for 256 color cursors, but none
            // of those RGBs are referenced in the bitmap data.
            //
            for (i = 0; i < 8; i++)
            {
                lpcmShared->colorTable[i]  =   g_osiVgaPalette[i];
            }

            if (g_osiScreenBPP == 4)
                iBase = 8;
            else
                iBase = 0xF8;

            for (i = 0; i < 8; i++)
            {
                lpcmShared->colorTable[i + iBase] = g_osiVgaPalette[i + 8];
            }
        }
        else
        {
            lpcmShared->bitmasks[0] = g_osiScreenRedMask;
            lpcmShared->bitmasks[1] = g_osiScreenGreenMask;
            lpcmShared->bitmasks[2] = g_osiScreenBlueMask;
        }

CursorDone:
        lpcmShared->cmCursorStamp   = g_cmNextCursorStamp++;

        if (g_cmCursorHidden)
        {
            g_asSharedMemory->cmCursorHidden = FALSE;
            g_cmCursorHidden = FALSE;
        }

        CM_SHM_STOP_WRITING;
    }

DC_EXIT_POINT:
    return(rc);
}
#pragma optimize("", on)



//
// XformCursorBits()
// This routine copies and transforms the cursor bits at the same time.
// We return either the same thing passed in (if we can't xform it) or
// our temp buffer g_cmXformMono.
//
LPCURSORSHAPE XformCursorBits
(
    LPCURSORSHAPE  lpOrg
)
{
    LPCURSORSHAPE   lpResult;
    LPDWORD lpDst;
    LPDWORD lpSrc;
    LPDWORD lpXform;
    UINT    cDwords;
    BOOL    fColor;

    lpResult = lpOrg;

    //
    // If no xform is on, bail out
    //
    if (!g_cmXformOn || !SELECTOROF(lpOrg))
        DC_QUIT;

    //
    // If the cursor isn't the right size, forget it.
    //
    if ((lpOrg->cx != g_cxCursor) || (lpOrg->cy != g_cyCursor))
        DC_QUIT;

    //
    // If the cursor isn't monochrome or the color depth of the display,
    // forget it.
    //
    if ((lpOrg->Planes == 1) && (lpOrg->BitsPixel == 1))
    {
        // We handle this
        fColor = FALSE;
    }
    else if ((lpOrg->Planes == g_osiScreenPlanes) && (lpOrg->BitsPixel == g_osiScreenBitsPlane))
    {
        // We handle this
        fColor = TRUE;
    }
    else
    {
        // Unrecognized
        DC_QUIT;
    }

    //
    // OK, we can handle this
    //
    lpResult = g_cmMungedCursor;

    //
    // COPY THE HEADER
    //
    *lpResult = *lpOrg;

    //
    // FIRST:
    // AND the two masks together (both are mono)
    //

    lpDst   = (LPDWORD)(lpResult+1);
    lpSrc   = (LPDWORD)(lpOrg+1);
    lpXform = (LPDWORD)g_cmXformMono;

    cDwords = g_cmMonoByteSize >> 2;
    while (cDwords-- > 0)
    {
        *lpDst = (*lpSrc) & (*lpXform);

        lpDst++;
        lpSrc++;
        lpXform++;
    }

    //
    // SECOND:
    // AND the mask of the xform with the image of the cursor.  If the
    // cursor is color, use the color-expanded mask of the xform
    //
    if (fColor)
    {
        lpXform = (LPDWORD)g_cmXformColor;
        cDwords = g_cmColorByteSize;
    }
    else
    {
        lpXform = (LPDWORD)g_cmXformMono;
        cDwords = g_cmMonoByteSize;
    }
    cDwords >>= 2;

    while (cDwords-- > 0)
    {
        *lpDst = (*lpSrc) & (*lpXform);

        lpDst++;
        lpSrc++;
        lpXform++;
    }

    //
    // LAST:
    // XOR the image of the xform with the image of the cursor
    //
    if (fColor)
    {
        lpXform = (LPDWORD)(g_cmXformColor + g_cmColorByteSize);
        cDwords = g_cmColorByteSize;
    }
    else
    {
        lpXform = (LPDWORD)(g_cmXformMono + g_cmMonoByteSize);
        cDwords = g_cmMonoByteSize;
    }
    cDwords >>= 2;

    lpDst = (LPDWORD)((LPBYTE)(lpResult+1) + g_cmMonoByteSize);

    while (cDwords-- > 0)
    {
        *lpDst ^= (*lpXform);

        lpDst++;
        lpXform++;
    }

DC_EXIT_POINT:
    return(lpResult);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\as16\com.c ===
//
// COM.C
// Utility functions
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>


//
// PostMessageNoFail()
// This makes sure posted messages don't get lost on Win95 due to the fixed
// interrupt queue.  Conveniently, USER exports PostPostedMessages for
// KERNEL to flush the queue, so we call that before calling PostMessage().
//
void PostMessageNoFail(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PostPostedMessages();
    PostMessage(hwnd, uMsg, wParam, lParam);
}


//
// AnsiToUni()
//
// UniToAnsi() is conveniently exported by krnl386.  However, we need 
// AnsiToUni() conversions also so we can make sure we end up where we
// started.  This one we have to roll our own thunk for
//
int AnsiToUni
(
    LPSTR   lpAnsi,
    int     cchAnsi,
    LPWSTR  lpUni,
    int     cchUni
)
{
    DWORD   dwMask;
    LONG    lReturn;

    DebugEntry(AnsiToUni);

    ASSERT(g_lpfnAnsiToUni);
    ASSERT(SELECTOROF(lpAnsi));
    ASSERT(SELECTOROF(lpUni));

    //
    // Set up the mask.  These are the params:
    //      0   --  CodePage (CP_ACP, which is 0L)
    //      1   --  Flags (0L)
    //      2   --  lpAnsi              POINTER
    //      3   --  cchAnsi
    //      4   --  lpUni               POINTER
    //      5   --  cchUni
    //
    //
    dwMask = (1L << 2) | (1L << 4);

    //
    // Take the win16lock an extra time; this API will release it, and we
    // can't yield in the middle of a GDI call.
    //
    _EnterWin16Lock();
    lReturn = CallProcEx32W(6, dwMask, (DWORD)g_lpfnAnsiToUni, 0L, 0L, lpAnsi,
        (DWORD)(UINT)cchAnsi, lpUni, (DWORD)(UINT)cchUni);
    _LeaveWin16Lock();

    DebugExitDWORD(AnsiToUni, (DWORD)lReturn);
    return((int)lReturn);
}


//
// PATCHING CODE
//


//
// Get32BitOnlyExport16()
//
// This function gets hold of a 16:16 function address that isn't exported
// but is called via a flat thunk from the exported 32-bit version.  We use
// this for GDI and USER functions that are handy.
//
// This code assumes that the 32-bit routine looks like the following:
//      <DEBUG>
//          68 dwStr32          Push string
//          E8 dwOffsetOut      Call trace out
//      <DEBUG AND RETAIL>
//          B1 bIndex           Put offset in thunk table into cl
//        OR
//          66 B9 wIndex        Put offset in thunk table into cx
//          
//          EB bOffset          Jmp to common flat thunk routine
//        OR
//          66 ED wOffset       Jmp word to common flat thunk routine
//        OR
//          prolog of common flat thunk routine
//          
BOOL GetGdi32OnlyExport
(
    LPSTR   lpszExport32,
    UINT    cbJmpOffset,
    FARPROC FAR* lplpfn16
)
{
    BOOL    rc;

    DebugEntry(GetGdi32OnlyExport);

    rc = Get32BitOnlyExport(GetProcAddress32(g_hInstGdi32, lpszExport32),
        cbJmpOffset, FT_GdiFThkThkConnectionData, lplpfn16);

    DebugExitBOOL(GetGdi32OnlyExport, rc);
    return(rc);
}


BOOL GetUser32OnlyExport
(
    LPSTR   lpszExport32,
    FARPROC FAR* lplpfn16
)
{
    BOOL    rc;

    DebugEntry(GetUser32OnlyExport);

    rc = Get32BitOnlyExport(GetProcAddress32(g_hInstUser32, lpszExport32),
        0, FT_UsrFThkThkConnectionData, lplpfn16);

    DebugExitBOOL(GetUser32OnlyExport, rc);
    return(rc);
}



BOOL Get32BitOnlyExport
(
    DWORD   dwfn32,
    UINT    cbJmpOffset,
    LPDWORD lpThunkTable,
    FARPROC FAR* lplpfn16
)
{
    LPBYTE  lpfn32;
    UINT    offsetThunk;

    DebugEntry(Get32BitOnlyExport);

    ASSERT(lplpfn16);
    *lplpfn16 = NULL;

    //
    // The thunk table pointer points to two DWORDs.  The first is a
    // checksum signature.  The second is the pointer to the target
    // function array.
    //
    ASSERT(!IsBadReadPtr(lpThunkTable, 2*sizeof(DWORD)));
    lpThunkTable = (LPDWORD)lpThunkTable[1];
    ASSERT(!IsBadReadPtr(lpThunkTable, sizeof(DWORD)));

    //
    // Get 16:16 pointer to export
    //
    lpfn32 = NULL;

    if (!dwfn32)
    {
        ERROR_OUT(("Missing 32-bit export"));
        DC_QUIT;
    }

    lpfn32 = MapLS((LPVOID)dwfn32);
    if (!SELECTOROF(lpfn32))
    {
        ERROR_OUT(("Out of selectors"));
        DC_QUIT;
    }

    //
    // Was a jmp offset passed in?  If so, decode the instruction there.
    // It should be a jmp <dword offset>.  Figure out what EIP would be
    // if we jumped there. That's the place the flat thunk occurs.  
    // Currently, only PolyPolyline needs this.
    //
    if (cbJmpOffset)
    {
        if (IsBadReadPtr(lpfn32, cbJmpOffset+5) ||
            (lpfn32[cbJmpOffset] != OPCODE32_JUMP4))
        {
            ERROR_OUT(("Can't read 32-bit export"));
            DC_QUIT;
        }

        //
        // Add dword at cbJmpOffset+1, add this number to (lpfn32+cbJmpOffset+
        // 5), which is the EIP of the next instruction after the jump.  This
        // produces the EIP of the real thunk stub.
        //
        dwfn32 += cbJmpOffset + 5 + *(LPDWORD)(lpfn32+cbJmpOffset+1);

        UnMapLS(lpfn32);
        lpfn32 = MapLS((LPVOID)dwfn32);
        if (!SELECTOROF(lpfn32))
        {
            ERROR_OUT(("Out of selectors"));
            DC_QUIT;
        }
    }

    //
    // Verify that we can read 13 bytes.  The reason this will won't go 
    // past the end in a legitimate case is that this thunklet is either
    // followed by the large # of bytes in the common flat thunk routine,
    // or by another thunklet
    //
    if (IsBadReadPtr(lpfn32, 13))
    {
        ERROR_OUT(("Can't read code in 32-bit export"));
        DC_QUIT;
    }

    //
    // Does this have the 10-byte DEBUG prolog?
    //
    if (*lpfn32 == OPCODE32_PUSH)
    {
        // Yes, skip it
        lpfn32 += 5;

        // Make sure that next thing is a call
        if (*lpfn32 != OPCODE32_CALL)
        {
            ERROR_OUT(("Can't read code in 32-bit export"));
            DC_QUIT;
        }

        lpfn32 += 5;
    }

    //
    // This should either be mov cl, byte or mov cx, word
    //
    if (*lpfn32 == OPCODE32_MOVCL)
    {
        offsetThunk = *(lpfn32+1);
    }
    else if (*((LPWORD)lpfn32) == OPCODE32_MOVCX)
    {
        //
        // NOTE:  Even though this is a CX offset, the thunk code only
        // looks at the low BYTE
        //
        offsetThunk = *(lpfn32+2);
    }
    else
    {
        ERROR_OUT(("Can't read code in 32-bit export"));
        DC_QUIT;
    }

    //
    // Now, can we read this value?
    //
    if (IsBadReadPtr(lpThunkTable+offsetThunk, sizeof(DWORD)) ||
        IsBadCodePtr((FARPROC)lpThunkTable[offsetThunk]))
    {
        ERROR_OUT(("Can't read thunk table entry"));
        DC_QUIT;
    }

    *lplpfn16 = (FARPROC)lpThunkTable[offsetThunk];

DC_EXIT_POINT:
    if (SELECTOROF(lpfn32))
    {
        UnMapLS(lpfn32);
    }
    DebugExitBOOL(Get32BitOnlyExport16, (*lplpfn16 != NULL));
    return(*lplpfn16 != NULL);
}




//
// CreateFnPatch()
// This sets things up to be able to quickly patch/unpatch a system routine.
// The patch is not originally enabled.
//
UINT CreateFnPatch
(
    LPVOID      lpfnToPatch,
    LPVOID      lpfnJumpTo,
    LPFN_PATCH  lpbPatch,
    UINT        uCodeAlias
)
{
    SEGINFO     segInfo;
    UINT        ib;

    DebugEntry(CreateFnPatch);

    ASSERT(lpbPatch->lpCodeAlias == NULL);
    ASSERT(lpbPatch->wSegOrg == 0);

    //
    // Do NOT call IsBadReadPtr() here, that will cause the segment, if
    // not present, to get pulled in, and will masks problems in the debug
    // build that will show up in retail.
    //
    // Fortunately, PrestoChangoSelector() will set the linear address and
    // limit and attributes of our read/write selector properly.
    //

    //
    // Call GetCodeInfo() to check out bit-ness of code segment.  If 32-bit
    // we need to use the 16-bit override opcode for a far 16:16 jump.
    //
    segInfo.flags = 0;
    GetCodeInfo(lpfnToPatch, &segInfo);
    if (segInfo.flags & NSUSE32)
    {
        WARNING_OUT(("Patching 32-bit code segment 0x%04x:0x%04x", SELECTOROF(lpfnToPatch), OFFSETOF(lpfnToPatch)));
        lpbPatch->f32Bit = TRUE;
    }

    //
    // We must fix the codeseg in linear memory, or our shadow will end up
    // pointing somewhere if the original moves.  PolyBezier and SetPixel
    // are in moveable code segments for example.
    //
    // So save this away.  We will fix it when the patch is enabled.
    //
    lpbPatch->wSegOrg = SELECTOROF(lpfnToPatch);

    if (uCodeAlias)
    {
        //
        // We are going to share an already allocated selector.  Note that
        // this only works if the code segments of the two patched functions
        // are identical.  We verify this by the base address in an assert
        // down below.
        //
        lpbPatch->fSharedAlias = TRUE;
    }
    else
    {
        //
        // Create a selector with read-write attributes to alias the read-only
        // code function.  Using the original will set the limit of our
        // selector to the same as that of the codeseg, with the same
        // attributes but read-write.
        //
        uCodeAlias = AllocSelector(SELECTOROF(lpfnToPatch));
        if (!uCodeAlias)
        {
            ERROR_OUT(("CreateFnPatch: Unable to create alias selector"));
            DC_QUIT;
        }
        uCodeAlias = PrestoChangoSelector(SELECTOROF(lpfnToPatch), uCodeAlias);
    }

    lpbPatch->lpCodeAlias = MAKELP(uCodeAlias, OFFSETOF(lpfnToPatch));

    //
    // Create the N patch bytes (jmp far16 Seg:Function) of the patch
    //
    ib = 0;
    if (lpbPatch->f32Bit)
    {
        lpbPatch->rgbPatch[ib++] = OPCODE32_16OVERRIDE;
    }
    lpbPatch->rgbPatch[ib++] = OPCODE_FARJUMP16;
    lpbPatch->rgbPatch[ib++] = LOBYTE(OFFSETOF(lpfnJumpTo));
    lpbPatch->rgbPatch[ib++] = HIBYTE(OFFSETOF(lpfnJumpTo));
    lpbPatch->rgbPatch[ib++] = LOBYTE(SELECTOROF(lpfnJumpTo));
    lpbPatch->rgbPatch[ib++] = HIBYTE(SELECTOROF(lpfnJumpTo));

    lpbPatch->fActive  = FALSE;
    lpbPatch->fEnabled = FALSE;
     
DC_EXIT_POINT:
    DebugExitBOOL(CreateFnPatch, uCodeAlias);
    return(uCodeAlias);
}



//
// DestroyFnPatch()
// This frees any resources used when creating a function patch.  The
// alias data selector to the codeseg for writing purposes is it.
//
void DestroyFnPatch(LPFN_PATCH lpbPatch)
{
    DebugEntry(DestroyFnPatch);

    //
    // First, disable the patch if in use
    //
    if (lpbPatch->fActive)
    {
        TRACE_OUT(("Destroying active patch"));
        EnableFnPatch(lpbPatch, PATCH_DEACTIVATE);
    }

    //
    // Second, free the alias selector if we allocated one
    //
    if (lpbPatch->lpCodeAlias)
    {
        if (!lpbPatch->fSharedAlias)
        {
            FreeSelector(SELECTOROF(lpbPatch->lpCodeAlias));
        }
        lpbPatch->lpCodeAlias = NULL;
    }

    //
    // Third, clear this to fine cleanup problems
    //
    lpbPatch->wSegOrg = 0;
    lpbPatch->f32Bit  = FALSE;

    DebugExitVOID(DestroyFnPatch);
}




//
// EnableFnPatch()
// This actually patches the function to jump to our routine using the
// info saved when created.
//
// THIS ROUTINE MAY GET CALLED AT INTERRUPT TIME.  YOU CAN NOT USE ANY
// EXTERNAL FUNCTION, INCLUDING DEBUG TRACING/ASSERTS.
//
#define SAFE_ASSERT(x)       if (!lpbPatch->fInterruptable) { ASSERT(x); }

void EnableFnPatch(LPFN_PATCH lpbPatch, UINT flags)
{
    UINT    ib;
    UINT    cbPatch;

    SAFE_ASSERT(lpbPatch->lpCodeAlias);
    SAFE_ASSERT(lpbPatch->wSegOrg);

    //
    // Make sure the original and the alias are pointing to the same
    // linear memory.  We don't do this when not enabling/disabling for calls,
    // only when starting/stopping the patches
    //

    //
    // If enabling for the first time, fix BEFORE bytes are copied
    //
    if ((flags & ENABLE_MASK) == ENABLE_ON)
    {
        //
        // We need to fix the original code segment so it won't move in
        // linear memory.  Note that we set the selector base of our alias
        // even though several patches (not too many) may share one.  The 
        // extra times are harmless, and this prevents us from having to order
        // patches in our array in such a way that the original precedes the
        // shared ones, and walking our array in opposite orders to enable or
        // disable.
        //
        // And GlobalFix() just bumps up a lock count, so again, it's OK to do
        // this multiple times.
        //

        //
        // WE KNOW THIS CODE DOESN'T EXECUTE AT INTERRUPT TIME.
        //
        ASSERT(!lpbPatch->fEnabled);
        ASSERT(!lpbPatch->fActive);

        if (!lpbPatch->fActive)
        {
            lpbPatch->fActive = TRUE;

            //
            // Make sure this segment gets pulled in if discarded.  GlobalFix()
            // fails if not, and worse we'll fault the second we try to write 
            // to or read from the alias.  We do this by grabbing the 1st word
            // from the original.
            //
            // GlobalFix will prevent the segment from being discarded until
            // GlobalUnfix() happens.
            //
            ib = *(LPUINT)MAKELP(lpbPatch->wSegOrg, OFFSETOF(lpbPatch->lpCodeAlias));
            GlobalFix((HGLOBAL)lpbPatch->wSegOrg);
            SetSelectorBase(SELECTOROF(lpbPatch->lpCodeAlias), GetSelectorBase(lpbPatch->wSegOrg));
        }
    }

    if (lpbPatch->fInterruptable)
    {
        //
        // If this is for starting/stopping the patch, we have to disable
        // interrupts around the byte copying.  Or we could die if the
        // interrupt handler happens in the middle.
        //
        // We don't need to do this when disabling/enabling to call through
        // to the original, since we know that reflected interrupts aren't
        // nested, and the interrupt will complete before we come back to 
        // the interrupted normal app code.
        //
        if (!(flags & ENABLE_FORCALL))
        {
            _asm cli
        }
    }

    SAFE_ASSERT(GetSelectorBase(SELECTOROF(lpbPatch->lpCodeAlias)) == GetSelectorBase(lpbPatch->wSegOrg));

    if (lpbPatch->f32Bit)
    {
        cbPatch = CB_PATCHBYTES32;
    }
    else
    {
        cbPatch = CB_PATCHBYTES16;
    }

    if (flags & ENABLE_ON)
    {
        SAFE_ASSERT(lpbPatch->fActive);
        SAFE_ASSERT(!lpbPatch->fEnabled);

        if (!lpbPatch->fEnabled)
        {
            //
            // Save the function's original first N bytes, and copy the jump far16
            // patch in.
            //
            for (ib = 0; ib < cbPatch; ib++)
            {
                lpbPatch->rgbOrg[ib]        = lpbPatch->lpCodeAlias[ib];
                lpbPatch->lpCodeAlias[ib]   = lpbPatch->rgbPatch[ib];
            }

            lpbPatch->fEnabled = TRUE;
        }
    }
    else
    {
        SAFE_ASSERT(lpbPatch->fActive);
        SAFE_ASSERT(lpbPatch->fEnabled);

        if (lpbPatch->fEnabled)
        {
            //
            // Put back the function's original first N bytes
            //
            for (ib = 0; ib < cbPatch; ib++)
            {
                lpbPatch->lpCodeAlias[ib] = lpbPatch->rgbOrg[ib];
            }

            lpbPatch->fEnabled = FALSE;
        }
    }

    SAFE_ASSERT(GetSelectorBase(SELECTOROF(lpbPatch->lpCodeAlias)) == GetSelectorBase(lpbPatch->wSegOrg));

    if (lpbPatch->fInterruptable)
    {
        //
        // Reenable interrupts
        //
        if (!(flags & ENABLE_FORCALL))
        {
            _asm sti
        }

    }

    //
    // If really stopping, unfix AFTER the bytes have been copied.  This will
    // bump down a lock count, so when all patches are disabled, the original
    // code segment will be able to move.
    //
    if ((flags & ENABLE_MASK) == ENABLE_OFF)
    {
        //
        // WE KNOW THIS CODE DOESN'T EXECUTE AT INTERRUPT TIME.
        //

        ASSERT(!lpbPatch->fEnabled);
        ASSERT(lpbPatch->fActive);

        if (lpbPatch->fActive)
        {
            lpbPatch->fActive = FALSE;
            GlobalUnfix((HGLOBAL)lpbPatch->wSegOrg);
        }
    }
}


//
// LIST MANIPULATION ROUTINES
//

//
// COM_BasedListInsertBefore(...)
//
// See com.h for description.
//
void COM_BasedListInsertBefore(PBASEDLIST pExisting, PBASEDLIST pNew)
{
    PBASEDLIST  pTemp;

    DebugEntry(COM_BasedListInsertBefore);

    //
    // Check for bad parameters.
    //
    ASSERT((pNew != NULL));
    ASSERT((pExisting != NULL));

    //
    // Find the item before pExisting:
    //
    pTemp = COM_BasedPrevListField(pExisting);
    ASSERT((pTemp != NULL));

    TRACE_OUT(("Inserting item at %#lx into list between %#lx and %#lx",
                 pNew, pTemp, pExisting));

    //
    // Set its <next> field to point to the new item
    //
    pTemp->next = PTRBASE_TO_OFFSET(pNew, pTemp);
    pNew->prev  = PTRBASE_TO_OFFSET(pTemp, pNew);

    //
    // Set <prev> field of pExisting to point to new item:
    //
    pExisting->prev = PTRBASE_TO_OFFSET(pNew, pExisting);
    pNew->next      = PTRBASE_TO_OFFSET(pExisting, pNew);

    DebugExitVOID(COM_BasedListInsertBefore);
} // COM_BasedListInsertBefore


//
// COM_BasedListInsertAfter(...)
//
// See com.h for description.
//
void COM_BasedListInsertAfter(PBASEDLIST pExisting, PBASEDLIST pNew)
{
    PBASEDLIST  pTemp;

    DebugEntry(COM_BasedListInsertAfter);

    //
    // Check for bad parameters.
    //
    ASSERT((pNew != NULL));
    ASSERT((pExisting != NULL));

    //
    // Find the item after pExisting:
    //
    pTemp = COM_BasedNextListField(pExisting);
    ASSERT((pTemp != NULL));

    TRACE_OUT(("Inserting item at %#lx into list between %#lx and %#lx",
                 pNew, pExisting, pTemp));

    //
    // Set its <prev> field to point to the new item
    //
    pTemp->prev = PTRBASE_TO_OFFSET(pNew, pTemp);
    pNew->next  = PTRBASE_TO_OFFSET(pTemp, pNew);

    //
    // Set <next> field of pExisting to point to new item:
    //
    pExisting->next = PTRBASE_TO_OFFSET(pNew, pExisting);
    pNew->prev      = PTRBASE_TO_OFFSET(pExisting, pNew);

    DebugExitVOID(COM_BasedListInsertAfter);
} // COM_BasedListInsertAfter


//
// COM_BasedListRemove(...)
//
// See com.h for description.
//
void COM_BasedListRemove(PBASEDLIST pListItem)
{
    PBASEDLIST pNext     = NULL;
    PBASEDLIST pPrev     = NULL;

    DebugEntry(COM_BasedListRemove);

    //
    // Check for bad parameters.
    //
    ASSERT((pListItem != NULL));

    pPrev = COM_BasedPrevListField(pListItem);
    pNext = COM_BasedNextListField(pListItem);

    ASSERT((pPrev != NULL));
    ASSERT((pNext != NULL));

    TRACE_OUT(("Removing item at %#lx from list", pListItem));

    pPrev->next = PTRBASE_TO_OFFSET(pNext, pPrev);
    pNext->prev = PTRBASE_TO_OFFSET(pPrev, pNext);

    DebugExitVOID(COM_BasedListRemove);
} // COM_BasedListRemove


//
// NOTE:
// Because this is small model 16-bit code, NULL (which is 0) gets turned
// into ds:0 when casting to void FAR*.  Therefore we use our own FAR_NULL
// define, which is 0:0.
//
void FAR * COM_BasedListNext( PBASEDLIST pHead, void FAR * pEntry, UINT nOffset )
{
     PBASEDLIST p;

     ASSERT(pHead != NULL);
     ASSERT(pEntry != NULL);

     p = COM_BasedNextListField(COM_BasedStructToField(pEntry, nOffset));
     return ((p == pHead) ? FAR_NULL : COM_BasedFieldToStruct(p, nOffset));
}

void FAR * COM_BasedListPrev ( PBASEDLIST pHead, void FAR * pEntry, UINT nOffset )
{
     PBASEDLIST p;

     ASSERT(pHead != NULL);
     ASSERT(pEntry != NULL);

     p = COM_BasedPrevListField(COM_BasedStructToField(pEntry, nOffset));
     return ((p == pHead) ? FAR_NULL : COM_BasedFieldToStruct(p, nOffset));
}


void FAR * COM_BasedListFirst ( PBASEDLIST pHead, UINT nOffset )
{
    return (COM_BasedListIsEmpty(pHead) ?
            FAR_NULL :
            COM_BasedFieldToStruct(COM_BasedNextListField(pHead), nOffset));
}

void FAR * COM_BasedListLast ( PBASEDLIST pHead, UINT nOffset )
{
    return (COM_BasedListIsEmpty(pHead) ?
            FAR_NULL :
            COM_BasedFieldToStruct(COM_BasedPrevListField(pHead), nOffset));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\as16\globals.h ===
//
// GLOBALS.H
// Global Variable Decls
//
// Copyright(c) Microsoft 1997-
//


//
// Debug stuff
//
#ifdef DEBUG
DC_DATA_VAL ( char,         g_szAssertionFailure[], "Assertion failure!" );
DC_DATA_VAL ( char,         g_szNewline[], "\n" );
DC_DATA_ARRAY ( char,       g_szDbgBuf, CCH_DEBUG_MAX );
DC_DATA     ( UINT,         g_dbgRet );
DC_DATA     ( UINT,         g_trcConfig );
#endif // DEBUG


//
// DLL/Driver stuff
//
DC_DATA     ( HINSTANCE,    g_hInstAs16 );
DC_DATA     ( UINT,         g_cProcesses );
DC_DATA     ( HTASK,        g_hCoreTask );

DC_DATA     ( HINSTANCE,    g_hInstKrnl16 );
DC_DATA     ( HMODULE,      g_hModKrnl16 );
DC_DATA     ( DWORD,        g_hInstKrnl32 );
DC_DATA     ( HINSTANCE,    g_hInstKrnl32MappedTo16 );
DC_DATA     ( ANSITOUNIPROC,    g_lpfnAnsiToUni );

DC_DATA     ( HINSTANCE,    g_hInstGdi16 );
DC_DATA     ( HMODULE,      g_hModGdi16 );
DC_DATA     ( DWORD,        g_hInstGdi32 );
DC_DATA     ( REALPATBLTPROC,   g_lpfnRealPatBlt );
DC_DATA     ( EXTTEXTOUTWPROC,  g_lpfnExtTextOutW );
DC_DATA     ( TEXTOUTWPROC,     g_lpfnTextOutW );
DC_DATA     ( POLYLINETOPROC,   g_lpfnPolylineTo );
DC_DATA     ( POLYPOLYLINEPROC, g_lpfnPolyPolyline );

DC_DATA     ( HINSTANCE,    g_hInstUser16 );
DC_DATA     ( HMODULE,      g_hModUser16 );
DC_DATA     ( DWORD,        g_hInstUser32 );
DC_DATA     ( GETWINDOWTHREADPROCESSIDPROC,  g_lpfnGetWindowThreadProcessId );

DC_DATA     ( HDC,          g_osiScreenDC );
DC_DATA     ( HDC,          g_osiMemoryDC );
DC_DATA     ( HBITMAP,      g_osiMemoryBMP );
DC_DATA     ( HBITMAP,      g_osiMemoryOld );
DC_DATA     ( RECT,         g_osiScreenRect );
DC_DATA     ( UINT,         g_osiScreenBitsPlane );
DC_DATA     ( UINT,         g_osiScreenPlanes );
DC_DATA     ( UINT,         g_osiScreenBPP );
DC_DATA     ( DWORD,        g_osiScreenRedMask );
DC_DATA     ( DWORD,        g_osiScreenGreenMask );
DC_DATA     ( DWORD,        g_osiScreenBlueMask );

DC_DATA     ( BITMAPINFO_ours,  g_osiScreenBMI );
DC_DATA     ( HWND,         g_osiDesktopWindow );


//
// Shared Memory
//
DC_DATA     ( LPSHM_SHARED_MEMORY,  g_asSharedMemory );
DC_DATA_ARRAY ( LPOA_SHARED_DATA,   g_poaData,  2 );


//
// Window/Task tracking
//
DC_DATA ( HWND,             g_asMainWindow );
DC_DATA ( ATOM,             g_asHostProp );
DC_DATA ( HHOOK,            g_hetTrackHook );
DC_DATA ( HHOOK,            g_hetEventHook );
DC_DATA ( BOOL,             g_hetDDDesktopIsShared );


//
// Cursor Manager
//
DC_DATA ( LPCURSORSHAPE,    g_cmMungedCursor );     // Holds <= color cursor bits
DC_DATA ( LPBYTE,           g_cmXformMono );        // 2x height, mono
DC_DATA ( LPBYTE,           g_cmXformColor );       // 2x height, color
DC_DATA ( BOOL,             g_cmXformOn );
DC_DATA ( BOOL,             g_cmCursorHidden );
DC_DATA ( DWORD,            g_cmNextCursorStamp );
DC_DATA ( UINT,             g_cxCursor );
DC_DATA ( UINT,             g_cyCursor );
DC_DATA ( UINT,             g_cmMonoByteSize );
DC_DATA ( UINT,             g_cmColorByteSize );
DC_DATA ( SETCURSORPROC,    g_lpfnSetCursor );
DC_DATA ( FN_PATCH,         g_cmSetCursorPatch );

extern PALETTEENTRY CODESEG g_osiVgaPalette[16];



//
// Order Accumulator
//

DC_DATA ( UINT,         g_oaFlow );
DC_DATA_VAL ( BOOL,     g_oaPurgeAllowed,            TRUE);



//
// Order Encoder
//
DC_DATA ( BOOL,             g_oeViewers );

DC_DATA ( UINT,             g_oeEnterCount );

DC_DATA ( BOOL,             g_oeSendOrders );

DC_DATA ( BOOL,             g_oeTextEnabled );
DC_DATA_ARRAY ( BYTE,       g_oeOrderSupported,   ORD_NUM_INTERNAL_ORDERS );

DC_DATA ( HPALETTE,         g_oeStockPalette );

DC_DATA ( TSHR_RECT32,      g_oeLastETORect );

//
// Only valid within a single DDI call, saves stack space to use globals
// NOTE:
// We need at most 2 pointers to DCs, the source and dest.  So we have
// two allocated selectors.
//
DC_DATA ( OESTATE,          g_oeState );
DC_DATA ( UINT,             g_oeSelDst );
DC_DATA ( UINT,             g_oeSelSrc );

DC_DATA ( HWND,             g_oeLastWindow );
DC_DATA ( BOOL,             g_oeLastWindowShared );

DC_DATA ( BOOL,             g_oeBaselineTextEnabled );
DC_DATA ( UINT,             g_oeFontCaps );


//
// Local font matching data - this is passed from the share core
// NOTE:  it's so large that we allocate it in 16-bit code
//
DC_DATA ( LPLOCALFONT,      g_poeLocalFonts );
DC_DATA_ARRAY( WORD,        g_oeLocalFontIndex, FH_LOCAL_INDEX_SIZE );
DC_DATA ( UINT,             g_oeNumFonts );

DC_DATA ( FH_CACHE,         g_oeFhLast );
DC_DATA_ARRAY ( char,       g_oeAnsiString, ORD_MAX_STRING_LEN_WITHOUT_DELTAS+1 );
DC_DATA_ARRAY ( WCHAR,      g_oeTempString, ORD_MAX_STRING_LEN_WITHOUT_DELTAS+1 );


DC_DATA_ARRAY ( FN_PATCH,   g_oeDDPatches, DDI_MAX );

DC_DATA ( FN_PATCH,         g_oeDisplaySettingsPatch );
DC_DATA ( FN_PATCH,         g_oeDisplaySettingsExPatch );
DC_DATA ( CDSEXPROC,        g_lpfnCDSEx );


//
// Bounds Accumulation
//

DC_DATA ( UINT,             g_baFirstRect );
DC_DATA ( UINT,             g_baLastRect );
DC_DATA ( UINT,             g_baRectsUsed );

DC_DATA_ARRAY ( DD_BOUNDS,  g_baBounds,   BA_NUM_RECTS+1);

//
// A local copy of the bounding rectangles which the share core is
// currently processing.  These are used when accumulating orders which
// rely on the contents of the destination.
//
DC_DATA         ( UINT,    g_baNumSpoilingRects);
DC_DATA_ARRAY   ( RECT,    g_baSpoilingRects,    BA_NUM_RECTS);

//
// Is the spoiling of existing orders when adding screen data allowed at
// the moment, or temporarily disabled ?  To do the spoiling, both
// baSpoilByNewSDA and baSpoilByNewSDAEnabled must be TRUE.
//
DC_DATA_VAL ( BOOL,         g_baSpoilByNewSDAEnabled,     TRUE);



//
// Save Screenbits Interceptor
//

//
// Remote status for SSB
//
DC_DATA ( REMOTE_SSB_STATE,  g_ssiRemoteSSBState );

//
// Local status for SSB
//
DC_DATA ( LOCAL_SSB_STATE,  g_ssiLocalSSBState );

//
// Current max for save screen bitmap size
//
DC_DATA ( DWORD,            g_ssiSaveBitmapSize );

DC_DATA ( SAVEBITSPROC,     g_lpfnSaveBits );

DC_DATA ( FN_PATCH,         g_ssiSaveBitsPatch );

DC_DATA ( HBITMAP,          g_ssiLastSpbBitmap );



//
// IM stuff
//

//
// NOTE:
// Since we smart pagelock our data segment anyway, we don't need to
// put g_imSharedData into a separate block of memory.
//
DC_DATA ( IM_SHARED_DATA,   g_imSharedData );
DC_DATA ( IM_WIN95_DATA,    g_imWin95Data );
DC_DATA_ARRAY ( FN_PATCH,   g_imPatches, IM_MAX );
DC_DATA ( int,              g_imMouseDowns );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\as16\het.c ===
//
// HET.C
// Hosted Entity Tracker
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>


//
// OSI and HET apis are the equivalent of the NT HOOK functionality.
// HET_DD apis      are the equivalent of the NT display driver apis.
//

/////
//
// HOOK functionality
//
/////



BOOL WINAPI OSIIsWindowScreenSaver16(HWND hwnd)
{
    BOOL    fScreenSaver;

    DebugEntry(OSIIsWindowScreenSaver16);

    //
    // If there is no screen saver active, this window can't be one.
    //
    fScreenSaver = FALSE;
    SystemParametersInfo(SPI_GETSCREENSAVEACTIVE, 0, &fScreenSaver, 0);
    if (fScreenSaver)
    {
        char    szClassName[64];

        //
        // Is the class name WindowsScreenSaverClass?  This is what all
        // screen savers using the Win95 toolkit use.  BOGUS BUGBUG
        // EXCEPT FOR THE IE4 CHANNEL SCREEN SAVER.
        //
        if (!GetClassName(hwnd, szClassName, sizeof(szClassName)) ||
            lstrcmp(szClassName, HET_SCREEN_SAVER_CLASS))
        {
            fScreenSaver = FALSE;
        }
    }

    DebugExitBOOL(OSIIsWindowScreenSaver16, fScreenSaver);
    return(fScreenSaver);
}


//
// OSIStartWindowTracking16()
//
// This installs our global call window proc hook then watches windows
// being created, destroyed, shown, hidden and looks for relationships via
// process or related process info to the currently shared windows.
//
BOOL WINAPI OSIStartWindowTracking16(void)
{
    BOOL    rc = FALSE;

    DebugEntry(OSIStartWindowTracking16);

    ASSERT(!g_hetTrackHook);

    //
    // Install window/task tracking hook
    //
    g_hetTrackHook = SetWindowsHookEx(WH_CALLWNDPROC, HETTrackProc, g_hInstAs16, NULL);
    if (!g_hetTrackHook)
    {
        ERROR_OUT(("Can't install WH_CALLWNDPROC hook"));
        DC_QUIT;
    }

    //
    // Install event hook
    //
    g_hetEventHook = SetWindowsHookEx(WH_CBT, HETEventProc, g_hInstAs16, NULL);
    if (!g_hetEventHook)
    {
        ERROR_OUT(("Can't install WH_CBT hook"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(OSIStartWindowTracking16, rc);
    return(rc);
}


//
// OSIStopWindowTracking16()
//
void WINAPI OSIStopWindowTracking16(void)
{
    DebugEntry(OSIStopWindowTracking16);

    //
    // Remove Graphic Output hooks
    //
    HETDDViewing(FALSE);

    //
    // Remove event hook
    //
    if (g_hetEventHook)
    {
        UnhookWindowsHookEx(g_hetEventHook);
        g_hetEventHook = NULL;
    }

    //
    // Remove window/task tracking hook
    //
    if (g_hetTrackHook)
    {
        UnhookWindowsHookEx(g_hetTrackHook);
        g_hetTrackHook = NULL;
    }

    DebugExitVOID(OSIStopWindowTracking16);
}



//
// HETEventProc()
// This is a global CBT hook that prevents the screensaver from kicking
// in when sharing.
//
LRESULT CALLBACK HETEventProc
(
    int     nCode,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    LRESULT lResult;

    DebugEntry(HETEventProc);

    if ((nCode == HCBT_SYSCOMMAND) && (wParam == SC_SCREENSAVE))
    {
        // Prevent the screen saver from starting.  NONZERO means disallow.
        WARNING_OUT(("Preventing screensaver from starting, we're currently sharing"));
        lResult = TRUE;
    }
    else
    {
        lResult = CallNextHookEx(g_hetEventHook, nCode, wParam, lParam);
    }

    DebugExitDWORD(HETEventProc, lResult);
    return(lResult);
}



//
// HETTrackProc()
//
// This is the global hook that watches for windows coming & going, 
// showing & hiding to see if new ones related to shared ones should also
// be shared.  This covers related processes as well as related windows.
//
LRESULT CALLBACK HETTrackProc
(
    int     nCode,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    LPCWPSTRUCT lpCwp;
    LPWINDOWPOS lpPos;
    LRESULT lResult;

    DebugEntry(HETTrackProc);

    //
    // wParam is a BOOL, TRUE if this is interthread
    // lParam is a pointer to a CWPSTRUCT
    //
    lpCwp = (LPCWPSTRUCT)lParam;
    ASSERT(!IsBadReadPtr(lpCwp, sizeof(*lpCwp)));

    //
    // We better be tracking still
    //
    ASSERT(g_hetTrackHook);

    //
    // Skip calls that happen in CONF itself.  This is our implementation
    // of the SKIP_OWNPROCESS WinEvent option in NT's hook dll
    //
    if (GetCurrentTask() != g_hCoreTask)
    {
        switch (lpCwp->message)
        {
            case WM_NCCREATE:
                HETHandleCreate(lpCwp->hwnd);
                break;

            case WM_NCDESTROY:
                HETHandleDestroy(lpCwp->hwnd);
                break;

            case WM_NCPAINT:
                //
                // This will catch being shown before WINDOWPOSCHANGED does.
                // We still keep that for a catch all.
                //
                if (IsWindowVisible(lpCwp->hwnd))
                {
                    HETHandleShow(lpCwp->hwnd, FALSE);
                }
                break;

            case WM_WINDOWPOSCHANGED:
                lpPos = (LPWINDOWPOS)lpCwp->lParam;
                ASSERT(!IsBadReadPtr(lpPos, sizeof(WINDOWPOS)));

                if (!(lpPos->flags & SWP_NOMOVE))
                    HETCheckParentChange(lpCwp->hwnd);

                if (lpPos->flags & SWP_SHOWWINDOW)
                    HETHandleShow(lpCwp->hwnd, TRUE);
                else if (lpPos->flags & SWP_HIDEWINDOW)
                    HETHandleHide(lpCwp->hwnd);
                break;
            }
    }

    lResult = CallNextHookEx(g_hetTrackHook, nCode, wParam, lParam);

    DebugExitDWORD(HETTrackProc, lResult);
    return(lResult);
}



//
// HETHandleCreate()
//
void HETHandleCreate(HWND hwnd)
{
    HET_TRACK_INFO  hti;
    UINT            hostType;

    DebugEntry(HETHandleCreate);

    //
    // Ignore child windows
    //
    if (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        if (GetParent(hwnd) != g_osiDesktopWindow)
        {
            TRACE_OUT(("Skipping child window %04x create", hwnd));
            DC_QUIT;
        }
    }

    hti.idThread = g_lpfnGetWindowThreadProcessId(hwnd, &hti.idProcess);

    //
    // Ignore special shell threads
    //
    if (HET_IsShellThread(hti.idThread))
    {
        TRACE_OUT(("Skipping shell thread window %04x create", hwnd));
        DC_QUIT;
    }

    //
    // We don't need to ignore menus.  Only when first shared do we skip
    // menus.  The cached one we never want to share.  The others will
    // go away almost immediately.  From now on, we treat them the same
    // as other windows.
    //

    //
    // Figure out what to do.
    //
    hti.hwndUs = hwnd;
    hti.cWndsApp = 0;
    hti.cWndsSharedThread = 0;
    hti.cWndsSharedProcess = 0;

UpOneLevel:
    EnumWindows(HETShareEnum, (LPARAM)(LPHET_TRACK_INFO)&hti);

    if (hti.cWndsSharedThread)
    {
        TRACE_OUT(("New window %04x in shared thread %08lx",
                hwnd, hti.idThread));
        hostType = HET_HOSTED_PERMANENT | HET_HOSTED_BYTHREAD;
    }
    else if (hti.cWndsSharedProcess)
    {
        TRACE_OUT(("New window %04x in shared process %08lx",
                hwnd, hti.idProcess));
        hostType = HET_HOSTED_PERMANENT | HET_HOSTED_BYPROCESS;
    }
    else if (hti.cWndsApp)
    {
        //
        // There's another window in our app, but none are shared.  So don't
        // share us either.
        //
        TRACE_OUT(("New window %04x in unshared process %08lx",
                hwnd, hti.idProcess));
        DC_QUIT;
    }
    else
    {
        DWORD   idParentProcess;

        // Loop through our ancestor processes (no thread info at this point)
        HETGetParentProcessID(hti.idProcess, &idParentProcess);

        if (!idParentProcess)
        {
            TRACE_OUT(("Can't get parent of process %08lx", hti.idProcess));
            DC_QUIT;
        }

        //
        // We know if we got here that all our favorite fields are still
        // zero.  So just loop!  But NULL out idThread to avoid matching
        // anything while we look at our parent.
        //
        TRACE_OUT(("First window %04x in process %08lx, checking parent %08lx",
                hwnd, hti.idProcess, idParentProcess));

        hti.idThread    = 0;
        hti.idProcess   = idParentProcess;
        goto UpOneLevel;
    }

    //
    // OK, we are going to share this.  No need to repaint, all our
    // notifications are synchronous.
    //
    OSIShareWindow16(hwnd, hostType, FALSE, TRUE);

DC_EXIT_POINT:
    DebugExitVOID(HETHandleCreate);
}



//
// HETHandleDestroy()
// Handles the destruction of a window
//
void HETHandleDestroy(HWND hwnd)
{
    DebugEntry(HETHandleDestroy);

    //
    // Blow away our cache.  Our cache holds the last window
    // drawing happened for, whether it was shared or not,
    // to let us more quickly decide whether we care.
    //
    OSIUnshareWindow16(hwnd, TRUE);

    if (hwnd == g_oeLastWindow)
    {
        TRACE_OUT(("Tossing oe cached window %04x", g_oeLastWindow));
        g_oeLastWindow = NULL;
    }

    DebugExitVOID(HETHandleDestroy);
}



//
// HETHandleShow()
//
void HETHandleShow
(
    HWND    hwnd,
    BOOL    fForceRepaint
)
{
    UINT    hostType;
    HET_TRACK_INFO  hti;

    DebugEntry(HETHandleShow);

    hostType = HET_GetHosting(hwnd);

    //
    // If this window is a real child, clear the hosting property. Usually
    // one isn't there.  But in the case of a top level window becoming
    // a child of another, we want to wipe out junk.
    //
    if (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        if (GetParent(hwnd) != g_osiDesktopWindow)
        {
            TRACE_OUT(("Skipping child window 0x%04x show", hwnd));
            if (hostType)
            {
                WARNING_OUT(("Unsharing shared child window 0x%04 from SHOW", hwnd));
                OSIUnshareWindow16(hwnd, TRUE);
            }
            DC_QUIT;
        }   
    }

    //
    // Is this guy already shared?  Nothing to do if so.  Unlike NT,
    // we don't get async notifications.
    //
    if (hostType)
    {
        TRACE_OUT(("Window %04x already shared, ignoring show", hwnd));
        DC_QUIT;
    }


    //
    // Here's where we also enumerate the top level windows and find a
    // match.  But we DO not track across processes in this case.  Instead
    // we look at the owner if there is one.
    //
    // This solves the create-as-a-child then change to a top level
    // window problem, like combo dropdowns.
    //

    hti.idThread = g_lpfnGetWindowThreadProcessId(hwnd, &hti.idProcess);

    //
    // Ignore special shell threads
    //
    if (HET_IsShellThread(hti.idThread))
    {
        TRACE_OUT(("Skipping shell thread window 0x%04x show", hwnd));
        DC_QUIT;
    }

    hti.hwndUs = hwnd;
    hti.cWndsApp = 0;
    hti.cWndsSharedThread = 0;
    hti.cWndsSharedProcess = 0;

    EnumWindows(HETShareEnum, (LPARAM)(LPHET_TRACK_INFO)&hti);

    //
    // These kinds of windows are always only temp shared.  They don't
    // start out as top level windows that we saw from the beginning or
    // watched created.  These are SetParent() or menu kinds of dudes, so
    // for a lot of reasons we're plain safer sharing these babies only
    // temporarily
    //

    //
    // Anything else shared on this thread/process, the decision is easy.
    // Otherwise, we look at the ownership trail.
    //
    if (!hti.cWndsSharedThread && !hti.cWndsSharedProcess)
    {
        HWND    hwndOwner;

        //
        // Does it have an owner that is shared?
        //
        hwndOwner = hwnd;
        while (hwndOwner = GetWindow(hwndOwner, GW_OWNER))
        {
            if (HET_GetHosting(hwndOwner))
            {
                TRACE_OUT(("Found shared owner %04x of window %04x", hwndOwner, hwnd));
                break;
            }
        }

        if (!hwndOwner)
        {
            DC_QUIT;
        }
    }

    //
    // We maybe getting this too late, like in the case of a menu coming up,
    // and it may have already painted/erased.  So invalidate this baby.
    // That's what the fForceRepaint parameter is for.  That is only true
    // when coming from WM_WINDOWPOSCHANGED after an explicit WM_SHOWWINDOW
    // call.  Most of the time, we catch WM_NCPAINT though, for show.
    //
    TRACE_OUT(("Sharing temporary window %04x", hwnd));

    OSIShareWindow16(hwnd, HET_HOSTED_BYWINDOW | HET_HOSTED_TEMPORARY,
        fForceRepaint, TRUE);

DC_EXIT_POINT:
    DebugExitVOID(HETHandleShow);
}



//
// HETHandleHide()
//
void HETHandleHide(HWND hwnd)
{
    UINT    hostType;

    DebugEntry(HETHandleHide);

    hostType = HET_GetHosting(hwnd);

    if (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        if (GetParent(hwnd) != GetDesktopWindow())
        {
            TRACE_OUT(("Skipping child window %04x hide", hwnd));
            if (hostType)
            {
                WARNING_OUT(("Unsharing shared child window 0x%04 from HIDE", hwnd));
                OSIUnshareWindow16(hwnd, TRUE);
            }

            DC_QUIT;
        }
    }

    if (!hostType)
    {
        //
        // Unlike NT, we don't get hide notifications out of context, so 
        // we don't need to recount the top level guys.
        //
        TRACE_OUT(("Window %04x not shared, ignoring hide", hwnd));
    }
    else if (hostType & HET_HOSTED_TEMPORARY)
    {
        TRACE_OUT(("Unsharing temporary window %04x", hwnd));
        OSIUnshareWindow16(hwnd, TRUE);
    }
    else
    {
        ASSERT(hostType & HET_HOSTED_PERMANENT);

        // Nothing to do
        TRACE_OUT(("Window %04x permanently shared, ignoring hide", hwnd));
    }

DC_EXIT_POINT:
    DebugExitVOID(HETHandleHide);
}



//
// HETCheckParentChange()
//
// On a windowposchange with MOVE, we make sure that no child window has the
// hosting property.  When a window's parent changes, it is always moved,
// so that's the best way I have to check for it.  Since we only look at
// top level windows, converted-to-children windows will stay shared forever
// and won't show up in the share menu.
//
// This is NOT perfect.  If the child is not moving to a different position
// relative to the two parents, we won't see anything.  But for the case
// where one is switching to/from top level, its very likely we will come
// through here.  More likely than checking for hide/show.
// 
void HETCheckParentChange(HWND hwnd)
{
    DebugEntry(HETCheckParentChange);

    if (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        if (GetParent(hwnd) != GetDesktopWindow())
        {
            UINT    hostType;

            hostType = HET_GetHosting(hwnd);
            if (hostType)
            {
                WARNING_OUT(("Unsharing shared child window 0x%04x from MOVE", hwnd));
                OSIUnshareWindow16(hwnd, TRUE);
            }
        }
    }

    DebugExitVOID(HETCheckParentChange);
}


//
//  HETShareEnum()
//
//  This is the EnumWindows() callback.  We stop when we find the first
//  matching shared window (thread or process).  We keep a running tally
//  of the count of all top level windows in our process (not shared by
//  thread or process) at the same time.  This lets us do tracking.
//
BOOL CALLBACK HETShareEnum(HWND hwnd, LPARAM lParam)
{
    LPHET_TRACK_INFO    lphti = (LPHET_TRACK_INFO)lParam;
    DWORD               idProcess;
    DWORD               idThread;
    UINT                hostType;
    BOOL                rc = TRUE;

    DebugEntry(HETShareEnum);

    // Skip ourself.
    if (hwnd == lphti->hwndUs)
    {
        DC_QUIT;
    }

    // Skip if window is gone.
    idThread = g_lpfnGetWindowThreadProcessId(hwnd, &idProcess);
    if (!idThread)
    {
        DC_QUIT;
    }

    //
    // Do the processes match?  If not, easy amscray
    //
    if (idProcess != lphti->idProcess)
    {
        DC_QUIT;
    }
    lphti->cWndsApp++;

    hostType = HET_GetHosting(hwnd);
    if (!hostType)
    {
        DC_QUIT;
    }

    //
    // Now, if this window is shared by thread or process, do the right
    // thing.
    //
    if (hostType & HET_HOSTED_BYPROCESS)
    {
        // We have a match.  We can return immediately.
        lphti->cWndsSharedProcess++;
        rc = FALSE;
    }
    else if (hostType & HET_HOSTED_BYTHREAD)
    {
        //
        // For WOW apps, we don't want this one, if in a separate thread, to
        // count.  No matter what.
        //
        if (idThread == lphti->idThread)
        {
            lphti->cWndsSharedThread++;
            rc = FALSE;
        }
    }


DC_EXIT_POINT:
    DebugExitBOOL(HETShareEnum, rc);
    return(rc);
}




//
// HET_IsShellThread()
// Returns TRUE if thread is one of shell's special threads
//
BOOL  HET_IsShellThread(DWORD threadID)
{
    BOOL    rc;

    DebugEntry(HET_IsShellThread);

    if ((threadID == g_lpfnGetWindowThreadProcessId(HET_GetShellDesktop(), NULL)) ||
        (threadID == g_lpfnGetWindowThreadProcessId(HET_GetShellTray(), NULL)))
    {
        rc = TRUE;
    }
    else
    {
        rc = FALSE;
    }

    DebugExitBOOL(HET_IsShellThread, rc);
    return(rc);
}



//
// OSIShareWindow16()
// This shares a window.  This is called when
//      * An app is unshared
//      * A window is destroyed
//      * A temporarily shared window is hidden
//
// This returns TRUE if it shared a window
//
BOOL WINAPI OSIShareWindow16
(
    HWND    hwnd,
    UINT    hostType,
    BOOL    fRepaint,
    BOOL    fUpdateCount
)
{
    BOOL    rc = FALSE;

    DebugEntry(OSIShareWindow16);

    //
    // Set the property
    //
    if (!HET_SetHosting(hwnd, hostType))
    {
        ERROR_OUT(("Couldn't set shared property on window %04x", hwnd));
        DC_QUIT;
    }

    //
    // Toss out our cache--it could have been a child of this one.
    //
    g_oeLastWindow = NULL;

    TRACE_OUT(("Shared window %04x of type %04x", hwnd, hostType));

    //
    // Repaint it
    //
    if (fRepaint)
    {
        USR_RepaintWindow(hwnd);
    }

    if (fUpdateCount)
    {
        PostMessageNoFail(g_asMainWindow, DCS_NEWTOPLEVEL_MSG, TRUE, 0);
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(OSIShareWindow16, rc);
    return(rc);
}



//
// OSIUnshareWindow16()
// This unshares a window.  This is called when
//      * An app is unshared
//      * A window is destroyed
//      * A temporarily shared window is hidden
//
// This returns TRUE if it unshared a shared window.
//
BOOL WINAPI OSIUnshareWindow16
(
    HWND    hwnd,
    BOOL    fUpdateCount
)
{
    BOOL    rc = FALSE;
    UINT    hostType;

    DebugEntry(OSIUnshareWindow16);

    //
    // This gets the old property and clears it in one step.
    //
    hostType = HET_ClearHosting(hwnd);
    if (!hostType)
    {
        //
        // Unlike NT, all the destroy notifications we get are synchronous.
        // So we don't need to recalculate the total.
        //
        DC_QUIT;
    }

    TRACE_OUT(("Unsharing window %04x of type %04x", hwnd, hostType));

    //
    // Toss our cache--the sharing status of some window has changed.
    //
    g_oeLastWindow = NULL;

    //
    // Update the top level count
    //
    if (fUpdateCount)
    {
        PostMessageNoFail(g_asMainWindow, DCS_NEWTOPLEVEL_MSG, FALSE, 0);
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(OSI_UnshareWindow, rc);
    return(rc);
}



//
// HET_WindowIsHosted()
// Returns TRUE if a window is shared.  This is used by the IM code in its
// high level hooks.
//
BOOL HET_WindowIsHosted(HWND hwnd)
{
    BOOL    rc = FALSE;
    HWND    hwndParent;

    DebugEntry(HETHookWindowIsHosted);

    if (!hwnd)
        DC_QUIT;

    //
    // Walk up to the top level window this one is inside of
    //
    while (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        hwndParent = GetParent(hwnd);
        if (hwndParent == GetDesktopWindow())
            break;

        hwnd = hwndParent;
    }

    rc = HET_GetHosting(hwnd);

DC_EXIT_POINT:
    DebugExitBOOL(HET_WindowIsHosted, rc);
    return(rc);
}



//
// HETGetParentProcessID()
// Get parent process if this one
//
void HETGetParentProcessID
(
    DWORD       processID,
    LPDWORD     pParentProcessID
)
{
    //
    // Get the ID of the parent process
    //
    ASSERT(processID);
    *pParentProcessID = GetProcessDword(processID, GPD_PARENT);
}




/////
//
// DISPLAY DRIVER functionality
//
/////

//
// HET_DDInit()
//
BOOL HET_DDInit(void)
{
    return(TRUE);
}


//
// HET_DDTerm()
//
void HET_DDTerm(void)
{
    DebugEntry(HET_DDTerm);

    //
    // Make sure we stop hosting
    //
    g_hetDDDesktopIsShared = FALSE;
    OSIStopWindowTracking16();

    DebugExitVOID(HET_DDTerm);
}



//
// HET_DDProcessRequest()
// Handles HET escapes
//

BOOL  HET_DDProcessRequest
(
    UINT    fnEscape,
    LPOSI_ESCAPE_HEADER pResult,
    DWORD   cbResult
)
{
    BOOL    rc = TRUE;

    DebugEntry(HET_DDProcessRequest);

    switch (fnEscape)
    {
        //
        // NOTE:
        // Unlike NT, we have no need of keeping a duplicated list of
        // shared windows.  We can make window calls directly, and can use
        // GetProp to find out.
        //
        case HET_ESC_UNSHARE_ALL:
        {
            // Nothing to do
        }
        break;

        case HET_ESC_SHARE_DESKTOP:
        {
            ASSERT(!g_hetDDDesktopIsShared);
            g_hetDDDesktopIsShared = TRUE;
        }
        break;

        case HET_ESC_UNSHARE_DESKTOP:
        {
            ASSERT(g_hetDDDesktopIsShared);
            g_hetDDDesktopIsShared = FALSE;
            HETDDViewing(FALSE);
        }
        break;

        case HET_ESC_VIEWER:
        {
            HETDDViewing(((LPHET_VIEWER)pResult)->viewersPresent != 0);
            break;
        }

        default:
        {
            ERROR_OUT(("Unrecognized HET escape"));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(HET_DDProcessRequest, rc);
    return(rc);
}




//
// HETDDViewing()
//
// Called when viewing of our shared apps starts/stops.  Naturally, no longer
// sharing anything stops viewing also.
//
void HETDDViewing(BOOL fViewers)
{
    DebugEntry(HETDDViewing);

    if (g_oeViewers != fViewers)
    {
        g_oeViewers = fViewers;
        OE_DDViewing(fViewers);
    }

    DebugExitVOID(HETDDViewing);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\as16\im.c ===
//
// IM.C
// Input Manager
//
// Copyright(c) 1997-
//

#include <as16.h>



//
// IM_DDInit()
// This creates the resources we need for controlling
//
BOOL IM_DDInit(void)
{
    UINT    uSel;
    BOOL    rc = FALSE;

    DebugEntry(IM_DDInit);

    //
    // Create interrupt patches for mouse_event and keybd_event
    //
    uSel = CreateFnPatch(mouse_event, ASMMouseEvent, &g_imPatches[IM_MOUSEEVENT], 0);
    if (!uSel)
    {
        ERROR_OUT(("Couldn't find mouse_event"));
        DC_QUIT;
    }
    g_imPatches[IM_MOUSEEVENT].fInterruptable = TRUE;


    if (!CreateFnPatch(keybd_event, ASMKeyboardEvent, &g_imPatches[IM_KEYBOARDEVENT], uSel))
    {
        ERROR_OUT(("Couldn't find keybd_event"));
        DC_QUIT;
    }
    g_imPatches[IM_KEYBOARDEVENT].fInterruptable = TRUE;


    //
    // Create patch for SignalProc32 so we can find out when fault/hung
    // dialogs from KERNEL32 come up.
    //
    if (!CreateFnPatch(SignalProc32, DrvSignalProc32, &g_imPatches[IM_SIGNALPROC32], 0))
    {
        ERROR_OUT(("Couldn't patch SignalProc32"));
        DC_QUIT;
    }

    //
    // Create patches for win16lock pulsing in 16-bit app modal loops
    //
    uSel = CreateFnPatch(RealGetCursorPos, DrvGetCursorPos, &g_imPatches[IM_GETCURSORPOS], 0);
    if (!uSel)
    {
        ERROR_OUT(("Couldn't find GetCursorPos"));
        DC_QUIT;
    }

    if (!CreateFnPatch(GetAsyncKeyState, DrvGetAsyncKeyState, &g_imPatches[IM_GETASYNCKEYSTATE], 0))
    {
        ERROR_OUT(("Couldn't find GetAsyncKeyState"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(IM_DDInit, rc);
    return(rc);
}


//
// IM_DDTerm()
// This cleans up any resources we needed for controlling
//
void IM_DDTerm(void)
{
    IM_PATCH    imPatch;

    DebugEntry(IM_DDTerm);

    //
    // Force undo of hooks
    //
    OSIInstallControlledHooks16(FALSE, FALSE);

    //
    // Destroy patches
    //
    for (imPatch = IM_FIRST; imPatch < IM_MAX; imPatch++)
    {
        DestroyFnPatch(&g_imPatches[imPatch]);
    }

    DebugExitVOID(IM_DDTerm);
}



//
// OSIInstallControlledHooks16()
//
// This installs/removes the input hooks we need to allow this machine to
// be controlled.  
//
BOOL WINAPI OSIInstallControlledHooks16(BOOL fEnable, BOOL fDesktop)
{               
    BOOL        rc = TRUE;
    IM_PATCH    imPatch;

    DebugEntry(OSIInstallControlledHooks16);

    if (fEnable)
    {
        if (!g_imWin95Data.imLowLevelHooks)
        {
            g_imWin95Data.imLowLevelHooks = TRUE;

            g_imMouseDowns = 0;

            //
            // GlobalSmartPageLock() stuff we need:
            //      * Our code segment
            //      * Our data segment
            //
            GlobalSmartPageLock((HGLOBAL)SELECTOROF((LPVOID)DrvMouseEvent));
            GlobalSmartPageLock((HGLOBAL)SELECTOROF((LPVOID)&g_imSharedData));

            //
            // Install hooks
            //
            for (imPatch = IM_FIRST; imPatch < IM_MAX; imPatch++)
            {
                EnableFnPatch(&g_imPatches[imPatch], PATCH_ACTIVATE);
            }
        }

        //
        // Install high-level mouse hook
        if (!fDesktop)
        {
            if (!g_imWin95Data.imhHighLevelMouseHook)
            {
                //
                // Install the mouse hook.
                //
                g_imWin95Data.imhHighLevelMouseHook = SetWindowsHookEx(WH_MOUSE,
                    IMMouseHookProc, g_hInstAs16, 0);
            
                if (!g_imWin95Data.imhHighLevelMouseHook)
                {
                    ERROR_OUT(("Failed to install mouse hook"));
                    rc = FALSE;
                }
            }
        }
    }
    else
    {
        if (g_imWin95Data.imLowLevelHooks)
        {
            //
            // Uninstall hooks
            //
            for (imPatch = IM_MAX; imPatch > 0; imPatch--)
            {
                EnableFnPatch(&g_imPatches[imPatch-1], PATCH_DEACTIVATE);
            }

            //
            // GlobalSmartUnPageLock() stuff we needed
            //
            GlobalSmartPageUnlock((HGLOBAL)SELECTOROF((LPVOID)&g_imSharedData));
            GlobalSmartPageUnlock((HGLOBAL)SELECTOROF((LPVOID)DrvMouseEvent));

            g_imWin95Data.imLowLevelHooks = FALSE;
        }

        if (!fDesktop)
        {
            if (g_imWin95Data.imhHighLevelMouseHook)
            {
                //
                // Remove the mouse hook.
                //
                UnhookWindowsHookEx(g_imWin95Data.imhHighLevelMouseHook);
                g_imWin95Data.imhHighLevelMouseHook = NULL;
            }
        }
    }

    DebugExitBOOL(OSIInstallControlledHooks16, rc);
    return(rc);
}



#pragma optimize("gle", off)
void IMInject(BOOL fOn)
{
    if (fOn)
    {
#ifdef DEBUG
        DWORD   tmp;

        //
        // Disable interrupts then turn injection global on
        // But before we do this, we must make sure that we aren't going
        // to have to fault in a new stack page.  Since this is on a 32-bit
        // thread, we will be in trouble.
        //
        tmp = GetSelectorBase(SELECTOROF(((LPVOID)&fOn))) +
            OFFSETOF((LPVOID)&fOn);
        if ((tmp & 0xFFFFF000) != ((tmp - 0x100) & 0xFFFFF000))
        {
            ERROR_OUT(("Close to page boundary on 32-bit stack %08lx", tmp));
        }
#endif // DEBUG

        _asm    cli
        g_imWin95Data.imInjecting = TRUE;
    }
    else
    {
        //
        // Turn injection global off then enable interrupts
        //
        g_imWin95Data.imInjecting = FALSE;
        _asm    sti
    }
}
#pragma optimize("", on)


//
// OSIInjectMouseEvent16()
//
void WINAPI OSIInjectMouseEvent16
(
    UINT    flags,
    int     x,
    int     y,
    UINT    mouseData,
    DWORD   dwExtraInfo
)
{
    DebugEntry(OSIInjectMouseEvent16);

    if (flags & IM_MOUSEEVENTF_BUTTONDOWN_FLAGS)
    {
        ++g_imMouseDowns;
    }

    //
    // We disable interrupts, call the real mouse_event, reenable
    // interrupts.  That way our mouse_event patch is serialized.
    // And we can check imInjecting.
    //
    IMInject(TRUE);
    CallMouseEvent(flags, x, y, mouseData, LOWORD(dwExtraInfo), HIWORD(dwExtraInfo));
    IMInject(FALSE);

    if (flags & IM_MOUSEEVENTF_BUTTONUP_FLAGS)
    {
        --g_imMouseDowns;
        ASSERT(g_imMouseDowns >= 0);
    }

    DebugExitVOID(OSIInjectMouseEvent16);
}



//
// OSIInjectKeyboardEvent16()
//
void WINAPI OSIInjectKeyboardEvent16
(
    UINT    flags,
    WORD    vkCode,
    WORD    scanCode,
    DWORD   dwExtraInfo
)
{
    DebugEntry(OSIInjectKeyboardEvent16);

    //
    // First, fix up the flags
    //
    if (flags & KEYEVENTF_KEYUP)
    {
        // Put 0x80 in the HIBYTE of vkCode, this means a keyup
        vkCode = (WORD)(BYTE)vkCode | USERKEYEVENTF_KEYUP;
    }

    if (flags & KEYEVENTF_EXTENDEDKEY)
    {                         
        // Put 0x01 in the HIBYTE of scanCode, this means extended
        scanCode = (WORD)(BYTE)scanCode | USERKEYEVENTF_EXTENDEDKEY;
    }

    //
    // We disable interrupts, call the real keybd_event, reenable
    // interrupts.  That way our keybd_event patch is serialized.
    // And we can check the imfInject variable.
    //
    IMInject(TRUE);
    CallKeyboardEvent(vkCode, scanCode, LOWORD(dwExtraInfo), HIWORD(dwExtraInfo));
    IMInject(FALSE);

    DebugExitVOID(OSIInjectKeyboardEvent16);
}



//
// Win16lock pulse points when injecting mouse down/up sequences into 16-bit
// modal loop apps.
//


//
// IMCheckWin16LockPulse()
// This pulses the win16lock if we are in the middle of injecting a mouse
// down-up sequence to a 16-bit app shared on this machine.  We do this to
// prevent deadlock, caused by 16-bit dudes going into modal loops, not
// releasing the win16lock.  Our 32-bit thread would get stuck on the win16
// lock trying to play back the rest of the sequence.
//
void IMCheckWin16LockPulse(void)
{
    DebugEntry(IMCheckWin16LockPulse);

    if ((g_imMouseDowns > 0) &&
        (GetProcessDword(0, GPD_FLAGS) & GPF_WIN16_PROCESS))
    {
        TRACE_OUT(("Pulsing win16lock for 16-bit app; mouse down count %d", g_imMouseDowns));

        _LeaveWin16Lock();
        _EnterWin16Lock();

        TRACE_OUT(("Pulsed win16lock for 16-bit app; mouse down count %d", g_imMouseDowns));
    }

    DebugExitVOID(IMCheckWin16LockPulse);
}



int WINAPI DrvGetAsyncKeyState(int vk)
{
    int     retVal;

    DebugEntry(DrvGetAsyncKeyState);

    // Pulse BEFORE we call to USER
    IMCheckWin16LockPulse();

    EnableFnPatch(&g_imPatches[IM_GETASYNCKEYSTATE], PATCH_DISABLE);
    retVal = GetAsyncKeyState(vk);
    EnableFnPatch(&g_imPatches[IM_GETASYNCKEYSTATE], PATCH_ENABLE);

    DebugExitBOOL(DrvGetAsyncKeyState, retVal);
    return(retVal);
}



//
// DrvGetCursorPos()
//
BOOL WINAPI DrvGetCursorPos(LPPOINT lppt)
{
    BOOL    retVal;

    DebugEntry(DrvGetCursorPos);

    // Pulse BEFORE calling USER
    IMCheckWin16LockPulse();

    EnableFnPatch(&g_imPatches[IM_GETCURSORPOS], PATCH_DISABLE);
    retVal = RealGetCursorPos(lppt);
    EnableFnPatch(&g_imPatches[IM_GETCURSORPOS], PATCH_ENABLE);

    DebugExitBOOL(DrvGetCursorPos, retVal);
    return(retVal);
}



//
// IMMouseHookProc()
// High level mouse hook to make sure mice messages are going where we
// think they should when your machine is being controlled.
//
LRESULT CALLBACK IMMouseHookProc
(
    int     code,
    WPARAM  wParam,
    LPARAM  lParam
)
{
    LRESULT             rc;
    BOOL                fBlock = FALSE;
    LPMOUSEHOOKSTRUCT   lpMseHook  = (LPMOUSEHOOKSTRUCT)lParam;

    DebugEntry(IMMouseHookProc);

    if (code < 0)
    {
        //
        // Only pass along
        //
        DC_QUIT;
    }

    //
    // Decide if we should block this event.  We will if it is not destined
    // for a hosted window and not destined for a screen saver.
    //
    if (!HET_WindowIsHosted(lpMseHook->hwnd) &&
        !OSIIsWindowScreenSaver16(lpMseHook->hwnd))
    {
        fBlock = TRUE;

    }

    TRACE_OUT(("MOUSEHOOK hwnd %04x -> block: %s",
        lpMseHook->hwnd,
        (fBlock ? (LPSTR)"YES" : (LPSTR)"NO")));

DC_EXIT_POINT:
    //
    // Call the next hook
    //
    rc = CallNextHookEx(g_imWin95Data.imhHighLevelMouseHook, code, wParam, lParam);

    if (fBlock)
    {
        //
        // To block further processing in USER, return TRUE
        //
        rc = TRUE;
    }

    DebugExitDWORD(IMMouseHookProc, rc);
    return(rc);
}





//
// DrvMouseEvent()
// mouse_event interrupt patch
//
void WINAPI DrvMouseEvent
(
    UINT    regAX,
    UINT    regBX,
    UINT    regCX,
    UINT    regDX,
    UINT    regSI,
    UINT    regDI
)
{
    BOOL    fAllow;

    //
    // If this is injected by us, just pass it through.
    //
    fAllow = TRUE;
    if (g_imWin95Data.imInjecting)
    {
        DC_QUIT;
    }

    //
    // NOTE:
    //      flags is in     AX
    //      x coord is in   BX
    //      y coord is in   CX
    //      mousedata is in DX
    //      dwExtraInfo is in DI, SI
    //

    if (g_imSharedData.imControlled && !g_imSharedData.imPaused)
    {
        //
        // If this is a button click, take control back
        //
        if (regAX &
            (MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_RIGHTDOWN | MOUSEEVENTF_MIDDLEDOWN))
        {
            if (!g_imSharedData.imUnattended)
            {
                PostMessage(g_asMainWindow, DCS_REVOKECONTROL_MSG, FALSE, 0);
            }
        }

        if (!g_imSharedData.imSuspended)
            fAllow = FALSE;
    }

DC_EXIT_POINT:
    if (fAllow)
    {
        EnableFnPatch(&g_imPatches[IM_MOUSEEVENT], PATCH_DISABLE);
        CallMouseEvent(regAX, regBX, regCX, regDX, regSI, regDI);
        EnableFnPatch(&g_imPatches[IM_MOUSEEVENT], PATCH_ENABLE);
    }
}


//
// DrvKeyboardEvent()
// keybd_event interrupt patch
//
void WINAPI DrvKeyboardEvent
(
    UINT    regAX,
    UINT    regBX,
    UINT    regSI,
    UINT    regDI
)
{
    BOOL    fAllow;

    //
    // If this is injected by us, pass it through.  Do the same for
    // critical errors, since everything is frozen and we can't play back
    // input if we wanted to.
    //
    // If the scan-code (in regBX) is 0 we assume that the input
    // is injected by an application (such as an IME) and we don't
    // want to block this or take control.
    //

    fAllow = TRUE;
    if (g_imWin95Data.imInjecting || !regBX)
    {
        DC_QUIT;
    }

    //
    // NOTE:
    //      vkCode is in    AX, LOBYTE is vkCode, HIBYTE is state
    //      scanCode is in  BX
    //      dwExtraInfo is in   DI, SI
    //

    if (g_imSharedData.imControlled && !g_imSharedData.imPaused)
    {
        if (!(regAX & USERKEYEVENTF_KEYUP))
        {
            //
            // This is a key down.  Take control back (except for ALT key),
            // and kill control allowability if it's the ESC key.
            //

            if (LOBYTE(regAX) == VK_ESCAPE)
            {
                PostMessage(g_asMainWindow, DCS_ALLOWCONTROL_MSG, FALSE, 0);
            }
            else if (LOBYTE(regAX != VK_MENU))
            {
                if (!g_imSharedData.imUnattended)
                {
                    PostMessage(g_asMainWindow, DCS_REVOKECONTROL_MSG, 0, 0);
                }
            }
        }

        //
        // Don't discard toggle keys.  The enabled/disabled function
        // is already set before we see the keystroke.  If we discard,
        // the lights are incorrect.
        //
        if (!IM_KEY_IS_TOGGLE(LOBYTE(regAX)) && !g_imSharedData.imSuspended)
        {
            fAllow = FALSE;
        }
    }

DC_EXIT_POINT:
    if (fAllow)
    {
        EnableFnPatch(&g_imPatches[IM_KEYBOARDEVENT], PATCH_DISABLE);
        CallKeyboardEvent(regAX, regBX, regSI, regDI);
        EnableFnPatch(&g_imPatches[IM_KEYBOARDEVENT], PATCH_ENABLE);
    }
}



//
// DrvSignalProc32()
// This patches USER's SignalProc32 export and watches for the FORCE_LOCK
// signals.  KERNEL32 calls them before/after putting up critical error and
// fault dialogs.  That's how we know when one is coming up, and can 
// temporarily suspend remote control of your machine so you can dismiss
// them.  Usually the thread they are on is boosted so high priority that
// nothing else can run, and so NM can't pump in input from the remote.
//
BOOL WINAPI DrvSignalProc32
(
    DWORD   dwSignal,
    DWORD   dwID,
    DWORD   dwFlags,
    WORD    hTask16
)
{
    BOOL    fRet;

    DebugEntry(DrvSignalProc32);

    if (dwSignal == SIG_PRE_FORCE_LOCK)
    {
        TRACE_OUT(("Disabling remote control before critical dialog, count %ld",
            g_imSharedData.imSuspended));
        ++g_imSharedData.imSuspended;
    }

    EnableFnPatch(&g_imPatches[IM_SIGNALPROC32], PATCH_DISABLE);
    fRet = SignalProc32(dwSignal, dwID, dwFlags, hTask16);
    EnableFnPatch(&g_imPatches[IM_SIGNALPROC32], PATCH_ENABLE);

    if (dwSignal == SIG_POST_FORCE_LOCK)
    {
        --g_imSharedData.imSuspended;
        TRACE_OUT(("Enabling remote control after critical dialog, count %ld",
            g_imSharedData.imSuspended));
    }

    DebugExitBOOL(DrvSignalProc32, fRet);
    return(fRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\as16\makefile.inc ===
#############################################################################
#
#   MAKEFILE.INC
#
#   Common rules for the Win95-16 groupware binaries (mnm*.*)
#
#############################################################################

.SUFFIXES : .asm .thk .rc .c .cpp .lib .exp .typ


C_TOTAL = $(C_FLAGS) -I$(INCLUDES:;= -I)
MASM_TOTAL = $(MASM_FLAGS) -I$(INCLUDES:;= -I)


{}.c{$(O)\}.obj:
    @type <<$(ECHO_RSP)
$(C_NAME) $(MAKEDIR)\$(<F)
$(C_TOTAL)
<<NOKEEP
    @$(C_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F)
$(C_TOTAL: =
)
<<NOKEEP



{}.asm{$(O)\}.obj:
    @type <<$(ECHO_RSP)
$(MASM_NAME) $(MAKEDIR)\$(<F)
$(MASM_TOTAL)
<<NOKEEP
    @$(MASM_NAME) @<<$(CL_RSP) -Fo$(MAKEDIR)\$@ $(MAKEDIR)\$(<F)
$(MASM_TOTAL: =
)
<<NOKEEP


# This is kind of whacky
{$(AS_ROOT)\thk\}.thk{}.asm:
    $(THUNK_NAME) -t thk -o $@ $?


RC_TOTAL = -r $(RC_FLAGS) -I$(RC_INCLUDES:;= -I)

$(O)\$(TARGETNAME).res : $(TARGETNAME).rc
    $(RC_NAME) $(RC_TOTAL) -fo $@ $(TARGETNAME).rc


$(DYNLINK_LIB) $(DYNLINK_LIB:.lib=.exp): $(DLLDEF) $(LIBRARY_OBJS)
    $(IMPLIB_NAME) $(IMPLIB_FLAGS) $(DYNLINK_LIB) $(DLLDEF)
    $(LIBEXTRA_CMD)


!if "$(TARGETTYPE)" != "DYNLINK" || "$(MAKEDLL)" != ""

$(TARGET): $(OBJECTS) $(LINKLIBS) $(CRTLIBS) $(MACHINE_TARGETLIBS)
    @type <<$(ECHO_RSP)
$(LINK_NAME) 
$(LINK_FLAGS)
$(OBJECTS: =
)
$(LINKLIBS: =
)
$(TARGETLIBS: =
)
<<NOKEEP
    @$(LINK_NAME) @<<$(CL_RSP)
$(LINK_FLAGS) +
$(OBJECTS: =+^
),
$(TARGET),
$(TARGETPATHLIB)\$(TARGET_DIRECTORY)\$(TARGETNAME).map,
$(LINKLIBS) +
$(TARGETLIBS: =+^
),
$(DLLDEF)
<<NOKEEP
    $(RC_NAME) $(RES_FLAGS) $(O)\$(TARGETNAME).res $(TARGET)
    $(SPLITSYM_CMD)
    $(TARGETCOPY_CMD)
    $(MAPSYM_CMD)
    $(MAPCOPY_CMD)
    $(SYMCOPY_CMD)
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\as16\oa.c ===
//
// OA.C
// Order Accumulator
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>


#ifdef DEBUG
//
// We use this to make sure our order heap list is committed in the order 
// the items were allocated in.
//
// NOTE:
// Can't make this CODESEG.  USER in Win95 has a bug, the validation layer
// for CopyRect() got the parameters reversed, and it won't continue
// if the SOURCE (it meant the DEST) rect isn't writeable.
//
static RECT g_oaEmptyRect = { 0x7FFF, 0x7FFF, 0, 0 };

#endif // DEBUG

//
// OA_DDProcessRequest()
// Handles OA escapes
//
BOOL OA_DDProcessRequest
(
    UINT                fnEscape,
    LPOSI_ESCAPE_HEADER pRequest,
    DWORD               cbRequest
)
{
    BOOL                rc = TRUE;

    DebugEntry(OA_DDProcessRequest);

    switch (fnEscape)
    {
        case OA_ESC_FLOW_CONTROL:
        {
            ASSERT(cbRequest == sizeof(OA_FLOW_CONTROL));

            // Save new throughput measurement
            g_oaFlow = ((LPOA_FLOW_CONTROL)pRequest)->oaFlow;
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized OA escape"));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(OA_DDProcessRequest, rc);
    return(rc);
}



//
//
// OA_DDAddOrder(..)
//
// Adds an order to the queue for transmission.
//
// If the new order is completetly covered by the current SDA then
// it is spoilt.
//
// If the order is opaque and overlaps earlier orders it may clip
// or spoil them.
//
// Called by the GDI interception code.
//
//
void  OA_DDAddOrder(LPINT_ORDER pNewOrder, void FAR * pExtraInfo)
{
    RECT      SDARects[BA_NUM_RECTS*2];
    UINT      cBounds;
    UINT      spoilingBounds;
    UINT      totalBounds;
    UINT      i;
    RECT      SrcRect;
    RECT      tmpRect;
    BOOL      gotBounds = FALSE;
    int       dx;
    int       dy;
    RECT      IntersectedSrcRect;
    RECT      InvalidDstRect;
    LPINT_ORDER  pTmpOrder;
    LPEXTTEXTOUT_ORDER  pExtTextOut;
    LPOA_FAST_DATA  lpoaFast;
    LPOA_SHARED_DATA lpoaShared;

    DebugEntry(OA_DDAddOrder);

    lpoaShared = OA_SHM_START_WRITING;
    lpoaFast   = OA_FST_START_WRITING;

    //
    // Accumulate order accumulation rate.  We are interested in how
    // quickly orders are being added to the buffer, so that we can tell
    // DCS scheduling whether frequent sends are advisable
    //
    SHM_CheckPointer(lpoaFast);
    lpoaFast->ordersAccumulated++;

    //
    // If the order is a private one, then we just add it to the Order
    // List and return immediately.
    //
    // Private Orders are used to send bitmap cache information (bitmap
    // bits and color tables).
    //
    // Private Orders never spoil any others and must never be spoilt.
    //
    if (pNewOrder->OrderHeader.Common.fOrderFlags & OF_PRIVATE)
    {
        TRACE_OUT(("Add private order (%lx)", pNewOrder));
        OADDAppendToOrderList(lpoaShared, pNewOrder);
        DC_QUIT;
    }

    //
    // If this order is spoilable and its is completely enclosed by the
    // current screen data area, we can spoil it.  Unless...
    //
    // PM - Performance
    //
    // We have observed in usability testing that clipping orders always
    // degrades the end-user's perceived performance.  This is because the
    // orders flow much faster than the screendata and tend to relate to
    // text, which is what the user really wants to see.  For example, text
    // overwriting a bitmap will be delayed because we want to send the
    // bitmap as screendata.
    //
    // Also, word documents tend to contain sections of screendata due to
    // mismatched fonts, intelliquotes, spelling annotation, current line
    // memblit.  Nothing we can do about this, but if we page down two or
    // three times, or down and up again we get an accumulation of the
    // screendata on all the pages spoiling the orders and the end result
    // is that we have to wait longer than we would if we had not spoiled
    // the orders.
    //
    // So, what we can do instead is leave the text orders in and overwrite
    // them with screendata when it gets through.  However, to make this
    // really effective what we also do is convert any transparent text
    // (as WEB browsers tend to use) into opaque text on a default
    // background.
    //
    //
    if ((pNewOrder->OrderHeader.Common.fOrderFlags & OF_SPOILABLE) != 0)
    {
        //
        // Get the driver's current bounds.
        //
        BA_CopyBounds(SDARects, &cBounds, FALSE);
        gotBounds = TRUE;

        for (i = 0; i < cBounds; i++)
        {
            if ( OADDCompleteOverlapRect(&pNewOrder->OrderHeader.Common.rcsDst,
                                      &(SDARects[i])) )
            {
                //
                // The destination of the order is completely covered by
                // the SDA.  Check for a text order.
                //
                pExtTextOut = (LPEXTTEXTOUT_ORDER)pNewOrder->abOrderData;
                if (pExtTextOut->type == ORD_EXTTEXTOUT_TYPE)
                {
                    //
                    // The order is going to be completely overwritten so
                    // we can play around with it all we like.
                    // Just make it opaque so the user can read it while
                    // waiting for the screendata to follow on.
                    //
                    pExtTextOut->fuOptions |= ETO_OPAQUE;

                    //
                    // pExtTextOut->rectangle is a TSHR_RECT32
                    //
                    pExtTextOut->rectangle.left = pNewOrder->OrderHeader.Common.rcsDst.left;
                    pExtTextOut->rectangle.top = pNewOrder->OrderHeader.Common.rcsDst.top;
                    pExtTextOut->rectangle.right = pNewOrder->OrderHeader.Common.rcsDst.right;
                    pExtTextOut->rectangle.bottom = pNewOrder->OrderHeader.Common.rcsDst.bottom;

                    TRACE_OUT(("Converted text order to opaque"));
                    break;
                }
                else
                {
                    TRACE_OUT(("Spoiling order %08lx by SDA", pNewOrder));
                    OA_DDFreeOrderMem(pNewOrder);
                    DC_QUIT;
                }
            }
        }
    }

    //
    // Pass the order onto the Bitmap Cache Controller to try to cache the
    // src bitmap.
    //
    if (ORDER_IS_MEMBLT(pNewOrder) || ORDER_IS_MEM3BLT(pNewOrder))
    {
        ERROR_OUT(("MEMBLT orders not supported!"));
    }

    if (ORDER_IS_SCRBLT(pNewOrder))
    {
        //
        //
        // Handle Screen to Screen (SS) bitblts.
        //
        // The basic plan
        // --------------
        //
        // If the source of a screen to screen blt intersects with the
        // current SDA then we have to do some additional work because all
        // orders are always executed before the SDA is copied.  This means
        // that the data within the SDA will not be available at the time
        // we want to do the SS blt.
        //
        // In this situation we adjust the SS blt to remove all overlap
        // from the src rectangle.  The destination rectangle is adjusted
        // accordingly.  The area removed from the destination rectangle is
        // added into the SDA.
        //
        //
        TRACE_OUT(("Handle SS blt(%lx)", pNewOrder));

        //
        // Make the order non-spoilable because we don't want the adding
        // of screen data to delete the order.
        //
        pNewOrder->OrderHeader.Common.fOrderFlags &= ~OF_SPOILABLE;

        //
        // Calculate the src rect.
        //
        SrcRect.left = ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nXSrc;
        SrcRect.right = SrcRect.left +
                        ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nWidth - 1;
        SrcRect.top = ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nYSrc;
        SrcRect.bottom = SrcRect.top +
                       ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nHeight - 1;

        //
        //
        // ORIGINAL SCRBLT SCHEME
        // ----------------------
        //
        // If the source rectangle intersects the current Screen Data Area
        // (SDA) then the src rectangle is modified so that no there is no
        // intersection with the SDA, and the dst rectangle adjusted
        // accordingly (this is the theory - in practice the operation
        // remains the same and we just adjust the dst clip rectangle).
        // The destination area that is removed is added into the SDA.
        //
        // The code works, but can result in more screen data being sent
        // than is required.
        //
        // e.g.
        //
        // Operation:
        //
        //      SSSSSS      DDDDDD
        //      SSSSSS  ->  DDDDDD
        //      SSSSSS      DDDDDD
        //      SxSSSS      DDDDDD
        //
        //      S - src rect
        //      D - dst rect
        //      x - SDA overlap
        //
        // The bottom edge of the blt is trimmed off, and the corresponding
        // destination area added into the SDA.
        //
        //      SSSSSS      DDDDDD
        //      SSSSSS  ->  DDDDDD
        //      SSSSSS      DDDDDD
        //                  xxxxxx
        //
        //
        //
        // NEW SCRBLT SCHEME
        // ------------------
        //
        // The new scheme does not modify the blt rectangles, and just
        // maps the SDA overlap to the destination rect and adds that
        // area back into the SDA.
        //
        // e.g. (as above)
        //
        // Operation:
        //
        //      SSSSSS      DDDDDD
        //      SSSSSS  ->  DDDDDD
        //      SSSSSS      DDDDDD
        //      SxSSSS      DDDDDD
        //
        //      S - src rect
        //      D - dst rect
        //      x - SDA overlap
        //
        // The blt operation remains the same, but the overlap area is
        // mapped to the destination rectangle and added into the SDA.
        //
        //      SSSSSS      DDDDDD
        //      SSSSSS  ->  DDDDDD
        //      SSSSSS      DDDDDD
        //      SxSSSS      DxDDDD
        //
        //
        // This scheme results in a smaller SDA area. However, this scheme
        // does blt potentially invalid data to the destination - which
        // may briefly be visible at the remote machine (because orders
        // are replayed before Screen Data). This has not (yet) proved to
        // be a problem.
        //
        // The main benefit of the new scheme is when scrolling an area
        // that includes a small SDA.
        //
        //                                         new         old
        //                                        scheme      scheme
        //
        //     AAAAAAAA                          AAAAAAAA    AAAAAAAA
        //     AAAAAAAA                          AAAxAAAA    xxxxxxxx
        //     AAAAAAAA  scroll up 3 times ->    AAAxAAAA    xxxxxxxx
        //     AAAAAAAA                          AAAxAAAA    xxxxxxxx
        //     AAAxAAAA                          AAAxAAAA    xxxxxxxx
        //
        //
        //
        if (!gotBounds)
        {
            //
            // Get the driver's current bounds.
            //
            BA_CopyBounds(SDARects, &cBounds, FALSE);
        }

        //
        // Now get any bounds which the share core is currently processing.
        // We have to include these bounds when we are doing the above
        // processing to avoid a situation where the core grabs the screen
        // data from the source of a ScrBlt after the source has been
        // updated by another order.
        //
        // e.g.  If there is no driver SDA, but the core is processing the
        // area marked 'c'...
        //
        // If we ignore the core SDA, we queue a ScrBlt order which does
        // the following.
        //
        //      SSSSSS      DDDDDD
        //      SccccS  ->  DDDDDD
        //      SccccS      DDDDDD
        //      SSSSSS      DDDDDD
        //
        // However, if another order (marked 'N') is accumulated before
        // the core grabs the SDA, we end up with the shadow doing the
        // following
        //
        //      SSSSSS      DDDDDD
        //      ScNNcS  ->  DDNNDD
        //      ScNNcS      DDNNDD
        //      SSSSSS      DDDDDD
        //
        // i.e. the new order gets copied to the destination of the ScrBlt.
        // So, the ScrBlt order must be processed as
        //
        //      SSSSSS      DDDDDD
        //      SccccS  ->  DxxxxD
        //      SccccS      DxxxxD
        //      SSSSSS      DDDDDD
        //
        //
        BA_QuerySpoilingBounds(&SDARects[cBounds], &spoilingBounds);
        totalBounds = cBounds + spoilingBounds;

        //
        //
        // This is the new SCRBLT handler.
        //
        //
        for (i = 0; i < totalBounds ; i++)
        {
            if ( (SrcRect.left >= SDARects[i].left) &&
                 (SrcRect.right <= SDARects[i].right) &&
                 (SrcRect.top >= SDARects[i].top) &&
                 (SrcRect.bottom <= SDARects[i].bottom) )
            {
                //
                // The src of the SS blt is completely within the SDA.  We
                // must add in the whole destination rectangle into the SDA
                // and spoil the SS blt.
                //
                TRACE_OUT(("SS blt src within SDA - spoil it"));

                RECT_FROM_TSHR_RECT16(&tmpRect,
                                        pNewOrder->OrderHeader.Common.rcsDst);
                OA_DDFreeOrderMem(pNewOrder);
                BA_AddScreenData(&tmpRect);
                DC_QUIT;
            }

            //
            // Intersect the src rect with the SDA rect.
            //
            IntersectedSrcRect.left = max( SrcRect.left,
                                              SDARects[i].left );
            IntersectedSrcRect.right = min( SrcRect.right,
                                               SDARects[i].right );
            IntersectedSrcRect.top = max( SrcRect.top,
                                             SDARects[i].top );
            IntersectedSrcRect.bottom = min( SrcRect.bottom,
                                                SDARects[i].bottom );

            dx = ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nLeftRect -
                   ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nXSrc;
            dy = ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nTopRect -
                   ((LPSCRBLT_ORDER)&pNewOrder->abOrderData)->nYSrc;

            InvalidDstRect.left   = IntersectedSrcRect.left + dx;
            InvalidDstRect.right  = IntersectedSrcRect.right + dx;
            InvalidDstRect.top    = IntersectedSrcRect.top + dy;
            InvalidDstRect.bottom = IntersectedSrcRect.bottom + dy;

            //
            // Intersect the invalid destination rectangle with the
            // destination clip rectangle.
            //
            InvalidDstRect.left = max(
                                InvalidDstRect.left,
                                pNewOrder->OrderHeader.Common.rcsDst.left );
            InvalidDstRect.right = min(
                                InvalidDstRect.right,
                                pNewOrder->OrderHeader.Common.rcsDst.right );
            InvalidDstRect.top = max(
                                InvalidDstRect.top,
                                pNewOrder->OrderHeader.Common.rcsDst.top );
            InvalidDstRect.bottom = min(
                                InvalidDstRect.bottom,
                                pNewOrder->OrderHeader.Common.rcsDst.bottom );

            if ( (InvalidDstRect.left <= InvalidDstRect.right) &&
                 (InvalidDstRect.top <= InvalidDstRect.bottom) )
            {
                //
                // Add the invalid area into the SDA.
                //
                TRACE_OUT(("Sending SDA {%d, %d, %d, %d}", InvalidDstRect.left,
                    InvalidDstRect.top, InvalidDstRect.right, InvalidDstRect.bottom));
                BA_AddScreenData(&InvalidDstRect);
            }

        } // for (i = 0; i < totalBounds ; i++)

        //
        // Make the order spoilable again (this assumes that all SS blts
        // are spoilable.
        //
        pNewOrder->OrderHeader.Common.fOrderFlags |= OF_SPOILABLE;

    } // if (ORDER_IS_SCRBLT(pNewOrder))

    else if ((pNewOrder->OrderHeader.Common.fOrderFlags & OF_DESTROP) != 0)
    {
        //
        // This is the case where the output of the order depends on the
        // existing contents of the target area (e.g.  an invert).
        //
        // What we have to do here is to add any parts of the destination
        // of this order which intersect the SDA which the share core is
        // processing to the driver SDA.  The reason for this is the same
        // as the SCRBLT case - the share core may grab the data from the
        // screen after we have applied this order (e.g.  after we have
        // inverted an area of the screen), then send the order as well
        // (re-inverting the area of the screen).
        //
        // Note that we only have to worry about the SDA which the share
        // core is processing - we can ignore the driver's SDA.
        //
        TRACE_OUT(("Handle dest ROP (%#.8lx)", pNewOrder));

        BA_QuerySpoilingBounds(SDARects, &spoilingBounds);
        for (i = 0; i < spoilingBounds ; i++)
        {
            //
            // Intersect the dest rect with the share core SDA rect.
            //
            InvalidDstRect.left = max(
                                SDARects[i].left,
                                pNewOrder->OrderHeader.Common.rcsDst.left );
            InvalidDstRect.right = min(
                                SDARects[i].right,
                                pNewOrder->OrderHeader.Common.rcsDst.right );
            InvalidDstRect.top = max(
                                SDARects[i].top,
                                pNewOrder->OrderHeader.Common.rcsDst.top );
            InvalidDstRect.bottom = min(
                                SDARects[i].bottom,
                                pNewOrder->OrderHeader.Common.rcsDst.bottom );

            if ( (InvalidDstRect.left <= InvalidDstRect.right) &&
                 (InvalidDstRect.top <= InvalidDstRect.bottom) )
            {
                //
                // Add the invalid area into the SDA.
                //
                TRACE_OUT(("Sending SDA {%d, %d, %d, %d}",
                             InvalidDstRect.left,
                             InvalidDstRect.top,
                             InvalidDstRect.right,
                             InvalidDstRect.bottom));
                BA_AddScreenData(&InvalidDstRect);
            }
        }
    }

    //
    // Add the new order to the end of the Order List.
    //
    OADDAppendToOrderList(lpoaShared, pNewOrder);
    TRACE_OUT(("Append order(%lx) to list", pNewOrder));

    //
    // Now see if this order spoils any existing orders
    //
    if (pNewOrder->OrderHeader.Common.fOrderFlags & OF_SPOILER)
    {
        //
        // Its a spoiler, so try to spoil with it.
        //
        // We have to pass in the bounding rectangle of the order, and the
        // first order to try to spoil to OADDSpoilFromOrder.  The first
        // order to try to spoil is the one before the new order.
        //
        RECT_FROM_TSHR_RECT16(&tmpRect,
                                pNewOrder->OrderHeader.Common.rcsDst);

        pTmpOrder = COM_BasedListPrev(&lpoaShared->orderListHead, pNewOrder,
            FIELD_OFFSET(INT_ORDER, OrderHeader.list));

        OADDSpoilFromOrder(lpoaShared, pTmpOrder, &tmpRect);
    }

    //
    // This is where the Win95 product would call DCS_TriggerEarlyTimer.
    //

DC_EXIT_POINT:
    OA_FST_STOP_WRITING;
    OA_SHM_STOP_WRITING;
    DebugExitVOID(OA_DDAddOrder);
}

//
//
// FUNCTION: OA_DDAllocOrderMem
//
// DESCRIPTION:
//
// Allocates memory for an internal order structure from our own private
// Order Heap.
//
// Allocates any Additional Order Memory from global memory.  A pointer to
// the Additional Order Memory is stored within the allocated order's
// header (pOrder->OrderHeader.pAdditionalOrderData).
//
//
// PARAMETERS:
//
// cbOrderDataLength - length in bytes of the order data to be allocated
// from the Order Heap.
//
// cbAdditionalOrderDataLength - length in bytes of additional order data
// to be allocated from Global Memory.  If this parameter is zero no
// additional order memory is allocated.
//
//
// RETURNS:
//
// A pointer to the allocated order memory.  NULL if the memory allocation
// failed.
//
//
//
LPINT_ORDER  OA_DDAllocOrderMem(UINT cbOrderDataLength, UINT cbAdditionalOrderDataLength)
{
    LPINT_ORDER  pOrder = NULL;
    LPINT_ORDER  pFirstOrder;
    LPINT_ORDER  pTailOrder;
    RECT        tferRect;
    LONG        targetSize;
    DWORD       moveOffset;
    DWORD       moveBytes;
    LPINT_ORDER  pColorTableOrder = NULL;
    LPBYTE     pNextOrderPos;
    LPOA_SHARED_DATA    lpoaShared;

    DebugEntry(OA_DDAllocOrderMem);

    lpoaShared = OA_SHM_START_WRITING;

    //
    // PM Performance
    //
    // Although turning order accumulation off does clear the pipe, ready
    // for us to get the screendata over the wire as soon as we can, it
    // actually hinders end-user responsiveness because they see a longer
    // interval when nothing is happening, rather than getting feedback
    // that we are busy and the whole thing taking longer!
    //
    // So, what we do when we fill up the order buffer is we discard half
    // the orders in the buffer, adding them to the screendata.  In this
    // way we will always keep between 50 and 100% of the orders for the
    // final updates to the window, which hopefully will be what the user
    // really wants to see.
    //
    // If the orders keep coming then we will keep on accumulating some,
    // sending them, discarding others until things quiet down, at which
    // point we will flush out our order buffer.
    //
    // When we come to flush the order buffer we also spoil the early ones
    // against screendata, so that we only have the final set of orders to
    // replay.  We control the size of this final non-spoiled set depending
    // on whether we are running over a high or low speed connection.
    // Also, if we did not encounter any back pressure during the session
    // then we do not purge any orders at all, preferring to send
    // everything we possibly can as orders.
    //
    // Note that this approach assumes that we do not spoil all orders
    // against screendata on the fly because that leads to us generally
    // sending out-of-data orders followed by up-to-date screendata, which
    // is exactly what we do not want to see.
    //
    //

    CheckOaHeap(lpoaShared);

    //
    // First check that we have not already exceeded our high water mark
    // recommended by flow control.  If we have then purge half the queue
    // so we have space to accumulate the later, more valuable, orders
    //
    // Note that this does not guarantee that we will have less orders
    // accumulated than the limit set by flow control.  However, if enough
    // orders are generated, we will come through this branch on each order
    // and finally reduce to below the imposed limit.
    //
    SHM_CheckPointer(&lpoaShared->totalOrderBytes);

    if (g_oaPurgeAllowed && (lpoaShared->totalOrderBytes >
        (DWORD)(g_oaFlow == OAFLOW_FAST ? OA_FAST_HEAP : OA_SLOW_HEAP)))
    {
        RECT        aRects[BA_NUM_RECTS];
        UINT        numRects;
        UINT        i;

        WARNING_OUT(("Purging orders; total 0x%08x is greater than heap 0x%08x",
            lpoaShared->totalOrderBytes,
            (DWORD)(g_oaFlow == OAFLOW_FAST ? OA_FAST_HEAP : OA_SLOW_HEAP)));

        //
        // If we need to make room for the new order then purge half the
        // current queue.  We do this so we end up with the most recent
        // orders on the queue, rather than the oldest.
        //
        targetSize = lpoaShared->totalOrderBytes / 2;
        TRACE_OUT(("Target size %ld", targetSize));

        //
        // Iterate through the list until we have found the first order
        // beyond the limit to be destroyed.  Once we have got this order,
        // we can shuffle the list over the useless orders.
        //
        pOrder = COM_BasedListFirst(&lpoaShared->orderListHead,
            FIELD_OFFSET(INT_ORDER, OrderHeader.list));

        pTailOrder = (LPINT_ORDER)COM_BasedPrevListField(&lpoaShared->orderListHead);

        //
        // If we hit this condition, we have to have at least one order
        // pending, so these both must be non NULL.
        //
        SHM_CheckPointer(pOrder);
        SHM_CheckPointer(pTailOrder);

        TRACE_OUT(("Order 0x%08lx, tail 0x%08lx", pOrder, pTailOrder));

        //
        // Disable spoiling of existing orders by screen data while we do
        // the purge otherwise we may try to spoil an order which we are
        // purging !
        //
        g_baSpoilByNewSDAEnabled = FALSE;

        while ((pOrder != NULL) && (targetSize > 0))
        {
            //
            // Can't check at end; COM_BasedListNext may return NULL and
            // SHM_CheckPointer doesn't like that.
            //
            SHM_CheckPointer(pOrder);

            //
            // Check to see if this is an internal color table order.  If
            // it is, the OF_INTERNAL flag will be set.
            //
            // MemBlt orders rely on being preceeded by a color table order
            // to set up the colors correctly.  If we purge all the color
            // table orders, the following Mem(3)Blts will get the wrong
            // colors.  So, we have to keep track of the last color table
            // order to be purged and then add it back into the order heap
            // later.
            //
            if ((pOrder->OrderHeader.Common.fOrderFlags & OF_INTERNAL) != 0)
            {
                TRACE_OUT(("Found color table order at %#.8lx", pOrder));
                pColorTableOrder = pOrder;
            }
            else
            {
                //
                // Add the order to the Screen Data Area
                //
                TRACE_OUT(("Purging orders. Add rect to SDA {%d, %d, %d, %d}",
                             pOrder->OrderHeader.Common.rcsDst.left,
                             pOrder->OrderHeader.Common.rcsDst.top,
                             pOrder->OrderHeader.Common.rcsDst.right,
                             pOrder->OrderHeader.Common.rcsDst.bottom));

                RECT_FROM_TSHR_RECT16(&tferRect,
                                        pOrder->OrderHeader.Common.rcsDst);
                BA_AddScreenData(&tferRect);
            }

            //
            // Keep track of how much data still needs removing.
            //
            targetSize                 -= INT_ORDER_SIZE(pOrder);

            lpoaShared->totalHeapOrderBytes -= INT_ORDER_SIZE(pOrder);
            TRACE_OUT(("Total heap order bytes: %ld",
                lpoaShared->totalHeapOrderBytes));

            lpoaShared->totalOrderBytes     -= MAX_ORDER_SIZE(pOrder);
            TRACE_OUT(("Total order bytes: %ld",
                lpoaShared->totalOrderBytes));

            //
            // If the order is a Mem(3)Blt, we have to tell SBC that we are
            // getting rid of it.
            //
            if (ORDER_IS_MEMBLT(pOrder) || ORDER_IS_MEM3BLT(pOrder))
            {
                ERROR_OUT(("MEMBLT orders not supported!"));
            }

            //
            // Get the next order to be removed.
            //
            pOrder = COM_BasedListNext(&lpoaShared->orderListHead,
                pOrder, FIELD_OFFSET(INT_ORDER, OrderHeader.list));
        }

        TRACE_OUT(("Stopped at order %#.8lx", pOrder));

        //
        // Orders have been transferred to SDA, so now we have to
        //   - move the last purged color table order (if there is one) to
        //     the start of the order heap
        //   - shuffle up the heap
        //   - reset the pointers.
        //
        // pOrder points to the first non-purged order.
        //
        if (pOrder != NULL)
        {
            pNextOrderPos = lpoaShared->orderHeap;

            //
            // If we purged (at least) one color table order, move the last
            // color table order to the start of the order heap.
            //
            if (pColorTableOrder != NULL)
            {
                TRACE_OUT(("Moving color table from %#.8lx to start",
                             pColorTableOrder));

                hmemcpy(pNextOrderPos, pColorTableOrder,
                              INT_ORDER_SIZE(pColorTableOrder));

                pColorTableOrder        = (LPINT_ORDER)pNextOrderPos;
                lpoaShared->totalHeapOrderBytes
                                       += INT_ORDER_SIZE(pColorTableOrder);
                TRACE_OUT(("Total heap order bytes: %ld",
                    lpoaShared->totalHeapOrderBytes));

                lpoaShared->totalOrderBytes += MAX_ORDER_SIZE(pColorTableOrder);
                TRACE_OUT(("Total order bytes: %ld",
                    lpoaShared->totalOrderBytes));

                pNextOrderPos          += INT_ORDER_SIZE(pColorTableOrder);

                //
                // Chain the order into the start of the order list.  Just
                // do the pointers to and from the list head for now, we
                // will do the rest later.
                //
                lpoaShared->orderListHead.next =
                   PTRBASE_TO_OFFSET(pColorTableOrder, &lpoaShared->orderListHead);

                pColorTableOrder->OrderHeader.list.prev =
                   PTRBASE_TO_OFFSET(&lpoaShared->orderListHead, pColorTableOrder);
            }

            //
            // Move the heap up to the top of the buffer.  The following
            // diagram illustrates how the order heap is split up at the
            // moment.
            //
            //              lpoaShared->nextOrder
            // |<>|
            //
            //         moveOffset          moveBytes
            //     |<>|<>|
            //
            // 
            //                                                       
            //        purged           remaining          unused     
            //        orders           orders                        
            //                                                      
            // 
            // ^  ^                 ^
            //                    
            //                    
            //                     pOrder
            //   
            //    pNextOrderPos
            //  
            //   color table order
            // 
            //  lpoaShared->orderHeap (pColorTableOrder)
            //
            // If there is no color table order, pNextOrderPos is equal to
            // lpoaShared->orderHeap.
            //
            // moveOffset is the number of bytes to move the remaining
            // orders by.
            //
            // moveBytes is the number of bytes to be moved.
            //
            //
            moveOffset = PTRBASE_TO_OFFSET(pOrder, pNextOrderPos);
            moveBytes  = lpoaShared->nextOrder
                       - moveOffset
                       - (pNextOrderPos - lpoaShared->orderHeap);

            TRACE_OUT(("Moving %ld bytes", moveBytes));

            hmemcpy(pNextOrderPos, pOrder, moveBytes);

            //
            // Update the head and tail pointers to reflect their new
            // positions.
            //
            pFirstOrder = (LPINT_ORDER)pNextOrderPos;
            pTailOrder  = (LPINT_ORDER)((DWORD)pTailOrder - moveOffset);
            SHM_CheckPointer(pFirstOrder);
            SHM_CheckPointer(pTailOrder);

            TRACE_OUT(("New first unpurged %#.8lx, tail %#.8lx",
                         pFirstOrder,
                         pTailOrder));

            //
            // Since the offsets are relative to the order pointer, we only
            // need to modify the start and end offsets.
            //
            // Unfortunately, the possibility of a color table order at the
            // start of the heap complicates the chaining of pFirstOrder.
            // If there is a color table order, we chain pFirstOrder to the
            // color table order, otherwise we chain it to the start of the
            // order list.
            //
            lpoaShared->orderListHead.prev =
                         PTRBASE_TO_OFFSET(pTailOrder, &lpoaShared->orderListHead);
            pTailOrder->OrderHeader.list.next =
                         PTRBASE_TO_OFFSET(&lpoaShared->orderListHead, pTailOrder);

            if (pColorTableOrder != NULL)
            {
                pColorTableOrder->OrderHeader.list.next =
                             PTRBASE_TO_OFFSET(pFirstOrder, pColorTableOrder);
                pFirstOrder->OrderHeader.list.prev =
                             PTRBASE_TO_OFFSET(pColorTableOrder, pFirstOrder);
            }
            else
            {
                lpoaShared->orderListHead.next =
                        PTRBASE_TO_OFFSET(pFirstOrder, &lpoaShared->orderListHead);
                pFirstOrder->OrderHeader.list.prev =
                        PTRBASE_TO_OFFSET(&lpoaShared->orderListHead, pFirstOrder);
            }

            //
            // Sort out where the next order to be allocated will go
            //
            lpoaShared->nextOrder -= moveOffset;
            TRACE_OUT(("Next order: %ld", lpoaShared->nextOrder));
        }
        else
        {
            //
            // No orders left - this happens if we've had lots of spoiling.
            // We have now cleared out all the valid orders so let's
            // re-initialise the heap for next time.
            //
            OA_DDResetOrderList();
        }

        //
        // Now re-enable the spoiling of orders by SDA.
        //
        g_baSpoilByNewSDAEnabled = TRUE;

        CheckOaHeap(lpoaShared);

        WARNING_OUT(("Purged orders, total is now 0x%08x", lpoaShared->totalOrderBytes));

        //
        // Lastly, spoil the remaining orders by the screen data.
        // If we've gotten this far, there's a lot of data being sent
        // and/or we're slow.  So nuke 'em.
        //
        BA_CopyBounds(aRects, &numRects, FALSE);

        for (i = 0; i < numRects; i++)
        {
            OA_DDSpoilOrdersByRect(aRects+i);
        }

        WARNING_OUT(("Spoiled remaining orders by SDA, total is now 0x%08x", lpoaShared->totalOrderBytes));

        TRACE_OUT(("Next 0x%08lx", lpoaShared->nextOrder));
        TRACE_OUT(("Head 0x%08lx", lpoaShared->orderListHead.next));
        TRACE_OUT(("Tail 0x%08lx", lpoaShared->orderListHead.prev));
        TRACE_OUT(("Total heap bytes 0x%08lx", lpoaShared->totalHeapOrderBytes));
        TRACE_OUT(("Total order bytes 0x%08lx", lpoaShared->totalOrderBytes));

        CheckOaHeap(lpoaShared);
    }

    pOrder = OADDAllocOrderMemInt(lpoaShared, cbOrderDataLength,
                                cbAdditionalOrderDataLength);
    if ( pOrder != NULL )
    {
        //
        // Update the count of total order data.
        //
        SHM_CheckPointer(&lpoaShared->totalHeapOrderBytes);
        lpoaShared->totalHeapOrderBytes       += sizeof(INT_ORDER_HEADER)
                                         +  cbOrderDataLength;
        TRACE_OUT(("Total heap order bytes: %ld", lpoaShared->totalHeapOrderBytes));

        SHM_CheckPointer(&lpoaShared->totalAdditionalOrderBytes);
        lpoaShared->totalAdditionalOrderBytes += cbAdditionalOrderDataLength;
        TRACE_OUT(("Total additional order bytes: %ld", lpoaShared->totalAdditionalOrderBytes));
    }
    TRACE_OUT(("Alloc order, addr %lx, size %u", pOrder,
                                                   cbOrderDataLength));

    CheckOaHeap(lpoaShared);

    OA_SHM_STOP_WRITING;
    DebugExitDWORD(OA_DDAllocOrderMem, (DWORD)pOrder);
    return(pOrder);
}

//
//
// FUNCTION: OA_DDFreeOrderMem
//
//
// DESCRIPTION:
//
// Frees order memory from our own private heap.
// Frees any Additional Order Memory associated with this order.
//
//
// PARAMETERS:
//
// pOrder - pointer to the order to be freed.
//
//
// RETURNS:
//
// Nothing.
//
//
void  OA_DDFreeOrderMem(LPINT_ORDER pOrder)
{
    LPOA_SHARED_DATA lpoaShared;

    DebugEntry(OA_DDFreeOrderMem);

    ASSERT(pOrder);

    lpoaShared = OA_SHM_START_WRITING;

    TRACE_OUT(("Free order %lx", pOrder));

    CheckOaHeap(lpoaShared);

    //
    // Update the data totals.
    //
    SHM_CheckPointer(&lpoaShared->totalHeapOrderBytes);
    lpoaShared->totalHeapOrderBytes -= (sizeof(INT_ORDER_HEADER)
                              + pOrder->OrderHeader.Common.cbOrderDataLength);
    TRACE_OUT(("Total heap order bytes: %ld", lpoaShared->totalHeapOrderBytes));

    SHM_CheckPointer(&lpoaShared->totalAdditionalOrderBytes);
    lpoaShared->totalAdditionalOrderBytes -=
                              pOrder->OrderHeader.cbAdditionalOrderDataLength;
    TRACE_OUT(("Total additional order bytes: %ld", lpoaShared->totalAdditionalOrderBytes));

    //
    // Do the work.
    //
    OADDFreeOrderMemInt(lpoaShared, pOrder);

    CheckOaHeap(lpoaShared);

    OA_SHM_STOP_WRITING;
    DebugExitVOID(OA_DDFreeOrderMem);
}


//
//
// FUNCTION: OA_DDResetOrderList
//
//
// DESCRIPTION:
//
// Frees all Orders and Additional Order Data in the Order List.
// Frees up the Order Heap memory.
//
//
// PARAMETERS:
//
// None.
//
//
// RETURNS:
//
// Nothing.
//
//
void  OA_DDResetOrderList(void)
{
    LPOA_SHARED_DATA    lpoaShared;

    DebugEntry(OA_DDResetOrderList);

    TRACE_OUT(("Resetting order list"));

    lpoaShared = OA_SHM_START_WRITING;

    CheckOaHeap(lpoaShared);

    //
    // First free all the orders on the list.
    //
    OADDFreeAllOrders(lpoaShared);

    //
    // Ensure that the list pointers are NULL.
    //
    SHM_CheckPointer(&lpoaShared->orderListHead);
    if ((lpoaShared->orderListHead.next != 0) || (lpoaShared->orderListHead.prev != 0))
    {
        ERROR_OUT(("Non-NULL list pointers (%lx)(%lx)",
                       lpoaShared->orderListHead.next,
                       lpoaShared->orderListHead.prev));

        SHM_CheckPointer(&lpoaShared->orderListHead);
        COM_BasedListInit(&lpoaShared->orderListHead);
    }

    CheckOaHeap(lpoaShared);

    OA_SHM_STOP_WRITING;
    DebugExitVOID(OA_DDResetOrderList);
}



//
// OA_DDSyncUpdatesNow
//
// Called when a sync operation is required.
//
// Discards all outstanding orders.
//
void  OA_DDSyncUpdatesNow(void)
{
    DebugEntry(OA_DDSyncUpdatesNow);

    TRACE_OUT(("Syncing OA updates now"));
    OADDFreeAllOrders(g_poaData[g_asSharedMemory->displayToCore.currentBuffer]);

    DebugExitVOID(OA_DDSyncUpdatesNow);
}


//
//
// OA_DDRemoveListOrder(..)
//
// Removes the specified order from the Order List by marking it as spoilt.
//
// Returns:
//   Pointer to the order following the removed order.
//
//
LPINT_ORDER  OA_DDRemoveListOrder(LPINT_ORDER pCondemnedOrder)
{
    LPOA_SHARED_DATA lpoaShared;
    LPINT_ORDER pSaveOrder;

    DebugEntry(OA_DDRemoveListOrder);

    TRACE_OUT(("Remove list order (%lx)", pCondemnedOrder));

    lpoaShared = OA_SHM_START_WRITING;

    SHM_CheckPointer(pCondemnedOrder);

    //
    // Check for a valid order.
    //
    if (pCondemnedOrder->OrderHeader.Common.fOrderFlags & OF_SPOILT)
    {
        ERROR_OUT(("Invalid order"));
        DC_QUIT;
    }

    //
    // Get the offset value of this order.
    //
    SHM_CheckPointer(&lpoaShared->orderHeap);

    //
    // Mark the order as spoilt.
    //
    pCondemnedOrder->OrderHeader.Common.fOrderFlags |= OF_SPOILT;

    //
    // Update the count of bytes currently in the Order List.
    //
    SHM_CheckPointer(&lpoaShared->totalOrderBytes);
    lpoaShared->totalOrderBytes -= MAX_ORDER_SIZE(pCondemnedOrder);
    TRACE_OUT(("Total order bytes: %ld", lpoaShared->totalOrderBytes));

    //
    // Save the order so we can remove it from the linked list after having
    // got the next element in the chain.
    //
    pSaveOrder = pCondemnedOrder;

    //
    // Return the next order in the list.
    //
    SHM_CheckPointer(&lpoaShared->orderListHead);
    pCondemnedOrder = COM_BasedListNext(&lpoaShared->orderListHead,
        pCondemnedOrder, FIELD_OFFSET(INT_ORDER, OrderHeader.list));

    if (pSaveOrder == pCondemnedOrder)
    {
        ERROR_OUT(("Order list has gone circular !"));
    }

    //
    // Delete the unwanted order from the linked list.
    //
    COM_BasedListRemove(&pSaveOrder->OrderHeader.list);

    //
    // Check that the list is still consistent with the total number of
    // order bytes.
    //
    if ( (lpoaShared->orderListHead.next != 0) &&
         (lpoaShared->orderListHead.prev != 0) &&
         (lpoaShared->totalOrderBytes    == 0) )
    {
        ERROR_OUT(("List head wrong: %ld %ld", lpoaShared->orderListHead.next,
                                                 lpoaShared->orderListHead.prev));
        COM_BasedListInit(&lpoaShared->orderListHead);
        pCondemnedOrder = NULL;
    }


DC_EXIT_POINT:
    CheckOaHeap(lpoaShared);
    OA_SHM_STOP_WRITING;

    DebugExitDWORD(OA_DDRemoveListOrder, (DWORD)pCondemnedOrder);
    return(pCondemnedOrder);
}



//
// OA_DDSpoilOrdersByRect - see oa.h
//
void  OA_DDSpoilOrdersByRect(LPRECT pRect)
{
    LPOA_SHARED_DATA lpoaShared;
    LPINT_ORDER  pOrder;

    DebugEntry(OA_DDSpoilOrdersByRect);

    lpoaShared = OA_SHM_START_WRITING;

    CheckOaHeap(lpoaShared);

    //
    // We want to start spoiling from the newest order i.e.  the one at the
    // end of the order list.
    //
    pOrder = COM_BasedListLast(&lpoaShared->orderListHead,
        FIELD_OFFSET(INT_ORDER, OrderHeader.list));
    if (pOrder != NULL)
    {
        OADDSpoilFromOrder(lpoaShared, pOrder, pRect);
    }

    CheckOaHeap(lpoaShared);

    OA_SHM_STOP_WRITING;
    
    DebugExitVOID(OA_DDSpoilOrdersByRect);
}



//
//
// OADDAppendToOrderList(..)
//
// Commits an allocated order to the end of the Order List.  The order must
// NOT be freed once it has been added.  The whole list must be invalidated
// to free the committed orders.
//
//
void  OADDAppendToOrderList(LPOA_SHARED_DATA lpoaShared, LPINT_ORDER pNewOrder)
{
    DebugEntry(OADDAppendToOrderList);

    //
    // Chain entry is already set up so all we do is keep track of
    // committed orders.
    //

    //
    // Store the total number of order bytes used.
    //
    SHM_CheckPointer(&lpoaShared->totalOrderBytes);
    lpoaShared->totalOrderBytes += MAX_ORDER_SIZE(pNewOrder);
    TRACE_OUT(("Total Order Bytes: %ld", lpoaShared->totalOrderBytes));

    DebugExitVOID(OADDAppendToOrderList);
}


//
//
// FUNCTION: OADDAllocOrderMemInt
//
// DESCRIPTION:
//
// Allocates memory for an internal order structure from our order heap.
//
//
// PARAMETERS:
//
// cbOrderDataLength - length in bytes of the order data to be allocated
// from the Order Heap.
//
// cbAdditionalOrderDataLength - length in bytes of additional order data
// to be allocated.  If this parameter is zero no additional order memory
// is allocated.
//
//
// RETURNS:           
//
// A pointer to the allocated order memory.  NULL if the memory allocation
// failed.
//
//
//
LPINT_ORDER  OADDAllocOrderMemInt
(
    LPOA_SHARED_DATA    lpoaShared,
    UINT                cbOrderDataLength,
    UINT                cbAdditionalOrderDataLength
)
{
    LPINT_ORDER   pOrder = NULL;
    UINT       cbOrderSize;

    DebugEntry(OADDAllocOrderMemInt);

    //
    // If the additional data will take us over our Additional Data Limit
    // then fail the memory allocation.
    //
    SHM_CheckPointer(&lpoaShared->totalAdditionalOrderBytes);
    if ((lpoaShared->totalAdditionalOrderBytes + cbAdditionalOrderDataLength) >
                                                    MAX_ADDITIONAL_DATA_BYTES)
    {
        TRACE_OUT(("Hit Additional Data Limit, current %lu addint %u",
                     lpoaShared->totalAdditionalOrderBytes,
                     cbAdditionalOrderDataLength));
        DC_QUIT;
    }

    //
    // Calculate the number of bytes we need to allocate (including the
    // order header).  Round up to the nearest 4 bytes to keep the 4 byte
    // alignment for the next order.
    //
    cbOrderSize = sizeof(INT_ORDER_HEADER) + cbOrderDataLength;
    cbOrderSize = (cbOrderSize + 3) & 0xFFFFFFFC;

    //
    // Make sure we don't overrun our heap limit
    //
    SHM_CheckPointer(&lpoaShared->nextOrder);
    if (lpoaShared->nextOrder + cbOrderSize > OA_HEAP_MAX)
    {
        WARNING_OUT(("Heap limit hit"));
        DC_QUIT;
    }

    //
    // Construct a far pointer to the allocated memory, and fill in the
    // length field in the Order Header.
    //
    SHM_CheckPointer(&lpoaShared->orderHeap);
    pOrder = (LPINT_ORDER)(lpoaShared->orderHeap + lpoaShared->nextOrder);
    pOrder->OrderHeader.Common.cbOrderDataLength = cbOrderDataLength;

    //
    // Update the order header to point to the next section of free heap.
    //
    SHM_CheckPointer(&lpoaShared->nextOrder);
    lpoaShared->nextOrder += cbOrderSize;

    //
    // Allocate any Additional Order Memory from Global Memory.
    //
    if (cbAdditionalOrderDataLength > 0)
    {
        //
        // Make sure we don't overrun our heap limit
        //
        SHM_CheckPointer(&lpoaShared->nextOrder);
        if (lpoaShared->nextOrder + cbAdditionalOrderDataLength > OA_HEAP_MAX)
        {
            WARNING_OUT(("Heap limit hit for additional data"));

            //
            // Clear the allocated order and quit.
            //
            SHM_CheckPointer(&lpoaShared->nextOrder);
            lpoaShared->nextOrder -= cbOrderSize;
            pOrder            = NULL;
            DC_QUIT;
        }

        //
        // Store the space for the additional data.
        //
        SHM_CheckPointer(&lpoaShared->nextOrder);
        pOrder->OrderHeader.additionalOrderData         = lpoaShared->nextOrder;
        pOrder->OrderHeader.cbAdditionalOrderDataLength =
                                                  cbAdditionalOrderDataLength;

        //
        // Update the next order pointer to point to the next 4-byte
        // boundary.
        //
        SHM_CheckPointer(&lpoaShared->nextOrder);
        lpoaShared->nextOrder += cbAdditionalOrderDataLength + 3;
        lpoaShared->nextOrder &= 0xFFFFFFFC;
    }
    else
    {
        pOrder->OrderHeader.additionalOrderData         = 0;
        pOrder->OrderHeader.cbAdditionalOrderDataLength = 0;
    }

    TRACE_OUT(("Next order: %ld", lpoaShared->nextOrder));

#ifdef DEBUG
    //
    // Initialize the bounds rect to something whacky, so we can detect if
    // our list ever gets out of order.  Orders MUST be committed in the 
    // sequence that they are allocated in.  Otherwise, spoilers will cause
    // us to mess up the linked list, since they walk backwards and assume
    // all previous orders are already committed.
    //
    CopyRect((LPRECT)&pOrder->OrderHeader.Common.rcsDst, &g_oaEmptyRect);
#endif // DEBUG

    //
    // Create the chain entry.
    //
    SHM_CheckPointer(&lpoaShared->orderListHead);
    COM_BasedListInsertBefore(&lpoaShared->orderListHead, &pOrder->OrderHeader.list);

DC_EXIT_POINT:
    DebugExitDWORD(OADDAllocOrderMemInit, (DWORD)pOrder);
    return(pOrder);
}


//
//
// FUNCTION: OADDFreeOrderMemInt
//
//
// DESCRIPTION:
//
// Frees order memory from our orders heap.  Frees any Additional Order
// Memory associated with this order.  This must NOT be used on an order
// that has been committed to the order list.
//
//
// PARAMETERS:
//
// pOrder - pointer to the order to be freed.
//
//
// RETURNS:
//
// Nothing.
//
//
void  OADDFreeOrderMemInt(LPOA_SHARED_DATA lpoaShared, LPINT_ORDER pOrder)
{
    LPINT_ORDER pOrderTail;

    DebugEntry(OADDFreeOrderMemInt);

    //
    // The order heap is real a misnomer.  We know that the memory is only
    // allocated in a purely sequential manner and deallocated as one large
    // lump of memory.
    //
    // So we do not need to implement a full memory heap allocation
    // mechanism.  Instead, we just need to keep track of where the
    // previous high water mark was before this order was freed.
    //

    //
    // Find the tail of the current chain.
    //
    pOrderTail = COM_BasedListLast(&lpoaShared->orderListHead, FIELD_OFFSET(INT_ORDER, OrderHeader.list));
    SHM_CheckPointer(pOrderTail);

    //
    // We wont necessarily be freeing the last item in the order heap.
    //
    if (pOrder == pOrderTail)
    {
        //
        // This is the last item in the heap, so we can set the pointer to
        // the next order to be used back to the start of the order being
        // freed.
        //
        SHM_CheckPointer(&lpoaShared->nextOrder);
        lpoaShared->nextOrder = (LONG)PTRBASE_TO_OFFSET(pOrder, lpoaShared->orderHeap);

        TRACE_OUT(("Next order: %ld", lpoaShared->nextOrder));
    }
    else
    {
        //
        // This is not the last item in the heap - we must not reset the
        // pointer to the next item to be used.
        //
        TRACE_OUT(("Not resetting next order (not last item in heap)"));
    }

    //
    // Delete the item from the chain.
    //
    COM_BasedListRemove(&pOrder->OrderHeader.list);

    DebugExitVOID(OADDFreeOrderMemInt);
}


//
// OADDFreeAllOrders
//
// Free the all the individual orders on the orders list, without
// discarding the list itself.
//
void  OADDFreeAllOrders(LPOA_SHARED_DATA lpoaShared)
{
    DebugEntry(OADDFreeAllOrders);

    TRACE_OUT(("Freeing all orders"));

    //
    // Simply clear the list head.
    //
    COM_BasedListInit(&lpoaShared->orderListHead);
    SHM_CheckPointer(&lpoaShared->orderListHead);

    lpoaShared->totalHeapOrderBytes       = 0;
    lpoaShared->totalOrderBytes           = 0;
    lpoaShared->totalAdditionalOrderBytes = 0;
    lpoaShared->nextOrder                 = 0;

    DebugExitVOID(OADDFreeAllOrders);
}

BOOL  OADDCompleteOverlapRect(LPTSHR_RECT16 prcsSrc, LPRECT prcsOverlap)
{
    //
    // Return TRUE if the source is completely enclosed by the overlap
    // rectangle.
    //
    return( (prcsSrc->left >= prcsOverlap->left) &&
            (prcsSrc->right <= prcsOverlap->right) &&
            (prcsSrc->top >= prcsOverlap->top) &&
            (prcsSrc->bottom <= prcsOverlap->bottom) );
}


//
// Name:      OADDSpoilFromOrder
//
// Purpose:   Remove any orders from the order heap which should be spoiled
//            by a given rectangle..
//
// Returns:   Nothing
//
// Params:    IN  pTargetOrder - Pointer to the first order to try to
//                               spoil.
//            IN  pRect        - Pointer to the spoiling rectangle.
//
// Operation: pTargetOrder may be spoiled by this function, so be careful
//            on return.
//
void  OADDSpoilFromOrder
(
    LPOA_SHARED_DATA    lpoaShared,
    LPINT_ORDER         pTargetOrder,
    LPRECT              pSpoilRect
)
{
    UINT      nonProductiveScanDepth = 0;
    UINT      scanExitDepth;
    BOOL      reachedBlocker = FALSE;

    DebugEntry(OADDSpoilFromOrder);

    TRACE_OUT(("Spoiling rect is {%d, %d, %d, %d}",
                 pSpoilRect->left,
                 pSpoilRect->top,
                 pSpoilRect->right,
                 pSpoilRect->bottom));

    //
    // Work out how deep we will scan if the spoiling is non-productive.
    // We go further for bigger orders over PSTN.  (ie Irrespective of the
    // bandwidth we do not want to do much work when the app is blasting
    // out a lot of single pel orders!)
    //
    if (((pSpoilRect->right - pSpoilRect->left) < FULL_SPOIL_WIDTH) &&
        ((pSpoilRect->bottom - pSpoilRect->top) < FULL_SPOIL_HEIGHT))
    {
        TRACE_OUT(("Small order so reducing spoil depth"));
        scanExitDepth = OA_FAST_SCAN_DEPTH;
    }
    else
    {
        //
        // Use the current default scan depth (this is based on the
        // current network throughput).
        //
        scanExitDepth = (g_oaFlow == OAFLOW_FAST) ?
            OA_FAST_SCAN_DEPTH : OA_SLOW_SCAN_DEPTH;
    }

    //
    // Loop backwards from the base order until we have one of the
    // following occurs.
    //   - We spoil all the preceeding orders.
    //   - We reach a blocker which we can't spoil.
    //   - We find scanExitDepth orders which we can't spoil.
    //
    while ((pTargetOrder != NULL)
             && !reachedBlocker
             && (nonProductiveScanDepth < scanExitDepth))
    {
        //
        // We do not exit immediately when we reach a blocker because it is
        // possible that we will spoil it.  If we do spoil it, then we can
        // quite happily try spoiling the orders which preceed it.
        //
        // So, just set a flag here which we will reset if we spoil the
        // order.
        //
        reachedBlocker =
           ((pTargetOrder->OrderHeader.Common.fOrderFlags & OF_BLOCKER) != 0);

        //
        // Only try to spoil spoilable orders.
        //
        if (pTargetOrder->OrderHeader.Common.fOrderFlags & OF_SPOILABLE)
        {
            //
            // Make sure this order is committed!
            //
            ASSERT(!EqualRect((LPRECT)&pTargetOrder->OrderHeader.Common.rcsDst, &g_oaEmptyRect));

            if (OADDCompleteOverlapRect(
                        &pTargetOrder->OrderHeader.Common.rcsDst, pSpoilRect))
            {
                //
                // The order can be spoilt.  If the order is a MemBlt or a
                // Mem3Blt, we have to notify SBC to allow it to free up
                // associated data.
                //
                if (ORDER_IS_MEMBLT(pTargetOrder) ||
                    ORDER_IS_MEM3BLT(pTargetOrder))
                {
                    ERROR_OUT(("MEMBLT orders not supported!"));
                }

                TRACE_OUT(("Spoil by order {%d, %d, %d, %d}",
                             pTargetOrder->OrderHeader.Common.rcsDst.left,
                             pTargetOrder->OrderHeader.Common.rcsDst.top,
                             pTargetOrder->OrderHeader.Common.rcsDst.right,
                             pTargetOrder->OrderHeader.Common.rcsDst.bottom));

                pTargetOrder = OA_DDRemoveListOrder(pTargetOrder);

                //
                // Reset the blocker flag - we spoiled the order, so if it
                // was a blocker we can now try to spoil earlier orders.
                //
                reachedBlocker = FALSE;
            }
            else
            {
                nonProductiveScanDepth++;
            }
        }
        else
        {
            nonProductiveScanDepth++;
        }

        //
        // Get the previous order in the list.  We have to be careful
        // because we may have just removed the last item in the list, in
        // which case pTargetOrder will be NULL.
        //
        if (pTargetOrder == NULL)
        {
            pTargetOrder = COM_BasedListLast(&lpoaShared->orderListHead,
                FIELD_OFFSET(INT_ORDER, OrderHeader.list));
        }
        else
        {
            pTargetOrder = COM_BasedListPrev(&lpoaShared->orderListHead,
                pTargetOrder, FIELD_OFFSET(INT_ORDER, OrderHeader.list));
        }
    }

    DebugExitVOID(OADDSpoilFromOrder);
}



#ifdef DEBUG

//
// This is a DEBUG-only function that walks a double-linked list and verifies
// that it is sane.
//
// We walk the list front to back, ensuring that the next item of the
// current order is the same as the previous item of the next order.
//
// Then we walk the list back to front, ensuring that the previous item of
// the current order is the same as the next item of the previous order.
//
// At the same time, we sum up the total order and total heap bytes.  They
// should equal what's in the structure header.
//

void CheckOaHeap(LPOA_SHARED_DATA lpoaHeap)
{
    PBASEDLIST         pList;
    LPINT_ORDER     pNextPrev;
    LPINT_ORDER     pCur;
    LPINT_ORDER     pNext;

    if (!(g_trcConfig & ZONE_OAHEAPCHECK))
        return;

    //
    // Walk front to back
    //
    pList           = &lpoaHeap->orderListHead;

    pCur = COM_BasedListFirst(pList, FIELD_OFFSET(INT_ORDER, OrderHeader.list));
    while (pCur != NULL)
    {
        //
        // Get the next item
        //
        pNext = COM_BasedListNext(pList, pCur, FIELD_OFFSET(INT_ORDER, OrderHeader.list));

        //
        // Is the previous dude of the next the same as us?
        //
        if (pNext != NULL)
        {
            pNextPrev = COM_BasedListPrev(pList, pNext, FIELD_OFFSET(INT_ORDER, OrderHeader.list));

            ASSERT(pNextPrev == pCur);
        }

        pCur = pNext;
    }


    //
    // Walk back to front
    //
    pCur = COM_BasedListLast(pList, FIELD_OFFSET(INT_ORDER, OrderHeader.list));

    while (pCur != NULL)
    {
        //
        // Get the previous item
        //
        pNextPrev = COM_BasedListPrev(pList, pCur, FIELD_OFFSET(INT_ORDER, OrderHeader.list));

        //
        // Is the next dude of the previous the same as us?
        //
        if (pNextPrev != NULL)
        {
            pNext = COM_BasedListNext(pList, pNextPrev, FIELD_OFFSET(INT_ORDER, OrderHeader.list));

            ASSERT(pNext == pCur);
        }

        pCur = pNextPrev;
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\as16\osi.c ===
//
// OSI.C
// Operating System Independent DLL
//      * Graphical Output tracking (DDI hook/display driver)
//      * Window/Task tracking (Window hook)
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>

#include <version.h>
#include <ndcgver.h>



PALETTEENTRY CODESEG g_osiVgaPalette[16] =
{
    {0x00, 0x00, 0x00, 0x00},             // Black          0x00
    {0x80, 0x00, 0x00, 0x00},             // Dk Red         0x01
    {0x00, 0x80, 0x00, 0x00},             // Dk Green       0x02
    {0x80, 0x80, 0x00, 0x00},             // Dk Yellow      0x03
    {0x00, 0x00, 0x80, 0x00},             // Dk Blue        0x04
    {0x80, 0x00, 0x80, 0x00},             // Dk Purple      0x05
    {0x00, 0x80, 0x80, 0x00},             // Dk Teal        0x06
    {0xC0, 0xC0, 0xC0, 0x00},             //    Gray        0x07
    {0x80, 0x80, 0x80, 0x00},             // Dk Gray        0x08 or 0xF8
    {0xFF, 0x00, 0x00, 0x00},             //    Red         0x09 or 0xF9
    {0x00, 0xFF, 0x00, 0x00},             //    Green       0x0A or 0xFA
    {0xFF, 0xFF, 0x00, 0x00},             //    Yellow      0x0B or 0xFB
    {0x00, 0x00, 0xFF, 0x00},             //    Blue        0x0C or 0xFC
    {0xFF, 0x00, 0xFF, 0x00},             //    Purple      0x0D or 0xFD
    {0x00, 0xFF, 0xFF, 0x00},             //    Teal        0x0E or 0xFE
    {0xFF, 0xFF, 0xFF, 0x00}              //    White       0x0F or 0xFF
};



// --------------------------------------------------------------------------
//
//  DllEntryPoint
//
// --------------------------------------------------------------------------
BOOL WINAPI DllEntryPoint(DWORD dwReason, WORD hInst, WORD wDS,
    WORD wHeapSize, DWORD dwReserved1, WORD  wReserved2)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
            // First app pulled us in
            if (g_cProcesses++ == 0)
            {
                g_hInstAs16 = (HINSTANCE)hInst;
            }
            break;

        case DLL_PROCESS_DETACH:
            // Last app went away
            if (--g_cProcesses == 0)
            {
                // Clean up anything that got left around
                OSITerm16(TRUE);
            }
            break;
    }

    return(TRUE);
}



//
// OSILoad16
// Called on process attach of mnmcpi32.dll, to establish the flat thunks
// and return back our instance handle
//
void WINAPI OSILoad16
(
    LPDWORD     lpdwInstance
)
{
    DebugEntry(OSI_Load16);

    *lpdwInstance = (DWORD)(UINT)g_hInstAs16;

    DebugExitVOID(OSI_Load16);
}




// --------------------------------------------------------------------------
//
//  OSIInit16
//
//  Inits binary patcher, gdi + user patching, windows hooks, etc.
//
// --------------------------------------------------------------------------
BOOL WINAPI OSIInit16
(
    DWORD       version,
    HWND        hwndCore,
    ATOM        atomTrack,
    LPDWORD     ppSharedMem,
    LPDWORD     ppoaSharedMem,
    LPDWORD     ppimSharedMem,
    LPDWORD     lpsbcEnabled,
    LPDWORD     ppShuntBuffers,
    LPDWORD     pBitmasks
)
{
    BOOL    rc = FALSE;
    HGLOBAL hMem;
    HMODULE hModDisplay;

    DebugEntry(OSIInit16);

    //
    // Fill in our instance handle.  We always return this so the 32-bit
    // code can free our library after having loaded it.
    //
    *lpsbcEnabled = FALSE;

#ifdef DEBUG
    g_imSharedData.cbSize = sizeof(g_imSharedData);
#endif

    *ppimSharedMem = (DWORD)MapSL(&g_imSharedData);
    ASSERT(*ppimSharedMem);

    if (version != DCS_MAKE_VERSION())
    {
        ERROR_OUT(("OSIInit16: failing, version mismatch 0x%lx (core) 0x%lx (dd)",
            version, DCS_MAKE_VERSION()));
        DC_QUIT;
    }

    // ONLY ALLOW ONE CLIENT TO INITIALIZE
    if (g_asMainWindow != NULL)
    {
        WARNING_OUT(("OSIInit16: mnmas16.dll was left around last time"));

        // If this task is no longer valid, then cleanup for it
        if (IsWindow(g_asMainWindow))
        {
            //
            // Uh oh.  Somehow a previous version of NM is still around.  
            // Do the safest thing--refuse to share.
            //
            ERROR_OUT(("OSIInit16: Another version of NetMeeting is still running!"));
            DC_QUIT;
        }

        // Cleanup (this is similar to the NT dd code)
        OSITerm16(TRUE);
        ASSERT(!g_asMainWindow);
    }

    //
    // Clear out shared IM memory.
    //
    g_imSharedData.imSuspended  = FALSE;
    g_imSharedData.imControlled = FALSE;
    g_imSharedData.imPaused     = FALSE;
    g_imSharedData.imUnattended = FALSE;

    g_asMainWindow = hwndCore;
    ASSERT(g_asMainWindow);
    g_asHostProp   = atomTrack;
    ASSERT(g_asHostProp);
    g_hCoreTask = GetCurrentTask();

    g_osiDesktopWindow = GetDesktopWindow();
    ASSERT(g_osiDesktopWindow);

    //
    // DISPLAY DRIVER STUFF
    //
    hModDisplay = GetModuleHandle("DISPLAY");
    g_lpfnSetCursor = (SETCURSORPROC)GetProcAddress(hModDisplay,
            MAKEINTRESOURCE(ORD_OEMSETCURSOR));
    if (!hModDisplay || !g_lpfnSetCursor)
    {
        ERROR_OUT(("Couldn't find cursor entry points"));
        DC_QUIT;
    }

    // This doesn't always exist
    g_lpfnSaveBits = (SAVEBITSPROC)GetProcAddress(hModDisplay,
            MAKEINTRESOURCE(ORD_OEMSAVEBITS));

    //
    // KERNEL16 AND KERNEL32 STUFF
    //

    //
    // Get KRNL16's instance/module handle
    //
    g_hInstKrnl16 = LoadLibrary("KRNL386.EXE");
    ASSERT(g_hInstKrnl16);
    FreeLibrary(g_hInstKrnl16);

    g_hModKrnl16 = GetExePtr(g_hInstKrnl16);
    ASSERT(g_hModKrnl16);

    //
    // Get KERNEL32's instance/module handle
    //
    g_hInstKrnl32 = GetModuleHandle32("KERNEL32.DLL");
    ASSERT(g_hInstKrnl32);

    //
    // Get mapped 16-bit equivalent of KERNEL32's instance handle
    //
    g_hInstKrnl32MappedTo16 = MapInstance32(g_hInstKrnl32);
    ASSERT(g_hInstKrnl32MappedTo16);

    //
    // Get hold of MultiByteToWideChar() routine
    //
    g_lpfnAnsiToUni = (ANSITOUNIPROC)GetProcAddress32(g_hInstKrnl32,
        "MultiByteToWideChar");
    ASSERT(g_lpfnAnsiToUni);


    //
    // GDI16 AND GDI32 STUFF
    //

    //
    // Get GDI16's instance/module handle
    //
    g_hInstGdi16 = LoadLibrary("GDI.EXE");
    ASSERT(g_hInstGdi16);
    FreeLibrary(g_hInstGdi16);

    g_hModGdi16 = GetExePtr(g_hInstGdi16);
    ASSERT(g_hModGdi16);

    //
    // Get GDI32's instance/module handle
    //
    g_hInstGdi32 = GetModuleHandle32("GDI32.DLL");
    ASSERT(g_hInstGdi32);

    //
    // Get hold of GDI16 functions not exported but which are the target of 
    // public GDI32 functions via flat thunks
    //
    if (!GetGdi32OnlyExport("ExtTextOutW", 0, (FARPROC FAR*)&g_lpfnExtTextOutW)  ||
        !GetGdi32OnlyExport("TextOutW", 0, (FARPROC FAR*)&g_lpfnTextOutW) ||
        !GetGdi32OnlyExport("PolylineTo", 0, (FARPROC FAR*)&g_lpfnPolylineTo) ||
        !GetGdi32OnlyExport("PolyPolyline", 18, (FARPROC FAR*)&g_lpfnPolyPolyline))
    {
        ERROR_OUT(("Couldn't get hold of GDI32 routines"));
        DC_QUIT;
    }

    ASSERT(g_lpfnExtTextOutW);
    ASSERT(g_lpfnTextOutW);
    ASSERT(g_lpfnPolylineTo);
    ASSERT(g_lpfnPolyPolyline);


    //
    // USER16 and USER32 STUFF
    //

    //
    // Get USER16's instance/module handle
    //
    g_hInstUser16 = LoadLibrary("USER.EXE");
    ASSERT(g_hInstUser16);
    FreeLibrary(g_hInstUser16);

    g_hModUser16 = GetExePtr(g_hInstUser16);
    ASSERT(g_hModUser16);

    //
    // Get hold of USER32's instance handle. It has functions we
    // want to call which USER16 doesn't export.
    //
    g_hInstUser32 = GetModuleHandle32("USER32.DLL");
    ASSERT(g_hInstUser32);


    //
    // Get hold of USER16 functions not exported but which are the target of
    // public USER32 functions via flat thunks
    //
    if (!GetUser32OnlyExport("GetWindowThreadProcessId", (FARPROC FAR*)&g_lpfnGetWindowThreadProcessId))
    {
        ERROR_OUT(("Couldn't get hold of USER32 routines"));
        DC_QUIT;
    }

    ASSERT(g_lpfnGetWindowThreadProcessId);

    // 
    // This exists in Memphis but not Win95
    //
    g_lpfnCDSEx = (CDSEXPROC)GetProcAddress(g_hModUser16, "ChangeDisplaySettingsEx");


    //
    // Allocate the shared memory we use to communicate with the 32-bit
    // share core.
    //
    ASSERT(!g_asSharedMemory);
    ASSERT(!g_poaData[0]);
    ASSERT(!g_poaData[1]);

    //
    // Allocate our blocks GMEM_SHARE so we aren't bound by the vagaries
    // of process ownership.  We want our DLL to control them.  Note that
    // we do the same thing with GDI objects we create--our module owns the.
    //
    // We use GMEM_FIXED since we map these to flat addresses for mnmcpi32.dll,
    // and we don't want the linear address of these memory blocks to move
    // afterwards.
    //
    hMem = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT | GMEM_SHARE, sizeof(SHM_SHARED_MEMORY));
    g_asSharedMemory = MAKELP(hMem, 0);

    hMem = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT | GMEM_SHARE, sizeof(OA_SHARED_DATA));
    g_poaData[0] = MAKELP(hMem, 0);

    hMem =  GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT | GMEM_SHARE, sizeof(OA_SHARED_DATA));
    g_poaData[1] = MAKELP(hMem, 0);

    if (!g_asSharedMemory  ||
        !g_poaData[0] ||
        !g_poaData[1])
    {
        ERROR_OUT(("OSIInit16: couldn't allocate shared memory blocks"));
        DC_QUIT;
    }

    //
    // Get current screen attributes
    //

    g_oeStockPalette = GetStockObject(DEFAULT_PALETTE);

    g_osiScreenRect.left    = 0;
    g_osiScreenRect.top     = 0;
    g_osiScreenRect.right   = GetSystemMetrics(SM_CXSCREEN);
    g_osiScreenRect.bottom  = GetSystemMetrics(SM_CYSCREEN);

    g_osiScreenDC   = CreateDC("DISPLAY", 0L, 0L, 0L);
    g_osiMemoryDC   = CreateCompatibleDC(g_osiScreenDC);
    g_osiMemoryBMP  = CreateCompatibleBitmap(g_osiScreenDC, 1, 1);

    if (!g_osiScreenDC || !g_osiMemoryDC || !g_osiMemoryBMP)
    {
        ERROR_OUT(("Couldn't get screen dc"));
        DC_QUIT;
    }

    SetObjectOwner(g_osiScreenDC, g_hInstAs16);

    SetObjectOwner(g_osiMemoryDC, g_hInstAs16);

    SetObjectOwner(g_osiMemoryBMP, g_hInstAs16);
    MakeObjectPrivate(g_osiMemoryBMP, TRUE);

    g_osiScreenBitsPlane    = GetDeviceCaps(g_osiScreenDC, BITSPIXEL);
    g_osiScreenPlanes       = GetDeviceCaps(g_osiScreenDC, PLANES);
    g_osiScreenBPP          = (g_osiScreenBitsPlane * g_osiScreenPlanes);


    //
    // Get the color masks
    //

    g_osiScreenRedMask      = 0x000000FF;
    g_osiScreenGreenMask    = 0x0000FF00;
    g_osiScreenBlueMask     = 0x00FF0000;

    //
    // Only displays with more than 8bpp (palettized) might have color
    // masks.  Use our 1 pixel scratch bitmap to get them.
    //
    if (g_osiScreenBPP > 8)
    {
        DIB4    dib4T;

        //
        // Get the header
        //
        dib4T.bi.biSize = sizeof(BITMAPINFOHEADER);
        dib4T.bi.biBitCount = 0;
        GetDIBits(g_osiScreenDC, g_osiMemoryBMP, 0, 1, NULL, (LPBITMAPINFO)&dib4T.bi,
            DIB_RGB_COLORS);

        //
        // Get the mask
        //
        GetDIBits(g_osiScreenDC, g_osiMemoryBMP, 0, 1, NULL, (LPBITMAPINFO)&dib4T.bi,
            DIB_RGB_COLORS);

        if (dib4T.bi.biCompression == BI_BITFIELDS)
        {
            g_osiScreenRedMask = dib4T.ct[0];
            g_osiScreenGreenMask = dib4T.ct[1];
            g_osiScreenBlueMask = dib4T.ct[2];
        }
    }

    g_osiMemoryOld = SelectBitmap(g_osiMemoryDC, g_osiMemoryBMP);

    //
    // Initialize the bmiHeader so OEConvertColor() doesn't have to do it
    // over and over, when the header isn't touched by GDI.
    //
    g_osiScreenBMI.bmiHeader.biSize     = sizeof(BITMAPINFOHEADER);
    g_osiScreenBMI.bmiHeader.biPlanes   = 1;
    g_osiScreenBMI.bmiHeader.biBitCount = g_osiScreenBPP;
    g_osiScreenBMI.bmiHeader.biCompression  = BI_RGB;
    g_osiScreenBMI.bmiHeader.biSizeImage    = 0;
    g_osiScreenBMI.bmiHeader.biXPelsPerMeter = 1000;
    g_osiScreenBMI.bmiHeader.biYPelsPerMeter = 1000;
    g_osiScreenBMI.bmiHeader.biClrUsed  = 0;
    g_osiScreenBMI.bmiHeader.biClrImportant = 0;
    g_osiScreenBMI.bmiHeader.biWidth    = 1;
    g_osiScreenBMI.bmiHeader.biHeight   = 1;


    //
    // Init the various display driver components
    //
    BA_DDInit();

    if (!CM_DDInit(g_osiScreenDC))
    {
        ERROR_OUT(("CM failed to init"));
        DC_QUIT;
    }

    if (!SSI_DDInit())
    {
        ERROR_OUT(("SSI failed to init"));
        DC_QUIT;
    }

    if (!OE_DDInit())
    {
        ERROR_OUT(("OE failed to init"));
        DC_QUIT;
    }

    if (!IM_DDInit())
    {
        ERROR_OUT(("IM failed to init"));
        DC_QUIT;
    }

    if (!HET_DDInit())
    {
        ERROR_OUT(("HET failed to init"));
        DC_QUIT;
    }

    //
    // If we're here, all succeeded initializing
    //
    //
    // Map ptrs to flat addresses so they can be used in 32-bit code.  This
    // can't fail unless kernel is so messed up Windows is about to keel
    // over and die.
    //
    ASSERT(ppSharedMem);
    *ppSharedMem  = (DWORD)MapSL(g_asSharedMemory);
    ASSERT(*ppSharedMem);
    
    ASSERT(ppoaSharedMem);
    ppoaSharedMem[0] = (DWORD)MapSL(g_poaData[0]);
    ASSERT(ppoaSharedMem[0]);

    ppoaSharedMem[1] = (DWORD)MapSL(g_poaData[1]);
    ASSERT(ppoaSharedMem[1]);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(OSIInit16, rc);
    return(rc);
}


// --------------------------------------------------------------------------
//
//  OSITerm16
//  Cleans up binary patcher, gdi + user patching, windows hooks, etc.
//
//  We do this on normal OSI stop, and on catastrophic failure.
//
// --------------------------------------------------------------------------
void WINAPI OSITerm16(BOOL fUnloading)
{
    DebugEntry(OSITerm16);

    if (!g_hCoreTask)
    {
        // Nothing to cleanup.
        DC_QUIT;
    }

    //
    // Is the task that actually caused us to allocate our resources?  In
    // other words, we don't want to clean up if
    //      App A loads mnmas16.dll, and gets it inited
    //      App B somehow starts up, loads mnmas16.dll, but mnmas16.dll
    //          doesn't init for sharing because cProcesses is > 1
    //      App B shuts down
    //      App B calls OSITerm16
    //
    // So in the 'dll is really about to go away case', we always cleanup.
    // But in normal term of sharing, we cleanup if the current task is the
    // current one.
    //
    if (fUnloading || (g_hCoreTask == GetCurrentTask()))
    {
        //
        // Term other pieces that depend on layout of shared memory
        //
        HET_DDTerm();

        IM_DDTerm();

        OE_DDTerm();

        SSI_DDTerm();

        CM_DDTerm();

        //
        // Free memory blocks
        //

        if (g_poaData[1])
        {
            GlobalFree((HGLOBAL)SELECTOROF(g_poaData[1]));
            g_poaData[1] = NULL;
        }

        if (g_poaData[0])
        {
            GlobalFree((HGLOBAL)SELECTOROF(g_poaData[0]));
            g_poaData[0] = NULL;
        }

        if (g_asSharedMemory)
        {
            GlobalFree((HGLOBAL)SELECTOROF(g_asSharedMemory));
            g_asSharedMemory = NULL;
        }

        if (g_osiMemoryOld)
        {
            SelectBitmap(g_osiMemoryDC, g_osiMemoryOld);
            g_osiMemoryOld = NULL;
        }

        if (g_osiMemoryBMP)
        {
            SysDeleteObject(g_osiMemoryBMP);
            g_osiMemoryBMP = NULL;
        }

        if (g_osiMemoryDC)
        {
            DeleteDC(g_osiMemoryDC);
            g_osiMemoryDC = NULL;
        }

        if (g_osiScreenDC)
        {
            DeleteDC(g_osiScreenDC);
            g_osiScreenDC = NULL;
        }

        g_asMainWindow = NULL;
        g_asHostProp = 0;
        g_hCoreTask = NULL;
    }

DC_EXIT_POINT:
    DebugExitVOID(OSITerm16);
}



// --------------------------------------------------------------------------
//
//  OSIFunctionRequest16
//
//  Communication function with 32-bit MNMCPI32.DLL
//
// --------------------------------------------------------------------------
BOOL WINAPI OSIFunctionRequest16(DWORD fnEscape, LPOSI_ESCAPE_HEADER lpOsiEsc,
    DWORD   cbEscInfo)
{

    BOOL    rc = FALSE;

    DebugEntry(OSIFunctionRequest16);

    //
    // Check the data is long enough to store our standard escape header.
    // If it is not big enough this must be an escape request for another
    // driver.
    //
    if (cbEscInfo < sizeof(OSI_ESCAPE_HEADER))
    {
        ERROR_OUT(("Escape block not big enough"));
        DC_QUIT;
    }

    //
    // Check for our escape ID.  If it is not our escape ID this must be an
    // escape request for another driver.
    //
    if (lpOsiEsc->identifier != OSI_ESCAPE_IDENTIFIER)
    {
        ERROR_OUT(("Bogus Escape header ID"));
        DC_QUIT;
    }
    else if (lpOsiEsc->version != DCS_MAKE_VERSION())
    {
        ERROR_OUT(("Mismatched display driver and NetMeeting"));
        DC_QUIT;
    }


    if ((fnEscape >= OSI_ESC_FIRST) && (fnEscape <= OSI_ESC_LAST))
    {
        rc = OSI_DDProcessRequest((UINT)fnEscape, lpOsiEsc, cbEscInfo);
    }
    else if ((fnEscape >= OSI_OE_ESC_FIRST) && (fnEscape <= OSI_OE_ESC_LAST))
    {
        rc = OE_DDProcessRequest((UINT)fnEscape, lpOsiEsc, cbEscInfo);
    }
    else if ((fnEscape >= OSI_HET_ESC_FIRST) && (fnEscape <= OSI_HET_ESC_LAST))
    {
        rc = HET_DDProcessRequest((UINT)fnEscape, lpOsiEsc, cbEscInfo);
    }
    else if ((fnEscape >= OSI_SBC_ESC_FIRST) && (fnEscape <= OSI_SBC_ESC_LAST))
    {
        // Do nothing
    }
    else if ((fnEscape >= OSI_SSI_ESC_FIRST) && (fnEscape <= OSI_SSI_ESC_LAST))
    {
        rc = SSI_DDProcessRequest((UINT)fnEscape, lpOsiEsc, cbEscInfo);
    }
    else if ((fnEscape >= OSI_CM_ESC_FIRST) && (fnEscape <= OSI_CM_ESC_LAST))
    {
        rc = CM_DDProcessRequest((UINT)fnEscape, lpOsiEsc, cbEscInfo);
    }
    else if ((fnEscape >= OSI_OA_ESC_FIRST) && (fnEscape <= OSI_OA_ESC_LAST))
    {
        rc = OA_DDProcessRequest((UINT)fnEscape, lpOsiEsc, cbEscInfo);
    }
    else if ((fnEscape >= OSI_BA_ESC_FIRST) && (fnEscape <= OSI_BA_ESC_LAST))
    {
        rc = BA_DDProcessRequest((UINT)fnEscape, lpOsiEsc, cbEscInfo);
    }
    else if ((fnEscape >= OSI_HET_WO_ESC_FIRST) && (fnEscape <= OSI_HET_WO_ESC_LAST))
    {
        rc = HET_DDProcessRequest((UINT)fnEscape, lpOsiEsc, cbEscInfo);
    }
    else
    {
        ERROR_OUT(("Unknown function request"));
    }

DC_EXIT_POINT:
    DebugExitBOOL(OSIFunctionRequest16, rc);
    return(rc);
}



//
// OSI_DDProcessRequest()
// Handles OSI generic escapes
//
BOOL OSI_DDProcessRequest
(
    UINT    fnEscape,
    LPOSI_ESCAPE_HEADER pResult,
    DWORD   cbResult
)
{
    BOOL    rc;

    DebugEntry(OSI_DDProcessRequest);

    switch (fnEscape)
    {
        case OSI_ESC_SYNC_NOW:
        {
            ASSERT(cbResult == sizeof(OSI_ESCAPE_HEADER));

            //
            // Resync with the 32-bit ring 3 core.  This happens when
            // somebody joins or leaves a share.
            //
            BA_ResetBounds();
            OA_DDSyncUpdatesNow();
            rc = TRUE;

        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized OSI escape"));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(OSI_DDProcessRequest, rc);
    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\as16\sbc.c ===
//
// SBC.C
// Sent Bitmap Cache
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>



//
// SBC_DDProcessRequest()
// Handle SBC escapes
//
BOOL SBC_DDProcessRequest
(
    UINT        fnEscape,
    LPOSI_ESCAPE_HEADER pResult,
    DWORD       cbResult
)
{
    BOOL        rc;

    DebugEntry(SBC_DDProcessRequest);

    switch (fnEscape)
    {
        case SBC_ESC_NEW_CAPABILITIES:
        {
            TRACE_OUT(("SBC_ESC_NEW_CAPABILITIES"));

            ASSERT(cbResult == sizeof(SBC_NEW_CAPABILITIES));

#if 0
            SBCDDSetNewCapabilities((LPSBC_NEW_CAPABILITIES)pResult);
#endif

            rc = TRUE;
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized SBC_ escape"));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(SBC_DDProcessRequest, rc);
    return(rc);
}



#if 0
//
// FUNCTION:    SBCDDSetNewCapabilities
//
// DESCRIPTION:
//
// Set the new SBC related capabilities
//
// RETURNS:
//
// NONE
//
// PARAMETERS:
//
// pDataIn  - pointer to the input buffer
//
//
void SBCDDSetNewCapabilities(LPSBC_NEW_CAPABILITIES pCapabilities)
{
    DebugEntry(SBCSetNewCapabilities);

    //
    // Copy the data from the Share Core.
    //
    g_sbcSendingBPP     = pCapabilities->sendingBpp;

    hmemcpy(&g_sbcCacheInfo, pCapabilities->cacheInfo, sizeof(g_sbcCacheInfo));


    DebugExitVOID(SBCSetNewCapabilities);
}
#endif




//
// SBC_DDInit()
//
BOOL SBC_DDInit
(
    HDC     hdcScreen,
    LPDWORD ppShuntBuffers,
    LPDWORD pBitmasks
)
{
    UINT    i;
    BOOL    rc = FALSE;

    DebugEntry(SBC_DDInit);

#if 0
    for (i = 0; i < SBC_NUM_TILE_SIZES; i++)
    {
        ASSERT(!g_sbcWorkInfo[i].pShuntBuffer);
        ASSERT(!g_sbcWorkInfo[i].mruIndex);
        ASSERT(!g_sbcWorkInfo[i].workBitmap);

        if (i == SBC_SMALL_TILE_INDEX)
        {
            g_sbcWorkInfo[SBC_SMALL_TILE_INDEX].tileWidth = SBC_SMALL_TILE_WIDTH;
            g_sbcWorkInfo[SBC_SMALL_TILE_INDEX].tileHeight = SBC_SMALL_TILE_HEIGHT;
        }
        else
        {
            ASSERT(i == SBC_LARGE_TILE_INDEX);

            g_sbcWorkInfo[SBC_LARGE_TILE_INDEX].tileWidth = SBC_LARGE_TILE_WIDTH;
            g_sbcWorkInfo[SBC_LARGE_TILE_INDEX].tileHeight = SBC_LARGE_TILE_HEIGHT;
        }

        g_sbcWorkInfo[i].workBitmap = CreateCompatibleBitmap(hdcScreen,
            g_sbcWorkInfo[i].tileWidth, g_sbcWorkInfo[i].tileHeight);

        if (! g_sbcWorkInfo[i].workBitmap)
        {
            ERROR_OUT(("Failed to create work bitmap %d", i));
            DC_QUIT;
        }

        SetObjectOwner(g_sbcWorkInfo[i].workBitmap, g_hInstAs16);
        MakeObjectPrivate(g_sbcWorkInfo[i].workBitmap, TRUE);
    }

    //
    // Initialize the shunt buffers
    //
    if (! SBCDDCreateShuntBuffers())
        DC_QUIT;

    //
    // We've created our SBC cache.  Fill in the details
    //
    for (i = 0; i < SBC_NUM_TILE_SIZES; i++)
    {
        ppShuntBuffers[i] = (DWORD)MapSL(g_sbcWorkInfo[i].pShuntBuffer);
        ASSERT(ppShuntBuffers[i]);
    }

    pBitmasks[0] = g_osiScreenRedMask;
    pBitmasks[1] = g_osiScreenGreenMask;
    pBitmasks[2] = g_osiScreenBlueMask;

    g_sbcPaletteChanged = TRUE;

    rc = TRUE;

DC_EXIT_POINT:

#endif

    DebugExitBOOL(SBC_DDInit, rc);
    return(rc);
}



//
// SBC_DDTerm()
//
void SBC_DDTerm(void)
{
    UINT    i;

    DebugEntry(SBC_DDTerm);

#if 0
    //
    // Clear out our array and free the shunt buffer memory.
    //
    for (i = 0 ; i < SBC_NUM_TILE_SIZES ; i++)
    {
        // Kill the bitmap if we there
        if (g_sbcWorkInfo[i].workBitmap)
        {
            SysDeleteObject(g_sbcWorkInfo[i].workBitmap);
            g_sbcWorkInfo[i].workBitmap = NULL;
        }

        if (g_sbcWorkInfo[i].pShuntBuffer)
        {
            GlobalFree((HGLOBAL)SELECTOROF(g_sbcWorkInfo[i].pShuntBuffer));
            g_sbcWorkInfo[i].pShuntBuffer = NULL;
        }

        g_sbcWorkInfo[i].mruIndex        = 0;
    }
#endif

    DebugExitVOID(SBC_DDTerm);
}



#if 0

//
// SBC_DDTossFromCache()
// This throws away a bitmap if we'd cached it, which happens when the
// contents change.
//
void SBC_DDTossFromCache
(
    HBITMAP hbmp
)
{
    DebugEntry(SBC_DDTossFromCache);

    DebugExitVOID(SBC_DDTossFromCache);
}



//
//
// SBC_DDIsMemScreenBltCachable() - see sbc.h
//
//
BOOL SBC_DDIsMemScreenBltCachable
(
    UINT        type,
    HDC         hdcSrc,
    HBITMAP     hbmpSrc,
    UINT        cxSubWidth,
    UINT        cySubHeight,
    HDC         hdcDst,
    LPBITMAPINFO    lpbmi
)
{
    BOOL        rc = FALSE;
    UINT        srcBpp;
    UINT        tileWidth;
    UINT        tileHeight;
    BITMAP      bmpDetails;
    int         bmpWidth;
    int         bmpHeight;

    DebugEntry(SBC_DDIsMemScreenBltCachable);


    ASSERT((type == LOWORD(ORD_MEMBLT)) || (type == LOWORD(ORD_MEM3BLT)));

    if (g_sbcSendingBPP > 8)
    {
        TRACE_OUT(( "Unsupported sending bpp %d", g_sbcSendingBPP));
        DC_QUIT;
    }

    //
    // If this is a thrasher then don't cache it
    //
    if (!SBCBitmapCacheAllowed(hbmp))
    {
        TRACE_OUT(( "Its a thrasher"));
        DC_QUIT;
    }

    //
    // Ensure we're not in full screen mode.
    //
    if (g_asShared->fullScreen)
    {
        TRACE_OUT(("Not caching SBC; full screen active"));
        DC_QUIT;
    }

    if (hdcSrc && (GetMapMode(hdcSrc) != MM_TEXT))
    {
        TRACE_OUT(("Not caching SBC; source map mode not MM_TEXT"));
        DC_QUIT;
    }

    if (!hbmp)
    {
        //
        // We don't cache compressed DIB and DIB section bitmaps
        //
        if (lpbi->bmiHeader.biCompression != BI_RGB)
            DC_QUIT;

        bmpWidth = lpbi->bmiHeader.biWidth;
        bmpHeight = lpbi->bmiHeader.biHeight;
        srcBpp = lpbi->bmiHeader.biPlanes * lpbi->bmiHeader.biBitCount;
    }
    else
    {
        if (!GetObject(hbmp, sizeof(bmpDetails), &bmpDetails))
        {
            ERROR_OUT(("Can't get source info"));
            DC_QUIT;
        }

        srcBpp = bmpDetails.bmBitsPixel * bmpDetails.bmPlanes;
        bmpWidth = bmpDetails.bmWidth;
        bmpHeight = bmpDetails.bmHeight;
    }

    //
    // Oprah394
    //
    // This function is much too ready to take on work, even when it would
    // mean bogging down the host with unnecessary caching work.  We
    // have no way to determine when an app is doing animation save to
    // reject cache requests when the rate looks to be too high.
    //
    // This function is called for complete source bitmaps before tiling
    // so we do not need to worry about confusing tiling with animation.
    // The CacheRequests count is decayed in SBC_Periodic
    //
    //
    // MNM0063 - Oprah 394 revisited
    //
    // If we decide here that we are doing animation, we set the
    // sbcAnimating flag for the benefit of other parts of the code.  In
    // particular, we use this to suppress the comparison of before and
    // after states of the screen during a BitBlt operation
    //
    //
    if ((cxSubBitmapWidth  != bmpWidth) ||
        (cySubBitmapHeight != bmpHeight))
    {
        TRACE_OUT(("Partial blit - check for slideshow effects"));
        g_sbcBltRate++;
        if (g_sbcBltRate > SBC_CACHE_DISABLE_RATE)
        {
            TRACE_OUT(("Excessive cache rate %d - disabled", g_sbcBltRate));
            g_sbcAnimating = TRUE;
            DC_QUIT;
        }
    }
    //
    // MNM63: if we get here, we will assume we're not animating
    //
    g_sbcAnimating = FALSE;

    //
    // If the bitmap is 1bpp and the colors are not default then we don't
    // cache it (all bitmaps are cached in glorious technicolor!)
    //
    if ( (srcBpp == 1) &&
         ( (g_oeState.lpdc->DrawMode.bkColorL != DEFAULT_BG_COLOR) ||
           (g_oeState.lpdc->DrawMode.txColorL != DEFAULT_FG_COLOR) ||
           (type == LOWORD(ORD_MEM3BLT))) )
    {
        TRACE_OUT(("Didn't cache mono bitmap with non-default colors"));
        DC_QUIT;
    }

    //
    // Check that the cache will accept tiles
    //
    if (!SBC_DDQueryBitmapTileSize(bmpWidth,
                                 bmpHeight,
                                 &tileWidth,
                                 &tileHeight))
    {
        TRACE()"Cache does not support tiling"));
        DC_QUIT;
    }

    //
    // We are ready to go ahead with the caching!
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SBC_DDIsMemScreenBltCachable, rc);
    return(rc);
}


//
//
// SBC_DDCacheMemScreenBlt() - see sbc.h
//
//
BOOL SBC_DDCacheMemScreenBlt
(
    LPINT_ORDER                 pOrder,
    LPMEMBLT_ORDER_EXTRA_INFO   lpMemBltInfo,
    HDC                         hdcDst
)
{
    BOOL                rc = FALSE;
    LPMEMBLT_ORDER      pMemBltOrder = (LPMEMBLT_ORDER)&(pOrder->abOrderData);
    LPMEM3BLT_ORDER     pMem3BltOrder = (LPMEM3BLT_ORDER)pMemBltOrder;
    HBITMAP             hBitmap;
    HDC                 hdcSrc;
    UINT                iCache;
    UINT                iCacheEntry;
    UINT                iColorTable;
    UINT                type;
    LPINT               pXSrc;
    LPINT               pYSrc;
    UINT                srcBpp;
    BITMAP              bmpDetails;
    UINT                bmpWidth;
    UINT                bmpHeight;
    UINT                tileWidth;
    UINT                tileHeight;
    POINT               tileOrg;
    UINT                cxSubBitmapWidth;
    UINT                cySubBitmapHeight;
    LPBYTE              pWorkBits;
    RECT                destRect;
    POINT               sourcePt;
    int                 tileSize;
    LPSBC_TILE_DATA     pTileData = NULL;

    DebugEntry(SBC_DDCacheMemScreenBlt);

    //
    // Do a first pass on the cacheability of the Blt
    //
    if (!SBC_DDIsMemScreenBltCachable(lpMemBltInfo))
    {
        TRACE_OUT(( "This MemBlt Order is not cachable"));
        DC_QUIT;
    }

    //
    // Get the width and height of the source bitmap
    //
    pSourceSurf = pMemBltInfo->pSource;
    bmpWidth    = pSourceSurf->sizlBitmap.cx;
    bmpHeight   = pSourceSurf->sizlBitmap.cy;

    //
    // Calculate the tile size for this blit
    //
    if (!SBC_DDQueryBitmapTileSize(bmpWidth,
                                   bmpHeight,
                                   &tileWidth,
                                   &tileHeight))
    {
        TRACE_OUT(( "Cache does not support tiling"));
        DC_QUIT;
    }

    //
    // Set up pointers to the source coordinates in the order.
    //
    type = pMemBltOrder->type;
    if (type == ORD_MEMBLT_TYPE)
    {
        sourcePt.x = pMemBltOrder->nXSrc;
        sourcePt.y = pMemBltOrder->nYSrc;
        TRACE_OUT((
              "Request to cache MemBlt (%d, %d), %d x %d -> (%d, %d), src %x",
                 sourcePt.x,
                 sourcePt.y,
                 pMemBltOrder->nWidth,
                 pMemBltOrder->nHeight,
                 pMemBltOrder->nLeftRect,
                 pMemBltOrder->nTopRect,
                 pSourceSurf->hsurf));
    }
    else
    {
        sourcePt.x = pMem3BltOrder->nXSrc;
        sourcePt.y = pMem3BltOrder->nYSrc;
        TRACE_OUT((
             "Request to cache Mem3Blt (%d, %d), %d x %d -> (%d, %d), src %x",
                 sourcePt.x,
                 sourcePt.y,
                 pMem3BltOrder->nWidth,
                 pMem3BltOrder->nHeight,
                 pMem3BltOrder->nLeftRect,
                 pMem3BltOrder->nTopRect,
                 pSourceSurf->hsurf));
    }

    //
    // Calculate the tile origin and size of remaining bitmap.  Origin is
    // rounded down to the nearest tile.  Actual size of bitmap to cache
    // may be smaller than tile size if the tile runs off the right/bottom
    // of the bitmap
    //
    tileOrg.x = sourcePt.x - (sourcePt.x % tileWidth);
    tileOrg.y = sourcePt.y - (sourcePt.y % tileHeight);

    //
    // Actual size of bitmap to cache may be smaller than tile size if the
    // tile runs off the right/bottom of the bitmap. To see why this
    // calculation is correct, realize that (bmpWidth - tileOrg.x) is the
    // remaining width of the bitmap after the start of this tile.
    //
    cxSubBitmapWidth  = min(tileWidth, bmpWidth - tileOrg.x);
    cySubBitmapHeight = min(tileHeight, bmpHeight - tileOrg.y);

    //
    // We know how large a tile we have - we now have to Blt it into one of
    // our work bitmaps and pass it up to the share core.  First, work out
    // which of our work bitmaps we should use and set up some variables
    // based on this.
    //
    for (tileSize=0 ; tileSize<SBC_NUM_TILE_SIZES ; tileSize++)
    {
        if ((cxSubBitmapWidth <= g_sbcWorkInfo[tileSize].tileWidth) &&
            (cySubBitmapHeight <= g_sbcWorkInfo[tileSize].tileHeight))
        {
            break;
        }
    }

    if (tileSize == SBC_NUM_TILE_SIZES)
    {
        ERROR_OUT(( "%d x %d tile doesn't fit into work bmp",
                     cxSubBitmapWidth,
                     cySubBitmapHeight));
        DC_QUIT;
    }

    //
    // Before doing any more work, get the next free entry in the shunt
    // buffer.  Note that this fills in the tileId element of the returned
    // structure.
    //
    // It is perfectly valid for this call to fail.  The shunt buffer may
    // just be full if we are sending lots of bitmap data up to the share
    // core.
    //
    if (!SBCDDGetNextFreeTile(tileSize, &pTileData))
    {
        TRACE_OUT(( "Unable to get a free tile in shunt buffer"));
        DC_QUIT;
    }

    //
    // Lock the work bitmap to get a surface to pass to EngBitBlt
    //
    pWorkSurf = EngLockSurface((HSURF)g_sbcWorkInfo[tileSize].workBitmap);
    if (pWorkSurf == NULL)
    {
        ERROR_OUT(( "Failed to lock work surface"));
        DC_QUIT;
    }
    TRACE_OUT(( "Locked surface"));

    //
    // Do the Blt to our work bitmap to get the bits at native bpp, and
    // using the color table which we sent to the share core.
    //
    destRectl.top    = 0;
    destRectl.left   = 0;
    destRectl.right  = cxSubBitmapWidth;
    destRectl.bottom = cySubBitmapHeight;

    sourcePt = tileOrg;

    if (!EngBitBlt(pWorkSurf,
                   pSourceSurf,
                   NULL,                    // mask surface
                   NULL,                    // clip object
                   pMemBltInfo->pXlateObj,
                   &destRectl,
                   &sourcePt,
                   NULL,                    // mask origin
                   NULL,                    // brush
                   NULL,                    // brush origin
                   0xcccc))                 // SRCCPY
    {
        ERROR_OUT(( "Failed to Blt to work bitmap"));
        DC_QUIT;
    }
    TRACE_OUT(( "Completed BitBlt"));

    //
    // The Blt succeeded, so pass the bits to the share core by copying
    // them into the correct shunt buffer.
    //
    // bytesUsed is set to the number of bytes required for
    // cySubBitmapHeight number of full scanlines in the shunt buffer tile
    // (NOT the number of bytes available in the tile, or the number of
    // bytes of data which was actually Blted)
    //
    // major/minorCacheInfo are set to details from the source surface.
    // hdev does not change on consecutive Blts from the same surface, but
    // iUniq may.
    //
    pDestSurf            = pMemBltInfo->pDest;
    pDestDev             = (LPOSI_PDEV)pDestSurf->dhpdev;
    pTileData->bytesUsed = BYTES_IN_BITMAP(g_sbcWorkInfo[tileSize].tileWidth,
                                           cySubBitmapHeight,
                                           pDestDev->cBitsPerPel);
    pTileData->srcX           = (TSHR_UINT16)sourcePt.x;
    pTileData->srcY           = (TSHR_UINT16)sourcePt.y;
    pTileData->width          = cxSubBitmapWidth;
    pTileData->height         = cySubBitmapHeight;
    pTileData->tilingWidth    = tileWidth;
    pTileData->tilingHeight   = tileHeight;
    pTileData->majorCacheInfo = (UINT)pSourceSurf->hsurf;
    pTileData->minorCacheInfo = (UINT)pSourceSurf->iUniq;
    pTileData->majorPalette   = (UINT)pMemBltInfo->pXlateObj;
    pTileData->minorPalette   = (UINT)(pMemBltInfo->pXlateObj != NULL ?
                                           pMemBltInfo->pXlateObj->iUniq : 0);

    //
    // If the source surface has the BMF_DONTCACHE flag set then it is a
    // DIB Section.  This means that an app can change the bits in the
    // surface without calling GDI, and hence without the iUniq value being
    // updated.
    //
    // We rely on iUniq changing for the fast path to work, so we must
    // exclude these bitmaps from the fast path.  Do this by resetting the
    // majorCacheInfo field (we use this rather than minorCacheInfo because
    // we can't tell what an invalid iUniq value is).
    //
    if ( (pSourceSurf->iType == STYPE_BITMAP) &&
         ((pSourceSurf->fjBitmap & BMF_DONTCACHE) != 0) )
    {
        TRACE_OUT(( "Source hsurf %#.8lx has BMF_DONTCACHE set",
                     pTileData->majorCacheInfo));
        pTileData->majorCacheInfo = SBC_DONT_FASTPATH;
    }

    //
    // Note that this only works correctly because we create our work
    // bitmaps to be "top down" rather than the default of "bottom up".
    // i.e.  the data for the top scanline is first in memory, so we can
    // start copying from the start of the bit data.  Bottom up would mean
    // working out an offset into the work bitmap to start copying from.
    //
    memcpy(pTileData->bitData, pWorkSurf->pvBits, pTileData->bytesUsed);

    //
    // We've done the copy.  Reset the work bitmap bits for next time we
    // use this work bitmap - this helps with compression later on.
    //
    memset(pWorkSurf->pvBits, 0, pWorkSurf->cjBits);

    //
    // Fill in the required info in the Mem(3)Blt order.
    //
    if (type == ORD_MEMBLT_TYPE)
    {
        pMemBltOrder->cacheId = pTileData->tileId;
    }
    else
    {
        pMem3BltOrder->cacheId = pTileData->tileId;
    }

    //
    // We've filled in all the data in the shunt buffer entry, so mark it
    // as in use so that the share core can access it.
    //
    pTileData->inUse = TRUE;

    //
    // Must have completed successfully to get to here
    //
    TRACE_OUT(( "Queued tile (%d, %d), %d x %d, tile %d x %d, Id %hx",
                 sourcePt.x,
                 sourcePt.y,
                 cxSubBitmapWidth,
                 cySubBitmapHeight,
                 g_sbcWorkInfo[tileSize].tileWidth,
                 g_sbcWorkInfo[tileSize].tileHeight,
                 pTileData->tileId));
    rc = TRUE;

DC_EXIT_POINT:

    //
    // Unlock the work surface (if required)
    //
    if (pWorkSurf != NULL)
    {
        EngUnlockSurface(pWorkSurf);
        TRACE_OUT(( "Unlocked surface"));
    }

    DebugExitDWORD(SBC_DDCacheMemScreenBlt, rc);
    return(rc);

    //
    // If the data flow rate is high enough then we don't bother with
    // any bitmap caching.  This allows the host to run at its maximum
    // speed at all times, which gives us the maximum amount of spoiling
    // and responsiveness.
    //
    if (!usrCacheBitmaps)
    {
        DC_QUIT;
    }

    //
    // Bitmap caching is only supported for 4bpp and 8bpp protocols.  If we
    // switch the sending bpp during a share it does not matter because we
    // are controlling the remote bitmap caches.
    //
    if ((usrSendingbpp != 4) &&
        (usrSendingbpp != 8))
    {
        DC_QUIT;
    }

    //
    // Extract the src DC handle from the Order Header.
    //
    hdcSrc = pOrder->OrderHeader.memBltInfo.hdcSrc;

    //
    // If the mapping mode of the src DC is anything other that MM_TEXT
    // (the default) then we don't cache the bitmap.
    // We are aiming to cache icons and buttons and these will normally
    // be drawn using MM_TEXT mapping mode. Therefore if the mode is
    // anything other than MM_TEXT we can assume something more complex
    // is going on and we probably don't want to cache it anyway.
    //
    if ((hdcSrc != NULL) && (GetMapMode(hdcSrc) != MM_TEXT))
    {
        TRACE()"Didn't cache blt using complex mapping mode"));
        DC_QUIT;
    }

    //
    // Extract the src bitmap handle from the Order.
    //
    type = ((LPMEMBLT_ORDER)&pOrder->abOrderData)->type;
    if (type == LOWORD(ORD_MEMBLT))
    {
        hBitmap = (HBITMAP)((LPMEMBLT_ORDER)&pOrder->abOrderData)->hBitmap;
    }
    else
    {
        hBitmap = (HBITMAP)((LPMEM3BLT_ORDER)&pOrder->abOrderData)->hBitmap;
    }
    TRACE_DBG()"hBitmap %x", hBitmap));

    //
    // If this is a thrasher then don't cache it
    //
    if (!SBCBitmapCacheAllowed(hBitmap))
    {
        TRACE()"Its a thrasher!"));
        DC_QUIT;
    }

    //
    // Fetch the bitmap details.  If the bitmap is 1bpp and the colors are
    // not default then we don't cache it (all bitmaps are cached in
    // glorious technicolor!)
    //
    if (hBitmap == NULL)
    {
        bmpWidth  = (TSHR_INT16)pOrder->OrderHeader.memBltInfo.lpbmi->
                                                            bmiHeader.biWidth;
        bmpHeight = (TSHR_INT)pOrder->OrderHeader.memBltInfo.lpbmi->
                                                           bmiHeader.biHeight;
        srcBpp = pOrder->OrderHeader.memBltInfo.lpbmi->bmiHeader.biPlanes *
                 pOrder->OrderHeader.memBltInfo.lpbmi->bmiHeader.biBitCount;
    }
    else
    {
        if (GetObject(hBitmap, sizeof(BITMAP), &bmpDetails))
        {
            srcBpp = bmpDetails.bmBitsPixel * bmpDetails.bmPlanes;
            bmpWidth = bmpDetails.bmWidth;
            bmpHeight = bmpDetails.bmHeight;
        }
        else
        {
            TRACE_ERR()"Failed to get bmp details (%x)", (TSHR_UINT16)hBitmap));
            DC_QUIT;
        }
    }

    if ( (srcBpp == 1) &&
         ( (GetBkColor(hdcDst) != DEFAULT_BG_COLOR) ||
           (GetTextColor(hdcDst) != DEFAULT_FG_COLOR) ||
           (type == LOWORD(ORD_MEM3BLT))) )
    {
        TRACE()"Didn't cache mono bitmap with non-default colors"));
        DC_QUIT;
    }

    //
    // Set up pointers to the source coordinates in the order.
    //
    if ( type == LOWORD(ORD_MEMBLT) )
    {
        pXSrc = &((LPMEMBLT_ORDER)&(pOrder->abOrderData))->nXSrc;
        pYSrc = &((LPMEMBLT_ORDER)&(pOrder->abOrderData))->nYSrc;
    }
    else
    {
        pXSrc = &((LPMEM3BLT_ORDER)&(pOrder->abOrderData))->nXSrc;
        pYSrc = &((LPMEM3BLT_ORDER)&(pOrder->abOrderData))->nYSrc;
    }

    //
    // Calculate the tile size for this blit
    //
    if (!SBC_QueryBitmapTileSize(bmpWidth,
                                 bmpHeight,
                                 &tileWidth,
                                 &tileHeight))
    {
        TRACE()"Cache does not support tiling"));
        DC_QUIT;
    }

    //
    // Calculate the tile origin and size of remaining bitmap.  Origin is
    // rounded down to the nearest tile.  Actual size of bitmap to cache
    // may be smaller than tile size if the tile runs off the right/bottom
    // of the bitmap
    //
    tileOrg.x = *pXSrc - (*pXSrc % tileWidth);
    tileOrg.y = *pYSrc - (*pYSrc % tileHeight);

    //
    // Actual size of bitmap to cache may be smaller than tile size if the
    // tile runs off the right/bottom of the bitmap. To see why this
    // calculation is correct, realize that (bmpWidth - tileOrg.x) is the
    // remaining width of the bitmap after the start of this tile.
    //
    cxSubBitmapWidth  = MIN((TSHR_INT16)tileWidth, bmpWidth - tileOrg.x);
    cySubBitmapHeight = MIN((TSHR_INT16)tileHeight, bmpHeight - tileOrg.y);

    //
    // Add the bitmap to the cache.
    //
    // If the sub-bitmap is already in the cache then this function will
    // locate it and return the cache index.
    //
    // If the sub-bitmap is not in the cache, this function will cache
    // it, adding the sub-bitmap data to the order queue.
    //
    if (!SBCCacheSubBitmap(&iCache,
                           hBitmap,
                           hdcSrc,
                           hdcDst,
                           tileOrg.x,
                           tileOrg.y,
                           bmpWidth,
                           bmpHeight,
                           cxSubBitmapWidth,
                           cySubBitmapHeight,
                           srcBpp,
                           &iCacheEntry,
                           &iColorTable,
                           pOrder->OrderHeader.memBltInfo.pBits,
                           pOrder->OrderHeader.memBltInfo.lpbmi,
                           pOrder->OrderHeader.memBltInfo.fuColorUse,
                           pOrder->OrderHeader.memBltInfo.hPalDest))
    {
        //
        // The sub-bitmap could not be cached - return FALSE.
        // The caller will add the destination of the blt into the SDA and
        // discard the order.
        //
        TRACE()"Failed to cache bitmap %04x", hBitmap));
        DC_QUIT;
    }

    //
    // Set up the source co-ordinates. For R1 protocols, the x-coordinate
    // includes the offset which is required to get the right cell within
    // the receive bitmap cache. For R2, we set up the cache entry in a
    // separate field.
    //
    if (!sbcMultiPoint)
    {
        *pXSrc = (iCacheEntry * sbcBmpCaches[iCache].cCellSize) +
                             *pXSrc % tileWidth;
    }
    else
    {
        *pXSrc = *pXSrc % tileWidth;
    }
    *pYSrc = *pYSrc % tileHeight;

    //
    // The sub-bitmap and color table are in the cache.  Store a cache
    // handle and color handle (which the receiver will turn back into an
    // HBITMAP).  Also store the cache index for R2 protocols (see above).
    //
    if (type == LOWORD(ORD_MEMBLT))
    {
        ((LPMEMBLT_ORDER)&pOrder->abOrderData)->hBitmap =
                             MEMBLT_COMBINEHANDLES(iColorTable,iCache);
        if (sbcMultiPoint)
        {
            ((LPMEMBLT_R2_ORDER)&pOrder->abOrderData)->type =
                                                       LOWORD(ORD_MEMBLT_R2);
            ((LPMEMBLT_R2_ORDER)&pOrder->abOrderData)->cacheIndex =
                                                                  iCacheEntry;
        }
        TRACE()"MEMBLT color %d bitmap %d:%d",iColorTable,iCache,iCacheEntry));
    }
    else
    {
        ((LPMEM3BLT_ORDER)&pOrder->abOrderData)->hBitmap =
                             MEMBLT_COMBINEHANDLES(iColorTable,iCache);
        if (sbcMultiPoint)
        {
            ((LPMEM3BLT_R2_ORDER)&pOrder->abOrderData)->type =
                                                       LOWORD(ORD_MEM3BLT_R2);
            ((LPMEM3BLT_R2_ORDER)&pOrder->abOrderData)->cacheIndex =
                                                                  iCacheEntry;
        }
        TRACE()"MEM3BLT color %d bitmap %d:%d",iColorTable,iCache,iCacheEntry));

    }

    TRACE_DBG()"iCacheEntry=%u, tileWidth=%hu, xSrc=%hd, ySrc=%hd",
        iCacheEntry, tileWidth, *pXSrc, *pYSrc));

    rc = TRUE;

    DC_EXIT(rc);
}

//
//
// SBC_DDQueryBitmapTileSize - see sbc.h
//
//
BOOL SBC_DDQueryBitmapTileSize
(
    UINT   bmpWidth,
    UINT   bmpHeight,
    LPUINT  pTileWidth,
    LPUINT  pTileHeight
)
{
    BOOL    rc = FALSE;
    UINT    i;
    UINT    maxSide;

    DebugEntry(SBC_DDQueryBitmapTileSize);

    //
    // The tile cell sizes are a local only decision, with the proviso that
    // the largest uncompressed tile must fit into the largest cache slot.
    // What this means is that for R1.1 we must define cell dimensions that
    // have a good fit in the square cache cells.  For R2.0 we can just
    // select tile sizes that seem appropriate.  Taking widths that are not
    // a multiple of 16 is wasteful.  The height should generally be less
    // than the width, simply on the grounds that bitmaps tend to be wider
    // than they are high.
    //
    if (g_sbcCacheInfo[ID_LARGE_BMP_CACHE].cCellSize <
           (g_sbcWorkInfo[SBC_SMALL_TILE_INDEX].tileWidth *
            g_sbcWorkInfo[SBC_SMALL_TILE_INDEX].tileHeight))
    {
        ERROR_OUT(( "No space for any cells"));
        DC_QUIT;
    }

    rc = TRUE;

    //
    // If large cell size is adequate then allow 64*63 cells for
    // wide bitmaps
    //
    if (g_sbcCacheInfo[ID_LARGE_BMP_CACHE].cCellSize >=
        (MP_LARGE_TILE_WIDTH * MP_LARGE_TILE_HEIGHT))
    {
        if ((bmpWidth > MP_SMALL_TILE_WIDTH) ||
            (bmpHeight > MP_SMALL_TILE_HEIGHT))
        {
            *pTileWidth  = MP_LARGE_TILE_WIDTH;
            *pTileHeight = MP_LARGE_TILE_HEIGHT;
            DC_QUIT;
        }
    }

    //
    // Otherwise we just use 32*31 cells
    //
    *pTileWidth  = MP_SMALL_TILE_WIDTH;
    *pTileHeight = MP_SMALL_TILE_HEIGHT;

DC_EXIT_POINT:
    DebugExitBOOL(SBC_DDQueryBitmapTileSize, rc);
    return(rc);
}


//
//
// SBC_DDSyncUpdatesNow() - see sbc.h
//
//
void SBC_DDSyncUpdatesNow(void)
{
    LPSBC_TILE_DATA  pTileData;
    UINT          i;
    UINT          j;

    DebugEntry(SBC_DDSyncUpdatesNow);

    TRACE_OUT(( "Marking all shunt buffer entries as not in use"));

    //
    // We have to mark all entries in the shunt buffers as being free.
    //
    for (i = 0 ; i < SBC_NUM_TILE_SIZES; i++)
    {
        for (j = 0 ; j < g_sbcWorkInfo[i].pShuntBuffer->numEntries; j++)
        {
            pTileData = SBCTilePtrFromIndex(g_sbcWorkInfo[i].pShuntBuffer, j);
            pTileData->inUse = FALSE;
        }

        //
        // Reset the MRU counter for this shunt buffer
        //
        g_sbcWorkInfo[i].mruIndex = 0;
    }

    //
    // If we are a palette device (i.e.  we are running at 8 bpp or less),
    // set the paletteChanged flag so we will send up a color table before
    // our next Mem(3)Blt.  We do this because the color table order for
    // the current device palette may have been discarded during the OA
    // sync.
    //
    g_sbcPaletteChanged = (g_osiScreenBPP <= 8);

    DebugExitVOID(SBC_DDSyncUpdatesNow);
}


//
//
// SBC_DDOrderSpoiltNotification() - see sbc.h
//
//
void SBC_DDOrderSpoiltNotification(LPINT_ORDER pOrder)
{
    LPMEMBLT_ORDER      pMemBltOrder  = (LPMEMBLT_ORDER)&(pOrder->abOrderData);
    LPMEM3BLT_ORDER     pMem3BltOrder = (LPMEM3BLT_ORDER)pMemBltOrder;
    UINT                tileId;
    LPSBC_TILE_DATA     pTileData;
    UINT                tileType;
    UINT                i;

    DebugEntry(SBC_DDOrderSpoiltNotification);

    //
    // pOrder has been removed from the order heap before being processed.
    // We have to free up the entry which it references in one of the shunt
    // buffers.  First get the tile Id.
    //
    if (pMemBltOrder->type = ORD_MEMBLT_TYPE)
    {
        tileId = pMemBltOrder->cacheId;
    }
    else
    {
        tileId = pMem3BltOrder->cacheId;
    }
    TRACE_OUT(( "Order referencing tile %hx has been spoiled", tileId));

    //
    // Find out which of the shunt buffers the entry should be in based on
    // the tileId
    //
    tileType = SBC_TILE_TYPE(tileId);

    //
    // We implement the shunt buffers as circular FIFO queues, so we will
    // start looking from the last order which we marked as being in use,
    // and work BACKWARDS.  This is because, in general, the entries after
    // the last one we accessed will not be in use (unless the whole shunt
    // buffer is in use).
    //
    // So, get the index of the last tile we accessed.
    //
    i = g_sbcWorkInfo[tileType].mruIndex;

    //
    // Loop through the circular buffer until we get a match, or have
    // circled back to the beginning.
    //
    // Note that this has been coded as a "do while" loop, rather than just
    // a "while" loop so that we don't miss mruIndex.  mruIndex is set up
    // to point to the NEXT entry to be used, rather than the last entry to
    // be used, so decrementing i before doing any work first time round
    // the loop is actually what we want to do.
    //
    do
    {
        //
        // On to the next tile
        //
        i = (i == 0)
          ? g_sbcWorkInfo[tileType].pShuntBuffer->numEntries - 1
          : i - 1;

        pTileData = SBCTilePtrFromIndex(g_sbcWorkInfo[tileType].pShuntBuffer, i);

        if (pTileData->inUse && (pTileData->tileId == tileId))
        {
            //
            // We've got a match, so mark the tile as being free.
            //
            // We don't want to update the shunt buffer mruIndex - this
            // should remain indicating the next tile to be used when
            // adding an entry to the shunt buffer.
            //
            TRACE_OUT(( "Marked tile Id %hx at index %d as free",
                         tileId,
                         i));
            pTileData->inUse = FALSE;
            break;
        }
    }
    while (i != g_sbcWorkInfo[tileType].mruIndex);

    DebugExitVOID(SBC_DDOrderSpoiltNotification);
}


//
//
// SBC_DDMaybeQueueColorTable() - see sbc.h
//
//
BOOL SBC_DDMaybeQueueColorTable(void)
{
    BOOL                      queuedOK = FALSE;
    int                       orderSize;
    LPINT_ORDER               pOrder;
    LPINT_COLORTABLE_ORDER_1BPP  pColorTableOrder;
    UINT                      numColors;
    UINT                      i;

    DebugEntry(SBC_DDMaybeQueueColorTable);

    //
    // If we're running at > 8 bpp, then we don't have a palette, so just
    // quit out.
    //
    if (g_osiScreenBPP > 8)
    {
        queuedOK = TRUE;
        DC_QUIT;
    }

    //
    // Check the boolean in our PDEV to see if the palette has changed
    // since the last time we sent a color table order.  Note that if we
    // have a non palette device, the boolean will never be set.
    //
    if (!g_sbcPaletteChanged)
    {
        queuedOK = TRUE;
        DC_QUIT;
    }

    //
    // The palette has changed, so allocate order memory to queue a color
    // table order.  The order size depends on the bpp of our device.  Note
    // that the allocation can fail if the order buffer is full.
    //
    switch (g_osiScreenBPP)
    {
        case 1:
        {
            orderSize = sizeof(INT_COLORTABLE_ORDER_1BPP);
        }
        break;

        case 4:
        {
            orderSize = sizeof(INT_COLORTABLE_ORDER_4BPP);
        }
        break;

        case 8:
        {
            orderSize = sizeof(INT_COLORTABLE_ORDER_8BPP);
        }
        break;

        default:
        {
            ERROR_OUT(("Invalid bpp (%d) for palette device", g_osiScreenBPP));
            DC_QUIT;
        }
        break;
    }

    pOrder = OA_DDAllocOrderMem(orderSize, 0);
    if (pOrder == NULL)
    {
        TRACE_OUT(( "Failed to allocate %d bytes for order", orderSize));
        DC_QUIT;
    }
    TRACE_OUT(( "Allocate %d bytes for color table order", orderSize));

    //
    // We've successfully allocated the order, so fill in the details.  We
    // mark the order as internal so that the Update Packager will spot it
    // up in the share core and prevent it being sent over the wire.
    //
    pOrder->OrderHeader.Common.fOrderFlags = OF_INTERNAL;

    pColorTableOrder = (LPINT_COLORTABLE_ORDER_1BPP)&(pOrder->abOrderData);
    pColorTableOrder->header.type = INTORD_COLORTABLE_TYPE;
    pColorTableOrder->header.bpp  = g_osiScreenBPP;

    //
    // Get the current system palette and save it.
    //
    numColors = COLORS_FOR_BPP(g_osiScreenBPP);
    for (i = 0 ; i < numColors; i++)
    {
        pColorTableOrder->colorData[i].rgbRed   = ppDev->pPal[i].peRed;
        pColorTableOrder->colorData[i].rgbGreen = ppDev->pPal[i].peGreen;
        pColorTableOrder->colorData[i].rgbBlue  = ppDev->pPal[i].peBlue;
    }

    //
    // Add the order
    //
    OA_DDAddOrder(pOrder, NULL);
    TRACE_OUT(( "Added internal color table order, size %d", orderSize));

    //
    // Reset the flag which indicates that the palette needs to be sent
    //
    g_sbcPaletteChanged = FALSE;

    //
    // Must be OK to get to here
    //
    queuedOK = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SBC_DDMaybeQueueColorTable, queuedOK);
    return(queuedOK);
}




//
// Name:      SBCDDCreateShuntBuffers
//
// Purpose:   Allocate memory for, and initialize the two shunt buffers
//            used to pass data from the driver to the share core.
//
// Returns:   TRUE if the buffers were allocated OK, FALSE otherwise.
//
// Operation: If this function succeeds, the following global variables
//            are initialized.
//
//               g_sbcWorkInfo[x].pShuntBuffer
//               g_sbcWorkInfo[x].mruIndex
//               g_sbcNextTileId
//
//            If the function fails, some of these variables may be
//            initialized.
//
BOOL SBCDDCreateShuntBuffers(void)
{
    int     i;
    UINT    memPerTile[SBC_NUM_TILE_SIZES];
    UINT    numEntries[SBC_NUM_TILE_SIZES];
    DWORD   memRequired;
    DWORD   minRequired;
    HGLOBAL hBuffer;
    LPBYTE  pBuffer;
    BOOL    rc;

    DebugEntry(SBCDDCreateShuntBuffers);

    rc = FALSE;

    //
    // We should already have a pointer to the shared memory we can use for
    // our shunt buffers, and the number of bytes available.  What we have
    // to do is to partition this shared memory into SBC_NUM_TILE_SIZE
    // shunt buffers.  i.e. one shunt buffer per tile size.
    //
    //
    // <--- buffer 0 ---><------------------ buffer 1 -------------------->
    //
    //
    //    :  :  :  :             :        :         :         :        
    //    :  :  :  :       tile  :  tile  :  tile   :  tile   :  tile  
    //    :  :  :  :             :        :         :         :        
    //
    //^ ^                  ^
    //                   
    //  header[0]      header[1]
    //
    // psbcSharedMemory
    //
    //
    // We try to use the number of entries given in the pEntries array, but
    // if we do not have enough shared memory for this, we reduce the
    // number of entries in each shunt buffer, preserving the ratio between
    // the number of entries in each of the shunt buffers.
    //

    for (i = 0; i < SBC_NUM_TILE_SIZES ; i++)
    {
        numEntries[i] = SBC_TILE_ENTRIES;

        //
        // Calculate how much memory we need per tile, and for the whole
        // shunt buffer.
        //
        memPerTile[i]   = SBC_BYTES_PER_TILE(g_sbcWorkInfo[i].tileWidth,
                                             g_sbcWorkInfo[i].tileHeight,
                                             g_osiScreenBPP);

        memRequired  = SBCShuntBufferSize(memPerTile[i], numEntries[i]);

        if (i == SBC_SMALL_TILE_INDEX)
            minRequired = SBCShuntBufferSize(memPerTile[i], SBC_SMALL_TILE_MIN_ENTRIES);
        else
            minRequired = SBCShuntBufferSize(memPerTile[i], SBC_LARGE_TILE_MIN_ENTRIES); 

        TRACE_OUT(( "[%d]: Requested %d entries, %ld bytes, %ld bytes min",
                     i, numEntries[i], memRequired, minRequired));

        //
        // If memRequired or minRequired are greater than 64K, bail out.
        //
        if (memRequired > 0x10000)
        {
            if (minRequired > 0x10000)
            {
                WARNING_OUT(("Not enough memory for SBC"));
                DC_QUIT;
            }

            //
            // We have enough shared memory for the minimum # of entries,
            // but not enough for the default.  Figure out how many will fit.
            // in 64K.  We do this in a tricky way to avoid DWORD divides
            //
            // Basically, the result is 
            //      (64K - fixed shunt buffer goop) / memPerTile
            //
            numEntries[i] = (0xFFFF -
                (sizeof(SBC_SHUNT_BUFFER) - sizeof(SBC_TILE_DATA)) + 1) /
                memPerTile[i];
        }

        //
        // Try to allocate memory block.
        //
        hBuffer = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT | GMEM_SHARE,
            SBCShuntBufferSize(memPerTile[i], numEntries[i]));

        if (!hBuffer)
        {
            WARNING_OUT(("Not enough memory for SBC"));
            DC_QUIT;
        }

        g_sbcWorkInfo[i].pShuntBuffer = (LPSBC_SHUNT_BUFFER)MAKELP(hBuffer, 0);
    }

    //
    // There are currently only two tile sizes and therefore two shunt
    // buffers.  If we run out of memory on the second one, yeah, we'll
    // exit this function with one 64K block still allocated for the small
    // tile size cache.  It will get freed when SBC_DDTerm() is called.
    //
    // If this happens, freeing the block isn't going to make much of a 
    // difference, Windows is almost on its knees anyway.  So no point in
    // getting fancy and freeing it now.
    //

    //
    // OK, we're home free.
    //
    for (i = 0; i < SBC_NUM_TILE_SIZES ; i++)
    {
        ASSERT(g_sbcWorkInfo[i].pShuntBuffer);

        g_sbcWorkInfo[i].pShuntBuffer->numEntries    = numEntries[i];
        g_sbcWorkInfo[i].pShuntBuffer->numBytes      = memPerTile[i]
                                                   - sizeof(SBC_TILE_DATA);
        g_sbcWorkInfo[i].pShuntBuffer->structureSize = memPerTile[i];

        //
        // Fill in the mruIndex for this shunt buffer
        //
        g_sbcWorkInfo[i].mruIndex = 0;
    }

    //
    // Initialize the global variables associated with the shunt buffers
    //
    g_sbcNextTileId = 0;

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SBCDDCreateShuntBuffers, rc);
    return(rc);
}




//
// Name:      SBCDDGetNextFreeTile
//
// Purpose:   Return the next free tile of the correct size from one of the
//            shunt buffers.
//
// Returns:   TRUE if a tile is returned, FALSE otherwise
//
// Params:    IN  workTileSize - The tile size.  One of
//                     SBC_SMALL_TILE
//                     SBC_LARGE_TILE
//            OUT ppTileData   - A pointer to the tile.
//
// Operation: The tileId field of the tile is filled in on return from
//            this function.
//
//*PROC-********************************************************************
BOOL SBCDDGetNextFreeTile(int tileSize, LPSBC_TILE_DATA FAR * ppTileData)
{
    BOOL              foundFreeTile = FALSE;
    LPSBC_TILE_DATA      pTileData;

    DebugEntry(SBCDDGetNextFreeTile);

    ASSERT(tileSize < SBC_NUM_TILE_SIZES);

    //
    // Get a pointer to the next entry to be used in the shunt buffer
    // containing tiles of the given size.
    //
    pTileData = SBCTilePtrFromIndex(g_sbcWorkInfo[tileSize].pShuntBuffer,
                                        g_sbcWorkInfo[tileSize].mruIndex);

    //
    // If the entry is still in use (the share core has not yet processed
    // the order which references this tile) we have to quit - the shunt
    // buffer is full.
    //
    if (pTileData->inUse)
    {
        TRACE_OUT(( "Target entry (%d, %d) is still in use",
                     tileSize,
                     g_sbcWorkInfo[tileSize].mruIndex));
        DC_QUIT;
    }

    //
    // The entry is not in use - we can re-use it.  Fill in the Id field,
    // and the pointer to the entry which we return to the caller.
    //
    // We always set the top bit of the tile Id for large tiles, and clear
    // it for small tiles.
    //
    *ppTileData       = pTileData;
    pTileData->tileId = g_sbcNextTileId;
    if (tileSize == SBC_SMALL_TILE_INDEX)
    {
        pTileData->tileId &= ~0x8000;
    }
    else
    {
        pTileData->tileId |= 0x8000;
    }
    TRACE_OUT(( "Returning entry (%d, %d), Id %hx",
                 tileSize,
                 g_sbcWorkInfo[tileSize].mruIndex,
                 pTileData->tileId));

    //
    // Update the index of the next free entry in this shunt buffer, and
    // also the Id which we should assign next time.  Remember to wrap the
    // shunt buffer index to the number of entries in the shunt buffer.
    //
    g_sbcWorkInfo[tileSize].mruIndex = (g_sbcWorkInfo[tileSize].mruIndex + 1) %
            g_sbcWorkInfo[tileSize].pShuntBuffer->numEntries;


    g_sbcNextTileId++;
    g_sbcNextTileId &= ~0x8000;

    //
    // Completed successfully !
    //
    foundFreeTile = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SBCDDGetNextFreeTile, foundFreeTile);
    return(foundFreeTile);
}


//
// Name:      SBCDDIsBitmapThrasher
//
// Purpose:   Check to see if the given bitmap (surface object) is one
//            which would cause cache thrashing.
//
// Returns:   TRUE if the bitmap is a thrasher, FALSE otherwise.
//
// Params:    IN  pSurfObj - Pointer to the bitmap
//
BOOL SBCDDIsBitmapThrasher(HDC hdc)
{
    UINT      i;
    BOOL      rc = FALSE;
    BOOL      bitmapInList = FALSE;
    BOOL      updateEntry  = FALSE;
    UINT      updateIndex;
    UINT    nextTickCount;
    UINT      evictIndex;
    UINT    evictTickCount;

    DebugEntry(SBCDDIsBitmapThrasher);

    //
    // Here's an overview of how our bitmap cache thrash detection works...
    //
    // We hold an array of information about the last SBC_NUM_THRASHERS
    // bitmaps which we have tried to cache.  This information is
    //  - A value to identify the bitmap.  This is the hsurf field from the
    //    bitmap surface object, and is different for every bitmap.
    //  - A value to identify the "version" of the bitmap.  This is the
    //    iUniq field from the bitmap surface object, and is updated by GDI
    //    each time the bitmap is drawn to.
    //  - A timestamp for the last time which we saw iUniq change for this
    //    bitmap (or when we added the bitmap to the array).
    //
    // Each time this function is called, we scan this array looking for an
    // entry for the bitmap.
    //
    // If we find an entry, we check whether the bitmap has changed (has
    // the iUniq field changed).  If it has not changed, the bitmap is not
    // a thrasher.  If the bitmap has changed, we check the interval from
    // the timestamp value to the current time.  If the interval is less
    // than the SBC_THRASH_INTERVAL, the bitmap has changed too quickly, so
    // it is a thrasher.  If the interval is OK, the bitmap is not a
    // thrasher.  In either case, we update the stored iUniq field and the
    // timestamp to record the time / version at which we spotted that the
    // bitmap changed.
    //
    // If we do not find an entry for the bitmap, we add an entry for it.
    // If the array is fully populated, we evict the entry with the oldest
    // timestamp, and replace it with the new entry.
    //

    //
    // Scan the thrasher list looking for a match
    //
    for (i=0 ; i < SBC_NUM_THRASHERS ; i++)
    {
        //
        // If we find a match then we are only worried if it has been
        // modified since the last time we read it.
        //
        if (sbcThrashers[i].hsurf == lpdce->hbmp)
        {
            bitmapInList = TRUE;

            if (sbcThrashers[i].iUniq != pSurfObj->iUniq)
            {
                TRACE_OUT(( "Matching surface %x, index %u,"
                             "tick count %u has been modified",
                             pSurfObj->hsurf,
                             i,
                             sbcThrashers[i].tickCount));
                updateEntry = TRUE;
                updateIndex = i;

                //
                // Now we need to determine if this is a thrasher.  It is a
                // thrasher if the time we last read it is less than our
                // thrash interval.  (We only update the time when we read
                // a modified bitmap)
                //
                nextTickCount = SBCDDGetTickCount();
                if ((nextTickCount - sbcThrashers[i].tickCount) <
                                                          SBC_THRASH_INTERVAL)
                {
                    TRACE_OUT((
                             "Rejected cache attempt of thrashy bitmap %x",
                             pSurfObj->hsurf));
                    rc = TRUE;
                }
                sbcThrashers[i].tickCount = nextTickCount;
                sbcThrashers[i].iUniq     = pSurfObj->iUniq;
            }

            //
            // We've found a match - we can break out of the loop
            //
            break;
        }
    }

    if (!bitmapInList)
    {
        //
        // The bitmap isn't already in the thrasher list, so add it now.
        // Find the entry with the smallest (earliest) tick count - we will
        // evict this entry from the array to make room for the new entry.
        //
        evictIndex     = 0;
        evictTickCount = 0xffffffff;

        for (i = 0; i < SBC_NUM_THRASHERS; i++)
        {
            if (evictTickCount > sbcThrashers[i].tickCount)
            {
                evictTickCount = sbcThrashers[i].tickCount;
                evictIndex     = i;
            }
        }
        TRACE_OUT(( "Evicting entry %d, surface %x",
                     evictIndex,
                     sbcThrashers[i].hsurf));

        nextTickCount = SBCDDGetTickCount();

        TRACE_OUT(( "Adding surface %x to thrash list, tick %d",
                     pSurfObj->hsurf,
                     nextTickCount));
        updateEntry = TRUE;
        updateIndex = evictIndex;
    }

    if (updateEntry)
    {
        //
        // We have to update the entry at index updateIndex.  We optimise
        // things slightly by always putting the most recent bitmap in
        // position 0 of the array, so copy entry 0 to the eviction index,
        // and put the new entry in position 0.
        //
        sbcThrashers[updateIndex] = sbcThrashers[0];

        sbcThrashers[0].hsurf     = lpdce->hbmp;
        sbcThrashers[0].iUniq     = pSurfObj->iUniq;
        sbcThrashers[0].tickCount = nextTickCount;
    }

    DebugExitBOOL(SBCDDIsBitmapThrasher, rc);
    return(rc);
}


//
// Name:      SBCDDGetTickCount
//
// Purpose:   Get a system tick count
//
// Returns:   The number of centi-seconds since the system was started.
//            This number will wrap after approximately 497 days!
//
// Params:    None
//
DWORD SBCDDGetTickCount(void)
{
    DWORD   tickCount;

    DebugEntry(SBCDDGetTickCount);

    tickCount = GetTickCount() / 10;

    DebugExitDWORD(SBCDDGetTickCount, tickCount);
    return(tickCount);
}


#endif // #if 0





#if 0

//
// SBC_BitmapHasChanged(..)
//
// See asbcapi.h for description.
//
DCVOID DCAPI SBC_BitmapHasChanged(HBITMAP hChangedBitmap)
{
    TSHR_UINT nextIndex;
    TSHR_INT  nextTickCount;
    TSHR_INT  tickDelta;
    TSHR_INT  tickWork;
    UINT      i;

    TRACE_FN("SBC_BitmapHasChanged");

    //
    // We maintain a list of bitmaps that are the target for a drawing
    // operation and we prevent these bitmaps from being cached unless
    // the update frequency is below a target value.
    //
    // All we need to do at this stage is to make sure that the bitmap
    // handle is in the thrash list and is marked as modified since the
    // last read.  That means that the next read will be "productive"
    // and so we will check/update the timer at that stage.  If the
    // "productive" read occurs within a certain interval from the last
    // read then this bitmap has become a thrasher.
    //
    if (sbcThrashers[0].hBitmap == hChangedBitmap)
    {
        TRACE()"Repeat bitmap %x modified",(UINT)hChangedBitmap));
        sbcThrashers[0].modified = TRUE;
    }
    else
    {
        nextIndex     = 0;
        nextTickCount = (int)(CO_GET_TICK_COUNT()/32);
        tickDelta     = abs(nextTickCount - sbcThrashers[0].tickCount);

        for (i=1; i<SBC_NUM_THRASHERS; i++)
        {
            if (sbcThrashers[i].hBitmap == hChangedBitmap)
            {
                sbcThrashers[i].modified = TRUE;
                break;
            }

            tickWork = abs(nextTickCount - sbcThrashers[i].tickCount);
            if (tickWork > tickDelta)
            {
                tickDelta = tickWork;
                nextIndex = i;
            }

        }

        //
        // If not found in the list then add to the list.  Always add to
        // the top of the list so we find repeated bitmaps as the first
        // entry
        //
        if (i == SBC_NUM_THRASHERS)
        {
            TRACE()"Relegating bitmap %x at list pos %u",
                          (UINT)sbcThrashers[nextIndex].hBitmap,nextIndex));
            if (nextIndex != 0)
            {
                sbcThrashers[nextIndex].hBitmap   = sbcThrashers[0].hBitmap;
                sbcThrashers[nextIndex].tickCount = sbcThrashers[0].tickCount;
                sbcThrashers[nextIndex].modified  = sbcThrashers[0].modified;
            }
            sbcThrashers[0].hBitmap   = hChangedBitmap;
            sbcThrashers[0].tickCount = nextTickCount - BMC_THRASH_INTERVAL;
            sbcThrashers[0].modified  = TRUE;
            TRACE()"Adding bitmap %x to thrash list tick %u",
                                       (TSHR_UINT16)hChangedBitmap, nextTickCount));
        }
    }

    //
    // We also maintain a list of "fast path" bitmaps, which is those tiles
    // that have not been modified since we cached them and can therefore
    // be interpreted from the handle alone.  This must be an exhaustive
    // search for each bitmap update and so we cannot offord the CPU of
    // processing a very long list, but we can afford to cache enough to
    // handle most animations.  Also it is not worth the CPU to try and
    // save individual tiles here.  We just evict the complete bitmap.
    //
    for (i=0; i<SBC_NUM_FASTPATH; i++)
    {
        if (sbcFastPath[i].hBitmap == hChangedBitmap)
        {
            TRACE()"Bitmap %x no longer fastpathed",(UINT)hChangedBitmap));
            sbcFastPath[i].hBitmap = 0;
        }
    }

    return;
}

//
// SBC_BitmapDeleted()
//
// See asbcapi.h for description.
//
DCVOID DCAPI SBC_BitmapDeleted(HBITMAP hDeletedBitmap)
{
    UINT i;

    TRACE_FN("SBC_BitmapDeleted");

    //
    // Remove the bitmap from the thrashy list.
    //
    for (i=0; i<SBC_NUM_THRASHERS; i++)
    {
        if (sbcThrashers[i].hBitmap == hDeletedBitmap)
        {
            TRACE_DBG()"Bitmap %x no longer thrashing",hDeletedBitmap));
            sbcThrashers[i].hBitmap   = 0;
            sbcThrashers[i].tickCount = 0;
            break;
        }
    }

    //
    // We also maintain a list of "fast path" bitmaps, which is those tiles
    // that have not been modified since we cached them and can therefore
    // be interpreted from the handle alone.  This must be an exhaustive
    // search for each bitmap update and so we cannot offord the CPU of
    // processing a very long list, but we can afford to cache enough to
    // handle most animations.  Also it is not worth the CPU to try and
    // save individual tiles here.  We just evict the complete bitmap.
    //
    for (i=0; i<SBC_NUM_FASTPATH; i++)
    {
        if (sbcFastPath[i].hBitmap == hDeletedBitmap)
        {
            TRACE()"Bitmap %x no longer fastpathed",(UINT)hDeletedBitmap));
            sbcFastPath[i].hBitmap   = 0;
            sbcFastPath[i].tickCount = 0;
        }
    }

    return;
}

//
// SBC_ColorsChanged()
//
// Called whenever the system palette changes (presumably as a result of
// a new logical palette being realized to the screen).
//
//
DCVOID DCAPI SBC_ColorsChanged(DCVOID)
{
    TRACE_FN("SBC_ColorsChanged");
    //
    // Just clear out all the fast path cache because we can no longer
    // trust the cached bits to accurately reflect the color table we
    // have cached.  (Note that this does not mean we will not use the
    // bits without resending, merely that we will force a retest of
    // the bits with the latest color info selected.
    //
    TRACE()"Fastpath table reset"));
    memset(sbcFastPath, 0, sizeof(sbcFastPath));
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\as16\shm.c ===
//
// SHM.C
// Shared Memory Manager
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>




//
// SHM_StartAccess
//
LPVOID  SHM_StartAccess(int block)
{
    LPBUFFER_CONTROL    pControl;
    LPVOID              pMemBlock;

    DebugEntry(SHM_StartAccess);

    //
    // Test for shared memory present
    //
    ASSERT(g_asSharedMemory != NULL);

    //
    // Determine which data block we are handling...
    //
    switch (block)
    {
        case SHM_OA_DATA:
            pControl = &g_asSharedMemory->displayToCore;
            break;

        case SHM_OA_FAST:
        case SHM_BA_FAST:
        case SHM_CM_FAST:
            pControl = &g_asSharedMemory->fastPath;
            break;

        default:
            ERROR_OUT(("Unknown type %d", block));
            break;
    }

    //
    // Mark the double-buffer as busy.
    //
    pControl->busyFlag = TRUE;

    //
    // Set up the current buffer pointer if this is the first access to the
    // shared memory.
    //
    pControl->indexCount++;
    if (pControl->indexCount == 1)
    {
        //
        // Set up the 'in use' buffer pointer
        //
        pControl->currentBuffer = pControl->newBuffer;

        //
        // Mark the buffer as busy so that the Share Core knows where we
        // are.
        //
        pControl->bufferBusy[pControl->currentBuffer] = 1;
    }

    //
    // Get the pointer to the block to return
    //
    switch (block)
    {
        case SHM_OA_DATA:
            pMemBlock = g_poaData[pControl->currentBuffer];
            break;

        case SHM_OA_FAST:
            pMemBlock = &(g_asSharedMemory->oaFast[pControl->currentBuffer]);
            break;

        case SHM_BA_FAST:
            pMemBlock = &(g_asSharedMemory->baFast[pControl->currentBuffer]);
            break;

        case SHM_CM_FAST:
            pMemBlock = &(g_asSharedMemory->cmFast[pControl->currentBuffer]);
            break;

        default:
            ERROR_OUT(("Unknown type %d", block));
            break;
    }

    DebugExitDWORD(SHM_StartAccess, (DWORD)pMemBlock);
    return(pMemBlock);
}


//
// SHM_StopAccess
//
void  SHM_StopAccess(int block)
{
    LPBUFFER_CONTROL pControl;

    DebugEntry(SHM_StopAccess);

    ASSERT(g_asSharedMemory != NULL);

    //
    // Determine which data block we are handling...
    //
    switch (block)
    {
        case SHM_OA_DATA:
            pControl = &g_asSharedMemory->displayToCore;
            break;

        case SHM_OA_FAST:
        case SHM_BA_FAST:
        case SHM_CM_FAST:
            pControl = &g_asSharedMemory->fastPath;
            break;

        default:
            ERROR_OUT(("Unknown type %d", block));
            break;
    }

    //
    // Decrement usage count - if we have finally finished with the memory,
    // clear the busy flags so that the Share Core knows it won't tread on
    // the display driver's toes.
    //
    pControl->indexCount--;
    if (pControl->indexCount == 0)
    {
        BOOL    fPulseLock;

        //
        // If this is the order heap, and it is more than half full, 
        // strobe the win16lock so the core has a chance to run and pick up
        // the pending orders.  This will NOT cause interthread sends to
        // get received on this guy.
        //
        fPulseLock = FALSE;
        if (block == SHM_OA_DATA)
        {
            LPOA_SHARED_DATA pMemBlock = g_poaData[pControl->currentBuffer];

            ASSERT(pMemBlock);

            if (pMemBlock->totalOrderBytes >=
                ((g_oaFlow == OAFLOW_FAST ? OA_FAST_HEAP : OA_SLOW_HEAP) / 2))
            {
                fPulseLock = TRUE;
                TRACE_OUT(("Pulsing Win16lock since order heap size %08ld is getting full",
                    pMemBlock->totalOrderBytes));
            }
        }

        pControl->bufferBusy[pControl->currentBuffer] = 0;

        pControl->busyFlag = 0;

        if (fPulseLock)
        {
            _LeaveWin16Lock();
            _EnterWin16Lock();
            
            TRACE_OUT(("Done pulsing Win16lock to flush order heap"));
        }
    }

    DebugExitVOID(SHM_StopAccess);
}


#ifdef _DEBUG
//
// SHM_CheckPointer - see shm.h
//
void  SHM_CheckPointer(LPVOID ptr)
{
    DebugEntry(SHMCheckPointer);

    //
    // Is it even accessible?
    //
    ASSERT(!IsBadWritePtr(ptr, 4));

    //
    // Is it in the proper range?  NOTE--our shared memory is not one
    // contiguous block.  Therefore we need to determine which chunk it
    // is in.  Since each chunk already has a limit built in, we just
    // need to make sure the selector is cool.
    //

    ASSERT(g_asSharedMemory);
    ASSERT(g_poaData[0]);
    ASSERT(g_poaData[1]);

    if ((SELECTOROF(ptr) != SELECTOROF(g_asSharedMemory)) &&
        (SELECTOROF(ptr) != SELECTOROF(g_poaData[0])) &&
        (SELECTOROF(ptr) != SELECTOROF(g_poaData[1])))
    {
        ERROR_OUT(("Pointer not in any shared memory block"));
    }

    DebugExitVOID(SHM_CheckPointer);
}
#endif // _DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\as16\oe.c ===
//
// OE.C
// Order Encoder
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>


//
// Define entries in the Font Alias table.  This table is used to convert
// non-existant fonts (used by certain widely used applications) into
// something we can use as a local font.
//
// The font names that we alias are:
//
// "Helv"
// This is used by Excel. It is mapped directly onto "MS Sans Serif".
//
// "MS Dialog"
// This is used by Word. It is the same as an 8pt bold MS Sans Serif.
// We actually map it to a "MS Sans Serif" font that is one pel narrower
// than the metrics specify (because all matching is done on non-bold
// fonts) - hence the 1 value in the charWidthAdjustment field.
//
// "MS Dialog Light"
// Added as part of the Win95 performance enhancements...Presumably for
// MS-Word...
//
//
#define NUM_ALIAS_FONTS     3

char CODESEG g_szMsSansSerif[]      = "MS Sans Serif";
char CODESEG g_szHelv[]             = "Helv";
char CODESEG g_szMsDialog[]         = "MS Dialog";
char CODESEG g_szMsDialogLight[]    = "MS Dialog Light";

FONT_ALIAS_TABLE CODESEG g_oeFontAliasTable[NUM_ALIAS_FONTS] =
{
    { g_szHelv,             g_szMsSansSerif,    0 },
    { g_szMsDialog,         g_szMsSansSerif,    1 },
    { g_szMsDialogLight,    g_szMsSansSerif,    0 }
};


//
// OE_DDProcessRequest()
// Handles OE escapes
//

BOOL OE_DDProcessRequest
(
    UINT   fnEscape,
    LPOSI_ESCAPE_HEADER pResult,
    DWORD   cbResult
)
{
    BOOL    rc = TRUE;

    DebugEntry(OE_DDProcessRequest);

    switch (fnEscape)
    {
        case OE_ESC_NEW_FONTS:
        {
            ASSERT(cbResult == sizeof(OE_NEW_FONTS));

            OEDDSetNewFonts((LPOE_NEW_FONTS)pResult);
        }
        break;

        case OE_ESC_NEW_CAPABILITIES:
        {
            ASSERT(cbResult == sizeof(OE_NEW_CAPABILITIES));

            OEDDSetNewCapabilities((LPOE_NEW_CAPABILITIES)pResult);
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized OE escape"));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(OE_DDProcessRequest, rc);
    return(rc);
}


//
// OE_DDInit()
// This creates the patches we need.
// 
BOOL OE_DDInit(void)
{
    BOOL    rc = FALSE;
    HGLOBAL hMem;
    UINT    uSel;
    DDI_PATCH iPatch;

    DebugEntry(OE_DDInit);

    //
    // lstrcmp(), like strcmp(), works numerically for US/Eng code page.
    // But it's lexographic like Win32 lstrcmp() is all the time for non
    // US.
    //
    // So we use MyStrcmp()
    //
    ASSERT(MyStrcmp("Symbol", "SYmbol") > 0);

    //
    // Allocate a cached selector.  We use it when reading from swapped-out
    // DCs.  Therefore base it off of GDI's data segement, so it has the
    // same access rights and limit.
    //
    g_oeSelDst = AllocSelector((UINT)g_hInstGdi16);
    g_oeSelSrc = AllocSelector((UINT)g_hInstGdi16);
    if (!g_oeSelDst || !g_oeSelSrc)
    {
        ERROR_OUT(("Out of selectors"));
        DC_QUIT;
    }

    //
    // Allocate g_poeLocalFonts--it's too big for our DS.  We make it
    // a very small size since on new fonts, we will realloc it.
    //
    hMem = GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT | GMEM_SHARE,
        sizeof(LOCALFONT));
    if (!hMem)
    {
        ERROR_OUT(("OE_DDInit:  Couldn't allocate font matching array"));
        DC_QUIT;
    }
    g_poeLocalFonts = MAKELP(hMem, 0);


    //
    // Create two patches for ChangeDisplaySettings/Ex and ENABLE them right
    // away.  We don't want you to be able to change your display when
    // NetMeeting is running, regardless of whether you are in a share yet.
    //
    uSel = CreateFnPatch(ChangeDisplaySettings, DrvChangeDisplaySettings,
        &g_oeDisplaySettingsPatch, 0);
    if (!uSel)
    {
        ERROR_OUT(("CDS patch failed to create"));
        DC_QUIT;
    }

    EnableFnPatch(&g_oeDisplaySettingsPatch, PATCH_ACTIVATE);

    if (SELECTOROF(g_lpfnCDSEx))
    {
        if (!CreateFnPatch(g_lpfnCDSEx, DrvChangeDisplaySettingsEx,
                &g_oeDisplaySettingsExPatch, uSel))
        {
            ERROR_OUT(("CDSEx patch failed to create"));
            DC_QUIT;
        }

        EnableFnPatch(&g_oeDisplaySettingsExPatch, PATCH_ACTIVATE);
    }

    //
    // Create patches.
    // NOTE this code assumes that various groups of functions are in
    // the same segment.  CreateFnPatch has asserts to verify this.
    //
    // Rather than check each for failure (low on selectors), we try to
    // create all the patches, then loop through looking for any that
    // didn't succeed.
    //
    // Why do we do this?  Because allocating 50 different selectors is 
    // not so hot when 16-bit selectors are the most precious resource on
    // Win95 (most out-of-memory conditions that aren't blatant app errors
    // are caused by a lack of selectors, not logical memory).
    //

    // _ARCDDA
    uSel = CreateFnPatch(Arc, DrvArc, &g_oeDDPatches[DDI_ARC], 0);
    CreateFnPatch(Chord, DrvChord, &g_oeDDPatches[DDI_CHORD], uSel);
    CreateFnPatch(Ellipse, DrvEllipse, &g_oeDDPatches[DDI_ELLIPSE], uSel);
    CreateFnPatch(Pie, DrvPie, &g_oeDDPatches[DDI_PIE], uSel);
    CreateFnPatch(RoundRect, DrvRoundRect, &g_oeDDPatches[DDI_ROUNDRECT], uSel);

    // IGROUP
    uSel = CreateFnPatch(BitBlt, DrvBitBlt, &g_oeDDPatches[DDI_BITBLT], 0);
    CreateFnPatch(ExtTextOut, DrvExtTextOutA, &g_oeDDPatches[DDI_EXTTEXTOUTA], uSel);
    CreateFnPatch(InvertRgn, DrvInvertRgn, &g_oeDDPatches[DDI_INVERTRGN], uSel);
    CreateFnPatch(DeleteObject, DrvDeleteObject, &g_oeDDPatches[DDI_DELETEOBJECT], uSel);
    CreateFnPatch(Death, DrvDeath, &g_oeDDPatches[DDI_DEATH], uSel);
    CreateFnPatch(Resurrection, DrvResurrection, &g_oeDDPatches[DDI_RESURRECTION], uSel);


    //
    // Note:  PatBlt and IPatBlt (internal PatBlt) jump to RealPatBlt, which
    // is 3 bytes past PatBlt.  So patch RealPatBlt, or we'll (1) fault with
    // misaligned instructions and (2) miss many PatBlt calls.  But our
    // function needs to preserve CX since those two routines pass 0 for
    // internal calls (EMF) and -1 for external calls.
    //
    g_lpfnRealPatBlt = (REALPATBLTPROC)((LPBYTE)PatBlt+3);
    CreateFnPatch(g_lpfnRealPatBlt, DrvPatBlt, &g_oeDDPatches[DDI_PATBLT], uSel);
    CreateFnPatch(StretchBlt, DrvStretchBlt, &g_oeDDPatches[DDI_STRETCHBLT], uSel);
    CreateFnPatch(TextOut, DrvTextOutA, &g_oeDDPatches[DDI_TEXTOUTA], uSel);

    // _FLOODFILL
    uSel = CreateFnPatch(ExtFloodFill, DrvExtFloodFill, &g_oeDDPatches[DDI_EXTFLOODFILL], 0);
    CreateFnPatch(FloodFill, DrvFloodFill, &g_oeDDPatches[DDI_FLOODFILL], uSel);

    // _FONTLOAD
    uSel = CreateFnPatch(g_lpfnExtTextOutW, DrvExtTextOutW, &g_oeDDPatches[DDI_EXTTEXTOUTW], 0);
    CreateFnPatch(g_lpfnTextOutW, DrvTextOutW, &g_oeDDPatches[DDI_TEXTOUTW], uSel);

    // _PATH
    uSel = CreateFnPatch(FillPath, DrvFillPath, &g_oeDDPatches[DDI_FILLPATH], 0);
    CreateFnPatch(StrokeAndFillPath, DrvStrokeAndFillPath, &g_oeDDPatches[DDI_STROKEANDFILLPATH], uSel);
    CreateFnPatch(StrokePath, DrvStrokePath, &g_oeDDPatches[DDI_STROKEPATH], uSel);

    // _RGOUT
    uSel = CreateFnPatch(FillRgn, DrvFillRgn, &g_oeDDPatches[DDI_FILLRGN], 0);
    CreateFnPatch(FrameRgn, DrvFrameRgn, &g_oeDDPatches[DDI_FRAMERGN], uSel);
    CreateFnPatch(PaintRgn, DrvPaintRgn, &g_oeDDPatches[DDI_PAINTRGN], uSel);

    // _OUTMAN
    uSel = CreateFnPatch(LineTo, DrvLineTo, &g_oeDDPatches[DDI_LINETO], 0);
    CreateFnPatch(Polyline, DrvPolyline, &g_oeDDPatches[DDI_POLYLINE], uSel);
    CreateFnPatch(g_lpfnPolylineTo, DrvPolylineTo, &g_oeDDPatches[DDI_POLYLINETO], uSel);

    // EMF
    uSel = CreateFnPatch(PlayEnhMetaFileRecord, DrvPlayEnhMetaFileRecord, &g_oeDDPatches[DDI_PLAYENHMETAFILERECORD], 0);

    // METAPLAY
    uSel = CreateFnPatch(PlayMetaFile, DrvPlayMetaFile, &g_oeDDPatches[DDI_PLAYMETAFILE], 0);
    CreateFnPatch(PlayMetaFileRecord, DrvPlayMetaFileRecord, &g_oeDDPatches[DDI_PLAYMETAFILERECORD], uSel);

    // _POLYGON
    uSel = CreateFnPatch(Polygon, DrvPolygon, &g_oeDDPatches[DDI_POLYGON], 0);
    CreateFnPatch(PolyPolygon, DrvPolyPolygon, &g_oeDDPatches[DDI_POLYPOLYGON], uSel);

    // _BEZIER
    uSel = CreateFnPatch(PolyBezier, DrvPolyBezier, &g_oeDDPatches[DDI_POLYBEZIER], 0);
    CreateFnPatch(PolyBezierTo, DrvPolyBezierTo, &g_oeDDPatches[DDI_POLYBEZIERTO], uSel);

    // _WIN32
    uSel = CreateFnPatch(g_lpfnPolyPolyline, DrvPolyPolyline, &g_oeDDPatches[DDI_POLYPOLYLINE], 0);

    // _RECT
    uSel = CreateFnPatch(Rectangle, DrvRectangle, &g_oeDDPatches[DDI_RECTANGLE], 0);

    // _DIBITMAP
    uSel = CreateFnPatch(SetDIBitsToDevice, DrvSetDIBitsToDevice, &g_oeDDPatches[DDI_SETDIBITSTODEVICE], 0);
    CreateFnPatch(StretchDIBits, DrvStretchDIBits, &g_oeDDPatches[DDI_STRETCHDIBITS], uSel);

    // _DCSTUFF
    uSel = CreateFnPatch(CreateSpb, DrvCreateSpb, &g_oeDDPatches[DDI_CREATESPB], 0);

    // _PIXDDA
    uSel = CreateFnPatch(SetPixel, DrvSetPixel, &g_oeDDPatches[DDI_SETPIXEL], 0);

    // _PALETTE
    uSel = CreateFnPatch(UpdateColors, DrvUpdateColors, &g_oeDDPatches[DDI_UPDATECOLORS], 0);
    CreateFnPatch(GDIRealizePalette, DrvGDIRealizePalette, &g_oeDDPatches[DDI_GDIREALIZEPALETTE], uSel);
    CreateFnPatch(RealizeDefaultPalette, DrvRealizeDefaultPalette, &g_oeDDPatches[DDI_REALIZEDEFAULTPALETTE], uSel);

    // (User WINRARE)
    uSel = CreateFnPatch(WinOldAppHackoMatic, DrvWinOldAppHackoMatic, &g_oeDDPatches[DDI_WINOLDAPPHACKOMATIC], 0);

    //
    // Loop through our patches and check for failure
    //
    for (iPatch = DDI_FIRST; iPatch < DDI_MAX; iPatch++)
    {
        if (!SELECTOROF(g_oeDDPatches[iPatch].lpCodeAlias))
        {
            ERROR_OUT(("Patch %u failed to create", iPatch));
            DC_QUIT;
        }
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(OE_DDInit, rc);
    return(rc);
}



//
// OE_DDTerm()
// This destroys the patches we created.
//
void OE_DDTerm(void)
{
    DDI_PATCH   iPatch;

    DebugEntry(OE_DDTerm);

    //
    // Destroying patches will also disable any still active.
    //
    for (iPatch = DDI_FIRST; iPatch < DDI_MAX; iPatch++)
    {
        // destroy patches
        DestroyFnPatch(&g_oeDDPatches[iPatch]);
    }

    //
    // Destroy ChangeDisplaySettings patches
    //
    if (SELECTOROF(g_lpfnCDSEx))
        DestroyFnPatch(&g_oeDisplaySettingsExPatch);
    DestroyFnPatch(&g_oeDisplaySettingsPatch);

    //
    // Free font memory
    //
    if (SELECTOROF(g_poeLocalFonts))
    {
        GlobalFree((HGLOBAL)SELECTOROF(g_poeLocalFonts));
        g_poeLocalFonts = NULL;
    }

    //
    // Free cached selectors
    //
    if (g_oeSelSrc)
    {
        FreeSelector(g_oeSelSrc);
        g_oeSelSrc = 0;
    }

    if (g_oeSelDst)
    {
        FreeSelector(g_oeSelDst);
        g_oeSelDst = 0;
    }

    DebugExitVOID(OE_DDTerm);
}


//
// OE_DDViewing()
//
// Turns on/off patches for trapping graphic output.
//
void OE_DDViewing(BOOL fViewers)
{
    DDI_PATCH   patch;

    DebugEntry(OE_DDViewing);

    //
    // Clear window and font caches
    //
    g_oeLastWindow = NULL;
    g_oeFhLast.fontIndex = 0xFFFF;

    //
    // Enable or disable GDI patches
    //
    for (patch = DDI_FIRST; patch < DDI_MAX; patch++)
    {
        EnableFnPatch(&g_oeDDPatches[patch], (fViewers ? PATCH_ACTIVATE :
            PATCH_DEACTIVATE));
    }

    //
    // Do save bits & cursor patches too
    //
    SSI_DDViewing(fViewers);
    CM_DDViewing(fViewers);

    if (fViewers)
    {
        //
        // Our palette color array starts out as all black on each share.
        // So force PMUpdateSystemColors() to do something.
        //
        ASSERT(g_asSharedMemory);
        g_asSharedMemory->pmPaletteChanged = TRUE;
    }

    DebugExitVOID(OE_DDViewing);
}





//
// FUNCTION:    OEDDSetNewCapabilities
//
// DESCRIPTION:
//
// Set the new OE related capabilities
//
// RETURNS:
//
// NONE
//
// PARAMETERS:
//
// pDataIn  - pointer to the input buffer
//
//
void  OEDDSetNewCapabilities(LPOE_NEW_CAPABILITIES pCapabilities)
{
    LPBYTE  lpos16;

    DebugEntry(OEDDSetNewCapabilities);

    //
    // Copy the data from the Share Core.
    //
    g_oeBaselineTextEnabled = pCapabilities->baselineTextEnabled;

    g_oeSendOrders          = pCapabilities->sendOrders;

    g_oeTextEnabled         = pCapabilities->textEnabled;

    //
    // The share core has passed down a pointer to it's copy of the order
    // support array.  We take a copy for the kernel here.
    //
    lpos16 = MapLS(pCapabilities->orderSupported);
    if (SELECTOROF(lpos16))
    {
        hmemcpy(g_oeOrderSupported, lpos16, sizeof(g_oeOrderSupported));
        UnMapLS(lpos16);
    }
    else
    {
        UINT    i;

        ERROR_OUT(("OEDDSetNewCaps:  can't save new order array"));

        for (i = 0; i < sizeof(g_oeOrderSupported); i++)
            g_oeOrderSupported[i] = FALSE;
    }

    TRACE_OUT(( "OE caps: BLT %c Orders %c Text %c",
                 g_oeBaselineTextEnabled ? 'Y': 'N',
                 g_oeSendOrders ? 'Y': 'N',
                 g_oeTextEnabled ? 'Y': 'N'));
                    
    DebugExitVOID(OEDDSetNewCapabilities);
}



//
// FUNCTION:    OEDDSetNewFonts
//
// DESCRIPTION:
//
// Set the new font handling information to be used by the display driver.
//
// RETURNS:
//
// NONE
//
//
void  OEDDSetNewFonts(LPOE_NEW_FONTS pRequest)
{
    HGLOBAL hMem;
    UINT    cbNewSize;
    LPVOID  lpFontData;
    LPVOID  lpFontIndex;

    DebugEntry(OEDDSetNewFonts);

    TRACE_OUT(( "New fonts %d", pRequest->countFonts));

    //
    // Initialize new number of fonts to zero in case an error happens.
    // We don't want to use stale font info if so.  And clear the font
    // cache.
    //
    g_oeNumFonts = 0;
    g_oeFhLast.fontIndex = 0xFFFF;

    g_oeFontCaps = pRequest->fontCaps;

    //
    // Can we get 16:16 addresses for font info?
    //
    lpFontData = MapLS(pRequest->fontData);
    lpFontIndex = MapLS(pRequest->fontIndex);
    if (!lpFontData || !lpFontIndex)
    {
        ERROR_OUT(("OEDDSetNewFonts: couldn't map flat addresses to 16-bit"));
        DC_QUIT;
    }

    //
    // Realloc our current font block if we need to.  Always shrink it
    // too, this thing can get large!
    //
    ASSERT(pRequest->countFonts <= (0xFFFF / sizeof(LOCALFONT)));
    cbNewSize = pRequest->countFonts * sizeof(LOCALFONT);

    hMem = (HGLOBAL)SELECTOROF(g_poeLocalFonts);

    hMem = GlobalReAlloc(hMem, cbNewSize, GMEM_MOVEABLE | GMEM_SHARE);
    if (!hMem)
    {
        ERROR_OUT(("OEDDSetNewFonts: can't allocate space for font info"));
        DC_QUIT;
    }
    else
    {
        g_poeLocalFonts = MAKELP(hMem, 0);
    }

    //
    // We got here, so everything is OK.  Update the font info we have.
    //
    g_oeNumFonts = pRequest->countFonts;

    hmemcpy(g_poeLocalFonts, lpFontData, cbNewSize);

    hmemcpy(g_oeLocalFontIndex, lpFontIndex,
        sizeof(g_oeLocalFontIndex[0]) * FH_LOCAL_INDEX_SIZE);

DC_EXIT_POINT:
    if (lpFontData)
        UnMapLS(lpFontData);

    if (lpFontIndex)
        UnMapLS(lpFontIndex);

    DebugExitVOID(OEDDSetNewFonts);
}



//
// UTILITY ROUTINES
//


//
// OEGetPolarity()
// Gets the axes polarity signs.
//
// NOTE that we fill in the ptPolarity field of our OESTATE global, to
// save on stack.
//
void OEGetPolarity(void)
{
    SIZE    WindowExtent;
    SIZE    ViewportExtent;

    DebugEntry(OEGetPolarity);

    switch (GetMapMode(g_oeState.hdc))
    {
        case MM_ANISOTROPIC:
        case MM_ISOTROPIC:
            GetWindowExtEx(g_oeState.hdc, &WindowExtent);
            GetViewportExtEx(g_oeState.hdc, &ViewportExtent);

            if ((ViewportExtent.cx < 0) == (WindowExtent.cx < 0))
                g_oeState.ptPolarity.x = 1;
            else
                g_oeState.ptPolarity.x = -1;

            if ((ViewportExtent.cy < 0) == (WindowExtent.cy < 0))
                g_oeState.ptPolarity.y = 1;
            else
                g_oeState.ptPolarity.y = -1;
            break;

        case MM_HIENGLISH:
        case MM_HIMETRIC:
        case MM_LOENGLISH:
        case MM_LOMETRIC:
        case MM_TWIPS:
            g_oeState.ptPolarity.x = 1;
            g_oeState.ptPolarity.y = -1;
            break;

        default:
            g_oeState.ptPolarity.x = 1;
            g_oeState.ptPolarity.y = 1;
            break;
    }

    DebugExitVOID(OEGetPolarity);
}


//
// OEGetState()
// This sets up the fields in the g_oeState global, depending on what
// a particular DDI needs.  That is conveyed via the flags.
//
void OEGetState
(
    UINT    uFlags
)
{
    DWORD   dwOrg;

    DebugEntry(OEGetState);

    if (uFlags & OESTATE_COORDS)
    {
        dwOrg = GetDCOrg(g_oeState.hdc);
        g_oeState.ptDCOrg.x = LOWORD(dwOrg);
        g_oeState.ptDCOrg.y = HIWORD(dwOrg);

        OEGetPolarity();
    }

    if (uFlags & OESTATE_PEN)
    {
        // Try to get the pen data
        if (!GetObject(g_oeState.lpdc->hPen, sizeof(g_oeState.logPen),
                &g_oeState.logPen))
        {
            ERROR_OUT(("Couldn't get pen info"));
            g_oeState.logPen.lopnWidth.x = 1;
            g_oeState.logPen.lopnWidth.y = 1;
            g_oeState.logPen.lopnStyle   = PS_NULL;
            uFlags &= ~OESTATE_PEN;
        }
    }

    if (uFlags & OESTATE_BRUSH)
    {
        // Try to get the brush data
        if (!GetObject(g_oeState.lpdc->hBrush, sizeof(g_oeState.logBrush),
                &g_oeState.logBrush))
        {
            ERROR_OUT(("Couldn't get brush info"));
            g_oeState.logBrush.lbStyle = BS_NULL;
            uFlags &= ~OESTATE_BRUSH;
        }
    }

    if (uFlags & OESTATE_FONT)
    {
        // Try to get the logfont data
        if (!GetObject(g_oeState.lpdc->hFont, sizeof(g_oeState.logFont),
            &g_oeState.logFont))
        {
            ERROR_OUT(("Gouldn't get font info"));

            //
            // Fill in an empty face name
            //
            g_oeState.logFont.lfFaceName[0] = 0;
            uFlags &= ~OESTATE_FONT;
        }
        else
        {
            GetTextMetrics(g_oeState.hdc, &g_oeState.tmFont);
            g_oeState.tmAlign = GetTextAlign(g_oeState.hdc);
        }
    }

    if (uFlags & OESTATE_REGION)
    {
        DWORD   cbSize;

        cbSize = GetRegionData(g_oeState.lpdc->hRaoClip,
            sizeof(g_oeState.rgnData), (LPRGNDATA)&g_oeState.rgnData);
        if (cbSize > sizeof(g_oeState.rgnData))
        {
            WARNING_OUT(("Clip region %04x is too big, unclipped drawing may result"));
        }

        if (!cbSize || (cbSize > sizeof(g_oeState.rgnData)))
        {
            // Bound box is best we can do.
            RECT    rcBound;

            if (GetRgnBox(g_oeState.lpdc->hRaoClip, &rcBound) <= NULLREGION)
            {
                WARNING_OUT(("Couldn't even get bounding box of Clip region"));
                SetRectEmpty(&rcBound);
            }

            g_oeState.rgnData.rdh.iType = SIMPLEREGION;
            g_oeState.rgnData.rdh.nRgnSize = sizeof(RDH) + sizeof(RECTL);
            g_oeState.rgnData.rdh.nRectL = 1;
            RECT_TO_RECTL(&rcBound, &g_oeState.rgnData.rdh.arclBounds);
            RECT_TO_RECTL(&rcBound, g_oeState.rgnData.arclPieces);
        }
    }

    g_oeState.uFlags |= uFlags;

    DebugExitVOID(OEGetState);
}


//
// OEPolarityAdjust()
// This swaps the coordinates of a rectangle based on the sign polarity.
//
// NOTE:  We use the g_oeState polarity field.  So this function assumes
// polarity is setup already.
//
void OEPolarityAdjust
(
    LPRECT  aRects,
    UINT    cRects
)
{
    int     tmp;

    DebugEntry(OEPolarityAdjust);

    ASSERT(g_oeState.uFlags & OESTATE_COORDS);

    while (cRects > 0)
    {
        if (g_oeState.ptPolarity.x < 0)
        {
            // Swap left & right
            tmp = aRects->left;
            aRects->left = aRects->right;
            aRects->right = tmp;
        }

        if (g_oeState.ptPolarity.y < 0)
        {
            // Swap top & bottom
            tmp = aRects->top;
            aRects->top = aRects->bottom;
            aRects->bottom = tmp;
        }

        cRects--;
        aRects++;
    }

    DebugExitVOID(OEPolarityAdjust);
}


//
// OECheckOrder()
// This checks for the common stuff that all the DDIs do before deciding
// to send an order or accumulate screen data.
//
BOOL OECheckOrder
(
    DWORD   order,
    UINT    flags
)
{
    if (!OE_SendAsOrder(order))
        return(FALSE);

    if ((flags & OECHECK_PEN) && !OECheckPenIsSimple())
        return(FALSE);

    if ((flags & OECHECK_BRUSH) && !OECheckBrushIsSimple())
        return(FALSE);

    if ((flags & OECHECK_CLIPPING) && OEClippingIsComplex())
        return(FALSE);

    return(TRUE);
}


//
// OELPtoVirtual()
// Converts coords from logical to device (pixels).  This does map mode
// then translation offsets.
//
void OELPtoVirtual
(
    HDC     hdc,
    LPPOINT aPts,
    UINT    cPts
)
{
    LONG    l;
    int     s;

    DebugEntry(OELPtoVirtual);

    ASSERT(g_oeState.uFlags & OESTATE_COORDS);

    ASSERT(hdc == g_oeState.hdc);

    //
    // Convert to pixels
    //
    LPtoDP(hdc, aPts, cPts);

    //
    // Use the device origin, so we can convert from DC-relative to screen
    // coords.
    //

    while (cPts > 0)
    {
        //
        // Prevent overflow
        //
        l = (LONG)aPts->x + (LONG)g_oeState.ptDCOrg.x;
        s = (int)l;

        if (l == (LONG)s)
        {
            aPts->x = s;
        }
        else
        {
            //
            // HIWORD(l) will be 1 for positive overflow, 0xFFFF for
            // negative overflow.  Therefore we will get 0x7FFE or 0x8000
            // (+32766 or -32768).
            //
            aPts->x = 0x7FFF - HIWORD(l);
            TRACE_OUT(("adjusted X from %ld to %d", l, aPts->x));
        }

        //
        // Look for int overflow in the Y coordinate
        //
        l = (LONG)aPts->y + (LONG)g_oeState.ptDCOrg.y;
        s = (int)l;

        if (l == (LONG)s)
        {
            aPts->y = s;
        }
        else
        {
            //
            // HIWORD(l) will be 1 for positive overflow, 0xFFFF for
            // negative overflow.  Therefore we will get 0x7FFE or 0x8000
            // (+32766 or -32768).
            //
            aPts->y = 0x7FFF - HIWORD(l);
            TRACE_OUT(("adjusted Y from %ld to %d", l, aPts->y));
        }

        //
        // Move on to the next point
        //
        --cPts;
        ++aPts;
    }

    DebugExitVOID(OELPtoVirtual);
}



//
// OELRtoVirtual
//
// Adjusts RECT in window coordinates to virtual coordinates.  Clips the
// result to [+32766, -32768] which is near enough to [+32767, -32768]
//
// NB.  This function takes a Windows rectangle (Exclusive coords) and
//      returns a DC-Share rectangle (inclusive coords).
//      This means that any calling function can safely convert to inclusive
//      without having to worry above overflowing.
//
void OELRtoVirtual
(
    HDC     hdc,
    LPRECT  aRects,
    UINT    cRects
)
{
    int     temp;

    DebugEntry(OELRtoVirtual);

    //
    // Convert the points to screen coords, clipping to INT16s
    //
    OELPtoVirtual(hdc, (LPPOINT)aRects, 2 * cRects);

    //
    // Make each rectangle inclusive
    //
    while (cRects > 0)
    {
        //
        // LAURABU BOGUS!
        // Use OEPolarityAdjust() instead, this is safer.
        //

        //
        // If the rect is bad then flip the edges.  This will be the case
        // if the LP coordinate system is running in a different direction
        // than the device coordinate system.
        //
        if (aRects->left > aRects->right)
        {
            TRACE_OUT(("Flipping x coords"));

            temp = aRects->left;
            aRects->left = aRects->right;
            aRects->right = temp;
        }

        if (aRects->top > aRects->bottom)
        {
            TRACE_OUT(("Flipping y coords"));

            temp = aRects->top;
            aRects->top = aRects->bottom;
            aRects->bottom = temp;
        }

        aRects->right--;
        aRects->bottom--;

        //
        // Move on to the next rect
        //
        cRects--;
        aRects++;
    }

    DebugExitVOID(OELRtoVirtual);
}



//
// OE_SendAsOrder()
//
BOOL  OE_SendAsOrder(DWORD order)
{
    BOOL  rc = FALSE;

    DebugEntry(OE_SendAsOrder);

    //
    // Only check the order if we are allowed to send orders in the first
    // place!
    //
    if (g_oeSendOrders)
    {
        TRACE_OUT(("Orders enabled"));

        //
        // We are sending some orders, so check individual flags.
        //
        rc = (BOOL)g_oeOrderSupported[HIWORD(order)];
        TRACE_OUT(("Send order %lx HIWORD %u", order, HIWORD(order)));
    }

    DebugExitDWORD(OE_SendAsOrder, rc);
    return(rc);
}

//
// FUNCTION: OESendRop3AsOrder.
//
// DESCRIPTION:
//
// Checks to see if the rop uses the destination bits. If it does then
// returns FALSE unless the "send all rops" property flag is set.
//
// PARAMETERS: The rop3 to be checked (in protocol format ie a byte).
//
// RETURNS: TRUE if the rop3 should be sent as an order.
//
//
BOOL OESendRop3AsOrder(BYTE rop3)
{
    BOOL   rc = TRUE;

    DebugEntry(OESendRop3AsOrder);

    //
    // Rop 0x5F is used by MSDN to highlight search keywords.  This XORs
    // a pattern with the destination, producing markedly different (and
    // sometimes unreadable) shadow output.  We special-case no-encoding for
    // it.
    //
    if (rop3 == 0x5F)
    {
        WARNING_OUT(("Rop3 0x5F never encoded"));
        rc = FALSE;
    }

    DebugExitBOOL(OESendRop3AsOrder, rc);
    return(rc);
}


//
// OEPenWidthAdjust()
//
// Adjusts a rectangle to allow for the current pen width divided by
// the divisor, rounding up.
//
// NOTE:  This routine uses the logPen and ptPolarity fields of g_oeState.
//
void OEPenWidthAdjust
(
    LPRECT      lprc,
    UINT        divisor
)
{
    UINT        width;
    UINT        roundingFactor = divisor - 1;

    DebugEntry(OEPenWidthAdjust);

    width = max(g_oeState.logPen.lopnWidth.x, g_oeState.logPen.lopnWidth.y);

    InflateRect(lprc,
        ((g_oeState.ptPolarity.x * width) +
             (g_oeState.ptPolarity.x * roundingFactor)) / divisor,
        ((g_oeState.ptPolarity.y * width) +
             (g_oeState.ptPolarity.x * roundingFactor)) / divisor);

    DebugExitVOID(OEPenWidthAdjust);
}



//
// Function:    OEExpandColor
//
// Description: Converts a generic bitwise representation of an RGB color
//              index into an 8-bit color index as used by the line
//              protocol.
//
void  OEExpandColor
(
    LPBYTE  lpField,
    DWORD   srcColor,
    DWORD   mask
)
{
    DWORD   colorTmp;

    DebugEntry(OEExpandColor);

    //
    // Different example bit masks:
    //
    // Normal 24-bit:
    //      0x000000FF  (red)
    //      0x0000FF00  (green)
    //      0x00FF0000  (blue)
    //
    // True color 32-bits:
    //      0xFF000000  (red)
    //      0x00FF0000  (green)
    //      0x0000FF00  (blue)
    //
    // 5-5-5 16-bits
    //      0x0000001F  (red)
    //      0x000003E0  (green)
    //      0x00007C00  (blue)
    //
    // 5-6-5 16-bits
    //      0x0000001F  (red)
    //      0x000007E0  (green)
    //      0x0000F800  (blue)
    //
    //
    // Convert the color using the following algorithm.
    //
    // <new color> = <old color> * <new bpp mask> / <old bpp mask>
    //
    // where:
    //
    // new bpp mask = mask for all bits at new setting (0xFF for 8bpp)
    //
    // This way maximal (eg.  0x1F) and minimal (eg.  0x00) settings are
    // converted into the correct 8-bit maximum and minimum.
    //
    // Rearranging the above equation we get:
    //
    // <new color> = (<old color> & <old bpp mask>) * 0xFF / <old bpp mask>
    //
    // where:
    //
    // <old bpp mask> = mask for the color
    //

    //
    // LAURABU BOGUS:
    // We need to avoid overflow caused by the multiply.  NOTE:  in theory
    // we should use a double, but that's painfully slow.  So for now hack
    // it.  If the HIBYTE is set, just right shift 24 bits.
    //
    colorTmp = srcColor & mask;
    if (colorTmp & 0xFF000000)
        colorTmp >>= 24;
    else
        colorTmp = (colorTmp * 0xFF) / mask;
    *lpField = (BYTE)colorTmp;

    TRACE_OUT(( "0x%lX -> 0x%X", srcColor, (WORD)*lpField));

    DebugExitVOID(OEExpandColor);
}


//
// OEConvertColor()
// Converts a PHYSICAL color to a real RGB
//
void OEConvertColor
(
    DWORD           rgb,
    LPTSHR_COLOR    lptshrDst,
    BOOL            fAllowDither
)
{
    DWORD           rgbConverted;
    PALETTEENTRY    pe;
    int             pal;
    DWORD           numColors;

    DebugEntry(OEConvertColor);

    rgbConverted = rgb;

    //
    // Get the current palette size.
    //
    GetObject(g_oeState.lpdc->hPal, sizeof(pal), &pal);
    if (pal == 0)
    {
        //
        // GDI has a bug.  It allows a ResizePalette() call to set a new
        // size of zero for the palette.  If you subsequently make
        // certain palette manager calls on such a palette, GDI will fault.
        //
        // To avoid this problem, as seen in 3D Kitchen by Books that Work,
        // we check for this case and simply return the input color.
        //
        WARNING_OUT(("Zero-sized palette"));
        DC_QUIT;
    }

    if (g_oeState.lpdc->hPal == g_oeStockPalette)
    {
        //
        // Quattro Pro and others put junk in the high bits of their colors.
        // We need to mask it out.
        //
        if (rgb & 0xFC000000)
        {
            rgb &= 0x00FFFFFF;
        }
        else
        {
            if (rgb & PALETTERGB_FLAG)
            {
                //
                // Using PALETTERGB is just like using an RGB, turn it off.
                // The color will be dithered, if necessary, using the
                // default system colors.
                //
                rgb &= 0x01FFFFFF;

            }
        }
    }

    if (rgb & COLOR_FLAGS)
    {
        if (rgb & PALETTERGB_FLAG)
        {
            pal = GetNearestPaletteIndex(g_oeState.lpdc->hPal, rgb);
        }
        else
        {
            ASSERT(rgb & PALETTEINDEX_FLAG);
            pal = LOWORD(rgb);
        }

        //
        // Look up entry in palette.
        //
        if (!GetPaletteEntries(g_oeState.lpdc->hPal, pal, 1, &pe))
        {
            ERROR_OUT(("GetPaletteEntries failed for index %d", pal));
            *((LPDWORD)&pe) = 0L;
        }
        else if (pe.peFlags & PC_EXPLICIT)
        {
            //
            // If this is PC_EXPLICIT, it's an index into the system 
            // palette.
            //
            pal = LOWORD(*((LPDWORD)&pe));

            if (g_osiScreenBPP < 32)
            {
                numColors = 1L << g_osiScreenBPP;
            }
            else
            {
                numColors = 0xFFFFFFFF;
            }

            if (numColors > 256)
            {
                //
                // We are on a direct color device.  What does explicit 
                // mean in this case?  The answer is, use the VGA color
                // palette.
                //
                pe = g_osiVgaPalette[pal % 16];
            }
            else
            {
                pal %= numColors;

                GetSystemPaletteEntries(g_oeState.hdc, pal, 1, &pe);
            }
        }

        rgbConverted = *((LPDWORD)&pe);
    }

DC_EXIT_POINT:
    //
    // To get the correct results for any RGBs we send to true color systems,
    // we need to normalize the RGB to an exact palette match on the local
    // system.  This is because we aren't guaranteed that the RGB on the 
    // local will have an exact match to the current system palette.  If
    // not, then GDI will convert them locally, but the orders will send
    // to remotes will be displayed exactly, resulting in a mismatch.
    //
    if ((g_osiScreenBPP == 8)   &&
        !(rgb & COLOR_FLAGS)    &&
        (!fAllowDither || (g_oeState.lpdc->hPal != g_oeStockPalette)))
    {
        TSHR_RGBQUAD    rgq;

        rgbConverted &= 0x00FFFFFF;

        //
        // Common cases.
        //
        if ((rgbConverted == RGB(0, 0, 0)) ||
            (rgbConverted == RGB(0xFF, 0xFF, 0xFF)))
        {
            goto ReallyConverted;
        }

        //
        // g_osiScreenBMI.bmiHeader is already filled in.
        //

        //
        // NOTE:
        // We don't need or want to realize any palettes.  We want color
        // mapping based on the current screen palette contents.
        //
        // We disable SetPixel() patch, or our trap will trash the
        // variables for this call.
        //

        //
        // g_osiMemoryDC() always has our 1x1 color bitmap g_osiMemoryBMP
        // selected into it.
        //

        EnableFnPatch(&g_oeDDPatches[DDI_SETPIXEL], PATCH_DISABLE);
        SetPixel(g_osiMemoryDC, 0, 0, rgbConverted);
        EnableFnPatch(&g_oeDDPatches[DDI_SETPIXEL], PATCH_ENABLE);

        //
        // Get mapped color index
        //
        GetDIBits(g_osiMemoryDC, g_osiMemoryBMP, 0, 1, &pal,
            (LPBITMAPINFO)&g_osiScreenBMI, DIB_RGB_COLORS);

        rgq =  g_osiScreenBMI.bmiColors[LOBYTE(pal)];

        OTRACE(("Mapped color %08lx to %08lx", rgbConverted,
            RGB(rgq.rgbRed, rgq.rgbGreen, rgq.rgbBlue)));

        rgbConverted = RGB(rgq.rgbRed, rgq.rgbGreen, rgq.rgbBlue);
    }

ReallyConverted:
    lptshrDst->red  = GetRValue(rgbConverted);
    lptshrDst->green = GetGValue(rgbConverted);
    lptshrDst->blue = GetBValue(rgbConverted);

    DebugExitVOID(OEConvertColor);
}



//
// OEGetBrushInfo()
// Standard brush goop
//
void OEGetBrushInfo
(
    LPTSHR_COLOR    pBack,
    LPTSHR_COLOR    pFore,
    LPTSHR_UINT32   pStyle,
    LPTSHR_UINT32   pHatch,
    LPBYTE          pExtra
)
{
    int             iRow;

    DebugEntry(OEGetBrushInfo);

    OEConvertColor(g_oeState.lpdc->DrawMode.bkColorL, pBack, FALSE);

    *pStyle = g_oeState.logBrush.lbStyle;

    if (g_oeState.logBrush.lbStyle == BS_PATTERN)
    {
        //
        // We only track mono patterns, so the foreground color is the 
        // brush color.
        //
        OEConvertColor(g_oeState.lpdc->DrawMode.txColorL, pFore, FALSE);

        // For pattern brushes, the hatch stores the 1st pattern byte,
        // the Extra field the remaining 7 pattern bytes
        *pHatch = g_oeState.logBrushExtra[0];
        hmemcpy(pExtra, g_oeState.logBrushExtra+1, TRACKED_BRUSH_SIZE-1);
    }
    else
    {
        ASSERT(g_oeState.logBrush.lbStyle != BS_DIBPATTERN);

        OEConvertColor(g_oeState.logBrush.lbColor, pFore, TRUE);

        // The hatch is the hatch style
        *pHatch = g_oeState.logBrush.lbHatch;

        // Extra info is empty
        for (iRow = 0; iRow < TRACKED_BRUSH_SIZE-1; iRow++)
        {
            pExtra[iRow] = 0;
        }
    }

    DebugExitVOID(OEGetBrushInfo);
}



//
// OEClippingIsSimple()
//
BOOL OEClippingIsSimple(void)
{
    BOOL        fSimple;
    RECT        rc;

    DebugEntry(OEClippingIsSimple);

    ASSERT(g_oeState.uFlags & OESTATE_REGION);

    fSimple = (g_oeState.rgnData.rdh.nRectL <= 1);

    DebugExitBOOL(OEClippingIsSimple, fSimple);
    return(fSimple);
}

//
// OEClippingIsComplex()
//
BOOL OEClippingIsComplex(void)
{
    BOOL        fComplex;

    DebugEntry(OEClippingIsComplex);

    ASSERT(g_oeState.uFlags & OESTATE_REGION);

    fComplex = (g_oeState.rgnData.rdh.nRgnSize >=
        sizeof(RDH) + CRECTS_COMPLEX*sizeof(RECTL));

    DebugExitBOOL(OEClippingIsComplex, fComplex);
    return(fComplex);
}



//
// OECheckPenIsSimple()
//
BOOL OECheckPenIsSimple(void)
{
    POINT   ptArr[2];
    BOOL    fSimple;

    DebugEntry(OECheckPenIsSimple);

    if (g_oeState.uFlags & OESTATE_PEN)
    {
        ptArr[0].x = ptArr[0].y = 0;
        ptArr[1].x = g_oeState.logPen.lopnWidth.x;
        ptArr[1].y = 0;

        LPtoDP(g_oeState.hdc, ptArr, 2);

        fSimple = ((ptArr[1].x - ptArr[0].x) <= 1);
    }
    else
    {
        // The current pen in the DC is invalid
        WARNING_OUT(("Invalid pen selected into DC"));
        fSimple = FALSE;
    }

    DebugExitBOOL(OECheckPenIsSimple, fSimple);
    return(fSimple);
}


//
// OECheckBrushIsSimple()
//
BOOL OECheckBrushIsSimple(void)
{
    BOOL    fSimple;

    DebugEntry(OECheckBrushIsSimple);

    // Assume not simple
    fSimple = FALSE;

    if (g_oeState.uFlags & OESTATE_BRUSH)
    {
        //
        // If the brush is a pattern, it's OK if one of standard pattern 
        // brushes.  If it comes from a DIB, it's never OK.  All other 
        // brushes are OK.
        //
        if (g_oeState.logBrush.lbStyle == BS_PATTERN)
        {
            LPGDIHANDLE lpgh;
            LPBRUSH     lpBrush;
            LPBITMAP    lpPattern;

            //
            // For pattern brushes, the lbHatch field of the ilBrushOverhead
            // item in the GDI local BRUSH object is a global handle to
            // a memory block that is the BITMAP of the thing.
            //

            //
            // BOGUS LAURABU:
            // NM 2.0 Win95 went to a lot more work to check if a color bitmap
            // pattern brush had only 2 colors and therefore was orderable.  But 
            // I can't find a single that uses such a thing.  So for now, we just 
            // care if the pattern bitmap is monochrome and the pattern is between 8x8 and
            // 16x8.
            //

            // Get a pointer to the brush data
            lpgh = MAKELP(g_hInstGdi16, g_oeState.lpdc->hBrush);
            ASSERT(!IsBadReadPtr(lpgh, sizeof(DWORD)));
            ASSERT(!(lpgh->objFlags & OBJFLAGS_SWAPPEDOUT));

            lpBrush = MAKELP(g_hInstGdi16, lpgh->pGdiObj);
            ASSERT(!IsBadReadPtr(lpBrush, sizeof(BRUSH)));

            // Get the bitmapinfo handle -- it's the lbHatch field
            lpPattern = MAKELP(lpBrush->ilBrushOverhead.lbHatch, 0);

            //
            // Macromedia Director among others creates pattern brushes
            // with no pattern.  We therefore consider these objects to
            // be too complex to send in an order
            //

            //
            // Is this monochrome with a pattern between 8 and 16 pels?
            // We save the left 8 pixel grid if so.
            //
            if (!IsBadReadPtr(lpPattern, sizeof(BITMAP)) &&
                (lpPattern->bmWidth >= MIN_BRUSH_WIDTH) &&
                (lpPattern->bmWidth <= MAX_BRUSH_WIDTH) &&
                (lpPattern->bmHeight == TRACKED_BRUSH_HEIGHT) &&
                (lpPattern->bmPlanes == 1) && (lpPattern->bmBitsPixel == 1))
            {
                LPUINT  lpRow;
                int     iRow;

                // Save the pattern away in logBrushExtra
                lpRow = lpPattern->bmBits;
                ASSERT(!IsBadReadPtr(lpRow, TRACKED_BRUSH_HEIGHT*sizeof(UINT)));

                //
                // The pattern is always WORD aligned.  But only the
                // LOBYTE has meaning.  
                // 
                // NOTE:
                // We fill the pattern in DIB order, namely bottom to
                // top.
                //
                ASSERT(lpPattern->bmWidthBytes == 2);
                for (iRow = 0; iRow < TRACKED_BRUSH_HEIGHT; iRow++, lpRow++)
                {
                    g_oeState.logBrushExtra[TRACKED_BRUSH_HEIGHT - 1 - iRow] =
                        (BYTE)*lpRow;
                }

                fSimple = TRUE;
            }
        }
        else if (g_oeState.logBrush.lbStyle != BS_DIBPATTERN)
        {
            fSimple = TRUE;
        }
    }
    else
    {
        WARNING_OUT(("Invalid brush selected into DC"));
    }

    DebugExitBOOL(OECheckBrushIsSimple, fSimple);
    return(fSimple);
}




//
// OEAddLine()
// This calculates the bounds of a line output call, and either adds an
// order or gets set for screen data accum.
//
void OEAddLine
(
    POINT       ptStart,
    POINT       ptEnd
)
{
    LPINT_ORDER     pOrder;
    LPLINETO_ORDER  pLineTo;

    DebugEntry(OEAddLine);

    //
    // Get the bounds
    //
    g_oeState.rc.left = min(ptStart.x, ptEnd.x);
    g_oeState.rc.top  = min(ptStart.y, ptEnd.y);
    g_oeState.rc.right = max(ptStart.x, ptEnd.x);
    g_oeState.rc.bottom = max(ptStart.y, ptEnd.y);

    //
    // Adjust for axes polarity and pen dimensions
    //
    ASSERT(g_oeState.uFlags & OESTATE_COORDS);

    OEPolarityAdjust(&g_oeState.rc, 1);
    OEPenWidthAdjust(&g_oeState.rc, 1);

    //
    // OEPenWidthAdjust returns an inclusive rect.  But OELRtoVirtual
    // expects an exclusive.  After it returns, we need to add back
    // the extra subtraction.
    //
    // NOTE that OELRtoVirtual also adjusts for virtual desktop origin.
    //
    OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

    g_oeState.rc.right++;
    g_oeState.rc.bottom++;

    //
    // Now we have the true draw bounds.  Can we send this as an order?
    //
    pOrder = NULL;

    if (OECheckOrder(ORD_LINETO, OECHECK_PEN | OECHECK_CLIPPING))
    {
        //
        // We can send an order.
        //
        pOrder = OA_DDAllocOrderMem(sizeof(LINETO_ORDER), 0);
        if (!pOrder)
            DC_QUIT;

        pLineTo = (LPLINETO_ORDER)pOrder->abOrderData;

        pLineTo->type      = LOWORD(ORD_LINETO);

        //
        // Must do this first:  oords in the LINETO order are 32-bit
        //
        OELPtoVirtual(g_oeState.hdc, &ptStart, 1);
        OELPtoVirtual(g_oeState.hdc, &ptEnd, 1);

        pLineTo->nXStart   = ptStart.x;
        pLineTo->nYStart   = ptStart.y;
        pLineTo->nXEnd     = ptEnd.x;
        pLineTo->nYEnd     = ptEnd.y;

        //
        // This is a physical color
        //
        OEConvertColor(g_oeState.lpdc->DrawMode.bkColorL,
            &pLineTo->BackColor, FALSE);

        pLineTo->BackMode  = g_oeState.lpdc->DrawMode.bkMode;
        pLineTo->ROP2      = g_oeState.lpdc->DrawMode.Rop2;
        pLineTo->PenStyle  = g_oeState.logPen.lopnStyle;

        //
        // Currently only pen withs of 1 are supported.  Unfortunately
        // GDI left it up to the driver to decide on how to stroke the
        // line, so we can't predict what pixels will be on or off for
        // pen widths bigger.
        //
        pLineTo->PenWidth = 1;

        //
        // This is a logical color
        //
        OEConvertColor(g_oeState.logPen.lopnColor, &pLineTo->PenColor,
            FALSE);

        //
        // Store the general order data.
        //
        pOrder->OrderHeader.Common.fOrderFlags   = OF_SPOILABLE;

        //
        // This will add in OESTATE_SENTORDER if it succeeded.
        // Then OEDDPostStopAccum() will ignore screen data, or
        // will add our nicely calculated bounds above in instead.
        //
        OTRACE(("Line:  Start {%d, %d}, End {%d, %d}", ptStart.x, ptStart.y,
            ptEnd.x, ptEnd.y));
        OEClipAndAddOrder(pOrder, NULL);
    }

DC_EXIT_POINT:
    if (!pOrder)
    {
        OTRACE(("Line:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }

    DebugExitVOID(OEAddLine);
}




//
// OEValidateDC()
// This makes sure the thing passed in is a valid DC and gets a pointer to
// the DC data structure in GDI if so.  We need to handle the (rare) case
// of the DC being swapped out to GDI's extended flat memory space as well 
// as the HDC being prsent in GDI's 16-bit dataseg
//
// NOTE:
// It is NOT valid to hang on to a LPDC around a GDI call.  Something may
// be swapped out before the call, then get swapped in after the call.  
// In which case the original based32 ptr gets freed.  And vice-versa, the
// original GDI dc-16 localptr may get realloced small.
//
// In normal usage, this is very fast.  Only in low memory (or when 
// parameters are invalid) does doing this twice even matter.
//
LPDC OEValidateDC
(
    HDC     hdc,
    BOOL    fSrc
)
{
    LPDC        lpdc = NULL;
    LPGDIHANDLE lpgh;
    DWORD       dwBase;

    DebugEntry(OEDDValidateDC);

    if (IsGDIObject(hdc) != GDIOBJ_DC)
    {
        // 
        // This is a metafile HDC, an IC, or just a plain old bad param.
        //
        DC_QUIT;
    }

    //
    // OK. The HDC is a local handle to two words in GDI's DS:
    //      * 1st is actual ptr of DC (or local32 handle if swapped out)
    //      * 2nd is flags
    //
    // NOTE:
    // Gdi's data segment is already GlobalFixed().  So we don't have to
    // worry about it moving.
    //
    lpgh = MAKELP(g_hInstGdi16, hdc);
    if (lpgh->objFlags & OBJFLAGS_SWAPPEDOUT)
    {
        UINT    uSel;

        //
        // This is an error only so we can actually stop when we hit this
        // rare case and make sure our code is working!
        //
        WARNING_OUT(("DC is swapped out, getting at far heap info"));

        //
        // Need to make our cached selector  point at this thing.  NOTE that
        // in OEDDStopAccum, we need to reget lpdc since it will have been
        // swapped in during the output call.
        //

        dwBase = GetSelectorBase((UINT)g_hInstGdi16);
        ASSERT(dwBase);

        uSel = (fSrc ? g_oeSelSrc : g_oeSelDst);
        SetSelectorBase(uSel, dwBase + 0x10000);

        //
        // The pGdiObj is the local32 handle.  GDI:10000+pGdiObj has a DWORD
        // which is the based32 address, relative to GDI's dataseg, of the DC.
        // We've set the base of our selector 64K higher than GDI, so we can
        // use it as an offset directly.
        //
        ASSERT(!IsBadReadPtr(MAKELP(uSel, lpgh->pGdiObj), sizeof(DWORD)));
        dwBase = *(LPDWORD)MAKELP(uSel, lpgh->pGdiObj);
        
        //
        // The 16-bit base is the nearest 64K less than this 32-bit pointer,
        // above GDI's ds.
        //
        SetSelectorBase(uSel, GetSelectorBase((UINT)g_hInstGdi16) +
            (dwBase & 0xFFFF0000));

        //
        // Remainder is slop past 64K.
        //
        lpdc = MAKELP(uSel, LOWORD(dwBase));
    }
    else
    {
        lpdc = MAKELP(g_hInstGdi16, lpgh->pGdiObj);
    }

    ASSERT(!IsBadReadPtr(lpdc, sizeof(DC)));

DC_EXIT_POINT:
    DebugExitDWORD(OEDDValidateDC, (DWORD)lpdc);
    return(lpdc);
}


//
// OEBeforeDDI()
//
// This does all the common stuff at the start of an intercepted DDI call:
//      * Increment the reentrancy count
//      * Disable the patch
//      * Get a ptr to the DC structure (if valid)
//      * Get some attributes about the DC (if valid)
//      * Set up to get the drawing bounds calculated in GDI
//
BOOL OEBeforeDDI
(
    DDI_PATCH   ddiType,
    HDC         hdcDst,
    UINT        uFlags
)
{
    LPDC        lpdc;
    BOOL        fWeCare = FALSE;

    DebugEntry(OEBeforeDDI);

    EnableFnPatch(&g_oeDDPatches[ddiType], PATCH_DISABLE);
    if (++g_oeEnterCount > 1)
    {
        TRACE_OUT(("Skipping nested output call"));
        DC_QUIT;
    }

    //
    // Get a pointer to the destination DC.  Since we may have an output
    // call where both the source and dest are swapped out, we may need to
    // use both our cached selectors.  Thus, we must to tell OEValidateDC()
    // which DC this is to avoid collision.
    //
    lpdc = OEValidateDC(hdcDst, FALSE);
    if (!SELECTOROF(lpdc))
    {
        TRACE_OUT(("Bogus DC"));
        DC_QUIT;
    }

    //
    // Is this a screen DC w/o an active path?  When a path is active, the
    // output is being recorded into a path, which is like a region.  Then
    // stroking/filling the path can cause output.
    //
    if (!(lpdc->DCFlags & DC_IS_DISPLAY) ||
         (lpdc->fwPath & DCPATH_ACTIVE))
    {
        TRACE_OUT(("Not screen DC"));
        DC_QUIT;
    }

    //
    // Only if this is a screen DC do we care about where the output is 
    // going to happen.  For memory DCs,
    //
    // If this is a bitmap DC or a path is active, we want to mess with
    // the bitmap cache.
    if (lpdc->DCFlags & DC_IS_MEMORY)
    {
        //
        // No screen data or other goop accumulated for non-output calls
        // We just want to do stuff in OEAfterDDI.
        //
        uFlags &= ~OESTATE_DDISTUFF;
        goto WeCareWeReallyCare;
    }
    else
    {
        //
        // Is this a DC we care about?  Our algorithm is:
        //      * If sharing the desktop, yes.
        //      * If no window associated with DC or window is desktop, maybe.
        //      * If window is ancestor of shared window, yes.  Else no.
        //

        if (!g_hetDDDesktopIsShared)
        {
            HWND    hwnd;
            HWND    hwndP;

            hwnd = WindowFromDC(hdcDst);

            //
            // LAURABU:
            // Should we blow off painting into the desktop window?  It's
            // either clipped, in which case it's the shell background
            // painting, or it's not, in which case it's the non-full drag
            // dotted lines.
            //
            if (hwnd && (hwnd != g_osiDesktopWindow))
            {
                //
                // If this is our cache, the result is g_oeLastWindowShared.
                // Otherwise, compute it.
                //
                // Note that the HET code clears the cache when the cached 
                // window
                // goes away, or any window changes its sharing status since in
                // that case this window may be a descendant and hence not shared.
                //
                if (hwnd != g_oeLastWindow)
                {
                    TRACE_OUT(("oeLastWindow cache miss: %04x, now %04x", g_oeLastWindow, hwnd));

                    //
                    // Cache this dude.  Note that we don't care about
                    // visibility, since we know we won't get real painting
                    // into an invisible window (it has an empty visrgn).
                    //
                    g_oeLastWindow = hwnd;
                    g_oeLastWindowShared = HET_WindowIsHosted(hwnd);
                }
                else
                {
                    TRACE_OUT(("oeLastWindow cache hit:  %04x", g_oeLastWindow));
                }

                //
                // This window isn't shared.
                //
                if (!g_oeLastWindowShared)
                {
                    TRACE_OUT(("Output in window %04x: don't care", g_oeLastWindow));
                    DC_QUIT;
                }
            }
        }
    }

    //
    // Code from here to WeCareWeReallyCare() is only for screen DCs
    //

    //
    // For the *TextOut* apis, we want to accumulate DCBs if the font is too
    // complex.
    //
    if (uFlags & OESTATE_SDA_FONTCOMPLEX)
    {
        BOOL    fComplex;
        POINT   aptCheck[2];

        fComplex = TRUE;

        // Get the logfont info
        if (!GetObject(lpdc->hFont, sizeof(g_oeState.logFont), &g_oeState.logFont) ||
            (g_oeState.logFont.lfEscapement != 0))
            goto FontCheckDone;

        //
        // The font is too complex if it has escapement or the logical units
        // are bigger than pixels.
        //
        // NOTE that NM 2.0 had a bug--it used one point only for non
        // MM_TEXT mode.  They did this because they wouldn't get back
        // the same thing passed in, forgetting that LPtoDP takes into
        // account viewport and window origins in addition to scaling.
        //
        // So we do this the right way, using two points and looking at
        // the difference.
        //
        aptCheck[0].x = 0;
        aptCheck[0].y = 0;
        aptCheck[1].x = 1000;
        aptCheck[1].y = 1000;

        LPtoDP(hdcDst, aptCheck, 2);

        if ((aptCheck[1].x - aptCheck[0].x <= 1000) ||
            (aptCheck[1].y - aptCheck[0].y <= 1000))
        {
            fComplex = FALSE;
        }

FontCheckDone:
        if (fComplex)
        {
            TRACE_OUT(("Font too complex for text order"));
            uFlags |= OESTATE_SDA_DCB;
        }
    }

    //
    // Some DDIs calculate their own bound rects, which is faster than
    // GDI's BoundsRect() services.  But some don't because it's too 
    // complicated.  In that case, we do it for 'em.
    //
    if (uFlags & OESTATE_SDA_DCB)
    {
        //
        // We don't have to worry about the mapping mode when getting the 
        // bounds.  The only thing to note is that the return rect is 
        // relative to the window org of the DC, and visrgn/clipping occurs
        //
        g_oeState.uGetDCB = GetBoundsRect(hdcDst, &g_oeState.rcDCB, 0);
        g_oeState.uSetDCB = SetBoundsRect(hdcDst, NULL, DCB_ENABLE | DCB_RESET)
            & (DCB_ENABLE | DCB_DISABLE);

        // No curpos needed if going as screen data, not order
        uFlags &= ~OESTATE_CURPOS;
    }

    if (uFlags & OESTATE_CURPOS)
    {
        GetCurrentPositionEx(hdcDst, &g_oeState.ptCurPos);
    }

WeCareWeReallyCare:
    fWeCare = TRUE;
    g_oeState.uFlags = uFlags;
    g_oeState.hdc    = hdcDst;

DC_EXIT_POINT:
    DebugExitBOOL(OEBeforeDDI, fWeCare);
    return(fWeCare);
}


//
// OEAfterDDI()
// 
// This does all the common things right after a DDI call.  It returns TRUE
// if output happened into a screen DC that we care about.
//
BOOL OEAfterDDI
(
    DDI_PATCH   ddiType,
    BOOL        fWeCare,
    BOOL        fOutput
)
{
    DebugEntry(OEAfterDDI);

    //
    // Reenable patch
    //
    EnableFnPatch(&g_oeDDPatches[ddiType], PATCH_ENABLE);
    --g_oeEnterCount;

    if (!fWeCare)
    {
        // 
        // This was reentrant, we don't care about output into this
        // DC, or something went wrong, bail out.
        //
        DC_QUIT;
    }

    g_oeState.lpdc = OEValidateDC(g_oeState.hdc, FALSE);
    if (!SELECTOROF(g_oeState.lpdc))
    {
        ERROR_OUT(("Bogus DC"));
        DC_QUIT;
    }
    ASSERT(g_oeState.lpdc->DCFlags & DC_IS_DISPLAY);
    ASSERT(!(g_oeState.lpdc->fwPath & DCPATH_ACTIVE));

    //
    // If this output happened into a memory bitmap, see if it affects
    // SPBs or our sent bitmap cache
    //
    if (g_oeState.lpdc->DCFlags & DC_IS_MEMORY)
    {
        //
        // Don't set fOutput to FALSE for SPB operations, we want
        // BitBlt to look at it.
        //
        if (fOutput)
        {
            // If this is BitBlt, check for SPB creation
            if ((ddiType != DDI_BITBLT) ||
                (g_oeState.lpdc->hBitmap != g_ssiLastSpbBitmap))
            {
                fOutput = FALSE;
            }
        }
    }
    else
    {
        //
        // Drawing on the screen that isn't going to be handled in the DDI
        // call.
        //
        if (fOutput && (g_oeState.uFlags & OESTATE_SDA_MASK))
        {
            //
            // We do some common tasks that several DDIs would have to do
            //      * take the screen bounds and add as SD
            //      * take the draw bounds and add as SD
            //
            OEGetState(OESTATE_COORDS | OESTATE_REGION);

            if (g_oeState.uFlags & OESTATE_SDA_DCB)
            {
                //
                // Get the drawing bounds
                //
                int     mmMode;
                SIZE    ptWindowExt;
                SIZE    ptViewportExt;
                int     uBoundsNew;

                mmMode = GetMapMode(g_oeState.hdc);
                if (mmMode != MM_TEXT)
                {
                    //
                    // Changing the map mode whacks the window/view exts
                    // So save them so we can replace them when done.
                    //
                    GetWindowExtEx(g_oeState.hdc, &ptWindowExt);
                    GetViewportExtEx(g_oeState.hdc, &ptViewportExt);

                    SetMapMode(g_oeState.hdc,  MM_TEXT);
                }
                
                //
                // Get the drawing bounds and update them.
                //
                uBoundsNew = GetBoundsRect(g_oeState.hdc, &g_oeState.rc, DCB_RESET);

                //
                // If no drawing bounds updated, act like no output happened.
                //
                if ((uBoundsNew & DCB_SET) == DCB_RESET)
                {
                    fOutput = FALSE;
                }
                else
                {
                    OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);
                }

                if (mmMode != MM_TEXT)
                {
                    SetMapMode(g_oeState.hdc, mmMode);

                    // Put back the window, viewport exts; SetMapMode wipes them out
                    SetWindowExt(g_oeState.hdc, ptWindowExt.cx, ptWindowExt.cy);
                    SetViewportExt(g_oeState.hdc, ptViewportExt.cx, ptViewportExt.cy);
                }
            }
            else
            {
                ASSERT(g_oeState.uFlags & OESTATE_SDA_SCREEN);

                g_oeState.rc.left = g_osiScreenRect.left;
                g_oeState.rc.top  = g_osiScreenRect.top;
                g_oeState.rc.right = g_osiScreenRect.right - 1;
                g_oeState.rc.bottom = g_osiScreenRect.bottom - 1;
            }

            if (fOutput)
            {
                if (g_oeState.uFlags & OESTATE_OFFBYONEHACK)
                    g_oeState.rc.bottom++;

                OEClipAndAddScreenData(&g_oeState.rc);

                // This way caller won't do anything else.
                fOutput = FALSE;
            }

            //
            // Put back the draw bounds if we'd turned them on.
            //
            if (g_oeState.uFlags & OESTATE_SDA_DCB)
            {
                if (g_oeState.uGetDCB == DCB_SET)
                {
                    SetBoundsRect(g_oeState.hdc, &g_oeState.rcDCB,
                        g_oeState.uSetDCB | DCB_ACCUMULATE);
                }
                else
                {
                    SetBoundsRect(g_oeState.hdc, NULL,
                        g_oeState.uSetDCB | DCB_RESET);
                }
            }
        }
    }

DC_EXIT_POINT:
    DebugExitBOOL(OEAfterDDI, (fWeCare && fOutput));
    return(fWeCare && fOutput);

}



//
// OEClipAndAddScreenData()
//
void OEClipAndAddScreenData
(
    LPRECT      lprcAdd
)
{
    RECT            rcSDA;
    RECT            rcClipped;
    LPRECTL         pClip;
    UINT            iClip;

    DebugEntry(OEClipAndAddScreenData);

    ASSERT(g_oeState.uFlags & OESTATE_REGION);

    //
    // The rect passed is in virtual desktop inclusive coords.  Convert to
    // Windows screen coords
    //
    rcSDA.left      = lprcAdd->left;
    rcSDA.top       = lprcAdd->top;
    rcSDA.right     = lprcAdd->right + 1;
    rcSDA.bottom    = lprcAdd->bottom + 1;

    //
    // We've got our region data.  In the case of a region that has more
    // than 64 pieces, we just use the bound box (one piece), that's been
    // set up for us already.
    //

    //
    // Intersect each piece with the total bounds to product an SDA rect
    // clipped appropriately.
    //
    for (iClip = 0, pClip = g_oeState.rgnData.arclPieces;
         iClip < g_oeState.rgnData.rdh.nRectL; iClip++, pClip++)
    {
        RECTL_TO_RECT(pClip, &rcClipped);

        if (IntersectRect(&rcClipped, &rcClipped, &rcSDA))
        {
            //
            // Convert to virtual desktop inclusive coords
            //
            rcClipped.right -= 1;
            rcClipped.bottom -= 1;

            BA_AddScreenData(&rcClipped);
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(OEClipAndAddScreenData);
}



//
// FUNCTION: OEClipAndAddOrder
//
// DESCRIPTION:
//
// Clips the supplied order to the current clip region in the DC.  If this
// results in more than one clipped rectangle then the order is duplicated
// and multiple copies are added to the Order List (with the only
// difference between the orders being the destination rectangle).
//
// PARAMETERS: pOrder - a pointer to the order
//
// RETURNS: VOID
//
//
void OEClipAndAddOrder
(
    LPINT_ORDER pOrder,
    void FAR*   lpExtraInfo
)
{
    RECT        rcOrder;
    RECT        rcPiece;
    RECT        rcClipped;
    LPRECTL     pPiece;
    UINT        iClip;
    BOOL        fOrderClipped;
    LPINT_ORDER pNewOrder;
    LPINT_ORDER pLastOrder;

    DebugEntry(OEClipAndAddOrder);

    ASSERT(g_oeState.uFlags & OESTATE_REGION);

    //
    // If this fails somewhere, we accumulate screen data in the same place
    // to spoil the order(s).
    //

    //
    // NOTE:
    // There are some VERY important things about the way this function
    // works that you should be aware of:
    //
    // (1) Every time an order is allocated, it is added to the end of
    // the order heap linked list
    // (2) Appending an order commits it, that updates some total byte info.
    // If the order is a spoiler, the append code will walk backwards from
    // the order being appended and will wipe out orders whose bounds are
    // completely contained within the rect of the current one.
    //
    // THEREFORE, it is important to append orders in the order they are
    // allocated it.  When we come into this function, one order is already
    // allocated.  Its rcsDst bound rect is uninitialized.  When a second
    // intersection with the visrgn occurs, we must allocate a new order, 
    // but append the previously allocated block with the previous rect
    // info.  
    // 
    // Otherwise you will encounter the bug that took me a while to figure
    // out:
    //      * Laura allocates an order in say PatBlt with a spoiler ROP
    //      * Laura calls OEClipAndAddOrder and of course the rcsDst field
    //          hasn't been initialized yet.
    //      * The order intersects two pieces of the visrgn.  On the first
    //          intersection, we save that info away.
    //      * On the second, we allocate a new order block, fill in the NEW
    //          order's info by copying from the old, setting up the rect
    //          with the first intersection, and call OA_DDAddOrder.
    //      * This, as a spoiler, causes the OA_ code to walk backwards in
    //          the linked list looking for orders whose bounds are
    //          completely enclosed by this one.
    //      * It comes to the original order allocated, whose bounds are
    //          currently NOT initialized
    //      * It may find that these uninitialized values describe a rect
    //          contained within the new order's bounds
    //      * It frees this order but the order was not yet committed
    //      * The heap sizes and heap info no longer match, causing an
    //          error about the "List head wrong", the list to get reinited,
    //          and orders to be lost.
    //

    rcOrder.left    = g_oeState.rc.left;
    rcOrder.top     = g_oeState.rc.top;
    rcOrder.right   = g_oeState.rc.right + 1;
    rcOrder.bottom  = g_oeState.rc.bottom  + 1;

    pNewOrder       = pOrder;
    fOrderClipped   = FALSE;
    g_oaPurgeAllowed = FALSE;

    //
    // Intersect each piece rect with the draw bounds
    //
    for (iClip = 0, pPiece = g_oeState.rgnData.arclPieces;
            iClip < g_oeState.rgnData.rdh.nRectL; iClip++, pPiece++)
    {
        RECTL_TO_RECT(pPiece, &rcPiece);

        if (!IntersectRect(&rcPiece, &rcPiece, &rcOrder))
            continue;

        if (fOrderClipped)
        {
            //
            // This adds a clipped order for the LAST intersection, not
            // the current one.  We do this to avoid allocating an extra
            // order when only ONE intersection occurs.
            //

            //
            // The order has already been clipped once, so it actually
            // intersects more than one clip rect. We cope with this
            // by duplicating the order and clipping it again.
            //
            pNewOrder = OA_DDAllocOrderMem(
                pLastOrder->OrderHeader.Common.cbOrderDataLength, 0);
            if (pNewOrder == NULL)
            {
                WARNING_OUT(("OA alloc failed"));

                //
                // BOGUS LAURABU:
                // If some order in the middle fails to be
                // allocated, we need the previous order + the remaining
                // intersections to be added as screen data!
                //
                // NT's code is bogus, it will miss some output.
                //

                //
                // Allocation of memory for a duplicate order failed.  
                // Just add the original order as screen data, and free 
                // the original's memory.  Note that g_oeState.rc has
                // the proper bounds, so we can just call OEClipAndAddScreenData().
                //
                OA_DDFreeOrderMem(pLastOrder);
                OEClipAndAddScreenData(&g_oeState.rc);
                DC_QUIT;
            }

            //
            // Copy the header & data from the original order to this 
            // new one.  Don't overwrite the list info at the start.
            //
            hmemcpy((LPBYTE)pNewOrder + FIELD_SIZE(INT_ORDER, OrderHeader.list),
                    (LPBYTE)pLastOrder + FIELD_SIZE(INT_ORDER, OrderHeader.list),
                    pLastOrder->OrderHeader.Common.cbOrderDataLength +
                        sizeof(INT_ORDER_HEADER) -
                        FIELD_SIZE(INT_ORDER, OrderHeader.list));

            //
            // Set the clip rect.  NOTE:  This is the clipped rect from
            // LAST time.
            //
            pLastOrder->OrderHeader.Common.rcsDst.left =
                rcClipped.left;
            pLastOrder->OrderHeader.Common.rcsDst.top =
                rcClipped.top;
            pLastOrder->OrderHeader.Common.rcsDst.right =
                rcClipped.right - 1;
            pLastOrder->OrderHeader.Common.rcsDst.bottom =
                rcClipped.bottom - 1;

            OTRACE(("Duplicate clipped order %08lx at {%d, %d, %d, %d}",
                pLastOrder,
                pLastOrder->OrderHeader.Common.rcsDst.left,
                pLastOrder->OrderHeader.Common.rcsDst.top,
                pLastOrder->OrderHeader.Common.rcsDst.right,
                pLastOrder->OrderHeader.Common.rcsDst.bottom));

            OA_DDAddOrder(pLastOrder, lpExtraInfo);
        }

        //
        // Save the clipping rect for the NEXT dude.
        //
        CopyRect(&rcClipped, &rcPiece);
        fOrderClipped = TRUE;
        pLastOrder    = pNewOrder;
    }


    //
    // We're out of the loop now.
    //
    if (fOrderClipped)
    {
        pLastOrder->OrderHeader.Common.rcsDst.left =
            rcClipped.left;
        pLastOrder->OrderHeader.Common.rcsDst.top =
            rcClipped.top;
        pLastOrder->OrderHeader.Common.rcsDst.right =
            rcClipped.right - 1;
        pLastOrder->OrderHeader.Common.rcsDst.bottom =
            rcClipped.bottom - 1;

        OTRACE(("Clipped order %08lx at {%d, %d, %d, %d}",
            pLastOrder,
            pLastOrder->OrderHeader.Common.rcsDst.left,
            pLastOrder->OrderHeader.Common.rcsDst.top,
            pLastOrder->OrderHeader.Common.rcsDst.right,
            pLastOrder->OrderHeader.Common.rcsDst.bottom));

        OA_DDAddOrder(pLastOrder, lpExtraInfo);
    }
    else
    {
        OTRACE(("Order clipped completely"));
        OA_DDFreeOrderMem(pOrder);
    }

DC_EXIT_POINT:
    g_oaPurgeAllowed = TRUE;

    DebugExitVOID(OEClipAndAddOrder);
}






//
// DDI PATCHES
//

//
// DrvArc()
//
BOOL WINAPI DrvArc
(
    HDC     hdcDst,
    int     xLeft,
    int     yTop,
    int     xRight,
    int     yBottom,
    int     xStartArc,
    int     yStartArc,
    int     xEndArc,
    int     yEndArc
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    LPINT_ORDER pOrder;
    LPARC_ORDER pArc;
    POINT   ptStart;
    POINT   ptEnd;

    DebugEntry(DrvArc);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_ARC, hdcDst, 0);

    fOutput = Arc(hdcDst, xLeft, yTop, xRight, yBottom, xStartArc,
        yStartArc, xEndArc, yEndArc);

    if (OEAfterDDI(DDI_ARC, fWeCare, fOutput))
    {
        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_REGION);

        //
        // Get the bound rect
        //
        g_oeState.rc.left   =   xLeft;
        g_oeState.rc.top    =   yTop;
        g_oeState.rc.right  =   xRight;
        g_oeState.rc.bottom =   yBottom;

        OEPenWidthAdjust(&g_oeState.rc, 1);
        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        //
        // Can we send an ARC order?
        //
        pOrder = NULL;

        if (OECheckOrder(ORD_ARC, OECHECK_PEN | OECHECK_CLIPPING))
        {
            pOrder = OA_DDAllocOrderMem(sizeof(ARC_ORDER), 0);
            if (!pOrder)
                goto NoArcOrder;

            pArc = (LPARC_ORDER)pOrder->abOrderData;
            pArc->type      = LOWORD(ORD_ARC);

            //
            // Note that order coordinates are 32-bits, but we're 16-bits.
            // So we need intermediate variables to do conversions on.
            //
            pArc->nLeftRect     = g_oeState.rc.left;
            pArc->nTopRect      = g_oeState.rc.top;
            pArc->nRightRect    = g_oeState.rc.right;
            pArc->nBottomRect   = g_oeState.rc.bottom;

            ptStart.x       = xStartArc;
            ptStart.y       = yStartArc;
            OELPtoVirtual(g_oeState.hdc, &ptStart, 1);
            pArc->nXStart   = ptStart.x;
            pArc->nYStart   = ptStart.y;

            ptEnd.x         = xEndArc;
            ptEnd.y         = yEndArc;
            OELPtoVirtual(g_oeState.hdc, &ptEnd, 1);
            pArc->nXEnd     = ptEnd.x;
            pArc->nYEnd     = ptEnd.y;

            OEConvertColor(g_oeState.lpdc->DrawMode.bkColorL,
                &pArc->BackColor, FALSE);
            pArc->BackMode      = g_oeState.lpdc->DrawMode.bkMode;
            pArc->ROP2          = g_oeState.lpdc->DrawMode.Rop2;

            pArc->PenStyle      = g_oeState.logPen.lopnStyle;
            pArc->PenWidth      = 1;
            OEConvertColor(g_oeState.logPen.lopnColor,
                &pArc->PenColor, FALSE);

            //
            // Get the arc direction (counter-clockwise or clockwise)
            //
            if (g_oeState.lpdc->fwPath & DCPATH_CLOCKWISE)
                pArc->ArcDirection = ORD_ARC_CLOCKWISE;
            else
                pArc->ArcDirection = ORD_ARC_COUNTERCLOCKWISE;

            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILABLE;

            OTRACE(("Arc:  Order %08lx, Rect {%d, %d, %d, %d}, Start {%d, %d}, End {%d, %d}",
                pOrder,
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom, ptStart.x, ptStart.y, ptEnd.x, ptEnd.y));
            OEClipAndAddOrder(pOrder, NULL);
        }

NoArcOrder:
        if (!pOrder)
        {
            OTRACE(("Arc:  Sending as screen data {%d, %d, %d, %d}",
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvArc, fOutput);
    return(fOutput);
}





//
// DrvChord()
//
BOOL WINAPI DrvChord
(
    HDC     hdcDst,
    int     xLeft,
    int     yTop,
    int     xRight,
    int     yBottom,
    int     xStartChord,
    int     yStartChord,
    int     xEndChord,
    int     yEndChord
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    LPINT_ORDER pOrder;
    LPCHORD_ORDER   pChord;
    POINT   ptStart;
    POINT   ptEnd;
    POINT   ptBrushOrg;

    DebugEntry(DrvChord);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_CHORD, hdcDst, 0);

    fOutput = Chord(hdcDst, xLeft, yTop, xRight, yBottom,
        xStartChord, yStartChord, xEndChord, yEndChord);

    if (OEAfterDDI(DDI_CHORD, fWeCare, fOutput))
    {
        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_BRUSH | OESTATE_REGION);

        //
        // Get the bound rect
        //
        g_oeState.rc.left   =   xLeft;
        g_oeState.rc.top    =   yTop;
        g_oeState.rc.right  =   xRight;
        g_oeState.rc.bottom =   yBottom;
        OEPenWidthAdjust(&g_oeState.rc, 1);
        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        //
        // Can we send a CHORD order?
        //
        pOrder = NULL;

        if (OECheckOrder(ORD_CHORD, OECHECK_PEN | OECHECK_BRUSH | OECHECK_CLIPPING))
        {
            pOrder = OA_DDAllocOrderMem(sizeof(CHORD_ORDER), 0);
            if (!pOrder)
                goto NoChordOrder;

            pChord = (LPCHORD_ORDER)pOrder->abOrderData;
            pChord->type = LOWORD(ORD_CHORD);

            pChord->nLeftRect   = g_oeState.rc.left;
            pChord->nTopRect    = g_oeState.rc.top;
            pChord->nRightRect  = g_oeState.rc.right;
            pChord->nBottomRect = g_oeState.rc.bottom;

            ptStart.x           = xStartChord;
            ptStart.y           = yStartChord;
            OELPtoVirtual(g_oeState.hdc, &ptStart, 1);
            pChord->nXStart     = ptStart.x;
            pChord->nYStart     = ptStart.y;

            ptEnd.x             = xEndChord;
            ptEnd.y             = yEndChord;
            OELPtoVirtual(g_oeState.hdc, &ptEnd, 1);
            pChord->nXEnd       = ptEnd.x;
            pChord->nYEnd       = ptEnd.y;

            OEGetBrushInfo(&pChord->BackColor, &pChord->ForeColor,
                &pChord->BrushStyle, &pChord->BrushHatch, pChord->BrushExtra);

            GetBrushOrgEx(g_oeState.hdc, &ptBrushOrg);
            pChord->BrushOrgX = (BYTE)ptBrushOrg.x;
            pChord->BrushOrgY = (BYTE)ptBrushOrg.y;

            pChord->BackMode    = g_oeState.lpdc->DrawMode.bkMode;
            pChord->ROP2        = g_oeState.lpdc->DrawMode.Rop2;

            pChord->PenStyle    = g_oeState.logPen.lopnStyle;
            pChord->PenWidth    = 1;
            OEConvertColor(g_oeState.logPen.lopnColor,
                &pChord->PenColor, FALSE);

            if (g_oeState.lpdc->fwPath & DCPATH_CLOCKWISE)
                pChord->ArcDirection = ORD_ARC_CLOCKWISE;
            else
                pChord->ArcDirection = ORD_ARC_COUNTERCLOCKWISE;

            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILABLE;

            OTRACE(("Chord:  Order %08lx, Rect {%d, %d, %d, %d}, Start {%d, %d}, End {%d, %d}",
                pOrder,
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom, ptStart.x, ptStart.y, ptEnd.x, ptEnd.y));
            OEClipAndAddOrder(pOrder, NULL);
        }

NoChordOrder:
        if (!pOrder)
        {
            OTRACE(("Chord:  Sending as screen data {%d, %d, %d, %d}",
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvChord, fOutput);
    return(fOutput);
}





//
// DrvEllipse()
//
BOOL WINAPI DrvEllipse
(
    HDC     hdcDst,
    int     xLeft,
    int     yTop,
    int     xRight,
    int     yBottom
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    LPINT_ORDER pOrder;
    LPELLIPSE_ORDER pEllipse;
    POINT   ptBrushOrg;

    DebugEntry(DrvEllipse);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_ELLIPSE, hdcDst, 0);

    fOutput = Ellipse(hdcDst, xLeft, yTop, xRight, yBottom);

    if (OEAfterDDI(DDI_ELLIPSE, fWeCare, fOutput))
    {
        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_BRUSH | OESTATE_REGION);

        //
        // Calc bound rect
        //
        g_oeState.rc.left   = xLeft;
        g_oeState.rc.top    = yTop;
        g_oeState.rc.right  = xRight;
        g_oeState.rc.bottom = yBottom;
        OEPenWidthAdjust(&g_oeState.rc, 1);
        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        //
        // Can we send ELLIPSE order?
        //
        pOrder = NULL;

        if (OECheckOrder(ORD_ELLIPSE, OECHECK_PEN | OECHECK_BRUSH | OECHECK_CLIPPING))
        {
            pOrder = OA_DDAllocOrderMem(sizeof(ELLIPSE_ORDER), 0);
            if (!pOrder)
                goto NoEllipseOrder;

            pEllipse = (LPELLIPSE_ORDER)pOrder->abOrderData;
            pEllipse->type = LOWORD(ORD_ELLIPSE);

            pEllipse->nLeftRect     = g_oeState.rc.left;
            pEllipse->nTopRect      = g_oeState.rc.top;
            pEllipse->nRightRect    = g_oeState.rc.right;
            pEllipse->nBottomRect   = g_oeState.rc.bottom;

            OEGetBrushInfo(&pEllipse->BackColor, &pEllipse->ForeColor,
                &pEllipse->BrushStyle, &pEllipse->BrushHatch,
                pEllipse->BrushExtra);

            GetBrushOrgEx(g_oeState.hdc, &ptBrushOrg);
            pEllipse->BrushOrgX = (BYTE)ptBrushOrg.x;
            pEllipse->BrushOrgY = (BYTE)ptBrushOrg.y;

            pEllipse->BackMode  = g_oeState.lpdc->DrawMode.bkMode;
            pEllipse->ROP2      = g_oeState.lpdc->DrawMode.Rop2;

            pEllipse->PenStyle  = g_oeState.logPen.lopnStyle;
            pEllipse->PenWidth  = 1;

            OEConvertColor(g_oeState.logPen.lopnColor, &pEllipse->PenColor,
                FALSE);

            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILABLE;

            OTRACE(("Ellipse:  Order %08lx, Rect {%d, %d, %d, %d}",
                pOrder,
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddOrder(pOrder, NULL);
        }

NoEllipseOrder:
        if (!pOrder)
        {
            OTRACE(("Ellipse:  Sending as screen data {%d, %d, %d, %d}",
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvEllipse, fOutput);
    return(fOutput);
}




//
// DrvPie()
//
BOOL WINAPI DrvPie
(
    HDC     hdcDst,
    int     xLeft,
    int     yTop,
    int     xRight,
    int     yBottom,
    int     xStartArc,
    int     yStartArc,
    int     xEndArc,
    int     yEndArc
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    LPINT_ORDER pOrder;
    LPPIE_ORDER pPie;
    POINT   ptStart;
    POINT   ptEnd;
    POINT   ptBrushOrg;

    DebugEntry(DrvPie);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_PIE, hdcDst, 0);

    fOutput = Pie(hdcDst, xLeft, yTop, xRight, yBottom, xStartArc, yStartArc,
        xEndArc, yEndArc);

    if (OEAfterDDI(DDI_PIE, fWeCare, fOutput))
    {
        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_BRUSH | OESTATE_REGION);

        //
        // Get bound rect
        //
        g_oeState.rc.left       = xLeft;
        g_oeState.rc.top        = yTop;
        g_oeState.rc.right      = xRight;
        g_oeState.rc.bottom     = yBottom;
        OEPenWidthAdjust(&g_oeState.rc, 1);
        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        //
        // Can we send PIE order?
        //
        pOrder = NULL;

        if (OECheckOrder(ORD_PIE, OECHECK_PEN | OECHECK_BRUSH | OECHECK_CLIPPING))
        {
            pOrder = OA_DDAllocOrderMem(sizeof(PIE_ORDER), 0);
            if (!pOrder)
                goto NoPieOrder;

            pPie = (LPPIE_ORDER)pOrder->abOrderData;
            pPie->type = LOWORD(ORD_PIE);

            pPie->nLeftRect   = g_oeState.rc.left;
            pPie->nTopRect    = g_oeState.rc.top;
            pPie->nRightRect  = g_oeState.rc.right;
            pPie->nBottomRect = g_oeState.rc.bottom;

            ptStart.x         = xStartArc;
            ptStart.y         = yStartArc;
            OELPtoVirtual(g_oeState.hdc, &ptStart, 1);
            pPie->nXStart     = ptStart.x;
            pPie->nYStart     = ptStart.y;

            ptEnd.x           = xEndArc;
            ptEnd.y           = yEndArc;
            OELPtoVirtual(g_oeState.hdc, &ptEnd, 1);
            pPie->nXEnd       = ptEnd.x;
            pPie->nYEnd       = ptEnd.y;

            OEGetBrushInfo(&pPie->BackColor, &pPie->ForeColor,
                &pPie->BrushStyle, &pPie->BrushHatch, pPie->BrushExtra);

            GetBrushOrgEx(g_oeState.hdc, &ptBrushOrg);
            pPie->BrushOrgX = (BYTE)ptBrushOrg.x;
            pPie->BrushOrgY = (BYTE)ptBrushOrg.y;

            pPie->BackMode    = g_oeState.lpdc->DrawMode.bkMode;
            pPie->ROP2        = g_oeState.lpdc->DrawMode.Rop2;

            pPie->PenStyle    = g_oeState.logPen.lopnStyle;
            pPie->PenWidth    = 1;
            OEConvertColor(g_oeState.logPen.lopnColor, &pPie->PenColor,
                FALSE);

            if (g_oeState.lpdc->fwPath & DCPATH_CLOCKWISE)
                pPie->ArcDirection = ORD_ARC_CLOCKWISE;
            else
                pPie->ArcDirection = ORD_ARC_COUNTERCLOCKWISE;

            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILABLE;

            OTRACE(("Pie:  Order %08lx, Rect {%d, %d, %d, %d}, Start {%d, %d}, End {%d, %d}",
                pOrder,
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddOrder(pOrder, NULL);
        }

NoPieOrder:
        if (!pOrder)
        {
            OTRACE(("PieOrder:  Sending as screen data {%d, %d, %d, %d}",
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPie, fOutput);
    return(fOutput);
}



//
// DrvRoundRect()
//
BOOL WINAPI DrvRoundRect
(
    HDC     hdcDst,
    int     xLeft,
    int     yTop,
    int     xRight,
    int     yBottom,
    int     cxEllipse,
    int     cyEllipse
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    LPINT_ORDER pOrder;
    LPROUNDRECT_ORDER   pRoundRect;
    POINT   ptBrushOrg;

    DebugEntry(DrvRoundRect);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_ROUNDRECT, hdcDst, 0);

    fOutput = RoundRect(hdcDst, xLeft, yTop, xRight, yBottom, cxEllipse, cyEllipse);

    if (OEAfterDDI(DDI_ROUNDRECT, fWeCare, fOutput))
    {
        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_BRUSH | OESTATE_REGION);

        //
        // Get bound rect
        //
        g_oeState.rc.left   = xLeft;
        g_oeState.rc.top    = yTop;
        g_oeState.rc.right  = xRight;
        g_oeState.rc.bottom = yBottom;
        OEPenWidthAdjust(&g_oeState.rc, 1);
        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        //
        // Can we send ROUNDRECT order?
        //
        pOrder = NULL;

        if (OECheckOrder(ORD_ROUNDRECT, OECHECK_PEN | OECHECK_BRUSH | OECHECK_CLIPPING) &&
            (GetMapMode(hdcDst) == MM_TEXT))
        {
            pOrder = OA_DDAllocOrderMem(sizeof(ROUNDRECT_ORDER), 0);
            if (!pOrder)
                goto NoRoundRectOrder;

            pRoundRect = (LPROUNDRECT_ORDER)pOrder->abOrderData;
            pRoundRect->type            = LOWORD(ORD_ROUNDRECT);

            pRoundRect->nLeftRect       = g_oeState.rc.left;
            pRoundRect->nTopRect        = g_oeState.rc.top;
            pRoundRect->nRightRect      = g_oeState.rc.right;
            pRoundRect->nBottomRect     = g_oeState.rc.bottom;

            //
            // It's too difficult to do the mapping of the ellipse 
            // dimensions when not MM_TEXT.  Therefore we don't.  If we
            // are here, we just pass the sizes straight through.
            //
            pRoundRect->nEllipseWidth   = cxEllipse;
            pRoundRect->nEllipseHeight  = cyEllipse;

            OEGetBrushInfo(&pRoundRect->BackColor, &pRoundRect->ForeColor,
                &pRoundRect->BrushStyle, &pRoundRect->BrushHatch,
                pRoundRect->BrushExtra);

            GetBrushOrgEx(g_oeState.hdc, &ptBrushOrg);
            pRoundRect->BrushOrgX = ptBrushOrg.x;
            pRoundRect->BrushOrgY = ptBrushOrg.y;

            pRoundRect->BackMode    = g_oeState.lpdc->DrawMode.bkMode;
            pRoundRect->ROP2        = g_oeState.lpdc->DrawMode.Rop2;

            pRoundRect->PenStyle    = g_oeState.logPen.lopnStyle;
            pRoundRect->PenWidth    = 1;
            OEConvertColor(g_oeState.logPen.lopnColor,
                &pRoundRect->PenColor, FALSE);

            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILABLE;
            
            OTRACE(("RoundRect:  Order %08lx, Rect {%d, %d, %d, %d}, Curve {%d, %d}",
                pOrder,
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom, cxEllipse, cyEllipse));
            OEClipAndAddOrder(pOrder, NULL);
        }

NoRoundRectOrder:
        if (!pOrder)
        {
            OTRACE(("RoundRect:  Sending as screen data {%d, %d, %d, %d}",
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvRoundRect, fOutput);
    return(fOutput);
}


//
// DrvBitBlt
//
BOOL WINAPI DrvBitBlt
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    int     cxDst,
    int     cyDst,
    HDC     hdcSrc,
    int     xSrc,
    int     ySrc,
    DWORD   dwRop
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    BYTE    bRop;
    LPDC    lpdcSrc;
    LPINT_ORDER  pOrder;
    LPSCRBLT_ORDER pScrBlt;
    POINT   ptT;
    RECT    rcT;

    DebugEntry(DrvBitBlt);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_BITBLT, hdcDst, 0);

    fOutput = BitBlt(hdcDst, xDst, yDst, cxDst, cyDst, hdcSrc, xSrc, ySrc, dwRop);

    if (OEAfterDDI(DDI_BITBLT, fWeCare, fOutput && cxDst && cyDst))
    {
        //
        // Is this really PatBlt?
        //
        bRop = LOBYTE(HIWORD(dwRop));

        if (((bRop & 0x33) << 2) == (bRop & 0xCC))
        {
            TRACE_OUT(("BitBlt used for PatBlt"));

            OEGetState(OESTATE_COORDS | OESTATE_BRUSH | OESTATE_REGION);

            //
            // Get bound rect
            //
            g_oeState.rc.left   = xDst;
            g_oeState.rc.top    = yDst;
            g_oeState.rc.right  = xDst + cxDst;
            g_oeState.rc.bottom = yDst + cyDst;

            OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

            OEAddBlt(dwRop);
            DC_QUIT;
        }

        //
        // SPB goop
        //
        if (g_oeState.lpdc->hBitmap == g_ssiLastSpbBitmap)
        {
            //
            // This is an SPB operation.  The source is in screen coords.
            //
            ASSERT(g_ssiLastSpbBitmap);
            ASSERT(g_oeState.lpdc->DCFlags & DC_IS_MEMORY);
            ASSERT(dwRop == SRCCOPY);

            g_oeState.rc.left = xSrc;
            g_oeState.rc.top  = ySrc;
            g_oeState.rc.right = xSrc + cxDst;
            g_oeState.rc.bottom = ySrc + cyDst;

            SSISaveBits(g_ssiLastSpbBitmap, &g_oeState.rc);
            g_ssiLastSpbBitmap = NULL;

            DC_QUIT;
        }

        ASSERT(!(g_oeState.lpdc->DCFlags & DC_IS_MEMORY));

        //
        // Is this a memory to screen blt for SPB restoration?
        //
        lpdcSrc = OEValidateDC(hdcSrc, TRUE);
        if (SELECTOROF(lpdcSrc)                     &&
            (lpdcSrc->DCFlags & DC_IS_DISPLAY)      &&
            (lpdcSrc->DCFlags & DC_IS_MEMORY)       &&
            (dwRop == SRCCOPY)                      &&
            SSIRestoreBits(lpdcSrc->hBitmap))
        {
            OTRACE(("BitBlt:  SPB restored"));
            DC_QUIT;
        }

        //
        // Now, we accumulate orders for screen-to-screen blts
        //
        OEGetState(OESTATE_COORDS | OESTATE_BRUSH | OESTATE_REGION);

        g_oeState.rc.left   = xDst;
        g_oeState.rc.top    = yDst;
        g_oeState.rc.right  = xDst + cxDst;
        g_oeState.rc.bottom = yDst + cyDst;

        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        pOrder = NULL;

        if (hdcSrc == hdcDst)
        {
            if (!OECheckOrder(ORD_SCRBLT, OECHECK_CLIPPING) ||
                !OESendRop3AsOrder(bRop)                    ||
                !ROP3_NO_PATTERN(bRop))
            {
                goto NoBitBltOrder;
            }

            //
            // Get source coords
            //
            ptT.x = xSrc;
            ptT.y = ySrc;
            OELPtoVirtual(hdcSrc, &ptT, 1);

            //
            // If the clipping isn't simple and the source overlaps the dest,
            // send as screen data.  It's too complicated for an order.
            //
            if (!OEClippingIsSimple())
            {
                //
                // NOTE:
                // The NM 2.0 code was really messed up, the source rect
                // calcs were bogus.
                //
                rcT.left = max(g_oeState.rc.left, ptT.x);
                rcT.right = min(g_oeState.rc.right,
                    ptT.x + (g_oeState.rc.right - g_oeState.rc.left));

                rcT.top  = max(g_oeState.rc.top, ptT.y);
                rcT.bottom = min(g_oeState.rc.bottom,
                    ptT.y + (g_oeState.rc.bottom - g_oeState.rc.top));

                if ((rcT.left <= rcT.right) &&
                    (rcT.top  <= rcT.bottom))
                {
                    TRACE_OUT(("No SCRBLT order; non-rect clipping and Src/Dst intersect"));
                    goto NoBitBltOrder;
                }
            }

            pOrder = OA_DDAllocOrderMem(sizeof(SCRBLT_ORDER), 0);
            if (!pOrder)
                goto NoBitBltOrder;

            pScrBlt = (LPSCRBLT_ORDER)pOrder->abOrderData;
            pScrBlt->type = LOWORD(ORD_SCRBLT);

            pScrBlt->nLeftRect  = g_oeState.rc.left;
            pScrBlt->nTopRect   = g_oeState.rc.top;
            pScrBlt->nWidth     = g_oeState.rc.right - g_oeState.rc.left + 1;
            pScrBlt->nHeight    = g_oeState.rc.bottom - g_oeState.rc.top + 1;
            pScrBlt->bRop       = bRop;

            pScrBlt->nXSrc      = ptT.x;
            pScrBlt->nYSrc      = ptT.y;

            pOrder->OrderHeader.Common.fOrderFlags  = OF_BLOCKER | OF_SPOILABLE;

            OTRACE(("ScrBlt:  From {%d, %d}, To {%d, %d}, Size {%d, %d}",
                ptT.x, ptT.y, g_oeState.rc.left, g_oeState.rc.top,
                g_oeState.rc.right - g_oeState.rc.left + 1,
                g_oeState.rc.bottom - g_oeState.rc.top + 1));

            OEClipAndAddOrder(pOrder, NULL);
        }

NoBitBltOrder:
        if (!pOrder)
        {
            OTRACE(("BitBlt:  Sending as screen data {%d, %d, %d, %d}",
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

DC_EXIT_POINT:
    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvBitBlt, fOutput);
    return(fOutput);
}



//
// DrvExtTextOutA()
//
BOOL WINAPI DrvExtTextOutA
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    UINT    uOptions,
    LPRECT  lprcClip,
    LPSTR  lpszText,
    UINT    cchText,
    LPINT   lpdxCharSpacing
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    UINT    uFlags;

    DebugEntry(DrvExtTextOutA);

    OE_SHM_START_WRITING;

    //
    // Is this really just opaquing?
    //
    if ((cchText == 0)          &&
        SELECTOROF(lprcClip)    &&
        !IsBadReadPtr(lprcClip, sizeof(RECT))   &&
        (uOptions & ETO_OPAQUE))
    {
        uFlags = 0;
    }
    else
    {
        uFlags = OESTATE_SDA_FONTCOMPLEX | OESTATE_CURPOS;
    }

    fWeCare = OEBeforeDDI(DDI_EXTTEXTOUTA, hdcDst, uFlags);

    fOutput = ExtTextOut(hdcDst, xDst, yDst, uOptions, lprcClip, lpszText, cchText, lpdxCharSpacing);

    if (OEAfterDDI(DDI_EXTTEXTOUTA, fWeCare, fOutput))
    {
        //
        // Is this a simple OPAQUE rect, or a textout call?
        // NOTE that OEAfterDDI() returns FALSE if fOutput is TRUE but 
        // we used DCBs to add it as screen data.
        //
        if (uFlags & OESTATE_SDA_FONTCOMPLEX)
        {
            if (cchText)
            {
                POINT   ptStart = {xDst, yDst};

                OEAddText(ptStart, uOptions, lprcClip, lpszText, cchText, lpdxCharSpacing);
            }
        }
        else
        {
            OEAddOpaqueRect(lprcClip);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvExtTextOutA, fOutput);
    return(fOutput);
}



#pragma optimize("gle", off)
//
// DrvPatBlt()
//
BOOL WINAPI DrvPatBlt
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    int     cxDst,
    int     cyDst,
    DWORD   rop
)
{
    UINT    cxSave;
    BOOL    fWeCare;
    BOOL    fOutput;
    LPINT_ORDER pOrder;

    // Save CX
    _asm    mov cxSave, cx

    DebugEntry(DrvPatBlt);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_PATBLT, hdcDst, 0);

    // Restore CX for RealPatBlt
    _asm     mov cx, cxSave
    fOutput = g_lpfnRealPatBlt(hdcDst, xDst, yDst, cxDst, cyDst, rop);

    if (OEAfterDDI(DDI_PATBLT, fWeCare, fOutput && (cxSave != 0)))
    {
        OEGetState(OESTATE_COORDS | OESTATE_BRUSH | OESTATE_REGION);

        //
        // Get bound rect
        //
        g_oeState.rc.left   = xDst;
        g_oeState.rc.top    = yDst;
        g_oeState.rc.right  = xDst + cxDst;
        g_oeState.rc.bottom = yDst + cyDst;

        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        OEAddBlt(rop);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPatBlt, fOutput);
    return(fOutput);
}
#pragma optimize("", on)



//
// OEAddBlt()
// Used for simple destination ROP blts
//
void OEAddBlt
(
    DWORD       dwRop
)
{
    LPINT_ORDER pOrder;
    DWORD       type;
    POINT       ptBrushOrg;
    BYTE        bRop;

    DebugEntry(OEAddBlt);

    pOrder = NULL;

    //
    // Is this a full PATBLT_ORDER or a simple DSTBLT_ORDER?  If the top
    // nibble of the ROP is equal to the bottom nibble, no pattern is
    // required.  WHITENESS for example.
    //
    bRop = LOBYTE(HIWORD(dwRop));
    if ((bRop >> 4) == (bRop & 0x0F))
    {
        type = ORD_DSTBLT;
    }
    else
    {
        type = ORD_PATBLT;

        if (!OECheckBrushIsSimple())
        {
            DC_QUIT;
        }

        if ((dwRop == PATCOPY) && (g_oeState.logBrush.lbStyle == BS_NULL))
        {
            // No output happens in this scenario at all, no screen data even
            goto NothingAtAll;
        }
    }

    if (OE_SendAsOrder(type)        &&
        OESendRop3AsOrder(bRop)     &&
        !OEClippingIsComplex())
    {
        if (type == ORD_PATBLT)
        {
            LPPATBLT_ORDER  pPatBlt;

            pOrder = OA_DDAllocOrderMem(sizeof(PATBLT_ORDER), 0);
            if (!pOrder)
                DC_QUIT;

            pPatBlt = (LPPATBLT_ORDER)pOrder->abOrderData;
            pPatBlt->type = LOWORD(ORD_PATBLT);

            pPatBlt->nLeftRect  =   g_oeState.rc.left;
            pPatBlt->nTopRect   =   g_oeState.rc.top;
            pPatBlt->nWidth     =   g_oeState.rc.right - g_oeState.rc.left + 1;
            pPatBlt->nHeight    =   g_oeState.rc.bottom - g_oeState.rc.top + 1;

            pPatBlt->bRop       =   bRop;

            OEGetBrushInfo(&pPatBlt->BackColor, &pPatBlt->ForeColor,
                &pPatBlt->BrushStyle, &pPatBlt->BrushHatch, pPatBlt->BrushExtra);

            GetBrushOrgEx(g_oeState.hdc, &ptBrushOrg);
            pPatBlt->BrushOrgX = (BYTE)ptBrushOrg.x;
            pPatBlt->BrushOrgY = (BYTE)ptBrushOrg.y;

            OTRACE(("PatBlt:  Order %08lx, Rect {%d, %d, %d, %d}",
                pOrder,
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.right));
        }
        else
        {
            LPDSTBLT_ORDER     pDstBlt;

            ASSERT(type == ORD_DSTBLT);

            pOrder = OA_DDAllocOrderMem(sizeof(DSTBLT_ORDER), 0);
            if (!pOrder)
                DC_QUIT;
           
            pDstBlt = (LPDSTBLT_ORDER)pOrder->abOrderData;
            pDstBlt->type = LOWORD(ORD_DSTBLT);

            pDstBlt->nLeftRect  = g_oeState.rc.left;
            pDstBlt->nTopRect   = g_oeState.rc.top;
            pDstBlt->nWidth     = g_oeState.rc.right - g_oeState.rc.left + 1;
            pDstBlt->nHeight    = g_oeState.rc.bottom - g_oeState.rc.top + 1;

            pDstBlt->bRop       = bRop;

            OTRACE(("DstBlt:  Order %08lx, Rect {%d, %d, %d, %d}",
                pOrder,
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
        }

        pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILABLE;
        if (ROP3_IS_OPAQUE(bRop))
            pOrder->OrderHeader.Common.fOrderFlags |= OF_SPOILER;

        OEClipAndAddOrder(pOrder, NULL);
    }

DC_EXIT_POINT:
    if (!pOrder)
    {
        OTRACE(("PatBlt:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }
    
NothingAtAll:
    DebugExitVOID(OEAddBlt);
}



//
// DrvStretchBlt()
//
BOOL WINAPI DrvStretchBlt
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    int     cxDst,
    int     cyDst,
    HDC     hdcSrc,
    int     xSrc,
    int     ySrc,
    int     cxSrc,
    int     cySrc,
    DWORD   rop
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvStretchBlt);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_STRETCHBLT, hdcDst, 0);

    fOutput = StretchBlt(hdcDst, xDst, yDst, cxDst, cyDst, hdcSrc, xSrc, ySrc, cxSrc, cySrc, rop);

    if (OEAfterDDI(DDI_STRETCHBLT, fWeCare, fOutput))
    {
        OEGetState(OESTATE_COORDS | OESTATE_REGION);

        g_oeState.rc.left   = xDst;
        g_oeState.rc.top    = yDst;
        g_oeState.rc.right  = xDst + cxDst;
        g_oeState.rc.bottom = yDst + cyDst;
        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        OTRACE(("StretchBlt:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));

        OEClipAndAddScreenData(&g_oeState.rc);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvStretchBlt, fOutput);
    return(fOutput);
}



//
// TextOutA()
//
BOOL WINAPI DrvTextOutA
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    LPSTR  lpszText,
    int     cchText
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvTextOutA);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_TEXTOUTA, hdcDst, OESTATE_SDA_FONTCOMPLEX | OESTATE_CURPOS);

    fOutput = TextOut(hdcDst, xDst, yDst, lpszText, cchText);

    if (OEAfterDDI(DDI_TEXTOUTA, fWeCare, fOutput && cchText))
    {
        POINT   ptStart = {xDst, yDst};
        OEAddText(ptStart, 0, NULL, lpszText, cchText, NULL);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvTextOutA, fOutput);
    return(fOutput);
}



//
// DrvExtFloodFill()
//
// This just gets added as screen data.  Too darned complicated to
// calculate the result.
//
BOOL WINAPI DrvExtFloodFill
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    COLORREF    clrFill,
    UINT    uFillType
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvExtFloodFill);

    OE_SHM_START_WRITING;

    //
    // GDI's draw bounds has an off-by-one bug in ExtFloodFill and FloodFill
    //
    fWeCare = OEBeforeDDI(DDI_EXTFLOODFILL, hdcDst, OESTATE_SDA_DCB | 
        OESTATE_OFFBYONEHACK);

    fOutput = ExtFloodFill(hdcDst, xDst, yDst, clrFill, uFillType);

    OEAfterDDI(DDI_EXTFLOODFILL, fWeCare, fOutput);

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvExtFloodFill, fOutput);
    return(fOutput);
}



//
// DrvFloodFill()
//
BOOL WINAPI DrvFloodFill
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    COLORREF    clrFill
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvFloodFill);

    OE_SHM_START_WRITING;

    //
    // GDI's draw bounds has an off-by-one bug in ExtFloodFill and FloodFill
    //
    fWeCare = OEBeforeDDI(DDI_FLOODFILL, hdcDst, OESTATE_SDA_DCB |
        OESTATE_OFFBYONEHACK);

    fOutput = FloodFill(hdcDst, xDst, yDst, clrFill);

    OEAfterDDI(DDI_FLOODFILL, fWeCare, fOutput);

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvFloodFill, fOutput);
    return(fOutput);
}



//
// DrvExtTextOut()
//
BOOL WINAPI DrvExtTextOutW
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    UINT    uOptions,
    LPRECT  lprcClip,
    LPWSTR lpwszText,
    UINT    cchText,
    LPINT   lpdxCharSpacing
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    UINT    uFlags;

    //
    // NOTE:
    // ExtTextOutW and TextOutW are only called on 32-bit app threads.  So
    // chewing up stack space isn't a problem.
    //
    UINT    cchAnsi = 0;
    char    szAnsi[ORD_MAX_STRING_LEN_WITHOUT_DELTAS+1];

    DebugEntry(DrvExtTextOutW);

    OE_SHM_START_WRITING;

    if ((cchText == 0)                          &&
        SELECTOROF(lprcClip)                    &&
        !IsBadReadPtr(lprcClip, sizeof(RECT))   &&
        (uOptions & ETO_OPAQUE))
    {
        uFlags = 0;
    }
    else
    {
        //
        // Is this order-able?  It is if we can convert the unicode string
        // to ansi then back to unicode, and end up where we started.
        //
        uFlags = OESTATE_SDA_DCB;

        if (cchText &&
            (cchText <= ORD_MAX_STRING_LEN_WITHOUT_DELTAS) &&
            !IsBadReadPtr(lpwszText, cchText*sizeof(WCHAR)))
        {
            int cchUni;

            //
            // NOTE:
            // UniToAnsi() returns ONE LESS than the # of chars converted
            //
            cchAnsi = UniToAnsi(lpwszText, szAnsi, cchText) + 1;
            cchUni  = AnsiToUni(szAnsi, cchAnsi, g_oeTempString, ORD_MAX_STRING_LEN_WITHOUT_DELTAS);

            if (cchUni == cchText)
            {
                //
                // Verify these strings are the same
                //
                UINT ich;

                for (ich = 0; ich < cchText; ich++)
                {
                    if (lpwszText[ich] != g_oeTempString[ich])
                        break;
                }

                if (ich == cchText)
                {
                    //
                    // We made it to the end; everything matched.
                    //
                    uFlags = OESTATE_SDA_FONTCOMPLEX | OESTATE_CURPOS;
                }
            }

#ifdef DEBUG
            if (uFlags == OESTATE_SDA_DCB)
            {
                WARNING_OUT(("Can't encode ExtTextOutW"));
            }
#endif // DEBUG
        }
    }

    fWeCare = OEBeforeDDI(DDI_EXTTEXTOUTW, hdcDst, uFlags);

    fOutput = g_lpfnExtTextOutW(hdcDst, xDst, yDst, uOptions, lprcClip,
        lpwszText, cchText, lpdxCharSpacing);

    if (OEAfterDDI(DDI_EXTTEXTOUTW, fWeCare, fOutput))
    {
        //
        // Is this a simple OPAQUE rect, or a textout call we can order?
        // NOTE that OEAfterDDI() returns FALSE even if fOutput but we
        // used DCBs to add as screen data.
        //
        if (uFlags & OESTATE_SDA_FONTCOMPLEX)
        {
            POINT   ptStart = {xDst, yDst};

            ASSERT(cchAnsi);
            OEAddText(ptStart, uOptions, lprcClip, szAnsi, cchAnsi, lpdxCharSpacing);
        }
        else
        {
            OEAddOpaqueRect(lprcClip);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvExtTextOutW, fOutput);
    return(fOutput);
}



//
// DrvTextOutW()
//
BOOL WINAPI DrvTextOutW
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    LPWSTR lpwszText,
    int     cchText
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    UINT    uFlags;

    //
    // NOTE:
    // ExtTextOutW and TextOutW are only called on 32-bit app threads.  So
    // chewing up stack space isn't a problem.
    //
    UINT    cchAnsi = 0;
    char    szAnsi[ORD_MAX_STRING_LEN_WITHOUT_DELTAS+1];

    DebugEntry(DrvTextOutW);

    OE_SHM_START_WRITING;

    //
    // Is this order-able?  It is if we can convert the unicode string to
    // ansi then back to unicode, and end up where we started.
    //
    uFlags = OESTATE_SDA_DCB;

    if (cchText &&
        (cchText <= ORD_MAX_STRING_LEN_WITHOUT_DELTAS)  &&
        !IsBadReadPtr(lpwszText, cchText*sizeof(WCHAR)))
    {
        int cchUni;

        //
        // NOTE:
        // UniToAnsi() returns one LESS than the # of chars converted
        //
        cchAnsi = UniToAnsi(lpwszText, szAnsi, cchText) + 1;
        cchUni  = AnsiToUni(szAnsi, cchAnsi, g_oeTempString, cchText);

        if (cchUni == cchText)
        {
            //
            // Verify these strings are the same
            //
            UINT ich;

            for (ich = 0; ich < cchText; ich++)
            {
                if (lpwszText[ich] != g_oeTempString[ich])
                    break;
            }

            if (ich == cchText)
            {
                //
                // We made it to the end; everything matched.
                //
                uFlags = OESTATE_SDA_FONTCOMPLEX | OESTATE_CURPOS;
            }

#ifdef DEBUG
            if (uFlags == OESTATE_SDA_DCB)
            {
                WARNING_OUT(("Can't encode TextOutW"));
            }
#endif // DEBUG

        }
    }

    fWeCare = OEBeforeDDI(DDI_TEXTOUTW, hdcDst, uFlags);

    fOutput = g_lpfnTextOutW(hdcDst, xDst, yDst, lpwszText, cchText);

    if (OEAfterDDI(DDI_TEXTOUTW, fWeCare, fOutput && cchText))
    {
        POINT ptStart = {xDst, yDst};
        OEAddText(ptStart, 0, NULL, szAnsi, cchAnsi, NULL);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvTextOutW, fOutput);
    return(fOutput);
}


//
// OEAddOpaqueRect()
// Adds a simple opaque rect order, used for "erasing" ExtTextOutA/W
// calls.  The most common examples are in Office.
//
void OEAddOpaqueRect(LPRECT lprcOpaque)
{
    LPINT_ORDER         pOrder;
    LPOPAQUERECT_ORDER  pOpaqueRect;

    DebugEntry(OEAddOpaqueRect);

    OEGetState(OESTATE_COORDS | OESTATE_REGION);

    g_oeState.rc = *lprcOpaque;
    OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

    pOrder = NULL;

    if (OECheckOrder(ORD_OPAQUERECT, OECHECK_CLIPPING))
    {
        pOrder = OA_DDAllocOrderMem(sizeof(OPAQUERECT_ORDER), 0);
        if (!pOrder)
            DC_QUIT;

        pOpaqueRect = (LPOPAQUERECT_ORDER)pOrder->abOrderData;
        pOpaqueRect->type = LOWORD(ORD_OPAQUERECT);

        pOpaqueRect->nLeftRect  = g_oeState.rc.left;
        pOpaqueRect->nTopRect   = g_oeState.rc.top;
        pOpaqueRect->nWidth     = g_oeState.rc.right - g_oeState.rc.left + 1;
        pOpaqueRect->nHeight    = g_oeState.rc.bottom - g_oeState.rc.top + 1;

        OEConvertColor(g_oeState.lpdc->DrawMode.bkColorL,
            &pOpaqueRect->Color, FALSE);

        pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILER | OF_SPOILABLE;

        OTRACE(("OpaqueRect:  Order %08lx, Rect {%d, %d, %d, %d}, Color %08lx",
            pOrder,
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom, pOpaqueRect->Color));

        OEClipAndAddOrder(pOrder, NULL);
    }

DC_EXIT_POINT:
    if (!pOrder)
    {
        OTRACE(("OpaqueRect:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }

    DebugExitVOID(OEAddOpaqueRect);
}


//
// OEAddText()
// Big monster routine that handles TextOutA/ExtTextOutA
//
// In general, we care about:
//      * Clip rect--if none, and no text, it's an OpaqueRect instead
//      * The font
//      * Whether it's too complicated to send as an order
//      * If it needs a deltaX array
//
void OEAddText
(
    POINT   ptStart,
    UINT    uOptions,
    LPRECT  lprcClip,
    LPSTR   lpszText,
    UINT    cchText,
    LPINT   lpdxCharSpacing
)
{
    RECT                rcT;
    int                 overhang;
    int                 width;
    UINT                fOrderFlags;
    int                 cchMax;
    DWORD               order;
    LPINT_ORDER         pOrder;
    LPEXTTEXTOUT_ORDER  pExtTextOut;
    LPTEXTOUT_ORDER     pTextOut;
    LPCOMMON_TEXTORDER  pCommon;
    UINT                fontHeight;
    UINT                fontWidth;
    UINT                fontWeight;
    UINT                fontFlags;
    UINT                fontIndex;
    BOOL                fSendDeltaX;
    POINT               ptT;
    
    DebugEntry(OEAddText);

    //
    // NOTE:
    // Do NOT convert ptStart.  It is needed in logical form for several
    // different things.
    //

    OEGetState(OESTATE_COORDS | OESTATE_FONT | OESTATE_REGION);

    //
    // We need to apply the same validation to the flags that GDI does.
    // This bit massaging is for various app compatibility things.
    //
    if (uOptions & ~(ETO_CLIPPED | ETO_OPAQUE | ETO_GLYPH_INDEX | ETO_RTLREADING))
    {
        uOptions &= (ETO_CLIPPED | ETO_OPAQUE);
    }
    if (!(uOptions & (ETO_CLIPPED | ETO_OPAQUE)))
    {
        // No opaquing/clipping, no clip rect
        lprcClip = NULL;
    }
    if (!SELECTOROF(lprcClip))
    {
        // No clip rect, no opaquing/clipping
        uOptions &= ~(ETO_CLIPPED | ETO_OPAQUE);
    }

    pOrder = NULL;

    fOrderFlags = OF_SPOILABLE;

    //
    // Calculate the real starting position of the text
    //
    if (g_oeState.tmAlign & TA_UPDATECP)
    {
        ASSERT(g_oeState.uFlags & OESTATE_CURPOS);
        ptStart = g_oeState.ptCurPos;
    }

    overhang = OEGetStringExtent(lpszText, cchText, lpdxCharSpacing, &rcT);

    width = rcT.right - overhang - rcT.left;
    switch (g_oeState.tmAlign & (TA_CENTER | TA_LEFT | TA_RIGHT))
    {
        case TA_CENTER:
            // The original x coord is the MIDPOINT
            TRACE_OUT(("TextOut HORZ center"));
            ptStart.x -= (width * g_oeState.ptPolarity.x / 2);
            break;

        case TA_RIGHT:
            // The original x coord is the RIGHT SIDE
            TRACE_OUT(("TextOut HORZ right"));
            ptStart.x -= (width * g_oeState.ptPolarity.x);
            break;

        case TA_LEFT:
            break;
    }

    switch (g_oeState.tmAlign & (TA_BASELINE | TA_BOTTOM | TA_TOP))
    {
        case TA_BASELINE:
            // The original y coord is the BASELINE
            TRACE_OUT(("TextOut VERT baseline"));
            ptStart.y -= (g_oeState.tmFont.tmAscent * g_oeState.ptPolarity.y);
            break;

        case TA_BOTTOM:
            // The original y coord is the BOTTOM SIDE
            TRACE_OUT(("TextOut VERT bottom"));
            ptStart.y -= ((rcT.bottom - rcT.top) * g_oeState.ptPolarity.y);
            break;

        case TA_TOP:
            break;
    }


    //
    // Calculate extent rect for order
    //
    if (uOptions & ETO_CLIPPED)
    {
        // Because of CopyRect() validation layer bug, do this directly
        g_oeState.rc = *lprcClip;

        if (uOptions & ETO_OPAQUE)
            fOrderFlags |= OF_SPOILER;
    }
    else
    {
        g_oeState.rc.left  = ptStart.x + (g_oeState.ptPolarity.x * rcT.left);
        g_oeState.rc.top   = ptStart.y + (g_oeState.ptPolarity.y * rcT.top);
        g_oeState.rc.right = ptStart.x + (g_oeState.ptPolarity.x * rcT.right);
        g_oeState.rc.bottom = ptStart.y + (g_oeState.ptPolarity.y * rcT.bottom);

        if (uOptions & ETO_OPAQUE)
        {
            //
            // Set the SPOILER flag in the order header.  However, if the 
            // text extends outside the opaque rect, then the order isn't
            // really opaque, and we have to clear this flag.
            //
 
            fOrderFlags |= OF_SPOILER;

            if (g_oeState.ptPolarity.x == 1)
            {
                if ((g_oeState.rc.left < lprcClip->left) ||
                    (g_oeState.rc.right > lprcClip->right))
                {
                    fOrderFlags &= ~OF_SPOILER;
                }

                g_oeState.rc.left = min(g_oeState.rc.left, lprcClip->left);
                g_oeState.rc.right = max(g_oeState.rc.right, lprcClip->right);
            }
            else
            {
                if ((g_oeState.rc.left > lprcClip->left) ||
                    (g_oeState.rc.right < lprcClip->right))
                {
                    fOrderFlags &= ~OF_SPOILER;
                }

                g_oeState.rc.left = max(g_oeState.rc.left, lprcClip->left);
                g_oeState.rc.right = min(g_oeState.rc.right, lprcClip->right);
            }

            if (g_oeState.ptPolarity.y == 1)
            {
                if ((g_oeState.rc.top < lprcClip->top) ||
                    (g_oeState.rc.bottom > lprcClip->bottom))
                {
                    fOrderFlags &= ~OF_SPOILER;
                }

                g_oeState.rc.top = min(g_oeState.rc.top, lprcClip->top);
                g_oeState.rc.bottom = max(g_oeState.rc.bottom, lprcClip->bottom);
            }
            else
            {
                if ((g_oeState.rc.top > lprcClip->top) ||
                    (g_oeState.rc.bottom < lprcClip->bottom))
                {
                    fOrderFlags &= ~OF_SPOILER;
                }

                g_oeState.rc.top = max(g_oeState.rc.top, lprcClip->top);
                g_oeState.rc.bottom = min(g_oeState.rc.bottom, lprcClip->bottom);
            }

            //
            // After all this, if the text is OPAQUE, then it is a spoiler
            //
            if (g_oeState.lpdc->DrawMode.bkMode == OPAQUE)
                fOrderFlags |= OF_SPOILER;
        }
    }

    OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

    //
    // Is the font supported?
    //
    if (!OECheckFontIsSupported(lpszText, cchText, &fontHeight,
            &fontWidth, &fontWeight, &fontFlags, &fontIndex, &fSendDeltaX))
        DC_QUIT;

    //
    // What type of order are we sending?  And therefore what is the max
    // # of chars we can encode?
    //
    if (fSendDeltaX || SELECTOROF(lpdxCharSpacing) || uOptions)
    {
        order = ORD_EXTTEXTOUT;
        cchMax = ORD_MAX_STRING_LEN_WITH_DELTAS;
    }
    else
    {
        order = ORD_TEXTOUT;
        cchMax = ORD_MAX_STRING_LEN_WITHOUT_DELTAS;
    }


    if (OECheckOrder(order, OECHECK_CLIPPING)   &&
        (cchText <= cchMax))
    {
        if (order == ORD_TEXTOUT)
        {
            pOrder = OA_DDAllocOrderMem((sizeof(TEXTOUT_ORDER)
                - ORD_MAX_STRING_LEN_WITHOUT_DELTAS
                + cchText),
                0);
            if (!pOrder)
                DC_QUIT;

            pTextOut = (LPTEXTOUT_ORDER)pOrder->abOrderData;
            pTextOut->type = LOWORD(order);

            pCommon = &pTextOut->common;
        }
        else
        {
            //
            // BOGUS LAURABU
            // This allocates space for a deltax array whether or not one is
            // needed.
            //
            pOrder = OA_DDAllocOrderMem((sizeof(EXTTEXTOUT_ORDER)
                - ORD_MAX_STRING_LEN_WITHOUT_DELTAS
                - (ORD_MAX_STRING_LEN_WITH_DELTAS * sizeof(TSHR_INT32))
                + cchText
                + (cchText * sizeof(TSHR_INT32))
                + 4), 0);       // 4 is for dword alignment padding
            if (!pOrder)
                DC_QUIT;

            pExtTextOut = (LPEXTTEXTOUT_ORDER)pOrder->abOrderData;
            pExtTextOut->type = LOWORD(order);

            pCommon = &pExtTextOut->common;
        }

        //
        // The order coords are TSHR_INT32s
        //
        ptT = ptStart;
        OELPtoVirtual(g_oeState.hdc, &ptT, 1);
        pCommon->nXStart   =   ptT.x;
        pCommon->nYStart   =   ptT.y;

        OEConvertColor(g_oeState.lpdc->DrawMode.bkColorL,
            &pCommon->BackColor, FALSE);
        OEConvertColor(g_oeState.lpdc->DrawMode.txColorL,
             &pCommon->ForeColor, FALSE);

        pCommon->BackMode = g_oeState.lpdc->DrawMode.bkMode;
        pCommon->CharExtra = g_oeState.lpdc->DrawMode.CharExtra;
        pCommon->BreakExtra = g_oeState.lpdc->DrawMode.TBreakExtra;
        pCommon->BreakCount = g_oeState.lpdc->DrawMode.BreakCount;

        //
        // Font details
        //
        pCommon->FontHeight = fontHeight;
        pCommon->FontWidth  = fontWidth;
        pCommon->FontWeight = fontWeight;
        pCommon->FontFlags  = fontFlags;
        pCommon->FontIndex  = fontIndex;

        if (order == ORD_TEXTOUT)
        {
            //
            // Copy the string
            //
            pTextOut->variableString.len = cchText;
            hmemcpy(pTextOut->variableString.string, lpszText, cchText);
        }
        else
        {
            pExtTextOut->fuOptions  = uOptions & (ETO_OPAQUE | ETO_CLIPPED);

            //
            // If there is a clipping rect, set it up.  Otherwise use the
            // last ETO's clip rect.  This makes OE2 encoding more efficient.
            //
            // NOTE that this is not the same as the drawing bounds--the
            // text may extend outside the clip area.
            //
            if (SELECTOROF(lprcClip))
            {
                ASSERT(uOptions & (ETO_OPAQUE | ETO_CLIPPED));

                rcT = *lprcClip;
                OELRtoVirtual(g_oeState.hdc, &rcT, 1);


                //
                // This is a TSHR_RECT32, so we can't just copy
                //
                pExtTextOut->rectangle.left     = rcT.left;
                pExtTextOut->rectangle.top      = rcT.top;
                pExtTextOut->rectangle.right    = rcT.right;
                pExtTextOut->rectangle.bottom   = rcT.bottom;

                g_oeLastETORect = pExtTextOut->rectangle;
            }
            else
            {
                pExtTextOut->rectangle = g_oeLastETORect;
            }

            //
            // Copy the string
            //
            pExtTextOut->variableString.len = cchText;
            hmemcpy(pExtTextOut->variableString.string, lpszText, cchText);

            //
            // Copy the deltax array
            // 
            // Although we have a defined fixed length structure for
            // storing ExtTextOut orders, we don't send the full structure
            // over the network as the text will only be, say, 10 chars while 
            // the structure contains room for 127.
            //
            // Hence we pack the structure now to remove all the blank data
            // BUT we must maintain the natural alignment of the variables.
            //
            // So we know the length of the string which we can use to
            // start the new delta structure at the next 4-byte boundary.
            //
            if (!OEAddDeltaX(pExtTextOut, lpszText, cchText, lpdxCharSpacing, fSendDeltaX, ptStart))
            {
                WARNING_OUT(("Couldn't add delta-x array to EXTTEXTOUT order"));
                OA_DDFreeOrderMem(pOrder);
                pOrder = NULL;
            }
        }
    }


DC_EXIT_POINT:
    if (pOrder)
    {
        //
        // Call OEMaybeSimulateDeltaX to add a deltax array to the order
        // if needed to correctly position the text.  This happens when
        // the font in use doesn't exist on other machines.
        //
        pOrder->OrderHeader.Common.fOrderFlags = fOrderFlags;

        OTRACE(("TextOut:  Type %08lx, Order %08lx, Rect {%d, %d, %d, %d}, Length %d",
            pOrder, order, 
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom, cchText));
          
        OEClipAndAddOrder(pOrder, NULL);
    }
    else
    {
        OTRACE(("OEAddText:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }
    DebugExitVOID(OEAddText);
}



//
// OECheckFontIsSupported()
//
// We check if we can send this font.  If we haven't received the negotiated
// packet caps yet, forget it.  
//
// It returns:
//      font height in points
//      font ascender in points
//      average font width in points
//      font weight
//      font style flags
//      font handle
//      do we need to send delta x
//

BOOL OECheckFontIsSupported
(
    LPSTR       lpszText,
    UINT        cchText,
    LPUINT      pFontHeight,
    LPUINT      pFontWidth,
    LPUINT      pFontWeight,
    LPUINT      pFontFlags,
    LPUINT      pFontIndex,
    LPBOOL      pSendDeltaX
)
{
    BOOL        fFontSupported;
    UINT        codePage;
    UINT        i;
    UINT        iLocal;
    TSHR_UINT32 matchQuality;
    UINT        charWidthAdjustment;
    int         fontNameLen;
    int         compareResult;
    POINT       xformSize[2];

    DebugEntry(OECheckFontIsSupported);

    ASSERT(g_oeState.uFlags & OESTATE_FONT);

    //
    // Set up defaults
    //
    fFontSupported = FALSE;
    *pSendDeltaX = FALSE;

    //
    // Do we have our list yet?
    //
    if (!g_oeTextEnabled)
        DC_QUIT;

    //
    // Get the font facename
    //
    GetTextFace(g_oeState.hdc, LF_FACESIZE, g_oeState.logFont.lfFaceName);
    
    //
    // Search our Font Alias Table for the font name.  If we find it,
    // replace it with the aliased name.
    //
    charWidthAdjustment = 0;
    for (i = 0; i < NUM_ALIAS_FONTS; i++)
    {
        if (!lstrcmp(g_oeState.logFont.lfFaceName,
                     g_oeFontAliasTable[i].pszOriginalFontName))
        {
            TRACE_OUT(("Alias name: %s -> %s", g_oeState.logFont.lfFaceName,
                    g_oeFontAliasTable[i].pszAliasFontName));
            lstrcpy(g_oeState.logFont.lfFaceName,
                    g_oeFontAliasTable[i].pszAliasFontName);
            charWidthAdjustment = g_oeFontAliasTable[i].charWidthAdjustment;
            break;
        }
    }

    //
    // Get the current font code page
    //
    switch (g_oeState.tmFont.tmCharSet)
    {
        case ANSI_CHARSET:
            codePage = NF_CP_WIN_ANSI;
            break;

        case OEM_CHARSET:
            codePage = NF_CP_WIN_OEM;
            break;

        //
        // LAURABU BUGBUG
        // This wasn't in NM 2.0 -- does this cause problems in int'l?
        //
        case SYMBOL_CHARSET:
            codePage = NF_CP_WIN_SYMBOL;
            break;

        default:
            codePage = NF_CP_UNKNOWN;
            break;
    }


    //
    // We have a font name to match with those we know to be available
    // remotely.  Try to jump straight to the first entry in the local font
    // table starting with the same char as this font.  If this index slot
    // is empty (has 0xFFFF in it), then bail out immediately.
    //
    for (iLocal = g_oeLocalFontIndex[(BYTE)g_oeState.logFont.lfFaceName[0]];
         iLocal < g_oeNumFonts;
         iLocal++)
    {
        //
        // If this font isn't supported remotely, skip it.
        //
        matchQuality = g_poeLocalFonts[iLocal].SupportCode;
        if (matchQuality == FH_SC_NO_MATCH)
        {
            continue;
        }

        //
        // If this facename is different than ours, skip it.  WE MUST
        // CALL STRCMP(), because lstrcmp and strcmp() do different things
        // for case.  lstrcmp is lexi, and strcmp is alphi.
        //
        compareResult = MyStrcmp(g_poeLocalFonts[iLocal].Details.nfFaceName,
            g_oeState.logFont.lfFaceName);

        //
        // If this font is alphabetically before the one we're searching for,
        // skip it and continue looking.
        //
        if (compareResult < 0)
        {
            continue;
        }

        //
        // If this font is alphabetically after the one we're searching for,
        // then an entry for ours doesn't exist since the table is sorted
        // alphabetically.  Bail out.
        //
        if (compareResult > 0)
        {
            break;
        }

        //
        // This looks promising, a font with the right name is supported on
        // the remote system.  Let's look at the metrics.
        //
        *pFontFlags  = 0;
        *pFontIndex  = iLocal;
        *pFontWeight = g_oeState.tmFont.tmWeight;

        //
        // Check for a fixed pitch font (NOT present means fixed)
        //
        if (!(g_oeState.tmFont.tmPitchAndFamily & FIXED_PITCH))
        {
            *pFontFlags |= NF_FIXED_PITCH;
        }

        //
        // Check for a truetype font
        //
        if (g_oeState.tmFont.tmPitchAndFamily & TMPF_TRUETYPE)
        {
            *pFontFlags |= NF_TRUE_TYPE;
        }

        //
        // Convert the font dimensions into pixel values.  We use the 
        // average font width and the character height
        //
        xformSize[0].x = 0;
        xformSize[0].y = 0;
        xformSize[1].x = g_oeState.tmFont.tmAveCharWidth;
        xformSize[1].y = g_oeState.tmFont.tmHeight -
            g_oeState.tmFont.tmInternalLeading;

        //
        // For non-truetype simulated bold/italic fonts only:
        //
        // If the font is bold, the overhang field indicates the extra
        // space a char takes up.  Since our internal table contains the
        // size of normal (non-bold) chars for simulated bold, we adjust
        // for that here.
        // 
        // If the font is italic, the overhang field indicates the number
        // of pixels the char is skewed.  We don't want to make adjustments
        // in this case.
        //
        if (!(g_oeState.tmFont.tmPitchAndFamily & TMPF_TRUETYPE) &&
            !g_oeState.tmFont.tmItalic)
        {
            xformSize[1].x -= g_oeState.tmFont.tmOverhang;
        }

        //
        // LAURABU BOGUS
        // For baseline text orders
        //
        // xformSize[2].x = 0;
        // xformSize[2].y = g_oeState.tmFont.tmAscent;
        //

        LPtoDP(g_oeState.hdc, xformSize, 2);

        //
        // Calculate the font width & height
        //
        *pFontHeight = abs(xformSize[1].y - xformSize[0].y);
        *pFontWidth  = abs(xformSize[1].x - xformSize[0].x)
            - charWidthAdjustment;

        //
        // LAURABU BOGUS
        // For baseline text orders
        //
        // Get the offset to the start of the text cell
        //
        // *pFontAscender = abs(xformSize[2].y - xformSize[0].y);
        //


        //
        // Check that we have a matching pair -- where we require that the
        // fonts (i.e., the one being used by the app and the one we've
        // matched with the remot system) are the same pitch and use the
        // same technology.
        //
        if ((g_poeLocalFonts[iLocal].Details.nfFontFlags & NF_FIXED_PITCH) !=
            (*pFontFlags & NF_FIXED_PITCH))
        {
            OTRACE(("Fixed pitch mismatch"));
            continue;
        }
        if ((g_poeLocalFonts[iLocal].Details.nfFontFlags & NF_TRUE_TYPE) !=
            (*pFontFlags & NF_TRUE_TYPE))
        {
            OTRACE(("True type mismatch"));
            continue;
        }

        //
        // We have a pair of fonts with the same attributes, both fixed or
        // variable pitch, and using the same font technology.
        //
        // If the font is fixed pitch, then we need to check that the size
        // matches also.
        //
        // If not, assume it's always matchable.
        //
        if (g_poeLocalFonts[iLocal].Details.nfFontFlags & NF_FIXED_SIZE)
        {
            //
            // The font is fixed size, so we must check that this
            // particular size is matchable.
            //
            if ( (*pFontHeight != g_poeLocalFonts[iLocal].Details.nfAveHeight) ||
                 (*pFontWidth  != g_poeLocalFonts[iLocal].Details.nfAveWidth)  )
            {
                //
                // The sizes differ, so we must fail this match.
                //
                TRACE_OUT(("Font size mismatch:  want {%d, %d}, found {%d, %d}",
                    *pFontHeight, *pFontWidth, g_poeLocalFonts[iLocal].Details.nfAveHeight,
                    g_poeLocalFonts[iLocal].Details.nfAveWidth));
                continue;
            }
        }

        //
        // Finally, we've got a matched pair.
        //
        fFontSupported = TRUE;
        break;
    }


    if (!fFontSupported)
    {
        TRACE_OUT(("Couldn't find matching font for %s in table",
            g_oeState.logFont.lfFaceName));
        DC_QUIT;
    }

    //
    // Build up the rest of the font flags.  We've got pitch already.
    //
    if (g_oeState.tmFont.tmItalic)
    {
        *pFontFlags |= NF_ITALIC;
    }
    if (g_oeState.tmFont.tmUnderlined)
    {
        *pFontFlags |= NF_UNDERLINE;
    }
    if (g_oeState.tmFont.tmStruckOut)
    {
        *pFontFlags |= NF_STRIKEOUT;
    }

    //
    // LAURABU BOGUS
    // On NT, here's where simulated bold fonts are handled.  Note that we, 
    // like NM 2.0, handle it above with the overhang.
    //
#if 0
    //
    // It is possible to have a font made bold by Windows, i.e.  the
    // standard font definition is not bold, but windows manipulates the
    // font data to create a bold effect.  This is marked by the
    // FO_SIM_BOLD flag.
    //
    // In this case we need to ensure that the font flags are marked as
    // bold according to the weight.
    //
    if ( ((pfo->flFontType & FO_SIM_BOLD) != 0)       &&
         ( pFontMetrics->usWinWeight      <  FW_BOLD) )
    {
        TRACE_OUT(( "Upgrading weight for a bold font"));
        *pFontWeight = FW_BOLD;
    }
#endif

    //
    // Should we check the chars in the string itself?  Use matchQuality
    // to decide.
    //
    // If the font is an exact match, or if it's an approx match for its
    // entire range (0x00 to 0xFF), then send it happily.  If not, only 
    // send chars within the range 0x20-0x7F (real ASCII)
    //
    if (codePage != g_poeLocalFonts[iLocal].Details.nfCodePage)
    {
        TRACE_OUT(( "Using different CP: downgrade to APPROX_ASC"));
        matchQuality = FH_SC_APPROX_ASCII_MATCH;
    }

    //
    // If we don't have an exact match, check the individual characters.
    //
    if ( (matchQuality != FH_SC_EXACT_MATCH ) &&
         (matchQuality != FH_SC_APPROX_MATCH) )
    {
        //
        // LAURABU BOGUS!
        // NT does approximate matching only if the font supports the
        // ANSI charset.  NM 2.0 never did this, so we won't either.
        //

        //
        // This font is not a good match across its entire range.  Check
        // that all chars are within the desired range.
        //
        for (i = 0; i < cchText; i++)
        {
            if ( (lpszText[i] == 0) ||
                 ( (lpszText[i] >= NF_ASCII_FIRST) &&
                   (lpszText[i] <= NF_ASCII_LAST)  )  )
            {
                continue;
            }

            //
            // Can only get here by finding a char outside our acceptable
            // range.
            //
            OTRACE(("Found non ASCII char %c", lpszText[i]));
            fFontSupported = FALSE;
            DC_QUIT;
        }

        if (fFontSupported)
        {
            //
            // We still have to check that this is ANSI text.  Consider a
            // string written in symbol font where all the chars in
            // the string are in the range 0x20-0x7F, but none of them 
            // are ASCII.
            //
            OemToAnsiBuff(lpszText, g_oeAnsiString, cchText);

            //
            // BOGUS LAURABU
            // This is our own inline MEMCMP to avoid pulling in the CRT.
            // If any other place needs it, we should make this a function
            //
            for (i = 0; i < cchText; i++)
            {
                if (lpszText[i] != g_oeAnsiString[i])
                {
                    OTRACE(("Found non ANSI char %c", lpszText[i]));
                    fFontSupported = FALSE;
                    DC_QUIT;
                }
            }
        }
    }


    //
    // We have a valid font.  Now sort out deltaX issues
    //
    if (!(g_oeFontCaps & CAPS_FONT_NEED_X_ALWAYS))
    {
        if (!(g_oeFontCaps & CAPS_FONT_NEED_X_SOMETIMES))
        {
            //
            // CAPS_FONT_NEED_X_SOMETIMES and CAPS_FONT_NEED_X_ALWAYS are
            // both not set so we can exit now.  (We do not need a delta X
            // array).
            //
            TRACE_OUT(( "Capabilities eliminated delta X"));
            DC_QUIT;
        }

        //
        // CAPS_FONT_NEED_X_SOMETIMES is set and CAPS_FONT_NEED_X_ALWAYS is
        // not set.  In this case whether we need a delta X is determined
        // by whether the font is an exact match or an approximate match
        // (because of either approximation of name, signature, or aspect
        // ratio).  We can only find this out after we have extracted the
        // font handle from the existing order.
        //
    }

    //
    // If the string is a single character (or less) then we can just
    // return.
    //
    if (cchText <= 1)
    {
        TRACE_OUT(( "String only %u long", cchText));
        DC_QUIT;
    }

    //
    // Capabilities allow us to ignore delta X position if we have an exact
    // match.
    //
    if (matchQuality & FH_SC_EXACT)
    {
        //
        // Exit immediately, providing that there is no override to always
        // send increments.
        //
        if (!(g_oeFontCaps & CAPS_FONT_NEED_X_ALWAYS))
        {
            TRACE_OUT(( "Font has exact match"));
            DC_QUIT;
        }
    }

    //
    // We must send a deltaX array
    //
    *pSendDeltaX = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(OECheckFontIsSupported, fFontSupported);
    return(fFontSupported);
}



//
// OEAddDeltaX()
//
// This fills in the allocated deltaX array if one is needed, either because
// the app passed one in ExtTextOut, or we need to simulate a font that
// isn't available remotely.
//
BOOL OEAddDeltaX
(
    LPEXTTEXTOUT_ORDER  pExtTextOut,
    LPSTR               lpszText,
    UINT                cchText,
    LPINT               lpdxCharSpacing,
    BOOL                fDeltaX,
    POINT               ptStart
)
{
    BOOL                fSuccess;
    LPBYTE              lpVariable;
    LPVARIABLE_DELTAX   lpDeltaPos;
    UINT                i;
    int                 charWidth;
    int                 xLastLP;
    int                 xLastDP;

    DebugEntry(OEAddDeltaX);

    lpVariable = ((LPBYTE)&pExtTextOut->variableString) +
        sizeof(pExtTextOut->variableString.len) + cchText;
    lpDeltaPos = (LPVARIABLE_DELTAX)DC_ROUND_UP_4((DWORD)lpVariable);

    fSuccess = FALSE;

    if (SELECTOROF(lpdxCharSpacing))
    {
        //
        // We must translate the LPDX increments into device units.  
        // We have to do this a single point at a time to preserve
        // accuracy and because the order field isn't the same size.
        //
        // We preserve accuracy by calculating the position of the
        // point in the current coords, and converting this before
        // subtracting the original point to get the delta.  
        // Otherwise, we'd hit rounding errors very often.  4 chars
        // is the limit in TWIPs e.g.
        //

        lpDeltaPos->len = cchText * sizeof(TSHR_INT32);

        xLastLP = ptStart.x;
        ptStart.y = 0;
        LPtoDP(g_oeState.hdc, &ptStart, 1);
        xLastDP = ptStart.x;

        for (i = 0; i < cchText; i++)
        {
            xLastLP += lpdxCharSpacing[i];

            ptStart.x = xLastLP;
            ptStart.y = 0;
            LPtoDP(g_oeState.hdc, &ptStart, 1);

            lpDeltaPos->deltaX[i] = ptStart.x - xLastDP;
            xLastDP = ptStart.x;
        }

        //
        // Remember we have a deltax array
        //
        pExtTextOut->fuOptions |= ETO_LPDX;
        fSuccess = TRUE;
    }
    else if (fDeltaX)
    {
        //
        // Simulate deltax.
        //
        lpDeltaPos->len = cchText * sizeof(TSHR_INT32);

        //
        // Is this the same font as last time?  If so, we have the 
        // generated character width table cached.
        //
        // NOTE that when the capabilities chage, we clear the cache to
        // avoid matching a font based on a stale index.  And when starting
        // to share.
        //
        if ((g_oeFhLast.fontIndex     != pExtTextOut->common.FontIndex) ||
            (g_oeFhLast.fontHeight    != pExtTextOut->common.FontHeight) ||
            (g_oeFhLast.fontWidth     != pExtTextOut->common.FontWidth) ||
            (g_oeFhLast.fontWeight    != pExtTextOut->common.FontWeight) ||
            (g_oeFhLast.fontFlags     != pExtTextOut->common.FontFlags))
        {
            LPLOCALFONT lpFont;
            HFONT       hFontSim;
            HFONT       hFontOld;
            TEXTMETRIC  tmNew;
            int         width;
            ABC         abc;
            BYTE        italic;
            BYTE        underline;
            BYTE        strikeout;
            BYTE        pitch;
            BYTE        charset;
            BYTE        precis;
            TSHR_UINT32 FontFlags;

            //
            // Generate a new table and cache the info
            //
            // We can not use the ACTUAL font selected in.  We must
            // create a new logical font from our table info.
            //

            ASSERT(g_poeLocalFonts);
            lpFont = g_poeLocalFonts + pExtTextOut->common.FontIndex;
            FontFlags = pExtTextOut->common.FontFlags;

            //
            // What are the logical attributes of this desired font?
            //

            italic      = (BYTE)(FontFlags & NF_ITALIC);
            underline   = (BYTE)(FontFlags & NF_UNDERLINE);
            strikeout   = (BYTE)(FontFlags & NF_STRIKEOUT);

            if (FontFlags & NF_FIXED_PITCH)
            {
                pitch = FF_DONTCARE | FIXED_PITCH;
            }
            else
            {
                pitch = FF_DONTCARE | VARIABLE_PITCH;
            }

            //
            // Is this a TrueType font?  The windows Font Mapper biases
            // towards non-TrueType fonts.
            //
            if (FontFlags & NF_TRUE_TYPE)
            {
                pitch |= TMPF_TRUETYPE;
                precis = OUT_TT_ONLY_PRECIS;
            }
            else
            {
                precis = OUT_RASTER_PRECIS;
            }

            //
            // The given height is the char height, not the cell height.
            // So pass it as a negative value below...
            //

            //
            // Use the codepage (misleadingly named) to figure out the
            // charset to ask for.
            //
            if (lpFont->Details.nfCodePage == NF_CP_WIN_ANSI)
            {
                charset = ANSI_CHARSET;
            }
            else if (lpFont->Details.nfCodePage == NF_CP_WIN_OEM)
            {
                charset = OEM_CHARSET;
            }
            else if (lpFont->Details.nfCodePage == NF_CP_WIN_SYMBOL)
            {
                charset = SYMBOL_CHARSET;
            }
            else
            {
                charset = DEFAULT_CHARSET;
            }

            hFontSim = CreateFont(-(int)pExtTextOut->common.FontHeight,
                (int)pExtTextOut->common.FontWidth, 0, 0,
                (int)pExtTextOut->common.FontWeight, italic, underline,
                strikeout, charset, precis, CLIP_DEFAULT_PRECIS,
                DEFAULT_QUALITY, pitch, (LPSTR)lpFont->Details.nfFaceName);
            if (!hFontSim)
            {
                ERROR_OUT(("Couldn't create simulated font for metrics"));
                DC_QUIT;
            }
            
            hFontOld = SelectFont(g_osiScreenDC, hFontSim);
            if (!hFontOld)
            {
                ERROR_OUT(("Couldn't select simulated font for metrics"));
                DeleteFont(hFontSim);
                DC_QUIT;
            }

            //
            // Get the character dimensions
            //
            GetTextMetrics(g_osiScreenDC, &tmNew);

            for (i = 0; i < 256; i++)
            {
                if (tmNew.tmPitchAndFamily & TMPF_TRUETYPE)
                {
                    //
                    // Use ABC spacing for truetype
                    //
                    GetCharABCWidths(g_osiScreenDC, i, i, &abc);
    
                    width = abc.abcA + abc.abcB + abc.abcC;
                }
                else if (!(tmNew.tmPitchAndFamily & FIXED_PITCH))
                {
                    //
                    // Note that the name of FIXED_PITCH is not what you'd
                    // expect, its ABSENCE means it's fixed.
                    //
                    // In any case, for fixed pitch fonts, each char is the 
                    // same size.
                    //
                    width = tmNew.tmAveCharWidth - tmNew.tmOverhang; 
                }
                else
                {
                    //
                    // Query the width of the char
                    //
                    GetCharWidth(g_osiScreenDC, i, i, &width);
                    width -= tmNew.tmOverhang;
                }

                g_oeFhLast.charWidths[i] = width;
            }

            //
            // We've successfully generated the width info for this font,
            // update our cache.
            //
            g_oeFhLast.fontIndex  = pExtTextOut->common.FontIndex;
            g_oeFhLast.fontHeight = pExtTextOut->common.FontHeight;
            g_oeFhLast.fontWidth  = pExtTextOut->common.FontWidth;  
            g_oeFhLast.fontWeight = pExtTextOut->common.FontWeight;
            g_oeFhLast.fontFlags  = pExtTextOut->common.FontFlags;

            //
            // Select back in old font and delete new one
            //
            SelectFont(g_osiScreenDC, hFontOld);
            DeleteFont(hFontSim);
        }

        //
        // Now calculate the width of each character in the string.  
        // This includes the last char because it is needed to correctly 
        // define the extent of the string.
        //
        for (i = 0; i < cchText; i++)
        {
            //
            // The width is that in the width table for the current char. 
            //
            lpDeltaPos->deltaX[i] = g_oeFhLast.charWidths[lpszText[i]];
        }

        //
        // Remember we have a deltax array
        //
        pExtTextOut->fuOptions |= ETO_LPDX;
        fSuccess = TRUE;
    }
    else
    {
        //
        // No deltax array
        //
        lpDeltaPos->len = 0;
        fSuccess = TRUE;
    }

DC_EXIT_POINT:
    DebugExitBOOL(OEAddDeltaX, fSuccess);
    return(fSuccess);
}



//
// OEGetStringExtent()
//
int OEGetStringExtent
(
    LPSTR   lpszText,
    UINT    cchText,
    LPINT   lpdxCharSpacing,
    LPRECT  lprcExtent
)
{
    DWORD   textExtent;
    UINT    i;
    int     thisX;
    int     minX;
    int     maxX;
    ABC     abcSpace;
    int     overhang = 0;

    DebugEntry(OEGetStringExtent);

    ASSERT(g_oeState.uFlags & OESTATE_FONT);
    ASSERT(g_oeState.uFlags & OESTATE_COORDS);

    //
    // With no characters, return a NULL rect
    //
    if (cchText == 0)
    {
        lprcExtent->left    = 1;
        lprcExtent->top     = 0;
        lprcExtent->right   = 0;
        lprcExtent->bottom  = 0;
    }
    else if (!SELECTOROF(lpdxCharSpacing))
    {
        //
        // Get the simple text extent from GDI
        //
        textExtent = GetTextExtent(g_oeState.hdc, lpszText, cchText);

        lprcExtent->left    = 0;
        lprcExtent->top     = 0;
        lprcExtent->right   = LOWORD(textExtent);
        lprcExtent->bottom  = HIWORD(textExtent);

        //
        // We now have the the advance distance for the string.  However,
        // some fonts like TrueType with C widths, or Italic, may extend
        // beyond this.  Add in extra space here if necessary
        //
        if (g_oeState.tmFont.tmPitchAndFamily & TMPF_TRUETYPE)
        {
            //
            // Get the A-B-C widths of the last character
            //
            GetCharABCWidths(g_oeState.hdc, lpszText[cchText-1],
                lpszText[cchText-1], &abcSpace);

            //
            // Add on the C width (the right side extra) of the last char
            //
            overhang = abcSpace.abcC;
        }
        else
        {
            //
            // Use global overhang, this is an old font (like simulated Italic)
            //
            overhang = g_oeState.tmFont.tmOverhang;
        }

        lprcExtent->right += overhang;
    }
    else
    {
        //
        // Delta positions were given.  In this case, the text extent is 
        // the sum of the delta values + the width of the last char
        //

        // Get the dimensions of the chars one by one, starting with 1st char
        textExtent = GetTextExtent(g_oeState.hdc, lpszText, 1);

        thisX = 0;
        minX  = 0;
        maxX  = LOWORD(textExtent);

        for (i = 1; i < cchText; i++)
        {
            thisX   += g_oeState.ptPolarity.x * lpdxCharSpacing[i-1];
            textExtent = GetTextExtent(g_oeState.hdc, lpszText+i, 1);

            minX = min(minX, thisX);
            maxX = max(maxX, thisX + (int)LOWORD(textExtent));
        }

        thisX += g_oeState.ptPolarity.x * lpdxCharSpacing[cchText-1];
        maxX   = max(maxX, thisX);

        lprcExtent->left    = minX;
        lprcExtent->top     = 0;
        lprcExtent->right   = maxX;
        lprcExtent->bottom  = HIWORD(textExtent);
    }

    DebugExitDWORD(OEGetStringExtent, (DWORD)(LONG)overhang);
    return(overhang);
}



//
// DrvFillPath()
//
BOOL WINAPI DrvFillPath
(
    HDC     hdcDst
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvFillPath);

    OE_SHM_START_WRITING;

    //
    // The Path() apis don't set the drawing bounds.  We assume the whole
    // screen (device coords) instead.
    //
    // NOTE that NM 2.0 had a bug--it didn't account for the virtual
    // screen origin when setting up the rect to accum as screen data.
    // It just passed (0, 0, 32765, 32765) in.
    //
    fWeCare = OEBeforeDDI(DDI_FILLPATH, hdcDst, OESTATE_SDA_SCREEN);

    fOutput = FillPath(hdcDst);

    OEAfterDDI(DDI_FILLPATH, fWeCare, fOutput);

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvFillPath, fOutput);
    return(fOutput);
}


//
// DrvStrokeAndFillPath()
//
BOOL WINAPI DrvStrokeAndFillPath
(
    HDC     hdcDst
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvStrokeAndFillPath);

    OE_SHM_START_WRITING;

    //
    // The Path() apis don't set the drawing bounds.  We assume the whole
    // screen (device coords) instead.
    //
    // NOTE that NM 2.0 had a bug--it didn't account for the virtual
    // screen origin when setting up the rect to accum as screen data.
    // It just passed (0, 0, 32765, 32765) in.
    //

    fWeCare = OEBeforeDDI(DDI_STROKEANDFILLPATH, hdcDst, OESTATE_SDA_SCREEN);

    fOutput = StrokeAndFillPath(hdcDst);

    OEAfterDDI(DDI_STROKEANDFILLPATH, fWeCare, fOutput);

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvStrokeAndFillPath, fOutput);
    return(fOutput);
}


//
// DrvStrokePath()
//
BOOL WINAPI DrvStrokePath
(
    HDC     hdcDst
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvStrokePath);

    OE_SHM_START_WRITING;

    //
    // The Path() apis don't set the drawing bounds.  We assume the whole
    // screen (device coords) instead.
    //
    // NOTE that NM 2.0 had a bug--it didn't account for the virtual
    // screen origin when setting up the rect to accum as screen data.
    // It just passed (0, 0, 32765, 32765) in.
    //
    fWeCare = OEBeforeDDI(DDI_STROKEPATH, hdcDst, OESTATE_SDA_SCREEN);

    fOutput = StrokePath(hdcDst);

    OEAfterDDI(DDI_STROKEPATH, fWeCare, fOutput);

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvStrokePath, fOutput);
    return(fOutput);
}



//
// DrvFillRgn()
//
BOOL WINAPI DrvFillRgn
(
    HDC     hdcDst,
    HRGN    hrgnFill,
    HBRUSH  hbrFill
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvFillRgn);

    OE_SHM_START_WRITING;

    //
    // We can't use Rgn apis if the map mode isn't MM_TEXT.  So we use DCBs
    // instead.
    //
    fWeCare = OEBeforeDDI(DDI_FILLRGN, hdcDst, 0);

    fOutput = FillRgn(hdcDst, hrgnFill, hbrFill);

    if (OEAfterDDI(DDI_FILLRGN, fWeCare, fOutput))
    {
        //
        // NOTE that OEAfterDDI() returns FALSE even if fOutput if we used
        // DCBs to send as screen data.  In other words, OEAfterDDI() returns
        // TRUE IFF output happened into a DC we care about and it needs 
        // processing still.
        //
        OEAddRgnPaint(hrgnFill, hbrFill, g_oeState.lpdc->DrawMode.Rop2);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvFillRgn, fOutput);
    return(fOutput);
}


//
// OETwoWayRopToThree()
// Gets the 3-way ROP equivalent of a 2-way ROP.
//
BOOL OETwoWayRopToThree
(
    int     rop2,
    LPDWORD lpdwRop3
)
{
    BOOL    fConverted = TRUE;

    DebugEntry(OETwoWayRopToThree);

    switch (rop2)
    {
        case R2_BLACK:
            *lpdwRop3 = BLACKNESS;
            break;

        case R2_NOT:
            *lpdwRop3 = DSTINVERT;
            break;

        case R2_XORPEN:
            *lpdwRop3 = PATINVERT;
            break;

        case R2_COPYPEN:
            *lpdwRop3 = PATCOPY;
            break;

        case R2_WHITE:
            *lpdwRop3 = WHITENESS;
            break;

        default:
            fConverted = FALSE;
            break;
    }

    DebugExitBOOL(OETwoWayRopToThree, fConverted);
    return(fConverted);
}

//
// OEAddRgnPaint()
// This will set up a modified region (vis intersect param) and brush, and
// if possible will fake a PatBlt.  If not, screen data.
//
// NOTE:
// (1) hrgnPaint is in DC coords
// (2) GetClipRgn() returns a region in screen coords
// (3) SelectClipRgn() takes a region in DC coords
//
void OEAddRgnPaint
(
    HRGN    hrgnPaint,
    HBRUSH  hbrPaint,
    UINT    rop2
)
{
    BOOL    fScreenData = TRUE;
    HRGN    hrgnClip;
    HRGN    hrgnNewClip;
    HRGN    hrgnOldClip;
    POINT   ptXlation;
    DWORD   dwRop3;

    DebugEntry(OEAddRgnPaint);

    //
    // Get the original visrgn.
    //
    OEGetState(OESTATE_COORDS | OESTATE_REGION);

    //
    // Get the bounding box and convert the bounding box to our coords.
    //
    if (GetRgnBox(hrgnPaint, &g_oeState.rc) <= NULLREGION)
    {
        // Nothing to do.
        TRACE_OUT(("OEAddRgnPaint:  empty region"));
        goto DC_EMPTY_REGION;
    }
    OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

    //
    // We can't continue if we aren't MM_TEXT--clip rgn APIs only work 
    // in that mode.  So send as screen data instead.
    //
    if (GetMapMode(g_oeState.hdc) != MM_TEXT)
    {
        TRACE_OUT(("OEAddRgnPaint: map mode not MM_TEXT, send as screen data"));
        DC_QUIT;
    }

    //
    // Save a copy of the current cliprgn
    //
    hrgnNewClip = CreateRectRgn(0, 0, 0, 0);
    if (!hrgnNewClip)
        DC_QUIT;

    //
    // Get app LP xlation factor; SelectClipRgn() expects DP units
    //
    ptXlation.x = 0;
    ptXlation.y = 0;
    DPtoLP(g_oeState.hdc, &ptXlation, 1);

    hrgnOldClip = NULL;
    if (hrgnClip = GetClipRgn(g_oeState.hdc))
    {
        hrgnOldClip = CreateRectRgn(0, 0, 0, 0);
        if (!hrgnOldClip)
        {
            DeleteRgn(hrgnNewClip);
            DC_QUIT;
        }

        //
        // This is in screen coords.  Convert to DC coords
        //      * Subtract the DC origin
        //      * Get the DP-LP xlation and subtract
        //
        CopyRgn(hrgnOldClip, hrgnClip);
        OffsetRgn(hrgnOldClip,
            -g_oeState.ptDCOrg.x + ptXlation.x,
            -g_oeState.ptDCOrg.y + ptXlation.y);

        //
        // Intersect the current clip with the paint region (already in
        // DC coords)
        //
        IntersectRgn(hrgnNewClip, hrgnOldClip, hrgnPaint);

        //
        // Convert the old LP region back to DP units to select back in
        // when done.
        //
        OffsetRgn(hrgnOldClip, -ptXlation.x, -ptXlation.y);
    }
    else
    {
        CopyRgn(hrgnNewClip, hrgnPaint);
    }

    //
    // Convert LP paint region to DP clip region
    //
    OffsetRgn(hrgnNewClip, -ptXlation.x, -ptXlation.y);

    //
    // Select in new clip region (expected to be in device coords).
    //
    SelectClipRgn(g_oeState.hdc, hrgnNewClip);
    DeleteRgn(hrgnNewClip);

    //
    // Reget the RAO (intersect of vis/clip)
    //
    OEGetState(OESTATE_REGION);

    //
    // Get brush info
    //
    if (hbrPaint)
    {
        if (GetObject(hbrPaint, sizeof(g_oeState.logBrush), &g_oeState.logBrush))
        {
            g_oeState.uFlags |= OESTATE_BRUSH;
        }
        else
        {
            g_oeState.logBrush.lbStyle = BS_NULL;
        }
    }

    //
    // Fake a patblt
    //
    if (OETwoWayRopToThree(rop2, &dwRop3))
    {
        fScreenData = FALSE;
        OEAddBlt(dwRop3);
    }

    //
    // Select back in the previous clip rgn
    //
    SelectClipRgn(g_oeState.hdc, hrgnOldClip);
    if (hrgnOldClip)
        DeleteRgn(hrgnOldClip);


DC_EXIT_POINT:
    if (fScreenData)
    {
        OTRACE(("OEAddRgnPaint:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }

DC_EMPTY_REGION:
    DebugExitVOID(OEAddRgnPaint);
}



//
// DrvFrameRgn()
//
BOOL WINAPI DrvFrameRgn
(
    HDC     hdcDst,
    HRGN    hrgnFrameArea,
    HBRUSH  hbrFramePattern,
    int     cxFrame,
    int     cyFrame
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvFrameRgn);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_FRAMERGN, hdcDst, 0);

    fOutput = FrameRgn(hdcDst, hrgnFrameArea, hbrFramePattern,
        cxFrame, cyFrame);

    if (OEAfterDDI(DDI_FRAMERGN, fWeCare, fOutput))
    {
        OEGetState(OESTATE_COORDS | OESTATE_REGION);

        if (GetRgnBox(hrgnFrameArea, &g_oeState.rc) > NULLREGION)
        {
            InflateRect(&g_oeState.rc,
                g_oeState.ptPolarity.x * cxFrame,
                g_oeState.ptPolarity.y * cyFrame);
            OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

            OTRACE(("FrameRgn:  Sending as screen data {%d, %d, %d, %d}",
                g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvFrameRgn, fOutput);
    return(fOutput);
}



//
// DrvInvertRgn()
//
BOOL WINAPI DrvInvertRgn
(
    HDC     hdcDst,
    HRGN    hrgnInvert
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvInvertRgn);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_INVERTRGN, hdcDst, 0);

    fOutput = InvertRgn(hdcDst, hrgnInvert);

    if (OEAfterDDI(DDI_INVERTRGN, fWeCare, fOutput))
    {
        OEAddRgnPaint(hrgnInvert, NULL, R2_NOT);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvInvertRgn, fOutput);
    return(fOutput);
}



//
// DrvPaintRgn()
//
BOOL WINAPI DrvPaintRgn
(
    HDC     hdcDst,
    HRGN    hrgnPaint
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvPaintRgn);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_PAINTRGN, hdcDst, 0);

    fOutput = PaintRgn(hdcDst, hrgnPaint);

    if (OEAfterDDI(DDI_PAINTRGN, fWeCare, fOutput))
    {
        OEAddRgnPaint(hrgnPaint, g_oeState.lpdc->hBrush, g_oeState.lpdc->DrawMode.Rop2);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPaintRgn, fOutput);
    return(fOutput);
}



//
// DrvLineTo()
//
BOOL WINAPI DrvLineTo
(
    HDC     hdcDst,
    int     xTo,
    int     yTo
)
{
    POINT   ptEnd;
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvLineTo);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_LINETO, hdcDst, OESTATE_CURPOS);

    fOutput = LineTo(hdcDst, xTo, yTo);

    //
    // OEAfterDDI returns TRUE if the DC is a screen DC and output happened
    // and we aren't skipping due to reentrancy.
    //
    if (OEAfterDDI(DDI_LINETO, fWeCare, fOutput))
    {
        //
        // OEAddLine() will calculate extents, and if an order can't be sent,
        // OEDoneDDI will add the bounds as screen data.
        //
        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_REGION);
                                  
        ptEnd.x = xTo;
        ptEnd.y = yTo;

        ASSERT(g_oeState.uFlags & OESTATE_CURPOS);
        OEAddLine(g_oeState.ptCurPos, ptEnd);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvLineTo, fOutput);
    return(fOutput);
}



//
// DrvPolyline()
//
// NOTE:
// The differences between Polyline() and PolylineTo() are
//      (1) PolylineTo moves the current position to the end coords of the
//          last point; Polyline preserves the current position
//      (2) Polyline uses the first point in the array as the starting coord
//          of the first point; PolylineTo() uses the current position.
//
BOOL WINAPI DrvPolyline
(
    HDC     hdcDst,
    LPPOINT    aPoints,
    int     cPoints
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvPolyline);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_POLYLINE, hdcDst, 0);

    fOutput = Polyline(hdcDst, aPoints, cPoints);

    if (OEAfterDDI(DDI_POLYLINE, fWeCare, fOutput && cPoints > 1))
    {
        //
        // GDI should NEVER return success if the aPoints parameter is
        // bogus.
        //
        // NOTE LAURABU:
        // This implementation is better than NM 2.0.  That one would turn
        // this GDI call actually into separate MoveTo/LineTo calls, which 
        // whacks out metafiles etc.  Instead, we call through to the org
        // Polyline, then add LineTo orders.
        //
        ASSERT(!IsBadReadPtr(aPoints, cPoints*sizeof(POINT)));

        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_REGION);

        OEAddPolyline(aPoints[0], aPoints+1, cPoints-1);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPolyline, fOutput);
    return(fOutput);
}



//
// DrvPolylineTo()
//
BOOL WINAPI DrvPolylineTo
(
    HDC     hdcDst,
    LPPOINT    aPoints,
    int     cPoints
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvPolylineTo);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_POLYLINETO, hdcDst, OESTATE_CURPOS);

    fOutput = g_lpfnPolylineTo(hdcDst, aPoints, cPoints);

    if (OEAfterDDI(DDI_POLYLINETO, fWeCare, fOutput && cPoints))
    {
        //
        // GDI should NEVER return success if the aPoints parameter is
        // bogus.
        //
        // NOTE LAURABU:
        // This implementation is better than NM 2.0.  That one would turn
        // this GDI call actually into separate LineTo calls, which whacks
        // out metafiles etc.  Instead, we call through to the original
        // PolylineTo, then add LineTo orders.
        //
        ASSERT(!IsBadReadPtr(aPoints, cPoints*sizeof(POINT)));

        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_REGION);
        ASSERT(g_oeState.uFlags & OESTATE_CURPOS);

        OEAddPolyline(g_oeState.ptCurPos, aPoints, cPoints);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPolylineTo, fOutput);
    return(fOutput);
}



//
// OEAddPolyline
// Used by Polyline(), PolylineTo(), and PolyPolyline()
//
void OEAddPolyline
(
    POINT   ptStart,
    LPPOINT aPoints,
    UINT    cPoints
)
{
    DebugEntry(OEAddPolyline);

    ASSERT(g_oeState.uFlags & OESTATE_COORDS);
    ASSERT(g_oeState.uFlags & OESTATE_REGION);

    while (cPoints-- > 0)
    {
        OEAddLine(ptStart, *aPoints);

        //
        // The start point of the next line is the end point of the
        // current one.
        //
        ptStart = *aPoints;

        aPoints++;
    }

    DebugExitVOID(OEAddPolyline);
}



//
// DrvPlayEnhMetaFileRecord()
//
BOOL WINAPI DrvPlayEnhMetaFileRecord
(
    HDC     hdcDst,
    LPHANDLETABLE   lpEMFHandles,
    LPENHMETARECORD lpEMFRecord,
    DWORD   cEMFHandles
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvPlayEnhMetaFileRecord);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_PLAYENHMETAFILERECORD, hdcDst, OESTATE_SDA_DCB);

    fOutput = PlayEnhMetaFileRecord(hdcDst, lpEMFHandles, lpEMFRecord, cEMFHandles);

    OEAfterDDI(DDI_PLAYENHMETAFILERECORD, fWeCare, fOutput);

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPlayEnhMetaFileRecord, fOutput);
    return(fOutput);
}



//
// DrvPlayMetaFile()
//
BOOL WINAPI DrvPlayMetaFile
(
    HDC     hdcDst,
    HMETAFILE   hmf
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvPlayMetaFile);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_PLAYMETAFILE, hdcDst, OESTATE_SDA_DCB);
    
    fOutput = PlayMetaFile(hdcDst, hmf);

    OEAfterDDI(DDI_PLAYMETAFILE, fWeCare, fOutput);

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPlayMetaFile, fOutput);
    return(fOutput);
}



//
// DrvPlayMetaFileRecord()
//
void WINAPI DrvPlayMetaFileRecord
(
    HDC     hdcDst,
    LPHANDLETABLE   lpMFHandles,
    LPMETARECORD    lpMFRecord,
    UINT    cMFHandles
)
{
    BOOL    fWeCare;

    DebugEntry(DrvPlayMetaFileRecord);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_PLAYMETAFILERECORD, hdcDst, OESTATE_SDA_DCB);

    PlayMetaFileRecord(hdcDst, lpMFHandles, lpMFRecord, cMFHandles);

    OEAfterDDI(DDI_PLAYMETAFILERECORD, fWeCare, TRUE);

    OE_SHM_STOP_WRITING;

    DebugExitVOID(DrvPlayMetaFileRecord);
}



//
// DrvPolyBezier()
//
BOOL WINAPI DrvPolyBezier
(
    HDC     hdcDst,
    LPPOINT    aPoints,
    UINT    cPoints
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvPolyBezier);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_POLYBEZIER, hdcDst, 0);

    fOutput = PolyBezier(hdcDst, aPoints, cPoints);

    if (OEAfterDDI(DDI_POLYBEZIER, fWeCare, fOutput && (cPoints > 1)))
    {
        ASSERT(!IsBadReadPtr(aPoints, cPoints*sizeof(POINT)));

        OEAddPolyBezier(aPoints[0], aPoints+1, cPoints-1); 
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPolyBezier, fOutput);
    return(fOutput);
}



//
// DrvPolyBezierTo()
//
BOOL WINAPI DrvPolyBezierTo
(
    HDC     hdcDst,
    LPPOINT    aPoints,
    UINT    cPoints
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvPolyBezierTo);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_POLYBEZIERTO, hdcDst, OESTATE_CURPOS);

    fOutput = PolyBezierTo(hdcDst, aPoints, cPoints);

    if (OEAfterDDI(DDI_POLYBEZIERTO, fWeCare, fOutput && cPoints))
    {
        ASSERT(!IsBadReadPtr(aPoints, cPoints*sizeof(POINT)));
        ASSERT(g_oeState.uFlags & OESTATE_CURPOS);

        OEAddPolyBezier(g_oeState.ptCurPos, aPoints, cPoints);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPolyBezierTo, fOutput);
    return(fOutput);
}



//
// OEAddPolyBezier()
//
// Adds poly bezier order for both PolyBezier() and PolyBezierTo().
//
void OEAddPolyBezier
(
    POINT   ptStart,
    LPPOINT aPoints,
    UINT    cPoints
)
{
    UINT    iPoint;
    LPINT_ORDER pOrder;
    LPPOLYBEZIER_ORDER   pPolyBezier;

    DebugEntry(OEAddPolyBezier);

    OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_REGION);

    //
    // Calculate the bounds
    //
    g_oeState.rc.left = ptStart.x;
    g_oeState.rc.top  = ptStart.y;
    g_oeState.rc.right = ptStart.x;
    g_oeState.rc.bottom = ptStart.y;

    for (iPoint = 0; iPoint < cPoints; iPoint++)
    {
        g_oeState.rc.left = min(g_oeState.rc.left, aPoints[iPoint].x);
        g_oeState.rc.right = max(g_oeState.rc.right, aPoints[iPoint].x);
        g_oeState.rc.top = min(g_oeState.rc.top, aPoints[iPoint].y);
        g_oeState.rc.bottom = max(g_oeState.rc.bottom, aPoints[iPoint].y);
    }

    OEPolarityAdjust(&g_oeState.rc, 1);
    OEPenWidthAdjust(&g_oeState.rc, 1);
    OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

    //
    // OELRtoVirtual takes an exclusive rect and returns an inclusive one.
    // But we passed it an inclusive already rect, so we need to account
    // for that.
    //
    g_oeState.rc.right++;
    g_oeState.rc.bottom++;

    pOrder = NULL;

    // Account for starting point also
    if (OECheckOrder(ORD_POLYBEZIER, OECHECK_PEN | OECHECK_CLIPPING)    &&
        (cPoints < ORD_MAX_POLYBEZIER_POINTS))
    {
        pOrder = OA_DDAllocOrderMem(sizeof(POLYBEZIER_ORDER) -
            ((ORD_MAX_POLYBEZIER_POINTS - cPoints - 1) *
            sizeof(pPolyBezier->variablePoints.aPoints[0])), 0);
        if (!pOrder)
            DC_QUIT;

        pPolyBezier = (LPPOLYBEZIER_ORDER)pOrder->abOrderData;
        pPolyBezier->type = LOWORD(ORD_POLYBEZIER);

        //
        // Copy them into the order array
        //
        pPolyBezier->variablePoints.len =
            ((cPoints+1) * sizeof(pPolyBezier->variablePoints.aPoints[0]));

        pPolyBezier->variablePoints.aPoints[0].x = ptStart.x;
        pPolyBezier->variablePoints.aPoints[0].y = ptStart.y;
        hmemcpy(pPolyBezier->variablePoints.aPoints+1, aPoints,
                cPoints*sizeof(pPolyBezier->variablePoints.aPoints[0]));

        //
        // Convert points to virtual
        //
        // NOTE that this works because aPoints[] holds TSHR_POINT16s, which
        // are natively the same size as POINT structures.
        //
        OELPtoVirtual(g_oeState.hdc, (LPPOINT)pPolyBezier->variablePoints.aPoints,
            cPoints+1);

        OEConvertColor(g_oeState.lpdc->DrawMode.bkColorL,
            &pPolyBezier->BackColor, FALSE);
        OEConvertColor(g_oeState.lpdc->DrawMode.txColorL,
            &pPolyBezier->ForeColor, FALSE);
                
        pPolyBezier->BackMode   = g_oeState.lpdc->DrawMode.bkMode;
        pPolyBezier->ROP2       = g_oeState.lpdc->DrawMode.Rop2;

        pPolyBezier->PenStyle   = g_oeState.logPen.lopnStyle;
        pPolyBezier->PenWidth   = 1;
        OEConvertColor(g_oeState.logPen.lopnColor, &pPolyBezier->PenColor,
            FALSE);

        pOrder->OrderHeader.Common.fOrderFlags  = OF_SPOILABLE;

        OTRACE(("PolyBezier:  Order %08lx, Rect {%d, %d, %d, %d} with %d points",
            pOrder, g_oeState.rc.left, g_oeState.rc.top,
            g_oeState.rc.right, g_oeState.rc.bottom, cPoints+1));
        OEClipAndAddOrder(pOrder, NULL);
    }

DC_EXIT_POINT:
    if (!pOrder)
    {
        OTRACE(("PolyBezier:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }

    DebugExitVOID(OEAddPolyBezier);
}



//
// DrvPolygon()
//
BOOL WINAPI DrvPolygon
(
    HDC     hdcDst,
    LPPOINT    aPoints,
    int     cPoints
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    LPINT_ORDER pOrder;
    LPPOLYGON_ORDER pPolygon;
    int     iPoint;
    POINT   ptBrushOrg;

    DebugEntry(DrvPolygon);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_POLYGON, hdcDst, 0);

    fOutput = Polygon(hdcDst, aPoints, cPoints);

    if (OEAfterDDI(DDI_POLYGON, fWeCare, fOutput && (cPoints > 1)))
    {
        ASSERT(!IsBadReadPtr(aPoints, cPoints*sizeof(POINT)));

        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_BRUSH | OESTATE_REGION);

        //
        // Compute the bounds
        //
        g_oeState.rc.left = aPoints[0].x;
        g_oeState.rc.top = aPoints[0].y;
        g_oeState.rc.right = aPoints[0].x;
        g_oeState.rc.bottom = aPoints[0].y;

        for (iPoint = 1; iPoint < cPoints; iPoint++)
        {
            g_oeState.rc.left = min(g_oeState.rc.left, aPoints[iPoint].x);
            g_oeState.rc.top = min(g_oeState.rc.top, aPoints[iPoint].y);
            g_oeState.rc.right = max(g_oeState.rc.right, aPoints[iPoint].x);
            g_oeState.rc.bottom = max(g_oeState.rc.bottom, aPoints[iPoint].y);
        }

        OEPolarityAdjust(&g_oeState.rc, 1);
        OEPenWidthAdjust(&g_oeState.rc, 1);

        //
        // The rect is in inclusive coords already, OELRtoVirtual thinks
        // it's exclusive.  So we need to add one back on to the right
        // and bottom to end up with the real inclusive rect.
        //
        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);
        g_oeState.rc.right++;
        g_oeState.rc.bottom++;

        pOrder = NULL;

        if (OECheckOrder(ORD_POLYGON, OECHECK_PEN | OECHECK_BRUSH | OECHECK_CLIPPING) &&
            (cPoints <= ORD_MAX_POLYGON_POINTS))
        {
            pOrder = OA_DDAllocOrderMem(sizeof(POLYGON_ORDER) -
                ((ORD_MAX_POLYGON_POINTS - cPoints) *
                sizeof(pPolygon->variablePoints.aPoints[0])), 0);
            if (!pOrder)
                goto NoPolygonOrder;

            pPolygon = (LPPOLYGON_ORDER)pOrder->abOrderData;
            pPolygon->type = LOWORD(ORD_POLYGON);

            pPolygon->variablePoints.len =
                cPoints * sizeof(pPolygon->variablePoints.aPoints[0]);
            hmemcpy(pPolygon->variablePoints.aPoints, aPoints,
                pPolygon->variablePoints.len);

            //
            // Convert all the points to virtual
            //
            // NOTE that this works because aPoints[] hols TSHR_POINT16s,
            // which are natively the same size as POINT structures.
            //
            OELPtoVirtual(g_oeState.hdc, (LPPOINT)pPolygon->variablePoints.aPoints,
                cPoints);

            OEGetBrushInfo(&pPolygon->BackColor, &pPolygon->ForeColor,
                &pPolygon->BrushStyle, &pPolygon->BrushHatch,
                pPolygon->BrushExtra);

            GetBrushOrgEx(g_oeState.hdc, &ptBrushOrg);
            pPolygon->BrushOrgX = (BYTE)ptBrushOrg.x;
            pPolygon->BrushOrgY = (BYTE)ptBrushOrg.y;

            pPolygon->BackMode = g_oeState.lpdc->DrawMode.bkMode;
            pPolygon->ROP2 = g_oeState.lpdc->DrawMode.Rop2;

            //
            // Pen info
            //
            pPolygon->PenStyle = g_oeState.logPen.lopnStyle;
            pPolygon->PenWidth = 1;
            OEConvertColor(g_oeState.logPen.lopnColor, &pPolygon->PenColor,
                FALSE);
            pPolygon->FillMode = GetPolyFillMode(g_oeState.hdc);

            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILABLE;
            
            OTRACE(("Polygon:  Order %08lx, Rect {%d, %d, %d, %d} with %d points",
                pOrder, g_oeState.rc.left, g_oeState.rc.top,
                g_oeState.rc.right, g_oeState.rc.bottom, cPoints));
            OEClipAndAddOrder(pOrder, NULL);

        }

NoPolygonOrder:
        if (!pOrder)
        {
            OTRACE(("Polygon:  Sending %d points as screen data {%d, %d, %d, %d}",
                cPoints, g_oeState.rc.left, g_oeState.rc.top,
                g_oeState.rc.right, g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPolygon, fOutput);
    return(fOutput);
}



//
// DrvPolyPolygon()
//
BOOL WINAPI DrvPolyPolygon
(
    HDC     hdcDst,
    LPPOINT    aPoints,
    LPINT   aPolygonPoints,
    int     cPolygons
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    int     iPolygon;
    int     iPoint;

    DebugEntry(DrvPolyPolygon);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_POLYPOLYGON, hdcDst, 0);

    fOutput = PolyPolygon(hdcDst, aPoints, aPolygonPoints, cPolygons);

    if (OEAfterDDI(DDI_POLYPOLYGON, fWeCare, fOutput && cPolygons))
    {
        ASSERT(!IsBadReadPtr(aPolygonPoints, cPolygons*sizeof(int)));

#ifdef DEBUG
        //
        // How many points total are there?
        //
        iPoint = 0;
        for (iPolygon = 0; iPolygon < cPolygons; iPolygon++)
        {
            iPoint += aPolygonPoints[iPolygon];
        }

        ASSERT(!IsBadReadPtr(aPoints, iPoint*sizeof(POINT)));
#endif

        //
        // Like LineTo, we need to juggle the coords for polarity.
        //
        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_REGION);

        for (iPolygon = 0; iPolygon < cPolygons; iPolygon++, aPolygonPoints++)
        {
            // 
            // No points for this polygon, nothing to do.
            //
            if (*aPolygonPoints < 2)
            {
                aPoints += *aPolygonPoints;
                continue;
            }

            g_oeState.rc.left = aPoints[0].x;
            g_oeState.rc.top  = aPoints[0].y;
            g_oeState.rc.right = aPoints[0].x;
            g_oeState.rc.bottom = aPoints[0].y;

            aPoints++;

            for (iPoint = 1; iPoint < *aPolygonPoints; iPoint++, aPoints++)
            {
                g_oeState.rc.left = min(g_oeState.rc.left, aPoints[0].x);
                g_oeState.rc.top = min(g_oeState.rc.top, aPoints[0].y);
                g_oeState.rc.right = max(g_oeState.rc.right, aPoints[0].x);
                g_oeState.rc.bottom = max(g_oeState.rc.bottom, aPoints[0].y);
            }

            OEPolarityAdjust(&g_oeState.rc, 1);
            OEPenWidthAdjust(&g_oeState.rc, 1);

            //
            // Our rectangle is already inclusive, and OELRtoVirtual() will
            // treat it like it's exclusive.  So after we return add one back
            // to the right & bottom to end up with the real inclusive
            // rectangle.
            //
            OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);
            g_oeState.rc.right++;
            g_oeState.rc.bottom++;

            OTRACE(("PolyPolygon:  Sending piece %d as screen data {%d, %d, %d, %d}",
                iPolygon, g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
                g_oeState.rc.bottom));
            OEClipAndAddScreenData(&g_oeState.rc);
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPolyPolygon, fOutput);
    return(fOutput);
}



//
// PolyPolyline()
//
BOOL WINAPI DrvPolyPolyline
(
    DWORD   cPtTotal,
    HDC     hdcDst,
    LPPOINT    aPoints,
    LPINT   acPolylinePoints,
    int     cPolylines
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    UINT    cPoints;

    DebugEntry(DrvPolyPolyline);

    OE_SHM_START_WRITING;

    //
    // LAURABU NOTE:
    // This code is better than 2.0.  2.0 would simulate the actual GDI
    // call by repeated Polyline calls.  We accumulate orders the same way
    // that would have happened, but let GDI do the drawing, which is much
    // more metafile friendly, among other things.
    //
    fWeCare = OEBeforeDDI(DDI_POLYPOLYLINE, hdcDst, 0);

    fOutput = g_lpfnPolyPolyline(cPtTotal, hdcDst, aPoints, acPolylinePoints,
        cPolylines);

    if (OEAfterDDI(DDI_POLYPOLYLINE, fWeCare, fOutput && cPolylines))
    {
        ASSERT(!IsBadReadPtr(acPolylinePoints, cPolylines*sizeof(int)));
        ASSERT(!IsBadReadPtr(aPoints, (UINT)cPtTotal*sizeof(POINT)));

        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_REGION);

        while (cPolylines-- > 0)
        {
            cPoints = *(acPolylinePoints++);

            if (cPoints > 1)
            {
                OEAddPolyline(aPoints[0], aPoints+1, cPoints-1);
            }

            aPoints += cPoints;
        }
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvPolyPolyline, fOutput);
    return(fOutput);
}



//
// DrvRectangle()
//
BOOL WINAPI DrvRectangle
(
    HDC     hdcDst,
    int     xLeft,
    int     yTop,
    int     xRight,
    int     yBottom
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    RECT    rcAdjusted;
    LPINT_ORDER pOrder;
    LPRECTANGLE_ORDER   pRectangle;
    POINT   ptBrushOrg;
    LPRECT  pRect;
    int     sideWidth;

    DebugEntry(DrvRectangle);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_RECTANGLE, hdcDst, 0);

    fOutput = Rectangle(hdcDst, xLeft, yTop, xRight, yBottom);

    if (OEAfterDDI(DDI_RECTANGLE, fWeCare, fOutput && (xLeft != xRight) && (yTop != yBottom)))
    {
        OEGetState(OESTATE_COORDS | OESTATE_PEN | OESTATE_BRUSH | OESTATE_REGION);

        g_oeState.rc.left   = xLeft;
        g_oeState.rc.top    = yTop;
        g_oeState.rc.right  = xRight;
        g_oeState.rc.bottom = yBottom;

        CopyRect(&rcAdjusted, &g_oeState.rc);

        if ((g_oeState.logPen.lopnStyle == PS_SOLID)    ||
            (g_oeState.logPen.lopnStyle == PS_INSIDEFRAME))
        {
            OEPenWidthAdjust(&rcAdjusted, 2);
        }

        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);
        OELRtoVirtual(g_oeState.hdc, &rcAdjusted, 1);

        rcAdjusted.right--;
        rcAdjusted.bottom--;

        pOrder = NULL;

        if (OECheckOrder(ORD_RECTANGLE, OECHECK_PEN | OECHECK_BRUSH | OECHECK_CLIPPING))
        {
            pOrder = OA_DDAllocOrderMem(sizeof(RECTANGLE_ORDER), 0);
            if (!pOrder)
                goto NoRectOrder;

            pRectangle = (LPRECTANGLE_ORDER)pOrder->abOrderData;
            pRectangle->type = LOWORD(ORD_RECTANGLE);

            pRectangle->nLeftRect   = g_oeState.rc.left;
            pRectangle->nTopRect    = g_oeState.rc.top;
            pRectangle->nRightRect  = g_oeState.rc.right;
            pRectangle->nBottomRect = g_oeState.rc.bottom;

            OEGetBrushInfo(&pRectangle->BackColor, &pRectangle->ForeColor,
                &pRectangle->BrushStyle, &pRectangle->BrushHatch,
                pRectangle->BrushExtra);

            GetBrushOrgEx(g_oeState.hdc, &ptBrushOrg);
            pRectangle->BrushOrgX   = (BYTE)ptBrushOrg.x;
            pRectangle->BrushOrgY   = (BYTE)ptBrushOrg.y;

            pRectangle->BackMode    = g_oeState.lpdc->DrawMode.bkMode;
            pRectangle->ROP2        = g_oeState.lpdc->DrawMode.Rop2;

            pRectangle->PenStyle    = g_oeState.logPen.lopnStyle;
            pRectangle->PenWidth    = 1;

            OEConvertColor(g_oeState.logPen.lopnColor, &pRectangle->PenColor,
                FALSE);

            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILABLE;
            if ((g_oeState.logBrush.lbStyle == BS_SOLID) ||
                ((pRectangle->BackMode == OPAQUE) &&
                    (g_oeState.logBrush.lbStyle != BS_NULL)))
            {
                pOrder->OrderHeader.Common.fOrderFlags |= OF_SPOILER;
            }

            //
            // Since we only encode orders of width 1, the bounding rect
            // stuff is simple.
            //
            OTRACE(("Rectangle:  Order %08lx, pOrder, Rect {%d, %d, %d, %d}",
                pOrder, g_oeState.rc.left,
                g_oeState.rc.top, g_oeState.rc.right, g_oeState.rc.bottom));
            
            OEClipAndAddOrder(pOrder, NULL);
        }
NoRectOrder:
        if (!pOrder)
        {
            //
            // This is more complicated.  We accumulate screen data for
            // pens of different sizes.
            //

            //
            // If the interior is drawn, then we need to send all the screen
            // area enclosed by the rect.  Otherwise, we can just send the
            // four rectangles describing the border.
            //
            if (g_oeState.logBrush.lbStyle == BS_NULL)
            {
                pRect = NULL;

                //
                // Use the pen width to determine the width of each rect
                // to add as screen data
                //
                switch (g_oeState.logPen.lopnStyle)
                {
                    case PS_NULL:
                        // Nothing to do.
                        break;

                    case PS_SOLID:
                        //
                        // The difference between the adjusted and normal
                        // rects is half the pen width, so double this up
                        // to get the width of each piece to send.
                        //
                        pRect = &rcAdjusted;
                        sideWidth = 2*(g_oeState.rc.left - rcAdjusted.left)
                            - 1;
                        break;

                    case PS_INSIDEFRAME:
                        //
                        // The pen is contained entirely within the corner
                        // pts passed to this function.
                        //
                        pRect = &g_oeState.rc;
                        sideWidth = 2*(g_oeState.rc.left - rcAdjusted.left)
                            - 1;
                        break;

                    default:
                        //
                        // All other pens have width of 1 and are inside the
                        // frame.
                        //
                        pRect = &g_oeState.rc;
                        sideWidth = 0;
                        break;
                }

                if (pRect)
                {
                    RECT    rcT;

                    //
                    // Left
                    //
                    CopyRect(&rcT, pRect);
                    rcT.right = rcT.left + sideWidth;
                    rcT.bottom -= sideWidth + 1;

                    OTRACE(("Rectangle left:  Sending screen data {%d, %d, %d, %d}",
                        rcT.left, rcT.top, rcT.right, rcT.bottom));
                    OEClipAndAddScreenData(&rcT);

                    //
                    // Top
                    //
                    CopyRect(&rcT, pRect);
                    rcT.left += sideWidth + 1;
                    rcT.bottom = rcT.top + sideWidth;

                    OTRACE(("Rectangle top:  Sending screen data {%d, %d, %d, %d}",
                        rcT.left, rcT.top, rcT.right, rcT.bottom));
                    OEClipAndAddScreenData(&rcT);

                    //
                    // Right
                    //
                    CopyRect(&rcT, pRect);
                    rcT.left = rcT.right - sideWidth;
                    rcT.top  += sideWidth + 1;

                    OTRACE(("Rectangle right:  Sending screen data {%d, %d, %d, %d}",
                        rcT.left, rcT.top, rcT.right, rcT.bottom));
                    OEClipAndAddScreenData(&rcT);

                    //
                    // Bottom
                    //
                    CopyRect(&rcT, pRect);
                    rcT.right -= sideWidth + 1;
                    rcT.top = rcT.bottom - sideWidth;

                    OTRACE(("Rectangle bottom:  Sending screen data {%d, %d, %d, %d}",
                        rcT.left, rcT.top, rcT.right, rcT.bottom));
                    OEClipAndAddScreenData(&rcT);
                }
            }
            else
            {
                if (g_oeState.logPen.lopnStyle == PS_SOLID)
                    pRect = &rcAdjusted;
                else
                    pRect = &g_oeState.rc;

                OTRACE(("Rectangle:  Sending as screen data {%d, %d, %d, %d}",
                    pRect->left, pRect->top, pRect->right, pRect->bottom));
                OEClipAndAddScreenData(pRect);
            }
        }

    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvRectangle, fOutput);
    return(fOutput);
}



//
// DrvSetDIBitsToDevice()
//
int WINAPI DrvSetDIBitsToDevice
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    int     cxDst,
    int     cyDst,
    int     xSrc,
    int     ySrc,
    UINT    uStartScan,
    UINT    cScanLines,
    LPVOID  lpvBits,
    LPBITMAPINFO    lpbmi,
    UINT    fuColorUse
)
{
    BOOL    fWeCare;
    BOOL    fOutput;

    DebugEntry(DrvSetDIBitsToDevice);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_SETDIBITSTODEVICE, hdcDst, 0);

    fOutput = SetDIBitsToDevice(hdcDst, xDst, yDst, cxDst, cyDst,
        xSrc, ySrc, uStartScan, cScanLines, lpvBits, lpbmi, fuColorUse);

    if (OEAfterDDI(DDI_SETDIBITSTODEVICE, fWeCare, fOutput))
    {
        OEGetState(OESTATE_COORDS | OESTATE_REGION);

        g_oeState.rc.left   = xDst;
        g_oeState.rc.top    = yDst;
        OELPtoVirtual(g_oeState.hdc, (LPPOINT)&g_oeState.rc.left, 1);
        g_oeState.rc.right  = g_oeState.rc.left + cxDst;
        g_oeState.rc.bottom = g_oeState.rc.top  + cyDst;

        OTRACE(("SetDIBitsToDevice:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }

    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvSetDIBitsToDevice, fOutput);
    return(fOutput);
}



//
// DrvSetPixel()
//
COLORREF WINAPI DrvSetPixel
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    COLORREF crPixel
)
{
    BOOL    fWeCare;
    COLORREF    rgbOld;

    DebugEntry(DrvSetPixel);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_SETPIXEL, hdcDst, 0);

    rgbOld = SetPixel(hdcDst, xDst, yDst, crPixel);
    
    if (OEAfterDDI(DDI_SETPIXEL, fWeCare, (rgbOld != (COLORREF)-1)))
    {
        OEGetState(OESTATE_COORDS | OESTATE_REGION);

        g_oeState.rc.left   = xDst;
        g_oeState.rc.top    = yDst;
        g_oeState.rc.right  = xDst;
        g_oeState.rc.bottom = yDst;
        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        g_oeState.rc.right++;
        g_oeState.rc.bottom++;

        OTRACE(("SetPixel:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }

    OE_SHM_STOP_WRITING;

    DebugExitDWORD(DrvSetPxel, rgbOld);
    return(rgbOld);
}



//
// DrvStretchDIBits()
//
int WINAPI DrvStretchDIBits
(
    HDC     hdcDst,
    int     xDst,
    int     yDst,
    int     cxDst,
    int     cyDst,
    int     xSrc,
    int     ySrc,
    int     cxSrc,
    int     cySrc,
    LPVOID  lpvBits,
    LPBITMAPINFO lpbmi,
    UINT    fuColorUse,
    DWORD   dwRop
)
{
    BOOL    fWeCare;
    BOOL    fOutput;
    BYTE    bRop;

    DebugEntry(DrvStretchDIBits);

    OE_SHM_START_WRITING;

    fWeCare = OEBeforeDDI(DDI_STRETCHDIBITS, hdcDst, 0);

    fOutput = StretchDIBits(hdcDst, xDst, yDst, cxDst, cyDst,
        xSrc, ySrc, cxSrc, cySrc, lpvBits, lpbmi, fuColorUse, dwRop);

    if (OEAfterDDI(DDI_STRETCHDIBITS, fWeCare, fOutput && cxDst && cyDst))
    {
        OEGetState(OESTATE_COORDS | OESTATE_BRUSH | OESTATE_REGION);

        g_oeState.rc.left   = xDst;
        g_oeState.rc.top    = yDst;
        g_oeState.rc.right  = xDst + cxDst;
        g_oeState.rc.bottom = yDst + cyDst;

        OELRtoVirtual(g_oeState.hdc, &g_oeState.rc, 1);

        //
        // If this is a PatBlt really, do that instead.
        //
        bRop = LOBYTE(HIWORD(dwRop));
        if (((bRop & 0x33) << 2) == (bRop & 0xCC))
        {
            OEAddBlt(dwRop);
            DC_QUIT;
        }

        //
        // Do tile bitblt order stuff...
        //

        OTRACE(("StretchDIBits:  Sending as screen data {%d, %d, %d, %d}",
            g_oeState.rc.left, g_oeState.rc.top, g_oeState.rc.right,
            g_oeState.rc.bottom));
        OEClipAndAddScreenData(&g_oeState.rc);
    }

DC_EXIT_POINT:
    OE_SHM_STOP_WRITING;

    DebugExitBOOL(DrvStretchDIBits, fOutput);
    return(fOutput);
}



//
// DrvUpdateColors()
//
int WINAPI DrvUpdateColors
(
    HDC hdcDst
)
{
    BOOL    fWeCare;
    int     ret;

    DebugEntry(DrvUpdateColors);

    OE_SHM_START_WRITING;

    //
    // This doesn't reset the drawing bounds.  So we just assume the whole
    // DC changed.  And the return value is meaningless.  We can't assume
    // that zero means failure.
    //
    fWeCare = OEBeforeDDI(DDI_UPDATECOLORS, hdcDst, OESTATE_SDA_SCREEN);

    ret = UpdateColors(hdcDst);

    OEAfterDDI(DDI_UPDATECOLORS, fWeCare, TRUE);

    OE_SHM_STOP_WRITING;

    DebugExitDWORD(DrvUpdateColors, (DWORD)(UINT)ret);
    return(ret);
}



//
// SETTINGS/MODE FUNCTIONS
// For full screen dos boxes, resolution/color depth changes
//


//
// DrvGDIRealizePalette()
//
// The WM_PALETTE* messages in Win95 are unreliable.  So, like NM 2.0, we
// patch two GDI APIs instead and update a shared variable
//
DWORD WINAPI DrvGDIRealizePalette(HDC hdc)
{
    DWORD   dwRet;

    DebugEntry(DrvGDIRealizePalette);

    EnableFnPatch(&g_oeDDPatches[DDI_GDIREALIZEPALETTE], PATCH_DISABLE);
    dwRet = GDIRealizePalette(hdc);
    EnableFnPatch(&g_oeDDPatches[DDI_GDIREALIZEPALETTE], PATCH_ENABLE);

    ASSERT(g_asSharedMemory);
    g_asSharedMemory->pmPaletteChanged = TRUE;

    DebugExitDWORD(DrvGDIRealizePalette, dwRet);
    return(dwRet);
}



//
// DrvRealizeDefaultPalette()
//
// The WM_PALETTE* messages in Win95 are unreliable.  So, like NM 2.0, we
// patch two GDI APIs instead and update a shared variable
//
void WINAPI DrvRealizeDefaultPalette(HDC hdc)
{
    DebugEntry(DrvRealizeDefaultPalette);

    EnableFnPatch(&g_oeDDPatches[DDI_REALIZEDEFAULTPALETTE], PATCH_DISABLE);
    RealizeDefaultPalette(hdc);
    EnableFnPatch(&g_oeDDPatches[DDI_REALIZEDEFAULTPALETTE], PATCH_ENABLE);

    ASSERT(g_asSharedMemory);
    g_asSharedMemory->pmPaletteChanged = TRUE;

    DebugExitVOID(DrvRealizeDefaultPalette);
}


//
// This is called when a blue screen fault is coming up, or an app calls
// Disable() in USER.
//
UINT WINAPI DrvDeath
(
    HDC     hdc
)
{
    UINT    uResult;

    g_asSharedMemory->fullScreen = TRUE;

    EnableFnPatch(&g_oeDDPatches[DDI_DEATH], PATCH_DISABLE);
    uResult = Death(hdc);
    EnableFnPatch(&g_oeDDPatches[DDI_DEATH], PATCH_ENABLE);

    return(uResult);
}


//
// This is called when a blue screen fault is going away, or an app calls
// Enable() in USER.
//
UINT WINAPI DrvResurrection
(
    HDC     hdc,
    DWORD   dwParam1,
    DWORD   dwParam2,
    DWORD   dwParam3
)
{
    UINT    uResult;

    g_asSharedMemory->fullScreen = FALSE;

    EnableFnPatch(&g_oeDDPatches[DDI_RESURRECTION], PATCH_DISABLE);
    uResult = Resurrection(hdc, dwParam1, dwParam2, dwParam3);
    EnableFnPatch(&g_oeDDPatches[DDI_RESURRECTION], PATCH_ENABLE);

    return(uResult);
}


//
// This is called by a dosbox when going to or coming out of full screen
// mode.  DirectX calls it also.
//
LONG WINAPI DrvWinOldAppHackoMatic
(
    LONG    lFlags
)
{
    LONG    lResult;

    if (lFlags == WOAHACK_LOSINGDISPLAYFOCUS)
    {
        //
        // DOS box is going to full screen from windowed
        //
        g_asSharedMemory->fullScreen = TRUE;
    }
    else if (lFlags == WOAHACK_GAININGDISPLAYFOCUS)
    {
        //
        // DOS box is going from windowed to full screen
        //
        g_asSharedMemory->fullScreen = FALSE;
    }

    EnableFnPatch(&g_oeDDPatches[DDI_WINOLDAPPHACKOMATIC], PATCH_DISABLE);
    lResult = WinOldAppHackoMatic(lFlags);
    EnableFnPatch(&g_oeDDPatches[DDI_WINOLDAPPHACKOMATIC], PATCH_ENABLE);

    return(lResult);
}


//
// ChangeDisplaySettings()          WIN95
// ChangeDisplaySettingsEx()        MEMPHIS
//
// This is called in 3 circumstances:
//      * By the control to change your screen
//      * By the shell when warm-docking
//      * By 3rd party games to change the settings silently.
//
// Easiest thing to do is just to fail this completely.
//

LONG WINAPI DrvChangeDisplaySettings
(
    LPDEVMODE   lpDevMode,
    DWORD       flags
)
{
    return(DISP_CHANGE_FAILED);
}


LONG WINAPI DrvChangeDisplaySettingsEx
(
    LPCSTR      lpszDeviceName,
    LPDEVMODE   lpDevMode,
    HWND        hwnd,
    DWORD       flags,
    LPVOID      lParam
)
{
    return(DISP_CHANGE_FAILED);
}


//
// OBJECT FUNCTIONS
// For bitmaps (SPBs and cache) and brushes
//


//
// DrvCreateSpb()
//
// This watches for SPB bitmaps being created.
//
UINT WINAPI DrvCreateSpb
(
    HDC     hdcCompat,
    int     cxWidth,
    int     cyHeight
)
{
    HBITMAP hbmpRet;

    DebugEntry(DrvCreateSpb);

    EnableFnPatch(&g_oeDDPatches[DDI_CREATESPB], PATCH_DISABLE);
    hbmpRet = (HBITMAP)CreateSpb(hdcCompat, cxWidth, cyHeight);
    EnableFnPatch(&g_oeDDPatches[DDI_CREATESPB], PATCH_ENABLE);

    if (hbmpRet)
    {
        // 
        // Save in our "next SPB" bitmap list
        //
        g_ssiLastSpbBitmap = hbmpRet;
    }

    DebugExitDWORD(DrvCreateSpb, (DWORD)(UINT)hbmpRet);
    return((UINT)hbmpRet);
}



//
// DrvDeleteObject()
//
// This and DrvSysDeleteObject() watch for bitmaps being destroyed.
//
BOOL WINAPI DrvDeleteObject
(
    HGDIOBJ hobj
)
{
    BOOL    fReturn;
    int     gdiType;

    DebugEntry(DrvDeleteObject);

    gdiType = IsGDIObject(hobj);
    if (gdiType == GDIOBJ_BITMAP)
    {
        OE_SHM_START_WRITING;

        //
        // If SPB, toss it.  Else if cached bitmap, kill cache entry.
        //
        if ((HBITMAP)hobj == g_ssiLastSpbBitmap)
        {
            g_ssiLastSpbBitmap = NULL;
        }
        else if (!SSIDiscardBits((HBITMAP)hobj))
        {
        }

        OE_SHM_STOP_WRITING;
    }

    EnableFnPatch(&g_oeDDPatches[DDI_DELETEOBJECT], PATCH_DISABLE);
    fReturn = DeleteObject(hobj);
    EnableFnPatch(&g_oeDDPatches[DDI_DELETEOBJECT], PATCH_ENABLE);

    DebugExitBOOL(DrvDeleteObject, fReturn);
    return(fReturn);
}




//
// OE_RectIntersectsSDA()
// 
// Used by SSI and BLT orders
//
BOOL  OE_RectIntersectsSDA(LPRECT pRect)
{
    RECT  rectVD;
    BOOL  fIntersection = FALSE;
    UINT  i;

    DebugEntry(OE_RectIntersectsSDA);

    //
    // Copy the supplied rectangle, converting to inclusive Virtual
    // Desktop coords.
    //
    rectVD.left   = pRect->left;
    rectVD.top    = pRect->top;
    rectVD.right  = pRect->right - 1;
    rectVD.bottom = pRect->bottom - 1;

    //
    // Loop through each of the bounding rectangles checking for
    // an intersection with the supplied rectangle.
    //
    for (i = 0; i <= BA_NUM_RECTS; i++)
    {
        if ( (g_baBounds[i].InUse) &&
             (g_baBounds[i].Coord.left <= rectVD.right) &&
             (g_baBounds[i].Coord.top <= rectVD.bottom) &&
             (g_baBounds[i].Coord.right >= rectVD.left) &&
             (g_baBounds[i].Coord.bottom >= rectVD.top) )
        {
            OTRACE(("Rect {%d, %d, %d, %d} intersects SDA {%d, %d, %d, %d}",
                rectVD.left, rectVD.top, rectVD.right, rectVD.bottom,
                g_baBounds[i].Coord.left, g_baBounds[i].Coord.top,
                g_baBounds[i].Coord.right, g_baBounds[i].Coord.bottom));
            fIntersection = TRUE;
            break;
        }
    }

    DebugExitBOOL(OE_RectIntersectsSDA, fIntersection);
    return(fIntersection);
}



//
// MyStrcmp()
// Real strcmp() algorithm.
//
int MyStrcmp(LPCSTR lp1, LPCSTR lp2)
{
    ASSERT(lp1);
    ASSERT(lp2);

    while (*lp1 == *lp2)
    {
        //
        // The two strings are identical
        //
        if (!*lp1)
            return(0);

        lp1++;
        lp2++;
    }

    //
    // String1 is numerically > String2, or < 
    //
    return((*lp1 > *lp2) ? 1 : -1);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\as16\ssi.c ===
//
// SSI.C
// Save Screenbits Interceptor
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>


//
// GENERAL COMMENTS
//
// We patch the display driver's onboard bitmap DDI call if it exists.  This
// doesn't exist on newer displays, but we need to fail it on older ones.
// We won't see drawing that happens via calls to it otherwise.
//
// NM 2.0 used to grovel in USER's dataseg to find the variable address of
// the onboard bitmap routine and fill in its own, whether there was one or
// not.  Then it used to return TRUE always for saves.  Since USER '95 checked
// for a non-zero address to decide if onboard capabilities were present,
// this sort of worked.  Except of course that NM 2.0 needed special case
// code for all the flavors of Win95.
//
// With multiple monitor support, there is no single savebits proc address
// anymore.  Plus, we're tired of having to alter our code with every
// change in the OS.  Our new scheme works based off blts to/from a memory
// bitmap owned by USER.  Since we already spy on bitmaps for the SBC
// it doesn't really add overhead to do it this way.
//
// When USER is saving bits
//      (1) It creates the SPB bitmap via CreateSpb() (GDI calls it
//          CreateUserDiscardableBitmap()),
//          the only time it calls this routine.  If the bits get discarded,
//          the BitBlt back from this bitmap will fail, in which case USER
//          will repaint the affected area.
//      (2) It does a BitBlt from the screen into this bitmap, after making
//          it owned by g_hModUser16.  This bitmap is byte-pixel-aligned
//          horizontally, so it may be a bit wider than the window about to
//          be shown there.
//      (3) This happens just before a CS_SAVEBITS window is shown in that
//          area.  The window gets a private WS_HASSPB style bit set on it.
//      (4) After creating the SPB bitmap, USER walks through the windows
//          behind where the window is going to be in the z-order and subtracts
//          pending updage regions from the "OK" region of the SPB.  This
//          may result in discarding the SPB right away.
//          
// When USER is discarding saved bits
//      (1) It deletes the bitmap it created when saving
//
// When USER is restoring saved bits
//      (1) It may decide to discard if there's not much saved by restoring
//      (2) It will temporarily select in a visrgn for the screen that is 
//          only the valid part of the SPB
//      (3) It will blt from a memory DC with the SPB bitmap selected in
//          to the screen, again byte-aligned pixelwise horizontally.
//      (4) It will return a region to be invalidated and repainted via
//          normal methods (the complement of the valid blt visrgn)
//
// We have to be able to support nested savebits.  We do this via a 
// stack-like bitmap cache.  New save requests get put at the front.
//  



//
// SSI_DDProcessRequest()
// Handles SSI escapes
//
BOOL    SSI_DDProcessRequest
(
    UINT                fnEscape,
    LPOSI_ESCAPE_HEADER pRequest,
    DWORD               cbRequest
)
{
    BOOL                rc;

    DebugEntry(SSI_DDProcessRequest);

    switch (fnEscape)
    {
        case SSI_ESC_RESET_LEVEL:
        {
            ASSERT(cbRequest == sizeof(OSI_ESCAPE_HEADER));

            SSIResetSaveScreenBitmap();
            rc = TRUE;
        }
        break;

        case SSI_ESC_NEW_CAPABILITIES:
        {
            ASSERT(cbRequest == sizeof(SSI_NEW_CAPABILITIES));

            SSISetNewCapabilities((LPSSI_NEW_CAPABILITIES)pRequest);
            rc = TRUE;
        }
        break;

        default:
        {
            ERROR_OUT(("Unrecognized SSI_ escape"));
            rc = FALSE;
        }
        break;
    }

    DebugExitBOOL(SSI_DDProcessRequest, rc);
    return(rc);
}


//
// SSI_DDInit()
//
BOOL SSI_DDInit(void)
{
    BOOL    rc = TRUE;

    DebugEntry(SSI_DDInit);

    //
    // Patch the display driver's onboard SaveBits routine, if there is one
    //
    if (SELECTOROF(g_lpfnSaveBits))
    {
        if (!CreateFnPatch(g_lpfnSaveBits, DrvSaveBits, &g_ssiSaveBitsPatch, 0))
        {
            ERROR_OUT(("Unable to patch savebits routine"));
            rc = FALSE;
        }
    }

    DebugExitBOOL(SSI_DDInit, rc);
    return(rc);
}



//
// SSI_DDTerm()
//
void SSI_DDTerm(void)
{
    DebugEntry(SSI_DDTerm);

    if (SELECTOROF(g_lpfnSaveBits))
    {
        DestroyFnPatch(&g_ssiSaveBitsPatch);
    }

    DebugExitVOID(SSI_DDTerm);
}



//
// SSI_DDViewing()
//
void SSI_DDViewing(BOOL fViewers)
{
    DebugEntry(SSI_DDViewing);

    //
    // Activate our SaveBits patch if we have one
    //
    if (SELECTOROF(g_lpfnSaveBits))
    {
        EnableFnPatch(&g_ssiSaveBitsPatch, (fViewers ? PATCH_ACTIVATE :
            PATCH_DEACTIVATE));
    }

    //
    // Reset our SSI stack
    //
    SSIResetSaveScreenBitmap();

    DebugExitVOID(SSI_DDViewing);
}



//
// DrvSaveBits()
//
// Since we have to have code to spy on USER spb bitmaps, it doesn't make
// sense to have twice the code.  So we simply return FALSE here.  This 
// also avoids the "enable the patch after a bitmap was saved via a call
// to the driver so on the restore we're confused" problem.  The worst that
// will happen now is that USER will blt from a bitmap we've never seen
// to the screen, we'll catch the drawing, and send it over the wire as
// screen update (not cached!).  The next full save/restore will use an
// order instead.
//
BOOL WINAPI DrvSaveBits
(
    LPRECT  lpRect,
    UINT    uCmd
)
{
    return(FALSE);
}


//
// NOTE:
// ssiSBSaveLevel is the index of the NEXT FREE SPB SLOT
//


//
// FUNCTION: SSIResetSaveScreenBitmap.
//
// DESCRIPTION:
//
// Resets the SaveScreenBitmap state.
//
// PARAMETERS: None.
//
// RETURNS: Nothing.
//
//
void SSIResetSaveScreenBitmap(void)
{
    DebugEntry(SSIResetSaveScreenBitmap);

    //
    // Discard all currently saved bits
    //
    g_ssiLocalSSBState.saveLevel = 0;

    //
    // Reset the # of pels saved
    //
    g_ssiRemoteSSBState.pelsSaved = 0;

    DebugExitVOID(SSIResetSaveScreenBitmap);
}



//
// FUNCTION: SSISendSaveBitmapOrder
//
// DESCRIPTION:
//
// Attempts to send a SaveBitmap order matching the supplied parameters.
//
//
// PARAMETERS:
//
// lpRect - pointer to the rectangle coords (EXCLUSIVE screen coords)
//
// wCommand - SaveScreenBitmap command (ONBOARD_SAVE, ONBOARD_RESTORE,
// SSB_DISCARDBITS)
//
//
// RETURNS:
//
// TRUE if order successfully sent FALSE if order not sent
//
//
BOOL SSISendSaveBitmapOrder
(
    LPRECT  lpRect,
    UINT    wCommand
)
{
    DWORD               cRemotePelsRequired;
    LPSAVEBITMAP_ORDER  pSaveBitmapOrder;
    LPINT_ORDER         pOrder;
    BOOL                rc = FALSE;

    DebugEntry(SSISendSaveBitmapOrder);

    //
    // If the SaveBitmap order is not supported then return FALSE
    // immediately.
    //
    if (!OE_SendAsOrder(ORD_SAVEBITMAP))
    {
        TRACE_OUT(( "SaveBmp not supported"));
        DC_QUIT;
    }

    switch (wCommand)
    {
        case ONBOARD_DISCARD:
            //
            // We don't transmit DISCARD orders, there's no need since
            // saves/restores are paired.
            //
            g_ssiRemoteSSBState.pelsSaved -=
                CURRENT_LOCAL_SSB_STATE.remotePelsRequired;
            rc = TRUE;
            DC_QUIT;

        case ONBOARD_SAVE:
            //
            // Calculate the number of pels required in the remote Save
            // Bitmap to handle this rectangle.
            //
            cRemotePelsRequired = SSIRemotePelsRequired(lpRect);

            //
            // If there aren't enough pels in the remote Save Bitmap to
            // handle this rectangle then return immediately.
            //
            if ((g_ssiRemoteSSBState.pelsSaved + cRemotePelsRequired) >
                                                            g_ssiSaveBitmapSize)
            {
                TRACE_OUT(( "no space for %lu pels", cRemotePelsRequired));
                DC_QUIT;
            }

            //
            // Allocate memory for the order.
            //
            pOrder = OA_DDAllocOrderMem(sizeof(SAVEBITMAP_ORDER), 0);
            if (!pOrder)
                DC_QUIT;

            //
            // Store the drawing order data.
            //
            pSaveBitmapOrder = (LPSAVEBITMAP_ORDER)pOrder->abOrderData;

            pSaveBitmapOrder->type = LOWORD(ORD_SAVEBITMAP);
            pSaveBitmapOrder->Operation = SV_SAVEBITS;

            //
            // SAVEBITS is a BLOCKER order i.e. it prevents any earlier
            // orders from being spoilt by subsequent orders or Screen
            // Data.
            //
            pOrder->OrderHeader.Common.fOrderFlags = OF_BLOCKER;

            //
            // Copy the rect, converting to inclusive Virtual Desktop
            // coords.
            //
            pSaveBitmapOrder->nLeftRect = lpRect->left;
            pSaveBitmapOrder->nTopRect  = lpRect->top;
            pSaveBitmapOrder->nRightRect = lpRect->right - 1;
            pSaveBitmapOrder->nBottomRect = lpRect->bottom - 1;

            pSaveBitmapOrder->SavedBitmapPosition = g_ssiRemoteSSBState.pelsSaved;

            //
            // Store the relevant details in the current entry of the
            // local SSB structure.
            //
            CURRENT_LOCAL_SSB_STATE.remoteSavedPosition =
                                        pSaveBitmapOrder->SavedBitmapPosition;

            CURRENT_LOCAL_SSB_STATE.remotePelsRequired = cRemotePelsRequired;

            //
            // Update the count of remote pels saved.
            //
            g_ssiRemoteSSBState.pelsSaved += cRemotePelsRequired;

            //
            // The operation rectangle is NULL.
            //
            pOrder->OrderHeader.Common.rcsDst.left   = 1;
            pOrder->OrderHeader.Common.rcsDst.right  = 0;
            pOrder->OrderHeader.Common.rcsDst.top    = 1;
            pOrder->OrderHeader.Common.rcsDst.bottom = 0;

            break;

        case ONBOARD_RESTORE:
            //
            // Update the remote pel count first. Even if we fail to send
            // the order we want to free up the remote pels.
            //
            g_ssiRemoteSSBState.pelsSaved -=
                                   CURRENT_LOCAL_SSB_STATE.remotePelsRequired;

            //
            // Allocate memory for the order.
            //
            pOrder = OA_DDAllocOrderMem(sizeof(SAVEBITMAP_ORDER), 0);
            if (!pOrder)
                DC_QUIT;

            //
            // Store the drawing order data.
            //
            pSaveBitmapOrder = (LPSAVEBITMAP_ORDER)pOrder->abOrderData;

            pSaveBitmapOrder->type = LOWORD(ORD_SAVEBITMAP);
            pSaveBitmapOrder->Operation = SV_RESTOREBITS;

            //
            // The order can spoil others (it is opaque).
            // It is not SPOILABLE because we want to keep the remote
            // save level in a consistent state.
            //
            pOrder->OrderHeader.Common.fOrderFlags = OF_SPOILER;

            //
            // Copy the rect, converting to inclusive Virtual Desktop
            // coords.
            //
            pSaveBitmapOrder->nLeftRect = lpRect->left;
            pSaveBitmapOrder->nTopRect  = lpRect->top;
            pSaveBitmapOrder->nRightRect = lpRect->right - 1;
            pSaveBitmapOrder->nBottomRect = lpRect->bottom - 1;

            pSaveBitmapOrder->SavedBitmapPosition =
                          CURRENT_LOCAL_SSB_STATE.remoteSavedPosition;


            //
            // The operation rectangle is also the bounding rectangle of
            // the order.
            //
            pOrder->OrderHeader.Common.rcsDst.left =
                                       pSaveBitmapOrder->nLeftRect;
            pOrder->OrderHeader.Common.rcsDst.right =
                                       pSaveBitmapOrder->nRightRect;
            pOrder->OrderHeader.Common.rcsDst.top =
                                       pSaveBitmapOrder->nTopRect;
            pOrder->OrderHeader.Common.rcsDst.bottom =
                                       pSaveBitmapOrder->nBottomRect;
            break;

        default:
            ERROR_OUT(( "Unexpected wCommand(%d)", wCommand));
            break;
    }

    OTRACE(( "SaveBitmap op %d pos %ld rect {%d %d %d %d}",
        pSaveBitmapOrder->Operation, pSaveBitmapOrder->SavedBitmapPosition,
        pSaveBitmapOrder->nLeftRect, pSaveBitmapOrder->nTopRect,
        pSaveBitmapOrder->nRightRect, pSaveBitmapOrder->nBottomRect ));

    //
    // Add the order to the order list.
    // IT IS NEVER CLIPPED.
    //
    OA_DDAddOrder(pOrder, NULL);
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(SSISendSaveBitmapOrder, rc);
    return(rc);
}



//
// SSISaveBits()
//
// This attemps to save the SPB into our stack.  If we have no more room,
// no big deal.  We won't find it on a bitblt back to the screen, and that
// info will go as screen data.
//
// The rectangle is EXCLUSIVE screen coords.
//
void SSISaveBits
(
    HBITMAP hbmpSpb,
    LPRECT  lpRect
)
{
    DebugEntry(SSISaveBits);

    //
    // We should never have unbalanced save/restore operations
    //
    ASSERT(g_ssiLocalSSBState.saveLevel >= 0);

    //
    // Are we out of space?
    //
    if (g_ssiLocalSSBState.saveLevel >= SSB_MAX_SAVE_LEVEL)
    {
        TRACE_OUT(("SaveLevel(%d) exceeds maximum", g_ssiLocalSSBState.saveLevel));
        DC_QUIT;
    }

    //
    // If the rectangle to be saved intersects the current SDA, then we will
    // have to force a repaint on the restore.  This is because orders are
    // always sent before Screen Data.
    //
    // Otherwise mark the bits as saved.
    //
    if (OE_RectIntersectsSDA(lpRect))
    {
        CURRENT_LOCAL_SSB_STATE.saveType = ST_FAILED_TO_SAVE;
    }
    else
    {
        CURRENT_LOCAL_SSB_STATE.saveType = ST_SAVED_BY_BMP_SIMULATION;
    }

    //
    // Store the bitmap and associated screen rectangle
    //
    CURRENT_LOCAL_SSB_STATE.hbmpSave = hbmpSpb;
    CopyRect(&CURRENT_LOCAL_SSB_STATE.rect, lpRect);

    //
    // If successfully saved, try to accumulate a SaveBits order
    //
    if (CURRENT_LOCAL_SSB_STATE.saveType != ST_FAILED_TO_SAVE)
    {
        CURRENT_LOCAL_SSB_STATE.fSavedRemotely =
            SSISendSaveBitmapOrder(lpRect, ONBOARD_SAVE);
    }
    else
    {
        //
        // We didn't manage to save it.  No point in trying to save the
        // bitmap remotely.
        //
        TRACE_OUT(( "Keep track of failed save for restore later"));
        CURRENT_LOCAL_SSB_STATE.fSavedRemotely = FALSE;
    }

    //
    // Update the save level
    // NOTE this now points to the NEXT free slot
    //
    g_ssiLocalSSBState.saveLevel++;

DC_EXIT_POINT:
    DebugExitVOID(SSISaveBits);
}



//
// SSIFindSlotAndDiscardAbove()
//
// This starts at the topmost valid entry on the SPB stack and works
// backwards.  NOTE that saveLevel is the NEXT valid entry.
//
BOOL SSIFindSlotAndDiscardAbove(HBITMAP hbmpSpb)
{
    int   i;
    int   iNewSaveLevel;
    BOOL  rc = FALSE;

    DebugEntry(SSIFindSlotAndDiscardAbove);

    //
    // Look for this SPB.  If we find it, then discard the entries after
    // it in our stack.
    //
    iNewSaveLevel = g_ssiLocalSSBState.saveLevel;

    for (i = 0; i < g_ssiLocalSSBState.saveLevel; i++)
    {
        if (rc)
        {
            //
            // We found this SPB, so we are discarding all entries after
            // it in the stack.  Subtract the saved pixels count for this
            // dude.
            //
            g_ssiRemoteSSBState.pelsSaved -=
                g_ssiLocalSSBState.saveState[i].remotePelsRequired;
        }
        else if (g_ssiLocalSSBState.saveState[i].hbmpSave == hbmpSpb)
        {
            //
            // Found the one we were looking for
            //
            OTRACE(( "Found SPB %04x at slot %d", hbmpSpb, i));

            iNewSaveLevel = i;
            rc = TRUE;
        }
    }

    g_ssiLocalSSBState.saveLevel = iNewSaveLevel;

    DebugExitBOOL(SSIFindSlotAndDiscardAbove, rc);
    return(rc);
}



//
// SSIRestoreBits()
//
// Called when a BitBlt happens to screen from memory.  We try to find the
// memory bitmap in our SPB stack.  If we can't, we return FALSE, and the OE
// code will save away a screen painting order.
//
// If we find it, we save a small SPB restore order instead.
//
BOOL SSIRestoreBits
(
    HBITMAP hbmpSpb
)
{
    BOOL    rc = FALSE;

    DebugEntry(SSIRestoreBits);

    ASSERT(g_ssiLocalSSBState.saveLevel >= 0);

    //
    // Can we find the SPB?
    //
    if (SSIFindSlotAndDiscardAbove(hbmpSpb))
    {
        //
        // saveLevel is the index of our SPB.
        //
        if (CURRENT_LOCAL_SSB_STATE.fSavedRemotely)
        {
            //
            // The bits were saved remotely, so send and order.
            //
            rc = SSISendSaveBitmapOrder(&CURRENT_LOCAL_SSB_STATE.rect,
                ONBOARD_RESTORE);
        }
        else
        {
            //
            // We failed to save the bitmap remotely originally, so now
            // we need to return FALSE so that BitBlt() will accumulate
            // screen data in the area.
            //
            TRACE_OUT(( "No remote save, force repaint"));
        }

        if (g_ssiLocalSSBState.saveLevel == 0)
        {
            g_ssiRemoteSSBState.pelsSaved = 0;
        }
    }

    DebugExitBOOL(SSIRestoreBits, rc);
    return(rc);
}



//
// SSIDiscardBits()
//
// This discards the saved SPB if we have it in our stack.
// NOTE that SSIRestoreBits() also discards the bitmap.
//
// We return TRUE if we found the bitmap.
//
BOOL SSIDiscardBits(HBITMAP hbmpSpb)
{
    BOOL    rc;

    DebugEntry(SSIDiscardBits);

    //
    // Search for the corresponding save order on our stack.
    //
    if (rc = SSIFindSlotAndDiscardAbove(hbmpSpb))
    {
        //
        // The save level is now the index to this entry.  Since we are
        // about to free it, this will be the place the next SAVE goes 
        // into.
        //

        //
        // If the bits were saved remotely, then send a DISCARD order
        //
        if (CURRENT_LOCAL_SSB_STATE.fSavedRemotely)
        {
            //
            // NOTE that SSISendSaveBitmapOrder() for DISCARD doesn't have
            // a side effect, we can just pass in the address of the rect
            // of the SPB we stored.
            //
            if (!SSISendSaveBitmapOrder(&CURRENT_LOCAL_SSB_STATE.rect, ONBOARD_DISCARD))
            {
                TRACE_OUT(("Failed to send DISCARDBITS"));
            }
        }

        if (g_ssiLocalSSBState.saveLevel == 0)
        {
            g_ssiRemoteSSBState.pelsSaved = 0;
        }
    }

    DebugExitBOOL(SSIDiscardBits, rc);
    return(rc);
}



//
// FUNCTION: SSIRemotePelsRequired
//
// DESCRIPTION:
//
// Returns the number of remote pels required to store the supplied
// rectangle, taking account of the Save Bitmap granularity.
//
// PARAMETERS:
//
// lpRect - pointer to rectangle position in EXCLUSIVE screen coordinates.
//
// RETURNS: Number of remote pels required.
//
//
DWORD SSIRemotePelsRequired(LPRECT lpRect)
{
    UINT    rectWidth;
    UINT    rectHeight;
    UINT    xGranularity;
    UINT    yGranularity;
    DWORD   rc;

    DebugEntry(SSIRemotePelsRequired);

    ASSERT(lpRect);

    //
    // Calculate the supplied rectangle size (it is in EXCLUSIVE coords).
    //
    rectWidth  = (DWORD)(lpRect->right  - lpRect->left);
    rectHeight = (DWORD)(lpRect->bottom - lpRect->top);

    xGranularity = g_ssiLocalSSBState.xGranularity;
    yGranularity = g_ssiLocalSSBState.yGranularity;

    rc = (DWORD)((rectWidth + (xGranularity-1))/xGranularity * xGranularity) *
         (DWORD)((rectHeight + (yGranularity-1))/yGranularity * yGranularity);

    //
    // Return the pels required in the remote SaveBits bitmap to handle
    // this rectangle, taking account of its granularity.
    //
    DebugExitDWORD(SSIRemotePelsRequired, rc);
    return(rc);
}



//
// FUNCTION:    SSISetNewCapabilities
//
// DESCRIPTION:
//
// Set the new SSI related capabilities
//
// RETURNS:
//
// NONE
//
// PARAMETERS:
//
// pDataIn  - pointer to the input buffer
//
//
void SSISetNewCapabilities(LPSSI_NEW_CAPABILITIES pCapabilities)
{
    DebugEntry(SSISetNewCapabilities);

    //
    // Copy the data from the Share Core.
    //
    g_ssiSaveBitmapSize             = pCapabilities->sendSaveBitmapSize;

    g_ssiLocalSSBState.xGranularity = pCapabilities->xGranularity;

    g_ssiLocalSSBState.yGranularity = pCapabilities->yGranularity;

    TRACE_OUT(( "SSI caps: Size %ld X gran %hd Y gran %hd",
                 g_ssiSaveBitmapSize,
                 g_ssiLocalSSBState.xGranularity,
                 g_ssiLocalSSBState.yGranularity));

    DebugExitVOID(SSISetNewCapabilities);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\as16\trc.c ===
//
// TRC.C
// Debug tracing utilities
//
// Copyright(c) Microsoft 1997-
//

#include <as16.h>



#ifdef _DEBUG

// Set g_trcConfig to ZONE_FUNCTION in the debugger to get fn tracing on

//
// DbgZPrintFn()
// DbgZPrintFnExitDWORD()
//
// This prints out strings for function tracing
//

void DbgZPrintFn(LPSTR szFn)
{
    if (g_trcConfig & ZONE_FUNCTION)
    {
        WARNING_OUT(("%s", szFn));
    }
}



void DbgZPrintFnExitDWORD(LPSTR szFn, DWORD dwResult)
{
    if (g_trcConfig & ZONE_FUNCTION)
    {
        WARNING_OUT(("%s, RETURN %08lx", szFn, dwResult));
    }
}




#endif // DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\as16\winddi.h ===
// --------------------------------------------------------------------------
//
//  WINDDI.H
//
//  Win16 DDI header
//
// --------------------------------------------------------------------------

#ifndef _WINDDI_
#define _WINDDI_


//
// Display Driver ordinals
//
#define ORD_OEMINQUIRECURSOR    101
#define ORD_OEMSETCURSOR        102
#define ORD_OEMMOVECURSOR       103
#define ORD_OEMCHECKCURSOR      104
#define ORD_OEMSAVEBITS          92


//
// DDI patches
//

#define DDI_FIRST       0
typedef enum
{
    //
    // Screen Output routines
    //
    DDI_ARC = DDI_FIRST,
    DDI_BITBLT,
    DDI_CHORD,
    DDI_ELLIPSE,
    DDI_EXTFLOODFILL,
    DDI_EXTTEXTOUTA,
    DDI_EXTTEXTOUTW,
    DDI_FILLPATH,
    DDI_FILLRGN,
    DDI_FLOODFILL,
    DDI_FRAMERGN,
    DDI_INVERTRGN,
    DDI_LINETO,
    DDI_PAINTRGN,
    DDI_PATBLT,
    DDI_PIE,
    DDI_PLAYENHMETAFILERECORD,
    DDI_PLAYMETAFILE,
    DDI_PLAYMETAFILERECORD,
    DDI_POLYGON,
    DDI_POLYBEZIER,
    DDI_POLYBEZIERTO,
    DDI_POLYLINE,
    DDI_POLYLINETO,
    DDI_POLYPOLYLINE,
    DDI_POLYPOLYGON,
    DDI_RECTANGLE,
    DDI_ROUNDRECT,
    DDI_SETDIBITSTODEVICE,
    DDI_SETPIXEL,
    DDI_STRETCHBLT,
    DDI_STRETCHDIBITS,
    DDI_STROKEANDFILLPATH,
    DDI_STROKEPATH,
    DDI_TEXTOUTA,
    DDI_TEXTOUTW,
    DDI_UPDATECOLORS,

    //
    // SPB stuff
    //
    DDI_CREATESPB,
    DDI_DELETEOBJECT,
    // DDI_SETOBJECTOWNER for Memphis

    //
    // Display mode, dosbox stuff
    //
    DDI_DEATH,
    DDI_RESURRECTION,
    DDI_WINOLDAPPHACKOMATIC,
    DDI_GDIREALIZEPALETTE,
    DDI_REALIZEDEFAULTPALETTE,

    //
    // If we implement an SBC, 
    // DDI_SETBITMAPBITS,
    // DDI_SETDIBCOLORTABLE,
    // DDI_SETDIBITS,
    // DDI_SYSDELETEOBJECT,
    //

    DDI_MAX
} DDI_PATCH;


//
// IM Patches
// We patch these DDIs when you are sharing and your machine is being
// controlled by a remote.  If a 16-bit shared app goes into a modal loop
// on mouse/key down, we pulse the win16lock so our 32-bit thread can
// play back the mouse/key moves and ups.
//
#define IM_FIRST        0
typedef enum
{
    //
    // Low level input processing
    //
    IM_MOUSEEVENT   = IM_FIRST,
    IM_KEYBOARDEVENT,
    IM_SIGNALPROC32,

    //
    // Win16lock pulsing for 16-bit apps that do modal loops on mouse input
    //
    IM_GETASYNCKEYSTATE,
    IM_GETCURSORPOS,
    
    IM_MAX
} IM_PATCH;


//
// DDI Routines
//
BOOL    WINAPI DrvArc(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI DrvBitBlt(HDC, int, int, int, int, HDC, int, int, DWORD);
BOOL    WINAPI DrvChord(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI DrvEllipse(HDC, int, int, int, int);
BOOL    WINAPI DrvExtFloodFill(HDC, int, int, COLORREF, UINT);
BOOL    WINAPI DrvExtTextOutA(HDC, int, int, UINT, LPRECT, LPSTR, UINT, LPINT);
BOOL    WINAPI DrvExtTextOutW(HDC, int, int, UINT, LPRECT, LPWSTR, UINT, LPINT);
BOOL    WINAPI DrvFillPath(HDC);
BOOL    WINAPI DrvFillRgn(HDC, HRGN, HBRUSH);
BOOL    WINAPI DrvFloodFill(HDC, int, int, COLORREF);
BOOL    WINAPI DrvFrameRgn(HDC, HRGN, HBRUSH, int, int);
BOOL    WINAPI DrvInvertRgn(HDC, HRGN);
BOOL    WINAPI DrvLineTo(HDC, int, int);
BOOL    WINAPI DrvPaintRgn(HDC, HRGN);
BOOL    WINAPI DrvPatBlt(HDC, int, int, int, int, DWORD);
BOOL    WINAPI DrvPie(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI DrvPlayEnhMetaFileRecord(HDC, LPHANDLETABLE, LPENHMETARECORD, DWORD);
BOOL    WINAPI DrvPlayMetaFile(HDC, HMETAFILE);
void    WINAPI DrvPlayMetaFileRecord(HDC, LPHANDLETABLE, METARECORD FAR*, UINT);
BOOL    WINAPI DrvPolyBezier(HDC, LPPOINT, UINT);
BOOL    WINAPI DrvPolyBezierTo(HDC, LPPOINT, UINT);
BOOL    WINAPI DrvPolygon(HDC, LPPOINT, int);
BOOL    WINAPI DrvPolyline(HDC, LPPOINT, int);
BOOL    WINAPI DrvPolylineTo(HDC, LPPOINT, int);
BOOL    WINAPI DrvPolyPolygon(HDC, LPPOINT, LPINT, int);
BOOL    WINAPI DrvPolyPolyline(DWORD, HDC, LPPOINT, LPINT, int);
BOOL    WINAPI DrvRectangle(HDC, int, int, int, int);
BOOL    WINAPI DrvRoundRect(HDC, int, int, int, int, int, int);
int     WINAPI DrvSetDIBitsToDevice(HDC, int, int, int, int, int, int, UINT, UINT,
                    LPVOID, LPBITMAPINFO, UINT);
COLORREF WINAPI DrvSetPixel(HDC, int, int, COLORREF);
BOOL    WINAPI DrvStretchBlt(HDC, int, int, int, int, HDC, int, int, int, int, DWORD);
int     WINAPI DrvStretchDIBits(HDC, int, int, int, int, int,
                        int, int, int, const void FAR*, LPBITMAPINFO, UINT, DWORD);
BOOL    WINAPI DrvStrokeAndFillPath(HDC);
BOOL    WINAPI DrvStrokePath(HDC);
BOOL    WINAPI DrvTextOutA(HDC, int, int, LPSTR, int);
BOOL    WINAPI DrvTextOutW(HDC, int, int, LPWSTR, int);
int     WINAPI DrvUpdateColors(HDC);

void    WINAPI DrvRealizeDefaultPalette(HDC);
DWORD   WINAPI DrvGDIRealizePalette(HDC);

UINT    WINAPI DrvCreateSpb(HDC, int, int);
BOOL    WINAPI DrvDeleteObject(HGDIOBJ);
LONG    WINAPI DrvSetBitmapBits(HBITMAP, DWORD, const void FAR*);
UINT    WINAPI DrvSetDIBColorTable(HDC, UINT, UINT, const RGBQUAD FAR*);
int     WINAPI DrvSetDIBits(HDC, HBITMAP, UINT, UINT, const void FAR*, BITMAPINFO FAR*, UINT);
BOOL    WINAPI DrvSysDeleteObject(HGDIOBJ);


BOOL    WINAPI DrvSetPointerShape(LPCURSORSHAPE lpcur);
BOOL    WINAPI DrvSaveBits(LPRECT lprc, UINT wSave);

UINT    WINAPI DrvDeath(HDC);
UINT    WINAPI DrvResurrection(HDC, DWORD, DWORD, DWORD);
LONG    WINAPI DrvWinOldAppHackoMatic(LONG flags);

LONG    WINAPI DrvChangeDisplaySettings(LPDEVMODE, DWORD);
LONG    WINAPI DrvChangeDisplaySettingsEx(LPCSTR, LPDEVMODE, HWND, DWORD, LPVOID);
BOOL    WINAPI DrvSignalProc32(DWORD, DWORD, DWORD, WORD);

void    WINAPI DrvMouseEvent(UINT regAX, UINT regBX, UINT regCX, UINT regDX,
                UINT regSI, UINT regDI);
void    WINAPI DrvKeyboardEvent(UINT regAX, UINT regBX, UINT regSI, UINT regDI);

//
// GetAsyncKeyState
// GetCursorPos
//
int     WINAPI DrvGetAsyncKeyState(int);
BOOL    WINAPI DrvGetCursorPos(LPPOINT);


//
// GDI STRUCTURES
//


typedef struct tagGDIHANDLE
{
    PBYTE       pGdiObj;        // If not swapped out, in GDI ds
                                // If swapped out, local32handle
    BYTE        objFlags;
} GDIHANDLE, FAR* LPGDIHANDLE;

#define OBJFLAGS_SWAPPEDOUT     0x40
#define OBJFLAGS_INVALID        0xFF



//
// More useful definition of RGNDATA
//

#define CRECTS_COMPLEX      32
#define CRECTS_MAX          ((0x4000 - sizeof(RDH)) / sizeof(RECTL))

//
// Keep RGNDATA <= 8K.  WE can get a larger region then combine areas if
// needed.
//
typedef struct tagRDH
{
    DWORD   dwSize;
    DWORD   iType;
    DWORD   nRectL;                 // Number of rect pieces
    DWORD   nRgnSize;
    RECTL   arclBounds;
}
RDH, FAR* LPRDH;


typedef struct tagREAL_RGNDATA
{
    RDH     rdh;
    RECTL   arclPieces[CRECTS_MAX];
}
REAL_RGNDATA, FAR* LPREAL_RGNDATA;



//
// DRAWMODE
//

typedef struct tagDRAWMODE
{
    int         Rop2;               // 16-bit encoded logical op
    int         bkMode;             // Background mode (for text only)
    DWORD       bkColorP;           // Physical background color
    DWORD       txColorP;           // Physical foreground (text) color
    int         TBreakExtra;        // Total pixels to stuff into a line
    int         BreakExtra;         // div(TBreakExtra, BreakCount)
    int         BreakErr;           // Running error term
    int         BreakRem;           // mod(TBreakExtra, BreakCount)
    int         BreakCount;         // Number of breaks in the line
    int         CharExtra;          // Extra pixels to stuff after each char
    DWORD       bkColorL;           // Logical background color
    DWORD       txColorL;           // Logical foreground color
    DWORD       ICMCXform;          // Transform for DIC image color matching
    int         StretchBltMode;     // Stretch blt mode
    DWORD       eMiterLimit;        // Miter limit (single precision IEEE float)
} DRAWMODE;
typedef DRAWMODE FAR * LPDRAWMODE;


typedef struct tagGDIOBJ_HEAD
{
    LOCALHANDLE ilhphOBJ;
    UINT        ilObjType;
    DWORD       ilObjCount;
    UINT        ilObjMetaList;
    UINT        ilObjSelCount;
    UINT        ilObjTask;
} GDIOBJ_HEAD;
typedef GDIOBJ_HEAD FAR* LPGDIOBJ_HEAD;



typedef struct tagDC
{
    GDIOBJ_HEAD     MrDCHead;
    BYTE            DCFlags;
    BYTE            DCFlags2;
    HMETAFILE       hMetaFile;
    HRGN            hClipRgn;
    HRGN            hMetaRgn;
    GLOBALHANDLE    hPDevice;   // Physical device handle

    HPEN            hPen;       // Current logical pen
    HBRUSH          hBrush;     // Current logical brush
    HFONT           hFont;      // Current logical font
    HBITMAP         hBitmap;    // Current logical bitmap
    HPALETTE        hPal;       // Current logical palette

    LOCALHANDLE     hLDevice;   // Logical device handle
    HRGN            hRaoClip;   // Intersection of clip regions
    LOCALHANDLE     hPDeviceBlock;    // DC phys instance data inc. GDIINFO
    LOCALHANDLE     hPPen;      // Current physical pen
    LOCALHANDLE     hPBrush;    // Current physical brush
    LOCALHANDLE     hPFontTrans;    // Current physical font transform
    LOCALHANDLE     hPFont;     // Current physical font

    LPBYTE          lpPDevice;  // Ptr to physical device or bitmap
    PBYTE           pLDeviceBlock;   // Near ptr to logical device block
    PBYTE           hBitBits;   // Handle of selected bitmap bits
    PBYTE           pPDeviceBlock;   // Near ptr to physical device block
    LPBYTE          lpPPen;     // Ptr to OEM pen data
    LPBYTE          lpPBrush;   // Ptr to OEM brush data
    PBYTE           pPFontTrans;    // Near ptr to text transform
    LPBYTE          lpPFont;        // Ptr to physical font
    UINT            nPFTIndex;  // PFT index for font/DEVICE_FONT

    POINT           Translate;
    DRAWMODE        DrawMode;

    HGLOBAL         hPath;
    UINT            fwPath;
    // ...
} DC;
typedef DC FAR* LPDC;


// 
// Values for DCFlags
//

#define DC_IS_MEMORY        0x01
#define DC_IS_DISPLAY       0x02
#define DC_HAS_DIRTYVISRGN  0x04
#define DC_IS_PARTIAL       0x80
#define DC_HAS_DIRTYFONT    0x40
#define DC_HAS_DIRTYPEN     0x20
#define DC_HAS_DIRTYCLIP    0x10

//
// Values for DCFlags2
//
#define DRAFTFLAG           0x01
#define ChkDispPal          0x02
#define dfFont              0x04
#define SimVectFont         0x08
#define deFont              0x10
#define TT_NO_DX_MOD        0x40    // DC is for Micrografx's metafile recorder
#define DC_DIB              0x80    // memory DC is now a DIB DC.

//
// Values for fwPath
//
#define DCPATH_ACTIVE       0x0001
#define DCPATH_SAVE         0x0002
#define DCPATH_CLOCKWISE    0x0004


//
// BRUSH structure
//
typedef struct tagBRUSH
{
    GDIOBJ_HEAD     ilObjHead;
    LOGBRUSH        ilBrushOverhead;        // lbHatch is the HGLOBAL of the bitmap
    HBITMAP         ilBrushBitmapOrg;
} BRUSH;
typedef BRUSH FAR* LPBRUSH;




#endif  // !_WINDDI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\as16\ut.asm ===
;
; UT.ASM
; Tracing goop, debug only
; Mouse/Keyboard event interrupt junk, all flavors
;


.386
option oldstructs
option readonly
option segment:use16
.model large,pascal

ifdef DEBUG
externDef   _wsprintf:far16
externDef   OutputDebugString:far16
externDef   DebugBreak:far16
endif ; DEBUG

externDef   DrvMouseEvent:far16
externDef   DrvKeyboardEvent:far16
externDef   mouse_event:far16
externDef   keybd_event:far16
externDef   MaphinstLS:far16

.data

ifdef DEBUG
externDef   g_szDbgBuf:word
externDef   g_szNewline:word
externDef   g_dbgRet:word
externDef   g_trcConfig:word
endif ; DEBUG

if 0
; DOS key redirection
externDef   g_imDOSShellVDDEntry:dword
externDef   g_imDOSVKDEntry:dword
endif

.code _TEXT


ifdef DEBUG

;
; We come in here with _cdecl var args.  We use DebugOutput() to spit out
; the message.  Then we do the debugbreak ourself.
;
_DbgZPrintWarning   proc    near
    ; Save IP of caller.  What's left on stack is var args
    pop     [g_dbgRet]   ; Save IP of output caller

    ; Push g_szDbgBuf to put result into.
    push    ds
    push    offset g_szDbgBuf

    ; We now have _cdecl args to wsprintf
    call    _wsprintf

    ;
    ; The same args are left on the stack, since wsprintf is _cdecl.  The
    ; first is g_szDbgBuf.  So we can convienently pass this to OutputDebugString().
    ; That routine is NOT _cdecl, so when it returns, we have exactly the
    ; same args that were passed in to us.
    ;
    call    OutputDebugString

    ; Now output a new line
    push    ds
    push    offset g_szNewline
    call    OutputDebugString

    ; Now we just need to do a near RET to the caller
    push    [g_dbgRet]
    ret
_DbgZPrintWarning   endp


;
; We come in here with _cdecl var args
;
_DbgZPrintTrace     proc    near
    ; Is tracing on?
    test    [g_trcConfig],  0001h
    jnz     _DbgZPrintWarning
    ret
_DbgZPrintTrace     endp



_DbgZPrintError     proc    near
    ; Save IP of caller.  What's left on stack is var args
    pop     [g_dbgRet]   ; Save IP of output caller

    ; Push g_szDbgBuf to put result into.
    push    ds
    push    offset g_szDbgBuf

    ; We now have _cdecl args to wsprintf
    call    _wsprintf

    ;
    ; The same args are left on the stack, since wsprintf is _cdecl.  The
    ; first is g_szDbgBuf.  So we can convienently pass this to OutputDebugString().
    ; That routine is NOT _cdecl, so when it returns, we have exactly the
    ; same args that were passed in to us.
    ;
    call    OutputDebugString

    ; Now output a new line
    push    ds
    push    offset g_szNewline
    call    OutputDebugString


    ; Break into the debugger
    call    DebugBreak

    ; Now we just need to do a near RET to the caller
    push    [g_dbgRet]
    ret
_DbgZprintError     endp

endif


;
; ASMMouseEvent()
; This passes the registers as parameters to a C function, DrvMouseEvent.
; It is basically the inverse of CallMouseEvent().
;
; NOTE:
; To be on the safe side, we preserve all registers just like keybd_event().
; USER trashes some registers, but it would not come as a surprise to find
; mouse drivers that expect incorrectly a register or two to not be
; altered.
;
ASMMouseEvent   proc    far

    ; Save registers that C code doesn't preserve
    push    eax
    push    ebx
    push    ecx
    push    edx

    ; Save original flags for turning ints off/on
    pushf

    ; Push AX for DrvMouseEvent() call
    push    ax

    ; Do we need to turn interrupts off?  We don't if they are already
    pushf
    pop     ax
    test    ax, 0200h
    jz      SkipCli
    cli
SkipCli:

    ; AX has already been pushed; push the rest of the parameters
    push    bx
    push    cx
    push    dx
    push    si
    push    di
    cld
    call    DrvMouseEvent

    ; If interrupts were not disabled before, enable them now.
    pop     cx      ; saved flags
    pushf
    pop     ax      ; current flags

    ; Find out what is different
    xor     ax, cx
    test    ax, 0200h
    jz      InterruptsOk

    ; The interrupt flag needs to be changed, do it
    test    cx, 0200h
    jnz     EnableInterrupts
    cli
    jmp     InterruptsOk

EnableInterrupts:
    sti

InterruptsOk:
    ; Does the direction flag need to be changed?
    test    ax, 0400h
    jz      DirectionOk

    ; The direction flag needs to be changed, do it
    test    cx, 0400h
    jnz     SetDirectionFlag
    cld
    jmp     DirectionOk

SetDirectionFlag:
    std

DirectionOk:
    ; Restore registers
    pop     edx
    pop     ecx
    pop     ebx
    pop     eax

    retf
ASMMouseEvent   endp


;
; CallMouseEvent()
; This puts the parameters into registers and calls the original mouse_event.
;
; There are two ways we can call this function:
;   (1) Injection code is piping mouse events through USER.  It is 
; responsible for disabling/enabling interrupts before calling us.
;   (2) mouse_event patch is calling through to USER.
;
CallMouseEvent      proc    near
    ;
    ; This is the stack, BP relative:
    ;       WORD    bpSave
    ;       WORD    near_ret
    ;       WORD    regDI
    ;       WORD    regSI
    ;       WORD    regDX
    ;       WORD    regCX
    ;       WORD    regBX
    ;       WORD    regAX
    ;
    ; We must preserve SI and DI
    ;
    push    bp
    mov     bp, sp
    push    si
    push    di

    mov     di, word ptr ss:[bp+4]
    mov     si, word ptr ss:[bp+6]
    mov     dx, word ptr ss:[bp+8]
    mov     cx, word ptr ss:[bp+10]
    mov     bx, word ptr ss:[bp+12]
    mov     ax, word ptr ss:[bp+14]

    call    mouse_event

    pop     di
    pop     si
    mov     sp, bp
    pop     bp
    ret     6*2
CallMouseEvent      endp



;
; ASMKeyboardEvent()
; This passes the registers as parameters to a C function, DrvKeyboardEvent.
; It is basically the inverse of CallKeyboardEvent().
;
; NOTE:
; keybd_event() MUST preserve all registers, unlike mouse_event().
;
ASMKeyboardEvent    proc    far

    ; Save flags and registers that aren't preserved in C code
    push    eax
    push    ebx
    push    ecx
    push    edx
    pushf

    ; Push AX for DrvKeyboardEvent() call
    push    ax

    ; Check if interrupts off, w/o trashing CX permanently
    pushf
    pop     ax
    test    ax, 0200h
    jz      SkipCli
    cli
SkipCli:

    ; AX has already been pushed; push the rest of the parameters
    push    bx
    push    si
    push    di
    cld
    call    DrvKeyboardEvent

    ;
    ; Restore the interrupt and string move direction flags to what they
    ; were before.
    ;
    pop     cx      ; Original flags
    pushf
    pop     ax      ; Current flags

    ; What has changed?
    xor     ax, cx

    ; Has the interrupt state been altered?
    test    ax, 0200h
    jz      InterruptsOk

    ; Interrupts need to be turned on/off
    test    cx, 0200h
    jnz     EnableInterrupts
    cli
    jmp     InterruptsOk

EnableInterrupts:
    sti

InterruptsOk:
    ; Has the direction flag been altered?
    test    ax, 0400h
    jz      DirectionOk

    ; Direction flag needs to be set/cleared
    test    cx, 0400h
    jnz     SetDirection
    cld
    jmp     DirectionOk

SetDirection:
    std

DirectionOk:
    ; Restore registers
    pop     edx
    pop     ecx
    pop     ebx
    pop     eax

    retf
ASMKeyboardEvent    endp



;
; CallKeyboardEvent()
; This puts the parameters in registers and calls USER's keybd_event.
;
; There are two ways we can call this function:
;   (1) Injection code is piping keybd events through USER.  It is 
; responsible for disabling/enabling interrupts before calling us.
;   (2) keybd_event patch is calling through to USER.
;
CallKeyboardEvent   proc    near
    ;
    ; This is the stack, BP relative:
    ;       WORD    bpSave
    ;       WORD    near_ret
    ;       WORD    regDI
    ;       WORD    regSI
    ;       WORD    regBX
    ;       WORD    regAX
    ;
    ; We must preserve SI and DI
    ;
    push    bp
    mov     bp, sp
    push    si
    push    di

    mov     di, word ptr ss:[bp+4]
    mov     si, word ptr ss:[bp+6]
    mov     bx, word ptr ss:[bp+8]
    mov     ax, word ptr ss:[bp+10]

    call    keybd_event

    pop     di
    pop     si
    mov     sp, bp
    pop     bp
    ret     4*2
CallKeyboardEvent   endp


;
; This is our wrapper around krnl386's MaphinstLS() routine, which expects
; the 32-bit instance handle in EAX
;
MapInstance32   proc    far
    ; Pop far return, pop 32-bit instance into eax, and replace far return
    pop     edx
    pop     eax
    push    edx

    ; Call krnl386 -- when MaphinstLS returns, it will return to our caller
    jmp     MaphinstLS
MapInstance32   endp



if 0
;
; DOS box key injection gunk.  We use the shell vdd service.
;

IMGetDOSShellVDDEntry   proc    near
    ; Save DI, int2f will trash it
    push    di

    ; int2f 0x1684, vdd 0x0017 (shell) gets the service entry point
    ; It is returned in es:di
    mov     ax, 1684h
    mov     bx, 017h
    int     2F

    ; Save the address (even if null)
    mov     word ptr ds:[g_imDOSShellVDDEntry], di
    mov     word ptr ds:[g_imDOSShellVDDEntry+2], es

    pop     di
    ret
IMGetDOSShellVDDEntry   endp


IMGetDOSVKDEntry        proc    near
    ; Save DI, int2f will trash it
    push    di

    ; int2f 0x1684, vkd 0x000d (vkd) gets the service entry point
    ; It is returned in es:di
    mov     ax, 1684h
    mov     bx, 00dh
    int     2Fh

    mov     word ptr ds:[g_imDOSVKDEntry], di
    mov     word ptr ds:[g_imDOSVKDEntry+1], es

    pop     di
    ret
IMGetDOSVKDEntry    endp



IMForceDOSKey           proc    near
    ; ss:[sp]   is  near ret
    ; ss:[sp+2] is  scanCode
    ; ss:[sp+4] is  keyState

    push    bp
    mov     bp, sp

    ; Preserve extended registers
    push    ebx
    push    ecx
    push    edx

    ; Setup for VKD call
    mov     eax, 1                      ; Service 1, stuff key
    xor     ebx, ebx                    ; VM 0, current VM
    movzx   ecx, word ptr ss:[bp+4]     
    shl     ecx, 8                      ; Scan code in high byte
    or      ecx, 1                      ; Repeat count in low byte
    movzx   edx, word ptr ss:[bp+6]     ; Shift state

    call    dword ptr ds:[g_imDOSVKDEntry]
    mov     ax, 0
    
    ; Failure?
    jc      DoneForceKey
    
    ; Success!
    inc     ax

DoneForceKey:
    pop     edx
    pop     ecx
    pop     ebx

    mov     sp, bp
    pop     bp

    ret     2+2
IMForceDOSKey       endp

endif ; if 0 for DOS key redirection

end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\awc.cpp ===
#include "precomp.h"


//
// AWC.CPP
// Active Window Coordinator
//
// Copyright(c) Microsoft 1997-
//
#define MLZ_FILE_ZONE  ZONE_CORE


//
// The AWC code does three things:
//      * Notifies everybody in the share what the current active window
//          is when sharing (either a shared window or something else)
//      * When in control, requests to restore/activate a remote's shared
//          window
//      * When being controlled, handles request to restore/activate
//          a local hosted window
//

//
// For the purposes of this strategy the AWC packets can be split into two
// categories.
//
// 1.  Immediate - these are the packets which are generated when a shadow
// window is controlled by some means other than direct keyboard or mouse
// input to the shadow window (which is all sent to the host system and
// handled there).  Examples include the Task List, window switching
// (Alt-TAB, Alt-Esc etc), minimising or closing another app which may pass
// activation on to a shadow window etc.  The packets in this category are:
//
//  AWC_MSG_ACTIVATE_WINDOW
//  AWC_MSG_RESTORE_WINDOW
//
// These packets can be (and are) sent immediately that the event happens.
// This is because they always refer to real windows on the host system.
//
// 2.  Periodic - these are the packets sent when the AWC detects that the
// active window has changed locally and it should inform the remote AWC.
// This packet is sent when AWC_Periodic is called.  The packets in this
// category are:
//
//  AWC_MSG_ACTIVE_CHANGE_SHARED
//  AWC_MSG_ACTIVE_CHANGE_LOCAL
//  AWC_MSG_ACTIVE_CHANGE_INVISIBLE
//
// These are only sent when AWC_Periodic is called because they may refer
// to shadow windows and therefore we avoid sending it until we know that
// the SWL has succesfully sent a window structure which includes the
// window referenced in the message.
//
// For packets in the first category we will queue up to two packets and at
// the point where we have three packets we cannot send we will discard
// packets from the front of the queue so that a users most recent actions
// have priority over any previous actions.  We will try to send all queued
// packets whenever a new category 1 packet is generated and on the
// AWC_Periodic call.
//
// For packets in the second category we will drop the packets if we cannot
// send them but remember that we have failed to send a packet and retry on
// the next call to AWC_Periodic.  This is not the same as queueing as the
// active window may change between us dropping a packet and being able to
// send the next packet from AWC_Periodic.  Queuing the dropped packet
// would have been pointless as it would now be out of date.
//
// All AWC packets go on the same stream (the updates stream) so that they
// are guaranteed to arrive in the same order as they are generated to
// prevent a AWC_MSG_ACTIVE_CHANGE_XXX being overtaken by an
// AWC_MSG_ACTIVATE_WINDOW and therefore the effect of
// AWC_MSG_ACTIVATE_WINDOW being overridden by the
// AWC_MSG_ACTIVE_CHANGE_XXX.
//




//
// AWC_ReceivedPacket()
//
void  ASShare::AWC_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PAWCPACKET      pAWCPacket;
    UINT            activateWhat;
    HWND            hwnd;

    DebugEntry(ASShare::AWC_ReceivedPacket);

    ValidatePerson(pasPerson);

    pAWCPacket = (PAWCPACKET)pPacket;

    //
    // We trace the person ID out here so we don't bother to do it
    // elsewhere in this function on TRACE lines.
    //
    TRACE_OUT(("AWC_ReceivedPacket from [%d] - msg %x token %u data 0x%08x",
                 pasPerson->mcsID,
                 pAWCPacket->msg,
                 pAWCPacket->token,
                 pAWCPacket->data1));

    if (AWC_IS_INDICATION(pAWCPacket->msg))
    {
        //
        // We should simply change the view of the remote.
        //
        if (pasPerson->awcActiveWinID != pAWCPacket->data1)
        {
            pasPerson->awcActiveWinID = pAWCPacket->data1;

            if (pasPerson->m_pView)
            {
                // Update the pressed item on the window bar.
                VIEW_WindowBarChangedActiveWindow(pasPerson);
            }
        }
    }
    else if (AWC_MSG_SAS == pAWCPacket->msg)
    {
        //
        // Cause Ctrl+Alt+Del to be injected if we're in a service app,
        // we're hosting, and we're controlled by the sender.
        //
        if ((g_asOptions & AS_SERVICE) && (pasPerson->m_caInControlOf == m_pasLocal))
        {
            ASSERT(m_pHost);
            OSI_InjectCtrlAltDel();
        }
    }
    else
    {
        hwnd = (HWND)pAWCPacket->data1;

        //
        // Only accept requests if we're being controlled currently by
        // this person.  We might get renegade packets from remotes that
        // don't yet they aren't in control, or from back-level systems.
        //
        if (pasPerson->m_caInControlOf != m_pasLocal)
        {
            // We're not controlled by this person
            DC_QUIT;
        }

        ASSERT(m_pHost);

        if ((pAWCPacket->msg == AWC_MSG_ACTIVATE_WINDOW) &&
            IsWindow(hwnd)                               &&
            IsWindowEnabled(hwnd))
        {
            // Ony get owned window if enabled and we're activating.
            hwnd = GetLastActivePopup(hwnd);
        }

        if (IsWindow(hwnd) &&
            HET_WindowIsHosted(hwnd) &&
            IsWindowEnabled(hwnd))
        {
            switch (pAWCPacket->msg)
            {
                case AWC_MSG_ACTIVATE_WINDOW:
                    //
                    // Activate the window.
                    //
                    TRACE_OUT(("Received AWC_MSG_ACTIVATE_WINDOW for hwnd 0x%08x from [%d]",
                        hwnd, pasPerson->mcsID));
                    m_pHost->AWC_ActivateWindow(hwnd);
                    break;

                case AWC_MSG_RESTORE_WINDOW:
                    //
                    // Restore the window
                    //
                    TRACE_OUT(("Received AWC_MSG_RESTORE_WINDOW for hwnd 0x%08x from [%d]",
                        hwnd, pasPerson->mcsID));
                    if (IsIconic(hwnd))
                    {
                        PostMessage(hwnd, WM_SYSCOMMAND, SC_RESTORE, 0);
                    }
                    break;

                default:
                    WARNING_OUT(("Received invalid msg %d from [%d]",
                        pAWCPacket->msg, pasPerson->mcsID));
                    break;
            }
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::AWC_ReceivedPacket);
}


//
// AWC_Periodic()
//
void  ASHost::AWC_Periodic(void)
{
    HWND            currentActiveWindow;
    HWND            sendActiveWindow;
    TSHR_UINT16     sendMsg;

    DebugEntry(ASHost::AWC_Periodic);

    //
    // If we are hosting the desktop, skip this.
    //
    if (m_pShare->m_pasLocal->hetCount == HET_DESKTOPSHARED)
    {
        // Skip.
        DC_QUIT;
    }

    //
    // Find the current active window.
    //
    if (SWL_IsOurDesktopActive())
    {
        currentActiveWindow = GetForegroundWindow();
    }
    else
    {
        // Another desktop is up.
        currentActiveWindow = NULL;
    }

    if (m_pShare->HET_WindowIsHosted(currentActiveWindow))
    {
        //
        // A window which belongs to shared application is active -
        // find out if it is visible.
        //
        if (IsWindowVisible(currentActiveWindow))
        {
            //
            // The active window is also visible - this means the
            // remote system will know about it as it will have
            // been sent in a preceding SWL message.
            //
            sendMsg = AWC_MSG_ACTIVE_CHANGE_SHARED;
            sendActiveWindow = SWL_GetSharedIDFromLocalID(currentActiveWindow);
        }
        else
        {
            //
            // The active window is invisible - this means that
            // although it is shared the remote system will not
            // know about it.  Send a message to inform the remote
            // system about this.
            //
            sendMsg = AWC_MSG_ACTIVE_CHANGE_INVISIBLE;
            sendActiveWindow = 0;
        }
    }
    else
    {
        //
        // A local application has been activated send
        // AWC_ACTIVE_WINDOW_LOCAL.
        //
        sendMsg = AWC_MSG_ACTIVE_CHANGE_LOCAL;
        sendActiveWindow = 0;
    }

    //
    // Now send the packet if it's not the same as the last packet we
    // sent.  NOTE that for local unshared windows, we don't care if
    // we've deactivated one and activated another, they are generic.  So
    // we send a message if we
    //      * change activation from a shared window
    //      * change activation to a shared window
    //
    if ((sendActiveWindow   != m_awcLastActiveWindow) ||
        (sendMsg            != m_awcLastActiveMsg))
    {
        //
        // Note that this packet is sent on the updates stream so that it
        // cannot overtake a SWL packet containing the newly active window.
        //
        TRACE_OUT(("Broadcasting AWC change msg %x, hwnd 0x%08x",
            sendMsg, sendActiveWindow));
        if (m_pShare->AWC_SendMsg(g_s20BroadcastID, sendMsg, HandleToUlong(sendActiveWindow), 0))
        {
            //
            // The packet was sent succesfully - remember which window we
            // sent.
            //
            m_awcLastActiveWindow = sendActiveWindow;
            m_awcLastActiveMsg    = sendMsg;
        }
        else
        {
            //
            // The packet could not be sent for some reason - set
            // m_awcLastActiveWindow to invalid so that we will try again
            // on the next call to AWC_Periodic.
            //
            m_awcLastActiveWindow = AWC_INVALID_HWND;
            m_awcLastActiveMsg    = AWC_MSG_INVALID;
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASHost::AWC_Periodic);
}



//
// AWC_SyncOutgoing()
//
void  ASHost::AWC_SyncOutgoing(void)
{
    DebugEntry(ASHost::AWC_SyncOutgoing);

    //
    // Ensure that we resend an indication message as soon as possible
    //
    m_awcLastActiveWindow = AWC_INVALID_HWND;
    m_awcLastActiveMsg    = AWC_MSG_INVALID;

    DebugExitVOID(ASHost::AWC_SyncOutgoing);
}


//
// FUNCTION: AWC_SendMsg
//
// DESCRIPTION:
//
// Sends a AWC message to remote system
//      * Requests to activate are just to one host
//      * Notifications of activation are to everyone
//
// RETURNS: TRUE or FALSE - success or failure
//
//
BOOL  ASShare::AWC_SendMsg
(
    UINT_PTR            nodeID,
    UINT            msg,
    UINT_PTR            data1,
    UINT_PTR            data2
)
{

    PAWCPACKET      pAWCPacket;
    BOOL            rc = FALSE;
#ifdef _DEBUG
    UINT            sentSize;
#endif

    DebugEntry(ASShare::AWC_SendMsg);

    //
    // Allocate correct sized packet.
    //
    pAWCPacket = (PAWCPACKET)SC_AllocPkt(PROT_STR_UPDATES, nodeID, sizeof(AWCPACKET));
    if (!pAWCPacket)
    {
        WARNING_OUT(("Failed to alloc AWC packet"));
        DC_QUIT;
    }

    //
    // Set up the data header for an AWC message.
    //
    pAWCPacket->header.data.dataType = DT_AWC;

    //
    // Now set up the AWC fields.  By passing AWC_SYNC_MSG_TOKEN in the
    // token field, we ensure that back-level remotes will never drop our
    // packets.
    //
    pAWCPacket->msg     = (TSHR_UINT16)msg;
    pAWCPacket->data1   = data1;
    pAWCPacket->data2   = data2;
    pAWCPacket->token   = AWC_SYNC_MSG_TOKEN;

    //
    // Send the packet.
    //
    if (m_scfViewSelf)
        AWC_ReceivedPacket(m_pasLocal, &(pAWCPacket->header));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    DCS_CompressAndSendPacket(PROT_STR_UPDATES, nodeID,
        &(pAWCPacket->header), sizeof(*pAWCPacket));

    TRACE_OUT(("AWC packet size: %08d, sent: %08d", sizeof(*pAWCPacket), sentSize));

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASShare::AWC_SendMsg, rc);
    return(rc);
}




//
// AWC_ActivateWindow()
//
// Activates a shared window via a remote controller's request.
//
void ASHost::AWC_ActivateWindow(HWND window)
{
    BOOL    rcSFW;
    HWND    hwndForeground;

    DebugEntry(ASHost::AWC_ActivateWindow);

    if (!IsWindow(window))
    {
        WARNING_OUT(( "Trying to activate invalid window %08x", window));
        DC_QUIT;
    }

    //
    // SetForegroundWindow appears to be asynchronous.  That is, it may
    // return successfully here but immediately querying the active
    // window does not always reveal the newly set foreground window to
    // be active.
    //
    rcSFW = SetForegroundWindow(window);
    hwndForeground = GetForegroundWindow();

    if (hwndForeground != window)
    {
        //
        // If a Screen Saver is active then it always refuses to let us
        // activate another window.  Trace an alert if the call to
        // SetForegroundWindow, above, failed.
        //
        if (OSI_IsWindowScreenSaver(hwndForeground) ||
            (m_swlCurrentDesktop != DESKTOP_OURS))
        {
            WARNING_OUT(("Screen Saver or other desktop is up, failed to activate window 0x%08x",
                window));
        }
        else if ( !rcSFW )
        {
            //
            // The active window is not the one we set because
            // SetForegroundWindow failed.
            //
            WARNING_OUT(("Failed to activate window 0x%08x", window));
        }

        //
        // We have apparently failed to set the active window, but
        // SetForegroundWindow succeeded. This is probably just a lag in
        // Windows getting up to date, so continue as if all is normal.
        //
    }

    //
    // Whether we succeeded or failed, make sure we broadcast the current
    // active window.
    //
    m_awcLastActiveWindow = AWC_INVALID_HWND;
    m_awcLastActiveMsg    = AWC_MSG_INVALID;

DC_EXIT_POINT:
    DebugExitVOID(ASHost::AWC_ActivateWindow);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\al.cpp ===
#include "precomp.h"


//
// Application Loader
//
#define MLZ_FILE_ZONE  ZONE_OM



//
// ALP_Init()
//
BOOL ALP_Init(BOOL * pfCleanup)
{
    BOOL        fInit = FALSE;

    DebugEntry(ALP_Init);

    UT_Lock(UTLOCK_AL);

    if (g_putAL || g_palPrimary)
    {
        *pfCleanup = FALSE;
        ERROR_OUT(("Can't start AL primary task; already running"));
        DC_QUIT;
    }
    else
    {
        //
        // From this point on, there is cleanup to do.
        //
        *pfCleanup = TRUE;
    }

    //
    // Register AL task
    //
    if (!UT_InitTask(UTTASK_AL, &g_putAL))
    {
        ERROR_OUT(("Failed to start AL task"));
        DC_QUIT;
    }

    //
    // Allocate PRIMARY data
    //
    g_palPrimary = (PAL_PRIMARY)UT_MallocRefCount(sizeof(AL_PRIMARY), TRUE);
    if (!g_palPrimary)
    {
        ERROR_OUT(("Failed to allocate AL memory block"));
        DC_QUIT;
    }

    SET_STAMP(g_palPrimary, ALPRIMARY);
    g_palPrimary->putTask       = g_putAL;

    //
    // Register an exit and event proc
    //
    UT_RegisterExit(g_putAL, ALPExitProc, g_palPrimary);
    g_palPrimary->exitProcRegistered = TRUE;

    UT_RegisterEvent(g_putAL, ALPEventProc, g_palPrimary, UT_PRIORITY_NORMAL);
    g_palPrimary->eventProcRegistered = TRUE;

    if (!CMS_Register(g_putAL, CMTASK_AL, &g_palPrimary->pcmClient))
    {
        ERROR_OUT(("Could not register ALP with CMS"));
        DC_QUIT;
    }

    //
    // Register as an OBMAN Secondary task (call OM_Register())
    //
    if (OM_Register(g_putAL, OMCLI_AL, &g_palPrimary->pomClient) != 0)
    {
        ERROR_OUT(( "Could not register ALP with OBMAN"));
        DC_QUIT;
    }

    fInit = TRUE;

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_AL);

    DebugExitBOOL(ALP_Init, fInit);
    return(fInit);
}



//
// ALP_Term()
//
void ALP_Term(void)
{
    DebugEntry(ALP_Term);

    UT_Lock(UTLOCK_AL);

    if (g_palPrimary)
    {
        ValidateALP(g_palPrimary);

        ValidateUTClient(g_putAL);

        //
        // Deregister from Call Manager (if registered call CM_Deregister())
        //
        if (g_palPrimary->pcmClient)
        {
            CMS_Deregister(&g_palPrimary->pcmClient);
        }

        //
        // Deregister from OBMAN (if registered call OM_Deregister())
        //
        if (g_palPrimary->pomClient)
        {
            OM_Deregister(&g_palPrimary->pomClient);
        }

        //
        // Do our own task termination
        //
        ALPExitProc(g_palPrimary);
    }

    UT_TermTask(&g_putAL);

    UT_Unlock(UTLOCK_AL);

    DebugExitVOID(ALP_Term);
}



//
// ALPExitProc()
//
void CALLBACK ALPExitProc(LPVOID data)
{
    PAL_PRIMARY palPrimary = (PAL_PRIMARY)data;
    UINT        i;

    DebugEntry(ALPExitProc);

    UT_Lock(UTLOCK_AL);

    ValidateALP(palPrimary);
    ASSERT(palPrimary == g_palPrimary);

    //
    // Deregister event procedure
    //
    if (palPrimary->eventProcRegistered)
    {
        UT_DeregisterEvent(g_putAL, ALPEventProc, palPrimary);
        palPrimary->eventProcRegistered = FALSE;
    }

    //
    // Deregister exit procedure (if registered call UT_DeregisterExit()
    //
    if (palPrimary->exitProcRegistered)
    {
        UT_DeregisterExit(g_putAL, ALPExitProc, palPrimary);
        palPrimary->exitProcRegistered = FALSE;
    }

    //
    // Free memory
    //
    UT_FreeRefCount((void**)&g_palPrimary, TRUE);

    UT_Unlock(UTLOCK_AL);

    DebugExitVOID(ALPExitProc);
}


//
// ALPEventProc()
//
BOOL CALLBACK ALPEventProc
(
    LPVOID      data,
    UINT        event,
    UINT_PTR    param1,
    UINT_PTR    param2
)
{
    PAL_PRIMARY palPrimary  = (PAL_PRIMARY)data;
    BOOL        processed   = FALSE;

    DebugEntry(ALPEventProc);

    UT_Lock(UTLOCK_AL);

    ValidateALP(palPrimary);

    switch (event)
    {
        case AL_INT_RETRY_NEW_CALL:
            // Retry new call
            ALNewCall(palPrimary, (UINT)param1, (UINT)param2);
            processed = TRUE;
            break;

        case CMS_NEW_CALL:
            // First try new call
            ALNewCall(palPrimary, AL_NEW_CALL_RETRY_COUNT, (UINT)param2);
            break;

        case CMS_END_CALL:
            ALEndCall(palPrimary, (UINT)param2);
            break;

        case OM_WSGROUP_REGISTER_CON:
            ALWorksetRegisterCon(palPrimary,
                                 ((POM_EVENT_DATA32)&param2)->correlator,
                                 ((POM_EVENT_DATA32)&param2)->result,
                                 ((POM_EVENT_DATA16)&param1)->hWSGroup);
            break;

        case OM_WORKSET_OPEN_CON:
            if ((((POM_EVENT_DATA16)&param1)->hWSGroup ==
                                        palPrimary->alWSGroupHandle) &&
                (((POM_EVENT_DATA16)&param1)->worksetID == 0) &&
                (((POM_EVENT_DATA32)&param2)->result == 0) )
            {
                TRACE_OUT(( "OM_WORKSET_OPEN_CON OK for AL workset 0"));
                palPrimary->alWorksetOpen = TRUE;

                if (palPrimary->alWBRegPend)
                    ALLocalLoadResult(palPrimary, (palPrimary->alWBRegSuccess != FALSE));
            }
            break;

        case OM_WORKSET_NEW_IND:
            if (ALWorksetNewInd(palPrimary,
                                  ((POM_EVENT_DATA16)&param1)->hWSGroup,
                                  ((POM_EVENT_DATA16)&param1)->worksetID))
            {
                //
                // The event was for a workset the Application Loader was
                // expecting - don't pass it on
                //
                processed = TRUE;
            }
            break;

        case OM_OBJECT_ADD_IND:
            //
            // See if it is a new workset group in an OBMAN control workset
            // (call ALNewWorksetGroup())
            //
            // If it isn't then see if it is a load result in the
            // Application Loader result workset (call ALRemoteLoadResult())
            //
            //
            TRACE_OUT(( "OM_OBJECT_ADD_IND"));

            if (ALNewWorksetGroup(palPrimary, ((POM_EVENT_DATA16)&param1)->hWSGroup,
                                    (POM_OBJECT)param2))
            {
                //
                // OBJECT_ADD was for an OBMAN control workset object Don't
                // pass event on to other handlers.
                //
                TRACE_OUT(("OBJECT_ADD was for OBMAN workset group"));
                processed = TRUE;
            }
            else
            {
                if (ALRemoteLoadResult(palPrimary, ((POM_EVENT_DATA16)&param1)->hWSGroup,
                                         (POM_OBJECT)param2))
                {
                    //
                    // OBJECT_ADD was for an AL remote result workset
                    // object Don't pass event on to other handlers.
                    //
                    TRACE_OUT(("OBJECT_ADD was for AL workset group"));
                    processed = TRUE;
                }
            }
            break;

        case OM_WORKSET_CLEAR_IND:
            TRACE_OUT(( "OM_WORKSET_CLEAR_IND"));

            if (palPrimary->alWSGroupHandle ==
                                ((POM_EVENT_DATA16)&param1)->hWSGroup)
            {
                TRACE_OUT(( "Confirming OM_WORKSET_CLEAR_IND event"));
                OM_WorksetClearConfirm(palPrimary->pomClient,
                        ((POM_EVENT_DATA16)&param1)->hWSGroup,
                        ((POM_EVENT_DATA16)&param1)->worksetID);
            }
            break;

        case OM_OBJECT_DELETE_IND:
            if (palPrimary->alWSGroupHandle ==
                                ((POM_EVENT_DATA16)&param1)->hWSGroup)
            {
                OM_ObjectDeleteConfirm(palPrimary->pomClient,
                        ((POM_EVENT_DATA16)&param1)->hWSGroup,
                        ((POM_EVENT_DATA16)&param1)->worksetID,
                        (POM_OBJECT)param2);
            }
            break;

        case OM_OBJECT_REPLACE_IND:
            if (palPrimary->alWSGroupHandle ==
                                ((POM_EVENT_DATA16)&param1)->hWSGroup)
            {
                OM_ObjectReplaceConfirm(palPrimary->pomClient,
                        ((POM_EVENT_DATA16)&param1)->hWSGroup,
                        ((POM_EVENT_DATA16)&param1)->worksetID,
                        (POM_OBJECT)param2);
            }
            break;

        case OM_OBJECT_UPDATE_IND:
            if (palPrimary->alWSGroupHandle ==
                                ((POM_EVENT_DATA16)&param1)->hWSGroup)
            {
                OM_ObjectUpdateConfirm(palPrimary->pomClient,
                        ((POM_EVENT_DATA16)&param1)->hWSGroup,
                        ((POM_EVENT_DATA16)&param1)->worksetID,
                        (POM_OBJECT)param2);
            }
            break;

        case AL_INT_STARTSTOP_WB:
            ALStartStopWB(palPrimary, (LPCTSTR)param2);
            processed = TRUE;
            break;

        default:
            break;
    }

    UT_Unlock(UTLOCK_AL);

    DebugExitBOOL(ALPEventProc, processed);
    return(processed);
}



//
// ALNewCall()
//
void ALNewCall
(
    PAL_PRIMARY         palPrimary,
    UINT                retryCount,
    UINT                callID
)
{
    UINT                rc;
    OM_WSGROUP_HANDLE   hWSGroup;
    CM_STATUS           status;

    DebugEntry(ALNewCall);

    ValidateALP(palPrimary);

    //
    // Can we handle a new call?
    //
    if (palPrimary->inCall)
    {
        WARNING_OUT(("No more room for calls"));
        DC_QUIT;
    }

    //
    // Is ObMan/AppLoader/OldWB disabled for this call?
    //
    CMS_GetStatus(&status);
    if (!(status.attendeePermissions & NM_PERMIT_USEOLDWBATALL))
    {
        WARNING_OUT(("Joining Meeting with no OLDWB AL at all"));
        DC_QUIT;
    }

    //
    // Register as a secondary with the OBMAN workset group for the new
    // call:
    //
    rc = OM_WSGroupRegisterS(palPrimary->pomClient,
                             callID,
                             OMFP_OM,
                             OMWSG_OM,
                            &hWSGroup);

    if ((rc == OM_RC_NO_PRIMARY) && (retryCount > 0))
    {
        //
        // Although a call has started, ObMan hasn't joined it yet - we
        // must have got the NEW_CALL event before it did.  So, we'll try
        // again after a short delay.
        //
        // Note that we cannot post the CMS_NEW_CALL event itself back to
        // ourselves, because it is bad programming practice to post other
        // people's events (e.g.  CM could register a hidden handler which
        // performs some non-repeatable operation on receipt of one of its
        // events).
        //
        // Therefore, we post an internal AL event which we treat in the
        // same way.
        //
        // To avoid retry forever, we use the first parameter of the event
        // as a countdown retry count.  The first time this function is
        // called (on receipt of a genuine CMS_NEW_CALL) the count is set
        // to the default.  Each time we post a delay event, we decrement
        // the value passed in and post that as param1.  When it hits zero,
        // we give up.
        //

        TRACE_OUT(("Got OM_RC_NO_PRIMARY from 2nd reg for call %d, %d retries left",
               callID, retryCount));

        UT_PostEvent(palPrimary->putTask,
                     palPrimary->putTask,
                     AL_RETRY_DELAY,
                     AL_INT_RETRY_NEW_CALL,
                     --retryCount,
                     callID);
        DC_QUIT;
    }

    if (rc) // includes NO_PRIMARY when retry count == 0
    {
        //
        // If we get any other error (or NO_PRIMARY when the retry count is
        // zero, it's more serious:
        //
        // lonchanc: was ERROR_OUT (happened when hang up immediately place a call)
        WARNING_OUT(( "Error registering with obman WSG, rc = %#x", rc));
        DC_QUIT;
    }

    TRACE_OUT(("Registered as OBMANCONTROL secondary in call %d", callID));

    //
    // Record the call ID and the correlator in the call information in
    // primary task memory
    //
    palPrimary->inCall           = TRUE;
    palPrimary->omWSGroupHandle  = hWSGroup;
    palPrimary->callID           = callID;
    palPrimary->alWSGroupHandle  = 0;

    //
    // Now we want to open workset #0 in the OBMAN workset group, but it
    // mightn't exist yet.  As soon as it is created, we will get a
    // WORKSET_NEW event, so we wait (asynchronously) for that.
    //

    //
    // Now that we have opened the OBMAN workset group, we shall register
    // with the application loader workset group
    //
    if (OM_WSGroupRegisterPReq(palPrimary->pomClient, callID,
            OMFP_AL, OMWSG_AL, &palPrimary->omWSGCorrelator) != 0)
    {
        ERROR_OUT(( "Could not register AL workset group"));
    }

DC_EXIT_POINT:
    DebugExitVOID(ALNewCall);
}



//
// ALEndCall()
//
void ALEndCall
(
    PAL_PRIMARY     palPrimary,
    UINT            callID
)
{
    UINT             i;

    DebugEntry(ALEndCall);

    ValidateALP(palPrimary);

    //
    // See if we have information for this call
    //
    if (!palPrimary->inCall ||
        (palPrimary->callID != callID))
    {
        //
        // Not an error - we may not have joined the call yet.
        //
        TRACE_OUT(("Unexpected call %d", callID));
        DC_QUIT;
    }

    //
    // Deregister from the OBMAN workset group for the call (if registered
    // call OM_WSGroupDeregister())
    //
    if (palPrimary->omWSGroupHandle)
    {
        OM_WSGroupDeregister(palPrimary->pomClient,
                            &palPrimary->omWSGroupHandle);
        ASSERT(palPrimary->omWSGroupHandle == 0);
    }

    //
    // Deregister from the AL workset group for the call (if registered
    // call OM_WSGroupDeregister())
    //
    if (palPrimary->alWSGroupHandle)
    {
        OM_WSGroupDeregister(palPrimary->pomClient,
                            &palPrimary->alWSGroupHandle);
        ASSERT(palPrimary->alWSGroupHandle == 0);
    }

    //
    // Clear out all our call state variables
    //
    palPrimary->inCall = FALSE;
    palPrimary->omWSGCorrelator = 0;
    palPrimary->callID = 0;
    palPrimary->omWSCorrelator = 0;
    palPrimary->omUID = 0;
    palPrimary->alWorksetOpen = FALSE;
    palPrimary->alWBRegPend = FALSE;

DC_EXIT_POINT:
    DebugExitVOID(ALEndCall);
}



//
// ALWorksetNewInd()
//
BOOL ALWorksetNewInd
(
    PAL_PRIMARY         palPrimary,
    OM_WSGROUP_HANDLE   hWSGroup,
    OM_WORKSET_ID       worksetID
)
{
    BOOL                fHandled = FALSE;

    DebugEntry(ALWorksetNewInd);

    ValidateALP(palPrimary);

    if (worksetID != 0)
    {
        TRACE_OUT(( "Workset ID is %u, ignoring and passing event on",
                 worksetID));
        DC_QUIT;
    }

    if (!palPrimary->inCall ||
        (palPrimary->omWSGroupHandle != hWSGroup))
    {
        TRACE_OUT(("Got WORKSET_NEW_IND for WSG %d, but not in call", hWSGroup));
        DC_QUIT;
    }

    //
    // Now open the workset (secondary Open, so synchronous):
    //
    if (OM_WorksetOpenS(palPrimary->pomClient, palPrimary->omWSGroupHandle, 0) != 0)
    {
        ERROR_OUT(( "Error opening OBMAN control workset"));
        palPrimary->inCall = FALSE;
        DC_QUIT;
    }

    TRACE_OUT(("Opened OBMANCONTROL workset #0 in call %d", palPrimary->callID));

    fHandled = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ALWorksetNewInd, fHandled);
    return(fHandled);
}


//
// ALNewWorksetGroup()
//
BOOL ALNewWorksetGroup
(
    PAL_PRIMARY         palPrimary,
    OM_WSGROUP_HANDLE   omWSGroup,
    POM_OBJECT          pObj
)
{
    BOOL                fHandled = FALSE;
    POM_OBJECTDATA      pData = NULL;
    OM_WSGROUP_INFO     WSGInfo;
    OMFP                fpHandler;
    BOOL                fLoaded;

    DebugEntry(ALNewWorksetGroup);

    ValidateALP(palPrimary);

    //
    // If the workset group is not in out list of calls, then this event
    // is for a group the Application Loader has registered with.  The
    // event should be passed onto other event procedures.
    //
    if (!palPrimary->inCall ||
        (palPrimary->omWSGroupHandle != omWSGroup))
    {
        TRACE_OUT(("WSG 0x%x not the OBMAN WSG", omWSGroup));
        DC_QUIT;
    }

    //
    // This event is for us
    //
    fHandled = TRUE;

    //
    // If the workset group was not created locally
    //
    TRACE_OUT(("About to read object 0x%08x in OMC", pObj));

    if (OM_ObjectRead(palPrimary->pomClient, omWSGroup, 0, pObj, &pData) != 0)
    {
        ERROR_OUT(( "Could not access object"));
        DC_QUIT;
    }

    //
    // Take a copy of the information so we can release the object straight
    // away
    //
    memcpy(&WSGInfo, pData, min(sizeof(WSGInfo), pData->length));

    //
    // Release the object
    //
    OM_ObjectRelease(palPrimary->pomClient, omWSGroup, 0, pObj, &pData);

    if (WSGInfo.idStamp != OM_WSGINFO_ID_STAMP)
    {
        TRACE_OUT(( "Not WSG Info - ignoring"));
        DC_QUIT;
    }

    TRACE_OUT(("New WSG FP %s, name %s, ID = 0x%08x in call %d",
            WSGInfo.functionProfile,
            WSGInfo.wsGroupName,
            WSGInfo.wsGroupID,
            palPrimary->callID));

    //
    // Store the UID for the local OBMAN in the new call
    //
    if (!palPrimary->omUID)
    {
        OM_GetNetworkUserID(palPrimary->pomClient, omWSGroup, &(palPrimary->omUID));
    }

    //
    // Ignore workset groups created by the local machine
    //
    if (WSGInfo.creator == palPrimary->omUID)
    {
        TRACE_OUT(("WSG %s created locally - ignoring", WSGInfo.functionProfile));
        DC_QUIT;
    }

    //
    // Is this a workset we care about?  I.E. not a backlevel clipboard
    // or whatever thing.
    //
    fpHandler = OMMapNameToFP(WSGInfo.functionProfile);

    if (fpHandler != OMFP_WB)
    {
        //
        // We don't care about this one.
        //
        TRACE_OUT(("Obsolete workset %s from another party", WSGInfo.functionProfile));
        DC_QUIT;
    }

    //
    // If prevented by policy, don't launch it either.
    //
    if (g_asPolicies & SHP_POLICY_NOOLDWHITEBOARD)
    {
        WARNING_OUT(("Failing auto-launch of old whiteboard; prevented by policy"));
    }
    else
    {
        // Old whiteboard...
        fLoaded = ALStartStopWB(palPrimary, NULL);
        ALLocalLoadResult(palPrimary, fLoaded);
    }

DC_EXIT_POINT:
    DebugExitBOOL(ALNewWorksetGroup, fHandled);
    return(fHandled);
}


//
// ALLocalLoadResult()
//
void ALLocalLoadResult
(
    PAL_PRIMARY     palPrimary,
    BOOL            success
)
{
    PTSHR_AL_LOAD_RESULT    pAlLoadObject;
    POM_OBJECT          pObjNew;
    POM_OBJECTDATA      pDataNew;
    CM_STATUS           cmStatus;

    DebugEntry(ALLocalLoadResult);

    //
    // Have we accessed the workset correctly yet?
    //
    if (!palPrimary->alWorksetOpen && palPrimary->inCall)
    {
        TRACE_OUT(("AL Workset not open yet; deferring local load result"));

        palPrimary->alWBRegPend = TRUE;
        palPrimary->alWBRegSuccess = (success != FALSE);

        DC_QUIT;
    }

    //
    // Clear out pending reg stuff
    //
    palPrimary->alWBRegPend = FALSE;

    //
    // Create an object to be used to inform remote sites of the result of
    // the load.
    //
    if (OM_ObjectAlloc(palPrimary->pomClient, palPrimary->alWSGroupHandle, 0,
            sizeof(*pAlLoadObject), &pDataNew) != 0)
    {
        ERROR_OUT(("Could not allocate AL object for WB load"));
        DC_QUIT;
    }

    //
    // Fill in information about object
    //
    pDataNew->length  = sizeof(*pAlLoadObject);
    pAlLoadObject = (PTSHR_AL_LOAD_RESULT)pDataNew->data;

    //
    // HERE'S WHERE WE MAP the FP constant back to a string
    //
    lstrcpy(pAlLoadObject->szFunctionProfile, OMMapFPToName(OMFP_WB));

    CMS_GetStatus(&cmStatus);
    lstrcpy(pAlLoadObject->personName, cmStatus.localName);
    pAlLoadObject->result = (success ? AL_LOAD_SUCCESS : AL_LOAD_FAIL_BAD_EXE);

    //
    // Add object to Application Loader workset
    //
    if (OM_ObjectAdd(palPrimary->pomClient, palPrimary->alWSGroupHandle, 0,
        &pDataNew, 0, &pObjNew, LAST) != 0)
    {
        ERROR_OUT(("Could not add WB load object to AL WSG"));

        //
        // Free object
        //
        OM_ObjectDiscard(palPrimary->pomClient, palPrimary->alWSGroupHandle,
                0, &pDataNew);
        DC_QUIT;
    }

    //
    // Now that we have added the object - lets delete it!
    //
    // This may sound strange, but every application that has this workset
    // open will receive OBJECT_ADD events and be able to read the object
    // before they confirm the delete.  This means that all the Application
    // Loader primary tasks in the call will be able to record the result
    // of this attempted load.
    //
    // Deleting the object here is the simplest way of tidying up the
    // workset.
    //
    OM_ObjectDelete(palPrimary->pomClient, palPrimary->alWSGroupHandle,
            0, pObjNew);

DC_EXIT_POINT:
    DebugExitVOID(ALLocalLoadResult);
}


//
// ALWorksetRegister()
//
void ALWorksetRegisterCon
(
    PAL_PRIMARY         palPrimary,
    UINT                correlator,
    UINT                result,
    OM_WSGROUP_HANDLE   hWSGroup
)
{
    DebugEntry(ALWorksetRegisterCon);

    ValidateALP(palPrimary);

    //
    // See if this an event for the Application Loader function profile
    //
    if (!palPrimary->inCall ||
        (palPrimary->omWSGCorrelator != correlator))
    {
        TRACE_OUT(( "OM_WSGROUP_REGISTER_CON not for us"));
        DC_QUIT;
    }

    palPrimary->omWSGCorrelator = 0;

    //
    // Store the workset group handle if the registration was successful
    //
    if (result)
    {
        WARNING_OUT(("Could not register with AL function profile, %#hx",
                    result));
        DC_QUIT;
    }

    palPrimary->alWSGroupHandle = hWSGroup;

    TRACE_OUT(("Opened AL workset group, handle 0x%x", hWSGroup));

    //
    // Open workset 0 in the workset group - this will be used to transfer
    // 'load results' from site to site
    //
    OM_WorksetOpenPReq(palPrimary->pomClient,
                            palPrimary->alWSGroupHandle,
                            0,
                            NET_LOW_PRIORITY,
                            FALSE,
                            &palPrimary->omWSCorrelator);

DC_EXIT_POINT:
    DebugExitVOID(ALWorksetRegisterCon);
}



//
// ALRemoteLoadResult()
//
BOOL ALRemoteLoadResult
(
    PAL_PRIMARY         palPrimary,
    OM_WSGROUP_HANDLE   alWSGroup,
    POM_OBJECT          pObj
)
{
    CM_STATUS           cmStatus;
    BOOL                fHandled = FALSE;
    POM_OBJECTDATA      pData = NULL;
    TSHR_AL_LOAD_RESULT alLoadResult;

    DebugEntry(ALRemoteLoadResult);

    ValidateALP(palPrimary);

    //
    // Find the call information stored for this call
    //
    // If the workset group is not in out list of calls, then this event
    // is for a group the Application Loader has registered with.  The
    // event should be passed onto other event procedures.
    //
    if (!palPrimary->inCall ||
        (palPrimary->alWSGroupHandle != alWSGroup))
    {
        TRACE_OUT(("WSG 0x%x not the AL WSG", alWSGroup));
        DC_QUIT;
    }

    //
    // We care
    //
    fHandled = TRUE;

    //
    // Read the object
    //
    if (OM_ObjectRead(palPrimary->pomClient, alWSGroup, 0, pObj, &pData) != 0)
    {
        ERROR_OUT(( "Could not access object"));
        DC_QUIT;
    }

    //
    // Take a copy of the information so we can release the object straight
    // away
    //
    memcpy(&alLoadResult, &pData->data, sizeof(alLoadResult));

    //
    // Release the object
    //
    OM_ObjectRelease(palPrimary->pomClient, alWSGroup, 0, pObj, &pData);

    //
    // Convert the machine name to a person handle for this machine
    //
    TRACE_OUT(("Load result for FP %s is %d for person %s",
           alLoadResult.szFunctionProfile,
           alLoadResult.result,
           alLoadResult.personName));

    //
    // If the load was successful, don't bother notifying WB; it isn't
    // going to do anything.
    //
    if (alLoadResult.result == AL_LOAD_SUCCESS)
    {
        TRACE_OUT(("Load was successful; Whiteboard doesn't care"));
        DC_QUIT;
    }

    //
    // If this was us, also don't notify WB.
    //
    CMS_GetStatus(&cmStatus);
    if (!lstrcmp(alLoadResult.personName, cmStatus.localName))
    {
        TRACE_OUT(("Load was for local dude; Whiteboard doesn't care"));
        DC_QUIT;
    }

    //
    // Map function profile to type
    //
    if (OMMapNameToFP(alLoadResult.szFunctionProfile) == OMFP_WB)
    {
        if (palPrimary->putWB != NULL)
        {
            UT_PostEvent(palPrimary->putTask,
                         palPrimary->putWB,
                         0,
                         ALS_REMOTE_LOAD_RESULT,
                         alLoadResult.result,
                         0);
        }
    }

DC_EXIT_POINT:
    DebugExitBOOL(ALRemoteLoadResult, fHandled);
    return(fHandled);
}



//
// ALStartStopWB()
//
// This takes care of starting/stopping the old Whiteboard applet.  This is
// no longer a separate EXE.  It is now a DLL (though still MFC) which gets
// loaded in CONF's process.  We take care of LoadLibrary()ing it the first
// time it is pulled in, either via normal or auto launch.  Then we call into
// it to get a new thread/window.
//
// By having CONF post a message to the primary task, where autolaunch also
// happens, we get the load synchronized.  It is only ever done from the
// same thread, meaning we don't have to create extra protection for our
// variables.
//
// fNewWB is a TEMP HACK variable to launch the new whiteboard until we
// have the T.120 wiring in place
//
BOOL ALStartStopWB(PAL_PRIMARY palPrimary, LPCTSTR szFileNameCopy)
{
    BOOL    fSuccess;

    DebugEntry(ALStartStopWB);

    if (!palPrimary->putWB)
    {
        //
        // Whiteboard isn't running, we can only start it.
        //
        // This won't return until WB is initialized and registered.
        // We own the AL lock, so we don't have to worry about starting
        // more than one thread at a time, etc.
        //
        DCS_StartThread(OldWBThreadProc);
    }

    fSuccess = (palPrimary->putWB != NULL);
    if (fSuccess)
    {
        UT_PostEvent(palPrimary->putTask, palPrimary->putWB,
            0, ALS_LOCAL_LOAD, 0, (UINT_PTR)szFileNameCopy);
    }

    DebugExitBOOL(ALStartStopWB, fSuccess);
    return(fSuccess);
}



//
// This is the whiteboard thread.  We have the thread code actually in our
// DLL, so we can control when WB is running.  The proc loads the WB dll,
// calls Run(), then frees the dll.
//
DWORD WINAPI OldWBThreadProc(LPVOID hEventWait)
{
    DWORD       rc = 0;
    HMODULE     hLibWB;
    PFNINITWB   pfnInitWB;
    PFNRUNWB    pfnRunWB;
    PFNTERMWB   pfnTermWB;

    DebugEntry(OldWBThreadProc);

    //
    // Load the WB library
    //
    hLibWB = LoadLibrary(TEXT("nmoldwb.dll"));
    if (!hLibWB)
    {
        ERROR_OUT(("Can't start 2.x whiteboard; nmoldwb.dll not loaded"));
        DC_QUIT;
    }

    pfnInitWB = (PFNINITWB)GetProcAddress(hLibWB, "InitWB");
    pfnRunWB = (PFNRUNWB)GetProcAddress(hLibWB, "RunWB");
    pfnTermWB = (PFNTERMWB)GetProcAddress(hLibWB, "TermWB");

    if (!pfnInitWB || !pfnRunWB || !pfnTermWB)
    {
        ERROR_OUT(("Can't start 2.x whiteboard; nmoldwb.dll is wrong version"));
        DC_QUIT;
    }

    //
    // Let WB do its thing.  When it has inited, it will pulse the event,
    // which will let the caller continue.
    //
    if (!pfnInitWB())
    {
        ERROR_OUT(("Couldn't initialize whiteboard"));
    }
    else
    {
        //
        // The AL/OM thread is blocked waiting for us to set the event.
        // It owns the AL critsect.  So we can modify the global variable
        // without taking the critsect.
        //
        ASSERT(g_palPrimary != NULL);

        // Bump up shared mem ref count
        UT_BumpUpRefCount(g_palPrimary);

        // Save WB task for event posting
        ASSERT(g_autTasks[UTTASK_WB].dwThreadId);
        g_palPrimary->putWB = &g_autTasks[UTTASK_WB];

        // Register exit cleanup proc
        UT_RegisterExit(g_palPrimary->putWB, ALSExitProc, NULL);

        //
        // Let the caller continue.  The run code is going to do message
        // loop stuff.
        //
        SetEvent((HANDLE)hEventWait);
        pfnRunWB();

        //
        // This will cleanup if we haven't already
        //
        ALSExitProc(NULL);
    }
    pfnTermWB();

DC_EXIT_POINT:

    if (hLibWB != NULL)
    {
        //
        // Free the WB dll
        //
        FreeLibrary(hLibWB);
    }

    return(0);
}






//
// ALSExitProc()
//
void CALLBACK ALSExitProc(LPVOID data)
{
    DebugEntry(ALSecExitProc);

    UT_Lock(UTLOCK_AL);

    ASSERT(g_palPrimary != NULL);

    //
    // Deregister exit procedure (if registered call UT_DeregisterExit()
    // with ALSecExitProc()).
    //
    UT_DeregisterExit(g_palPrimary->putWB, ALSExitProc, NULL);
    g_palPrimary->putWB = NULL;

    //
    // Bump down ref count on AL primary
    //
    UT_FreeRefCount((void**)&g_palPrimary, TRUE);

    UT_Unlock(UTLOCK_AL);

    DebugExitVOID(ALSExitProc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\bcd.cpp ===
#include "precomp.h"


//
// BCD.CPP
// Bitmap Compression-Decompression
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_ORDER

//
// Introduction
//
// These functions take a bitmap and encode it according to the codes
// defined in bcd.h.  Although there are some complexities in the
// encoding (particularly with the "sliding palette" encoding for
// compressing 8 bit down to 4 bit) the encodings should be self
// explanatory.  bcd describes some nuances of the encoding scheme.
//
// The important thing to note is that, when used in conjunction with a
// dictionary based compression scheme the objective of this function is
// not to minimize the output but to "prime" it such that the GDC can
// perform faster and more effectively on the data.
//
// Specifically we must NOT encode short runs in the data, even though we
// know that they reduce the output from this stage, as they will
// invariably reduce the efficiency of the GDC compression by a greater
// factor!  The break even point seems to be about a 5/6 byte run.  To
// illustrate this, consider the following run
// xxxxyyyyyxxxyyyxxxxxyyyyyyxxxyyyxxxxyyy We would encode this as
// 4x5y3x3y5x5y3x3y4x3y The compression factor is only *2 and yet the
// output data is now much more random - the tokenized look of the input
// has been lost.
//
// Encodings that are not context independent are particularly bad.  A FG
// run in one position may become a SET+FG run in another position, thus
// "randomizing" the data.
//
// Bottom line is that all of the apparently arbitrary numbers below have
// been carefully tuned to prep the data for input to GDC.  Screwing them
// down does increase the compression of this stage in some cases by as
// much as 20%, but loses about 20% post GDC.  Frustrating!  Be warned.
//
//



//
// BCD_ShareStarting()
// Creates resources needed for bitmap compression/decompression
//
BOOL  ASShare::BCD_ShareStarting(void)
{
    BOOL    rc = FALSE;

    DebugEntry(ASShare::BCD_ShareStarting);

    // Allocate BCD scratch buffers
    m_abNormal = new BYTE[BCD_NORMALSIZE];
    if (!m_abNormal)
    {
        ERROR_OUT(("BCD_ShareStarting: failed to alloc m_abNormal"));
        DC_QUIT;
    }

    m_abXor = new BYTE[BCD_XORSIZE];
    if (!m_abXor)
    {
        ERROR_OUT(("BCD_ShareStarting: failed to alloc m_abXor"));
        DC_QUIT;
    }

    m_amatch = new MATCH[BCD_MATCHCOUNT];
    if (!m_amatch)
    {
        ERROR_OUT(("BCD_ShareStarting: failed to alloc m_amatch"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::BCD_ShareStarting, rc);
    return(rc);
}


//
// BCD_ShareEnded()
//
void ASShare::BCD_ShareEnded(void)
{
    DebugEntry(ASShare::BCD_ShareEnded);

    //
    // Free the BCD scratch buffers
    //
    if (m_amatch)
    {
        delete[] m_amatch;
        m_amatch = NULL;
    }

    if (m_abXor)
    {
        delete[] m_abXor;
        m_abXor = NULL;
    }

    if (m_abNormal)
    {
        delete[] m_abNormal;
        m_abNormal = NULL;
    }

    DebugExitVOID(ASShare::BCD_ShareEnded);
}


//
// BC_CompressBitmap(..)
//
BOOL  ASShare::BC_CompressBitmap
(
    LPBYTE      pSrcBitmap,
    LPBYTE      pDstBuffer,
    LPUINT      pDstBufferSize,
    UINT        bitmapWidth,
    UINT        bitmapHeight,
    UINT        cBpp,
    LPBOOL      pLossy
)
{
    BOOL        fCompressedData = FALSE;
    UINT        cbScanWidth;
    PCD_HEADER  pCompDataHeader;
    LPBYTE      pCompData;
    UINT        cbUncompressedDataSize;
    UINT        cbFreeDstBytes;
    UINT        cbCompFirstRowSize;
    UINT        cbCompMainBodySize;

    DebugEntry(ASShare::BC_CompressBitmap);

    //
    // We support 4 and 8 bpp only
    //
    if ((cBpp != 4) && (cBpp != 8))
    {
        TRACE_OUT(("BC_CompressBitmap:  No compression at %d bpp", cBpp));
        DC_QUIT;
    }

    //
    // If we don't have scratch buffers, can't do it either
    // But for now, we just won't enter into a share if we can't allocate
    // themm.
    //
    ASSERT(m_abNormal);
    ASSERT(m_abXor);
    ASSERT(m_amatch);

    cbScanWidth = BYTES_IN_SCANLINE(bitmapWidth, cBpp);

    //
    // Take a local copy of the destination buffer size.
    //
    cbFreeDstBytes = *pDstBufferSize;

    //
    // Calculate the size of the uncompressed src data.
    //
    cbUncompressedDataSize = cbScanWidth * bitmapHeight;

    //
    // Check that the size of the uncompressed data is less than our max.
    //
    ASSERT(cbUncompressedDataSize < TSHR_MAX_SEND_PKT);

    //
    // We write a compressed data header at the start of the dst buffer.
    // Reserve space for it now, and fill in the size of the uncompressed
    // data.
    //
    if (sizeof(CD_HEADER) >= cbFreeDstBytes)
    {
        WARNING_OUT(("BC_CompressBitmap: Dest buffer too small: %d", cbFreeDstBytes));
        DC_QUIT;
    }

    pCompDataHeader = (PCD_HEADER)pDstBuffer;
    pCompDataHeader->cbUncompressedSize = (TSHR_UINT16)cbUncompressedDataSize;
    pCompData = ((LPBYTE)pCompDataHeader) + sizeof(CD_HEADER);
    cbFreeDstBytes -= sizeof(CD_HEADER);

    //
    // Compress the bitmap data.
    // We just pass the complete image into the compression function.
    // The header size in the packet is set to 0 and the whole thing
    // flows as the main body
    //

    cbCompFirstRowSize = 0; // lonchanc: a must for V2
    cbCompMainBodySize = CompressV2Int(pSrcBitmap, pCompData,
            bitmapWidth*bitmapHeight, cBpp, cbScanWidth, cbFreeDstBytes,
            pLossy, m_abNormal, m_abXor, m_amatch);

    if (cbCompMainBodySize == 0)
    {
        WARNING_OUT(("BC_CompressBitmap: Compression failed"));
        DC_QUIT;
    }

    //
    // Fill in the compressed data header.
    //
    pCompDataHeader->cbCompFirstRowSize = (TSHR_UINT16)cbCompFirstRowSize;
    pCompDataHeader->cbCompMainBodySize = (TSHR_UINT16)cbCompMainBodySize;
    pCompDataHeader->cbScanWidth = (TSHR_UINT16)cbScanWidth;

    ASSERT(IsV2CompressedDataHeader(pCompDataHeader));

    //
    // Write back the new (compressed) packet size.
    //
    *pDstBufferSize = sizeof(CD_HEADER) + cbCompFirstRowSize + cbCompMainBodySize;

    TRACE_OUT(("Bitmap Compressed %u bytes to %u",
        cbUncompressedDataSize, *pDstBufferSize));

    fCompressedData = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::BC_CompressBitmap, fCompressedData);
    return(fCompressedData);
}




//
// BD_DecompressBitmap(..)
//
BOOL  ASShare::BD_DecompressBitmap
(
    LPBYTE      pCompressedData,
    LPBYTE      pDstBitmap,
    UINT        cbSrcData,
    UINT        bitmapWidth,
    UINT        bitmapHeight,
    UINT        cBpp
)
{
    BOOL        fDecompressedData = FALSE;
    PCD_HEADER  pCompDataHeader;
    LPBYTE      pCompDataFirstRow;
    LPBYTE      pCompDataMainBody;
    UINT        decompSize;


    DebugEntry(ASShare::BD_DecompressBitmap);

    //
    // We currently support 4 and 8 bpp bitmaps only
    //
    if ((cBpp != 4) && (cBpp != 8))
    {
        ERROR_OUT(("BD_DecompressBitmap: Unsupported bpp %d", cBpp));
        DC_QUIT;
    }


    //
    // Work out the location in the source data of each component.
    //
    pCompDataHeader = (PCD_HEADER)pCompressedData;

    pCompDataFirstRow = (LPBYTE)pCompDataHeader + sizeof(CD_HEADER);
    pCompDataMainBody = pCompDataFirstRow +
                                         pCompDataHeader->cbCompFirstRowSize;
    ASSERT(IsV2CompressedDataHeader(pCompDataHeader));


    TRACE_OUT(( "FirstRowSize(%u) MainBodySize(%u) ScanWidth(%u)",
                                         pCompDataHeader->cbCompFirstRowSize,
                                         pCompDataHeader->cbCompMainBodySize,
                                         pCompDataHeader->cbScanWidth ));

    //
    // Check that the supplied data size matches our expectations.
    //
    if (cbSrcData != sizeof(CD_HEADER) +
                     pCompDataHeader->cbCompFirstRowSize +
                     pCompDataHeader->cbCompMainBodySize )
    {
        ERROR_OUT(("BD_DecompressBitmap: Supplied packet size %u does not match bitmap header",
            cbSrcData));
        DC_QUIT;
    }

    //
    // As with compression, the V2 decompression function just takes
    // the whole image for decompression.
    // THE ABSENCE OF A FIRST LINE COUNT DOES, IN FACT, INDICATE TO US
    // THAT THIS IS A V2 COMPRESSED BITMAP.
    //
    if (pCompDataHeader->cbCompFirstRowSize != 0)
    {
        ERROR_OUT(("BD_DecompressBitmap: Bogus header data"));
    }
    else
    {
        ASSERT(m_abXor);

        decompSize = DecompressV2Int(pCompDataFirstRow, pDstBitmap,
            pCompDataHeader->cbCompMainBodySize, cBpp,
            pCompDataHeader->cbScanWidth, m_abXor);

        TRACE_OUT(("Bitmap Exploded %u bytes from %u", decompSize, cbSrcData));

        fDecompressedData = TRUE;
    }

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::BD_DecompressBitmap, fDecompressedData);
    return(fDecompressedData);
}



//
//
// Create a second copy of the source, which consists of all lines XORed,
// if there is a rowDelta specified
//
// Scan both the non-xored and the xored buffers for matches
//
// A best matches are built up in an array which contains an index to the
// match type, together with the match type.  Non repetetive sequences are
// stored in this array as color image strings.
//
//

//
// The following constant controls the threshold at which we decide that
// a lossy compress is a pointless overhead.  For low bandwidth connections
// DC-Share will always initially request a lossy compress to get some
// data out quickly.  If we find that the percentage of COLOR_IMAGE data
// is below this threshold then we turn off lossy compression for this
// bitmap, redo the analysis, perform non-lossy compression and return
// an indication to the caller that the compression was non-lossy.
//
#define LOSSY_THRESHOLD   75

//
// The following functions have been carefully coded to ensure that the
// 16 bit compiler can minimize its switching of segment registers.
// However, this will not impair its performance on 32 bit systems.
//

//
// Utility macros for encoding orders
//

//
// Encode a combined order and set fg color
//
#define ENCODE_SET_ORDER_MEGA(buffer,                                        \
                              order_code,                                    \
                              length,                                        \
                              mega_order_code,                               \
                              DEF_LENGTH_ORDER,                              \
                              DEF_LENGTH_LONG_ORDER)                         \
        if (length <= DEF_LENGTH_ORDER)                                      \
        {                                                                    \
            *buffer++ = (BYTE)((BYTE)order_code | (BYTE)length);    \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            if (length <= DEF_LENGTH_LONG_ORDER)                             \
            {                                                                \
                *buffer++ = (BYTE)order_code;                             \
                *buffer++ = (BYTE)(length-DEF_LENGTH_ORDER-1);            \
            }                                                                \
            else                                                             \
            {                                                                \
                *buffer++ = (BYTE)mega_order_code;                        \
                INSERT_TSHR_UINT16_UA( buffer, (TSHR_UINT16)length);         \
                buffer += 2;                                                 \
            }                                                                \
        }                                                                    \
        *buffer++ = fgChar;

//
// Encode a combined order and set fg color for a special FGBG image
//
#define ENCODE_SET_ORDER_MEGA_FGBG(buffer,                                   \
                                   order_code,                               \
                                   length,                                   \
                                   mega_order_code,                          \
                                   DEF_LENGTH_ORDER,                         \
                                   DEF_LENGTH_LONG_ORDER)                    \
        if (((length & 0x0007) == 0) &&                                      \
            (length <= DEF_LENGTH_ORDER))                                    \
        {                                                                    \
            *buffer++ = (BYTE)((BYTE)order_code | (BYTE)(length/8));\
        }                                                                    \
        else                                                                 \
        {                                                                    \
            if (length <= DEF_LENGTH_LONG_ORDER)                             \
            {                                                                \
                *buffer++ = (BYTE)order_code;                             \
                *buffer++ = (BYTE)(length-1);                             \
            }                                                                \
            else                                                             \
            {                                                                \
                *buffer++ = (BYTE)mega_order_code;                        \
                INSERT_TSHR_UINT16_UA( buffer, (TSHR_UINT16)length);         \
                buffer += 2;                                                 \
            }                                                                \
        }                                                                    \
        *buffer++ = fgChar;


//
// Encode an order for a standard run
//
#define ENCODE_ORDER_MEGA(buffer,                                            \
                          order_code,                                        \
                          length,                                            \
                          mega_order_code,                                   \
                          DEF_LENGTH_ORDER,                                  \
                          DEF_LENGTH_LONG_ORDER)                             \
        if (length <= DEF_LENGTH_ORDER)                                      \
        {                                                                    \
            *buffer++ = (BYTE)((BYTE)order_code | (BYTE)length);    \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            if (length <= DEF_LENGTH_LONG_ORDER)                             \
            {                                                                \
                *buffer++ = (BYTE)order_code;                             \
                *buffer++ = (BYTE)(length-DEF_LENGTH_ORDER-1);            \
            }                                                                \
            else                                                             \
            {                                                                \
                *buffer++ = (BYTE)mega_order_code;                        \
                INSERT_TSHR_UINT16_UA( buffer, (TSHR_UINT16)length);         \
                buffer += 2;                                                 \
            }                                                                \
        }

//
// Encode a special FGBG image
//
#define ENCODE_ORDER_MEGA_FGBG(buffer,                                       \
                          order_code,                                        \
                          length,                                            \
                          mega_order_code,                                   \
                          DEF_LENGTH_ORDER,                                  \
                          DEF_LENGTH_LONG_ORDER)                             \
        if (((length & 0x0007) == 0) &&                                      \
            (length <= DEF_LENGTH_ORDER))                                    \
        {                                                                    \
            *buffer++ = (BYTE)((BYTE)order_code | (BYTE)(length/8));\
        }                                                                    \
        else                                                                 \
        {                                                                    \
            if (length <= DEF_LENGTH_LONG_ORDER)                             \
            {                                                                \
                *buffer++ = (BYTE)order_code;                             \
                *buffer++ = (BYTE)(length-1);                             \
            }                                                                \
            else                                                             \
            {                                                                \
                *buffer++ = (BYTE)mega_order_code;                        \
                INSERT_TSHR_UINT16_UA( buffer, (TSHR_UINT16)length);         \
                buffer += 2;                                                 \
            }                                                                \
        }

//
// Macros to extract the length from order codes
//
#define EXTRACT_LENGTH(buffer, length)                                       \
        length = *buffer++ & MAX_LENGTH_ORDER;                               \
        if (length == 0)                                                     \
        {                                                                    \
            length = *buffer++ + MAX_LENGTH_ORDER + 1;                       \
        }

#define EXTRACT_LENGTH_LITE(buffer, length)                                  \
        length = *buffer++ & MAX_LENGTH_ORDER_LITE;                          \
        if (length == 0)                                                     \
        {                                                                    \
            length = *buffer++ + MAX_LENGTH_ORDER_LITE + 1;                  \
        }

#define EXTRACT_LENGTH_FGBG(buffer, length)                                  \
        length = *buffer++ & MAX_LENGTH_ORDER;                               \
        if (length == 0)                                                     \
        {                                                                    \
            length = *buffer++ + 1;                                          \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            length = length << 3;                                            \
        }

#define EXTRACT_LENGTH_FGBG_LITE(buffer, length)                             \
        length = *buffer++ & MAX_LENGTH_ORDER_LITE;                          \
        if (length == 0)                                                     \
        {                                                                    \
            length = *buffer++ + 1;                                          \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            length = length << 3;                                            \
        }

//
// RunSingle
//
// Determine the length of the current run
//
// RunSingle may only be called if the buffer has at least four
// consecutive identical bytes from the start position
//
// For 16 bit processing there are two versions of this macro.  For 32
// bit the nulling of NEAR/FAR will make them the same.
//
#define RUNSINGLE_XOR(buffer, length, result)                                \
     {                                                                       \
         BYTE NEAR *buf    = buffer+4;                                    \
         BYTE NEAR *endbuf = buffer+length-4;                             \
         while ((buf < endbuf) &&                                            \
                (EXTRACT_TSHR_UINT32_UA(buf) == EXTRACT_TSHR_UINT32_UA(buf-4)))  \
         {                                                                   \
             buf += 4;                                                       \
         }                                                                   \
         endbuf += 4;                                                        \
         while(buf < endbuf && (*buf == *(buf-1)))                           \
         {                                                                   \
             buf++;                                                          \
         }                                                                   \
         result = (DWORD)(buf - (buffer));                                            \
     }

#define RUNSINGLE_NRM(buffer, length, result)                                \
     {                                                                       \
         BYTE FAR *buf    = buffer+4;                                     \
         BYTE FAR *endbuf = buffer+length-4;                              \
         while ((buf < endbuf) &&                                            \
                (EXTRACT_TSHR_UINT32_UA(buf) == EXTRACT_TSHR_UINT32_UA(buf-4)))  \
         {                                                                   \
             buf += 4;                                                       \
         }                                                                   \
         endbuf += 4;                                                        \
         while(buf < endbuf && (*buf == *(buf-1)))                           \
         {                                                                   \
             buf++;                                                          \
         }                                                                   \
         result = (DWORD)(buf - (buffer));                                            \
     }


//
// RunDouble
//
// Determine the length of the current run of paired bytes
//
#define RunDouble(buffer, length, result)                                    \
    {                                                                        \
        int   len  = ((int)length);                                      \
        BYTE FAR *buf = buffer;                                           \
        BYTE testchar1 = *buf;                                            \
        BYTE testchar2 = *(buf+1);                                        \
        result = 0;                                                          \
        while(len > 1)                                                       \
        {                                                                    \
            if (*buf++ != testchar1)                                         \
            {                                                                \
                break;                                                       \
            }                                                                \
            if (*buf++ != testchar2)                                         \
            {                                                                \
                break;                                                       \
            }                                                                \
            result += 2;                                                     \
            len    -= 2;                                                     \
        }                                                                    \
    }


//
// RUNFGBG
//
// Determine the length of the run of bytes that consist
// only of black or a single FG color
// We exit the loop when
// - the next character is not a fg or bg color
// - we hit a run of 24 of the FG or BG color
// 24 may seem excessive, but note the following sample compression:
//                12     16     20     24     28
// Pre GDC       3845   3756   3712   3794   3822
// Post GDC      2401   2313   2286   2189   2209
//
//
#define RUNFGBG(buffer, length, result, work)                                \
    {                                                                        \
        BYTE NEAR *buf = buffer;                                          \
        BYTE NEAR *endbuf = buffer + length;                              \
        result = 0;                                                          \
        work = *buf;                                                         \
        while (TRUE)                                                         \
        {                                                                    \
            buf++;                                                           \
            result++;                                                        \
            if (buf >= endbuf)                                               \
            {                                                                \
                break;                                                       \
            }                                                                \
                                                                             \
            if ((*buf != work) && (*buf != 0))                               \
            {                                                                \
                break;                                                       \
            }                                                                \
                                                                             \
            if ((result & 0x0007) == 0)                                      \
            {                                                                \
                if ((*buf == *(buf+1)) &&                                    \
                    (EXTRACT_TSHR_UINT16_UA(buf) ==                            \
                                            EXTRACT_TSHR_UINT16_UA(buf+ 2)) && \
                    (EXTRACT_TSHR_UINT32_UA(buf) ==                            \
                                            EXTRACT_TSHR_UINT32_UA(buf+ 4)) && \
                    (EXTRACT_TSHR_UINT32_UA(buf) ==                            \
                                            EXTRACT_TSHR_UINT32_UA(buf+ 8)) && \
                    (EXTRACT_TSHR_UINT32_UA(buf) ==                            \
                                            EXTRACT_TSHR_UINT32_UA(buf+12)) && \
                    (EXTRACT_TSHR_UINT32_UA(buf) ==                            \
                                            EXTRACT_TSHR_UINT32_UA(buf+16)) && \
                    (EXTRACT_TSHR_UINT32_UA(buf) ==                            \
                                            EXTRACT_TSHR_UINT32_UA(buf+20)) )  \
                {                                                            \
                    break;                                                   \
                }                                                            \
            }                                                                \
        }                                                                    \
    }

//
// Determine whether a run is better than any previous run
// For efficiency we take any run of 32 pels or more without looking
// further.
//
#define CHECK_BEST_RUN(run_type, run_length, bestrun_length, bestrun_type)   \
        if (run_length > bestrun_length)                                     \
        {                                                                    \
            bestrun_length = run_length;                                     \
            bestrun_type = run_type;                                         \
            if (bestrun_length >= 32)                                        \
            {                                                                \
                break;                                                       \
            }                                                                \
        }

//
// SETFGCHAR
//
// Set up a new value in fgChar and recalculate the shift
//
#define CHECK_WORK(workchar)

#define SETFGCHAR(newchar, curchar, curshift)                                \
     curchar    = newchar;                                                   \
     {                                                                       \
         BYTE workchar = curchar;                                         \
         curshift = 0;                                                       \
         CHECK_WORK(workchar);                                               \
         while ((workchar & 0x01) == 0)                                      \
         {                                                                   \
             curshift++;                                                     \
             workchar = (BYTE)(workchar>>1);                              \
         }                                                                   \
     }


//
// Macro to store an FGBG image
//
#define STORE_FGBG(xorbyte, fgbgChar, fgChar, bits)                          \
      {                                                                      \
        UINT   numbits = bits;                                             \
        if (fgbgChar & 0x01)                                                 \
        {                                                                    \
            *destbuf++ = (BYTE)(xorbyte ^ fgChar);                        \
        }                                                                    \
        else                                                                 \
        {                                                                    \
            *destbuf++ = xorbyte;                                            \
        }                                                                    \
        if (--numbits > 0)                                                   \
        {                                                                    \
          if (fgbgChar & 0x02)                                               \
          {                                                                  \
              *destbuf++ = (BYTE)(xorbyte ^ fgChar);                      \
          }                                                                  \
          else                                                               \
          {                                                                  \
              *destbuf++ = xorbyte;                                          \
          }                                                                  \
          if (--numbits > 0)                                                 \
          {                                                                  \
            if (fgbgChar & 0x04)                                             \
            {                                                                \
                *destbuf++ = (BYTE)(xorbyte ^ fgChar);                    \
            }                                                                \
            else                                                             \
            {                                                                \
                *destbuf++ = xorbyte;                                        \
            }                                                                \
            if (--numbits > 0)                                               \
            {                                                                \
              if (fgbgChar & 0x08)                                           \
              {                                                              \
                  *destbuf++ = (BYTE)(xorbyte ^ fgChar);                  \
              }                                                              \
              else                                                           \
              {                                                              \
                  *destbuf++ = xorbyte;                                      \
              }                                                              \
              if (--numbits > 0)                                             \
              {                                                              \
                if (fgbgChar & 0x10)                                         \
                {                                                            \
                    *destbuf++ = (BYTE)(xorbyte ^ fgChar);                \
                }                                                            \
                else                                                         \
                {                                                            \
                    *destbuf++ = xorbyte;                                    \
                }                                                            \
                if (--numbits > 0)                                           \
                {                                                            \
                  if (fgbgChar & 0x20)                                       \
                  {                                                          \
                      *destbuf++ = (BYTE)(xorbyte ^ fgChar);              \
                  }                                                          \
                  else                                                       \
                  {                                                          \
                      *destbuf++ = xorbyte;                                  \
                  }                                                          \
                  if (--numbits > 0)                                         \
                  {                                                          \
                    if (fgbgChar & 0x40)                                     \
                    {                                                        \
                        *destbuf++ = (BYTE)(xorbyte ^ fgChar);            \
                    }                                                        \
                    else                                                     \
                    {                                                        \
                        *destbuf++ = xorbyte;                                \
                    }                                                        \
                    if (--numbits > 0)                                       \
                    {                                                        \
                      if (fgbgChar & 0x80)                                   \
                      {                                                      \
                          *destbuf++ = (BYTE)(xorbyte ^ fgChar);          \
                      }                                                      \
                      else                                                   \
                      {                                                      \
                          *destbuf++ = xorbyte;                              \
                      }                                                      \
                    }                                                        \
                  }                                                          \
                }                                                            \
              }                                                              \
            }                                                                \
          }                                                                  \
        }                                                                    \
      }


//
// ENCODEFGBG
//
// Encode 8 bytes of FG and black into a one byte bitmap representation
//
// The FgChar will always be non-zero, and therefore must have at least one
// bit set.
//
// We arrange that all bytes have this bit in their lowest position
//
// The zero pels will still have a 0 in the lowest bit.
//
// Getting the result is a 4 stage process
//
//  1) Get the wanted bits into bit 0 of each byte
//
//  <***************work1*****************>
//  31 0
//  0000 000d 0000 000c 0000 000b 0000 000a
//          ^ ^ ^ ^
//  <***************work2*****************>
//  31 0
//  0000 000h 0000 000g 0000 000f 0000 000e
//          ^ ^ ^ ^
//
// a..h = bits that we want to output
//
// We just need to collect the indicated bits and squash them into a single
// byte.
//
//  2) Compress down to 32 bits
//
//  <***************work1*****************>
//  31 0
//  000h 000d 000g 000c 000f 000b 000e 000a
//     ^ ^ ^ ^ ^ ^ ^ ^
//
//  3) Compress down to 16 bits
//
//  <******work*******>
//  15 0
//  0h0f 0d0b 0g0e 0c0a
//     ^ ^ ^ ^
//
//  4) Compress down to 8 bits
//
//  hgfedcba
//
#define ENCODEFGBG(result)                                                   \
{                                                                            \
    UINT work1;                                                          \
    UINT work2;                                                          \
    UINT   work;                                                           \
                                                                             \
    work1 = (((UINT)(xorbuf[srcOffset])        ) |                       \
             ((UINT)(xorbuf[srcOffset+1]) <<  8) |                       \
             ((UINT)(xorbuf[srcOffset+2]) << 16) |                       \
             ((UINT)(xorbuf[srcOffset+3]) << 24));                       \
    work2 = (((UINT)(xorbuf[srcOffset+4])      ) |                       \
             ((UINT)(xorbuf[srcOffset+5]) <<  8) |                       \
             ((UINT)(xorbuf[srcOffset+6]) << 16) |                       \
             ((UINT)(xorbuf[srcOffset+7]) << 24));                       \
                                                                             \
    work1 = (work1 >> fgShift) & 0x01010101;                                 \
    work2 = (work2 >> fgShift) & 0x01010101;                                 \
                                                                             \
    work1 = (work2 << 4) | work1;                                            \
                                                                             \
    work = work1 | (work1 >> 14);                                            \
                                                                             \
    result = ((BYTE)(((BYTE)(work>>7)) | ((BYTE)work)));            \
}


//
// Unpack4bpp
//
// Convert a 4bpp bitmap into an 8bpp one
//
void  Unpack4bpp(LPBYTE destbuf,
                                     LPBYTE srcbuf,
                                     UINT   srclen)
{
    do
    {
        *destbuf++ = (BYTE)((*srcbuf) >> 4);
        *destbuf++ = (BYTE)((*srcbuf) & 0x0F);
        srcbuf++;
    } while (--srclen > 0);
}

//
// Pack4bpp
//
// Convert an 8bpp bitmap back to 4bpp
//
void  Pack4bpp(LPBYTE destbuf,
                                   LPBYTE srcbuf,
                                   UINT   srclen)
{
    BYTE work1, work2;

    DebugEntry(Pack4bpp);

    while (srclen > 1)
    {
        work1  = (BYTE)(*srcbuf++ << 4);
        work2  = (BYTE)(*srcbuf++ & 0x0F);
        *destbuf++ = (BYTE)(work1 | work2);
        srclen -= 2;
    }
    if (srclen > 0)
    {
        *destbuf++ = (BYTE)(*srcbuf++ << 4);
    }

    DebugExitVOID(Pack4bpp);
}

//
// XORBuffer
//
// Create an XOR image of the input bitmap
//
// Note: This function assumes that rowDelta is always a multiple of 4, and
// that destbuf and srcbuf start on a 4 byte boundary.  It does not deal
// with unaligned accesses if this is not true.
//
void  XORBuffer(BYTE  NEAR *destbuf,
                                    BYTE  FAR  *srcbuf,
                                    UINT   srclen,
                                    int    rowDelta)
{
    UINT NEAR *dwdest = (UINT NEAR *)destbuf;

    DebugEntry(XORBuffer);


    ASSERT((rowDelta % 4 == 0));
    ASSERT((((UINT_PTR)destbuf) % 4 == 0));
    ASSERT((((UINT_PTR)srcbuf) % 4 == 0));

    while (srclen > 8)
    {
        *dwdest++ = *((LPUINT)srcbuf) ^ *((LPUINT)(srcbuf+rowDelta));
        srclen -= 4;
        srcbuf += 4;
        *dwdest++ = *((LPUINT)srcbuf) ^ *((LPUINT)(srcbuf+rowDelta));
        srclen -= 4;
        srcbuf += 4;
    }
    if (srclen)
    {
        destbuf = (BYTE NEAR *)dwdest;
        while(srclen)
        {
            *destbuf++ = (BYTE)(*srcbuf++ ^  *(srcbuf+rowDelta));
            srclen--;
        }
    }

    DebugExitVOID(XORBuffer);
}

//
// CompressV2Int
//
// Internal compresssion function
//
// The work buffer addresses are moved onto the stack, thus eliminating any
// need to use DS to address the default data segment.  This allows the
// compiler to perform more general optimizations.
//
UINT    CompressV2Int(LPBYTE pSrc,
                                          LPBYTE pDst,
                                          UINT   numPels,
                                          UINT   bpp,
                                          UINT   rowDelta,
                                          UINT   dstBufferSize,
                                          LPBOOL  pLossy,
                                          LPBYTE  nrmbuf,
                                          LPBYTE  xorbuf,
                                          MATCH    FAR  *match)
{

    int     i;
    UINT    srcOffset;
    UINT    matchindex;
    UINT    bestRunLength;
    UINT    nextRunLength;
    UINT    runLength;
    UINT    bestFGRunLength;
    UINT    checkFGBGLength;
    UINT    scanCount;
    BOOL    firstLine;
    UINT    saveNumPels;
    BOOL    saveLossy;
    BOOL    lossy;
    BYTE   bestRunType      = 0;
    LPBYTE  destbuf          = pDst;
    BYTE   fgChar           = 0xFF;
    BYTE   fgCharWork       = 0xFF;
    BYTE   fgShift          = 0;
    BOOL    lossyStarted     = FALSE;
    BOOL    inColorRun       = FALSE;
    UINT    compressedLength = 0;

    DebugEntry(CompressV2Int);

    //
    // Validate the line length
    //
    if ((numPels < rowDelta) ||
        (rowDelta & 0x0003) ||
        (numPels & 0x0003))
    {
        WARNING_OUT(( "Lines must be a multiple of 4 pels"));
        DC_QUIT;
    }

    //
    // First create the character and XOR buffers
    //
    if (bpp == 4)
    {
        Unpack4bpp(nrmbuf, pSrc, numPels/2);

    }
    else
    {
        nrmbuf = pSrc;
    }

    //
    // Set up the first portion of the XORBUF to contain the source buffer
    //
    memcpy(xorbuf, nrmbuf, rowDelta);

    //
    // Calculate the rest of the XOR buffer
    //
    XORBuffer( xorbuf+rowDelta,
               nrmbuf+rowDelta,
               numPels-rowDelta,
               -(int)rowDelta);

    //
    // Loop processing the input
    // We perform the loop twice, the first time for the non-xor portion
    // of the buffer and the second for the XOR portion
    // Note that we start the run at a match index of 2 to avoid having
    // to special case the startup condition in some of the match
    // merging code
    // The first time through is always a non-lossy pass.  If we find
    // enough incompressible data then we redo the compression in lossy
    // mode.  To achieve this we set saveLossy = FALSE here and reset it
    // following the first scan.
    //
    saveLossy     = FALSE;

RESTART_COMPRESSION_IN_LOSSY_MODE:
    srcOffset     = 0;
    firstLine     = TRUE;
    match[0].type = 0;
    match[1].type = 0;
    matchindex    = 2;
    saveNumPels   = numPels;

    //
    // Until we enter XOR mode we do not allow lossy compression on a
    // non-XOR request so set up to process just the first line.
    // Also, if the user is requesting a lossy compression then we
    // perform an initial full non-lossy pass to see if the request is
    // worthwhile.
    //
    lossy   = FALSE;
    numPels = rowDelta;

    for (scanCount = 0; scanCount < 2; scanCount++)
    {

        while (srcOffset < numPels)
        {
            //
            // Give up if we are nearing the end of the match array
            //
            if (matchindex >= BCD_MATCHCOUNT)
            {
                DC_QUIT;
            }

            //
            // Start a while loop to allow a more structured break when we
            // hit the first run type we want to encode (We can't afford
            // the overheads of a function call to provide the scope here.)
            //
            while (TRUE)
            {
                bestRunLength      = 0;
                bestFGRunLength    = 0;

                //
                // If we are hitting the end of the buffer then just take
                // color characters now - take them one at a time so that
                // lossy encoding still works.  We will only hit this
                // condition if we break out of a run just before the end
                // of the buffer, so this should not be too common a
                // situation, which is good given that we are encoding the
                // final 6 bytes uncompressed.
                //
                if (srcOffset+6 >= numPels)
                {
                    bestRunType = IMAGE_COLOR;
                    bestRunLength = 1;
                    break;
                }

                //
                // First do the scans on the XOR buffer.  Look for a
                // character run or a BG run.  Note that if there is no row
                // delta then xorbuf actually points to the normal buffer.
                // We must do the test independent of how long the run
                // might be because even for a 1 pel BG run our later logic
                // requires that we detect it seperately.  This code is
                // absolute main path so fastpath as much as possible.  In
                // particular detect short bg runs early and allow
                // RunSingle to presuppose at least 4 matching bytes
                //
                if (xorbuf[srcOffset] == 0x00)
                {
                    if (((srcOffset+1) >= numPels) ||
                        (xorbuf[srcOffset+1] != 0x00))
                    {
                        bestRunType = RUN_BG;
                        bestRunLength = 1;
                        if (!inColorRun)
                        {
                            break;
                        }
                    }
                    else
                    {
                        if (((srcOffset+2) >= numPels) ||
                            (xorbuf[srcOffset+2] != 0x00))
                        {
                            bestRunType = RUN_BG;
                            bestRunLength = 2;
                            if (!inColorRun)
                            {
                                break;
                            }
                        }
                        else
                        {
                            if (((srcOffset+3) >= numPels) ||
                                (xorbuf[srcOffset+3] != 0x00))
                            {
                                bestRunType = RUN_BG;
                                bestRunLength = 3;
                                if (!inColorRun)
                                {
                                    break;
                                }
                            }
                            else
                            {
                                RUNSINGLE_XOR(xorbuf+srcOffset,
                                             numPels-srcOffset,
                                             bestFGRunLength);
                                CHECK_BEST_RUN(RUN_BG,
                                               bestFGRunLength,
                                               bestRunLength,
                                               bestRunType);
                                if (!inColorRun)
                                {
                                     break;
                                }
                            }
                        }
                    }
                }
                else
                {
                    //
                    // No point in starting if FG run less than 4 bytes so
                    // check the first dword as quickly as possible Note
                    // that we don't need to check for an end-buffer
                    // condition here because our XOR buffer always has
                    // some free space at the end and the RUNSINGLE_XOR
                    // will break at the correct place
                    //
                    if ( (xorbuf[srcOffset] == xorbuf[srcOffset+1]) &&
                         (xorbuf[srcOffset] == xorbuf[srcOffset+2]) &&
                         (xorbuf[srcOffset] == xorbuf[srcOffset+3]) )
                    {
                        RUNSINGLE_XOR(xorbuf+srcOffset,
                                     numPels-srcOffset,
                                     bestFGRunLength);
                        //
                        // Don't permit a short FG run to prevent a FGBG
                        // image from starting up.  Only take if >= 5
                        //
                        if (bestFGRunLength > 5)
                        {
                            CHECK_BEST_RUN(RUN_FG,
                                           bestFGRunLength,
                                           bestRunLength,
                                           bestRunType);
                        }
                    }
                }


                //
                // Look for sequences in the non XOR buffer In this case we
                // insist upon a run of at least 6 pels
                //
                if ( (nrmbuf[srcOffset]     == nrmbuf[srcOffset + 2]) &&
                     (nrmbuf[srcOffset]     == nrmbuf[srcOffset + 4]) &&
                     (nrmbuf[srcOffset + 1] == nrmbuf[srcOffset + 3]) &&
                     (nrmbuf[srcOffset + 1] == nrmbuf[srcOffset + 5]) )
                {
                    //
                    // Now do the scan on the normal buffer for a character
                    // run Don't bother if first line because we will have
                    // found it already in the XOR buffer, since we just
                    // copy nrmbuf to xorbuf for the first line
                    //
                    if (*(nrmbuf+srcOffset) == *(nrmbuf+srcOffset+1))
                    {
                        if (!firstLine)
                        {
                            RUNSINGLE_NRM(nrmbuf+srcOffset,
                                         numPels-srcOffset,
                                         nextRunLength);
                            if (nextRunLength > 5)
                            {
                                CHECK_BEST_RUN(RUN_COLOR,
                                               nextRunLength,
                                               bestRunLength,
                                               bestRunType);
                            }
                        }
                    }
                    else
                    {
                        //
                        // Look for a dither on the nrm buffer Dithers are
                        // not very efficient for short runs so only take
                        // if 8 or longer
                        //
                        RunDouble(nrmbuf+srcOffset,
                                  numPels-srcOffset,
                                  nextRunLength);
                        if (nextRunLength > 9)
                        {
                            CHECK_BEST_RUN(RUN_DITHER,
                                           nextRunLength,
                                           bestRunLength,
                                           bestRunType);
                        }
                    }
                }

                //
                // If nothing so far then look for a FGBG run (The 6 is
                // carefully tuned!)
                //
                if (bestRunLength < 6)
                {
                    //
                    // But first look for a single fg bit breaking up a BG
                    // run.  If so then encode a BG run.  Careful of the
                    // enforced BG run break across the first line
                    // non-XOR/XOR boundary.
                    //
                    if ((EXTRACT_TSHR_UINT32_UA(xorbuf+srcOffset+1) == 0) &&
                        (*(xorbuf+srcOffset) == fgChar) &&
                        (match[matchindex-1].type == RUN_BG) &&
                        (srcOffset != (TSHR_UINT16)rowDelta))
                    {
                        RUNSINGLE_XOR(xorbuf+srcOffset+1,
                                     numPels-srcOffset-1,
                                     nextRunLength);
                        nextRunLength++;
                        CHECK_BEST_RUN(RUN_BG_PEL,
                                       nextRunLength,
                                       bestRunLength,
                                       bestRunType);
                    }
                    else
                    {
                        //
                        // If we have not found a run then look for a FG/BG
                        // image.  The disruptive effect of a short FGBG
                        // run on GDC is such that it is worth preventing
                        // one unless we are certain of the benefits.
                        // However, if the alternative is a color run then
                        // allow a lower value.
                        //
                        RUNFGBG( xorbuf+srcOffset,
                                 numPels-srcOffset,
                                 nextRunLength,
                                 fgCharWork );

                        checkFGBGLength = 48;
                        if (fgCharWork == fgChar)
                        {
                            checkFGBGLength -= 16;
                        }
                        if ((nextRunLength & 0x0007) == 0)
                        {
                            checkFGBGLength -= 8;
                        }
                        if (nextRunLength >= checkFGBGLength)
                        {
                            CHECK_BEST_RUN(IMAGE_FGBG,
                                           nextRunLength,
                                           bestRunLength,
                                           bestRunType);
                        }
                    }
                }

                //
                // If nothing useful so far then allow a short run, if any
                // Don't do this if we are accumulating a color run because
                // it will really mess up GDC compression if we allow lots
                // of little runs.  Also require that it is a regular short
                // run, rather than one that disturbs the fgChar
                //
                if (!inColorRun)
                {
                    if (bestRunLength < 6)
                    {
                        if ((bestFGRunLength > 4) &&
                            (xorbuf[srcOffset] == fgChar))
                        {
                            if (match[matchindex-1].type == RUN_FG)
                            {
                                match[matchindex-1].length += (WORD)bestFGRunLength;
                                srcOffset += bestFGRunLength;
                                continue;
                            }
                            else
                            {
                                bestRunLength = bestFGRunLength;
                                bestRunType   = RUN_FG;
                            }

                        }
                        else
                        {
                            //
                            // If we decided to take a run earlier then
                            // allow it now.  (May be a short BG run, for
                            // example) If nothing so far then take color
                            // image)
                            //
                            if (bestRunLength == 0)
                            {
                                bestRunType = IMAGE_COLOR;
                                bestRunLength = 1;
                            }

                        }
                    }
                }
                else
                {
                    //
                    // May seem restrictive, but it is important for our
                    // lossy compression that a color run is rather
                    // "sticky", in particular not broken by random FGBG
                    // runs which do appear from time to time.
                    //
                    if (lossy)
                    {
                        if ((bestRunLength < 8) ||
                            ((bestRunType == IMAGE_FGBG) &&
                             (bestRunLength < 16)))

                        {
                            bestRunType = IMAGE_COLOR;
                            bestRunLength = 1;
                        }
                    }
                    else
                    {
                        if ((bestRunLength < 6) ||
                            ((bestRunType != RUN_BG) && (bestRunLength < 8)))
                        {
                            bestRunType = IMAGE_COLOR;
                            bestRunLength = 1;
                        }
                    }
                }

                break;
            }

            //
            // When we get here we have found the best run.  Now check for
            // various amalamation conditions with the previous run type.
            // Note that we may already have done amalgamation of short
            // runs, but we had to do multiple samples for the longer runs
            // so we repeat the checks here
            //

            //
            // If we are encoding a color run then
            //     - process it for lossy compression
            //     - combine it with an existing run if possible
            //
            if (bestRunType == IMAGE_COLOR)
            {
                //
                // Flag that we are within a color run
                //
                inColorRun = TRUE;

                //
                // If we are doing a lossy compression then process
                // even/odd lines differently
                //
                if (lossy)
                {
                    //
                    // For even lines duplicate every other character,
                    // discarding the original value
                    //
                    if (((srcOffset/rowDelta)%2) == 0)
                    {
                        if ((match[matchindex-1].type == IMAGE_COLOR) &&
                            (match[matchindex-1].length%2 == 1))
                        {
                            nrmbuf[srcOffset] = nrmbuf[srcOffset-1];
                            //
                            // If we are not on the final line of the
                            // bitmap then propagate the update down to the
                            // next XORed line
                            //
                            if (numPels-srcOffset > rowDelta)
                            {
                                xorbuf[srcOffset+rowDelta] =
                                        (BYTE)(nrmbuf[srcOffset+rowDelta] ^
                                                  nrmbuf[srcOffset]);
                            }
                        }
                    }
                    else
                    {
                        //
                        // For odd lines we will just encode nulls which
                        // will replicate the previous line.  However, if
                        // the last run was a BG run then we will
                        // inadvertently insert a pel, so if we hit this
                        // situation then leave a single color char
                        //
                        bestRunType = IMAGE_LOSSY_ODD;

                        //
                        // No need to adjust the buffers for this, except
                        // to update the next XOR line to reflect the fact
                        // that the decoder will be operating on a
                        // replicated line.  Therefore we replace the
                        // character in the next line of the XOR buffer
                        // with the value it would have if the current line
                        // was identical with the previous line
                        //
                        if (numPels-srcOffset > (TSHR_UINT16)rowDelta)
                        {
                            xorbuf[srcOffset+rowDelta] =
                                     (BYTE)(nrmbuf[srcOffset+rowDelta] ^
                                               nrmbuf[srcOffset-rowDelta]);
                        }
                    }
                }

                //
                // Merge the color run immediately, if possible
                //
                if (match[matchindex-1].type == bestRunType)
                {
                    match[matchindex-1].length += (WORD)bestRunLength;
                    srcOffset += bestRunLength;
                    continue;
                }
            }
            else
            {
                //
                // We are no longer encoding a COLOR_IMAGE of any kind
                //
                inColorRun = FALSE;

                //
                // Keep track of the fg Color The macro that searches for
                // FGBG runs leaves the character in fgCharWork.
                //
                if (bestRunType == RUN_FG)
                {
                    fgChar = xorbuf[srcOffset];
                }
                else
                {
                    if (bestRunType == IMAGE_FGBG)
                    {
                        fgChar = fgCharWork;
                    }
                }
            }

            //
            // If we can amalgamate the entry then do so without creating a
            // new array entry.  We must amalgamate a lossy ODD with a
            // RUN_BG because otherwise the lossy would trigger a pel
            // insertion.  Our search for FGBG runs is dependent upon that
            // type of run being amalgamated because we break every 64
            // characters so that our mode switch detection works OK.
            //
            // Take care not to merge across the non-xor/xor boundary
            //
            if (srcOffset == (TSHR_UINT16)rowDelta)
            {
                //
                // Just bump the source offset
                //
                srcOffset += bestRunLength;
            }
            else
            {
                //
                // Bump srcOffset and try a merge
                //
                srcOffset += bestRunLength;

                //
                // The simpler merges are where the types are identical
                //
                if (bestRunType == match[matchindex-1].type)
                {
                    //
                    // COLOR IMAGES and BG images are trivial
                    //
                    if ((bestRunType == IMAGE_LOSSY_ODD)    ||
                        (bestRunType == RUN_BG))
                    {
                        match[matchindex-1].length += (WORD)bestRunLength;
                        continue;
                    }

                    //
                    // FG runs and FGBG images merge if fgChars match
                    //
                    if (((bestRunType == RUN_FG) ||
                         (bestRunType == IMAGE_FGBG)) &&
                        (fgChar  == match[matchindex-1].fgChar))
                    {
                        match[matchindex-1].length += (WORD)bestRunLength;
                        TRACE_OUT(( "Merged %u with preceding, giving %u",
                                 match[matchindex-1].type,
                                 match[matchindex-1].length));
                        continue;
                    }
                }

                //
                // BG RUNs merge with LOSSY odd lines It is important that
                // we do this merging because otherwise we will get
                // inadvertent pel insertion due to the broken BG runs.
                //
                if (((bestRunType == RUN_BG) ||
                     (bestRunType == IMAGE_LOSSY_ODD)) &&
                    ((match[matchindex-1].type == RUN_BG) ||
                     (match[matchindex-1].type == IMAGE_LOSSY_ODD) ||
                     (match[matchindex-1].type == RUN_BG_PEL)))
                {
                    match[matchindex-1].length += (WORD)bestRunLength;
                    continue;
                }

                //
                // If it is a normal FGBG run which follows a short BG run
                // then it is better to merge them.
                //
                if ((bestRunType == IMAGE_FGBG) &&
                    (match[matchindex-1].type == RUN_BG) &&
                    (match[matchindex-1].length < 8))
                {
                    match[matchindex-1].type   = IMAGE_FGBG;
                    match[matchindex-1].length += (WORD)bestRunLength;
                    match[matchindex-1].fgChar = fgChar;
                    TRACE_OUT(( "Merged FGBG with preceding BG run -> %u",
                             match[matchindex-1].length));
                    continue;

                }

                //
                // If it is a BG run following a FGBG run then merge in the
                // pels to make the FGBG a multiple of 8 bits.  The if the
                // remaining BG run is < 16 merge it in also otherwise just
                // write the shortened BG run
                //
                if (((bestRunType == RUN_BG) ||
                     (bestRunType == RUN_BG_PEL)) &&
                    (match[matchindex-1].type == IMAGE_FGBG) &&
                    (match[matchindex-1].length & 0x0007))
                {
                    UINT mergelen = 8 -
                                        (match[matchindex-1].length & 0x0007);
                    if (mergelen > bestRunLength)
                    {
                        mergelen = bestRunLength;
                    }
                    match[matchindex-1].length += (WORD)mergelen;
                    bestRunLength -= mergelen;
                    TRACE_OUT(( "Added %u pels to FGBG giving %u leaving %u",
                       mergelen, match[matchindex-1].length,bestRunLength));

                    if (bestRunLength < 9)
                    {
                        match[matchindex-1].length += (WORD)bestRunLength;
                        TRACE_OUT(( "Merged BG with preceding FGBG gives %u",
                             match[matchindex-1].length));
                        continue;
                    }
                }

                //
                // Finally, if it is a color run spanning any kind of
                // single pel entity then merge that last two entries.
                //
                if ((bestRunType == IMAGE_COLOR) &&
                    (match[matchindex-2].type == IMAGE_COLOR) &&
                    (match[matchindex-1].length == 1))
                {
                    match[matchindex-2].length += bestRunLength + 1;
                    matchindex--;
                    TRACE_OUT(( "Merged color with preceding color gives %u",
                         match[matchindex-1].length));
                    continue;
                }
            }

            //
            // Handle runs that will not amalgamate by adding a new array
            // entry
            //
            match[matchindex].type   = bestRunType;
            match[matchindex].length = (WORD)bestRunLength;
            match[matchindex].fgChar = fgChar;

            TRACE_OUT(( "Best run of type %u (index %u) has length %u",
                                     match[matchindex-1].type,
                                     matchindex-1,
                                     match[matchindex-1].length));
            TRACE_OUT(( "Trying run of type %u (index %u) length %u",
                                     match[matchindex].type,
                                     matchindex,
                                     match[matchindex].length));

            matchindex++;

        }

        //
        // If we have just done our scan of the first line then now do the
        // rest of the buffer.  Reset our saved pel count.
        //
        numPels   = saveNumPels;
        lossy     = saveLossy;
        firstLine = FALSE;
    }
    //
    // END OF INITIAL TWO PASS SCAN OF THE INPUT
    //


    //
    // We have parsed the buffer so now we can go ahead and encode it.
    // First we should check to see whether we want to redo the encoding
    // in lossy mode.  We only do this if requested and worthwhile.
    //
    if (!saveLossy && (pLossy != NULL) && *pLossy)
    {
        UINT    lossyCharCount = 0;
        UINT    divisor;
        for (i = 2; i < (int)matchindex; i++)
        {
            if ((match[i].type == IMAGE_COLOR) ||
                (match[i].type == IMAGE_LOSSY_ODD))
            {
                lossyCharCount += match[i].length;
            }
        }
        divisor = max(numPels/100, 1);
        if (lossyCharCount/divisor > LOSSY_THRESHOLD)
        {
            saveLossy  = TRUE;
            goto RESTART_COMPRESSION_IN_LOSSY_MODE;
        }
        else
        {
            *pLossy    = FALSE;
        }
    }

    //
    // Now do the encoding
    //
    srcOffset = 0;
    firstLine = TRUE;
    lossy     = FALSE;
    fgChar    = 0xFF;

    for (i = 2; i < (int)matchindex; i++)
    {
        //
        // First check for our approaching the end of the destination
        // buffer and get out if this is the case.  We allow for the
        // largest general run order (a mega-mega set run = 4 bytes).
        // Orders which may be larger are checked within the case arm
        //
        if ((UINT)(destbuf - pDst + 4) > dstBufferSize)
        {
            //
            // We are about to blow it so just get out
            //
            DC_QUIT;
        }

        //
        // While we are encoding the first line keep checking for the end
        // of line to switch encoding states
        //
        if (firstLine)
        {
            if (srcOffset >= rowDelta)
            {
                firstLine = FALSE;
                lossy     = saveLossy;
            }
        }

        switch (match[i].type)
        {
                //
                // BG_RUN, FG_RUN, COLOR, PACKED COLOR and FGBG are normal
                // precision codes
                //
            case RUN_BG:
            case RUN_BG_PEL:
                ENCODE_ORDER_MEGA(destbuf,
                                  CODE_BG_RUN,
                                  match[i].length,
                                  CODE_MEGA_MEGA_BG_RUN,
                                  MAX_LENGTH_ORDER,
                                  MAX_LENGTH_LONG_ORDER);
                TRACE_OUT(( "BG RUN %u",match[i].length));
                srcOffset += match[i].length;
                break;

            case IMAGE_LOSSY_ODD:
                //
                // For a lossy odd line we encode a background run
                // Note that we do not need to encode a start lossy
                // because the decode does not need to distinguish this
                // from a regular bg run
                //
                ENCODE_ORDER_MEGA(destbuf,
                                  CODE_BG_RUN,
                                  match[i].length,
                                  CODE_MEGA_MEGA_BG_RUN,
                                  MAX_LENGTH_ORDER,
                                  MAX_LENGTH_LONG_ORDER);
                TRACE_OUT(( "BG RUN %u",match[i].length));
                srcOffset += match[i].length;
                break;

            case RUN_FG:
                //
                // If the fg char is not yet set then encode a set+run code
                //
                if (fgChar != match[i].fgChar)
                {
                    SETFGCHAR(match[i].fgChar, fgChar, fgShift);
                    //
                    // Encode the order
                    //
                    ENCODE_SET_ORDER_MEGA(destbuf,
                                          CODE_SET_FG_FG_RUN,
                                          match[i].length,
                                          CODE_MEGA_MEGA_SET_FG_RUN,
                                          MAX_LENGTH_ORDER_LITE,
                                          MAX_LENGTH_LONG_ORDER_LITE);
                    TRACE_OUT(( "SET_FG_FG_RUN %u",match[i].length));
                    srcOffset += match[i].length;
                }
                else
                {
                    ENCODE_ORDER_MEGA(destbuf,
                                      CODE_FG_RUN,
                                      match[i].length,
                                      CODE_MEGA_MEGA_FG_RUN,
                                      MAX_LENGTH_ORDER,
                                      MAX_LENGTH_LONG_ORDER);
                    TRACE_OUT(( "FG_RUN %u",match[i].length));
                    srcOffset += match[i].length;
                }
                break;

            case IMAGE_FGBG:
                //
                // IMAGE_FGBG
                //
                runLength = match[i].length;

                //
                // First check for our approaching the end of the
                // destination buffer and get out if this is the case.
                //
                if ((destbuf-pDst+(runLength+7)/8+4) > dstBufferSize)
                {
                    //
                    // We are about to blow it so just get out
                    //
                    DC_QUIT;
                }

                //
                // We need to convert FGBG runs into the pixel form
                //
                if (fgChar != match[i].fgChar)
                {
                    SETFGCHAR(match[i].fgChar, fgChar, fgShift);

                    ENCODE_SET_ORDER_MEGA_FGBG(destbuf,
                                               CODE_SET_FG_FG_BG,
                                               runLength,
                                               CODE_MEGA_MEGA_SET_FGBG,
                                               MAX_LENGTH_FGBG_ORDER_LITE,
                                               MAX_LENGTH_LONG_FGBG_ORDER);
                    TRACE_OUT(( "SET_FG_FG_BG %u",match[i].length));
                    while (runLength >= 8)
                    {
                        ENCODEFGBG(*destbuf);
                        destbuf++;
                        srcOffset += 8;
                        runLength -= 8;
                    }
                    if (runLength)
                    {
                        ENCODEFGBG(*destbuf);
                        //
                        // Keep the final partial byte clean to help GDC
                        // packing
                        //
                        *destbuf &= ((0x01 << runLength) - 1);
                        destbuf++;
                        srcOffset += runLength;
                    }
                }
                else
                {

                    if  (runLength == 8)
                    {
                        BYTE fgbgChar;
                        //
                        // See if it is one of the high probability bytes
                        //
                        ENCODEFGBG(fgbgChar);

                        //
                        // Check for single byte encoding of FGBG images
                        //
                        switch (fgbgChar)
                        {
                            case SPECIAL_FGBG_CODE_1:
                                *destbuf++ = CODE_SPECIAL_FGBG_1;
                                break;
                            case SPECIAL_FGBG_CODE_2:
                                *destbuf++ = CODE_SPECIAL_FGBG_2;
                                break;
                            default:

                                ENCODE_ORDER_MEGA_FGBG(destbuf,
                                                  CODE_FG_BG_IMAGE,
                                                  runLength,
                                                  CODE_MEGA_MEGA_FGBG,
                                                  MAX_LENGTH_FGBG_ORDER,
                                                  MAX_LENGTH_LONG_FGBG_ORDER);
                                *destbuf++ = fgbgChar;
                                break;
                        }
                        srcOffset += 8;
                    }
                    else
                    {
                        //
                        // Encode as standard FGBG
                        //
                        ENCODE_ORDER_MEGA_FGBG(destbuf,
                                               CODE_FG_BG_IMAGE,
                                               runLength,
                                               CODE_MEGA_MEGA_FGBG,
                                               MAX_LENGTH_FGBG_ORDER,
                                               MAX_LENGTH_LONG_FGBG_ORDER);
                        TRACE_OUT(( "FG_BG %u",match[i].length));
                        while (runLength >= 8)
                        {
                            ENCODEFGBG(*destbuf);
                            destbuf++;
                            srcOffset += 8;
                            runLength -= 8;
                        }
                        if (runLength)
                        {
                            ENCODEFGBG(*destbuf);
                            *destbuf &= ((0x01 << runLength) - 1);
                            destbuf++;
                            srcOffset += runLength;
                        }
                    }
                }
                break;


            case RUN_COLOR:
                //
                // COLOR RUN
                //
                ENCODE_ORDER_MEGA(destbuf,
                                  CODE_COLOR_RUN,
                                  match[i].length,
                                  CODE_MEGA_MEGA_COLOR_RUN,
                                  MAX_LENGTH_ORDER,
                                  MAX_LENGTH_LONG_ORDER);
                TRACE_OUT(( "COLOR_RUN %u",match[i].length));
                *destbuf++ = nrmbuf[srcOffset];
                srcOffset += match[i].length;
                break;

            case RUN_DITHER:
                //
                // DITHERED RUN
                //
                {
                    UINT   ditherlen = match[i].length/2;
                    ENCODE_ORDER_MEGA(destbuf,
                                      CODE_DITHERED_RUN,
                                      ditherlen,
                                      CODE_MEGA_MEGA_DITHER,
                                      MAX_LENGTH_ORDER_LITE,
                                      MAX_LENGTH_LONG_ORDER_LITE);
                    TRACE_OUT(( "DITHERED_RUN %u",match[i].length));
                    //
                    // First check for our approaching the end of the
                    // destination buffer and get out if this is the case.
                    //
                    if ((UINT)(destbuf - pDst + 2) > dstBufferSize)
                    {
                        //
                        // We are about to blow it so just get out
                        //
                        DC_QUIT;
                    }
                    *destbuf++ = nrmbuf[srcOffset];
                    *destbuf++ = nrmbuf[srcOffset+1];
                    srcOffset += match[i].length;
                }
                break;

            case IMAGE_COLOR:
                //
                // IMAGE_COLOR
                //
                //
                // A length of 1 can possibly be encoded as a single
                // "BLACK"
                //
                if (match[i].length == 1)
                {
                    if (nrmbuf[srcOffset] == 0x00)
                    {
                        *destbuf++ = CODE_BLACK;
                        srcOffset++;
                        break;
                    }
                    if (nrmbuf[srcOffset] == 0xFF)
                    {
                        *destbuf++ = CODE_WHITE;
                        srcOffset++;
                        break;
                    }
                }

                //
                // If lossy compression is requested then indicate it
                // immediately we get a color image to encode here
                //
                if (lossy & !lossyStarted)
                {
                    lossyStarted = TRUE;
                    *destbuf++   = CODE_START_LOSSY;
                }

                //
                // For 4bpp data pack color runs into nibbles
                //
                if (bpp == 4)
                {
                    //
                    // Store the data in packed format
                    //
                    ENCODE_ORDER_MEGA(destbuf,
                                      CODE_PACKED_COLOR_IMAGE,
                                      match[i].length,
                                      CODE_MEGA_MEGA_PACKED_CLR,
                                      MAX_LENGTH_ORDER,
                                      MAX_LENGTH_LONG_ORDER);
                    TRACE_OUT(( "PACKED COLOR %u",match[i].length));

                    //
                    // If we are not doing lossy compress then just copy
                    // the data over, packing two to a byte
                    //
                    if (!lossy)
                    {
                        //
                        // First check for our approaching the end of the
                        // destination buffer and get out if this is the
                        // case.
                        //
                        if ((destbuf - pDst + (UINT)(match[i].length + 1) / 2) >
                            dstBufferSize)
                        {
                            //
                            // We are about to blow it so just get out
                            //
                            DC_QUIT;
                        }

                        Pack4bpp(destbuf, nrmbuf+srcOffset, match[i].length);
                        destbuf   += (match[i].length+1)/2;
                        srcOffset += match[i].length;
                    }
                    else
                    {
                        //
                        // First check for our approaching the end of the
                        // destination buffer and get out if this is the
                        // case.
                        //
                        if ((destbuf - pDst + (UINT)(match[i].length + 3) / 4) >
                            dstBufferSize)
                        {
                            //
                            // We are about to blow it so just get out
                            //
                            DC_QUIT;
                        }

                        //
                        // For a lossy compress we need to discard every
                        // even byte
                        //
                        while (match[i].length > 2)
                        {
                            *destbuf++ =
                                   (BYTE)((*(nrmbuf+srcOffset)<<4) |
                                             (*(nrmbuf+srcOffset+2) & 0x0F));
                            if (match[i].length > 3)
                            {
                                srcOffset       += 4;
                                match[i].length -= 4;
                            }
                            else
                            {
                                srcOffset       += 3;
                                match[i].length -= 3;
                            }
                        }
                        if (match[i].length > 0)
                        {
                            *destbuf++ = (BYTE)(*(nrmbuf+srcOffset)<<4);
                            srcOffset  += match[i].length;
                        }
                    }
                }
                else
                {
                    //
                    // For 8bpp we don't bother trying to detect packed
                    // data.  Doing so disturbs GDC.
                    //
                    if (!lossy)
                    {
                        //
                        // Store the data in non-compressed form
                        //
                        ENCODE_ORDER_MEGA(destbuf,
                                          CODE_COLOR_IMAGE,
                                          match[i].length,
                                          CODE_MEGA_MEGA_CLR_IMG,
                                          MAX_LENGTH_ORDER,
                                          MAX_LENGTH_LONG_ORDER);
                        TRACE_OUT(( "COLOR_IMAGE %u",match[i].length));

                        //
                        // First check for our approaching the end of the
                        // destination buffer and get out if this is the
                        // case.
                        //
                        if ((destbuf - pDst + (UINT)match[i].length) > dstBufferSize)
                        {
                            //
                            // We are about to blow it so just get out
                            //
                            DC_QUIT;
                        }

                        //
                        // Now just copy the data over
                        //
                        memcpy(destbuf, nrmbuf+srcOffset, match[i].length);
                        destbuf   += match[i].length;
                        srcOffset += match[i].length;
                    }
                    else
                    {
                        //
                        // Lossy compression - store the data with
                        // discarding
                        //
                        ENCODE_ORDER_MEGA(destbuf,
                                          CODE_COLOR_IMAGE,
                                          match[i].length,
                                          CODE_MEGA_MEGA_CLR_IMG,
                                          MAX_LENGTH_ORDER,
                                          MAX_LENGTH_LONG_ORDER);
                        TRACE_OUT(( "COLOR_IMAGE %u",match[i].length));

                        //
                        // First check for our approaching the end of the
                        // destination buffer and get out if this is the
                        // case.
                        //
                        if ((destbuf - pDst + (UINT)(match[i].length + 1) / 2) >
                            dstBufferSize)
                        {
                            //
                            // We are about to blow it so just get out
                            //
                            DC_QUIT;
                        }

                        //
                        // For a lossy compress we need to discard every
                        // even byte
                        //
                        while (match[i].length > 1)
                        {
                            *destbuf++ = *(nrmbuf+srcOffset);
                            srcOffset += 2;
                            match[i].length -= 2;
                        }
                        if (match[i].length == 1)
                        {
                            *destbuf++ = *(nrmbuf+srcOffset);
                            srcOffset++;
                        }
                    }
                }
                break;

            default:
                ERROR_OUT(( "Invalid run type %u",match[i].type));
        }
    }

    //
    // return the size of the compressed buffer
    //
    compressedLength = (UINT)(destbuf-pDst);

DC_EXIT_POINT:
    DebugExitDWORD(CompressV2Int, compressedLength);
    return(compressedLength);
}

//
// DecompressV2Int
//
UINT    DecompressV2Int(LPBYTE pSrc,
                                            LPBYTE pDst,
                                            UINT   bytes,
                                            UINT   bpp,
                                            UINT   rowDelta,
                                            LPBYTE nrmbuf)
{
    UINT    codeLength;
    BYTE   codeByte;
    BYTE   codeByte2;
    BYTE   decode;
    BYTE   decodeLite;
    BYTE   decodeMega;
    BYTE   fgChar             = 0xFF;
    BYTE NEAR *destbuf        = nrmbuf;
    LPBYTE  endSrc             = pSrc + bytes;
    BOOL    backgroundNeedsPel = FALSE;
    BOOL    lossyStarted       = FALSE;
    UINT    resultSize         = 0;
    BOOL    firstLine          = TRUE;

    DebugEntry(DecompressV2Int);

    //
    // Loop processing the input
    //
    while(pSrc < endSrc)
    {

        //
        // While we are processing the first line we should keep a look out
        // for the end of the line
        //
        if (firstLine)
        {
            if ((UINT)(destbuf - nrmbuf) >= rowDelta)
            {
                firstLine = FALSE;
                backgroundNeedsPel = FALSE;
            }
        }

        //
        // Trace out the source data for debugging
        //
        TRACE_OUT(( "Next code is %2.2x%2.2x%2.2x%2.2x",
                *pSrc,
                *(pSrc+1),
                *(pSrc+2),
                *(pSrc+3)));

        //
        // Get the decode
        //
        decode     = (BYTE)(*pSrc & CODE_MASK);
        decodeLite = (BYTE)(*pSrc & CODE_MASK_LITE);
        decodeMega = (BYTE)(*pSrc);

        //
        // BG RUN
        //
        if ((decode == CODE_BG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_BG_RUN))
        {
            if (decode == CODE_BG_RUN)
            {
                EXTRACT_LENGTH(pSrc, codeLength);
            }
            else
            {
                codeLength = EXTRACT_TSHR_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            TRACE_OUT(( "Background run %u",codeLength));

            if (!firstLine)
            {
                if (backgroundNeedsPel)
                {
                    *destbuf++ = (BYTE)(*(destbuf - rowDelta) ^ fgChar);
                    codeLength--;
                }
                while (codeLength-- > 0)
                {
                    *destbuf++ = *(destbuf - rowDelta);
                }
            }
            else
            {
                if (backgroundNeedsPel)
                {
                    *destbuf++ = fgChar;
                    codeLength--;
                }
                while (codeLength-- > 0)
                {
                    *destbuf++ = 0x00;
                }
            }
            //
            // A follow on BG run will need a pel inserted
            //
            backgroundNeedsPel = TRUE;
            continue;
        }

        //
        // For any of the other runtypes a follow on BG run does not need
        // a FG pel inserted
        //
        backgroundNeedsPel = FALSE;

        //
        // FGBG IMAGE
        //
        if ((decode == CODE_FG_BG_IMAGE)      ||
            (decodeLite == CODE_SET_FG_FG_BG) ||
            (decodeMega == CODE_MEGA_MEGA_FGBG)    ||
            (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
        {
            if ((decodeMega == CODE_MEGA_MEGA_FGBG) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
            {
                codeLength = EXTRACT_TSHR_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                if (decode == CODE_FG_BG_IMAGE)
                {
                    EXTRACT_LENGTH_FGBG(pSrc, codeLength);
                }
                else
                {
                    EXTRACT_LENGTH_FGBG_LITE(pSrc, codeLength);
                }
            }

            if ((decodeLite == CODE_SET_FG_FG_BG) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FGBG))
            {
                fgChar    = *pSrc++;
                TRACE_OUT(( "Set FGBG image %u",codeLength));
            }
            else
            {
                TRACE_OUT(( "FGBG image     %u",codeLength));
            }

            while (codeLength > 8)
            {
                codeByte  = *pSrc++;
                if (firstLine)
                {
                    STORE_FGBG(0x00, codeByte, fgChar, 8);
                }
                else
                {
                    STORE_FGBG(*(destbuf - rowDelta), codeByte, fgChar, 8);
                }
                codeLength -= 8;
            }
            if (codeLength > 0)
            {
                codeByte  = *pSrc++;
                if (firstLine)
                {
                    STORE_FGBG(0x00, codeByte, fgChar, codeLength);
                }
                else
                {
                   STORE_FGBG(*(destbuf - rowDelta),
                              codeByte,
                              fgChar,
                              codeLength);
                }
            }
            continue;
        }

        //
        // FG RUN
        //
        if ((decode == CODE_FG_RUN) ||
            (decodeLite == CODE_SET_FG_FG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_FG_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_SET_FG_RUN))
        {

            if ((decodeMega == CODE_MEGA_MEGA_FG_RUN) ||
                (decodeMega == CODE_MEGA_MEGA_SET_FG_RUN))
            {
                codeLength = EXTRACT_TSHR_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                if (decode == CODE_FG_RUN)
                {
                    EXTRACT_LENGTH(pSrc, codeLength);
                }
                else
                {
                    EXTRACT_LENGTH_LITE(pSrc, codeLength);
                }
            }

            //
            // Push the old fgChar down to the ALT position
            //
            if ((decodeLite == CODE_SET_FG_FG_RUN) ||
                (decodeMega  == CODE_MEGA_MEGA_SET_FG_RUN))
            {
                TRACE_OUT(( "Set FG run     %u",codeLength));
                fgChar    = *pSrc++;
            }
            else
            {
                TRACE_OUT(( "FG run         %u",codeLength));
            }

            while (codeLength-- > 0)
            {
                if (!firstLine)
                {
                    *destbuf++ = (BYTE)(*(destbuf - rowDelta) ^ fgChar);
                }
                else
                {
                    *destbuf++ = fgChar;
                }
            }
            continue;
        }

        //
        // DITHERED RUN
        //
        if ((decodeLite == CODE_DITHERED_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_DITHER))
        {
            if (decodeMega == CODE_MEGA_MEGA_DITHER)
            {
                codeLength = EXTRACT_TSHR_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH_LITE(pSrc, codeLength);
            }
            TRACE_OUT(( "Dithered run   %u",codeLength));

            codeByte  = *pSrc++;
            codeByte2 = *pSrc++;
            while (codeLength-- > 0)
            {
                *destbuf++ = codeByte;
                *destbuf++ = codeByte2;
            }
            continue;
        }

        //
        // COLOR IMAGE
        //
        if ((decode == CODE_COLOR_IMAGE) ||
            (decodeMega == CODE_MEGA_MEGA_CLR_IMG))
        {
            if (decodeMega == CODE_MEGA_MEGA_CLR_IMG)
            {
                codeLength = EXTRACT_TSHR_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH(pSrc, codeLength);
            }
            TRACE_OUT(( "Color image    %u",codeLength));

            //
            // If not doing lossy compression then just copy the bytes
            //
            if (!lossyStarted)
            {
                while (codeLength-- > 0)
                {
                    //
                    // Update the target with the character
                    //
                    *destbuf++ = *pSrc++;
                }
            }
            else
            {
                //
                // For lossy compression we must duplicate all the bytes,
                // bar the final odd byte
                //
                while (codeLength > 3)
                {
                    //
                    // Dither the bytes unless they are black in which
                    // case a non-dither is preferable
                    //
                    *destbuf++ = *pSrc;
                    if (*pSrc == 0)
                    {
                        *destbuf++ = *(pSrc);
                        *destbuf++ = *(pSrc+1);
                        *destbuf++ = *(pSrc+1);
                        pSrc += 2;
                    }
                    else
                    {
                        *destbuf++ = *(pSrc+1);
                        *destbuf++ = *pSrc++;
                        *destbuf++ = *pSrc++;
                    }
                    codeLength -= 4;
                }
                if (codeLength == 3)
                {
                    *destbuf++ = *pSrc;
                    *destbuf++ = *(pSrc+1);
                    *destbuf++ = *pSrc;
                    pSrc += 2;
                }
                else
                {
                    if (codeLength == 2)
                    {
                        *destbuf++ = *pSrc;
                        *destbuf++ = *pSrc++;
                    }
                    else
                    {
                        if (codeLength == 1)
                        {
                            *destbuf++ = *pSrc++;
                        }
                    }
                }
            }
            continue;
        }

        //
        // PACKED COLOR IMAGE
        //
        if ((decode == CODE_PACKED_COLOR_IMAGE) ||
            (decodeMega == CODE_MEGA_MEGA_PACKED_CLR))
        {
            if (decodeMega == CODE_MEGA_MEGA_PACKED_CLR)
            {
                codeLength = EXTRACT_TSHR_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH(pSrc, codeLength);
            }
            TRACE_OUT(( "Packed color   %u",codeLength));

            //
            // If not doing lossy compression then we just unpack the 4bpp
            // data two pels per byte
            //
            if (!lossyStarted)
            {
                if (bpp == 4)
                {
                    UINT   worklen = (codeLength)/2;
                    BYTE  workchar;
                    while (worklen--)
                    {
                        workchar   = *pSrc++;
                        *destbuf++ = (BYTE)(workchar>>4);
                        *destbuf++ = (BYTE)(workchar & 0x0F);
                    }
                    if (codeLength & 0x0001)
                    {
                        *destbuf++ = (BYTE)(*pSrc++>>4);
                    }
                }
                else
                {
                    ERROR_OUT(( "Don't support packed color for 8bpp"));
                }
            }
            else
            {
                //
                // For lossy compression we must duplicate all the bytes,
                // bar the final odd byte, again unpacking as we go
                //
                while (codeLength > 3)
                {
                    *destbuf++ = (BYTE)((*pSrc) >> 4);
                    *destbuf++ = (BYTE)((*pSrc) >> 4);
                    *destbuf++ = (BYTE)((*pSrc) & 0x0F);
                    *destbuf++ = (BYTE)((*pSrc) & 0x0F);
                    pSrc++;
                    codeLength -= 4;
                }

                if (codeLength > 0)
                {
                    if (codeLength-- > 0)
                    {
                        *destbuf++ = (BYTE)((*pSrc) >> 4);
                    }
                    if (codeLength-- > 0)
                    {
                        *destbuf++ = (BYTE)((*pSrc) >> 4);
                    }
                    if (codeLength-- > 0)
                    {
                        *destbuf++ = (BYTE)((*pSrc) & 0x0F);
                    }
                    if (codeLength-- > 0)
                    {
                        *destbuf++ = (BYTE)((*pSrc) & 0x0F);
                    }
                    pSrc++;
                }
            }

            continue;
        }

        //
        // COLOR RUN
        //
        if ((decode == CODE_COLOR_RUN) ||
            (decodeMega == CODE_MEGA_MEGA_COLOR_RUN))
        {

            if (decodeMega == CODE_MEGA_MEGA_COLOR_RUN)
            {
                codeLength = EXTRACT_TSHR_UINT16_UA(pSrc+1);
                pSrc += 3;
            }
            else
            {
                EXTRACT_LENGTH(pSrc, codeLength);
            }
            TRACE_OUT(( "Color run      %u",codeLength));

            codeByte  = *pSrc++;
            while (codeLength-- > 0)
            {
                *destbuf++ = codeByte;
            }
            continue;
        }


        //
        // If we get here then the code must be a special one
        //
        TRACE_OUT(( "Special code   %x",decodeMega));
        switch (decodeMega)
        {
            case CODE_BLACK:
                *destbuf++ = 0x00;
                break;

            case CODE_WHITE:
                *destbuf++ = 0xFF;
                break;

            //
            // Ignore the unreachable code warnings that follow
            // Simply because we use the STORE_FGBG macro with a constant
            // value
            //
            case CODE_SPECIAL_FGBG_1:
                if (firstLine)
                {
                    STORE_FGBG(0x00, SPECIAL_FGBG_CODE_1, fgChar, 8);
                }
                else
                {
                    STORE_FGBG(*(destbuf - rowDelta),
                               SPECIAL_FGBG_CODE_1,
                               fgChar,
                               8);
                }
                break;

            case CODE_SPECIAL_FGBG_2:
                if (firstLine)
                {
                    STORE_FGBG(0x00,
                               SPECIAL_FGBG_CODE_2,
                               fgChar,
                               8);
                }
                else
                {
                    STORE_FGBG(*(destbuf - rowDelta),
                               SPECIAL_FGBG_CODE_2,
                               fgChar,
                               8);
                }
                break;


            case CODE_START_LOSSY:
                lossyStarted = TRUE;
                break;

            default:
                ERROR_OUT(( "Invalid compression data %x",decodeMega));
                break;
        }
        pSrc++;

    }

    //
    // Our final task is to copy the decoded image into the target buffer
    // compacting if we are generating a 4bpp image
    //
    resultSize = (UINT)(destbuf-nrmbuf);
    if (bpp == 4)
    {
        //
        // Zero the final byte to eliminate single byte packing problems
        //
        *destbuf = 0x00;

        Pack4bpp(pDst, nrmbuf, resultSize);
    }
    else
    {
        memcpy(pDst, nrmbuf, resultSize);
    }
    TRACE_OUT(( "Returning %u bytes",resultSize));

    //
    // Return the number of pixels decoded
    //
    DebugExitDWORD(DecompressV2Int, resultSize);
    return(resultSize);
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\ch.cpp ===
#include "precomp.h"


//
// CH.CPP
// Cache Handler
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE

//
// CACHE HANDLER
//
// The Cache Handler is a generic cache manager that handles blocks of
// memory supplied by the calling component.
//
// Once a cache of a particular size has been created, blocks of memory can
// be added to it (CH_CacheData).  The cache can then be searched
// (CH_SearchCache) to try and match the contents of a given block of
// memory with the blocks in the cache.
//
// When a block is added to the cache and the cache is full, one of the
// blocks currently in the cache is discarded on a Least-Recently Used
// (LRU) basis.
//
// The component that creates the cache specifies a callback function which
// is called every time a block is removed from the cache.  This allows the
// caller to free up memory blocks when they are no longer in use.
//



//
// FUNCTION: CH_CreateCache
//
BOOL  ASHost::CH_CreateCache
(
    PCHCACHE *          ppCache,
    UINT                cCacheEntries,
    UINT                cNumEvictionCategories,
    UINT                cbNotHashed,
    PFNCACHEDEL         pfnCacheDel
)
{
    UINT                cbCacheSize;
    UINT                i;
    PCHCACHE            pCache;

    DebugEntry(ASHost::CH_CreateCache);


    //
    // Initialize return value
    //
    pCache = NULL;

    //
    // Do a few parameter validation checks.
    //
    ASSERT((cCacheEntries > 0));
    ASSERT((cCacheEntries < CH_MAX_CACHE_ENTRIES));
    ASSERT(cNumEvictionCategories > 0);
    ASSERT(cNumEvictionCategories <= CH_NUM_EVICTION_CATEGORIES);


    //
    // Calculate the amount of memory required.
    // NOTE that the CHCACHE definition includes one cache entry
    //
    cbCacheSize = sizeof(CHCACHE) + ((cCacheEntries-1) * sizeof(CHENTRY));

    //
    // Allocate memory for the cache.
    //
    pCache = (PCHCACHE)new BYTE[cbCacheSize];
    if (pCache == NULL)
    {
        ERROR_OUT(("Failed to alloc cache"));
        DC_QUIT;
    }

    SET_STAMP(pCache, CHCACHE);

    pCache->pRoot = NULL;
    pCache->pFirst = NULL;
    pCache->pLast= NULL;
    pCache->free = 0;

    pCache->cEntries = cCacheEntries;
    pCache->cNumEvictionCategories = cNumEvictionCategories;
    pCache->cbNotHashed = cbNotHashed;
    pCache->pfnCacheDel = pfnCacheDel;

    //
    // Initialize the cache entries
    //
    for (i = 0; i < cCacheEntries; i++)
    {
        CHInitEntry(&pCache->Entry[i]);
        pCache->Entry[i].free = (WORD)(i+1);
    }
    pCache->Entry[cCacheEntries-1].free = CH_MAX_CACHE_ENTRIES;

    //
    // Set up the default eviction category limits. Default is to balance
    // at 75% to the high category, 75% of the remainder to the next lower
    // and so on
    //
    for (i = cNumEvictionCategories; i > 0; i--)
    {
        pCache->iMRUHead[i-1] = CH_MAX_CACHE_ENTRIES;
        pCache->iMRUTail[i-1] = CH_MAX_CACHE_ENTRIES;
        pCache->cEvictThreshold[i-1] = (WORD)((cCacheEntries*3)/4);
    }

DC_EXIT_POINT:
    *ppCache = pCache;
    DebugExitBOOL(ASHost::CH_CreateCache, (pCache != NULL));
    return(pCache != NULL);
}


//
// CH_DestroyCache
// Destroys a created cache, if it is valid.
//
void ASHost::CH_DestroyCache(PCHCACHE pCache)
{
    DebugEntry(ASHost::CH_DestroyCache);

    ASSERT(IsValidCache(pCache));

    //
    // Clear the entries in the cache
    //
    CH_ClearCache(pCache);

    //
    // Free the memory
    //
    delete pCache;

    DebugExitVOID(ASHost::CH_DestroyCache);
}


//
// FUNCTION: CH_SearchCache
//
BOOL  ASHost::CH_SearchCache
(
    PCHCACHE    pCache,
    LPBYTE      pData,
    UINT        cbDataSize,
    UINT        evictionCategory,
    UINT *      piCacheEntry
)
{
    BOOL        rc = FALSE;
    UINT        checkSum;

    DebugEntry(ASHost::CH_SearchCache);

    ASSERT(IsValidCache(pCache));

    checkSum = CHCheckSum(pData + pCache->cbNotHashed,
        cbDataSize - pCache->cbNotHashed);

    *piCacheEntry = CHTreeSearch(pCache, checkSum, cbDataSize, pData);
    if ( *piCacheEntry != CH_MAX_CACHE_ENTRIES )
    {
        //
        // Found a match
        //
        CHUpdateMRUList(pCache, *piCacheEntry, evictionCategory);
        rc = TRUE;
    }

    DebugExitBOOL(ASHost::CH_SearchCache, rc);
    return(rc);
}

//
// FUNCTION: CH_CacheData
//
UINT  ASHost::CH_CacheData
(
    PCHCACHE    pCache,
    LPBYTE      pData,
    UINT        cbDataSize,
    UINT        evictionCategory
)
{
    UINT        evictionCount;
    UINT        iEntry = CH_MAX_CACHE_ENTRIES;
    PCHENTRY    pEntry;

    DebugEntry(ASHost::CH_CacheData);

    ASSERT(IsValidCache(pCache));
    ASSERT((evictionCategory < pCache->cNumEvictionCategories));

    if (!CHFindFreeCacheEntry(pCache, &iEntry, &evictionCount))
    {
        iEntry = CHEvictLRUCacheEntry(pCache, evictionCategory, evictionCount);

        //
        // MNM1422: Ideally we would now call CHFindFreeCacheEntry again to
        // get the entry freed up by the eviction process - but since we
        // have just been returned that entry, we may as well use it to
        // improve performance.
        //
        // However, the processing has left pTreeCacheData->tree.free
        // pointing to the entry we have just evicted - which we are about
        // to use.  So we need to perform the same processing on the free
        // list as CHFindFreeCacheEntry would have done, or next time
        // through, the first 'free' entry will really be in use, and the
        // insert code will assert!
        //
        ASSERT(pCache->free == iEntry);
        pCache->free = pCache->Entry[iEntry].free;
    }

    pEntry = &pCache->Entry[iEntry];
    pEntry->pData = pData;
    pEntry->cbData = cbDataSize;
    pEntry->checkSum = CHCheckSum(pData + pCache->cbNotHashed,
                                 cbDataSize - pCache->cbNotHashed);
    pEntry->evictionCategory = (WORD)evictionCategory;
    CHAvlInsert(pCache, pEntry);

    TRACE_OUT(( "Cache 0x%08x entry %d checksum 0x%08x data 0x%08x",
        pCache, iEntry, pEntry->checkSum, pEntry->pData));

    CHUpdateMRUList(pCache, iEntry, evictionCategory);

    DebugExitDWORD(ASHost::CH_CacheData, iEntry);
    return(iEntry);
}


//
// FUNCTION: CH_SearchAndCacheData
//
BOOL  ASHost::CH_SearchAndCacheData
(
    PCHCACHE    pCache,
    LPBYTE      pData,
    UINT        cbDataSize,
    UINT        evictionCategory,
    UINT *      piCacheEntry
)
{
    UINT        checkSum;
    UINT        i;
    BOOL        preExisting;
    UINT        iEntry        = CH_MAX_CACHE_ENTRIES;
    UINT        evictionCount = 0;
    PCHENTRY    pEntry;

    DebugEntry(ASHost::CH_SearchAndCacheData);

    ASSERT(IsValidCache(pCache));
    ASSERT(evictionCategory < pCache->cNumEvictionCategories);

    //
    // Does this entry exist?
    //
    checkSum = CHCheckSum(pData + pCache->cbNotHashed,
                          cbDataSize - pCache->cbNotHashed);

    iEntry = CHTreeSearch(pCache, checkSum, cbDataSize, pData);
    if ( iEntry == CH_MAX_CACHE_ENTRIES)
    {
        preExisting = FALSE;
        //
        // We didn't find the entry--can we add it?
        //
        TRACE_OUT(("CACHE: entry not found in cache 0x%08x csum 0x%08x",
            pCache, checkSum));

        if (!CHFindFreeCacheEntry(pCache, &iEntry, &evictionCount))
        {
            //
            // Nope.  Evict an entry
            //
            iEntry = CHEvictLRUCacheEntry(pCache, evictionCategory, evictionCount);

            ASSERT(iEntry != CH_MAX_CACHE_ENTRIES);

            TRACE_OUT(("CACHE: no free entries so evicted cache 0x%08x entry %d",
                pCache, iEntry));

            //
            // Ideally we would now call CHFindFreeCacheEntry again to
            // get the entry freed up via the eviction process, but since
            // we just returned that entry use to to improve perf.
            //
            // However, the processing has left pCache->free pointing
            // to the entry we just evicted and are about to use.  So
            // we need to fix it up.
            //
            ASSERT(pCache->free == iEntry);
            pCache->free = pCache->Entry[iEntry].free;
        }


        //
        // Fill in this entry's data
        //
        pEntry = &pCache->Entry[iEntry];
        pEntry->pData = pData;
        pEntry->cbData = cbDataSize;
        pEntry->checkSum = checkSum;
        pEntry->evictionCategory = (WORD)evictionCategory;

        CHAvlInsert(pCache, pEntry);
        TRACE_OUT(( "CACHE: NEW ENTRY cache 0x%08x entry %d csum 0x%08x pdata 0x%08x",
            pCache, iEntry, checkSum,  pEntry->pData));
    }
    else
    {
        //
        // We found the entry
        //
        preExisting = TRUE;

        TRACE_OUT(( "CACHE: entry found in cache 0x%08x entry %d csum 0x%08x",
                pCache, iEntry, checkSum));
    }

    CHUpdateMRUList(pCache, iEntry, evictionCategory);
    *piCacheEntry = iEntry;

    DebugExitBOOL(ASHost::CH_SearchAndCacheData, preExisting);
    return(preExisting);
}


//
// FUNCTION: CH_RemoveCacheEntry
//
void  ASHost::CH_RemoveCacheEntry
(
    PCHCACHE    pCache,
    UINT        iCacheEntry
)
{
    DebugEntry(ASHost::CH_RemoveCacheEntry);

    ASSERT(IsValidCache(pCache));
//    ASSERT(IsValidCacheIndex(pCache, iCacheEntry)); Always True

    CHEvictCacheEntry(pCache, iCacheEntry, pCache->Entry[iCacheEntry].evictionCategory);

    DebugExitVOID(ASHost::CH_RemoveCacheEntry);
}

//
// FUNCTION: CH_ClearCache
//
void  ASHost::CH_ClearCache
(
    PCHCACHE pCache
)
{
    UINT    i;

    DebugEntry(ASHost::CH_ClearCache);

    ASSERT(IsValidCache(pCache));

    //
    // Remove the cache entries
    //
    for (i = 0; i < pCache->cEntries; i++)
    {
        if (pCache->Entry[i].pData != NULL)
        {
            CHRemoveEntry(pCache, i);
        }
    }

    DebugExitVOID(ASHost::CH_ClearCache);
}



//
// CH_TouchCacheEntry() - see ch.h
//
void ASHost::CH_TouchCacheEntry
(
    PCHCACHE    pCache,
    UINT        iCacheEntry
)
{
    DebugEntry(ASHost::CH_TouchCacheEntry);

    ASSERT(IsValidCache(pCache));
//     ASSERT(IsValidCacheIndex(pCache, iCacheEntry)); Always True

    TRACE_OUT(( "Touching cache entry 0x%08x %d", pCache, iCacheEntry));

    CHUpdateMRUList(pCache, iCacheEntry, 0);

    DebugExitVOID(ASHost::CH_TouchCacheEntry);
}



//
// CHInitEntry
// Initializes a cache entry
//
//
void ASHost::CHInitEntry(PCHENTRY pEntry)
{
    pEntry->pParent     = NULL;
    pEntry->pLeft       = NULL;
    pEntry->pRight      = NULL;
    pEntry->pData       = NULL;
    pEntry->checkSum    = 0;
    pEntry->lHeight     = 0xFFFF;
    pEntry->rHeight     = 0xFFFF;
    pEntry->chain.next  = CH_MAX_CACHE_ENTRIES;
    pEntry->chain.prev  = CH_MAX_CACHE_ENTRIES;
    pEntry->cbData      = 0;
}



//
// FUNCTION: CHUpdateMRUList
//
void  ASHost::CHUpdateMRUList
(
    PCHCACHE    pCache,
    UINT        iEntry,
    UINT        evictionCategory
)
{
    WORD        inext;
    WORD        iprev;

    DebugEntry(ASHost::CHUpdateMRUList);

    //
    // Move the given entry to the head of the MRU if isn't there already
    //

    if (pCache->iMRUHead[evictionCategory] != iEntry)
    {
        //
        // Remove the supplied entry from the MRU list, if it is currently
        // chained.  Since we never do this if the entry is already in the
        // front, an iprev of CH_MAX_CACHE_ENTRIES indicates that we are
        // updated an unchained entry.
        //
        iprev = pCache->Entry[iEntry].chain.prev;
        inext = pCache->Entry[iEntry].chain.next;
        TRACE_OUT(("Add/promote entry %u which was chained off %hu to %hu",
                    iEntry,iprev,inext));

        if (iprev != CH_MAX_CACHE_ENTRIES)
        {
            pCache->Entry[iprev].chain.next = inext;
            if (inext != CH_MAX_CACHE_ENTRIES)
            {
                pCache->Entry[inext].chain.prev = iprev;
            }
            else
            {
                TRACE_OUT(("Removing final entry(%u) from MRU chain leaving %hu at tail",
                            iEntry, iprev));
                pCache->iMRUTail[evictionCategory] = iprev;
            }
        }

        //
        // Now add this entry to the head of the MRU list
        //
        inext = pCache->iMRUHead[evictionCategory];
        pCache->Entry[iEntry].chain.next = inext;
        pCache->Entry[iEntry].chain.prev = CH_MAX_CACHE_ENTRIES;
        pCache->iMRUHead[evictionCategory] = (WORD)iEntry;

        if (inext != CH_MAX_CACHE_ENTRIES)
        {
            pCache->Entry[inext].chain.prev = (WORD)iEntry;
        }
        else
        {
            //
            // If the MRU chain is currently empty, then we must first add
            // the entry to the tail of the chain.
            //
            pCache->iMRUTail[evictionCategory] = (WORD)iEntry;
            TRACE_OUT(("Cache 0x%08x entry %u is first so add to MRU %u tail",
                          pCache, iEntry, evictionCategory));
        }

        TRACE_OUT(( "Cache 0x%08x entry %u to head of MRU category %u",
                pCache, iEntry, evictionCategory));

    }
    else
    {
        TRACE_OUT(("Cache 0x%08x entry %u already at head of eviction category %u",
            pCache, iEntry, evictionCategory));
    }

    DebugExitVOID(ASHost::CHUpateMRUList);
}


//
// FUNCTION: CHFindFreeCacheEntry
//
BOOL  ASHost::CHFindFreeCacheEntry
(
    PCHCACHE    pCache,
    UINT*       piEntry,
    UINT*       pEvictionCount
)
{
    UINT        iEntry;
    BOOL        rc = FALSE;

    DebugEntry(ASHost::CHFindFreeCacheEntry);

    ASSERT(IsValidCache(pCache));

    iEntry = pCache->free;
    if (iEntry == CH_MAX_CACHE_ENTRIES)
    {
        TRACE_OUT(( "Cache 0x%08x is full", pCache));

        *pEvictionCount = pCache->cEntries;
        rc = FALSE;
    }
    else
    {
        TRACE_OUT(( "Free entry at %u",iEntry));

        *piEntry = iEntry;
        pCache->free = pCache->Entry[iEntry].free;

        *pEvictionCount = 0;
        rc = TRUE;
    }

    DebugExitBOOL(ASHost::CHFindFreeCacheEntry, rc);
    return(rc);
}

//
// FUNCTION: CHEvictCacheEntry
//
UINT  ASHost::CHEvictCacheEntry
(
    PCHCACHE    pCache,
    UINT        iEntry,
    UINT        evictionCategory
)
{
    WORD        inext;
    WORD        iprev;

    DebugEntry(ASHost::CHEvictCacheEntry);

    //
    // Evict the specified entry by removing it from the MRU chain, and
    // then resetting it.  If it is in the cache, it must be in an MRU
    // cache.
    //

    inext = pCache->Entry[iEntry].chain.next;
    iprev = pCache->Entry[iEntry].chain.prev;
    TRACE_OUT(( "Evicting entry %u which was chained off %hu to %hu",
        iEntry, iprev, inext));

    if (iprev < CH_MAX_CACHE_ENTRIES)
    {
        pCache->Entry[iprev].chain.next = inext;
    }
    else
    {
        TRACE_OUT(("Removing head entry(%u) from MRU chain leaving %hu at head",
            iEntry, inext));
        pCache->iMRUHead[evictionCategory] = inext;
    }

    if (inext < CH_MAX_CACHE_ENTRIES)
    {
        pCache->Entry[inext].chain.prev = iprev;
    }
    else
    {
        TRACE_OUT(("Removing tail entry(%u) from MRU chain leaving %hu at tail",
            iEntry, iprev));
        pCache->iMRUTail[evictionCategory] = iprev;
    }

    CHRemoveEntry(pCache, iEntry);

    DebugExitDWORD(ASHost::CHEvictCacheEntry, iEntry);
    return(iEntry);
}


//
// FUNCTION: CHEvictLRUCacheEntry
//
UINT  ASHost::CHEvictLRUCacheEntry
(
    PCHCACHE    pCache,
    UINT        evictionCategory,
    UINT        evictionCount
)
{
    UINT        iEntry;
    UINT        i;

    DebugEntry(ASHost::CHEvictLRUCacheEntry);

    TRACE_OUT(("0x%08x LRU eviction requested, category %u, count %u",
           pCache, evictionCategory, evictionCount));

    //
    // Evict from the same eviction category provided the number cached
    // is above the threshold.  Otherwise, take from the category one above.
    // This will allow the system to eventually stabilize at the correct
    // thresholds as all cache entries get used up.
    //
    if (evictionCount < pCache->cEvictThreshold[evictionCategory])
    {
        for (i = 0; i < pCache->cNumEvictionCategories; i++)
        {
            evictionCategory = (evictionCategory + 1) %
                               pCache->cNumEvictionCategories;
            if (pCache->iMRUTail[evictionCategory] != CH_MAX_CACHE_ENTRIES)
                break;
        }

        WARNING_OUT(( "Threshold %u, count %u so set eviction category to %u",
                pCache->cEvictThreshold[evictionCategory],
                evictionCount,
                evictionCategory));
    }

    //
    // Evict the lasat entry in the MRU chain
    //
    iEntry = pCache->iMRUTail[evictionCategory];
    TRACE_OUT(( "Selected %u for eviction",iEntry));
    ASSERT((iEntry != CH_MAX_CACHE_ENTRIES));

    CHEvictCacheEntry(pCache, iEntry, evictionCategory);

    DebugExitDWORD(ASHost::CHEvictLRUCacheEntry, iEntry);
    return(iEntry);
}



//
// FUNCTION: CHRemoveEntry
//
void  ASHost::CHRemoveEntry
(
    PCHCACHE    pCache,
    UINT        iCacheEntry
)
{
    DebugEntry(ASHost::CHRemoveEntry);

    ASSERT(IsValidCache(pCache));
//    ASSERT(IsValidCacheIndex(pCache, iCacheEntry)); Always True

    if (pCache->Entry[iCacheEntry].pData != NULL)
    {
        if (pCache->pfnCacheDel)
        {
            (pCache->pfnCacheDel)(this, pCache, iCacheEntry,
                pCache->Entry[iCacheEntry].pData);
        }
        else
        {
            // Simple deletion -- just free memory
            delete[] pCache->Entry[iCacheEntry].pData;
        }
    }

    CHAvlDelete(pCache, &pCache->Entry[iCacheEntry], iCacheEntry);

    DebugExitVOID(ASHost::CHRemoveEntry);
}

//
// FUNCTION: CHCheckSum
//
// For processing speed we calculate the checksum based on whole multiples
// of 4 bytes followed by a final addition of the last few bytes
//
UINT  ASHost::CHCheckSum
(
    LPBYTE  pData,
    UINT    cbDataSize
)
{
    UINT    cSum = 0;
    UINT *  pCh;
    UINT *  pEnd;
    LPBYTE  pCh8;

    DebugEntry(ASHost::CHCheckSum);

    ASSERT(cbDataSize > 3);

    pCh  = (UINT *)pData;
    pEnd = (UINT *)(pData + cbDataSize - 4);

    //
    // Get the DWORD-aligned checksum
    //
    while (pCh <= pEnd)
    {
        cSum = (cSum << 1) + *pCh++ + ((cSum & 0x80000000) != 0);
    }

    //
    // Get the rest past the last DWORD boundaray
    //
    pEnd = (UINT *)(pData + cbDataSize);
    for (pCh8 = (LPBYTE)pCh; pCh8 < (LPBYTE)pEnd; pCh8++)
    {
        cSum = cSum + *pCh8;
    }

    DebugExitDWORD(ASHost::CHCheckSum, cSum);
    return(cSum);
}

//
// FUNCTION: CHTreeSearch
//
// Finds a node in the cache tree which matches size, checksum and data.
//
UINT  ASHost::CHTreeSearch
(
    PCHCACHE    pCache,
    UINT        checkSum,
    UINT        cbDataSize,
    LPBYTE      pData
)
{
    PCHENTRY    pEntry;
    UINT        iCacheEntry = CH_MAX_CACHE_ENTRIES;

    DebugEntry(ASHost::CHTreeSearch);

    pEntry = CHAvlFind(pCache, checkSum, cbDataSize);
    while (pEntry != NULL)
    {
        ASSERT(IsValidCacheEntry(pEntry));

        //
        // Found a match based on the checksum.  Now see if the data
        // also matches.
        //
        if (!memcmp(pEntry->pData + pCache->cbNotHashed,
                            pData + pCache->cbNotHashed,
                            cbDataSize - pCache->cbNotHashed))
        {
            //
            // Data also matches.  Get an index into the memory block
            // of the cache.
            //
            iCacheEntry = (UINT)(pEntry - pCache->Entry);
            TRACE_OUT(( "Cache 0x%08x entry %d match-csum 0x%08x",
                    pCache, iCacheEntry, checkSum));
            break;
        }
        else
        {
            TRACE_OUT(( "Checksum 0x%08x size %u matched, data didn't",
                         checkSum, cbDataSize));

            pEntry = CHAvlFindEqual(pCache, pEntry);
        }
    }

    DebugExitDWORD(ASHost::CHTreeSearch, iCacheEntry);
    return(iCacheEntry);
}


//
// Name:      CHAvlInsert
//
// Purpose:   Insert the supplied node into the specified AVL tree
//
// Returns:   Nothing
//
// Params:    IN    pTree              - a pointer to the AVL tree
//            IN    pEntry              - a pointer to the node to insert
//
// Operation: Scan down the tree looking for the insert point, going left
//            if the insert key is less than or equal to the key in the tree
//            and right if it is greater. When the insert point is found
//            insert the new node and rebalance the tree if necessary.
//
//
void  ASHost::CHAvlInsert
(
    PCHCACHE    pCache,
    PCHENTRY    pEntry
)
{
    PCHENTRY    pParentEntry;
    int         result;

    DebugEntry(ASHost::CHAvlInsert);

    ASSERT(IsValidCacheEntry(pEntry));
    ASSERT(!IsCacheEntryInTree(pEntry));

    pEntry->rHeight = 0;
    pEntry->lHeight = 0;

    if (pCache->pRoot == NULL)
    {
        //
        // tree is empty, so insert at root
        //
        TRACE_OUT(( "tree is empty, so insert at root" ));
        pCache->pRoot = pEntry;
        pCache->pFirst = pEntry;
        pCache->pLast = pEntry;
        DC_QUIT;
    }

    //
    // scan down the tree looking for the appropriate insert point
    //
    TRACE_OUT(( "scan for insert point" ));
    pParentEntry = pCache->pRoot;
    while (pParentEntry != NULL)
    {
        //
        // go left or right, depending on comparison
        //
        result = CHCompare(pEntry->checkSum, pEntry->cbData, pParentEntry);

        if (result > 0)
        {
            //
            // new key is greater than this node's key, so move down right
            // subtree
            //
            TRACE_OUT(( "move down right subtree" ));
            if (pParentEntry->pRight == NULL)
            {
                //
                // right subtree is empty, so insert here
                //
                TRACE_OUT(( "right subtree empty, insert here" ));

                pEntry->pParent = pParentEntry;
                ASSERT((pParentEntry != pEntry));

                pParentEntry->pRight = pEntry;
                pParentEntry->rHeight = 1;
                if (pParentEntry == pCache->pLast)
                {
                    //
                    // parent was the right-most node in the tree, so new
                    // node is now right-most
                    //
                    TRACE_OUT(( "new last node" ));
                    pCache->pLast = pEntry;
                }
                break;
            }
            else
            {
                //
                // right subtree is not empty
                //
                TRACE_OUT(( "right subtree not empty" ));
                pParentEntry = pParentEntry->pRight;
            }
        }
        else
        {
            //
            // New key is less than or equal to this node's key, so move
            // down left subtree.  The new node could be inserted before
            // the current node when equal, but this happens so rarely
            // that it's not worth special casing.
            //
            TRACE_OUT(( "move down left subtree" ));
            if (pParentEntry->pLeft == NULL)
            {
                //
                // left subtree is empty, so insert here
                //
                TRACE_OUT(( "left subtree empty, insert here" ));
                pEntry->pParent = pParentEntry;
                ASSERT((pParentEntry != pEntry));

                pParentEntry->pLeft = pEntry;
                pParentEntry->lHeight = 1;
                if (pParentEntry == pCache->pFirst)
                {
                    //
                    // parent was the left-most node in the tree, so new
                    // node is now left-most
                    //
                    TRACE_OUT(( "new first node" ));
                    pCache->pFirst = pEntry;
                }
                break;
            }
            else
            {
                //
                // left subtree is not empty
                //
                TRACE_OUT(( "left subtree not empty" ));
                pParentEntry = pParentEntry->pLeft;
            }
        }
    }

    //
    // now rebalance the tree if necessary
    //
    CHAvlBalanceTree(pCache, pParentEntry);

DC_EXIT_POINT:
    DebugExitVOID(ASHost::CHAvlInsert);
}



//
// Name:      CHAvlDelete
//
// Purpose:   Delete the specified node from the specified AVL tree
//
// Returns:   Nothing
//
// Params:    IN    pCache              - a pointer to the AVL tree
//            IN    pEntry              - a pointer to the node to delete
//
//
void  ASHost::CHAvlDelete
(
    PCHCACHE    pCache,
    PCHENTRY    pEntry,
    UINT        iCacheEntry
)
{
    PCHENTRY    pReplaceEntry;
    PCHENTRY    pParentEntry;
    WORD        newHeight;

    DebugEntry(ASHost::CHAvlDelete);

    ASSERT(IsValidCacheEntry(pEntry));
    ASSERT(IsCacheEntryInTree(pEntry));


    if ((pEntry->pLeft == NULL) && (pEntry->pRight == NULL))
    {
        //
        // Barren node (no children).  Update all references to it with
        // our parent.
        //
        TRACE_OUT(( "delete barren node" ));
        pReplaceEntry = NULL;

        if (pCache->pFirst == pEntry)
        {
            //
            // We are the first in the b-tree
            //
            TRACE_OUT(( "replace first node in tree" ));
            pCache->pFirst = pEntry->pParent;
        }

        if (pCache->pLast == pEntry)
        {
            //
            // We are the last in the b-tree
            //
            TRACE_OUT(( "replace last node in tree" ));
            pCache->pLast = pEntry->pParent;
        }
    }
    else if (pEntry->pLeft == NULL)
    {
        //
        // This node has no left child,  so update references to it with
        // pointer to right child.
        //
        TRACE_OUT(( "node has no left child, replace with right child" ));
        pReplaceEntry = pEntry->pRight;

        if (pCache->pFirst == pEntry)
        {
            //
            // We are the first in the b-tree
            //
            TRACE_OUT(( "replace first node in tree" ));
            pCache->pFirst = pReplaceEntry;
        }

        // WE CAN'T BE THE LAST IN THE B-TREE SINCE WE HAVE A RIGHT CHILD
        ASSERT(pCache->pLast != pEntry);
    }
    else if (pEntry->pRight == NULL)
    {
        //
        // This node has no right child, so update references to it with
        // pointer to left child.
        //
        TRACE_OUT(( "node has no right son, replace with left son" ));
        pReplaceEntry = pEntry->pLeft;

        // WE CAN'T BE THE FIRST IN THE B-TREE SINCE WE HAVE A LEFT CHILD
        ASSERT(pCache->pFirst != pEntry);

        if (pCache->pLast == pEntry)
        {
            //
            // We are the last in the b-tree
            //
            TRACE_OUT(( "replace last node in tree" ));
            pCache->pLast = pReplaceEntry;
        }
    }
    else
    {
        //
        // HARDEST CASE.  WE HAVE LEFT AND RIGHT CHILDREN
        TRACE_OUT(( "node has two sons" ));
        if (pEntry->rHeight > pEntry->lHeight)
        {
            //
            // Right subtree is bigger than left subtree
            //
            TRACE_OUT(( "right subtree is higher" ));
            if (pEntry->pRight->pLeft == NULL)
            {
                //
                // Replace references to entry with right child since it
                // has no left child (left grandchild of us)
                //
                TRACE_OUT(( "replace node with right son" ));
                pReplaceEntry = pEntry->pRight;
                pReplaceEntry->pLeft = pEntry->pLeft;
                pReplaceEntry->pLeft->pParent = pReplaceEntry;
                pReplaceEntry->lHeight = pEntry->lHeight;
            }
            else
            {
                //
                // Swap with leftmost descendent of the right subtree
                //
                TRACE_OUT(( "swap with left-most right descendent" ));
                CHAvlSwapLeftmost(pCache, pEntry->pRight, pEntry);
                pReplaceEntry = pEntry->pRight;
            }
        }
        else
        {
            //
            // Left subtree is bigger than or equal to right subtree
            //
            TRACE_OUT(( "left subtree is higher" ));
            TRACE_OUT(( "(or both subtrees are of equal height)" ));
            if (pEntry->pLeft->pRight == NULL)
            {
                //
                // Replace references to entry with left child since it
                // no right child (right grandchild of us)
                //
                TRACE_OUT(( "replace node with left son" ));
                pReplaceEntry = pEntry->pLeft;
                pReplaceEntry->pRight = pEntry->pRight;
                pReplaceEntry->pRight->pParent = pReplaceEntry;
                pReplaceEntry->rHeight = pEntry->rHeight;
            }
            else
            {
                //
                // Swap with rightmost descendent of the left subtree
                //
                TRACE_OUT(( "swap with right-most left descendent" ));
                CHAvlSwapRightmost(pCache, pEntry->pLeft, pEntry);
                pReplaceEntry = pEntry->pLeft;
            }
        }
    }

    //
    // NOTE:  We can not save parent entry above because some code might
    // swap the tree around.  In which case, our parenty entry will change
    // out from underneath us.
    //
    pParentEntry = pEntry->pParent;

    //
    // Clear out the about-to-be-deleted cache entry
    //
    TRACE_OUT(( "reset deleted node" ));
    CHInitEntry(pEntry);

    if (pReplaceEntry != NULL)
    {
        //
        // Fix up parent pointers, and calculate new heights of subtree
        //
        TRACE_OUT(( "fixup parent pointer of replacement node" ));
        pReplaceEntry->pParent = pParentEntry;
        newHeight = (WORD)(1 + max(pReplaceEntry->lHeight, pReplaceEntry->rHeight));
    }
    else
    {
        newHeight = 0;
    }
    TRACE_OUT(( "new height of parent is %d", newHeight ));

    if (pParentEntry != NULL)
    {
        //
        // Fixup parent entry pointers
        //
        TRACE_OUT(( "fix-up parent node" ));
        if (pParentEntry->pRight == pEntry)
        {
            //
            //  Entry is right child of parent
            //
            TRACE_OUT(( "replacement node is right son" ));
            pParentEntry->pRight = pReplaceEntry;
            pParentEntry->rHeight = newHeight;
        }
        else
        {
            //
            // Entry is left child of parent
            //
            TRACE_OUT(( "replacement node is left son" ));
            pParentEntry->pLeft = pReplaceEntry;
            pParentEntry->lHeight = newHeight;
        }

        //
        // Now rebalance the tree if necessary
        //
        CHAvlBalanceTree(pCache, pParentEntry);
    }
    else
    {
        //
        // Replacement is now root of tree
        //
        TRACE_OUT(( "replacement node is now root of tree" ));
        pCache->pRoot = pReplaceEntry;
    }


    //
    // Put entry back into free list.
    //
    pEntry->free = pCache->free;
    pCache->free = (WORD)iCacheEntry;

    DebugExitVOID(ASHost::CHAvlDelete);
}


//
// Name:      CHAvlNext
//
// Purpose:   Find next node in the AVL tree
//
// Returns:   A pointer to the next node's data
//
// Params:    IN     pEntry             - a pointer to the current node in
//                                       the tree
//
// Operation: If the specified node has a right-son then return the left-
//            most son of this. Otherwise search back up until we find a
//            node of which we are in the left sub-tree and return that.
//
//
LPBYTE ASHost::CHAvlNext
(
    PCHENTRY pEntry
)
{
    //
    // find next node in tree
    //
    DebugEntry(ASHost::CHAvlNext);

    ASSERT(IsValidCacheEntry(pEntry));
    ASSERT(IsCacheEntryInTree(pEntry));

    if (pEntry->pRight != NULL)
    {
        //
        // Next entry is the left-most in the right-subtree
        //
        TRACE_OUT(( "next node is left-most right descendent" ));
        pEntry = pEntry->pRight;
        ASSERT(IsValidCacheEntry(pEntry));

        while (pEntry->pLeft != NULL)
        {
            ASSERT(IsValidCacheEntry(pEntry->pLeft));
            pEntry = pEntry->pLeft;
        }
    }
    else
    {
        //
        // No right child.  So find an entry for which we are in its left
        // subtree.
        //
        TRACE_OUT(( "find node which this is in left subtree of" ));

        while (pEntry != NULL)
        {
            ASSERT(IsValidCacheEntry(pEntry));

            if ((pEntry->pParent == NULL) ||
                (pEntry->pParent->pLeft == pEntry))
            {
                pEntry = pEntry->pParent;
                break;
            }
            pEntry = pEntry->pParent;
        }
    }

    DebugExitVOID(ASHost::CHAvlNext);
    return((pEntry != NULL) ? pEntry->pData : NULL);
}



//
// Name:      CHAvlPrev
//
// Purpose:   Find previous node in the AVL tree
//
// Returns:   A pointer to the previous node's data in the tree
//
// Params:    IN     PNode             - a pointer to the current node in
//                                       the tree
//
// Operation: If we have a left-son then the previous node is the right-most
//            son of this. Otherwise, look for a node of whom we are in the
//            left subtree and return that.
//
//
LPBYTE  ASHost::CHAvlPrev(PCHENTRY pEntry)
{
    //
    // find previous node in tree
    //
    DebugEntry(ASHost::CHAvlPrev);

    ASSERT(IsValidCacheEntry(pEntry));
    ASSERT(IsCacheEntryInTree(pEntry));

    if (pEntry->pLeft != NULL)
    {
        //
        // Previous entry is right-most in left-subtree
        //
        TRACE_OUT(( "previous node is right-most left descendent" ));

        pEntry = pEntry->pLeft;
        ASSERT(IsValidCacheEntry(pEntry));

        while (pEntry->pRight != NULL)
        {
            ASSERT(IsValidCacheEntry(pEntry->pRight));
            pEntry = pEntry->pRight;
        }
    }
    else
    {
        //
        // No left child.  So find an entry for which we are in the right
        // subtree.
        //
        TRACE_OUT(( "find node which this is in right subtree of"));
        while (pEntry != NULL)
        {
            ASSERT(IsValidCacheEntry(pEntry));

            if ((pEntry->pParent == NULL) ||
                (pEntry->pParent->pRight == pEntry))
            {
                pEntry = pEntry->pParent;
                break;
            }

            pEntry = pEntry->pParent;
        }
    }

    DebugExitVOID(ASHost::CHAvlPrev);
    return((pEntry != NULL) ? pEntry->pData : NULL);
}



//
// Name:      CHAvlFindEqual
//
// Purpose:   Find the node in the AVL tree with the same key and size as
//            the supplied node
//
// Returns:   A pointer to the node
//            NULL if no node is found with the specified key and size
//
// Params:    IN     pCache              - a pointer to the AVL tree
//            IN     pEntry              - a pointer to the node to test
//
// Operation: Check if the left node has the same key and size, returning
//            a pointer to its data if it does.
//
//
PCHENTRY  ASHost::CHAvlFindEqual
(
    PCHCACHE    pCache,
    PCHENTRY    pEntry
)
{
    int         result;
    PCHENTRY    pReturn = NULL;

    DebugEntry(ASHost::CHAvlFindEqual);

    ASSERT(IsValidCacheEntry(pEntry));

    if (pEntry->pLeft)
    {
        ASSERT(IsValidCacheEntry(pEntry->pLeft));

        result = CHCompare(pEntry->pLeft->checkSum, pEntry->cbData, pEntry);

        if (result < 0)
        {
            //
            // specified key is less than key of this node - this is what
            // will normally occur
            //
            TRACE_OUT(( "left node size %u csum 0x%08x",
                     pEntry->pLeft->cbData,
                     pEntry->pLeft->checkSum));
        }
        else if (result == 0)
        {
            //
            // Found a match on size and key.
            //
            TRACE_OUT(( "left node dups size and key" ));
            pReturn = pEntry->pLeft;
        }
        else
        {
            //
            // This is an error (left node should never be greater)
            //
            ERROR_OUT(( "left node csum %#lx, supplied %#lx",
                     pEntry->pLeft->checkSum,
                     pEntry->checkSum));
        }
    }

    DebugExitPVOID(ASHost::CHAvlFindEqual, pReturn);
    return(pReturn);
}





//
// Name:      CHAvlFind
//
// Purpose:   Find the node in the AVL tree with the supplied key and size
//
// Returns:   A pointer to the node
//            NULL if no node is found with the specified key and size
//
// Params:    IN     pCache              - a pointer to the AVL tree
//            IN     checkSum           - a pointer to the key
//            IN     cbSize             - number of node data bytes
//
// Operation: Search down the tree going left if the search key is less than
//            the node in the tree and right if the search key is greater.
//            When we run out of tree to search through either we've found
//            it or the node is not in the tree.
//
//
PCHENTRY  ASHost::CHAvlFind
(
    PCHCACHE    pCache,
    UINT        checkSum,
    UINT        cbSize
)
{
    PCHENTRY    pEntry;
    int         result;

//    DebugEntry(ASHost::CHAvlFind);

    pEntry = pCache->pRoot;

    while (pEntry != NULL)
    {
        ASSERT(IsValidCacheEntry(pEntry));

        //
        // Compare the supplied key (checksum) with that of the current node
        //
        result = CHCompare(checkSum, cbSize, pEntry);

        if (result > 0)
        {
            //
            // Supplied key is greater than that of this entry, so look in
            // the right subtree
            //
            pEntry = pEntry->pRight;
            TRACE_OUT(( "move down right subtree to node 0x%08x", pEntry));
        }
        else if (result < 0)
        {
            //
            // Supplied key is lesser than that of this entry, so look in
            // the left subtree
            //
            pEntry = pEntry->pLeft;
            TRACE_OUT(( "move down left subtree to node 0x%08x", pEntry));
        }
        else
        {
            //
            // We found the FIRST entry with an identical key (checksum).
            //
            TRACE_OUT(( "found requested node" ));
            break;
        }
    }

//    DebugExitPVOID(ASHost::CHAvlFind, pEntry);
    return(pEntry);
}




//
// Name:      CHAvlBalanceTree
//
// Purpose:   Reblance the tree starting at the supplied node and ending at
//            the root of the tree
//
// Returns:   Nothing
//
// Params:    IN     pCache             - a pointer to the AVL tree
//            IN     pEntry             - a pointer to the node to start
//                                       balancing from
//
//
void  ASHost::CHAvlBalanceTree
(
    PCHCACHE pCache,
    PCHENTRY pEntry
)
{
    //
    // Balance the tree starting at the given entry, ending with the root
    // of the tree
    //
    DebugEntry(ASHost::CHAvlBalanceTree);

    ASSERT(IsValidCacheEntry(pEntry));

    while (pEntry->pParent != NULL)
    {
        ASSERT(IsValidCacheEntry(pEntry->pParent));

        //
        // node has uneven balance, so may need to rebalance it
        //
        TRACE_OUT(( "check node balance" ));
        TRACE_OUT(( "  rHeight = %hd", pEntry->rHeight ));
        TRACE_OUT(( "  lHeight = %hd", pEntry->lHeight ));

        if (pEntry->pParent->pRight == pEntry)
        {
            //
            // node is right-son of its parent
            //
            TRACE_OUT(( "node is right-son" ));
            pEntry = pEntry->pParent;
            CHAvlRebalance(&pEntry->pRight);

            //
            // now update the right height of the parent
            //
            pEntry->rHeight = (WORD)
                 (1 + max(pEntry->pRight->rHeight, pEntry->pRight->lHeight));
            TRACE_OUT(( "new rHeight = %d", pEntry->rHeight ));
        }
        else
        {
            //
            // node is left-son of its parent
            //
            TRACE_OUT(( "node is left-son" ));
            pEntry = pEntry->pParent;
            CHAvlRebalance(&pEntry->pLeft);

            //
            // now update the left height of the parent
            //
            pEntry->lHeight = (WORD)
                   (1 + max(pEntry->pLeft->rHeight, pEntry->pLeft->lHeight));
            TRACE_OUT(( "new lHeight = %d", pEntry->lHeight ));
        }

        ASSERT(IsValidCacheEntry(pEntry));
    }

    if (pEntry->lHeight != pEntry->rHeight)
    {
        //
        // rebalance root node
        //
        TRACE_OUT(( "rebalance root node"));
        CHAvlRebalance(&pCache->pRoot);
    }

    DebugExitVOID(ASHost::CHAvlBalanceTree);
}

//
// Name:      CHAvlRebalance
//
// Purpose:   Reblance a subtree of the AVL tree (if necessary)
//
// Returns:   Nothing
//
// Params:    IN/OUT ppSubtree         - a pointer to the subtree to
//                                       rebalance
//
//
void  ASHost::CHAvlRebalance
(
    PCHENTRY *  ppSubtree
)
{
    int         moment;

    DebugEntry(ASHost::CHAvlRebalance);

    ASSERT(IsValidCacheEntry(*ppSubtree));

    TRACE_OUT(( "rebalance subtree" ));
    TRACE_OUT(( "  rHeight = %hd", (*ppSubtree)->rHeight ));
    TRACE_OUT(( "  lHeight = %hd", (*ppSubtree)->lHeight ));

    //
    // How unbalanced - don't want to recalculate
    //
    moment = (*ppSubtree)->rHeight - (*ppSubtree)->lHeight;

    if (moment > 1)
    {
        //
        // subtree is heavy on the right side
        //
        TRACE_OUT(( "subtree is heavy on right side" ));
        TRACE_OUT(( "right subtree" ));
        TRACE_OUT(( "  rHeight = %d", (*ppSubtree)->pRight->rHeight ));
        TRACE_OUT(( "  lHeight = %d", (*ppSubtree)->pRight->lHeight ));
        if ((*ppSubtree)->pRight->lHeight > (*ppSubtree)->pRight->rHeight)
        {
            //
            // right subtree is heavier on left side, so must perform right
            // rotation on this subtree to make it heavier on the right
            // side
            //
            TRACE_OUT(( "right subtree is heavier on left side ..." ));
            TRACE_OUT(( "... so rotate it right" ));
            CHAvlRotateRight(&(*ppSubtree)->pRight);
            TRACE_OUT(( "right subtree" ));
            TRACE_OUT(( "  rHeight = %d", (*ppSubtree)->pRight->rHeight ));
            TRACE_OUT(( "  lHeight = %d", (*ppSubtree)->pRight->lHeight ));
        }

        //
        // now rotate the subtree left
        //
        TRACE_OUT(( "rotate subtree left" ));
        CHAvlRotateLeft(ppSubtree);
    }
    else if (moment < -1)
    {
        //
        // subtree is heavy on the left side
        //
        TRACE_OUT(( "subtree is heavy on left side" ));
        TRACE_OUT(( "left subtree" ));
        TRACE_OUT(( "  rHeight = %d", (*ppSubtree)->pLeft->rHeight ));
        TRACE_OUT(( "  lHeight = %d", (*ppSubtree)->pLeft->lHeight ));
        if ((*ppSubtree)->pLeft->rHeight > (*ppSubtree)->pLeft->lHeight)
        {
            //
            // left subtree is heavier on right side, so must perform left
            // rotation on this subtree to make it heavier on the left side
            //
            TRACE_OUT(( "left subtree is heavier on right side ..." ));
            TRACE_OUT(( "... so rotate it left" ));
            CHAvlRotateLeft(&(*ppSubtree)->pLeft);
            TRACE_OUT(( "left subtree" ));
            TRACE_OUT(( "  rHeight = %d", (*ppSubtree)->pLeft->rHeight ));
            TRACE_OUT(( "  lHeight = %d", (*ppSubtree)->pLeft->lHeight ));
        }

        //
        // now rotate the subtree right
        //
        TRACE_OUT(( "rotate subtree right" ));
        CHAvlRotateRight(ppSubtree);
    }

    TRACE_OUT(( "balanced subtree" ));
    TRACE_OUT(( "  rHeight = %d", (*ppSubtree)->rHeight ));
    TRACE_OUT(( "  lHeight = %d", (*ppSubtree)->lHeight ));

    DebugExitVOID(ASHost::CHAvlRebalance);
}

//
// Name:      CHAvlRotateRight
//
// Purpose:   Rotate a subtree of the AVL tree right
//
// Returns:   Nothing
//
// Params:    IN/OUT ppSubtree         - a pointer to the subtree to rotate
//
//
void  ASHost::CHAvlRotateRight
(
    PCHENTRY * ppSubtree
)
{
    PCHENTRY pLeftSon;

    DebugEntry(ASHost::CHAvlRotateRight);

    ASSERT(IsValidCacheEntry(*ppSubtree));
    pLeftSon = (*ppSubtree)->pLeft;
    ASSERT(IsValidCacheEntry(pLeftSon));

    (*ppSubtree)->pLeft = pLeftSon->pRight;
    if ((*ppSubtree)->pLeft != NULL)
    {
        (*ppSubtree)->pLeft->pParent = (*ppSubtree);
    }
    (*ppSubtree)->lHeight = pLeftSon->rHeight;

    pLeftSon->pParent = (*ppSubtree)->pParent;

    pLeftSon->pRight = *ppSubtree;
    pLeftSon->pRight->pParent = pLeftSon;
    pLeftSon->rHeight = (WORD)
                   (1 + max((*ppSubtree)->rHeight, (*ppSubtree)->lHeight));

    *ppSubtree = pLeftSon;

    DebugExitVOID(ASHost::CHAvlRotateRight);
}

//
// Name:      CHAvlRotateLeft
//
// Purpose:   Rotate a subtree of the AVL tree left
//
// Returns:   Nothing
//
// Params:    IN/OUT ppSubtree        - a pointer to the subtree to rotate
//
//
void  ASHost::CHAvlRotateLeft
(
    PCHENTRY *  ppSubtree
)
{
    PCHENTRY    pRightSon;

    DebugEntry(ASHost::CHAvlRotateLeft);

    ASSERT(IsValidCacheEntry(*ppSubtree));
    pRightSon = (*ppSubtree)->pRight;
    ASSERT(IsValidCacheEntry(pRightSon));

    (*ppSubtree)->pRight = pRightSon->pLeft;
    if ((*ppSubtree)->pRight != NULL)
    {
        (*ppSubtree)->pRight->pParent = (*ppSubtree);
    }
    (*ppSubtree)->rHeight = pRightSon->lHeight;

    pRightSon->pParent = (*ppSubtree)->pParent;

    pRightSon->pLeft = *ppSubtree;
    pRightSon->pLeft->pParent = pRightSon;
    pRightSon->lHeight = (WORD)
                   (1 + max((*ppSubtree)->rHeight, (*ppSubtree)->lHeight));

    *ppSubtree = pRightSon;

    DebugExitVOID(ASHost::CHAvlRotateLeft);
}


//
// Name:      CHAvlSwapRightmost
//
// Purpose:   Swap node with right-most descendent of subtree
//
// Returns:   Nothing
//
// Params:    IN     pCache             - a pointer to the tree
//            IN     pSubtree          - a pointer to the subtree
//            IN     pEntry             - a pointer to the node to swap
//
//
void  ASHost::CHAvlSwapRightmost
(
    PCHCACHE    pCache,
    PCHENTRY    pSubtree,
    PCHENTRY    pEntry
)
{
    PCHENTRY    pSwapEntry;
    PCHENTRY    pSwapParent;
    PCHENTRY    pSwapLeft;

    DebugEntry(ASHost::CHAvlSwapRightmost);

    ASSERT(IsValidCacheEntry(pEntry));
    ASSERT((pEntry->pRight != NULL));
    ASSERT((pEntry->pLeft != NULL));

    //
    // find right-most descendent of subtree
    //
    ASSERT(IsValidCacheEntry(pSubtree));
    pSwapEntry = pSubtree;
    while (pSwapEntry->pRight != NULL)
    {
        pSwapEntry = pSwapEntry->pRight;
        ASSERT(IsValidCacheEntry(pSwapEntry));
    }

    ASSERT((pSwapEntry->rHeight == 0));
    ASSERT((pSwapEntry->lHeight <= 1));

    //
    // save parent and left-son of right-most descendent
    //
    pSwapParent = pSwapEntry->pParent;
    pSwapLeft = pSwapEntry->pLeft;

    //
    // move swap node to its new position
    //
    pSwapEntry->pParent = pEntry->pParent;
    pSwapEntry->pRight = pEntry->pRight;
    pSwapEntry->pLeft = pEntry->pLeft;
    pSwapEntry->rHeight = pEntry->rHeight;
    pSwapEntry->lHeight = pEntry->lHeight;
    pSwapEntry->pRight->pParent = pSwapEntry;
    pSwapEntry->pLeft->pParent = pSwapEntry;
    if (pEntry->pParent == NULL)
    {
        //
        // node is at root of tree
        //
        pCache->pRoot = pSwapEntry;
    }
    else if (pEntry->pParent->pRight == pEntry)
    {
        //
        // node is right-son of parent
        //
        pSwapEntry->pParent->pRight = pSwapEntry;
    }
    else
    {
        //
        // node is left-son of parent
        //
        pSwapEntry->pParent->pLeft = pSwapEntry;
    }

    //
    // move node to its new position
    //
    pEntry->pParent = pSwapParent;
    pEntry->pRight = NULL;
    pEntry->pLeft = pSwapLeft;
    if (pEntry->pLeft != NULL)
    {
        pEntry->pLeft->pParent = pEntry;
        pEntry->lHeight = 1;
    }
    else
    {
        pEntry->lHeight = 0;
    }
    pEntry->rHeight = 0;
    pEntry->pParent->pRight = pEntry;

    DebugExitVOID(ASHost::CHAvlSwapRightmost);
}

//
// Name:      CHAvlSwapLeftmost
//
// Purpose:   Swap node with left-most descendent of subtree
//
// Returns:   Nothing
//
// Params:    IN     pCache             - a pointer to the tree
//            IN     pSubtree          - a pointer to the subtree
//            IN     pEntry             - a pointer to the node to swap
//
//
void  ASHost::CHAvlSwapLeftmost
(
    PCHCACHE    pCache,
    PCHENTRY    pSubtree,
    PCHENTRY    pEntry
)
{
    PCHENTRY    pSwapEntry;
    PCHENTRY    pSwapParent;
    PCHENTRY    pSwapRight;

    DebugEntry(ASHost::CHAvlSwapLeftmost);

    ASSERT(IsValidCacheEntry(pEntry));
    ASSERT((pEntry->pRight != NULL));
    ASSERT((pEntry->pLeft != NULL));

    //
    // find left-most descendent of pSubtree
    //
    ASSERT(IsValidCacheEntry(pSubtree));
    pSwapEntry = pSubtree;
    while (pSwapEntry->pLeft != NULL)
    {
        pSwapEntry = pSwapEntry->pLeft;
        ASSERT(IsValidCacheEntry(pSwapEntry));
    }

    ASSERT((pSwapEntry->lHeight == 0));
    ASSERT((pSwapEntry->rHeight <= 1));

    //
    // save parent and right-son of left-most descendent
    //
    pSwapParent = pSwapEntry->pParent;
    pSwapRight = pSwapEntry->pRight;

    //
    // move swap node to its new position
    //
    pSwapEntry->pParent = pEntry->pParent;
    pSwapEntry->pRight = pEntry->pRight;
    pSwapEntry->pLeft = pEntry->pLeft;
    pSwapEntry->rHeight = pEntry->rHeight;
    pSwapEntry->lHeight = pEntry->lHeight;
    pSwapEntry->pRight->pParent = pSwapEntry;
    pSwapEntry->pLeft->pParent = pSwapEntry;
    if (pEntry->pParent == NULL)
    {
        //
        // node is at root of tree
        //
        pCache->pRoot = pSwapEntry;
    }
    else if (pEntry->pParent->pRight == pEntry)
    {
        //
        // node is right-son of parent
        //
        pSwapEntry->pParent->pRight = pSwapEntry;
    }
    else
    {
        //
        // node is left-son of parent
        //
        pSwapEntry->pParent->pLeft = pSwapEntry;
    }

    //
    // move node to its new position
    //
    pEntry->pParent = pSwapParent;
    pEntry->pRight = pSwapRight;
    pEntry->pLeft = NULL;
    if (pEntry->pRight != NULL)
    {
        pEntry->pRight->pParent = pEntry;
        pEntry->rHeight = 1;
    }
    else
    {
        pEntry->rHeight = 0;
    }
    pEntry->lHeight = 0;
    pEntry->pParent->pLeft = pEntry;

    DebugExitVOID(ASHost::CHAvlSwapLeftmost);
}


//
// Name:      CHCompare
//
// Purpose:   Standard function for comparing UINTs
//
// Returns:   -1 if key < pEntry->checksum
//            -1 if key = pEntry->checksum AND sizes do not match
//             0 if key = pEntry->checksum AND sizes match
//             1 if key > pEntry->checksum
//
// Params:    IN  key           - a pointer to the comparison key
//            IN  cbSize        - number of comparison data bytes
//            IN  pEntry         - a pointer to the node to compare
//
//
int  ASHost::CHCompare
(
    UINT        key,
    UINT        cbSize,
    PCHENTRY    pEntry
)
{
    int         ret_val;

    DebugEntry(ASHost::CHCompare);

    ASSERT(IsValidCacheEntry(pEntry));

    if (key < pEntry->checkSum)
    {
        ret_val = -1;
        TRACE_OUT(( "Key is less (-1)"));
    }
    else if (key > pEntry->checkSum)
    {
        ret_val = 1;
        TRACE_OUT(( "Key is more (+1)"));
    }
    else
    {
        if (cbSize == pEntry->cbData)
        {
            ret_val = 0;
            TRACE_OUT(( "Key and size match"));
        }
        else
        {
            ret_val = -1;
            TRACE_OUT(( "Key match, size mismatch (-1)"));
        }
    }

    DebugExitDWORD(ASHost::CHCompare, ret_val);
    return(ret_val);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\asmaster.cpp ===
#include "precomp.h"

#include <RegEntry.h>
#include <oprahcom.h>
#include <asmaster.h>

#define MLZ_FILE_ZONE  ZONE_CORE


ASMaster *g_pMaster = NULL;



HRESULT WINAPI CreateASObject
(
    IAppSharingNotify * pNotify,
    UINT                flags,
    IAppSharing**       ppAS
)
{
    HRESULT             hr  = E_OUTOFMEMORY;
    ASMaster *          pMaster = NULL;

    DebugEntry(CreateASObject);

    ASSERT(ppAS);

    if (g_pMaster != NULL)
    {
        ERROR_OUT(("CreateASObject:  IAppSharing * alreadycreated; only one allowed at a time"));
        hr = E_UNEXPECTED;
        DC_QUIT;
    }

    ASSERT(!g_asMainThreadId);
    ASSERT(!g_putOM);
    ASSERT(!g_putAL);
    ASSERT(!g_putAS);


    pMaster = new ASMaster(flags, pNotify);
    if (pMaster != NULL)
    {
        //
        // Register as the groupware primary, with an event proc but no exit proc
        //
        if (!UT_InitTask(UTTASK_UI, &g_putUI))
        {
            ERROR_OUT(("Failed to register UI task"));
            DC_QUIT;
        }

        UT_RegisterEvent(g_putUI, eventProc, g_putUI, UT_PRIORITY_NORMAL);

        // Start groupware thread.
        if (!DCS_StartThread(WorkThreadEntryPoint))
        {
            ERROR_OUT(("Couldn't start groupware thread"));
            DC_QUIT;
        }

        // Make sure the work thread initialization is ok
        if (! g_asMainThreadId)
        {
            ERROR_OUT(("Init failed in the work thread"));
            DC_QUIT;
        }

        //
        // Success!
        //
    }

    hr = S_OK;

DC_EXIT_POINT:
    if (!SUCCEEDED(hr))
    {
        if (pMaster)
        {
            ERROR_OUT(("CreateASObject:  Init of ASMaster failed"));
            pMaster->Release();
            pMaster = NULL;
        }
    }

    *ppAS = pMaster;
    DebugExitHRESULT(CreateASObject, hr);
    return hr;
}


ASMaster::ASMaster(UINT flags, IAppSharingNotify * pNotify) :
    m_cRefs              (1),
    m_pNotify            (pNotify)
{
    DebugEntry(ASMaster::ASMaster);

    if (m_pNotify)
    {
        m_pNotify->AddRef();
    }

    ASSERT(!g_pMaster);
    g_pMaster = this;

    //
    // Set up global flags:
    //      * service
    //      * unattended
    //
    g_asOptions = flags;

    DebugExitVOID(ASMaster::ASMaster);
}


ASMaster::~ASMaster()
{
    DebugEntry(ASMaster::~ASMaster);

    //
    // Kill any share that's current or pending in the queue
    // This will do nothing if no share is extant at the time the
    // message is received.
    //
    if (g_asMainWindow)
    {
        PostMessage(g_asMainWindow, DCS_KILLSHARE_MSG, 0, 0);
    }

    //
    // Kill off the worker thread
    //
    if (g_asMainThreadId)
    {
        PostThreadMessage(g_asMainThreadId, WM_QUIT, 0, 0);
    }

    //
    // Clean up the UI
    //
    if (g_putUI)
    {
        UT_TermTask(&g_putUI);
    }

    // global variables cleanup
    if (m_pNotify)
    {
        m_pNotify->Release();
        m_pNotify = NULL;
    }

    if (g_pMaster == this)
    {
        g_pMaster = NULL;
    }

    DebugExitVOID(ASMaster::~ASMaster);
}



STDMETHODIMP ASMaster::QueryInterface(REFIID iid, void ** pv)
{
    return E_NOINTERFACE;
}

STDMETHODIMP_(ULONG) ASMaster::AddRef()
{
    InterlockedIncrement(&m_cRefs);
    return m_cRefs;
}

STDMETHODIMP_(ULONG) ASMaster::Release()
{
    ASSERT(m_cRefs > 0);
    if (::InterlockedDecrement(&m_cRefs) == 0)
    {
        delete this;
        return 0;
    }

    return m_cRefs;
}




//
// WorkThreadEntryPoint()
//
// This is the groupware code--obman, taskloader, and app sharing
//

DWORD WINAPI WorkThreadEntryPoint(LPVOID hEventWait)
{
    BOOL            result = FALSE;
    BOOL            fCMGCleanup = FALSE;
    BOOL            fOMCleanup = FALSE;
    BOOL            fALCleanup = FALSE;
    BOOL            fDCSCleanup = FALSE;
    MSG             msg;
    HWND            hwndTop;

    DebugEntry(WorkThreadEntryPoint);

    //
    // Get the current thread ID.  This is used in the stop code to know
    // if the previous thread is still exiting.  In the run-when-windows
    // starts mode, our init code is called when Conf brings up UI and our
    // term code is called when Conf brings it down.  We have a race condition
    // because this thread is created on each init.  If we create a new
    // one while the old one is exiting, we will stomp over each other and
    // GP-fault.
    //
    g_asMainThreadId = GetCurrentThreadId();

    //
    // Get our policies
    //

    g_asPolicies = 0;

    if (g_asOptions & AS_SERVICE)
    {
        //
        // No old whiteboard, no how, for RDS
        //
        g_asPolicies |= SHP_POLICY_NOOLDWHITEBOARD;
    }
    else
    {
        RegEntry rePol(POLICIES_KEY, HKEY_CURRENT_USER);

        //
        // Is old whiteboard disabled?
        //
        if (rePol.GetNumber(REGVAL_POL_NO_OLDWHITEBOARD, DEFAULT_POL_NO_OLDWHITEBOARD))
        {
            WARNING_OUT(("Policy disables Old Whiteboard"));
            g_asPolicies |= SHP_POLICY_NOOLDWHITEBOARD;
        }

        //
        // Is application sharing disabled completely?
        //
        if (rePol.GetNumber(REGVAL_POL_NO_APP_SHARING, DEFAULT_POL_NO_APP_SHARING))
        {
            WARNING_OUT(("Policy disables App Sharing"));
            g_asPolicies |= SHP_POLICY_NOAPPSHARING;
        }
        else
        {
            //
            // Only grab AS policies if AS is even allowed
            //
            if (rePol.GetNumber(REGVAL_POL_NO_SHARING, DEFAULT_POL_NO_SHARING))
            {
                WARNING_OUT(("Policy prevents user from sharing"));
                g_asPolicies |= SHP_POLICY_NOSHARING;
            }

            if (rePol.GetNumber(REGVAL_POL_NO_MSDOS_SHARING, DEFAULT_POL_NO_MSDOS_SHARING))
            {
                WARNING_OUT(("Policy prevents user from sharing command prompt"));
                g_asPolicies |= SHP_POLICY_NODOSBOXSHARE;
            }

            if (rePol.GetNumber(REGVAL_POL_NO_EXPLORER_SHARING, DEFAULT_POL_NO_EXPLORER_SHARING))
            {
                WARNING_OUT(("Policy prevents user from sharing explorer"));
                g_asPolicies |= SHP_POLICY_NOEXPLORERSHARE;
            }

            if (rePol.GetNumber(REGVAL_POL_NO_DESKTOP_SHARING, DEFAULT_POL_NO_DESKTOP_SHARING))
            {
                WARNING_OUT(("Policy prevents user from sharing desktop"));
                g_asPolicies |= SHP_POLICY_NODESKTOPSHARE;
            }

            if (rePol.GetNumber(REGVAL_POL_NO_TRUECOLOR_SHARING, DEFAULT_POL_NO_TRUECOLOR_SHARING))
            {
                WARNING_OUT(("Policy prevents user from sharing in true color"));
                g_asPolicies |= SHP_POLICY_NOTRUECOLOR;
            }

            if (rePol.GetNumber(REGVAL_POL_NO_ALLOW_CONTROL, DEFAULT_POL_NO_ALLOW_CONTROL))
            {
                WARNING_OUT(("Policy prevents user from letting others control"));
                g_asPolicies |= SHP_POLICY_NOCONTROL;
            }
        }
    }


    // Register the call primary code, for T.120 GCC
    if (!CMP_Init(&fCMGCleanup))
    {
        ERROR_OUT(("CMP_Init failed"));
        DC_QUIT;
    }

    if (!(g_asPolicies & SHP_POLICY_NOOLDWHITEBOARD))
    {
        if (!OMP_Init(&fOMCleanup))
        {
            ERROR_OUT(("Couldn't start ObMan"));
            DC_QUIT;
        }

        if (!ALP_Init(&fALCleanup))
        {
            ERROR_OUT(("Couldn't start AppLoader"));
            DC_QUIT;
        }
    }

    //
    // Do DCS fast init; slow font enum will happen later off a posted
    // message.  We can still share & participate in sharing without a
    // full font list...
    //
    if (!(g_asPolicies & SHP_POLICY_NOAPPSHARING))
    {
        fDCSCleanup = TRUE;
        if (!DCS_Init())
        {
            ERROR_OUT(("AS did not initialize"));
            DC_QUIT;
        }
    }

    //
    // We've successfully initialised - let the thread which created this
    // one continue
    //
    SetEvent((HANDLE)hEventWait);


    //
    // Enter the main message processing loop:
    //

    while (GetMessage(&msg, NULL, 0, 0))
    {
        //
        // For dialogs, it's OK to do normal message processing.
        //
        if (hwndTop = IsForDialog(msg.hwnd))
        {
            if (!IsDialogMessage(hwndTop, &msg))
            {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
            }
        }
        else
        {
            //
            // Note that this message dispatch loop DOES NOT include a call to
            // Translate Message.  This is because we do not want it to call
            // ToAscii and affect the state maintained internally by ToAscii.
            // We will call ToAscii ourselves in the IM when the user is typing
            // in a view and calling it more than once for a keystroke
            // will cause it to return wrong results (eg for dead keys).
            //
            // The consequence of this is that any windows which are driven by
            // this dispatch loop will NOT receive WM_CHAR or WM_SYSCHAR
            // messages.  This is not a problem for dialog windows belonging to
            // a task using this message loop as the dialog will run its own
            // dispatch loop.
            //
            // If it becomes necessary for windows driven by this dispatch loop
            // to get their messages translated then we could add logic to
            // determine whether the message is destined for a view
            // before deciding whether to translate it.
            //

            //
            // Because we don't have a translate message in our message loop we
            // need to do the following to ensure the keyboard LEDs follow what
            // the user does when their input is going to this message loop.
            //
            if (((msg.message == WM_KEYDOWN) ||
                 (msg.message == WM_SYSKEYDOWN) ||
                 (msg.message == WM_KEYUP) ||
                 (msg.message == WM_SYSKEYUP)) &&
                IM_KEY_IS_TOGGLE(msg.wParam))
            {
                BYTE        kbState[256];

                //
                // There is a chance the LEDs state has changed so..
                //
                GetKeyboardState(kbState);
                SetKeyboardState(kbState);
            }

            DispatchMessage(&msg);
        }
   }

   result = (int)msg.wParam;

   //
   // We emerge from the processing loop when someone posts us a WM_QUIT.
   // We do ObMan specific termination then call UT_TermTask (which will
   // call any exit procedures we have registered).
   //

DC_EXIT_POINT:

    if (fDCSCleanup)
        DCS_Term();

    if (fALCleanup)
        ALP_Term();

    if (fOMCleanup)
        OMP_Term();

    if (fCMGCleanup)
        CMP_Term();

    g_asMainThreadId = 0;

    DebugExitDWORD(WorkThreadEntryPoint, result);
    return(result);
}



//
// IsForDialog()
// Returns if the message is intended for a window in a dialog.  AppSharing
// has the host UI dialog, incoming request dialogs, and possibly
// notification message box dialogs.
//
HWND IsForDialog(HWND hwnd)
{
    BOOL    rc = FALSE;
    HWND    hwndParent;

    DebugEntry(IsForDialog);

    if (!hwnd)
        DC_QUIT;

    while (GetWindowLong(hwnd, GWL_STYLE) & WS_CHILD)
    {
        hwndParent = GetParent(hwnd);
        if (hwndParent == GetDesktopWindow())
            break;

        hwnd = hwndParent;
    }

    if (GetWindowLong(hwnd, GWL_EXSTYLE) & WS_EX_DLGMODALFRAME)
    {
        // This is a dialog
    }
    else
    {
        hwnd = NULL;
    }

DC_EXIT_POINT:
    DebugExitPTR(IsForDialog, hwnd);
    return(hwnd);
}


//
// ASMaster member functions
//
//



//
//
// ASMaster::OnEvent
//
// Parameters: event    event type
//             param1   other parameter
//             param2   other parameter
//
//



BOOL CALLBACK eventProc
(
    LPVOID  cpiHandle_,
    UINT    event,
    UINT_PTR param1,
    UINT_PTR param2
)
{
    BOOL    rc;

    if (g_pMaster)
    {
        rc = g_pMaster->OnEvent(event, param1, param2);
    }
    else
    {
        WARNING_OUT(("Received ASMaster event %d but no g_pMaster", event));
        rc = FALSE;
    }

    return rc;
}



BOOL ASMaster::OnEvent
(
    UINT    event,
    UINT_PTR param1,
    UINT_PTR param2
)
{
    BOOL    rc = TRUE;

    DebugEntry(ASMaster::OnEvent);

    if (!m_pNotify)
    {
        // Nothing to do
        rc = FALSE;
        DC_QUIT;
    }

    switch (event)
    {
        case SH_EVT_APPSHARE_READY:
            m_pNotify->OnReadyToShare(param1 != 0);
            break;

        case SH_EVT_SHARE_STARTED:
            m_pNotify->OnShareStarted();
            break;

        case SH_EVT_SHARING_STARTED:
            m_pNotify->OnSharingStarted();
            break;

        case SH_EVT_SHARE_ENDED:
            m_pNotify->OnShareEnded();
            break;

        case SH_EVT_PERSON_JOINED:
            m_pNotify->OnPersonJoined((IAS_GCC_ID)param1);
            break;

        case SH_EVT_PERSON_LEFT:
            m_pNotify->OnPersonLeft((IAS_GCC_ID)param1);
            break;

        case SH_EVT_STARTINCONTROL:
            m_pNotify->OnStartInControl((IAS_GCC_ID)param1);
            break;

        case SH_EVT_STOPINCONTROL:
            m_pNotify->OnStopInControl((IAS_GCC_ID)param1);
            break;

        case SH_EVT_PAUSEDINCONTROL:
            m_pNotify->OnPausedInControl((IAS_GCC_ID)param1);
            break;

        case SH_EVT_UNPAUSEDINCONTROL:
            m_pNotify->OnUnpausedInControl((IAS_GCC_ID)param1);
            break;

        case SH_EVT_CONTROLLABLE:
            m_pNotify->OnControllable(param1 != 0);
            break;

        case SH_EVT_STARTCONTROLLED:
            m_pNotify->OnStartControlled((IAS_GCC_ID)param1);
            break;

        case SH_EVT_STOPCONTROLLED:
            m_pNotify->OnStopControlled((IAS_GCC_ID)param1);
            break;

        case SH_EVT_PAUSEDCONTROLLED:
            m_pNotify->OnPausedControlled((IAS_GCC_ID)param1);
            break;

        case SH_EVT_UNPAUSEDCONTROLLED:
            m_pNotify->OnUnpausedControlled((IAS_GCC_ID)param1);
            break;

        default:
            // Unrecognized, unhandled event
            rc = FALSE;
            break;
    }

DC_EXIT_POINT:
    DebugExitBOOL(ASMaster::OnEvent, rc);
    return(rc);
}


//
// ASMaster::IsSharingAvailable()
//
STDMETHODIMP_(BOOL) ASMaster::IsSharingAvailable()
{
    return(g_asSession.hwndHostUI != NULL);
}



//
// ASMaster::CanShareNow()
//
STDMETHODIMP_(BOOL) ASMaster::CanShareNow()
{
    BOOL    rc = FALSE;

    UT_Lock(UTLOCK_AS);

    //
    // We can share if
    //      * We can capture graphic output on this OS
    //      * We're in a call
    //
    if (g_asSession.hwndHostUI     &&
        g_asSession.callID         &&
        (g_asSession.attendeePermissions & NM_PERMIT_SHARE) &&
        (g_s20State >= S20_NO_SHARE))
    {
        rc = TRUE;
    }

    UT_Unlock(UTLOCK_AS);

    return(rc);
}


//
// ASMaster::InInShare()
//
STDMETHODIMP_(BOOL) ASMaster::IsInShare()
{
    return(g_asSession.pShare != NULL);
}


//
// ASMaster::IsSharing()
//
STDMETHODIMP_(BOOL) ASMaster::IsSharing()
{
    IAS_PERSON_STATUS personStatus;

    ::ZeroMemory(&personStatus, sizeof(personStatus));
    personStatus.cbSize = sizeof(personStatus);
    GetPersonStatus(0, &personStatus);

    return(personStatus.AreSharing != 0);
}


//
// CanAllowControl()
// We can allow control if we're sharing and it's not prevented by policy
//
STDMETHODIMP_(BOOL) ASMaster::CanAllowControl(void)
{
    if (g_asPolicies & SHP_POLICY_NOCONTROL)
        return(FALSE);

    return(IsSharing());
}


//
// IsControllable()
// We are controllable if our state isn't detached.
//
STDMETHODIMP_(BOOL) ASMaster::IsControllable(void)
{
    IAS_PERSON_STATUS personStatus;

    ::ZeroMemory(&personStatus, sizeof(personStatus));
    personStatus.cbSize = sizeof(personStatus);
    GetPersonStatus(0, &personStatus);

    return(personStatus.Controllable != 0);
}



//
// GetPersonStatus()
//
STDMETHODIMP ASMaster::GetPersonStatus(IAS_GCC_ID Person, IAS_PERSON_STATUS * pStatus)
{
    return(::SHP_GetPersonStatus(Person, pStatus));
}




//
// ASMaster::IsWindowShareable()
//
STDMETHODIMP_(BOOL) ASMaster::IsWindowShareable(HWND hwnd)
{
    return(CanShareNow() && HET_IsWindowShareable(hwnd));
}


//
// ASMaster::IsWindowShared()
//
STDMETHODIMP_(BOOL) ASMaster::IsWindowShared(HWND hwnd)
{
    return(HET_IsWindowShared(hwnd));
}




//
//
// ASMaster::Share
//
// Parameters: HWND of the window to share.  This can be any (valid) HWND.
//
//
STDMETHODIMP ASMaster::Share(HWND hwnd, IAS_SHARE_TYPE uAppType)
{
    HRESULT     hr;

    DebugEntry(ASMaster::Share);

    hr = E_FAIL;

    if (!CanShareNow())
    {
        WARNING_OUT(("Share failing; can't share now"));
        DC_QUIT;
    }

    //
    // If this is the desktop, check for a policy against just it.
    //
    if (hwnd == ::GetDesktopWindow())
    {
        if (g_asPolicies & SHP_POLICY_NODESKTOPSHARE)
        {
            WARNING_OUT(("Sharing desktop failing; prevented by policy"));
            DC_QUIT;
        }
    }

    switch (uAppType)
    {
        case IAS_SHARE_DEFAULT:
        case IAS_SHARE_BYPROCESS:
        case IAS_SHARE_BYTHREAD:
        case IAS_SHARE_BYWINDOW:
            break;

        default:
        {
            ERROR_OUT(("IAppSharing::Share - invalid share type %d", uAppType));
            return E_INVALIDARG;
        }
    }

    if (SHP_Share(hwnd, uAppType))
    {
        hr = S_OK;
    }

DC_EXIT_POINT:
    DebugExitHRESULT(ASMaster::Share, hr);
    return hr;
}


//
//
// ASMaster::Unshare
//
// Parameters: HWND of the window to unshare
//
//
STDMETHODIMP ASMaster::Unshare(HWND hwnd)
{
    return(::SHP_Unshare(hwnd));
}


//
//
// ASMaster::LaunchHostUI()
//
//
STDMETHODIMP ASMaster::LaunchHostUI(void)
{
    return(SHP_LaunchHostUI());
}



//
//
// ASMaster::GetShareableApps
//
// Generates a list of HWND's into <validAppList>
// These objects are allocated dynamically, so must be deleted by the
// caller.
//
//
STDMETHODIMP ASMaster::GetShareableApps(IAS_HWND_ARRAY **ppHwnds)
{
    if (!CanShareNow())
        return(E_FAIL);

    return(HET_GetAppsList(ppHwnds) ? S_OK : E_FAIL);
}


STDMETHODIMP ASMaster::FreeShareableApps(IAS_HWND_ARRAY * pMemory)
{
    HET_FreeAppsList(pMemory);
    return S_OK;
}




//
// TakeControl()
//
// From viewer to host, asking to take control of host.
//
STDMETHODIMP ASMaster::TakeControl(IAS_GCC_ID PersonOf)
{
    return(SHP_TakeControl(PersonOf));
}



//
// CancelTakeControl()
//
// From viewer to host, to cancel pending TakeControl request.
//
STDMETHODIMP ASMaster::CancelTakeControl(IAS_GCC_ID PersonOf)
{
    return(SHP_CancelTakeControl(PersonOf));
}


//
// ReleaseControl()
//
// From viewer to host, telling host that viewer is not in control of host
// anymore.
//
STDMETHODIMP ASMaster::ReleaseControl(IAS_GCC_ID PersonOf)
{
    return(SHP_ReleaseControl(PersonOf));
}


//
// PassControl()
//
// From viewer to host, when viewer is in control of host, asking to pass
// control of host to a different viewer.
STDMETHODIMP ASMaster::PassControl(IAS_GCC_ID PersonOf, IAS_GCC_ID PersonTo)
{
    return(SHP_PassControl(PersonOf, PersonTo));
}


//
// AllowControl()
//
// On host side, to allow/stop allowing control at all of shared apps/desktop.
// When one starts to host, allowing control always starts as off.  So
// turning on allowing control, stopping sharing, then sharing something
// else will not leave host vulnerable.
//
// When turning it off, if a viewer was in control of the host, kill control
// from the host to the viewer will occur first.
//
// The "ESC" key is an accelerator to stop allowing control, when pressed
// by the user on the host who is currently controlled.
//
STDMETHODIMP ASMaster::AllowControl(BOOL fAllow)
{
    return(::SHP_AllowControl(fAllow));
}



//
// GiveControl()
//
// From host to viewer, inviting the viewer to take control of the host.
// It's the inverse of TakeControl.
//
STDMETHODIMP ASMaster::GiveControl(IAS_GCC_ID PersonTo)
{
    return(SHP_GiveControl(PersonTo));
}



//
// CancelGiveControl()
//
// From host to viewer, to cancel pending GiveControl request
//
STDMETHODIMP ASMaster::CancelGiveControl(IAS_GCC_ID PersonTo)
{
    return(SHP_CancelGiveControl(PersonTo));
}


//
// RevokeControl()
//
// From host to viewer, when host wishes to stop viewer from controlling him.
// AllowControl is still on, for another to possibly take control of the host.
//
// Mouse clicks and key presses other than "ESC" by the user on the controlled
// host host areaccelerators to kill control.
//
STDMETHODIMP ASMaster::RevokeControl(IAS_GCC_ID PersonTo)
{
    return(SHP_RevokeControl(PersonTo));
}





//
// PauseControl()
//
// On host, to temporarily allow local user to do stuff without breaking
// control bond.  We put the viewer on hold.
//
STDMETHODIMP ASMaster::PauseControl(IAS_GCC_ID PersonInControl)
{
    return(SHP_PauseControl(PersonInControl, TRUE));
}



//
// UnpauseControl()
//
// On host, to unpause control that has been paused.  We take the viewer
// off hold.
//
STDMETHODIMP ASMaster::UnpauseControl(IAS_GCC_ID PersonInControl)
{
    return(SHP_PauseControl(PersonInControl, FALSE));
}



//
// StartStopOldWB
//
extern "C"
{
BOOL WINAPI StartStopOldWB(LPCTSTR szFile)
{
    LPTSTR szCopyOfFile;

    ValidateUTClient(g_putUI);

    if (g_asPolicies & SHP_POLICY_NOOLDWHITEBOARD)
    {
        WARNING_OUT(("Not launching old whiteboard; prevented by policy"));
        return(FALSE);
    }

    //
    // Because we're posting a message effectively, we have to make a
    // copy of the string.  If we ever have "SendEvent", we won't have
    // that problem anymore.
    //
    if (szFile)
    {
        int     cchLength;
        BOOL    fSkippedQuote;

        // Skip past first quote
        if (fSkippedQuote = (*szFile == '"'))
            szFile++;

        cchLength = lstrlen(szFile);
        szCopyOfFile = (LPTSTR)::GlobalAlloc(GPTR, (cchLength+1)*sizeof(TCHAR));
        if (!szCopyOfFile)
        {
            ERROR_OUT(("Can't make file name copy for whiteboard launch"));
            return(FALSE);
        }

        lstrcpy(szCopyOfFile, szFile);

        //
        // NOTE:
        // There may be DBCS implications with this.  Hence we check to see
        // if we skipped the first quote; we assume that if the file name
        // starts with a quote it must end with one also.  But we need to check
        // it out.
        //
        // Strip last quote
        if (fSkippedQuote && (cchLength > 0) && (szCopyOfFile[cchLength - 1] == '"'))
        {
            TRACE_OUT(("Skipping last quote in file name %s", szCopyOfFile));
            szCopyOfFile[cchLength - 1] = '\0';
        }
    }
    else
    {
        szCopyOfFile = NULL;
    }

    UT_PostEvent(g_putUI, g_putAL, NO_DELAY,
            AL_INT_STARTSTOP_WB, 0, (UINT_PTR)szCopyOfFile);
    return(TRUE);
}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\ba.cpp ===
#include "precomp.h"


//
// BA.CPP
// Bounds Accumulator
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE



//
// BA_SyncOutgoing()
// Reset rect count
//
void ASHost::BA_SyncOutgoing(void)
{
    DebugEntry(ASHost::BA_SyncOutgoing);

    m_baNumRects = 0;

    DebugExitVOID(ASHost::BA_SyncOutgoing);
}



//
// BA_AddRect()
//
void  ASHost::BA_AddRect(LPRECT pRect)
{
    DebugEntry(ASHost::BA_AddRect);

    //
    // Make sure that we don't have too many rects
    //
    if (m_baNumRects >= BA_NUM_RECTS)
    {
        ERROR_OUT(( "Too many rectangles"));
        DC_QUIT;
    }

    //
    // Check that the caller has passed a valid rectangle.  If not, do a
    // trace alert, and then return immediately (as an invalid rectangle
    // shouldn't contribute to the accumulated bounds) - but report an OK
    // return code, so we keep running.
    //
    if ((pRect->right < pRect->left) ||
        (pRect->bottom < pRect->top))
    {
        WARNING_OUT(("BA_AddRect: empty rect {%04d, %04d, %04d, %04d}",
                   pRect->left,
                   pRect->top,
                   pRect->right,
                   pRect->bottom ));
        DC_QUIT;
    }

    //
    // Add the rect to the bounds.
    //
    m_abaRects[m_baNumRects++] = *pRect;

DC_EXIT_POINT:
    DebugExitVOID(ASHost::BA_AddRect);
}



//
// BA_QueryAccumulation()
//
UINT  ASHost::BA_QueryAccumulation(void)
{
    UINT totalSDA;
    LPBA_FAST_DATA lpbaFast;

    DebugEntry(ASHost::BA_QueryAccumulation);

    lpbaFast = BA_FST_START_WRITING;

    //
    // Get the current setting and clear the previous one.
    //
    totalSDA = lpbaFast->totalSDA;
    lpbaFast->totalSDA = 0;

    BA_FST_STOP_WRITING;

    DebugExitDWORD(ASHost::BA_QueryAccumulation, totalSDA);
    return(totalSDA);
}



//
//
// BA_FetchBounds()
//
//
void  ASHost::BA_FetchBounds(void)
{
    BA_BOUNDS_INFO  boundsInfo;
    UINT          i;

    DebugEntry(ASHost::BA_FetchBounds);

    //
    // Clear our copy of the bounds
    //
    m_baNumRects = 0;


    //
    // Get the driver's latest bounds rects
    //
    OSI_FunctionRequest(BA_ESC_GET_BOUNDS,
                        (LPOSI_ESCAPE_HEADER)&boundsInfo,
                        sizeof(boundsInfo));

    //
    // Add the driver's bounds into our array
    //
    TRACE_OUT(( "Retreived %d rects from driver", boundsInfo.numRects));

    for (i = 0; i < boundsInfo.numRects; i++)
    {
        TRACE_OUT(( "Rect %d, (%d, %d) (%d, %d)",
                     i,
                     boundsInfo.rects[i].left,
                     boundsInfo.rects[i].top,
                     boundsInfo.rects[i].right,
                     boundsInfo.rects[i].bottom));
        BA_AddRect((LPRECT)&boundsInfo.rects[i]);
    }

    DebugExitVOID(ASHost::BA_FetchBounds);
}


//
// BA_ReturnBounds()
//
void  ASHost::BA_ReturnBounds(void)
{
    BA_BOUNDS_INFO  boundsInfo;

    DebugEntry(ASHost::BA_ReturnBounds);

    //
    // Copy the share core's bounds into the structure which we pass to the
    // driver.  This will also clear the share core's copy of the bounds.
    //
    BA_CopyBounds((LPRECT)boundsInfo.rects, (LPUINT)&boundsInfo.numRects, TRUE);

    //
    // Now set up for, and then call into the driver to fetch the driver's
    // bounds.
    //
    TRACE_OUT(( "Passing %d rects to driver", boundsInfo.numRects));
    OSI_FunctionRequest(BA_ESC_RETURN_BOUNDS,
                        (LPOSI_ESCAPE_HEADER)&boundsInfo,
                        sizeof(boundsInfo));

    DebugExitVOID(ASHost::BA_ReturnBounds);
}




//
// BA_CopyBounds()
//
void  ASHost::BA_CopyBounds(LPRECT pRects, LPUINT pNumRects, BOOL fReset)
{
    DebugEntry(ASHost::BA_CopyBounds);

    if (*pNumRects = m_baNumRects)
    {
        TRACE_OUT(( "num rects : %d", m_baNumRects));

        memcpy(pRects, m_abaRects, m_baNumRects * sizeof(RECT));

        if (fReset)
        {
            m_baNumRects = 0;
        }
    }

    DebugExitVOID(ASHost::BA_CopyBounds);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\cm.cpp ===
#include "precomp.h"


//
// CM.CPP
// Cursor Manager
//
// Copyright(c) Microsoft 1997-
//
#define MLZ_FILE_ZONE  ZONE_CORE




//
// CM_ShareStarting()
// Creates resources used by the share
//
BOOL ASShare::CM_ShareStarting(void)
{
    BOOL        rc = FALSE;
    HBITMAP     hbmpT;
    ICONINFO    cursorInfo;
    char        szTmp[MAX_CURSOR_TAG_FONT_NAME_LENGTH];

    DebugEntry(ASShare::CM_ShareStarting);

    //
    // Create the hatching brush we will use to make shadow cursors
    // distinguishable from real cursors.
    //
    hbmpT = LoadBitmap(g_asInstance, MAKEINTRESOURCE(IDB_HATCH32X32) );
    m_cmHatchBrush = CreatePatternBrush(hbmpT);
    DeleteBitmap(hbmpT);

    if (!m_cmHatchBrush)
    {
        ERROR_OUT(("CM_ShareStarting: Failed to created hatched brush"));
        DC_QUIT;
    }

    m_cmArrowCursor = LoadCursor(NULL, IDC_ARROW);
    if (!m_cmArrowCursor)
    {
        ERROR_OUT(("CM_ShareStarting: Failed to load cursors"));
        DC_QUIT;
    }

    // Get the arrow hotspot
    GetIconInfo(m_cmArrowCursor, &cursorInfo);
    m_cmArrowCursorHotSpot.x = cursorInfo.xHotspot;
    m_cmArrowCursorHotSpot.y = cursorInfo.yHotspot;

    DeleteBitmap(cursorInfo.hbmMask);
    if (cursorInfo.hbmColor)
        DeleteBitmap(cursorInfo.hbmColor);

    //
    // Get the size of the cursor on this system. (Cursor bitmaps are word
    // padded 1bpp).
    //
    m_cmCursorWidth  = GetSystemMetrics(SM_CXCURSOR);
    m_cmCursorHeight = GetSystemMetrics(SM_CYCURSOR);

    //
    // Load the name of the font which will be used for creating cursor
    // tags.  It makes sense to have this in a resource, so it can be
    // localized.
    //
    LoadString(g_asInstance, IDS_FONT_CURSORTAG, szTmp, sizeof(szTmp));
    m_cmCursorTagFont = CreateFont(CURSOR_TAG_FONT_HEIGHT, 0, 0, 0, FW_NORMAL,
                             FALSE, FALSE, FALSE, DEFAULT_CHARSET,
                             OUT_TT_PRECIS, CLIP_DEFAULT_PRECIS,
                             DEFAULT_QUALITY, DEFAULT_PITCH | FF_DONTCARE,
                             szTmp);
    if (!m_cmCursorTagFont)
    {
        ERROR_OUT(("CM_ShareStarting: couldn't create cursor tag font"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CM_ShareStarting, rc);
    return(rc);
}



//
// CM_ShareEnded()
// Frees resources used by the share
//
void ASShare::CM_ShareEnded(void)
{
    DebugEntry(ASShare::CM_ShareEnded);

    //
    // Free cursor tag font
    //
    if (m_cmCursorTagFont != NULL)
    {
        DeleteFont(m_cmCursorTagFont);
        m_cmCursorTagFont = NULL;
    }

    //
    // Free shadow cursor dither brush
    //
    if (m_cmHatchBrush != NULL)
    {
        DeleteBrush(m_cmHatchBrush);
        m_cmHatchBrush = NULL;
    }

    DebugExitVOID(ASShare::CM_ShareEnded);
}


//
// CM_PartyJoiningShare()
//
BOOL ASShare::CM_PartyJoiningShare(ASPerson * pasPerson)
{
    BOOL          rc = FALSE;

    DebugEntry(ASShare::CM_PartyJoiningShare);

    ValidatePerson(pasPerson);

    //
    // For 2.x nodes, create cursor cache now
    // For 3.0 nodes, create it when they start to host
    //
    if (pasPerson->cpcCaps.general.version < CAPS_VERSION_30)
    {
        if (!CMCreateIncoming(pasPerson))
        {
            ERROR_OUT(("CM_PartyJoiningShare: can't create cursor cache"));
            DC_QUIT;
        }
    }

    pasPerson->cmhRemoteCursor  = m_cmArrowCursor;
    pasPerson->cmHotSpot        = m_cmArrowCursorHotSpot;

    ASSERT(pasPerson->cmPos.x == 0);
    ASSERT(pasPerson->cmPos.y == 0);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CM_PartyJoiningShare, rc);
    return(rc);

}


//
// CM_PartyLeftShare()
//
// See cm.h for description.
//
void ASShare::CM_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::CM_PartyLeftShare);

    ValidatePerson(pasPerson);

    //
    // Clear the incoming (receive) cursor cache info
    //
    if (pasPerson->cpcCaps.general.version < CAPS_VERSION_30)
    {
        TRACE_OUT(("CM_PartyLeftShare: freeing 2.x cursor cache for [%d]",
            pasPerson->mcsID));
        CMFreeIncoming(pasPerson);
    }
    else
    {
        ASSERT(!pasPerson->ccmRxCache);
        ASSERT(!pasPerson->acmRxCache);
    }

    DebugExitVOID(ASShare::CM_PartyLeftShare);
}


//
// CM_HostStarting()
//
// Called when we start to host.  Creates the outgoing cursor cache
//
BOOL ASHost::CM_HostStarting(void)
{
    BOOL    rc = FALSE;

    DebugEntry(ASHost::CM_HostStarting);

    //
    // Calculate actual size of cache we will use -- if 3.0 share, it's
    // what we advertise in our caps, but if 2.x share, it's <= to that
    // amount, being the min of everybody in the share.
    //
    // We however create the cache the size we want, knowing that in a 2.x
    // share we'll use some subset of it.  That's cool.
    //
    m_pShare->CM_RecalcCaps(TRUE);

    if (!CH_CreateCache(&m_cmTxCacheHandle, TSHR_CM_CACHE_ENTRIES,
            1, 0, NULL))
    {
        ERROR_OUT(("Could not create CM cache"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::CM_HostStarting, rc);
    return(rc);
}


//
// CM_HostEnded()
//
// Called when we stop hosting, so we can free cursor data
//
void ASHost::CM_HostEnded(void)
{
    DebugEntry(ASHost::CM_HostEnded);

    //
    // Destroy the outgoing cursor cache
    //
    if (m_cmTxCacheHandle)
    {
        CH_DestroyCache(m_cmTxCacheHandle);
        m_cmTxCacheHandle = 0;
        m_cmNumTxCacheEntries = 0;
    }

    DebugExitVOID(ASHost::CM_HostEnded);
}



//
// CM_ViewStarting()
//
// Called when somebody we're viewing starts to host.  We create
// the incoming cursor cache (well, we create it if they are 3.0; 2.x
// nodes populated it even when not hosting).
//
BOOL ASShare::CM_ViewStarting(ASPerson * pasPerson)
{
    BOOL    rc = FALSE;

    DebugEntry(ASShare::CM_ViewStarting);

    ValidatePerson(pasPerson);

    if (pasPerson->cpcCaps.general.version < CAPS_VERSION_30)
    {
        // Reuse created cache
        ASSERT(pasPerson->acmRxCache);
        TRACE_OUT(("CM_ViewStarting: reusing cursor cache for 2.x node [%d]",
                pasPerson->mcsID));
    }
    else
    {
        if (!CMCreateIncoming(pasPerson))
        {
            ERROR_OUT(("CM_ViewStarting:  can't create cursor cache for [%d]",
                pasPerson->mcsID));
            DC_QUIT;
        }
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CM_ViewStarting, rc);
    return(rc);
}



//
// CM_ViewEnded()
//
// Called when somebody we are viewing has stopped hosting.  We free up
// cursor data needed to handle what they send us (well, for 3.0 dudes we
// do; for 2.x dudes we keep it as long as they are in a share).
//
void ASShare::CM_ViewEnded(ASPerson * pasPerson)
{
    DebugEntry(ASShare::CM_ViewEnded);

    ValidatePerson(pasPerson);

    if (pasPerson->cpcCaps.general.version >= CAPS_VERSION_30)
    {
        // Free cursor cache
        CMFreeIncoming(pasPerson);
    }
    else
    {
        TRACE_OUT(("CM_ViewEnded: keeping cursor cache for 2.x node [%d]",
            pasPerson->mcsID));
    }

    DebugExitVOID(ASShare::CM_ViewEnded);
}



//
// CMCreateIncoming()
// Creates cursor cache for person.
// If 3.0 node, we create it when they start to host
// If 2.x node, we create it when they join the share
//
BOOL ASShare::CMCreateIncoming(ASPerson * pasPerson)
{
    BOOL rc = FALSE;

    DebugEntry(ASShare::CMCreateIncoming);

    if (!pasPerson->cpcCaps.cursor.capsCursorCacheSize)
    {
        //
        // This person has no cursor cache; don't create one.
        //
        WARNING_OUT(("CMCreateIncoming: person [%d] has no cursor cache size", pasPerson->mcsID));
        rc = TRUE;
        DC_QUIT;
    }

    pasPerson->ccmRxCache = pasPerson->cpcCaps.cursor.capsCursorCacheSize;
    pasPerson->acmRxCache = new CACHEDCURSOR[pasPerson->ccmRxCache];
    if (!pasPerson->acmRxCache)
    {
        ERROR_OUT(("CMCreateIncoming: can't create cursor cache for node [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    ZeroMemory(pasPerson->acmRxCache, sizeof(CACHEDCURSOR) * pasPerson->ccmRxCache);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CMCreateIncoming, rc);
    return(rc);
}



//
// CMFreeIncoming()
// Frees cursor cache for person.
// If 3.0 node, we free it when they stop hosting
// If 2.x node, we free it when they leave the share
//
void ASShare::CMFreeIncoming(ASPerson * pasPerson)
{
    UINT            irx;
    POINT           cursorPos;
    HWND            hwnd;
    HCURSOR         hCurCursor;

    DebugEntry(ASShare::CMFreeIncoming);

    hCurCursor = ::GetCursor();

    if (pasPerson->acmRxCache)
    {
        for (irx = 0; irx < pasPerson->ccmRxCache; irx++)
        {
            if (pasPerson->acmRxCache[irx].hCursor != NULL)
            {
                if (pasPerson->acmRxCache[irx].hCursor == hCurCursor)
                {
                    //
                    // We're about to destroy the current cursor.  Reset it.
                    // Note that this can only happen when there's an active
                    // frame for this host.  And that frame must be about
                    // to go away, in which case USER will jiggle the cursor
                    // anyway.  So we don't need to do more than this.
                    //
                    ::SetCursor(m_cmArrowCursor);
                }

                if (pasPerson->acmRxCache[irx].hCursor == pasPerson->cmhRemoteCursor)
                {
                    pasPerson->cmhRemoteCursor = NULL;
                }

                ::DestroyCursor(pasPerson->acmRxCache[irx].hCursor);
                pasPerson->acmRxCache[irx].hCursor = NULL;
            }
        }

        pasPerson->ccmRxCache = 0;

        delete[] pasPerson->acmRxCache;
        pasPerson->acmRxCache = NULL;

    }

    DebugExitVOID(ASShare::CMFreeIncoming);
}



//
// CM_Periodic()
//
void  ASHost::CM_Periodic(void)
{
    HWND    hwnd;

    DebugEntry(ASHost::CM_Periodic);

    CM_MaybeSendCursorMovedPacket();

    //
    // Find out which window is currently controlling the cursor
    // appearance.
    //
    hwnd = CMGetControllingWindow();
    if (hwnd)
    {
        UINT    cursorType;
        CURSORDESCRIPTION desiredCursor;
        UINT    idDelta;

        //
        // Send a cursor shape update for the controlling window if necessary
        //
        if (m_pShare->HET_WindowIsHosted(hwnd))
            cursorType = CM_CT_DISPLAYEDCURSOR;
        else
            cursorType = CM_CT_DEFAULTCURSOR;

        switch (cursorType)
        {
            case CM_CT_DEFAULTCURSOR:
                if ((m_cmLastCursorShape.type == CM_CD_SYSTEMCURSOR) &&
                    (m_cmLastCursorShape.id == CM_IDC_ARROW) )
                {
                    //
                    // No change.
                    //
                    DC_QUIT;
                }
                desiredCursor.type = CM_CD_SYSTEMCURSOR;
                desiredCursor.id = CM_IDC_ARROW;
                break;

            case CM_CT_DISPLAYEDCURSOR:
                CMGetCurrentCursor(&desiredCursor);

                if (desiredCursor.type == m_cmLastCursorShape.type)
                {
                    switch (desiredCursor.type)
                    {
                        case CM_CD_SYSTEMCURSOR:
                            if (desiredCursor.id == m_cmLastCursorShape.id)
                            {
                                //
                                // Same cursor as last time.
                                //
                                DC_QUIT;
                            }
                            break;

                        case CM_CD_BITMAPCURSOR:
                            //
                            // If the cursor has already been used, ignore it.
                            // Check if stamp is less than or equal to the last
                            // one - assume any sufficiently large difference
                            // is due to overflow.
                            //
                            idDelta = (UINT)
                                (desiredCursor.id - m_cmLastCursorShape.id);

                            if (((idDelta == 0) || (idDelta > 0x10000000)) &&
                                ((g_asSharedMemory->cmCursorHidden != FALSE) == (m_cmfCursorHidden != FALSE)))
                            {
                                TRACE_OUT(( "No change in cursor"));
                                DC_QUIT;
                            }
                            break;

                        default:
                            ERROR_OUT(("Invalid cursor definition"));
                            break;
                   }
                }
                break;

            default:
                ERROR_OUT(("cursorType invalid"));
                DC_QUIT;
        }

        if (desiredCursor.type == CM_CD_SYSTEMCURSOR)
        {
            if (!CMSendSystemCursor(desiredCursor.id))
            {
                //
                // We failed to send the system cursor, so we just exit without
                // updating m_cmLastCursorShape.  We will attempt to send it again
                // on the next call to CM_Periodic.
                //
                DC_QUIT;
            }

            m_cmLastCursorShape.type = desiredCursor.type;
            m_cmLastCursorShape.id = desiredCursor.id;
        }
        else
        {
            //
            // Save the 'hidden' state.
            //
            m_cmfCursorHidden = (g_asSharedMemory->cmCursorHidden != FALSE);

            if (!CMSendBitmapCursor())
            {
                //
                // We failed to send the bitmap cursor, so we just exit without
                // updating m_cmLastCursorShape.  We will attempt to send it again
                // on the next call to CM_Periodic.
                //
                DC_QUIT;
            }

            m_cmLastCursorShape.type = desiredCursor.type;
            m_cmLastCursorShape.id = desiredCursor.id;
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASHost::CM_Periodic);
}



//
// CM_SyncOutgoing()
// Forces a send of the current cursor shape/pos when we start to host or
// somebody new joins the conference
//
void ASHost::CM_SyncOutgoing(void)
{
    DebugEntry(ASHost::CM_SyncOutgoing);

    //
    // Mark the last cursor as unknown.  On next timer tick we'll send the
    // current one.
    //
    m_cmLastCursorShape.type = CM_CD_UNKNOWN;
    m_cmLastCursorPos.x = -1;
    m_cmLastCursorPos.y = -1;

    //
    // Clear the cursor cache.
    //
    if (m_cmTxCacheHandle != 0)
    {
        CH_ClearCache(m_cmTxCacheHandle);
    }

    DebugExitVOID(ASHost::CM_SyncOutgoing);
}





//
// CM_DrawShadowCursor(..)
//
void  ASShare::CM_DrawShadowCursor(ASPerson * pasHost, HDC hdc)
{
    HBRUSH      hbrOld;
    HDC         hdcMem;
    HBITMAP     hbmp;
    HBITMAP     hbmpOld;
    HPALETTE    hpalScreen = NULL;
    HPALETTE    hpalOldDIB = NULL;
    POINT       ptFrame;

    DebugEntry(ASShare::CM_DrawShadowCursor);

    ValidateView(pasHost);

    //
    // Draw the shadow cursor if there is one.
    //
    if (pasHost->cmShadowOff || !pasHost->cmhRemoteCursor)
    {
        TRACE_OUT(("CM_DrawShadowCursor: no cursor to draw"));
        DC_QUIT;
    }

    //
    // The cursor position is always kept in the host's screen coordinates.
    // When we paint our view frame, we adjust the DC so that painting
    // in host coordinates works right, even though the view frame may
    // be scrolled over.
    //
    ptFrame.x = pasHost->cmPos.x - pasHost->cmHotSpot.x - pasHost->m_pView->m_viewPos.x;
    ptFrame.y = pasHost->cmPos.y - pasHost->cmHotSpot.y - pasHost->m_pView->m_viewPos.y;

    //
    // We draw a greyed cursor using the following steps.
    // - copy the destination window rectangle to a memory bitmap.
    // - draw the cursor into the memory bitmap
    //
    // [the memory bitmap now contains the window background + a non-greyed
    // cursor]
    //
    // - blt the window bitmap back to the memory using a 3-way ROP and a
    //   hatched pattern bitmap.  The ROP is chosen such that the 0s and 1s
    //   in the pattern bitmap select either a bitmap pel or a destination
    //   pel for the final result.  The pattern bitmap is such that most
    //   of the bitmap pels are copied, but a few destination pels are
    //   left unchanged, giving a greying effect.
    //
    // - copy the resulting bitmap back into the window.
    //
    // The last two steps are done so that the cursor does not appear to
    // change shape as it is moved.  If the 3 way blt is done back to the
    // screen at stage 3, the pattern stays relative to the screen coords
    // and hence as the cursor moves, it will lose different pels each
    // time and appear to deform.
    //
    // The ROP is calculated to copy the source pel where the pattern is 1
    // and to leave the destination pel unchanged where the pattern is 0:
    //
    //   P  S  D     R
    //
    //   0  0  0     0
    //   0  0  1     1
    //   0  1  0     0
    //   0  1  1     1
    //   1  0  0     0
    //   1  0  1     0
    //   1  1  0     1
    //   1  1  1     1
    //
    //               ^
    //               Read upwards -> 0xCA
    //
    // From the table in the SDK, this gives a full ROP value of 0x00CA0749
    //
    //
    #define GREY_ROP 0x00CA0749

    if (NULL == (hdcMem = CreateCompatibleDC(hdc)))
    {
        WARNING_OUT(( "Failed to create memory DC"));
        DC_QUIT;
    }

    if (NULL == (hbmp = CreateCompatibleBitmap(hdc, CM_MAX_CURSOR_WIDTH, CM_MAX_CURSOR_HEIGHT)))
    {
        WARNING_OUT(( "Failed to create bitmap"));
        DeleteDC(hdcMem);
        DC_QUIT;
    }

    if (NULL == (hbmpOld = SelectBitmap(hdcMem, hbmp)))
    {
        WARNING_OUT(( "Failed to select bitmap"));
        DeleteBitmap(hbmp);
        DeleteDC(hdcMem);
        DC_QUIT;
    }

    hbrOld = SelectBrush(hdcMem, m_cmHatchBrush);

    //
    //
    // We need to make sure that we have the same logical palette selected
    // into both DCs otherwise we will corrupt the background color info
    // when we do the blitting.
    //
    //
    hpalScreen = SelectPalette(hdc,
        (HPALETTE)GetStockObject(DEFAULT_PALETTE),
                               FALSE );
    SelectPalette( hdc, hpalScreen, FALSE );
    hpalOldDIB = SelectPalette( hdcMem, hpalScreen, FALSE );
    RealizePalette(hdcMem);

    BitBlt( hdcMem,
            0,
            0,
            CM_MAX_CURSOR_WIDTH,
            CM_MAX_CURSOR_HEIGHT,
            hdc,
            ptFrame.x,
            ptFrame.y,
            SRCCOPY );

    DrawIcon(hdcMem, 0, 0, pasHost->cmhRemoteCursor);
    CMDrawCursorTag(pasHost, hdcMem);

    BitBlt( hdcMem,
            0,
            0,
            CM_MAX_CURSOR_WIDTH,
            CM_MAX_CURSOR_HEIGHT,
            hdc,
            ptFrame.x,
            ptFrame.y,
            GREY_ROP );

    BitBlt( hdc,
            ptFrame.x,
            ptFrame.y,
            CM_MAX_CURSOR_WIDTH,
            CM_MAX_CURSOR_HEIGHT,
            hdcMem,
            0,
            0,
            SRCCOPY );

    SelectBrush(hdcMem, hbrOld);

    SelectBitmap(hdcMem, hbmpOld);
    DeleteBitmap(hbmp);

    if (hpalOldDIB != NULL)
    {
        SelectPalette(hdcMem, hpalOldDIB, FALSE);
    }

    DeleteDC(hdcMem);


DC_EXIT_POINT:
    DebugExitVOID(ASShare::CM_DrawShadowCursor);
}



//
// CM_ReceivedPacket(..)
//
void  ASShare::CM_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PCMPACKETHEADER pCMPacket;

    DebugEntry(ASShare::CM_ReceivedPacket);

    ValidatePerson(pasPerson);

    pCMPacket = (PCMPACKETHEADER)pPacket;

    //
    // Switch on the packet type
    //
    switch (pCMPacket->type)
    {
        case CM_CURSOR_ID:
        case CM_CURSOR_MONO_BITMAP:
        case CM_CURSOR_COLOR_BITMAP:
        case CM_CURSOR_COLOR_CACHE:
            CMReceivedCursorShapePacket(pasPerson, pCMPacket);
            break;

        case CM_CURSOR_MOVE:
            CMReceivedCursorMovedPacket(pasPerson, pCMPacket);
            break;

        default:
            ERROR_OUT(("Invalid CM data packet from [%d] of type %d",
                pasPerson->mcsID, pCMPacket->type));
            break;
    }

    DebugExitVOID(ASShare::CM_ReceivedPacket);
}



//
// CM_ApplicationMovedCursor(..)
//
void  ASHost::CM_ApplicationMovedCursor(void)
{
    DebugEntry(ASHost::CM_ApplicationMovedCursor);

    WARNING_OUT(("CM host:  cursor moved by app, tell viewers"));
    m_cmfSyncPos = TRUE;
    CM_MaybeSendCursorMovedPacket();

    DebugExitVOID(ASHost::CM_ApplicationMovedCursor);
}



//
// CM_RecalcCaps()
//
// This calculates the CM hosting caps when
//      * we start to host
//      * we're hosting and somebody joins the share
//      * we're hosting and somebody leaves the share
//
// This can GO AWAY WHEN 2.x COMPAT IS GONE -- no more min() of cache size
//
void ASShare::CM_RecalcCaps(BOOL fJoiner)
{
    ASPerson * pasT;

    DebugEntry(ASShare::CM_RecalcCaps);

    if (!m_pHost || !fJoiner)
    {
        //
        // Nothing to do if we're not hosting.  And also, if somebody has
        // left, no recalculation -- 2.x didn't.
        //
        DC_QUIT;
    }

    ValidatePerson(m_pasLocal);

    m_pHost->m_cmNumTxCacheEntries        = m_pasLocal->cpcCaps.cursor.capsCursorCacheSize;
    m_pHost->m_cmfUseColorCursorProtocol  =
        (m_pasLocal->cpcCaps.cursor.capsSupportsColorCursors == CAPS_SUPPORTED);

    //
    // Now with 3.0, viewers just create caches which are the size
    // of the host's send caps.  No more min, no more receive caps
    //

    if (m_scShareVersion < CAPS_VERSION_30)
    {
        TRACE_OUT(("In share with 2.x nodes, must recalc CM caps"));

        for (pasT = m_pasLocal->pasNext; pasT != NULL; pasT = pasT->pasNext)
        {
            m_pHost->m_cmNumTxCacheEntries = min(m_pHost->m_cmNumTxCacheEntries,
                pasT->cpcCaps.cursor.capsCursorCacheSize);

            if (pasT->cpcCaps.cursor.capsSupportsColorCursors != CAPS_SUPPORTED)
            {
                m_pHost->m_cmfUseColorCursorProtocol = FALSE;
            }
        }

        TRACE_OUT(("Recalced CM caps:  Tx Cache size %d, color cursors %d",
            m_pHost->m_cmNumTxCacheEntries,
            (m_pHost->m_cmfUseColorCursorProtocol != FALSE)));
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CM_RecalcCaps);
}



//
// FUNCTION: CMReceivedCursorShapePacket
//
// DESCRIPTION:
//
// Processes a received cursor shape packet.
//
// PARAMETERS:
//
// personID - ID of the packet sender
//
// pCMPacket - pointer to the received cursor shape packet
//
// RETURNS: Nothing
//
//
void  ASShare::CMReceivedCursorShapePacket
(
    ASPerson *      pasPerson,
    PCMPACKETHEADER pCMPacket
)
{
    BOOL        fSetCursorToNULL = FALSE;
    HCURSOR     hNewCursor;
    HCURSOR     hOldCursor = NULL;
    POINT       newHotSpot;
    UINT        cacheID;

    DebugEntry(ASShare::CMReceivedCursorShapePacket);

    ValidatePerson(pasPerson);

    //
    // Now create or load the new cursor.
    //
    switch (pCMPacket->type)
    {
        case CM_CURSOR_ID:
            CMProcessCursorIDPacket((PCMPACKETID)pCMPacket,
                &hNewCursor, &newHotSpot);
            break;

        case CM_CURSOR_MONO_BITMAP:
        case CM_CURSOR_COLOR_BITMAP:
            if (pCMPacket->type == CM_CURSOR_MONO_BITMAP)
            {
                cacheID = CMProcessMonoCursorPacket((PCMPACKETMONOBITMAP)pCMPacket,
                    &hNewCursor, &newHotSpot);
            }
            else
            {
                cacheID = CMProcessColorCursorPacket((PCMPACKETCOLORBITMAP)pCMPacket,
                    &hNewCursor, &newHotSpot );
            }

            ASSERT(pasPerson->acmRxCache);
            ASSERT(cacheID < pasPerson->ccmRxCache);

            hOldCursor = pasPerson->acmRxCache[cacheID].hCursor;

            if (hNewCursor != NULL)
            {

                TRACE_OUT(("Cursor using cache %u", cacheID));
                pasPerson->acmRxCache[cacheID].hCursor = hNewCursor;
                pasPerson->acmRxCache[cacheID].hotSpot = newHotSpot;
            }
            else
            {
                //
                // use default cursor.
                //
                TRACE_OUT(( "color cursor failed so use arrow"));

                pasPerson->acmRxCache[cacheID].hCursor = NULL;
                pasPerson->acmRxCache[cacheID].hotSpot.x = 0;
                pasPerson->acmRxCache[cacheID].hotSpot.y = 0;

                hNewCursor = m_cmArrowCursor;
                newHotSpot = m_cmArrowCursorHotSpot;
            }
            break;

        case CM_CURSOR_COLOR_CACHE:
            cacheID = ((PCMPACKETCOLORCACHE)pCMPacket)->cacheIndex;

            ASSERT(pasPerson->acmRxCache);
            ASSERT(cacheID < pasPerson->ccmRxCache);

            //
            // If the caching failed last time then use the default arrow
            // cursor.
            //
            if (pasPerson->acmRxCache[cacheID].hCursor == NULL)
            {
                TRACE_OUT(( "cache empty so use arrow"));
                hNewCursor = m_cmArrowCursor;
                newHotSpot = m_cmArrowCursorHotSpot;
            }
            else
            {
                hNewCursor = pasPerson->acmRxCache[cacheID].hCursor;
                newHotSpot = pasPerson->acmRxCache[cacheID].hotSpot;
            }
            break;

        default:
            WARNING_OUT(( "Unknown cursor type: %u", pCMPacket->type));
            DC_QUIT;
    }

    //
    // Destroy the old cursor.  Note that for bitmap cursor packets,
    // we will set the cursor to the new image twice.
    //
    if (hOldCursor)
    {
        if (hOldCursor == ::GetCursor())
        {
            ::SetCursor(hNewCursor);
        }

        ::DestroyCursor(hOldCursor);
    }

    pasPerson->cmhRemoteCursor = hNewCursor;

    //
    // Decide what to do with the new cursor...
    //
    if (!pasPerson->cmShadowOff)
    {
        //
        // The shadow cursor is enabled so update it.  It won't change state
        // or move, it will just repaint with the new image and/or hotspot.
        //
        TRACE_OUT(("Update shadow cursor"));

        CM_UpdateShadowCursor(pasPerson, pasPerson->cmShadowOff,
            pasPerson->cmPos.x, pasPerson->cmPos.y,
            newHotSpot.x, newHotSpot.y);
    }
    else
    {
        HWND    hwnd;

        // Update the hotspot.
        pasPerson->cmHotSpot = newHotSpot;

        // Refresh if no old cursor
        ASSERT(pasPerson->m_pView);

        hwnd = CMGetControllingWindow();
        if (hwnd == pasPerson->m_pView->m_viewClient)
        {
            SendMessage(hwnd, WM_SETCURSOR, (WPARAM)hwnd, MAKELONG(HTCLIENT, 0));
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CMReceivedCursorShapePacket);
}


//
// FUNCTION: CMProcessMonoCursorPacket
//
// DESCRIPTION:
//
// Processes a received mono cursor packet.
//
// PARAMETERS:
//
// pCMPacket - pointer to the received cursor ID packet
//
// phNewCursor - pointer to a HCURSOR variable that receives the handle
// of a cursor that corresponds to the received packet
//
// pNewHotSpot - pointer to a POINT variable that receives the hot-spot
// of the new cursor
//
// RETURNS: Nothing
//
//
UINT  ASShare::CMProcessMonoCursorPacket
(
    PCMPACKETMONOBITMAP     pCMPacket,
    HCURSOR*                phNewCursor,
    LPPOINT                 pNewHotSpot
)
{
    UINT        cbReceivedMaskBytes;
    LPBYTE      pANDMask;
    LPBYTE      pXORMask;

    DebugEntry(ASShare::CMProcessMonoCursorPacket);

    //
    // Work out the size (in bytes) of the two bitmap masks we have just
    // received.  (Cursor bitmaps are 1bpp and word padded).
    //
    cbReceivedMaskBytes = pCMPacket->height * CM_BYTES_FROM_WIDTH(pCMPacket->width);

    //
    // NOTE:  Compressed cursors are an R.11 remnant.  NM 1.0 and 2.0 never
    // sent them specially compressed.  Therefore the code to handle
    // decompression should be unnecessary.  Let's find out!
    //
    ASSERT(pCMPacket->header.type == CM_CURSOR_MONO_BITMAP);

    //
    // Get the XOR and AND masks
    //
    pXORMask = pCMPacket->aBits;
    pANDMask = pXORMask + cbReceivedMaskBytes;

    //
    // Create a cursor from the definition supplied in the packet.
    //
    *phNewCursor = CMCreateMonoCursor(pCMPacket->xHotSpot,
        pCMPacket->yHotSpot, pCMPacket->width, pCMPacket->height,
        pANDMask, pXORMask);
    if (*phNewCursor == NULL)
    {
        WARNING_OUT(( "Failed to create hRemoteCursor"));
        DC_QUIT;
    }

    //
    // Return the hot spot.
    //
    pNewHotSpot->x = pCMPacket->xHotSpot;
    pNewHotSpot->y = pCMPacket->yHotSpot;

DC_EXIT_POINT:
    DebugExitDWORD(ASShare::CMProcessMonoCursorPacket, 0);
    return(0);
}


//
// FUNCTION: CMProcessColorCursorPacket
//
// DESCRIPTION:
//
// Processes a received color cursor packet.
//
// PARAMETERS:
//
// pCMPacket - pointer to the received cursor ID packet
//
// phNewCursor - pointer to a HCURSOR variable that receives the handle
// of a cursor that corresponds to the received packet
//
// pNewHotSpot - pointer to a POINT variable that receives the hot-spot
// of the new cursor
//
// RETURNS: Nothing
//
//
UINT  ASShare::CMProcessColorCursorPacket
(
    PCMPACKETCOLORBITMAP    pCMPacket,
    HCURSOR*                phNewCursor,
    LPPOINT                 pNewHotSpot
)
{
    LPBYTE          pXORBitmap;
    LPBYTE          pANDMask;

    DebugEntry(ASShare::CMProcessColorCursorPacket);

    //
    // Calculate the pointers to the XOR bitmap and the AND mask within the
    // color cursor data.
    //
    pXORBitmap = pCMPacket->aBits;
    pANDMask = pXORBitmap + pCMPacket->cbXORBitmap;

    //
    // Create a cursor from the definition supplied in the packet.
    //
    *phNewCursor = CMCreateColorCursor(pCMPacket->xHotSpot, pCMPacket->yHotSpot,
        pCMPacket->cxWidth, pCMPacket->cyHeight, pANDMask, pXORBitmap,
        pCMPacket->cbANDMask, pCMPacket->cbXORBitmap);

    if (*phNewCursor == NULL)
    {
        WARNING_OUT(( "Failed to create color cursor"));
        DC_QUIT;
    }

    //
    // Return the hot spot.
    //
    pNewHotSpot->x = pCMPacket->xHotSpot;
    pNewHotSpot->y = pCMPacket->yHotSpot;

DC_EXIT_POINT:
    DebugExitDWORD(ASShare::CMProcessColorCursorPacket, pCMPacket->cacheIndex);
    return(pCMPacket->cacheIndex);
}


//
// FUNCTION: CMReceivedCursorMovedPacket
//
// DESCRIPTION:
//
// Processes a received cursor movement packet.
//
// PARAMETERS:
//
// personID - ID of the sender of this packet
//
// pCMPacket - pointer to the received cursor movement packet
//
// RETURNS: Nothing
//
//
void  ASShare::CMReceivedCursorMovedPacket
(
    ASPerson *      pasFrom,
    PCMPACKETHEADER pCMHeader
)
{
    ASPerson *      pasControlling;
    PCMPACKETMOVE   pCMPacket = (PCMPACKETMOVE)pCMHeader;

    DebugEntry(ASShare::CMReceivedCursorMovedPacket);

    //
    // Handle an incoming cursor moved packet.
    //
    ValidatePerson(pasFrom);

    TRACE_OUT(("Received cursor move packet from [%d] to pos (%d,%d)",
        pasFrom->mcsID, pCMPacket->xPos, pCMPacket->yPos));

    CM_UpdateShadowCursor(pasFrom, pasFrom->cmShadowOff,
        pCMPacket->xPos, pCMPacket->yPos,
        pasFrom->cmHotSpot.x, pasFrom->cmHotSpot.y);

    //
    // If we're in control of this person and it's a sync, we need to
    // move our cursor too, to reflect where the app really stuck it.
    //
    if ((pasFrom->m_caControlledBy == m_pasLocal)   &&
        !pasFrom->m_caControlPaused                 &&
        (pCMPacket->header.flags & CM_SYNC_CURSORPOS))
    {
        //
        // If our mouse is over this host's client area,
        // autoscroll to pos or move our cursor
        //
        WARNING_OUT(("CM SYNC pos to {%04d, %04d}", pCMPacket->xPos,
            pCMPacket->yPos));
        VIEW_SyncCursorPos(pasFrom, pCMPacket->xPos, pCMPacket->yPos);
    }

    DebugExitVOID(ASShare::CMReceivedCursorMovedPacket);
}



//
// CM_UpdateShadowCursor()
//
// This repaints the host's shadow cursor in the view frame we have for him.
// It is used when
//      * the cursor image has changed
//      * the cursor tag has changed (due to control changes)
//      * the cursor hotspot has changed
//      * the cursor state is changing between on and off
//      * the cursor has moved
//
void  ASShare::CM_UpdateShadowCursor
(
    ASPerson *  pasPerson,
    BOOL        cmShadowOff,
    int         xNewPos,
    int         yNewPos,
    int         xNewHot,
    int         yNewHot
)
{
    RECT        rcInval;

    DebugEntry(ASShare::CM_UpdateShadowCursor);

    //
    // Is the remote cursor currently on?
    //
    if (!pasPerson->cmShadowOff)
    {
        if (pasPerson->m_pView)
        {
            //
            // We need to invalidate the old rectangle where the cursor
            // was.  We need to adjust for the hotspot.  Also, adjust for
            // any scrolling we may have done in the view frame.
            //
            rcInval.left   = pasPerson->cmPos.x - pasPerson->cmHotSpot.x;
            rcInval.top    = pasPerson->cmPos.y - pasPerson->cmHotSpot.y;
            rcInval.right  = rcInval.left + m_cmCursorWidth;
            rcInval.bottom = rcInval.top + m_cmCursorHeight;

            VIEW_InvalidateRect(pasPerson, &rcInval);
        }
    }

    // Update the state, position, and hotspot
    pasPerson->cmShadowOff  = cmShadowOff;
    pasPerson->cmPos.x      = xNewPos;
    pasPerson->cmPos.y      = yNewPos;
    pasPerson->cmHotSpot.x  = xNewHot;
    pasPerson->cmHotSpot.y  = yNewHot;

    if (!pasPerson->cmShadowOff)
    {
        if (pasPerson->m_pView)
        {
            //
            // We need to invalidate the new rectangle where the cursor is
            // moving to.  Again, we need to adjust for the hotspot, and any
            // scrolling done in the view frame.
            //
            rcInval.left = pasPerson->cmPos.x - pasPerson->cmHotSpot.x;
            rcInval.top  = pasPerson->cmPos.y - pasPerson->cmHotSpot.y;
            rcInval.right = rcInval.left + m_cmCursorWidth;
            rcInval.bottom = rcInval.top + m_cmCursorHeight;

            VIEW_InvalidateRect(pasPerson, &rcInval);
        }
    }

    DebugExitVOID(ASShare::CM_UpdateShadowCursor);
}


void  ASHost::CM_MaybeSendCursorMovedPacket(void)
{

    PCMPACKETMOVE   pCMPacket;
    POINT           cursorPos;
#ifdef _DEBUG
    UINT            sentSize;
#endif

    DebugEntry(ASHost::CM_MaybeSendCursorMovedPacket);

    //
    // Get the cursor position.
    //
    if(!GetCursorPos(&cursorPos))
    {
        WARNING_OUT(("Unable to get cursor position. Error=%d", GetLastError()));
        goto DC_EXIT_POINT;
    }

    //
    // Has it changed?
    //
    if (m_cmfSyncPos ||
        (cursorPos.x != m_cmLastCursorPos.x) ||
        (cursorPos.y != m_cmLastCursorPos.y))
    {
        //
        // Try to allocate a packet.
        //
        pCMPacket = (PCMPACKETMOVE)m_pShare->SC_AllocPkt(PROT_STR_MISC, g_s20BroadcastID,
            sizeof(*pCMPacket));
        if (!pCMPacket)
        {
            WARNING_OUT(("Failed to alloc CM move packet"));
            DC_QUIT;
        }

        TRACE_OUT(("Sending cursor moved packet to pos (%d, %d)",
            cursorPos.x, cursorPos.y));

        //
        // Fill in the fields
        //
        pCMPacket->header.header.data.dataType = DT_CM;

        pCMPacket->header.type = CM_CURSOR_MOVE;
        pCMPacket->header.flags = 0;
        if (m_cmfSyncPos)
        {
            pCMPacket->header.flags |= CM_SYNC_CURSORPOS;
        }
        pCMPacket->xPos = (TSHR_UINT16)cursorPos.x;
        pCMPacket->yPos = (TSHR_UINT16)cursorPos.y;

        //
        // Compress and send the packet.
        //
        if (m_pShare->m_scfViewSelf)
            m_pShare->CM_ReceivedPacket(m_pShare->m_pasLocal, &(pCMPacket->header.header));

#ifdef _DEBUG
        sentSize =
#endif // _DEBUG
        m_pShare->DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
            &(pCMPacket->header.header), sizeof(*pCMPacket));

        TRACE_OUT(("CM MOVE packet size: %08d, sent %08d", sizeof(*pCMPacket), sentSize));

        m_cmfSyncPos = FALSE;
        m_cmLastCursorPos = cursorPos;
    }

DC_EXIT_POINT:
    DebugExitVOID(ASHost::CM_MaybeSendCursorMovedPacket);
}



//
// FUNCTION: CMSendCursorShape
//
// DESCRIPTION:
//
// Sends a packet containing the given cursor shape (bitmap). If the
// same shape is located in the cache then a cached cursor packet is sent.
//
// PARAMETERS:
//
// pCursorShape - pointer to the cursor shape
//
// cbCursorDataSize - pointer to the cursor data size
//
// RETURNS: TRUE if successful, FALSE otherwise.
//
//
BOOL  ASHost::CMSendCursorShape
(
    LPCM_SHAPE      pCursorShape,
    UINT            cbCursorDataSize
)
{
    BOOL            rc = FALSE;
    BOOL            fInCache;
    LPCM_SHAPE      pCacheData;
    UINT            iCacheEntry;

    DebugEntry(ASHost::CMSendCursorShape);

    fInCache = CH_SearchCache(m_cmTxCacheHandle,
                               (LPBYTE)pCursorShape,
                               cbCursorDataSize,
                               0,
                               &iCacheEntry );
    if (!fInCache)
    {
        pCacheData = (LPCM_SHAPE)new BYTE[cbCursorDataSize];
        if (pCacheData == NULL)
        {
            WARNING_OUT(("Failed to alloc CM_SHAPE data"));
            DC_QUIT;
        }

        memcpy(pCacheData, pCursorShape, cbCursorDataSize);

        iCacheEntry = CH_CacheData(m_cmTxCacheHandle,
                                    (LPBYTE)pCacheData,
                                    cbCursorDataSize,
                                    0);

        TRACE_OUT(( "Cache new cursor: pShape 0x%p, iEntry %u",
                                        pCursorShape, iCacheEntry));

        if (!CMSendColorBitmapCursor(pCacheData, iCacheEntry ))
        {
            CH_RemoveCacheEntry(m_cmTxCacheHandle, iCacheEntry);
            DC_QUIT;
        }
    }
    else
    {
        TRACE_OUT(("Cursor in cache: pShape 0x%p, iEntry %u",
                                        pCursorShape, iCacheEntry));

        if (!CMSendCachedCursor(iCacheEntry))
        {
            DC_QUIT;
        }
    }

    //
    // Return success.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASHost::CMSendCursorShape, rc);
    return(rc);
}



//
// FUNCTION: CMCopy1bppTo1bpp
//
// DESCRIPTION:
//
// Color conversion utility function to copy 1bpp cursor data to 1bpp (no
// conversion required).
//
// Data is assumed to be padded to word boundaries, and that the
// destination buffer is big enough to receive the 1bpp cursor data.
//
// PARAMETERS:
//
// pSrc - pointer to source data
//
// pDst - pointer to destination buffer
//
// cx - width of cursor in pixels
//
// cy - height of cursor in pixels
//
// RETURNS: Nothing
//
//
void  CMCopy1bppTo1bpp( LPBYTE pSrc,
                                            LPBYTE pDst,
                                            UINT   cx,
                                            UINT   cy )
{
    UINT cbRowWidth;

    DebugEntry(CMCopy1bppTo1bpp);

    cbRowWidth = ((cx + 15)/16) * 2;

    memcpy(pDst, pSrc, (cbRowWidth * cy));

    DebugExitVOID(CMCopy1bppTo1bpp);
}


//
// FUNCTION: CMCopy4bppTo1bpp
//
// DESCRIPTION:
//
// Color conversion utility function to copy 4bpp cursor data to 1bpp.
//
// Data is assumed to be padded to word boundaries, and that the
// destination buffer is big enough to receive the 1bpp cursor data.
//
// PARAMETERS:
//
// pSrc - pointer to source data
//
// pDst - pointer to destination buffer
//
// cx - width of cursor in pixels
//
// cy - height of cursor in pixels
//
// RETURNS: Nothing
//
//
void  CMCopy4bppTo1bpp( LPBYTE pSrc,
                                            LPBYTE pDst,
                                            UINT   cx,
                                            UINT   cy )
{
    UINT  x;
    UINT  y;
    UINT  cbDstRowWidth;
    UINT  cbSrcRowWidth;
    UINT  cbUnpaddedDstRowWidth;
    BOOL  fPadByteNeeded;
    BYTE Mask;

    DebugEntry(CMCopy4bppTo1bpp);

    cbDstRowWidth = ((cx + 15)/16) * 2;
    cbUnpaddedDstRowWidth = (cx + 7) / 8;
    cbSrcRowWidth = (cx + 1) / 2;
    fPadByteNeeded = ((cbDstRowWidth - cbUnpaddedDstRowWidth) > 0);

    for (y = 0; y < cy; y++)
    {
        *pDst = 0;
        Mask = 0x80;
        for (x = 0; x < cbSrcRowWidth; x++)
        {
            if (Mask == 0)
            {
                Mask = 0x80;
                pDst++;
                *pDst = 0;
            }

            if ((*pSrc & 0xF0) != 0)
            {
                *pDst |= Mask;
            }

            if ((*pSrc & 0x0F) != 0)
            {
                *pDst |= (Mask >> 1);
            }

            Mask >>= 2;

            pSrc++;
        }

        if (fPadByteNeeded)
        {
            pDst++;
            *pDst = 0;
        }

        pDst++;
    }

    DebugExitVOID(CMCopy4bppTo1bpp);
}

//
// FUNCTION: CMCopy8bppTo1bpp
//
// DESCRIPTION:
//
// Color conversion utility function to copy 8bpp cursor data to 1bpp.
//
// Data is assumed to be padded to word boundaries, and that the
// destination buffer is big enough to receive the 1bpp cursor data.
//
// PARAMETERS:
//
// pSrc - pointer to source data
//
// pDst - pointer to destination buffer
//
// cx - width of cursor in pixels
//
// cy - height of cursor in pixels
//
// RETURNS: Nothing
//
//
void  CMCopy8bppTo1bpp( LPBYTE pSrc,
                                            LPBYTE pDst,
                                            UINT   cx,
                                            UINT   cy )
{
    UINT  x;
    UINT  y;
    UINT  cbDstRowWidth;
    UINT  cbSrcRowWidth;
    UINT  cbUnpaddedDstRowWidth;
    BOOL  fPadByteNeeded;
    BYTE Mask;

    DebugEntry(CMCopy8bppTo1bpp);

    cbDstRowWidth = ((cx + 15)/16) * 2;
    cbUnpaddedDstRowWidth = (cx + 7) / 8;
    cbSrcRowWidth = cx;
    fPadByteNeeded = ((cbDstRowWidth - cbUnpaddedDstRowWidth) > 0);

    for (y = 0; y < cy; y++)
    {
        *pDst = 0;
        Mask = 0x80;
        for (x = 0; x < cbSrcRowWidth; x++)
        {
            if (Mask == 0x00)
            {
                Mask = 0x80;
                pDst++;
                *pDst = 0;
            }

            if (*pSrc != 0)
            {
                *pDst |= Mask;
            }

            Mask >>= 1;

            pSrc++;
        }

        if (fPadByteNeeded)
        {
            pDst++;
            *pDst = 0;
        }

        pDst++;
    }

    DebugExitVOID(CMCopy8bppTo1bpp);
}

//
// FUNCTION: CMCopy16bppTo1bpp
//
// DESCRIPTION:
//
// Color conversion utility function to copy 16bpp cursor data to 1bpp.
//
// Data is assumed to be padded to word boundaries, and that the
// destination buffer is big enough to receive the 1bpp cursor data.
//
// PARAMETERS:
//
// pSrc - pointer to source data
//
// pDst - pointer to destination buffer
//
// cx - width of cursor in pixels
//
// cy - height of cursor in pixels
//
// RETURNS: Nothing
//
//
void  CMCopy16bppTo1bpp( LPBYTE pSrc,
                                             LPBYTE pDst,
                                             UINT   cx,
                                             UINT   cy )
{
    UINT  x;
    UINT  y;
    UINT  cbDstRowWidth;
    UINT  cbUnpaddedDstRowWidth;
    BOOL  fPadByteNeeded;
    BYTE Mask;

    DebugEntry(CMCopy16bppTo1bpp);

    cbDstRowWidth = ((cx + 15)/16) * 2;
    cbUnpaddedDstRowWidth = (cx + 7) / 8;
    fPadByteNeeded = ((cbDstRowWidth - cbUnpaddedDstRowWidth) > 0);

    for (y = 0; y < cy; y++)
    {
        *pDst = 0;
        Mask = 0x80;
        for (x = 0; x < cx; x++)
        {
            if (Mask == 0)
            {
                Mask = 0x80;
                pDst++;
                *pDst = 0;
            }

            if (*(LPTSHR_UINT16)pSrc != 0)
            {
                *pDst |= Mask;
            }

            Mask >>= 1;

            pSrc += 2;
        }

        if (fPadByteNeeded)
        {
            pDst++;
            *pDst = 0;
        }

        pDst++;
    }

    DebugExitVOID(CMCopy16bppTo1bpp);
}


//
// FUNCTION: CMCopy24bppTo1bpp
//
// DESCRIPTION:
//
// Color conversion utility function to copy 24bpp cursor data to 1bpp.
//
// Data is assumed to be padded to word boundaries, and that the
// destination buffer is big enough to receive the 1bpp cursor data.
//
// PARAMETERS:
//
// pSrc - pointer to source data
//
// pDst - pointer to destination buffer
//
// cx - width of cursor in pixels
//
// cy - height of cursor in pixels
//
// RETURNS: Nothing
//
//
void  CMCopy24bppTo1bpp( LPBYTE pSrc,
                                             LPBYTE pDst,
                                             UINT   cx,
                                             UINT   cy )
{
    UINT  x;
    UINT  y;
    UINT  cbDstRowWidth;
    UINT  cbUnpaddedDstRowWidth;
    BOOL  fPadByteNeeded;
    BYTE Mask;
    UINT intensity;

    DebugEntry(CMCopy24bppTo1bpp);

    cbDstRowWidth = ((cx + 15)/16) * 2;
    cbUnpaddedDstRowWidth = (cx + 7) / 8;
    fPadByteNeeded = ((cbDstRowWidth - cbUnpaddedDstRowWidth) > 0);

    for (y = 0; y < cy; y++)
    {
        *pDst = 0;
        Mask = 0x80;
        for (x = 0; x < cx; x++)
        {
            if (Mask == 0)
            {
                Mask = 0x80;
                pDst++;
                *pDst = 0;
            }

            //
            // Work out the intensity of the RGB value.  There are three
            // possible results
            // 1) intensity <=CM_BLACK_THRESHOLD
            //    -- we leave the dest as blck
            // 2) intensity > CM_WHITE_THRESHOLD
            //    -- we definitely map to white
            // 3) otherwise
            //    -- we map to white in a grid hatching fashion
            //
            intensity = ((UINT)pSrc[0]*(UINT)pSrc[0]) +
                        ((UINT)pSrc[1]*(UINT)pSrc[1]) +
                        ((UINT)pSrc[2]*(UINT)pSrc[2]);

            if ( (intensity > CM_WHITE_THRESHOLD) ||
                ((intensity > CM_BLACK_THRESHOLD) && (((x ^ y) & 1) == 1)))
            {
                *pDst |= Mask;
            }

            Mask >>= 1;

            pSrc += 3;
        }

        if (fPadByteNeeded)
        {
            pDst++;
            *pDst = 0;
        }

        pDst++;
    }

    DebugExitVOID(CMCopy24bppTo1bpp);
}




//
// FUNCTION: CMSendCachedCursor
//
// DESCRIPTION:
//
// Sends a packet containing the given cache entry id.
//
// PARAMETERS:
//
// iCacheEntry - cache index
//
// RETURNS: TRUE if packet sent, FALSE otherwise.
//
//
BOOL  ASHost::CMSendCachedCursor(UINT iCacheEntry)
{
    BOOL                    rc = FALSE;
    PCMPACKETCOLORCACHE     pCMPacket;
#ifdef _DEBUG
    UINT                    sentSize;
#endif // _DEBUG

    DebugEntry(ASHost::CMSendCachedCursor);

    TRACE_OUT(( "Send cached cursor(%u)", iCacheEntry));

    pCMPacket = (PCMPACKETCOLORCACHE)m_pShare->SC_AllocPkt(PROT_STR_MISC, g_s20BroadcastID,
        sizeof(*pCMPacket));
    if (!pCMPacket)
    {
        WARNING_OUT(("Failed to alloc CM cached image packet"));
        DC_QUIT;
    }

    //
    // Fill in the packet.
    //
    pCMPacket->header.header.data.dataType = DT_CM;
    pCMPacket->header.type = CM_CURSOR_COLOR_CACHE;
    pCMPacket->cacheIndex = (TSHR_UINT16)iCacheEntry;

    //
    // Send it
    //
    if (m_pShare->m_scfViewSelf)
        m_pShare->CM_ReceivedPacket(m_pShare->m_pasLocal, &(pCMPacket->header.header));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    m_pShare->DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
        &(pCMPacket->header.header), sizeof(*pCMPacket));

    TRACE_OUT(("CM COLOR CACHE packet size: %08d, sent %08d", sizeof(*pCMPacket),
        sentSize));

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::CMSendCachedCursor, rc);
    return(rc);
}



//
// FUNCTION: CMGetControllingWindow
//
// DESCRIPTION:
//
// Determines the window that is controlling the cursor's current shape.
//
// PARAMETERS: None
//
// RETURNS: the window that is controlling the cursor's current shape.
//
//
HWND  CMGetControllingWindow(void)
{
    POINT   cursorPos;
    HWND    hwnd;

    DebugEntry(CMGetControllingWindow);

    //
    // If a SysErrPopup Window (which is always System Modal) is present
    // then WindowFromPoint enters a infinite recursion loop, trashing the
    // stack and crashing the whole system.
    // If there is a SysModal window Window ensure WindowFromPoint is not
    // executed.
    //
    // The window controlling the cursor appearance is:
    //
    // - the local window that has the mouse capture (if any)
    // - the window that is under the current mouse position
    //
    //
    hwnd = GetCapture();
    if (!hwnd)
    {
        //
        // Get the current mouse position.
        //
        GetCursorPos(&cursorPos);
        hwnd = WindowFromPoint(cursorPos);
    }

    DebugExitDWORD(CMGetControllingWindow, HandleToUlong(hwnd));
    return(hwnd);
}




//
// FUNCTION: CMGetCurrentCursor
//
// DESCRIPTION:
//
// Returns a description of the current cursor
//
// PARAMETERS:
//
// pCursor - pointer to a CURSORDESCRIPTION variable that receives details
// of the current cursor
//
// RETURNS: Nothing
//
//
void  CMGetCurrentCursor(LPCURSORDESCRIPTION pCursor)
{
    LPCM_FAST_DATA lpcmShared;

    DebugEntry(CMGetCurrentCursor);

    lpcmShared = CM_SHM_START_READING;

    pCursor->type = CM_CD_BITMAPCURSOR;
    pCursor->id = lpcmShared->cmCursorStamp;

    CM_SHM_STOP_READING;

    DebugExitVOID(CMGetCurrentCursor);
}


//
// FUNCTION: CMSendSystemCursor
//
// DESCRIPTION:
//
// Sends a packet containing the given system cursor IDC.
//
// PARAMETERS:
//
// cursorIDC - the IDC of the system cursor to send
//
// RETURNS: TRUE if successful, FALSE otherwise.
//
//
BOOL  ASHost::CMSendSystemCursor(UINT cursorIDC)
{
    BOOL            rc = FALSE;
    PCMPACKETID     pCMPacket;
#ifdef _DEBUG
    UINT            sentSize;
#endif // _DEBUG

    DebugEntry(ASHost::CMSendSystemCursor);

    ASSERT((cursorIDC == CM_IDC_NULL) || (cursorIDC == CM_IDC_ARROW));

    //
    // The cursor is one of the system cursors - create a PROTCURSOR packet
    //
    pCMPacket = (PCMPACKETID)m_pShare->SC_AllocPkt(PROT_STR_MISC, g_s20BroadcastID,
        sizeof(*pCMPacket));
    if (!pCMPacket)
    {
        WARNING_OUT(("Failed to alloc CM system image packet"));
        DC_QUIT;
    }

    //
    // Fill in the packet.
    //
    pCMPacket->header.header.data.dataType = DT_CM;
    pCMPacket->header.type = CM_CURSOR_ID;
    pCMPacket->idc = cursorIDC;

    TRACE_OUT(( "Send CMCURSORID %ld", cursorIDC));

    //
    // Send it
    //
    if (m_pShare->m_scfViewSelf)
        m_pShare->CM_ReceivedPacket(m_pShare->m_pasLocal, &(pCMPacket->header.header));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    m_pShare->DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
        &(pCMPacket->header.header), sizeof(*pCMPacket));

    TRACE_OUT(("CM ID packet size: %08d, sent %08d", sizeof(*pCMPacket),
        sentSize));

    //
    // Indicate that we successfully sent a packet.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::CMSendSystemCursor, rc);
    return(rc);
}



//
// FUNCTION: CMSendBitmapCursor
//
// DESCRIPTION:
//
// Sends the current cursor as a bitmap.
//
// PARAMETERS: None
//
// RETURNS: TRUE if successful, FALSE otherwise.
//
//
BOOL  ASHost::CMSendBitmapCursor(void)
{
    BOOL            rc = FALSE;
    LPCM_SHAPE      pCursor;
    UINT            cbCursorDataSize;

    DebugEntry(ASHost::CMSendBitmapCursor);

    //
    // If cursor is hidden, send Null cursor
    //
    if (m_cmfCursorHidden)
    {
        TRACE_OUT(( "Send Null cursor (cursor hidden)"));
        CMSendSystemCursor(CM_IDC_NULL);
        DC_QUIT;
    }

    //
    // Get a pointer to the current cursor shape.
    //
    if (!CMGetCursorShape(&pCursor, &cbCursorDataSize))
    {
        DC_QUIT;
    }

    //
    // If this is a Null pointer, send the relevant packet.
    //
    if (CM_CURSOR_IS_NULL(pCursor))
    {
        TRACE_OUT(( "Send Null cursor"));
        CMSendSystemCursor(CM_IDC_NULL);
        DC_QUIT;
    }

    //
    // If all of the parties in the call support the color cursor protocol
    // then we try to send the cursor using that protocol, otherwise we
    // send a mono cursor.
    //
    if (m_cmfUseColorCursorProtocol)
    {
        if (!CMSendCursorShape(pCursor, cbCursorDataSize))
        {
            DC_QUIT;
        }
    }
    else
    {
        //
        // We cannot send cursors that are not 32x32 using the mono
        // protocol.
        //
        if ((pCursor->hdr.cx != 32) || (pCursor->hdr.cy != 32))
        {
            //
            // Maybe copy and alter the cursor definition so that it is
            // 32x32 ?
            //
            WARNING_OUT(( "Non-standard cursor (%d x %d)", pCursor->hdr.cx,
                                                         pCursor->hdr.cy ));
            DC_QUIT;
        }

        if (!CMSendMonoBitmapCursor(pCursor))
        {
            DC_QUIT;
        }
    }

    //
    // Return success.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASHost::CMSendBitmapCursor, rc);
    return(rc);
}


//
// FUNCTION: CMCalculateColorCursorSize
//
// DESCRIPTION:
//
// Calculates the size in bytes of a given color cursor.
//
// PARAMETERS:
//
// pCursor - pointer to the cursor shape
//
// pcbANDMaskSize - pointer to a UINT variable that receives the AND mask
// size in bytes
//
// pcbXORBitmapSize - pointer to a UINT variable that receives the XOR
// bitmap size in bytes
//
// RETURNS: Nothing
//
//
void  CMCalculateColorCursorSize( LPCM_SHAPE pCursor,
                                             LPUINT        pcbANDMaskSize,
                                             LPUINT        pcbXORBitmapSize)
{
    DebugEntry(CMCalculcateColorCursorSize);

    *pcbANDMaskSize = CURSOR_AND_MASK_SIZE(pCursor);

    *pcbXORBitmapSize = CURSOR_DIB_BITS_SIZE( pCursor->hdr.cx,
                                              pCursor->hdr.cy,
                                              24 );

    DebugExitVOID(CMCalculateColorCursorSize);
}


//
// FUNCTION: CMSendColorBitmapCursor
//
// DESCRIPTION:
//
// Sends a given cursor as a color bitmap.
//
// PARAMETERS:
//
// pCursor - pointer to the cursor shape
//
// iCacheEntry - cache index to store in the transmitted packet
//
// RETURNS: TRUE if packet sent, FALSE otherwise
//
//
BOOL  ASHost::CMSendColorBitmapCursor(LPCM_SHAPE pCursor, UINT iCacheEntry)
{
    UINT        cbPacketSize;
    PCMPACKETCOLORBITMAP  pCMPacket;
    BOOL      rc = FALSE;
    UINT      cbANDMaskSize;
    UINT      cbXORBitmapSize;
    UINT      cbColorCursorSize;
#ifdef _DEBUG
    UINT      sentSize;
#endif // _DEBUG

    DebugEntry(ASHost::CMSendColorBitmapCursor);


    CMCalculateColorCursorSize(pCursor, &cbANDMaskSize, &cbXORBitmapSize );

    cbColorCursorSize = cbANDMaskSize + cbXORBitmapSize;

    //
    // Allocate a packet.
    //
    cbPacketSize = sizeof(CMPACKETCOLORBITMAP) + (cbColorCursorSize - 1);
    pCMPacket = (PCMPACKETCOLORBITMAP)m_pShare->SC_AllocPkt(PROT_STR_MISC,
        g_s20BroadcastID, cbPacketSize);
    if (!pCMPacket)
    {
        WARNING_OUT(("Failed to alloc CM color image packet, size %u", cbPacketSize));
        DC_QUIT;
    }

    //
    // Fill in the packet.
    //
    pCMPacket->header.header.data.dataType = DT_CM;

    //
    // Fill in fields.
    //
    pCMPacket->header.type = CM_CURSOR_COLOR_BITMAP;
    pCMPacket->cacheIndex = (TSHR_UINT16)iCacheEntry;

    if (!CMGetColorCursorDetails(pCursor,
        &(pCMPacket->cxWidth), &(pCMPacket->cyHeight),
        &(pCMPacket->xHotSpot), &(pCMPacket->yHotSpot),
        pCMPacket->aBits + cbXORBitmapSize,
        &(pCMPacket->cbANDMask),
        pCMPacket->aBits,
        &(pCMPacket->cbXORBitmap )))
    {
        //
        // Failed to get a cursor details.  Must free up SNI packet
        //
        S20_FreeDataPkt(&(pCMPacket->header.header));
        DC_QUIT;
    }

    ASSERT((pCMPacket->cbANDMask == cbANDMaskSize));

    ASSERT((pCMPacket->cbXORBitmap == cbXORBitmapSize));

    //
    // Send it
    //
    if (m_pShare->m_scfViewSelf)
        m_pShare->CM_ReceivedPacket(m_pShare->m_pasLocal, &(pCMPacket->header.header));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    m_pShare->DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
        &(pCMPacket->header.header), sizeof(*pCMPacket));

    TRACE_OUT(("CM COLOR BITMAP packet size: %08d, sent %08d", sizeof(*pCMPacket),
        sentSize));

    //
    // Indicate that we successfully sent a packet.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASHost::CMSendColorBitmapCursor, rc);
    return(rc);
}


//
// FUNCTION: CMSendMonoBitmapCursor
//
// DESCRIPTION:
//
// Sends a given cursor as a mono bitmap
//
// PARAMETERS:
//
// pCursor - pointer to the cursor shape
//
// RETURNS: TRUE if packet sent, FALSE otherwise
//
//
BOOL  ASHost::CMSendMonoBitmapCursor(LPCM_SHAPE pCursor)
{
    UINT                cbPacketSize;
    PCMPACKETMONOBITMAP pCMPacket;
    BOOL                rc = FALSE;
    TSHR_UINT16         cbANDMaskSize;
    TSHR_UINT16         cbXORBitmapSize;
#ifdef _DEBUG
    UINT                sentSize;
#endif // _DEBUG

    DebugEntry(AShare::CMSendMonoBitmapCursor);

    //
    // Calculate the sizes of the converted (1bpp) AND and XOR bitmaps.
    //
    cbANDMaskSize = (TSHR_UINT16)CURSOR_AND_MASK_SIZE(pCursor);
    cbXORBitmapSize = cbANDMaskSize;

    //
    // Allocate a packet.
    //
    cbPacketSize = sizeof(CMPACKETMONOBITMAP) +
                   (cbANDMaskSize + cbXORBitmapSize - 1);
    pCMPacket = (PCMPACKETMONOBITMAP)m_pShare->SC_AllocPkt(PROT_STR_MISC,
        g_s20BroadcastID, cbPacketSize);
    if (!pCMPacket)
    {
        WARNING_OUT(("Failed to alloc CM mono image packet, size %u", cbPacketSize));
        DC_QUIT;
    }

    //
    // Fill FF in to initialize the XOR and AND bits
    //
    FillMemory((LPBYTE)(pCMPacket+1)-1, cbANDMaskSize + cbXORBitmapSize, 0xFF);

    //
    // Fill in the packet.
    //
    pCMPacket->header.header.data.dataType = DT_CM;

    //
    // Fill in fields.
    //
    pCMPacket->header.type = CM_CURSOR_MONO_BITMAP;

    CMGetMonoCursorDetails(pCursor,
                            &(pCMPacket->width),
                            &(pCMPacket->height),
                            &(pCMPacket->xHotSpot),
                            &(pCMPacket->yHotSpot),
                            pCMPacket->aBits + cbXORBitmapSize,
                            &cbANDMaskSize,
                            pCMPacket->aBits,
                            &cbXORBitmapSize );

    pCMPacket->cbBits = (TSHR_UINT16) (cbANDMaskSize + cbXORBitmapSize);

    TRACE_OUT(( "Mono cursor cx:%u cy:%u xhs:%u yhs:%u cbAND:%u cbXOR:%u",
        pCMPacket->width, pCMPacket->height,
        pCMPacket->xHotSpot, pCMPacket->yHotSpot,
        cbANDMaskSize, cbXORBitmapSize));

    //
    // Send it
    //
    if (m_pShare->m_scfViewSelf)
        m_pShare->CM_ReceivedPacket(m_pShare->m_pasLocal, &(pCMPacket->header.header));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    m_pShare->DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
        &(pCMPacket->header.header), sizeof(*pCMPacket));

    TRACE_OUT(("CM MONO BITMAP packet size: %08d, sent %08d", sizeof(*pCMPacket),
        sentSize));

    //
    // Indicate that we successfully sent a packet.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(ASHost::CMSendMonoBitmapCursor, rc);
    return(rc);
}





//
// FUNCTION: CMCreateMonoCursor
//
// DESCRIPTION: Creates a mono cursor
//
// PARAMETERS:
//
// xHotSpot - x position of the hotspot
//
// yHotSpot - y position of the hotspot
//
// cxWidth - width of the cursor
//
// cyHeight - height of the cursor
//
// pANDMask - pointer to a 1bpp, word-padded AND mask
//
// pXORBitmap - pointer to a 1bpp, word-padded XOR bitmap
//
// RETURNS: a valid cursor id, or NULL if the function fails
//
//
HCURSOR  ASShare::CMCreateMonoCursor(UINT     xHotSpot,
                                                 UINT     yHotSpot,
                                                 UINT     cxWidth,
                                                 UINT     cyHeight,
                                                 LPBYTE   pANDMask,
                                                 LPBYTE   pXORBitmap)
{
    HCURSOR  rc;

    DebugEntry(ASShare::CMCreateMonoCursor);

    //
    // Attempt to create the mono cursor.
    //
    rc = CreateCursor(g_asInstance, xHotSpot, yHotSpot, cxWidth, cyHeight,
            pANDMask, pXORBitmap);

    //
    // Check that the cursor handle is not null.
    //
    if (NULL == rc)
    {
        //
        // Substitute the default arrow cursor.
        //
        rc = m_cmArrowCursor;

        WARNING_OUT(( "Could not create cursor - substituting default arrow"));
    }

    //
    // Return the cursor
    //
    DebugExitDWORD(ASShare::CMCreateMonoCursor, HandleToUlong(rc));
    return(rc);
}



//
// FUNCTION: CMCreateColorCursor
//
// DESCRIPTION:
//
// Creates a color cursor.
//
// PARAMETERS:
//
// xHotSpot - x position of the hotspot
//
// yHotSpot - y position of the hotspot
//
// cxWidth - width of the cursor
//
// cyHeight - height of the cursor
//
// pANDMask - pointer to a 1bpp, word-padded AND mask
//
// pXORBitmap - pointer to a 24bpp, word-padded XOR bitmap
//
// cbANDMask - the size in bytes of the AND mask
//
// cbXORBitmap - the size in bytes of the XOR bitmap
//
// RETURNS: a valid cursor id, or NULL if the function fails
//
//
HCURSOR  ASShare::CMCreateColorCursor
(
    UINT     xHotSpot,
    UINT     yHotSpot,
    UINT     cxWidth,
    UINT     cyHeight,
    LPBYTE   pANDMask,
    LPBYTE   pXORBitmap,
    UINT     cbANDMask,
    UINT     cbXORBitmap
)
{
    HCURSOR         rc = 0;
    UINT             cbAllocSize;
    LPBITMAPINFO       pbmi = NULL;
    HDC                hdc = NULL;
    ICONINFO           iconInfo;
    HBITMAP            hbmXORBitmap = NULL;
    HBITMAP            hbmANDMask = NULL;
    HWND               hwndDesktop = NULL;

    DebugEntry(ASShare::CMCreateColorCursor);

    TRACE_OUT(("xhs(%u) yhs(%u) cx(%u) cy(%u) cbXOR(%u) cbAND(%u)",
                                                             xHotSpot,
                                                             yHotSpot,
                                                             cxWidth,
                                                             cyHeight,
                                                             cbXORBitmap,
                                                             cbANDMask ));


    //
    // We need a BITMAPINFO structure plus one additional RGBQUAD (there is
    // one included within the BITMAPINFO).  We use this to pass the 24bpp
    // XOR bitmap (which has no color table) and the 1bpp AND mask (which
    // requires 2 colors).
    //
    cbAllocSize = sizeof(*pbmi) + sizeof(RGBQUAD);

    pbmi = (LPBITMAPINFO)new BYTE[cbAllocSize];
    if (pbmi == NULL)
    {
        WARNING_OUT(( "Failed to alloc bmi(%x)", cbAllocSize));
        DC_QUIT;
    }

    //
    // Get a screen DC that we can pass to CreateDIBitmap.  We do not use
    // CreateCompatibleDC(NULL) here because that results in Windows
    // creating a mono bitmap.
    //
    hwndDesktop = GetDesktopWindow();
    hdc = GetWindowDC(hwndDesktop);
    if (hdc == NULL)
    {
        WARNING_OUT(( "Failed to create DC"));
        DC_QUIT;
    }

    pbmi->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
    pbmi->bmiHeader.biWidth  = cxWidth;
    pbmi->bmiHeader.biHeight = cyHeight;
    pbmi->bmiHeader.biPlanes = 1;
    pbmi->bmiHeader.biBitCount = 24;
    pbmi->bmiHeader.biCompression = 0;
    pbmi->bmiHeader.biSizeImage = cbXORBitmap;
    pbmi->bmiHeader.biXPelsPerMeter = 0;
    pbmi->bmiHeader.biYPelsPerMeter = 0;
    pbmi->bmiHeader.biClrUsed = 0;
    pbmi->bmiHeader.biClrImportant = 0;

    hbmXORBitmap = CreateDIBitmap( hdc,
                                   (LPBITMAPINFOHEADER)pbmi,
                                   CBM_INIT,
                                   pXORBitmap,
                                   pbmi,
                                   DIB_RGB_COLORS );

    ReleaseDC(hwndDesktop, hdc);

    if (hbmXORBitmap == NULL)
    {
        WARNING_OUT(( "Failed to create XOR bitmap"));
        DC_QUIT;
    }

    //
    // Create MONOCHROME mask bitmap.  This works on both Win95 and NT.
    // COLOR masks don't work on Win95, just NT.
    //
    hdc = CreateCompatibleDC(NULL);
    if (!hdc)
    {
        WARNING_OUT(("Failed to get screen dc"));
        DC_QUIT;
    }

    pbmi->bmiHeader.biBitCount = 1;
    pbmi->bmiHeader.biCompression = 0;
    pbmi->bmiHeader.biSizeImage = cbANDMask;

    // Black
    pbmi->bmiColors[0].rgbRed      = 0x00;
    pbmi->bmiColors[0].rgbGreen    = 0x00;
    pbmi->bmiColors[0].rgbBlue     = 0x00;
    pbmi->bmiColors[0].rgbReserved = 0x00;

    // White
    pbmi->bmiColors[1].rgbRed      = 0xFF;
    pbmi->bmiColors[1].rgbGreen    = 0xFF;
    pbmi->bmiColors[1].rgbBlue     = 0xFF;
    pbmi->bmiColors[1].rgbReserved = 0x00;

    hbmANDMask = CreateDIBitmap( hdc,
                                 (LPBITMAPINFOHEADER)pbmi,
                                 CBM_INIT,
                                 pANDMask,
                                 pbmi,
                                 DIB_RGB_COLORS );

    DeleteDC(hdc);

    if (hbmANDMask == NULL)
    {
        WARNING_OUT(( "Failed to create AND mask"));
        DC_QUIT;
    }

#ifdef _DEBUG
    //
    // Make sure the AND mask is monochrome
    //
    {
        BITMAP  bmp;

        GetObject(hbmANDMask, sizeof(BITMAP), &bmp);
        ASSERT(bmp.bmPlanes == 1);
        ASSERT(bmp.bmBitsPixel == 1);
    }
#endif

    iconInfo.fIcon = FALSE;
    iconInfo.xHotspot = xHotSpot;
    iconInfo.yHotspot = yHotSpot;
    iconInfo.hbmMask  = hbmANDMask;
    iconInfo.hbmColor = hbmXORBitmap;

    rc = CreateIconIndirect(&iconInfo);

    TRACE_OUT(( "CreateCursor(%x) cx(%u)cy(%u)", rc, cxWidth, cyHeight));

DC_EXIT_POINT:

    if (hbmXORBitmap != NULL)
    {
        DeleteBitmap(hbmXORBitmap);
    }

    if (hbmANDMask != NULL)
    {
        DeleteBitmap(hbmANDMask);
    }

    if (pbmi != NULL)
    {
        delete[] pbmi;
    }

    //
    // Check that we have successfully managed to create the cursor.  If
    // not then substitute the default cursor.
    //
    if (rc == 0)
    {
        //
        // Substitute the default arrow cursor.
        //
        rc = m_cmArrowCursor;

        WARNING_OUT(( "Could not create cursor - substituting default arrow"));
    }

    DebugExitDWORD(ASShare::CMCreateColorCursor, HandleToUlong(rc));
    return(rc);
}



//
// FUNCTION: CMCreateAbbreviatedName
//
// DESCRIPTION:
//
// This function attempts to take a name, and create an abbreviation from
// the first characters of the first and last name.
//
// PARAMETERS:
//
// szTagName    - a pointer to a string containing the name to abbreviate.
// szBuf        - a pointer to a buffer into which the abbreviation will
//                be created.
// cbBuf        - size of buffer pointed to by szBuf.
//
// RETURNS:
//
// TRUE:        Success.  szBuf filled in.
// FALSE:       Failure.  szBuf is not filled in.
//
//
BOOL CMCreateAbbreviatedName(LPCSTR szTagName, LPSTR szBuf,
                               UINT cbBuf)
{
    BOOL  rc = FALSE;
    LPSTR p;
    LPSTR q;

    DebugEntry(CMCreateAbbreviatedName);

    //
    // This function isn't DBCS safe, so we don't abbreviate in DBCS
    // character sets.
    //
    if (TRUE == GetSystemMetrics(SM_DBCSENABLED))
    {
        DC_QUIT;
    }

    //
    // Try to create initials.  If that doesn't work, fail the call.
    //
    if ((NULL != (p = (LPSTR)_StrChr(szTagName, ' '))) && ('\0' != *(p+1)))
    {
        //
        // Is there enough room for initials?
        //
        if (cbBuf < NTRUNCLETTERS)
        {
            DC_QUIT;
        }

        q = szBuf;

        *q++ = *szTagName;
        *q++ = '.';
        *q++ = *(p+1);
        *q++ = '.';
        *q = '\0';

        AnsiUpper(szBuf);

        rc = TRUE;
    }

DC_EXIT_POINT:
    DebugExitBOOL(CMCreateAbbreviatedName, rc);
    return rc;
}

//
// FUNCTION: CMDrawCursorTag
//
// DESCRIPTION:
//
// PARAMETERS:
//
// hdcWindow - DC handle of the window to be drawn to
//
// cursorID - handle of cursor to drawn
//
// RETURNS: Nothing.
//
//
void  ASShare::CMDrawCursorTag
(
    ASPerson *  pasHost,
    HDC         hdc
)
{
    ASPerson *  pasPerson;
    char        ShortName[TSHR_MAX_PERSON_NAME_LEN];
    HFONT       hOldFont = NULL;
    RECT        rect;
    UINT        cCharsFit;
    LPSTR       p;

    DebugEntry(ASShare::CMDrawCursorTag);

    pasPerson = pasHost->m_caControlledBy;
    if (!pasPerson)
    {
        // Nothing to do
        DC_QUIT;
    }

    ValidatePerson(pasPerson);

    //
    // Try to abbreviate the person's name, so it will fit into the tag.
    // If the abbreviation fails, just copy the entire name for now.
    //
    if (!(CMCreateAbbreviatedName(pasPerson->scName, ShortName, sizeof(ShortName))))
    {
        lstrcpyn(ShortName, pasPerson->scName, sizeof(ShortName));
    }

    //
    // Select the cursor tag font into the DC.
    //
    hOldFont = SelectFont(hdc, m_cmCursorTagFont);

    if (hOldFont == NULL)
    {
        WARNING_OUT(("CMDrawCursorTag failed"));
        DC_QUIT;
    }

    //
    // Create the tag background...
    //
    PatBlt(hdc, TAGXOFF, TAGYOFF, TAGXSIZ, TAGYSIZ, WHITENESS);

    //
    // See how many characters of the name or abbreviation we can fit into
    // the tag.  First assume the whole thing fits.
    //
    cCharsFit = lstrlen(ShortName);

    //
    // Determine how many characters actually fit.
    //
    rect.left = rect.top = rect.right = rect.bottom = 0;

    for (p = AnsiNext(ShortName); ; p = AnsiNext(p))
    {
        if (DrawText(hdc, ShortName, (int)(p - ShortName), &rect,
                     DT_CALCRECT | DT_SINGLELINE | DT_NOPREFIX))
        {
            if (rect.right > TAGXSIZ)
            {
                //
                // This number of characters does not fit into the tag. Try
                // the next smaller number.
                //
                cCharsFit = (UINT)(AnsiPrev(ShortName, p) - ShortName);
                break;
            }
        }

        if ( '\0' == *p)
            break;
    }

    //
    // Now draw the text.  Note that DrawText does not return a documented
    // error code, so we don't check.
    //
    rect.left = TAGXOFF;
    rect.top = TAGYOFF;
    rect.right = TAGXOFF + TAGXSIZ;
    rect.bottom = TAGYOFF + TAGYSIZ;

    DrawText(hdc, ShortName, cCharsFit, &rect,
             DT_CENTER | DT_SINGLELINE | DT_NOPREFIX);

DC_EXIT_POINT:
    //
    // Perform necessary cleanup.
    //
    if (hOldFont)
    {
        SelectFont(hdc, hOldFont);
    }

    DebugExitVOID(ASShare::CMDrawCursorTag);
}





//
// FUNCTION: CMGetCursorShape
//
// DESCRIPTION:
//
// Returns a pointer to a DCCURSORSHAPE structure that defines the bit
// definition of the currently displayed cursor.
//
// A DCCURSORSHAPE structure is OS-specific.  The higher level code does
// not look at any individual fields in this structure - it just compares
// the whole data block with others in the cursor cache.  If two
// DCCURSORSHAPE structures contain the same the data, then the
// corresponding cursors are assumed to be the same.
//
// The LPCM_SHAPE returned here is passed back into
// CMGetColorCursorDetails or CMGetMonoCursorDetails to retrieve the
// specific details.
//
// PARAMETERS:
//
// ppCursorShape - pointer to a LPCM_SHAPE variable that receives the
// pointer to the DCCURSORSHAPE structure
//
// pcbCursorDataSize - pointer to a UINT variable that receives the size
// in bytes of the DCCURSORSHAPE structure
//
// RETURNS: Success TRUE/FALSE
//
//
BOOL  CMGetCursorShape(LPCM_SHAPE * ppCursorShape,
                                     LPUINT       pcbCursorDataSize )
{
    LPCM_FAST_DATA  lpcmShared;
    BOOL            rc = FALSE;

    DebugEntry(CMGetCursorShape);

    lpcmShared = CM_SHM_START_READING;

    //
    // Check that a cursor has been written to shared memory - may happen
    // on start-up before the display driver has written a cursor - or if
    // the display driver is not working.
    //
    if (lpcmShared->cmCursorShapeData.hdr.cBitsPerPel == 0)
    {
        TRACE_OUT(( "No cursor in shared memory"));
        DC_QUIT;
    }

    *ppCursorShape = (LPCM_SHAPE)&lpcmShared->cmCursorShapeData;
    *pcbCursorDataSize = CURSORSHAPE_SIZE(&lpcmShared->cmCursorShapeData);

    rc = TRUE;

DC_EXIT_POINT:
    CM_SHM_STOP_READING;

    DebugExitDWORD(CMGetCursorShape, rc);
    return(rc);
}



//
// FUNCTION: CMGetColorCursorDetails
//
// DESCRIPTION:
//
// Returns details of a cursor at 24bpp, given a DCCURSORSHAPE structure.
//
// PARAMETERS:
//
// pCursor - pointer to a DCCURSORSHAPE structure from which this function
// extracts the details
//
// pcxWidth - pointer to a TSHR_UINT16 variable that receives the cursor width
// in pixels
//
// pcyHeight - pointer to a TSHR_UINT16 variable that receives the cursor
// height in pixels
//
// pxHotSpot - pointer to a TSHR_UINT16 variable that receives the cursor
// hotspot x coordinate
//
// pyHotSpot - pointer to a TSHR_UINT16 variable that receives the cursor
// hotspot y coordinate
//
// pANDMask - pointer to a buffer that receives the cursor AND mask
//
// pcbANDMask - pointer to a TSHR_UINT16 variable that receives the size in
// bytes of the cursor AND mask
//
// pXORBitmap - pointer to a buffer that receives the cursor XOR bitmap at
// 24bpp
//
// pcbXORBitmap - pointer to a TSHR_UINT16 variable that receives the size in
// bytes of the cursor XOR bitmap
//
//
BOOL  ASHost::CMGetColorCursorDetails
(
    LPCM_SHAPE          pCursor,
    LPTSHR_UINT16       pcxWidth,
    LPTSHR_UINT16       pcyHeight,
    LPTSHR_UINT16       pxHotSpot,
    LPTSHR_UINT16       pyHotSpot,
    LPBYTE              pANDMask,
    LPTSHR_UINT16       pcbANDMask,
    LPBYTE              pXORBitmap,
    LPTSHR_UINT16       pcbXORBitmap
)
{
    BOOL             rc = FALSE;
    LPCM_SHAPE_HEADER  pCursorHdr;
    HDC                hdcScreen = NULL;
    HBITMAP            hbmp = NULL;
    UINT             cbANDMaskSize;
    UINT             cbXORBitmapSize;
    HDC                hdcTmp = NULL;
    UINT             cbANDMaskRowWidth;
    UINT             cbSrcRowOffset;
    UINT             cbDstRowOffset;
    UINT             y;
    LPUINT          pDestBitmasks;
    BITMAPINFO_ours    bmi;
    BITMAPINFO_ours    srcbmi;
    HBITMAP            oldBitmap;
    void *            pBmBits = NULL;
    int              numColors;
    int              ii;
    LPCM_FAST_DATA  lpcmShared;

    DebugEntry(ASHost::CMGetColorCursorDetails);

    if (pCursor == NULL)
    {
        DC_QUIT;
    }
    pCursorHdr = &(pCursor->hdr);

    //
    // Copy the cursor size and hotspot coords.
    //
    *pcxWidth  = pCursorHdr->cx;
    *pcyHeight = pCursorHdr->cy;
    *pxHotSpot = (TSHR_UINT16)pCursorHdr->ptHotSpot.x;
    *pyHotSpot = (TSHR_UINT16)pCursorHdr->ptHotSpot.y;
    TRACE_OUT(( "cx(%u) cy(%u) cbWidth %d planes(%u) bpp(%u)",
                                                   pCursorHdr->cx,
                                                   pCursorHdr->cy,
                                                   pCursorHdr->cbRowWidth,
                                                   pCursorHdr->cPlanes,
                                                   pCursorHdr->cBitsPerPel ));

    cbANDMaskSize = CURSOR_AND_MASK_SIZE(pCursor);
    cbXORBitmapSize = CURSOR_XOR_BITMAP_SIZE(pCursor);

    //
    // Copy the AND mask - this is always mono.
    //
    // The AND mask is currently in top-down format (the top row of the
    // bitmap comes first).
    //
    // The protocol sends bitmaps in Device Independent format, which is
    // bottom-up.  We therefore have to flip the rows as we copy the mask.
    //
    cbANDMaskRowWidth = pCursorHdr->cbRowWidth;
    cbSrcRowOffset = 0;
    cbDstRowOffset = cbANDMaskRowWidth * (pCursorHdr->cy-1);

    for (y = 0; y < pCursorHdr->cy; y++)
    {
        memcpy( pANDMask + cbDstRowOffset,
                pCursor->Masks + cbSrcRowOffset,
                cbANDMaskRowWidth );
        cbSrcRowOffset += cbANDMaskRowWidth;
        cbDstRowOffset -= cbANDMaskRowWidth;
    }

    //
    // The XOR mask is color and is in DIB format - at 1bpp for mono
    // cursors, or the display driver bpp.
    //
    // We create a bitmap of the same size, set the bits into it and then
    // get the bits out in 24bpp DIB format.
    //
    hdcTmp = CreateCompatibleDC(NULL);
    if (hdcTmp == NULL)
    {
        ERROR_OUT(( "failed to create DC"));
        DC_QUIT;
    }

    //
    // Setup source bitmap information.
    //
    m_pShare->USR_InitDIBitmapHeader((BITMAPINFOHEADER *)&srcbmi, pCursorHdr->cBitsPerPel);
    srcbmi.bmiHeader.biWidth  = pCursorHdr->cx;
    srcbmi.bmiHeader.biHeight = pCursorHdr->cy;

    numColors = COLORS_FOR_BPP(pCursorHdr->cBitsPerPel);

    //
    // Setup source palette info.
    //
    if (pCursorHdr->cBitsPerPel > 8)
    {
        //
        // If the device bpp is > 8, we have to set up the DIB section to
        // use the same bitmasks as the device.  This means setting the
        // compression type to BI_BITFIELDS and setting the first 3 DWORDS
        // of the bitmap info color table to be the bitmasks for R, G and B
        // respectively.
        // But not for 24bpp.  No bitmask or palette are used - it is
        // always 8,8,8 RGB.
        //
        if (pCursorHdr->cBitsPerPel != 24)
        {
            TRACE_OUT(( "Copy bitfields"));
            srcbmi.bmiHeader.biCompression = BI_BITFIELDS;

            lpcmShared = CM_SHM_START_READING;

            pDestBitmasks    = (LPUINT)(srcbmi.bmiColors);
            pDestBitmasks[0] = lpcmShared->bitmasks[0];
            pDestBitmasks[1] = lpcmShared->bitmasks[1];
            pDestBitmasks[2] = lpcmShared->bitmasks[2];

            CM_SHM_STOP_READING;
        }
        else
        {
            TRACE_OUT(( "24bpp cursor: no bitmasks"));
        }
    }
    else
    {
        TRACE_OUT(( "Get palette %d", numColors));

        lpcmShared = CM_SHM_START_READING;

        //
        // Flip the palette - its RGB in the kernel, and needs to be BGR
        // here.
        //
        for (ii = 0; ii < numColors; ii++)
        {
            srcbmi.bmiColors[ii].rgbRed   = lpcmShared->colorTable[ii].peRed;
            srcbmi.bmiColors[ii].rgbGreen = lpcmShared->colorTable[ii].peGreen;
            srcbmi.bmiColors[ii].rgbBlue  = lpcmShared->colorTable[ii].peBlue;
        }

        CM_SHM_STOP_READING;
    }

    //
    // Create source bitmap and write in the bitmap bits.
    //
    hbmp = CreateDIBSection(hdcTmp,
                            (BITMAPINFO *)&srcbmi,
                            DIB_RGB_COLORS,
                            &pBmBits,
                            NULL,
                            0);
    if (hbmp == NULL)
    {
        ERROR_OUT(( "Failed to create bitmap"));
        DC_QUIT;
    }

    TRACE_OUT(( "Copy %d bytes of data into bitmap 0x%08x",
                  cbXORBitmapSize, pBmBits));
    memcpy(pBmBits, pCursor->Masks + cbANDMaskSize, cbXORBitmapSize);


    //
    // Set up the structure required by GetDIBits - 24bpp.  Set the height
    // -ve to allow for top-down ordering of the bitmap.
    //
    m_pShare->USR_InitDIBitmapHeader((BITMAPINFOHEADER *)&bmi, 24);
    bmi.bmiHeader.biWidth  = pCursorHdr->cx;
    bmi.bmiHeader.biHeight = -pCursorHdr->cy;

    if (GetDIBits(hdcTmp,
                  hbmp,
                  0,
                  pCursorHdr->cy,
                  pXORBitmap,
                  (LPBITMAPINFO)&bmi,
                  DIB_RGB_COLORS) == 0)
    {
        ERROR_OUT(( "GetDIBits failed hdc(%x) hbmp(%x) cy(%d)",
                     (TSHR_UINT16)hdcTmp,
                     (TSHR_UINT16)hbmp,
                     pCursorHdr->cy ));
        DC_QUIT;
    }

    *pcbANDMask   = (TSHR_UINT16) CURSOR_AND_MASK_SIZE(pCursor);
    *pcbXORBitmap = (TSHR_UINT16) CURSOR_DIB_BITS_SIZE(pCursor->hdr.cx,
                                                    pCursor->hdr.cy,
                                                    24);

    //
    // Return success.
    //
    rc = TRUE;

DC_EXIT_POINT:
    //
    // Clean up before exit.
    //
    if (hdcTmp)
    {
        DeleteDC(hdcTmp);
    }

    if (hbmp != NULL)
    {
        DeleteBitmap(hbmp);
    }

    DebugExitBOOL(ASHost::CMGetColorCursorDetails, rc);
    return(rc);
}

//
// FUNCTION: CMGetMonoCursorDetails
//
// DESCRIPTION:
//
// Returns details of a cursor at 1bpp, given a DCCURSORSHAPE structure.
//
// PARAMETERS:
//
// pCursor - pointer to a DCCURSORSHAPE structure from which this function
// extracts the details
//
// pcxWidth - pointer to a TSHR_UINT16 variable that receives the cursor width
// in pixels
//
// pcyHeight - pointer to a TSHR_UINT16 variable that receives the cursor
// height in pixels
//
// pxHotSpot - pointer to a TSHR_UINT16 variable that receives the cursor
// hotspot x coordinate
//
// pyHotSpot - pointer to a TSHR_UINT16 variable that receives the cursor
// hotspot y coordinate
//
// pANDMask - pointer to a buffer that receives the cursor AND mask
//
// pcbANDMask - pointer to a TSHR_UINT16 variable that receives the size in
// bytes of the cursor AND mask
//
// pXORBitmap - pointer to a buffer that receives the cursor XOR bitmap at
// 1bpp
//
// pcbXORBitmap - pointer to a TSHR_UINT16 variable that receives the size in
// bytes of the cursor XOR bitmap
//
//
BOOL  CMGetMonoCursorDetails(LPCM_SHAPE pCursor,
                                                 LPTSHR_UINT16      pcxWidth,
                                                 LPTSHR_UINT16      pcyHeight,
                                                 LPTSHR_UINT16      pxHotSpot,
                                                 LPTSHR_UINT16      pyHotSpot,
                                                 LPBYTE       pANDMask,
                                                 LPTSHR_UINT16      pcbANDMask,
                                                 LPBYTE       pXORBitmap,
                                                 LPTSHR_UINT16      pcbXORBitmap)
{
    BOOL            rc = FALSE;
    LPCM_SHAPE_HEADER pCursorHdr;
    UINT            x;
    UINT            y;
    LPBYTE          pSrcRow;
    UINT          cbDstRowWidth;
    LPBYTE          pDstData;
    UINT          cbSrcANDMaskSize;
    LPBYTE          pSrcXORMask;
    PFNCMCOPYTOMONO   pfnCopyToMono;

    DebugEntry(CMGetMonoCursor);

    pCursorHdr = &(pCursor->hdr);

    TRACE_OUT(( "cx(%u) cy(%u) cbWidth %d planes(%u) bpp(%u)",
                                                   pCursorHdr->cx,
                                                   pCursorHdr->cy,
                                                   pCursorHdr->cbRowWidth,
                                                   pCursorHdr->cPlanes,
                                                   pCursorHdr->cBitsPerPel ));

    //
    // Copy the cursor size and hotspot coords.
    //
    *pcxWidth  = pCursorHdr->cx;
    *pcyHeight = pCursorHdr->cy;
    *pxHotSpot = (TSHR_UINT16)pCursorHdr->ptHotSpot.x;
    *pyHotSpot = (TSHR_UINT16)pCursorHdr->ptHotSpot.y;

    //
    // Copy the AND mask - this is always mono...
    // The rows are padded to word (16-bit) boundaries.
    //
    pDstData = pANDMask;
    pSrcRow = pCursor->Masks;
    cbDstRowWidth = ((pCursorHdr->cx + 15)/16) * 2;

    for (y = 0; y < pCursorHdr->cy; y++)
    {
        for (x = 0; x < cbDstRowWidth; x++)
        {
            if (x < pCursorHdr->cbRowWidth)
            {
                //
                // Copy data from the cursor definition.
                //
                *pDstData++ = pSrcRow[x];
            }
            else
            {
                //
                // Padding required.
                //
                *pDstData++ = 0xFF;
            }
        }
        pSrcRow += pCursorHdr->cbRowWidth;
    }

    //
    // Copy the XOR mask - this may be color.  We convert to mono by:
    //
    //   - turning all zero values into a binary 0
    //   - turning all non-zero value into a binary 1
    //
    //
    switch (pCursorHdr->cBitsPerPel)
    {
        case 1:
            TRACE_OUT(( "1bpp"));
            pfnCopyToMono = CMCopy1bppTo1bpp;
            break;

        case 4:
            TRACE_OUT(( "4bpp"));
            pfnCopyToMono = CMCopy4bppTo1bpp;
            break;

        case 8:
            TRACE_OUT(( "8bpp"));
            pfnCopyToMono = CMCopy8bppTo1bpp;
            break;

        case 16:
            TRACE_OUT(( "16bpp"));
            pfnCopyToMono = CMCopy16bppTo1bpp;
            break;

        case 24:
            TRACE_OUT(( "24bpp"));
            pfnCopyToMono = CMCopy24bppTo1bpp;
            break;

        default:
            ERROR_OUT(( "Unexpected bpp: %d", pCursorHdr->cBitsPerPel));
            DC_QUIT;
    }

    cbSrcANDMaskSize = pCursorHdr->cbRowWidth * pCursorHdr->cy;
    pSrcXORMask = pCursor->Masks + cbSrcANDMaskSize;

    (*pfnCopyToMono)( pSrcXORMask,
                              pXORBitmap,
                              pCursorHdr->cx,
                              pCursorHdr->cy );

    *pcbANDMask   = (TSHR_UINT16) (cbDstRowWidth * pCursorHdr->cy);
    *pcbXORBitmap = (TSHR_UINT16) *pcbANDMask;

    //
    // Return success.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(CMGetMonoCursor, rc);
    return(rc);
}



//
// FUNCTION: CMSetCursorTransform
//
// DESCRIPTION:
//
// This function is responsible for setting cursor transforms.
//
// PARAMETERS:
//
// cWidth        - the width in pels of the AND mask and the XOR DIB
// cHeight       - the height in pels of the AND mask and the XOR DIB
// pOrigANDMask  - a pointer to the bits of a WORD padded AND mask (the
//                 bits are top-down)
// pOrigXORDIB   - a pointer to a DIB of the size given by cWidth and
//                 cHeight.
//
//
BOOL ASHost::CMSetCursorTransform
(
    LPBYTE          pOrigANDMask,
    LPBITMAPINFO    pOrigXORDIB
)
{
    BOOL        rc = FALSE;
    LPBYTE      pBits = NULL;
    UINT        cbSize;
    CM_DRV_XFORM_INFO drvXformInfo;
    UINT        srcRowLength;

    DebugEntry(ASHost::CMSetCursorTransform);

    //
    // The transform should be monochrome
    //
    ASSERT(pOrigXORDIB->bmiHeader.biBitCount == 1);

    //
    // For mono tags, create a single 1bpp DIB with AND followed by XOR
    // data.  Since both the AND mask and the XOR bitmap are word
    // aligned we need to know the word aligned row length for
    // allocating memory.
    //

    //
    // Calculate the source and destination row lengths (in bytes).
    //
    srcRowLength = ((m_pShare->m_cmCursorWidth + 15)/16) * 2;
    cbSize = srcRowLength * m_pShare->m_cmCursorHeight;

    pBits = new BYTE[cbSize * 2];
    if (!pBits)
    {
        ERROR_OUT(( "Alloc %lu bytes failed", cbSize * 2));
        DC_QUIT;
    }

    //
    // Copy the packed 1bpp AND and XOR bits to the buffer
    //
    TRACE_OUT(( "Copy %d bytes from 0x%08x", cbSize, pOrigANDMask));

    //
    // Copy the AND and XOR 1bpp masks.
    //
    memcpy(pBits, pOrigANDMask, cbSize);
    memcpy(pBits + cbSize, POINTER_TO_DIB_BITS(pOrigXORDIB), cbSize);

    //
    // Call the display driver to set the pointer transform.
    //
    drvXformInfo.width      = m_pShare->m_cmCursorWidth;
    drvXformInfo.height     = m_pShare->m_cmCursorHeight;
    drvXformInfo.pANDMask   = pBits;
    drvXformInfo.result     = FALSE;

    if (!OSI_FunctionRequest(CM_ESC_XFORM, (LPOSI_ESCAPE_HEADER)&drvXformInfo,
            sizeof(drvXformInfo)) ||
        !drvXformInfo.result)
    {
        ERROR_OUT(("CM_ESC_XFORM failed"));
        DC_QUIT;
    }

    //
    // Set flag inidicating that transform is applied.
    //
    m_cmfCursorTransformApplied = TRUE;
    rc = TRUE;

DC_EXIT_POINT:
    //
    // Release allocated memory, bitmaps, DCs.
    //
    if (pBits)
    {
        delete[] pBits;
    }

    DebugExitBOOL(ASHost::CMSetCursorTransform, rc);
    return(rc);
}


//
// FUNCTION: CMRemoveCursorTransform
//
// DESCRIPTION:
// This function is responsible for removing cursor transforms.
//
// PARAMETERS: None.
//
void ASHost::CMRemoveCursorTransform(void)
{
    DebugEntry(ASHost::CMRemoveCursorTransform);

    //
    // Check to see if there is currently a transform applied.
    //
    if (m_cmfCursorTransformApplied)
    {
        CM_DRV_XFORM_INFO drvXformInfo;

        //
        // Call down to the display driver to remove the pointer tag.
        //
        drvXformInfo.pANDMask = NULL;
        drvXformInfo.result = FALSE;

        OSI_FunctionRequest(CM_ESC_XFORM, (LPOSI_ESCAPE_HEADER)&drvXformInfo,
            sizeof(drvXformInfo));

        m_cmfCursorTransformApplied = FALSE;
    }

    DebugExitVOID(ASHost::CMRemoveCursorTransform);
}



//
// FUNCTION: CMProcessCursorIDPacket
//
// DESCRIPTION:
//
// Processes a received cursor ID packet.
//
// PARAMETERS:
//
// pCMPacket - pointer to the received cursor ID packet
//
// phNewCursor - pointer to a HCURSOR variable that receives the handle
// of a cursor that corresponds to the received packet
//
// pNewHotSpot - pointer to a POINT variable that receives the hot-spot
// of the new cursor
//
// RETURNS: Nothing
//
//
void  ASShare::CMProcessCursorIDPacket
(
    PCMPACKETID     pCMPacket,
    HCURSOR*        phNewCursor,
    LPPOINT         pNewHotSpot
)
{
    DebugEntry(ASShare::CMProcessCursorIDPacket);

    //
    // We only support NULL and ARROW
    //

    //
    // If the IDC is not NULL then load the cursor.
    //
    if (pCMPacket->idc != CM_IDC_NULL)
    {
        if (pCMPacket->idc != CM_IDC_ARROW)
        {
            WARNING_OUT(("ProcessCursorIDPacket:  unrecognized ID, using arrow"));
        }

        *phNewCursor = m_cmArrowCursor;
        *pNewHotSpot = m_cmArrowCursorHotSpot;
    }
    else
    {
        // NULL is used for hidden cursors
        *phNewCursor = NULL;
        pNewHotSpot->x = 0;
        pNewHotSpot->y = 0;
    }

    DebugExitVOID(ASShare::CMProcessCursorIDPacket);
}




//
// CM_Controlled()
//
// Called when we start/stop being controlled.
//
extern              CURTAGINFO g_cti;

void ASHost::CM_Controlled(ASPerson * pasController)
{
    char  szAbbreviatedName[128];

    DebugEntry(ASHost::CM_Controlled);

    //
    // If we are not being controlled, turn off the cursor tag.  Note that
    // being detached means we aren't controlled.
    //
    if (!pasController)
    {
        // We're not being controlled by a remote.  No cursor xform
        CMRemoveCursorTransform();
    }
    else
    {
        BOOL fAbbreviated = CMCreateAbbreviatedName(pasController->scName,
            szAbbreviatedName, sizeof(szAbbreviatedName));

        if ( !fAbbreviated )
        {
            lstrcpyn(szAbbreviatedName, pasController->scName,
                    ARRAY_ELEMENTS(szAbbreviatedName));
        }

        if (!CMGetCursorTagInfo(szAbbreviatedName))
        {
            ERROR_OUT(("GetCurTagInfo failed, not setting cursor tag"));
        }
        else
        {
            CMSetCursorTransform(&g_cti.aAndBits[0], &g_cti.bmInfo);
        }
    }

    DebugExitVOID(ASHost::CM_Controlled);
}



// This initializes our single, volatile data for
// creating cursor tags.

CURTAGINFO g_cti = {
    32,    // height of masks
    32,    // width of masks

    // bits describing the AND mask, this is a 12x24 rectangle in lower right
    // if the tag size is changed, the mask will have to be edited, the
    // following helps draw attention to this
    #if ( TAGXOFF != 8 || TAGYOFF != 20 || TAGXSIZ != 24 || TAGYSIZ != 12 )
    #error "Bitmap mask may be incorrect"
    #endif

    {    0xff, 0xff, 0xff, 0xff,        // line 1
        0xff, 0xff, 0xff, 0xff,        // line 2
        0xff, 0xff, 0xff, 0xff,        // line 3
        0xff, 0xff, 0xff, 0xff,        // line 4
        0xff, 0xff, 0xff, 0xff,        // line 5
        0xff, 0xff, 0xff, 0xff,        // line 6
        0xff, 0xff, 0xff, 0xff,        // line 7
        0xff, 0xff, 0xff, 0xff,        // line 8
        0xff, 0xff, 0xff, 0xff,        // line 9
        0xff, 0xff, 0xff, 0xff,        // line 10
        0xff, 0xff, 0xff, 0xff,        // line 11
        0xff, 0xff, 0xff, 0xff,        // line 12
        0xff, 0xff, 0xff, 0xff,        // line 13
        0xff, 0xff, 0xff, 0xff,        // line 14
        0xff, 0xff, 0xff, 0xff,        // line 15
        0xff, 0xff, 0xff, 0xff,        // line 16
        0xff, 0xff, 0xff, 0xff,        // line 17
        0xff, 0xff, 0xff, 0xff,        // line 18
        0xff, 0xff, 0xff, 0xff,        // line 19
        0xff, 0xff, 0xff, 0xff,        // line 20
        0xff, 0x00, 0x00, 0x00,        // line 21
        0xff, 0x00, 0x00, 0x00,        // line 22
        0xff, 0x00, 0x00, 0x00,        // line 23
        0xff, 0x00, 0x00, 0x00,        // line 24
        0xff, 0x00, 0x00, 0x00,        // line 25
        0xff, 0x00, 0x00, 0x00,        // line 26
        0xff, 0x00, 0x00, 0x00,        // line 27
        0xff, 0x00, 0x00, 0x00,        // line 28
        0xff, 0x00, 0x00, 0x00,        // line 29
        0xff, 0x00, 0x00, 0x00,        // line 30
        0xff, 0x00, 0x00, 0x00,        // line 31
        0xff, 0x00, 0x00, 0x00        // line 32
    },
    // Initialize the BITMAPINFO structure:
    {
        // Initialize the BITMAPINFOHEADER structure:
        {
            sizeof(BITMAPINFOHEADER),
            32, // width
            -32, // height (top down bitmap)
            1, // planes
            1, // bits per pixel
            BI_RGB, // compression format (none)
            0, // not used for uncompressed bitmaps
            0, // xpels per meter, not set
            0, // ypels per meter, not set
            0, // biClrsUsed, indicates 2 color entries follow this struct
            0 // biClrsImportant (all)
        },

        // Initialize the foreground color (part of BITMAPINFO struct)
        // This is BLACK
        { 0x0, 0x0, 0x0, 0x0 },
    },

    // Initialize the background color (part of single RGBQUAD struct following
    // BITMAPINFO STRUCTURE
    { 0xff, 0xff, 0xff, 0x00 },

    // Because this is a packed bitmap, the bitmap bits follow:
    // These will be written into dynamically to create the tag

    { 0, }
};



//
// This function isn't DBCS safe, so we don't abbreviate in
// DBCS character sets
//

BOOL ASShare::CMCreateAbbreviatedName
(
    LPCSTR  szTagName,
    LPSTR   szBuf,
    UINT    cbBuf
)
{
    BOOL    rc = FALSE;

    DebugEntry(ASShare::CMCreateAbbreviatedName);

    if (GetSystemMetrics(SM_DBCSENABLED))
    {
        TRACE_OUT(("Do not attempt to abbreviate on DBCS system"));
        DC_QUIT;
    }

    // We will try to create initials first

    LPSTR p;
    if ( NULL != (p = (LPSTR) _StrChr ( szTagName, ' ' )))
    {
        // Enough room for initials?
        if (cbBuf < NTRUNCLETTERS)
        {
            TRACE_OUT(("CMCreateAbbreviatedName: not enough room for initials"));
            DC_QUIT;
        }

        char * q = szBuf;

        *q++ = *szTagName;
        *q++ = '.';
        *q++ = *(p+1);
        *q++ = '.';
        *q = '\0';

        CharUpper ( q );

        rc = TRUE;
    }

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CMCreateAbbreviatedName, rc);
    return(rc);
}


// This function will create the appropriate data in the
// volatile global and return a pointer to it.

BOOL ASHost::CMGetCursorTagInfo(LPCSTR szTagName)
{
    HDC hdc = NULL;
    HDC hdcScratch = NULL;
    HBITMAP hBmpOld = NULL;
    HBITMAP hBitmap = NULL;
    PCURTAGINFO pctiRet = NULL;
    RECT    rect;
    HFONT hOldFont;
    BOOL    rc = FALSE;

    DebugEntry(ASHost::CMGetCursorTagInfo);

    hdcScratch = CreateCompatibleDC(NULL);
    if (!hdcScratch)
    {
        ERROR_OUT(("CMGetCursorTagInfo: couldn't get scratch DC"));
        DC_QUIT;
    }

    hBitmap = CreateDIBitmap(hdcScratch,
                &(g_cti.bmInfo.bmiHeader),
                0, // don't initialize bits
                NULL, // don't initialize bits
                &(g_cti.bmInfo),
                DIB_RGB_COLORS );

    if (!hBitmap)
    {
        ERROR_OUT(("CMGetCursorTagInfo: failed to create bitmap"));
        DC_QUIT;
    }

    hBmpOld = SelectBitmap(hdcScratch, hBitmap);
    hOldFont = SelectFont(hdcScratch, m_pShare->m_cmCursorTagFont);

    // Create the tag background...

    PatBlt ( hdcScratch, 0, 0, 32, 32, BLACKNESS );
    PatBlt ( hdcScratch, TAGXOFF, TAGYOFF, TAGXSIZ, TAGYSIZ, WHITENESS );

    // Now see how many characters of the name or abbreviation
    // we can fit into the tag

    int cCharsFit;
    SIZE size;
    LPSTR p;

    // First assume the whole thing fits
    cCharsFit = lstrlen(szTagName);

    // Now try to find out how big a part actually fits

    rect.left = rect.top = rect.right = rect.bottom = 0;

    for ( p = CharNext(szTagName); ; p = CharNext(p) )
    {
        if ( DrawText(hdcScratch, szTagName, (int)(p - szTagName), &rect,
                    DT_CALCRECT | DT_SINGLELINE | DT_NOPREFIX ) )
        {
            if ( rect.right > TAGXSIZ )
            {
                // This number of characters no longer fits into the
                // tag. Take the next smaller number and leave the loop
                cCharsFit = (int)(CharPrev(szTagName, p) - szTagName);
                break;
            }
        }

        if ( NULL == *p )
            break;
    }

    TRACE_OUT(("Tag: [%s], showing %d chars", szTagName, cCharsFit ));

    // Now draw the text...
    // DrawText doesn't return a documented error...

    rect.top = TAGYOFF;
    rect.left = TAGXOFF;
    rect.bottom = TAGYOFF + TAGYSIZ;
    rect.right = TAGXOFF + TAGXSIZ;

    DrawText ( hdcScratch, szTagName, cCharsFit, &rect,
            DT_CENTER | DT_SINGLELINE | DT_NOPREFIX );

    SelectFont (hdcScratch, hOldFont);

    // Now get the bitmap bits into the global volatile data area
    // Make sure the number of scan lines requested is returned

    if ( 32 != GetDIBits ( hdcScratch,
                hBitmap,
                0,
                32,
                g_cti.aXorBits,
                &(g_cti.bmInfo),
                DIB_RGB_COLORS ))
    {
        ERROR_OUT(("CMGetCursorTagInfo: GetDIBits failed"));
        DC_QUIT;
    }

    // Reset the foreground and background colors to black
    // and white respectively no matter what GetDIBits has filled in.
    // REVIEW: how do we get GetDIBits to fill in the expected (B&W) color
    // table?

    g_cti.bmInfo.bmiColors[0].rgbBlue = 0x0;
    g_cti.bmInfo.bmiColors[0].rgbGreen = 0x0;
    g_cti.bmInfo.bmiColors[0].rgbRed = 0x0;
    g_cti.bmInfo.bmiColors[0].rgbReserved = 0;

    g_cti.rgbBackground[0].rgbBlue = 0xff;
    g_cti.rgbBackground[0].rgbGreen = 0xff;
    g_cti.rgbBackground[0].rgbRed = 0xff;
    g_cti.rgbBackground[0].rgbReserved = 0;

    // Finally, we are happy
    rc = TRUE;

DC_EXIT_POINT:

    // Perform necessary cleanup
    if (hBmpOld)
        SelectBitmap ( hdcScratch, hBmpOld);

    if ( hBitmap )
        DeleteBitmap ( hBitmap );

    if ( hdcScratch )
        DeleteDC ( hdcScratch );

    DebugExitBOOL(ASHost::CMGetCursorTagInfo, rc);
    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\cmg.cpp ===
#include "precomp.h"

//
// CMG.C
// Call Management
//
// Copyright(c) Microsoft 1997-
//


#define MLZ_FILE_ZONE  ZONE_NET

GUID g_csguidMeetingSettings = GUID_MTGSETTINGS;

//
// CMP_Init()                                              
//
BOOL CMP_Init(BOOL * pfCleanup)
{
    BOOL                rc = FALSE;
    GCCError            gcc_rc;

    DebugEntry(CMP_Init);

    UT_Lock(UTLOCK_T120);

    if (g_putCMG || g_pcmPrimary)
    {
        *pfCleanup = FALSE;
        ERROR_OUT(("Can't start CMP primary task; already running"));
        DC_QUIT;
    }
    else
    {
        *pfCleanup = TRUE;
    }

    //
    // Register CMG task
    //
    if (!UT_InitTask(UTTASK_CMG, &g_putCMG))
    {
        ERROR_OUT(("Failed to start CMG task"));
        DC_QUIT;
    }

    //
    // Allocate a Call Manager handle, ref counted
    //
    g_pcmPrimary = (PCM_PRIMARY)UT_MallocRefCount(sizeof(CM_PRIMARY), TRUE);
    if (!g_pcmPrimary)
    {
        ERROR_OUT(("CMP_Init failed to allocate CM_PRIMARY data"));
        DC_QUIT;
    }

    SET_STAMP(g_pcmPrimary, CMPRIMARY);
    g_pcmPrimary->putTask       = g_putCMG;

    //
    // Init the people list
    //
    COM_BasedListInit(&(g_pcmPrimary->people));

    //
    // Get the local user name
    //
    COM_GetSiteName(g_pcmPrimary->localName, sizeof(g_pcmPrimary->localName));

    //
    // Register event and exit procedures
    //
    UT_RegisterExit(g_putCMG, CMPExitProc, g_pcmPrimary);
    g_pcmPrimary->exitProcRegistered = TRUE;

    //                                                                    
    // - GCCCreateSap, which is the interesting one.                       
    //
    gcc_rc = GCC_CreateAppSap((IGCCAppSap **) &(g_pcmPrimary->pIAppSap),
                              g_pcmPrimary,
                              CMPGCCCallback);
    if (GCC_NO_ERROR != gcc_rc || NULL == g_pcmPrimary->pIAppSap)
    {
        ERROR_OUT(( "Error from GCCCreateSap"));
        DC_QUIT;
    }

    rc = TRUE;

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitBOOL(CMP_Init, rc);
    return(rc);
}



//
// CMP_Term()                                               
//
void CMP_Term(void)
{
    DebugEntry(CMP_Term);

    UT_Lock(UTLOCK_T120);

    if (g_pcmPrimary)
    {
        ValidateCMP(g_pcmPrimary);

        ValidateUTClient(g_putCMG);

        //
        // Unregister our GCC SAP.                                             
        //
        if (NULL != g_pcmPrimary->pIAppSap)
        {
            g_pcmPrimary->pIAppSap->ReleaseInterface();
            g_pcmPrimary->pIAppSap = NULL;
        }

        //
        // Call the exit procedure to do all our termination                   
        //
        CMPExitProc(g_pcmPrimary);
    }

    UT_TermTask(&g_putCMG);

    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(CMP_Term);
}




//
// CMPExitProc()                                     
//
void CALLBACK CMPExitProc(LPVOID data)
{
    PCM_PRIMARY pcmPrimary = (PCM_PRIMARY)data;

    DebugEntry(CMPExitProc);

    UT_Lock(UTLOCK_T120);

    //
    // Check parameters                                                    
    //
    ValidateCMP(pcmPrimary);
    ASSERT(pcmPrimary == g_pcmPrimary);

    //
    // Deregister the exit procedure.
    //
    if (pcmPrimary->exitProcRegistered)
    {
        UT_DeregisterExit(pcmPrimary->putTask,
                          CMPExitProc,
                          pcmPrimary);
        pcmPrimary->exitProcRegistered = FALSE;
    }

    CMPCallEnded(pcmPrimary);

    //
    // Free the CMP data
    //
    UT_FreeRefCount((void**)&g_pcmPrimary, TRUE);

    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(CMPExitProc);

}

//
// CMPCallEnded()                                            
//
void CMPCallEnded
(
    PCM_PRIMARY pcmPrimary
)
{
    PCM_PERSON  pPerson;
    PCM_PERSON  pPersonT;
    int         cmTask;

    DebugEntry(CMPCallEnded);

    ValidateCMP(pcmPrimary);

    if (!(pcmPrimary->currentCall))
    {
        TRACE_OUT(("CMCallEnded: not in call"));
        DC_QUIT;
    }

    //
    // Issue CMS_PERSON_LEFT events for all people still in the call.  
    // Do this back to front.
    //
    pPerson = (PCM_PERSON)COM_BasedListLast(&(pcmPrimary->people), FIELD_OFFSET(CM_PERSON, chain));
    while (pPerson != NULL)
    {
        ASSERT(pcmPrimary->peopleCount > 0);

        TRACE_OUT(("Person [%d] LEAVING call", pPerson->netID));

        //
        // Get the previous person
        //
        pPersonT = (PCM_PERSON)COM_BasedListPrev(&(pcmPrimary->people), pPerson,
                                     FIELD_OFFSET(CM_PERSON, chain));

        //
        // Remove this guy from the list
        //
        COM_BasedListRemove(&(pPerson->chain));
        pcmPrimary->peopleCount--;

        //
        // Notify people of his leaving
        //
        CMPBroadcast(pcmPrimary,
                    CMS_PERSON_LEFT,
                    pcmPrimary->peopleCount,
                    pPerson->netID);

        //
        // Free the memory for the item
        //
        delete pPerson;

        //
        // Move the previous person in the list
        pPerson = pPersonT;
    }

    //
    // Inform all registered secondary tasks of call ending (call          
    // CMbroadcast() with CMS_END_CALL)                                    
    //
    CMPBroadcast(pcmPrimary,
                CMS_END_CALL,
                0,
                pcmPrimary->callID);

    //
    // Reset the current call vars
    //
    pcmPrimary->currentCall  = FALSE;
    pcmPrimary->fTopProvider    = FALSE;
    pcmPrimary->callID          = 0;
    pcmPrimary->gccUserID       = 0;
    pcmPrimary->gccTopProviderID    = 0;

    //
    // Discard outstanding channel/token requests
    //
    for (cmTask = CMTASK_FIRST; cmTask < CMTASK_MAX; cmTask++)
    {
        if (pcmPrimary->tasks[cmTask])
        {
            pcmPrimary->tasks[cmTask]->channelKey = 0;
            pcmPrimary->tasks[cmTask]->tokenKey = 0;
        }
    }

DC_EXIT_POINT:
    //
    // Nobody should be in the call anymore
    //
    ASSERT(pcmPrimary->peopleCount == 0);

    DebugExitVOID(CMCallEnded);
}




//                                                                         
// CMPGCCCallback                                            
//
void CALLBACK CMPGCCCallback(GCCAppSapMsg * gccMessage)
{
    PCM_PRIMARY                         pcmPrimary;
    GCCConferenceID                     confID;
    GCCApplicationRoster FAR * FAR *    pRosterList;
    UINT                                roster;
    LPOSTR                              pOctetString;
    GCCObjectKey FAR *                  pObjectKey;
    UINT                              checkLen;

    DebugEntry(CMPGCCCallback);

    UT_Lock(UTLOCK_T120);

    //
    // The userDefined parameter is the Primary's PCM_CLIENT.               
    //
    pcmPrimary = (PCM_PRIMARY)gccMessage->pAppData;

    if (pcmPrimary != g_pcmPrimary)
    {
        ASSERT(NULL == g_pcmPrimary);
        return;
    }

    ValidateCMP(pcmPrimary);

    switch (gccMessage->eMsgType)
    {
        case GCC_PERMIT_TO_ENROLL_INDICATION:
        {
            //
            // This indicates a conference has started:                    
            //
            CMPProcessPermitToEnroll(pcmPrimary,
                        &gccMessage->AppPermissionToEnrollInd);
        }
        break;

        case GCC_ENROLL_CONFIRM:
        {
            //
            // This contains the result of a GCCApplicationEnrollRequest.  
            //
            CMPProcessEnrollConfirm(pcmPrimary,
                        &gccMessage->AppEnrollConfirm);
        }
        break;

        case GCC_REGISTER_CHANNEL_CONFIRM:
        {
            //
            // This contains the result of a GCCRegisterChannelRequest.    
            //
            CMPProcessRegistryConfirm(
                        pcmPrimary,
                        gccMessage->eMsgType,
                        &gccMessage->RegistryConfirm);
        }
        break;

        case GCC_ASSIGN_TOKEN_CONFIRM:
        {
            //
            // This contains the result of a GCCRegistryAssignTokenRequest.
            //
            CMPProcessRegistryConfirm(
                        pcmPrimary,
                        gccMessage->eMsgType,
                        &gccMessage->RegistryConfirm);
        }
        break;

        case GCC_APP_ROSTER_REPORT_INDICATION:
        {
            //
            // This indicates that the application roster has changed.     
            //
            confID = gccMessage->AppRosterReportInd.nConfID;
            pRosterList = gccMessage->AppRosterReportInd.apAppRosters;

            for (roster = 0;
                 roster < gccMessage->AppRosterReportInd.cRosters;
                 roster++)
            {

                //
                // Check this app roster to see if it relates to the       
                // Groupware session (the first check is because we always 
                // use a NON_STANDARD application key).                    
                //
                pObjectKey = &(pRosterList[roster]->
                               session_key.application_protocol_key);

                //
                // We only ever use a non standard key.                    
                //
                if (pObjectKey->key_type != GCC_H221_NONSTANDARD_KEY)
                {
                    TRACE_OUT(("Standard key, so not a roster we are interested in..."));
                    continue;
                }

                pOctetString = &pObjectKey->h221_non_standard_id;

                //
                // Now check the octet string.  It should be the same      
                // length as our hardcoded GROUPWARE- string (including    
                // NULL term) and should match byte for byte:              
                //
                checkLen = sizeof(GROUPWARE_GCC_APPLICATION_KEY);
                if ((pOctetString->length != checkLen)
                    ||
                    (memcmp(pOctetString->value,
                            GROUPWARE_GCC_APPLICATION_KEY,
                            checkLen) != 0))
                {
                    //
                    // This roster is not for our session - go to the next 
                    // one.                                                
                    //
                    TRACE_OUT(("Roster not for Groupware session - ignore"));
                    continue;
                }

                //
                // Process the application roster.                         
                //
                CMPProcessAppRoster(pcmPrimary,
                                       confID,
                                       pRosterList[roster]);
            }
        }
        break;
    }

    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(CMPGCCCallback);
}


//
//                                                                        
// CMPBuildGCCRegistryKey(...)                                              
//
//
void CMPBuildGCCRegistryKey
(
    UINT                    dcgKeyNum,
    GCCRegistryKey FAR *    pGCCKey,
    LPSTR                   dcgKeyStr
)
{
    DebugEntry(CMPBuildGCCRegistryKey);

    //
    // Build up a string of the form "Groupware-XX" where XX is a string   
    // representation (in decimal) of the <dcgKey> parameter passed in.    
    //
    memcpy(dcgKeyStr, GROUPWARE_GCC_APPLICATION_KEY, sizeof(GROUPWARE_GCC_APPLICATION_KEY)-1);

    wsprintf(dcgKeyStr+sizeof(GROUPWARE_GCC_APPLICATION_KEY)-1, "%d",
        dcgKeyNum);

    //
    // Now build the GCCRegistryKey.  This involves putting a pointer to   
    // our static <dcgKeyStr> deep inside the GCC structure.  We also store
    // the length, which is lstrlen+1, because we want to include the    
    // NULLTERM explicitly (since GCC treats the octet_string as an        
    // arbitrary array of bytes).                                          
    //

    pGCCKey->session_key.application_protocol_key.
        key_type = GCC_H221_NONSTANDARD_KEY;

    pGCCKey->session_key.application_protocol_key.h221_non_standard_id.
        length = sizeof(GROUPWARE_GCC_APPLICATION_KEY);

    pGCCKey->session_key.application_protocol_key.h221_non_standard_id.
        value = (LPBYTE) GROUPWARE_GCC_APPLICATION_KEY;

    pGCCKey->session_key.session_id          = 0;

    pGCCKey->resource_id.length =
              (sizeof(GROUPWARE_GCC_APPLICATION_KEY) +
              lstrlen(&dcgKeyStr[sizeof(GROUPWARE_GCC_APPLICATION_KEY)-1]));

    pGCCKey->resource_id.value               = (LPBYTE) dcgKeyStr;


    DebugExitVOID(CMPBuildGCCRegistryKey);
}



//                                                                        
// CMPProcessPermitToEnroll(...)                                            
//
void CMPProcessPermitToEnroll
(
    PCM_PRIMARY                         pcmPrimary,
    GCCAppPermissionToEnrollInd *       pMsg
)
{
    DebugEntry(CMPProcessPermitToEnroll);

    ValidateCMP(pcmPrimary);

    //
    // We will send CMS_PERSON_JOINED events when we receive a         
    // GCC_APP_ROSTER_REPORT_INDICATION.                                   
    //

    if (pMsg->fPermissionGranted)
    {
        // CALL STARTED

        //
        // If we haven't had a NCS yet then we store the conference ID.    
        // Otherwise ignore it.                                            
        //
        ASSERT(!pcmPrimary->currentCall);

        //
        // Initially, we do not consider ourselves to be in the call - we will 
        // add an entry when we get the ENROLL_CONFIRM:                        
        //
        ASSERT(pcmPrimary->peopleCount == 0);

        pcmPrimary->currentCall = TRUE;
        pcmPrimary->callID      = pMsg->nConfID;
        pcmPrimary->fTopProvider =
            pcmPrimary->pIAppSap->IsThisNodeTopProvider(pMsg->nConfID);

        //
        // Our person data:                                                    
        //
        COM_GetSiteName(pcmPrimary->localName, sizeof(pcmPrimary->localName));

        //
        // Tell GCC whether we're interested:                              
        //
        if (!CMPGCCEnroll(pcmPrimary, pMsg->nConfID, TRUE))
        {
            //
            // We are only interested in an error if it is a Groupware conf.   
            // All we can really do is pretend the conference has ended due
            // to a network error.                                         
            //
            WARNING_OUT(("Error from CMPGCCEnroll"));
            CMPCallEnded(pcmPrimary);
        }

        //
        // The reply will arrive on a GCC_ENROLL_CONFIRM event.            
        //
    }
    else
    {
        // CALL ENDED
        if (g_pcmPrimary->currentCall)
        {
            //
            // Inform Primary task and all secondary tasks that the call has ended 
            //

            CMPCallEnded(g_pcmPrimary);

            //
            // Un-enroll from the GCC Application Roster.                          
            //
            if (g_pcmPrimary->bGCCEnrolled)
            {
                CMPGCCEnroll(g_pcmPrimary, g_pcmPrimary->callID, FALSE);
                g_pcmPrimary->bGCCEnrolled = FALSE;
            }
        }
    }

    DebugExitVOID(CMPProcessPermitToEnroll);
}



//
//                                                                        
// CMPProcessEnrollConfirm(...)                                             
//
//
void CMPProcessEnrollConfirm
(
    PCM_PRIMARY             pcmPrimary,
    GCCAppEnrollConfirm *   pMsg
)
{
    DebugEntry(CMPProcessEnrollConfirm);

    ValidateCMP(pcmPrimary);

    ASSERT(pcmPrimary->currentCall);
    ASSERT(pMsg->nConfID == pcmPrimary->callID);

    //
    // This event contains the GCC node ID (i.e.  the MCS user ID of the   
    // GCC node controller at this node).  Store it for later reference    
    // against the roster report:                                          
    //
    TRACE_OUT(( "GCC user_id: %u", pMsg->nidMyself));

    pcmPrimary->gccUserID           = pMsg->nidMyself;
    pcmPrimary->gccTopProviderID    = pcmPrimary->pIAppSap->GetTopProvider(pcmPrimary->callID);
    ASSERT(pcmPrimary->gccTopProviderID);

    if (pMsg->nResult != GCC_RESULT_SUCCESSFUL)
    {
        WARNING_OUT(( "Attempt to enroll failed (reason: %u", pMsg->nResult));
        //
        // All we can really do is pretend the conference has ended due to 
        // a network error.                                                
        //
        CMPCallEnded(pcmPrimary);
    }

    DebugExitVOID(CMProcessEnrollConfirm);
}



//                                                                        
// CMPProcessRegistryConfirm(...)                                           
//
void CMPProcessRegistryConfirm
(
    PCM_PRIMARY         pcmPrimary,
    GCCMessageType      messageType,
    GCCRegistryConfirm *pConfirm
)
{
    UINT                event =     0;
    BOOL                succeeded;
    LPSTR               pGCCKeyStr;    // extracted from the GCC registry key  
    UINT                dcgKeyNum;     // the value originally passed in as key
    UINT                itemID;        // can be channel or token ID
    int                 cmTask;
    PUT_CLIENT          secondaryHandle = NULL;

    DebugEntry(CMPProcessRegistryConfirm);

    ValidateCMP(pcmPrimary);

    //
    // Check this is for the Groupware conference:                         
    //
    if (!pcmPrimary->currentCall ||
        (pConfirm->nConfID != pcmPrimary->callID))
    {
        WARNING_OUT(( "Got REGISTRY_XXX_CONFIRM for unknown conference %lu",
            pConfirm->nConfID));
        DC_QUIT;
    }

    //
    // Embedded deep down inside the message from GCC is a pointer to an   
    // octet string which is of the form "Groupware-XX", where XX is a     
    // string representation of the numeric key the original Call Manager  
    // secondary used when registering the item.  Extract it now:          
    //
    pGCCKeyStr = (LPSTR)pConfirm->pRegKey->resource_id.value;

    dcgKeyNum = DecimalStringToUINT(&pGCCKeyStr[sizeof(GROUPWARE_GCC_APPLICATION_KEY)-1]);

    if (dcgKeyNum == 0)
    {
        WARNING_OUT(( "Received ASSIGN/REGISTER_CONFIRM with unknown key: %s",
            pGCCKeyStr));
        DC_QUIT;
    }

    TRACE_OUT(( "Conf ID %u, DCG Key %u, result %u",
        pConfirm->nConfID, dcgKeyNum, pConfirm->nResult));

    //
    // This is either a REGISTER_CHANNEL_CONFIRM or a ASSIGN_TOKEN_CONFIRM.
    // Check, and set up the relevant pointers:                            
    //
    switch (messageType)
    {
        case GCC_REGISTER_CHANNEL_CONFIRM:
        {
            event = CMS_CHANNEL_REGISTER_CONFIRM;
            itemID = pConfirm->pRegItem->channel_id;

            // Look for task that registered this channel
            for (cmTask = CMTASK_FIRST; cmTask < CMTASK_MAX; cmTask++)
            {
                if (pcmPrimary->tasks[cmTask] &&
                    (pcmPrimary->tasks[cmTask]->channelKey == dcgKeyNum))
                {
                    pcmPrimary->tasks[cmTask]->channelKey = 0;
                    secondaryHandle = pcmPrimary->tasks[cmTask]->putTask;
                }
            }
        }
        break;

        case GCC_ASSIGN_TOKEN_CONFIRM:
        {
            event = CMS_TOKEN_ASSIGN_CONFIRM;
            itemID = pConfirm->pRegItem->token_id;

            // Look for task that assigned this token
            for (cmTask = CMTASK_FIRST; cmTask < CMTASK_MAX; cmTask++)
            {
                if (pcmPrimary->tasks[cmTask] &&
                    (pcmPrimary->tasks[cmTask]->tokenKey == dcgKeyNum))
                {
                    pcmPrimary->tasks[cmTask]->tokenKey = 0;
                    secondaryHandle = pcmPrimary->tasks[cmTask]->putTask;
                }
            }
        }
        break;

        default:
        {
            ERROR_OUT(( "Unexpected registry event %u", messageType));
            DC_QUIT;
        }
    }

    switch (pConfirm->nResult)
    {
        case GCC_RESULT_SUCCESSFUL:
        {
            //
            // We were the first to register an item against this key.     
            //
            TRACE_OUT(("We were first to register using key %u (itemID: %u)",
                     dcgKeyNum, itemID));
            succeeded = TRUE;
        }
        break;

        case GCC_RESULT_ENTRY_ALREADY_EXISTS:
        {
            //
            // Someone beat us to it: they have registered a channel       
            // against the key we specified.  This value is in the GCC     
            // message:                                                    
            //
            TRACE_OUT(("Another node registered using key %u (itemID: %u)",
                      dcgKeyNum, itemID));
            succeeded = TRUE;
        }
        break;

        default:
        {
            ERROR_OUT(("Error %#hx registering/assigning item against key %u",
                     pConfirm->nResult, dcgKeyNum));
            succeeded = FALSE;
        }
        break;
    }

    //
    // Tell the secondary about the result.                                
    //
    if (secondaryHandle)
    {
        UT_PostEvent(pcmPrimary->putTask,
                 secondaryHandle,
                 0,
                 event,
                 succeeded,
                 MAKELONG(itemID, dcgKeyNum));
    }

DC_EXIT_POINT:
    DebugExitVOID(CMProcessRegistryConfirm);
}



//                                                                        
// CMPProcessAppRoster(...)                                               
//
void CMPProcessAppRoster
(
    PCM_PRIMARY             pcmPrimary,
    GCCConferenceID         confID,
    GCCApplicationRoster*   pAppRoster
)
{
    UINT                    newList;
    UserID                  oldNode;
    UserID                  newNode;
    PCM_PERSON              pPerson;
    PCM_PERSON              pPersonT;
    BOOL                    found;
    int                     task;
    BOOL                    notInOldRoster = TRUE;
    BOOL                    inNewRoster    = FALSE;

    DebugEntry(CMPProcessAppRoster);

    ValidateCMP(pcmPrimary);

    //
    // If we are not in a call ignore this.                                
    //
    if (!pcmPrimary->currentCall ||
        (confID != pcmPrimary->callID))
    {
        WARNING_OUT(("Report not for active Groupware conference - ignore"));
        DC_QUIT;
    }

    //
    // At this point, pAppRoster points to the bit of the roster which     
    // relates to Groupware.  Trace out some info:                         
    //
    TRACE_OUT(( "Number of records %u;", pAppRoster->number_of_records));
    TRACE_OUT(( "Nodes added: %s, removed: %s",
        (pAppRoster->nodes_were_added   ? "YES" : "NO"),
        (pAppRoster->nodes_were_removed ? "YES" : "NO")));

    //
    // We store the GCC user IDs in shared memory as TSHR_PERSONIDs.
    // Compare this list of people we know to be in the call, and 
    //      * Remove people no longer around
    //      * See if we are new to the roster
    //      * Add people who are new
    //

    pPerson = (PCM_PERSON)COM_BasedListFirst(&(pcmPrimary->people), FIELD_OFFSET(CM_PERSON, chain));

    while (pPerson != NULL)
    {
        ASSERT(pcmPrimary->peopleCount > 0);

        oldNode = (UserID)pPerson->netID;

        //
        // Get the next guy in the list in case we remove this one.
        //
        pPersonT = (PCM_PERSON)COM_BasedListNext(&(pcmPrimary->people), pPerson,
                                     FIELD_OFFSET(CM_PERSON, chain));

        //
        // Check to see if our node is currently in the roster             
        // 
        if (oldNode == pcmPrimary->gccUserID)
        {
            TRACE_OUT(( "We are currently in the app roster"));
            notInOldRoster = FALSE;
        }

        //
        // ...check if they're in the new list...                          
        //
        found = FALSE;
        for (newList = 0; newList < pAppRoster->number_of_records; newList++)
        {
            if (oldNode == pAppRoster->application_record_list[newList]->node_id)
            {
                found = TRUE;
                break;
            }
        }

        if (!found)
        {
            //
            // This node is no longer present, so remove him.
            //
            TRACE_OUT(("Person %u left", oldNode));

            COM_BasedListRemove(&(pPerson->chain));
            pcmPrimary->peopleCount--;

            CMPBroadcast(pcmPrimary,
                        CMS_PERSON_LEFT,
                        pcmPrimary->peopleCount,
                        oldNode);

            //
            // Free the memory for the person item
            //
            delete pPerson;
        }

        pPerson = pPersonT;
    }

    //
    // Now see if we are new to the roster
    //
    for (newList = 0; newList < pAppRoster->number_of_records; newList++)
    {
        if (pAppRoster->application_record_list[newList]->node_id ==
                                                   pcmPrimary->gccUserID)
        {
            TRACE_OUT(( "We are in the new app roster"));
            inNewRoster = TRUE;
            break;
        }
    }

    if (notInOldRoster && inNewRoster)
    {
        //
        // We are new to the roster so we can now do all the processing we 
        // were previously doing in the enroll confirm handler.  GCC spec  
        // requires that we do not do this until we get the roster         
        // notification back.                                              
        //                                                                
        // Flag we are enrolled and start registering channels etc.        
        //
        pcmPrimary->bGCCEnrolled = TRUE;

        //
        // Post a CMS_NEW_CALL events to all secondary tasks               
        //
        TRACE_OUT(( "Broadcasting CMS_NEW_CALL with call handle 0x%08lx",
                                        pcmPrimary->callID));

        //
        // If we are not the caller then delay the broadcast a little      
        //
        CMPBroadcast(pcmPrimary, CMS_NEW_CALL,
            pcmPrimary->fTopProvider, pcmPrimary->callID);

#ifdef _DEBUG
        //
        // Process any outstanding channel register and assign token       
        // requests.                                                       
        //
        for (task = CMTASK_FIRST; task < CMTASK_MAX; task++)
        {
            if (pcmPrimary->tasks[task] != NULL)
            {
                ASSERT(pcmPrimary->tasks[task]->channelKey == 0);
                ASSERT(pcmPrimary->tasks[task]->tokenKey == 0);
            }
        }
#endif // _DEBUG
    }

    //
    // If we are not yet enrolled in the conference then do not start      
    // sending PERSON_JOINED notifications.                                
    //
    if (!pcmPrimary->bGCCEnrolled)
    {
        DC_QUIT;
    }

    //
    // Add the new people (this will include us).  At this point, we know 
    // that everyone in the people list is currently in the roster, since
    // we would have removed 'em above.
    //
    // we need to walk the existing list over and over.
    // But at least we can skip the people we add.  So we save the current
    // front of the list.
    //
    pPersonT = (PCM_PERSON)COM_BasedListFirst(&(pcmPrimary->people), FIELD_OFFSET(CM_PERSON, chain));

    for (newList = 0; newList < pAppRoster->number_of_records; newList++)
    {
        newNode = pAppRoster->application_record_list[newList]->node_id;

        found = FALSE;

        pPerson  = pPersonT;

        while (pPerson != NULL)
        {
            if (newNode == pPerson->netID)
            {
                //
                // This person already existed - don't need to do anything 
                //
                found = TRUE;
                break;          // out of inner for loop                   
            }

            pPerson = (PCM_PERSON)COM_BasedListNext(&(pcmPrimary->people), pPerson,
                FIELD_OFFSET(CM_PERSON, chain));
        }

        if (!found)
        {
            //
            // This dude is new; add him to our people list.
            //
            TRACE_OUT(("Person with GCC user_id %u joined", newNode));

            pPerson = new CM_PERSON;
            if (!pPerson)
            {
                //
                // Uh oh; can't add him.
                //
                ERROR_OUT(("Can't add person GCC user_id %u; out of memory",
                    newNode));
                break;
            }

            ZeroMemory(pPerson, sizeof(*pPerson));
            pPerson->netID = newNode;

            //
            // LONCHANC: We should collapse all these events into a single one
            // that summarize all added and removed nodes,
            // instead of posting the events one by one.
            //

            //
            // Stick him in at the beginning.  At least that way we don't
            // have to look at his record anymore.
            //
            COM_BasedListInsertAfter(&(pcmPrimary->people), &pPerson->chain);
            pcmPrimary->peopleCount++;

            CMPBroadcast(pcmPrimary, 
                CMS_PERSON_JOINED,
                pcmPrimary->peopleCount,
                newNode);
        }
    }

    TRACE_OUT(( "Num people now in call %u", pcmPrimary->peopleCount));

DC_EXIT_POINT:
    DebugExitVOID(CMPProcessAppRoster);
}



//
// CMPBroadcast()                                            
//
void CMPBroadcast
(
    PCM_PRIMARY pcmPrimary,
    UINT        event,
    UINT        param1,
    UINT_PTR        param2
)
{
    int         task;

    DebugEntry(CMPBroadcast);

    ValidateCMP(pcmPrimary);

    //
    // for every secondary task                                            
    //
    for (task = CMTASK_FIRST; task < CMTASK_MAX; task++)
    {
        if (pcmPrimary->tasks[task] != NULL)
        {
            UT_PostEvent(pcmPrimary->putTask,
                         pcmPrimary->tasks[task]->putTask,
                         NO_DELAY,
                         event,
                         param1,
                         param2);

        }
    }

    DebugExitVOID(CMPBroadcast);
}


//                                                                        
// CMPGCCEnroll(...)                                                        
//                                                                        
BOOL CMPGCCEnroll
(
    PCM_PRIMARY         pcmPrimary,
    GCCConferenceID     conferenceID,
    BOOL                fEnroll
)
{
    GCCError                    rcGCC =         GCC_NO_ERROR;
    GCCSessionKey               gccSessionKey;
    GCCObjectKey FAR *          pGCCObjectKey;
    BOOL                        succeeded = TRUE;
    GCCNonCollapsingCapability  caps;
    GCCNonCollapsingCapability* pCaps;
    OSTR                        octetString;
    GCCEnrollRequest            er;
    GCCRequestTag               nReqTag;

    DebugEntry(CMPGCCEnroll);

    ValidateCMP(pcmPrimary);

    //
    // Do some error checking.                                             
    //
    if (fEnroll && pcmPrimary->bGCCEnrolled)
    {
        WARNING_OUT(("Already enrolled"));
        DC_QUIT;
    }

    TRACE_OUT(("CMGCCEnroll for CM_hnd 0x%08x, confID 0x%08x, in/out %d",
                           pcmPrimary, conferenceID, fEnroll));

    //
    // Set up the session key which identifies us uniquely in the GCC      
    // AppRoster.  We use a non-standard key (because we're not part of the
    // T.120 standards series)                                             
    //                                                                    
    // Octet strings aren't null terminated, but we want ours to include   
    // the NULL at the end of the C string, so specify lstrlen+1 for the 
    // length.                                                             
    //
    pGCCObjectKey = &(gccSessionKey.application_protocol_key);

    pGCCObjectKey->key_type = GCC_H221_NONSTANDARD_KEY;

    pGCCObjectKey->h221_non_standard_id.value =
        (LPBYTE) GROUPWARE_GCC_APPLICATION_KEY;
    pGCCObjectKey->h221_non_standard_id.length =
                       sizeof(GROUPWARE_GCC_APPLICATION_KEY);

    gccSessionKey.session_id = 0;

    //
    // Try to enroll/unenroll with GCC.  This may fail because we have not 
    // yet received a GCC_PERMIT_TO_ENROLL_INDICATION.                     
    //
    TRACE_OUT(("Enrolling local site '%s'", pcmPrimary->localName));

    //
    // Create the non-collapsing capabilites list to pass onto GCC.        
    //
    octetString.length = lstrlen(pcmPrimary->localName) + 1;
    octetString.value = (LPBYTE) pcmPrimary->localName;
    caps.application_data = &octetString;
    caps.capability_id.capability_id_type = GCC_STANDARD_CAPABILITY;
    caps.capability_id.standard_capability = 0;
    pCaps = &caps;

    //
    // Fill in the enroll request structure
    //
    ZeroMemory(&er, sizeof(er));
    er.pSessionKey = &gccSessionKey;
    // er.fEnrollActively = FALSE;
    // er.nUserID = 0; // no user ID
    // er.fConductingCapable = FALSE;
    er.nStartupChannelType = MCS_STATIC_CHANNEL;
    er.cNonCollapsedCaps = 1;
    er.apNonCollapsedCaps = &pCaps;
    // er.cCollapsedCaps = 0;
    // er.apCollapsedCaps = NULL;
    er.fEnroll = fEnroll;

    rcGCC = pcmPrimary->pIAppSap->AppEnroll(
                                   conferenceID,
                                   &er,
                                   &nReqTag);
    if (GCC_NO_ERROR != rcGCC)
    {
        //
        // Leave the decision about any error processing to the caller.    
        //
        TRACE_OUT(("Error 0x%08x from GCCApplicationEnrollRequest conf ID %lu enroll=%s",
              rcGCC, conferenceID, fEnroll ? "YES": "NO"));
        succeeded = FALSE;
    }
    else
    {
        //
        // Whether we have asked to enroll or un-enroll, we act as if we   
        // are no longer enrolled at once.  We are only really enrolled    
        // when we receive an enroll confirm event.                        
        //
        pcmPrimary->bGCCEnrolled = FALSE;
        ASSERT(succeeded);
        TRACE_OUT(( "%s with conference %d", fEnroll ? 
                         "Enroll Outstanding" : "Unenrolled",
               conferenceID));
    }


DC_EXIT_POINT:
    DebugExitBOOL(CMPGCCEnroll, succeeded);
    return(succeeded);
}



//
// CMS_Register()                                           
//
BOOL CMS_Register
(
    PUT_CLIENT      putTask,
    CMTASK          taskType,
    PCM_CLIENT*     ppcmClient
)
{
    BOOL            fRegistered = FALSE;
    PCM_CLIENT      pcmClient = NULL;

    DebugEntry(CMS_Register);

    UT_Lock(UTLOCK_T120);

    if (!g_pcmPrimary)
    {
        ERROR_OUT(("CMS_Register failed; primary doesn't exist"));
        DC_QUIT;
    }

    ValidateUTClient(putTask);

    ASSERT(taskType >= CMTASK_FIRST);
    ASSERT(taskType < CMTASK_MAX);

    *ppcmClient = NULL;

    //
    // Is this task already present?  If so, share it
    //
    if (g_pcmPrimary->tasks[taskType] != NULL)
    {
        TRACE_OUT(("Sharing CMS task 0x%08x", g_pcmPrimary->tasks[taskType]));

        *ppcmClient = g_pcmPrimary->tasks[taskType];
        ValidateCMS(*ppcmClient);

        (*ppcmClient)->useCount++;

        // Return -- we exist.
        fRegistered = TRUE;
        DC_QUIT;
    }

    //
    // If we got here the task is not a Call Manager Secondary yet, so go  
    // ahead with the registration.                                        
    //

    //
    // Allocate memory for the client
    //
    pcmClient = new CM_CLIENT;
    if (! pcmClient)
    {
        ERROR_OUT(("Could not allocate CM handle"));
        DC_QUIT;
    }
    ZeroMemory(pcmClient, sizeof(*pcmClient));
    *ppcmClient = pcmClient;

    //
    // Fill in information                                                 
    //
    SET_STAMP(pcmClient, CMCLIENT);
    pcmClient->putTask      = putTask;
    pcmClient->taskType     = taskType;
    pcmClient->useCount     = 1;

    UT_BumpUpRefCount(g_pcmPrimary);
    g_pcmPrimary->tasks[taskType] = pcmClient;

    //
    // Register an exit procedure
    //
    UT_RegisterExit(putTask, CMSExitProc, pcmClient);
    pcmClient->exitProcRegistered = TRUE;

    fRegistered = TRUE;

DC_EXIT_POINT:

    UT_Unlock(UTLOCK_T120);

    DebugExitBOOL(CMS_Register, fRegistered);
    return(fRegistered);
}



//
// CMS_Deregister()                                         
//
void CMS_Deregister(PCM_CLIENT * ppcmClient)
{
    PCM_CLIENT      pcmClient = *ppcmClient;

    DebugEntry(CMS_Deregister);

    //
    // Check the parameters are valid                                      
    //
    UT_Lock(UTLOCK_T120);

    ValidateCMS(pcmClient);

    //
    // Only actually deregister the client if the registration count has   
    // reached zero.                                                       
    //
    pcmClient->useCount--;
    if (pcmClient->useCount != 0)
    {
        DC_QUIT;
    }

    //
    // Call the exit procedure to do our local cleanup                     
    //
    CMSExitProc(pcmClient);

DC_EXIT_POINT:
    *ppcmClient = NULL;

    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(CMS_Deregister);
}



//
// CMS_GetStatus()                                          
//
extern "C"
{
BOOL WINAPI CMS_GetStatus(PCM_STATUS pcmStatus)
{
    BOOL    inCall;

    DebugEntry(CMS_GetStatus);

    UT_Lock(UTLOCK_T120);

    ASSERT(!IsBadWritePtr(pcmStatus, sizeof(CM_STATUS)));
    ZeroMemory(pcmStatus, sizeof(CM_STATUS));

    ValidateCMP(g_pcmPrimary);

    //
    // Copy the statistics from the control block                          
    //
    lstrcpy(pcmStatus->localName, g_pcmPrimary->localName);
    pcmStatus->localHandle      = g_pcmPrimary->gccUserID;
    pcmStatus->peopleCount      = g_pcmPrimary->peopleCount;
    pcmStatus->fTopProvider     = g_pcmPrimary->fTopProvider;
    pcmStatus->topProviderID    = g_pcmPrimary->gccTopProviderID;

    //
    // Meeting settings
    //
    pcmStatus->attendeePermissions = NM_PERMIT_ALL;
    if (!pcmStatus->fTopProvider)
    {
        T120_GetUserData(g_pcmPrimary->callID, g_pcmPrimary->gccTopProviderID,
            &g_csguidMeetingSettings, (LPBYTE)&pcmStatus->attendeePermissions,
            sizeof(pcmStatus->attendeePermissions));
    }

    //
    // Fill in information about other primary                             
    //
    pcmStatus->callID    = g_pcmPrimary->callID;
    inCall = (g_pcmPrimary->currentCall != FALSE);

    UT_Unlock(UTLOCK_T120);

    DebugExitBOOL(CMS_GetStatus, inCall);
    return(inCall);
}
}


//
// CMS_ChannelRegister()                                    
//
BOOL CMS_ChannelRegister
(
    PCM_CLIENT      pcmClient,
    UINT            channelKey,
    UINT            channelID
)
{
    BOOL                fRegistered = FALSE;
    GCCRegistryKey      gccRegistryKey;
    GCCError            rcGCC;
    char                dcgKeyStr[sizeof(GROUPWARE_GCC_APPLICATION_KEY)+MAX_ITOA_LENGTH];

    DebugEntry(CMS_ChannelRegister);

    UT_Lock(UTLOCK_T120);

    //
    // Check the CMG task
    //
    ValidateUTClient(g_putCMG);

    //
    // Check the parameters are valid
    //
    ValidateCMP(g_pcmPrimary);
    ValidateCMS(pcmClient);

    //
    // If we are not in a call it is an error.                             
    //
    if (!g_pcmPrimary->currentCall)
    {
        WARNING_OUT(("CMS_ChannelRegister failed; not in call"));
        DC_QUIT;
    }
    if (!g_pcmPrimary->bGCCEnrolled)
    {
        WARNING_OUT(("CMS_ChannelRegister failed; not enrolled in call"));
        DC_QUIT;
    }

    // Make sure we don't have one pending already
    ASSERT(pcmClient->channelKey == 0);
   
    TRACE_OUT(("Channel ID %u Key %u", channelID, channelKey));

    //
    // Build a GCCRegistryKey based on our channelKey:                 
    //
    CMPBuildGCCRegistryKey(channelKey, &gccRegistryKey, dcgKeyStr);

    //
    // Now call through to GCC.  GCC will invoke our callback when it  
    // has processed the request.                                      
    //
    rcGCC = g_pcmPrimary->pIAppSap->RegisterChannel(
                                          g_pcmPrimary->callID,
                                          &gccRegistryKey,
                                          (ChannelID)channelID);
    if (rcGCC)
    {
        //
        // Tell the secondary client that the request failed.          
        //
        WARNING_OUT(( "Error %#lx from GCCRegisterChannel (key: %u)",
            rcGCC, channelKey));
    }
    else
    {
        // Remember so we can post confirm event back to proper task
        pcmClient->channelKey = channelKey;

        fRegistered = TRUE;
    }

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitBOOL(CMS_ChannelRegister, fRegistered);
    return(fRegistered);
}



//
// CMS_AssignTokenId()                                      
//
BOOL CMS_AssignTokenId
(
    PCM_CLIENT  pcmClient,
    UINT        tokenKey
)
{
    GCCRegistryKey  gccRegistryKey;
    GCCError        rcGCC;
    char            dcgKeyStr[sizeof(GROUPWARE_GCC_APPLICATION_KEY)+MAX_ITOA_LENGTH];
    BOOL            fAssigned = FALSE;

    DebugEntry(CMS_AssignTokenId);

    UT_Lock(UTLOCK_T120);

    //
    // Check the parameters are valid
    //
    ValidateCMP(g_pcmPrimary);
    ValidateCMS(pcmClient);

    ValidateUTClient(g_putCMG);

    if (!g_pcmPrimary->currentCall)
    {
        WARNING_OUT(("CMS_AssignTokenId failing; not in call"));
        DC_QUIT;
    }
    if (!g_pcmPrimary->bGCCEnrolled)
    {
        WARNING_OUT(("CMS_AssignTokenId failing; not enrolled in call"));
        DC_QUIT;
    }

    // Make sure we don't have one already
    ASSERT(pcmClient->tokenKey == 0);

    //
    // Build a GCCRegistryKey based on our tokenKey:                   
    //
    CMPBuildGCCRegistryKey(tokenKey, &gccRegistryKey, dcgKeyStr);

    //
    // Now call through to GCC.  GCC will invoke our callback when it  
    // has processed the request.                                      
    //
    rcGCC = g_pcmPrimary->pIAppSap->RegistryAssignToken(
        g_pcmPrimary->callID, &gccRegistryKey);
    if (rcGCC)
    {
        //
        // Tell the secondary client that the request failed.          
        //
        WARNING_OUT(( "Error %x from GCCAssignToken (key: %u)",
            rcGCC, tokenKey));
    }
    else
    {
        // Remember so we can post confirm to proper task
        pcmClient->tokenKey = tokenKey;
        fAssigned = TRUE;
    }

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_T120);

    DebugExitBOOL(CMS_AssignTokenId, fAssigned);
    return(fAssigned);
}


//
// CMSExitProc()                                    
//
void CALLBACK CMSExitProc(LPVOID data)
{
    PCM_CLIENT pcmClient = (PCM_CLIENT)data;

    DebugEntry(CMSExitProc);

    UT_Lock(UTLOCK_T120);

    //
    // Check parameters                                                    
    //
    ValidateCMS(pcmClient);

    //
    // Deregister exit procedure
    //
    if (pcmClient->exitProcRegistered)
    {
        UT_DeregisterExit(pcmClient->putTask,
                          CMSExitProc,
                          pcmClient);
        pcmClient->exitProcRegistered = FALSE;
    }

    //
    // Remove the task entry from the primary's list
    //
    g_pcmPrimary->tasks[pcmClient->taskType] = NULL;
    UT_FreeRefCount((void**)&g_pcmPrimary, TRUE);

    //
    // Free the client data
    //
    delete pcmClient;

    UT_Unlock(UTLOCK_T120);

    DebugExitVOID(CMSExitProc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\control.cpp ===
#include "precomp.h"


//
// CONTROL.CPP
// Control by us, control of us
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE




//
// CA_ReceivedPacket()
//
void  ASShare::CA_ReceivedPacket
(
    ASPerson *      pasFrom,
    PS20DATAPACKET  pPacket
)
{
    PCAPACKET       pCAPacket;

    DebugEntry(ASShare::CA_ReceivedPacket);

    ValidatePerson(pasFrom);

    pCAPacket = (PCAPACKET)pPacket;

    switch (pCAPacket->msg)
    {
        case CA_MSG_NOTIFY_STATE:
            if (pasFrom->cpcCaps.general.version < CAPS_VERSION_30)
            {
                ERROR_OUT(("Ignoring CA_MSG_NOTIFY_STATE from 2.x node [%d]",
                    pasFrom->mcsID));
            }
            else
            {
                CAHandleNewState(pasFrom, (PCANOTPACKET)pPacket);
            }
            break;

        case CA_OLDMSG_DETACH:
        case CA_OLDMSG_COOPERATE:
            // Set "cooperating", and map it to allow/disallow control
            CA2xCooperateChange(pasFrom, (pCAPacket->msg == CA_OLDMSG_COOPERATE));
            break;

        case CA_OLDMSG_REQUEST_CONTROL:
            CA2xRequestControl(pasFrom, pCAPacket);
            break;

        case CA_OLDMSG_GRANTED_CONTROL:
            CA2xGrantedControl(pasFrom, pCAPacket);
            break;

        default:
            // Ignore for now -- old 2.x messages
            break;
    }

    DebugExitVOID(ASShare::CA_ReceivedPacket);
}



//
// CA30_ReceivedPacket()
//
void ASShare::CA30_ReceivedPacket
(
    ASPerson *      pasFrom,
    PS20DATAPACKET  pPacket
)
{
    LPBYTE          pCAPacket;

    DebugEntry(ASShare::CA30_ReceivedPacket);

    pCAPacket = (LPBYTE)pPacket + sizeof(CA30PACKETHEADER);

    if (pasFrom->cpcCaps.general.version < CAPS_VERSION_30)
    {
        ERROR_OUT(("Ignoring CA30 packet %d from 2.x node [%d]",
            ((PCA30PACKETHEADER)pPacket)->msg, pasFrom->mcsID));
        DC_QUIT;
    }

    switch (((PCA30PACKETHEADER)pPacket)->msg)
    {
        // From VIEWER (remote) to HOST (us)
        case CA_REQUEST_TAKECONTROL:
        {
            CAHandleRequestTakeControl(pasFrom, (PCA_RTC_PACKET)pCAPacket);
            break;
        }

        // From HOST (remote) to VIEWER (us)
        case CA_REPLY_REQUEST_TAKECONTROL:
        {
            CAHandleReplyRequestTakeControl(pasFrom, (PCA_REPLY_RTC_PACKET)pCAPacket);
            break;
        }

        // From HOST (remote) to VIEWER (us)
        case CA_REQUEST_GIVECONTROL:
        {
            CAHandleRequestGiveControl(pasFrom, (PCA_RGC_PACKET)pCAPacket);
            break;
        }

        // From VIEWER (remote) to HOST (us)
        case CA_REPLY_REQUEST_GIVECONTROL:
        {
            CAHandleReplyRequestGiveControl(pasFrom, (PCA_REPLY_RGC_PACKET)pCAPacket);
            break;
        }

        // From CONTROLLER (remote) to HOST (us)
        case CA_PREFER_PASSCONTROL:
        {
            CAHandlePreferPassControl(pasFrom, (PCA_PPC_PACKET)pCAPacket);
            break;
        }



        // From CONTROLLER (remote) to HOST (us)
        case CA_INFORM_RELEASEDCONTROL:
        {
            CAHandleInformReleasedControl(pasFrom, (PCA_INFORM_PACKET)pCAPacket);
            break;
        }

        // From HOST (remote) to CONTROLLER (us)
        case CA_INFORM_REVOKEDCONTROL:
        {
            CAHandleInformRevokedControl(pasFrom, (PCA_INFORM_PACKET)pCAPacket);
            break;
        }

        // From HOST (remote) to CONTROLLER (us)
        case CA_INFORM_PAUSEDCONTROL:
        {
            CAHandleInformPausedControl(pasFrom, (PCA_INFORM_PACKET)pCAPacket);
            break;
        }

        // From HOST (remote) to CONTROLLER (us)
        case CA_INFORM_UNPAUSEDCONTROL:
        {
            CAHandleInformUnpausedControl(pasFrom, (PCA_INFORM_PACKET)pCAPacket);
            break;
        }

        default:
        {
            WARNING_OUT(("CA30_ReceivedPacket: unrecognized message %d",
                ((PCA30PACKETHEADER)pPacket)->msg));
            break;
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA30_ReceivedPacket);
}



//
// CANewRequestID()
//
// Returns a new token.  It uses the current value, fills in the new one, and
// also returns the new one.  We wrap around if necessary.  ZERO is never
// valid.  Note that this is a unique identifier only to us.
//
// It is a stamp for the control operation.  Since you can't be controlling
// and controlled at the same time, we have one stamp for all ops.
//
UINT ASShare::CANewRequestID(void)
{
    DebugEntry(ASShare::CANewRequestID);

    ++(m_pasLocal->m_caControlID);
    if (m_pasLocal->m_caControlID == 0)
    {
        ++(m_pasLocal->m_caControlID);
    }

    DebugExitDWORD(ASShare::CANewRequestID, m_pasLocal->m_caControlID);
    return(m_pasLocal->m_caControlID);
}



//
// CA_ViewStarting()
// Called when a REMOTE starts hosting
//
// We only do anything if it's a 2.x node since they could be cooperating
// but not hosting.
//
BOOL ASShare::CA_ViewStarting(ASPerson * pasPerson)
{
    DebugEntry(ASShare::CA_ViewStarting);

    //
    // If this isn't a back level system, ignore it.
    //
    if (pasPerson->cpcCaps.general.version >= CAPS_VERSION_30)
    {
        DC_QUIT;
    }

    //
    // See if AllowControl should now be on.
    //
    if (pasPerson->m_ca2xCooperating)
    {
        //
        // Yes, it should.  2.x node is cooperating, now they are hosting,
        // and we can take control of them.
        //
        ASSERT(!pasPerson->m_caAllowControl);
        pasPerson->m_caAllowControl = TRUE;
        VIEW_HostStateChange(pasPerson);
    }

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CA_ViewStarting, TRUE);
    return(TRUE);
}


//
// CA_ViewEnded()
// Called when a REMOTE stopped hosting
//
void ASShare::CA_ViewEnded(ASPerson * pasPerson)
{
    PCAREQUEST  pRequest;
    PCAREQUEST  pNext;

    DebugEntry(ASShare::CA_ViewEnded);

    //
    // Clear any control stuff we are a part of where they are the host
    //
    CA_ClearLocalState(CACLEAR_VIEW, pasPerson, FALSE);

    //
    // Clear any control stuff involving remotes
    //
    if (pasPerson->m_caControlledBy)
    {
        ASSERT(pasPerson->m_caControlledBy != m_pasLocal);

        CAClearHostState(pasPerson, NULL);
        ASSERT(!pasPerson->m_caControlledBy);
    }

    pasPerson->m_caAllowControl = FALSE;

    //
    // Clean up outstanding control packets to this person
    //
    pRequest = (PCAREQUEST)COM_BasedListFirst(&m_caQueuedMsgs, FIELD_OFFSET(CAREQUEST, chain));
    while (pRequest)
    {
        pNext = (PCAREQUEST)COM_BasedListNext(&m_caQueuedMsgs, pRequest,
            FIELD_OFFSET(CAREQUEST, chain));

        if (pRequest->destID == pasPerson->mcsID)
        {
            if (pRequest->type == REQUEST_30)
            {
                //
                // Delete messages sent by us to this person who is hosting
                //
                switch (pRequest->msg)
                {
                    case CA_REQUEST_TAKECONTROL:
                    case CA_PREFER_PASSCONTROL:
                    case CA_REPLY_REQUEST_GIVECONTROL:
                        WARNING_OUT(("Deleting viewer control message %d, person [%d] stopped hosting",
                            pRequest->msg, pasPerson->mcsID));
                        COM_BasedListRemove(&pRequest->chain);
                        delete pRequest;
                        break;
                }
            }
            else
            {
                ASSERT(pRequest->type == REQUEST_2X);

                // Change GRANTED_CONTROL packets to this host to DETACH
                if (pRequest->msg == CA_OLDMSG_GRANTED_CONTROL)
                {
                    //
                    // For 2.x messages, destID is only non-zero when we are
                    // attempting to control a particular node.  It allows us
                    // to undo/cancel control, to map our one-to-one model
                    // into the global 2.x collaboration model.
                    //

                    //
                    // Make this a DETACH, that way we don't have to worry if
                    // part of the COOPERATE/GRANTED_CONTROL sequence got out
                    // but part was left in the queue.
                    //
                    WARNING_OUT(("Changing GRANTED_CONTROL to 2.x host [%d] into DETATCH",
                        pasPerson->mcsID));

                    pRequest->destID            = 0;
                    pRequest->msg               = CA_OLDMSG_DETACH;
                    pRequest->req.req2x.data1   = 0;
                    pRequest->req.req2x.data2   = 0;
                }
            }
        }

        pRequest = pNext;
    }

    DebugExitVOID(ASView::CA_ViewEnded);
}

//
// CA_PartyLeftShare()
//
void ASShare::CA_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::CA_PartyLeftShare);

    ValidatePerson(pasPerson);

    //
    // Clean up 2.x control stuff
    //
    if (pasPerson == m_ca2xControlTokenOwner)
    {
        m_ca2xControlTokenOwner = NULL;
    }

    //
    // We must have cleaned up hosting info for this person already.
    // So it can't be controlled or controllable.
    //
    ASSERT(!pasPerson->m_caAllowControl);
    ASSERT(!pasPerson->m_caControlledBy);

    if (pasPerson != m_pasLocal)
    {
        PCAREQUEST  pRequest;
        PCAREQUEST  pNext;

        //
        // Clear any control stuff we are a part of where they are the
        // viewer.
        //
        CA_ClearLocalState(CACLEAR_HOST, pasPerson, FALSE);

        //
        // Clear any control stuff involving remotes
        //
        if (pasPerson->m_caInControlOf)
        {
            ASSERT(pasPerson->m_caInControlOf != m_pasLocal);
            CAClearHostState(pasPerson->m_caInControlOf, NULL);
        }

        //
        // Clean up outgoing packets meant for this person.
        //
        pRequest = (PCAREQUEST)COM_BasedListFirst(&m_caQueuedMsgs, FIELD_OFFSET(CAREQUEST, chain));
        while (pRequest)
        {
            pNext = (PCAREQUEST)COM_BasedListNext(&m_caQueuedMsgs, pRequest,
                FIELD_OFFSET(CAREQUEST, chain));

            //
            // This doesn't need to know if it's a 2.x or 3.0 request,
            // simply remove queued packets intended for somebody leaving.
            //
            // Only GRANTED_CONTROL requests will have non-zero destIDs of
            // the 2.x packets.
            //
            if (pRequest->destID == pasPerson->mcsID)
            {
                WARNING_OUT(("Freeing outgoing RESPONSE to node [%d]", pasPerson->mcsID));

                COM_BasedListRemove(&(pRequest->chain));
                delete pRequest;
            }

            pRequest = pNext;
        }

        ASSERT(m_caWaitingForReplyFrom != pasPerson);
    }
    else
    {
        //
        // When our waiting for/controlled dude stopped sharing, we should
        // have cleaned this goop up.
        //
        ASSERT(!pasPerson->m_caInControlOf);
        ASSERT(!pasPerson->m_caControlledBy);
        ASSERT(!m_caWaitingForReplyFrom);
        ASSERT(!m_caWaitingForReplyMsg);

        //
        // There should be NO outgoing control requests
        //
        ASSERT(COM_BasedListIsEmpty(&(m_caQueuedMsgs)));
    }

    DebugExitVOID(ASShare::CA_PartyLeftShare);
}



//
// CA_Periodic() -> SHARE STUFF
//
void  ASShare::CA_Periodic(void)
{
    DebugEntry(ASShare::CA_Periodic);

    //
    // Flush as many queued outgoing messages as we can
    //
    CAFlushOutgoingPackets();

    DebugExitVOID(ASShare::CA_Periodic);
}



//
// CA_SyncAlreadyHosting()
//
void ASHost::CA_SyncAlreadyHosting(void)
{
    DebugEntry(ASHost::CA_SyncAlreadyHosting);

    m_caRetrySendState          = TRUE;

    DebugExitVOID(ASHost::CA_SyncAlreadyHosting);
}


//
// CA_Periodic() -> HOSTING STUFF
//
void ASHost::CA_Periodic(void)
{
    DebugEntry(ASHost::CA_Periodic);

    if (m_caRetrySendState)
    {
        PCANOTPACKET  pPacket;
#ifdef _DEBUG
        UINT            sentSize;
#endif // _DEBUG

        pPacket = (PCANOTPACKET)m_pShare->SC_AllocPkt(PROT_STR_MISC, g_s20BroadcastID,
            sizeof(*pPacket));
        if (!pPacket)
        {
            WARNING_OUT(("CA_Periodic: couldn't broadcast new state"));
        }
        else
        {
            pPacket->header.data.dataType   = DT_CA;
            pPacket->msg                    = CA_MSG_NOTIFY_STATE;

            pPacket->state                  = 0;
            if (m_pShare->m_pasLocal->m_caAllowControl)
                pPacket->state              |= CASTATE_ALLOWCONTROL;

            if (m_pShare->m_pasLocal->m_caControlledBy)
                pPacket->controllerID       = m_pShare->m_pasLocal->m_caControlledBy->mcsID;
            else
                pPacket->controllerID       = 0;

#ifdef _DEBUG
            sentSize =
#endif // _DEBUG
            m_pShare->DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
                &(pPacket->header), sizeof(*pPacket));

            m_caRetrySendState = FALSE;
        }
    }

    DebugExitVOID(ASHost::CA_Periodic);
}



//
// CAFlushOutgoingPackets()
//
// This tries to send private packets (not broadcast notifications) that
// we have accumulated.  It returns TRUE if the outgoing queue is empty.
//
BOOL ASShare::CAFlushOutgoingPackets(void)
{
    BOOL            fEmpty = TRUE;
    PCAREQUEST      pRequest;

    //
    // If we're hosting and haven't yet flushed the HET or CA state,
    // force queueing.
    //
    if (m_hetRetrySendState || (m_pHost && m_pHost->m_caRetrySendState))
    {
        TRACE_OUT(("CAFlushOutgoingPackets:  force queuing, pending HET/CA state broadcast"));
        fEmpty = FALSE;
        DC_QUIT;
    }

    while (pRequest = (PCAREQUEST)COM_BasedListFirst(&m_caQueuedMsgs,
        FIELD_OFFSET(CAREQUEST, chain)))
    {
        //
        // Allocate/send packet
        //
        if (pRequest->type == REQUEST_30)
        {
            if (!CASendPacket(pRequest->destID, pRequest->msg,
                &pRequest->req.req30.packet))
            {
                WARNING_OUT(("CAFlushOutgoingPackets: couldn't send request"));
                fEmpty = FALSE;
                break;
            }
        }
        else
        {
            ASSERT(pRequest->type == REQUEST_2X);

            if (!CA2xSendMsg(pRequest->destID, pRequest->msg,
                pRequest->req.req2x.data1, pRequest->req.req2x.data2))
            {
                WARNING_OUT(("CAFlushOutgoingmsgs: couldn't send request"));
                fEmpty = FALSE;
                break;
            }
        }

        //
        // Do we do state transitions here or when things are added to queue?
        // requestID, results are calculated when put on queue.  Results can
        // change though based on a future action.
        //

        COM_BasedListRemove(&(pRequest->chain));
        delete pRequest;
    }

DC_EXIT_POINT:
    DebugExitBOOL(CAFlushOutgoingPackets, fEmpty);
    return(fEmpty);
}


//
// CASendPacket()
// This sends a private message (request or response) to the destination.
// If there are queued private messages in front of this one, or we can't
// send it, we add it to the pending queue.
//
// This TRUE if sent.
//
// It's up to the caller to change state info appropriately.
//
BOOL  ASShare::CASendPacket
(
    UINT_PTR            destID,
    UINT            msg,
    PCA30P          pData
)
{
    BOOL                fSent = FALSE;
    PCA30PACKETHEADER   pPacket;
#ifdef _DEBUG
    UINT                sentSize;
#endif // _DEBUG

    DebugEntry(ASShare::CASendPacket);

    //
    // Note that CA30P does not include size of header.
    //
    pPacket = (PCA30PACKETHEADER)SC_AllocPkt(PROT_STR_INPUT, destID,
        sizeof(CA30PACKETHEADER) + sizeof(*pData));
    if (!pPacket)
    {
        WARNING_OUT(("CASendPacket: no memory to send %d packet to [%d]",
            msg, destID));
        DC_QUIT;
    }

    pPacket->header.data.dataType   = DT_CA30;
    pPacket->msg                    = msg;
    memcpy(pPacket+1, pData, sizeof(*pData));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    DCS_CompressAndSendPacket(PROT_STR_INPUT, destID,
            &(pPacket->header), sizeof(*pPacket));
    TRACE_OUT(("CA30 request packet size: %08d, sent %08d", sizeof(*pPacket), sentSize));

    fSent = TRUE;

DC_EXIT_POINT:

    DebugExitBOOL(ASShare::CASendPacket, fSent);
    return(fSent);
}




//
// CAQueueSendPacket()
// This flushes pending queued requests if there are any, then tries to
// send this one.  If it can't, we add it to the queue.  If there's not any
// memory even for that, we return an error about it.
//
BOOL ASShare::CAQueueSendPacket
(
    UINT_PTR            destID,
    UINT            msg,
    PCA30P          pPacketSend
)
{
    BOOL            rc = TRUE;
    PCAREQUEST      pCARequest;

    DebugEntry(ASShare::CAQueueSendPacket);

    //
    // These must go out in order.  So if any queued messages are still
    // present, those must be sent first.
    //
    if (!CAFlushOutgoingPackets() ||
        !CASendPacket(destID, msg, pPacketSend))
    {
        //
        // We must queue this.
        //
        TRACE_OUT(("CAQueueSendPacket: queuing request for send later"));

        pCARequest = new CAREQUEST;
        if (!pCARequest)
        {
            ERROR_OUT(("CAQueueSendPacket: can't even allocate memory to queue request; must fail"));
            rc = FALSE;
        }
        else
        {
            SET_STAMP(pCARequest, CAREQUEST);

            pCARequest->type                    = REQUEST_30;
            pCARequest->destID                  = destID;
            pCARequest->msg                     = msg;
            pCARequest->req.req30.packet        = *pPacketSend;

            //
            // Stick this at the end of the queue
            //
            COM_BasedListInsertBefore(&(m_caQueuedMsgs), &(pCARequest->chain));
        }
    }

    DebugExitBOOL(ASShare::CAQueueSendPacket, rc);
    return(rc);
}



//
// CALangToggle()
//
// This temporarily turns off the keyboard language toggle key, so that a
// remote controlling us doesn't inadvertently change it.  When we stop being
// controlled, we put it back.
//
void  ASShare::CALangToggle(BOOL fBackOn)
{
    //
    // Local Variables
    //
    LONG        rc;
    HKEY        hkeyToggle;
    BYTE        regValue[2];
    DWORD       cbRegValue;
    DWORD       dwType;
    LPCSTR      szValue;

    DebugEntry(ASShare::CALangToggle);

    szValue = (g_asWin95) ? NULL : LANGUAGE_TOGGLE_KEY_VAL;

    if (fBackOn)
    {
        //
        // We are gaining control of our local keyboard again - we restore the
        // language togging functionality.
        //
        // We must directly access the registry to accomplish this.
        //
        if (m_caToggle != LANGUAGE_TOGGLE_NOT_PRESENT)
        {
            rc = RegOpenKey(HKEY_CURRENT_USER, LANGUAGE_TOGGLE_KEY,
                        &hkeyToggle);

            if (rc == ERROR_SUCCESS)
            {
                //
                // Clear the value for this key.
                //
                regValue[0] = m_caToggle;
                regValue[1] = '\0';                  // ensure NUL termination

                //
                // Restore the value.
                //
                RegSetValueEx(hkeyToggle, szValue, 0, REG_SZ,
                    regValue, sizeof(regValue));

                //
                // We need to inform the system about this change.  We do not
                // tell any other apps about this (ie do not set any of the
                // notification flags as the last parm)
                //
                SystemParametersInfo(SPI_SETLANGTOGGLE, 0, 0, 0);
            }

            RegCloseKey(hkeyToggle);
        }
    }
    else
    {
        //
        // We are losing control of our keyboard - ensure that remote key
        // events will not change our local keyboard settings by disabling the
        // keyboard language toggle.
        //
        // We must directly access the registry to accomplish this.
        //
        rc = RegOpenKey(HKEY_CURRENT_USER, LANGUAGE_TOGGLE_KEY,
                    &hkeyToggle);

        if (rc == ERROR_SUCCESS)
        {
            cbRegValue = sizeof(regValue);

            rc = RegQueryValueEx(hkeyToggle, szValue, NULL,
                &dwType, regValue, &cbRegValue);

            if (rc == ERROR_SUCCESS)
            {
                m_caToggle = regValue[0];

                //
                // Clear the value for this key.
                //
                regValue[0] = '3';
                regValue[1] = '\0';                  // ensure NUL termination

                //
                // Clear the value.
                //
                RegSetValueEx(hkeyToggle, szValue, 0, REG_SZ,
                    regValue, sizeof(regValue));

                //
                // We need to inform the system about this change.  We do not
                // tell any other apps about this (ie do not set any of the
                // notification flags as the last parm)
                //
                SystemParametersInfo(SPI_SETLANGTOGGLE, 0, 0, 0);
            }
            else
            {
                m_caToggle = LANGUAGE_TOGGLE_NOT_PRESENT;
            }

            RegCloseKey(hkeyToggle);
        }
    }

    DebugExitVOID(ASShare::CALangToggle);
}



//
// CAStartControlled()
//
void ASShare::CAStartControlled
(
    ASPerson *  pasInControl,
    UINT        controlID
)
{
    DebugEntry(ASShare::CAStartControlled);

    ValidatePerson(pasInControl);

    //
    // Undo last known state of remote
    //
    CAClearRemoteState(pasInControl);

    //
    // Get any VIEW frame UI out of the way
    //
    SendMessage(g_asSession.hwndHostUI, HOST_MSG_CONTROLLED, TRUE, 0);
    VIEWStartControlled(TRUE);

    ASSERT(!m_pasLocal->m_caControlledBy);
    m_pasLocal->m_caControlledBy = pasInControl;

    ASSERT(!pasInControl->m_caInControlOf);
    pasInControl->m_caInControlOf = m_pasLocal;

    ASSERT(!pasInControl->m_caControlID);
    ASSERT(controlID);
    pasInControl->m_caControlID = controlID;

    //
    // Notify IM.
    //
    IM_Controlled(pasInControl);

    //
    // Disable language toggling.
    //
    CALangToggle(FALSE);

    ASSERT(m_pHost);
    m_pHost->CM_Controlled(pasInControl);

    //
    // Notify the UI.  Pass GCCID of controller
    //
    DCS_NotifyUI(SH_EVT_STARTCONTROLLED, pasInControl->cpcCaps.share.gccID, 0);

    //
    // Broadcast new state
    //
    m_pHost->m_caRetrySendState = TRUE;
    m_pHost->CA_Periodic();

    DebugExitVOID(ASShare::CAStartControlled);
}



//
// CAStopControlled()
//
void ASShare::CAStopControlled(void)
{
    ASPerson *  pasControlledBy;

    DebugEntry(ASShare::CAStopControlled);

    pasControlledBy = m_pasLocal->m_caControlledBy;
    ValidatePerson(pasControlledBy);

    //
    // If control is paused, unpause it.
    //
    if (m_pasLocal->m_caControlPaused)
    {
        CA_PauseControl(pasControlledBy, FALSE, FALSE);
    }

    m_pasLocal->m_caControlledBy        = NULL;

    ASSERT(pasControlledBy->m_caInControlOf == m_pasLocal);
    pasControlledBy->m_caInControlOf    = NULL;

    ASSERT(pasControlledBy->m_caControlID);
    pasControlledBy->m_caControlID      = 0;

    //
    // Notify IM.
    //
    IM_Controlled(NULL);

    //
    // Restore language toggling functionality.
    //
    CALangToggle(TRUE);

    ASSERT(m_pHost);
    m_pHost->CM_Controlled(NULL);

    VIEWStartControlled(FALSE);
    ASSERT(IsWindow(g_asSession.hwndHostUI));
    SendMessage(g_asSession.hwndHostUI, HOST_MSG_CONTROLLED, FALSE, 0);


    //
    // Notify the UI
    //
    DCS_NotifyUI(SH_EVT_STOPCONTROLLED, pasControlledBy->cpcCaps.share.gccID, 0);

    //
    // Broadcast the new state
    //
    m_pHost->m_caRetrySendState = TRUE;
    m_pHost->CA_Periodic();

    DebugExitVOID(ASShare::CAStopControlled);
}


//
// CAStartInControl()
//
void ASShare::CAStartInControl
(
    ASPerson *  pasControlled,
    UINT        controlID
)
{
    DebugEntry(ASShare::CAStartInControl);

    ValidatePerson(pasControlled);

    //
    // Undo last known state of host
    //
    CAClearRemoteState(pasControlled);

    ASSERT(!m_pasLocal->m_caInControlOf);
    m_pasLocal->m_caInControlOf = pasControlled;

    ASSERT(!pasControlled->m_caControlledBy);
    pasControlled->m_caControlledBy = m_pasLocal;

    ASSERT(!pasControlled->m_caControlID);
    ASSERT(controlID);
    pasControlled->m_caControlID = controlID;

    ASSERT(!g_lpimSharedData->imControlled);
    IM_InControl(pasControlled);

    VIEW_InControl(pasControlled, TRUE);

    //
    // Pass GCC ID of node we're controlling
    //
    DCS_NotifyUI(SH_EVT_STARTINCONTROL, pasControlled->cpcCaps.share.gccID, 0);

    DebugExitVOID(ASShare::CAStartInControl);
}


//
// CAStopInControl()
//
void ASShare::CAStopInControl(void)
{
    ASPerson *  pasInControlOf;

    DebugEntry(ASShare::CAStopInControl);

    pasInControlOf = m_pasLocal->m_caInControlOf;
    ValidatePerson(pasInControlOf);

    if (pasInControlOf->m_caControlPaused)
    {
        pasInControlOf->m_caControlPaused = FALSE;
    }

    m_pasLocal->m_caInControlOf         = NULL;

    ASSERT(pasInControlOf->m_caControlledBy == m_pasLocal);
    pasInControlOf->m_caControlledBy    = NULL;

    ASSERT(pasInControlOf->m_caControlID);
    pasInControlOf->m_caControlID       = 0;

    ASSERT(!g_lpimSharedData->imControlled);
    IM_InControl(NULL);

    VIEW_InControl(pasInControlOf, FALSE);

    DCS_NotifyUI(SH_EVT_STOPINCONTROL, pasInControlOf->cpcCaps.share.gccID, 0);

    DebugExitVOID(ASShare::CAStopInControl);
}


//
// CA_AllowControl()
// Allows/disallows remotes from controlling us.
//
void ASShare::CA_AllowControl(BOOL fAllow)
{
    DebugEntry(ASShare::CA_AllowControl);

    if (!m_pHost)
    {
        WARNING_OUT(("CA_AllowControl: ignoring, we aren't hosting"));
        DC_QUIT;
    }

    if (fAllow != m_pasLocal->m_caAllowControl)
    {
        if (!fAllow)
        {
            // Undo pending control/control queries/being controlled stuff
            CA_ClearLocalState(CACLEAR_HOST, NULL, TRUE);
        }

        m_pasLocal->m_caAllowControl = fAllow;

        ASSERT(IsWindow(g_asSession.hwndHostUI));
        SendMessage(g_asSession.hwndHostUI, HOST_MSG_ALLOWCONTROL, fAllow, 0);

        DCS_NotifyUI(SH_EVT_CONTROLLABLE, fAllow, 0);

        m_pHost->m_caRetrySendState = TRUE;
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA_AllowControl);
}





//
// CA_HostEnded()
//
// When we stop hosting, we do not need to flush queued control
// responses.  But we need to delete them!
//
void ASHost::CA_HostEnded(void)
{
    PCAREQUEST  pCARequest;
    PCAREQUEST  pCANext;

    DebugEntry(ASHost::CA_HostEnded);

    m_pShare->CA_ClearLocalState(CACLEAR_HOST, NULL, FALSE);

    //
    // Delete now obsolete messages originating from us as host.
    //
    pCARequest = (PCAREQUEST)COM_BasedListFirst(&m_pShare->m_caQueuedMsgs,
        FIELD_OFFSET(CAREQUEST, chain));
    while (pCARequest)
    {
        pCANext = (PCAREQUEST)COM_BasedListNext(&m_pShare->m_caQueuedMsgs, pCARequest,
            FIELD_OFFSET(CAREQUEST, chain));

        if (pCARequest->type == REQUEST_30)
        {
            switch (pCARequest->msg)
            {
                //
                // Delete messages sent by us when we are hosting.
                //
                case CA_INFORM_PAUSEDCONTROL:
                case CA_INFORM_UNPAUSEDCONTROL:
                case CA_REPLY_REQUEST_TAKECONTROL:
                case CA_REQUEST_GIVECONTROL:
                    WARNING_OUT(("Deleting host control message %d, we stopped hosting",
                        pCARequest->msg));
                    COM_BasedListRemove(&pCARequest->chain);
                    delete pCARequest;
                    break;
            }
        }

        pCARequest = pCANext;
    }

    if (m_pShare->m_pasLocal->m_caAllowControl)
    {
        m_pShare->m_pasLocal->m_caAllowControl = FALSE;

        ASSERT(IsWindow(g_asSession.hwndHostUI));
        SendMessage(g_asSession.hwndHostUI, HOST_MSG_ALLOWCONTROL, FALSE, 0);

        DCS_NotifyUI(SH_EVT_CONTROLLABLE, FALSE, 0);
    }

    DebugExitVOID(ASHost::CA_HostEnded);
}



//
// CA_TakeControl()
//
// Called by viewer to ask to take control of host.  Note parallels to
// CA_GiveControl(), which is called by host to get same result.
//
void ASShare::CA_TakeControl(ASPerson *  pasHost)
{
    DebugEntry(ASShare::CA_TakeControl);

    ValidatePerson(pasHost);
    ASSERT(pasHost != m_pasLocal);

    //
    // If this person isn't hosting or controllable, fail.
    //
    if (!pasHost->m_pView)
    {
        WARNING_OUT(("CA_TakeControl: failing, person [%d] not hosting",
            pasHost->mcsID));
        DC_QUIT;
    }

    if (!pasHost->m_caAllowControl)
    {
        WARNING_OUT(("CA_TakeControl: failing, host [%d] not controllable",
            pasHost->mcsID));
        DC_QUIT;
    }

    //
    // Undo current state.
    //
    CA_ClearLocalState(CACLEAR_ALL, NULL, TRUE);

    //
    // Now take control.
    //
    if (pasHost->cpcCaps.general.version >= CAPS_VERSION_30)
    {
        //
        // 3.0 host
        //
        CA30P   packetSend;

        ZeroMemory(&packetSend, sizeof(packetSend));
        packetSend.rtc.viewerControlID = CANewRequestID();

        if (CAQueueSendPacket(pasHost->mcsID, CA_REQUEST_TAKECONTROL, &packetSend))
        {
            //
            // Now we're in waiting state.
            //
            CAStartWaiting(pasHost, CA_REPLY_REQUEST_TAKECONTROL);
            VIEW_UpdateStatus(pasHost, IDS_STATUS_WAITINGFORCONTROL);
        }
        else
        {
            WARNING_OUT(("CA_TakeControl of [%d]: failing, out of memory", pasHost->mcsID));
        }
    }
    else
    {
        CA2xTakeControl(pasHost);
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA_TakeControl);
}



//
// CA_CancelTakeControl()
//
void ASShare::CA_CancelTakeControl
(
    ASPerson *  pasHost,
    BOOL        fPacket
)
{
    DebugEntry(ASShare::CA_CancelTakeControl);

    ValidatePerson(pasHost);
    ASSERT(pasHost != m_pasLocal);

    if ((m_caWaitingForReplyFrom        != pasHost) ||
        (m_caWaitingForReplyMsg         != CA_REPLY_REQUEST_TAKECONTROL))
    {
        // We're not waiting for control of this host.
        WARNING_OUT(("CA_CancelTakeControl failing; not waiting to take control of [%d]",
            pasHost->mcsID));
        DC_QUIT;
    }

    ASSERT(pasHost->cpcCaps.general.version >= CAPS_VERSION_30);
    ASSERT(pasHost->m_caControlID == 0);

    if (fPacket)
    {
        CA30P   packetSend;

        ZeroMemory(&packetSend, sizeof(packetSend));
        packetSend.inform.viewerControlID   = m_pasLocal->m_caControlID;
        packetSend.inform.hostControlID     = pasHost->m_caControlID;

        if (!CAQueueSendPacket(pasHost->mcsID, CA_INFORM_RELEASEDCONTROL,
            &packetSend))
        {
            WARNING_OUT(("Couldn't tell node [%d] we're no longer waiting for control",
                pasHost->mcsID));
        }
    }

    m_caWaitingForReplyFrom     = NULL;
    m_caWaitingForReplyMsg      = 0;

    VIEW_UpdateStatus(pasHost, IDS_STATUS_NONE);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA_CancelTakeControl);
}



//
// CA_ReleaseControl()
//
void ASShare::CA_ReleaseControl
(
    ASPerson *  pasHost,
    BOOL        fPacket
)
{
    DebugEntry(ASShare::CA_ReleaseControl);

    ValidatePerson(pasHost);
    ASSERT(pasHost != m_pasLocal);

    if (pasHost->m_caControlledBy != m_pasLocal)
    {
        // We're not in control of this dude, nothing to do.
        WARNING_OUT(("CA_ReleaseControl failing; not in control of [%d]",
            pasHost->mcsID));
        DC_QUIT;
    }

    ASSERT(!m_caWaitingForReplyFrom);
    ASSERT(!m_caWaitingForReplyMsg);

    if (fPacket)
    {
        if (pasHost->cpcCaps.general.version >= CAPS_VERSION_30)
        {
            CA30P   packetSend;

            ZeroMemory(&packetSend, sizeof(packetSend));
            packetSend.inform.viewerControlID   = m_pasLocal->m_caControlID;
            packetSend.inform.hostControlID     = pasHost->m_caControlID;

            if (!CAQueueSendPacket(pasHost->mcsID, CA_INFORM_RELEASEDCONTROL,
                &packetSend))
            {
                WARNING_OUT(("Couldn't tell node [%d] they're no longer controlled",
                    pasHost->mcsID));
            }
        }
        else
        {
            if (!CA2xQueueSendMsg(0, CA_OLDMSG_DETACH, 0, 0))
            {
                WARNING_OUT(("Couldn't tell 2.x node [%d] they're no longer controlled",
                    pasHost->mcsID));
            }
        }
    }

    CAStopInControl();

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA_ReleaseControl);
}



//
// CA_PassControl()
//
void ASShare::CA_PassControl(ASPerson *  pasHost, ASPerson *  pasViewer)
{
    CA30P       packetSend;

    DebugEntry(ASShare::CA_PassControl);

    ValidatePerson(pasHost);
    ValidatePerson(pasViewer);
    ASSERT(pasHost != pasViewer);
    ASSERT(pasHost != m_pasLocal);
    ASSERT(pasViewer != m_pasLocal);

    if (pasHost->m_caControlledBy != m_pasLocal)
    {
        WARNING_OUT(("CA_PassControl: failing, we're not in control of [%d]",
            pasHost->mcsID));
        DC_QUIT;
    }

    ASSERT(!m_caWaitingForReplyFrom);
    ASSERT(!m_caWaitingForReplyMsg);

    //
    // No 2.x nodes, neither host nor controller, allowed
    //
    if ((pasHost->cpcCaps.general.version < CAPS_VERSION_30) ||
        (pasViewer->cpcCaps.general.version < CAPS_VERSION_30))
    {
        WARNING_OUT(("CA_PassControl: failing, we can't pass control with 2.x nodes"));
        DC_QUIT;
    }

    ZeroMemory(&packetSend, sizeof(packetSend));
    packetSend.ppc.viewerControlID  = m_pasLocal->m_caControlID;
    packetSend.ppc.hostControlID    = pasHost->m_caControlID;
    packetSend.ppc.mcsPassTo        = pasViewer->mcsID;

    if (CAQueueSendPacket(pasHost->mcsID, CA_PREFER_PASSCONTROL, &packetSend))
    {
        CAStopInControl();
    }
    else
    {
        WARNING_OUT(("Couldn't tell node [%d] we want them to pass control to [%d]",
            pasHost->mcsID, pasViewer->mcsID));
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA_PassControl);
}




//
// CA_GiveControl()
//
// Called by host to ask to grant control to viewer.  Note parallels to
// CA_TakeControl(), which is called by viewer to get same result.
//
void ASShare::CA_GiveControl(ASPerson * pasTo)
{
    CA30P       packetSend;

    DebugEntry(ASShare::CA_GiveControl);

    ValidatePerson(pasTo);
    ASSERT(pasTo != m_pasLocal);

    //
    // If we aren't hosting or controllable, fail.
    //
    if (!m_pHost)
    {
        WARNING_OUT(("CA_GiveControl: failing, we're not hosting"));
        DC_QUIT;
    }

    if (!m_pasLocal->m_caAllowControl)
    {
        WARNING_OUT(("CA_GiveControl: failing, we're not controllable"));
        DC_QUIT;
    }

    if (pasTo->cpcCaps.general.version < CAPS_VERSION_30)
    {
        //
        // Can't do this with 2.x node.
        //
        WARNING_OUT(("CA_GiveControl: failing, can't invite 2.x node [%d]",
            pasTo->mcsID));
        DC_QUIT;
    }

    //
    // Undo our control state.
    //
    CA_ClearLocalState(CACLEAR_ALL, NULL, TRUE);

    //
    // Now invite control.
    //
    ZeroMemory(&packetSend, sizeof(packetSend));
    packetSend.rgc.hostControlID    = CANewRequestID();
    packetSend.rgc.mcsPassFrom      = 0;

    if (CAQueueSendPacket(pasTo->mcsID, CA_REQUEST_GIVECONTROL, &packetSend))
    {
        //
        // Now we're in waiting state.
        //
        CAStartWaiting(pasTo, CA_REPLY_REQUEST_GIVECONTROL);
    }
    else
    {
        WARNING_OUT(("CA_GiveControl of [%d]: failing, out of memory", pasTo->mcsID));
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA_GiveControl);
}



//
// CA_CancelGiveControl()
// Cancels an invite TAKE or PASS request.
//
void ASShare::CA_CancelGiveControl
(
    ASPerson *  pasTo,
    BOOL        fPacket
)
{
    DebugEntry(ASShare::CA_CancelGiveControl);

    ValidatePerson(pasTo);
    ASSERT(pasTo != m_pasLocal);

    //
    // Have we invited this person, and are we now waiting for a response?
    //
    if ((m_caWaitingForReplyFrom        != pasTo)   ||
        (m_caWaitingForReplyMsg         != CA_REPLY_REQUEST_GIVECONTROL))
    {
        // We're not waiting to be controlled by this viewer.
        WARNING_OUT(("CA_CancelGiveControl failing; not waiting to give control to [%d]",
            pasTo->mcsID));
        DC_QUIT;
    }

    ASSERT(pasTo->cpcCaps.general.version >= CAPS_VERSION_30);
    ASSERT(!pasTo->m_caControlID);

    if (fPacket)
    {
        CA30P   packetSend;

        ZeroMemory(&packetSend, sizeof(packetSend));
        packetSend.inform.viewerControlID   = pasTo->m_caControlID;
        packetSend.inform.hostControlID     = m_pasLocal->m_caControlID;

        if (!CAQueueSendPacket(pasTo->mcsID, CA_INFORM_REVOKEDCONTROL,
            &packetSend))
        {
            WARNING_OUT(("Couldn't tell node [%d] they're no longer invited to control us",
               pasTo->mcsID));
        }
    }

    m_caWaitingForReplyFrom     = NULL;
    m_caWaitingForReplyMsg      = 0;

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA_CancelGiveControl);
}




//
// CA_RevokeControl()
// Takes control back.  If we're cleaning up (we've stopped hosting or
//
//
void ASShare::CA_RevokeControl
(
    ASPerson *  pasInControl,
    BOOL        fPacket
)
{
    CA30P       packetSend;
    PCAREQUEST  pRequest;

    DebugEntry(ASShare::CA_RevokeControl);

    //
    // If the response to pasController is still queued, simply delete it.
    // There should NOT be any CARESULT_CONFIRMED responses left.
    //
    // Otherwise, if it wasn't found, we must send a packet.
    //
    ValidatePerson(pasInControl);
    ASSERT(pasInControl != m_pasLocal);

    if (pasInControl != m_pasLocal->m_caControlledBy)
    {
        WARNING_OUT(("CA_RevokeControl: node [%d] not in control of us",
            pasInControl->mcsID));
        DC_QUIT;
    }

    //
    // Take control back if we're being controlled
    //
    if (fPacket)
    {
        //
        // Regardless of whether we can queue or not, we get control back!
        // Note that we use the controller's request ID, so he knows if
        // this is still applicable.
        //
        ZeroMemory(&packetSend, sizeof(packetSend));
        packetSend.inform.viewerControlID  = pasInControl->m_caControlID;
        packetSend.inform.hostControlID    = m_pasLocal->m_caControlID;

        if (!CAQueueSendPacket(pasInControl->mcsID, CA_INFORM_REVOKEDCONTROL,
            &packetSend))

        {
            WARNING_OUT(("Couldn't tell node [%d] they're no longer in control",
                pasInControl->mcsID));
        }
    }

    CAStopControlled();

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA_RevokeControl);
}




//
// CA_PauseControl()
//
void ASShare::CA_PauseControl
(
    ASPerson *  pasControlledBy,
    BOOL        fPause,
    BOOL        fPacket
)
{
    DebugEntry(ASShare::CA_PauseControl);

    ValidatePerson(pasControlledBy);
    ASSERT(pasControlledBy != m_pasLocal);

    //
    // If we aren't a controlled host, this doesn't do anything.
    //
    if (pasControlledBy != m_pasLocal->m_caControlledBy)
    {
        WARNING_OUT(("CA_PauseControl failing; not controlled by [%d]", pasControlledBy->mcsID));
        DC_QUIT;
    }

    ASSERT(m_pHost);
    ASSERT(m_pasLocal->m_caAllowControl);

    if (m_pasLocal->m_caControlPaused == (fPause != FALSE))
    {
        WARNING_OUT(("CA_PauseControl failing; already in requested state"));
        DC_QUIT;
    }

    if (fPacket)
    {
        CA30P       packetSend;

        ZeroMemory(&packetSend, sizeof(packetSend));
        packetSend.inform.viewerControlID   = m_pasLocal->m_caControlledBy->m_caControlID;
        packetSend.inform.hostControlID     = m_pasLocal->m_caControlID;

        if (!CAQueueSendPacket(m_pasLocal->m_caControlledBy->mcsID,
            (fPause ? CA_INFORM_PAUSEDCONTROL : CA_INFORM_UNPAUSEDCONTROL),
            &packetSend))
        {
            WARNING_OUT(("CA_PauseControl: out of memory, can't notify [%d]",
                m_pasLocal->m_caControlledBy->mcsID));
        }
    }

    // Do pause
    m_pasLocal->m_caControlPaused   = (fPause != FALSE);
    g_lpimSharedData->imPaused      = (fPause != FALSE);

    DCS_NotifyUI((fPause ? SH_EVT_PAUSEDCONTROLLED : SH_EVT_UNPAUSEDCONTROLLED),
        pasControlledBy->cpcCaps.share.gccID, 0);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA_PauseControl);
}




//
// CAHandleRequestTakeControl()
//      WE are HOST, REMOTE is VIEWER
// Handles incoming take control request.  If our state is good, we accept.
//
void ASShare::CAHandleRequestTakeControl
(
    ASPerson *      pasViewer,
    PCA_RTC_PACKET  pPacketRecv
)
{
    UINT            result = CARESULT_CONFIRMED;

    DebugEntry(ASShare::CAHandleRequestTakeControl);

    ValidatePerson(pasViewer);

    //
    // If we aren't hosting, or haven't turned allow control on, we're
    // not controllable.
    //
    if (!m_pHost || !m_pasLocal->m_caAllowControl)
    {
        result = CARESULT_DENIED_WRONGSTATE;
        goto RESPOND_PACKET;
    }

    //
    // Are we doing something else right now?  Waiting to hear back about
    // something?
    //

    if (m_caWaitingForReplyFrom)
    {
        result = CARESULT_DENIED_BUSY;
        goto RESPOND_PACKET;
    }

    if (m_caQueryDlg)
    {
        result = CARESULT_DENIED_BUSY;
        goto RESPOND_PACKET;
    }

    //
    // LAURABU TEMPORARY:
    // In a bit, if we're controlled when a new control request comes in,
    // pause control then allow host to handle it.
    //
    if (m_pasLocal->m_caControlledBy)
    {
        result = CARESULT_DENIED_BUSY;
        goto RESPOND_PACKET;
    }


    //
    // Try to put up query dialog
    //
    if (!CAStartQuery(pasViewer, CA_REQUEST_TAKECONTROL, (PCA30P)pPacketRecv))
    {
        result = CARESULT_DENIED;
    }

RESPOND_PACKET:
    if (result != CARESULT_CONFIRMED)
    {
        // Instant failure.
        CACompleteRequestTakeControl(pasViewer, pPacketRecv, result);
    }
    else
    {
        //
        // We're in a waiting state.  CACompleteRequestTakeControl() will
        // complete later or the request will just go away.
        //
    }

    DebugExitVOID(ASShare::CAHandleRequestTakeControl);
}



//
// CACompleteRequestTakeControl()
//      WE are HOST, REMOTE is VIEWER
// Completes the take control request.
//
void ASShare::CACompleteRequestTakeControl
(
    ASPerson *      pasFrom,
    PCA_RTC_PACKET  pPacketRecv,
    UINT            result
)
{
    CA30P           packetSend;

    DebugEntry(ASShare::CACompleteRequestTakeControl);

    ValidatePerson(pasFrom);

    ZeroMemory(&packetSend, sizeof(packetSend));
    packetSend.rrtc.viewerControlID     = pPacketRecv->viewerControlID;
    packetSend.rrtc.result              = result;

    if (result == CARESULT_CONFIRMED)
    {
        packetSend.rrtc.hostControlID   = CANewRequestID();
    }

    if (CAQueueSendPacket(pasFrom->mcsID, CA_REPLY_REQUEST_TAKECONTROL, &packetSend))
    {
        if (result == CARESULT_CONFIRMED)
        {
            // Clear current state, whatever that is.
            CA_ClearLocalState(CACLEAR_ALL, NULL, TRUE);

            // We are now controlled by the sender.
            CAStartControlled(pasFrom, pPacketRecv->viewerControlID);
        }
        else
        {
            WARNING_OUT(("Denying REQUEST TAKE CONTROL from [%d] with reason %d",
                pasFrom->mcsID, result));
        }
    }
    else
    {
        WARNING_OUT(("Reply to REQUEST TAKE CONTROL from [%d] failing, out of memory",
            pasFrom->mcsID));
    }

    DebugExitVOID(ASShare::CACompleteRequestTakeControl);
}



//
// CAHandleReplyRequestTakeControl()
//      WE are VIEWER, REMOTE is HOST
// Handles reply to previous take control request.
//
void ASShare::CAHandleReplyRequestTakeControl
(
    ASPerson *              pasHost,
    PCA_REPLY_RTC_PACKET    pPacketRecv
)
{
    DebugEntry(ASShare::CAHandleReplyRequestTakeControl);

    ValidatePerson(pasHost);

    if (pPacketRecv->result == CARESULT_CONFIRMED)
    {
        // On success, should have valid op ID.
        ASSERT(pPacketRecv->hostControlID);
    }
    else
    {
        // On failure, should have invalid op ID.
        ASSERT(!pPacketRecv->hostControlID);
    }

    //
    // Is this response for the current control op?
    //
    if ((m_caWaitingForReplyFrom        != pasHost) ||
        (m_caWaitingForReplyMsg         != CA_REPLY_REQUEST_TAKECONTROL))
    {
        WARNING_OUT(("Ignoring TAKE CONTROL REPLY from [%d], not waiting for one",
            pasHost->mcsID));
        DC_QUIT;
    }

    if (pPacketRecv->viewerControlID    != m_pasLocal->m_caControlID)
    {
        WARNING_OUT(("Ignoring TAKE CONTROL REPLY from [%d], request %d is out of date",
            pasHost->mcsID, pPacketRecv->viewerControlID));
        DC_QUIT;

    }

    ASSERT(!m_caQueryDlg);

    //
    // Cleanup waiting state (for both failure & success)
    //
    CA_CancelTakeControl(pasHost, FALSE);
    ASSERT(!m_caWaitingForReplyFrom);
    ASSERT(!m_caWaitingForReplyMsg);

    if (pPacketRecv->result == CARESULT_CONFIRMED)
    {
        // Success!  We're now in control of the host.

        // Make sure our own state is OK
        ASSERT(!m_pasLocal->m_caControlledBy);
        ASSERT(!m_pasLocal->m_caInControlOf);

        CAStartInControl(pasHost, pPacketRecv->hostControlID);
    }
    else
    {
        UINT        ids;

        WARNING_OUT(("TAKE CONTROL REPLY from host [%d] is failure %d", pasHost->mcsID,
            pPacketRecv->result));

        ids = IDS_ERR_TAKECONTROL_MIN + pPacketRecv->result;
        if ((ids < IDS_ERR_TAKECONTROL_FIRST) || (ids > IDS_ERR_TAKECONTROL_LAST))
            ids = IDS_ERR_TAKECONTROL_LAST;

        VIEW_Message(pasHost, ids);
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CAHandleReplyRequestTakeControl);
}




//
// CAHandleRequestGiveControl()
//      WE are VIEWER, REMOTE is HOST
// Handles incoming take control invite.  If our state is good, we accept.
//
// NOTE how similar this routine is to CAHandleRequestTakeControl().  They
// are inverses of each other.  With RequestTake/Reply sequence, viewer
// initiates, host finishes.  With RequestGive/Reply sequence, host initiates,
// viewer finishes.  Both end up with viewer in control of host when
// completed successfully.
//
void ASShare::CAHandleRequestGiveControl
(
    ASPerson *      pasHost,
    PCA_RGC_PACKET  pPacketRecv
)
{
    UINT            result = CARESULT_CONFIRMED;

    DebugEntry(ASShare::CAHandleRequestGiveControl);

    ValidatePerson(pasHost);

    //
    // Is this node hosting as far as we know.  If not, or has not turned
    // on allow control, we can't do it.
    //
    if (!pasHost->m_pView)
    {
        WARNING_OUT(("GIVE CONTROL went ahead of HOSTING, that's bad"));
        result = CARESULT_DENIED_WRONGSTATE;
        goto RESPOND_PACKET;
    }

    if (!pasHost->m_caAllowControl)
    {
        //
        // We haven't got an AllowControl notification yet, this info is
        // more up to-date.  Make use of it.
        //
        WARNING_OUT(("GIVE CONTROL went ahead of ALLOW CONTROL, that's kind of bad"));
        result = CARESULT_DENIED_WRONGSTATE;
        goto RESPOND_PACKET;
    }


    //
    // Are we doing something else right now?  Waiting to hear back about
    // something?
    //
    if (m_caWaitingForReplyFrom)
    {
        result = CARESULT_DENIED_BUSY;
        goto RESPOND_PACKET;
    }

    if (m_caQueryDlg)
    {
        result = CARESULT_DENIED_BUSY;
        goto RESPOND_PACKET;
    }

    //
    // LAURABU TEMPORARY:
    // In a bit, if we're controlled when a new control request comes in,
    // pause control then allow host to handle it.
    //
    if (m_pasLocal->m_caControlledBy)
    {
        result = CARESULT_DENIED_BUSY;
        goto RESPOND_PACKET;
    }

    //
    // Try to put up query dialog
    //
    if (!CAStartQuery(pasHost, CA_REQUEST_GIVECONTROL, (PCA30P)pPacketRecv))
    {
        result = CARESULT_DENIED;
    }

RESPOND_PACKET:
    if (result != CARESULT_CONFIRMED)
    {
        // Instant failure.
        CACompleteRequestGiveControl(pasHost, pPacketRecv, result);
    }
    else
    {
        //
        // We're in a waiting state.  CACompleteRequestGiveControl() will
        // complete later or the request will just go away.
        //
    }

    DebugExitVOID(ASShare::CAHandleRequestGiveControl);
}



//
// CACompleteRequestGiveControl()
//      WE are VIEWER, REMOTE is HOST
// Completes the invite control request.
//
void ASShare::CACompleteRequestGiveControl
(
    ASPerson *      pasFrom,
    PCA_RGC_PACKET  pPacketRecv,
    UINT            result
)
{
    CA30P           packetSend;

    DebugEntry(ASShare::CACompleteRequestGiveControl);

    ValidatePerson(pasFrom);

    ZeroMemory(&packetSend, sizeof(packetSend));
    packetSend.rrgc.hostControlID       = pPacketRecv->hostControlID;
    packetSend.rrgc.result              = result;

    if (result == CARESULT_CONFIRMED)
    {
        packetSend.rrgc.viewerControlID     = CANewRequestID();
    }

    if (CAQueueSendPacket(pasFrom->mcsID, CA_REPLY_REQUEST_GIVECONTROL, &packetSend))
    {
        //
        // If this is successful, change our state.  We're now in control.
        //
        if (result == CARESULT_CONFIRMED)
        {
            // Clear current state, whatever that is.
            CA_ClearLocalState(CACLEAR_ALL, NULL, TRUE);

            CAStartInControl(pasFrom, pPacketRecv->hostControlID);
        }
        else
        {
            WARNING_OUT(("Denying GIVE CONTROL from [%d] with reason %d",
                pasFrom->mcsID, result));
        }
    }
    else
    {
        WARNING_OUT(("Reply to GIVE CONTROL from [%d] failing, out of memory",
            pasFrom->mcsID));
    }

    DebugExitVOID(ASShare::CACompleteRequestGiveControl);
}




//
// CAHandleReplyRequestGiveControl()
//      WE are HOST, REMOTE is VIEWER
// Handles reply to previous take control invite.
//
void ASShare::CAHandleReplyRequestGiveControl
(
    ASPerson *              pasViewer,
    PCA_REPLY_RGC_PACKET    pPacketRecv
)
{
    DebugEntry(ASShare::CAHandleReplyRequestGiveControl);

    ValidatePerson(pasViewer);

    if (pPacketRecv->result == CARESULT_CONFIRMED)
    {
        // On success, should have valid op ID.
        ASSERT(pPacketRecv->viewerControlID);
    }
    else
    {
        // On failure, should have invalid op ID.
        ASSERT(!pPacketRecv->viewerControlID);
    }

    //
    // Is this response for the latest control op?
    //
    if ((m_caWaitingForReplyFrom        != pasViewer) ||
        (m_caWaitingForReplyMsg         != CA_REPLY_REQUEST_GIVECONTROL))
    {
        WARNING_OUT(("Ignoring GIVE CONTROL REPLY from [%d], not waiting for one",
            pasViewer->mcsID));
        DC_QUIT;
    }

    if (pPacketRecv->hostControlID     != m_pasLocal->m_caControlID)
    {
        WARNING_OUT(("Ignoring GIVE CONTROL REPLY from [%d], request %d is out of date",
            pasViewer->mcsID, pPacketRecv->hostControlID));
        DC_QUIT;
    }

    ASSERT(!m_caQueryDlg);
    ASSERT(m_pHost);
    ASSERT(m_pasLocal->m_caAllowControl);

    //
    // Cleanup waiting state (for both failure & success)
    //
    CA_CancelGiveControl(pasViewer, FALSE);
    ASSERT(!m_caWaitingForReplyFrom);
    ASSERT(!m_caWaitingForReplyMsg);

    if (pPacketRecv->result == CARESULT_CONFIRMED)
    {
        // Success!  We are now controlled by the viewer

        // Make sure our own state is OK
        ASSERT(!m_pasLocal->m_caControlledBy);
        ASSERT(!m_pasLocal->m_caInControlOf);

        CAStartControlled(pasViewer, pPacketRecv->viewerControlID);
    }
    else
    {
        WARNING_OUT(("GIVE CONTROL to viewer [%d] was denied", pasViewer->mcsID));
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CAHandleReplyRequestGiveControl);
}




//
// CAHandlePreferPassControl()
//      WE are HOST, REMOTE is CONTROLLER
// Handles incoming pass control request.  If we are controlled by the
// remote, and end user is cool with it, accept.
//
void ASShare::CAHandlePreferPassControl
(
    ASPerson *      pasController,
    PCA_PPC_PACKET  pPacketRecv
)
{
    ASPerson *      pasNewController;

    DebugEntry(ASShare::CAHandlePreferPassControl);

    ValidatePerson(pasController);

    //
    // If we're not controlled by the requester, ignore it.
    //
    if (m_pasLocal->m_caControlledBy    != pasController)
    {
        WARNING_OUT(("Ignoring PASS CONTROL from [%d], not controlled by him",
            pasController->mcsID));
        DC_QUIT;
    }

    if ((pPacketRecv->viewerControlID   != pasController->m_caControlID) ||
        (pPacketRecv->hostControlID     != m_pasLocal->m_caControlID))
    {
        WARNING_OUT(("Ignoring PASS CONTROL from [%d], request %d %d out of date",
            pasController->mcsID, pPacketRecv->viewerControlID, pPacketRecv->hostControlID));
        DC_QUIT;
    }

    ASSERT(!m_caQueryDlg);
    ASSERT(!m_caWaitingForReplyFrom);
    ASSERT(!m_caWaitingForReplyMsg);

    //
    // OK, the sender is not in control of us anymore.
    //
    CA_RevokeControl(pasController, FALSE);

    // Is the pass to person specified valid?
    pasNewController = SC_PersonFromNetID(pPacketRecv->mcsPassTo);
    if (!pasNewController                       ||
        (pasNewController == pasController)     ||
        (pasNewController == m_pasLocal)        ||
        (pasNewController->cpcCaps.general.version < CAPS_VERSION_30))
    {
        WARNING_OUT(("PASS CONTROL to [%d] failing, not valid person to pass to",
            pPacketRecv->mcsPassTo));
        DC_QUIT;
    }

    //
    // Try to put up query dialog
    //
    if (!CAStartQuery(pasController, CA_PREFER_PASSCONTROL, (PCA30P)pPacketRecv))
    {
        // Instant failure.  In this case, no packet.
        WARNING_OUT(("Denying PREFER PASS CONTROL from [%d], out of memory",
            pasController->mcsID));
    }
    else
    {
        //
        // We're in a waiting state.  CACompletePreferPassControl() will
        // complete later or the request will just go away.
        //
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CAHandlePreferPassControl);
}



//
// CACompletePreferPassControl()
//      WE are HOST, REMOTE is new potential CONTROLLER
// Completes the prefer pass control request.
//
void ASShare::CACompletePreferPassControl
(
    ASPerson *      pasTo,
    UINT_PTR            mcsOrg,
    PCA_PPC_PACKET  pPacketRecv,
    UINT            result
)
{
    CA30P           packetSend;

    DebugEntry(ASShare::CACompletePreferPassControl);

    ValidatePerson(pasTo);

    if (result == CARESULT_CONFIRMED)
    {
        ZeroMemory(&packetSend, sizeof(packetSend));
        packetSend.rgc.hostControlID = CANewRequestID();
        packetSend.rgc.mcsPassFrom   = mcsOrg;

        if (CAQueueSendPacket(pasTo->mcsID, CA_REQUEST_GIVECONTROL,
                &packetSend))
        {
            CA_ClearLocalState(CACLEAR_HOST, NULL, TRUE);

            CAStartWaiting(pasTo, CA_REPLY_REQUEST_GIVECONTROL);
        }
        else
        {
            WARNING_OUT(("Reply to PREFER PASS CONTROL from [%d] to [%d] failing, out of memory",
                mcsOrg, pasTo->mcsID));
        }
    }
    else
    {
        WARNING_OUT(("Denying PREFER PASS CONTROL from [%d] to [%d] with reason %d",
            mcsOrg, pasTo->mcsID, result));
    }

    DebugExitVOID(ASShare::CACompletePreferPassControl);
}




//
// CAHandleInformReleasedControl()
//      WE are HOST, REMOTE is CONTROLLER
//
void ASShare::CAHandleInformReleasedControl
(
    ASPerson *              pasController,
    PCA_INFORM_PACKET       pPacketRecv
)
{
    DebugEntry(ASShare::CAHandleInformReleasedControl);

    ValidatePerson(pasController);

    //
    // Do we currently have a TakeControl dialog up for this request?  If so,
    // take it down but don't send a packet.
    //
    if (m_caQueryDlg                            &&
        (m_caQuery.pasReplyTo    == pasController)   &&
        (m_caQuery.msg      == CA_REQUEST_TAKECONTROL)  &&
        (m_caQuery.request.rtc.viewerControlID  == pPacketRecv->viewerControlID))
    {
        ASSERT(!pPacketRecv->hostControlID);
        CACancelQuery(pasController, FALSE);
        DC_QUIT;
    }

    //
    // If this person isn't in control of us or the control op referred to
    // isn't the current one, ignore.  NULL hostControlID means the person
    // cancelled a request before they heard back from us.
    //

    if (pasController->m_caInControlOf  != m_pasLocal)
    {
        WARNING_OUT(("Ignoring RELEASE CONTROL from [%d], we're not controlled by them",
            pasController->mcsID));
        DC_QUIT;
    }

    if (pPacketRecv->viewerControlID    != pasController->m_caControlID)
    {
        WARNING_OUT(("Ignoring RELEASE CONTROL from [%d], viewer ID out of date",
            pasController->mcsID, pPacketRecv->viewerControlID));
        DC_QUIT;
    }

    if (pPacketRecv->hostControlID && (pPacketRecv->hostControlID != m_pasLocal->m_caControlID))
    {
        WARNING_OUT(("Ignoring RELEASE CONTROL from [%d], host ID out of date",
            pasController->mcsID, pPacketRecv->hostControlID));
        DC_QUIT;
    }


    // Undo control, but no packet gets sent, we're just cleaning up.
    CA_RevokeControl(pasController, FALSE);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CAHandleInformReleasedControl);
}




//
// CAHandleInformRevokedControl()
//      WE are CONTROLLER, REMOTE is HOST
//
void ASShare::CAHandleInformRevokedControl
(
    ASPerson *              pasHost,
    PCA_INFORM_PACKET       pPacketRecv
)
{
    DebugEntry(ASShare::CAHandleInformRevokedControl);

    ValidatePerson(pasHost);

    //
    // Do we currently have a GiveControl dialog up for this request?  If so,
    // take it down but don't send a packet.
    //

    if (m_caQueryDlg                            &&
        (m_caQuery.pasReplyTo        == pasHost)     &&
        (m_caQuery.msg          == CA_REQUEST_GIVECONTROL)   &&
        (m_caQuery.request.rgc.hostControlID == pPacketRecv->hostControlID))
    {
        ASSERT(!pPacketRecv->viewerControlID);
        CACancelQuery(pasHost, FALSE);
        DC_QUIT;
    }

    //
    // If this person isn't controlled by us or the control op referred to
    // isn't the current one, ignore.
    //
    if (pasHost->m_caControlledBy       != m_pasLocal)
    {
        WARNING_OUT(("Ignoring REVOKE CONTROL from [%d], not in control of them",
            pasHost->mcsID));
        DC_QUIT;
    }

    if (pPacketRecv->hostControlID     != pasHost->m_caControlID)
    {
        WARNING_OUT(("Ignoring REVOKE CONTROL from [%d], host ID out of date",
            pasHost->mcsID, pPacketRecv->hostControlID));
        DC_QUIT;
    }

    if (pPacketRecv->viewerControlID && (pPacketRecv->viewerControlID != m_pasLocal->m_caControlID))
    {
        WARNING_OUT(("Ignoring REVOKE CONTROL from [%d], viewer ID out of date",
            pasHost->mcsID, pPacketRecv->viewerControlID));
        DC_QUIT;
    }


    // Undo control, but no packet gets sent, we're just cleaning up.
    CA_ReleaseControl(pasHost, FALSE);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CAHandleInformRevokedControl);
}



//
// CAHandleInformPausedControl()
//      WE are CONTROLLER, REMOTE is HOST
//
void ASShare::CAHandleInformPausedControl
(
    ASPerson *              pasHost,
    PCA_INFORM_PACKET       pPacketRecv
)
{
    DebugEntry(ASShare::CAHandleInformPausedControl);

    ValidatePerson(pasHost);

    if (pasHost->m_caControlledBy != m_pasLocal)
    {
        WARNING_OUT(("Ignoring control paused from [%d], not controlled by us",
            pasHost->mcsID));
        DC_QUIT;
    }

    if (pasHost->m_caControlPaused)
    {
        WARNING_OUT(("Ignoring control paused from [%d], already paused",
            pasHost->mcsID));
        DC_QUIT;
    }

    pasHost->m_caControlPaused = TRUE;
    VIEW_PausedInControl(pasHost, TRUE);

    DCS_NotifyUI(SH_EVT_PAUSEDINCONTROL, pasHost->cpcCaps.share.gccID, 0);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CAHandleInformPausedControl);
}




//
// CAHandleInformUnpausedControl()
//      WE are CONTROLLER, REMOTE is HOST
//
void ASShare::CAHandleInformUnpausedControl
(
    ASPerson *              pasHost,
    PCA_INFORM_PACKET       pPacketRecv
)
{
    DebugEntry(ASShare::CAHandleInformUnpausedControl);

    ValidatePerson(pasHost);

    if (pasHost->m_caControlledBy != m_pasLocal)
    {
        WARNING_OUT(("Ignoring control unpaused from [%d], not controlled by us",
            pasHost->mcsID));
        DC_QUIT;
    }

    if (!pasHost->m_caControlPaused)
    {
        WARNING_OUT(("Ignoring control unpaused from [%d], not paused",
            pasHost->mcsID));
        DC_QUIT;
    }

    pasHost->m_caControlPaused = FALSE;
    VIEW_PausedInControl(pasHost, FALSE);

    DCS_NotifyUI(SH_EVT_UNPAUSEDINCONTROL, pasHost->cpcCaps.share.gccID, 0);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CAHandleInformUnpausedControl);
}




void ASShare::CAHandleNewState
(
    ASPerson *      pasHost,
    PCANOTPACKET    pPacket
)
{
    BOOL            caOldAllowControl;
    BOOL            caNewAllowControl;
    ASPerson *      pasController;

    DebugEntry(ASShare::CAHandleNewState);

    //
    // If this node isn't hosting, ignore this.
    //
    ValidatePerson(pasHost);
    ASSERT(pasHost->cpcCaps.general.version >= CAPS_VERSION_30);
    ASSERT(pasHost->hetCount);

    //
    // Update controllable state FIRST, so view window changes will
    // reflect it.
    //
    caOldAllowControl           = pasHost->m_caAllowControl;
    caNewAllowControl           = ((pPacket->state & CASTATE_ALLOWCONTROL) != 0);

    if (!caNewAllowControl && (pasHost->m_caControlledBy == m_pasLocal))
    {
        //
        // Fix up bogus notification
        //
        ERROR_OUT(("CA_STATE notification error!  We're in control of [%d] but he says he's not controllable.",
            pasHost->mcsID));
        CA_ReleaseControl(pasHost, FALSE);
    }

    pasHost->m_caAllowControl   = caNewAllowControl;


    // Update/clear controller
    if (!pPacket->controllerID)
    {
        pasController = NULL;
    }
    else
    {
        pasController = SC_PersonFromNetID(pPacket->controllerID);
        if (pasController == pasHost)
        {
            ERROR_OUT(("Bogus controller, same as host [%d]", pPacket->controllerID));
            pasController = NULL;
        }
    }

    if (!CAClearHostState(pasHost, pasController))
    {
        // This failed.  Put back old controllable state.
        pasHost->m_caAllowControl = caOldAllowControl;
    }

    // Force a state change if the allow state has altered
    if (caOldAllowControl != pasHost->m_caAllowControl)
    {
        VIEW_HostStateChange(pasHost);
    }

    DebugExitVOID(ASShare::CAHandleNewState);
}



//
// CAStartWaiting()
// Sets up vars for waiting state.
//
void ASShare::CAStartWaiting
(
    ASPerson *  pasWaitForReplyFrom,
    UINT        msgWaitForReplyFrom
)
{
    DebugEntry(ASShare::CAStartWaiting);

    ValidatePerson(pasWaitForReplyFrom);
    ASSERT(msgWaitForReplyFrom);

    ASSERT(!m_caWaitingForReplyFrom);
    ASSERT(!m_caWaitingForReplyMsg);

    m_caWaitingForReplyFrom    = pasWaitForReplyFrom;
    m_caWaitingForReplyMsg     = msgWaitForReplyFrom;

    DebugExitVOID(ASShare::CAStartWaiting);
}


//
// CA_ClearLocalState()
//
// Called to reset control state for LOCAL dude.
//
void ASShare::CA_ClearLocalState
(
    UINT        flags,
    ASPerson *  pasRemote,
    BOOL        fPacket
)
{
    DebugEntry(ASShare::CA_ClearLocalState);

    //
    // Clear HOST stuff
    //
    if (flags & CACLEAR_HOST)
    {
        if (m_caWaitingForReplyMsg == CA_REPLY_REQUEST_GIVECONTROL)
        {
            if (!pasRemote || (pasRemote == m_caWaitingForReplyFrom))
            {
                // Kill the outstanding invitation to the remote
                CA_CancelGiveControl(m_caWaitingForReplyFrom, fPacket);
            }
        }

        if (m_caQueryDlg &&
            ((m_caQuery.msg == CA_REQUEST_TAKECONTROL) ||
             (m_caQuery.msg == CA_PREFER_PASSCONTROL)))
        {
            if (!pasRemote || (pasRemote == m_caQuery.pasReplyTo))
            {
                // Kill the user query dialog that's up
                CACancelQuery(m_caQuery.pasReplyTo, fPacket);
            }
        }

        if (m_pasLocal->m_caControlledBy)
        {
            if (!pasRemote || (pasRemote == m_pasLocal->m_caControlledBy))
            {
                CA_RevokeControl(m_pasLocal->m_caControlledBy, fPacket);
                ASSERT(!m_pasLocal->m_caControlledBy);
            }
        }
    }

    //
    // Clear VIEW stuff
    //
    if (flags & CACLEAR_VIEW)
    {
        if (m_caWaitingForReplyMsg == CA_REPLY_REQUEST_TAKECONTROL)
        {
            if (!pasRemote || (pasRemote == m_caWaitingForReplyFrom))
            {
                CA_CancelTakeControl(m_caWaitingForReplyFrom, fPacket);
            }
        }

        if (m_caQueryDlg && (m_caQuery.msg == CA_REQUEST_GIVECONTROL))
        {
            if (!pasRemote || (pasRemote == m_caQuery.pasReplyTo))
            {
                // Kill the user query dialog that's up
                CACancelQuery(m_caQuery.pasReplyTo, fPacket);
            }
        }

        if (m_pasLocal->m_caInControlOf)
        {
            if (!pasRemote || (pasRemote == m_pasLocal->m_caInControlOf))
            {
                CA_ReleaseControl(m_pasLocal->m_caInControlOf, fPacket);
                ASSERT(!m_pasLocal->m_caInControlOf);
            }
        }
    }

    DebugExitVOID(ASShare::CA_ClearLocalState);
}


//
// CAClearRemoteState()
//
// Called to reset all control state for a REMOTE node
//
void ASShare::CAClearRemoteState(ASPerson * pasClear)
{
    DebugEntry(ASShare::CAClearRemoteState);

    if (pasClear->m_caInControlOf)
    {
        CAClearHostState(pasClear->m_caInControlOf, NULL);
        ASSERT(!pasClear->m_caInControlOf);
        ASSERT(!pasClear->m_caControlledBy);
    }
    else if (pasClear->m_caControlledBy)
    {
        CAClearHostState(pasClear, NULL);
        ASSERT(!pasClear->m_caControlledBy);
        ASSERT(!pasClear->m_caInControlOf);
    }

    DebugExitVOID(ASShare:CAClearRemoteState);
}


//
// CAClearHostState()
//
// Called to clean up the mutual pointers when undoing a node's host state.
// We need to undo the previous states:
//      * Clear the previous controller of the host
//      * Clear the previous controller of the controller
//      * Clear the previous controllee of the controller
//
// This may be recursive.
//
// It returns TRUE if the change takes effect, FALSE if it's ignored because
// it involves us and we have more recent information.
//
BOOL ASShare::CAClearHostState
(
    ASPerson *  pasHost,
    ASPerson *  pasController
)
{
    BOOL        rc = FALSE;
    UINT        gccID;

    DebugEntry(ASShare::CAClearHostState);

    ValidatePerson(pasHost);

    //
    // If nothing is changing, do nothing
    //
    if (pasHost->m_caControlledBy == pasController)
    {
        TRACE_OUT(("Ignoring control change; nothing's changing"));
        rc = TRUE;
        DC_QUIT;
    }

    //
    // If the host is us, ignore.
    // Also, if the host isn't hosting yet we got an in control change,
    // ignore it too.
    //
    if ((pasHost == m_pasLocal) ||
        (pasController && !pasHost->hetCount))
    {
        WARNING_OUT(("Ignoring control change; host is us or not sharing"));
        DC_QUIT;
    }

    //
    // UNDO any old state of the controller
    //
    if (pasController)
    {
        if (pasController == m_pasLocal)
        {
            TRACE_OUT(("Ignoring control with us as controller"));
            DC_QUIT;
        }
        else if (pasController->m_caInControlOf)
        {
            ASSERT(!pasController->m_caControlledBy);
            ASSERT(pasController->m_caInControlOf->m_caControlledBy == pasController);
            rc = CAClearHostState(pasController->m_caInControlOf, NULL);
            if (!rc)
            {
                DC_QUIT;
            }
            ASSERT(!pasController->m_caInControlOf);
        }
        else if (pasController->m_caControlledBy)
        {
            ASSERT(!pasController->m_caInControlOf);
            ASSERT(pasController->m_caControlledBy->m_caInControlOf == pasController);
            rc = CAClearHostState(pasController, NULL);
            if (!rc)
            {
                DC_QUIT;
            }
            ASSERT(!pasController->m_caControlledBy);
        }
    }

    //
    // UNDO any old IN CONTROL state of the host
    //
    if (pasHost->m_caInControlOf)
    {
        ASSERT(!pasHost->m_caControlledBy);
        ASSERT(pasHost->m_caInControlOf->m_caControlledBy == pasHost);
        rc = CAClearHostState(pasHost->m_caInControlOf, NULL);
        if (!rc)
        {
            DC_QUIT;
        }
        ASSERT(!pasHost->m_caInControlOf);
    }

    //
    // FINALLY!  Update CONTROLLED BY state of the host
    //

    // Clear OLD ControlledBy
    if (pasHost->m_caControlledBy)
    {
        ASSERT(pasHost->m_caControlledBy->m_caInControlOf == pasHost);
        pasHost->m_caControlledBy->m_caInControlOf = NULL;
    }

    // Set NEW ControlledBy
    pasHost->m_caControlledBy = pasController;
    if (pasController)
    {
        pasController->m_caInControlOf = pasHost;
        gccID = pasController->cpcCaps.share.gccID;
    }
    else
    {
        gccID = 0;
    }

    VIEW_HostStateChange(pasHost);

    //
    // The hosts' controller has changed.  Repaint the shadow cursor with/wo
    // the new initials.
    //
    CM_UpdateShadowCursor(pasHost, pasHost->cmShadowOff, pasHost->cmPos.x,
        pasHost->cmPos.y, pasHost->cmHotSpot.x, pasHost->cmHotSpot.y);

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CAClearHostState, rc);
    return(rc);
}



//
// 2.X COMPATIBILITY STUFF
// This is so that we can do a decent job of reflecting old 2.x control
// stuff, and allow a 3.0 node to take control of a 2.x system.
//


//
// CA2xCooperateChange()
//
// This is called when a 2.x node is cooperating or not.  When a 2.x node
// is a host and cooperating, he is "controllable" by 3.0 standards.  So
// when he starts/stops hosting or starts/stops cooperating we must
// recalculate "AllowControl"
//
void ASShare::CA2xCooperateChange
(
    ASPerson *      pasPerson,
    BOOL            fCooperating
)
{
    BOOL            fAllowControl;

    DebugEntry(ASShare::CA2xCooperateChange);

    ValidatePerson(pasPerson);

    //
    // If this isn't a back level system, ignore it.
    //
    if (pasPerson->cpcCaps.general.version >= CAPS_VERSION_30)
    {
        WARNING_OUT(("Received old CA cooperate message from 3.0 node [%d]",
            pasPerson->mcsID));
        DC_QUIT;
    }

    //
    // Update the cooperating state.
    //
    pasPerson->m_ca2xCooperating = fCooperating;

    //
    // If cooperating & this person owns the control token, this person
    // is now in control of all 2.x cooperating nodes.  If we were
    // controlling a 2.x host, act like we've been bounced.  But we MUST
    // send a packet.
    //
    if (fCooperating)
    {
        if (pasPerson == m_ca2xControlTokenOwner)
        {
            //
            // This person is now "in control" of the 2.x cooperating nodes.
            // If we were in control of a 2.x host, we've basically been
            // bounced and another 2.x node is running the show.  With 3.0,
            // it doesn't matter and we don't need to find out what's going
            // on with a 3.0 node in control of 2.x dudes.
            //
            if (m_pasLocal->m_caInControlOf &&
                (m_pasLocal->m_caInControlOf->cpcCaps.general.version < CAPS_VERSION_30))
            {
                CA_ReleaseControl(pasPerson, TRUE);
            }
        }
    }

    //
    // Figure out whether we need to set/clear AllowControl
    //
    fAllowControl = (fCooperating && pasPerson->m_pView);

    if (pasPerson->m_caAllowControl != fAllowControl)
    {
        if (pasPerson->m_pView && !fAllowControl)
        {
            //
            // This 2.x node is hosting, and no longer is cooperating.
            // Cleanup the controller
            //
            if (pasPerson->m_caControlledBy == m_pasLocal)
            {
                CA_ReleaseControl(pasPerson, TRUE);
            }
            else
            {
                CAClearHostState(pasPerson, NULL);
            }
        }

        pasPerson->m_caAllowControl = fAllowControl;

        // This will do nothing if this person isn't hosting.
        VIEW_HostStateChange(pasPerson);
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA2xCooperateChange);
}



//
// CA2xRequestControl()
//
// Called when a 2.x node requests control.
//
void ASShare::CA2xRequestControl
(
    ASPerson *      pasPerson,
    PCAPACKET       pCAPacket
)
{
    DebugEntry(ASShare::CA2xRequestControl);

    //
    // A 2.x node has sent this.  3.0 hosts never request, they simply
    // grab control.
    //
    ValidatePerson(pasPerson);

    //
    // If it's from a 3.0 node, it's an error.
    //
    if (pasPerson->cpcCaps.general.version >= CAPS_VERSION_30)
    {
        ERROR_OUT(("Received CA_OLDMSG_REQUEST_CONTROL from 3.0 node [%d]",
            pasPerson->mcsID));
        DC_QUIT;
    }

    //
    // If we have the token, grant it.  We must release control of a host if
    // that person is 2.x.
    //
    if (m_ca2xControlTokenOwner == m_pasLocal)
    {
        //
        // In this case, we do NOT want a dest ID.  This isn't us trying to
        // take control of a 2.x host.  It is simply granting control to
        // a 2.x dude.
        //
        if (CA2xQueueSendMsg(0, CA_OLDMSG_GRANTED_CONTROL,
            pasPerson->mcsID, m_ca2xControlGeneration))
        {
            m_ca2xControlTokenOwner = pasPerson;

            // Release control of 2.x host.
            if (m_pasLocal->m_caInControlOf &&
                (m_pasLocal->m_caInControlOf->cpcCaps.general.version < CAPS_VERSION_30))
            {
                CA_ReleaseControl(m_pasLocal->m_caInControlOf, TRUE);
            }
        }
        else
        {
            ERROR_OUT(("CA2xRequestControl:  Unable to respond GRANTED to node [%d]",
                pasPerson->mcsID));
        }
    }

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CA2xRequestControl);
}



//
// CA2xGrantedControl()
//
// Called when any node (2.x or 3.0 controlling 2.x) broadcasts granted
// control.  If we are controlling a 2.x host, it is now nuked.
//
void ASShare::CA2xGrantedControl
(
    ASPerson *  pasPerson,
    PCAPACKET   pCAPacket
)
{
    DebugEntry(ASShare::CA2xGrantedControl);

    ValidatePerson(pasPerson);

    if ((pCAPacket->data2 >= m_ca2xControlGeneration) ||
        ((m_ca2xControlGeneration - pCAPacket->data2) > 0x80000000))
    {
        ASPerson * pas2xNewTokenOwner;

        //
        // This dude is now the controller of 2.x nodes.  Remember it for
        // later COOPERATE msgs.  If nothing has changed (this is a sync
        // broadcast for example, do nothing ourselvs).
        //
        pas2xNewTokenOwner = SC_PersonFromNetID(pCAPacket->data1);
        if (pas2xNewTokenOwner != m_ca2xControlTokenOwner)
        {
            m_ca2xControlTokenOwner = pas2xNewTokenOwner;
            m_ca2xControlGeneration = pCAPacket->data2;

            //
            // Are we in control of a 2.x node?  If so, undo it.
            //
            if (m_pasLocal->m_caInControlOf &&
                (m_pasLocal->m_caInControlOf->cpcCaps.general.version < CAPS_VERSION_30))
            {
                CA_ReleaseControl(m_pasLocal->m_caInControlOf, TRUE);
            }
        }
    }

    DebugExitVOID(ASShare::CA2xGrantedControl);
}



//
// CA2xTakeControl()
//
// This fakes up packets to take control of a 2.x node.  We don't broadcast,
// we send them privately just to the individual node so we don't control
// any other host but him.
//
// We do this by sending COOPERATE then GRANTED_CONTROL.  If there's a
// collision, we'll see a GRANTED_CONTROL from somebody else that outdates
// ours.
//
void ASShare::CA2xTakeControl(ASPerson * pasHost)
{
    UINT_PTR    caNew2xControlGeneration;

    DebugEntry(ASShare::CA2xTakeControl);

    ValidateView(pasHost);

    caNew2xControlGeneration = m_ca2xControlGeneration + m_pasLocal->mcsID;

    if (CA2xQueueSendMsg(0, CA_OLDMSG_COOPERATE, 0, 0))
    {
        if (!CA2xQueueSendMsg(pasHost->mcsID, CA_OLDMSG_GRANTED_CONTROL,
            m_pasLocal->mcsID, caNew2xControlGeneration))
        {
            //
            // Failure.  Best we can do is follow it with a DETACH
            //
            ERROR_OUT(("CA2xTakeControl:  Can't take control of [%d]", pasHost->mcsID));
            CA2xQueueSendMsg(0, CA_OLDMSG_DETACH, 0, 0);
        }
        else
        {
            m_ca2xControlGeneration = caNew2xControlGeneration;
            m_ca2xControlTokenOwner = m_pasLocal;

            CANewRequestID();
            CAStartInControl(pasHost, 1);
        }
    }
    else
    {
        ERROR_OUT(("CA2xTakeControl:  Can't take control of [%d]", pasHost->mcsID));
    }

    DebugExitVOID(ASShare::CA2xTakeControl);
}




//
// CA2xSendMsg()
// This sends a 2.x node CA message.  It returns FALSE if it can't alloc
// a packet.
//
BOOL ASShare::CA2xSendMsg
(
    UINT_PTR            destID,
    UINT            msg,
    UINT_PTR            data1,
    UINT_PTR            data2
)
{
    BOOL            fSent = FALSE;
    PCAPACKET       pPacket;
#ifdef _DEBUG
    UINT            sentSize;
#endif // _DEBUG

    DebugEntry(ASShare::CASendPacket);

    //
    // For cooperate/detach, there's no target.  We broadcast them no
    // matter what so everybody knows what state we're in.
    //
    if (msg != CA_OLDMSG_GRANTED_CONTROL)
    {
        ASSERT(!destID);
    }

    //
    // WE MUST USE PROT_STR_MISC!  Backlevel nodes will uncompress it
    // using that prot dictionary.  And note that we must broadcast 2.x
    // CA packets so everybody knows what's going on.
    //
    pPacket = (PCAPACKET)SC_AllocPkt(PROT_STR_MISC, g_s20BroadcastID,
        sizeof(*pPacket));
    if (!pPacket)
    {
        WARNING_OUT(("CA2xSendMsg: can't get packet to send"));
        WARNING_OUT(("  msg             0x%08x",    msg));
        WARNING_OUT(("  data1           0x%08x",    data1));
        WARNING_OUT(("  data2           0x%08x",    data2));

        DC_QUIT;
    }

    pPacket->header.data.dataType   = DT_CA;
    pPacket->msg                    = (TSHR_UINT16)msg;
    pPacket->data1                  = (TSHR_UINT16)data1;
    pPacket->data2                  = data2;

#ifdef _DEBUG
    sentSize =
#endif
    DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
            &(pPacket->header), sizeof(*pPacket));
    TRACE_OUT(("CA request packet size: %08d, sent %08d", sizeof(*pPacket), sentSize));

    fSent = TRUE;

DC_EXIT_POINT:

    DebugExitBOOL(ASShare::CA2xSendMsg, fSent);
    return(fSent);
}


//
// CA2xQueueSendMsg()
// This sends (or queues if failure) a 2.x node CA message.  It has different
// fields, hence a different routine.
//
BOOL ASShare::CA2xQueueSendMsg
(
    UINT_PTR        destID,
    UINT            msg,
    UINT_PTR        data1,
    UINT_PTR        data2
)
{
    BOOL            rc = TRUE;
    PCAREQUEST      pCARequest;

    DebugEntry(ASShare::CA2xQueueSendMsg);

    if (msg != CA_OLDMSG_GRANTED_CONTROL)
    {
        ASSERT(!destID);
    }

    //
    // A DETACH message will cancel out a pending GRANTED_CONTROL message.
    // So look for that first.  If we find one (and there can only be at
    // most one), replace it.
    //
    if (msg == CA_OLDMSG_DETACH)
    {
        pCARequest = (PCAREQUEST)COM_BasedListFirst(&m_caQueuedMsgs,
            FIELD_OFFSET(CAREQUEST, chain));
        while (pCARequest)
        {
            if ((pCARequest->type       == REQUEST_2X)   &&
                (pCARequest->destID     == destID)      &&
                (pCARequest->msg        == CA_OLDMSG_GRANTED_CONTROL))
            {
                // Replace it
                WARNING_OUT(("Replacing cancelled GRANTED_CONTROL msg to 2.x host"));

                pCARequest->destID              = 0;
                pCARequest->msg                 = CA_OLDMSG_DETACH;
                pCARequest->req.req2x.data1     = 0;
                pCARequest->req.req2x.data2     = 0;

                // We're done.
                DC_QUIT;
            }

            pCARequest = (PCAREQUEST)COM_BasedListNext(&m_caQueuedMsgs, pCARequest,
                FIELD_OFFSET(CAREQUEST, chain));
        }
    }
    //
    // The messages must go out in order.  So we must flush pending
    // queued messages first.
    //
    if (!CAFlushOutgoingPackets() ||
        !CA2xSendMsg(destID, msg, data1, data2))
    {
        //
        // We must queue this.
        //
        WARNING_OUT(("CA2xQueueSendMsg: queueing request for send later"));

        pCARequest = new CAREQUEST;
        if (!pCARequest)
        {
            ERROR_OUT(("CA2xQueueSendMsg: can't even allocate memory to queue request; must fail"));
            rc = FALSE;
        }
        else
        {
            SET_STAMP(pCARequest, CAREQUEST);

            pCARequest->type                    = REQUEST_2X;
            pCARequest->destID                  = destID;
            pCARequest->msg                     = msg;
            pCARequest->req.req2x.data1         = data1;
            pCARequest->req.req2x.data2         = data2;

            //
            // Stick this at the end of the queue
            //
            COM_BasedListInsertBefore(&(m_caQueuedMsgs),
                &(pCARequest->chain));
        }
    }

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CA2xQueueSendMsg, rc);
    return(rc);
}



//
// CAStartQuery()
//
// This puts up the modeless dialog to query the user about a control
// request.  It will timeout if not handled.
//
BOOL ASShare::CAStartQuery
(
    ASPerson *  pasFrom,
    UINT        msg,
    PCA30P      pReq
)
{
    BOOL        rc = FALSE;

    DebugEntry(ASShare::CAStartQuery);

    ValidatePerson(pasFrom);

    //
    // We have no stacked queries.  If another comes in while the current
    // one is up, it gets an immediate failure busy.
    //
    ASSERT(!m_caQueryDlg);
    ASSERT(!m_caQuery.pasReplyTo);
    ASSERT(!m_caQuery.msg);

    //
    // Setup for new query
    //
    if (msg == CA_PREFER_PASSCONTROL)
    {
        //
        // With forwarding, the person we're going to send a packet to
        // if accepted is not the person who sent us the request.  It's the
        // person we're forwarding to.
        //
        m_caQuery.pasReplyTo = SC_PersonFromNetID(pReq->ppc.mcsPassTo);
        ValidatePerson(m_caQuery.pasReplyTo);
    }
    else
    {
        m_caQuery.pasReplyTo = pasFrom;
    }
    m_caQuery.mcsOrg    = pasFrom->mcsID;
    m_caQuery.msg       = msg;
    m_caQuery.request   = *pReq;

    //
    // If we are unattended, or the requester is unattended, instantly
    // confirm.  That's why we show the window after creating the dialog.
    //
    if ((m_pasLocal->cpcCaps.general.typeFlags & AS_UNATTENDED) ||
        (pasFrom->cpcCaps.general.typeFlags & AS_UNATTENDED))
    {
        CAFinishQuery(CARESULT_CONFIRMED);
        rc = TRUE;
    }
    else
    {
        //
        // If this is a request to us && we're hosting, check auto-accept/
        // auto-reject settings.
        //
        if (m_pHost &&
            ((msg == CA_REQUEST_TAKECONTROL) || (msg == CA_PREFER_PASSCONTROL)))
        {
            if (m_pHost->m_caTempRejectRequests)
            {
                CAFinishQuery(CARESULT_DENIED_BUSY);
                rc = TRUE;
                DC_QUIT;
            }
            else if (m_pHost->m_caAutoAcceptRequests)
            {
                CAFinishQuery(CARESULT_CONFIRMED);
                rc = TRUE;
                DC_QUIT;
            }
        }

        m_caQueryDlg    = CreateDialogParam(g_asInstance,
            MAKEINTRESOURCE(IDD_QUERY), NULL, CAQueryDlgProc, 0);
        if (!m_caQueryDlg)
        {
            ERROR_OUT(("Failed to create query message box from [%d]",
                pasFrom->mcsID));

            m_caQuery.pasReplyTo     = NULL;
            m_caQuery.mcsOrg    = 0;
            m_caQuery.msg       = 0;
        }
        else
        {
            // Success
            rc = TRUE;
        }
    }

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CAStartQuery, rc);
    return(rc);
}



//
// CAFinishQuery()
//
// Called to finish the query we started, either because of UI or because
// we or the remote are unattended.
//
void ASShare::CAFinishQuery(UINT result)
{
    CA30PENDING     request;

    DebugEntry(ASShare::CAFinishQuery);

    ValidatePerson(m_caQuery.pasReplyTo);

    // Make a copy of our request
    request         = m_caQuery;

    //
    // If we have a dialog up, destroy it NOW.  Completing the request
    // may cause us to be controlled or whatever.  So get the dialog
    // out of the way immediately.
    //
    // Note that destroying ourself will clear the request vars, hence the
    // copy above.
    //
    if (m_caQueryDlg)
    {
        DestroyWindow(m_caQueryDlg);
    }
    else
    {
        m_caQuery.pasReplyTo     = NULL;
        m_caQuery.mcsOrg    = 0;
        m_caQuery.msg       = 0;
    }

    switch (request.msg)
    {
        case CA_REQUEST_TAKECONTROL:
        {
            CACompleteRequestTakeControl(request.pasReplyTo,
                &request.request.rtc, result);
            break;
        }

        case CA_REQUEST_GIVECONTROL:
        {
            CACompleteRequestGiveControl(request.pasReplyTo,
                &request.request.rgc, result);
            break;
        }

        case CA_PREFER_PASSCONTROL:
        {
            CACompletePreferPassControl(request.pasReplyTo,
                request.mcsOrg, &request.request.ppc, result);
            break;
        }

        default:
        {
            ERROR_OUT(("Unrecognized query msg %d", request.msg));
            break;
        }
    }

    DebugExitVOID(ASShare::CAFinishQuery);
}



//
// CA_QueryDlgProc()
//
// Handles querying user dialog
//
INT_PTR CALLBACK CAQueryDlgProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    return(g_asSession.pShare->CA_QueryDlgProc(hwnd, message, wParam, lParam));
}



BOOL ASShare::CA_QueryDlgProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    BOOL        rc = TRUE;

    DebugEntry(CA_QueryDlgProc);

    switch (message)
    {
        case WM_INITDIALOG:
        {
            char    szT[256];
            char    szRes[512];
            char    szShared[64];
            UINT    idsTitle;
            ASPerson *  pasT;
            HDC     hdc;
            HFONT   hfn;
            RECT    rc;
            RECT    rcOwner;

            ValidatePerson(m_caQuery.pasReplyTo);

            pasT = NULL;

            // Set title.
            ASSERT(m_caQuery.msg);
            switch (m_caQuery.msg)
            {
                case CA_REQUEST_TAKECONTROL:
                {
                    idsTitle    = IDS_TITLE_QUERY_TAKECONTROL;

                    if (m_pasLocal->hetCount == HET_DESKTOPSHARED)
                        LoadString(g_asInstance, IDS_DESKTOP_LOWER, szShared, sizeof(szShared));
                    else
                        LoadString(g_asInstance, IDS_PROGRAMS_LOWER, szShared, sizeof(szShared));

                    LoadString(g_asInstance, IDS_MSG_QUERY_TAKECONTROL, szT, sizeof(szT));

                    wsprintf(szRes, szT, m_caQuery.pasReplyTo->scName, szShared);
                    break;
                }

                case CA_REQUEST_GIVECONTROL:
                {
                    if (m_caQuery.pasReplyTo->hetCount == HET_DESKTOPSHARED)
                        LoadString(g_asInstance, IDS_DESKTOP_LOWER, szShared, sizeof(szShared));
                    else
                        LoadString(g_asInstance, IDS_PROGRAMS_LOWER, szShared, sizeof(szShared));

                    if (m_caQuery.request.rgc.mcsPassFrom)
                    {
                        pasT = SC_PersonFromNetID(m_caQuery.request.rgc.mcsPassFrom);
                    }

                    if (pasT)
                    {
                        idsTitle    = IDS_TITLE_QUERY_YIELDCONTROL;

                        LoadString(g_asInstance, IDS_MSG_QUERY_YIELDCONTROL,
                            szT, sizeof(szT));

                        wsprintf(szRes, szT, pasT->scName, m_caQuery.pasReplyTo->scName, szShared);
                    }
                    else
                    {
                        idsTitle    = IDS_TITLE_QUERY_GIVECONTROL;

                        LoadString(g_asInstance, IDS_MSG_QUERY_GIVECONTROL,
                            szT, sizeof(szT));

                        wsprintf(szRes, szT, m_caQuery.pasReplyTo->scName, szShared);
                    }

                    break;
                }

                case CA_PREFER_PASSCONTROL:
                {
                    pasT = SC_PersonFromNetID(m_caQuery.mcsOrg);
                    ValidatePerson(pasT);

                    idsTitle    = IDS_TITLE_QUERY_FORWARDCONTROL;

                    if (m_pasLocal->hetCount == HET_DESKTOPSHARED)
                        LoadString(g_asInstance, IDS_DESKTOP_LOWER, szShared, sizeof(szShared));
                    else
                        LoadString(g_asInstance, IDS_PROGRAMS_LOWER, szShared, sizeof(szShared));

                    LoadString(g_asInstance, IDS_MSG_QUERY_FORWARDCONTROL, szT, sizeof(szT));

                    wsprintf(szRes, szT, pasT->scName, szShared, m_caQuery.pasReplyTo->scName);

                    break;
                }

                default:
                {
                    ERROR_OUT(("Bogus m_caQuery.msg %d", m_caQuery.msg));
                    break;
                }
            }

            LoadString(g_asInstance, idsTitle, szT, sizeof(szT));
            SetWindowText(hwnd, szT);

            // Set message.
            SetDlgItemText(hwnd, CTRL_QUERY, szRes);

            // Center the message vertically
            GetWindowRect(GetDlgItem(hwnd, CTRL_QUERY), &rcOwner);
            MapWindowPoints(NULL, hwnd, (LPPOINT)&rcOwner, 2);

            rc = rcOwner;

            hdc = GetDC(hwnd);
            hfn = (HFONT)SendDlgItemMessage(hwnd, CTRL_QUERY, WM_GETFONT, 0, 0);
            hfn = SelectFont(hdc, hfn);

            DrawText(hdc, szRes, -1, &rc, DT_NOCLIP | DT_EXPANDTABS |
                DT_NOPREFIX | DT_WORDBREAK | DT_CALCRECT);

            SelectFont(hdc, hfn);
            ReleaseDC(hwnd, hdc);

            ASSERT((rc.bottom - rc.top) <= (rcOwner.bottom - rcOwner.top));

            SetWindowPos(GetDlgItem(hwnd, CTRL_QUERY), NULL,
                rcOwner.left,
                ((rcOwner.top + rcOwner.bottom) - (rc.bottom - rc.top)) / 2,
                (rcOwner.right - rcOwner.left),
                rc.bottom - rc.top,
                SWP_NOACTIVATE | SWP_NOZORDER);

            SetTimer(hwnd, IDT_CAQUERY, PERIOD_CAQUERY, 0);

            //
            // Show window, the user will handle
            //
            ShowWindow(hwnd, SW_SHOWNORMAL);
            SetForegroundWindow(hwnd);
            UpdateWindow(hwnd);

            break;
        }

        case WM_COMMAND:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                {
                    CAFinishQuery(CARESULT_CONFIRMED);
                    break;
                }

                case IDCANCEL:
                {
                    CAFinishQuery(CARESULT_DENIED_USER);
                    break;
                }
            }
            break;
        }

        case WM_TIMER:
        {
            if (wParam != IDT_CAQUERY)
            {
                rc = FALSE;
            }
            else
            {
                KillTimer(hwnd, IDT_CAQUERY);

                // Timed out failure.
                CAFinishQuery(CARESULT_DENIED_TIMEDOUT);
            }
            break;
        }

        case WM_DESTROY:
        {
            //
            // Clear pending info
            //
            m_caQueryDlg        = NULL;
            m_caQuery.pasReplyTo     = NULL;
            m_caQuery.mcsOrg    = 0;
            m_caQuery.msg       = 0;
            break;
        }

        default:
        {
            rc = FALSE;
            break;
        }
    }

    DebugExitBOOL(CA_QueryDlgProc, rc);
    return(rc);
}



//
// CACancelQuery()
//
// If a dialog is up for a take control request, it hasn't been handled yet,
// and we get a cancel notification from the viewer, we need to take the
// dialog down WITHOUT generating a response packet.
//
void ASShare::CACancelQuery
(
    ASPerson *  pasFrom,
    BOOL        fPacket
)
{
    DebugEntry(ASShare::CACancelQuery);

    ASSERT(m_caQueryDlg);
    ASSERT(m_caQuery.pasReplyTo == pasFrom);

    if (fPacket)
    {
        // This will send a packet then destroy the dialog
        CAFinishQuery(CARESULT_DENIED);
    }
    else
    {
        // Destroy the dialog
        DestroyWindow(m_caQueryDlg);
    }

    ASSERT(!m_caQueryDlg);
    ASSERT(!m_caQuery.pasReplyTo);
    ASSERT(!m_caQuery.msg);

    DebugExitVOID(ASShare::CACancelQuery);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\cpi32dll.cpp ===
#include "precomp.h"


//
// CPI32DLL.CPP
// CPI32 dll entry point
//
// Copyright(c) Microsoft 1997-
//

#define INIT_DBG_ZONE_DATA
#include "dbgzones.h"


BOOL APIENTRY DllMain (HINSTANCE hInstance, DWORD reason, LPVOID plReserved)
{
    BOOL    rc = TRUE;

    switch (reason)
    {
        case DLL_PROCESS_ATTACH:
        {
#ifdef _DEBUG
            MLZ_DbgInit((PSTR *) &c_apszDbgZones[0],
                        (sizeof(c_apszDbgZones) / sizeof(c_apszDbgZones[0])) - 1);
#endif // _DEBUG

            DBG_INIT_MEMORY_TRACKING(hInstance);

            //
            // Utility stuff
            //
            if (!UT_HandleProcessStart(hInstance))
            {
                rc = FALSE;
                break;
            }

            //
            // Call platform specific init code
            //
            OSI_Load();

            //
            // Do common stuff
            //

            //
            // Init Persistent PKZIP -- this just calculates some values 
            // which are effectively constants, the tables are just too 
            // unwieldy to declare as such.
            //
            GDC_Init();

            break;
        }

        case DLL_PROCESS_DETACH:
        {
            //
            // Call platform specific cleanup code
            //
            OSI_Unload();


            //
            // Utility stuff
            //
            UT_HandleProcessEnd();

            DBG_CHECK_MEMORY_TRACKING(hInstance);

#ifdef _DEBUG
            MLZ_DbgDeInit();
#endif // _DEBUG

            break;
        }

        case DLL_THREAD_DETACH:
            UT_HandleThreadEnd();
            break;

        default:
            break;
    }

    return(rc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\cpc.cpp ===
#include "precomp.h"


//
// CPC.CPP
// Capabilities Coordinator
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE




//
// CPC_PartyJoiningShare()
//
BOOL  ASShare::CPC_PartyJoiningShare
(
    ASPerson *  pasPerson,
    UINT        cbCaps,
    LPVOID      pCapsData
)
{
    PPROTCOMBINEDCAPS   pCombinedCaps;
    LPBYTE      pCapsSrc;
    PPROTCAPS   pCapsDst;
    UINT        sizeSrc;
    UINT        sizeDst;
    BOOL        rc = FALSE;
    int         i;
    PPROTCAPS   pCapCheck;

    DebugEntry(ASShare::CPC_PartyJoiningShare);

    //
    // Set up caps
    //
    if (pasPerson == m_pasLocal)
    {
        // Copy the global variable caps
        memcpy(&pasPerson->cpcCaps, pCapsData, cbCaps);
        pasPerson->cpcCaps.share.gccID = g_asSession.gccID;
    }
    else
    {
        // When the person is created, it is zeroed out, so cpcCaps is too
        pCombinedCaps = (PPROTCOMBINEDCAPS)pCapsData;

        memcpy(&(pasPerson->cpcCaps.header), &(pCombinedCaps->header),
            sizeof(pCombinedCaps->header));

        //
        // Save the caps we care about in a simple easy structure
        //
        pCapsSrc = (LPBYTE)pCombinedCaps->capabilities;

        for (i = 0; i < pCombinedCaps->header.numCapabilities; i++)
        {
            sizeSrc = (UINT)(((PPROTCAPS)pCapsSrc)->header.capSize);

            switch (((PPROTCAPS)pCapsSrc)->header.capID)
            {
                case CAPS_ID_GENERAL:
                    pCapsDst = (PPROTCAPS)&(pasPerson->cpcCaps.general);
                    sizeDst = sizeof(PROTCAPS_GENERAL);
                    break;

                case CAPS_ID_SCREEN:
                    pCapsDst = (PPROTCAPS)&(pasPerson->cpcCaps.screen);
                    sizeDst = sizeof(PROTCAPS_SCREEN);
                    break;

                case CAPS_ID_ORDERS:
                    pCapsDst = (PPROTCAPS)&(pasPerson->cpcCaps.orders);
                    sizeDst = sizeof(PROTCAPS_ORDERS);
                    break;

                case CAPS_ID_BITMAPCACHE:
                    pCapsDst = (PPROTCAPS)&(pasPerson->cpcCaps.bitmaps);
                    sizeDst = sizeof(PROTCAPS_BITMAPCACHE);
                    break;

                case CAPS_ID_CM:
                    pCapsDst = (PPROTCAPS)&(pasPerson->cpcCaps.cursor);
                    sizeDst = sizeof(PROTCAPS_CM);
                    break;

                case CAPS_ID_PM:
                    pCapsDst = (PPROTCAPS)&(pasPerson->cpcCaps.palette);
                    sizeDst = sizeof(PROTCAPS_PM);
                    break;

                case CAPS_ID_SC:
                    pCapsDst = (PPROTCAPS)&(pasPerson->cpcCaps.share);
                    sizeDst = sizeof(PROTCAPS_SC);
                    break;

                default:
                    // Skip caps we don't recognize
                    WARNING_OUT(("Ignoring unrecognized cap ID %d, size %d from person [%d]",
                        ((PPROTCAPS)pCapsSrc)->header.capID, sizeSrc,
                        pasPerson->mcsID));
                    pCapsDst = NULL;
                    break;
            }

            if (pCapsDst)
            {
                //
                // Only copy the amount given, but keep the size of the
                // structure in the header the right one.
                //
                CopyMemory(pCapsDst, pCapsSrc, min(sizeSrc, sizeDst));
                pCapsDst->header.capSize = (TSHR_UINT16)sizeDst;
            }

            pCapsSrc += sizeSrc;
        }
    }


    //
    // Check that we have the basic 7 caps
    //
    if (!pasPerson->cpcCaps.general.header.capID)
    {
        ERROR_OUT(("Bogus GENERAL caps for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }
    if (!pasPerson->cpcCaps.screen.header.capID)
    {
        ERROR_OUT(("Bogus SCREEN caps for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }
    if (!pasPerson->cpcCaps.orders.header.capID)
    {
        ERROR_OUT(("Bogus ORDERS caps for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }
    if (!pasPerson->cpcCaps.bitmaps.header.capID)
    {
        ERROR_OUT(("Bogus BITMAPS caps for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }
    if (!pasPerson->cpcCaps.cursor.header.capID)
    {
        ERROR_OUT(("Bogus CURSOR caps for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }
    if (!pasPerson->cpcCaps.palette.header.capID)
    {
        ERROR_OUT(("Bogus PALETTE caps for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }
    if (!pasPerson->cpcCaps.share.header.capID)
    {
        ERROR_OUT(("Bogus SHARE caps for person [%d]", pasPerson->mcsID));
        DC_QUIT;
    }

    // SUCCESS!

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::CPC_PartyJoiningShare, rc);
    return(rc);
}



//
// CPC_UpdatedCaps()
//
void ASShare::CPC_UpdatedCaps(PPROTCAPS pCaps)
{
    ASPerson *      pasT;
    PCPCPACKET      pCPCPacket;
    UINT            packetSize;
#ifdef _DEBUG
    UINT            sentSize;
#endif

    DebugEntry(ASShare::CPC_UpdatedCaps);

    //
    // Only allow screen size change!
    //
    ASSERT(pCaps->header.capID == CAPS_ID_SCREEN);

    //
    // Only send change if all support it
    //
    for (pasT = m_pasLocal; pasT != NULL; pasT = pasT->pasNext)
    {
        if (pasT->cpcCaps.general.supportsCapsUpdate != CAPS_SUPPORTED)
        {
            WARNING_OUT(("Not sending caps update; person [%d] doesn't support it",
                pasT->mcsID));
            DC_QUIT;
        }
    }

    // Everybody supports a caps change.  Try to send the changed packet

    //
    // Allocate a DT_CPC packet and send it to the remote site
    //
    packetSize = sizeof(CPCPACKET) + pCaps->header.capSize - sizeof(PROTCAPS);
    pCPCPacket = (PCPCPACKET)SC_AllocPkt(PROT_STR_MISC, g_s20BroadcastID, packetSize);
    if (!pCPCPacket)
    {
        WARNING_OUT(("Failed to alloc CPC packet, size %u", packetSize));
        DC_QUIT;
    }

    //
    // Fill in the capabilities that have changed
    //
    pCPCPacket->header.data.dataType = DT_CPC;

    memcpy(&pCPCPacket->caps, pCaps, pCaps->header.capSize);

    //
    // Compress and send the packet
    //
#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
        &(pCPCPacket->header), packetSize);

    TRACE_OUT(("CPC packet size: %08d, sent %08d", packetSize, sentSize));

    // Handle change
    CPCCapabilitiesChange(m_pasLocal, pCaps);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::CPC_UpdatedCaps);
}



//
// CPC_ReceivedPacket()
//
void  ASShare::CPC_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PCPCPACKET  pCPCPacket;

    DebugEntry(ASShare::CPC_ReceivedPacket);

    ValidatePerson(pasPerson);

    pCPCPacket = (PCPCPACKET)pPacket;

    //
    // Capabilities have changed - update the local copy and inform all
    // components
    //
    TRACE_OUT(( "Capabilities changing for person [%d]", pasPerson->mcsID));

    TRACE_OUT(("Size of new capabilities 0x%08x", pCPCPacket->caps.header.capSize));
    CPCCapabilitiesChange(pasPerson, &(pCPCPacket->caps));

    DebugExitVOID(ASShare::CPC_ReceivedPacket);
}



//
// CPCCapabilitiesChange()
//
BOOL  ASShare::CPCCapabilitiesChange
(
    ASPerson *          pasPerson,
    PPROTCAPS           pCaps
)
{
    BOOL                changed;

    DebugEntry(ASShare::CPCCapabilitiesChange);

    ValidatePerson(pasPerson);

    //
    // Get pointer to the caps we're changing (SHOULD ONLY BE SCREEN!)
    //
    if (pCaps->header.capID != CAPS_ID_SCREEN)
    {
        ERROR_OUT(("Received caps change from [%d] for cap ID %d we can't handle",
            pasPerson->mcsID, pCaps->header.capID));
        changed = FALSE;
    }
    else
    {
        CopyMemory(&(pasPerson->cpcCaps.screen), pCaps,
            min(sizeof(PROTCAPS_SCREEN), pCaps->header.capSize));
        pasPerson->cpcCaps.screen.header.capSize = sizeof(PROTCAPS_SCREEN);

        USR_ScreenChanged(pasPerson);

        changed = TRUE;
    }

    DebugExitBOOL(ASShare::CPCCapabilitiesChange, changed);
    return(changed);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\dcs.cpp ===
#include "precomp.h"


//
// DCS.CPP
// Sharing main (init/term plus communication to/from ASMaster)
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE





//
// DCS_Init()
//
BOOL  DCS_Init(void)
{
    WNDCLASS    wc;
    BOOL        rc = FALSE;
    HDC         hdc;

    DebugEntry(DCS_Init);

    if (g_asOptions & AS_SERVICE)
    {
        WARNING_OUT(("AS is running as SERVICE"));
    }

    //
    // Register with the DC-Groupware Utility Services
    //
    if (!UT_InitTask(UTTASK_DCS, &g_putAS))
    {
        ERROR_OUT(( "Failed to init DCS task"));
        DC_QUIT;
    }
    UT_RegisterEvent(g_putAS, S20_UTEventProc, NULL, UT_PRIORITY_APPSHARING);


    //
    // Create the window
    //

    //
    // Register the main window class.
    //
    wc.style = 0;
    wc.lpfnWndProc = DCSMainWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = g_asInstance;
    wc.hIcon   = NULL;
    wc.hCursor = NULL;
    wc.hbrBackground = NULL;
    wc.lpszMenuName =  NULL;
    wc.lpszClassName = DCS_MAIN_WINDOW_CLASS;

    if (!RegisterClass(&wc))
    {
        ERROR_OUT(("DCS_Init: couldn't register main window class"));
        DC_QUIT;
    }

    //
    // Create the main window.
    //
    // We make the window topmost so that it is sent the WM_QUERYENDSESSION
    // message before any other (non-topmost) windows.  This lets us
    // prevent the session from closing down if we are still in a share.
    //
    g_asMainWindow = CreateWindowEx(
           WS_EX_TOPMOST,                // Make the window topmost
           DCS_MAIN_WINDOW_CLASS,        // See RegisterClass() call.
           NULL,                         // Text for window title bar.
           0,                            // Invisible.
           0,                            // Default horizontal position.
           0,                            // Default vertical position.
           200,                          // Default width.
           100,                          // Default height.
           NULL,                         // Overlapped windows have no parent.
           NULL,                         // Use the window class menu.
           g_asInstance,
           NULL                          // Pointer not needed.
           );

    if (!g_asMainWindow)
    {
        ERROR_OUT(("DCS_Init: couldn't create main window"));
        DC_QUIT;
    }

    //
    // Add a global atom for identifying hosted windows with.
    //
    g_asHostProp = GlobalAddAtom(HET_ATOM_NAME);
    if (!g_asHostProp)
    {
        ERROR_OUT(("Failed to add global atom for hosting property"));
        DC_QUIT;
    }

    //
    // Check that display driver is loaded (if it isn't we can't host)
    //
    hdc = GetDC(NULL);
    g_usrScreenBPP = GetDeviceCaps(hdc, BITSPIXEL) *
        GetDeviceCaps(hdc, PLANES);
    g_usrPalettized = ((GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE) != 0);
    ReleaseDC(NULL, hdc);

    g_usrCaptureBPP = g_usrScreenBPP;

    ASSERT(!g_asCanHost);
    ASSERT(!g_osiInitialized);
    ASSERT(!g_asSharedMemory);
    ASSERT(!g_poaData[0]);
    ASSERT(!g_poaData[1]);
    ASSERT(!g_lpimSharedData);
    ASSERT(!g_sbcEnabled);
    ASSERT(!g_asbcBitMasks[0]);
    ASSERT(!g_asbcBitMasks[1]);
    ASSERT(!g_asbcBitMasks[2]);

    OSI_Init();


    //
    // If we can't get hold of a pointer to shared IM vars, we are hosed.
    //
    if (!g_lpimSharedData)
    {
        ERROR_OUT(("Failed to get shared IM data"));
        DC_QUIT;
    }

    ASSERT(g_lpimSharedData->cbSize == sizeof(IM_SHARED_DATA));

    if (g_asOptions & AS_UNATTENDED)
    {
        // Let the input pieces (Win9x or NT) know we're in unattended mode
        g_lpimSharedData->imUnattended = TRUE;
    }

    //
    // Scheduler
    //
    if (!SCH_Init())
    {
        ERROR_OUT(("SCH Init failed"));
        DC_QUIT;
    }

    //
    // Hosting
    //
    if (!HET_Init())
    {
        ERROR_OUT(("HET Init failed"));
        DC_QUIT;
    }

    //
    // Viewing
    //
    if (!VIEW_Init())
    {
        ERROR_OUT(("VIEW Init failed"));
        DC_QUIT;
    }

    //
    // T.120 & T.128 Net
    //

    //
    // Initialize the network layer last of all.  This prevents us from
    // getting requests before we've fully initialized our components.
    //
    if (!S20_Init())
    {
        ERROR_OUT(("S20 Init failed"));
        DC_QUIT;

    }
    if (!SC_Init())
    {
        ERROR_OUT(("SC Init failed"));
        DC_QUIT;
    }

    //
    // We are now initialized.  Post a deferred message to get fonts.
    //
    PostMessage(g_asMainWindow, DCS_FINISH_INIT_MSG, 0, 0);

    // All modules have successfully initialised. Return success.
    // We are now ready to participate in sharing.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(DCS_Init, rc);
    return(rc);
}


//
// DCS_Term()
//
void  DCS_Term(void)
{
    DebugEntry(DCS_Term);

    //
    // Kill window.  Do this FIRST so that any attempts to send us requests
    // or notifications will fail.
    //
    if (g_asMainWindow)
    {
        DestroyWindow(g_asMainWindow);
        g_asMainWindow = NULL;
    }

    UnregisterClass(DCS_MAIN_WINDOW_CLASS, g_asInstance);


    //
    // Network layer - terminate this early because it will handle
    // termination in a call by generating approriate events.
    //
    S20_Term();
    SC_Term();

    //
    // Scheduler.
    //
    SCH_Term();

    //
    // Viewing
    //
    VIEW_Term();

    //
    // Hosting
    //
    HET_Term();

    //
    // Fonts
    //
    FH_Term();

    //
    // Terminate OSI
    //
    OSI_Term();

    //
    // Free our atom.
    //
    if (g_asHostProp)
    {
        GlobalDeleteAtom(g_asHostProp);
        g_asHostProp = 0;
    }

    //
    // Deregister from the Groupware Utility Services
    //
    if (g_putAS)
    {
        UT_TermTask(&g_putAS);
    }

    DebugExitVOID(DCS_Term);
}


//
// DCS_FinishInit()
//
// This does slow font enumeration, and then tries to join a call if one
// has started up.  Even if font enum fails, we can share/view shared, we
// just won't send text orders
//
void DCS_FinishInit(void)
{
    DebugEntry(DCS_FinishInit);

    //
    // Determine what fonts we have locally.
    // Done after the r11 caps field is filled in, since if we dont support
    // some of the r11 caps, then we can reduce the amount of work we do
    // when we get the font metrics etc.
    //
    g_cpcLocalCaps.orders.capsNumFonts = (TSHR_UINT16)FH_Init();

    DebugExitVOID(DCS_FinishInit);
}



//
// FUNCTION: DCS_PartyJoiningShare
//
BOOL ASShare::DCS_PartyJoiningShare(ASPerson * pasPerson)
{
    BOOL            rc = FALSE;
    UINT            iDict;

    DebugEntry(ASShare::DCS_PartyJoiningShare);

    ValidatePerson(pasPerson);

    //
    // Allocate dictionaries for GDC Persistent dictionary compression if
    // this person supports it.  We'll use them to decompress data
    // received from this person.  NOTE:  Win95 2.0 does not support
    // persistent pkzip.
    //
    if (pasPerson->cpcCaps.general.genCompressionType & GCT_PERSIST_PKZIP)
    {
        //
        // Allocate persistent dictionaries (outgoing if us, incoming if
        // others).
        //
        TRACE_OUT(( "Allocating receive dictionary set for [%d]", pasPerson->mcsID));

        pasPerson->adcsDict = new GDC_DICTIONARY[GDC_DICT_COUNT];
        if (!pasPerson->adcsDict)
        {
            ERROR_OUT(("Failed to allocate persistent dictionaries for [%d]", pasPerson->mcsID));
            DC_QUIT;
        }
        else
        {
            //
            // Initialize cbUsed to zero
            //
            for (iDict = 0; iDict < GDC_DICT_COUNT; iDict++)
            {
                pasPerson->adcsDict[iDict].cbUsed = 0;
            }
        }
    }

    rc = TRUE;

DC_EXIT_POINT:
    DebugExitBOOL(ASShare::DCS_PartyJoiningShare, rc);
    return(rc);
}



//
// FUNCTION: DCS_PartyLeftShare
//
void  ASShare::DCS_PartyLeftShare(ASPerson * pasPerson)
{
    DebugEntry(ASShare::DCS_PartyLeftShare);

    ValidatePerson(pasPerson);

    //
    // Free any dictionaries we allocated
    //
    if (pasPerson->adcsDict)
    {
        delete[] pasPerson->adcsDict;
        pasPerson->adcsDict = NULL;
    }

    DebugExitVOID(ASShare::DCS_PartyLeftShare);
}



//
// DCS_RecalcCaps()
//
// Called when someone joins or leaves share.
//
void  ASShare::DCS_RecalcCaps(BOOL fJoiner)
{
    ASPerson * pasT;

    DebugEntry(ASShare::DCS_RecalcCaps);

    //
    // The combined compression support is initialised to the local support
    //
    ValidatePerson(m_pasLocal);
    m_dcsCompressionSupport = m_pasLocal->cpcCaps.general.genCompressionType;
    m_dcsCompressionLevel   = m_pasLocal->cpcCaps.general.genCompressionLevel;

    //
    // Loop through the remotes
    //
    for (pasT = m_pasLocal->pasNext; pasT != NULL; pasT = pasT->pasNext)
    {
        ValidatePerson(pasT);

        m_dcsCompressionSupport &=
            pasT->cpcCaps.general.genCompressionType;

        m_dcsCompressionLevel = min(m_dcsCompressionLevel,
            pasT->cpcCaps.general.genCompressionLevel);
    }

    TRACE_OUT(("DCS Combined compression level %u, support %#x",
            m_dcsCompressionLevel,
            m_dcsCompressionSupport));

    DebugExitVOID(ASShare::DCS_RecalcCaps);
}


//
// SC_Periodic()
//
// The Scheduler runs a separate thread which is responsible for posting
// messages to our main thread, for which SC_Periodic() is the handler.
// Posted messages have the highest priority in GetMessage(), above input,
// paints, and timers.
//
// The Scheduler is in one of three states:
// asleep, normal or turbo.  When it is asleep, this function is not
// called.  When it is in normal mode, this function is called at least
// once, but the scheduler is a lazy guy, so will fall asleep again unless
// you keep prodding him.  In turbo mode this function is called repeatedly
// and rapidly, but only for a relatively short time, after which the
// scheduler falls back into normal mode, and from there falls asleep.
//
void  ASShare::SC_Periodic(void)
{
    UINT    currentTime;

    DebugEntry(ASShare::SC_Periodic);

    //
    // We must get the time accurately.
    //
    currentTime = GetTickCount();

    //
    // Dont do a lot of work if this is an immediate reschedule due to
    // multiple queued entries.  Most processors will achieve this in
    // less than 5 mS.
    //
    if ((currentTime - m_dcsLastScheduleTime) < 5)
    {
        WARNING_OUT(("Quit early"));
        DC_QUIT;
    }

    m_dcsLastScheduleTime = currentTime;

    //
    // Call the input manager event playback function frequently so that
    // we keep the input queue empty.  (Note that we do not want to just
    // dump the input queue into USER because we would lose all the
    // repeat keystroke packets we have so carefully sent across)
    // To trigger input we just use a 0 personid and NULL packet.
    //
    if ((currentTime - m_dcsLastIMTime) > DCS_IM_PERIOD)
    {
        m_dcsLastIMTime = currentTime;
        IM_ReceivedPacket(NULL, NULL);
    }

    //
    // There are calls which are made periodically but don't have any
    // dependencies.  First call the ones we want to be called fairly
    // frequently.
    //
    if ((currentTime - m_dcsLastFastMiscTime) > DCS_FAST_MISC_PERIOD )
    {
        m_dcsLastFastMiscTime = currentTime;

        OE_Periodic();
        HET_Periodic();
        CA_Periodic();
        IM_Periodic();
    }

    //
    // Only send updates if we're hosting, and have managed to tell everyone
    // we're hosting.
    //
    if (m_pHost && !m_hetRetrySendState)
    {
        UINT    swlRc = 0;
        BOOL    fetchedBounds = FALSE;

        m_pHost->CA_Periodic();

        //
        // See if we need to swap the buffers over.  Only swap if we have
        // sent all the data from the current orders.
        //
        if (m_pHost->OA_GetFirstListOrder() == NULL)
        {
            //
            // Get the current bounds from the driver.  This will fill in
            // the share core's copy of the bounds.
            //
            m_pHost->BA_FetchBounds();
            fetchedBounds = TRUE;

            //
            // Set up the new order list buffer
            //
            m_pHost->OA_ResetOrderList();

            //
            // Bounds data should be reset to a usable state by SDG once it
            // has finished with them, so we just need to swap the buffers
            // at this point.
            //
            SHM_SwitchReadBuffer();
        }

        //
        // In this high frequency code path we only send SWP info if it
        // is flagged as needed by the CBT hooks or if SWL determines a
        // send is required.  Only SWL knows if a send is required so
        // pass the CBT indication into SWL and let it do the
        // determination.
        //
        // The SWL window scan performs preemptable operations and we
        // must detect the occurrence of preemption otherwise we find
        // ourselves sending updates against an invalid window
        // structure.  Therefore we query OA and BA to see if any
        // updates have been accumulated in the interim.  We can tight
        // loop trying to get a good SWL list because we really don't
        // want to yield at this point - it is just that we cannot
        // prevent it sometimes.  (Sweeping through menus is a good way
        // to exercise this code.)
        //

        //
        // Synchronize the fast path data
        //
        SHM_SwitchFastBuffer();

        swlRc = m_pHost->SWL_Periodic();
        if (swlRc != SWL_RC_ERROR)
        {
            //
            // Only send this stuff if we were able to send the window list
            // packet.
            //
            m_pHost->AWC_Periodic();

            //
            // We've sent a window list and the current active window, now
            // send drawing updates.
            //
            m_pHost->UP_Periodic(currentTime);

            //
            // See if the cursor has changed image or position
            //
            m_pHost->CM_Periodic();
        }
        else
        {
            TRACE_OUT(("SWL_Periodic waiting for visibility count"));
        }

        //
        // If we got the bounds from the driver, we have to let the driver know
        // how much of the bounds remain to be sent.
        //
        if (fetchedBounds)
        {
            m_pHost->BA_ReturnBounds();
        }
    }

DC_EXIT_POINT:
    SCH_ContinueScheduling(SCH_MODE_NORMAL);

    DebugExitVOID(ASShare::SC_Periodic);
}



//
// DCS_CompressAndSendPacket()
//
#ifdef _DEBUG
UINT ASShare::DCS_CompressAndSendPacket
#else
void ASShare::DCS_CompressAndSendPacket
#endif // _DEBUG
(
    UINT            streamID,
    UINT_PTR        nodeID,
    PS20DATAPACKET  pPacket,
    UINT            packetLength
)
{
    UINT            cbSrcDataSize;
    UINT            cbDstDataSize;
    UINT            compression;
    BOOL            compressed;
    UINT            dictionary;

    DebugEntry(ASShare::DCS_CompressAndSendPacket);

    ASSERT(streamID >= SC_STREAM_LOW);
    ASSERT(streamID <= SC_STREAM_HIGH);

    ASSERT(!m_ascSynced[streamID-1]);
    ASSERT(!m_scfInSync);

    ASSERT(packetLength < TSHR_MAX_SEND_PKT);

    //
    // Decide which (if any) compression algorithm we are going to use to
    // try and compress this packet.
    //
    compression     = 0;
    cbSrcDataSize   = packetLength - sizeof(S20DATAPACKET);

    //
    // Is the data a compressable size?
    //
    if ((cbSrcDataSize >= DCS_MIN_COMPRESSABLE_PACKET) &&
        (!m_dcsLargePacketCompressionOnly ||
            (cbSrcDataSize >= DCS_MIN_FAST_COMPRESSABLE_PACKET)))
    {

        //
        // If all nodes have genCompressionLevel 1 or above and all nodes
        // support PERSIST_PKZIP we will use PERSIST_PKZIP (if we are
        // ready).
        //
        // Otherwise, if all nodes support PKZIP and the packet is larger
        // than a predefined minimum size we will use PKZIP.
        //
        // Otherwise, we don't compress
        //
        if ((m_dcsCompressionLevel >= 1) &&
            (m_dcsCompressionSupport & GCT_PERSIST_PKZIP) &&
            (cbSrcDataSize <= DCS_MAX_PDC_COMPRESSABLE_PACKET))
        {
            //
            // Use PERSIST_PKZIP compression
            //
            compression = GCT_PERSIST_PKZIP;
        }
        else if (m_dcsCompressionSupport & GCT_PKZIP)
        {
            //
            // Use PKZIP compression
            //
            compression = GCT_PKZIP;
        }
    }


    //
    // Compress the packet
    //
    compressed = FALSE;
    if (compression != 0)
    {
        PGDC_DICTIONARY pgdcSrc = NULL;

        //
        // We compress only the data and not the header of course
        //
        cbDstDataSize     = cbSrcDataSize;

        ASSERT(m_ascTmpBuffer != NULL);

        //
        // Compress the data following the packet header.
        //
        if (compression == GCT_PERSIST_PKZIP)
        {
            //
            // Figure out what dictionary to use for the stream priority
            //
            switch (streamID)
            {
                case PROT_STR_UPDATES:
                    dictionary = GDC_DICT_UPDATES;
                    break;

                case PROT_STR_MISC:
                    dictionary = GDC_DICT_MISC;
                    break;

                case PROT_STR_INPUT:
                    dictionary = GDC_DICT_INPUT;
                    break;
            }

            pgdcSrc = &m_pasLocal->adcsDict[dictionary];
        }

        compressed = GDC_Compress(pgdcSrc,  GDCCO_MAXCOMPRESSION,
            m_agdcWorkBuf, (LPBYTE)(pPacket + 1),
            cbSrcDataSize, m_ascTmpBuffer, &cbDstDataSize);

        if (compressed)
        {
            //
            // The data was successfully compressed, copy it back
            //
            ASSERT(cbDstDataSize <= cbSrcDataSize);
            memcpy((pPacket+1), m_ascTmpBuffer, cbDstDataSize);

            //
            // The data length include the data header
            //
            pPacket->dataLength = (TSHR_UINT16)(cbDstDataSize + sizeof(DATAPACKETHEADER));
            pPacket->data.compressedLength = pPacket->dataLength;

            packetLength = cbDstDataSize + sizeof(S20DATAPACKET);
        }
    }

    //
    // Update the packet header.
    //
    if (!compressed)
    {
        pPacket->data.compressionType = 0;
    }
    else
    {
        if (m_dcsCompressionLevel >= 1)
        {
            pPacket->data.compressionType = (BYTE)compression;
        }
        else
        {
            pPacket->data.compressionType = CT_OLD_COMPRESSED;
        }
    }

    //
    // Send the packet.
    //
    S20_SendDataPkt(streamID, nodeID, pPacket);

#ifdef _DEBUG
    DebugExitDWORD(ASShare::DCS_CompressAndSendPacket, packetLength);
    return(packetLength);
#else
    DebugExitVOID(ASShare::DCS_CompressAndSendPacket);
#endif // _DEBUG
}


//
// DCS_FlowControl()
//
// This is called back from our flow control code.  The parameter passed
// is the new bytes/second rate that data is flowing at.  We turn small
// packet compression off when the rate is large, it means we're on a
// fast link so there's no need to bog down the CPU compressing small
// packets.
//
void  ASShare::DCS_FlowControl
(
    UINT    DataBytesPerSecond
)
{
    DebugEntry(ASShare::DCS_FlowControl);

    if (DataBytesPerSecond < DCS_FAST_THRESHOLD)
    {
        //
        // Throughput is slow
        //
        if (m_dcsLargePacketCompressionOnly)
        {
            m_dcsLargePacketCompressionOnly = FALSE;
            TRACE_OUT(("DCS_FlowControl:  SLOW; compress small packets"));
        }
    }
    else
    {
        //
        // Throughput is fast
        //
        if (!m_dcsLargePacketCompressionOnly)
        {
            m_dcsLargePacketCompressionOnly = TRUE;
            TRACE_OUT(("DCS_FlowControl:  FAST; don't compress small packets"));
        }
    }

    DebugExitVOID(ASShare::DCS_FlowControl);
}



//
// DCS_SyncOutgoing() - see dcs.h
//
void ASShare::DCS_SyncOutgoing(void)
{
    DebugEntry(ASShare::DCS_SyncOutgoing);

    //
    // Reset the send compression dictionaries
    //
    if (m_pasLocal->cpcCaps.general.genCompressionType & GCT_PERSIST_PKZIP)
    {
        UINT    i;

        ASSERT(m_pasLocal->adcsDict);

        for (i = 0; i < GDC_DICT_COUNT; i++)
        {
            //
            // Somebody has joined or left.  We need to start over
            // and wipe out any saved data.
            //
            m_pasLocal->adcsDict[i].cbUsed = 0;
        }
    }

    DebugExitVOID(ASShare::DCS_SyncOutgoing);
}




//
// DCS_NotifyUI()
//
void DCS_NotifyUI
(
    UINT        eventID,
    UINT        parm1,
    UINT        parm2
)
{
    DebugEntry(DCS_NotifyUI);

    //
    // Post event to Front End
    //
    UT_PostEvent(g_putAS, g_putUI, 0, eventID, parm1, parm2);

    DebugExitVOID(DCS_NotifyUI);
}



//
// DCSLocalDesktopSizeChanged
//
// Routine called whenever the desktop size changes.
//
// Updates local desktop size stored in capabilities and informs all other
// machine in a share of the new size
//
void  DCSLocalDesktopSizeChanged(UINT width, UINT height)
{
    DebugEntry(DCSLocalDesktopSizeChanged);

    //
    // Check that the desktop has actually changed size
    //
    if ((g_cpcLocalCaps.screen.capsScreenHeight == height) &&
        (g_cpcLocalCaps.screen.capsScreenWidth == width))
    {
        TRACE_OUT(( "Desktop size has not changed!"));
        DC_QUIT;
    }

    //
    // Update the desktop size
    //
    g_cpcLocalCaps.screen.capsScreenWidth = (TSHR_UINT16)width;
    g_cpcLocalCaps.screen.capsScreenHeight = (TSHR_UINT16)height;

    if (g_asSession.pShare)
    {
        g_asSession.pShare->CPC_UpdatedCaps((PPROTCAPS)&g_cpcLocalCaps.screen);
    }

DC_EXIT_POINT:
    DebugExitVOID(DCSLocalDesktopSizeChanged);
}




//
// Main window message procedure.
//
LRESULT CALLBACK DCSMainWndProc
(
    HWND        hwnd,
    UINT        message,
    WPARAM      wParam,
    LPARAM      lParam
)
{
    LRESULT     rc = 0;

    DebugEntry(DCSMainWndProc);

    switch (message)
    {
        case DCS_FINISH_INIT_MSG:
        {
            DCS_FinishInit();
            break;
        }

        case DCS_PERIODIC_SCHEDULE_MSG:
        {
            if (g_asSession.pShare)
            {
                //
                // Call our periodic processing function if there's at least
                // another person in the share with us.
                //
                g_asSession.pShare->ValidatePerson(g_asSession.pShare->m_pasLocal);

                //
                // NOTE:
                // If we add record/playback capabilities, get rid of this
                // or change the check.  This prevents us from allocating,
                // composing, and sending packets to nowhere when we are
                // the only person in the share.
                //
                if (g_asSession.pShare->m_pasLocal->pasNext || g_asSession.pShare->m_scfViewSelf)
                {
                    g_asSession.pShare->SC_Periodic();
                }
            }

            //
            // Notify the Scheduler that we have processed the scheduling
            // message, which signals that another one can be sent (only
            // one is outstanding at a time).
            //
            SCH_SchedulingMessageProcessed();
        }
        break;

        case WM_ENDSESSION:
        {
            //
            // The wParam specifies whether the session is about to end.
            //
            if (wParam && !(g_asOptions & AS_SERVICE))
            {
                //
                // Windows is about to terminate (abruptly!).  Call our
                // termination functions now - before Windows shuts down
                // the hardware device drivers.
                //
                // We don't leave this job to the WEP because by the time
                // it gets called the hardware device drivers have been
                // shut down and some of the calls we make then fail (e.g.
                // timeEndPeriod requires TIMER.DRV).
                //
                DCS_Term();
            }
        }
        break;

        case WM_CLOSE:
        {
            ERROR_OUT(("DCS window received WM_CLOSE, this should never happen"));
        }
        break;

        case WM_PALETTECHANGED:
        case WM_PALETTEISCHANGING:
        {
            //
            // Win95 patches the Palette DDIs which are more accurate,
            // so only key off this message for NT.
            //
            if (!g_asWin95 && g_asSharedMemory)
            {
                g_asSharedMemory->pmPaletteChanged = TRUE;
            }
        }
        break;

        case WM_DISPLAYCHANGE:
        {
            //
            // The desktop size is changing - we are passed the new size.
            //
            DCSLocalDesktopSizeChanged(LOWORD(lParam),
                                       HIWORD(lParam));
        }
        break;

        case WM_SETTINGCHANGE:
        case WM_USERCHANGED:
            if (g_asSession.pShare && g_asSession.pShare->m_pHost)
            {
                WARNING_OUT(("AS: Reset effects on %s", (message == WM_SETTINGCHANGE)
                    ? "SETTINGCHANGE" : "USERCHANGE"));
                HET_SetGUIEffects(FALSE, &g_asSession.pShare->m_pHost->m_hetEffects);
            }
            break;

        //
        // Private app sharing messages
        //
        case DCS_KILLSHARE_MSG:
            SC_EndShare();
            break;

        case DCS_SHARE_MSG:
            DCS_Share((HWND)lParam, (IAS_SHARE_TYPE)wParam);
            break;

        case DCS_UNSHARE_MSG:
            DCS_Unshare((HWND)lParam);
            break;

        case DCS_ALLOWCONTROL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->CA_AllowControl((BOOL)wParam);
            }
            break;

        case DCS_TAKECONTROL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->DCS_TakeControl((UINT)wParam);
            }
            break;

        case DCS_CANCELTAKECONTROL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->DCS_CancelTakeControl((UINT)wParam);
            }
            break;

        case DCS_RELEASECONTROL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->DCS_ReleaseControl((UINT)wParam);
            }
            break;

        case DCS_PASSCONTROL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->DCS_PassControl((UINT)wParam, (UINT)lParam);
            }
            break;

        case DCS_GIVECONTROL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->DCS_GiveControl((UINT)wParam);
            }
            break;

        case DCS_CANCELGIVECONTROL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->DCS_CancelGiveControl((UINT)wParam);
            }
            break;

        case DCS_REVOKECONTROL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->DCS_RevokeControl((UINT)wParam);
            }
            break;

        case DCS_PAUSECONTROL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->DCS_PauseControl((UINT)lParam, (BOOL)wParam != 0);
            }
            break;

        case DCS_NEWTOPLEVEL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->HET_HandleNewTopLevel((BOOL)wParam);
            }
            break;

        case DCS_RECOUNTTOPLEVEL_MSG:
            if (g_asSession.pShare)
            {
                g_asSession.pShare->HET_HandleRecountTopLevel((UINT)wParam);
            }
            break;

        default:
            rc = DefWindowProc(hwnd, message, wParam, lParam);
            break;
    }

    DebugExitDWORD(DCSMainWndProc, rc);
    return(rc);
}


//
// DCS_Share()
//
void DCS_Share(HWND hwnd, IAS_SHARE_TYPE uType)
{
    DWORD   dwAppID;

    DebugEntry(DCS_Share);

    if (!g_asSession.pShare)
    {
        //
        // Create one.
        //
        if (!SC_CreateShare(S20_CREATE))
        {
            WARNING_OUT(("Failing share request; in wrong state"));
            DC_QUIT;
        }
    }

    ASSERT(g_asSession.pShare);

    //
    // Figure out what to do.
    //
    if (hwnd == ::GetDesktopWindow())
    {
        g_asSession.pShare->HET_ShareDesktop();
    }
    else
    {
        DWORD   dwThreadID;
        DWORD   dwProcessID;

        dwThreadID = GetWindowThreadProcessId(hwnd, &dwProcessID);
        if (!dwThreadID)
        {
            WARNING_OUT(("Failing share request, window %08lx is invalid", hwnd));
            DC_QUIT;
        }

        //
        // If caller didn't specify exactly what they want, figure it out
        //
        if (uType == IAS_SHARE_DEFAULT)
        {
            if (OSI_IsWOWWindow(hwnd))
                uType = IAS_SHARE_BYTHREAD;
            else
                uType = IAS_SHARE_BYPROCESS;
        }

        if (uType == IAS_SHARE_BYPROCESS)
            dwAppID = dwProcessID;
        else if (uType == IAS_SHARE_BYTHREAD)
            dwAppID = dwThreadID;
        else if (uType == IAS_SHARE_BYWINDOW)
            dwAppID = HandleToUlong(hwnd);

        if (IsIconic(hwnd))
            ShowWindow(hwnd, SW_SHOWNOACTIVATE);

        g_asSession.pShare->HET_ShareApp(uType, dwAppID);
    }

DC_EXIT_POINT:
    DebugExitVOID(DCS_Share);
}



//
// DCS_Unshare()
//
void DCS_Unshare(HWND hwnd)
{
    DebugEntry(DCS_Unshare);

    if (!g_asSession.pShare || !g_asSession.pShare->m_pHost)
    {
        WARNING_OUT(("Failing unshare, nothing is shared by us"));
        DC_QUIT;
    }

    if ((hwnd == HWND_BROADCAST) || (hwnd == ::GetDesktopWindow()))
    {
        // Unshare everything.
        g_asSession.pShare->HET_UnshareAll();
    }
    else
    {
        DWORD       idProcess;
        DWORD       idThread;
        DWORD       dwAppID;
        UINT        hostType;

        hostType = (UINT)HET_GetHosting(hwnd);
        if (!hostType)
        {
            WARNING_OUT(("Window %08lx is not shared", hwnd));
            DC_QUIT;
        }

        idThread = GetWindowThreadProcessId(hwnd, &idProcess);
        if (!idThread)
        {
            WARNING_OUT(("Window %08lx is gone", hwnd));
            DC_QUIT;
        }

        if (hostType & HET_HOSTED_BYPROCESS)
        {
            hostType = IAS_SHARE_BYPROCESS;
            dwAppID = idProcess;
        }
        else if (hostType & HET_HOSTED_BYTHREAD)
        {
            hostType = IAS_SHARE_BYTHREAD;
            dwAppID = idThread;
        }
        else
        {
            ASSERT(hostType & HET_HOSTED_BYWINDOW);
            hostType = IAS_SHARE_BYWINDOW;
            dwAppID = HandleToUlong(hwnd);
        }

        g_asSession.pShare->HET_UnshareApp(hostType, dwAppID);
    }

DC_EXIT_POINT:
    DebugExitVOID(DCS_Unshare);
}


//
// DCSGetPerson()
//
// Validates GCC ID passed in, returns non-null ASPerson * if all is cool.
//
ASPerson * ASShare::DCSGetPerson(UINT gccID, BOOL fNull)
{
    ASPerson * pasPerson = NULL;

    //
    // Special value?
    //
    if (!gccID)
    {
        if (fNull)
        {
            pasPerson = m_pasLocal->m_caInControlOf;
        }
    }
    else
    {
        pasPerson = SC_PersonFromGccID(gccID);
    }

    if (!pasPerson)
    {
        WARNING_OUT(("Person [%d] not in share", gccID));
    }
    else if (pasPerson == m_pasLocal)
    {
        ERROR_OUT(("Local person [%d] was passed in", gccID));
        pasPerson = NULL;
    }

    return(pasPerson);
}

//
// DCS_TakeControl()
//
void ASShare::DCS_TakeControl(UINT gccOf)
{
    ASPerson * pasHost;

    DebugEntry(ASShare::DCS_TakeControl);

    pasHost = DCSGetPerson(gccOf, FALSE);
    if (!pasHost)
    {
        WARNING_OUT(("DCS_TakeControl: ignoring, host [%d] not valid", gccOf));
        DC_QUIT;
    }

    CA_TakeControl(pasHost);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::DCS_TakeControl);
}



//
// DCS_CancelTakeControl()
//
void ASShare::DCS_CancelTakeControl(UINT gccOf)
{
    ASPerson * pasHost;

    DebugEntry(ASShare::DCS_CancelTakeControl);

    if (!gccOf)
    {
        pasHost = m_caWaitingForReplyFrom;
    }
    else
    {
        pasHost = DCSGetPerson(gccOf, FALSE);
    }

    if (!pasHost)
    {
        WARNING_OUT(("DCS_CancelTakeControl: Ignoring, host [%d] not valid", gccOf));
        DC_QUIT;
    }

    CA_CancelTakeControl(pasHost, TRUE);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::DCS_CancelTakeControl);
}


//
// DCS_ReleaseControl()
//
void ASShare::DCS_ReleaseControl(UINT gccOf)
{
    ASPerson * pasHost;

    DebugEntry(ASShare::DCS_ReleaseControl);

    //
    // Validate host
    //
    pasHost = DCSGetPerson(gccOf, TRUE);
    if (!pasHost)
    {
        WARNING_OUT(("DCS_ReleaseControl: ignoring, host [%d] not valid", gccOf));
        DC_QUIT;
    }

    CA_ReleaseControl(pasHost, TRUE);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::DCS_ReleaseControl);
}



//
// DCS_PassControl()
//
void ASShare::DCS_PassControl(UINT gccOf, UINT gccTo)
{
    ASPerson *  pasHost;
    ASPerson *  pasControllerNew;

    DebugEntry(ASShare::DCS_PassControl);

    //
    // Validate host
    //
    pasHost = DCSGetPerson(gccOf, TRUE);
    if (!pasHost)
    {
        WARNING_OUT(("DCS_PassControl: ignoring, host [%d] not valid", gccTo));
        DC_QUIT;
    }

    //
    // Validate new controller
    //
    pasControllerNew = DCSGetPerson(gccTo, FALSE);
    if (!pasControllerNew)
    {
        WARNING_OUT(("DCS_PassControl: ignoring, viewer [%d] not valid", gccTo));
        DC_QUIT;
    }

    if (pasControllerNew == pasHost)
    {
        ERROR_OUT(("DCS_PassControl: ignoring, pass of == pass to [%d]", pasControllerNew->mcsID));
        DC_QUIT;
    }

    CA_PassControl(pasHost, pasControllerNew);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::DCS_PassControl);
}



//
// DCS_GiveControl()
//
void ASShare::DCS_GiveControl(UINT gccTo)
{
    ASPerson * pasViewer;

    DebugEntry(ASShare::DCS_GiveControl);

    //
    // Validate viewer
    //
    pasViewer = DCSGetPerson(gccTo, FALSE);
    if (!pasViewer)
    {
        WARNING_OUT(("DCS_GiveControl: ignoring, viewer [%d] not valid", gccTo));
        DC_QUIT;
    }

    CA_GiveControl(pasViewer);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::DCS_GiveControl);
}



//
// DCS_CancelGiveControl()
//
void ASShare::DCS_CancelGiveControl(UINT gccTo)
{
    ASPerson * pasTo;

    DebugEntry(ASShare::DCS_CancelGiveControl);

    if (!gccTo)
    {
        pasTo = m_caWaitingForReplyFrom;
    }
    else
    {
        pasTo = DCSGetPerson(gccTo, FALSE);
    }

    if (!pasTo)
    {
        WARNING_OUT(("DCS_CancelGiveControl: Ignoring, person [%d] not valid", gccTo));
        DC_QUIT;
    }

    CA_CancelGiveControl(pasTo, TRUE);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::DCS_CancelGiveControl);
}



//
// DCS_RevokeControl()
//
void ASShare::DCS_RevokeControl(UINT gccController)
{
    ASPerson * pasController;

    DebugEntry(ASShare::DCS_RevokeControl);

    if (!gccController)
    {
        // Special value:  match whomever is controlling us
        pasController = m_pasLocal->m_caControlledBy;
    }
    else
    {
        pasController = DCSGetPerson(gccController, FALSE);
    }

    if (!pasController)
    {
        WARNING_OUT(("DCS_RevokeControl: ignoring, controller [%d] not valid", gccController));
        DC_QUIT;
    }

    CA_RevokeControl(pasController, TRUE);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::DCS_RevokeControl);
}




//
// DCS_PauseControl()
//
void ASShare::DCS_PauseControl(UINT gccOf, BOOL fPause)
{
    ASPerson *  pasControlledBy;

    DebugEntry(ASShare::DCS_PauseControl);

    if (!gccOf)
    {
        pasControlledBy = m_pasLocal->m_caControlledBy;
    }
    else
    {
        pasControlledBy = DCSGetPerson(gccOf, FALSE);
    }

    if (!pasControlledBy)
    {
        WARNING_OUT(("DCS_PauseControl: ignoring, controller [%d] not valid", gccOf));
        DC_QUIT;
    }

    CA_PauseControl(pasControlledBy, fPause, TRUE);

DC_EXIT_POINT:
    DebugExitVOID(ASShare::DCS_PauseControl);
}



//
// SHP_LaunchHostUI()
//
// Posts a message to start or activate the host UI.
//
HRESULT SHP_LaunchHostUI(void)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_LaunchHostUI);

    if (g_asSession.hwndHostUI &&
        PostMessage(g_asSession.hwndHostUI, HOST_MSG_OPEN, 0, 0))
    {
        hr = S_OK;
    }

    DebugExitHRESULT(SHP_LaunchHostUI, hr);
    return(hr);
}


//
// SHP_Share
//
BOOL  SHP_Share
(
    HWND            hwnd,
    IAS_SHARE_TYPE  uType
)
{
    BOOL        rc = FALSE;

    DebugEntry(SHP_ShareApp);

    if (g_asSession.hwndHostUI)
    {
        rc = PostMessage(g_asMainWindow, DCS_SHARE_MSG, uType, (LPARAM)hwnd);
    }
    else
    {
        ERROR_OUT(("SHP_Share: not able to share"));
    }

    DebugExitBOOL(SHP_ShareApp, rc);
    return(rc);
}



//
// SHP_Unshare()
//
// For unsharing, we use a window.  The window has all the information
// we need to stop sharing already set in its host prop.
//
HRESULT SHP_Unshare(HWND hwnd)
{
    HRESULT     hr = E_FAIL;

    DebugEntry(SHP_Unshare);

    if (g_asSession.hwndHostUI)
    {
        if (PostMessage(g_asMainWindow, DCS_UNSHARE_MSG, 0, (LPARAM)hwnd))
        {
            hr = S_OK;
        }
    }
    else
    {
        ERROR_OUT(("SHP_Unshare: not able to share"));
    }

    DebugExitHRESULT(SHP_Unshare, hr);
    return(hr);
}



//
// SHP_TakeControl()
// Request to take control of a remote host.
//      PersonOf is the GCC id of the remote.
//
HRESULT  SHP_TakeControl(IAS_GCC_ID PersonOf)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_TakeControl);

    if (g_asMainWindow &&
        PostMessage(g_asMainWindow, DCS_TAKECONTROL_MSG, PersonOf, 0))
    {
        hr = S_OK;
    }

    DebugExitHRESULT(SHP_TakeControl, hr);
    return(hr);
}



//
// SHP_CancelTakeControl()
// Cancel request to take control of a remote host.
//      PersonOf is the GCC id of the remote.
//
HRESULT  SHP_CancelTakeControl(IAS_GCC_ID PersonOf)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_CancelTakeControl);

    if (g_asMainWindow &&
        PostMessage(g_asMainWindow, DCS_CANCELTAKECONTROL_MSG, PersonOf, 0))
    {
        hr = S_OK;
    }

    DebugExitHRESULT(SHP_CancelTakeControl, hr);
    return(hr);
}



//
// SHP_ReleaseControl()
// Release control of a remote host.
//      PersonOf is the GCC id of the remote we are currently controlling
//          and wish to stop.  Zero means "whomever" we are in control of
//          at the time.
//
HRESULT SHP_ReleaseControl(IAS_GCC_ID PersonOf)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_ReleaseControl);

    if (g_asMainWindow &&
        PostMessage(g_asMainWindow, DCS_RELEASECONTROL_MSG, PersonOf, 0))
    {
        hr = S_OK;
    }

    DebugExitHRESULT(SHP_ReleaseControl, hr);
    return(hr);
}



//
// SHP_PassControl()
// Pass control of a remote to another prerson.
//      PersonOf is the GCC id of the remote we are currently controlling
//      PersonTo is the GCC id of the remote we wish to pass control to
//
HRESULT SHP_PassControl(IAS_GCC_ID PersonOf, IAS_GCC_ID PersonTo)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_PassControl);

    if (g_asMainWindow &&
        PostMessage(g_asMainWindow, DCS_PASSCONTROL_MSG, PersonOf, PersonTo))
    {
        hr = S_OK;
    }

    DebugExitHRESULT(SHP_PassControl, hr);
    return(hr);
}


//
// SHP_AllowControl()
// Toggle the ability for remotes to control us (when we are sharing stuff)
//
HRESULT SHP_AllowControl(BOOL fAllowed)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_AllowControl);

    if (!g_asSession.hwndHostUI)
    {
        ERROR_OUT(("SHP_AllowControl failing, can't host"));
        DC_QUIT;

    }

    if (g_asPolicies & SHP_POLICY_NOCONTROL)
    {
        ERROR_OUT(("SHP_AllowControl failing. prevented by policy"));
        DC_QUIT;
    }

    if (PostMessage(g_asMainWindow, DCS_ALLOWCONTROL_MSG, fAllowed, 0))
    {
        hr = S_OK;
    }

DC_EXIT_POINT:
    DebugExitHRESULT(SHP_AllowControl, hr);
    return(hr);
}



//
// SHP_GiveControl()
//
// Give control of our shared stuff to a remote.
//
HRESULT SHP_GiveControl(IAS_GCC_ID PersonTo)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_GiveControl);

    if (g_asMainWindow &&
        PostMessage(g_asMainWindow, DCS_GIVECONTROL_MSG, PersonTo, 0))
    {
        hr = S_OK;
    }

    DebugExitHRESULT(SHP_GiveControl, hr);
    return(hr);
}



//
// SHP_CancelGiveControl()
//
// Cancel giving control of our shared stuff to a remote.
//
HRESULT SHP_CancelGiveControl(IAS_GCC_ID PersonTo)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_CancelGiveControl);

    if (g_asMainWindow &&
        PostMessage(g_asMainWindow, DCS_CANCELGIVECONTROL_MSG, PersonTo, 0))
    {
        hr = S_OK;
    }

    DebugExitHRESULT(SHP_CancelGiveControl, hr);
    return(hr);
}





//
// SHP_RevokeControl()
// Take control away from a remote who is in control of us.
//
// NOTE:
// SHP_AllowControl(FALSE) will of course revoke control if someone is
// in control of us at the time.
//
HRESULT SHP_RevokeControl(IAS_GCC_ID PersonTo)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_RevokeControl);

    if (g_asMainWindow &&
        PostMessage(g_asMainWindow, DCS_REVOKECONTROL_MSG, PersonTo, 0))
    {
        hr = S_OK;
    }

    DebugExitHRESULT(SHP_RevokeControl, hr);
    return(hr);
}




//
// SHP_PauseControl()
// Pause or unpause control, when we are controlled by a remote
//
HRESULT SHP_PauseControl(IAS_GCC_ID PersonControlledBy, BOOL fPause)
{
    HRESULT hr = E_FAIL;

    DebugEntry(SHP_PauseControl);

    if (g_asMainWindow &&
        PostMessage(g_asMainWindow, DCS_PAUSECONTROL_MSG, fPause, PersonControlledBy))
    {
        hr = S_OK;
    }

    DebugExitHRESULT(SHP_PauseControl, hr);
    return(hr);
}



//
// SHP_GetPersonStatus()
//
HRESULT  SHP_GetPersonStatus(IAS_GCC_ID Person, IAS_PERSON_STATUS * pStatus)
{
    HRESULT     hr = E_FAIL;
    UINT        cbSize;

    DebugEntry(SHP_GetPersonStatus);

    UT_Lock(UTLOCK_AS);

    if (IsBadWritePtr(pStatus, sizeof(*pStatus)))
    {
        ERROR_OUT(("SHP_GetPersonStatus failing; IAS_PERSON_STATUS pointer is bogus"));
        DC_QUIT;
    }

    //
    // Check that size field is filled in properly
    //
    cbSize = pStatus->cbSize;
    if (cbSize != sizeof(*pStatus))
    {
        ERROR_OUT(("SHP_GetPersonStatus failing; cbSize field not right"));
        DC_QUIT;
    }

    //
    // First, clear the structure
    //
    ::ZeroMemory(pStatus, cbSize);
    pStatus->cbSize = cbSize;

    //
    // Is AS present?
    //
    if (!g_asMainWindow)
    {
        ERROR_OUT(("SHP_GetPersonStatus failing; AS not present"));
        DC_QUIT;
    }

    //
    // Are we in a share?
    //
    if (g_asSession.pShare)
    {
        ASPerson * pasT;

        //
        // Find this person
        //
        if (!Person)
        {
            Person = g_asSession.gccID;
        }

        for (pasT = g_asSession.pShare->m_pasLocal; pasT != NULL; pasT = pasT->pasNext)
        {
            if (pasT->cpcCaps.share.gccID == Person)
            {
                ASPerson * pTemp;

                //
                // Found it
                //
                pStatus->InShare = TRUE;

                switch (pasT->cpcCaps.general.version)
                {
                    case CAPS_VERSION_20:
                        pStatus->Version = IAS_VERSION_20;
                        break;

                    case CAPS_VERSION_30:
                        pStatus->Version = IAS_VERSION_30;
                        break;

                    default:
                        ERROR_OUT(("Unknown version %d", pasT->cpcCaps.general.version));
                        break;
                }

                if (pasT->hetCount == HET_DESKTOPSHARED)
                    pStatus->AreSharing = IAS_SHARING_DESKTOP;
                else if (pasT->hetCount)
                    pStatus->AreSharing = IAS_SHARING_APPLICATIONS;
                else
                    pStatus->AreSharing = IAS_SHARING_NOTHING;

                pStatus->Controllable = pasT->m_caAllowControl;

                //
                // We MUST assign to avoid faults.
                //
                pTemp = pasT->m_caInControlOf;
                if (pTemp)
                {
                    pStatus->InControlOf = pTemp->cpcCaps.share.gccID;
                }
                else
                {
                    pTemp = pasT->m_caControlledBy;
                    if (pTemp)
                    {
                        pStatus->ControlledBy = pTemp->cpcCaps.share.gccID;
                    }
                }

                pStatus->IsPaused = pasT->m_caControlPaused;

                //
                // We MUST assign to avoid faults.
                //
                pTemp = g_asSession.pShare->m_caWaitingForReplyFrom;
                if (pTemp)
                {
                    if (pasT == g_asSession.pShare->m_pasLocal)
                    {
                        //
                        // We have an outstanding request to this dude.
                        //
                        switch (g_asSession.pShare->m_caWaitingForReplyMsg)
                        {
                            case CA_REPLY_REQUEST_TAKECONTROL:
                                pStatus->InControlOfPending = pTemp->cpcCaps.share.gccID;
                                break;

                            case CA_REPLY_REQUEST_GIVECONTROL:
                                pStatus->ControlledByPending = pTemp->cpcCaps.share.gccID;
                                break;
                        }
                    }
                    else if (pasT == pTemp)
                    {
                        //
                        // This dude has an outstanding request from us.
                        //
                        switch (g_asSession.pShare->m_caWaitingForReplyMsg)
                        {
                            case CA_REPLY_REQUEST_TAKECONTROL:
                                pStatus->ControlledByPending = g_asSession.pShare->m_pasLocal->cpcCaps.share.gccID;
                                break;

                            case CA_REPLY_REQUEST_GIVECONTROL:
                                pStatus->InControlOfPending = g_asSession.pShare->m_pasLocal->cpcCaps.share.gccID;
                                break;
                        }
                    }
                }

                break;
            }
        }
    }

    hr = S_OK;

DC_EXIT_POINT:
    UT_Unlock(UTLOCK_AS);
    DebugExitHRESULT(SHP_GetPersonStatus, hr);
    return(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\enduser\netmeeting\as\cpi32\fh.cpp ===
#include "precomp.h"


//
// FH.CPP
// Font Handling
//
// Copyright(c) Microsoft 1997-
//

#define MLZ_FILE_ZONE  ZONE_CORE



//
// FH_Init()
//
// This routine allocates a structure for the local font list, then fills
// it in.  It returns the number of local fonts in the list, or zero if
// something went wrong
//
UINT FH_Init(void)
{
    UINT    cFonts = 0;

    DebugEntry(FH_Init);

    //
    // Create the font array and the font index array
    //
    g_fhFonts = new FHLOCALFONTS;
    if (!g_fhFonts)
    {
        ERROR_OUT(("FH_Init: couldn't allocate g_fhFonts local list"));
        DC_QUIT;
    }

    ZeroMemory(g_fhFonts, sizeof(FHLOCALFONTS));
    SET_STAMP(g_fhFonts, FHLOCALFONTS);

    //
    // Now we consider the fonts individually, and store all acceptable
    // ones in the local font list.
    //
    FHConsiderAllLocalFonts();

    cFonts = g_fhFonts->fhNumFonts;
    if (cFonts)
    {
        FHSortAndIndexLocalFonts();
    }
    else
    {
        WARNING_OUT(( "No fonts found - this seems unlikely"));
    }

DC_EXIT_POINT:
    DebugExitDWORD(FH_Init, cFonts);
    return(cFonts);
}


//
// FH_Term()
//
void FH_Term(void)
{
    DebugEntry(FH_Term);

    if (g_fhFonts)
    {
        delete g_fhFonts;
        g_fhFonts = NULL;
    }

    DebugExitVOID(FH_Term);
}


//
// FH_ReceivedPacket - see fh.h
//
void  ASShare::FH_ReceivedPacket
(
    ASPerson *      pasPerson,
    PS20DATAPACKET  pPacket
)
{
    PFHPACKET       pFontsPacket;
    UINT            iLocal;
    UINT            iRemote;
    LPNETWORKFONT   pRemoteFont;
    POEREMOTEFONT   pLocalFont;
    UINT            cbSize;

    DebugEntry(ASShare::FH_ReceivedPacket);

    ValidatePerson(pasPerson);

    pFontsPacket = (PFHPACKET)pPacket;

    //
    // If the number we received isn't the same as before, we need to
    // possibly free the previous font block, and then allocate a new one.
    //
    // Once we're in a share with this person, every new joiner will cause
    // existing members to resend their local fonts, usually the same size.
    // So we can optimize and not realloc in that case.
    //
    if (pFontsPacket->cFonts != pasPerson->oecFonts)
    {
        if (pasPerson->poeFontInfo)
        {
            delete[] pasPerson->poeFontInfo;
            pasPerson->poeFontInfo = NULL;
            pasPerson->oecFonts = 0;
        }
        else
        {
            ASSERT(!pasPerson->oecFonts);
        }

        //
        // Allocate a new block
        //
        pasPerson->poeFontInfo = new OEREMOTEFONT[pFontsPacket->cFonts];
        if (!pasPerson->poeFontInfo)
        {
            ERROR_OUT(("Couldn't allocate %d fonts for FH packet from [%d]",
                pasPerson->mcsID));
            DC_QUIT;
        }

        ZeroMemory(pasPerson->poeFontInfo, pFontsPacket->cFonts * sizeof(OEREMOTEFONT));
        pasPerson->oecFonts = pFontsPacket->cFonts;
    }


    TRACE_OUT(("Received %d remote fonts in packet from person [%d]",
        pasPerson->oecFonts, pasPerson->mcsID));

    //
    // Consider each remote font. The multibyte fields of the NETWORKFONT
    // structure are flipped as they are read; otherwise we would have to
    // duplicate the logic about which fields are present in which version.
    //

    //
    // The size of each font is in the packet.
    //
    cbSize      = pFontsPacket->cbFontSize;
    pRemoteFont = pFontsPacket->aFonts;
    pLocalFont  = pasPerson->poeFontInfo;

    for (iRemote = 0; iRemote < pasPerson->oecFonts; iRemote++, pLocalFont++)
    {
        //
        // Copy the fields we store directly.
        //
        pLocalFont->rfFontFlags     = pRemoteFont->nfFontFlags;
        pLocalFont->rfAveWidth      = pRemoteFont->nfAveWidth;
        pLocalFont->rfAveHeight     = pRemoteFont->nfAveHeight;
        pLocalFont->rfAspectX       = pRemoteFont->nfAspectX;
        pLocalFont->rfAspectY       = pRemoteFont->nfAspectY;

        //
        // And the R2.0 field(s)...
        //
        if (m_oeCombinedOrderCaps.capsfFonts & CAPS_FONT_CODEPAGE)
        {
            pLocalFont->rfCodePage = pRemoteFont->nfCodePage;
        }
        //
        // And the other R2.0 field(s)...
        //
        if (m_oeCombinedOrderCaps.capsfFonts & CAPS_FONT_R20_SIGNATURE)
        {
            pLocalFont->rfSigFats    = pRemoteFont->nfSigFats;
            pLocalFont->rfSigThins   = pRemoteFont->nfSigThins;
            pLocalFont->rfSigSymbol  = pRemoteFont->nfSigSymbol;
        }
        if (m_oeCombinedOrderCaps.capsfFonts & CAPS_FONT_EM_HEIGHT)
        {
            pLocalFont->rfMaxAscent  = pRemoteFont->nfMaxAscent;
            TRACE_OUT(( "maxAscent %hd", pLocalFont->rfMaxAscent));
        }

        //
        // Set up an initial remote to local handle mapping, by scanning
        // for the first local font with the remote font's facename.
        //
        // We first set a default match value, in case we dont find a true
        // match - this value should never be referenced since we never get
        // sent fonts that we can't match (because we sent details of our
        // fonts to remote systems, and they should be using the same, or a
        // compatible, font matching algorithm.
        //
        // The mapping we obtain here is to the first local font that has
        // the remote font's facename, which is probably not the correct
        // font (ie there are probably multiple fonts with the same
        // facename).  This initial mapping will be updated when we do the
        // full matching for all remote fonts.  (See FHConsiderRemoteFonts
        // for details), but is sufficient, as all we will use it for until
        // then, is to obtain the facename.
        //
        // This approach means that we do not have to store the remote
        // facename, which is a useful saving on remote font details space.
        //
        // SFR5279: cannot default to zero because that means we give a
        // name to fonts that do not in fact match at all, causing us to
        // always waste effort in FHConsiderRemoteFonts and sometimes to
        // wrongly match two fonts that do not really match at all.
        //
        pLocalFont->rfLocalHandle= NO_FONT_MATCH;

        for (iLocal = 0; iLocal < g_fhFonts->fhNumFonts; iLocal++)
        {
            if (!lstrcmp(g_fhFonts->afhFonts[iLocal].Details.nfFaceName,
                          pRemoteFont->nfFaceName))
            {
                pLocalFont->rfLocalHandle = (TSHR_UINT16)iLocal;
                break;
            }
        }

        //
        // Advance to the next remote font.
        //
        pRemoteFont = (LPNETWORKFONT)((LPBYTE)pRemoteFont + cbSize);
    }

DC_EXIT_POINT:
    //
    // We have a new set of fonts, so determine the common list.
    //
    FH_DetermineFontSupport();

    DebugExitVOID(ASShare::FH_ReceivedPacket);
}

//
// FH_SendLocalFontInfo()
//
void ASShare::FH_SendLocalFontInfo(void)
{
    PFHPACKET       pFontPacket = NULL;
    LPBYTE          pNetworkFonts;
    UINT            pktSize;
    UINT            iFont;
    BOOL            fSendFont;
    UINT            cDummyFonts = 0;
#ifdef _DEBUG
    UINT            sentSize;
#endif // _DEBUG

    DebugEntry(ASShare::FH_SendLocalFontInfo);

    ASSERT(!m_fhLocalInfoSent);

    //
    //
    // Look at the combined capability flags to see whether the remote(s)
    // can cope with our preferred font structure (R20) or a slightly
    // older one (R11) or only the original flavor (pre R11).
    //
    //
    if (!(m_oeCombinedOrderCaps.capsfFonts & CAPS_FONT_R20_TEST_FLAGS))
    {
        WARNING_OUT(("Remotes in share don't support CAPS_FONT_R20"));
        m_fhLocalInfoSent = TRUE;
        DC_QUIT;
    }

    pktSize = sizeof(FHPACKET) + (g_fhFonts->fhNumFonts - 1) * sizeof(NETWORKFONT);
    pFontPacket = (PFHPACKET)SC_AllocPkt(PROT_STR_MISC, g_s20BroadcastID, pktSize);
    if (!pFontPacket)
    {
        WARNING_OUT(("Failed to alloc FH packet, size %u", pktSize));
        DC_QUIT;
    }

    //
    // Packet successfully allocated.  Fill in the data and send it.
    //
    pFontPacket->header.data.dataType = DT_FH;

    pFontPacket->cbFontSize = sizeof(NETWORKFONT);

    //
    // Copy the fonts we want to send into the network packet.
    //
    pNetworkFonts = (LPBYTE)pFontPacket->aFonts;
    cDummyFonts = 0;
    for (iFont = 0 ; iFont < g_fhFonts->fhNumFonts ; iFont++)
    {
        //
        // Assume we will send this font.
        //
        fSendFont = TRUE;

        //
        // Check whether font is ANSI charset or font CodePage capability
        // is supported.  If neither, skip on to next local font.
        //
        TRACE_OUT(( "TEST CP set OK: font[%u] CodePage[%hu]", iFont,
                                g_fhFonts->afhFonts[iFont].Details.nfCodePage));

        if ((g_fhFonts->afhFonts[iFont].Details.nfCodePage != ANSI_CHARSET) &&
            (!(m_oeCombinedOrderCaps.capsfFonts & CAPS_FONT_CODEPAGE))   )
        {
            TRACE_OUT(( "Dont send font[%u] CodePage[%hu]", iFont,
                                g_fhFonts->afhFonts[iFont].Details.nfCodePage));
            fSendFont = FALSE;
        }

        if (fSendFont)
        {
            //
            // We want to send this entry so copy across as much of the
            // stored details as the protocol level requires.
            // We then mask the flags and advance to the next location in
            // the packet.
            //
            memcpy(pNetworkFonts,
                      &g_fhFonts->afhFonts[iFont].Details,
                      sizeof(NETWORKFONT));

            ((LPNETWORKFONT)pNetworkFonts)->nfFontFlags &= ~NF_LOCAL;
        }
        else
        {
            //
            // If we determine that we do not want to send the current
            // font then we fill the corresponding entry in the network
            // packet with zeros. This ensures that an index into our
            // local font table is also an index into the network packet,
            // so no conversion is required. Setting the whole entry to
            // zero gives the font a NULL facename and zero size, which
            // will never match a real font.
            //
            ZeroMemory(pNetworkFonts, sizeof(NETWORKFONT));
            cDummyFonts++;
        }

        //
        // Move to the next entry in the font packet.
        //
        pNetworkFonts += sizeof(NETWORKFONT);
    }

    //
    // Note that at the end of this loop, we may not have sent any fonts,
    // eg where the remote system does not support the font CodePage
    // capability and we do not have any true ANSI fonts.  We send the
    // packet anyway, so the remote system sees that we have no fonts to
    // match.
    //

    //
    // Only now do we know the number of fonts we actually put in the
    // packet.
    //
    pFontPacket->cFonts = (TSHR_UINT16)g_fhFonts->fhNumFonts;

    //
    // Send the fonts packet on the MISC stream.  It has no dependency on
    // any updates and we want it to get across quickly.
    //
    if (m_scfViewSelf)
        FH_ReceivedPacket(m_pasLocal, &(pFontPacket->header));

#ifdef _DEBUG
    sentSize =
#endif // _DEBUG
    DCS_CompressAndSendPacket(PROT_STR_MISC, g_s20BroadcastID,
        &(pFontPacket->header), pktSize);

    TRACE_OUT(("FH packet size: %08d, sent %08d", pktSize, sentSize));
    TRACE_OUT(( "Sent font packet with %u fonts (inc %u dummies)",
                 g_fhFonts->fhNumFonts,
                 cDummyFonts));

    //
    // Set the flag that indicates that we have successfully sent the
    // font info.
    //
    m_fhLocalInfoSent = TRUE;

    //
    // The font info has been sent, so this may mean we can enable text
    // orders.
    //
    FHMaybeEnableText();

DC_EXIT_POINT:
    DebugExitVOID(ASShare::FH_SendLocalFontInfo);
}


//
// FUNCTION: FH_GetMaxHeightFromLocalHandle
//
// DESCRIPTION:
//
// Given an FH font handle (ie a handle originating from the locally
// supported font structure which was sent to the remote machine at the
// start of the call) this function returns the MaxBaseLineExt value stored
// with the LOCALFONT details
//
// PARAMETERS:
//
// fontHandle - font handle being queried.
//
// RETURNS: max font height
//
//
UINT  FH_GetMaxHeightFromLocalHandle(UINT  fontHandle)
{
    UINT rc;

    DebugEntry(FH_GetMaxHeightFromLocalHandle);

    //
    // First check that the font handle is valid.
    //
    if (fontHandle >= g_fhFonts->fhNumFonts)
    {
        ERROR_OUT(( "Invalid font handle %u", fontHandle));
        fontHandle = 0;
    }

    //
    // Return the max font height
    //
    rc = g_fhFonts->afhFonts[fontHandle].lMaxBaselineExt;

    DebugExitDWORD(FH_GetMaxHeightFromLocalHandle, rc);
    return(rc);
}


//
// FUNCTION: FH_GetFontFlagsFromLocalHandle
//
// DESCRIPTION:
//
// Given an FH font handle (ie a handle originating from the locally
// supported font structure which was sent to the remote machine at the
// start of the call) this function returns the FontFlags value stored with
// the LOCALFONT details
//
// PARAMETERS:
//
// fontHandle - font handle being queried.
//
// RETURNS: font flags
//
//
UINT  FH_GetFontFlagsFromLocalHandle(UINT  fontHandle)
{
    UINT rc;

    DebugEntry(FH_GetFontFlagsFromLocalHandle);

    //
    // First check that the font handle is valid.
    //
    if (fontHandle >= g_fhFonts->fhNumFonts)
    {
        ERROR_OUT(( "Invalid font handle %u", fontHandle));
        fontHandle = 0;
    }

    //
    // Return the font flags.
    //
    rc = g_fhFonts->afhFonts[fontHandle].Details.nfFontFlags;

    DebugExitDWORD(FH_GetFontFlagsFromLocalHandle, rc);
    return(rc);
}

//
// FUNCTION: FH_GetCodePageFromLocalHandle
//
// DESCRIPTION:
//
// Given an FH font handle (ie a handle originating from the locally
// supported font structure which was sent to the remote machine at the
// start of the call) this function returns the CodePage value stored with
// the LOCALFONT details
//
// PARAMETERS:
//
// fontHandle - font handle being queried.
//
// RETURNS: char set
//
//
UINT  FH_GetCodePageFromLocalHandle(UINT  fontHandle)
{
    UINT rc = 0;

    DebugEntry(FH_GetCodePageFromLocalHandle);

    //
    // First check that the font handle is valid.
    //
    if (fontHandle >= g_fhFonts->fhNumFonts)
    {
        ERROR_OUT(( "Invalid font handle %u", fontHandle));
        fontHandle = 0;
    }

    //
    // Return the char set.
    //
    rc = g_fhFonts->afhFonts[fontHandle].Details.nfCodePage;

    DebugExitDWORD(FH_GetCodePageFromLocalHandle, rc);
    return(rc);
}



//
// FH_ConvertAnyFontIDToLocal()
//
// DESCRIPTION:
// Converts any font name ID fields in the passed order from remote font
// face name IDs to local font facename IDs.
//
void  ASShare::FH_ConvertAnyFontIDToLocal
(
    LPCOM_ORDER pOrder,
    ASPerson *  pasPerson
)
{
    LPCOMMON_TEXTORDER   pCommon = NULL;

    DebugEntry(ASShare::FH_ConvertAnyFontIDToLocal);

    ValidatePerson(pasPerson);

    //
    // Get a pointer to the structure which is common to both TextOut and
    // ExtTextOut
    //
    if (TEXTFIELD(pOrder)->type == LOWORD(ORD_TEXTOUT))
    {
        pCommon = &TEXTFIELD(pOrder)->common;
    }
    else if (EXTTEXTFIELD(pOrder)->type == LOWORD(ORD_EXTTEXTOUT))
    {
        pCommon = &EXTTEXTFIELD(pOrder)->common;
    }
    else
    {
        ERROR_OUT(( "Order type not TextOut or ExtTextOut."));
        DC_QUIT;
    }

    TRACE_OUT(( "fonthandle IN %lu", pCommon->FontIndex));
    pCommon->FontIndex = FHGetLocalFontHandle(pCommon->FontIndex, pasPerson);
    TRACE_OUT(( "fonthandle OUT %lu", pCommon->FontIndex));

DC_EXIT_POINT:
    DebugExitVOID(ASShare::FH_ConvertAnyFontIDToLocal);
}

//
// FH_GetFaceNameFromLocalHandle - see fh.h
//
LPSTR  FH_GetFaceNameFromLocalHandle(UINT fontHandle, LPUINT pFaceNameLength)
{
    LPSTR pFontName = NULL;

    DebugEntry(FH_GetFaceNameFromLocalHandle);

    //
    // First check that the font handle is valid.
    //
    if (fontHandle >= g_fhFonts->fhNumFonts)
    {
        ERROR_OUT(( "Invalid font handle %u", fontHandle));
        fontHandle = 0;
    }

    //
    // Now get the facename
    //
    *pFaceNameLength = lstrlen(g_fhFonts->afhFonts[fontHandle].RealName);
    pFontName = g_fhFonts->afhFonts[fontHandle].RealName;

    DebugExitVOID(FH_GetFaceNameFromLocalHandle);
    return(pFontName);
}


//
// FH_DetermineFontSupport()
//
void  ASShare::FH_DetermineFontSupport(void)
{
    UINT            cCommonFonts;
    UINT            iLocal;
    ASPerson *      pasPerson;

    DebugEntry(ASShare::FH_DetermineFontSupport);

    //
    // First mark all local fonts as supported.
    //
    cCommonFonts = g_fhFonts->fhNumFonts;
    for (iLocal = 0; iLocal < g_fhFonts->fhNumFonts; iLocal++)
    {
        g_fhFonts->afhFonts[iLocal].SupportCode = FH_SC_EXACT_MATCH;
    }

    //
    // Work through all remote people (but not us)
    //
    ValidatePerson(m_pasLocal);

    for (pasPerson = m_pasLocal->pasNext;
        (cCommonFonts > 0) && (pasPerson != NULL);
        pasPerson = pasPerson->pasNext)
    {
        ValidatePerson(pasPerson);

        if (pasPerson->oecFonts)
        {
            cCommonFonts = FHConsiderRemoteFonts(cCommonFonts, pasPerson);
        }
        else
        {
            //
            // We do not have valid fonts for this person, so must not
            // send any text orders at all.
            //
            TRACE_OUT(( "Pending FONT INFO from person [%d]", pasPerson->mcsID));
            cCommonFonts = 0;
        }
    }

    //
    // We have determined the common supported fonts, and may be able to
    // enable text orders now.
    //
    FHMaybeEnableText();

    DebugExitVOID(ASShare::FH_DetermineFontSupport);
}



//
// FH_CreateAndSelectFont()
//
BOOL  FH_CreateAndSelectFont(HDC    surface,
                                                 HFONT*       pHNewFont,
                                                 HFONT*       pHOldFont,
                                                 LPSTR        fontName,
                                                 UINT         codepage,
                                                 UINT         fontMaxHeight,
                                                 UINT         fontHeight,
                                                 UINT         fontWidth,
                                                 UINT         fontWeight,
                                                 UINT         fontFlags)
{
    BOOL      rc;
    BYTE        italic;
    BYTE        underline;
    BYTE        strikeout;
    BYTE        pitch;
    BYTE        charset;
    BYTE        precis;

    DebugEntry(FH_CreateAndSelectFont);


    //
    // Set the return code to indicate failure (FALSE). We will change this
    // later if we successfully create the font.
    //
    rc = FALSE;

    //
    // Massage the data passed which describes the font into the correct
    // arrangement to pass on a create font call.  Then create a font.
    //

    //
    // If a facename passed is the null string then we are supposed to use
    // the system font.
    //
    if (fontName[0] == 0)
    {
        WARNING_OUT(( "Using system font"));
        *pHNewFont = GetStockFont(SYSTEM_FONT);
    }
    else
    {
        //
        // Determine the italic, underline, strikeout and pitch values from
        // the packed flags.
        //
        italic    = (BYTE)(fontFlags & NF_ITALIC);
        underline = (BYTE)(fontFlags & NF_UNDERLINE);
        strikeout = (BYTE)(fontFlags & NF_STRIKEOUT);

        if (fontFlags & NF_FIXED_PITCH)
        {
            pitch = FF_DONTCARE | FIXED_PITCH;
        }
        else
        {
            pitch = FF_DONTCARE | VARIABLE_PITCH;
        }

        //
        // Check whether this is a TrueType font.  This is important, as
        // the Windows Font mapper is biased towards non-TrueType, and it
        // is easy to do the subsequent decoding with a non-TrueType font.
        //
        // Note that the Windows headers do not define a name for the
        // required value (which is 0x04 in the manuals), so we use the
        // value used in the TextMetrics (which has the same value).
        //
        if (fontFlags & NF_TRUE_TYPE)
        {
            pitch |= TMPF_TRUETYPE;
            precis = OUT_TT_ONLY_PRECIS;
        }
        else
        {
            precis = OUT_RASTER_PRECIS;
        }

        //
        // The height we are passed is the character height, not the cell
        // height.  To indicate this to Windows we need to pass it in as a
        // negative value.
        //
        TRACE_OUT(( "CreateFont cx(%u) cy(%u) wt(%u) pitch(%u) name:%s",
                                                                 fontWidth,
                                                                 fontHeight,
                                                                 fontWeight,
                                                                 pitch,
                                                                 fontName ));

        //
        // Use the misleadingly named codepage value to calculate what
        // charset to ask Windows for.
        //
        if (codepage == NF_CP_WIN_ANSI)
        {
            charset = ANSI_CHARSET;
        }
        else if (codepage == NF_CP_WIN_OEM)
        {
            charset = OEM_CHARSET;
        }
        else if (codepage == NF_CP_WIN_SYMBOL)
        {
            charset = SYMBOL_CHARSET;
        }
        else
        {
            //
            // We have to trust our luck to Windows by specifying default
            // (meaning don't care).
            //
            charset = DEFAULT_CHARSET;
        }

        *pHNewFont = CreateFont(-(int)fontHeight,
                             fontWidth,
                             0,    // escapement
                             0,    // orientation
                             fontWeight,
                             italic,
                             underline,
                             strikeout,
                             charset,
                             precis,
                             CLIP_DEFAULT_PRECIS,
                             DEFAULT_QUALITY,
                             pitch,
                             fontName);
        if (*pHNewFont == NULL)
        {
            WARNING_OUT(( "Failed to create font %s", fontName));
            DC_QUIT;
        }
    }

    //
    // Now we have created the font we need to select it into the HDC
    // which was passed to us.
    //
    *pHOldFont = SelectFont(surface, *pHNewFont);
    if (*pHOldFont == NULL)
    {
        ERROR_OUT(( "Failed to select font %s", fontName));
        DeleteFont(*pHNewFont);
        *pHNewFont = NULL;
        DC_QUIT;
    }
    TRACE_OUT(( "Select new font: %p Old font: %", *pHNewFont,
                                               *pHOldFont));

    //
    // We have successfully created and selected the font.
    //
    rc = TRUE;

DC_EXIT_POINT:
    DebugExitDWORD(FH_CreateAndSelectFont, rc);
    return(rc);
}


//
// FHAddFontToLocalTable
//
// Adds the given font into the local font table, along with any renaming
// and approximate matches.
//
//
void  FHAddFontToLocalTable( LPSTR  faceName,
                                                 TSHR_UINT16 fontFlags,
                                                 TSHR_UINT16 codePage,
                                                 TSHR_UINT16 maxHeight,
                                                 TSHR_UINT16 aveHeight,
                                                 TSHR_UINT16 aveWidth,
                                                 TSHR_UINT16 aspectX,
                                                 TSHR_UINT16 aspectY,
                                                 TSHR_UINT16 maxAscent)
{
    TSHR_INT16       fatSig;
    TSHR_INT16       thinSig;
    TSHR_INT16       symbolSig;
    FHWIDTHTABLE  wTable;
    TSHR_UINT16      height;
    TSHR_UINT16      width;
    TSHR_UINT16      weight;
    LOCALFONT     thisFont;
    TSHR_UINT16      fIndex;

    //
    // SFRFONT: place marker.
    // Here would be the best place to adjust codepage; for example suppose
    // we find that CodePage 950 (Chinese) is so different on all platforms
    // that we just should not send text orders in this codepage, we can
    // set codePage=NF_CP_UNKNOWN and it will be discarded.
    //

    //
    // SFRFONT: no point hanging on to details of fonts with unknown
    // code pages; we cannot risk matching them.
    //
    if (codePage == NF_CP_UNKNOWN)
    {
        TRACE_OUT(( "unknown CP: discard"));
        DC_QUIT;
    }

    //
    // Check we still have room for more fonts.
    //
    if (g_fhFonts->fhNumFonts >= FH_MAX_FONTS)
    {
        //
        // We are already at our maximum number of fonts.
        //
        DC_QUIT;
    }

    //
    // Zero the fields where we store facenames to allow bytewise matches.
    //
    ZeroMemory(thisFont.Details.nfFaceName, FH_FACESIZE);
    ZeroMemory(thisFont.RealName, FH_FACESIZE);

    //
    // Store the easy bits!
    //
    thisFont.Details.nfFontFlags = fontFlags;
    thisFont.Details.nfAveWidth  = aveWidth;
    thisFont.Details.nfAveHeight = aveHeight;
    thisFont.Details.nfAspectX   = aspectX;
    thisFont.Details.nfAspectY   = aspectY;
    thisFont.Details.nfCodePage  = codePage;

    thisFont.lMaxBaselineExt     = maxHeight;

    //
    // Store the real name, for use when we want to create an instance of
    // this font.
    //
    lstrcpy (thisFont.RealName, faceName);

    //
    // Fill in the wire-format facename.
    //
    // NB - This has a machine-specific prefix, but for NT the prefix is an
    // empty string, so we can just use a strcpy without worrying about the
    // issues of adding a prefix.
    //
    lstrcpy (thisFont.Details.nfFaceName, faceName);

    //
    // Make sure the signatures are zero for now.
    //
    thisFont.Details.nfSigFats       = 0;
    thisFont.Details.nfSigThins      = 0;
    thisFont.Details.nfSigSymbol     = 0;

    //
    // Now calculate the signature and maxAscent for this font
    //
    weight = 0;                             // use default weight

    if ((fontFlags & NF_FIXED_SIZE) != 0)
    {
        //
        // Fixed size font: use actual font size for signatures/maxAscent
        //
        height = thisFont.lMaxBaselineExt;
        width  = thisFont.Details.nfAveWidth;

        thisFont.Details.nfMaxAscent = maxAscent;
    }
    else
    {
        //
        // Scalable font: use default height/width for signatures/maxAscent
        //
        height = NF_METRICS_HEIGHT;
        width  = NF_METRICS_WIDTH;

        thisFont.Details.nfMaxAscent = NF_METRICS_HEIGHT;
    }

    //
    // Initialise signature fields to zero (== NF_NO_SIGNATURE).  They will
    // be overwritten assuming we get a font width table OK.
    //
    fatSig    = 0;
    thinSig   = 0;
    symbolSig = 0;

    //
    // FHGenerateFontWidthTable also gives us a proper maxAscent value for
    // scalable fonts (i.e. based on its own rendition of the font)
    //
    if (FHGenerateFontWidthTable(&wTable,
                                 &thisFont,
                                  height,
                                  width,
                                  weight,
                                  thisFont.Details.nfFontFlags,
                                 &maxAscent))
    {
        //
        // If this is a scalable font, use the updated maxAscent value that
        // FHGenerateFontWidthTable has given us.
        //
        if (0 == (thisFont.Details.nfFontFlags & NF_FIXED_SIZE))
        {
            thisFont.Details.nfMaxAscent = maxAscent;
            TRACE_OUT(( "Set maxAscent = %d", thisFont.Details.nfMaxAscent));
        }

        //
        // We have all the raw data we need.  Calculate the signatures.
        //
        FHCalculateSignatures(&wTable, &fatSig, &thinSig, &symbolSig);
    }

    //
    // Store the signatures.  If the call to FHGenerateFontWidthTable
    // fails, the signatures are zero.
    //
    thisFont.Details.nfSigFats     =  (BYTE)fatSig;
    thisFont.Details.nfSigThins    =  (BYTE)thinSig;
    thisFont.Details.nfSigSymbol   = (TSHR_UINT16)symbolSig;

    TRACE_OUT(( "Font %hu signatures: (x%.4hx%.2hx%.2hx)",
             g_fhFonts->fhNumFonts,
             thisFont.Details.nfSigSymbol,
             (TSHR_UINT16)(thisFont.Details.nfSigThins),
             (TSHR_UINT16)(thisFont.Details.nfSigFats)));

    //
    // We can now copy the details to the end of the local table.
    //
    memcpy((void *)&g_fhFonts->afhFonts[g_fhFonts->fhNumFonts],
              (void *)&thisFont,
              sizeof(LOCALFONT));

    //
    // Count this font.
    //
    TRACE_OUT(( "Added record %s",
                                g_fhFonts->afhFonts[g_fhFonts->fhNumFonts].Details.nfFaceName));
    g_fhFonts->fhNumFonts++;

    TRACE_OUT(( "g_fhFonts->fhNumFonts now %u", g_fhFonts->fhNumFonts));

DC_EXIT_POINT:
    DebugExitVOID(FHAddFontToLocalTable);
}

//
// FHConsiderRemoteFonts
//
// Considers the remote fonts for a single remote person.
//
// Takes the existing number of supported fonts, and returns the number
// that are still common after considering this person.
//
UINT  ASShare::FHConsiderRemoteFonts
(
    UINT        cCanSend,
    ASPerson *  pasPerson
)
{
    UINT  iLocal;
    UINT  iRemote;
    UINT  cCanReceive=0;
    BOOL  fCanReceive, fOnlyAscii;
    UINT  sendSupportCode;
    UINT  bestSupportSoFar;

    DebugEntry(ASShare::FHConsiderRemoteFonts);

    ValidatePerson(pasPerson);
    //
    // Consider each of the still valid local fonts, and see if the remote
    // person also supports them.
    //

    //
    // SFR5396: LOOP ONE
    //
    // Look through all the LOCAL fonts, for ones where we find a match in
    // the remote font table.  These are fonts we can SEND, and for which
    // we must set g_fhFonts->afhFonts[].Supported.
    //
    // We also set the rfLocalHandle for remote fonts that we can receive
    // if we encounter them in this search.  We complete the search for
    // remote fonts that we can receive in LOOP TWO.
    //
    // Things we check in this loop: - we may already know there is no
    // match for this local name
    //      so drop out quickly.  - otherwise check through EVERY REMOTE
    // font looking for the
    //      best possible match.  (If we find an EXACT match, leave the
    //      inner loop early)
    //
    //
    for (iLocal=0;
         (cCanSend > 0) && (iLocal < g_fhFonts->fhNumFonts);
         iLocal++)
    {
        if (g_fhFonts->afhFonts[iLocal].SupportCode != FH_SC_NO_MATCH)
        {
            //
            //
            // This font is still valid so check it with all the remote
            // fonts for this person.
            //
            // Things we check in this loop:
            // -    do the face names match? if no - try next remote font.
            // -    the pitch: if one is FIXED pitch and one isn't try next
            // -    the codepages: are the local/remote the same?  This
            //          determines whether we send only ASCII chars.
            // -    scalability: possible combinations are:
            //       local fixed/remote scalable       (can send/not rcv)
            //       local scalable/remote scalable    (can send and rcv)
            //       local fixed/remote fixed, sizes match (send & rcv)
            //       local scalable/remote fixed      (cannot send/can rcv)
            //          for this last case, keep trying the remote fonts.
            //
            // In "back level" calls to Pre-R11 boxes we stop here but
            // force the matches to be approximate.  Otherwise check
            //
            // -    aspect ratios (if present): must match or try the
            //       next remote font.
            // -    signatures: these are used to finally decide whether
            //       the fonts are exact matches; good enough to treat as
            //       approximate matches or such poor matches that the
            //       font is not supported (cannot be sent).
            //
            //

//
// Handy SHORTHAND macroes.
//
#define REMOTEFONT pasPerson->poeFontInfo[iRemote]
#define LOCALFT  g_fhFonts->afhFonts[iLocal]
#define LOCALDETS  LOCALFT.Details

            //
            // Initially assume that the fonts do not match, but that
            // if they do they will match across the whole codepage
            // (not just the ascii set).
            //
            sendSupportCode  = FH_SC_NO_MATCH;
            bestSupportSoFar = FH_SC_NO_MATCH;
            fOnlyAscii       = FALSE;

            //
            //
            // Loop through all the remote fonts looking to see which, if
            // any, offers the best possible match.  Initially,
            // sendSupportCode is set to NO_MATCH; as we go through each
            // iteration we see if we can improve on the current setting
            // of sendSupportCode.  We leave the loop as soon as we find
            // an EXACT_MATCH ('cos we are not going to do any better than
            // that!) or when we run out of remote fonts.  The best match
            // found so far is kept in bestSupportSoFar.
            //
            //
            for (iRemote = 0;
                 (iRemote < pasPerson->oecFonts)
                                   && (sendSupportCode != FH_SC_EXACT_MATCH);
                 iRemote++)
            {
                //
                // If the remote font is already flagged as having no
                // possible match then skip out now. (We set this field
                // during the initial processing of the remote font).
                //
                if (REMOTEFONT.rfLocalHandle==NO_FONT_MATCH)
                {
                    continue;                                    // SFR5279
                }

                //
                // Check the face names...
                //
                if (lstrcmp(LOCALDETS.nfFaceName,
                    g_fhFonts->afhFonts[REMOTEFONT.rfLocalHandle].Details.nfFaceName))
                {
                    continue;
                }
                TRACE_OUT(( "Matched Remote Face Name %s",
                       g_fhFonts->afhFonts[REMOTEFONT.rfLocalHandle]
                                                .Details.nfFaceName));

                //
                // Check the pitch...
                //
                if( (LOCALDETS.nfFontFlags & NF_FIXED_PITCH)!=
                                   (REMOTEFONT.rfFontFlags & NF_FIXED_PITCH) )
                {
                    TRACE_OUT(( "Different Pitch %x %x",
                                LOCALDETS.nfFontFlags,
                                REMOTEFONT.rfFontFlags));
                    continue;
                }

                //
                //
                // If both systems support the font CodePage capability
                // (indicated by the remote capability flags - which are
                // the union of remote and local by now), check that the
                // CodePages and CodePage flags match, and if not,
                // restrict ourselves to sending the ASCII subset.
                //
                // If we support the font CodePage capability but  remote
                // system does not, then restrict ourselves to sending the
                // ASCII subset.
                //
                // If we do not support the font CodePage capability, then
                // we assume that the remote is only sending ANSI CodePage,
                // either because it doesn't know about the font CodePage
                // capability or because it can see that we don't support
                // it.  Therefore, we do not need to check the CodePage.
                // BUT: restrict ourselves to ASCII only.
                //
                //
                if (!(m_pasLocal->cpcCaps.orders.capsfFonts & CAPS_FONT_CODEPAGE))
                {
                    //
                    // We do not support codepage checking.
                    //
                    TRACE_OUT(( "not checking CP"));
                    fOnlyAscii = TRUE;
                }

                if ((m_oeCombinedOrderCaps.capsfFonts & CAPS_FONT_CODEPAGE)
                    && (LOCALDETS.nfCodePage != REMOTEFONT.rfCodePage)  )
                {
                    TRACE_OUT(( "Different CPs %hu %hu",
                                LOCALDETS.nfCodePage,
                                REMOTEFONT.rfCodePage));
                    //
                    //
                    // Assume that all codepages include ASCII.
                    //
                    //
                    fOnlyAscii = TRUE;
                }

                //
                //
                // If we support codepage, but the remote does not then
                // the remote will only be sending us ANSI chars. Make sure
                // that we send only ASCII subset.
                //
                //
                if ((m_pasLocal->cpcCaps.orders.capsfFonts & CAPS_FONT_CODEPAGE)  &&
                    !(m_oeCombinedOrderCaps.capsfFonts & CAPS_FONT_CODEPAGE))
                {
                    TRACE_OUT(( "Only ASCII"));
                    fOnlyAscii = TRUE;
                }

                //
                //
                // The face names and CodePages match and the fonts are of
                // the same type of pitch (ie both are fixed pitch or both
                // are variable pitch).
                //
                //
                if ((REMOTEFONT.rfFontFlags & NF_FIXED_SIZE) == 0)
                {
                    //
                    //
                    // The remote font is scalable, so we can send any font
                    // (with this facename) to the remote system, even if
                    // the local font is fixed sized. Set sendSupportCode
                    // to FH_SC_EXACT_MATCH now - we will change this to
                    // FH_SC_APPROX_MATCH later if other fields differ.
                    //
                    //
                    TRACE_OUT((
                  "Person [%d] Can SEND: remote SCALABLE %s (remote)%u to (local)%u",
                           pasPerson->mcsID,
                           LOCALDETS.nfFaceName,
                           iRemote, iLocal));
                    sendSupportCode = FH_SC_EXACT_MATCH;

                    //
                    //
                    // SFR5396: it is true that we can SEND this font
                    // because the remote version of the font is scalable.
                    // That does not mean that we can necessarily receive
                    // the font... unless ours is scalable too.
                    //
                    //
                    if ((LOCALDETS.nfFontFlags & NF_FIXED_SIZE)==0)
                    {
                        TRACE_OUT((
                               "Person [%d] Can RECEIVE remote font %u as local %u",
                               pasPerson->mcsID, iRemote, iLocal));
                        REMOTEFONT.rfLocalHandle = (TSHR_UINT16)iLocal;
                    }
                }
                else if (LOCALDETS.nfFontFlags & NF_FIXED_SIZE)
                {
                    //
                    //
                    // The remote font is fixed size and so is the local
                    // one, so check if the sizes match exactly.
                    //
                    //
                    if ((LOCALDETS.nfAveWidth == REMOTEFONT.rfAveWidth) &&
                        (LOCALDETS.nfAveHeight == REMOTEFONT.rfAveHeight))
                    {
                        //
                        //
                        // Our fixed size local font is the same as the
                        // fixed size font at the remote.  We set
                        // sendSupportCode to FH_SC_EXACT_MATCH now - we
                        // will change this to FH_SC_APPROX_MATCH later if
                        // other fields differ.
                        //
                        //
                        TRACE_OUT(("Person [%d] Matched remote fixed font %s %u to %u",
                               pasPerson->mcsID,
                               LOCALDETS.nfFaceName,
                               iRemote, iLocal));
                        sendSupportCode = FH_SC_EXACT_MATCH;
                        REMOTEFONT.rfLocalHandle = (TSHR_UINT16)iLocal;
                    }
                    else
                    {
                        TRACE_OUT(( "rejected %s ave width/heights "
                                      "local/remote width %d/%d height %d/%d",
                                   LOCALDETS.nfFaceName,
                                   LOCALDETS.nfAveWidth,
                                                  REMOTEFONT.rfAveWidth,
                                   LOCALDETS.nfAveHeight,
                                                  REMOTEFONT.rfAveHeight));
                    }
                }
                else
                {
                    TRACE_OUT((
                   "Can only RECEIVE %s %u Remote is fixed, but local %u not",
                             LOCALDETS.nfFaceName,
                             iRemote,
                             iLocal));
                    //
                    //
                    // SFR5396: while we cannot SEND this font because our
                    // local version is scalable, but the remote's is
                    // fixed - we can still receive the font in an order.
                    //
                    //
                    REMOTEFONT.rfLocalHandle = (TSHR_UINT16)iLocal;
                }

                //
                //
                // If we have have set the send support code to indicate
                // that we have matched we now consider any R1.1 info if it
                // is present.  As a result of this we may adjust the send
                // support code (from indicating an exact match) to
                // indicate either an approximate match or no match at all.
                //
                //
                if (!pasPerson->oecFonts)
                {
                    //
                    //
                    // The remote system did not send us any R11 font
                    // info. In this case we assume all font matches are
                    // approximate and restrict ourselves to the ascii
                    // subset.
                    //
                    //
                    if (sendSupportCode != FH_SC_NO_MATCH)
                    {
                        TRACE_OUT(( "No R11 so approx match only"));
                        sendSupportCode = FH_SC_APPROX_ASCII_MATCH;
                    }
                }
                else if (sendSupportCode != FH_SC_NO_MATCH)
                {
                    //
                    //
                    // The remote system did send us R11 font info and
                    // the font is flagged as matching.
                    //
                    //

                    if ((m_oeCombinedOrderCaps.capsfFonts
                                            & CAPS_FONT_R20_SIGNATURE)!=0)
                    {
                        //
                        //
                        // Check the signatures.
                        //
                        //
                        TRACE_OUT((
 "Person [%d] local %d (remote %d) signatures (x%.4hx%.2hx%.2hx v x%.4hx%.2hx%.2hx)",
                               pasPerson->mcsID,
                               iLocal,
                               iRemote,
                               LOCALDETS.nfSigSymbol,
                               (TSHR_UINT16)(LOCALDETS.nfSigThins),
                               (TSHR_UINT16)(LOCALDETS.nfSigFats),
                               REMOTEFONT.rfSigSymbol,
                               (TSHR_UINT16)(REMOTEFONT.rfSigThins),
                               (TSHR_UINT16)(REMOTEFONT.rfSigFats)));

                        if ((LOCALDETS.nfSigFats != REMOTEFONT.rfSigFats) ||
                            (LOCALDETS.nfSigThins != REMOTEFONT.rfSigThins) ||
                            (LOCALDETS.nfSigSymbol != REMOTEFONT.rfSigSymbol) ||
                            (REMOTEFONT.rfSigSymbol == NF_NO_SIGNATURE))
                        {
                            //
                            // Decide what to do from the signatures.
                            //
                            if (REMOTEFONT.rfSigSymbol == NF_NO_SIGNATURE)
                            {
                                TRACE_OUT(("NO match: remote no signature"));
                                sendSupportCode = FH_SC_APPROX_ASCII_MATCH;
                            }
                            else if ((LOCALDETS.nfSigFats == REMOTEFONT.rfSigFats)
                                  && (LOCALDETS.nfSigThins == REMOTEFONT.rfSigThins))
                            {
                                TRACE_OUT(( "our ASCII sigs match"));
                                sendSupportCode = FH_SC_EXACT_ASCII_MATCH;
                            }
                            else
                            {
                                //
                                // NOTE:
                                // We could use the "closeness" of the fat
                                // and thin signatures to help us decide
                                // whether to use approximate matching or
                                // not.  But currently we don't.
                                //
                                TRACE_OUT(( "Sig mismatch: APPROX_ASC"));
                                sendSupportCode = FH_SC_APPROX_ASCII_MATCH;
                            }
                        }
                        else
                        {
                            //
                            //
                            // All signatures match exactly.
                            // Leave SendSupportCode as FH_SC_EXACT_MATCH
                            //
                            //
                            TRACE_OUT(("EXACT MATCH: Signatures match exactly"));
                        }
                    }
                    else
                    {
                        //
                        // Not using signatures.  Do we care?
                        //
                        sendSupportCode = FH_SC_APPROX_MATCH;
                        TRACE_OUT(( "APPROX MATCH: no sigs"));
                    }

                    //
                    //
                    // Check the aspect ratio - but only if we do not
                    // already know that this font does not match.
                    //
                    //
                    if ( (sendSupportCode!=FH_SC_NO_MATCH) &&
                         ( (!(m_oeCombinedOrderCaps.capsfFonts
                                                          & CAPS_FONT_ASPECT))
                           || (LOCALDETS.nfAspectX != REMOTEFONT.rfAspectX)
                           || (LOCALDETS.nfAspectY != REMOTEFONT.rfAspectY) ))
                    {
                        //
                        //
                        // Either no aspect ratio was supplied or the
                        // aspect ratio differed.
                        //
                        //
                        if (sendSupportCode == FH_SC_EXACT_MATCH)
                        {
                            //
                            // Force delta-X text orders for mismatched
                            // aspect ratio.  Note we tested above to
                            // see whether supportCode == EXACT because if
                            // we have already "downgraded" support then
                            // we do not need to change it here
                            //
                            sendSupportCode = FH_SC_APPROX_MATCH;
                            TRACE_OUT(( "AR mismatch: APPROX_MATCH"));
                        }
                        else if (sendSupportCode == FH_SC_EXACT_ASCII_MATCH)
                        {
                            //
                            // Same again but for ASCII only.
                            //
                            sendSupportCode = FH_SC_APPROX_ASCII_MATCH;
                            TRACE_OUT(( "AR mismatch: APPROX_ASCII_MATCH"));
                        }
                    }
                }

                if (sendSupportCode != FH_SC_NO_MATCH)
                {
                    //
                    //
                    // Is this a better match than any we have seen
                    // before?
                    //
                    //
                    switch (sendSupportCode)
                    {
                        case FH_SC_EXACT_MATCH:
                        case FH_SC_APPROX_MATCH:
                            //
                            //
                            // Note that we do not have to worry about
                            // overwriting a bestSupportSoFar of EXACT
                            // with APPROX because we leave the loop when
                            // we get an exact match.
                            //
                            //
                            bestSupportSoFar = sendSupportCode;
                            break;

                        case FH_SC_EXACT_ASCII_MATCH:
                            //
                            //
                            // An approximate match over the whole 255
                            // code points is better than an exact one
                            // over just the ascii-s.  Debatable, but that
                            // is what I have decided.
                            //
                            //
                            if (bestSupportSoFar != FH_SC_APPROX_MATCH)
                            {
                                bestSupportSoFar = FH_SC_EXACT_ASCII_MATCH;
                            }
                            break;

                        case FH_SC_APPROX_ASCII_MATCH:
                            //
                            //
                            // An approximate match over just the ascii-s
                            // is better than nothing at all!
                            //
                            //
                            if (bestSupportSoFar == FH_SC_NO_MATCH)
                            {
                                bestSupportSoFar = FH_SC_APPROX_ASCII_MATCH;
                            }
                            break;

                        default:
                            ERROR_OUT(("invalid support code"));
                            break;

                    }
                }
            }

            sendSupportCode = bestSupportSoFar;

            //
            // If we matched the remote font, we have already updated
            // its local handle to
            // the matched local font.  While the local handle was already
            // set up, it was only set up to the first local font with the
            // same facename, rather than the correct font.
            //
            // If we did not match the remote font, mark it as not
            // supported, and decrement the common font count.
            //
            if (sendSupportCode != FH_SC_NO_MATCH)
            {
                TRACE_OUT(( "Local font %d/%s can be SENT (code=%u)",
                            iLocal,
                            LOCALDETS.nfFaceName,
                            sendSupportCode));
                if (fOnlyAscii)
    