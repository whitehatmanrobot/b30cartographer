channel (clearing any dirty state)
//
//-----------------------------------------------------------------------------
void
CFlowLayout::Reset(BOOL fForce)
{
    super::Reset(fForce);
    CancelChanges();
}

//+----------------------------------------------------------------------------
//
//  Member:     Detach
//
//  Synopsis:   Reset the channel
//
//-----------------------------------------------------------------------------
void
CFlowLayout::Detach()
{
    // flushes the region cache and rel line cache.
    _dp.Detach();

    super::Detach();
}


//+---------------------------------------------------------------------------
//
//  Member:     CFlowLayout::CFlowLayout
//
//  Synopsis:   Normal constructor.
//
//  Arguments:  CElement * - element that owns the layout
//
//----------------------------------------------------------------------------

CFlowLayout::CFlowLayout(CElement * pElementFlowLayout, CLayoutContext *pLayoutContext)
                : CLayout(pElementFlowLayout, pLayoutContext)
{
    _sizeMin.SetSize(-1,-1);
    _sizeMax.SetSize(-1,-1);
    Assert(ElementContent());
    ElementContent()->_fOwnsRuns = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlowLayout::~CFlowLayout
//
//  Synopsis:   Normal destructor.
//
//  Arguments:  CElement * - element that owns the layout
//
//----------------------------------------------------------------------------

CFlowLayout::~CFlowLayout()
{

}

//+---------------------------------------------------------------------------
//
//  Member:     CFlowLayout::Init
//
//  Synopsis:   Initialization function to initialize the line array, and
//              scroll and background recalc information if necessary.
//
//----------------------------------------------------------------------------

HRESULT
CFlowLayout::Init()
{
    HRESULT hr;
    hr = super::Init();
    if(hr)
    {
        goto Cleanup;
    }

    if(!_dp.Init())
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Create layout context here if this element defines resolution
    if (_pElementOwner->TagType() == ETAG_GENERIC)
    {
        // NOTE: Calling GetFancyFormat from CFlowLayout::Init causes recursion on TD.
        //       That's why we check the tag before looking at properties.
        CFancyFormat const *pFF = _pElementOwner->GetFirstBranch()->GetFancyFormat();
        mediaType mediaReference = pFF->GetMediaReference();
        if (mediaReference != mediaTypeNotSet)
        {
            if (S_OK == CreateLayoutContext(this))
                DefinedLayoutContext()->SetMedia(mediaReference);
        }
    }

    // Set _fElementCanBeBroken to TRUE for flow layouts only if markup master is layout rect
    SetElementAsBreakable();

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CFlowLayout::OnExitTree
//
//  Synopsis:   Deinitilialize the display on exit tree
//
//----------------------------------------------------------------------------

HRESULT
CFlowLayout::OnExitTree()
{
    HRESULT hr;

    hr = super::OnExitTree();
    if(hr)
    {
        goto Cleanup;
    }

    _dp.FlushRecalc();

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CFlowLayout::OnPropertyChange
//
//  Synopsis:   Handle the changes in property.
//
//----------------------------------------------------------------------------

HRESULT
CFlowLayout::OnPropertyChange(DISPID dispid, DWORD dwFlags)
{
    HRESULT hr = S_OK;;

    switch(dispid)
    {
        case DISPID_A_EDITABLE:
            _dp.SetCaretWidth( IsEditable() ? 1 : 0);
            // fall thru
        default:
            hr = THR(super::OnPropertyChange(dispid, dwFlags));
            break;
    }

    RRETURN(hr);
}

void
CFlowLayout::DoLayout(
    DWORD   grfLayout)
{
    Assert(grfLayout & (LAYOUT_MEASURE | LAYOUT_POSITION | LAYOUT_ADORNERS));

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CFlowLayout::DoLayout L(0x%x, %S) grfLayout(0x%x)", this, ElementOwner()->TagName(), grfLayout ));

    CElement *  pElementOwner = ElementOwner();

    Assert(pElementOwner->CurrentlyHasAnyLayout());

    //  If this layout is no longer needed, ignore the request and remove it
    if (    pElementOwner->CurrentlyHasAnyLayout()
        &&  !pElementOwner->ShouldHaveLayout())
    {
        ElementOwner()->DestroyLayout();
    }

    //
    //  Hidden layout should just accumulate changes
    //  (It will be measured when re-shown)
    //

    else if(!IsDisplayNone())

    {
        CCalcInfo   CI(this);
        CSize       size;

        // Inside CalcSize we are going to apply element's transformations,
        // hence need to get apparent size.
        GetApparentSize(&size);

        CDispNode * pDispNode = GetElementDispNode();
        if (pDispNode)
        {
            CRect rc(CI._sizeParent);
            pDispNode->TransformRect(rc, COORDSYS_CONTENT, &rc, COORDSYS_TRANSFORMED);

            CI._sizeParent = rc.Size();
            CI._sizeParentForVert = CI._sizeParent;
        }

        CI._grfLayout |= grfLayout;

        //  Init available height for PPV 
        if (    CI.GetLayoutContext()
            &&  CI.GetLayoutContext()->ViewChain() 
            &&  ElementCanBeBroken()  )
        {
            CLayoutBreak *pLayoutBreak;
            CI.GetLayoutContext()->GetEndingLayoutBreak(pElementOwner, &pLayoutBreak);
            Assert(pLayoutBreak);

            if (pLayoutBreak)
            {
                CI._cyAvail = pLayoutBreak->AvailHeight();
            }
        }

        //
        //  If requested, measure
        //

        if (grfLayout & LAYOUT_MEASURE)
        {
            // we want to do this each time inorder to
            // properly pick up things like opacity.
            if ( _fForceLayout)
            {
                CI._grfLayout |= LAYOUT_FORCE;
            }

            EnsureDispNode(&CI, !!(CI._grfLayout & LAYOUT_FORCE));

            if (    IsDirty()
                ||  (CI._grfLayout & LAYOUT_FORCE)  )
            {
                CElement::CLock Lock(pElementOwner, CElement::ELEMENTLOCK_SIZING);
                int             xRTLOverflow = _dp.GetRTLOverflow();

                //
                // CalcSize handles transformations, vertical-flow, delegation, & attribute sizing.
                //
                // But if we are percent sized, then we cannot pass in our old/current size, we need 
                // to grab our parent size (which the current is calculated from, and pass that in)
                if (   (    PercentSize() 
                        ||  pElementOwner->IsAbsolute() )
                    && (   (    Tag() != ETAG_BODY 
                            &&  Tag() != ETAG_FRAME)
                        || pElementOwner->IsInViewLinkBehavior( FALSE )
                    )  )
                {
                    CLayout *pParent = GetUpdatedParentLayout(LayoutContext());
                    if (pParent)
                    {
                        CFlowLayout *pFlowParent = pParent->ElementOwner()->GetFlowLayout(LayoutContext());
                        CRect rect;

                        BOOL fStrictCSS1Document =    ElementOwner()->HasMarkupPtr() 
                                                  &&  ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document();

                        // If our parent cached a size for calcing children like us, then use that size.
                        if (    !fStrictCSS1Document 
                            &&  pFlowParent 
                            &&  pFlowParent->_sizeReDoCache.cx 
                            &&  pFlowParent->_sizeReDoCache.cy  )
                        {
                            size = pFlowParent->_sizeReDoCache;
                        }
                        // If CSS1 Strict use sizePropsed 
                        else if (   fStrictCSS1Document 
                                &&  pFlowParent )
                        {
                            size = pFlowParent->_sizeProposed;
                        }
                        else
                        {
                            //
                            // get the space inside the scrollbars and border
                            //
                            pParent->GetClientRect(&rect, CLIENTRECT_CONTENT);
                            size.cx = rect.Width();
                            size.cy = rect.Height();

                            //
                            // Now remove padding (and margin if it is the body)
                            //   CSS1 Strict Doctypes: Margin on the BODY really is margin, not padding.
                            //
                            if (    pParent->Tag() == ETAG_BODY
                                &&  !pParent->GetOwnerMarkup()->IsHtmlLayout() )
                            {
                                LONG xLeftMargin, xRightMargin;
                                LONG yTopMargin, yBottomMargin;

                                // get the margin info for the site
                                pParent->GetMarginInfo(&CI, 
                                                       &xLeftMargin, 
                                                       &yTopMargin, 
                                                       &xRightMargin, 
                                                       &yBottomMargin);
                                size.cx -= (xLeftMargin + xRightMargin);
                                size.cy -= (yTopMargin + yBottomMargin);
                            }
                        
                            {
                                CDisplay    *pdpParent   = pFlowParent ? pFlowParent->GetDisplay() : NULL;
                                long         lPadding[SIDE_MAX];

                                if (pdpParent)
                                {
                                    pdpParent->GetPadding(&CI, lPadding);

                                    // padding is in parent coordinate system, but we need it in global
                                    if (pParent->ElementOwner()->HasVerticalLayoutFlow()) 
                                    {
                                        size.cx -= (lPadding[SIDE_TOP] + lPadding[SIDE_BOTTOM]);
                                        size.cy -= (lPadding[SIDE_LEFT] + lPadding[SIDE_RIGHT]);
                                    }
                                    else
                                    {
                                        size.cx -= (lPadding[SIDE_LEFT] + lPadding[SIDE_RIGHT]);
                                        size.cy -= (lPadding[SIDE_TOP] + lPadding[SIDE_BOTTOM]);
                                    }
                                }
                            }
                        } // end "use _sizeReDoCache"
                    }

                    CI.SizeToParent(&size);

                    // now that we have found the proper size of our parent, we need to get ready
                    // to call CalcSize - this means setting "size" to be the same as pSizeObj in
                    //  MeasureSite() -- which means, removing OUR margins from the parent size.
                    //
                    // Note - we don't remove margins for APE's
                    //
                    if (!ElementOwner()->IsAbsolute())
                    {
                        LONG xLeftMargin, xRightMargin;
                        LONG yTopMargin, yBottomMargin;

                        // get the margin info for the site
                        GetMarginInfo(&CI, 
                                      &xLeftMargin, 
                                      &yTopMargin, 
                                      &xRightMargin, 
                                      &yBottomMargin);
                        size.cx -= (xLeftMargin + xRightMargin);
                        size.cy -= (yTopMargin + yBottomMargin);
                    }

                }

                CalcSize(&CI, &size);

                if (CI._grfLayout & LAYOUT_FORCE || 
                    IsRTLFlowLayout() && _dp.GetRTLOverflow() != xRTLOverflow) // another reason to update disp nodes.
                {
                    if (pElementOwner->IsAbsolute())
                    {
                        pElementOwner->SendNotification(NTYPE_ELEMENT_SIZECHANGED);
                    }
                }
            }

            Reset(FALSE);
        }
        _fForceLayout = FALSE;

        //
        //  Process outstanding layout requests (e.g., sizing positioned elements, adding adorners)
        //

        if (HasRequestQueue())
        {
            long xParentWidth;
            long yParentHeight;

            _dp.GetViewWidthAndHeightForChild(
                &CI,
                &xParentWidth,
                &yParentHeight,
                CI._smMode == SIZEMODE_MMWIDTH);

            ProcessRequests(&CI, CSize(xParentWidth, yParentHeight));
        }

        Assert(!HasRequestQueue() || GetView()->HasLayoutTask(this));
    }
    else
    {
        FlushRequests();
        RemoveLayoutRequest();
        Assert(!HasRequestQueue() || GetView()->HasLayoutTask(this));
    }

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CFlowLayout::DoLayout()" ));
}


//+------------------------------------------------------------------------
//
//  Member:     ResizePercentHeightSites
//
//  Synopsis:   Send an ElementResize for any immediate contained sites
//              whose size is a percentage
//
//-------------------------------------------------------------------------

void
CFlowLayout::ResizePercentHeightSites()
{
    CNotification   nf;
    CLayout *       pLayout;
    DWORD_PTR       dw;
    BOOL            fFoundAtLeastOne = FALSE;

    //
    // If no contained sites are affected, immediately return
    //
    if (!ContainsVertPercentAttr())
        return;

    //
    // Otherwise, iterate through all sites, sending an ElementResize notification for those affected
    // (Also, note that resizing a percentage height site cannot affect min/max values)
    // NOTE: With "autoclear", the min/max can vary after resizing percentage sized
    //       descendents. However, the calculated min/max values, which used for table
    //       sizing, should take into account those changes since doing so would likely
    //       break how tables layout relative to Netscape. (brendand)
    //
    Assert(!_fPreserveMinMax);
    _fPreserveMinMax = TRUE;

    for (pLayout = GetFirstLayout(&dw); pLayout; pLayout = GetNextLayout(&dw))
    {
        if (pLayout->PercentHeight())
        {
            nf.ElementResize(pLayout->ElementOwner(), NFLAGS_CLEANCHANGE);
            GetContentMarkup()->Notify( nf );

            fFoundAtLeastOne = TRUE;
        }
    }
    ClearLayoutIterator(dw, FALSE);

    _fPreserveMinMax = FALSE;

    // clear the flag if there was no work done.  oppurtunistic cleanup
    SetVertPercentAttrInfo(fFoundAtLeastOne);
}

//+-------------------------------------------------------------------------
//
//  Method:     CFlowLayout::CalcSizeVirtual
//
//  Synopsis:   Calculate the size of the object.  This function had two 
//      responsibilities. First it needs to delegate the CalcSize call to 
//      the IHTMLBehaviorLayout peer if it is there; second, it needs to 
//      detect if there is vertical text on the page and call CalcSizeEx()
//      to handle this.  CalcSizeCore() is the classic sizing code.
//
//      Note, changes to CalcSizeCore or CalcSizeEx need to be reflected in 
//      the other function
//
//      Note, because this function is so central to the layout process (I.E. perf), 
//      it is  organized to streamline the expected (no peerholder) scenario
//
//--------------------------------------------------------------------------

DWORD
CFlowLayout::CalcSizeVirtual( CCalcInfo * pci,
                              SIZE      * psize,
                              SIZE      * psizeDefault)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CFlowLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    WHEN_DBG(SIZE psizeIn = *psize);
    WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0

    CElement *pElementOwner = ElementOwner();
    CPeerHolder *   pPeerHolder = pElementOwner->GetLayoutPeerHolder();
    DWORD dwRet = 0;

    // If the element is editable
    if (IsEditable())
    {
        CTreeNode *pNode = pElementOwner->GetFirstBranch();

        // Parent is editable
        if (pNode->IsEditable(TRUE))
        {
            _dp.SetCaretWidth(1);
        }

        // Parent is not, while the element by itself is editable. Find out if it was
        // due to contentEditable. (we do not want to add a pixel for caret to
        // things like textarea/input which are editable at browse -- this is for
        // compat reasons).
        else if (pNode->GetFancyFormat()->_fContentEditable)
        {
            _dp.SetCaretWidth(1);
        }
        else
        {
            _dp.SetCaretWidth(0);
        }
    }

    if (   !pPeerHolder 
        || !pPeerHolder->TestLayoutFlags(BEHAVIORLAYOUTINFO_FULLDELEGATION))
    {
        // no PeerLayout, do the normal thing
        if (!pci->_pMarkup->_fHaveDifferingLayoutFlows)
        {
            dwRet = CalcSizeCore(pci, psize, psizeDefault);
        }
        else
        {
            dwRet = CalcSizeEx(pci, psize, psizeDefault);
        }
    }
    else
    {
        POINT pt = g_Zero.pt;
        BOOL  fSizeDispNodes;

        fSizeDispNodes = (S_FALSE == EnsureDispNode(pci, (pci->_grfLayout & LAYOUT_FORCE)));
        EnsureDispNodeIsContainer( ElementOwner() );

        DelegateCalcSize(BEHAVIORLAYOUTINFO_FULLDELEGATION, 
                         pPeerHolder, 
                         pci, 
                         *psize, 
                         &pt, 
                         psize);

        // do work here to set the dispnode
        if (!fSizeDispNodes)
        {
            CSize sizeOriginal; 
            GetSize(&sizeOriginal); 

            fSizeDispNodes = (psize->cx != sizeOriginal.cx) || (psize->cy != sizeOriginal.cy); 
        }

        if (fSizeDispNodes)
        {
            CSize sizeInset(pt.x, pt.y);

            // NOTE - not sure if setInset is going to do just what we want...
            // it feels like a hack, but if a LayoutBehavior is not a LayoutRender
            // we may have some trouble drawing it properly
            if (sizeInset.cx || sizeInset.cy)
            {
                _pDispNode->SetInset(sizeInset);
            }
            SizeDispNode(pci, *psize);

            SizeContentDispNode( CSize(psize->cx-max(pt.x, 0L), 
                                       psize->cy-max(pt.y, 0L)) );

            dwRet |= LAYOUT_HRESIZE | LAYOUT_VRESIZE;
        }

        //
        // Mark the site clean
        //
        SetSizeThis( FALSE );
    }
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CFlowLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    return dwRet;
}

//+-------------------------------------------------------------------------
//
//  Method:     CFlowLayout::CalcSizeEx
//
//  Synopsis:   Calculate the size of the object
//
//--------------------------------------------------------------------------

DWORD
CFlowLayout::CalcSizeEx( CCalcInfo * pci,
                         SIZE      * psize,
                         SIZE      * psizeDefault)
{
    WHEN_DBG(SIZE psizeIn = *psize);
    WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0

    DWORD          grfReturn = 0;
    CTreeNode        * pNode = GetFirstBranch();
    const CCharFormat  * pCF = pNode->GetCharFormat(LC_TO_FC(LayoutContext()));
    const CFancyFormat * pFF = pNode->GetFancyFormat(LC_TO_FC(LayoutContext()));
    BOOL fLayoutFlowVertical = pCF->HasVerticalLayoutFlow();

    if (!pFF->_fLayoutFlowChanged)
    {
        if (    pci->_smMode == SIZEMODE_MMWIDTH
            &&  fLayoutFlowVertical)
        {
            //
            // MIN/MAX mode for vertical layout
            // Need to change calculated min value to avoid situation
            // when each char is in its own vertical-line
            //
            LONG cuMin;
            CSizeUV sizeMaxWidth;
            grfReturn |= CalcSizeCore(pci, psize, (PSIZE)&sizeMaxWidth);

            if (ccSwitchCch > GetContentTextLength())
            {
                cuMin = sqrt(sizeMaxWidth.cu * sizeMaxWidth.cv);
            }
            else
            {
                CSizeUV sizeChar;
                GetAveCharSize(pci, (PSIZE)&sizeChar);
                cuMin = ccSwitchCch * sizeChar.cu;
            }

            psize->cy = min(_sizeMax.cu, max(_sizeMin.cu, cuMin));
            _sizeMin.SetSize(psize->cy, -1);
            _sizeMax.SetSize(psize->cx, -1);

            if (psizeDefault)
            {
                ((CSize *)psizeDefault)->SetSize(sizeMaxWidth.cu, sizeMaxWidth.cv);
            }
        }
        else if (pci->_smMode == SIZEMODE_NATURALMIN)
        {
            CSizeUV sizeMinWidth;
            grfReturn |= CalcSizeCore(pci, psize, (PSIZE)&sizeMinWidth);

            _sizeMin.SetSize(sizeMinWidth.cu, -1);
            _sizeMax.SetSize(psize->cx, -1);
        }
        else
        {
            // Normal and also horizontal when there are other vertical
            grfReturn |= CalcSizeCore(pci, psize, psizeDefault);
        }
    }
    else
    {
        CSaveCalcInfo sci(pci, this);

        BOOL fContentSizeOnly = pci->_fContentSizeOnly;
        pci->_fContentSizeOnly = FALSE;

        switch (pci->_smMode)
        {
        case SIZEMODE_MMWIDTH:
        {
            //
            // Coordinate system has been rotated by 270 or 90 degrees
            // MIN/MAX requires min/max logical height
            //
            CSizeUV size;
            CSizeUV sizeMinWidth;

            //
            // Calculate minimum logical height
            //
            //   size will contain max logical width and height
            //   sizeMinWidth will contain min logical width
            //
            {
                // needed only because we have another calc size call right after this one
                CSaveCalcInfo sci(pci, this);

                size.cu = pci->GetDeviceMaxX();
                size.cv = 0;
                pci->_smMode = SIZEMODE_NATURALMIN;
                grfReturn |= CalcSizeCore(pci, (PSIZE)&size, (PSIZE)&sizeMinWidth);
                pci->_smMode = SIZEMODE_MMWIDTH;
            }
            // sizeMin in the cordinates of the parent, and since we are differing flow,
            // we need to flip.
            _sizeMin.SetSize(size.cv, size.cu);

            //
            // Calculate logical width at which maximum logical height will be 
            // calculated
            //
            size.cu = sizeMinWidth.cu;
            size.cv = 0;
            if (fLayoutFlowVertical)
            {
                // Need to change proposed min width value to avoid situation
                // when each char is in its own vertical-line
                if (ccSwitchCch > GetContentTextLength())
                {
                    size.cu = sqrt(_sizeMin.cu * _sizeMin.cv);
                }
                else
                {
                    CSizeUV sizeChar;
                    GetAveCharSize(pci, (PSIZE)&sizeChar);
                    size.cu = ccSwitchCch * sizeChar.cu;
                }
                size.cu = max(sizeMinWidth.cu, min(_sizeMin.cv, size.cu));  // to keep within min/max range
            }
            //
            // Calculate maximum logical height
            //
            pci->_smMode = SIZEMODE_NATURAL;
            grfReturn |= CalcSizeCore(pci, (PSIZE)&size);
            pci->_smMode = SIZEMODE_MMWIDTH;
            // sizeMax in the cordinates of the parent, and since we are differing flow,
            // we need to flip.
            _sizeMax.SetSize(size.cv, size.cu);

            // If we have explicity specified width we need to keep it
            const CUnitValue & cuvWidth = pFF->GetLogicalWidth(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
            if (!cuvWidth.IsNullOrEnum() && !cuvWidth.IsPercent())
            {
                // If we have explicity specified width we need to keep it
                LONG uUserWidth = cuvWidth.XGetPixelValue(pci, pci->_sizeParent.cx,
                                                          pNode->GetFontHeightInTwips(&cuvWidth));
                //
                // NOTE: We shouldn't measure at > userLW.
                // We can have following cases:
                //    1) userLW <= minLW
                //    2) userLW >= maxLW
                //    3) userLW >  minLW & userLW < maxLW
                // NOTE: maxLW == _sizeMin.cv, minLW == _sizeMax.cv
                //

                // (1) We cannot measure at < minLW, so we need extend width to minLW
                //     In this case set MIN to MAX, to keep minLW
                if (uUserWidth <= _sizeMax.cv)
                {
                    _sizeMin = _sizeMax;
                }
                // (2) User width is greater than maxLW, so we don't care now
                //     We will adjust this value in NATURAL pass
                //
                // (3) We need to reduce maxLW to userLW
                //     To do that we need additional calc size to get MIN
                else if (!(uUserWidth >= _sizeMin.cv))
                {
                    size.SetSize(uUserWidth, 0);
                    pci->_smMode = SIZEMODE_NATURAL;
                    grfReturn |= CalcSizeCore(pci, (PSIZE)&size);
                    pci->_smMode = SIZEMODE_MMWIDTH;
                    // sizeMin in the cordinates of the parent, and since we are differing flow,
                    // we need to flip.
                    _sizeMin.SetSize(size.cv, size.cu);
                }
            }

            // If we have explicity specified height we need to keep it
            const CUnitValue & cuvHeight = pFF->GetLogicalHeight(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
            if (!cuvHeight.IsNullOrEnum() && !cuvHeight.IsPercent())
            {
                LONG lHeight = cuvHeight.YGetPixelValue(pci, pci->_sizeParent.cy, 
                                                        pNode->GetFontHeightInTwips(&cuvHeight));

                _uMinWidth  = _sizeMin.cu;
                _uMaxWidth  = _sizeMax.cu;
                _sizeMin.cu = max(_sizeMin.cu, lHeight);
                _sizeMax.cu = max(_sizeMax.cu, lHeight);
            }
            else
            {
                _uMinWidth = -1;
                _uMaxWidth = -1;
            }

            Assert((_sizeMax.cv != _sizeMin.cv) || (_sizeMax.cu == _sizeMin.cu));

            ((CSize *)psize)->SetSize(_sizeMax.cu, _sizeMin.cu);
            if (psizeDefault)
            {
                // since sizeDefault is the max dimensions and since they are in the coordinate
                // system of the parent, we need to flip when we set sizeDefault
                ((CSize *)psizeDefault)->SetSize(size.cv, size.cu);
            }

            MtAdd(Mt(LFCMinMax), 1, 0);
            _fMinMaxValid = TRUE;
            break;
        }

        case SIZEMODE_NATURAL:
        case SIZEMODE_NATURALMIN:
        {
            CFlowLayout *pFlowLayout = this;

            if (    GetLayoutDesc()->TestFlag(LAYOUTDESC_TABLECELL)
                &&  pci->GetLayoutContext() 
                &&  pci->GetLayoutContext()->ViewChain()    )
            {
                //  If this is a table cell in print preview 
                //  find layout in compatible layout context : 
                CMarkup *pMarkup = GetContentMarkup();
                AssertSz(pMarkup, "Layout MUST have markup pointer!!!"); 
                
                if (pMarkup && pMarkup->HasCompatibleLayoutContext())
                {
                    pFlowLayout = (CFlowLayout *)(ElementOwner()->GetUpdatedLayout(pMarkup->GetCompatibleLayoutContext())); 
                }
            }

            pci->_smMode = SIZEMODE_NATURAL;
            // _sizeMax.cv >= 0 means we had special MIN/MAX pass
            if (pFlowLayout->_sizeMax.cv >= 0)
            {
                MtAdd(Mt(LFCCalcSizeNaturalTotal), 1, 0);

                // 
                // Auto-sizing after special MIN/MAX mode
                // 

                LONG dur;
                LONG dvr;
                LONG durMin;
                LONG dvrMax = psize->cy;
                LONG dvrMaxOrig = psize->cy;
                BOOL fNeedRecalc = TRUE;
                LONG uUserWidth = -1;
                SIZECOORD   vMin = pFlowLayout->_sizeMin.cv;
                SIZECOORD   vMax = pFlowLayout->_sizeMax.cv;
                SIZECOORD   uMin = pFlowLayout->_sizeMin.cu;
                SIZECOORD   uMax = pFlowLayout->_sizeMax.cu;

                // Get logical user width
                const CUnitValue & cuvWidth = pFF->GetLogicalWidth(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
                if (!cuvWidth.IsNullOrEnum())
                {
                    // If we have explicity specified width we need to keep it
                    uUserWidth = cuvWidth.XGetPixelValue(pci, pci->_sizeParent.cx,
                                                         pNode->GetFontHeightInTwips(&cuvWidth));
                }

                // Set real min/max values
                if (pFlowLayout->_uMinWidth >= 0)
                {
                    uMin = pFlowLayout->_uMinWidth;
                }
                if (pFlowLayout->_uMaxWidth >= 0)
                {
                    uMax = pFlowLayout->_uMaxWidth;
                }

                //
                // 1) Get maximum logical height (maxLH)
                //    * dvrMax > maxLH => stop and return (dvrMax, LW(maxLH))
                //    * dvrMax = maxLH => stop and return (dvrMax, LW(maxLH))
                //    * dvrMax < maxLH => go to (2)
                // NOTE: maxLH == _sizeMax.cu
                //
                Assert(vMax >= 0);
                dur = max(vMax, uUserWidth);
                dvr = uMax;

                BOOL fDone = (dvr <= dvrMax) || (uUserWidth >= vMin);
                if (!fDone)
                {
                    CSizeUV sizeChar;

                    if (GetAveCharSize(pci, (PSIZE)&sizeChar))
                    {
                        // If requested logical height is too close to min/max
                        // boundaries (< sizeChar.cv), reduce it
                        if (dvrMax < uMin + sizeChar.cv)
                            dvrMax = uMin;
                        else if (dvrMax > uMax - sizeChar.cv)
                            dvrMax = uMax - sizeChar.cv;
                    }

                    durMin = sizeChar.cu;

                    //
                    // 2) Get minimum logical height (minLH)
                    //    * dvrMax < minLH => stop and return (dvrMax, LW(minLH))
                    //    * dvrMax = minLH => stop and return (dvrMax, LW(minLH))
                    //    * dvrMax > minLH => go to (3)
                    // NOTE: minLH == _sizeMin.cu
                    //
                    Assert(vMin >= 0);
                    dur = max(vMin, uUserWidth);
                    dvr = uMin;

                    fDone = (dvr >= (LONG)(dvrMax * ccErrorAcceptableLow));
                    if (!fDone)
                    {
                        //
                        // (3) Find cell's width for specified height
                        //     Start search of most accurate solution.
                        //
                        fNeedRecalc = FALSE;

                        CSizeUV start(vMax, uMax);
                        CSizeUV end(vMin, uMin);
                        CSizeUV sizeOut;

                        grfReturn |= CalcSizeSearch(pci, dur, dvrMax, 
                            (PSIZE)&start, (PSIZE)&end, (PSIZE)&sizeOut);

                        dur = sizeOut.cu;
                        dvr = sizeOut.cv;
                    }
                }

                if (fNeedRecalc)
                {
                    CSizeUV size(dur, dvr);

                    // CFlowLayout::CalcSizeCore checks psize to decide if 
                    // text needs a recalc. Here we are replacing original psize,  
                    // causing that logic to fail. SetSizeThis guarantees that 
                    // text will be recalculated.
                    SetSizeThis(TRUE); 
                    grfReturn |= CalcSizeCore(pci, (PSIZE)&size);
                    dur = size.cu;
                    dvr = size.cv;
                }

                // TODO: (SujalP IE6 bug 13567): If something changed in an abs pos'd cell, then
                // the table code (CalcAbsolutePosCell) does not redo the min-max.
                // It uses the old max value and calls CalcSizeAtUserWidth. The new
                // width might be greater because of the changes, and hence we want
                // to size the cell at that new width. The right fix is for the table
                // to do a min-max pass on the cell to correctly get its max size.
                // This is not fully correct, since we do not accout for overflow properties.
                // Hence the correct fix is really for CalcAbsolutePosCell to do min-max
                // on this cell.
                CFlowLayout * pFLParent = pNode->Parent() ? pNode->Parent()->GetFlowLayout(LayoutContext()) : NULL;
                BOOL fBlockInContext =    !pFLParent
                                       || pFLParent->IsElementBlockInContext(pNode->Element());
                if (   GetLayoutDesc()->TestFlag(LAYOUTDESC_TABLECELL)
                    && pFF->IsAbsolute()
                    && dvr != dvrMaxOrig)
                {
                    CDispNode * pdn = GetElementDispNode();
                    if (pdn)
                    {
                        if (((CTableCellLayout *)this)->TableLayout()->IsFixed())
                            dvr = max(dvr, dvrMaxOrig);
                        SizeDispNode(pci, CSize(dur, max(dvr, dvrMaxOrig)), FALSE);
                    }
                }
                // If out height is different than original we need to change calculated height 
                // and resize display node for non-positioned block elements.
                // Do it also in case of fixed table, because after node sizing
                // we change size to match requested values.
                else if (   (   dvr != dvrMaxOrig 
                             && fBlockInContext 
                             && !pFF->IsPositioned())
                         || (   GetLayoutDesc()->TestFlag(LAYOUTDESC_TABLECELL)
                             && ((CTableCellLayout *)this)->TableLayout()->IsFixed()))
                {
                    CDispNode * pdn = GetElementDispNode();
                    if (pdn)
                    {
                        dvr = max(dvr, dvrMaxOrig);
                        SizeDispNode(pci, CSize(dur, dvr), FALSE);
                    }
                }

                ((CSize *)psize)->SetSize(dur, dvr);
            }
            else
            {
                if (   GetLayoutDesc()->TestFlag(LAYOUTDESC_TABLECELL)
                    && (   psize->cx == 0
                        || ((CTableCellLayout *)this)->TableLayout()->IsFixed()))
                {
                    // 
                    // TD layout auto-sizing for fixed table, or
                    // TD layout auto-sizing in case of 0 width
                    //

                    // First calculate min/max
                    CSizeUV size;
                    pci->_smMode = SIZEMODE_MMWIDTH;
                    grfReturn |= pFlowLayout->CalcSizeEx(pci, (PSIZE)&size, NULL);
                    pci->_smMode = SIZEMODE_NATURAL;

                    // Now call naturalmin mode
                    grfReturn |= CalcSizeEx(pci, psize, psizeDefault);
                }
                else
                {
                    Assert(!pci->_fContentSizeOnly);

                    // 
                    // Compute proposed logical width and size at this value
                    //
                    if (pci->_sizeParent.cx == 0)
                    {
                        CTreeNode * pParentNode = pNode->Parent();
                        if (pParentNode)
                            pci->_sizeParent.cx = pParentNode->GetLogicalUserWidth(pci, 
                                                    pCF->HasVerticalLayoutFlow());
                        if (pci->_sizeParent.cx == 0)
                            pci->_sizeParent.cx = pci->_sizeParentForVert.cx;
                    }

                    if (!fLayoutFlowVertical)
                    {
                        if (psize->cx == 0)
                            psize->cx = pci->_sizeParent.cx;

                        // Get content size (sizing in NATURALMIN mode + pci->_fContentSizeOnly set to TRUE)
                        {
                            CSizeUV sizeMinWidth;

                            CSaveCalcInfo sci(pci, this);
                            BOOL fContentSizeOnly = pci->_fContentSizeOnly;
                            pci->_fContentSizeOnly = TRUE;

                            pci->_smMode = SIZEMODE_NATURALMIN;
                            grfReturn |= CalcSizeCore(pci, psize, (PSIZE)&sizeMinWidth);
                            pci->_smMode = SIZEMODE_NATURAL;

                            pci->_fContentSizeOnly = fContentSizeOnly;
                        }

                        // NATURALMIN mode doesn't do any alignment and it sizes to content size
                        // Hence need to recal text.
                        pci->_grfLayout |= LAYOUT_FORCE;
                        grfReturn |= CalcSizeCore(pci, psize, psizeDefault);
                    }
                    else
                    {
                        // NATURALMIN mode doesn't do any alignment and it sizes to content size.
                        // Hence need to recal text in NATURAL mode, set fNeedRecalc flag by
                        // default to TRUE.
                        BOOL fNeedRecalc = TRUE;

                        CSizeUV sizeMax, sizeMin, size, sizeAbsMax, sizeMinWidth;
                        LONG lMaxWidth;
                        LONG lMinWidth;

                        LONG lUserHeight = 0;

                        // Get logical user height
                        const CUnitValue & cuvHeight = pFF->GetLogicalHeight(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
                        if (!cuvHeight.IsNullOrEnum())
                        {
                            // If we have explicity specified width we need to keep it
                            lUserHeight = cuvHeight.YGetPixelValue(pci, pci->_sizeParent.cy,
                                                                   pNode->GetFontHeightInTwips(&cuvHeight));
                        }

                        //
                        // Get minimum logical width
                        //
                        SIZE sizeChar;
                        GetAveCharSize(pci, &sizeChar);
                        lMinWidth = ccSwitchCch * sizeChar.cx;

                        //
                        // Get maxmimum available logical width
                        //
                        lMaxWidth = pci->_sizeParent.cx;
                        if (lMaxWidth == 0)
                        {
                            lMaxWidth = pNode->GetLogicalUserWidth(pci, pCF->HasVerticalLayoutFlow());

                            // Its possible that we still do not have a logical width. In this case
                            // size at logical maximum(infinity) since that gives us the maximum 
                            // width for this layout and use that for our lMaxWidth.
                            if (lMaxWidth == 0)
                            {
                                CSaveCalcInfo sci(pci, this);
                                BOOL fContentSizeOnly = pci->_fContentSizeOnly;
                                pci->_fContentSizeOnly = TRUE;

                                sizeAbsMax.SetSize(pci->GetDeviceMaxX(), 0);
                                pci->_sizeParentForVert = pci->_sizeParent;
                                pci->_smMode = SIZEMODE_NATURALMIN;
                                grfReturn |= CalcSizeCore(pci, (PSIZE)&sizeAbsMax, (PSIZE)&sizeMinWidth);
                                lMaxWidth = sizeAbsMax.cu;

                                pci->_fContentSizeOnly = fContentSizeOnly;
                            }
                            pci->_sizeParent.cx = lMaxWidth;
                        }
                        lMaxWidth = max(lMaxWidth, lMinWidth);

                        //
                        // Calculate maximum logical width
                        //
                        if (sizeAbsMax.IsZero())
                        {
                            CSaveCalcInfo sci(pci, this);
                            BOOL fContentSizeOnly = pci->_fContentSizeOnly;
                            pci->_fContentSizeOnly = TRUE;
                            pci->_sizeParentForVert = pci->_sizeParent;

                            sizeMax.SetSize(lMaxWidth, 0);
                            pci->_smMode = SIZEMODE_NATURALMIN;
                            grfReturn |= CalcSizeCore(pci, (PSIZE)&sizeMax, (PSIZE)&sizeMinWidth);

                            if (lUserHeight > 0 && lUserHeight < sizeMax.cv)
                            {
                                CSaveCalcInfo sci(pci, this);
                                sizeAbsMax.SetSize(pci->GetDeviceMaxX(), 0);
                                pci->_sizeParentForVert = pci->_sizeParent;
                                pci->_smMode = SIZEMODE_NATURALMIN;
                                grfReturn |= CalcSizeCore(pci, (PSIZE)&sizeAbsMax, (PSIZE)&sizeMinWidth);
                                lMaxWidth = sizeAbsMax.cu;
                                sizeMax = sizeAbsMax;
                            }

                            pci->_fContentSizeOnly = fContentSizeOnly;
                        }
                        else
                        {
                            sizeMax = sizeAbsMax;
                        }

                        //
                        // Calculate minimum logical width, if necessary.
                        // 
                        // (1) if max is the same as min, then use max
                        // (2) if height for max width is >= user height, use max
                        // (3) if we overflow for max, then use max (there is no point to calc min)
                        // (4) get min size and if necessary search for solution
                        //
                        if (lMaxWidth <= lMinWidth)
                        {
                            // (1) see above
                            size = sizeMax;
                        }
                        else if (lUserHeight > 0 && lUserHeight <= sizeMax.cv)
                        {
                            // (2) see above
                            size = sizeMax;
                        }
                        else if (pci->_sizeParent.cy <= sizeMax.cv)
                        {
                            // (3) see above
                            size = sizeMax;
                        }
                        else
                        {
                            // (4) see above
                            {
                                CSaveCalcInfo sci(pci, this);
                                BOOL fContentSizeOnly = pci->_fContentSizeOnly;
                                pci->_fContentSizeOnly = TRUE;
                                pci->_sizeParentForVert = pci->_sizeParent;

                                sizeMin.SetSize(lMinWidth, 0);
                                pci->_smMode = SIZEMODE_NATURALMIN;
                                grfReturn |= CalcSizeCore(pci, (PSIZE)&sizeMin, (PSIZE)&sizeMinWidth);

                                pci->_fContentSizeOnly = fContentSizeOnly;
                            }

                            // 
                            // We have both min and max sizes. There are following cases:
                            //
                            // (a) if we underlow for min, then use min as size
                            // (b) if sulution is between min and max, we need to search for sulution
                            //
                            if (   (lUserHeight > 0 && lUserHeight < sizeMin.cv) 
                                || pci->_sizeParent.cy < sizeMin.cv)
                            {
                                // (b) Search for solution
                                BOOL fContentSizeOnly = pci->_fContentSizeOnly;
                                pci->_fContentSizeOnly = TRUE;

                                fNeedRecalc = FALSE;
                                grfReturn |= CalcSizeSearch(pci, sizeMax.cu, 
                                    (lUserHeight > 0) ? lUserHeight : pci->_sizeParent.cy, 
                                    (PSIZE)&sizeMin, (PSIZE)&sizeMax, (PSIZE)&size);

                                pci->_fContentSizeOnly = fContentSizeOnly;
                            }
                            else
                            {
                                // (a) We can measure at min and we fit to available height, so use it.
                                size = sizeMin;
                            }
                        }

                        //
                        // Recalc layout if:
                        // * we haven't sized at calculated size (fNeedRecalc == TRUE)
                        // * calculated height is smaller than user height -- if its smaller 
                        //
                        if (fNeedRecalc || (size.cv < lUserHeight))
                        {
                            // NATURALMIN mode doesn't do any alignment and it sizes to content size
                            // Hence need to recal text.
                            pci->_grfLayout |= LAYOUT_FORCE;

                            pci->_sizeParentForVert = pci->_sizeParent;
                            size.cv = 0;
                            grfReturn |= CalcSizeCore(pci, (PSIZE)&size);
                        }
                        // Block element without specified height need to be sized to parent's height.
                        // Positioned elements should size to content.
                        CFlowLayout * pFLParent = pNode->Parent() ? pNode->Parent()->GetFlowLayout(LayoutContext()) : NULL;
                        BOOL fBlockInContext =    !pFLParent
                                               || pFLParent->IsElementBlockInContext(pNode->Element());
                        if (   cuvHeight.IsNullOrEnum() 
                            && fBlockInContext
                            && !pFF->IsPositioned())
                        {
                            CDispNode * pdn = GetElementDispNode();
                            if (pdn)
                            {
                                LONG lParentHeight = pci->_sizeParent.cy;
                                if (pFF->_fHasMargins)
                                {
                                    CUnitValue cuvMargin;
                                    cuvMargin = pFF->GetLogicalMargin(SIDE_TOP, pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
                                    if (!cuvMargin.IsNullOrEnum())
                                    {
                                        lParentHeight -= cuvMargin.YGetPixelValue(pci, pci->_sizeParent.cy,
                                                            pNode->GetFontHeightInTwips(&cuvMargin));
                                    }
                                    cuvMargin = pFF->GetLogicalMargin(SIDE_BOTTOM, pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
                                    if (!cuvMargin.IsNullOrEnum())
                                    {
                                        lParentHeight -= cuvMargin.YGetPixelValue(pci, pci->_sizeParent.cy,
                                                            pNode->GetFontHeightInTwips(&cuvMargin));
                                    }
                                }
                                size.cv = max(size.cv, lParentHeight);
                                SizeDispNode(pci, CSize(size.cu, size.cv), FALSE);
                            }
                        }
                        ((CSize *)psize)->SetSize(size.cu, size.cv);
                    }
               }
            }
            break;
        }

        case SIZEMODE_SET:
#if DBG==1
            if (_sizeMax.cv >= 0)
                MtAdd(Mt(LFCCalcSizeSetTotal), 1, 0);
#endif
            // fall thru'
        case SIZEMODE_FULLSIZE:
        case SIZEMODE_PAGE:
            Assert(psize->cx >= 0);
            grfReturn |= CalcSizeCore(pci, psize, psizeDefault);
            break;

        case SIZEMODE_MINWIDTH:
            // MINWIDTH mode shouldn't be called for layouts with changed layout flow
            // because of special MIN/MAX pass
        default:
            Assert(FALSE);
            break;
        }
        pci->_fContentSizeOnly = fContentSizeOnly;
    }

    return grfReturn;
}

DWORD
CFlowLayout::CalcSizeSearch(CCalcInfo * pci,
                            LONG lWidthStart,       // (IN)  last used logical width (for stop algorithm)
                            LONG lHeightProp,       // (IN)  requested logical height
                            const SIZE * psizeMin,  // (IN)  minimum size
                            const SIZE * psizeMax,  // (IN)  maximum size
                            SIZE * psize)           // (OUT) output size
{
    DWORD grfReturn = 0;
    BOOL fNeedRecalc = FALSE;
    BOOL fDone = FALSE;
    BOOL fFastSolution = TRUE;
    BOOL fViewChain =   pci->GetLayoutContext() 
                    &&  pci->GetLayoutContext()->ViewChain();

    CSizeUV start(psizeMin->cx, psizeMin->cy);
    CSizeUV end(psizeMax->cx, psizeMax->cy);
    CSizeUV sizeProp;
    CSizeUV sizeChar;
    LONG dur, dvr, durOld;

    dur = lWidthStart;
    dvr = 0;

    GetAveCharSize(pci, (PSIZE)&sizeChar);

    //
    // Find cell's width for specified height
    // Start search of most accurate solution.
    //
    while (!fDone)
    {
        // This assert may fire. If it does, then its an interesting case which needs to be handled below.
        Assert(start.cv > end.cv);

        //
        // Averaging the area of the layout and then dividing by the proposed v-dimension 
        // to get the U dimension to measure at 
        //
        durOld = dur;

        //  use floating point arithmetic to avoid overflow numarical overflow in hi-res modes : 
        dur =  IntNear(    (((double)start.cu * (double)start.cv + (double)end.cu * (double)end.cv) * 0.5) 
                          / ((double)lHeightProp) );

        if (fFastSolution)
        {
            LONG durNew;
            durNew = (psizeMax->cx * psizeMax->cy) / lHeightProp;
            // keep within min/max range
            durNew = max(min(durNew, psizeMax->cx), psizeMin->cx);

            dur = max(durNew, dur);
        }
        else
        {
            // Note here we are using BOTH the hint from the area of the cell
            // and the mid-point of the current range. This allows us to converge
            // to a solution faster than if we used either one individually.
            dur = (dur + (start.cu + end.cu) / 2) / 2;
        }
        // Make dur a multiple of ave char width
        if (sizeChar.cu)
            dur = sizeChar.cu * (1 + ((dur - 1) / sizeChar.cu));
        // The above snapping to multiple of durMin may put us beyond end.cu, so
        // let us prevent that.
        dur = min(dur, end.cu);

        if (    fViewChain
             && ElementCanBeBroken() )        
        {
            //  In print view pci->_cxAvailForVert is transformed pci->_cyAvail, 
            //  and here we should not be bigger that that. 
            Assert(pci->_cxAvailForVert > 0);
            dur = min(dur, (LONG)pci->_cxAvailForVert);
        }

        if (dur == durOld)
        {
            // Avoid infinite loop; reduce dur by sizeChar.cu and keep it in our search range
            dur = max(start.cu, dur - sizeChar.cu);
        }

        sizeProp.SetSize(dur, 0);
        grfReturn |= CalcSizeCore(pci, (PSIZE)&sizeProp);
        dvr = sizeProp.cv;

        // 
        // Note in the fastSolution, we do not check if the computed dvr is within
        // 'x' percent of dvrmax (the proposed v value). Hence, if we are leaving 
        // too much white space it is because of the fastSolution. We can fix this
        // if needed, but will sacrifice perf for it.
        //
        // Note: in the fastSolution, we use larger tolerance than in regular search pass.
        //
        if (    dvr <= lHeightProp 
            &&  (   (   (fFastSolution && dvr >= (LONG)(lHeightProp * ccErrorAcceptableLowForFastSolution))
                    ||  dvr >= (LONG)(lHeightProp * ccErrorAcceptableLow)))
                    //  In print view we may have no content left to calc so just leave.
                ||  (   fViewChain 
                    &&  ElementCanBeBroken() 
                    &&  !pci->_fLayoutOverflow)   )
        {
            fDone = TRUE;
        }

        //
        // This is a bad case, we have ended up with a dvr which is greater than the
        // max which we had reported / smaller than the min which we had reported.
        // In this case, we will just size to min v. (actually not min v but the
        // last computed v which was lesser than the proposed v)
        //
        else if (dvr < end.cv || dvr > start.cv)
        {
            fDone = fNeedRecalc = TRUE;
            dur = end.cu;
            dvr = end.cv;
            MtAdd(Mt(LFCCalcSizeNaturalSlowAbort), 1, 0);
        }

        //
        // If we have reached the minimum resolution at which we will measure, then break.
        // We could go on till the difference is 1 px between start and end, but in most
        // cases there is little added value by computing beyond the width of a character
        // (i.e. durMin).
        //
        else if (sizeChar.cu >= (end.cu - start.cu) / 2)
        {
            fDone = TRUE;
            if (dvr > lHeightProp)
            {
                fNeedRecalc = TRUE;
                dur = end.cu;
                dvr = end.cv;
            }
        }

        //
        // If we have reached end point again, then break.
        //
        else if (dur == end.cu && dvr == end.cv)
        {
            fDone = TRUE;
            fNeedRecalc = TRUE;
            dur = end.cu;
            dvr = end.cv;
        }

        // This is the case where the above approximation algorithmus hasn't
        // come up with a real progress. dur and dvr felt back to start.cu and
        // start.cv. But in that case dvr is greater than lHeightProp and this
        // is not a proper solution. We force a progress by increasing
        // start.cu by one average character. 
        else if (dur == start.cu && dvr == start.cv)
        {
            Assert(dvr > lHeightProp);

            dur += sizeChar.cu;
            start.SetSize (dur, 0);
            grfReturn |= CalcSizeCore(pci, (PSIZE)&start);

            fDone = (   start.cv <= lHeightProp // if the changes lead to a solution break
                    ||  dvr == start.cv );      // or no progress was made 
            dvr = start.cv;
        }

        //
        // Preare to the next iteration step.
        //
        else
        {
            // Reduce searching range
            if (dvr > lHeightProp)
                start.SetSize(dur, dvr);
            else
                end.SetSize(dur, dvr);
        }

        if (fFastSolution)
        {
            fFastSolution = FALSE;
#if DBG==1
            if (fDone)
                MtAdd(Mt(LFCCalcSizeNaturalFast), 1, 0);
            else
                MtAdd(Mt(LFCCalcSizeNaturalSlow), 1, 0);
#endif
        }
    } // while(!fDone)

    ((CSize*)psize)->SetSize(dur, dvr);
    if (fNeedRecalc)
    {
        psize->cy = 0;
        grfReturn |= CalcSizeCore(pci, psize);
    }

    return grfReturn;
}

//+-------------------------------------------------------------------------
//
//  Method:     CFlowLayout::CalcSizeCore
//
//  Synopsis:   Calculate the size of the object
//
//      the basic flow of this routine is as follows:
//      0. get the original size.
//      1. determin if we need to recalc, if Yes :
//          a. get the default size (as set by height= and widht= attributes)
//          b. get the padding and border sizes (this leaves a rough idea for content size
//          c. CalcTextSize
//          d. deal with scroll paddin
//          e. if this is a layoutBehavior delegate 
//          f. if this element is sizeToContent and has % children recalc children
//          g. if (f) gives us a new size redelegate (e)
//      2. Deal with absolute positioned children
//      3. Set the new size values in the dispNode
//
//--------------------------------------------------------------------------
DWORD
CFlowLayout::CalcSizeCore(CCalcInfo * pci, 
                          SIZE      * psize, 
                          SIZE      * psizeDefault)
{
    if (    ElementOwner()->HasMarkupPtr() 
        &&  ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document()  )
    {
        return (CalcSizeCoreCSS1Strict(pci, psize, psizeDefault));
    }

    return (CalcSizeCoreCompat(pci, psize, psizeDefault));
}

DWORD
CFlowLayout::CalcSizeCoreCompat( CCalcInfo * pci,
                           SIZE      * psize,
                           SIZE      * psizeDefault)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CFlowLayout::CalcSizeCoreCompat L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    WHEN_DBG(SIZE psizeIn = *psize);
    WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0

    CheckSz(    !ElementOwner()->HasMarkupPtr() 
            ||  (   !ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document() 
                &&  !ElementOwner()->GetMarkupPtr()->IsHtmlLayout() ), 
           "CFlowLayout::CalcSizeCoreCompat is called to calculate CSS1 Strict Layout");

    CTreeNode * pNode       = GetFirstBranch();
    // BODYs inside viewlinks in general are NOT considered "main body"s,
    // but BODYs inside layout rects (which are viewlinks) ARE.
    BOOL fMainBody =   (    Tag() == ETAG_BODY
                        &&  !ElementOwner()->IsInViewLinkBehavior(FALSE) );

#if DBG == 1
    if (pNode->GetFancyFormat(LC_TO_FC(LayoutContext()))->_fLayoutFlowChanged)
    {
        MtAdd(Mt(LFCCalcSizeCore), 1, 0);
    }
#endif

    CSaveCalcInfo   sci(pci, this);
    CScopeFlag      csfCalcing(this);

    BOOL  fNormalMode = pci->IsNaturalMode();
    BOOL  fRecalcText = FALSE;
    BOOL  fWidthChanged, fHeightChanged;
    CSize sizeOriginal;
    SIZE  sizeSave;
    DWORD grfReturn;
    CPeerHolder * pPH = ElementOwner()->GetLayoutPeerHolder();

    AssertSz(pci, "no CalcInfo passed to CalcSizeCoreCompat");
    Assert(psize);

    pci->_pMarkup = GetContentMarkup();

    Assert(!IsDisplayNone());

    BOOL fViewChain   = (pci->GetLayoutContext() && pci->GetLayoutContext()->ViewChain());

    // NOTE (KTam): For cleanliness, setting the context in the pci ought to be done
    // at a higher level -- however, it's really only needed for layouts that can contain
    // others, which is why we can get away with doing it here.
    if ( !pci->GetLayoutContext() )
    {
        pci->SetLayoutContext( LayoutContext() );
    }
    else
    {
        Assert(pci->GetLayoutContext() == LayoutContext() 
            || pci->GetLayoutContext() == DefinedLayoutContext() 
            // while calc'ing table min max pass we use original cell layout 
            || pci->_smMode == SIZEMODE_MMWIDTH
            || pci->_smMode == SIZEMODE_MINWIDTH);
    }
    
    Listen();

#if DO_PROFILE
    // Start icecap if we're in a table cell.
    if (ElementOwner()->Tag() == ETAG_TD ||
        ElementOwner()->Tag() == ETAG_TH)
    {
        StartCAP();
    }
#endif
  
    //
    // Set default return values and initial state
    //
    if (_fForceLayout)
    {
        pci->_grfLayout |= LAYOUT_FORCE;
        _fForceLayout = FALSE;
    }

    grfReturn = (pci->_grfLayout & LAYOUT_FORCE);

    if (pci->_grfLayout & LAYOUT_FORCE)
    {
        SetSizeThis( TRUE );
        _fAutoBelow        = FALSE;
        _fPositionSet      = FALSE;
        _fContainsRelative = FALSE;
    }

    GetSize(&sizeOriginal);

    fWidthChanged   = fNormalMode && _sizePrevCalcSizeInput.cx != psize->cx;
    fHeightChanged  = fNormalMode && _sizePrevCalcSizeInput.cy != psize->cy;

    _sizePrevCalcSizeInput = *psize;

    //
    // If height has changed, mark percentage sized children as in need of sizing
    // (Width changes cause a full re-calc and thus do not need to resize each
    //  percentage-sized site)
    //

    if (    fNormalMode
        && !fWidthChanged
        && !ContainsVertPercentAttr()
        &&  fHeightChanged)
    {
        long fContentsAffectSize = _fContentsAffectSize;

        _fContentsAffectSize = FALSE;
        ResizePercentHeightSites();
        _fContentsAffectSize = fContentsAffectSize;
    }

    //
    // For changes which invalidate the entire layout, dirty all of the text
    //

    fRecalcText =   (fNormalMode && (   IsDirty()
                                    ||  IsSizeThis()
                                    ||  fWidthChanged
                                    ||  fHeightChanged))
                ||  (pci->_grfLayout & LAYOUT_FORCE)
                ||  (pci->_smMode == SIZEMODE_SET)
                ||  (pci->_smMode == SIZEMODE_MMWIDTH && !_fMinMaxValid)
                ||  (pci->_smMode == SIZEMODE_MINWIDTH && !_fMinMaxValid);

    if (!fRecalcText && fViewChain && ElementCanBeBroken()) // (olego) fix for 21322
    {
        // propogate information stored in page break (if any) into pci 
        CLayoutBreak *  pLayoutBreak; 

        pci->GetLayoutContext()->GetEndingLayoutBreak(ElementOwner(), &pLayoutBreak);
        CheckSz(pLayoutBreak, "Ending layout break is expected at this point");

        if (pLayoutBreak)
        {
            if (DYNCAST(CFlowLayoutBreak, pLayoutBreak)->LayoutBreakType() == LAYOUT_BREAKTYPE_LINKEDOVERFLOW)
                pci->_fLayoutOverflow = TRUE;
        }
    }

    //
    // Cache sizes and recalculate the text (if required)
    //

    if (fRecalcText)
    {
        BOOL        fNeedShiftLines = FALSE;
        SIZE        sizeUser    = g_Zero.size;
        SIZE        sizePadding = g_Zero.size;
        SIZE        sizeInset   = g_Zero.size;
        SIZE        sizeDefault;
        SIZE        sizeProposed = {0,0};
        CBorderInfo bi;
        LONG        bdrH = 0 , bdrV = 0;
        BOOL        fContentAffectWidth = FALSE;
        BOOL        fContentAffectHeight = FALSE;
        BOOL        fHasWidth = FALSE;
        BOOL        fHasHeight = FALSE;
        BOOL        fHasDefaultWidth  = FALSE;
        BOOL        fHasDefaultHeight = FALSE;
        BOOL        fWidthClipContent = FALSE;
        BOOL        fHeightClipContent = FALSE;
        const CFancyFormat * pFF = pNode->GetFancyFormat(LC_TO_FC(LayoutContext()));
        const CCharFormat  * pCF = pNode->GetCharFormat(LC_TO_FC(LayoutContext()));
        BOOL fVerticalLayoutFlow = pCF->HasVerticalLayoutFlow();
        BOOL fWritingModeUsed = pCF->_fWritingModeUsed;
        BOOL fWidthPercent  = pFF->IsLogicalWidthPercent(fVerticalLayoutFlow, fWritingModeUsed);
        BOOL fHeightPercent = pFF->IsLogicalHeightPercent(fVerticalLayoutFlow, fWritingModeUsed);
        const CUnitValue & cuvWidth  = pFF->GetLogicalWidth(fVerticalLayoutFlow, fWritingModeUsed);
        const CUnitValue & cuvHeight = pFF->GetLogicalHeight(fVerticalLayoutFlow, fWritingModeUsed);
        styleOverflow overflowX;
        styleOverflow overflowY;
        BOOL fNeedToSizeDispNodes = pci->_fNeedToSizeContentDispNode;

        BOOL fHasInsets = FALSE;
        BOOL fSpecialLayout =    Tag() == ETAG_TD
                             ||  Tag() == ETAG_TH
                             ||  Tag() == ETAG_CAPTION
                             ||  Tag() == ETAG_TC
                             ||  fMainBody
                             ||  Tag() == ETAG_INPUT
                                 && DYNCAST(CInput, ElementOwner())->GetType() == htmlInputFile;

        CElement::CLock Lock(ElementOwner(), CElement::ELEMENTLOCK_SIZING);
            
        //
        // If dirty, ensure display tree nodes exist
        //
        if (    IsSizeThis()
            &&  fNormalMode
            &&  (EnsureDispNode(pci, (grfReturn & LAYOUT_FORCE)) == S_FALSE))
        {
            grfReturn |= LAYOUT_HRESIZE | LAYOUT_VRESIZE;
        }

        //
        // don't move this above Ensuredispnode
        // since the element overflow might be changed
        //

        overflowX = pFF->GetLogicalOverflowX(   fVerticalLayoutFlow,
                                                fWritingModeUsed);
        overflowY = pFF->GetLogicalOverflowY(   fVerticalLayoutFlow,
                                                fWritingModeUsed);


        if (fViewChain)
        {
            // 
            //  Defensive code if there is no available height to fill prohibit breaking. 
            //
            if (pci->_cyAvail <= 0 )
            {
                SetElementCanBeBroken(FALSE);
            }

            // TODO (112467, olego): Now we have CLayout::_fElementCanBeBroken bit flag 
            // that prohibit layout breaking in Page View. This approach is not suffitient 
            // enouth for editable Page View there we want this property to be calculated 
            // dynamically depending on layout type and layout nesting position (if parent 
            // has it child should inherit). 
            // This work also will enable CSS attribute page-break-inside support.

            if (!fMainBody && ElementCanBeBroken())
            {
                //  Allow to break only if 
                //  1) element is not absolute positioned; 
                //  2) doesn't have certain overflow attribute set; 
                SetElementCanBeBroken(    !pFF->IsAbsolute()
                                        && overflowX != styleOverflowScroll 
                                       && overflowX != styleOverflowAuto 
                                       && overflowY != styleOverflowScroll
                                       && overflowY != styleOverflowAuto    );
            }

            fViewChain = fViewChain && ElementCanBeBroken();
        }

        //
        // exclude TD, TH and input type=file
        //
        if (!fSpecialLayout)
        {
            fHasWidth  = !cuvWidth.IsNullOrEnum();
            fHasHeight = !cuvHeight.IsNullOrEnum();
            fWidthClipContent  = (  overflowX != styleOverflowVisible
                                 && overflowX != styleOverflowNotSet);
            fHeightClipContent = (  overflowY != styleOverflowVisible 
                                 && overflowY != styleOverflowNotSet);

            if (ElementOwner()->GetBorderInfo(pci, &bi, FALSE, FALSE))
            {
                bdrH = bi.aiWidths[SIDE_LEFT] + bi.aiWidths[SIDE_RIGHT];
                bdrV = bi.aiWidths[SIDE_BOTTOM] + bi.aiWidths[SIDE_TOP];
            }

            // Get element's default size
            // Buttons don't have default w/h and return a 0 default size.
            // Text INPUTs and TEXTAREAs have both default width and height.
            // Marquees have default height.
            sizeDefault = *psize;
            GetDefaultSize(pci, sizeDefault, &fHasDefaultWidth, &fHasDefaultHeight);

            // use astrology to determine if we need to size to content
            if (    !fHasWidth 
                &&  !fHasDefaultWidth
                &&  !fMainBody
                &&  (
                            pFF->_bStyleFloat == styleStyleFloatLeft
                        ||  pFF->_bStyleFloat == styleStyleFloatRight
                        ||  !ElementOwner()->IsBlockElement()
                        ||  ElementOwner()->IsAbsolute()
                    )
                &&
                    // If we're in home publisher, we don't want to size to content.
                    (
                            !(Doc()->_fInHomePublisherDoc || g_fInHomePublisher98)
                        ||  !ElementOwner()->IsAbsolute()
                    )
// TODO (lmollico): should go away
                &&  ElementOwner()->_etag != ETAG_FRAME
                )
            {
                _fSizeToContent = TRUE;
            }
            else
            {
                _fSizeToContent = FALSE;
            }

            if (fWidthPercent && !fNormalMode)
            {
                sizeUser.cx = 0;
            }
            else
            {
                if (fHasWidth)
                {
                    LONG lParentWidth;
                    if (   fWidthPercent 
                        && ElementOwner()->IsAbsolute() 
                        && fVerticalLayoutFlow)
                    {
                        lParentWidth = pci->_sizeParent.cx;
                        CTreeNode   *pParentNode   = pNode->Parent();
                        CFlowLayout *pLayoutParent = pParentNode ? pParentNode->GetFlowLayout(pci->GetLayoutContext()) : 0;
                        CDisplay    *pdpParent     = pLayoutParent ? pLayoutParent->GetDisplay() : 0;
                        long lcxPadding = 0;
                        long lPadding[SIDE_MAX];

                        if (pdpParent)
                        {
                            pdpParent->GetPadding(pci, lPadding, pci->_smMode == SIZEMODE_MMWIDTH);

                            // padding is in parent coordinate system, but we need it in global
                            if (pParentNode->GetCharFormat()->HasVerticalLayoutFlow())
                                lcxPadding = lPadding[SIDE_LEFT] + lPadding[SIDE_RIGHT];
                            else
                                lcxPadding = lPadding[SIDE_TOP] + lPadding[SIDE_BOTTOM];
                        }
                        // add padding to the width
                        lParentWidth += lcxPadding;
                    }
                    else if (   fWidthPercent 
                             && fVerticalLayoutFlow)
                    {
                        lParentWidth = 0;

                        // The loop to iterate parent branch up the tree to skip non-block parents (bug #108389)...
                        CTreeNode * pNodeParent = pNode->Parent();
                        while (pNodeParent && !pNodeParent->Element()->IsBlockElement())
                        {
                            pNodeParent = pNodeParent->Parent();
                        }
                        if (pNodeParent)
                        {
                            const CUnitValue & cuvWidthParent = pNodeParent->GetFancyFormat()->GetLogicalWidth(fVerticalLayoutFlow, fWritingModeUsed);
                            if (!cuvWidthParent.IsNullOrEnum() && !cuvWidthParent.IsPercent())
                            {
                                lParentWidth = cuvWidthParent.XGetPixelValue(pci, 0, pNodeParent->GetFontHeightInTwips(&cuvWidthParent));
                            }
                            else if (cuvWidthParent.IsPercent() || pNodeParent->Tag() == ETAG_BODY)
                            {
                                lParentWidth = pci->_sizeParent.cx;
                            }
                        }
                    }
                    else
                    {
                        lParentWidth = pFF->_fAlignedLayout ? pci->_sizeParent.cx : psize->cx;
                    }

                    sizeUser.cx = cuvWidth.XGetPixelValue(pci, lParentWidth,
                                    pNode->GetFontHeightInTwips(&cuvWidth));
                }
                else
                {
                    sizeUser.cx = sizeDefault.cx;
                }
            }

            if (fHeightPercent && !fNormalMode)
            {
                sizeUser.cy = 0;
            }
            else
            {
                if (fHasHeight)
                {
                    LONG lParentHeight = pci->_sizeParent.cy;
                    if (   fHeightPercent 
                        && ElementOwner()->IsAbsolute() 
                        && !fVerticalLayoutFlow)
                    {
                        CTreeNode   *pParentNode   = pNode->Parent();
                        CFlowLayout *pLayoutParent = pParentNode ? pParentNode->GetFlowLayout(pci->GetLayoutContext()) : 0;
                        CDisplay    *pdpParent     = pLayoutParent ? pLayoutParent->GetDisplay() : 0;
                        long lcyPadding = 0;
                        long lPadding[SIDE_MAX];

                        if (pdpParent)
                        {
                            pdpParent->GetPadding(pci, lPadding, pci->_smMode == SIZEMODE_MMWIDTH);

                            // padding is in parent coordinate system, but we need it in global
                            if (pParentNode->GetCharFormat()->HasVerticalLayoutFlow())
                                lcyPadding = lPadding[SIDE_LEFT] + lPadding[SIDE_RIGHT];
                            else
                                lcyPadding = lPadding[SIDE_TOP] + lPadding[SIDE_BOTTOM];
                        }
                        // add padding to the height
                        lParentHeight += lcyPadding;
                    }

                    // 
                    // Complience to CSS2 percentage sizing...
                    // 
                    // This code is to ignore percentage height attribute if the element's *block* parent 
                    // doesn't have height explicitly specified. There are several tricky points here...
                    //
                    //  If the element doesn't have *percentage* size OR if this is a iframe do call right away...
                    if (!fHeightPercent)
                    {
                        sizeUser.cy = cuvHeight.YGetPixelValue(pci, lParentHeight,
                                    pNode->GetFontHeightInTwips(&cuvHeight));
                    }
                    else 
                    {
                        BOOL        fIgnoreUserPercentHeight = TRUE;

                        if (pFF->IsPositioned())
                        {
                            CElement *pElementZParent = pNode->ZParent(); 
                            Assert( pElementZParent 
                                &&  "pElementZParent == NULL means the element is not in the Tree. Why are we measuring it anyway ?");

                            if (pElementZParent)
                            {
                                if (    pElementZParent->ShouldHaveLayout() 
                                    //  FUTURE (olego): we should try to avoid "special" checks like this:
                                    ||  (  pElementZParent->TagType() == ETAG_GENERIC 
                                        && pElementZParent->HasPeerHolder()
                                        )    
                                    ||  (  pElementZParent->TagType() == ETAG_ROOT
                                        && pElementZParent->HasMasterPtr()
                                        )
                                   )
                                {
                                    sizeUser.cy = cuvHeight.YGetPixelValue(pci, lParentHeight,
                                                pNode->GetFontHeightInTwips(&cuvHeight));

                                    if (    !sizeUser.cy
                                        &&  pci->_fTableCalcInfo    )
                                    {

                                        CTreeNode * pNodeCur;

                                        // The loop to iterate parent branch up the tree to skip non-block parents (bug #108389)...
                                        for (pNodeCur = pNode->Parent(); pNodeCur; pNodeCur = pNodeCur->Parent())
                                        {
                                            if (    pNodeCur->Tag() == ETAG_TD 
                                                ||  pNodeCur->Tag() == ETAG_TH  )
                                            {
                                                CTableCalcInfo *ptci = (CTableCalcInfo *)pci;

                                                Assert(     ptci->_pRow 
                                                        &&  ptci->_pRowLayout 
                                                        &&  ptci->_pFFRow 
                                                        &&  ptci->_pRowLayout->GetFirstBranch()->GetFancyFormat(LC_TO_FC(ptci->GetLayoutContext())) == ptci->_pFFRow );

                                                //  If the layout is inside a table cell it's provided with zero height 
                                                //  during table normal calc size pass (always). If table cell has size 
                                                //  set, the layout will have a chance to calc itself one more time during 
                                                //  set calc size pass. We want to predict this and still override natual 
                                                //  size in this case.

                                                //  NOTE: checks below MUST stay consistent with code in CTableLayout::SetCellPositions !!!
                                                if (    ptci->_fTableHasUserHeight 
                                                    ||  ptci->_pRow->RowLayoutCache()->IsHeightSpecified() 
                                                    ||  ptci->_pFFRow->IsHeightPercent()    )
                                                {
                                                    sizeUser.cy = 1;
                                                }
                                            }
                                            // If this is a block element and not a table cell stop searching 
                                            else if (pNodeCur->Element()->IsBlockElement())
                                            {
                                                break;
                                            }
                                        }
                                    }

                                    fIgnoreUserPercentHeight = FALSE;
                                } 
                            }
                        }
                        else 
                        {
                            CTreeNode * pNodeCur;

                            // The loop to iterate parent branch up the tree to skip non-block parents (bug #108389)...
                            for (pNodeCur = pNode->Parent(); pNodeCur; pNodeCur = pNodeCur->Parent())
                            {
                                // If the current element has/should have a layout or 
                                // (bug #108387) this is a generic element with peer holder 
                                // (in which case it has no layout but should be treated as 
                                // an element with one)... Do calculations and stop.
                                if (    pNodeCur->Element()->ShouldHaveLayout() 
                                    //  FUTURE (olego): we should try to avoid "special" checks like this:
                                    ||  (  pNodeCur->Element()->TagType() == ETAG_GENERIC 
                                        && pNodeCur->Element()->HasPeerHolder()
                                        )    
                                    ||  (  pNodeCur->Element()->TagType() == ETAG_ROOT
                                        && pNodeCur->Element()->HasMasterPtr()
                                        )
                                   )
                                {
                                    sizeUser.cy = cuvHeight.YGetPixelValue(pci, lParentHeight,
                                                pNode->GetFontHeightInTwips(&cuvHeight));

                                    if (    !sizeUser.cy
                                        &&  (   pNodeCur->Tag() == ETAG_TD 
                                            ||  pNodeCur->Tag() == ETAG_TH )
                                        //  make sure this cell is inside a table.
                                        &&  pci->_fTableCalcInfo    )
                                    {
                                        CTableCalcInfo *ptci = (CTableCalcInfo *)pci;

                                        Assert(     ptci->_pRow 
                                                &&  ptci->_pRowLayout 
                                                &&  ptci->_pFFRow 
                                                &&  ptci->_pRowLayout->GetFirstBranch()->GetFancyFormat(LC_TO_FC(ptci->GetLayoutContext())) == ptci->_pFFRow );

                                        //  If the layout is inside a table cell it's provided with zero height 
                                        //  during table normal calc size pass (always). If table cell has size 
                                        //  set, the layout will have a chance to calc itself one more time during 
                                        //  set calc size pass. We want to predict this and still override natual 
                                        //  size in this case.

                                        //  NOTE: checks below MUST stay consistent with code in CTableLayout::SetCellPositions !!!
                                        if (    ptci->_fTableHasUserHeight 
                                            ||  ptci->_pRow->RowLayoutCache()->IsHeightSpecified() 
                                            ||  ptci->_pFFRow->IsHeightPercent()    )
                                        {
                                            sizeUser.cy = 1;
                                        }
                                    }

                                    fIgnoreUserPercentHeight = FALSE;
                                    break;
                                } 
                                // If this is a block element and it has no layout 
                                // (previous check failed) ignore percentage height by 
                                // breaking out of the loop.
                                else if (pNodeCur->Element()->IsBlockElement())
                                {
                                    break;
                                }
                            }
                        }

                        // bug (70270, 104514) % sized Iframes in tables are not being sized properly.
                        // this is because the parent height comes in as 0, and we don't default
                        // back to our defult size, so take the size as the specified percentage
                        // of the defualt height.
                        if (   fNormalMode
                            && Tag() == ETAG_IFRAME
                            && sizeUser.cy == 0)
                        {
                            sizeUser.cy = cuvHeight.GetPercentValue(
                                           CUnitValue::DIRECTION_CY, 
                                           (lParentHeight == 0) ? 150 : lParentHeight);
                            fIgnoreUserPercentHeight = FALSE;
                        }

                        if (fIgnoreUserPercentHeight) 
                        {
                            //  (bug #108565) at this point we fail to set user specified 
                            //  height. This may happen because of the code above decided 
                            //  not to apply it or if this layout is inside table cell (and 
                            //  its been provided with 0 parent height). At this point 
                            //  logical to drop fHasHeight and fHeightPercent flags to 
                            //  prevent confusion of the code below...
                            fHasHeight      = FALSE;
                            fHeightPercent  = FALSE;
                            sizeUser.cy     = sizeDefault.cy;
                        }
                    }

                    if (fHasHeight)
                    {
                        if (fViewChain)
                        {
                            sizeUser.cy = GetUserHeightForBlock(sizeUser.cy);
                        }
                    }
                }
                else
                {
                    sizeUser.cy = sizeDefault.cy;
                }
            }

            // The BODY's content never affects its width/height (style specified
            // w/h and/or container size (usually <HTML> and/orframe window) determine
            // BODY size).
            // In general, contents affects w/h if:
            //    1.) w/h isn't style-specified and there's no default w/h.
            // OR 2.) overflowX/Y == visible or not set (meaning f*ClipContent is false).
            // 
            // once we can support vertical center, we can remove the Tag
            //         check for buttons
            fContentAffectWidth =     !fMainBody
                                  &&  Tag() != ETAG_FRAME
                                  &&  Tag() != ETAG_IFRAME
                                  &&  (   !fHasWidth && !fHasDefaultWidth
                                      ||  !fWidthClipContent
                                      ||  Tag() == ETAG_BUTTON
                                      ||  Tag() == ETAG_INPUT && DYNCAST(CInput, ElementOwner())->IsButton()
                                      );
            fContentAffectHeight =    !fMainBody
                                  &&  Tag() != ETAG_FRAME
                                  &&  Tag() != ETAG_IFRAME
                                  &&  (   !fHasHeight && !fHasDefaultHeight
                                      ||  !fHeightClipContent
                                      ||  !sizeUser.cy 
                                      ||  Tag() == ETAG_BUTTON
                                      ||  Tag() == ETAG_INPUT && DYNCAST(CInput, ElementOwner())->IsButton()
                                      );
            _fContentsAffectSize = fContentAffectWidth || fContentAffectHeight;

            // set the (proposed) size to the default/attr-defined size + parentPadding.
// TODO (lmollico): should go away
            if (ElementOwner()->_etag != ETAG_FRAME)
                *psize = sizeUser;

            if (   fNormalMode
                || (   pci->_smMode==SIZEMODE_MMWIDTH 
                    && ( fHeightPercent || fWidthPercent)))
            {
                if (   fContentAffectHeight 
                    && !fHeightPercent )
                {
                    // when dealing with vertical flow we can't assume a height of zero as we size
                    // to the content, this is because we will end up word wrapping as this height
                    // is used as a width.
                    psize->cy = 0;
                }

                //
                // only marquee like element specify a scroll padding
                // which is used for vertical scrolling marquee
                // 
                sizePadding.cx  = max(0L, sizeUser.cx - bdrH);
                sizePadding.cy  = max(0L, sizeUser.cy - bdrV);

                GetScrollPadding(sizePadding);


                if (sizePadding.cx || sizePadding.cy)
                {
                    // make sure the display is fully recalced with the paddings
                    _dp._defPaddingTop      = sizePadding.cy;
                    _dp._defPaddingBottom   = sizePadding.cy;
                    _dp._fDefPaddingSet     = !!sizePadding.cy;

                    // marquee always size to content
                    _fSizeToContent = TRUE;
                }
            }

            if (    !ParentClipContent()
                &&  ElementOwner()->IsAbsolute()
                &&  (!fHasHeight || !fHasWidth)
               )
            {
                CRect rcSize;
                CalcAbsoluteSize(pci, psize, &rcSize);

                if (pNode->GetFancyFormat(LC_TO_FC(LayoutContext()))->_fLayoutFlowChanged)
                {
                    rcSize.SetWidth(max(rcSize.Width(), sizeUser.cx));
                    rcSize.SetHeight(max(rcSize.Height(), sizeUser.cx));
                }

                //  109440, for FRAME's that are APE, we do not want the height set to 0
                psize->cx = !fHasWidth  ? max(0L, rcSize.Width()) : max(0L, sizeUser.cx);
                psize->cy = !fHasHeight 
                                ? ((Tag() == ETAG_FRAME) ? max(0L, rcSize.Height()) : 0 )
                                : max(0L, sizeUser.cy);
            }

            // in NF, IFrames use the std flowlayout. For back compat the size specified (even if default)
            // needs to be INSIDE the borders, whereas for all others it is outside.  Since the border sizes
            // are removed from the proposedSize in CalcTextSize
            if (Tag() == ETAG_IFRAME)
            {
                CDispNodeInfo   dni;
                GetDispNodeInfo(&dni, pci, TRUE);

                if (dni.GetBorderType() != DISPNODEBORDER_NONE)
                {
                    CRect   rcBorders;

                    dni.GetBorderWidths(&rcBorders);

                    if (!fWidthPercent)
                        psize->cx    += rcBorders.left + rcBorders.right;

                    if (!fHeightPercent)
                        psize->cy    += rcBorders.top  + rcBorders.bottom;
                }
            }

        }


        sizeProposed = *psize;

        //
        // Calculate the text
        //

        //don't do CalcTextSize in minmax mode if our text size doesn't affect us anyway.
        if(     _fContentsAffectSize || fNormalMode 
            ||  fWidthPercent)  //  preserving backward compat (bug 27982)
        {
            CalcTextSize(pci, psize, psizeDefault);
        }
        else if (pci->_smMode == SIZEMODE_MMWIDTH)
        {
            psize->cy = psize->cx;
        }

        sizeSave = *psize;

        //
        // exclude TD, TH and input type=file
        //
        if (!fSpecialLayout)
        {
            sizeInset = sizeUser;
            fHasInsets = GetInsets(pci->_smMode, sizeInset, *psize, fHasWidth, fHasHeight, CSize(bdrH, bdrV));
            if (sizeSave.cx != psize->cx)
            {
                grfReturn      |= LAYOUT_HRESIZE;
                fNeedShiftLines = TRUE;
            }

            if (fNormalMode)
            {
                if (sizePadding.cx || sizePadding.cy)
                {
                    SIZE szBdr;

                    szBdr.cx = bdrH;
                    szBdr.cy = bdrV;
                    // We need to call GetScrollPadding, because now we know the text size
                    // we will update scroll parameters

                    SetScrollPadding(sizePadding, *psize, szBdr);

                    fNeedShiftLines = TRUE;
                    *psize = sizeUser;

                    // if the marquee like element is percentage sized or
                    // its size is not specified, its size should be the
                    // default size.
                    // if the default size or the css style size is less 
                    // or equal than 0, marquee like element should not be sized
                    // as such according to IE3 compatibility requirements

                    if ((fHeightPercent || !fHasHeight) && sizeUser.cy <= 0)
                    {
                        psize->cy = _dp.GetHeight() + bdrV; 
                    }
                    else if (!ContainsVertPercentAttr() && sizePadding.cx > 0)
                    {
                        //
                        // if the marquee is horizontal scrolling,
                        // the height should be at least the content high by IE5.
                        //
                        psize->cy = max(psize->cy, _dp.GetHeight() + bdrV);
                    }

                    if (!fHasWidth && sizeUser.cx <= 0)
                    {
                        psize->cx = _dp.GetWidth() + bdrH;
                    }
                }

                else if (fHasWidth && (fWidthClipContent || psize->cx < sizeUser.cx))
                {
                    if (psize->cx != sizeUser.cx)
                    {
                        fNeedShiftLines = TRUE;
                    }
                    psize->cx = max(0L, sizeUser.cx);
                }
                else if (   _fSizeToContent
                        && !((fHasDefaultWidth || fHasWidth || (sizeProposed.cx != psize->cx)) && fWidthClipContent))
                {
                    // when size to content and the width does not 
                    // clip the content, we need to clip on the parent
                    fNeedShiftLines = TRUE;

                    psize->cx = _dp.GetWidth() + bdrH;
                }

                if (fHasHeight)
                {
                    if (fViewChain)
                    {
                        if (psize->cy < sizeUser.cy)
                        {
                            psize->cy = max(0L, min(sizeUser.cy, (long)pci->_cyAvail));
                        }
                    }
                    else if (  !pci->_fContentSizeOnly
                            && sizeUser.cy 
                            && (   fHeightClipContent 
                                || psize->cy < sizeUser.cy))
                    {
                        psize->cy = max(0L, sizeUser.cy);
                    }
                }
            }
            else
            {
                if (fHasWidth || !_fContentsAffectSize)
                {
                    // cy contains the min width
                    if (pci->_smMode == SIZEMODE_MMWIDTH)
                    {
                        if (fWidthClipContent)
                        {
                            if (!fWidthPercent)
                            {
                                psize->cy = sizeProposed.cx;
                                psize->cx = psize->cy;
                            }
                        }
                        else
                        {
                            if (_fContentsAffectSize)
                            {
                                Assert(fHasWidth);
                                psize->cy = max(psize->cy, sizeProposed.cx);
                                if (!fWidthPercent)
                                    psize->cx = psize->cy;
                                Assert(psize->cx >= psize->cy);
                            }
                            else
                            {
                                if (!fWidthPercent)
                                {
                                    psize->cx = psize->cy = sizeProposed.cx;
                                }
                                else if (   Tag() == ETAG_IFRAME
                                         && pci->_smMode == SIZEMODE_MMWIDTH
                                         && sizeProposed.cx == 0)
                                {
                                    // bug 70270 - don't let minmax return 0 or else we will never display.
                                    psize->cy = 0; 
                                    psize->cx = cuvWidth.GetPercentValue(CUnitValue::DIRECTION_CX, 300);

                                }
                            }
                        }
                    }
                    else
                    {
                        // Something in TD causes min width to happen
                        if (   !_fContentsAffectSize
                            && fWidthPercent
                            && Tag() == ETAG_IFRAME
                            && sizeProposed.cx == 0
                            && pci->_smMode == SIZEMODE_MINWIDTH
                            )
                        {
                            // bug 70270
                            psize->cy = 0;
                            psize->cx = cuvWidth.GetPercentValue(CUnitValue::DIRECTION_CX, 300);
                        }
                        else
                        {
                            Assert(pci->_smMode == SIZEMODE_MINWIDTH);
                            *psize = sizeProposed;
                        }
                    }
                }
            }
        }

        //
        // Before we can cache the computed values and request layout tasks
        //  (positioning) we may need to give layoutBehaviors a chance to 
        //  modify the natural (trident-default) sizing of this element.
        //  e.g. a "glow behavior" may want to increase the size of the 
        //  element that it is instantiated on by 10 pixels in all directions,
        //  so that it can draw the fuzzy glow; or an external HTMLbutton
        //  is the size of its content + some decoration size.
        //
        if (   pPH   
            && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_MODIFYNATURAL))
        {
            POINT pt;

            pt.x = sizePadding.cx;
            pt.y = sizePadding.cy;

            DelegateCalcSize(BEHAVIORLAYOUTINFO_MODIFYNATURAL,
                             pPH, 
                             pci, 
                             CSize(_dp.GetWidth() + bdrH, _dp.GetHeight() + bdrV), 
                             &pt, psize);


            if (psize->cx != sizeUser.cx)
            {
                fNeedShiftLines = TRUE;
            }

            if (pt.x != sizePadding.cx)
            {
                sizeInset.cx += max(0L, pt.x - sizePadding.cx);
            }

            if (pt.y != sizePadding.cy)
            {
                sizeInset.cy += max(0L, pt.y - sizePadding.cy); 
            }
        }


        //
        // we have now completed the first pass of calculation (and possibly) delegation.
        // However, before we can finaly save the computed values, we have to verify that 
        // our percent sized children (if they exist) are resized, this is critical if we
        // ourselves are sized to content.
        //

        if (   fNormalMode 
            && !fSpecialLayout 
            && _fContentsAffectSize
            && (   ContainsHorzPercentAttr()
                || (ContainsVertPercentAttr() && fHasHeight)    )
           )
        {
            unsigned fcasSave = _fContentsAffectSize;
            BOOL     fpspSave = pci->_fPercentSecondPass;
            LONG     lUserHeightSave = sizeUser.cy;
            SIZE     sizeReDo;

            sizeReDo.cx = fHasWidth ? sizeProposed.cx : psize->cx;
            sizeReDo.cy = fHasHeight ? psize->cy : 0;

            _sizeReDoCache = sizeReDo;

            sizeUser = *psize;

            if (fViewChain)
            {
                pci->_fHasContent     = sci._fHasContent;
                pci->_fLayoutOverflow = 0;
            }

            pci->_fPercentSecondPass = TRUE;

            _fContentsAffectSize = FALSE;
            ResizePercentHeightSites();
            _fContentsAffectSize = fcasSave;

            CalcTextSize(pci, &sizeReDo, psizeDefault);

            if (sizeSave.cy != sizeReDo.cy && fContentAffectHeight)
            {
                SIZE szBdr;

                szBdr.cx = bdrH;
                szBdr.cy = bdrV;
                //
                // if we have increased the psize->cy, and we are delegating the size call
                // we need to give the control one more whack... but rememeber we have the
                // _fPercentSeconPass lit up so they can take the appropriate action.
                //
                if (   pPH   
                    && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_MODIFYNATURAL))
                {
                    DelegateCalcSize(BEHAVIORLAYOUTINFO_MODIFYNATURAL,
                                     pPH, 
                                     pci, 
                                     CSize(_dp.GetWidth() + bdrH, _dp.GetHeight() + bdrV), 
                                     (LPPOINT)&sizeInset, 
                                     &sizeReDo);

                }

                if (sizePadding.cy)
                {
                    // we need to set the new scrollpadding

                    SetScrollPadding(sizePadding, *psize, szBdr);
                    psize->cy = _dp.GetHeight() + bdrV; 
                }
                else
                {
                    psize->cy = fHasHeight ? max(lUserHeightSave, sizeReDo.cy) : sizeReDo.cy;
                }
            }

            if (    psize->cx != sizeReDo.cx
                &&  fContentAffectWidth
                &&  !sizePadding.cx)
            {
                psize->cx = sizeReDo.cx;
            }

            fNeedShiftLines = fNeedShiftLines || (psize->cx != sizeUser.cx);

            pci->_fPercentSecondPass = fpspSave;
        }
        // psize is finally correct, lets get out of here quick.


        if (    fViewChain 
            &&  !fSpecialLayout
            &&  fHasHeight
            &&  fNormalMode     )
        {
            if (psize->cy < sizeUser.cy)
            {
                psize->cy = max(0L, min(sizeUser.cy, (long)pci->_cyAvail));
                pci->_fLayoutOverflow = pci->_fLayoutOverflow || (pci->_cyAvail < sizeUser.cy);
            }

            SetUserHeightForNextBlock(psize->cy, sizeUser.cy);
        }


        //
        // but wait, there is one more thing:
        // if we are a master, then we should size ourselves based on the scroll size
        // of our content. this is necessary to display abs-pos elements. (ie bug 90842)
        // but NOT if we are a layoutRect or a [I]Frame
        //
        // Also, this MUST be done LAST (e.g. after the % sizing 2nd pass) so that we don't
        // initiate a race condition, where something in the slave that is % positioned keeps
        // focing the bounds out.
        //
        if (   fNormalMode 
            && !fSpecialLayout 
            && _fContentsAffectSize                        // implies not a [I]Frame
            && ElementOwner()->HasSlavePtr()              // is Master of a view 
            && !ElementOwner()->IsLinkedContentElement()  // not a layoutRect (printing)
            )
        {
            CMarkup  * pSlaveMarkup = ElementOwner()->GetSlavePtr()->GetMarkup();
            CElement * pSlaveElem = (pSlaveMarkup) ? pSlaveMarkup->GetElementClient() : NULL;

            if (pSlaveElem && !pSlaveMarkup->IsStrictCSS1Document())
            {
    
                CLayout * pSlaveLayout = pSlaveElem->GetUpdatedLayout(LayoutContext());

                Assert(pSlaveLayout);

            // NOTE - this works right now (ie5.5) because the slave is over-calculated.
            // the problem is that the positioning pass (required in order to get the 
            // correct Scroll bounds) doesn't happen until AFTER the measureing pass. so on
            // the first measurement, we are going to size to the flow-content-size, THEN
            // on later measures we will jump to the real scroll extent.
            //
            // (dmitryt) It stopped working in IE6 because we don't overcalc slave anymore.
            // So to make it back working as in IE5.5 (with understanding that bottom- and 
            // right- positioned objects and percent sizing is working weird) - I process
            // requests on slave's body. This is a terrible hack only justified by need
            // to get back to IE5.5 compat. (IE6 bug 1455)

            // <HACK>
            {
                CFlowLayout *pFL = pSlaveLayout->IsFlowLayout();

                if(    pFL 
                    && pFL->ElementOwner()->Tag() == ETAG_BODY
                    && pFL->HasRequestQueue() 
                  )
                {
                        long xParentWidth;
                        long yParentHeight;
                        CCalcInfo CI(pci);

                        CI._grfLayout |= LAYOUT_MEASURE|LAYOUT_POSITION;

                        pFL->GetDisplay()->GetViewWidthAndHeightForChild(
                                pci,
                                &xParentWidth,
                                &yParentHeight,
                                FALSE);


                        pFL->ProcessRequests(&CI, CSize(xParentWidth, yParentHeight));
                }
            }
            // </HACK>


                if (pSlaveLayout->GetElementDispNode())
                {
                    CRect rectSlave;
                    CSize sizeSave(*psize);

                    // We need to get our hands on the scrollable bounds.
                    //
                    pSlaveLayout->GetElementDispNode()->GetScrollExtent(&rectSlave);

                    // we want to treat the rect as being 0,0 based even if it isn't/
                    // e.g. the only content is APE, so we need the right, bottom (103545)
                    if (!fHasHeight)
                    {
                        psize->cy = (!pSlaveElem->HasVerticalLayoutFlow()) 
                              ? max(psize->cy, (bdrV + rectSlave.bottom)) 
                              : max(psize->cx, (bdrH + rectSlave.right));
                    }

                    if (!fHasWidth)
                    {
                        psize->cx = (!pSlaveElem->HasVerticalLayoutFlow()) 
                              ? max(psize->cx, (bdrH + rectSlave.right)) 
                              : max(psize->cy, (bdrV + rectSlave.bottom));
                    }

                    // now that we have the correct outer bounds, we need to resize the dispnode of the 
                    // slave to expand into the new space. This is necesary so that we do NOT clip away
                    // APE's
                    if (sizeSave != *psize)
                    {
                        sizeSave.cx = rectSlave.right;
                        sizeSave.cy = rectSlave.bottom;

                        pSlaveLayout->SizeDispNode(pci, sizeSave, TRUE);
                    }
                }
            }
        }


        // NOW we have our correct size and can get out of here.

        //
        // For normal modes, cache values and request layout
        //
        if (fNormalMode)
        {
            grfReturn |=  LAYOUT_THIS 
                        | (psize->cx != sizeOriginal.cx ? LAYOUT_HRESIZE : 0)
                        | (psize->cy != sizeOriginal.cy ? LAYOUT_VRESIZE : 0);

            if (!fSpecialLayout)
            {
                if (fHasInsets)
                {
                    CSize sizeInsetTemp(sizeInset.cx / 2, sizeInset.cy / 2);
                    _pDispNode->SetInset(sizeInsetTemp);
                }

                if (fNeedShiftLines) // || sizeProposed.cx != psize->cx)
                {
                    CRect rc(CSize(psize->cx - bdrH - sizeInset.cx, _dp.GetHeight()));

                    _fSizeToContent = TRUE;
                    _dp.SetViewSize(rc);
                    _dp.RecalcLineShift(pci, 0);
                    _fSizeToContent = FALSE;
                }
            }

            //
            // If size changes occurred, size the display nodes
            //
            if (   _pDispNode
                && ((grfReturn & (LAYOUT_FORCE | LAYOUT_HRESIZE | LAYOUT_VRESIZE))
                    || ( /* update display nodes when RTL overflow changes */
                        IsRTLFlowLayout() 
                        && _pDispNode->GetContentOffsetRTL() != _dp.GetRTLOverflow())
                    || HasMapSizePeer() // always call MapSize, if requested
                    || fNeedToSizeDispNodes
                  )
               ) 

            {
                SizeDispNode(pci, *psize);
                SizeContentDispNode(CSize(_dp.GetMaxWidth(), _dp.GetHeight()));
            }
            //see call to SetViewSize above - it could change the size of CDisplay
            //without changing the size of layout. We need to resize content dispnode.
            else if(fNeedShiftLines) 
            {
                SizeContentDispNode(CSize(_dp.GetMaxWidth(), _dp.GetHeight()));
            }

            if (    (grfReturn & (LAYOUT_FORCE | LAYOUT_HRESIZE | LAYOUT_VRESIZE))
                &&  (psize->cy < _yDescent) )
            {
                //  Layout descent should not exceed layout height (bug # 13413) 
                _yDescent = psize->cy;
            }

            //
            // Mark the site clean
            //
            SetSizeThis( FALSE );
        }

        //
        // For min/max mode, cache the values and note that they are now valid
        //

        else if (pci->_smMode == SIZEMODE_MMWIDTH)
        {
            _sizeMax.SetSize(psize->cx, -1);
            _sizeMin.SetSize(psize->cy, -1);
            _fMinMaxValid = TRUE;
        }

        else if (pci->_smMode == SIZEMODE_MINWIDTH)
        {
            _sizeMin.SetSize(psize->cx, -1);
        }
    }

    //
    // If any absolutely positioned sites need sizing, do so now
    //

    if (    (pci->_smMode == SIZEMODE_NATURAL || pci->_smMode == SIZEMODE_NATURALMIN)
        &&  HasRequestQueue())
    {
        long xParentWidth;
        long yParentHeight;

        _dp.GetViewWidthAndHeightForChild(
                pci,
                &xParentWidth,
                &yParentHeight,
                pci->_smMode == SIZEMODE_MMWIDTH);

        //
        //  To resize absolutely positioned sites, do MEASURE tasks.  Set that task flag now.
        //  If the call stack we are now on was instantiated from a WaitForRecalc, we may not have layout task flags set.
        //  There are two places to set them: here, or on the CDisplay::WaitForRecalc call.
        //  This has been placed in CalcSize for CTableLayout, C1DLayout, CFlowLayout, CInputLayout
        //  See bugs 69335, 72059, et. al. (greglett)
        //
        CCalcInfo CI(pci);
        CI._grfLayout |= LAYOUT_MEASURE;

        ProcessRequests(&CI, CSize(xParentWidth, yParentHeight));
    }

    //
    // Lastly, return the requested size
    //

    switch (pci->_smMode)
    {
    case SIZEMODE_NATURALMIN:
    case SIZEMODE_SET:
    case SIZEMODE_NATURAL:
    case SIZEMODE_FULLSIZE:
        Assert(!IsSizeThis());

        GetSize((CSize *)psize);

        if (HasMapSizePeer())
        {
            CRect rectMapped(CRect::CRECT_EMPTY);
            SIZE  sizeTemp;

            sizeTemp = *psize;

            // Get the possibly changed size from the peer
            if (DelegateMapSize(sizeTemp, &rectMapped, pci))
            {
                psize->cx = rectMapped.Width();
                psize->cy = rectMapped.Height();
            }
        }

        Reset(FALSE);
        Assert(!HasRequestQueue() || GetView()->HasLayoutTask(this));
        break;

    case SIZEMODE_MMWIDTH:
        Assert(_fMinMaxValid);
        psize->cx = _sizeMax.cu;
        psize->cy = _sizeMin.cu;
        if (!fRecalcText && psizeDefault)
        {
            GetSize((CSize *)psize);
        }

        if (HasMapSizePeer())
        {
            CRect rectMapped(CRect::CRECT_EMPTY);
            SIZE  sizeTemp;

            sizeTemp.cx = psize->cy;
            // DelegateMapSize does not like a 0 size, so set the cy to cx
            sizeTemp.cy = sizeTemp.cx;

            // Get the possibly changed size from the peer
            if(DelegateMapSize(sizeTemp, &rectMapped, pci))
            {
                psize->cy = rectMapped.Width();
                psize->cx = max(psize->cy, psize->cx);
            }
        }

        break;

    case SIZEMODE_MINWIDTH:
        psize->cx = _sizeMin.cu;

        if (HasMapSizePeer())
        {
            CRect rectMapped(CRect::CRECT_EMPTY);
            psize->cy = psize->cx;
            if(DelegateMapSize(*psize, &rectMapped, pci))
            {
                psize->cx = rectMapped.Width();
            }
        }

        psize->cy = 0;

        break;
    }

#if DO_PROFILE
    // Start icecap if we're in a table cell.
    if (ElementOwner()->Tag() == ETAG_TD ||
        ElementOwner()->Tag() == ETAG_TH)
        StopCAP();
#endif

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CFlowLayout::CalcSizeCoreCompat L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));

    return grfReturn;
}

DWORD
CFlowLayout::CalcSizeCoreCSS1Strict( CCalcInfo * pci,
                           SIZE      * psize,
                           SIZE      * psizeDefault)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CFlowLayout::CalcSizeCoreCSS1Strict L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    WHEN_DBG(SIZE psizeIn = *psize);
    WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0

    CheckSz(    !ElementOwner()->HasMarkupPtr() 
            ||  ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document(), 
           "CFlowLayout::CalcSizeCoreCSS1Strict is called to calculate non-CSS1 Strict Layout");

    CTreeNode * pNode       = GetFirstBranch();
    // BODYs inside viewlinks in general are NOT considered "main body"s,
    // but BODYs inside layout rects (which are viewlinks) ARE.
    // BODYs in Strict CSS1 documents are never special - they're just like a top-level DIV.
    BOOL fMainBody =   (    Tag() == ETAG_BODY
                        &&  !GetOwnerMarkup()->IsHtmlLayout() 
                        &&  !ElementOwner()->IsInViewLinkBehavior(FALSE) );

#if DBG == 1
    if (pNode->GetFancyFormat(LC_TO_FC(LayoutContext()))->_fLayoutFlowChanged)
    {
        MtAdd(Mt(LFCCalcSizeCore), 1, 0);
    }
#endif

    CSaveCalcInfo   sci(pci, this);
    CScopeFlag      csfCalcing(this);

    BOOL  fNormalMode = pci->IsNaturalMode();
    BOOL  fRecalcText = FALSE;
    BOOL  fWidthChanged, fHeightChanged;
    CSize sizeOriginal;
    SIZE  sizeSave;
    DWORD grfReturn;
    CPeerHolder * pPH = ElementOwner()->GetLayoutPeerHolder();

    AssertSz(pci, "no CalcInfo passed to CalcSizeCoreCSS1Strict");
    Assert(psize);

    pci->_pMarkup = GetContentMarkup();

    Assert(!IsDisplayNone());

    BOOL fViewChain = (pci->GetLayoutContext() && pci->GetLayoutContext()->ViewChain());

    // NOTE (KTam): For cleanliness, setting the context in the pci ought to be done
    // at a higher level -- however, it's really only needed for layouts that can contain
    // others, which is why we can get away with doing it here.
    if ( !pci->GetLayoutContext() )
    {
        pci->SetLayoutContext( LayoutContext() );
    }
    else
    {
        Assert(pci->GetLayoutContext() == LayoutContext() 
            || pci->GetLayoutContext() == DefinedLayoutContext() 
            // while calc'ing table min max pass we use original cell layout 
            || pci->_smMode == SIZEMODE_MMWIDTH
            || pci->_smMode == SIZEMODE_MINWIDTH);
    }
    
    Listen();

#if DO_PROFILE
    // Start icecap if we're in a table cell.
    if (ElementOwner()->Tag() == ETAG_TD ||
        ElementOwner()->Tag() == ETAG_TH)
    {
        StartCAP();
    }
#endif
  
    //
    // Set default return values and initial state
    //
    if (_fForceLayout)
    {
        pci->_grfLayout |= LAYOUT_FORCE;
        _fForceLayout = FALSE;
    }

    grfReturn = (pci->_grfLayout & LAYOUT_FORCE);

    if (pci->_grfLayout & LAYOUT_FORCE)
    {
        SetSizeThis( TRUE );
        _fAutoBelow        = FALSE;
        _fPositionSet      = FALSE;
        _fContainsRelative = FALSE;
    }

    GetSize(&sizeOriginal);

    fWidthChanged   = fNormalMode && _sizePrevCalcSizeInput.cx != psize->cx;
    fHeightChanged  = fNormalMode && _sizePrevCalcSizeInput.cy != psize->cy;

    _sizePrevCalcSizeInput = *psize;

    //
    // For changes which invalidate the entire layout, dirty all of the text
    //

    fRecalcText =   (fNormalMode && (   IsDirty()
                                    ||  IsSizeThis()
                                    ||  fWidthChanged
                                    ||  fHeightChanged))
                ||  (pci->_grfLayout & LAYOUT_FORCE)
                ||  (pci->_smMode == SIZEMODE_SET)
                ||  (pci->_smMode == SIZEMODE_MMWIDTH && !_fMinMaxValid)
                ||  (pci->_smMode == SIZEMODE_MINWIDTH && !_fMinMaxValid);

    if (!fRecalcText && fViewChain && ElementCanBeBroken()) // (olego) fix for 21322
    {
        // propogate information stored in page break (if any) into pci 
        CLayoutBreak *  pLayoutBreak; 

        pci->GetLayoutContext()->GetEndingLayoutBreak(ElementOwner(), &pLayoutBreak);
        CheckSz(pLayoutBreak, "Ending layout break is expected at this point");

        if (pLayoutBreak)
        {
            if (DYNCAST(CFlowLayoutBreak, pLayoutBreak)->LayoutBreakType() == LAYOUT_BREAKTYPE_LINKEDOVERFLOW)
                pci->_fLayoutOverflow = TRUE;
        }
    }

    //
    // Cache sizes and recalculate the text (if required)
    //

    if (fRecalcText)
    {
        BOOL        fNeedShiftLines = FALSE;
        SIZE        sizeUser    = g_Zero.size;
        SIZE        sizePadding = g_Zero.size;
        SIZE        sizeInset   = g_Zero.size;
        SIZE        sizeDefault;
        SIZE        sizeBorderAndPadding = g_Zero.size;
        SIZE        sizeProposed = g_Zero.size;
        CBorderInfo bi;
        LONG        bdrH = 0 , bdrV = 0;
        BOOL        fContentAffectWidth = FALSE;
        BOOL        fContentAffectHeight = FALSE;
        BOOL        fHasWidth = FALSE;
        BOOL        fHasHeight = FALSE;
        BOOL        fHasDefaultWidth  = FALSE;
        BOOL        fHasDefaultHeight = FALSE;
        BOOL        fWidthClipContent = FALSE;
        BOOL        fHeightClipContent = FALSE;
        const CFancyFormat * pFF = pNode->GetFancyFormat(LC_TO_FC(LayoutContext()));
        const CCharFormat  * pCF = pNode->GetCharFormat(LC_TO_FC(LayoutContext()));
        BOOL fVerticalLayoutFlow = pCF->HasVerticalLayoutFlow();
        BOOL fWritingModeUsed = pCF->_fWritingModeUsed;
        BOOL fWidthPercent  = pFF->IsLogicalWidthPercent(fVerticalLayoutFlow, fWritingModeUsed);
        BOOL fHeightPercent = pFF->IsLogicalHeightPercent(fVerticalLayoutFlow, fWritingModeUsed);
        const CUnitValue & cuvWidth  = pFF->GetLogicalWidth(fVerticalLayoutFlow, fWritingModeUsed);
        const CUnitValue & cuvHeight = pFF->GetLogicalHeight(fVerticalLayoutFlow, fWritingModeUsed);
        styleOverflow overflowX;
        styleOverflow overflowY;
        BOOL fNeedToSizeDispNodes = pci->_fNeedToSizeContentDispNode;

        BOOL fHasInsets = FALSE;
        BOOL fSpecialLayout =    Tag() == ETAG_TD
                             ||  Tag() == ETAG_TH
                             ||  Tag() == ETAG_CAPTION
                             ||  Tag() == ETAG_TC
                             ||  fMainBody
                             ||  Tag() == ETAG_INPUT
                                 && DYNCAST(CInput, ElementOwner())->GetType() == htmlInputFile;

        CElement::CLock Lock(ElementOwner(), CElement::ELEMENTLOCK_SIZING);
            
        //
        // If dirty, ensure display tree nodes exist
        //
        if (    IsSizeThis()
            &&  fNormalMode
            &&  (EnsureDispNode(pci, (grfReturn & LAYOUT_FORCE)) == S_FALSE))
        {
            grfReturn |= LAYOUT_HRESIZE | LAYOUT_VRESIZE;
        }

        //
        // don't move this above Ensuredispnode
        // since the element overflow might be changed
        //

        overflowX = pFF->GetLogicalOverflowX(   fVerticalLayoutFlow,
                                                fWritingModeUsed);
        overflowY = pFF->GetLogicalOverflowY(   fVerticalLayoutFlow,
                                                fWritingModeUsed);


        if (fViewChain)
        {
            // 
            //  Defensive code if there is no available height to fill prohibit breaking. 
            //
            if (pci->_cyAvail <= 0 )
            {
                SetElementCanBeBroken(FALSE);
            }

            // TODO (112467, olego): Now we have CLayout::_fElementCanBeBroken bit flag 
            // that prohibit layout breaking in Page View. This approach is not suffitient 
            // enouth for editable Page View there we want this property to be calculated 
            // dynamically depending on layout type and layout nesting position (if parent 
            // has it child should inherit). 
            // This work also will enable CSS attribute page-break-inside support.

            if (!fMainBody && ElementCanBeBroken())
            {
                //  Allow to break only if 
                //  1) element is not absolute positioned; 
                //  2) doesn't have certain overflow attribute set; 
                SetElementCanBeBroken(    !pFF->IsAbsolute()
                                        && overflowX != styleOverflowScroll 
                                       && overflowX != styleOverflowAuto 
                                       && overflowY != styleOverflowScroll
                                       && overflowY != styleOverflowAuto    );
            }

            fViewChain = fViewChain && ElementCanBeBroken();
        }

        // 
        // calc sizeBorderAndPadding
        // 
        if (ElementOwner()->GetBorderInfo(pci, &bi, FALSE, FALSE))
        {
            bdrH = bi.aiWidths[SIDE_LEFT] + bi.aiWidths[SIDE_RIGHT];
            bdrV = bi.aiWidths[SIDE_BOTTOM] + bi.aiWidths[SIDE_TOP];
        }

        // Button's content box includes padding and borders thus sizeBorderAndPadding should be (0, 0)
        if (    Tag() != ETAG_BUTTON
            &&  (Tag() != ETAG_INPUT || !DYNCAST(CInput, ElementOwner())->IsButton())   )
        {
            const CUnitValue & cuvPaddingLeft   = pFF->GetLogicalPadding(SIDE_LEFT, fVerticalLayoutFlow, fWritingModeUsed);
            const CUnitValue & cuvPaddingRight  = pFF->GetLogicalPadding(SIDE_RIGHT, fVerticalLayoutFlow, fWritingModeUsed);
            const CUnitValue & cuvPaddingTop    = pFF->GetLogicalPadding(SIDE_TOP, fVerticalLayoutFlow, fWritingModeUsed);
            const CUnitValue & cuvPaddingBottom = pFF->GetLogicalPadding(SIDE_BOTTOM, fVerticalLayoutFlow, fWritingModeUsed);

            sizeBorderAndPadding.cx = (bdrH 
                                     + cuvPaddingLeft.XGetPixelValue(pci, pci->_sizeParent.cx, pNode->GetFontHeightInTwips(&cuvPaddingLeft)) 
                                     + cuvPaddingRight.XGetPixelValue(pci, pci->_sizeParent.cx, pNode->GetFontHeightInTwips(&cuvPaddingRight)) );

            // NOTE : for vertical paddings we also provide lParentWidth as a reference (for percentage values), 
            //        this is done intentionally as per css spec.
            sizeBorderAndPadding.cy = (bdrV 
                                     + cuvPaddingTop.YGetPixelValue(pci, pci->_sizeParent.cx, pNode->GetFontHeightInTwips(&cuvPaddingTop)) 
                                     + cuvPaddingBottom.YGetPixelValue(pci, pci->_sizeParent.cx, pNode->GetFontHeightInTwips(&cuvPaddingBottom)) );
        }

        //
        // exclude TD, TH and input type=file
        //
        if (!fSpecialLayout)
        {
            fHasWidth  = pFF->UseLogicalUserWidth(pCF->_fUseUserHeight, fVerticalLayoutFlow, fWritingModeUsed);
            fHasHeight = pFF->UseLogicalUserHeight(pCF->_fUseUserHeight, fVerticalLayoutFlow, fWritingModeUsed);
            fWidthClipContent  = (  overflowX != styleOverflowVisible
                                 && overflowX != styleOverflowNotSet);
            fHeightClipContent = (  overflowY != styleOverflowVisible 
                                 && overflowY != styleOverflowNotSet);

            // Get element's default size
            // Buttons don't have default w/h and return a 0 default size.
            // Text INPUTs and TEXTAREAs have both default width and height.
            // Marquees have default height.
            sizeDefault = *psize;
            GetDefaultSize(pci, sizeDefault, &fHasDefaultWidth, &fHasDefaultHeight);

            // use astrology to determine if we need to size to content
            if (    !fHasWidth 
                &&  !fHasDefaultWidth
                &&  (
                            pFF->_bStyleFloat == styleStyleFloatLeft
                        ||  pFF->_bStyleFloat == styleStyleFloatRight
                        ||  !ElementOwner()->IsBlockElement()
                        ||  ElementOwner()->IsAbsolute()
                    )
                &&
                    // If we're in home publisher, we don't want to size to content.
                    (
                            !(Doc()->_fInHomePublisherDoc || g_fInHomePublisher98)
                        ||  !ElementOwner()->IsAbsolute()
                    )
// TODO (lmollico): should go away
                &&  ElementOwner()->_etag != ETAG_FRAME
                )
            {
                _fSizeToContent = TRUE;
            }
            else
            {
                _fSizeToContent = FALSE;
            }

            if (fWidthPercent && !fNormalMode)
            {
                sizeUser.cx      = 0;
                _sizeProposed.cx = 0;
            }
            else
            {
                if (fHasWidth)
                {
                    LONG lParentWidth;
                    if (   fWidthPercent 
                        && ElementOwner()->IsAbsolute() 
                        && fVerticalLayoutFlow)
                    {
                        lParentWidth = pci->_sizeParent.cx;
                        CTreeNode   *pParentNode   = pNode->Parent();
                        CFlowLayout *pLayoutParent = pParentNode ? pParentNode->GetFlowLayout(pci->GetLayoutContext()) : 0;
                        CDisplay    *pdpParent     = pLayoutParent ? pLayoutParent->GetDisplay() : 0;
                        long lcxPadding = 0;
                        long lPadding[SIDE_MAX];

                        if (pdpParent)
                        {
                            pdpParent->GetPadding(pci, lPadding, pci->_smMode == SIZEMODE_MMWIDTH);

                            // padding is in parent coordinate system, but we need it in global
                            if (pParentNode->GetCharFormat()->HasVerticalLayoutFlow())
                                lcxPadding = lPadding[SIDE_LEFT] + lPadding[SIDE_RIGHT];
                            else
                                lcxPadding = lPadding[SIDE_TOP] + lPadding[SIDE_BOTTOM];
                        }
                        // add padding to the width
                        lParentWidth += lcxPadding;
                    }
                    else if (   fWidthPercent 
                             && fVerticalLayoutFlow)
                    {
                        lParentWidth = 0;

                        // The loop to iterate parent branch up the tree to skip non-block parents (bug #108389)...
                        CTreeNode * pNodeParent = pNode->Parent();
                        while (pNodeParent && !pNodeParent->Element()->IsBlockElement())
                        {
                            pNodeParent = pNodeParent->Parent();
                        }
                        if (pNodeParent)
                        {
                            const CUnitValue & cuvWidthParent = pNodeParent->GetFancyFormat()->GetLogicalWidth(fVerticalLayoutFlow, fWritingModeUsed);
                            if (!cuvWidthParent.IsNullOrEnum() && !cuvWidthParent.IsPercent())
                            {
                                lParentWidth = cuvWidthParent.XGetPixelValue(pci, 0, pNodeParent->GetFontHeightInTwips(&cuvWidthParent));
                            }
                            else if (cuvWidthParent.IsPercent() || pNodeParent->Tag() == ETAG_BODY)
                            {
                                lParentWidth = pci->_sizeParent.cx;
                            }
                        }
                    }
                    else
                    {
                        lParentWidth = pci->_sizeParent.cx;
                    }

                    _sizeProposed.cx = cuvWidth.XGetPixelValue(pci, lParentWidth, pNode->GetFontHeightInTwips(&cuvWidth));
                    sizeUser.cx      = _sizeProposed.cx + sizeBorderAndPadding.cx;
                }
                else
                {
                    sizeUser.cx      = sizeDefault.cx;
                    _sizeProposed.cx = sizeDefault.cx;

                    // If this is default width it corresponds to content box -- no adjustment needed 
                    if (!fHasDefaultWidth)
                    {
                        _sizeProposed.cx -= sizeBorderAndPadding.cx;
                        if (_sizeProposed.cx < 0)
                            _sizeProposed.cx = 0;
                    }
                }
            }

            if (fHeightPercent && !fNormalMode)
            {
                sizeUser.cy      = 0;
                _sizeProposed.cy = 0;
            }
            else
            {
                if (fHasHeight)
                {
                    LONG lParentHeight = pci->_sizeParent.cy;
                    if (   fHeightPercent 
                        && ElementOwner()->IsAbsolute() 
                        && !fVerticalLayoutFlow)
                    {
                        CTreeNode   *pParentNode   = pNode->Parent();
                        CFlowLayout *pLayoutParent = pParentNode ? pParentNode->GetFlowLayout(pci->GetLayoutContext()) : 0;
                        CDisplay    *pdpParent     = pLayoutParent ? pLayoutParent->GetDisplay() : 0;
                        long lcyPadding = 0;
                        long lPadding[SIDE_MAX];

                        if (pdpParent)
                        {
                            pdpParent->GetPadding(pci, lPadding, pci->_smMode == SIZEMODE_MMWIDTH);

                            // padding is in parent coordinate system, but we need it in global
                            if (pParentNode->GetCharFormat()->HasVerticalLayoutFlow())
                                lcyPadding = lPadding[SIDE_LEFT] + lPadding[SIDE_RIGHT];
                            else
                                lcyPadding = lPadding[SIDE_TOP] + lPadding[SIDE_BOTTOM];
                        }
                        // add padding to the height
                        lParentHeight += lcyPadding;
                    }

                    _sizeProposed.cy = cuvHeight.YGetPixelValue(pci, lParentHeight, pNode->GetFontHeightInTwips(&cuvHeight));
                    sizeUser.cy      = _sizeProposed.cy + sizeBorderAndPadding.cy;

                    if (fViewChain)
                    {
                        sizeUser.cy = GetUserHeightForBlock(sizeUser.cy);
                    }
                }
                else
                {
                    sizeUser.cy      = sizeDefault.cy;
                    _sizeProposed.cy = sizeDefault.cy;

                    // If this is default height it corresponds to content box -- no adjustment needed 
                    if (!fHasDefaultHeight)
                    {
                        _sizeProposed.cy -= sizeBorderAndPadding.cy;
                        if (_sizeProposed.cy < 0)
                            _sizeProposed.cy = 0;
                    }
                }
            }

            // The BODY's content never affects its width/height (style specified
            // w/h and/or container size (usually <HTML> and/orframe window) determine
            // BODY size).
            // In general, contents affects w/h if:
            //    1.) w/h isn't style-specified and there's no default w/h.
            // OR 2.) overflowX/Y == visible or not set (meaning f*ClipContent is false).
            // 
            // once we can support vertical center, we can remove the Tag
            //         check for buttons
            fContentAffectWidth =     Tag() != ETAG_FRAME
                                  &&  Tag() != ETAG_IFRAME
                                  &&  (   !fHasWidth && !fHasDefaultWidth
                                      ||  !fWidthClipContent
                                      ||  Tag() == ETAG_BUTTON
                                      ||  Tag() == ETAG_INPUT && DYNCAST(CInput, ElementOwner())->IsButton()
                                      );

            fContentAffectHeight =    Tag() != ETAG_FRAME
                                  &&  Tag() != ETAG_IFRAME
                                  &&  (   !fHasHeight && !fHasDefaultHeight
                                      ||  !fHeightClipContent
                                      ||  Tag() == ETAG_BUTTON
                                      ||  Tag() == ETAG_INPUT && DYNCAST(CInput, ElementOwner())->IsButton()
                                      );
            _fContentsAffectSize = fContentAffectWidth || fContentAffectHeight;

            // set the (proposed) size to the default/attr-defined size + parentPadding.
// TODO (lmollico): should go away
            if (ElementOwner()->_etag != ETAG_FRAME)
                *psize = sizeUser;

            if (   fNormalMode
                || (   pci->_smMode==SIZEMODE_MMWIDTH 
                    && ( fHeightPercent || fWidthPercent)))
            {
                if (   fContentAffectHeight 
                    && !fHeightPercent )
                {
                    // when dealing with vertical flow we can't assume a height of zero as we size
                    // to the content, this is because we will end up word wrapping as this height
                    // is used as a width.
                    psize->cy = 0;
                }

                //
                // only marquee like element specify a scroll padding
                // which is used for vertical scrolling marquee
                // 
                sizePadding.cx  = max(0L, sizeUser.cx - bdrH);
                sizePadding.cy  = max(0L, sizeUser.cy - bdrV);

                GetScrollPadding(sizePadding);


                if (sizePadding.cx || sizePadding.cy)
                {
                    // make sure the display is fully recalced with the paddings
                    _dp._defPaddingTop      = sizePadding.cy;
                    _dp._defPaddingBottom   = sizePadding.cy;
                    _dp._fDefPaddingSet     = !!sizePadding.cy;

                    // marquee always size to content
                    _fSizeToContent = TRUE;
                }
            }

            if (    !ParentClipContent()
                &&  ElementOwner()->IsAbsolute()
                &&  (!fHasHeight || !fHasWidth)
               )
            {
                CRect rcSize;
                CalcAbsoluteSize(pci, psize, &rcSize);

                if (pNode->GetFancyFormat(LC_TO_FC(LayoutContext()))->_fLayoutFlowChanged)
                {
                    rcSize.SetWidth(max(rcSize.Width(), sizeUser.cx));
                    rcSize.SetHeight(max(rcSize.Height(), sizeUser.cx));
                }

                //  109440, for FRAME's that are APE, we do not want the height set to 0
                psize->cx = !fHasWidth  ? max(0L, rcSize.Width()) : max(0L, sizeUser.cx);
                psize->cy = !fHasHeight 
                                ? ((Tag() == ETAG_FRAME) ? max(0L, rcSize.Height()) : 0 )
                                : max(0L, sizeUser.cy);
            }

            // in NF, IFrames use the std flowlayout. For back compat the size specified (even if default)
            // needs to be INSIDE the borders, whereas for all others it is outside.  Since the border sizes
            // are removed from the proposedSize in CalcTextSize
            if (Tag() == ETAG_IFRAME)
            {
                CDispNodeInfo   dni;
                GetDispNodeInfo(&dni, pci, TRUE);

                if (dni.GetBorderType() != DISPNODEBORDER_NONE)
                {
                    CRect   rcBorders;

                    dni.GetBorderWidths(&rcBorders);

                    if (!fWidthPercent)
                        psize->cx    += rcBorders.left + rcBorders.right;

                    if (!fHeightPercent)
                        psize->cy    += rcBorders.top  + rcBorders.bottom;
                }
            }

        }
        else if (fMainBody)
        {
            _sizeProposed = pci->_sizeParent;
            _sizeProposed.cx -= sizeBorderAndPadding.cx;
            _sizeProposed.cy -= sizeBorderAndPadding.cy;
            if (_sizeProposed.cx < 0)
                _sizeProposed.cx = 0;
            if (_sizeProposed.cy < 0)
                _sizeProposed.cy = 0;
        }

        sizeProposed = *psize;

        //
        // Calculate the text
        //

        //don't do CalcTextSize in minmax mode if our text size doesn't affect us anyway.
        if(     _fContentsAffectSize || fNormalMode 
            ||  fWidthPercent)  //  preserving backward compat (bug 27982)
        {
            CalcTextSize(pci, psize, psizeDefault);
        }
        else if (pci->_smMode == SIZEMODE_MMWIDTH)
        {
            psize->cy = psize->cx;
        }

        sizeSave = *psize;

        //
        // exclude TD, TH and input type=file
        //
        if (!fSpecialLayout)
        {
            sizeInset = sizeUser;
            fHasInsets = GetInsets(pci->_smMode, sizeInset, *psize, fHasWidth, fHasHeight, CSize(bdrH, bdrV));
            if (sizeSave.cx != psize->cx)
            {
                grfReturn      |= LAYOUT_HRESIZE;
                fNeedShiftLines = TRUE;
            }

            if (fNormalMode)
            {
                if (sizePadding.cx || sizePadding.cy)
                {
                    SIZE szBdr;

                    szBdr.cx = bdrH;
                    szBdr.cy = bdrV;
                    // We need to call GetScrollPadding, because now we know the text size
                    // we will update scroll parameters

                    SetScrollPadding(sizePadding, *psize, szBdr);

                    fNeedShiftLines = TRUE;
                    *psize = sizeUser;

                    // if the marquee like element is percentage sized or
                    // its size is not specified, its size should be the
                    // default size.
                    // if the default size or the css style size is less 
                    // or equal than 0, marquee like element should not be sized
                    // as such according to IE3 compatibility requirements

                    if ((fHeightPercent || !fHasHeight) && sizeUser.cy <= 0)
                    {
                        psize->cy = _dp.GetHeight() + bdrV; 
                    }
                    else if (sizePadding.cx > 0)
                    {
                        //
                        // if the marquee is horizontal scrolling,
                        // the height should be at least the content high by IE5.
                        //
                        psize->cy = max(psize->cy, _dp.GetHeight() + bdrV);
                    }

                    if (!fHasWidth && sizeUser.cx <= 0)
                    {
                        psize->cx = _dp.GetWidth() + bdrH;
                    }
                }

                else if (fHasWidth && (fWidthClipContent || psize->cx < sizeUser.cx))
                {
                    if (psize->cx != sizeUser.cx)
                    {
                        fNeedShiftLines = TRUE;
                    }
                    psize->cx = max(0L, sizeUser.cx);
                }
                else if (   _fSizeToContent
                        && !((fHasDefaultWidth || fHasWidth || (sizeProposed.cx != psize->cx)) && fWidthClipContent))
                {
                    // when size to content and the width does not 
                    // clip the content, we need to clip on the parent
                    fNeedShiftLines = TRUE;

                    psize->cx = _dp.GetWidth() + bdrH;
                }

                if (fHasHeight)
                {
                    if (fViewChain)
                    {
                        if (psize->cy < sizeUser.cy)
                        {
                            psize->cy = max(0L, min(sizeUser.cy, (long)pci->_cyAvail));
                        }
                    }
                    else if (  !pci->_fContentSizeOnly
                            && (   fHeightClipContent 
                                || psize->cy < sizeUser.cy))
                    {
                        psize->cy = max(0L, sizeUser.cy);
                    }
                }
            }
            else
            {
                if (fHasWidth || !_fContentsAffectSize)
                {
                    // cy contains the min width
                    if (pci->_smMode == SIZEMODE_MMWIDTH)
                    {
                        if (fWidthClipContent)
                        {
                            if (!fWidthPercent)
                            {
                                psize->cy = sizeProposed.cx;
                                psize->cx = psize->cy;
                            }
                        }
                        else
                        {
                            if (_fContentsAffectSize)
                            {
                                Assert(fHasWidth);
                                psize->cy = max(psize->cy, sizeProposed.cx);
                                if (!fWidthPercent)
                                    psize->cx = psize->cy;
                                Assert(psize->cx >= psize->cy);
                            }
                            else
                            {
                                if (!fWidthPercent)
                                {
                                    psize->cx = psize->cy = sizeProposed.cx;
                                }
                                else if (   Tag() == ETAG_IFRAME
                                         && pci->_smMode == SIZEMODE_MMWIDTH
                                         && sizeProposed.cx == 0)
                                {
                                    // bug 70270 - don't let minmax return 0 or else we will never display.
                                    psize->cy = 0; 
                                    psize->cx = cuvWidth.GetPercentValue(CUnitValue::DIRECTION_CX, 300);

                                }
                            }
                        }
                    }
                    else
                    {
                        // Something in TD causes min width to happen
                        if (   !_fContentsAffectSize
                            && fWidthPercent
                            && Tag() == ETAG_IFRAME
                            && sizeProposed.cx == 0
                            && pci->_smMode == SIZEMODE_MINWIDTH
                            )
                        {
                            // bug 70270
                            psize->cy = 0;
                            psize->cx = cuvWidth.GetPercentValue(CUnitValue::DIRECTION_CX, 300);
                        }
                        else
                        {
                            Assert(pci->_smMode == SIZEMODE_MINWIDTH);
                            *psize = sizeProposed;
                        }
                    }
                }
            }
        }

        //
        // Before we can cache the computed values and request layout tasks
        //  (positioning) we may need to give layoutBehaviors a chance to 
        //  modify the natural (trident-default) sizing of this element.
        //  e.g. a "glow behavior" may want to increase the size of the 
        //  element that it is instantiated on by 10 pixels in all directions,
        //  so that it can draw the fuzzy glow; or an external HTMLbutton
        //  is the size of its content + some decoration size.
        //
        if (   pPH   
            && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_MODIFYNATURAL))
        {
            POINT pt;

            pt.x = sizePadding.cx;
            pt.y = sizePadding.cy;

            DelegateCalcSize(BEHAVIORLAYOUTINFO_MODIFYNATURAL,
                             pPH, 
                             pci, 
                             CSize(_dp.GetWidth() + bdrH, _dp.GetHeight() + bdrV), 
                             &pt, psize);


            if (psize->cx != sizeUser.cx)
            {
                fNeedShiftLines = TRUE;
            }

            if (pt.x != sizePadding.cx)
            {
                sizeInset.cx += max(0L, pt.x - sizePadding.cx);
            }

            if (pt.y != sizePadding.cy)
            {
                sizeInset.cy += max(0L, pt.y - sizePadding.cy); 
            }
        }

        if (    fViewChain 
            &&  !fSpecialLayout
            &&  fHasHeight
            &&  fNormalMode     )
        {
            if (psize->cy < sizeUser.cy)
            {
                psize->cy = max(0L, min(sizeUser.cy, (long)pci->_cyAvail));
                pci->_fLayoutOverflow = pci->_fLayoutOverflow || (pci->_cyAvail < sizeUser.cy);
            }

            SetUserHeightForNextBlock(psize->cy, sizeUser.cy);
        }

        //
        // For normal modes, cache values and request layout
        //
        if (fNormalMode)
        {
            grfReturn |=  LAYOUT_THIS 
                        | (psize->cx != sizeOriginal.cx ? LAYOUT_HRESIZE : 0)
                        | (psize->cy != sizeOriginal.cy ? LAYOUT_VRESIZE : 0);

            if (!fSpecialLayout)
            {
                if (fHasInsets)
                {
                    CSize sizeInsetTemp(sizeInset.cx / 2, sizeInset.cy / 2);
                    _pDispNode->SetInset(sizeInsetTemp);
                }

                if (fNeedShiftLines) // || sizeProposed.cx != psize->cx)
                {
                    CRect rc(CSize(psize->cx - bdrH - sizeInset.cx, _dp.GetHeight()));

                    _fSizeToContent = TRUE;
                    _dp.SetViewSize(rc);
                    _dp.RecalcLineShift(pci, 0);
                    _fSizeToContent = FALSE;
                }
            }

            //
            // If size changes occurred, size the display nodes
            //
            if (   _pDispNode
                && ((grfReturn & (LAYOUT_FORCE | LAYOUT_HRESIZE | LAYOUT_VRESIZE))
                    || ( /* update display nodes when RTL overflow changes */
                        IsRTLFlowLayout() 
                        && _pDispNode->GetContentOffsetRTL() != _dp.GetRTLOverflow())
                    || HasMapSizePeer() // always call MapSize, if requested
                    || fNeedToSizeDispNodes
                  )
               ) 

            {
                SizeDispNode(pci, *psize);
                SizeContentDispNode(CSize(_dp.GetMaxWidth(), _dp.GetHeight()));
            }
            //see call to SetViewSize above - it could change the size of CDisplay
            //without changing the size of layout. We need to resize content dispnode.
            else if(fNeedShiftLines) 
            {
                SizeContentDispNode(CSize(_dp.GetMaxWidth(), _dp.GetHeight()));
            }

            if (    (grfReturn & (LAYOUT_FORCE | LAYOUT_HRESIZE | LAYOUT_VRESIZE))
                &&  (psize->cy < _yDescent) )
            {
                //  Layout descent should not exceed layout height (bug # 13413) 
                _yDescent = psize->cy;
            }

            //
            // Mark the site clean
            //
            SetSizeThis( FALSE );
        }

        //
        // For min/max mode, cache the values and note that they are now valid
        //

        else if (pci->_smMode == SIZEMODE_MMWIDTH)
        {
            _sizeMax.SetSize(psize->cx, -1);
            _sizeMin.SetSize(psize->cy, -1);
            _fMinMaxValid = TRUE;
        }

        else if (pci->_smMode == SIZEMODE_MINWIDTH)
        {
            _sizeMin.SetSize(psize->cx, -1);
        }
    }

    //
    // If any absolutely positioned sites need sizing, do so now
    //

    if (    (pci->_smMode == SIZEMODE_NATURAL || pci->_smMode == SIZEMODE_NATURALMIN)
        &&  HasRequestQueue())
    {
        long xParentWidth;
        long yParentHeight;

        _dp.GetViewWidthAndHeightForChild(
                pci,
                &xParentWidth,
                &yParentHeight,
                pci->_smMode == SIZEMODE_MMWIDTH);

        //
        //  To resize absolutely positioned sites, do MEASURE tasks.  Set that task flag now.
        //  If the call stack we are now on was instantiated from a WaitForRecalc, we may not have layout task flags set.
        //  There are two places to set them: here, or on the CDisplay::WaitForRecalc call.
        //  This has been placed in CalcSize for CTableLayout, C1DLayout, CFlowLayout, CInputLayout
        //  See bugs 69335, 72059, et. al. (greglett)
        //
        CCalcInfo CI(pci);
        CI._grfLayout |= LAYOUT_MEASURE;

        ProcessRequests(&CI, CSize(xParentWidth, yParentHeight));
    }

    //
    // Lastly, return the requested size
    //

    switch (pci->_smMode)
    {
    case SIZEMODE_NATURALMIN:
    case SIZEMODE_SET:
    case SIZEMODE_NATURAL:
    case SIZEMODE_FULLSIZE:
        Assert(!IsSizeThis());

        GetSize((CSize *)psize);

        if (HasMapSizePeer())
        {
            CRect rectMapped(CRect::CRECT_EMPTY);
            SIZE  sizeTemp;

            sizeTemp = *psize;

            // Get the possibly changed size from the peer
            if (DelegateMapSize(sizeTemp, &rectMapped, pci))
            {
                psize->cx = rectMapped.Width();
                psize->cy = rectMapped.Height();
            }
        }

        Reset(FALSE);
        Assert(!HasRequestQueue() || GetView()->HasLayoutTask(this));
        break;

    case SIZEMODE_MMWIDTH:
        Assert(_fMinMaxValid);
        psize->cx = _sizeMax.cu;
        psize->cy = _sizeMin.cu;
        if (!fRecalcText && psizeDefault)
        {
            GetSize((CSize *)psize);
        }

        if (HasMapSizePeer())
        {
            CRect rectMapped(CRect::CRECT_EMPTY);
            SIZE  sizeTemp;

            sizeTemp.cx = psize->cy;
            // DelegateMapSize does not like a 0 size, so set the cy to cx
            sizeTemp.cy = sizeTemp.cx;

            // Get the possibly changed size from the peer
            if(DelegateMapSize(sizeTemp, &rectMapped, pci))
            {
                psize->cy = rectMapped.Width();
                psize->cx = max(psize->cy, psize->cx);
            }
        }

        break;

    case SIZEMODE_MINWIDTH:
        psize->cx = _sizeMin.cu;

        if (HasMapSizePeer())
        {
            CRect rectMapped(CRect::CRECT_EMPTY);
            psize->cy = psize->cx;
            if(DelegateMapSize(*psize, &rectMapped, pci))
            {
                psize->cx = rectMapped.Width();
            }
        }

        psize->cy = 0;

        break;
    }

#if DO_PROFILE
    // Start icecap if we're in a table cell.
    if (ElementOwner()->Tag() == ETAG_TD ||
        ElementOwner()->Tag() == ETAG_TH)
        StopCAP();
#endif

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CFlowLayout::CalcSizeCoreCSS1Strict L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));

    return grfReturn;
}

//+-------------------------------------------------------------------------
//
//  Method:     CFlowLayout::CalcTextSize
//
//  Synopsis:   Calculate the size of the contained text
//
//--------------------------------------------------------------------------

void
CFlowLayout::CalcTextSize(
    CCalcInfo * pci, 
    SIZE      * psize, 
    SIZE      * psizeDefault)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CFlowLayout::CalcTextSize L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    WHEN_DBG(SIZE psizeIn = *psize);
    WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0

    CDisplay    *pdp = &_dp;
    BOOL        fNormalMode = (   pci->_smMode == SIZEMODE_NATURAL
                               || pci->_smMode == SIZEMODE_NATURALMIN
                               || pci->_smMode == SIZEMODE_SET);
    BOOL        fFullRecalc;
    CRect       rcView;
    long        cxView, cyView;
    long        cxAdjustment = 0;
    long        cyAdjustment = 0;
    long        xViewWidthOld = pdp->GetViewWidth();
    long        yViewHeightOld = pdp->GetViewHeight();
    BOOL        fRTLDisplayOld = pdp->IsRTLDisplay();
    int         cyAvailSafe = pci->_cyAvail;
    BOOL        fViewChain = (   pci->GetLayoutContext() 
                              && pci->GetLayoutContext()->ViewChain() );

    // Hidden layouts should just accumulate changes, and
    // are measured when unhidden.
    Assert(!IsDisplayNone());

    pdp->SetRTLDisplay((GetFirstBranch()->GetCascadedBlockDirection(LC_TO_FC(LayoutContext())) == styleDirRightToLeft));

    //
    // Adjust the incoming size for max/min width requests
    //

    if (pci->_smMode == SIZEMODE_MMWIDTH)
    {
        psize->cx =
        psize->cy = pci->GetDeviceMaxX();
    }
    else if (pci->_smMode == SIZEMODE_MINWIDTH)
    {
        psize->cx = 1;
        psize->cy = pci->GetDeviceMaxX();
    }

    //
    // Construct the "view" rectangle from the available size
    // Also, determine the amount of space to allow for things external to the view
    // (For sites which size to their content, calculate the full amount;
    //  otherwise, simply take that which is left over after determining the
    //  view size. Additionally, ensure their view size is never less than 1
    //  pixel, since recalc will not take place for smaller sizes.)
    //

    if (_fContentsAffectSize)
    {
        long lMinimum = (pci->_smMode == SIZEMODE_MINWIDTH ? 1 : 0);

        rcView.top    = 0;
        rcView.left   = 0;
        rcView.right  = 0x7FFFFFFF;
        rcView.bottom = 0x7FFFFFFF;

        // Adjust the values of the passed-in rect to not include borders and scrollbar space
        SubtractClientRectEdges(&rcView, pci);

        // the "adjustment" values are the amount of space occupied by borders/scrollbars.
        cxAdjustment  = 0x7FFFFFFF - (rcView.right - rcView.left);
        cyAdjustment  = 0x7FFFFFFF - (rcView.bottom - rcView.top);

        rcView.right  = rcView.left + max(lMinimum, psize->cx - cxAdjustment);
        rcView.bottom = rcView.top  + max(lMinimum, psize->cy - cyAdjustment);
    }

    else
    {
        rcView.top    = 0;
        rcView.left   = 0;
        rcView.right  = psize->cx;
        rcView.bottom = psize->cy;

        SubtractClientRectEdges(&rcView, pci);
    }

    cxView = max(0L, rcView.right - rcView.left);
    cyView = max(0L, rcView.bottom - rcView.top);

    if (!_fContentsAffectSize)
    {
        cxAdjustment = psize->cx - cxView;
        cyAdjustment = psize->cy - cyView;
    }

    if (fViewChain)
    {
        //
        // Update available size 
        //
        
        // TODO (112489, olego) : Work should be done to make Trident story 
        // consistent for handling content document elements margins in PageView. 
        // This requires more feedback from PM.
        
        // (olego): cyAdjustment includes both top and bottom borders (and horizontal scroll bar) 
        // which is not what we want to count if the layout is going to break. We need to have more 
        // sofisticated logic here to correct available size. 
        pci->_cyAvail -= cyAdjustment;
    }

    //
    // Determine if a full recalc of the text is necessary
    // NOTE: SetViewSize must always be called first
    //

    pdp->SetViewSize(rcView);

    fFullRecalc =   pdp->GetViewWidth() != xViewWidthOld
                 || (   (  ContainsVertPercentAttr()
                        || _fContainsRelative
                        || pci->_pMarkup->_fHaveDifferingLayoutFlows)
                    &&  pdp->GetViewHeight() != yViewHeightOld  )
                 //  NOTE (olego) : Check for NoContent has been added to avoid text recalc for partial table 
                 //  cells in print view. So the logic is if layout has been calc'ed and layout has no lines 
                 //  ignore zero line count. 
                 || (!pdp->NoContent() && !pdp->LineCount())
                 || ElementOwner()->Tag() == ETAG_FRAME
                 || ElementOwner()->Tag() == ETAG_IFRAME
                 || !fNormalMode
                 || (pci->_grfLayout & LAYOUT_FORCE)
                 //  if print view do full recalc (since ppv doesn't support partial recalc)
                 || (fViewChain && ElementCanBeBroken())
                 || pdp->IsRTLDisplay() != fRTLDisplayOld;

    TraceTagEx((tagCalcSizeDetail, TAG_NONAME, " Full recalc: %S", (fFullRecalc ? _T("YES") : _T("NO")) ));
    if (fFullRecalc)
    {
        CSaveCalcInfo sci(pci, this);
        BOOL fWordWrap = pdp->GetWordWrap();

        if (!!_fDTRForceLayout)
            pci->_grfLayout |= LAYOUT_FORCE;

        //
        // If the text will be fully recalc'd, cancel any outstanding changes
        //

        CancelChanges();

        if (pci->_smMode != SIZEMODE_MMWIDTH &&
            pci->_smMode != SIZEMODE_MINWIDTH)
        {
            long          xParentWidth;
            long          yParentHeight;
            pdp->GetViewWidthAndHeightForChild(
                pci,
                &xParentWidth,
                &yParentHeight,
                pci->_smMode == SIZEMODE_MMWIDTH);

            if (    ElementOwner()->HasMarkupPtr() 
                &&  ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document()  )
            {
                // If renedering in CSS1 strict mode xParentWidth should stay the same 
                // since percent padding should be relative to *real* parent width. 
                xParentWidth = pci->_sizeParent.cx;
            }

            pci->SizeToParent(xParentWidth, yParentHeight);
        }
        
        if (pci->_smMode == SIZEMODE_MMWIDTH)
        {
            pdp->SetWordWrap(FALSE);
        }

        if (    fNormalMode
            && !(pci->_grfLayout & LAYOUT_FORCE)
            && !ContainsHorzPercentAttr()           // if we contain a horz percent attr, then RecalcLineShift() is insufficient; we need to do a full RecalcView()
            &&  _fMinMaxValid
            &&  pdp->_fMinMaxCalced
            &&  cxView >= pdp->_xMaxWidth
            && !pdp->GetLastLineAligned()           // RecalcLineShift does not handle last line alignment  
            && !_fSizeToContent
            &&  pdp->LineCount()                    // we can only shift lines if we actually have some, else we should do a RecalcView to make sure (bug #67618)
            // pdp->RecalcLineShift could not handle pagination, so if it's print preview use pdp->RecalcView
            && !fViewChain)
        {
            TraceTagEx((tagCalcSizeDetail, TAG_NONAME, " Full recalc via shifting lines"));
            Assert(pdp->_xWidthView  == cxView);
            Assert(!ContainsHorzPercentAttr());
            Assert(!ContainsNonHiddenChildLayout());

            pdp->RecalcLineShift(pci, pci->_grfLayout);
        }
        else
        {
            TraceTagEx((tagCalcSizeDetail, TAG_NONAME, " Full recalc via recalcing lines"));
            _fAutoBelow        = FALSE;
            _fContainsRelative = FALSE;
            pdp->RecalcView(pci, fFullRecalc);
        }

        //
        // Inval since we are doing a full recalc
        //
        Invalidate();

        if (fNormalMode)
        {
            pdp->_fMinMaxCalced = FALSE;
        }

        if (pci->_smMode == SIZEMODE_MMWIDTH)
        {
            pdp->SetWordWrap(fWordWrap);
        }
    }
    //
    // If only a partial recalc is necessary, commit the changes
    //
    else if (!IsCommitted())
    {
        TraceTagEx((tagCalcSizeDetail, TAG_NONAME, " Not a full recalc, but dirty, so committing changes.  DTR(%d, %d, %d) ", _dtr._cp, _dtr._cchNew, _dtr._cchOld ));
        Assert(pci->_smMode != SIZEMODE_MMWIDTH);
        Assert(pci->_smMode != SIZEMODE_MINWIDTH);

        CommitChanges(pci);
    }

    //
    //    Propagate CCalcInfo state as appropriate
    //

    if (fNormalMode)
    {
        CLineCore * pli;
        unsigned    i;

        //
        // For normal calculations, determine the baseline of the "first" line
        // (skipping over any aligned sites at the beginning of the text)
        //

        pci->_yBaseLine = 0;
        for (i=0; i < pdp->Count(); i++)
        {
            pli = pdp->Elem(i);
            if (!pli->IsFrame())
            {
                pci->_yBaseLine = pli->_yHeight - pli->oi()->_yDescent;
                break;
            }
        }
    }

    //
    // Determine the size from the calculated text
    //

    if (pci->_smMode != SIZEMODE_SET)
    {
        switch (pci->_smMode)
        {
        case SIZEMODE_FULLSIZE:
        case SIZEMODE_NATURAL:
            if (_fContentsAffectSize || pci->_smMode == SIZEMODE_FULLSIZE)
            {
                pdp->GetSize(psize);
                ((CSize *)psize)->MaxX(((CRect &)rcView).Size());
            }
            else
            {
                psize->cx = cxView;
                psize->cy = cyView;
            }
            break;

        case SIZEMODE_NATURALMIN:
            if (_fContentsAffectSize)
                pdp->GetSize(psize);
            else
                ((CSize*)psize)->SetSize(cxView, cyView);
            if (psizeDefault)
                psizeDefault->cx = psizeDefault->cy = pdp->_xMinWidth;
            break;

        case SIZEMODE_MMWIDTH:
        {
            psize->cx = pdp->GetWidth();
            psize->cy = pdp->_xMinWidth;

            if (psizeDefault)
            {
                psizeDefault->cx = pdp->GetWidth() + cxAdjustment;
                psizeDefault->cy = pdp->GetHeight() + cyAdjustment;
            }

            break;
        }
        case SIZEMODE_MINWIDTH:
        {
            psize->cx = pdp->GetWidth();
            psize->cy = pdp->GetHeight();
            pdp->FlushRecalc();
            break;
        }

#if DBG==1
        default:
            AssertSz(0, "CFlowLayout::CalcTextSize: Unknown SIZEMODE_xxxx");
            break;
#endif
        }

        psize->cx += cxAdjustment;
        psize->cy += (pci->_smMode == SIZEMODE_MMWIDTH
                              ? cxAdjustment
                              : cyAdjustment);
    }

    pci->_cyAvail = cyAvailSafe;

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CFlowLayout::CalcTextSize L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
}


//+----------------------------------------------------------------------------
//
//    Function:    ViewChange
//
//    Synopsis:    Called when the visible view has changed. Notifies the
//                Doc so that proper Ole notifications can be sent
//
//-----------------------------------------------------------------------------

void
CFlowLayout::ViewChange(BOOL fUpdate)
{
    Doc()->OnViewChange(DVASPECT_CONTENT);
#if 0
    if(fUpdate)
        Doc()->UpdateForm();
#endif
}


//+------------------------------------------------------------------------
//
//    Member:     CFlowLayout::ScrollRangeIntoView
//
//    Synopsis:   Scroll an arbitrary range into view
//
//    Arguments:  cpMin:     Starting cp of the range
//                cpMost:  Ending cp of the range
//                spVert:  Where to "pin" the range
//                spHorz:  Where to "pin" the range
//
//-------------------------------------------------------------------------

HRESULT
CFlowLayout::ScrollRangeIntoView(
    long        cpMin,
    long        cpMost,
    SCROLLPIN    spVert,
    SCROLLPIN    spHorz)
{
extern void BoundingRectForAnArrayOfRectsWithEmptyOnes(RECT *prcBound, CDataAry<RECT> * paryRects);

    HRESULT hr = S_OK;

    if (    _pDispNode
        &&    cpMin >= 0)
    {
        CStackDataAry<RECT, 5>    aryRects(Mt(CFlowLayoutScrollRangeInfoView_aryRects_pv));
        CRect                    rc;
        CCalcInfo                CI(this);

        hr = THR(WaitForParentToRecalc(cpMost, -1, &CI));
        if (hr)
            goto Cleanup;

        _dp.RegionFromElement( ElementOwner(),        // the element
                                 &aryRects,         // rects returned here
                                 NULL,                // offset the rects
                                 NULL,                // ask RFE to get CFormDrawInfo
                                 RFE_SCROLL_INTO_VIEW, // coord w/ respect to the display and not the client rc
                                 cpMin,             // give me the rects from here ..
                                 cpMost,            // ... till here
                                 NULL);             // dont need bounds of the element!

        // Calculate and return the total bounding rect
        BoundingRectForAnArrayOfRectsWithEmptyOnes(&rc, &aryRects);

        // Ensure rect isn't empty
        if (rc.right <= rc.left)
            rc.right = rc.left + 1;
        if (rc.bottom <= rc.top)
            rc.bottom = rc.top + 1;

        if(spVert == SP_TOPLEFT)
        {
            // Though RegionFromElement has already called WaitForRecalc,
            // it calls it until top is recalculated. In order to scroll
            // ptStart to the to of the screen, we need to wait until
            // another screen is recalculated.
            if (!_dp.WaitForRecalc(-1, rc.top + _dp.GetViewHeight()))
            {
                hr = E_FAIL;
                goto Cleanup;
            }
        }

        ScrollRectIntoView(rc, spVert, spHorz);
        hr = S_OK;
    }
    else
    {
        hr = super::ScrollRangeIntoView(cpMin, cpMost, spVert, spHorz);
    }


Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+----------------------------------------------------------------------------
//
// Member:      CFlowLayout::GetSiteWidth
//
// Synopsis:    returns the width and x proposed position of any given site
//              taking the margins into account.
//
//-----------------------------------------------------------------------------

BOOL
CFlowLayout::GetSiteWidth(CLayout   *pLayout,
                          CCalcInfo *pci,
                          BOOL       fBreakAtWord,
                          LONG       xWidthMax,
                          LONG      *pxWidth,
                          LONG      *pyHeight,
                          INT       *pxMinSiteWidth,
                          LONG      *pyBottomMargin)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CFlowLayout::GetSiteWidth L(0x%x, %S) measuring L(0x%x, %S)",
                this, ElementOwner()->TagName(), pLayout, pLayout->ElementOwner()->TagName() ));

    CDoc *pDoc = Doc();
    LONG xLeftMargin, xRightMargin;
    LONG yTopMargin, yBottomMargin;
    SIZE sizeObj = g_Zero.size;
   
    Assert (pLayout && pxWidth);

    *pxWidth = 0;

    if (pxMinSiteWidth)
        *pxMinSiteWidth = 0;

    if (pyHeight)
        *pyHeight = 0;

    if (pyBottomMargin)
        *pyBottomMargin = 0;
    
    if(pLayout->IsDisplayNone())
    {
        TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CFlowLayout::GetSiteWidth L(0x%x, %S) measuring L(0x%x, %S) - no work done",
                    this, ElementOwner()->TagName(), pLayout, pLayout->ElementOwner()->TagName() ));
        return FALSE;
    }

    // get the margin info for the site
    pLayout->GetMarginInfo(pci, &xLeftMargin, &yTopMargin, &xRightMargin, &yBottomMargin);

    //
    // measure the site
    //
    if (pDoc->_lRecursionLevel == MAX_RECURSION_LEVEL)
    {
        AssertSz(0, "Max recursion level reached!");
        sizeObj.cx = 0;
        sizeObj.cy = 0;
    }
    else
    {
        LONG lRet;

        pDoc->_lRecursionLevel++;
        lRet = MeasureSite(pLayout,
                   pci,
                   xWidthMax - xLeftMargin - xRightMargin,
                   fBreakAtWord,
                   &sizeObj,
                   pxMinSiteWidth);
        pDoc->_lRecursionLevel--;

        if (lRet)
        {
            TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CFlowLayout::GetSiteWidth L(0x%x, %S) measuring L(0x%x, %S)",
                        this, ElementOwner()->TagName(), pLayout, pLayout->ElementOwner()->TagName() ));
            return TRUE;
        }
    }
    
    //
    // Propagate the _fAutoBelow bit, if the child is auto positioned or
    // non-zparent children have auto positioned children
    //
    if (!_fAutoBelow)
    {
        const CFancyFormat * pFF = pLayout->GetFirstBranch()->GetFancyFormat(LC_TO_FC(LayoutContext()));

        if (    pFF->IsAutoPositioned()
            ||    (    !pFF->IsZParent()
                &&    (pLayout->_fContainsRelative || pLayout->_fAutoBelow)))
        {
            _fAutoBelow = TRUE;
        }
    }

    // not adjust the size and proposed x pos to include margins
    *pxWidth = max(0L, xLeftMargin + xRightMargin + sizeObj.cx);

    if (pxMinSiteWidth)
    {
        *pxMinSiteWidth += max(0L, xLeftMargin + xRightMargin);
    }

    if (pyHeight)
    {
        *pyHeight = max(0L, sizeObj.cy + yTopMargin + yBottomMargin);
    }

    if (pyBottomMargin)
    {
        *pyBottomMargin = max(0L, yBottomMargin);
    }
    
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CFlowLayout::GetSiteWidth L(0x%x, %S) measuring L(0x%x, %S)",
                this, ElementOwner()->TagName(), pLayout, pLayout->ElementOwner()->TagName() ));
    return FALSE;
}


//+----------------------------------------------------------------------------
//
// Member:      CFlowLayout::MeasureSite()
//
// Synopsis:    Measure width and height of a embedded site
//
//-----------------------------------------------------------------------------
int
CFlowLayout::MeasureSite(CLayout   *pLayout,
                         CCalcInfo *pci,
                         LONG       xWidthMax,
                         BOOL       fBreakAtWord,
                         SIZE      *psizeObj,
                         int       *pxMinWidth)
{
    CSaveCalcInfo sci(pci);
    LONG lRet = 0;

    Assert(pci->_smMode != SIZEMODE_SET);

    if (!pLayout->ElementOwner()->IsInMarkup())
    {
        psizeObj->cx = psizeObj->cy = 0;
        return lRet;
    }

    // if the layout we are measuring (must be a child of ours)
    // is percent sized, then we should take this oppurtunity
    // to set some work-flags 
    {
        // Set flags relative to this layout's coordinate system

        CTreeNode *pNodeChild = pLayout->GetFirstBranch();
        const CFancyFormat *pFFChild  = pNodeChild->GetFancyFormat(LC_TO_FC(pLayout->LayoutContext()));
        BOOL  fChildWritingModeUsed   = pNodeChild->GetCharFormat(LC_TO_FC(pLayout->LayoutContext()))->_fWritingModeUsed;
        BOOL  fThisVerticalLayoutFlow = GetFirstBranch()->GetCharFormat(LC_TO_FC(LayoutContext()))->HasVerticalLayoutFlow();

        if (pFFChild->IsLogicalHeightPercent(fThisVerticalLayoutFlow, fChildWritingModeUsed))
        {
            SetVertPercentAttrInfo(TRUE);
        }

        if (pFFChild->IsLogicalWidthPercent(fThisVerticalLayoutFlow, fChildWritingModeUsed))
        {
            SetHorzPercentAttrInfo(TRUE);
        }
    }

    if (    fBreakAtWord 
        && (!pci->_fIgnorePercentChild || !pLayout->PercentHeight())  )
    {
        BOOL fViewChain =  pci->GetLayoutContext() 
                        && pci->GetLayoutContext()->ViewChain();
        long xParentWidth;
        long yParentHeight;

        if (    ElementOwner()->HasMarkupPtr() 
            &&  ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document()  )
        {
            long cxParentWidth = _sizeProposed.cx - pLayout->ComputeMBPWidthHelper(pci, this);

            if (cxParentWidth < 0)
                cxParentWidth = 0;

            pci->SizeToParent(cxParentWidth, _sizeProposed.cy);
        }
        else 
        {
            _dp.GetViewWidthAndHeightForChild(
                    pci,
                    &xParentWidth,
                    &yParentHeight);

            // Set the appropriate parent width
            pci->SizeToParent(xParentWidth, yParentHeight);
        }


        // set available size in sizeObj or if absolutely positioned, 
        // we WANT the parent's width (bug 98849).
        psizeObj->cx = (pLayout->ElementOwner()->IsAbsolute()) 
                             ? pci->_sizeParent.cx
                             : xWidthMax;           // this value has margins removed from parent size
        psizeObj->cy = pci->_sizeParent.cy;

        if (fViewChain)
        {
            //  Update available height for nested layout
            pci->_cyAvail = max(0, pci->_cyAvail - pci->_yConsumed);
            pci->_yConsumed = 0;
        }

        //
        // Force child not to break if this layout could not 
        //

        // TODO (112467, olego): Now we have CLayout::_fElementCanBeBroken bit flag 
        // that prohibit layout breaking in Page View. This approach is not suffitient 
        // enouth for editable Page View there we want this property to be calculated 
        // dynamically depending on layout type and layout nesting position (if parent 
        // has it child should inherit). 
        // This work also will enable CSS attribute page-break-inside support.

        if (!ElementCanBeBroken())
        {
            pLayout->SetElementCanBeBroken(FALSE);
        }

        // Ensure the available size does not exceed that of the view
        // (For example, when word-breaking is disabled, the available size
        //    is set exceedingly large. However, percentage sized sites should
        //    still not grow themselves past the view width.)

        if (    pci->_smMode == SIZEMODE_NATURAL 
            &&  pLayout->PercentSize())
        {
            if (pci->_sizeParent.cx < psizeObj->cx)
            {
                psizeObj->cx = pci->_sizeParent.cx;
            }
            if (pci->_sizeParent.cy < psizeObj->cy)
            {
                psizeObj->cy = pci->_sizeParent.cy;
            }
        }

        //
        // If the site is absolutely positioned, only use SIZEMODE_NATURAL
        //
        if (pLayout->ElementOwner()->IsAbsolute(LC_TO_FC(pLayout->LayoutContext())))
        {
            pci->_smMode = SIZEMODE_NATURAL;
        }

        // Mark the site for sizing if it is already marked
        // or it is percentage sized and the view size has changed and
        // the site doesn't already know whether to resize.
        if (!pLayout->ElementOwner()->TestClassFlag(CElement::ELEMENTDESC_NOPCTRESIZE))
        {
            pLayout->SetSizeThis( pLayout->IsSizeThis() || pLayout->PercentSize() );
        }

        pLayout->CalcSize(pci, psizeObj);

        if (pxMinWidth)
        {
            // In MMWIDTH and NATURALMIN modes we need to get minimum object width
            // In MMWIDTH mode cy contains minimum object width
            // In NATURALMIN mode size is real object size, so we get cx as object width
            if (pci->_smMode == SIZEMODE_MMWIDTH)
                *pxMinWidth = psizeObj->cy;
            else if (pci->_smMode == SIZEMODE_NATURALMIN)
            {
                if (pLayout->GetLayoutDesc()->TestFlag(LAYOUTDESC_FLOWLAYOUT))
                {
                    CFlowLayout * pFlowLayout = DYNCAST(CFlowLayout, pLayout);
                    *pxMinWidth = pFlowLayout->_sizeMin.cu;
                }
                else
                {
                    *pxMinWidth = psizeObj->cx;
                }
            }
        }
    }
    else
    {
        pLayout->GetApparentSize(psizeObj);
    }

    return lRet;
}


//+------------------------------------------------------------------------
//
//    Member:     CommitChanges
//
//    Synopsis:    Commit any outstanding text changes to the display
//
//-------------------------------------------------------------------------
DeclareTag(tagLineBreakCheckOnCommit, "Commit", "Disable Line break check on commit");

void
CFlowLayout::CommitChanges(
    CCalcInfo * pci)
{
    long cp;
    long cchOld;
    long cchNew;
    bool fDTRForceLayout;

    //
    //    Ignore unnecessary or recursive requests
    //
    if (!IsDirty() || (IsDisplayNone()))
        goto Cleanup;

    //
    //    Reset dirty state (since changes they are now being handled)
    //    

    cp         = Cp() + GetContentFirstCp();
    cchOld     = CchOld();
    cchNew     = CchNew();
    //(dmitryt)
    //_fDTRForceLayout tells us to recalc layouts in DTR, even if they are not marked dirty
    //This is used to recalc after element insertion - in this case, element by itself can
    //influence how layouts inside its scope are laid out. However, we don't send
    //notification to descendants to mark them all dirty - too costly. 
    //Instead we set this flag and this forces recalc of all layouts (like IMG) inside
    //affected subtree. Note that _fDTRForceLayout is reset by CancelChanges and is, in fact, 
    //part of DTR so we cache it here to use couple of lines below.
    fDTRForceLayout = !!_fDTRForceLayout; 

    CancelChanges();

    WHEN_DBG(Lock());

    //
    //    Recalculate the display to account for the pending changes
    //

    {
        CElement::CLock Lock(ElementOwner(), CElement::ELEMENTLOCK_SIZING);
        CSaveCalcInfo    sci(pci, this);

        if (fDTRForceLayout)
        {
            pci->_grfLayout |= LAYOUT_FORCE;
        }

        _dp.UpdateView(pci, cp, cchOld, cchNew);
    }


    //
    //    Fire a "content changed" notification (to our host)
    //

    OnTextChange();

    WHEN_DBG(Unlock());

Cleanup:
    return;
}

//+------------------------------------------------------------------------
//
//    Member:     CancelChanges
//
//    Synopsis:    Cancel any outstanding text changes to the display
//
//-------------------------------------------------------------------------
void
CFlowLayout::CancelChanges()
{
    if (IsDirty())
    {
        _dtr.Reset();
    }
    _fDTRForceLayout = FALSE;
}

//+------------------------------------------------------------------------
//
//    Member:     IsCommitted
//
//    Synopsis:    Verify that all changes are committed
//
//-------------------------------------------------------------------------
BOOL
CFlowLayout::IsCommitted()
{
    return !IsDirty();
}

extern BOOL IntersectRgnRect(HRGN hrgn, RECT *prc, RECT *prcIntersect);

//+---------------------------------------------------------------------------
//
//    Member:     Draw
//
//    Synopsis:    Paint the object.
//
//----------------------------------------------------------------------------

void
CFlowLayout::Draw(CFormDrawInfo *pDI, CDispNode * pDispNode)
{
    _dp.Render(pDI, pDI->_rc, pDI->_rcClip, pDispNode);
}

inline BOOL
CFlowLayout::GetMultiLine() const
{
    // see if behaviour set default isMultiLine
    CDefaults *pDefaults = ElementOwner()->GetDefaults();
    return pDefaults ? !!pDefaults->GetAAisMultiLine() : TRUE;
}


//+----------------------------------------------------------------------------
//
//    Member:     GetTextNodeRange
//
//    Synopsis:    Return the range of lines that the given text flow node
//                owns
//
//    Arguments:    pDispNode    - text flow disp node.
//                piliStart    - return parameter for the index of the start line
//                piliFinish    - return parameter for the index of the last line
//
//-----------------------------------------------------------------------------
void
CFlowLayout::GetTextNodeRange(CDispNode * pDispNode, long * piliStart, long * piliFinish)
{
    Assert(pDispNode);
    Assert(piliStart);
    Assert(piliFinish);

    *piliStart = 0;
    *piliFinish = _dp.LineCount();

    //
    // First content disp node does not have a cookie
    //
    if (pDispNode != GetFirstContentDispNode())
    {
        *piliStart = (LONG)(LONG_PTR)pDispNode->GetExtraCookie();
    }

    for (pDispNode = pDispNode->GetNextFlowNode();
         pDispNode;
         pDispNode = pDispNode->GetNextFlowNode())
    {
        if (this == pDispNode->GetDispClient())
        {
            *piliFinish = (LONG)(LONG_PTR)pDispNode->GetExtraCookie();
            break;
        }
    }
}


//+----------------------------------------------------------------------------
//
//    Member:     GetPositionInFlow
//
//    Synopsis:    Return the position of a layout derived from its position within
//                the document text flow
//
//    Arguments:    pElement - element to position
//                ppt      - Returned top/left (in parent content relative coordinates)
//
//-----------------------------------------------------------------------------
void
CFlowLayout::GetPositionInFlow(
    CElement *    pElement,
    CPoint     *    ppt)
{
    CLinePtr rp(&_dp);
    CTreePos *    ptpStart;

    Assert(pElement);
    Assert(ppt);

    if(pElement->IsRelative() && !pElement->ShouldHaveLayout())
    {
        GetFlowPosition(pElement, ppt);
    }
    else
    {
        BOOL fRTLFlow = IsRTLFlowLayout();
    
        ppt->x = ppt->y = 0;

        // get the tree extent of the element of the layout passed in
        pElement->GetTreeExtent(&ptpStart, NULL);

        if (_dp.RenderedPointFromTp(ptpStart->GetCp(), ptpStart, FALSE, *ppt, &rp, TA_TOP, NULL, &fRTLFlow) < 0)
            return;

        if(pElement->ShouldHaveLayout())
        {
            CLayout *pLayout = pElement->GetUpdatedLayout(LayoutContext());
            
            ppt->y += pLayout->GetYProposed();
            
            // RTL: adjust position for flow direction
            if (fRTLFlow)
            {
                ppt->x -= pLayout->GetApparentWidth() - 1;
            }
        }
        ppt->y += rp->GetYTop(rp->oi());
    }
}


//----------------------------------------------------------------------------
//
//    Member:     CFlowLayout::BranchFromPoint, public
//
//    Synopsis:    Does a hit test against our object, determining where on the
//                object it hit.
//
//    Arguments:    [pt]           -- point to hit test in local coordinates
//                [ppNodeElement]   -- return the node hit
//
//    Returns:    HTC
//
//    Notes:        The node returned is guaranteed to be in the tree
//                so it is legal to look at the parent for this element.
//
//----------------------------------------------------------------------------

HTC
CFlowLayout::BranchFromPoint(
    DWORD            dwFlags,
    POINT            pt,
    CTreeNode     ** ppNodeBranch,
    HITTESTRESULTS* presultsHitTest,
    BOOL            fNoPseudoHit,
    CDispNode      * pDispNode)
{
    HTC         htc = HTC_YES;
    CDisplay  * pdp =  &_dp;
    CLinePtr    rp(pdp);
    CTreePos  * ptp   = NULL;
    LONG        cp, ili, yLine;
    DWORD        dwCFPFlags = 0;
    CRect        rc(pt, pt);
    long        iliStart  = -1;
    long        iliFinish = -1;
    HITTESTRESULTS htrSave = *presultsHitTest;

    dwCFPFlags |= (dwFlags & HT_ALLOWEOL)
                    ? CDisplay::CFP_ALLOWEOL : 0;
    dwCFPFlags |= !(dwFlags & HT_DONTIGNOREBEFOREAFTER)
                    ? CDisplay::CFP_IGNOREBEFOREAFTERSPACE : 0;
    dwCFPFlags |= !(dwFlags & HT_NOEXACTFIT)
                    ? CDisplay::CFP_EXACTFIT : 0;
    dwCFPFlags |= fNoPseudoHit
                    ? CDisplay::CFP_NOPSEUDOHIT : 0;

    Assert(ElementOwner()->IsVisible(FALSE FCCOMMA LC_TO_FC(LayoutContext())) || ElementOwner()->Tag() == ETAG_BODY);

    *ppNodeBranch = NULL;

    //
    // if the current layout has multiple text nodes then compute the
    // range of lines the belong to the current dispNode
    // Note: if dispNode is a container, the whole text range of the layout apply.
    if (pdp->_fHasMultipleTextNodes && pDispNode && !pDispNode->IsContainer())

    {
        GetTextNodeRange(pDispNode, &iliStart, &iliFinish);
    }

    if (pDispNode == GetElementDispNode())
    {
        GetClientRect(&rc); 
        rc.MoveTo(pt);
    }

    ili = pdp->LineFromPos(
                          rc, &yLine, &cp, CDisplay::LFP_ZORDERSEARCH   |
                                           CDisplay::LFP_IGNORERELATIVE |
                                           CDisplay::LFP_IGNOREALIGNED  |
                                            (fNoPseudoHit
                                                ? CDisplay::LFP_EXACTLINEHIT
                                                : 0),
                                            iliStart,
                                            iliFinish);
    if(ili < 0)
    {
        htc = HTC_NO;
        goto Cleanup;
    }

    if ((cp = pdp->CpFromPointEx(ili, yLine, cp, pt, &rp, &ptp, NULL, dwCFPFlags,
                              &presultsHitTest->_fRightOfCp, &presultsHitTest->_fPseudoHit,
                              &presultsHitTest->_cchPreChars,
                              &presultsHitTest->_fGlyphHit,
                              &presultsHitTest->_fBulletHit, NULL)) == -1 ) // fExactFit=TRUE to look at whole characters
    {
        htc = HTC_NO;
        goto Cleanup;
    }

    if (   cp < GetContentFirstCp()
        || cp > GetContentLastCp()
       )
    {
        htc = HTC_NO;
        goto Cleanup;
    }

    presultsHitTest->_cpHit  = cp;
    presultsHitTest->_iliHit = rp;
    presultsHitTest->_ichHit = rp.RpGetIch();

    if (IsEditable() && ptp->IsNode() && ptp->ShowTreePos()
                     && (cp + 1 == ptp->GetBranch()->Element()->GetFirstCp()))
    {
        presultsHitTest->_fWantArrow = TRUE;
        htc = HTC_YES;
        *ppNodeBranch = ptp->GetBranch();
    }
    else
    {
        if (pDispNode)
        {
            pt.y += pDispNode->GetPosition().y;
        }

        htc = BranchFromPointEx(pt, rp, ptp, NULL, ppNodeBranch, presultsHitTest->_fPseudoHit,
                                &presultsHitTest->_fWantArrow,
                                !(dwFlags & HT_DONTIGNOREBEFOREAFTER)
                                );
    }

Cleanup:
    if (htc != HTC_YES)
    {
        *presultsHitTest = htrSave;
        presultsHitTest->_fWantArrow = TRUE;
    }
    return htc;
}

extern BOOL PointInRectAry(POINT pt, CStackDataAry<RECT, 1> &aryRects);

HTC
CFlowLayout::BranchFromPointEx(
    POINT         pt,
    CLinePtr  &  rp,
    CTreePos  *  ptp,
    CTreeNode *  pNodeRelative,  // (IN) non-NULL if we are hit-testing a relative element (NOT its flow position)
    CTreeNode ** ppNodeBranch,     // (OUT) returns branch that we hit
    BOOL         fPseudoHit,     // (IN) if true, text was NOT hit (CpFromPointEx() figures this out)
    BOOL       * pfWantArrow,     // (OUT) 
    BOOL         bIgnoreBeforeAfter
    )
{
    const CCharFormat * pCF;
    CTreeNode * pNode = NULL;
    CElement * pElementStop = NULL;
    HTC         htc   = HTC_YES;
    BOOL        fVisible = TRUE;
    Assert(ptp);

    //
    // If we are on a line which contains an table, and we are not ignoring before and
    // aftrespace, then we want to hit that table...
    //
    if (!bIgnoreBeforeAfter)
    {
        CLineCore * pli = rp.CurLine();
        if (   pli
            && pli->_fSingleSite
            && pli->_cch == rp.RpGetIch()
           )
        {
            rp.RpBeginLine();
            rp.GetPdp()->FormattingNodeForLine(FNFL_NONE, rp.GetPdp()->GetFirstCp() + rp.GetCp(), NULL, pli->_cch, NULL, &ptp, NULL);
        }
    }

    // Get the branch corresponding to the cp hit.
    pNode = ptp->GetBranch();
    
    // If we hit the white space around text, then find the block element
    // that we hit. For example, if we hit in the padding of a block
    // element then it is hit.
    if (bIgnoreBeforeAfter && fPseudoHit)
    {
        CStackDataAry<RECT, 1>    aryRects(Mt(CFlowLayoutBranchFromPointEx_aryRects_pv));
        CMarkup *    pMarkup = GetContentMarkup();
        LONG        cpClipStart;
        LONG        cpClipFinish;
        DWORD        dwFlags = RFE_HITTEST;

        //
        // If a relative node is passed in, the point is already in the
        // co-ordinate system established by the relative element, so
        // pass RFE_IGNORE_RELATIVE to ignore the relative top left when
        // computing the region.
        //
        if (pNodeRelative)
        {
            dwFlags |= RFE_IGNORE_RELATIVE;
            pNode    =  pNodeRelative;
        }

        cpClipStart = cpClipFinish = rp.GetPdp()->GetFirstCp();
        rp.RpBeginLine();
        cpClipStart += rp.GetCp();
        rp.RpEndLine();
        cpClipFinish += rp.GetCp();

        // walk up the tree and find the block element that we hit.
        while (pNode && !SameScope(pNode, ElementContent()))
        {
            if (!pNodeRelative)
                pNode = pMarkup->SearchBranchForBlockElement(pNode, this);

            if (!pNode)
            {
                // this is bad, somehow, a pNodeRelavite was passed in for 
                // an element that is not under this flowlayout. How to interpret
                // this? easiest (and safest) is to just bail
                break;
            }

            _dp.RegionFromElement(pNode->Element(), &aryRects, NULL,
                                    NULL, dwFlags, cpClipStart, cpClipFinish);

            if (PointInRectAry(pt, aryRects))
            {
                break;
            }
            else if (pNodeRelative)
            {
                htc = HTC_NO;
            }

            if (pNodeRelative || SameScope(pNode, ElementContent()))
                break;

            pNode = pNode->Parent();
        }

        *pfWantArrow = TRUE;
    }

    if (!pNode)
    {
        htc = HTC_NO;
        goto Cleanup;
    }

    // pNode now points to the element we hit, but it might be
    // hidden.    If it's hidden, we need to walk up the parent
    // chain until we find an ancestor that isn't hidden,
    // or until we hit the layout owner or a relative element
    // (we want testing to stop on relative elements because
    // they exist in a different z-plane).    Note that
    // BranchFromPointEx may be called for hidden elements that
    // are inside a relative element.

    pElementStop = pNodeRelative
                                ? pNodeRelative->Element()
                                : ElementContent();

    while (DifferentScope(pNode, pElementStop))
    {
        pCF = pNode->GetCharFormat(LC_TO_FC(LayoutContext()));
        if (pCF->IsDisplayNone() || pCF->IsVisibilityHidden())
        {
            fVisible = FALSE;
            pNode = pNode->Parent();
        }
        else
            break;
    }

    Assert(pNode);

    //
    // if we hit the layout element and it is a pseudo hit or
    // if the element hit is not visible then consider it a miss
    //

    // We want to show an arrow if we didn't hit text (fPseudoHit TRUE) OR
    // if we did hit text, but it wasn't visible (as determined by the loop
    // above which set fVisible FALSE).
    if (fPseudoHit || !fVisible)
    {
        // If we walked all the way up to the container, then we want
        // to return HTC_NO so the display tree will call HitTestContent
        // on the container's dispnode (i.e. "the background"), which will
        // return HTC_YES.

        // If it's relative, then htc was set earlier, so don't
        // touch it now.
        if ( !pNodeRelative )
            htc = SameScope( pNode, ElementContent() ) ? HTC_NO : HTC_YES;

        *pfWantArrow  = TRUE;
    }
    else
    {
        *pfWantArrow  = !!fPseudoHit;
    }

Cleanup:
    *ppNodeBranch = pNode;

    return htc;
}

//+------------------------------------------------------------------------
//
//    Member:     GetFirstLayout
//
//    Synopsis:    Enumeration method to loop thru children (start)
//
//    Arguments:    [pdw]        cookie to be used in further enum
//                [fBack]     go from back
//
//    Returns:    Layout
//
//-------------------------------------------------------------------------
CLayout *
CFlowLayout::GetFirstLayout(DWORD_PTR * pdw, BOOL fBack /*=FALSE*/, BOOL fRaw /*=FALSE*/)
{
    Assert(!fRaw);

    if (ElementContent()->GetFirstBranch())
    {
        CChildIterator * pLayoutIterator = new
                CChildIterator(
                    ElementContent(),
                    NULL,
                    CHILDITERATOR_USELAYOUT);
        * pdw = (DWORD_PTR)pLayoutIterator;

        return *pdw == NULL ? NULL : CFlowLayout::GetNextLayout(pdw, fBack, fRaw);
    }
    else
    {
        // If CTxtSite is not in the tree, no need to walk through
        // CChildIterator
        //
        * pdw = 0;
        return NULL;
    }
}


//+------------------------------------------------------------------------
//
//    Member:     GetNextLayout
//
//    Synopsis:    Enumeration method to loop thru children
//
//    Arguments:    [pdw]        cookie to be used in further enum
//                [fBack]     go from back
//
//    Returns:    Layout
//
//-------------------------------------------------------------------------
CLayout *
CFlowLayout::GetNextLayout(DWORD_PTR * pdw, BOOL fBack, BOOL fRaw)
{
    CLayout * pLayout = NULL;

    Assert(!fRaw);

    {
        CChildIterator * pLayoutWalker =
                        (CChildIterator *) (* pdw);
        if (pLayoutWalker)
        {
            CTreeNode * pNode = fBack ? pLayoutWalker->PreviousChild()
                                    : pLayoutWalker->NextChild();
            pLayout = pNode ? pNode->GetUpdatedLayout( LayoutContext() ) : NULL;
        }
    }
    return pLayout;
}



//+---------------------------------------------------------------------------
//
//    Member : ClearLayoutIterator
// 
//----------------------------------------------------------------------------
void
CFlowLayout::ClearLayoutIterator(DWORD_PTR dw, BOOL fRaw)
{
    if (!fRaw)
    {
        CChildIterator * pLayoutWalker = (CChildIterator *) dw;
        if (pLayoutWalker)
            delete pLayoutWalker;
    }
}

//+------------------------------------------------------------------------
//
//    Member:     SetZOrder
//
//    Synopsis:    set z order for site
//
//    Arguments:    [pLayout]    set z order for this layout
//                [zorder]    to set
//                [fUpdate]    update windows and invalidate
//
//    Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CFlowLayout::SetZOrder(CLayout * pLayout, LAYOUT_ZORDER zorder, BOOL fUpdate)
{
    HRESULT     hr = S_OK;

    if (fUpdate)
    {
        Doc()->FixZOrder();

        Invalidate();
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//    Member:     IsElementBlockInContext
//
//    Synopsis:   Return whether the element is a block in the current context
//                In general: Elements, if marked, are blocks and sites are not.
//                The exception is CFlowLayouts which are blocks when considered
//                from within themselves and are not when considered
//                from within their parent
//
//    Arguments:
//                [pElement] Element to examine to see if it should be
//                           treated as no scope in the current context.
//
//----------------------------------------------------------------------------

BOOL
CFlowLayout::IsElementBlockInContext ( CElement * pElement )
{
    BOOL fRet = FALSE;
    
    if (pElement == ElementContent())
    {
        fRet = TRUE;
    }
    else if (!pElement->IsBlockElement(LC_TO_FC(LayoutContext())) && !pElement->IsContainer() )
    {
        fRet = FALSE;
    }
    else if (!pElement->ShouldHaveLayout(LC_TO_FC(LayoutContext())))
    {
        fRet = TRUE;
    }
    else
    {
        BOOL fIsContainer = pElement->IsContainer();

        if (!fIsContainer)
        {
            fRet = TRUE;

            //
            // God, I hate this hack ...
            //

            if (pElement->Tag() == ETAG_FIELDSET)
            {
                CTreeNode * pNode = pElement->GetFirstBranch();

                if (pNode)
                {
                    const CCharFormat *pCF = pNode->GetCharFormat();
                    if (  pNode->GetCascadeddisplay() != styleDisplayBlock 
                       && !pNode->GetFancyFormat()->GetLogicalWidth(
                                pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed).IsNullOrEnum()) // IsWidthAuto
                    {
                        fRet = FALSE;
                    }
                }
            }
        }
        else
        {
            //
            // HACK ALERT!
            //
            // For display purposes, contianer elements in their parent context must
            // indicate themselves as block elements.  We do this only for container
            // elements who have been explicity marked as display block.
            //

            if (fIsContainer)
            {
                CTreeNode * pNode = pElement->GetFirstBranch();

                if (pNode && pNode->GetCascadeddisplay(LC_TO_FC(LayoutContext())) == styleDisplayBlock)
                {
                    fRet = TRUE;
                }
            }
        }
    }

    return fRet;
}


//+------------------------------------------------------------------------
//
//    Member:     PreDrag
//
//    Synopsis:    Perform stuff before drag/drop occurs
//
//    Arguments:    ppDO    Data object to return
//                ppDS    Drop source to return
//
//-------------------------------------------------------------------------

HRESULT
CFlowLayout::PreDrag(
    DWORD            dwKeyState,
    IDataObject **    ppDO,
    IDropSource **    ppDS)
{
    HRESULT hr = S_OK;

    CDoc* pDoc = Doc();

    CSelDragDropSrcInfo *    pDragInfo;

    // Setup some info for drag feedback
    Assert(! pDoc->_pDragDropSrcInfo);
    pDragInfo = new CSelDragDropSrcInfo( pDoc ) ;

    if (!pDragInfo)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pDragInfo->Init(ElementContent()) );
    if( hr )
        goto Cleanup;
        
    hr = THR( pDragInfo->GetDataObjectAndDropSource( ppDO, ppDS ) );
    if ( hr )
        goto Cleanup;

    pDoc->_pDragDropSrcInfo = pDragInfo;


Cleanup:

    RRETURN(hr);

}


//+------------------------------------------------------------------------
//
//    Member:     PostDrag
//
//    Synopsis:    Handle the result of an OLE drag/drop operation
//
//    Arguments:    hrDrop        The hr that DoDragDrop came back with
//                dwEffect    The effect of the drag/drop
//
//-------------------------------------------------------------------------

HRESULT
CFlowLayout::PostDrag(HRESULT hrDrop, DWORD dwEffect)
{
#ifdef MERGEFUN // Edit team: figure out better way to send sel-change notifs
    CCallMgr                callmgr(GetPed());
#endif
    HRESULT                 hr;
    CDoc*                   pDoc = Doc();
    
    CParentUndo             pu( pDoc );

    hr = hrDrop;

    if( IsEditable() )
        pu.Start( IDS_UNDODRAGDROP );

    if (hr == DRAGDROP_S_CANCEL)
    {
        //
        // TODO (Bug 13568 ashrafm) - we may have to restore selection here.
        // for now I don't think we need to.
        //

        //Invalidate();
        //pSel->Update(FALSE, this);

        hr = S_OK;
        goto Cleanup;
    }

    if (hr != DRAGDROP_S_DROP)
        goto Cleanup;

    hr = S_OK;

    switch(dwEffect)
    {
    case DROPEFFECT_NONE:
    case DROPEFFECT_COPY:
        Invalidate();
        // pSel->Update(FALSE, this);
        break ;

    case DROPEFFECT_LINK:
        break;

    case 7:
        // dropEffect ALL - do the same thing as 3

    case 3: // TODO (Bug 13568 ashrafm) - this is for TriEdit - faking out a position with Drag & Drop.
        {
            Assert(pDoc->_pDragDropSrcInfo);
            if (pDoc->_pDragDropSrcInfo &&  
                pDoc->_pDragDropSrcInfo->_srcType == DRAGDROPSRCTYPE_SELECTION )
            {
                CSelDragDropSrcInfo * pDragInfo;
                pDragInfo = DYNCAST(CSelDragDropSrcInfo, pDoc->_pDragDropSrcInfo);
                pDragInfo->PostDragSelect();
            }

        }
        break;

    case DROPEFFECT_MOVE:
        if (pDoc->_fSlowClick)
            goto Cleanup;

        Assert(pDoc->_pDragDropSrcInfo);
        if (pDoc->_pDragDropSrcInfo && 
            pDoc->_pDragDropSrcInfo->_srcType == DRAGDROPSRCTYPE_SELECTION )
        {
            CSelDragDropSrcInfo * pDragInfo;
            pDragInfo = DYNCAST(CSelDragDropSrcInfo, pDoc->_pDragDropSrcInfo);
            pDragInfo->PostDragDelete();
        }
        break;

    default:
        Assert(FALSE && "Unrecognized drop effect");
        break;
    }

Cleanup:

    pu.Finish(hr);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//    Member:     Drop
//
//    Synopsis:
//
//----------------------------------------------------------------------------
#define DROPEFFECT_ALL (DROPEFFECT_NONE | DROPEFFECT_COPY | DROPEFFECT_MOVE | DROPEFFECT_LINK)

HRESULT
CFlowLayout::Drop(
    IDataObject *    pDataObj,
    DWORD            grfKeyState,
    POINTL            ptlScreen,
    DWORD *         pdwEffect)
{
    CDoc *    pDoc            = Doc();
    DWORD    dwAllowed        = *pdwEffect;
    TCHAR    pszFileType[4]    = _T("");
    CPoint    pt;
    HRESULT hr                = S_OK;
    

    // Can be null if dragenter was handled by script
    if (!_pDropTargetSelInfo)
    {
        *pdwEffect = DROPEFFECT_NONE ;
        return S_OK;
    }

    AddRef(); // addref ourselves incase we get whacked in the drop.

    //
    // Find out what the effect is and execute it
    // If our operation fails we return DROPEFFECT_NONE
    //
    DragOver(grfKeyState, ptlScreen, pdwEffect);

    IGNORE_HR(DropHelper(ptlScreen, dwAllowed, pdwEffect, pszFileType));


    if (Doc()->_fSlowClick && *pdwEffect == DROPEFFECT_MOVE)
    {
        *pdwEffect = DROPEFFECT_NONE ;
        goto Cleanup;
    }

    //
    // We're all ok at this point. We delegate the handling of the actual
    // drop operation to the DropTarget.
    //


    pt.x = ptlScreen.x;
    pt.y = ptlScreen.y;
    ScreenToClient( pDoc->_pInPlace->_hwnd, (POINT*) & pt );

    //
    // We DON'T TRANSFORM THE POINT, AS MOVEPOINTERTOPOINT is in Global Coords
    //

    hr = THR( _pDropTargetSelInfo->Drop( this, pDataObj, grfKeyState, pt, pdwEffect ));


Cleanup:
    // Erase any feedback that's showing.
    DragHide();
    
    Assert(_pDropTargetSelInfo);
    delete _pDropTargetSelInfo;
    _pDropTargetSelInfo = NULL;

    Release();
    
    RRETURN1(hr,S_FALSE);

}


//+---------------------------------------------------------------------------
//
//  Member:     DragLeave
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT
CFlowLayout::DragLeave()
{
#ifdef MERGEFUN // Edit team: figure out better way to send sel-change notifs
    CCallMgr        callmgr(GetPed());
#endif
    HRESULT         hr        = S_OK;

    if (!_pDropTargetSelInfo)
        goto Cleanup;

    hr = THR(super::DragLeave());

Cleanup:
    if (_pDropTargetSelInfo)
    {
        delete _pDropTargetSelInfo;
        _pDropTargetSelInfo = NULL;
    }
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     ParseDragData
//
//  Synopsis:   Drag/drop helper override
//
//----------------------------------------------------------------------------

HRESULT
CFlowLayout::ParseDragData(IDataObject *pDO)
{
    DWORD   dwFlags = 0;
    HRESULT hr;
    CTreeNode* pNode = NULL;
    ISegmentList    *pSegmentList = NULL;

    // Start with flags set to default values.

    Doc()->_fOKEmbed = FALSE;
    Doc()->_fOKLink = FALSE;
    Doc()->_fFromCtrlPalette = FALSE;

    if (!IsEditable() || !ElementOwner()->IsEnabled())
    {
        // no need to do anything else, bcos we're read only.
        hr = S_FALSE;
        goto Cleanup;
    }

    pNode = ElementOwner()->GetFirstBranch();
    if ( ! pNode )
    {
        hr = E_FAIL;
        goto Cleanup;
    }
    
    // Bug 101921: Check for frozen attribute.  Can't drop on a 'frozen' element.
    // Bug 104772: Should not allow drops on any frozen element.
    if (ElementOwner()->IsParentFrozen()
        || ElementOwner()->IsFrozen())
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    //	Bug 23063: In Whistler, shell data sources support CF_TEXT, so we need to 
    //	first check for CFSTR_SHELLIDLIST to see if the data source comes from the
    //	shell.  We don't want to handle file drops.
    if (pDO->QueryGetData(&g_rgFETC[iShellIdList]) == NOERROR)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    // Allow only plain text to be pasted in input text controls
    // Bug 82119: Don't allow dropping a button on another button.
    if (!pNode->SupportsHtml() || pNode->_etag == ETAG_BUTTON)
    {
        BOOL                    fSiteSelected = FALSE;
        SELECTION_TYPE          eType;
      
        hr = THR ( pDO->QueryInterface( IID_ISegmentList, (void**) & pSegmentList ));
        if ( !hr && pSegmentList )
        {
            IFC( pSegmentList->GetType( &eType ));

            if ( eType == SELECTION_TYPE_Control )
            {
                fSiteSelected = TRUE;
            }
        }
        
        if (fSiteSelected || pDO->QueryGetData(&g_rgFETC[iAnsiFETC]) != NOERROR)
        {
            hr = S_FALSE;
            goto Cleanup;
        }
    }

    {
        hr = THR(CTextXBag::GetDataObjectInfo(pDO, &dwFlags));
        if (hr)
            goto Cleanup;
    }

    if (dwFlags & DOI_CANPASTEPLAIN)
    {
        hr = S_OK;
    }
    else
    {
        hr = THR(super::ParseDragData(pDO));
    }

Cleanup:
    ReleaseInterface( pSegmentList );
    RRETURN1(hr, S_FALSE);
}



//+---------------------------------------------------------------------------
//
//  Member:     DrawDragFeedback
//
//  Synopsis:
//
//----------------------------------------------------------------------------

void
CFlowLayout::DrawDragFeedback(BOOL fCaretVisible)
{
    Assert(_pDropTargetSelInfo);

    _pDropTargetSelInfo->DrawDragFeedback(fCaretVisible);
}

//+------------------------------------------------------------------------
//
//  Member:     InitDragInfo
//
//  Synopsis:   Setup a struct to enable drawing of the drag feedback
//
//  Arguments:  pDO         The data object
//              ptlScreen   Screen loc of obj.
//
//  Notes:      This assumes that the DO has been parsed and
//              any appropriate data on the form has been set.
//
//-------------------------------------------------------------------------

HRESULT
CFlowLayout::InitDragInfo(IDataObject *pDO, POINTL ptlScreen)
{

    CPoint      pt;
    pt.x = ptlScreen.x;
    pt.y = ptlScreen.y;

    ScreenToClient( Doc()->_pInPlace->_hwnd, (CPoint*) & pt );


    //
    // We DON'T TRANSFORM THE POINT, AS MOVEPOINTERTOPOINT is in Global Coords
    //

    Assert(!_pDropTargetSelInfo);
    _pDropTargetSelInfo = new CDropTargetInfo( this, Doc(), pt );
    if (!_pDropTargetSelInfo)
        RRETURN(E_OUTOFMEMORY);


    return S_OK;

}

//+====================================================================================
//
// Method: DragOver
//
// Synopsis: Delegate to Layout::DragOver - unless we don't have a _pDropTargetSelInfo
//
//------------------------------------------------------------------------------------

HRESULT 
CFlowLayout::DragOver(DWORD grfKeyState, POINTL pt, DWORD * pdwEffect)
{
    // Can be null if dragenter was handled by script
    if (!_pDropTargetSelInfo || (!g_fInAccess9 && _pDropTargetSelInfo->IsAtInitialHitPoint(pt)))
    {
        //  Bug 100514: We want to update the caret position to follow the drag only
        //  if the caret is hidden.  The caret could be hidden if we are dragging over
        //  an invalid drop point.

        if (!_pDropTargetSelInfo)
        {
            CDoc        *pDoc = Doc();
            
            if (!pDoc->IsCaretVisible())
            {
                //  Ok, caret is hidden.  We want to update its position.
                IGNORE_HR( pDoc->UpdateCaretPosition(this, pt) );
            }
        }

        *pdwEffect = DROPEFFECT_NONE ;
        return S_OK;
    }
    
    return super::DragOver( grfKeyState, pt, pdwEffect );
}

//+---------------------------------------------------------------------------
//
//  Member:     UpdateDragFeedback
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT
CFlowLayout::UpdateDragFeedback(POINTL ptlScreen)
{
    CSelDragDropSrcInfo *pDragInfo = NULL;
    CDoc* pDoc = Doc();
    CPoint      pt;

    // Can be null if dragenter was handled by script
    if (!_pDropTargetSelInfo)
        return S_OK;

    pt.x = ptlScreen.x;
    pt.y = ptlScreen.y;

    ScreenToClient( pDoc->_pInPlace->_hwnd, (POINT*) & pt );

    //
    // We DON'T TRANSFORM THE POINT, AS MOVEPOINTERTOPOINT is in Global Coords
    //

    if ( ( pDoc->_fIsDragDropSrc )  &&
         ( pDoc->_pDragDropSrcInfo) &&
         ( pDoc->_pDragDropSrcInfo->_srcType == DRAGDROPSRCTYPE_SELECTION ) )
    {
        pDragInfo = DYNCAST( CSelDragDropSrcInfo, pDoc->_pDragDropSrcInfo );
    }
    _pDropTargetSelInfo->UpdateDragFeedback( this, pt, pDragInfo  );

    TraceTag((tagUpdateDragFeedback, "Update Drag Feedback: pt:%ld,%ld After Transform:%ld,%ld\n", ptlScreen.x, ptlScreen.y, pt.x, pt.y ));

    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     WaitForParentToRecalc
//
//  Synopsis:   Waits for a this site to finish recalcing upto cpMax/yMax.
//              If first waits for all txtsites above this to finish recalcing.
//
//  Params:     [cpMax]: The cp to calculate too
//              [yMax]:  The y position to calculate too
//              [pci]:   The CCalcInfo
//
//  Return:     HRESULT
//
//--------------------------------------------------------------------------
HRESULT
CFlowLayout::WaitForParentToRecalc(
    LONG cpMax,     //@parm Position recalc up to (-1 to ignore)
    LONG yMax,      //@parm ypos to recalc up to (-1 to ignore)
    CCalcInfo * pci)
{
    HRESULT hr = S_OK;

    Assert(!TestLock(CElement::ELEMENTLOCK_RECALC));

    if (!TestLock(CElement::ELEMENTLOCK_SIZING))
    {
#ifdef DEBUG
        // NOTE(sujalp): We should never recurse when we are not SIZING.
        // This code to catch the case in which we recurse when we are not
        // SIZING.
        CElement::CLock LockRecalc(ElementOwner(), CElement::ELEMENTLOCK_RECALC);
#endif
        ElementOwner()->SendNotification(NTYPE_ELEMENT_ENSURERECALC);
    }

    // ENSURERECALC notification could have caused us to recalc the line array,
    // thus changing the valid cp range.  Make sure we pass a valid cpMax to WFR().
    cpMax = min(cpMax, GetContentLastCp());

    if (!_dp.WaitForRecalc(cpMax, yMax, pci))
    {
        hr = S_FALSE;
        goto Cleanup;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+----------------------------------------------------------------------------
//
//  Member:     GetNextFlowLayout
//
//  Synopsis:   Get next text site in the specified direction from the
//              specified position
//
//  Arguments:  [iDir]       -  UP/DOWN/LEFT/RIGHT
//              [ptPosition] -  position in the current txt site
//              [pElementChild] -  The child element from where this call came
//              [pcp]        -  The cp in the found site where the caret
//                              should be placed.
//              [pfCaretNotAtBOL] - Is the caret at BOL?
//              [pfAtLogicalBOL] - Is the caret at the logical BOL?
//
//-----------------------------------------------------------------------------
CFlowLayout *
CFlowLayout::GetNextFlowLayout(NAVIGATE_DIRECTION iDir, POINT ptPosition, CElement *pElementLayout, LONG *pcp,
                               BOOL *pfCaretNotAtBOL, BOOL *pfAtLogicalBOL)
{
    CFlowLayout *pFlowLayout = NULL;   // Stores the new txtsite found in the given dirn.

    Assert(pcp);
    Assert(!pElementLayout || pElementLayout->GetUpdatedParentLayout() == this);

    if (pElementLayout == NULL)
    {
        CLayout *pParentLayout = GetUpdatedParentLayout();
        // By default ask our parent to get the next flowlayout.
        if (pParentLayout && pParentLayout->IsEditable())
        {
            pFlowLayout = pParentLayout->GetNextFlowLayout(iDir, ptPosition, ElementOwner(), pcp, pfCaretNotAtBOL, pfAtLogicalBOL);
        }
    }
    else
    {
        CTreePos *       ptpStart;  // extent of the element
        CTreePos *       ptpFinish;

        // Start off with the txtsite found as being this one
        pFlowLayout = this;
        *pcp = 0;

        // find the extent of the element passed in.
        pElementLayout->GetTreeExtent(&ptpStart, &ptpFinish);

        switch(iDir)
        {
        case NAVIGATE_UP:
        case NAVIGATE_DOWN:
            {
                CLinePtr rp(GetDisplay()); // The line in this site where the child lives
                POINT    pt;       // The point where the site resides.
                CElement  * pElement;
                BOOL     fVertical;

                pElement = ElementOwner();
                Assert( pElement );
                fVertical = pElement->HasVerticalLayoutFlow();

                // find the line where the given layout lives.
                if (_dp.RenderedPointFromTp(ptpStart->GetCp(), ptpStart, FALSE, pt, &rp, TA_TOP, NULL, NULL) < 0)
                    goto Cleanup;

                // Now navigate from this line ... either up/down
                pFlowLayout = _dp.MoveLineUpOrDown(iDir, fVertical, rp, ptPosition, pcp, pfCaretNotAtBOL, pfAtLogicalBOL);
                break;
            }
        case NAVIGATE_LEFT:
            // position ptpStart just before the child layout
            ptpStart = ptpStart->PreviousTreePos();

            if(ptpStart)
            {
                // Now let's get the txt site that's interesting to us
                pFlowLayout = ptpStart->GetBranch()->GetFlowLayout();

                // and the cp...
                *pcp = ptpStart->GetCp();
            }
            break;

        case NAVIGATE_RIGHT:
            // Position the ptpFinish just after the child layout.
            ptpFinish = ptpFinish->PreviousTreePos();

            if(ptpFinish)
            {
                // Now let's get the txt site that's interesting to us
                pFlowLayout = ptpFinish->GetBranch()->GetFlowLayout();

                // and the cp...
                *pcp = ptpFinish->GetCp();
                break;
            }
        }
    }

Cleanup:
    return pFlowLayout;
}

//+--------------------------------------------------------------------------
//
//  Member : GetChildElementTopLeft
//
//  Synopsis : CSite virtual override, the job of this function is to
//      do the actual work in reporting the top left posisiton of elements
//      that is it resposible for.
//              This is primarily used as a helper function for CElement's::
//      GetElementTopLeft.
//
//----------------------------------------------------------------------------
HRESULT
CFlowLayout::GetChildElementTopLeft(POINT & pt, CElement * pChild)
{
    Assert(pChild && !pChild->ShouldHaveLayout());

    // handle a couple special cases. we won't hit
    // these when coming in from the OM, but if this fx is
    // used internally, we might. so here they are
    switch ( pChild->Tag())
    {
    case ETAG_MAP :
        {
            pt.x = pt.y = 0;
        }
        break;

    case ETAG_AREA :
        {
            RECT rectBound;
            DYNCAST(CAreaElement, pChild)->GetBoundingRect(&rectBound);
            pt.x = rectBound.left;
            pt.y = rectBound.top;
        }
        break;

    default:
        {
            CTreePos  * ptpStart;
            CTreePos  * ptpEnd;
            LONG        cpStart;
            LONG        cpStop;
            CElement  * pElement = ElementOwner();
            ELEMENT_TAG etag = pElement->Tag();
            BOOL        fVertical = pElement->HasVerticalLayoutFlow();
            
            pt.x = pt.y = -1;

            // get the extent of this element
            pChild->GetTreeExtent(&ptpStart, &ptpEnd);

            if (!ptpStart || !ptpEnd)
                goto Cleanup;

            cpStart = ptpStart->GetCp();
            cpStop = ptpEnd->GetCp();

            {
                CStackDataAry<RECT, 1> aryRects(Mt(CFlowLayoutGetChildElementTopLeft_aryRects_pv));

                _dp.RegionFromElement(pChild, &aryRects, NULL, NULL,
                                      RFE_ELEMENT_RECT | RFE_INCLUDE_BORDERS | RFE_NO_EXTENT,
                                      cpStart, cpStop);

                if(aryRects.Size())
                {
                    if (!fVertical)
                    {
                        pt.x = aryRects[0].left;
                        pt.y = aryRects[0].top;
                    }
                    else
                    {
                        LONG iLast = aryRects.Size() - 1;
                        pt.y = aryRects[iLast].left;
                        pt.x = _dp.GetHeight() - aryRects[iLast].bottom;
                    }
                }
            }

            // if we are for a table cell, then we need to adjust for the cell insets,
            // in case the content is vertically aligned.
            if ( (etag == ETAG_TD) || (etag == ETAG_TH) || (etag == ETAG_CAPTION) )
            {
                CDispNode * pDispNode = GetElementDispNode();
                if (pDispNode && pDispNode->HasInset())
                {
                    CSize sizeInset = pDispNode->GetInset();
                    if (fVertical)
                    {
                        sizeInset.Flip();
                    }
                    pt.x += sizeInset.cx;
                    pt.y += sizeInset.cy;
                }
            }

        }
        break;
    }

Cleanup:
    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member:     GetPositionInFlowLayout
//
//  Synopsis:   For this flowlayout, find the correct position for the cp to be in
//              within this flowlayout. It may so happen that the ideal position
//              may be within a flowlayout within this one -- handle those cases too.
//
//  Arguments:  [iDir]       -  UP/DOWN/LEFT/RIGHT
//              [ptPosition] -  position in the current txt site
//              [pcp]        -  The cp in the found site where the caret
//                              should be placed.
//              [pfCaretNotAtBOL]: Is the caret at BOL?
//              [pfAtLogicalBOL] : Is the caret at logical BOL?
//
//-----------------------------------------------------------------------------
CFlowLayout *
CFlowLayout::GetPositionInFlowLayout(NAVIGATE_DIRECTION iDir, POINT ptPosition, LONG *pcp,
                                     BOOL *pfCaretNotAtBOL, BOOL *pfAtLogicalBOL)
{
    CFlowLayout  *pFlowLayout = this; // The txtsite we found ... by default us

    Assert(pcp);

    switch(iDir)
    {
    case NAVIGATE_UP:
    case NAVIGATE_DOWN:
    {
        CPoint   ptGlobal(ptPosition);  // The desired position of the caret
        CPoint   ptContent;
        CLinePtr rp(GetDisplay());         // The line in which the point ptPosition is
        CRect    rcClient;         // Rect used to get the client rect

        // Be sure that the point is within this site's client rect
        RestrictPointToClientRect(&ptGlobal);
        ptContent = ptGlobal;
        TransformPoint(&ptContent, COORDSYS_GLOBAL, COORDSYS_FLOWCONTENT);

        // Construct a point within this site's client rect (based on
        // the direction we are traversing.
        GetClientRect(&rcClient);
        rcClient.MoveTo(ptContent);

        // Find the line within this txt site where we want to be placed.
        rp = _dp.LineFromPos(rcClient,
                             (CDisplay::LFP_ZORDERSEARCH   |
                              CDisplay::LFP_IGNOREALIGNED  |
                              CDisplay::LFP_IGNORERELATIVE |
                              (iDir == NAVIGATE_UP
                                ? CDisplay::LFP_INTERSECTBOTTOM
                                : 0)));

        if (rp < 0)
        {
            *pcp = 0;
        }
        else
        {
            // Found the line ... let's navigate to it.
            pFlowLayout = _dp.NavigateToLine(iDir, rp, ptGlobal, pcp, pfCaretNotAtBOL, pfAtLogicalBOL);
        }
        break;
    }

    case NAVIGATE_LEFT:
    {
        // We have come to this site while going left in a site outside this site.
        // So position ourselves just after the last valid character.
        *pcp = GetContentLastCp() - 1;
#ifdef DEBUG
        {
            CRchTxtPtr rtp(GetPed());
            rtp.SetCp(*pcp);
            Assert(WCH_TXTSITEEND == rtp._rpTX.GetChar());
        }
#endif
        break;
    }

    case NAVIGATE_RIGHT:
        // We have come to this site while going right in a site outside this site.
        // So position ourselves just before the first character.
        *pcp = GetContentFirstCp();
#ifdef DEBUG
        {
            CRchTxtPtr rtp(GetPed());
            rtp.SetCp(*pcp);
            Assert(IsTxtSiteBreak(rtp._rpTX.GetPrevChar()));
        }
#endif
        break;
    }

    return pFlowLayout;
}


//+---------------------------------------------------------------------------
//
//  Member:     HandleSetCursor
//
//  Synopsis:   Helper for handling set cursor
//
//  Arguments:  [pMessage]  -- message
//              [fIsOverEmptyRegion -- is it over the empty region around text?
//
//  Returns:    Returns S_OK if keystroke processed, S_FALSE if not.
//
//----------------------------------------------------------------------------

HRESULT
CFlowLayout::HandleSetCursor(CMessage * pMessage, BOOL fIsOverEmptyRegion)
{
    HRESULT     hr              = S_OK;
    LPCTSTR     idcNew          = IDC_ARROW;
    RECT        rc;
    POINT       pt              = pMessage->pt;
    CElement*   pElement        = pMessage->pNodeHit->Element();
    BOOL        fMasterEditable =  pElement->IsMasterParentEditable();
    BOOL        fEditable       = IsEditable() || fMasterEditable ;
    BOOL        fUseSlaveCursor = FALSE;
    CElement*   pSiteSelectThis = NULL;
    
    CDoc* pDoc = Doc();
    BOOL fParentEditable = FALSE;
    
    Assert(pElement);
    //Assert( ! pDoc->_fDisableReaderMode );

    if (pDoc->_fDisableReaderMode)
    {
        return S_OK;
    }
    
    if ( CHECK_EDIT_BIT( pElement->GetMarkup(), _fOverrideCursor ))
    {
        return S_OK; // we don't touch the cursor - up to the host.        
    }

    // If the cursor is over slave content AND the master's cursor is not inherited,
    // then use the default cursor.
    if (    pElement != ElementOwner()
        &&  ElementOwner()->HasSlavePtr()
       )
    {
        CDefaults * pDefaults = ElementOwner()->GetDefaults();
        
        if(   pMessage->pNodeHit->IsConnectedToThisMarkup(ElementOwner()->GetSlavePtr()->GetMarkup())
           && pDefaults 
           && !pDefaults->GetAAviewInheritStyle()
          )
        {
            fUseSlaveCursor = TRUE;
        }
    }

    // TODO (MohanB) A hack to fix IE5 #60103; should be cleaned up in IE6.
    // MUSTFIX: We should set the default cursor (I-Beam for text, Arrow for the rest) only
    // after the message bubbles through all elements upto the root. This allows elements
    // (like anchor) which like to set non-default cursors over their content to do so.

    if (    !fEditable
        &&  !fUseSlaveCursor
        &&  ElementOwner()->TagType() == ETAG_GENERIC
       )
    {
        return S_FALSE;
    }


    fParentEditable = pElement->IsParentEditable(); 
    
    BOOL fOverEditableElement = ( fEditable &&
                                  pElement->_etag != ETAG_ROOT && 
                                  ( fParentEditable || fMasterEditable ) && 
                                  ( pDoc->_pElemCurrent && pDoc->_pElemCurrent->_etag != ETAG_ROOT ) && 
                                  ( pDoc->IsElementSiteSelectable( pElement ) ||
                                       ( pElement->IsTablePart( ) &&   // this is for mouse over borders of site-selected table-cells
                                         pDoc->IsPointInSelection( pt , pElement->GetFirstBranch() ) && 
                                         pDoc->GetSelectionType() == SELECTION_TYPE_Control )));

    if ( ! fOverEditableElement )
        GetClientRect(&rc);

    Assert(pMessage->IsContentPointValid());
    if ( fOverEditableElement || PtInRect(&rc, pMessage->ptContent) )
    {
        if (fIsOverEmptyRegion && ! fOverEditableElement )
        {
            idcNew = IDC_ARROW;
        }
        else
        {
            if (pMessage->htc == HTC_BEHAVIOR)
            {
                if ( pMessage->lBehaviorCookie )
                {                    
                    CPeerHolder *pPH = pElement->FindPeerHolder(pMessage->lBehaviorCookie);

                    if (pPH)
                    {
                        hr = pPH->SetCursor(pMessage->lBehaviorPartID);
                        goto Cleanup; // cursor is set. so we bail
                    }                        
                }
                else
                {
                    idcNew = IDC_ARROW;
                }    
            }
            else if ( fEditable  &&
                 ( pMessage->htc >= HTC_TOPBORDER || pMessage->htc == HTC_EDGE ) )
            {
                idcNew = pDoc->GetCursorForHTC( pMessage->htc );
            }        
            else if (! pDoc->IsPointInSelection( pt, pElement->GetFirstBranch()  ) )
            {
                // If CDoc is a HTML dialog, do not show IBeam cursor.

                if ( fEditable
                    || !( pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_DIALOG)
                    ||   _fAllowSelectionInDialog
                    )
                {
                    //
                    // Adjust for Slave to make currency checkwork
                    //
                    if (pElement->HasMasterPtr())
                    {
                        pElement = pElement->GetMasterPtr();
                        if (pElement->GetUpdatedParentLayoutNode())
                        {
                            fParentEditable = pElement->GetUpdatedParentLayoutNode()->IsEditable();
                        }
                    }

                    // 
                    if (  (fParentEditable || fMasterEditable ) && 
                          pDoc->IsElementSiteSelectable( pElement , & pSiteSelectThis ) &&
                          (pSiteSelectThis->IsParentEditable() || fMasterEditable) &&
                          ( pElement->GetMarkup() != pDoc->_pElemCurrent->GetMarkup() || 
                            pElement != pDoc->_pElemCurrent          // retain the old cursor as long as currency not changed
                          )
                       )                       
                    {
                        idcNew = IDC_SIZEALL;
                    } 
                    else
                        idcNew = IDC_IBEAM;                
                }                    
            }  
            else if ( pDoc->GetSelectionType() == SELECTION_TYPE_Control )
            {
                //
                // We are in a selection. But the Adorners didn't set the HTC_CODE.
                // Set the caret to the size all - to indicate they can click down and drag.
                //
                // This is a little ambiguous - they can click in and UI activate to type
                // but they can also start a move we decided on the below.
                //
                idcNew = IDC_SIZEALL;  
            }
        }
    }
    
    
#ifdef NEVER    // GetSelectionBarWidth returns 0
    else if (GetSelectionBarWidth() && PointInSelectionBar(pt))
    {
        // The selection bar is a vertical trench on the left side of the text
        // object that allows one to select multiple lines by swiping the trench
        idcNew = MAKEINTRESOURCE(IDC_SELBAR);
    }
#endif

    if (fUseSlaveCursor)
    {
        SetCursorIDC(idcNew);
        hr = S_OK;
    }
    else
    {
        ElementOwner()->SetCursorStyle(idcNew);
    }
Cleanup:
    RRETURN1(hr, S_FALSE);
}



void
CFlowLayout::ResetMinMax()
{
    _fMinMaxValid      = FALSE;
    _dp._fMinMaxCalced = FALSE;
    MarkHasAlignedLayouts(FALSE);
}


LONG
CFlowLayout::GetMaxLineWidth()
{
    CDisplay *pdp = GetDisplay();
    return pdp->GetViewWidth() - pdp->GetCaret();
}

//+----------------------------------------------------------------------------
//
// member: ReaderModeScroll
//
//-----------------------------------------------------------------------------
void
ReaderModeScroll(CLayout * pScrollLayout, int dx, int dy)
{
    CRect   rc;
    long    cxWidth;
    long    cyHeight;

    // this is a callback from commctl32 so it is possible that the layout
    // is hanging off a passivated element and there is no dispnode (e.g.
    // navigation has happened)
    // (greglett) If this is so, since layouts aren't refcounted, could pScrollLayout be bad?
    if (   !pScrollLayout->GetElementDispNode()
        || !pScrollLayout->GetElementDispNode()->IsScroller())
        return;

    pScrollLayout->GetElementDispNode()->GetClientRect(&rc, CLIENTRECT_CONTENT);

    cxWidth  = rc.Width();
    cyHeight = rc.Height();

    //
    // Sleep() call is required for keeping another world alive.
    // See ..shell\comctl32\.. reader.c for DoReadMode message pumping loop
    // and raid bug 19537 IEv60 (mikhaill 12/17/00).
    //

    int sleepTime = 10;

    //
    //  Scroll slowly if moving in a single dimension
    //

    if (    !dx
        ||  !dy)
    {
        if (abs(dx) == 1 || abs(dy) == 1)
        {
            sleepTime = 100;
        }
        else if (abs(dx) == 2 || abs(dy) == 2)
        {
            sleepTime = 50;
        }
    }

    Sleep(sleepTime);

    //
    //  Calculate the scroll delta
    //  (Use a larger amount if the incoming delta is large)
    //

    if (abs(dx) > 10)
    {
        dx = (dx > 0
                ? cxWidth / 2
                : -1 * (cxWidth / 2));
    }
    else if (abs(dx) > 8)
    {
        dx = (dx > 0
                ? cxWidth / 4
                : -1 * (cxWidth / 4));
    }
    else
    {
        dx = dx * 2;
    }

    if (abs(dy) > 10)
    {
        dy = (dy > 0
                ? cyHeight / 2
                : -1 * (cyHeight / 2));
    }
    else if (abs(dy) > 8)
    {
        dy = (dy > 0
                ? cyHeight / 4
                : -1 * (cyHeight / 4));
    }
    else
    {
        dy = dy * 2;
    }

    //
    //  Scroll the content
    //

    pScrollLayout->ScrollBy(CSize(dx, dy));

    CDoc *  pDoc = pScrollLayout->Doc();

    if(pDoc && pDoc ->InPlace() && pDoc ->InPlace()->_hwnd)
        ::UpdateWindow(pDoc->InPlace()->_hwnd);
}

//+----------------------------------------------------------------------------
//
// _ReaderMode_OriginWndProc
// _ReaderMode_Scroll
// _ReaderMode_TranslateDispatch
//
// Reader Mode Auto-Scroll helper routines, paste from classic MSHTML code
// These are callback functions for DoReaderMode.
//
//-----------------------------------------------------------------------------
LRESULT CALLBACK
_ReaderMode_OriginWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    HDC         hdc, hdcCompat;
    HBITMAP     hbmp = NULL;
    PAINTSTRUCT ps;

    switch (msg)
    {
    case WM_PAINT:
    case WM_ERASEBKGND:
        hdc = BeginPaint(hwnd, &ps);

        if ((hbmp = (HBITMAP)GetWindowLongPtr(hwnd, 0)) != NULL &&
                (hdcCompat = CreateCompatibleDC(hdc)) != NULL)
        {
            BITMAP   bmp;
            HBITMAP  hbmpOld;
            HBRUSH   hbrushOld;
            HPEN     hpenOld, hpen;
            COLORREF crColor;

            GetObject(hbmp, sizeof(BITMAP), &bmp);
            crColor   = RGB(0, 0, 0);
            hpen      = CreatePen(PS_SOLID, 2, crColor);
            if (hpen)
            {
                hpenOld   = (HPEN) SelectObject(hdc, hpen);
                hbmpOld   = (HBITMAP) SelectObject(hdcCompat, hbmp);
                hbrushOld = (HBRUSH) SelectObject(hdc, GetStockObject(NULL_BRUSH));

                BitBlt(hdc, 0, 0, bmp.bmWidth, bmp.bmHeight, hdcCompat, 0, 0, SRCCOPY);
                Ellipse(hdc, 0, 0, bmp.bmWidth + 1, bmp.bmHeight + 1);

                SelectObject(hdcCompat, hbmpOld);
                SelectObject(hdc, hbrushOld);
                SelectObject(hdc, hpenOld);
                DeleteObject(hpen);
            }
            DeleteObject(hdcCompat);
        }
        EndPaint(hwnd, &ps);
        break;

    default:
        return (DefWindowProc(hwnd, msg, wParam, lParam));
        break;
    }


    return 0;
}

#ifndef WIN16

// (dmitryt) Because of check for LayoutPtr, not LayoutAry, this scrolling 
// mechanism will not work in layout rects (print preview).
// We don't know at the moment how to correctly scroll things with several layouts anyway.

BOOL CALLBACK
_ReaderMode_Scroll(PREADERMODEINFO prmi, int dx, int dy)
{
    CElement *pElement = (CElement *) prmi->lParam;

    if(    !pElement 
        || !pElement->HasLayoutPtr() 
        || !pElement->IsInMarkup()
        || !pElement->IsScrollingParent()
      )
        return FALSE;

    ReaderModeScroll(pElement->GetLayoutPtr(), dx, dy);
    return TRUE;
}

BOOL CALLBACK
_ReaderMode_TranslateDispatch(LPMSG lpmsg)
{
    BOOL   fResult = FALSE;
    LPRECT lprc;

    if (lpmsg->message == WM_MBUTTONUP)
    {
        // If the button up click comes within the "neutral zone" rectangle
        // around the point where the button went down then we want
        // continue reader mode so swallow the message by returning
        // TRUE.  Otherwise, let the message go through so that we cancel
        // out of panning mode.
        //
        if ((lprc = (LPRECT)GetProp(lpmsg->hwnd, TEXT("ReaderMode"))) != NULL)
        {
            POINT ptMouse = {LOWORD(lpmsg->lParam), HIWORD(lpmsg->lParam)};
            if (PtInRect(lprc, ptMouse))
            {
                fResult = TRUE;
            }
        }
    }
    return fResult;
}
#endif //ndef WIN16


//+----------------------------------------------------------------------------
//
// member: ExecReaderMode
//
// Execure ReaderMode auto scroll. Use DoReaderMode in COMCTL32.DLL
//
//-----------------------------------------------------------------------------
void
ExecReaderMode(CElement *pScrollElement, CMessage * pMessage, BOOL fByMouse)
{
#ifndef WIN16
    POINT       pt;
    RECT        rc;
    HWND        hwndInPlace = NULL;
    HBITMAP     hbmp = NULL;
    BITMAP      bmp;
    HINSTANCE   hinst;

    if(    !pScrollElement 
        || !pScrollElement->HasLayoutPtr() 
        || !pScrollElement->IsInMarkup()
        || !pScrollElement->IsScrollingParent()
      )
        return;

    CLayout   *pScrollLayout = pScrollElement->GetLayoutPtr();
    CDoc      *pDoc          = pScrollLayout->Doc();
    CDispNode *pDispNode     = pScrollLayout->GetElementDispNode();

    BOOL        fOptSmoothScroll = pDoc->_pOptionSettings->fSmoothScrolling;

    Assert(pDispNode);
    Assert(pDispNode->IsScroller());

    CSize           size;
    const CSize &   sizeContent = DYNCAST(CDispScroller, pDispNode)->GetContentSize();
    BOOL            fEnableVScroll;
    BOOL            fEnableHScroll;

    size = pDispNode->GetSize();

    fEnableVScroll = (size.cy < sizeContent.cy);
    fEnableHScroll = (size.cx < sizeContent.cx);

    READERMODEINFO rmi =
    {
        sizeof(rmi),
        NULL,
        0,
        &rc,
        _ReaderMode_Scroll,
        _ReaderMode_TranslateDispatch,
        (LPARAM) pScrollElement
    };

    // force smooth scrolling
    //
    pDoc->_pOptionSettings->fSmoothScrolling = TRUE;

    if (!pDoc->InPlace() || !pDoc->InPlace()->_hwnd)
    {
        // not InPlace Activated yet, unable to do auto-scroll reader mode.
        //
        goto Cleanup;
    }

    rmi.hwnd = hwndInPlace = pDoc->InPlace()->_hwnd;

    hinst = (HINSTANCE) GetModuleHandleA("comctl32.dll");
    Assert(hinst && "GetModuleHandleA(COMCTL32) returns NULL");
    if (hinst)
    {
        if (fEnableVScroll && fEnableHScroll)
        {
            hbmp = LoadBitmap(hinst, MAKEINTRESOURCE(IDB_2DSCROLL));
        }
        else if (fEnableVScroll || fEnableHScroll)
        {
            rmi.fFlags |= (fEnableVScroll)
                            ? (RMF_VERTICALONLY) : (RMF_HORIZONTALONLY);
            hbmp = LoadBitmap(
                    hinst,
                    MAKEINTRESOURCE( (fEnableVScroll)
                                     ? (IDB_VSCROLL) : (IDB_HSCROLL)));
        }
    }
    if (!hbmp)
    {
        // 1) no scroll bars are enabled, no need for auto-scroll reader mode.
        // 2) LoadBitmap fails, unable to do auto-scroll reader mode.
        //
        goto Cleanup;
    }

    if (fByMouse)
    {
        pt.x = LOWORD(pMessage->lParam);
        pt.y = HIWORD(pMessage->lParam);
        SetRect(&rc, pt.x, pt.y, pt.x, pt.y);
    }
    else
    {
        GetWindowRect(hwndInPlace, &rc);
        MapWindowPoints(NULL, hwndInPlace, (LPPOINT) &rc, 2);
        SetRect(&rc, rc.left + rc.right / 2, rc.top  + rc.bottom / 2,
                     rc.left + rc.right / 2, rc.top  + rc.bottom / 2);
        rmi.fFlags |= RMF_ZEROCURSOR;
    }

    // Make the "neutral zone" be the size of the origin bitmap window.
    //
    GetObject(hbmp, sizeof(BITMAP), &bmp);
    InflateRect(&rc, bmp.bmWidth / 2, bmp.bmHeight / 2);

    SetProp(hwndInPlace, TEXT("ReaderMode"), (HANDLE)&rc);

    {
#define ORIGIN_CLASS TEXT("MSHTML40_Origin_Class")

        HWND     hwndT, hwndOrigin;
        WNDCLASS wc;
        HRGN     hrgn;

        hwndT = GetParent(hwndInPlace);

        if (!(::GetClassInfo(GetResourceHInst(), ORIGIN_CLASS, &wc)))
        {
            wc.style         = CS_SAVEBITS;
            wc.lpfnWndProc   = _ReaderMode_OriginWndProc;
            wc.cbClsExtra    = 0;
            wc.cbWndExtra    = sizeof(LONG_PTR);
            wc.hInstance     = GetResourceHInst(),
            wc.hIcon         = NULL;
            wc.hCursor       = NULL;
            wc.lpszMenuName  = NULL;
            wc.hbrBackground = NULL;
            wc.lpszClassName = ORIGIN_CLASS;
            RegisterClass(&wc);
        }
        MapWindowPoints(hwndInPlace, hwndT, (LPPOINT)&rc, 2);
        hwndOrigin = CreateWindowEx(
                0,
                ORIGIN_CLASS,
                NULL,
                WS_CHILD | WS_CLIPSIBLINGS,
                rc.left,
                rc.top,
                rc.right - rc.left,
                rc.bottom - rc.top,
                hwndT,
                NULL,
                wc.hInstance,
                NULL);
        if (hwndOrigin)
        {
            // Shove the bitmap into the first window long so that it can
            // be used for painting the origin bitmap in the window.
            //
            SetWindowLongPtr(hwndOrigin, 0, (LONG_PTR)hbmp);
            hrgn = CreateEllipticRgn(0, 0, bmp.bmWidth + 1, bmp.bmHeight + 1);
            SetWindowRgn(hwndOrigin, hrgn, FALSE);

            MapWindowPoints(hwndT, hwndInPlace, (LPPOINT)&rc, 2);

            SetWindowPos(
                    hwndOrigin,
                    HWND_TOP,
                    0,
                    0,
                    0,
                    0,
                    SWP_NOACTIVATE | SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW);
            UpdateWindow(hwndOrigin);

            DoReaderMode(&rmi);

            DestroyWindow(hwndOrigin);
        }

        DeleteObject(hbmp);

        // USER owns the hrgn, it will clean it up
        //
        // DeleteObject(hrgn);
    }
    RemoveProp(hwndInPlace, TEXT("ReaderMode"));

Cleanup:
    pDoc->_pOptionSettings->fSmoothScrolling = !!fOptSmoothScroll;
#endif // ndef WIN16
    return;
}

#ifndef WIN16
//
// helper function: determine how many lines to scroll per mouse wheel
//
LONG
WheelScrollLines()
{
    LONG uScrollLines = 3; // reasonable default

    if ((g_dwPlatformID == VER_PLATFORM_WIN32_WINDOWS)
            || (g_dwPlatformID == VER_PLATFORM_WIN32_NT
                            && g_dwPlatformVersion < 0x00040000))
    {
        HKEY hKey;
        if (RegOpenKeyEx(HKEY_CURRENT_USER, _T("Control Panel\\Desktop"),
                0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
        {
            TCHAR szData[128];
            DWORD dwKeyDataType;
            DWORD dwDataBufSize = ARRAY_SIZE(szData);

            if (RegQueryValueEx(hKey, _T("WheelScrollLines"), NULL,
                        &dwKeyDataType, (LPBYTE) &szData, &dwDataBufSize)
                    == ERROR_SUCCESS)
            {
                uScrollLines = _tcstoul(szData, NULL, 10);
            }
            RegCloseKey(hKey);
        }
    }
    else if (g_dwPlatformID == VER_PLATFORM_WIN32_NT &&
                 g_dwPlatformVersion >= 0x00040000)
    {
        ::SystemParametersInfo(
                   SPI_GETWHEELSCROLLLINES,
                   0,
                   &uScrollLines,
                   0);
    }

    return uScrollLines;
}

HRESULT
HandleMouseWheel(CLayout * pScrollLayout, CMessage * pMessage)
{
    // WM_MOUSEWHEEL       - line scroll mode
    // CTRL+WM_MOUSEWHEEL  - increase/decrease baseline font size.
    // SHIFT+WM_MOUSEWHEEL - navigate backward/forward
    //
    HRESULT hr          = S_FALSE;
    BOOL    fControl    = (pMessage->dwKeyState & FCONTROL)
                        ? (TRUE) : (FALSE);
    BOOL    fShift      = (pMessage->dwKeyState & FSHIFT)
                        ? (TRUE) : (FALSE);
    BOOL    fEditable   = pScrollLayout->IsEditable(TRUE);
    short   zDelta;
    short   zDeltaStep;
    short   zDeltaCount;

    const static LONG idmZoom[] = { IDM_BASELINEFONT1,
                                    IDM_BASELINEFONT2,
                                    IDM_BASELINEFONT3,
                                    IDM_BASELINEFONT4,
                                    IDM_BASELINEFONT5,
                                    0 };
    short       iZoom;
    MSOCMD      msocmd;

    CDispNode   *pDispNode = pScrollLayout->GetElementDispNode();
    if (!pDispNode || !pDispNode->IsScroller())
        goto Cleanup;

    if (!fControl && !fShift)
    {
        // Do not scroll if vscroll is disallowed. This prevents content of
        // frames with scrolling=no does not get scrolled (IE5 #31515).
        CDispNodeInfo   dni;
        pScrollLayout->GetDispNodeInfo(&dni);
        if (!dni.IsVScrollbarAllowed())
            goto Cleanup;

        // mousewheel scrolling, allow partial circle scrolling.
        //
        zDelta = (short) HIWORD(pMessage->wParam);

        if (zDelta != 0)
        {
            long uScrollLines = WheelScrollLines();
            LONG yPercent = (uScrollLines >= 0)
                          ? ((-zDelta * PERCENT_PER_LINE * uScrollLines) / WHEEL_DELTA)
                          : ((-zDelta * PERCENT_PER_PAGE * abs(uScrollLines)) / WHEEL_DELTA);

            if (pScrollLayout->ScrollByPercent(0, yPercent, MAX_SCROLLTIME))
            {
                hr = S_OK;
            }
        }
    }
    else
    {
        CDoc *  pDoc = pScrollLayout->Doc();

        // navigate back/forward or zoomin/zoomout, should wait until full
        // wheel circle is accumulated.
        //
        zDelta = ((short) HIWORD(pMessage->wParam)) + pDoc->_iWheelDeltaRemainder;
        zDeltaStep = (zDelta < 0) ? (-1) : (1);
        zDeltaCount = zDelta / WHEEL_DELTA;
        pDoc->_iWheelDeltaRemainder  = zDelta - zDeltaCount * WHEEL_DELTA;

        for (; zDeltaCount != 0; zDeltaCount = zDeltaCount - zDeltaStep)
        {
            if (fShift)
            {
                hr = pDoc->Exec(
                        (GUID *) &CGID_MSHTML,
                        (zDelta > 0) ? (IDM_GOFORWARD) : (IDM_GOBACKWARD),
                        0,
                        NULL,
                        NULL);
                if (hr)
                    goto Cleanup;
            }
            else // fControl
            {
                if (!fEditable)
                {
                    // get current baseline font size
                    //
                    for (iZoom = 0; idmZoom[iZoom]; iZoom ++)
                    {
                        msocmd.cmdID = idmZoom[iZoom];
                        msocmd.cmdf  = 0;
                        hr = THR(pDoc->QueryStatusHelper(
                                pScrollLayout->ElementOwner()->Document(),
                                (GUID *) &CGID_MSHTML,
                                1,
                                &msocmd,
                                NULL));
                        if (hr)
                            goto Cleanup;

                        if (msocmd.cmdf == MSOCMDSTATE_DOWN)
                            break;
                    }

                    Assert(idmZoom[iZoom] != 0);
                    if (!idmZoom[iZoom])
                    {
                        hr = E_FAIL;
                        goto Cleanup;
                    }

                    iZoom -= zDeltaStep;

                    if (iZoom >= 0 && idmZoom[iZoom])
                    {
                        // set new baseline font size
                        //
                        hr = THR(pDoc->Exec(
                                (GUID *) &CGID_MSHTML,
                                idmZoom[iZoom],
                                0,
                                NULL,
                                NULL));
                        if (hr)
                            goto Cleanup;
                    }
                }
            }
        }
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}
#endif // ndef WIN16

HRESULT BUGCALL
CFlowLayout::HandleMessage(
    CMessage * pMessage)
{
    HRESULT    hr    = S_FALSE;
    CDoc     * pDoc  = Doc();

    // TODO (13569 - actLayout): This must go into TLS!! (brendand)
    //
    static BOOL     g_fAfterDoubleClick = FALSE;

    BOOL        fLbuttonDown;
    BOOL        fInBrowseMode = !IsEditable();
    CDispNode * pDispNode     = GetElementDispNode();
    BOOL        fIsScroller   = (pDispNode && pDispNode->IsScroller());

    //
    //  Prepare the message for this layout
    //

    PrepareMessage(pMessage);

    // First, forward mouse messages to the scrollbars (if any)
    // (Keyboard messages are handled below and then notify the scrollbar)
    //
    if (    fIsScroller
        &&  (   pMessage->htc == HTC_VSCROLLBAR || pMessage->htc == HTC_HSCROLLBAR )
        &&  (   pMessage->pNodeHit->Element() == ElementOwner() )
        &&  (   (  pMessage->message >= WM_MOUSEFIRST
#ifndef WIN16
                &&  pMessage->message != WM_MOUSEWHEEL
#endif
                &&  pMessage->message <= WM_MOUSELAST)
            ||  pMessage->message == WM_SETCURSOR
            ||  pMessage->message == WM_CONTEXTMENU))
    {
        hr = HandleScrollbarMessage(pMessage, ElementOwner());
        if (hr != S_FALSE)
            goto Cleanup;
    }

    //
    //  In Edit mode, if no element was hit, resolve to the closest element
    //

    if (    !fInBrowseMode
        &&  !pMessage->pNodeHit
        &&  (   (   pMessage->message >= WM_MOUSEFIRST
                &&  pMessage->message <= WM_MOUSELAST)
            ||  pMessage->message == WM_SETCURSOR
            ||  pMessage->message == WM_CONTEXTMENU)
       )
    {
        CTreeNode * pNode;
        HTC         htc;

        pMessage->resultsHitTest._fWantArrow = FALSE;
        pMessage->resultsHitTest._fRightOfCp = FALSE;

        htc = BranchFromPoint(HT_DONTIGNOREBEFOREAFTER,
                            pMessage->ptContent,
                            &pNode,
                            &pMessage->resultsHitTest);

        if (HTC_YES == htc && pNode)
        {
            HRESULT hr2 = THR( pMessage->SetNodeHit(pNode) );
            if( hr2 )
            {
                hr = hr2;
                goto Cleanup;
            }
        }
    }

    switch(pMessage->message)
    {
    case WM_LBUTTONDBLCLK:
    case WM_RBUTTONDBLCLK:
        g_fAfterDoubleClick = TRUE;
        hr = HandleButtonDblClk(pMessage);
        break;

    case WM_MBUTTONDOWN:
#ifdef UNIX
        if (!fInBrowseMode && pMessage->pNodeHit->IsEditable())
        {
            // Perform a middle button paste
            VARIANTARG varTextHandle;
            V_VT(&varTextHandle) = VT_EMPTY;
            g_uxQuickCopyBuffer.GetTextSelection(NULL, FALSE, &varTextHandle);
            
            if (V_VT(&varTextHandle) == VT_EMPTY )
            {
                hr = S_OK; // NO data
            }
            else
            {
                //Convert to V_BSTR
                HGLOBAL hUnicode = TextHGlobalAtoW(V_BYREF(&varTextHandle));
                TCHAR *pszText = (LPTSTR)GlobalLock(hUnicode);
                if (pszText)
                {
                    VARIANTARG varBSTR;
                    TCHAR* pT = pszText;
                    
                    while (*pT) // Filter reserved chars
                    {
                        if (!IsValidWideChar(*pT))
                            *pT = _T('?');
                        pT++;
                    }
                    V_VT(&varBSTR) = VT_BSTR;
                    V_BSTR(&varBSTR) = SysAllocString(pszText);
                    hr = THR(pDoc->Exec((GUID*)&CGID_MSHTML, IDM_PASTE, IDM_PASTESPECIAL, &varBSTR, NULL));
                    SysFreeString(V_BSTR(&varBSTR));
                }
                GlobalUnlock(hUnicode);
                GlobalFree(hUnicode);
            }
            goto Cleanup;
        }
#endif

        if (
                pDispNode
            &&  pDispNode->IsScroller()
            &&  !Doc()->_fDisableReaderMode
            )
        {
            CDispNodeInfo   dni;
            GetDispNodeInfo(&dni);

            if (dni.IsVScrollbarAllowed())
            {
                //ExecReaderMode runs message pump, so element can be destroyed
                //during it. AddRef helps.
                CElement * pElement = ElementOwner();
                pElement->AddRef();
                ExecReaderMode(pElement, pMessage, TRUE);
                pElement->Release();
            }
            hr = S_OK;
        }
        break;

#ifdef UNIX
    case WM_GETTEXTPRIMARY:
        hr = S_OK;

        // Give Mainwin the data currently selected so it can
        // provide it to X for a middle button paste.
       
        // Or, give MSHTML a chance to update selected data, this comes from
        // Trident DoSelection done.
        if (pMessage->lParam == IDM_CLEARSELECTION) 
        {
            CMessage theMessage;
            SelectionMessageToCMessage((SelectionMessage *)pMessage->wParam, &theMessage);
            {
                CDoc *pSelDoc = theMessage.pNodeHit->Element()->Doc(); 
                g_uxQuickCopyBuffer.NewTextSelection(pSelDoc); 
            }
            goto Cleanup;
        }
        
        // Retrieve Text to caller.
        {
            // Check to see if we're selecting a password, in which case
            // don't copy it.
            // 
            CElement *pEmOld = pDoc->_pElemCurrent;
            if (pEmOld && pEmOld->Tag() == ETAG_INPUT &&
                (DYNCAST(CInput, pEmOld))->GetType() == htmlInputPassword)
            {
                *(HANDLE *)pMessage->lParam = (HANDLE) NULL;
                goto Cleanup;
            }

            VARIANTARG varTextHandle;
            V_VT(&varTextHandle) = VT_EMPTY;
            
            hr = pDoc->Exec((GUID*)&CGID_MSHTML, IDM_COPY, 0, NULL, &varTextHandle);
            if (hr == S_OK && V_ISBYREF(&varTextHandle))
            {
                *(HANDLE *)pMessage->lParam = (HANDLE)V_BYREF(&varTextHandle);
            }
            else
            {
                *(HANDLE *)pMessage->lParam = (HANDLE) NULL;
                hr = E_FAIL;
            }
        }
        break;

    case WM_UNDOPRIMARYSELECTION:
        // Under Motif only one app can have a selection active
        // at a time. Clear selection here.
        {
            //  NOTE - This is not really a legal operation (and therefore is 
            //   no longer supported).  In order to clear selection, we must 
            //  communicate with the editor.  See marka or johnthim for details.
            //
            //  CMarkup *pMarkup = pDoc->GetCurrentMarkup();
            //  if (pMarkup) // Clear selection 
            //      pMarkup->ClearSegments(TRUE);
            g_uxQuickCopyBuffer.ClearSelection();
        }
        break;
#endif

    case WM_MOUSEMOVE:
        fLbuttonDown = !!(GetKeyState(VK_LBUTTON) & 0x8000);

        if (fLbuttonDown && pDoc->_state >= OS_INPLACE)
        {
            // if we came in with a lbutton down (lbuttonDown = TRUE) and now
            // it is up, it might be that we lost the mouse up event due to a
            // DoDragDrop loop. In this case we have to UI activate ourselves
            //
            if (!(GetKeyState(VK_LBUTTON) & 0x8000))
            {
                hr = THR(ElementOwner()->BecomeUIActive());
                if (hr)
                    goto Cleanup;
            }
        }
        break;
#ifndef WIN16
    case WM_MOUSEWHEEL:
        hr = THR(HandleMouseWheel(this, pMessage));
        break;
#endif // ndef WIN16
    case WM_CONTEXTMENU:
    {
        ISegmentList            *pSegmentList = NULL;
        ISelectionServices      *pSelSvc = NULL;
        ISegmentListIterator    *pIter = NULL;     
        HRESULT                 hrSuccess = S_OK;
        
        hrSuccess = Doc()->GetSelectionServices(&pSelSvc);
        if( !hrSuccess )
            hrSuccess = pSelSvc->QueryInterface(IID_ISegmentList, (void **)&pSegmentList );
        if( !hrSuccess )
            hrSuccess = pSegmentList->CreateIterator( &pIter );

        if( FAILED(hrSuccess ) )            
        {
            AssertSz(FALSE, "Cannot get segment list");
            hr = S_OK;
        }
        else
        {
            switch(pDoc->GetSelectionType())
            {               
                case SELECTION_TYPE_Control:
                    // Pass on the message to the first element that is selected
                    {
                        ISegment        *pISegment = NULL;
                        IElementSegment *pIElemSegment = NULL;               
                        IHTMLElement    *pIElemSelected  = NULL;
                        CElement        *pElemSelected   = NULL;

                        // Get the current segment (the first one) and retrieve its
                        // associated element
                        if( S_OK == pIter->Current(&pISegment)                                              &&
                            S_OK == pISegment->QueryInterface(IID_IElementSegment, (void **)&pIElemSegment) &&
                            S_OK == pIElemSegment->GetElement(&pIElemSelected)                              &&
                            S_OK == pIElemSelected->QueryInterface( CLSID_CElement, (void**)&pElemSelected) )
                        {
                            // if the site-selected element is different from the owner, pass the message to it
                            Assert(pElemSelected);
                            if (pElemSelected != ElementOwner())
                            {
                                // Call HandleMessage directly because we do not bubbling here
                                hr = pElemSelected->HandleMessage(pMessage);
                            }
                        }
                        else
                        {
                            AssertSz(FALSE, "Cannot get selected element");                            
                            hr = S_OK;
                        }

                        ReleaseInterface(pISegment);
                        ReleaseInterface(pIElemSegment);
                        ReleaseInterface(pIElemSelected);
                    }
                    break;

                case SELECTION_TYPE_Text:
                    // Display special menu for text selection in browse mode
                    // (dmitryt) Elements that have "contentEditable" default to 
                    // CONTEXT_MENU_CONTROL. We just bail out of here and super::HandleMessage() 
                    // will do the right thing.
                    if (!IsEditable())  
                    {
                        int cx, cy;

                        cx = (short)LOWORD(pMessage->lParam);
                        cy = (short)HIWORD(pMessage->lParam);

                        if (cx == -1 && cy == -1) // SHIFT+F10
                        {
                            ISegment       *    pISegment   = NULL;
                            IMarkupPointer *    pIStart     = NULL;
                            IMarkupPointer *    pIEnd       = NULL;
                            CMarkupPointer *    pStart      = NULL;
                            CMarkupPointer *    pEnd        = NULL;

                            // Retrieve the selection segment
                            if( pIter->Current(&pISegment) == S_OK )
                            {
                                // Compute position at whcih to display the menu
                                if (    S_OK == pDoc->CreateMarkupPointer(&pStart)
                                    &&  S_OK == pDoc->CreateMarkupPointer(&pEnd)
                                    &&  S_OK == pStart->QueryInterface(IID_IMarkupPointer, (void**)&pIStart)
                                    &&  S_OK == pEnd->QueryInterface(IID_IMarkupPointer, (void**)&pIEnd)
                                    &&  S_OK == pISegment->GetPointers(pIStart, pIEnd) )
                                {
                                    CMarkupPointer * pmpSelMin;
                                    POINT            ptSelMin;

                                    ReleaseInterface(pIStart);
                                    ReleaseInterface(pIEnd);
                                    
                                    if (OldCompare( pStart, pEnd ) > 0)
                                        pmpSelMin = pEnd;
                                    else
                                        pmpSelMin = pStart;

                                    if (_dp.PointFromTp(
                                            pmpSelMin->GetCp(), NULL, FALSE, FALSE, ptSelMin, NULL, TA_BASELINE) != -1)
                                    {
                                        RECT rcWin;

                                        GetWindowRect(pDoc->InPlace()->_hwnd, &rcWin);
                                        cx = ptSelMin.x - GetXScroll() + rcWin.left - CX_CONTEXTMENUOFFSET;
                                        cy = ptSelMin.y - GetYScroll() + rcWin.top  - CY_CONTEXTMENUOFFSET;
                                    }
                                    
                                    ReleaseInterface(pStart);
                                    ReleaseInterface(pEnd);
                                }
                            }

                            ReleaseInterface(pISegment);
                        }
                        hr = THR(ElementOwner()->OnContextMenu(cx, cy, CONTEXT_MENU_TEXTSELECT));
                    }
                    break;

            } // Switch
        }
        
        ReleaseInterface(pSelSvc);
        ReleaseInterface(pIter);
        ReleaseInterface(pSegmentList);
    }
    break;
    

    case WM_SETCURSOR:
        // Are we over empty region?
        //
        hr = THR(HandleSetCursor(
                pMessage,
                pMessage->resultsHitTest._fWantArrow
                              && fInBrowseMode));
        break;

    case WM_SYSKEYDOWN:
        hr = THR(HandleSysKeyDown(pMessage));
        break;
    }

    // Remember to call super
    if (hr == S_FALSE)
    {
        hr = super::HandleMessage(pMessage);
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


ExternTag(tagPaginate);

class CStackPageBreaks
{
public:
    DECLARE_MEMCLEAR_NEW_DELETE(Mt(CStackPageBreaks))
    CStackPageBreaks();

    HRESULT Insert(long yPosTop, long yPosBottom, long xWidthSplit);
    long GetSplit();

    CStackPtrAry<LONG_PTR, 20> _aryYPos;
    CStackPtrAry<LONG_PTR, 20> _aryXWidthSplit;
};


CStackPageBreaks::CStackPageBreaks() : _aryYPos(Mt(CStackPageBreaks_aryYPos_pv)),
                                       _aryXWidthSplit(Mt(CStackPageBreaks_aryXWidthSplit_pv))
{
}

HRESULT
CStackPageBreaks::Insert(long yPosTop, long yPosBottom, long xWidthSplit)
{
    int     iStart = 0, iEnd = 0, cRanges = _aryYPos.Size() - 1, iCount, iSize;

    HRESULT hr = S_OK;

    Assert(yPosTop <= yPosBottom);
    Assert(xWidthSplit >= 0);


    // 0. Insert first range.
    if (!_aryYPos.Size())
    {
        hr = _aryYPos.Insert(0, yPosTop);
        if (hr)
            goto Cleanup;

        hr = _aryYPos.Insert(1, yPosBottom);
        if (hr)
            goto Cleanup;

        hr = _aryXWidthSplit.Insert(0, xWidthSplit);

        // Done.
        goto Cleanup;
    }

    // 1. Find beginning of range.
    while (iStart < cRanges && yPosTop > (LONG)_aryYPos[iStart])
        iStart++;

    // If necessary, beginning creates new range.
    if (yPosTop < (LONG)_aryYPos[iStart])
    {
        hr = _aryYPos.Insert(iStart, yPosTop);
        if (hr)
            goto Cleanup;

        hr = _aryXWidthSplit.Insert(iStart, (LONG)_aryXWidthSplit[iStart-1]);
        if (hr)
            goto Cleanup;

        cRanges++;
    }

    // 2. Find end of range.
    iEnd = iStart;

    while (iEnd < cRanges && yPosBottom > (LONG)_aryYPos[iEnd+1])
        iEnd++;

    // If necessary, end creates new range.
    if (iEnd < cRanges && yPosBottom < (LONG)_aryYPos[iEnd+1])
    {
        hr = _aryYPos.Insert(iEnd+1, yPosBottom);
        if (hr)
            goto Cleanup;

        hr = _aryXWidthSplit.Insert(iEnd+1, (LONG)_aryXWidthSplit[iEnd]);
        if (hr)
            goto Cleanup;

        cRanges++;
    }

    // 3. Increment the ranges covered.
    iSize = _aryXWidthSplit.Size(); // protecting from overflowing the split array
    for (iCount = iStart ; iCount <= iEnd && iCount < iSize ; iCount++)
    {
        _aryXWidthSplit[iCount] += xWidthSplit;
    }

#if DBG == 1
    if (IsTagEnabled(tagPaginate))
    {
        TraceTag((tagPaginate, "Dumping page break ranges:"));
        for (int iCount = 0; iCount < _aryXWidthSplit.Size(); iCount++)
        {
            TraceTag((tagPaginate, "%d - %d : %d", iCount, (LONG)_aryYPos[iCount], (LONG)_aryXWidthSplit[iCount]));
        }
    }
#endif

Cleanup:

    RRETURN(hr);
}


long
CStackPageBreaks::GetSplit()
{
    if (!_aryYPos.Size())
    {
        Assert(!"Empty array");
        return 0;
    }

    int iPosMin = _aryXWidthSplit.Size()-1, iCount;
    long xWidthSplitMin = (LONG)_aryXWidthSplit[iPosMin];

    for (iCount = iPosMin-1 ; iCount > 0 ; iCount--)
    {
        if ((LONG)_aryXWidthSplit[iCount] < xWidthSplitMin)
        {
            xWidthSplitMin = (LONG)_aryXWidthSplit[iCount];
            iPosMin = iCount;
        }
    }

    return (LONG)_aryYPos[iPosMin+1]-1;
}


//+---------------------------------------------------------------------------
//
//  Member:     AppendNewPage
//
//  Synopsis:   Adds a new page to the print doc.  Called by Paginate.  This
//              is a helper function used to reuse code and clean up paginate.
//
//  Arguments:  paryPP               Page array to add to
//              pPP                  New page
//              pPPHeaderFooter      Header footer buffer page
//              yHeader              Height of header to be repeated
//              yFooter              Height of footer
//              yFullPageHeight      Height of a full (new) page
//              xMaxPageWidthSofar   Width of broken line (max sofar)
//              pyTotalPrinted       Height of content paginated sofar
//              pySpaceLeftOnPage    Height of y-space left on page
//              pyPageHeight         Height of page
//              pfRejectFirstFooter  Should the first repeated footer be rejected
//
//----------------------------------------------------------------------------

HRESULT AppendNewPage(CDataAry<CPrintPage> * paryPP,
                      CPrintPage * pPP,
                      CPrintPage * pPPHeaderFooter,
                      long yHeader,
                      long yFooter,
                      long yFullPageHeight,
                      long xMaxPageWidthSofar,
                      long * pyTotalPrinted,
                      long * pySpaceLeftOnPage,
                      long * pyPageHeight,
                      BOOL * pfRejectFirstFooter)
{
    HRESULT hr = S_OK;

    Assert(pfRejectFirstFooter && paryPP && pPP &&
           pPPHeaderFooter && pyTotalPrinted && pySpaceLeftOnPage && pyPageHeight);

    TraceTag((tagPaginate, "Appending block of size %d", pPP->yPageHeight));

    if (yFooter)
    {
        pPP->fReprintTableFooter = !(*pfRejectFirstFooter);
        pPP->pTableFooter = pPPHeaderFooter->pTableFooter;
        pPP->rcTableFooter = pPPHeaderFooter->rcTableFooter;
        *pfRejectFirstFooter = FALSE;
    }

    hr = THR(paryPP->AppendIndirect(pPP));
    if (hr)
        goto Cleanup;

    *pyTotalPrinted += pPP->yPageHeight;
    pPP->yPageHeight = 0;
    pPP->xPageWidth = xMaxPageWidthSofar;
    *pySpaceLeftOnPage = *pyPageHeight = yFullPageHeight - yHeader - yFooter;
    pPP->fReprintTableFooter = FALSE;

    if (yHeader)
    {
        pPP->fReprintTableHeader = TRUE;
        pPP->pTableHeader = pPPHeaderFooter->pTableHeader;
        pPP->rcTableHeader = pPPHeaderFooter->rcTableHeader;
    }

Cleanup:

    RRETURN(hr);
}




#if DBG == 1
BOOL
CFlowLayout::IsInPlace()
{
    // lie if in a printdoc.
    return Doc()->IsPrintDialogNoUI() || Doc()->_state >= OS_INPLACE;
}
#endif

HRESULT
CFlowLayout::HandleButtonDblClk(CMessage *pMessage)
{
    // Repaint window to show any exposed portions
    //
    ViewChange(Doc()->_state >= OS_INPLACE ? TRUE : FALSE);
    return S_OK;
}

WORD ConvVKey(WORD vKey);
void TestMarkupServices(CElement *pElement);
void TestSelectionRenderServices( CMarkup* pMarkup, CElement* pTestElement);
void DumpFormatCaches();

HRESULT
CFlowLayout::HandleSysKeyDown(CMessage *pMessage)
{
    HRESULT    hr    = S_FALSE;

#if DBG == 1
    CMarkup * pMarkup   = GetContentMarkup();
#endif

    // NOTE: (anandra) Most of these should be handled as commands
    // not keydowns.  Use ::TranslateAccelerator to perform translation.
    //

    if(pMessage->wParam == VK_BACK && (pMessage->lParam & SYS_ALTERNATE))
    {
        Sound();
        hr = S_OK;
    }
#if DBG == 1
    else if ((pMessage->wParam == VK_F4) && !(pMessage->dwKeyState & MK_ALT)
            && !(pMessage->lParam & SYS_PREVKEYSTATE))
    {
#ifdef MERGEFUN // iRuns
         CTreePosList & eruns = GetList();
         LONG iStart, iEnd, iDelta, i;
         CElement * pElement;

        if (GetKeyState(VK_SHIFT) & 0x8000)
        {
            iStart = 0;
            iEnd = eruns.Count() - 1;
            iDelta = +1;
        }
        else
        {
            iStart = eruns.Count() - 1;
            iEnd = 0;
            iDelta = -1;
        }

        pElement = NULL;
        for (i=iStart; i != iEnd; i += iDelta)
        {
            if (eruns.GetRunAbs(i).Cch())
            {
                pElement = eruns.GetRunAbs(i).Branch()->ElementOwner();
                break;
            }
        }
        if (pElement)
        {
            SCROLLPIN sp = (iDelta > 0) ? SP_TOPLEFT : SP_BOTTOMRIGHT;
            hr = ScrollElementIntoView( pElement, sp, sp );
        }
        else
        {
            hr = S_OK;
        }
#endif
    }
    else if (   pMessage->wParam == VK_F9
             && !(pMessage->lParam & SYS_PREVKEYSTATE))
    {
        Doc()->DumpLayoutRects();
        hr = S_OK;
    }
    // Used by the TestSelectionRenderServices test
    else if (   pMessage->wParam == VK_F10
             && !(pMessage->lParam & SYS_PREVKEYSTATE))
    {
        if (GetKeyState(VK_SHIFT) & 0x8000)
            // Used by the TestSelectionRenderServices
            TestSelectionRenderServices(pMarkup, ElementOwner());
        hr = S_OK;
    }
    else if (   pMessage->wParam == VK_F11
             && !(pMessage->lParam & SYS_PREVKEYSTATE))
    {
        if (GetKeyState(VK_SHIFT) & 0x8000)
            TestMarkupServices(ElementOwner());
        else
            pMarkup->DumpTree();
        hr = S_OK;
    }
    else if (   pMessage->wParam == VK_F12
             && !(pMessage->lParam & SYS_PREVKEYSTATE))
    {
        if (GetKeyState(VK_SHIFT) & 0x8000)
            TestMarkupServices(ElementOwner());
        else
            DumpLines();
        hr = S_OK;
    }

    else if (   pMessage->wParam == VK_F9
             && !(pMessage->lParam & SYS_PREVKEYSTATE))
    {
        extern int g_CFTotalCalls;
        extern int g_CFAttemptedSteals;
        extern int g_CFSuccessfulSteals;

        if (InitDumpFile())
        {
            WriteHelp(g_f, _T("\r\nTotal: <0d> - "), (long)g_CFTotalCalls);
            WriteHelp(g_f, _T("\r\nAttempts to steal: <0d> - "), (long)g_CFAttemptedSteals);
            WriteHelp(g_f, _T("\r\nSuccess: <0d> - "), (long)g_CFSuccessfulSteals);
            CloseDumpFile();
        }

#ifdef MERGEFUN // iRuns
        CTreePosList & elementRuns = GetList();

        CNotification  nf;

        for (int i = 0; i < long(elementRuns.Count()); i++)
        {
            elementRuns.VoidCachedInfoOnBranch(elementRuns.GetBranchAbs(i));
        }
        pDoc->InvalidateTreeCache();

        nf.CharsResize(
                0,
                pMarkup->GetContentTextLength(),
                0,
                elementRuns.NumRuns(),
                GetFirstBranch());
        elementRuns.Notify(nf);
#endif
        hr = S_OK;
    }
    else if(   pMessage->wParam == VK_F8
            && !(pMessage->lParam & SYS_PREVKEYSTATE))
    {
        pMarkup->DumpClipboardText( );
    }
#endif

    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFlowLayout::HitTestContent
//
//  Synopsis:   Determine if the given display leaf node contains the hit point.
//
//  Arguments:  pptHit          hit test point
//              pDispNode       pointer to display node
//              pClientData     client-specified data value for hit testing pass
//
//  Returns:    TRUE if the display leaf node contains the point
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CFlowLayout::HitTestContent(
    const POINT *   pptHit,
    CDispNode *     pDispNode,
    void *          pClientData,
    BOOL            fDeclinedByPeer)
{
    Assert(pptHit);
    Assert(pDispNode);
    Assert(pClientData);

    CHitTestInfo *  phti            = (CHitTestInfo *)pClientData;
    CDispNode    *  pDispElement    = GetElementDispNode();
    HTC             htcLocal        = HTC_NO;

    BOOL            fHitTestContent = (   !pDispElement->IsContainer()
                                       || pDispElement != pDispNode
                                       || (phti->_grfFlags & HT_HTMLSCOPING));
    BOOL        fHackedHitForStrict = FALSE;
    
    // Skip nested markups if asked to do so
    if (phti->_grfFlags & HT_SKIPSITES)
    {
        CElement *pElement = ElementContent();
        if (   pElement
            && pElement->HasSlavePtr()
            && !SameScope(pElement, phti->_pNodeElement)
           )
        {
            phti->_htc = HTC_NO;
            goto Cleanup;
        }
    }
        
    if (fHitTestContent)
    {
        //
        //  If allowed, see if a child element is hit
        //  NOTE: Only check content when the hit display node is a content node
        //
        CTreeNode * pNodeHit = NULL;

        htcLocal = BranchFromPoint(phti->_grfFlags,
                                     *pptHit,
                                     &pNodeHit,
                                     phti->_phtr,
                                     TRUE,                  // ignore pseudo hit's
                                     pDispNode);

        // NOTE (donmarsh) - BranchFromPoint was written before the Display Tree
        // was introduced, so it might return a child element that already rejected
        // the hit when it was called directly from the Display Tree.  Therefore,
        // if BranchFromPoint returned an element that has its own layout, and if
        // that layout has its own display node, we reject the hit.
        //
        // But non-display tree callers (like moveToPoint) need this hit returned, since
        // they don't care about z-ordering or positioning.
        //
        // if the node hit is already registered in the hti, then we don't have to worry 
        // about this.
        if (    htcLocal == HTC_YES
            &&  pNodeHit != NULL
            && !phti->_phtr->_fGlyphHit
            &&  pNodeHit->Element() != ElementOwner()
            &&  pNodeHit->ShouldHaveLayout(LC_TO_FC(LayoutContext()))
            && !(phti->_grfFlags & HT_HTMLSCOPING)
            && pNodeHit != phti->_pNodeElement
            )
        {
            htcLocal = HTC_NO;
            pNodeHit = NULL;
        }

        // If we pseudo-hit a flow-layer dispnode that isn't the "bottom-most"
        // (i.e. "first") flow-layer dispnode for this element, then we pretend
        // we really didn't hit it.  This allows hit testing to "drill through"
        // multiple flow-layer dispnodes in order to support hitting through
        // non-text areas of display nodes generated by -ve margins.
        // Bug #
        else if (   htcLocal == HTC_YES 
                 && phti->_phtr->_fPseudoHit == TRUE
                 && pDispNode->IsFlowNode()
                 && !phti->_phtr->_fBulletHit
                )
        {
            if (pDispNode->GetPreviousFlowNode())
            {
                htcLocal = HTC_NO;
            }
        }

        if (   pNodeHit 
            && htcLocal != HTC_NO
           )
        {
            // At this point if we hit an element w/ layout, it better
            // be the the owner of this layout; otherwise the display
            // tree should have called us on the HitTestContent of that
            // layout!! 
            Assert(   phti->_phtr->_fGlyphHit
                   || (pNodeHit->Element()->ShouldHaveLayout(LC_TO_FC(LayoutContext())) ?
                       pNodeHit->Element() == ElementOwner() :
                       TRUE
                      )
                   || (phti->_grfFlags & HT_HTMLSCOPING)
                   || pNodeHit == phti->_pNodeElement
                  );

            //
            //  Save the point and CDispNode associated with the hit
            //
            phti->_pNodeElement = pNodeHit;
            phti->_htc = HTC_YES;
            SetHTILayoutContext( phti );
            phti->_ptContent    = *pptHit;
            phti->_pDispNode    = pDispNode;

            // keep hitttesting if htcLocal==NO. Note this is the opposite locic 
            // from the return below
            return (   pDispNode->HasBackground()
                    || htcLocal == HTC_YES);    
        }
        
        if (   htcLocal == HTC_NO
            && !pDispNode->HasBackground()
           )
        {
            Assert(fHitTestContent);
            CElement *pElement = ElementOwner();
            if (   ETAG_BODY == pElement->Tag()
                && pElement->GetMarkup()->IsStrictCSS1Document()
               )
            {
                fHackedHitForStrict = TRUE;
            }
        }

        if (   htcLocal == HTC_NO
            && pDispElement->IsContainer()
            && (phti->_grfFlags & HT_HTMLSCOPING)
            && pDispNode->HasBackground()
           )
        {
            fHitTestContent = FALSE;
        }
    }


    //
    // Do not call super if we are hit testing content and the current
    // element is a container. DisplayTree calls back with a HitTest
    // for the background after hittesting the -Z content.
    //
    if (   !fHitTestContent
        || fHackedHitForStrict
        || !pDispElement->IsContainer()
        || (   phti->_grfFlags & HT_HTMLSCOPING
            && phti->_pNodeElement == NULL
            && pDispElement == pDispNode))
    {
        //
        //  If no child and no peer was hit, use default handling
        //  Don't override hit info if something was already registered as the 
        //  psuedoHit element
        //
        HitTestContentWithOverride(pptHit, pDispNode, pClientData, FALSE, fDeclinedByPeer); 

        //
        // if there is a background set, we are opaque and should register
        // the hit as "hard", otherwise, cache the info but keep hittesting
        //

        return pDispNode->HasBackground() || fHackedHitForStrict;
    }
    
Cleanup:

    return (htcLocal != HTC_NO);
}


//+---------------------------------------------------------------------------
//
//  Member:     CFlowLayout::NotifyScrollEvent
//
//  Synopsis:   Respond to a change in the scroll position of the display node
//
//----------------------------------------------------------------------------

void
CFlowLayout::NotifyScrollEvent(
    RECT *  prcScroll,
    SIZE *  psizeScrollDelta)
{
    super::NotifyScrollEvent(prcScroll, psizeScrollDelta);
}


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     CFlowLayout::DumpDebugInfo
//
//  Synopsis:   Dump debugging information for the given display node.
//
//  Arguments:  hFile           file handle to dump into
//              level           recursive tree level
//              childNumber     number of this child within its parent
//              pDispNode       pointer to display node
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CFlowLayout::DumpDebugInfo(
        HANDLE hFile,
        long level,
        long childNumber,
        CDispNode const* pDispNode,
        void *cookie)
{
    if (pDispNode->IsOwned())
    {
        super::DumpDebugInfo(hFile, level, childNumber, pDispNode, cookie);
    }
    
    if (pDispNode->IsLeafNode())
    {
        CStr cstr;
        ElementOwner()->GetPlainTextInScope(&cstr);
        if (cstr.Length() > 0)
        {
            WriteString(hFile, _T("<content><![CDATA["));
            if (cstr.Length() > 50)
                cstr.SetLengthNoAlloc(50);
            WriteString(hFile, (LPTSTR) cstr);
            WriteString(hFile, _T("]]></content>\r\n"));
        }
    }
}
#endif

//+----------------------------------------------------------------------------
//
//  Member:     GetElementDispNode
//
//  Synopsis:   Return the display node for the pElement
//
//  Arguments:  pElement   - CElement whose display node is to obtained
//
//  Returns:    Pointer to the element CDispNode if one exists, NULL otherwise
//
//-----------------------------------------------------------------------------
CDispNode *
CFlowLayout::GetElementDispNode( CElement *  pElement ) const
{
    return (    !pElement
            ||  pElement == ElementOwner()
                    ? super::GetElementDispNode(pElement)
                    : pElement->IsRelative()
                        ? ((CFlowLayout *)this)->_dp.FindElementDispNode(pElement)
                        : NULL);
}

//+----------------------------------------------------------------------------
//
//  Member:     SetElementDispNode
//
//  Synopsis:   Set the display node for an element
//              NOTE: This is only supported for elements with layouts or
//                    those that are relatively positioned
//
//-----------------------------------------------------------------------------
void
CFlowLayout::SetElementDispNode( CElement *  pElement, CDispNode * pDispNode )
{
    if (    !pElement
        ||  pElement == ElementOwner())
    {
        super::SetElementDispNode(pElement, pDispNode);
    }
    else
    {
        Assert(pElement->IsRelative());
        Assert(!pElement->ShouldHaveLayout());
        _dp.SetElementDispNode(pElement, pDispNode);
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     CFlowLayout::GetContentSize
//
//  Synopsis:   Return the width/height of the content
//
//  Arguments:  psize - Pointer to CSize
//
//-----------------------------------------------------------------------------

void
CFlowLayout::GetContentSize(
    CSize * psize,
    BOOL    fActualSize)
{
    if (fActualSize)
    {
        psize->cx = _dp.GetWidth();
        psize->cy = _dp.GetHeight();
    }
    else
    {
        super::GetContentSize(psize, fActualSize);
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     CFlowLayout::GetContainerSize
//
//  Synopsis:   Return the width/height of the container
//
//  Arguments:  psize - Pointer to CSize
//
//-----------------------------------------------------------------------------

void
CFlowLayout::GetContainerSize(
    CSize * psize)
{
    psize->cx = _dp.GetViewWidth();
    psize->cy = _dp.GetHeight();
}


//+-------------------------------------------------------------------------
//
//  Method:     YieldCurrencyHelper
//
//  Synopsis:   Relinquish currency
//
//  Arguments:  pElemNew    New site that wants currency
//
//--------------------------------------------------------------------------
HRESULT
CFlowLayout::YieldCurrencyHelper(CElement * pElemNew)
{
    return S_OK;
}


//+-------------------------------------------------------------------------
//
//  Method:     BecomeCurrentHelper
//
//  Synopsis:   Force currency on the site.
//
//  Notes:      This is the method that external objects should call
//              to force sites to become current.
//
//--------------------------------------------------------------------------
HRESULT
CFlowLayout::BecomeCurrentHelper(long lSubDivision, BOOL *pfYieldFailed, CMessage * pMessage)
{
    BOOL    fOnSetFocus = ::GetFocus() == Doc()->_pInPlace->_hwnd;
    HRESULT hr          = S_OK;

    // Call OnSetFocus directly if the doc's window already had focus. We
    // don't need to do this if the window didn't have focus because when
    // we take focus in BecomeCurrent, the window message handler does this.
    //
    if (fOnSetFocus)
    {
        // if our inplace window did have the focus, then fire the onfocus
        // only if onblur was previously fired and the body is becoming the
        // current site and currency did not change in onchange or onpropchange
        //
        if (ElementOwner() == Doc()->_pElemCurrent && ElementOwner() == ElementOwner()->GetMarkup()->GetElementClient())
        {
            Doc()->GetCurrentWindow()->Post_onfocus();
        }
    }

    RRETURN1(hr, S_FALSE);
}

//+----------------------------------------------------------------------------
//
// Function: GetNestedElementCch
//
// Synopsis: Returns the number of characters that correspond to the element
//           under the current layout context
//
//-----------------------------------------------------------------------------
LONG
CFlowLayout::GetNestedElementCch(CElement  *pElement,       // IN:  The nested element
                                 CTreePos **pptpLast,       // OUT: The pos beyond pElement 
                                 LONG       cpLayoutLast,   // IN:  This layout's last cp
                                 CTreePos  *ptpLayoutLast)  // IN:  This layout's last pos
{
    CTreePos * ptpStart;
    CTreePos * ptpLast;
    long       cpElemStart;
    long       cpElemLast;

    if (cpLayoutLast == -1)
        cpLayoutLast = GetContentLastCp();
    Assert(cpLayoutLast == GetContentLastCp());
    if (ptpLayoutLast == NULL)
    {
        ElementContent()->GetTreeExtent(NULL, &ptpLayoutLast);
    }
#if DBG==1
    {
        CTreePos *ptpLastDbg;
        ElementContent()->GetTreeExtent(NULL, &ptpLastDbg);
        Assert(ptpLayoutLast == ptpLastDbg);
    }
#endif
    
    pElement->GetTreeExtent(&ptpStart, &ptpLast);

    Assert(ptpStart && ptpLast); //we should not layout elements that are not in the tree...

    cpElemStart = ptpStart->GetCp();
    cpElemLast  = ptpLast->GetCp();

    if(cpElemLast > cpLayoutLast)
    {
        if(pptpLast)
        {
            ptpLast = ptpLayoutLast->PreviousTreePos();
            while(!ptpLast->IsNode())
            {
                Assert(ptpLast->GetCch() == 0);
                ptpLast = ptpLast->PreviousTreePos();
            }
        }

        // for overlapping layout limit the range to
        // parent layout's scope.
        cpElemLast = cpLayoutLast - 1;
    }

    if(pptpLast)
        *pptpLast = ptpLast;

    return(cpElemLast - cpElemStart + 1);
}

void
CFlowLayout::ShowSelected( CTreePos* ptpStart, CTreePos* ptpEnd, BOOL fSelected,  BOOL fLayoutCompletelyEnclosed )
{
    Assert(ptpStart && ptpEnd && ptpStart->GetMarkup() == ptpStart->GetMarkup());
    CElement* pElement = ElementOwner();

    // If this has a slave, but the selection is in the main markup, then
    // select the element (as opposed to part or all of its content)
    if  ( pElement->HasSlavePtr()
           &&  ptpStart->GetMarkup() != ElementOwner()->GetSlavePtr()->GetMarkup() )
    {
        SetSelected( fSelected, TRUE );
    }
    else
    {
        if(
#ifdef  NEVER
           ( pElement->_etag == ETAG_HTMLAREA ) ||
#endif
           ( pElement->_etag == ETAG_BUTTON ) ||
           ( pElement->_etag == ETAG_TEXTAREA ) )
        {
            if (( fSelected && fLayoutCompletelyEnclosed ) ||
                ( !fSelected && ! fLayoutCompletelyEnclosed ) )
                SetSelected( fSelected, TRUE );
            else
            {
                                _dp.ShowSelected( ptpStart, ptpEnd, fSelected);
            }
        }
        else
                        _dp.ShowSelected( ptpStart, ptpEnd, fSelected);
    }      
}

//----------------------------------------------------------------------------
//  RegionFromElement
//
//  DESCRIPTION:
//      This is a virtual wrapper function to wrap the RegionFromElement that is
//      also implemented on the flow layout.
//      The RECT returned is in client coordinates.
//
//----------------------------------------------------------------------------

void
CFlowLayout::RegionFromElement( CElement       * pElement,
                                CDataAry<RECT> * paryRects,
                                RECT           * prcBound,
                                DWORD            dwFlags)
{
    Assert( pElement);
    Assert( paryRects );

    if ( !pElement || !paryRects )
        return;

    // Is the element passed the same element with the owner?
    if ( _pElementOwner == pElement )
    {
        // call CLayout implementation.
        super::RegionFromElement( pElement, paryRects, prcBound, dwFlags);
    }
    else
    {
        // Delegate the call to the CDisplay implementation
        _dp.RegionFromElement( pElement,          // the element
                               paryRects,         // rects returned here
                               NULL,              // offset the rects returned
                               NULL,              // ask RFE to get CFormDrawInfo
                               dwFlags,           // coord w/ respect to the client rc.
                               -1,                // Get the complete focus
                               -1,                //
                               prcBound);         // bounds of the element!
    }
}

//----------------------------------------------------------------------------
//  SizeDispNode
//
//  DESCRIPTION:
//      Size disp node, with adjustments specific to flow layout
//
//----------------------------------------------------------------------------

void
CFlowLayout::SizeDispNode(
    CCalcInfo *     pci,
    const SIZE &    size,
    BOOL            fInvalidateAll)
{
    
    super::SizeDispNode(pci, size, fInvalidateAll);
    
    if (IsRTLFlowLayout())
    {
        SizeRTLDispNode(_pDispNode, FALSE);
    }

    if (IsBodySizingForStrictCSS1Needed())
    {
        BodySizingForStrictCSS1Doc(_pDispNode);
    }
}

void
CFlowLayout::SizeContentDispNode(
    const SIZE &    size,
    BOOL            fInvalidateAll)
{
    BOOL fDoBodyWork = IsBodySizingForStrictCSS1Needed();
    
    if (!_dp._fHasMultipleTextNodes)
    {
        super::SizeContentDispNode(size, fInvalidateAll);

        if (IsRTLFlowLayout())
        {
            SizeRTLDispNode(GetFirstContentDispNode(), TRUE);
        }

        if (fDoBodyWork)
        {
            BodySizingForStrictCSS1Doc(GetFirstContentDispNode());
        }
    }
    else
    {
        CDispNode * pDispNode = GetFirstContentDispNode();

        // we better have a content dispnode
        Assert(pDispNode);

        for (; pDispNode; pDispNode = pDispNode->GetNextFlowNode())
        {
            CDispClient * pDispClient = this;

            if (pDispNode->GetDispClient() == pDispClient)
            {
                pDispNode->SetSize(CSize(size.cx, size.cy - (pDispNode->GetPosition()).y), NULL, fInvalidateAll);
                
                if (IsRTLFlowLayout())
                {
                    SizeRTLDispNode(pDispNode, TRUE);
                }
                if (fDoBodyWork)
                {
                    BodySizingForStrictCSS1Doc(GetFirstContentDispNode());
                }
            }
        }
    }
}

void
CFlowLayout::BodySizingForStrictCSS1Doc(CDispNode *pDispNode)
{
    CRect rc(CRect::CRECT_EMPTY);
    LONG leftV, rightV;

    GetExtraClipValues(&leftV, &rightV);
    rc.left = leftV;
    rc.right = rightV;
    pDispNode->SetExpandedClipRect(rc);
}

//----------------------------------------------------------------------------
//  SizeRTLDispNode
//
//  DESCRIPTION:
//      Store additional sizing information on RTL display node
//
//----------------------------------------------------------------------------
void
CFlowLayout::SizeRTLDispNode(CDispNode * pDispNode, BOOL fContent)
{
    // RTL layout may have a non-zero content origin caused by lines stretching to the left
    Assert(IsRTLFlowLayout());
    
    if(pDispNode && pDispNode->HasContentOrigin())
    {
        // set content origin to the difference between provisional layout width (cxView)
        // and actual layout width (cxLayout)
        int cxView = GetDisplay()->GetViewWidth();
        int cxLayout = GetDisplay()->GetWidth();
        int cxOffset = max(0, cxLayout - cxView);

        pDispNode->SetContentOrigin(CSize(0, 0), cxView);

        // Offset content disp nodes nodes to match container's origin offset
        if (fContent)
        {
            CPoint ptPosition(-cxOffset, 0);
            pDispNode->SetPosition(ptPosition);
        }
    }
    else
    {
        // If we have a disp node, it must have content origin allocated.
        // If it doesn't, it means that GetDispNodeInfo() is buggy
        AssertSz(!pDispNode, "No content origin on an RTL flow node ???");
    }
}


HRESULT
CFlowLayout::MovePointerToPointInternal(
    CElement *          pElemEditContext,
    POINT               tContentPoint,
    CTreeNode *         pNode,
    CLayoutContext *    pLayoutContext,     // layout context corresponding to pNode
    CMarkupPointer *    pPointer,
    BOOL *              pfNotAtBOL,
    BOOL *              pfAtLogicalBOL,
    BOOL *              pfRightOfCp,
    BOOL                fScrollIntoView,
    CLayout*            pContainingLayout ,
    BOOL*               pfValidLayout,
    BOOL                fHitTestEndOfLine,
    BOOL*               pfHitGlyph,
    CDispNode*          pDispNode
)
{
    HRESULT         hr = S_OK;
    LONG            cp = 0;
    BOOL            fNotAtBOL;
    BOOL            fAtLogicalBOL;
    BOOL            fRightOfCp;
    CMarkup *       pMarkup = NULL;
    BOOL            fPtNotAtBOL = FALSE;
    CPoint          ptHit(tContentPoint);
    CPoint          ptGlobal;

#if DBG == 1
    CElement* pDbgElement = pNode->Element();
    ELEMENT_TAG eDbgTag = pDbgElement->_etag;    
    TraceTag((tagViewServicesShowEtag, "MovePointerToPointInternal. _etag:%d", eDbgTag));
#endif

    {
        CDisplay * pdp = GetDisplay();
        CLinePtr rp( pdp );
        CLayout *pLayoutOriginal = pNode->GetUpdatedLayout( pLayoutContext );
        LONG cchPreChars = 0;

        //
        // NOTE: (johnbed) this is a completely arbitrary hack, but I have to
        // improvise since I don't know what line I'm on
        //
        fPtNotAtBOL = ptHit.x > 15;   

        if (pLayoutOriginal && this != pLayoutOriginal)
        {
            //
            // NOTE - right now - hit testing over the TR or Table is broken
            // we simply fail this situation. Selection then effectively ignores this point
            //
            if ( pLayoutOriginal->ElementOwner()->_etag == ETAG_TABLE ||
                   pLayoutOriginal->ElementOwner()->_etag == ETAG_TR )
            {
                hr = CTL_E_INVALIDLINE;
                goto Cleanup;
            }
        }

        pdp->WaitForRecalc(-1, ptHit.y );

        ptGlobal = ptHit;
        TransformPoint(&ptGlobal, COORDSYS_FLOWCONTENT, COORDSYS_GLOBAL, pDispNode);

        // NOTE (dmitryt) Passed rp is based on current CDisplay. CpFromPointReally can
        // get cp from some other markup (viewslaved for example) and use this found cp
        // to set cp of passed rp. this may be incorrect.

        cp = pdp->CpFromPointReally(    ptGlobal,       // Point
                                        &rp,            // Line Pointer
                                        &pMarkup,    // if not-NULL returned, use this markup for cp
                                        fHitTestEndOfLine ? CDisplay::CFP_ALLOWEOL : 0 ,
                                        &fRightOfCp,
                                        &cchPreChars,
                                        pfHitGlyph);
        if (cp == -1)
            goto Error;

        if(!pMarkup) 
            pMarkup = pNode->GetMarkup();

        if(!pMarkup)
            goto Error;

        TraceTag(( tagViewServicesCpHit, "ViewServices: cpFromPoint:%d\n", cp));

        // Note: (dmitryt) this forces cp back inside of ElementOwner...
        // This is all wrong, because we could easily be moved into a markup of a view slave,
        // with cp pointing into view slave and "this" flow layout and its elementOwner have 
        // nothing to do with it. Also, rp is set wrong in viewlinking case.
        // This function, because it can go across markups, should not
        // be on CFlowLayout. 
        // I commented this code during IE5.5 because it should not happen.
        // But it still happen in some weird situations so I'm adding Check().
        // We should be able to call "CFlowLayout::HitTestContent() from
        // here, or better yet, remove CFlowLayout::MovePointerToPointInternal totally because
        // it can be replaced at the point of call with CFlowLayout::HitTestContent()/MoveToCp pair.

        CheckSz(   cp >= 1 
                && cp < pMarkup->Cch(),
                "Please let Dmitry know ASAP if you see this assert firing! (dmitryt, x69876)");

        // (dmitryt, IE6) now I'm openeing this hack again because we hit this sometimes in stress.
        // It never happens in a debug code, some timing is involved. For now I reopen this and
        // hope someone will eventually be given time to implement a correct hittesting...
        
        if(pMarkup == GetContentMarkup())
        {
            LONG cpMin = GetContentFirstCp();
            LONG cpMax = GetContentLastCp();

            if( cp < cpMin )
            {
                cp = cpMin;
                rp.RpSetCp( cp , fPtNotAtBOL);
            }
            else if ( cp > cpMax )
            {
                cp = cpMax;
                rp.RpSetCp( cp , fPtNotAtBOL);
            }
        }

        fNotAtBOL = rp.RpGetIch() != 0;     // Caret OK at BOL if click
        fAtLogicalBOL = rp.RpGetIch() <= cchPreChars;
    }
    
    //
    // If we are positioned on a line that contains no text, 
    // then we should be at the beginning of that line
    //

    // TODO - Implement this in today's world

    //
    // Prepare results
    //
    
    if( pfNotAtBOL )
        *pfNotAtBOL = fNotAtBOL;

    if ( pfAtLogicalBOL )
        *pfAtLogicalBOL = fAtLogicalBOL;
    
    if( pfRightOfCp )
        *pfRightOfCp = fRightOfCp;

    hr = pPointer->MoveToCp( cp, pMarkup );
    if( hr )
        goto Error;
        
#if DBG == 1 // Debug Only

    //
    // Test that the pointer is in a valid position
    //
    
    {
        CTreeNode * pTst = pPointer->CurrentScope(MPTR_SHOWSLAVE);
        
        if( pTst )
        {
            if(  pTst->Element()->Tag() == ETAG_ROOT )
                TraceTag( ( tagViewServicesErrors, " MovePointerToPointInternal --- Root element "));
        }
        else
        {
            TraceTag( ( tagViewServicesErrors, " MovePointerToPointInternal --- current scope is null "));
        }
    }
#endif // DBG == 1 

    //
    // Scroll this point into view
    //
    
    if( fScrollIntoView && OK( hr ) )
    {

        //
        // TODO (Bug 13568 - ashrafm) - take the FlowLayout off of the ElemEditContext.
        //


        if ( pElemEditContext && pElemEditContext->GetFirstBranch() )
        {
            // $$ktam: Need layout context for pElemEditContext; where can we get it?
            CFlowLayout* pScrollLayout = NULL;        
            if ( pElemEditContext->HasMasterPtr() )
            {
                pScrollLayout = pElemEditContext->GetMasterPtr()->GetFlowLayout();
            }
            else
                pScrollLayout = pElemEditContext->GetFlowLayout();
                
            Assert( pScrollLayout );
            if ( pScrollLayout )
            {   
                if ( pScrollLayout != this )
                {
                    TransformPoint(&ptHit, COORDSYS_FLOWCONTENT, COORDSYS_GLOBAL);
                    pScrollLayout->TransformPoint(&ptHit, COORDSYS_GLOBAL, COORDSYS_FLOWCONTENT);
                }
                     
                {
                    //
                    // TODO (Bug 13568 - ashrafm): This scrolls the point into view - rather than the pointer we found
                    // unfotunately - scroll range into view is very jerky.
                    //
                    CRect r( ptHit.x - scrollSize, ptHit.y - scrollSize, ptHit.x + scrollSize, ptHit.y + scrollSize );            
                    pScrollLayout->ScrollRectIntoView( r, SP_MINIMAL, SP_MINIMAL );
                }
            }
        }
    }

    goto Cleanup;
    

Error:
    TraceTag( ( tagViewServicesErrors, " MovePointerToPointInternal --- Failed "));
    return( E_UNEXPECTED );
    
Cleanup:
    if ( pfValidLayout )
        *pfValidLayout = ( this == pContainingLayout );
        
    RRETURN(hr);
}

HRESULT
CFlowLayout::GetLineInfo(
    CMarkupPointer *pPointerInternal,
    BOOL fAtEndOfLine,
    HTMLPtrDispInfoRec *pInfo,
    CCharFormat const *pCharFormat )
{
    HRESULT hr = S_OK;
    POINT pt;
    CLinePtr   rp(GetDisplay());
    LONG cp = pPointerInternal->GetCp();
    CCalcInfo CI(this);
    BOOL fComplexLine;
    BOOL fRTLFlow;

    //
    // Query Position Info
    //
    
    if (-1 == _dp.PointFromTp( cp, NULL, fAtEndOfLine, FALSE, pt, &rp, TA_BASELINE, &CI, 
                                                      &fComplexLine, &fRTLFlow ))
    {
        /*
        //
        //  We should not return error because nobody is expecting this function 
        //  to fail with this return value!!!  Feed it with some valid information
        //  
        //  (zhenbinx)
        //  
        // 
            hr = OLE_E_BLANK;
            goto Cleanup;
        */
        CTreePos * ptp  = GetContentMarkup()->TreePosAtCp(cp, NULL, TRUE);
        Assert( ptp );
        pInfo->fRTLLine = ptp->GetBranch()->GetParaFormat()->HasRTL(TRUE);
        pInfo->fRTLFlow = pInfo->fRTLLine;

        pInfo->lXPosition           = 0;
        pInfo->lBaseline            = 0;

        pInfo->fAligned             = TRUE;
        pInfo->fHasNestedRunOwner   = FALSE;
        
        pInfo->lLineHeight          = 0;
        pInfo->lDescent             = 0;
        pInfo->lTextHeight          = 1;
        goto Cleanup;
    }

    pInfo->lXPosition = pt.x;
    pInfo->lBaseline = pt.y;
    pInfo->fRTLLine = rp->_fRTLLn;
    pInfo->fRTLFlow = fRTLFlow;
    pInfo->fAligned = ENSURE_BOOL( rp->_fHasAligned );
    pInfo->fHasNestedRunOwner = ENSURE_BOOL( rp->_fHasNestedRunOwner);
    
    Assert( ElementOwner()->Tag() != ETAG_ROOT );
    
    if( ElementOwner()->Tag() != ETAG_ROOT )
    {
        pInfo->lLineHeight = rp->_yHeight;
        pInfo->lDescent = rp.oi()->_yDescent;
        pInfo->lTextHeight = rp->_yHeight - rp.oi()->_yDescent;
    }
    else
    {
        pInfo->lLineHeight = 0;
        pInfo->lDescent = 0;
        pInfo->lTextHeight = 1;
    }

    //
    // try to compute true text height
    //
    {
        CCcs      ccs;
        const CBaseCcs *pBaseCcs;
        
        if (!fc().GetCcs(&ccs, CI._hdc, &CI, pCharFormat))
            goto Cleanup;

        pBaseCcs = ccs.GetBaseCcs();
        pInfo->lTextHeight = pBaseCcs->_yHeight;
        pInfo->lTextDescent = pBaseCcs->_yDescent;
        ccs.Release();
    }

Cleanup:
    RRETURN(hr);
}

HRESULT
CFlowLayout::LineStart(
                       LONG *pcp, BOOL *pfNotAtBOL, BOOL *pfAtLogicalBOL, BOOL fAdjust )
{
    // ensure calculated view
    _dp.WaitForRecalc( *pcp, -1 );    
    LONG cpNew;
    LONG cchSkip;
    LONG cp = *pcp;
    CLineCore *pli;
    HRESULT hr = S_OK;
    CLinePtr rp(GetDisplay());
    rp.RpSetCp( cp , *pfNotAtBOL );
    
    cp = cp - rp.GetIch();
    pli = rp.CurLine();
    
    // Check that we are sane
    if( cp < 1 || cp >= _dp.GetMarkup()->Cch() )
    {
        hr = E_FAIL;
        goto Cleanup;            
    }

    if( fAdjust && pli )
    {
        // See comment for LineEnd()
        _dp.WaitForRecalc( max(min(cp + pli->_cch, GetContentLastCp()), 
                                         GetContentFirstCp()),
                                     -1 );
        // WaitForRecalc can cause the line array memory to be reallocated
        pli = rp.CurLine();

        if(pli)
        {
            rp.GetPdp()->FormattingNodeForLine(FNFL_STOPATGLYPH, cp, NULL, pli->_cch, &cchSkip, NULL, NULL);
        }
        else
        {
            cchSkip = 0;
        }

        cpNew = cp + cchSkip;
    }
    else
    {
        cpNew = cp;
    }
    
    *pfNotAtBOL = cpNew != cp;
    *pfAtLogicalBOL = TRUE;
    *pcp = cpNew;

Cleanup:
    RRETURN( hr );
}

HRESULT
CFlowLayout::LineEnd(
                     LONG *pcp, BOOL *pfNotAtBOL, BOOL *pfAtLogicalBOL, BOOL fAdjust )
{
    // ensure calculated view up to current position
    _dp.WaitForRecalc( *pcp, -1 );    
    CLineCore * pli;
    LONG cpLineBegin;
    LONG cp = *pcp;
    HRESULT hr = S_OK;
    CLinePtr rp(GetDisplay());
    rp.RpSetCp( cp , *pfNotAtBOL );
    
    cpLineBegin = cp - rp.GetIch();
    pli = rp.CurLine();

    if( pli != NULL )
    {
        // Compute min using GetContentLastCp() instead of GetContentLastCp() - 1
        // because the dirty range on the layout could begin on the last cp.
        // (IE #87036).
        _dp.WaitForRecalc( max(min(cpLineBegin + pli->_cch, GetContentLastCp()), 
                                         GetContentFirstCp()),
                                     -1 );    
        // WaitForRecalc can cause the line array memory to be reallocated
        pli = rp.CurLine();

        if( fAdjust )
            cp = cpLineBegin + rp.GetAdjustedLineLength();
        else
            cp = cpLineBegin + pli->_cch;
    }
    else
    {
        cp = cpLineBegin;
    }
    
    // Check that we are sane
    if( cp < 1 || cp >= _dp.GetMarkup()->Cch() )
    {
        hr = E_FAIL;
        goto Cleanup;       
    }
        
    *pfNotAtBOL = cp != cpLineBegin ;
    *pfAtLogicalBOL = cp == cpLineBegin;
    *pcp = cp;

Cleanup:
    RRETURN( hr );
}

HRESULT
CFlowLayout::MoveMarkupPointer(
    CMarkupPointer *    pPointerInternal,
    LONG                cp,
    LAYOUT_MOVE_UNIT    eUnit, 
    POINT               ptCurReally, 
    BOOL *              pfNotAtBOL,
    BOOL *              pfAtLogicalBOL)
{
    HRESULT hr = S_OK;
    BOOL fAdjusted = TRUE;

    switch (eUnit)
    {
        case LAYOUT_MOVE_UNIT_OuterLineStart:
            fAdjusted = FALSE;
            // fall through
        case LAYOUT_MOVE_UNIT_CurrentLineStart:
        {
            hr = THR( LineStart(&cp, pfNotAtBOL, pfAtLogicalBOL, fAdjusted) );
            if (hr)
                goto Cleanup;
                
            // move pointer to new position
            // Note: the markup to use can be a slave markup if the flow layout 
            //       is actually a viewlink master
            hr = pPointerInternal->MoveToCp(cp, ElementContent()->GetMarkup());
            break;
        }
        
       case LAYOUT_MOVE_UNIT_OuterLineEnd:
            fAdjusted = FALSE;
            // fall through
       case LAYOUT_MOVE_UNIT_CurrentLineEnd:
        {
            hr = THR( LineEnd(&cp, pfNotAtBOL, pfAtLogicalBOL, fAdjusted) );
            if (hr)
                goto Cleanup;
                
            // move pointer to new position
            // Note: the markup to use can be a slave markup if the flow layout 
            //       is actually a viewlink master
            hr = pPointerInternal->MoveToCp(cp, ElementContent()->GetMarkup());
            break;
        }
        
        case LAYOUT_MOVE_UNIT_PreviousLine:
        case LAYOUT_MOVE_UNIT_PreviousLineEnd:
        {
            CLinePtr rp(GetDisplay());
            CFlowLayout *pFlowLayout = NULL;
            CElement *pElement;
            BOOL     fVertical;
            
            // Move one line up. This may cause the txt site to be different.

            if( !GetMultiLine() )
            {
                hr = E_FAIL;
                goto Cleanup;
            }
            
            rp.RpSetCp( cp , *pfNotAtBOL );

            // TODO (Bug 13568 - ashrafm): why is this code here?

            if (ptCurReally.x <= 0)
                ptCurReally.x = 12;
            
            if (ptCurReally.y <= 0)
                ptCurReally.y = 12;

            pElement = ElementOwner();
            Assert(pElement);
            fVertical = pElement->HasVerticalLayoutFlow();
            pFlowLayout = _dp.MoveLineUpOrDown(NAVIGATE_UP, fVertical, rp, ptCurReally, &cp, pfNotAtBOL, pfAtLogicalBOL);
            if( !pFlowLayout)
            {
                hr = E_FAIL;
                goto Cleanup;
            }
            
            Assert( pFlowLayout );
            Assert( pFlowLayout->ElementContent() );
            Assert( pFlowLayout->ElementContent()->GetMarkup() );
            // Check that we are sane
            if( cp < 1 || cp >= pFlowLayout->ElementContent()->GetMarkup()->Cch() )
            {
                hr = E_FAIL;
                goto Cleanup;
            }


            {
                CLinePtr rpNew(pFlowLayout->GetDisplay());
                rpNew.RpSetCp(cp, *pfNotAtBOL);

                if (rpNew.RpGetIch() == 0)
                    hr = THR(pFlowLayout->LineStart( &cp, pfNotAtBOL, pfAtLogicalBOL, TRUE ));
                else if (rpNew.RpGetIch() == rpNew->_cch)
                    hr = THR(pFlowLayout->LineEnd( &cp, pfNotAtBOL, pfAtLogicalBOL, TRUE ));
                if (hr)
                    goto Cleanup;
            }

            if( eUnit == LAYOUT_MOVE_UNIT_PreviousLineEnd )
            {
                hr = THR( pFlowLayout->LineEnd(&cp, pfNotAtBOL, pfAtLogicalBOL, TRUE) );
                if( hr )
                    goto Cleanup;
            }
            
            // move pointer to new position
            //
            // IEV6-5393-2000/08/01-zhenbinx:
            // as of current design, CDisplay::MoveLineUpOrDown can cross layout. 
            // Since we are native frame now, that translated into moving into
            // differnt markup. So the cp we have should be in a the layout's
            // markup
            //
            // IEV6-8506-2000/08/12-zhenbinx
            // 
            // We should use the content markup instead of ElementOwner markup
            
            hr = pPointerInternal->MoveToCp(cp, pFlowLayout->ElementContent()->GetMarkup());
            break;
        }
        
        case LAYOUT_MOVE_UNIT_NextLine:
        case LAYOUT_MOVE_UNIT_NextLineStart:
        {
            CLinePtr rp(GetDisplay());
            CFlowLayout *pFlowLayout = NULL;
            CElement *pElement;
            BOOL     fVertical;
            
            // Move down line up. This may cause the txt site to be different.
            if( !GetMultiLine() )
            {
                hr = E_FAIL;
                goto Cleanup;
            }
            
            rp.RpSetCp( cp , *pfNotAtBOL );

            // TODO (Bug 13568 - ashrafm): why is this code here?

            if (ptCurReally.x <= 0)
                ptCurReally.x = 12;
            
            if (ptCurReally.y <= 0)
                ptCurReally.y = 12;
            
            pElement = ElementOwner();
            Assert(pElement);
            fVertical = pElement->HasVerticalLayoutFlow();
            pFlowLayout = _dp.MoveLineUpOrDown(NAVIGATE_DOWN, fVertical, rp, ptCurReally, &cp, pfNotAtBOL, pfAtLogicalBOL);

            if( !pFlowLayout )
            {
                hr = E_FAIL;
                goto Cleanup;
            }                
            
            Assert( pFlowLayout );
            Assert( pFlowLayout->ElementContent() );
            Assert( pFlowLayout->ElementContent()->GetMarkup() );
            // Check that we are sane
            if( cp < 1 || cp >= pFlowLayout->ElementContent()->GetMarkup()->Cch() )
            {
                hr = E_FAIL;
                goto Cleanup;
            }

            {
                CLinePtr rpNew(pFlowLayout->GetDisplay());
                rpNew.RpSetCp(cp, *pfNotAtBOL);

                if (rpNew.RpGetIch() == 0)
                    hr = THR(pFlowLayout->LineStart(&cp, pfNotAtBOL, pfAtLogicalBOL, TRUE));
                else if (rpNew.RpGetIch() == rpNew->_cch)
                    hr = THR(pFlowLayout->LineEnd(&cp, pfNotAtBOL, pfAtLogicalBOL, TRUE));
                if (hr)
                    goto Cleanup;
            }
            
            if( eUnit == LAYOUT_MOVE_UNIT_NextLineStart )
            {
                hr = THR( pFlowLayout->LineStart(&cp, pfNotAtBOL, pfAtLogicalBOL, TRUE) );
                if( hr )
                    goto Cleanup;
            }
            
            // move pointer to new position
            //
            // IEV6-5393-2000/08/01-zhenbinx:
            // as of current design, CDisplay::MoveLineUpOrDown can cross layout. 
            // Since we are native frame now, that translated into moving into
            // differnt markup. So the cp we have should be in a the layout's
            // markup
            //
            // IEV6-8506-2000/08/12-zhenbinx
            // 
            // We should use the content markup instead of ElementOwner markup
            //
            //
            hr = pPointerInternal->MoveToCp(cp, pFlowLayout->ElementContent()->GetMarkup());

            break;
        }
        default:
            hr = E_NOTIMPL;
    }
Cleanup:
    RRETURN(hr);
}

BOOL
CFlowLayout::IsCpBetweenLines( LONG cp )
{
    // Clip incoming cp to content

    LONG cpMin = GetContentFirstCp();
    LONG cpMax = GetContentLastCp();
    
    if( cp < cpMin )
        cp = cpMin;
    if( cp >= cpMax )
        return TRUE;

    CLinePtr   rp1(GetDisplay());
    CLinePtr   rp2(GetDisplay());
    rp1.RpSetCp( cp , TRUE );
    rp2.RpSetCp( cp , FALSE );

    // if IRuns are different, then we are between lines
    return (rp1.GetIRun() != rp2.GetIRun() );
}

BOOL
CFlowLayout::GetFontSize(CCalcInfo * pci, SIZE * psizeFontForShortStr, SIZE * psizeFontForLongStr)
{
    BOOL fRet = FALSE;
    CCcs ccs;
    const CBaseCcs * pBaseCcs;

    fc().GetCcs(&ccs, pci->_hdc, pci, GetFirstBranch()->GetCharFormat());
    pBaseCcs = ccs.GetBaseCcs();
    
    if (pBaseCcs && pBaseCcs->HasFont())
    {
        if (psizeFontForShortStr)
        {
            psizeFontForShortStr->cx = pBaseCcs->_xMaxCharWidth;
            psizeFontForShortStr->cy = pBaseCcs->_yHeight;
        }
            
        if (psizeFontForLongStr)
        {
            psizeFontForLongStr->cx  = pBaseCcs->_xAveCharWidth;
            psizeFontForLongStr->cy  = pBaseCcs->_yHeight;
        }

        fRet = TRUE;
    }
    ccs.Release();

    return fRet;
}

BOOL
CFlowLayout::GetAveCharSize(CCalcInfo * pci, SIZE * psizeChar)
{
    BOOL fRet = _dp.GetAveCharSize(pci, psizeChar);
    if (!fRet)
    {
        fRet = GetFontSize(pci, NULL, psizeChar);
    }
    return fRet;
}

//+====================================================================================
//
// Method:      AllowVScrollbarChange
//
// Synopsis:    Return FALSE if we need to recalc before adding/removing the scrollbar.
//
//-------------------------------------------------------------------------------------
BOOL
CFlowLayout::AllowVScrollbarChange(BOOL fVScrollbarNeeded)
{
    // If a vertical scrollbar needs to be added/removed and the element
    // has overflow-y:auto, then the content of the element needs to be
    // remeasured, after leaving room for the scrollbar.


    if (!_fNeedRoomForVScrollBar != !fVScrollbarNeeded)
    {
        CTreeNode * pNode = GetFirstBranch();

        if (pNode)
        {
            const CFancyFormat *    pFF         = pNode->GetFancyFormat(LC_TO_FC(LayoutContext()));
            const CCharFormat *     pCF         = pNode->GetCharFormat(LC_TO_FC(LayoutContext()));
            BOOL                    fVertical   = pCF->HasVerticalLayoutFlow();
            BOOL                    fWM         = pCF->_fWritingModeUsed;
            
            if (   !ForceVScrollbarSpace()
                && pFF->GetLogicalOverflowY(fVertical, fWM)==styleOverflowAuto)
            {
                _fNeedRoomForVScrollBar = fVScrollbarNeeded;

                // Can't directly call RemeasureElement() here! If we do that, and if we
                // are in the scope of EnsureView(), the Remeasure task added to the view
                // gets deleted before the task gets processed! Instead, we add this to
                // the event queue, and call Remeasure on it in the next EnsureView.
                // The use of STDPROPID_XOBJ_WIDTH as the dispid is arbitrary and can be
                // changed in the future with little impact. The only reason it got picked
                // was because width is somewhat related to size/measurement.
                Doc()->GetView()->AddEventTask(ElementOwner(), STDPROPID_XOBJ_WIDTH, 0);
                return FALSE;
            }
        }
    }
    return TRUE;
}

long
CFlowLayout::GetContentFirstCpForBrokenLayout()
{
    CLayoutContext *pLayoutContext = LayoutContext();
    
    if (   !pLayoutContext 
        || !pLayoutContext->ViewChain() )
    {
        // not a broken layout
        return GetContentFirstCp();
    }
    
    CLayoutBreak  *pLayoutBreak;

    pLayoutContext->GetLayoutBreak(ElementOwner(), &pLayoutBreak);
    if (pLayoutBreak)
    {
        if (pLayoutBreak->LayoutBreakType() == LAYOUT_BREAKTYPE_LINKEDOVERFLOW)
            return DYNCAST(CFlowLayoutBreak, pLayoutBreak)->GetMarkupPointer()->GetCp();
    }
    
    return GetContentFirstCp();
}

long
CFlowLayout::GetContentLastCpForBrokenLayout()
{
    CLayoutContext *pLayoutContext = LayoutContext();
    
    if (   !pLayoutContext 
        || !pLayoutContext->ViewChain() )
    {
        // not a broken layout
        return GetContentLastCp();
    }
    
    CLayoutBreak  *pLayoutBreak;

    pLayoutContext->GetEndingLayoutBreak(ElementOwner(), &pLayoutBreak);
    if (pLayoutBreak)
    {
        if (pLayoutBreak->LayoutBreakType() == LAYOUT_BREAKTYPE_LINKEDOVERFLOW)
            return DYNCAST(CFlowLayoutBreak, pLayoutBreak)->GetMarkupPointer()->GetCp();
    }
    
    return GetContentLastCp();
}

#if DBG
void
CFlowLayout::DumpLayoutInfo( BOOL fDumpLines )
{
    super::DumpLayoutInfo( fDumpLines );

    CloseDumpFile();

    if ( fDumpLines )
    {
        DumpLines();
    }

    InitDumpFile();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\layout\fslyt.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       fslyt.cxx
//
//  Contents:   Implementation of CLegendLayout, CFieldSetLayout
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_FSLYT_HXX_
#define X_FSLYT_HXX_
#include "fslyt.hxx"
#endif

#ifndef X_E1D_HXX_
#define X_E1D_HXX_
#include "e1d.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_THEMEHLP_HXX_
#define X_THEMEHLP_HXX_
#include "themehlp.hxx"
#endif

MtDefine(CLegendLayout, Layout, "CLegendLayout")
MtDefine(CFieldSetLayout, Layout, "CFieldSetLayout")

const CLayout::LAYOUTDESC CLegendLayout::s_layoutdesc =
{
    LAYOUTDESC_FLOWLAYOUT,          // _dwFlags
};

HRESULT
CLegendLayout::Init()
{
    HRESULT hr = super::Init();

    if(hr)
        goto Cleanup;

    GetDisplay()->SetWordWrap(FALSE);

    // Field Sets can NOT be broken
    SetElementCanBeBroken(FALSE);

Cleanup:
    RRETURN(hr);
}

void
CLegendLayout::GetMarginInfo(CParentInfo *ppri,
                                LONG * plLMargin,
                                LONG * plTMargin,
                                LONG * plRMargin,
                                LONG * plBMargin)
{
    CParentInfo     PRI;
    long            lDefMargin;

    if (!ppri)
    {
        PRI.Init(this);
        ppri = &PRI;
    }
    lDefMargin = ppri->DeviceFromDocPixelsX(FIELDSET_CAPTION_OFFSET
                                            + FIELDSET_BORDER_OFFSET);

    super::GetMarginInfo( ppri, plLMargin, plTMargin, plRMargin, plBMargin);

    if (plLMargin)
    {
        *plLMargin += lDefMargin;
    }
    if (plRMargin)
    {
        *plRMargin += lDefMargin;
    }
}


void
CLegendLayout::GetLegendInfo(SIZE *pSizeLegend, POINT *pPosLegend)
{
    CDispNode * pDispNode = GetElementDispNode();

    if (pDispNode)
    {
        *pSizeLegend = pDispNode->GetApparentSize();
        *pPosLegend = pDispNode->GetPosition();
    }
    else
    {
        *pSizeLegend = g_Zero.size;
    }
}

void
CFieldSetLayout::DrawClient(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          cookie,
    void *          pClientData,
    DWORD           dwFlags)
{
    CFieldSetElement *pElem = DYNCAST(CFieldSetElement, ElementOwner());
    HTHEME          hTheme = pElem->GetTheme(THEME_BUTTON);
    CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
    CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);
 
    Assert(pClientData);

    super::DrawClient(prcBounds, prcRedraw, pDispSurface, pDispNode, cookie, pClientData, dwFlags);

    if (DYNCAST(CFieldSetElement, ElementOwner())->GetLegendLayout() && !hTheme)
    {
        CBorderInfo bi;

        DYNCAST(CFieldSetElement, ElementOwner())->_fDrawing = TRUE;
        if (ElementOwner()->GetBorderInfo(pDI, &bi, TRUE) != DISPNODEBORDER_NONE)
        {
            long lBdrLeft= bi.aiWidths[SIDE_LEFT];

            // only draws the top border
            bi.wEdges = BF_TOP;
            bi.aiWidths[SIDE_LEFT] = 0;
            bi.aiWidths[SIDE_RIGHT] = 0;
            bi.aiWidths[SIDE_BOTTOM] = 0;

            if (bi.sizeCaption.cx > lBdrLeft)
            {
                bi.sizeCaption.cx -= lBdrLeft;
                bi.sizeCaption.cy -= lBdrLeft;
            }

            ((CRect &)(pDI->_rcClip)).IntersectRect(*prcBounds);

            DrawBorder(pDI, &pDI->_rc, &bi);
        }
        DYNCAST(CFieldSetElement, ElementOwner())->_fDrawing = FALSE;
    }
}

void CFieldSetLayout::DrawClientBorder(
                const RECT *   prcBounds,
                const RECT *   prcRedraw,
                CDispSurface * pDispSurface,
                CDispNode *    pDispNode,
                void *         pClientData,
                DWORD          dwFlags)
{
    DYNCAST(CFieldSetElement, ElementOwner())->_fDrawing = TRUE;
    CFieldSetElement *pElem = DYNCAST(CFieldSetElement, ElementOwner());
    HTHEME          hTheme = pElem->GetTheme(THEME_BUTTON);
    CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
    CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);

    if (hTheme)
    {
        XHDC    hdc    = pDI->GetDC(TRUE);
        CRect   rc(pDI->_rc);
        CSize   sizeOffset(g_Zero.size);
        CBorderInfo bi;
        CRect   rcLegend;
        int     iClipSaveKind = 0;
        int     iClipKind = RGN_ERROR;
        HRGN    hrgnClipLegend = 0;
        HRGN    hrgnFieldset = 0;
        BOOL    fRetVal;
        CLegendLayout *pLayoutLegend = pElem->GetLegendLayout();


        if (pLayoutLegend)
        { 
            pLayoutLegend->GetRect(&rcLegend, COORDSYS_PARENT);

            hrgnClipLegend  = CreateRectRgnIndirect(&rcLegend);
            hrgnFieldset    = CreateRectRgnIndirect(prcRedraw);

            if (hrgnClipLegend && hrgnFieldset)
            {
                CRegion rgnFieldset(hrgnFieldset);

                iClipSaveKind = hdc.GetClipRgn(hrgnFieldset);
                rgnFieldset.Subtract(hrgnClipLegend);
                iClipKind = hdc.SelectClipRgn(rgnFieldset.GetRegionForLook());
            }
        }

        Verify(pElem->GetBorderInfo(pDI, &bi, TRUE));

        rc.top += bi.offsetCaption;

        fRetVal = hdc.DrawThemeBackground(  hTheme,
                                            BP_GROUPBOX,
                                            0,
                                            &rc,
                                            NULL);

        if (RGN_ERROR != iClipKind)
        {
            if (iClipSaveKind == 1)
                hdc.SelectClipRgn(hrgnFieldset);
            else
                hdc.SelectClipRgn(NULL);
        }

        if (hrgnClipLegend)
        {
            ::DeleteRgn(hrgnClipLegend);
        }

        if (hrgnFieldset)
        {
            ::DeleteRgn(hrgnFieldset);
        }

        if (fRetVal == FALSE)
        {
            CBorderInfo     bi;

            pElem->_fDrawing = TRUE;
            Verify(pElem->GetBorderInfo(pDI, &bi, TRUE));
            pElem->_fDrawing = FALSE;

            ::DrawBorder(pDI, (RECT *)prcBounds, &bi);

        }
    }
    else
    {
        super::DrawClientBorder(prcBounds, prcRedraw, pDispSurface, pDispNode, pClientData, dwFlags);
    }
    DYNCAST(CFieldSetElement, ElementOwner())->_fDrawing = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\layout\inputlyt.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       inputlyt.cxx
//
//  Contents:   Implementation of layout class for <INPUT> controls.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_RECT_HXX_
#define X_RECT_HXX_
#include "rect.hxx"
#endif

#ifndef X_SIZE_HXX_
#define X_SIZE_HXX_
#include "size.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_BTNHLPER_HXX_
#define X_BTNHLPER_HXX_
#include "btnhlper.hxx"
#endif

#ifndef X_INPUTLYT_HXX_
#define X_INPUTLYT_HXX_
#include "inputlyt.hxx"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_INPUTBTN_HXX_
#define X_INPUTBTN_HXX_
#include "inputbtn.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_THEMEHLP_HXX_
#define X_THEMEHLP_HXX_
#include "themehlp.hxx"
#endif

MtDefine(CInputLayout,       Layout, "CInputLayout")
MtDefine(CInputTextLayout,   Layout, "CInputTextLayout")
MtDefine(CInputFileLayout,   Layout, "CInputFileLayout")
MtDefine(CInputFileLayout_pchButtonCaption,   CInputFileLayout, "CInputFileLayout::_pchButtonCaption")
MtDefine(CInputButtonLayout, Layout, "CInputButtonLayout")

ExternTag(tagCalcSize);

extern void DrawTextSelectionForRect(XHDC hdc, CRect *prc, CRect *prcClip, BOOL fSwapColor);


const CLayout::LAYOUTDESC CInputLayout::s_layoutdesc =
{
    LAYOUTDESC_HASINSETS        |
    LAYOUTDESC_NOSCROLLBARS     |
    LAYOUTDESC_FLOWLAYOUT,      // _dwFlags
};

const CLayout::LAYOUTDESC CInputFileLayout::s_layoutdesc =
{
    LAYOUTDESC_HASINSETS        |
    LAYOUTDESC_NOSCROLLBARS     |
    LAYOUTDESC_NOTALTERINSET    |
    LAYOUTDESC_NEVEROPAQUE      |
    LAYOUTDESC_FLOWLAYOUT,      // _dwFlags
};

const CLayout::LAYOUTDESC CInputButtonLayout::s_layoutdesc =
{
    LAYOUTDESC_NOSCROLLBARS     |
    LAYOUTDESC_HASINSETS        |
    LAYOUTDESC_FLOWLAYOUT,          // _dwFlags
};


HRESULT
CInputTextLayout::OnTextChange(void)
{
    CInput * pInput  = DYNCAST(CInput, ElementOwner());

    if (!pInput->IsEditable(TRUE))
        pInput->_fTextChanged = TRUE;

    if (pInput->_fFiredValuePropChange)
    {
        pInput->_fFiredValuePropChange = FALSE;
    }
    else
    {
        pInput->OnPropertyChange(DISPID_CInput_value, 
                                 0, 
                                 (PROPERTYDESC *)&s_propdescCInputvalue); // value change
    }

    return S_OK;
}



CInputTextLayout::CInputTextLayout(CElement * pElementLayout, CLayoutContext *pLayoutContext)
                                : super(pElementLayout, pLayoutContext)
{
}

//+------------------------------------------------------------------------
//
//  Member:     CInputTextLayout::PreDrag
//
//  Synopsis:   Prevent dragging text out of Password control
//
//-------------------------------------------------------------------------

HRESULT
CInputTextLayout::PreDrag(
    DWORD           dwKeyState,
    IDataObject **  ppDO,
    IDropSource **  ppDS)
{
    HRESULT hr;

    if (DYNCAST(CInput, ElementOwner())->GetType() == htmlInputPassword)
        hr = S_FALSE;
    else
        hr = super::PreDrag(dwKeyState, ppDO, ppDS);
    RRETURN1(hr, S_FALSE);
}

void 
CInputTextLayout::DrawClientBorder(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          pClientData,
    DWORD           dwFlags)
{    
    CInput *        pElem  = DYNCAST(CInput, ElementOwner());
    HTHEME          hTheme = pElem->GetTheme(GetThemeClassId());

    Assert(pClientData);

    if (hTheme)
    {
        CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;        
        CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);
        XHDC            hdc    = pDI->GetDC(TRUE);               

        if (!hdc.DrawThemeBackground(    hTheme,
                                         EP_EDITTEXT,
                                         pElem->GetThemeState(),
                                         &pDI->_rc,
                                         NULL))
        {
            super::DrawClientBorder(prcBounds, prcRedraw, pDispSurface, pDispNode, pClientData, dwFlags);
        }
        

    }
    else
    {
        super::DrawClientBorder(prcBounds, prcRedraw, pDispSurface, pDispNode, pClientData, dwFlags);
    }
} 

//+---------------------------------------------------------------------------
//
//  Member:     CInputFileLayout::Init
//
//  Synopsis:   Loads the button caption for the "Browse..." button.
//
//----------------------------------------------------------------------------

HRESULT
CInputFileLayout::Init()
{
    HRESULT hr;
    TCHAR achTemp[128];

    //  Clear existing caption
    if (_pchButtonCaption)
    {
        MemFree(_pchButtonCaption);
    }
    
    //  Load the caption string
    hr = LoadString(GetResourceHInst(),
           IDS_BUTTONCAPTION_UPLOAD,
           achTemp,              
           ARRAY_SIZE(achTemp));
            
    if (FAILED(hr))
    {
        // TODO: Handle OOM here
        hr = MemAllocString(Mt(CInputFileLayout_pchButtonCaption), s_achUploadCaption, &_pchButtonCaption);
        _cchButtonCaption = ARRAY_SIZE(s_achUploadCaption) - 1;
    }
    else
    {
        // TODO: Handle OOM here
        hr = MemAllocString(Mt(CInputFileLayout_pchButtonCaption), achTemp, &_pchButtonCaption);
        _cchButtonCaption = _tcslen(achTemp);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInputFileLayout::GetFocusShape
//
//  Synopsis:   Returns the shape of the focus outline that needs to be drawn
//              when this element has focus. This function creates a new
//              CShape-derived object. It is the caller's responsibility to
//              release it.
//
//----------------------------------------------------------------------------

HRESULT
CInputFileLayout::GetFocusShape(long lSubDivision, CDocInfo * pdci, CShape ** ppShape)
{
    CRect           rc;    
    CRectShape *    pShape;
    CBorderInfo     biButton;
    CInput *        pInputFile = DYNCAST(CInput, ElementOwner());
    HRESULT         hr = S_FALSE;
    CTreeNode * pNodeLayout  = GetFirstBranch();
    const CParaFormat *  pPF = pNodeLayout->GetParaFormat();
    BOOL fRightToLeft = pPF->HasRTL(FALSE);
    HTHEME          hTheme = ElementOwner()->GetTheme(THEME_BUTTON);

    *ppShape = NULL;

    if (!pInputFile->_fButtonHasFocus)
        goto Cleanup;

    GetRect(&rc, COORDSYS_FLOWCONTENT);
    if (rc.IsEmpty())
        goto Cleanup;

    pShape = new CRectShape;
    if (!pShape)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if(!fRightToLeft)
        rc.left = rc.right - _sizeButton.cx;
    else
        rc.right = rc.left + _sizeButton.cx;

    if (hTheme)
    {
        CRect           rcTheme;

        hr = THR(GetThemeBackgroundExtent(
                                            hTheme,
                                            NULL,
                                            BP_PUSHBUTTON, 
                                            pInputFile->GetThemeState(), 
                                            &g_Zero.rc, 
                                            &rcTheme
                                        ));

        if(hr)
            goto Cleanup;

        rc.top     += pdci->DeviceFromDocPixelsY(-rcTheme.top);
        rc.left    += pdci->DeviceFromDocPixelsX(-rcTheme.left);
        rc.bottom  -= pdci->DeviceFromDocPixelsY(rcTheme.bottom);
        rc.right   -= pdci->DeviceFromDocPixelsX(rcTheme.right);
    }
    else
    {
        ComputeInputFileBorderInfo(pdci, biButton);

        rc.top     = rc.top + biButton.aiWidths[SIDE_TOP];
        rc.left    = rc.left + biButton.aiWidths[SIDE_LEFT];
        rc.bottom  = rc.bottom - biButton.aiWidths[SIDE_BOTTOM];
        rc.right   = rc.right - biButton.aiWidths[SIDE_RIGHT];

    }

    // Compensate for xyFlat
    rc.InflateRect(pdci->DeviceFromDocPixelsX(-1), pdci->DeviceFromDocPixelsY(-1));

    pShape->_rect = rc;
    *ppShape = pShape;
    hr = S_OK;

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CInputButtonLayout::GetFocusShape
//
//  Synopsis:   Returns the shape of the focus outline that needs to be drawn
//              when this element has focus. This function creates a new
//              CShape-derived object. It is the caller's responsibility to
//              release it.
//
//----------------------------------------------------------------------------

HRESULT
CInputButtonLayout::GetFocusShape(long lSubDivision, CDocInfo * pdci, CShape ** ppShape)
{
    CRect           rc;    
    CBorderInfo     bi;
    CRectShape *    pShape;
    HRESULT         hr = S_FALSE;
    CInput       *  pButton = DYNCAST(CInput, ElementOwner());

    *ppShape = NULL;
    
    pButton->GetBorderInfo(pdci, &bi);
    GetRect(&rc, COORDSYS_FLOWCONTENT);
    if (rc.IsEmpty())
        goto Cleanup;

    pShape = new CRectShape;
    if (!pShape)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pShape->_rect = rc;
    pShape->_rect.top     += bi.aiWidths[SIDE_TOP];
    pShape->_rect.left    += bi.aiWidths[SIDE_LEFT];
    pShape->_rect.bottom  -= bi.aiWidths[SIDE_BOTTOM];
    pShape->_rect.right   -= bi.aiWidths[SIDE_RIGHT];    

    // Exclude xflat border
    // (Themed buttons don't have this!!!)
    pShape->_rect.InflateRect(pdci->DeviceFromDocPixelsX(-1), pdci->DeviceFromDocPixelsY(-1));

    *ppShape = pShape;
    hr = S_OK;

    // IE6 bug 33042
    // For some reason, only the area inside the focus adorner is being invalidated
    // for submit inputs. This matters in the theme case because we need the border
    // to be invalidated in order to redraw the control. We're going to go ahead
    // and invalidate the whole dispnode here in order to ensure that the control
    // is properly drawn. This is only a problem for themed buttons.

    if (pButton->GetTheme(THEME_BUTTON))
        _pDispNode->Invalidate();
   
Cleanup:
    RRETURN1(hr, S_FALSE);
}
    
void
CInputButtonLayout::DrawClient(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          cookie,
    void *          pClientData,
    DWORD           dwFlags)
{
    super::DrawClient( prcBounds,
                       prcRedraw,
                       pDispSurface,
                       pDispNode,
                       cookie,
                       pClientData,
                       dwFlags);

    // (bug 49150) Has the button just appeared? Should it be the default element
    
    CInput * pButton = DYNCAST(CInput, ElementOwner());
    const CCharFormat *pCF = GetFirstBranch()->GetCharFormat();
    Assert(pButton && pCF);

    if (pButton->GetBtnWasHidden() && pButton->GetType() == htmlInputSubmit
        && !pCF->IsDisplayNone() && !pCF->IsVisibilityHidden())
    {
        pButton->SetDefaultElem();
        pButton->SetBtnWasHidden( FALSE );
    }
 
}

// TODO (112441, olego): Both classes CButtonLayout and CInputButtonLayout 
// have identical methods implementations.

void CInputButtonLayout::DrawClientBackground(
                const RECT *   prcBounds,
                const RECT *   prcRedraw,
                CDispSurface * pDispSurface,
                CDispNode *    pDispNode,
                void *         pClientData,
                DWORD          dwFlags)
{
    CInput *       pButton = DYNCAST(CInput, ElementOwner());
    HTHEME          hTheme = pButton->GetTheme(THEME_BUTTON);

    if (hTheme)
        return;

    super::DrawClientBackground(prcBounds, prcRedraw, pDispSurface, pDispNode, pClientData, dwFlags);
}

void CInputButtonLayout::DrawClientBorder(
                const RECT *   prcBounds,
                const RECT *   prcRedraw,
                CDispSurface * pDispSurface,
                CDispNode *    pDispNode,
                void *         pClientData,
                DWORD          dwFlags)
{
    Assert(pClientData);

    CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
    CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);
    CDoc *          pDoc = Doc();
    CBorderInfo     bi;
    BOOL            fDefaultAndCurrent =    pDoc 
                                        &&  ElementOwner()->_fDefault
                                        &&  ElementOwner()->IsEnabled()
                                        &&  pDoc->HasFocus();
    XHDC            hdc    = pDI->GetDC();
    CInput *        pButton = DYNCAST(CInput, ElementOwner());
    HTHEME          hTheme = pButton->GetTheme(THEME_BUTTON);

    if (hTheme)
    {
        CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
        CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);
        XHDC            hdc    = pDI->GetDC(TRUE);

        if (hdc.DrawThemeBackground(   hTheme,
                                        BP_PUSHBUTTON,
                                        pButton->GetThemeState(),
                                        &pDI->_rc,
                                        NULL))
        {
            return;
        }
    }

    Verify(pButton->GetNonThemedBorderInfo(pDI, &bi, TRUE));

    // draw default if necessary
    bi.acrColors[SIDE_TOP][1]    = 
    bi.acrColors[SIDE_RIGHT][1]  = 
    bi.acrColors[SIDE_BOTTOM][1] = 
    bi.acrColors[SIDE_LEFT][1]   = fDefaultAndCurrent 
                                            ? RGB(0,0,0)
                                            : ElementOwner()->GetInheritedBackgroundColor();

    //  NOTE (greglett) : This xyFlat scheme won't work for outputting to devices 
    //  without a square DPI. Luckily, we never do this.  I think. When this is fixed, 
    //  please change CButtonLayout::DrawClientBorder and CInputButtonLayout::DrawClientBorder 
    //  by removing the following assert and these comments.
    Assert(pDI->IsDeviceIsotropic());
    bi.xyFlat = pDI->DeviceFromDocPixelsX(fDefaultAndCurrent ? -1 : 1);
    //bi.yFlat = pDI->DeviceFromDocPixelsY(fDefaultAndCurrent ? -1 : 1);

    ::DrawBorder(pDI, (RECT *)prcBounds, &bi);
}

CBtnHelper * CInputButtonLayout::GetBtnHelper()
{
    CElement * pElement = ElementOwner();
    Assert(pElement);
    CInput * pButton = DYNCAST(CInput, pElement);
    return pButton->GetBtnHelper();
}

#define TEXT_INSET_DEFAULT_TOP      1
#define TEXT_INSET_DEFAULT_BOTTOM   1
#define TEXT_INSET_DEFAULT_RIGHT    1
#define TEXT_INSET_DEFAULT_LEFT     1

HRESULT
CInputLayout::Init()
{
    HRESULT hr = super::Init();

    if(hr)
        goto Cleanup;

    // Input layout can NOT be broken
    SetElementCanBeBroken(FALSE);

Cleanup:
    RRETURN(hr);
}

htmlInput
CInputLayout::GetType() const
{
    return DYNCAST(CInput, ElementOwner())->GetType();
}

BOOL
CInputLayout::GetMultiLine() const
{
    return IsTypeMultiline(GetType());
}

BOOL 
CInputLayout::GetAutoSize() const
{
    switch(GetType())
    {
    case htmlInputButton:
    case htmlInputSubmit:
    case htmlInputReset:
        return TRUE;
    default:
        return FALSE;
    }
}

THEMECLASSID
CInputLayout::GetThemeClassId() const
{
    CInput *    pInput = DYNCAST(CInput, ElementOwner());
    return pInput->GetInputThemeClsId();
}

//+------------------------------------------------------------------------
//
//  Member:     CInputFileLayout::GetMinSize
//
//  Synopsis:   Get minimum size of the input file control
//
//              the min size of the input file controls should be
//              the default browse button size + 0 char wide input box
//
//-------------------------------------------------------------------------
void
CInputFileLayout::GetMinSize(SIZE * pSize, CCalcInfo * pci)
{
    pSize->cx = pSize->cy = 0;
    AdjustSizeForBorder(pSize, pci, TRUE);
}

//+-------------------------------------------------------------------------
//
//  Method:     CInputTextLayout::CalcSizeHelper
//
//  Synopsis:   Calculate the size of the object
//
//--------------------------------------------------------------------------

DWORD
CInputFileLayout::CalcSizeHelper(
    CCalcInfo * pci,
    SIZE *      psize)
{
    DWORD           grfReturn    = (pci->_grfLayout & LAYOUT_FORCE);
    CTreeNode *     pNode        = GetFirstBranch();
    BOOL            fMinMax      = (     pci->_smMode == SIZEMODE_MMWIDTH
                                     ||  pci->_smMode == SIZEMODE_MINWIDTH );
    SIZE            sizeMin;

    const CFancyFormat * pFF     = pNode->GetFancyFormat();
    const CCharFormat  * pCF     = pNode->GetCharFormat();
    BOOL fVerticalLayoutFlow     = pCF->HasVerticalLayoutFlow();
    BOOL fWritingModeUsed        = pCF->_fWritingModeUsed;
    const CUnitValue & cuvWidth  = pFF->GetLogicalWidth(fVerticalLayoutFlow, fWritingModeUsed);
    const CUnitValue & cuvHeight = pFF->GetLogicalHeight(fVerticalLayoutFlow, fWritingModeUsed);
    BOOL fWidthNotSet            = cuvWidth.IsNullOrEnum();
    BOOL fHeightNotSet           = cuvHeight.IsNullOrEnum();

    GetMinSize(&sizeMin, pci);

    if (fWidthNotSet || fHeightNotSet)
    {
        long    rgPadding[SIDE_MAX];
        SIZE    sizeFontForShortStr;
        SIZE    sizeFontForLongStr;
        int     charX       = DYNCAST(CInput, ElementOwner())->GetAAsize();
        int     charY       = 1;
        
        Assert(charX > 0);

        GetDisplay()->GetPadding(pci, rgPadding, fMinMax);
        GetFontSize(pci, &sizeFontForShortStr, &sizeFontForLongStr);

        Assert(sizeFontForShortStr.cx && sizeFontForShortStr.cy && sizeFontForLongStr.cx && sizeFontForLongStr.cy);

        psize->cx = (charX -1) * sizeFontForLongStr.cx
                    + sizeFontForShortStr.cx
                    + rgPadding[SIDE_LEFT]
                    + rgPadding[SIDE_RIGHT];
        psize->cy = charY * sizeFontForLongStr.cy
                    + rgPadding[SIDE_TOP]
                    + rgPadding[SIDE_BOTTOM];

        // for textboxes, the border and scrollbars go outside
        AdjustSizeForBorder(psize, pci, TRUE);
    }

    if (!fWidthNotSet)
    {
        psize->cx = (!fMinMax || !PercentWidth()
                        ? cuvWidth.XGetPixelValue(pci,
                                               pci->_sizeParent.cx,
                                               pNode->GetFontHeightInTwips(&cuvWidth) )
                        : 0);
        if (psize->cx < sizeMin.cx)
        {
            psize->cx = sizeMin.cx;
        }
    }
    if (!fHeightNotSet)
    {
        psize->cy = (!fMinMax || !PercentHeight()
                        ? cuvHeight.YGetPixelValue(pci,
                                        pci->_sizeParent.cy,
                                        pNode->GetFontHeightInTwips(&cuvHeight))
                        : 0);
        if (psize->cy < sizeMin.cy)
        {
            psize->cy = sizeMin.cy;
        }
    }

    return grfReturn;
}


//+-------------------------------------------------------------------------
//
//  Method:     CInputFileLayout::CalcSizeCore
//
//  Synopsis:   Calculate the size of the object
//
//--------------------------------------------------------------------------

DWORD
CInputFileLayout::CalcSizeCore(CCalcInfo * pci, 
                               SIZE      * psize, 
                               SIZE      * psizeDefault)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CInputFileLayout::CalcSizeCore L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    Assert(ElementOwner());
    htmlInput       typeInput   = GetType();

    Assert(typeInput == htmlInputFile);

    CSaveCalcInfo   sci(pci, this);
    CSize           sizeOriginal;
    DWORD           grfReturn;
    BOOL            fRecalcText = FALSE;
    BOOL            fNormalMode = pci->IsNaturalMode() && (pci->_smMode != SIZEMODE_SET);
    BOOL            fWidthChanged;
    BOOL            fHeightChanged;
#ifdef  NEVER
    BOOL            fIsButton   =   typeInput == htmlInputButton
                                ||  typeInput == htmlInputReset
                                ||  typeInput == htmlInputSubmit;
#endif
    CScopeFlag  csfCalcing(this);

    Listen();

    CElement::CLock   LockS(ElementOwner(), CElement::ELEMENTLOCK_SIZING);

    GetSize(&sizeOriginal);

    if (_fForceLayout)
    {
        pci->_grfLayout |= LAYOUT_FORCE;
        _fForceLayout = FALSE;
    }

    grfReturn  = (pci->_grfLayout & LAYOUT_FORCE);

    if (pci->_grfLayout & LAYOUT_FORCE)
    {
        SetSizeThis( TRUE );
        _fAutoBelow        = FALSE;
        _fPositionSet      = FALSE;
        _fContainsRelative = FALSE;
    }


#ifdef  NEVER
    if (fIsButton)
    {
        fNormalMode = fNormalMode || pci->_smMode == SIZEMODE_SET;
    }
#endif

    fWidthChanged  = (fNormalMode
                                ? psize->cx != sizeOriginal.cx
                                : FALSE);
    fHeightChanged = (fNormalMode
                                ? psize->cy != sizeOriginal.cy
                                : FALSE);

    fRecalcText = (fNormalMode && (   IsDirty()
                                ||  IsSizeThis()
                                ||  fWidthChanged
                                ||  fHeightChanged))
            ||  (pci->_grfLayout & LAYOUT_FORCE)
            ||  (pci->_smMode == SIZEMODE_MMWIDTH && !_fMinMaxValid)
            ||  (pci->_smMode == SIZEMODE_MINWIDTH && (!_fMinMaxValid || _sizeMin.cu < 0));

    // If this site is in need of sizing, then size it
    if (fRecalcText)
    {
        SIZE sizeText;

        if (typeInput == htmlInputFile)
        {
            // calculate button size of input file
            IGNORE_HR(DYNCAST(CInputFileLayout, this)->ComputeInputFileButtonSize(pci));
        }

        //
        // If dirty, ensure display tree nodes exist
        //

        if (    IsSizeThis()
            &&  fNormalMode
            &&  (EnsureDispNode(pci, (grfReturn & LAYOUT_FORCE)) == S_FALSE))
        {
            grfReturn |= LAYOUT_HRESIZE | LAYOUT_VRESIZE;
        }

        //
        // to make input file work
        //
        grfReturn |= CalcSizeHelper(pci, psize);
        _fContentsAffectSize = FALSE;
        sizeText = *psize;
        grfReturn |= super::CalcSizeCore(pci, &sizeText, psizeDefault);
        if (!fNormalMode && PercentWidth())
        {
            *psize = sizeText;
        }

        if (psizeDefault)
        {
            *psizeDefault = *psize;
        }

        grfReturn |= LAYOUT_THIS  |
                    (psize->cx != sizeOriginal.cx
                            ? LAYOUT_HRESIZE
                            : 0) |
                    (psize->cy != sizeOriginal.cy
                            ? LAYOUT_VRESIZE
                            : 0);

        //
        // If size changes occurred, size the display nodes
        //

        if (    fNormalMode
            &&  _pDispNode
            &&  grfReturn & (LAYOUT_FORCE | LAYOUT_HRESIZE | LAYOUT_VRESIZE))
        {
            CSize sizeContent(_dp.GetMaxWidth(), _dp.GetHeight());

            SizeDispNode(pci, *psize);

            // (paulnel) Make sure the max of the content cell has the borders
            // removed. Taking the full container size will cause scrolling on
            // selection.
            CRect rcContainer;
            GetClientRect(&rcContainer);
            sizeContent.Max(rcContainer.Size());
            SizeContentDispNode(sizeContent);

            if (HasRequestQueue())
            {
                long xParentWidth;
                long yParentHeight;

                _dp.GetViewWidthAndHeightForChild(
                    pci,
                    &xParentWidth,
                    &yParentHeight,
                    pci->_smMode == SIZEMODE_MMWIDTH);

                //
                //  To resize absolutely positioned sites, do MEASURE tasks.  Set that task flag now.
                //  If the call stack we are now on was instantiated from a WaitForRecalc, we may not have layout task flags set.
                //  There are two places to set them: here, or on the CDisplay::WaitForRecalc call.
                //  This has been placed in CalcSize for CTableLayout, C1DLayout, CFlowLayout, CInputLayout
                //  See bugs 69335, 72059, et. al. (greglett)
                //
                CCalcInfo       CI(pci);
                CI._grfLayout |= LAYOUT_MEASURE;

                ProcessRequests(&CI, CSize(xParentWidth, yParentHeight));
            }

            Reset(FALSE);
            Assert(!HasRequestQueue() || GetView()->HasLayoutTask(this));
        }

        if (pci->_smMode == SIZEMODE_MMWIDTH)
        {
            _sizeMax.SetSize(psize->cx, -1);
            _sizeMin.SetSize(psize->cx, -1);
            psize->cy = psize->cx;

            _fMinMaxValid = TRUE;
        }
        else if (pci->_smMode == SIZEMODE_MINWIDTH)
        {
            _sizeMin.SetSize(psize->cx, -1);
        }

    }
    else
    {
        grfReturn = super::CalcSizeCore(pci, psize);
    }

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CInputFileLayout::CalcSizeCore L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    return grfReturn;
}

LONG
CInputLayout::GetMaxLength()
{
    switch (GetType())
    {
    case htmlInputText:
    case htmlInputPassword:
        return DYNCAST(CInput, ElementOwner())->GetAAmaxLength();
    default:
        return super::GetMaxLength();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CInputFileLayout::MeasureInputFileCaption
//
//  Synopsis:   Measure the button's caption for Input File.
//
//  Note:       Measuring needs to be done by ourselves as there's no underlying
//              TextSite for this faked button.
//
//----------------------------------------------------------------------------
HRESULT
CInputFileLayout::MeasureInputFileCaption(SIZE * psize, CCalcInfo * pci)
{
    HRESULT hr = S_OK;
    int i;
    long lWidth, lCharWidth;
    TCHAR * pch;
    CCcs ccs;

    Assert(psize);
    Assert(GetType() == htmlInputFile);

    CInput          *pInputFile     = DYNCAST(CInput, ElementOwner());

    if ( -1 == pInputFile->_icfButton )
    {
        CCharFormat cf = *GetFirstBranch()->GetCharFormat();
        LOGFONT lf;
        LONG icf;

        DefaultFontInfoFromCodePage( g_cpDefault, &lf, pci->_pDoc );

        cf.SetFaceName(lf.lfFaceName);

        cf._fBold = lf.lfWeight >= FW_BOLD;
        cf._fItalic = lf.lfItalic;
        cf._fUnderline = lf.lfUnderline;
        cf._fStrikeOut = lf.lfStrikeOut;

        cf._wWeight = (WORD)lf.lfWeight;

        cf._lcid = GetUserDefaultLCID();
        cf._bCharSet = lf.lfCharSet;
        cf._fNarrow = IsNarrowCharSet(lf.lfCharSet);
        cf._bPitchAndFamily = lf.lfPitchAndFamily;

        cf._bCrcFont = cf.ComputeFontCrc();
        cf._fHasDirtyInnerFormats = !!cf.AreInnerFormatsDirty();

        hr = TLS( _pCharFormatCache )->CacheData( & cf, & icf );

        if (hr)
            goto Cleanup;

        pInputFile->_icfButton = SHORT(icf);
    }

    if (!fc().GetCcs(&ccs, pci->_hdc, pci, GetCharFormatEx(pInputFile->_icfButton)))
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    lWidth = 0;
    for ( i = _cchButtonCaption,
            pch = _pchButtonCaption;
          i > 0;
          i--, pch++ )
    {
        if ( ! ccs.Include(*pch, lCharWidth) )
        {
            Assert(0 && "Char not in font!");
        }

        lWidth += lCharWidth;
    }

    psize->cx = lWidth;
    psize->cy = ccs.GetBaseCcs()->_yHeight;

    ccs.Release();

Cleanup:
    RRETURN(hr);
}
void
CInputFileLayout::ComputeInputFileBorderInfo(CDocInfo *pdci, CBorderInfo & BorderInfo)
{
    CInput *    pInput  = DYNCAST(CInput, ElementOwner());
    CDocInfo    DocInfo;
    int         i;

    if (!pdci)
    {
        pdci = &DocInfo;
        pdci->Init(pInput);
    }

    pInput->_fRealBorderSize = TRUE;
    pInput->GetBorderInfo( pdci, &BorderInfo);
    pInput->_fRealBorderSize = FALSE;

    Assert(SIDE_TOP < SIDE_RIGHT);
    Assert(SIDE_RIGHT < SIDE_LEFT);
    Assert(SIDE_TOP < SIDE_BOTTOM);
    Assert(SIDE_BOTTOM < SIDE_LEFT);

    for (i = SIDE_TOP; i <= SIDE_LEFT; i ++)
    {
        if (BorderInfo.abStyles[i] != fmBorderStyleSunken)
            continue;
        if (!BTN_PRESSED(pInput->_wBtnStatus))
        {
            BorderInfo.abStyles[i]= fmBorderStyleRaised;
        }
    }

    BorderInfo.wEdges = BF_RECT | BF_SOFT;

    GetBorderColorInfoHelper( GetFirstBranch()->GetCharFormat(), GetFirstBranch()->GetFancyFormat(), &GetFirstBranch()->GetFancyFormat()->_bd, pdci, &BorderInfo, FALSE);    // Need to pick up the colors, etc.
}

//+---------------------------------------------------------------------------
//
//  Member:     CInputFileLayout::ComputeButtonSize
//
//  Synopsis:   Measure the button's caption.
//
//  Note:       Measuring needs to be done by ourselves as there's no underlying
//              TextSite for this faked button.
//
//----------------------------------------------------------------------------
HRESULT
CInputFileLayout::ComputeInputFileButtonSize(CCalcInfo * pci)
{
    HRESULT hr = S_OK;
    SIZE        sizeText;
    CBorderInfo bInfo;
    int         uitotalBXWidth;
    // default horizontal offset size is 4 logical pixels
    int         uiMinInsetH = pci->DeviceFromDocPixelsX(4);
    HTHEME      hTheme = ElementOwner()->GetTheme(THEME_BUTTON);

    CInput *    pInput = DYNCAST(CInput, ElementOwner());
    
    hr = THR(MeasureInputFileCaption(&sizeText, pci));
    if ( hr )
        goto Error;

    if (hTheme)
    {
        CRect           rcTheme;

        hr = THR(GetThemeBackgroundExtent(
                                            hTheme,
                                            NULL,
                                            BP_PUSHBUTTON, 
                                            DYNCAST(CInput, ElementOwner())->GetThemeState(), 
                                            &g_Zero.rc, 
                                            &rcTheme
                                        ));

        if(hr)
            goto Cleanup;

        bInfo.aiWidths[SIDE_LEFT]   = pci->DeviceFromDocPixelsX(-rcTheme.left);
        bInfo.aiWidths[SIDE_RIGHT]  = pci->DeviceFromDocPixelsX(rcTheme.right);
        bInfo.aiWidths[SIDE_TOP]    = pci->DeviceFromDocPixelsY(-rcTheme.top);
        bInfo.aiWidths[SIDE_BOTTOM] = pci->DeviceFromDocPixelsY(rcTheme.bottom);

    }
    else
    {
        pInput->_fRealBorderSize = TRUE;
        pInput->GetBorderInfo(pci, &bInfo, FALSE, FALSE);
        pInput->_fRealBorderSize = FALSE;
    }

    uitotalBXWidth = bInfo.aiWidths[SIDE_RIGHT] + bInfo.aiWidths[SIDE_LEFT];    

    _xCaptionOffset = sizeText.cx / 2 - uitotalBXWidth;

    // we should have a min offset
    if (_xCaptionOffset < uiMinInsetH)
    {
        _xCaptionOffset = uiMinInsetH;
    }

    _sizeButton.cx = sizeText.cx + _xCaptionOffset + uitotalBXWidth;

    // only remember the text height of the button
    _sizeButton.cy = sizeText.cy;;

    _xCaptionOffset = _xCaptionOffset >> 1;

Cleanup:
    RRETURN(hr);

Error:
    hr = E_FAIL;
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CInputFileLayout::RenderInputFileButtonContent
//
//  Synopsis:   Render.
//
//  Note:       We draw the fake button image here
//
//----------------------------------------------------------------------------

void
CInputFileLayout::RenderInputFileButton(CFormDrawInfo *pDI)
{
    CBorderInfo BorderInfo;
    RECT rcClip;
    RECT rcCaption;
    CRect rcButton;
    SIZE sizeClient;
#ifdef WIN16
    GDIRECT rc, *pRect;
    pRect = &rc;
#else
    RECT *pRect = &rcClip;
#endif
    XHDC hdc = pDI->GetDC(TRUE);
    CTreeNode * pNodeLayout  = GetFirstBranch();
    const CParaFormat *  pPF = pNodeLayout->GetParaFormat();
    BOOL fRightToLeft = pPF->HasRTL(FALSE);
    CMarkup * pMarkupOwner = GetOwnerMarkup();

    CInput          *pInput = DYNCAST(CInput, ElementOwner());
    HTHEME          hTheme = pInput->GetTheme(THEME_BUTTON);
    BOOL            fThemed = FALSE;

    long lOffsetX, lOffsetY;
    CCcs ccs;
    DWORD dwDCObjType       = GetObjectType(hdc);
    const CCharFormat * pcf = GetCharFormatEx( pInput->_icfButton );

    if (!fc().GetCcs(&ccs, hdc, pDI, pcf ))
        return;

    ComputeInputFileBorderInfo(pDI, BorderInfo);    // Need to pick up the colors, etc.

    FONTIDX hfontOld = ccs.PushFont(hdc);

    GetSize(&sizeClient);

    if(!fRightToLeft)
    {
        rcButton.left = sizeClient.cx - _sizeButton.cx;
        rcButton.right = sizeClient.cx;
    }
    else
    {
        // when RTL the button goes on the left the the text input
        rcButton.left = 0;
        rcButton.right = _sizeButton.cx;
    }

    rcButton.top = 0;
    rcButton.bottom = sizeClient.cy;

    if (    hTheme 
        &&  hdc.DrawThemeBackground(   hTheme,
                                        BP_PUSHBUTTON,
                                        pInput->GetThemeState(),
                                        &rcButton,
                                        NULL))
    {
        fThemed = TRUE;
    }
    else
    {
        ::DrawBorder(pDI, &rcButton, &BorderInfo);
        SetBkColor  (hdc, GetSysColorQuick(COLOR_BTNFACE));
    }

    if(!fRightToLeft)
    {
        rcCaption.left = sizeClient.cx - _sizeButton.cx
                        + BorderInfo.aiWidths[SIDE_LEFT];
        rcCaption.right = sizeClient.cx - BorderInfo.aiWidths[SIDE_RIGHT];
    }
    else
    {
        rcCaption.left = BorderInfo.aiWidths[SIDE_LEFT];
        rcCaption.right = _sizeButton.cx - BorderInfo.aiWidths[SIDE_RIGHT];
    }

    rcCaption.top = BorderInfo.aiWidths[SIDE_TOP];
    rcCaption.bottom = sizeClient.cy - BorderInfo.aiWidths[SIDE_BOTTOM];

    lOffsetX = _xCaptionOffset
             + pDI->DeviceFromDocPixelsX(BTN_PRESSED(pInput->_wBtnStatus) ? 1 : 0);

    lOffsetY = max (0L, (LONG)((rcCaption.bottom - rcCaption.top - _sizeButton.cy) / 2))
             + pDI->DeviceFromDocPixelsY(BTN_PRESSED(pInput->_wBtnStatus) ? 1 : 0);
    IntersectRect(&rcClip, &rcCaption, pDI->ClipRect());

    // fix for printing

    if (   pMarkupOwner
        && pMarkupOwner->IsPrintMedia()
        && pMarkupOwner->PaintBackground()
        && (dwDCObjType == OBJ_ENHMETADC || dwDCObjType == OBJ_METADC)
       )
    {
        BitBlt(hdc,
                    rcCaption.left,
                    rcCaption.top,
                    rcCaption.right  - rcCaption.left,
                    rcCaption.bottom - rcCaption.top,
                    hdc, 0, 0, WHITENESS);
        PatBltBrush(hdc,
                    &rcCaption, PATCOPY,
                    GetSysColorQuick(COLOR_BTNFACE));
    }


    if (!pInput->IsEnabled())
    {
        SetTextColor(hdc,  GetSysColorQuick(COLOR_3DHILIGHT));
        VanillaTextOut(&ccs,
                        hdc,
                        rcCaption.left + lOffsetX + 1,
                        rcCaption.top + lOffsetY + 1,
                        fThemed ? ETO_CLIPPED : ETO_OPAQUE | ETO_CLIPPED,
                        pRect,
                        _pchButtonCaption
                            ? _pchButtonCaption
                            : g_Zero.ach,
                        _cchButtonCaption,
                        g_cpDefault,
                        NULL);
        SetTextColor(hdc, GetSysColorQuick(COLOR_3DSHADOW));
    }
    else
    {
        SetTextColor(hdc, GetSysColorQuick(COLOR_BTNTEXT));
    }   

    VanillaTextOut( &ccs,
                    hdc,
                    rcCaption.left + lOffsetX,
                    rcCaption.top + lOffsetY,
                    fThemed ? ETO_CLIPPED : ETO_OPAQUE | ETO_CLIPPED,
                    pRect,
                    _pchButtonCaption
                        ? _pchButtonCaption
                        : g_Zero.ach,
                    _cchButtonCaption,
                    g_cpDefault,
                    NULL);
    
    ccs.PopFont(hdc, hfontOld);
    ccs.Release();
}


void CInputFileLayout::DrawClientBorder(
                const RECT *   prcBounds,
                const RECT *   prcRedraw,
                CDispSurface * pDispSurface,
                CDispNode *    pDispNode,
                void *         pClientData,
                DWORD          dwFlags)
{    
    CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
    CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);
    CBorderInfo     bi;
    RECT            rc, rcButton;
    CTreeNode * pNodeLayout  = GetFirstBranch();
    const CParaFormat *  pPF = pNodeLayout->GetParaFormat();
    BOOL fRightToLeft = pPF->HasRTL(FALSE);
    HTHEME          hTheme = ElementOwner()->GetTheme(THEME_EDIT);

    DYNCAST(CInput, ElementOwner())->_fRealBorderSize = TRUE;
    Verify(ElementOwner()->GetBorderInfo(pDI, &bi, TRUE));
    DYNCAST(CInput, ElementOwner())->_fRealBorderSize = FALSE;
    
    rc = rcButton = *prcBounds;
    
    if(!fRightToLeft)
    {
        rc.right = rc.right - _sizeButton.cx 
                            - pDI->DeviceFromDocPixelsX(CInput::cxButtonSpacing);
        rcButton.left = rc.right;
    }
    else
    {
        rc.left = rc.left + _sizeButton.cx 
                            + pDI->DeviceFromDocPixelsX(CInput::cxButtonSpacing);
        rcButton.right = rc.left;
    }

    if (hTheme)
    {
        XHDC            hdc     = pDI->GetDC(TRUE);               
        RECT            rcTheme = rc;
        
        hdc.DrawThemeBackground(hTheme, EP_EDITTEXT, ETS_NORMAL, &rcTheme, NULL);
    }
    else
    {
        ::DrawBorder(pDI, &rc, &bi);
    }

    RenderInputFileButton(pDI);

    // We only want to paint selection on the button rect in this part
    // The client portion of the selection is handled in the DrawClient
    // method of this class. This way any text in the client will be
    // correctly painted with the selection.
    if (_fTextSelected)
    {
        DrawTextSelectionForRect(pDI->GetDC(), (CRect *)& rcButton ,& pDI->_rcClip , _fSwapColor);
    }


}

//+---------------------------------------------------------------------------
//
//  Member:     CInputFileLayout::DrawClient
//
//  Synopsis:   Draw client rect part of the controls
//
//  Arguments:  prcBounds       bounding rect of display leaf node
//              prcRedraw       rect to be redrawn
//              pSurface        surface to render into
//              pDispNode       pointer to display node
//              pClientData     client-dependent data for drawing pass
//              dwFlags         flags for optimization
//
//----------------------------------------------------------------------------

void
CInputFileLayout::DrawClient(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          cookie,
    void *          pClientData,
    DWORD           dwFlags)
{
    Assert(pClientData);

    CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;

    {
        // we set draw surface information separately for Draw() and
        // the stuff below, because the Draw method of some subclasses
        // (like CFlowLayout) puts pDI into a special device coordinate
        // mode
        CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);
        Draw(pDI);
    }

    {
        // see comment above
        CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);

        // We only want to paint selection on the client rect in this part
        // The button portion of the selection is handled in the DrawClientBorder
        // method of this class
        if (_fTextSelected)
        {
            DrawTextSelectionForRect(pDI->GetDC(), (CRect *)prcRedraw ,& pDI->_rcClip , _fSwapColor);
        }


        // just check whether we can draw zero border at design time
        if (IsShowZeroBorderAtDesignTime())
        {
            CLayout* pParentLayout = GetUpdatedParentLayout();

            if ( pParentLayout && pParentLayout->IsEditable() )
            {
                 DrawZeroBorder(pDI);
            }
        }
    }
}

void
CInputFileLayout::GetButtonRect(RECT *prc)
{
    CTreeNode * pNodeLayout  = GetFirstBranch();
    const CParaFormat *  pPF = pNodeLayout->GetParaFormat();
    BOOL fRightToLeft = pPF->HasRTL(FALSE);

    Assert(prc);
    GetRect(prc, COORDSYS_BOX);
    if(!fRightToLeft)
        prc->left = prc->right - _sizeButton.cx;
    else
        prc->right = prc->left + _sizeButton.cx;
}

//-----------------------------------------------------------------------------
//
//  Member:     Notify
//
//  Synopsis:   Respond to a tree notification
//
//  Arguments:  pnf - Pointer to the tree notification
//
//-----------------------------------------------------------------------------
void
CInputFileLayout::Notify(CNotification * pnf)
{
    if (pnf->IsTextChange())
    {
        // NOTE (jbeda): this may not be reliable -- what if a script
        // in a different frame (or a child frame) pushes a message loop
        // and we continue parsing...  Better safe than sorry, I guess.
        Assert(ElementOwner()->GetWindowedMarkupContext()->GetWindowPending());
        if (ElementOwner()->GetWindowedMarkupContext()->GetWindowPending()->Window()->IsInScript())
        {
            DYNCAST(CInput, ElementOwner())->_fDirtiedByOM = TRUE;
        }
    }
    super::Notify(pnf);
}

void CInputTextLayout::GetDefaultSize(CCalcInfo *pci, SIZE &psize, BOOL *fHasDefaultWidth, BOOL *fHasDefaultHeight)
{
    long            rgPadding[SIDE_MAX];
    SIZE            sizeFontForShortStr;
    SIZE            sizeFontForLongStr;
    CInput        * pInput = DYNCAST(CInput, ElementOwner());
    int             charX = 1;
    int             charY = 1;
    BOOL            fMinMax =   (   pci->_smMode == SIZEMODE_MMWIDTH 
                                ||  pci->_smMode == SIZEMODE_MINWIDTH   );
    charX = pInput->GetAAsize();
    Assert(charX > 0);

    if (    ElementOwner()->HasMarkupPtr() 
        &&  ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document()  )
    {
        GetDisplay()->GetPadding(pci, rgPadding, fMinMax);
    }
    else
    {
        // 
        // (olego) In compat rendering mode always apply default padding (==1)
        // Reasons : 
        // 1) backward copmatibility with IE 5.5
        // 2) CDisplay::GetPadding() returns bogus result when paddings are %'s;
        // 
        rgPadding[SIDE_LEFT]    = 
        rgPadding[SIDE_RIGHT]   = pci->DeviceFromDocPixelsX(1);
        rgPadding[SIDE_TOP]     = 
        rgPadding[SIDE_BOTTOM]  = pci->DeviceFromDocPixelsY(1);
    }

    GetFontSize(pci, &sizeFontForShortStr, &sizeFontForLongStr);

    psize.cx = (charX -1) * sizeFontForLongStr.cx
                    + sizeFontForShortStr.cx
                    + rgPadding[SIDE_LEFT]
                    + rgPadding[SIDE_RIGHT];
    psize.cy = charY * sizeFontForLongStr.cy
                    + rgPadding[SIDE_TOP]
                    + rgPadding[SIDE_BOTTOM];

    AdjustSizeForBorder(&psize, pci, TRUE);

    *fHasDefaultWidth = TRUE;
    *fHasDefaultHeight= TRUE;
}

// TODO (112441, olego): Both classes CButtonLayout and CInputButtonLayout 
// have identical methods implementations.
BOOL
CInputButtonLayout::GetInsets(SIZEMODE smMode, SIZE &size, SIZE &sizeText, BOOL fw, BOOL fh, const SIZE &sizeBorder)
{
    CCalcInfo       CI(this);
    SIZE            sizeFontForShortStr;
    SIZE            sizeFontForLongStr;
    CBtnHelper *    pBtnHelper = GetBtnHelper();
    
    GetFontSize(&CI, &sizeFontForShortStr, &sizeFontForLongStr);

    // if half of text size is less than the size of the netscape border
    // we need to make sure we display at least one char
    if (!fw && (sizeText.cx - sizeBorder.cx - sizeFontForLongStr.cx < 0))
    {
        sizeText.cx = sizeFontForLongStr.cx + CI.DeviceFromDocPixelsX(2) + sizeText.cx;
    }
    else
    {
        size.cx = max((long)CI.DeviceFromDocPixelsX(2), fw ? (size.cx - sizeText.cx)
                             : ((sizeText.cx - sizeBorder.cx)/2 - CI.DeviceFromDocPixelsX(6)));

        if (!fw)
        {
            sizeText.cx = size.cx + sizeText.cx;
        }
    }

    //
    // text centering is done through alignment
    //

    size.cx = 0;
    pBtnHelper->_sizeInset.cx = 0;

    if (smMode == SIZEMODE_MMWIDTH)
    {
        sizeText.cy = sizeText.cx;
        pBtnHelper->_sizeInset = g_Zero.size;
    }
    else
    {
        // vertical inset is 1/2 of font height
        size.cy = fh    ? (size.cy - sizeText.cy)
            : (sizeFontForShortStr.cy/2 - (sizeBorder.cy ? CI.DeviceFromDocPixelsY(6) : CI.DeviceFromDocPixelsY(4)));

        size.cy = max((long)CI.DeviceFromDocPixelsY(1), size.cy);
            
        sizeText.cy =   max(sizeText.cy, sizeFontForShortStr.cy + sizeBorder.cy)        
            + size.cy;

           
        if (size.cy < CI.DeviceFromDocPixelsY(3) && !fh)
        {        
            // for netscape compat            
            size.cy = 0;
        }

        pBtnHelper->_sizeInset.cy = size.cy / 2;
    }
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CInputButtonLayout::HitTestContent
//
//  Synopsis:   Determine if the given display leaf node contains the hit point.
//
//  Arguments:  pptHit          hit test point
//              pDispNode       pointer to display node
//              pClientData     client-specified data value for hit testing pass
//
//  Returns:    TRUE if the button layout contains the point
//
//----------------------------------------------------------------------------

BOOL
CInputButtonLayout::HitTestContent(
    const POINT *   pptHit,
    CDispNode *     pDispNode,
    void *          pClientData,
    BOOL            fDeclinedByPeer)
{
    Assert(pptHit);
    Assert(pDispNode);
    Assert(pClientData);

    CInput  *       pElem = DYNCAST(CInput, ElementOwner());
    CHitTestInfo *  phti = (CHitTestInfo *) pClientData;
    HTHEME          hTheme = pElem->GetTheme(THEME_BUTTON);
    BOOL            fRet = TRUE;
    RECT            rcClient;
    WORD            wHitTestCode;
    HRESULT         hr = S_OK;

    if (!hTheme)
    {
        fRet = super::HitTestContent(   pptHit,
                                        pDispNode,
                                        pClientData,
                                        fDeclinedByPeer);
        goto Cleanup;
    }

    Assert(pElem);

    GetClientRect(&rcClient);

    hr = HitTestThemeBackground(    hTheme,
                                    NULL,
                                    BP_PUSHBUTTON,
                                    pElem->GetThemeState(),
                                    0,
                                    &rcClient,
                                    NULL,
                                    *pptHit,
                                    &wHitTestCode);

    if (SUCCEEDED(hr) && wHitTestCode == HTNOWHERE)
    {
        fRet = FALSE;
        phti->_htc = HTC_NO;
        goto Cleanup;
    }

    fRet = super::HitTestContent(pptHit,
                                pDispNode,
                                pClientData,
                                fDeclinedByPeer);

Cleanup:
    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\layout\imglyt.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       imglyt.cxx
//
//  Contents:   Implementation of CImageLayout
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_IMGLYT_HXX_
#define X_IMGLYT_HXX_
#include "imglyt.hxx"
#endif

#ifndef X_IMGHLPER_HXX_
#define X_IMGHLPER_HXX_
#include "imghlper.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_MMPLAY_HXX_
#define X_MMPLAY_HXX_
#include "mmplay.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X_IMGANIM_HXX_
#define X_IMGANIM_HXX_
#include "imganim.hxx"
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X_EMAP_HXX_
#define X_EMAP_HXX_
#include "emap.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_DRAGDROP_HXX_
#define X_DRAGDROP_HXX_
#include "dragdrop.hxx"
#endif

#ifndef X_XBAG_HXX_
#define X_XBAG_HXX_
#include "xbag.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif


MtDefine(CImgElementLayout, Layout, "CImgElementLayout")
MtDefine(CInputImageLayout, Layout, "CInputImageLayout")
ExternTag(tagImgTrans);

//extern void SetCachedImageSize(LPCTSTR pchURL, SIZE size);
extern BOOL GetCachedImageSize(LPCTSTR pchURL, SIZE *psize);

extern HRESULT
CreateImgDataObject(CDoc * pDoc, CImgCtx * pImgCtx, CBitsCtx * pBitsCtx,
                    CElement * pElement, CGenDataObject ** ppImgDO);


class CImgDragDropSrcInfo : public CDragDropSrcInfo
{
public:
    CImgDragDropSrcInfo() : CDragDropSrcInfo()
    {
        _srcType = DRAGDROPSRCTYPE_IMAGE;
    }

    CGenDataObject *    _pImgDO;    // Data object for the image being dragged
};

const CLayout::LAYOUTDESC CImageLayout::s_layoutdesc =
{
    0, // _dwFlags
};

//+-------------------------------------------------------------------------
//
//  Method:     CImageLayout::CalcSizeVirtual
//
//  Synopsis   : This function adjusts the size of the image
//               it uses the image Width and Height if present
//
//--------------------------------------------------------------------------

DWORD
CImgElementLayout::CalcSizeVirtual( CCalcInfo * pci,
                                    SIZE      * psize,
                                    SIZE      * psizeDefault)
{
    Assert(ElementOwner());
    Assert(pci);
    Assert(psize);
    WHEN_DBG(SIZE psizeIn = *psize);
    WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0

    CScopeFlag        csfCalcing(this);
    CElement::CLock   LockS(ElementOwner(), CElement::ELEMENTLOCK_SIZING);
    CSaveCalcInfo     sci(pci, this);
    DWORD             grfReturn;

    if (_fForceLayout)
    {
        pci->_grfLayout |= LAYOUT_FORCE;
        _fForceLayout = FALSE;
    }
    grfReturn = (pci->_grfLayout & LAYOUT_FORCE);
    SetSizeThis(IsSizeThis() || (pci->_grfLayout & LAYOUT_FORCE));

    // If sizing is needed or it is a min/max request, handle it here
    if (   (    pci->_smMode != SIZEMODE_SET
            &&  IsSizeThis())
        || pci->_smMode == SIZEMODE_MMWIDTH
        || pci->_smMode == SIZEMODE_MINWIDTH
        )
    {
        HRESULT hr;
        CImgHelper * pImage;
        CSize sizeOriginal;

        GetSize(&sizeOriginal);

        pImage = DYNCAST(CImgElement, ElementOwner())->_pImage;
        Assert(pImage);
        pImage->CalcSize(pci, psize);

        if (pci->IsNaturalMode())
        {
            //
            // If dirty, ensure display tree nodes exist
            //

            if (   IsSizeThis()
                && (SUCCEEDED(hr = EnsureDispNode(pci, (grfReturn & LAYOUT_FORCE))))
               )
            {
                if (pImage->_pBitsCtx)
                {
                    SetPositionAware();
                }

                if (hr == S_FALSE)
                {
                    grfReturn |= LAYOUT_HRESIZE | LAYOUT_VRESIZE;
                }
            }
            SetSizeThis(FALSE);


            {
#define MIN_ALLOWED_WIDTH_DEFINED_BY_CWILSO     5
#define MAX_ALLOWED_HEIGHT_DEFINED_BY_CWILSO    75

                CLayoutContext *pLayoutContext = pci->GetLayoutContext();

                // TODO (112467, olego): Now we have CLayout::_fElementCanBeBroken bit flag 
                // that prohibit layout breaking in Page View. This approach is not suffitient 
                // enouth for editable Page View there we want this property to be calculated 
                // dynamically depending on layout type and layout nesting position (if parent 
                // has it child should inherit). 
                // This work also will enable CSS attribute page-break-inside support.
                
                //
                //  this is a hack to handle lo-o-ong images used as a border inside table in PPV. 
                //
                if (
                    //  if there is a layout context ...
                        pLayoutContext
                    //  ... and if the image is inside table ...
                    &&  pci->_fTableCalcInfo    )
                {
                    long lScreenPixelsWidth;
                    long lScreenPixelsHeight;

                    //  get image size in screen pixels
                    // (mikhaill: being more exact - in conventional document pixels)
                    if (pLayoutContext->GetMedia() != mediaTypeNotSet)
                    {
                        lScreenPixelsWidth  = pci->DocPixelsFromDeviceX(psize->cx);
                        lScreenPixelsHeight = pci->DocPixelsFromDeviceY(psize->cy);
                    }
                    else 
                    {
                        lScreenPixelsWidth  = psize->cx;
                        lScreenPixelsHeight = psize->cy;
                    }

                    //  ... and the image is narrow and long (the definition of "narrow" and "long" 
                    //  given by CWilso in description of bug # 97596) ...
                    if (    lScreenPixelsWidth  < MIN_ALLOWED_WIDTH_DEFINED_BY_CWILSO
                        &&  lScreenPixelsHeight > MAX_ALLOWED_HEIGHT_DEFINED_BY_CWILSO  )
                    {
                        //  if this is not compatible layout context ...
                        if (pLayoutContext->ViewChain()) 
                        {
                            //  ... cut the height beyond available height 
                            if (psize->cy > pci->_cyAvail)
                            {
                                psize->cy = pci->_cyAvail;
                            }
                        }
                        else
                        //  check if this is a compatible layout context 
                        {
                            CMarkup *pMarkup = GetContentMarkup();
                            AssertSz(pMarkup, "Layout MUST have markup pointer!!!"); 

                            if (pMarkup && pMarkup->GetCompatibleLayoutContext() == pLayoutContext)
                            {
                                //  table will be messed up if compatible layout of a table cell 
                                //  will be longer than real one. To prevent it lets return some 
                                //  reasonable height...
                                psize->cy = 1;
                            }
                        }
                    }
                }
            }


            grfReturn |=  LAYOUT_THIS 
                        | (psize->cx != sizeOriginal.cx ? LAYOUT_HRESIZE : 0) 
                        | (psize->cy != sizeOriginal.cy ? LAYOUT_VRESIZE : 0);

            //
            // Size display nodes if size changes occurred
            //

            if (grfReturn & (LAYOUT_FORCE | LAYOUT_HRESIZE | LAYOUT_VRESIZE))
            {
                SizeDispNode(pci, *psize, (grfReturn & LAYOUT_FORCE));
                pImage->SetActivity();
            }

            //  At this point we want to update psize with a new information accounting filter 
            if (HasMapSizePeer())
                 GetApparentSize(psize); // from DispNode

        }
        else if (   pci->_smMode == SIZEMODE_MMWIDTH
                 || pci->_smMode == SIZEMODE_MINWIDTH
                )
        {
            //  At this point we want to update psize with a new information accounting filter 
            //  for MIN MAX Pass inside table cell.
            if (HasMapSizePeer())
            {
                //  At this point we want to update psize with a new information accounting filter 
                CRect rectMapped(CRect::CRECT_EMPTY);
                // Get the possibly changed size from the peer
                if(DelegateMapSize(*psize, &rectMapped, pci))
                {
                    psize->cx = rectMapped.Width();
                    psize->cy = rectMapped.Height();
                }
            }

            if (pci->_smMode == SIZEMODE_MMWIDTH)
                psize->cy = psize->cx;
        }
    }

    // Otherwise, defer to default handling
    else
    {
        grfReturn = super::CalcSizeVirtual(pci, psize, NULL);
    }

    return grfReturn;
}


//+----------------------------------------------------------------------------
//
// Member: GetMarginInfo
//
//  add hSpace/vSpace to the margin
//
//-----------------------------------------------------------------------------
void
CImgElementLayout::GetMarginInfo(CParentInfo *ppri,
                                LONG * plLMargin,
                                LONG * plTMargin,
                                LONG * plRMargin,
                                LONG * plBMargin)
{
    CImgElement *      pImg            = DYNCAST(CImgElement, ElementOwner());

    super::GetMarginInfo( ppri, plLMargin, plTMargin, plRMargin, plBMargin);
    Assert(pImg && pImg->_pImage);
    pImg->_pImage->GetMarginInfo( ppri, plLMargin, plTMargin, plRMargin, plBMargin);
}

//+---------------------------------------------------------------------------
//
//  Member:     Draw
//
//  Synopsis:   Paint the object.
//
//----------------------------------------------------------------------------

void
CImgElementLayout::Draw(CFormDrawInfo *pDI, CDispNode *pDispNode)
{
    CImgElement *   pImg = DYNCAST(CImgElement, ElementOwner());

    
#if DBG==1
    BOOL fLayoutOpaque = IsOpaque();
    BOOL fDispNodeOpaque = pDispNode->IsOpaque();
    if (fDispNodeOpaque && !fLayoutOpaque)
    {
        CBackgroundInfo bi;
        GetBackgroundInfo(NULL, &bi, FALSE); 
        AssertSz(bi.crBack != COLORREF_NONE, "Display node and layout disagree about image opacity");
    }

    if (IsTagEnabled(tagImgTrans) && IsOpaque() && !pDispNode->IsOpaque())
    {
        TraceTag((tagImgTrans, "CImgElementLayout %x is opaque, dispnode %x isn't (perf)",
                    this, pDispNode));
    }
#endif

    // draw the image
    pImg->_pImage->Draw(pDI);

    // Draw the map if in edit mode
    if (IsEditable(TRUE))
    {
        pImg->EnsureMap();
        if (pImg->_pMap)
        {
            pImg->_pMap->Draw(pDI, pImg);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     Draw
//
//  Synopsis:   Paint the object.
//
//----------------------------------------------------------------------------

void
CInputImageLayout::Draw(CFormDrawInfo *pDI, CDispNode *pDispNode)
{
    CInput *   pImg = DYNCAST(CInput, ElementOwner());

#if DBG==1
    BOOL fLayoutOpaque = IsOpaque();
    BOOL fDispNodeOpaque = pDispNode->IsOpaque();
    if (fDispNodeOpaque && !fLayoutOpaque)
    {
        CBackgroundInfo bi;
        GetBackgroundInfo(NULL, &bi, FALSE); 
        AssertSz(bi.crBack != COLORREF_NONE, "Display node and layout disagree about image opacity");
    }

    if (IsTagEnabled(tagImgTrans) && IsOpaque() && !pDispNode->IsOpaque())
    {
        TraceTag((tagImgTrans, "CInputImageLayout %x is opaque, dispnode %x isn't (perf)",
                    this, pDispNode));
    }
#endif

    // draw the image
    pImg->_pImage->Draw(pDI);
}


HRESULT
CImgElementLayout::PreDrag(DWORD          dwKeyState,
                    IDataObject ** ppDO,
                    IDropSource ** ppDS)
{
    HRESULT                 hr          = S_OK;
    CImgDragDropSrcInfo *   pDragInfo   = NULL;
    CGenDataObject *        pDO         = NULL;
    CImgElement *           pImgElem    = DYNCAST(CImgElement, ElementOwner());
    CImgHelper *            pImg        = pImgElem->_pImage;

    Assert(!Doc()->_pDragDropSrcInfo);

    pDragInfo = new CImgDragDropSrcInfo;
    if (!pDragInfo)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    hr = THR(CreateImgDataObject(Doc(), pImg->_pImgCtx, pImg->_pBitsCtx, ElementOwner(), &pDO));
    if (hr)
    {
        goto Cleanup;
    }
    Assert(pDO);
    pDO->SetBtnState(dwKeyState);

    hr = pDO->QueryInterface(IID_IDataObject,(void **)ppDO);
    if (hr)
        goto Cleanup;

    hr = pDO->QueryInterface(IID_IDropSource,(void **)ppDS);
    if (hr)
        goto Cleanup;

    pDragInfo->_pImgDO = pDO;
    Doc()->_pDragDropSrcInfo = pDragInfo;

Cleanup:
    if (hr)
    {
        if (pDragInfo)
        {
            delete pDragInfo;
        }
        if (pDO)
        {
            pDO->Release();
        }
    }
    RRETURN(hr);
}


HRESULT
CImgElementLayout::PostDrag(HRESULT hrDrop, DWORD dwEffect)
{
    Assert(Doc()->_pDragDropSrcInfo);
    //
    // possible for not to be image - via dragElement calls via OM.
    //
    if ( Doc()->_pDragDropSrcInfo->_srcType == DRAGDROPSRCTYPE_IMAGE  )
    {    
        DYNCAST(CImgDragDropSrcInfo, Doc()->_pDragDropSrcInfo)->_pImgDO->Release();
    }        
    RRETURN(S_OK);
}





//+----------------------------------------------------------------------------
//
// Member: GetMarginInfo
//
//  add hSpace/vSpace to the margin
//
//-----------------------------------------------------------------------------
void
CInputImageLayout::GetMarginInfo(CParentInfo *ppri,
                                LONG * plLMargin,
                                LONG * plTMargin,
                                LONG * plRMargin,
                                LONG * plBMargin)
{
    CInput *      pImg            = DYNCAST(CInput, ElementOwner());

    super::GetMarginInfo( ppri, plLMargin, plTMargin, plRMargin, plBMargin);
    Assert(pImg && pImg->_pImage);
    pImg->_pImage->GetMarginInfo( ppri, plLMargin, plTMargin, plRMargin, plBMargin);
}

DWORD
CInputImageLayout::CalcSizeVirtual( CCalcInfo * pci,
                                    SIZE *      psize,
                                    SIZE *      psizeDefault)
{
    Assert(ElementOwner());
    Assert(pci);
    Assert(psize);
    WHEN_DBG(SIZE psizeIn = *psize);
    WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0

    //  TODO (112503, olego) : Do we ever get here with SIZEMODE_SET ???
    Assert(pci->_smMode != SIZEMODE_SET);

    CInput          * pImg = DYNCAST(CInput, ElementOwner());
    CScopeFlag        csfCalcing(this);
    CElement::CLock   LockS(ElementOwner(), CElement::ELEMENTLOCK_SIZING);
    CSize             sizeOriginal;
    DWORD             grfReturn;
    HRESULT           hr;

    GetSize(&sizeOriginal);

    if (_fForceLayout)
    {
        pci->_grfLayout |= LAYOUT_FORCE;
        _fForceLayout = FALSE;
    }

    grfReturn  = (pci->_grfLayout & LAYOUT_FORCE);
    SetSizeThis( IsSizeThis() || (pci->_grfLayout & LAYOUT_FORCE) );

    // If sizing is needed or it is a min/max request, handle it here
    if (   (    pci->_smMode != SIZEMODE_SET
            &&  IsSizeThis())
        || pci->_smMode == SIZEMODE_MMWIDTH
        || pci->_smMode == SIZEMODE_MINWIDTH
        )
    {
        Assert(pImg->_pImage);
        pImg->_pImage->CalcSize(pci, psize);

        if (pci->IsNaturalMode())
        {
            //
            // If dirty, ensure display tree nodes exist
            //

            if (    IsSizeThis()
                &&  (SUCCEEDED(hr = EnsureDispNode(pci, (grfReturn & LAYOUT_FORCE)))))
            {
                if (pImg->_pImage->_pBitsCtx)
                {
                    SetPositionAware();
                }

                if (hr == S_FALSE)
                    grfReturn |= LAYOUT_HRESIZE | LAYOUT_VRESIZE;
            }
            SetSizeThis( FALSE );
            grfReturn    |= LAYOUT_THIS  |
                            (psize->cx != sizeOriginal.cx
                                    ? LAYOUT_HRESIZE
                                    : 0) |
                            (psize->cy != sizeOriginal.cy
                                    ? LAYOUT_VRESIZE
                                    : 0);

            //
            // Size display nodes if size changes occurred
            //

            if (grfReturn & (LAYOUT_FORCE | LAYOUT_HRESIZE | LAYOUT_VRESIZE))
            {
                SizeDispNode(pci, *psize, (grfReturn & LAYOUT_FORCE));

                pImg->_pImage->SetActivity();
            }

            if(HasMapSizePeer())
                GetApparentSize(psize);

        }
        else if (   pci->_smMode == SIZEMODE_MMWIDTH
                 || pci->_smMode == SIZEMODE_MINWIDTH
                )
        {
            //  At this point we want to update psize with a new information accounting filter 
            //  for MIN MAX Pass inside table cell.
            if (HasMapSizePeer())
            {
                //  At this point we want to update psize with a new information accounting filter 
                CRect rectMapped(CRect::CRECT_EMPTY);
                // Get the possibly changed size from the peer
                if(DelegateMapSize(*psize, &rectMapped, pci))
                {
                    psize->cx = rectMapped.Width();
                    psize->cy = rectMapped.Height();
                }
            }

            if (pci->_smMode == SIZEMODE_MMWIDTH)
                psize->cy = psize->cx;
        }
    }

    // Otherwise, defer to default handling
    else
    {
        grfReturn = super::CalcSizeVirtual(pci, psize, NULL);
    }

    return grfReturn;
}

HRESULT
CInputImageLayout::GetFocusShape(long lSubDivision, CDocInfo * pdci, CShape ** ppShape)
{
    CRect           rc;
    CRectShape *    pShape;
    HRESULT         hr = S_FALSE;

    *ppShape = NULL;

    GetClientRect(&rc);
    if (rc.IsEmpty())
        goto Cleanup;

    pShape = new CRectShape;
    if (!pShape)
    {
        *ppShape = NULL;
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    pShape->_rect = rc;
    pShape->_rect.InflateRect(1, 1);
    *ppShape = pShape;

    hr = S_OK;

Cleanup:
    RRETURN1(hr, S_OK);
}

CImgHelper *
CImageLayout::GetImgHelper()
{
    CElement * pElement = ElementOwner();
    CImgHelper * pImgHelper = NULL;

    Assert(pElement);
    if (pElement->Tag() == ETAG_IMG)
        pImgHelper = DYNCAST(CImgElement, pElement)->_pImage;
    else if (pElement->Tag() == ETAG_INPUT)
        pImgHelper = DYNCAST(CInput, pElement)->_pImage;

    Assert(pImgHelper);

    return pImgHelper;
}

//+---------------------------------------------------------------------------
//
//  Member:     HandleViewChange
//
//  Synopsis:   Respond to change of in view status
//
//  Arguments:  flags           flags containing state transition info
//              prcClient       client rect in global coordinates
//              prcClip         clip rect in global coordinates
//              pDispNode       node which moved
//
//----------------------------------------------------------------------------
void
CImageLayout::HandleViewChange(
    DWORD           flags,
    const RECT*     prcClient,
    const RECT*     prcClip,
    CDispNode*      pDispNode)
{
    CImgHelper * pImg = GetImgHelper();

    if (!pImg->_fVideoPositioned)
    {
        pImg->_fVideoPositioned = TRUE;
        pImg->SetVideo();
    }

    if (pImg->_hwnd)
    {           
        CRect rcClip(*prcClip);
        UINT uFlags = SWP_NOACTIVATE | SWP_NOZORDER | SWP_NOCOPYBITS;

        if (flags & VCF_INVIEWCHANGED)
            uFlags |= (flags & VCF_INVIEW) ? SWP_SHOWWINDOW : SWP_HIDEWINDOW;

// NOTE (lmollico): setting SWP_NOREDRAW causes some problems: the activemovie window paints itself
// between our ScrollDC and EndDeferWindowPos
/*        else if (flags & VCF_NOREDRAW)
            uFlags |= SWP_NOREDRAW;*/

        DeferSetWindowPos(pImg->_hwnd, (RECT *) prcClient, uFlags, NULL);

        rcClip.OffsetRect(-((const CRect*)prcClient)->TopLeft().AsSize());
        SetWindowRgn(pImg->_hwnd, &rcClip, !(flags & VCF_NOREDRAW));

        if (pImg->_pVideoObj)
        {
            RECT rcImg;

            rcImg.top = 0;
            rcImg.left = 0;
            rcImg.bottom = prcClient->bottom - prcClient->top;
            rcImg.right = prcClient->right - prcClient->left;
            pImg->_pVideoObj->SetWindowPosition(&rcImg);
        }
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Function:   PercentSize
//
//  Synopsis:   Handy helper to check for percentage dimensions
//
//----------------------------------------------------------------------------
BOOL
CImageLayout::PercentSize()
{
    BOOL fPercentSize = super::PercentSize();

    //  If rendering in CSS1 strict mode image is allowed to have a padding. 
    //  Report if padding is defined in percents. 
    if (    !fPercentSize 
        &&  ElementOwner()->HasMarkupPtr() 
        &&  ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document()  )
    {
        const CFancyFormat *pFF = GetFirstBranch()->GetFancyFormat(LC_TO_FC(LayoutContext()));
        fPercentSize = pFF->HasPercentHorzPadding() || pFF->HasPercentVertPadding();
    }
    
    return fPercentSize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\layout\framelyt.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       frameset.cxx
//
//  Contents:   Implementation of CFrameSetLayout
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CGUID_H_
#define X_CGUID_H_
#include <cguid.h>
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_FRAMELYT_HXX_
#define X_FRAMELYT_HXX_
#include "framelyt.hxx"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DISPCONTAINER_HXX_
#define X_DISPCONTAINER_HXX_
#include "dispcontainer.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_OPTSHOLD_HXX_
#define X_OPTSHOLD_HXX_
#include "optshold.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx" // needed for EVENTPARAM
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif


#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

enum XorYLoop { XDirection = 0, YDirection = 1, Terminate = 2 };

MtDefine(CFrameSetLayout, Layout, "CFrameSetLayout")
MtDefine(CFrameSetLayout_aryResizeRecords_pv, CFrameSetLayout, "CFrameSetLayout::_aryResizeRecords::_pv")
MtDefine(CFrameSetLayoutCalcPositions_aryPosX_pv, Locals, "CFrameSetLayout::CalcPositions aryPosX::_pv")
MtDefine(CFrameSetLayoutCalcPositions_aryPosY_pv, Locals, "CFrameSetLayout::CalcPositions aryPosY::_pv")

ExternTag(tagCalcSize);
ExternTag(tagLayoutTasks);

const CLayout::LAYOUTDESC CFrameSetLayout::s_layoutdesc =
{
    0,          // _dwFlags
};

//+---------------------------------------------------------------------------
//
//  Member:     CFrameSetLayout::CFrameSetLayout, public
//
//  Synopsis:   CFrameSetLayout ctor
//
//----------------------------------------------------------------------------
CFrameSetLayout::CFrameSetLayout (CElement * pElement, CLayoutContext *pLayoutContext) :
    CLayout(pElement, pLayoutContext),
    _aryResizeRecords(Mt(CFrameSetLayout_aryResizeRecords_pv))
{
};

//+-------------------------------------------------------------------------
//
//  Method:     CFrameSetLayout::CalcSizeVirtual
//
//  Synopsis:   Calculate the size of the object
//              (See CLayout::CalcSize for details)
//
//--------------------------------------------------------------------------

DWORD
CFrameSetLayout::CalcSizeVirtual( CCalcInfo * pci,
                                  SIZE *      psize,
                                  SIZE *      psizeDefault)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CFrameSetLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));

    CScopeFlag      csfCalcing(this);
    CElement::CLock LockS(FrameSetElement(), CElement::ELEMENTLOCK_SIZING);
    CSaveCalcInfo   sci(pci, this);
    DWORD           grfReturn;
    CLayoutContext *pLayoutContext = pci->GetLayoutContext();

    Assert(pci);
    Assert(psize);

    if (_fForceLayout)
    {
        pci->_grfLayout |= LAYOUT_FORCE;
        _fForceLayout = FALSE;
    }

    // CLayout::CalcSizeVirtual (called below) requires SizeThis to be set to update size.
    // I believe this won't impact perf, because it just causes a few minor extra calculations
    // in CLayout::CalcSizeVirtual (not exactly complicated or intensive).
    SetSizeThis(TRUE);

    // super::CSV is usually going to size the frameset to the sizePar in the
    // pci.  For top-level framesets, this is usually the host window size,
    // for nested framesets it's usually the containing frame's size.
    // If a frameset is contained inside a layout rect or iframe (which
    // can be thought of as always having an explicit size that is unaffected
    // by content), then it's up to those layouts to make sure they call
    // into CFrameSetLayout::CalcSize* with pci's sizePar set to their size.

    grfReturn = super::CalcSizeVirtual(pci, psize, NULL);
    if (    grfReturn & (LAYOUT_HRESIZE | LAYOUT_VRESIZE)           // FRAMESET size has changed
        ||  GetDirtyFramePositions()                        )       // Dirtied when the FRAME row/col array changes
    {

        Assert(pci->_smMode == SIZEMODE_NATURAL || pci->_smMode == SIZEMODE_SET);
        CalcPositions(pci, *psize);
        SetDirtyFramePositions(FALSE);
    }

    // Framesets fire OnLayoutComplete when they finish calc'ing inside a context..
    // that would be now.
    if ( pLayoutContext && pLayoutContext != GUL_USEFIRSTLAYOUT )
        GetView()->AddEventTask( pLayoutContext->GetLayoutOwner()->ElementOwner(), DISPID_EVMETH_ONLAYOUTCOMPLETE );

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CFrameSetLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    return grfReturn;
}

//+-------------------------------------------------------------------------
//
//  Method:     CFrameSetLayout::GetManualResizeTravel
//
//  Synopsis:   Search the manual resize records for one
//              that matches a particular edge
//
//--------------------------------------------------------------------------

int CFrameSetLayout::GetManualResizeTravel(BOOL fVerticalTravel, int iEdge)
{
    int i;
    ManualResizeRecord *pmrr = _aryResizeRecords;
    for (i = _aryResizeRecords.Size();
         i > 0;
         i--, pmrr++)
    {
        if (pmrr->fVerticalTravel == fVerticalTravel &&
            pmrr->iEdge == iEdge)
            return pmrr->iTravel;
    }
    return 0;
}

//+-------------------------------------------------------------------------
//
//  Method:     CFrameSetLayout::CancelManualResizeTravel
//
//  Synopsis:   Eliminate the manual resize record for
//              a particular edge
//
//--------------------------------------------------------------------------

BOOL CFrameSetLayout::CancelManualResize(BOOL fVerticalTravel)
{
    BOOL retVal = FALSE;
    int i;
    ManualResizeRecord *pmrr = _aryResizeRecords;
    for (i = _aryResizeRecords.Size();
         i > 0;
         i--, pmrr++)
    {
        if (pmrr->fVerticalTravel == fVerticalTravel)
        {
            if (pmrr->iTravel != 0)
            {
                retVal = TRUE;
                pmrr->iTravel = 0;
            }
        }
    }
    return retVal;
}

#define MIN_RESIZE_SIZE 10

//+---------------------------------------------------------------------------
//
//  Member:     CFrameSetLayout::CalcPositions, public
//
//  Synopsis:   Calculates the positions of all the embedded frames.
//
//  Arguments:  [pci]       -- Pointer to CCalcInfo
//              [sizeSet]   -- Size of the FRAMESET
//
//----------------------------------------------------------------------------

void
CFrameSetLayout::CalcPositions(
    CCalcInfo * pci,
    SIZE        sizeSet)
{
    CSaveCalcInfo   sci(pci);
    int             iFixedWidth; // Pixels used up by percentage or pixel values
    int             iSizeRel;    // Number of pixels for "relative-sized" values
                                 //  This value is the size of "1*". Also used
                                 //  if the sum of percentages and pixels is greater
                                 //  than the total available width.
    int             iSumPercents = 0;   // sum of pixel values from percent unit values

    XorYLoop        dir;
    int             i=0, j=0;

    CDataAry<CUnitValue> *paryValues; // Ptr to array of values parsed in Init2
    CUnitValue *          puv;        // Ptr to current value
    CDataAry<DWORD>       aryPosX(Mt(CFrameSetLayoutCalcPositions_aryPosX_pv));    // Array of X coordinates for frames
    CDataAry<DWORD>       aryPosY(Mt(CFrameSetLayoutCalcPositions_aryPosY_pv));    // Array of Y coordinates for frames
    CDataAry<DWORD>      *paryPos;    // Pointer to current coordinate array
    DWORD                 pos;        // Current position to be stored in array
    int                   cRel;       // Count of "relative-sized" values
    int                   cStar;      // Count of "*"'s (e.g. "2*" is 2)
    int                   iTotal;     // # of pixels representing 100%
    BOOL                  fAdjust;    // If TRUE, the sum of values is not
                                      //  equal to the total width and we must
                                      //  proportionately size-down or up the
                                      //  values
    int                   iFrameSpacing;  // value of the frameSpacing attribute
    int                   iTopDelta=0;    // amount of travel for the top edge
    int                   iLeftDelta=0;   // amount of travel for the left edge

    SIZE                  origSizeSet = sizeSet;     // original sizeSet
    DWORD_PTR             dw = 0;

    AssertSz( ElementOwner()->Tag() == ETAG_FRAMESET, "CFrameSetSiteLayout's owner must be a CFrameSetSite!" );
    CFrameSetSite *       pFSS = FrameSetElement();

    CDispContainer* pDispContainer = DYNCAST(CDispContainer, GetElementDispNode());

    //
    // No need to do anything if we don't have any sites yet.
    // (or if we are in low mem condition and didn't get our dispnode - IE6 18081)
    if (!ContainsChildLayout() || !pDispContainer)
        return;

    {
        // Reduce the amount of space available to dole out (sizeSet) by our own
        // border size.
        CBorderInfo borderInfo;

        if (FrameSetElement()->GetBorderInfo(pci, &borderInfo, FALSE, FALSE))
        {
            sizeSet.cx -= borderInfo.aiWidths[SIDE_RIGHT] + borderInfo.aiWidths[SIDE_LEFT];
            sizeSet.cy -= borderInfo.aiWidths[SIDE_TOP] + borderInfo.aiWidths[SIDE_BOTTOM];
        }

        // Now reduce the sizeSet by the amount of space to be taken up by
        // the framespacing.  This will cause the contained sites to be
        // positioned incorrectly (but with the right size!) -- this will get
        // fixed up when we actually tell the sites where they're positioned.
        iFrameSpacing = FrameSetElement()->GetFrameSpacing();
        if (iFrameSpacing > min(sizeSet.cx, sizeSet.cy))
           iFrameSpacing = min(sizeSet.cx, sizeSet.cy);

        if (FrameSetElement()->_aryCols.Size() > 1)
            sizeSet.cx -= iFrameSpacing * (FrameSetElement()->_aryCols.Size() - 1);
        if (FrameSetElement()->_aryRows.Size() > 1)
            sizeSet.cy -= iFrameSpacing * (FrameSetElement()->_aryRows.Size() - 1);
    }

    {
        // Now adjust the sizeSet by the amount of travel of the
        // top/left/bottom/right edges.  This amount will be reversed
        // later, after the distribution of space to the contained sites.
        // This can only happen when the frameset is nested within another
        // frameset which has moved one of our edges.

        int j;
        ManualResizeRecord *pmrr = _aryResizeRecords;
        for (j = _aryResizeRecords.Size();
             j > 0;
             j--, pmrr++)
        {
            if (pmrr->iEdge == 0 )
            {
                if (pmrr->fVerticalTravel)
                {
                    iTopDelta = pmrr->iTravel;
                    sizeSet.cy += iTopDelta;
                }
                else
                {
                    iLeftDelta = pmrr->iTravel;
                    sizeSet.cx += iLeftDelta;
                }
            }
            else if (pmrr->iEdge == pFSS->_iNumActualRows && pmrr->fVerticalTravel)
                sizeSet.cy -= pmrr->iTravel;
            else if (pmrr->iEdge == pFSS->_iNumActualCols && !pmrr->fVerticalTravel)
                sizeSet.cx -= pmrr->iTravel;
        }
    }

    for (dir  = XDirection;
         dir != Terminate;
         dir  = ((dir==XDirection) ? YDirection : Terminate))
    {
        if (dir == XDirection)
        {
            paryValues = &(FrameSetElement()->_aryCols);
            paryPos    = &aryPosX;
            iTotal     = sizeSet.cx;
            pos        = 0;
        }
        else
        {
            paryValues = &(FrameSetElement()->_aryRows);
            paryPos    = &aryPosY;
            iTotal     = sizeSet.cy;
            pos        = 0;
        }

        iFixedWidth = 0;
        cRel        = 0;
        cStar       = 0;

        // Store the starting x or y position as the first element in the
        //  coordinate array.
        paryPos->AppendIndirect(&pos);

        // No need to do a bunch of calculations if there's 0 or 1 values
        if (paryValues->Size() <= 1)
        {
            iTotal += pos;
            paryPos->AppendIndirect((DWORD*)&iTotal);
            continue;
        }

        //
        // Compute the amount of space taken up by "fixed-sized" values
        // (percent or pixel values), and also the number of "relative-sized"
        // values that we must divide the remaining space between.
        //
        for (i=paryValues->Size(), puv = *paryValues;
             i > 0;
             i--, puv++)
        {
            if (puv->GetUnitType() == CUnitValue::UNIT_TIMESRELATIVE)
            {
                cStar += puv->GetTimesRelative();
                cRel++;
            }
            else
            {
                long iPixel = puv->GetPixelValue(
                                        pci,
                                        ((dir == XDirection)
                                            ? CUnitValue::DIRECTION_CX
                                            : CUnitValue::DIRECTION_CY),
                                        iTotal);
                iFixedWidth += iPixel;
                if (puv->GetUnitType() == CUnitValue::UNIT_PERCENT)
                {
                    iSumPercents += iPixel;
                }
            }
        }

        fAdjust = FALSE;

        if (cStar && (iFixedWidth < iTotal))
        {
            // We have relative-sized values, plus some space left over to give
            // them. Compute the size of "1*".
            //
            iSizeRel = (iTotal - iFixedWidth) / cStar;
        }
        else if (iFixedWidth != iTotal && iTotal >= 0)
        {
            // One of the following is true:
            //    - The sum of all "fixed-width" (percents and pixels) values
            //      is greater than our total space. Any relative-sized values
            //      in this case are given a size of zero.
            //    - The sum of all "fixed-width" values is less than our
            //      total available space and there are no "relative-sized"
            //      values.
            //
            // For both these cases, we must shrink or enlarge all regions by
            // a fixed amount to make them fit. iSizeRel is negative if
            // we're shrinking, and positive if we're enlarging.
            //
            Assert(cRel < paryValues->Size());

            iSizeRel = (iTotal - iFixedWidth) / (paryValues->Size() - cRel);
            fAdjust  = TRUE;
        }
        else
        {
            // The total of "fixed-width" values is exactly equal to the
            // window width. Any "relative-sized" values are given a size of
            // zero.
            //
            iSizeRel = 0;
        }

        //
        // Compute actual pixel positions and store them into the aryPos array
        //
        for (j=paryValues->Size(), puv = *paryValues;
             j > 0;
             j--, puv++)
        {
            if (puv->GetUnitType() == CUnitValue::UNIT_TIMESRELATIVE)
            {
                if (!fAdjust)
                {
                    pos += puv->GetPixelValue(
                                     pci,
                                     ((dir == XDirection)
                                       ? CUnitValue::DIRECTION_CX
                                       : CUnitValue::DIRECTION_CY),
                                     iSizeRel);
                }
                // else preserve the previous value of "pos", giving this
                // relative-sized frame a dimension of zero.
            }
            else
            {
                int iPixelValue = puv->GetPixelValue(pci,
                                          ((dir == XDirection)
                                            ? CUnitValue::DIRECTION_CX
                                            : CUnitValue::DIRECTION_CY),
                                          iTotal);
                pos += iPixelValue;
                if (fAdjust)
                {
                    if (puv->GetUnitType() == CUnitValue::UNIT_PERCENT ||
                        iSumPercents == 0)
                    {
                        // iRemainder is the total amount that needs
                        // to be adjusted (added or deleted)
                        long iRemainder = iTotal - iFixedWidth;

                        // our percentage is computed as follows:
                        // if there are > 0 "percentage" frames
                        //     our size divided by the sum of all percentage frames
                        // else
                        //     our size divided by the sum of all fixed width frames

                        long iAdjustment;

                        if (iSumPercents > 0)
                            iAdjustment = (iRemainder * iPixelValue) / iSumPercents;
                        else if (iFixedWidth > 0)
                            iAdjustment = (iRemainder * iPixelValue) / iFixedWidth;
                        else
                        {
                            // We haven't dolled anything out because there
                            // aren't any times-relative or fixed width.
                            // So, let's pretend that each of the "zeros"
                            // are divided evenly.
                            iAdjustment = iTotal / paryValues->Size();
                        }

                        pos += iAdjustment;
                    }
                }
            }

            paryPos->AppendIndirect(&pos);
        }
    }

    i = j = 0;

    //
    // Tweak the far-right and bottom pixel values to account for rounding
    // error by just setting them to the right and bottom of our rect.
    aryPosX[aryPosX.Size()-1] = sizeSet.cx;
    aryPosY[aryPosY.Size()-1] = sizeSet.cy;

    CDispNode * pDispNodeSibling = NULL;
    CDispNode * pDispNode;
    CPoint      pt;
    SIZE        size;

    i = -1;

    // Iterate through all contained sites and re-size all (if this site re-sized)
    // or those which requested re-sizing (themselves or a descendent)

    for (CLayout * pLayout = GetFirstLayout(&dw, FALSE, FALSE), *pPrevLayout = NULL;
        pLayout;
        pPrevLayout = pLayout, pLayout = GetNextLayout(&dw, FALSE, FALSE))
    {

        if (pLayout->ElementOwner()->_etag != ETAG_FRAME &&
            pLayout->ElementOwner()->_etag != ETAG_FRAMESET)
        {
            pLayout->SetYProposed(0);
            pLayout->SetXProposed(0);
            continue;
        }

        i++;
        if (i >= aryPosX.Size() - 1)
        {
            j++;
            i = 0;
        }

        if (j >= aryPosY.Size()-1)
        {
            // There's more <FRAME> tags than they gave values for.
            // Put it at (0,0) with zero width and height.
            pLayout->SetYProposed(0);
            pLayout->SetXProposed(0);
            size = g_Zero.size;
            pt   = g_Zero.pt;
        }
        else
        {
            Assert(i < aryPosX.Size()-1);

            pLayout->SetXProposed(aryPosX[i]);
            pLayout->SetYProposed(aryPosY[j]);
            size.cx = aryPosX[i+1] - pLayout->GetXProposed();
            size.cy = aryPosY[j+1] - pLayout->GetYProposed();


            // adjusted the origin for pLayout based on the amount
            // we reduced sizeSet above to compensate for frameSpacing
            pLayout->SetXProposed(pLayout->GetXProposed() + (i * iFrameSpacing));
            pLayout->SetYProposed(pLayout->GetYProposed() + (j * iFrameSpacing));
            pt.x = aryPosX[i] + (i * iFrameSpacing);
            pt.y = aryPosY[j] + (j * iFrameSpacing);
            {
                // Adjust the proposed pt and size for the current
                // size based on the manual resize records.  This
                // adjustment corresponds to the adjustment to the
                // sizeSet made up top.

                int iTravel;
                iTravel = GetManualResizeTravel(FALSE, i);
                if (iTravel != 0)
                {
                    // moving the left edge
                    pLayout->SetXProposed(pLayout->GetXProposed() + iTravel);
                    pt.x    += iTravel;
                    size.cx -= iTravel;
                }

                iTravel = GetManualResizeTravel(FALSE, i+1);
                if (iTravel != 0)
                {
                    // moving the right edge
                    size.cx += iTravel;
                }

                iTravel = GetManualResizeTravel(TRUE, j);
                if (iTravel != 0)
                {
                    // moving the top edge
                    pLayout->SetYProposed(pLayout->GetYProposed() + iTravel);
                    pt.y    += iTravel;
                    size.cy -= iTravel;
                }

                iTravel = GetManualResizeTravel(TRUE, j+1);
                if (iTravel != 0)
                {
                    // moving the bottom edge
                    size.cy += iTravel;
                }
                // if the top/left edge moved then we need
                // to shift things over by the amount they
                // moved.  this isn't a problem if the right/bottom
                // edges moved
                pLayout->SetYProposed(pLayout->GetYProposed() - iTopDelta);
                pLayout->SetXProposed(pLayout->GetXProposed() - iLeftDelta);
                pt.x -= iLeftDelta;
                pt.y -= iTopDelta;
                if (size.cx < 0 || size.cy < 0)
                {
                    // Check to see if we went negative.  This can
                    // happen if the user resized a frame to be small
                    // and then made the window smaller.
                    // For now just toss the resize info and recurse.
                    // It's possible we could do better.

                    if ( CancelManualResize(FALSE) || // cancelling horizontal
                         CancelManualResize(TRUE) )   // cancelling vertical
                    {
                        CalcPositions(pci, origSizeSet);
                        goto Cleanup;
                    }
#if !defined(WIN16) && !defined(WINCE) && DBG == 1
                    else
                    {
                        TCHAR buffer[100];
                        if (GetEnvironmentVariable(_T("NegativeFrameSizeDebug"),
                                                   buffer,
                                                   sizeof(buffer)/sizeof(buffer[0])))
                            DebugBreak();
                        TraceTag((tagWarning,
                                 "computed negative size for frame"));
                    }
#endif // !defined(WIN16) && !defined(WINCE)
                }
            }
        }

        pci->SizeToParent(&size);
        pLayout->CalcSize(pci, &size);
        pLayout->SetPosition(pt);

        pDispNode = pLayout->GetElementDispNode();

        if (pDispNode)
        {
            if (pDispNodeSibling)
            {
                if (pDispNodeSibling->GetNextSiblingNode() != pDispNode)
                {
                    GetView()->ExtractDispNode(pDispNode);
                    pDispNodeSibling->InsertSiblingNode(pDispNode, CDispNode::after);
                }
            }
            else
            {
                if (pDispContainer->GetFirstChildNode() != pDispNode)
                {
                    GetView()->ExtractDispNode(pDispNode);
                    DYNCAST(CDispContainer, GetElementDispNode())->InsertFirstChildInFlow(pDispNode);
                }
            }

            pDispNodeSibling = pDispNode;
        }
    }

    pFSS->_iNumActualRows = j+1;
    pFSS->_iNumActualCols = i+1;

Cleanup:
    ClearLayoutIterator(dw, FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     CFrameSetLayout::MaxTravelForEdge
//
//  Synopsis:   Determine the maximum travel for a resize of a particular
//              edge.  This requires us to look at the contained sites and,
//              if a contained site is a frameset we must recurse.
//
//-------------------------------------------------------------------------

BOOL CFrameSetLayout::MaxTravelForEdge(int iEdge, BOOL fVerticalTravel,
                                     int *pMinTravel, int *pMaxTravel)
{
    int iMaxTravel = INT_MAX;
    int iMinTravel = INT_MIN;

    int iHorz    = 0;
    int iVert    = 0;

    DWORD_PTR dw;

    for (CLayout *pLayout = GetFirstLayout(&dw, FALSE);
         pLayout;
         pLayout = GetNextLayout(&dw, FALSE))
    {
        CFrameSetLayout *pfss;
        CSize           size;

        pLayout->GetApparentSize(&size);

        switch (pLayout->ElementOwner()->_etag)
        {
        case ETAG_FRAMESET:
            pfss = DYNCAST(CFrameSetLayout, pLayout);
            break;

        case ETAG_FRAME:
            pfss = NULL;
            break;

        default:
            continue;
        }

        if (fVerticalTravel)
        {
            if (iVert == iEdge-1)
            {
                // motion limited upward by pLayout
                if (pfss)
                {
                    int iMin, iMax;
                    if (!pfss->MaxTravelForEdge(pfss->FrameSetElement()->_iNumActualRows,
                                                fVerticalTravel,
                                                &iMin,
                                                &iMax))
                        goto Retfalse;
                    iMinTravel = max(iMinTravel, iMin);
                }
                else
                {
                    if (DYNCAST(CFrameSite, pLayout->ElementOwner())->NoResize())
                        goto Retfalse;
                    iMinTravel = max(iMinTravel,
                                     min(0, (INT) -size.cy + MIN_RESIZE_SIZE));
                }
            }
            else if (iVert == iEdge)
            {
                // motion limited downward by pLayout
                if (pfss)
                {
                    int iMin, iMax;
                    if (!pfss->MaxTravelForEdge(0, fVerticalTravel,
                                           &iMin, &iMax))
                        goto Retfalse;
                    iMaxTravel = min(iMaxTravel, iMax);
                }
                else
                {
                    if (DYNCAST(CFrameSite, pLayout->ElementOwner())->NoResize())
                        goto Retfalse;
                    iMaxTravel = min(iMaxTravel,
                                     max(0, (INT) size.cy - MIN_RESIZE_SIZE));
                }
            }
        }
        else
        {
            if (iHorz == iEdge-1)
            {
                // motion limited to the left by pLayout
                if (pfss)
                {
                    int iMin, iMax;
                    if (!pfss->MaxTravelForEdge(pfss->FrameSetElement()->_iNumActualCols,
                                           fVerticalTravel,
                                           &iMin,
                                           &iMax))
                        goto Retfalse;
                    iMinTravel = max(iMinTravel, iMin);
                }
                else
                {
                    if (DYNCAST(CFrameSite, pLayout->ElementOwner())->NoResize())
                        goto Retfalse;
                    iMinTravel = max(iMinTravel,
                                     min(0, (INT) -size.cx + MIN_RESIZE_SIZE));
                }
            }
            else if (iHorz == iEdge)
            {
                // motion limited to the right by pLayout
                if (pfss)
                {
                    int iMin, iMax;
                    if (!pfss->MaxTravelForEdge(0, fVerticalTravel,
                                           &iMin, &iMax))
                        goto Retfalse;
                    iMaxTravel = min(iMaxTravel, iMax);
                }
                else
                {
                    if (DYNCAST(CFrameSite, pLayout->ElementOwner())->NoResize())
                        goto Retfalse;
                    iMaxTravel = min(iMaxTravel,
                                     max(0, (INT) size.cx - MIN_RESIZE_SIZE));
                }
            }
        }
        if (++iHorz == FrameSetElement()->_iNumActualCols)
        {
            iHorz = 0;
            iVert++;
        }
    }
    ClearLayoutIterator(dw, FALSE);
    if (pMaxTravel)
        *pMaxTravel = iMaxTravel;
    if (pMinTravel)
        *pMinTravel = iMinTravel;
    return TRUE;
    
Retfalse:
    ClearLayoutIterator(dw, FALSE);
    return FALSE;
}


//+------------------------------------------------------------------------
//
//  Member:     CFrameSetLayout::GetResizeInfo
//
//  Synopsis:   Record information about where the user clicked so that
//              subsequent mouse moves can do the appropriate resizing
//
//-------------------------------------------------------------------------

BOOL CFrameSetLayout::GetResizeInfo(POINT pt, FrameResizeInfo *pFRI)
{
    DWORD_PTR   dw;
    BOOL        retVal   = FALSE;
    CLayout    *pPrev    = NULL;
    CLayout    *pLayout  = GetFirstLayout(&dw, FALSE);
    int         iHorz    = 0;
    int         iVert    = 0;

    pFRI->vertical.iEdge = pFRI->horizontal.iEdge = -1;

    while (pLayout) {

        if (pLayout->ElementOwner()->_etag != ETAG_FRAMESET &&
            pLayout->ElementOwner()->_etag != ETAG_FRAME)
            goto next;

        if (pPrev)
        {
            CRect   rcPrev;
            CRect   rcCurr;

            pPrev->GetRect(&rcPrev, COORDSYS_GLOBAL);
            pLayout->GetRect(&rcCurr, COORDSYS_GLOBAL);
            InflateRect(&rcPrev, -2, -2);
            InflateRect(&rcCurr, -2, -2);

            //TODO (lmollico): Is -2 the size of the border?

            if (rcPrev.top == rcCurr.top)
            {
                // checking horizinally at this point
                iHorz++;
                if (pFRI->horizontal.iEdge == -1) // once is enough
                {
                    if (pt.x >= rcPrev.right && pt.x <= rcCurr.left)
                    {
                        if (MaxTravelForEdge(iHorz,
                                             FALSE,
                                             &pFRI->horizontal.iMinTravel,
                                             &pFRI->horizontal.iMaxTravel))
                        {
                            pFRI->horizontal.iEdge = iHorz;
                            pFRI->horizontal.rcEdge.top    = rcPrev.top;
                            pFRI->horizontal.rcEdge.left   = rcPrev.right;
                            pFRI->horizontal.rcEdge.right  = rcCurr.left;
                            pFRI->horizontal.rcEdge.bottom = rcCurr.bottom;
                          //  InflateRect(&pFRI->horizontal.rcEdge, -2, 0);
                            retVal = TRUE;
                        }
                    }
                }
            }
            else
            {
                // checking vertically at this point
                iHorz = 0;
                iVert++;
                if (pFRI->vertical.iEdge == -1) // once is enough
                {
                    if (pt.y >= rcPrev.bottom && pt.y <= rcCurr.top)
                    {
                        if (MaxTravelForEdge(iVert,
                                             TRUE,
                                             &pFRI->vertical.iMinTravel,
                                             &pFRI->vertical.iMaxTravel))
                        {
                            pFRI->vertical.iEdge = iVert;
                            pFRI->vertical.rcEdge.top    = rcPrev.bottom;
                            pFRI->vertical.rcEdge.left   = rcPrev.left;
                            pFRI->vertical.rcEdge.right  = rcCurr.right;
                            pFRI->vertical.rcEdge.bottom = rcCurr.top;
                            //InflateRect(&pFRI->vertical.rcEdge, 0, -2);
                            retVal = TRUE;
                        }
                    }
                }
            }
//#define MULTI_DIRECTIONAL_RESIZING
#ifndef MULTI_DIRECTIONAL_RESIZING
            if (retVal)
                goto Cleanup;
#endif
        }
        pPrev = pLayout;

    next:

        pLayout = GetNextLayout(&dw, FALSE);

    }
Cleanup:
    ClearLayoutIterator(dw, FALSE);
    return retVal;
}

//+--------------------------------------------------------------
//
//  Member:     CFrameSetLayout::Resize
//
//  Synopsis:   Resizes the contained sites based on a
//              ManualResizeRecord
//
//---------------------------------------------------------------

void CFrameSetLayout::Resize(const ManualResizeRecord *pmr)
{
    // Process, as follows:
    // (1) if we've moved this edge before, then merge this into the previous
    // (2) record this ManualResize object to be used in CalcPositions
    // (3) determine whether the edge in question borders another FrameSet
    //     and if so, propagate this change down to it
    // (4) in CalcPositions()
    //    a. take the SizeSet and adjust it according to those edge
    //       MR's which effect the left/right/top/bottom edges only
    //    b. proceed as normal, allocating the space to the children
    //    c. process the recorded MR's as follows:
    //         abuts the edge being processed.  note that this may not
    //       - adjust the size/position of all children whose rect
    //         be totally possible if things have shrunk due to the window
    //         having been made smaller (what to do?)

    ManualResizeRecord mr = *pmr;
    if (mr.iEdge == -1)
        mr.iEdge = mr.fVerticalTravel ? FrameSetElement()->_iNumActualRows : FrameSetElement()->_iNumActualCols;

    int i = _aryResizeRecords.Size();
    ManualResizeRecord *pMRList = _aryResizeRecords;
    while (--i >= 0)
    {
        if (pMRList->iEdge == mr.iEdge && pMRList->fVerticalTravel == mr.fVerticalTravel)
        {
            pMRList->iTravel += mr.iTravel;
            break;
        }
        pMRList++;
    }
    if (i == -1)
    {
        _aryResizeRecords.AppendIndirect(&mr);
    }

    DWORD_PTR dw;
    CLayout *pLayout = GetFirstLayout(&dw, FALSE);
    int iHorz = 0;
    int iVert = 0;

    while (pLayout)
    {
        CFrameSetLayout *pfss;

        switch (pLayout->ElementOwner()->_etag)
        {
        case ETAG_FRAMESET:
            pfss = DYNCAST(CFrameSetLayout, pLayout);
            break;

        case ETAG_FRAME:
            pfss = NULL;
            break;

        default:
            goto next;
        }

        if (pfss)
        {
            BOOL fDoit = FALSE;
            ManualResizeRecord mrTmp;
            if ( (mr.iEdge == iVert &&  mr.fVerticalTravel) ||
                 (mr.iEdge == iHorz && !mr.fVerticalTravel) )
            {
                mrTmp = mr;
                mrTmp.iEdge = 0;
                fDoit = TRUE;
            }
            else if ( (mr.iEdge-1 == iVert &&  mr.fVerticalTravel) ||
                      (mr.iEdge-1 == iHorz && !mr.fVerticalTravel) )
            {
                mrTmp = mr;
                mrTmp.iEdge = -1;
                fDoit = TRUE;
            }
            if (fDoit)
            {
                pfss->Resize(&mrTmp);  // recurse
            }
        }
        if (++iHorz == FrameSetElement()->_iNumActualCols)
        {
            iHorz = 0;
            iVert++;
        }

    next:

        pLayout = GetNextLayout(&dw, FALSE);
    }

    ClearLayoutIterator(dw, FALSE);

    SetDirtyFramePositions(TRUE);
    ElementOwner()->ResizeElement();
}


//+--------------------------------------------------------------
//
//  Function:   ResizeWndProc
//
//  Synopsis:   Window proc for the window which is displayed
//              during frame resizing
//
//---------------------------------------------------------------

LRESULT CALLBACK
ResizeWndProc(HWND hwnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
    switch(msg)
    {
    case WM_PAINT:
        {
            HBRUSH hbr = (HBRUSH)GetWindowLongPtr(hwnd, GWLP_USERDATA);
            PAINTSTRUCT ps;
            BeginPaint(hwnd, &ps);
            FillRect(ps.hdc, &ps.rcPaint, hbr);
            EndPaint(hwnd, &ps);
        }
    }
    return DefWindowProc(hwnd, msg, wParam, lParam);
}

//+--------------------------------------------------------------
//
//  Function:   CreateDitherBrush
//
//  Synopsis:   Used for drawing the resize bar
//
//  Notes:      stolen from ie3 which stole it from comctl132
//
//+--------------------------------------------------------------

static HBRUSH CreateDitherBrush(void)
{
    HBRUSH  hbrDitherBrush = NULL;
    HBITMAP hbmTemp;
    static WORD graybits[] = {0xAAAA, 0x5555, 0xAAAA, 0x5555, 0xAAAA, 0x5555, 0xAAAA, 0x5555};

    // build the dither brush.  this is a fixed 8x8 bitmap
    hbmTemp = CreateBitmap(8, 8, 1, 1, graybits);
    if (hbmTemp)
    {
        // now use the bitmap for what it was really intended...
        hbrDitherBrush = CreatePatternBrush(hbmTemp);
        DeleteObject(hbmTemp);
    }

    return( hbrDitherBrush );
}

void
CFrameSetLayout::AdjustFrameSize(CDataAry<CUnitValue> * paryValues,
                                 CDataAry<long> *       paryPos,
                                 long                   lSum)
{
    Assert(paryValues->Size() >= paryPos->Size()); 

    for (int i = 0; i < paryValues->Size(); i++)
    {
        CUnitValue::UNITVALUETYPE uvType = (*paryValues)[i].GetUnitType();
    
        if (uvType == CUnitValue::UNIT_PERCENT || uvType == CUnitValue::UNIT_TIMESRELATIVE)
        {
            (*paryValues)[i].SetPercent(MulDivQuick((*paryPos)[i], 100, lSum));
        }
        else
        {
            (*paryValues)[i].SetValue((*paryPos)[i], CUnitValue::UNIT_PIXELS);
        }
    }

}

void
CFrameSetLayout::CalcRowsCols(int iVerticalEdge, int iHorizontalEdge)
{
    HRESULT                 hr;
    DWORD_PTR               dw = 0;
    CLayout *               pLayout;
    CSize                   size;
    CFrameSetSite *         pFrameSetElement = FrameSetElement();
    CDataAry<long>          aryPosX(Mt(CFrameSetLayoutCalcPositions_aryPosX_pv));
    CDataAry<long>          aryPosY(Mt(CFrameSetLayoutCalcPositions_aryPosY_pv));
    CDataAry<long> *        paryPos;
    CDataAry<CUnitValue> *  paryValues;
    CUnitValue *            puv;
    long                    lSumX = 0;
    long                    lSumY = 0;
    long                    lSum;
    int                     i;
    XorYLoop                dir;
    TCHAR                   ach[256];
    int                     iEdge;

    if (pFrameSetElement->GetAAcols() && pFrameSetElement->GetAArows()) // (lmollico): not supported yet
        goto Cleanup;

    for (pLayout = GetFirstLayout(&dw); pLayout; pLayout = GetNextLayout(&dw))
    {
        pLayout->GetSize(&size);
        aryPosX.AppendIndirect(&size.cx);
        aryPosY.AppendIndirect(&size.cy);
        lSumX += size.cx;
        lSumY += size.cy;
    }

    for (dir  = XDirection;
         dir != Terminate;
         dir  = ((dir==XDirection) ? YDirection : Terminate))
    {
        CStr cstrRowsCols;

        if (dir == XDirection)
        {
            paryValues = &pFrameSetElement->_aryColsResize;
            paryPos = &aryPosX;
            lSum = lSumX;
            iEdge = iHorizontalEdge;
        }
        else
        {
            paryValues = &pFrameSetElement->_aryRowsResize;
            paryPos = &aryPosY;
            lSum = lSumY;
            iEdge = iVerticalEdge;
        }

        if (iEdge == -1)
            continue;

/* (dmitryt) If we move bar between to 'n*'-sized frames, why shouldn't we 
             convert both of them into percent-sized? If we only do it with the first,
             then the 'n*'-sized neighbour should be raclculated to reflect
             updated width available to all 'n*'-sized to share...

             Now, we only update sizes of frames adjacent to a bar that user is dragging.
             We don't recalc all frames to re-distribute width between them.
             So we have to convert both adjacent frames to non-automatic (non 'n*'-sized)
             to be visually consistent.

             IE6 bug 16127

        if (    (*paryValues)[iEdge - 1].GetUnitType() == CUnitValue::UNIT_TIMESRELATIVE
            &&  (*paryValues)[iEdge    ].GetUnitType() == CUnitValue::UNIT_TIMESRELATIVE)
        {
            AdjustFrameSize(paryValues, iEdge - 1, iEdge - 1, paryPos, lSum);
        }
        else
*/        
        if (iEdge < paryValues->Size())
            AdjustFrameSize(paryValues, paryPos, lSum);

        for (i = paryValues->Size(), puv = *paryValues;
             i > 0;
             i--, puv++)
        {
            if (cstrRowsCols.Length())
            {
                hr = cstrRowsCols.Append(_T(","));
                if (hr)
                    goto Cleanup;
            }

            if (puv->GetUnitType() == CUnitValue::UNIT_TIMESRELATIVE)
            {
                hr = cstrRowsCols.Append(_T("*"));
                if (hr)
                    goto Cleanup;
            }
            else
            {
                if (puv->GetUnitType() == CUnitValue::UNIT_PERCENT)
                    hr = Format(0, ach, ARRAY_SIZE(ach), _T("<0d>%"), puv->GetPercent());
                else
                    hr = Format(0, ach, ARRAY_SIZE(ach), _T("<0d>"), puv->GetPixelValue());
                if (hr)
                    goto Cleanup;

                hr = cstrRowsCols.Append(ach);
                if (hr)
                    goto Cleanup;
            }
        }

        if (dir == XDirection)
            hr = pFrameSetElement->SetAAcols(cstrRowsCols);
        else
            hr = pFrameSetElement->SetAArows(cstrRowsCols);
        if (hr)
            goto Cleanup;
    }

    Doc()->_lDirtyVersion = MAXLONG;

Cleanup:
    ClearLayoutIterator(dw, FALSE);
}

//+--------------------------------------------------------------
//
//  Member:     CFrameSetLayout::HandleMessage
//
//  Synopsis:   Handle the resizing of frames.  Otherwise, pass
//              it to super.
//
//  Notes:      This method uses a number of static variables
//              making it non-thread-safe.  Presumably this won't
//              be an issue since there's only one mouse.
//
//---------------------------------------------------------------

HRESULT BUGCALL
CFrameSetLayout::HandleMessage(CMessage * pMessage)
{
    static FrameResizeInfo s_fri;
    static BOOL s_fResizing = FALSE;
    static POINT s_ptMouseDown;
    static POINT s_ptPrevious;
    static POINT s_ptOrigin;
    static SIZE  s_size;
    static HBRUSH s_hbrOld;
    static HDC s_hdcScreen;
    HRESULT  hr = S_FALSE;

    BOOL fDynamicResize = FALSE;
#ifndef WINCE
    SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0, &fDynamicResize, 0);
#endif // WINCE

    switch (pMessage->message)
    {
        case WM_LBUTTONDOWN:
            if (GetResizeInfo(pMessage->pt, &s_fri))
            {
                FrameSetElement()->TakeCapture(TRUE);
                s_fResizing = TRUE;
                // hang on to this so we know
                // how far we've moved
                s_ptPrevious = s_ptMouseDown = pMessage->pt;

                if (!fDynamicResize)
                {
                    // compute the position, in screen coordinates, of the
                    // resize bar.  then draw it.  subsequent 'move' events
                    // will cause the previous location to be inverted
                    // and the new location to be redrawn (inverted)

                    RECT rc = s_fri.vertical.iEdge == -1 ? s_fri.horizontal.rcEdge
                                                     : s_fri.vertical  .rcEdge;
                    s_ptOrigin.x = rc.left;
                    s_ptOrigin.y = rc.top;
                    s_size.cx  = rc.right - rc.left;
                    s_size.cy  = rc.bottom - rc.top;

                    ClientToScreen(Doc()->_pInPlace->_hwnd, &s_ptOrigin);
                    s_hdcScreen = ::GetDC(NULL);
                    s_hbrOld = (HBRUSH)SelectObject(s_hdcScreen, CreateDitherBrush());
                    if (s_hbrOld)
                    {
                        PatBlt(s_hdcScreen, s_ptOrigin.x,
                               s_ptOrigin.y,
                               s_size.cx,
                               s_size.cy,
                               PATINVERT);
                    }
                    else
                        hr = E_FAIL;
                }
                hr = S_OK;
            }
            break;

        case WM_LBUTTONUP:
        case WM_KILLFOCUS:
            if (s_fResizing)
            {
                if (!fDynamicResize)
                {
                    // undo the last inversion
                    if (s_hbrOld)
                    {
                        PatBlt(s_hdcScreen, s_ptOrigin.x,
                               s_ptOrigin.y,
                               s_size.cx,
                               s_size.cy,
                               PATINVERT);

                        // put back the old brush and delete the current,
                        // temporary, one
                        DeleteObject(SelectObject(s_hdcScreen, s_hbrOld));
                    }

                    if (s_fri.vertical.iEdge != -1)
                    {
                        FrameResizeInfo1 *frr1 = &s_fri.vertical;

                        int iTravel = pMessage->pt.y - s_ptMouseDown.y;
                        iTravel = min(iTravel, frr1->iMaxTravel);
                        iTravel = max(iTravel, frr1->iMinTravel);

                        ManualResizeRecord mrr = { (SHORT)iTravel, (SHORT)frr1->iEdge, TRUE };
                        Resize(&mrr);
                    }
                    if (s_fri.horizontal.iEdge != -1)
                    {
                        FrameResizeInfo1 *frr1 = &s_fri.horizontal;

                        int iTravel = pMessage->pt.x - s_ptMouseDown.x;
                        iTravel = min(iTravel, frr1->iMaxTravel);
                        iTravel = max(iTravel, frr1->iMinTravel);

                        ManualResizeRecord mrr = { (SHORT)iTravel, (SHORT)frr1->iEdge, FALSE };
                        Resize(&mrr);
                    }

                    FrameSetElement()->WaitForRecalc();
                }

                FrameSetElement()->TakeCapture(FALSE);

                s_fResizing = FALSE;
                // allow WM_KILLFOCUS to bubble up to the root
                if (pMessage->message != WM_KILLFOCUS)
                {
                    hr = S_OK;
                }

                CalcRowsCols(s_fri.vertical.iEdge, s_fri.horizontal.iEdge);
            }
            break;

        case WM_SETCURSOR:
            if (!s_fResizing)
            {
                if (GetResizeInfo(pMessage->pt, &s_fri))
                {
                    LPCTSTR idcResize = NULL;
                    if (   s_fri.vertical.iEdge != -1
                        && s_fri.horizontal.iEdge != -1)
                        idcResize = IDC_SIZEALL;
                    else if ( s_fri.vertical.iEdge != -1 )
                        idcResize = IDC_SIZENS;
                    else if ( s_fri.horizontal.iEdge != -1 )
                        idcResize = IDC_SIZEWE;

                    FrameSetElement()->SetCursorStyle(idcResize);
                }
                else
                {
                    FrameSetElement()->SetCursorStyle(IDC_ARROW);
                }
            }
            hr = S_OK;
            break;

#ifndef WIN16
        case WM_MOUSEWHEEL:
            {
                CLayout *   pLayout;
                DWORD_PTR   dw;
                CDoc *      pDoc    = Doc();

                // NEWTREE  MonsterWalk should build these site arrays
                //          with branches instead of sites

                for (pLayout = GetFirstLayout(&dw, FALSE); pLayout;
                                pLayout = GetNextLayout(&dw, FALSE))
                {   
                    // Two cases:
                    //
                    // 1) _pElemCurrent is _pSiteRoot or the current frameset site,
                    //    in this case, need to check all child sites, be it
                    //    CFrameSetSite or CFrameElement.
                    // 2) _pElemCurrent is one of the child site, HandleMessage is
                    //    called up through the parent chain from _pElemCurrent, no
                    //    need to pass down to _pElemCurrent again to avoid
                    //    potential infinite call chain.
                    //
                    if (pLayout->ElementOwner() != pDoc->_pElemCurrent)
                    {
                        // Call HandleMessage directly because we do not bubbling here
                        hr = THR(pLayout->ElementOwner()->HandleMessage(pMessage));
                        if (hr != S_FALSE)
                            break;
                    }
                }
                ClearLayoutIterator(dw, FALSE);
            }
            break;
#endif // ndef WIN16

        case WM_MOUSEMOVE:
            if (s_fResizing)
            {
				// the following code causes the screen resize/update to
                // occur during the mouse drag operation rather than at
                // the mouse up.

                if (!fDynamicResize)
                    PatBlt(s_hdcScreen, s_ptOrigin.x,
                                        s_ptOrigin.y,
                                        s_size.cx,
                                        s_size.cy,
                                        PATINVERT);

                POINT pt = pMessage->pt;
                if (s_fri.vertical.iEdge != -1)
                {
                    FrameResizeInfo1 *frr1 = &s_fri.vertical;

                    pt.y = min((LONG)pt.y, (LONG)(s_ptMouseDown.y + frr1->iMaxTravel));
                    pt.y = max((LONG)pt.y, (LONG)(s_ptMouseDown.y + frr1->iMinTravel));

                    s_ptOrigin.y += pt.y - s_ptPrevious.y;

                    if (fDynamicResize)
                    {
                        ManualResizeRecord mrr = { (SHORT)(pt.y - s_ptPrevious.y),
                                                   (SHORT)(frr1->iEdge),
                                                   TRUE };
                        Resize(&mrr);
                    }
                }
                if (s_fri.horizontal.iEdge != -1)
                {
                    FrameResizeInfo1 *frr1 = &s_fri.horizontal;

                    pt.x = min((LONG)pt.x, (LONG)(s_ptMouseDown.x + frr1->iMaxTravel));
                    pt.x = max((LONG)pt.x, (LONG)(s_ptMouseDown.x + frr1->iMinTravel));

                    s_ptOrigin.x += pt.x - s_ptPrevious.x;

                    if (fDynamicResize)
                    {
                        ManualResizeRecord mrr = { (SHORT)(pt.x - s_ptPrevious.x),
                                                   (SHORT)(frr1->iEdge),
                                                   FALSE };
                        Resize(&mrr);
                    }
                }
                s_ptPrevious = pt;

                if (!fDynamicResize)
                {
                    PatBlt(s_hdcScreen, s_ptOrigin.x,
                                        s_ptOrigin.y,
                                        s_size.cx,
                                        s_size.cy,
                                        PATINVERT);
                }
                hr = S_OK;
            }
            break;

    }

    if (hr == S_FALSE)
    {
        hr = THR(super::HandleMessage(pMessage));
    }

    RRETURN1(hr, S_FALSE);
}

int CFrameSetLayout::iPixelFrameHighlightWidth = 0;
int CFrameSetLayout::iPixelFrameHighlightBuffer = 0;

//+----------------------------------------------------------------------------
//
// Member: CheckFrame3DBorder
//
// Synopsis: Based on current 3D border setting b3DBorder, determine which
//           extra 3D border edges are needed for pDoc, which can be a CDoc
//           inside one of the CFrameElement in this CFrameSetLayout
//
//-----------------------------------------------------------------------------
BOOL
CFrameSetLayout::CheckFrame3DBorder(CWindow * pWindow, BYTE b3DBorder)
{
    int  cRows   = max(FrameSetElement()->_aryRows.Size(), 1);
    int  cCols   = max(FrameSetElement()->_aryCols.Size(), 1);
    int  iRow    = 0;
    int  iCol    = 0;
    BOOL fResult = FALSE;

    DWORD_PTR         dw;
    BYTE              b3DBorderCurrent;
    CLayout       *   pLayout;
    CFrameElement *   pFrame;
    CWindow       *   pWindowCurrent;

    CDocInfo          DCIFrameSet(FrameSetElement());
    CBorderInfo       borderinfo;
    int               iBorderWidthMin;

    // need to exclude those 3D border drawn by outmost CFrameSetLayout
    //
    if (    FrameSetElement()->IsInMarkup()
        &&  FrameSetElement() == FrameSetElement()->GetMarkup()->GetElementClient() )
    {
        iBorderWidthMin = 2;
        FrameSetElement()->GetMarkup()->GetCanvasElement()->GetBorderInfo(NULL, &borderinfo, FALSE, FALSE);
    }
    else
    {
        iBorderWidthMin = 0;
        FrameSetElement()->GetBorderInfo(NULL, &borderinfo, FALSE, FALSE);
    }

    // if there is extra border space (top/left/bottom/right) needed for
    // CFrameSetLayout, need to draw 3D border edge for them
    //
    if (borderinfo.aiWidths[SIDE_TOP] > iBorderWidthMin)
    {
        b3DBorder |= NEED3DBORDER_TOP;
    }
    if (borderinfo.aiWidths[SIDE_LEFT] > iBorderWidthMin)
    {
        b3DBorder |= NEED3DBORDER_LEFT;
    }
    if (borderinfo.aiWidths[SIDE_BOTTOM] > iBorderWidthMin)
    {
        b3DBorder |= NEED3DBORDER_BOTTOM;
    }
    if (borderinfo.aiWidths[SIDE_RIGHT] > iBorderWidthMin)
    {
        b3DBorder |= NEED3DBORDER_RIGHT;
    }

    // loop through all CFrameElement and CFrameSetLayout inside current
    // CFrameSetLayout until we find pDoc
    //
    for (pLayout = GetFirstLayout(&dw, FALSE);
            pLayout && !fResult;
            pLayout = GetNextLayout(&dw, FALSE))
    {
        ELEMENT_TAG eTag = (ELEMENT_TAG) pLayout->ElementOwner()->_etag;

        pWindowCurrent = NULL;

        switch (eTag)
        {
        case ETAG_FRAME:
            pFrame = DYNCAST(CFrameElement, pLayout->ElementOwner());
            break;
        case ETAG_FRAMESET:
            pFrame = NULL;
            break;
        default:
            continue;
        }

        if (pFrame)
        {
            pWindowCurrent = pFrame->_pWindow ? pFrame->_pWindow->Window() : NULL;
        }

        if (eTag == ETAG_FRAMESET || pWindow == pWindowCurrent)
        {
            b3DBorderCurrent = b3DBorder;

            // If we are not the first row and there are more than one rows,
            // we should need to draw top 3D border edge
            //
            if ((iRow != 0) && (cRows > 1))
                b3DBorderCurrent |= NEED3DBORDER_TOP;

            // If we are not the last row and there are more than one rows,
            // we should need to draw bottom 3D border edge
            //
            if ((iRow != cRows - 1) && (cRows > 1))
                b3DBorderCurrent |= NEED3DBORDER_BOTTOM;

            // If we are not the first column and there are more than one
            // columns, we should need to draw left 3D border edge
            //
            if ((iCol != 0) && (cCols > 1))
                b3DBorderCurrent |= NEED3DBORDER_LEFT;

            // If we are not the first column and there are more than one
            // columns, we should need to draw right 3D border edge
            //
            if ((iCol != cCols - 1) && (cCols > 1))
                b3DBorderCurrent |= NEED3DBORDER_RIGHT;

            if (eTag == ETAG_FRAMESET)
            {
                // propogate down CFrameSetLayout to see if pDoc is inside there
                //
                fResult = DYNCAST(CFrameSetLayout, pLayout)->CheckFrame3DBorder(pWindow, b3DBorderCurrent);
            }
            else
            {
                CDocInfo DCIFrame(pFrame);

                // if there is extra border space (top/left/bottom/right)
                // needed for CFrameElement, need to draw 3D border edge then
                //
                memset(&borderinfo, 0, sizeof(borderinfo));
                pFrame->GetBorderInfo(&DCIFrame, &borderinfo, FALSE, FALSE);
                if (borderinfo.aiWidths[SIDE_TOP] > 0)
                {
                    b3DBorderCurrent |= NEED3DBORDER_TOP;
                }
                if (borderinfo.aiWidths[SIDE_LEFT] > 0)
                {
                    b3DBorderCurrent |= NEED3DBORDER_LEFT;
                }
                if (borderinfo.aiWidths[SIDE_BOTTOM] > 0)
                {
                    b3DBorderCurrent |= NEED3DBORDER_BOTTOM;
                }
                if (borderinfo.aiWidths[SIDE_RIGHT] > 0)
                {
                    b3DBorderCurrent |= NEED3DBORDER_RIGHT;
                }

                pWindow->_b3DBorder = b3DBorderCurrent;
                fResult          = TRUE;
            }
        }

        iCol ++;
        if (iCol == cCols)
        {
            iCol = 0;
            iRow ++;
        }
    }
    ClearLayoutIterator(dw, FALSE);

    return fResult;
}

//+------------------------------------------------------------------------
//
//  Member:     CFrameSetSite::GetBackgroundInfo
//
//  Synopsis:   Generate the background information for a framesite
//
//-------------------------------------------------------------------------
BOOL
CFrameSetLayout::GetBackgroundInfo(
    CFormDrawInfo *     pDI,
    CBackgroundInfo *   pbginfo,
    BOOL                fAll)
{
    Assert(pDI || !fAll);

    CColorValue ccv = FrameSetElement()->BorderColorAttribute();
    COLORREF    cr;
    CLayout   * pLayout;
    DWORD_PTR   dw;
    CColorValue ccvFrame;
    CDoc      * pDoc = Doc();

    // TODO (JHarding): 
    // There are some cases with merging frame border colors, that
    // Netscape handles and we don't.  Additionally, checks need to be done
    // for existence/color on a border-by-border basis for existence/color,
    // because we can have a case where one frameset has several non-
    // intersecting borders of different colors, widths, and existence.
    //
    // First, do we have a border or not?  If we don't have a border,
    // we shouldn't look for bordercolor attrs on <FRAME>s.
    //
    if (!pDoc->_fFrameBorderCacheValid)
    {
        // we can not assume that this is in the tree at this exact moment.
        // or. more accurately, the doc may have a body, and the frameset is added
        // through the DOM. thus the primaryElementClient may, validly, not be a frameset
        CElement * pElemClient = FrameSetElement()->GetMarkup()->GetElementClient();

        if (pElemClient->Tag() == ETAG_FRAMESET)
        {
            DYNCAST(CFrameSetSite, pElemClient)->FrameBorderAttribute(TRUE, FALSE);
            pDoc->_fFrameBorderCacheValid = TRUE;
        }
    }

    if(FrameSetElement()->IsSeamlessEdit())
    {
        cr = GetSysColorQuick(COLOR_ACTIVECAPTION);
    }
    else if(!FrameSetElement()->_fFrameBorder)
    {
        cr = pDoc->PrimaryRoot()->GetBackgroundColor();
    }
    else
    {
        if(ccv.IsDefined())
        {
            // First, if they gave us a border color, let's use it.
            //
            cr = ccv.GetColorRef();
        }
        else
        {
            // Otherwise, use the 3d button face color so we
            // match the window frame.
            //
            cr = GetSysColorQuick(COLOR_3DFACE);
        }

        // test if one of the frames has borderColor defined. If it is the case,
        // set borderColor to the first defined and use for all borders.
        //
        for (pLayout = GetFirstLayout(&dw, FALSE);
             pLayout;
             pLayout = GetNextLayout(&dw, FALSE))
        {
            if (pLayout->ElementOwner()->_etag == ETAG_FRAME)
            {
                ccvFrame = (DYNCAST(CFrameElement, pLayout->ElementOwner()))->GetAAborderColor();
                if (ccvFrame.IsDefined())
                {
                    cr = ccvFrame.GetColorRef();
                    break;
                }
            }
        }
        ClearLayoutIterator(dw, FALSE);
    }

    super::GetBackgroundInfo(pDI, pbginfo, fAll);
    pbginfo->crBack = cr;

    return TRUE;
}

//+------------------------------------------------------------------------
//
//  Member:     GetFirstLayout
//
//  Synopsis:   Enumeration method to loop thru children (start)
//
//  Arguments:  [pdw]       cookie to be used in further enum
//              [fBack]     go from back
//
//  Returns:    Layout
//
//-------------------------------------------------------------------------
CLayout *
CFrameSetLayout::GetFirstLayout(DWORD_PTR * pdw, BOOL fBack /*=FALSE*/, BOOL fRaw /*=FALSE*/)
{
    if (ElementOwner()->GetFirstBranch())
    {
        CChildIterator *    pLayoutIterator;
        static ELEMENT_TAG   atagStop = ETAG_FRAMESET;
        static ELEMENT_TAG   atagChild[2] = { ETAG_FRAMESET, ETAG_FRAME };
        
        pLayoutIterator = new CChildIterator(
            ElementOwner(),
            NULL,
            CHILDITERATOR_USETAGS,
            &atagStop, 1,
            atagChild, ARRAY_SIZE(atagChild));
        
        *pdw = (DWORD_PTR)pLayoutIterator;
        
        return *pdw == NULL ? NULL : CFrameSetLayout::GetNextLayout(pdw, fBack, fRaw);
    }
    
    // if CFrameSetSite is not in the tree, no need to walk through
    // CChildIterator
    //
    * pdw = 0;
    return NULL;
}


//+------------------------------------------------------------------------
//
//  Member:     GetNextLayout
//
//  Synopsis:   Enumeration method to loop thru children
//
//  Arguments:  [pdw]       cookie to be used in further enum
//              [fBack]     go from back
//
//  Returns:    Layout
//
//-------------------------------------------------------------------------
CLayout *
CFrameSetLayout::GetNextLayout ( DWORD_PTR * pdw, BOOL fBack, BOOL fRaw)
{
    CLayout *           pLayout = NULL;
    CChildIterator *    pLayoutWalker;

    pLayoutWalker = (CChildIterator *) (*pdw);
    if (pLayoutWalker)
    {
        CTreeNode * pNode = fBack ? pLayoutWalker->PreviousChild()
                                : pLayoutWalker->NextChild();
        pLayout = pNode ? pNode->GetUpdatedLayout( LayoutContext() ) : NULL;
    }
    return pLayout;
}


//+---------------------------------------------------------------------------
//
//  Member : ClearLayoutIterator
// 
//----------------------------------------------------------------------------
void
CFrameSetLayout::ClearLayoutIterator(DWORD_PTR dw, BOOL fRaw)
{
    if (!fRaw)
    {
        CChildIterator * pLayoutWalker = (CChildIterator *) dw;
        if (pLayoutWalker)
            delete pLayoutWalker;
    }
}


//+------------------------------------------------------------------------
//
//  Member:     SetZOrder
//
//  Synopsis:   set z order for site
//
//  Arguments:  [pLayout]   set z order for this layout
//              [zorder]    to set
//              [fUpdate]   update windows and invalidate
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CFrameSetLayout::SetZOrder(CLayout * pLayout, LAYOUT_ZORDER zorder, BOOL fUpdate)
{
    HRESULT     hr = S_OK;

    if (fUpdate)
    {
        Doc()->FixZOrder();
        Invalidate();
    }

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CFrameSetLayout::SelectSite
//
//  Synopsis:   Selects the site based on the flags passed in
//
//
//  Arguments:  [pLayout]       -- The layout to select (for parent layouts)
//              [dwFlags]       -- Action flags:
//                  SS_ADDTOSELECTION       add it to the selection
//                  SS_REMOVEFROMSELECTION  remove it from selection
//                  SS_KEEPOLDSELECTION     keep old selection
//                  SS_SETSELECTIONSTATE    set flag according to state
//
//  Returns:    HRESULT
//
//  Notes:      This method will call parent objects or children objects
//              depending on the action and passes the child/parent along
//
//-------------------------------------------------------------------------
HRESULT
CFrameSetLayout::SelectSite(CLayout * pLayout, DWORD dwFlags)
{
    HRESULT hr = S_OK;

    AssertSz(0,"This method doesn't do anything anymore - and will be deleted soon");
    
#ifdef NEVER
    if (pLayout == this && (dwFlags & SS_SETSELECTIONSTATE))
    {
        if (dwFlags & SS_CLEARSELECTION)
        {
            SetSelected(FALSE);
        }
        else if (!ElementOwner()->IsEditable() && GetParentLayout()
                                          && ElementOwner()->IsInMarkup())
        {
            Verify(!GetParentLayout()->SelectSite(this, dwFlags));
        }

        // call state on all children
        {
            DWORD_PTR dw;
            CLayout * pLayout;

            for (pLayout = GetFirstLayout(&dw); pLayout; pLayout = GetNextLayout(&dw))
            {
                Verify(!pLayout->SelectSite(pLayout, dwFlags));
            }
            ClearLayoutIterator(dw, FALSE);
        }
    }
    else
    {
        hr = super::SelectSite(pLayout, dwFlags);
    }
#endif    
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Member:     DoLayout
//
//  Synopsis:   Initiate a re-layout of the table
//
//  Arguments:  grfFlags - LAYOUT_xxxx flags
//
//-----------------------------------------------------------------------------
void
CFrameSetLayout::DoLayout(
    DWORD   grfLayout)
{
    Assert(grfLayout & (LAYOUT_MEASURE | LAYOUT_POSITION | LAYOUT_ADORNERS));

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CFrameSetLayout::DoLayout L(0x%x, %S) grfLayout(0x%x)", this, ElementOwner()->TagName(), grfLayout ));

    //
    //  If the element is not hidden, layout its content
    //

    if (!IsDisplayNone())
    {
        CElement::CLock Lock(ElementOwner(), CElement::ELEMENTLOCK_SIZING);
        CCalcInfo       CI(this);
        CSize           size;

        GetSize(&size);
        CI.SizeToParent(&size);

        CI._grfLayout |= grfLayout;

        //
        //  Layout child FRAMESETs and FRAMEs
        //

        if (grfLayout & LAYOUT_MEASURE)
        {
            // we want to do this each time inorder to
            // properly pick up things like opacity.
            if (_fForceLayout)
            {
                CI._grfLayout |= LAYOUT_FORCE;
            }

            EnsureDispNode(&CI, !!(CI._grfLayout & LAYOUT_FORCE));

            CalcSizeVirtual(&CI, &size, NULL);

            Reset(FALSE);
        }
        _fForceLayout = FALSE;

        //
        //  Process outstanding layout requests (e.g., sizing positioned elements, adding adorners)
        //

        if (HasRequestQueue())
        {
            ProcessRequests(&CI, size);
        }
    }

    //
    //  Otherwise, clear dirty state and dequeue the layout request
    //

    else
    {
        FlushRequests();
        Reset(TRUE);
    }

    Assert(!HasRequestQueue() || GetView()->HasLayoutTask(this));

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CFrameSetLayout::DoLayout L(0x%x, %S) grfLayout(0x%x)", this, ElementOwner()->TagName(), grfLayout ));
}


//-----------------------------------------------------------------------------
//
//  Member:     Notify
//
//  Synopsis:   Respond to a tree notification
//
//  Arguments:  pnf - Pointer to the tree notification
//
//-----------------------------------------------------------------------------
void
CFrameSetLayout::Notify(
    CNotification * pnf)
{
    Assert(!pnf->IsReceived(_snLast));

    super::Notify(pnf);

    if(pnf->IsTextChange())
    {
        if (!pnf->IsHandled())
        {
                pnf->SetHandler(ElementOwner());

                //
                //  Ignore the notification if already "dirty"
                //  Otherwise, post a layout request
                //

                if (    !IsSizeThis()
                    &&  !TestLock(CElement::ELEMENTLOCK_SIZING))
                {
                    TraceTagEx((tagLayoutTasks, TAG_NONAME,
                                "Layout Task: Posted on ly=0x%x [e=0x%x,%S sn=%d] by CFrameSetLayout::Notify() [n=%S srcelem=0x%x,%S]",
                                this,
                                _pElementOwner,
                                _pElementOwner->TagName(),
                                _pElementOwner->_nSerialNumber,
                                pnf->Name(),
                                pnf->Element(),
                                pnf->Element() ? pnf->Element()->TagName() : _T("")));
                    PostLayoutRequest(pnf->LayoutFlags() | LAYOUT_MEASURE);
                    //possibly got new children, need to recalc positions
                    SetDirtyFramePositions(TRUE);
                }
        }

    }
    else if(   pnf->Type() == NTYPE_ELEMENT_RESIZE
            || pnf->Type() == NTYPE_ELEMENT_REMEASURE
           )
    {
        if (!pnf->IsHandled() && pnf->Element())
        {
            if(pnf->Element() != ElementOwner())
            {
                pnf->Element()->DirtyLayout(pnf->LayoutFlags());

                pnf->SetHandler(ElementOwner());

                //
                //  Ignore the notification if already "dirty"
                //  Otherwise, post a layout request
                //

                if (    !IsSizeThis()
                    &&  !TestLock(CElement::ELEMENTLOCK_SIZING))
                {
                    TraceTagEx((tagLayoutTasks, TAG_NONAME,
                                "Layout Task: Posted on ly=0x%x [e=0x%x,%S sn=%d] by CFrameSetLayout::Notify() [n=%S srcelem=0x%x,%S]",
                                this,
                                _pElementOwner,
                                _pElementOwner->TagName(),
                                _pElementOwner->_nSerialNumber,
                                pnf->Name(),
                                pnf->Element(),
                                pnf->Element() ? pnf->Element()->TagName() : _T("")));
                    PostLayoutRequest(pnf->LayoutFlags() | LAYOUT_MEASURE);
                    //our child gets resized, need to recalc positions
                    SetDirtyFramePositions(TRUE);
                }
            }
            
        }
    }
    else if(pnf->Type() == NTYPE_SELECT_CHANGE)
    {
        // Fire this onto the form
        Doc()->OnSelectChange();
    }
    else if(pnf->Type() == NTYPE_ELEMENT_INVAL_Z_DESCENDANTS)
    {
        const CFancyFormat * pFF = GetFirstBranch()->GetFancyFormat();
        if (    pFF->_fPositioned   
            &&  (pFF->IsWidthPercent() || pFF->IsHeightPercent()))
        {
            ElementOwner()->RepositionElement();
        }
    }
    
#if DBG==1
    // Update _snLast unless this is a self-only notification. Self-only
    // notification are an anachronism and delivered immediately, thus
    // breaking the usual order of notifications.
    if (!pnf->SendToSelfOnly() && pnf->SerialNumber() != (DWORD)-1)
    {
        _snLast = pnf->SerialNumber();
    }
#endif
}


#if DBG == 1
//+------------------------------------------------------------------------
//
//  Member:     IsInPageTransition
//
//  Synopsis:   Returns TRUE if this element is involved in a page transition.
//              Only needed for an assert in CDispNode::GetDrawProgram.
//
//-------------------------------------------------------------------------

BOOL
CFrameSetLayout::IsInPageTransitionApply() const
{
    CElement *pElement          = ElementOwner();
    CDocument *pDoc             = pElement  ? pElement->DocumentOrPendingDocument() : NULL;
    CPageTransitionInfo *pInfo  = pDoc      ? pDoc->GetPageTransitionInfo()         : NULL;
    CMarkup *pMarkup            = pInfo     ? pInfo->GetTransitionFromMarkup()      : NULL;

    return (pMarkup &&
            pInfo->GetPageTransitionState() == CPageTransitionInfo::PAGETRANS_REQUESTED
            && pMarkup->GetElementClient() == pElement);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\layout\hrlyt.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       hrlyt.cxx
//
//  Contents:   Implementation of CHRLayout
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_HRLYT_HXX_
#define X_HRLYT_HXX_
#include "hrlyt.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif  

#ifndef X_EHR_HXX_
#define X_EHR_HXX_
#include "ehr.hxx"
#endif

MtDefine(CHRLayout, Layout, "CHRLayout")
ExternTag(tagCalcSize);

const CLayout::LAYOUTDESC CHRLayout::s_layoutdesc =
{
    0, // _dwFlags
};

//+-------------------------------------------------------------------------
//
//  Method:     CHRLayout::CalcSizeVirtual
//
//  Synopsis:   Calculate the size of the object
//
//--------------------------------------------------------------------------
#define MAX_HR_SIZE         100L // 100 pixels
#define MIN_HR_SIZE         1L   // 1 pixel
#define DEFAULT_HR_SIZE     2L
#define MIN_LEGAL_WIDTH     1L
#define MAX_HR_WIDTH        32000L

DWORD
CHRLayout::CalcSizeVirtual( CCalcInfo * pci,
                            SIZE      * psize,
                            SIZE      * psizeDefault)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CHRLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));

    Assert(ElementOwner());
    Assert(pci);
    Assert(psize);

    //  TODO (112503, olego) : Do we ever get here with SIZEMODE_SET ???
    Assert(pci->_smMode != SIZEMODE_SET);

    CScopeFlag      csfCalcing(this);
    CElement::CLock LockS(ElementOwner(), CElement::ELEMENTLOCK_SIZING);
    CSaveCalcInfo   sci(pci, this);
    CSize           sizeOriginal;
    DWORD           grfReturn;

    CTreeNode * pNode = GetFirstBranch();
    const CFancyFormat * pFF = pNode->GetFancyFormat(LC_TO_FC(LayoutContext()));

    GetSize(&sizeOriginal);

    if (_fForceLayout)
    {
        pci->_grfLayout |= LAYOUT_FORCE;
        _fForceLayout = FALSE;
    }

    grfReturn  = (pci->_grfLayout & LAYOUT_FORCE);
    SetSizeThis( IsSizeThis() || (pci->_grfLayout & LAYOUT_FORCE) );

    // Handle sizing and min/max requests here
    if (   (    pci->_smMode != SIZEMODE_SET
            &&  IsSizeThis())
        || pci->_smMode == SIZEMODE_MMWIDTH
        || pci->_smMode == SIZEMODE_MINWIDTH
       )
    {
        const CCharFormat *pCF = pNode->GetCharFormat(LC_TO_FC(LayoutContext()));
        BOOL fVertical = pCF->HasVerticalLayoutFlow();
        BOOL fWritingModeUsed = pCF->_fWritingModeUsed;

        // First, calculate the correct width
        // (Treat missing widths as if this object is percentage-sized. While not precisely
        //  correct, since such HRs simply take on the size of their parent, it does ensure
        //  the parent container will recalc the HR when their own size changes.)
        const CUnitValue & cuvWidth = pFF->GetLogicalWidth(fVertical, fWritingModeUsed);
        CPeerHolder      * pPH = ElementOwner()->GetLayoutPeerHolder();
        POINT              pt;

        pt.x = pt.y = 0;

        //
        // If There is a peer that wants full_delegation of the sizing...        
        //-------------------------------------------------------------------
        if (   pPH 
            && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_FULLDELEGATION))
        {
            DelegateCalcSize(BEHAVIORLAYOUTINFO_FULLDELEGATION, 
                             pPH, pci, *psize, &pt, psize);

            // now that we have the size, set the dispnode (below)
        }
        else
        {
            switch (pci->_smMode)
            {
            case SIZEMODE_MMWIDTH:
                psize->cx =
                psize->cy = (cuvWidth.IsNullOrEnum() || PercentWidth()
                                    ? MIN_LEGAL_WIDTH
                                    : min(cuvWidth.XGetPixelValue(pci, 0, pNode->GetFontHeightInTwips(&cuvWidth)),
                                          (LONG)USHRT_MAX));

                break;

            case SIZEMODE_NATURAL:
            case SIZEMODE_NATURALMIN:
                {
                    LONG    cxParent;

                    // Always use the available space.  We used to use the parent's
                    // size in case of a percent width.  The old code looked as follows:
                    // cxParent = max(1L, (_fWidthPercent ? pci->_sizeParent.cx : psize->cx));
                    // This was changed because of compatibility issues explained in bug 22948.
                    // In either case, "pin" the value to greater than or equal to 1
                    cxParent = max(1L, psize->cx);

                    // If the user did not supply a value or it is wider than the parent, use parent's width
                    if (cuvWidth.IsNull())
                    {
                        psize->cx = cxParent;
                    }

                    // Otherwise, take value from the user settings
                    else
                    {
                        LONG cx = cuvWidth.XGetPixelValue(pci, cxParent, pNode->GetFontHeightInTwips(&cuvWidth));

                        // If less than zero, then "pin" to zero
                        // If greater than zero, use what the user specified
                        // If equal to zero, use zero if width is a percentage
                        //                   otherwise, use parent's width

                        if(cx < 0)
                            psize->cx = 0;
                        else if(cx > 0)
                        {
                            LONG  cxMax = pci->DeviceFromDocPixelsX(MAX_HR_WIDTH);
                            psize->cx = min(cx, cxMax);
                        }
                        else
                            psize->cx = 1;

                        // Finally, ensure the size does not exceed the maximum
                        LONG  cxMin = pci->DeviceFromDocPixelsX(MIN_LEGAL_WIDTH);
                        psize->cx = max(cxMin, psize->cx);
                    }
                }
                break;

            case SIZEMODE_MINWIDTH:
                psize->cx = (cuvWidth.IsNullOrEnum() || PercentWidth()
                                ? MIN_LEGAL_WIDTH
                                : cuvWidth.XGetPixelValue(pci, 0, pNode->GetFontHeightInTwips(&cuvWidth)));
                break;

    #if DBG==1
            default:
                Assert(FALSE);
                break;
    #endif
            }

            // Then, for all but min/max modes, determine the correct height
            if (pci->_smMode != SIZEMODE_MMWIDTH)
            {
                const CUnitValue & cuvHeight = pFF->GetLogicalHeight(fVertical, fWritingModeUsed);

                // Determine the user specified height (if any) and the default height
                // (HR height can only be in pixels, so no need to pass the parent size)
                LONG    cyDefault = pci->DeviceFromDocPixelsY(DEFAULT_HR_SIZE);
                LONG    cy        = cuvHeight.YGetPixelValue(pci, 0, pNode->GetFontHeightInTwips(&cuvHeight));

                // If less than the default, use the default size
                // Otherwise, "pin" to the maximum
                // NOTE: The calculated default can be less than DEFAULT_HR_SIZE
                //       when zooming is in effect. We must still "pin" to
                //       DEFAULT_HR_SIZE as the minimum height.
                // NOTE: Height is "pin'd" to a maximum here, rather than in the PDL,
                //       so we can accept sizes greater than DEFAULT_HR_SIZE

                if(cuvHeight.IsNull())
                    psize->cy = max(cyDefault, DEFAULT_HR_SIZE);
                else
                {
                    LONG    cyMin = pci->DeviceFromDocPixelsY(MIN_HR_SIZE);
                    if(cy < cyMin)
                       psize->cy = cyMin;
                    else
                    {
                        LONG    cyMax = pci->DeviceFromDocPixelsY(MAX_HR_SIZE);
                        if(cy > cyMax)
                            psize->cy = min(max(cy, DEFAULT_HR_SIZE), cyMax);
                        else
                            psize->cy = cy;
                    }
                }
            }

            // at this point the size has been computed, so try to delegate 
            if (   pPH 
                && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_MODIFYNATURAL))
            {
                DelegateCalcSize(BEHAVIORLAYOUTINFO_MODIFYNATURAL, pPH, pci, *psize, &pt, psize);
            }
        }

        // Finally, set _sizeProposed (if appropriate)
        if (pci->IsNaturalMode())
        {
            //
            // If dirty, ensure display tree nodes exist
            //

            if (    IsSizeThis()
                &&  (EnsureDispNode(pci, (grfReturn & LAYOUT_FORCE)) == S_FALSE))
            {
                grfReturn |= LAYOUT_HRESIZE | LAYOUT_VRESIZE;
            }

            SetSizeThis( FALSE );
            grfReturn    |= LAYOUT_THIS  |
                            (psize->cx != sizeOriginal.cx
                                    ? LAYOUT_HRESIZE
                                    : 0) |
                            (psize->cy != sizeOriginal.cy
                                    ? LAYOUT_VRESIZE
                                    : 0);

            //
            // Size display nodes if size changes occurred
            //

            if (grfReturn & (LAYOUT_FORCE | LAYOUT_HRESIZE | LAYOUT_VRESIZE))
            {
                SizeDispNode(pci, *psize);
            }

            //if there is a map size peer (like glow filter) that silently modifies the size of
            //the disp node, ask what the size is..
            if(HasMapSizePeer())
                GetApparentSize(psize);
        }
        else if(   pci->_smMode == SIZEMODE_MMWIDTH
                || pci->_smMode == SIZEMODE_MINWIDTH
               )
        {
            if(pci->_smMode == SIZEMODE_MINWIDTH)
                psize->cy = psize->cx;
                
            //  At this point we want to update psize with a new information accounting filter 
            //  for MIN MAX Pass inside table cell.
            if (HasMapSizePeer())
            {
                //  At this point we want to update psize with a new information accounting filter 
                CRect rectMapped(CRect::CRECT_EMPTY);
                // Get the possibly changed size from the peer
                if(DelegateMapSize(*psize, &rectMapped, pci))
                {
                    psize->cy = psize->cx = rectMapped.Width();
                }
            }

            if(pci->_smMode == SIZEMODE_MINWIDTH)
                psize->cy = 0;
        }
    }

    // Otherwise, defer to default handling
    else
    {
        grfReturn = super::CalcSizeVirtual(pci, psize, NULL);
    }

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CHRLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    return grfReturn;
}


//+---------------------------------------------------------------------------
//
//  Member:     Draw
//
//  Synopsis:   Paint the object.
//
//----------------------------------------------------------------------------

void
CHRLayout::Draw (CFormDrawInfo * pDI, CDispNode *)
{
    DrawRule(pDI,
             pDI->_rc,
             DYNCAST(CHRElement, ElementOwner())->GetAAnoShade(),
             GetFirstBranch()->GetCascadedcolor(LC_TO_FC(LayoutContext())),
             ElementOwner()->GetBackgroundColor());
}

//+---------------------------------------------------------------------------
//
//  Function:     DrawRule
//
//  Synopsis:   Draw the rule with specified parameters
//
//----------------------------------------------------------------------------

static HRESULT
DrawRule(CFormDrawInfo * pDI, const RECT &rc, BOOL fNoShade, const CColorValue &cvCOLOR, COLORREF colorBack)
{
    HGDIOBJ     hBrush = NULL;
    XHDC        hdc = pDI->GetDC(TRUE);
    HPEN        hOrigPen;

    int oneX = pDI->DeviceFromDocPixelsX(1);
    int oneY = pDI->DeviceFromDocPixelsY(1);

    Assert(!IsRectEmpty(&rc));

    // When a color value is specified the 3d effect must be off
    if(!fNoShade && cvCOLOR.IsDefined())
    {
        fNoShade = TRUE;
    }

    if(fNoShade)
    {
        HBRUSH      hOrigBrush;

        if(cvCOLOR.IsDefined())
        {
            Verify(hBrush = CreateSolidBrush(cvCOLOR.GetColorRef()));
        }
        else
        {
            Verify(hBrush = CreateSolidBrush(GetSysColorQuick(COLOR_3DSHADOW)));
        }

        if (hBrush)
        {
            hOrigBrush = (HBRUSH)SelectObject(hdc, hBrush);
            hOrigPen = (HPEN)SelectObject(hdc, GetStockObject(NULL_PEN));
            Rectangle(hdc, rc.left, rc.top, rc.right+oneX, rc.bottom+oneY);
            SelectObject(hdc, hOrigBrush);
            SelectObject(hdc, hOrigPen);
            DeleteObject(hBrush);
        }
    }
    else
    {
        // Draw the ruler with 3d effect
        COLORREF    lightColor;
        COLORREF    darkColor;
        if (   pDI->_pMarkup 
            && !pDI->_pMarkup->IsPrintMedia())
        {
            COLORREF colorBtnFace = GetSysColorQuick(COLOR_BTNFACE);

            darkColor = GetSysColorQuick(COLOR_3DSHADOW);
            // for IE3/Nav3 compatibility
            // If the background color is the same as the border
            // color, Nav3 choose a different color than ButtonFace
            // This is the case in WC3 test page.
            // we do the same thing here
            if ((colorBack & CColorValue::MASK_COLOR) == colorBtnFace)
            {
                lightColor = RGB(230, 230, 230);
            }
            else
            {
                lightColor = colorBtnFace;
            }
        }
        else
        {
            // When printing
            darkColor  = RGB(128, 128, 128);
            lightColor = RGB(0, 0, 0);
        }

        CRect rcr = rc;
        int height = pDI->DocPixelsFromDeviceY(rcr.Height());

        CBorderInfo bi;                     // site\base\csite.hxx
        bi.wEdges = height < 2 ? BF_TOP     // public\sdk\inc\winuser.h
                  : height > 2 ? BF_RECT
                  : BF_BOTTOM | BF_TOP;

        bi.abStyles[SIDE_TOP   ] =          // site\include\cfpf.hxx
        bi.abStyles[SIDE_RIGHT ] =
        bi.abStyles[SIDE_BOTTOM] =
        bi.abStyles[SIDE_LEFT  ] = fmBorderStyleSingle;  // core\include\cdutil.hxx

        bi.aiWidths[SIDE_TOP   ] =
        bi.aiWidths[SIDE_BOTTOM] = oneY;
        bi.aiWidths[SIDE_RIGHT ] =
        bi.aiWidths[SIDE_LEFT  ] = oneX;

        bi.acrColors[SIDE_TOP   ][0] =
        bi.acrColors[SIDE_LEFT  ][0] = darkColor;
        bi.acrColors[SIDE_RIGHT ][0] =
        bi.acrColors[SIDE_BOTTOM][0] = lightColor;

        DrawBorder(pDI, &rcr, &bi);
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\layout\htmllyt.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       htmllyt.cxx
//
//  Contents:   Implementation of CHtmlLayout
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_HTMLYT_HXX_
#define X_HTMLYT_HXX_
#include "htmllyt.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_DISPPARENT_HXX_
#define X_DISPPARENT_HXX_
#include "dispparent.hxx"
#endif

#ifndef X_DISPSCROLLER_HXX_
#define X_DISPSCROLLER_HXX_
#include "dispscroller.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

MtDefine(CHtmlLayout, Layout, "CHtmlLayout")
DeclareTag(tagDisplayInnerHTMLNode,"Layout: Show InnerHTMLLyt Node",   "Gives the inner HTML node a background");
ExternTag(tagLayoutTasks);
ExternTag(tagCalcSizeDetail);

const CLayout::LAYOUTDESC CHtmlLayout::s_layoutdesc =
{
    0, // _dwFlags
};

CHtmlLayout::~CHtmlLayout()
{
    // (greglett) This is the wrong place to do this - the element disp node is waxed in CLayout::Detach
    if (_pInnerDispNode)
    {
        // Inner display node is never a scroller: No need to detach scrollbar container.
        Verify(OpenView());
        _pInnerDispNode->Destroy();
        _pInnerDispNode = NULL;
    }
}

void
CHtmlLayout::Notify(CNotification * pnf)
{
    BOOL fHandle = FALSE;

    Assert(!pnf->IsReceived(_snLast) || pnf->Type() == NTYPE_ELEMENT_ENSURERECALC);

    //
    //  Handle position change notifications
    //   
    if (IsPositionNotification(pnf))
    {
        fHandle = HandlePositionNotification(pnf);
    }    
    else if (IsInvalidationNotification(pnf))
    {
        //
        //  Invalidate the entire layout if the associated element initiated the request
        //
        if (   ElementOwner() == pnf->Element() 
            || pnf->IsType(NTYPE_ELEMENT_INVAL_Z_DESCENDANTS))
        {
            Invalidate();
        }
    }
#ifdef ADORNERS    
    //
    //  Handle adorner notifications
    //
    else if (pnf->IsType(NTYPE_ELEMENT_ADD_ADORNER))
    {
        fHandle = HandleAddAdornerNotification(pnf);
    }
#endif // ADORNERS
    else if (pnf->IsTextChange())
    {
        //do nothing. Should not happen because HTML does not have text content.
    }
    else if (!pnf->IsHandled() && pnf->IsLayoutChange() && pnf->Element())
    {

        CElement * pElemNotify = pnf->Element();

        if(pElemNotify != ElementOwner())
        {
            fHandle = TRUE;
            pElemNotify->DirtyLayout(pnf->LayoutFlags());
        }
        else
        {
            if (pnf->IsFlagSet(NFLAGS_FORCE))
            {
                _fForceLayout = TRUE;
            }
            pnf->ClearFlag(NFLAGS_FORCE);
        }
        
        if(!IsSizeThis())
        {
            //our child changed and we are not scheduled for calc by parent
            //post request to ourself
            TraceTagEx((tagLayoutTasks, TAG_NONAME,
                        "Layout Task: Posted on ly=0x%x [e=0x%x,%S sn=%d] by CHTMLLayout::Notify() [n=%S srcelem=0x%x,%S]",
                        this,
                        _pElementOwner,
                        _pElementOwner->TagName(),
                        _pElementOwner->_nSerialNumber,
                        pnf->Name(),
                        pElemNotify,
                        pElemNotify->TagName()));
            PostLayoutRequest(pnf->LayoutFlags() | LAYOUT_MEASURE);
        }

    }
    else
    {
        super::Notify(pnf);
    }

    if (fHandle)
    {
        pnf->SetHandler(ElementOwner());
    }
}



void UpdateScrollInfo(CDispNodeInfo * pdni, const CLayout * pLayout );

void
CHtmlLayout::GetDispNodeInfo(
    BOOL            fCanvas,                             
    CDispNodeInfo * pdni,
    CDocInfo *      pdci  ) const
{
    CElement *              pElement    = ElementOwner();
    CTreeNode *             pTreeNode   = pElement->GetFirstBranch();
    const CFancyFormat *    pFF         = pTreeNode->GetFancyFormat(LC_TO_FC(((CLayout *)this)->LayoutContext()));
    const CCharFormat  *    pCF         = pTreeNode->GetCharFormat(LC_TO_FC(((CLayout *)this)->LayoutContext()));
    const BOOL  fVerticalLayoutFlow     = pCF->HasVerticalLayoutFlow();
    const BOOL  fWritingModeUsed        = pCF->_fWritingModeUsed;
    BOOL                    fThemed     =    GetThemeClassId() != THEME_NO       
                                          && pElement->GetTheme(GetThemeClassId());
    CBackgroundInfo         bi;

    //
    //  Get general information
    //

    pdni->_etag                 = pElement->Tag();
    pdni->_layer                = DISPNODELAYER_FLOW;
    pdni->_fHasInset            = FALSE;
    pdni->_fIsOpaque            = FALSE;
    pdni->_fRTL                 = IsRTL();
    pdni->_fHasUserClip         = FALSE;
    pdni->_fHasExpandedClip     = FALSE;

    if (fCanvas)
    {
        pdni->_fHasUserTransform    = FALSE;
        pdni->_visibility           = VISIBILITYMODE_INHERIT;
        pdni->_fHasContentOrigin    = TRUE;

        //
        //  Determine background information
        //

        const_cast<CHtmlLayout *>(this)->GetBackgroundInfo(NULL, &bi, FALSE);

        pdni->_fHasBackground      = (bi.crBack != COLORREF_NONE || bi.pImgCtx) ||
                                      const_cast<CHtmlLayout *>(this)->IsShowZeroBorderAtDesignTime() ; // we always call DrawClientBackground when ZEROBORDER is on

        pdni->_fHasFixedBackground =        (bi.fFixed && !!bi.pImgCtx)
                                       ||   fThemed && pdni->_etag != ETAG_FIELDSET;


        // if there is a background image that doesn't cover the whole site, then we cannont be
        // opaque
        //
        // (carled) we are too close to RC0 to do the full fix.  Bug #66092 is opened for the ie6
        // timeframe to clean this up.  the imagehelper fx (above) should be REMOVED!! gone. bad
        // instead we need a virtual function on CLayout called BOOL CanBeOpaque(). The def imple
        // should contain the if stmt below. CImageLayout should override and use the contents
        // of CImgHelper::IsOpaque, (and call super). Framesets could possibly override and set
        // to false.  Input type=Image should override and do the same things as CImageLayout
        //
        pdni->_fIsOpaque  = (      pdni->_fIsOpaque
                            || bi.crBack != COLORREF_NONE && !fThemed
                            ||  (   !!bi.pImgCtx
                                 &&  !!(bi.pImgCtx->GetState() & (IMGTRANS_OPAQUE))
                                 &&  pFF->GetBgPosX().GetRawValue() == 0 // Logical/physical does not matter
                                 &&  pFF->GetBgPosY().GetRawValue() == 0 // since we check both X and Y here.
                                 &&  pFF->GetBgRepeatX()                 // Logical/physica does not matter
                                 &&  pFF->GetBgRepeatY())                // since we check both X and Y here.
                            );
        //
        //  Determine overflow, scroll and scrollbar direction properties
        //

        pdni->_overflowX   = pFF->GetLogicalOverflowX(fVerticalLayoutFlow, fWritingModeUsed);
        pdni->_overflowY   = pFF->GetLogicalOverflowY(fVerticalLayoutFlow, fWritingModeUsed);
        pdni->_fIsScroller = pTreeNode->IsScrollingParent(LC_TO_FC(LayoutContext()));

        if (    GetOwnerMarkup()->GetElementClient()
            &&  GetOwnerMarkup()->GetElementClient()->Tag() == ETAG_BODY
            && !ElementOwner()->IsInViewLinkBehavior( TRUE ) )
        {
            UpdateScrollInfo(pdni, this);
        }
        else
        {
            GetDispNodeScrollbarProperties(pdni);
        }

        //
        //  Get border information
        //
        Assert(pdci);

        pdni->_dnbBorders = (DISPNODEBORDER)pElement->GetBorderInfo(pdci, &(pdni->_bi), FALSE, FALSE FCCOMMA LC_TO_FC(((CLayout *)this)->LayoutContext()));

        Assert( pdni->_dnbBorders == DISPNODEBORDER_NONE
            ||  pdni->_dnbBorders == DISPNODEBORDER_SIMPLE
            ||  pdni->_dnbBorders == DISPNODEBORDER_COMPLEX);

        pdni->_fIsOpaque = pdni->_fIsOpaque
                            && (pdni->_dnbBorders == DISPNODEBORDER_NONE
                                || (    pdni->_bi.IsOpaqueEdge(SIDE_TOP)
                                    &&  pdni->_bi.IsOpaqueEdge(SIDE_LEFT)
                                    &&  pdni->_bi.IsOpaqueEdge(SIDE_BOTTOM)
                                    &&  pdni->_bi.IsOpaqueEdge(SIDE_RIGHT)) );

        // Check if need to disable 'scroll bits' mode
        pdni->_fDisableScrollBits =   pdni->_fHasFixedBackground 
                               || (pFF->GetTextOverflow() != styleTextOverflowClip);
    
    }
    else
    {
        pdni->_overflowX   = styleOverflowVisible;
        pdni->_overflowY   = styleOverflowVisible;
        pdni->_dnbBorders  = DISPNODEBORDER_NONE;
        pdni->_fIsScroller = FALSE;
        pdni->_fHasBackground       = FALSE;
        pdni->_fHasFixedBackground  = FALSE;
        pdni->_fDisableScrollBits   = FALSE;        
        pdni->_fHasContentOrigin    = FALSE;

#if DBG==1
        if (IsTagEnabled(tagDisplayInnerHTMLNode))
            pdni->_fHasBackground = TRUE;
#endif

        GetDispNodeScrollbarProperties(pdni);
       
        //
        //  Determine if custom transformations are required
        //
        pdni->_fHasUserTransform = GetElementTransform(NULL, NULL, NULL);

        pdni->_visibility   = VisibilityModeFromStyle(pTreeNode->GetCascadedvisibility(LC_TO_FC(((CLayout *)this)->LayoutContext())));
    }
}


DWORD
CHtmlLayout::CalcSizeVirtual( CCalcInfo * pci,
                              SIZE *      psize,
                              SIZE *      psizeDefault)
{
    CScopeFlag      csfCalcing(this);
    CElement::CLock LockS(ElementOwner(), CElement::ELEMENTLOCK_SIZING);
    CSaveCalcInfo   sci(pci, this);
    CLayout *       pChildLayout = GetChildLayout();
    CSize           sizeOriginal;
    CSize szTotal = *psize;
    CDispNodeInfo   dni, dni2;
    DWORD           grfReturn;

    // (KTam): For cleanliness, setting the context in the pci ought to be done
    // at a higher level -- however, it's really only needed for layouts that can contain
    // others, which is why we can get away with doing it here.
    if ( !pci->GetLayoutContext() )
    {
        pci->SetLayoutContext( LayoutContext() );
    }
    else
    {
        Assert(pci->GetLayoutContext() == LayoutContext() 
            || pci->GetLayoutContext() == DefinedLayoutContext() 
            // while calc'ing table min max pass we use original cell layout 
            || pci->_smMode == SIZEMODE_MMWIDTH
            || pci->_smMode == SIZEMODE_MINWIDTH);
    }
    
    //
    //  Calc (essentially set) size of our first (canvas) display node
    //
    GetSize(&sizeOriginal);
    GetDispNodeInfo(TRUE, &dni, pci);
    GetDispNodeInfo(FALSE, &dni2, pci);

    if (_fForceLayout)
    {
        TraceTagEx(( tagCalcSizeDetail, TAG_NONAME, "_fForceLayout is on"));
        pci->_grfLayout |= LAYOUT_FORCE;
        _fForceLayout = FALSE;
    }

    grfReturn  = (pci->_grfLayout & LAYOUT_FORCE);

    if (pci->_grfLayout & LAYOUT_FORCE)
    {
        TraceTagEx(( tagCalcSizeDetail, TAG_NONAME, "LAYOUT_FORCE is on"));
        SetSizeThis( TRUE );
        //_fAutoBelow        = FALSE;
        //_fPositionSet      = FALSE;
        //_fContainsRelative = FALSE;
    }

    //
    // Ensure the view/canvas display node is correct
    // (If they change, then force measuring since borders etc. may need re-sizing)
    //    
    if (EnsureDispNodeCore(pci, (grfReturn & LAYOUT_FORCE), dni, &_pDispNode) == S_FALSE)
    {
        grfReturn |= LAYOUT_HRESIZE | LAYOUT_VRESIZE;
        SetSizeThis( TRUE );
    }
    

    // FULL LayoutPeer CalcSize delegation would go HERE 
    // MODIFYNATURAL LayoutPeer CalcSize delegation would go HERE

    grfReturn  |=   LAYOUT_THIS |
                      (psize->cx != sizeOriginal.cx
                            ? LAYOUT_HRESIZE
                            : 0)  |
                      (psize->cy != sizeOriginal.cy
                            ? LAYOUT_VRESIZE
                            : 0);


    //
    //  Calc the size and position of our child
    //
    if (pChildLayout)
    {
        CTreeNode * pChildNode          = pChildLayout->GetFirstBranch(); 
        const CFancyFormat * pFF        = GetFirstBranch()->GetFancyFormat(LC_TO_FC(LayoutContext()));
        CSize szParentSizeForChild;
        CRect rcContent(*psize);
        CRect rcPaddings(CRect::CRECT_EMPTY);
        CRect rcChildMargins(CRect::CRECT_EMPTY);
        long  cxParentWidth;
        BOOL  fChildMarginLeftAuto      = FALSE;
        BOOL  fChildMarginRightAuto     = FALSE;
        BOOL  fChildPositioned          = !pChildNode->IsPositionStatic();
        BOOL  fChildIsAbsolute          = pChildNode->IsAbsolute();
        BOOL  fRTL                      = IsRTL();
        BOOL  fInViewLink               = ElementOwner()->IsInViewLinkBehavior(TRUE);

        // Get size minus border/scrollbar
        SubtractClientRectEdges(&rcContent, pci);
        rcContent.GetSize(&szParentSizeForChild); 

        {
            CUnitValue  cuvPadding;

            cuvPadding = pFF->GetPadding(SIDE_LEFT);
            if (!cuvPadding.IsNullOrEnum())
            {
                rcPaddings.left = cuvPadding.XGetPixelValue(pci, szTotal.cx, pChildNode->GetFontHeightInTwips(&cuvPadding));
            }

            cuvPadding = pFF->GetPadding(SIDE_RIGHT);
            if (!cuvPadding.IsNullOrEnum())
            {
                rcPaddings.right = cuvPadding.XGetPixelValue(pci, szTotal.cx, pChildNode->GetFontHeightInTwips(&cuvPadding));            
            }

            cuvPadding = pFF->GetPadding(SIDE_TOP);
            if (!cuvPadding.IsNullOrEnum())
            {
                rcPaddings.top = cuvPadding.YGetPixelValue(pci, szTotal.cx, pChildNode->GetFontHeightInTwips(&cuvPadding));
            }

            cuvPadding = pFF->GetPadding(SIDE_BOTTOM);
            if (!cuvPadding.IsNullOrEnum())
            {
                rcPaddings.bottom = cuvPadding.YGetPixelValue(pci, szTotal.cx, pChildNode->GetFontHeightInTwips(&cuvPadding));
            }

            // Constrain each padding to [0, SHRT_MAX]
            for (int i=0; i<3; i++)
            {
                if (rcPaddings[i] > SHRT_MAX)
                    rcPaddings[i] = SHRT_MAX;
                else if (rcPaddings[i] < 0)
                    rcPaddings[i] = 0;
            }

            szParentSizeForChild.cx -= rcPaddings.left + rcPaddings.right;
            szParentSizeForChild.cy -= rcPaddings.top + rcPaddings.bottom;
        }
        
        //  Parent Size = Our size - Our Border - Our Padding
        pci->SizeToParent(&szParentSizeForChild);

        {
            const CFancyFormat *pChildFF = pChildNode->GetFancyFormat(LC_TO_FC(pChildLayout->LayoutContext()));
            BOOL fWritingModeUsed        = pChildNode->GetCharFormat(LC_TO_FC(pChildLayout->LayoutContext()))->_fWritingModeUsed;
            CUnitValue cuvMargin;

            cuvMargin = pChildFF->GetLogicalMargin(SIDE_LEFT, FALSE, fWritingModeUsed);
            if (!cuvMargin.IsNull())
            {
                rcChildMargins.left   = cuvMargin.XGetPixelValue(pci, pci->_sizeParent.cx, pChildNode->GetFontHeightInTwips(&cuvMargin));
                fChildMarginLeftAuto  = (cuvMargin.GetUnitType() == CUnitValue::UNIT_ENUM) && (cuvMargin.GetUnitValue() == styleAutoAuto);
            }

            cuvMargin = pChildFF->GetLogicalMargin(SIDE_RIGHT, FALSE, fWritingModeUsed);
            if (!cuvMargin.IsNull())
            {
                rcChildMargins.right  = cuvMargin.XGetPixelValue(pci, pci->_sizeParent.cx, pChildNode->GetFontHeightInTwips(&cuvMargin));
                fChildMarginRightAuto = (cuvMargin.GetUnitType() == CUnitValue::UNIT_ENUM) && (cuvMargin.GetUnitValue() == styleAutoAuto);
            }

            cuvMargin = pChildFF->GetLogicalMargin(SIDE_TOP, FALSE, fWritingModeUsed);
            if (!cuvMargin.IsNull())
            {
                rcChildMargins.top    = cuvMargin.YGetPixelValue(pci, pci->_sizeParent.cx, pChildNode->GetFontHeightInTwips(&cuvMargin));
            }

            cuvMargin = pChildFF->GetLogicalMargin(SIDE_BOTTOM, FALSE, fWritingModeUsed);
            if (!cuvMargin.IsNull())
            {
                rcChildMargins.bottom = cuvMargin.YGetPixelValue(pci, pci->_sizeParent.cx, pChildNode->GetFontHeightInTwips(&cuvMargin));
            }
        }

        szParentSizeForChild.cx -= rcChildMargins.left + rcChildMargins.right;
        szParentSizeForChild.cy -= rcChildMargins.top + rcChildMargins.bottom;
        
        cxParentWidth = szParentSizeForChild.cx;

        if(!pChildLayout->IsDisplayNone())
            grfReturn |= pChildLayout->CalcSize(pci, &szParentSizeForChild);
        else
            szParentSizeForChild = g_Zero.size;

        //
        // If size changed, resize display nodes
        // Note: if in view link, we size to content, ignore automargins, RTL, scrolling
        // and any positioning of the child layout. It is temporary solution until we
        // figure out what to do when we "size to content" in case of view linked behavior
        // Basically, we just show the body/frameset with margins and HTML's padding
        if(fInViewLink)
        {
            if (grfReturn & (LAYOUT_THIS | LAYOUT_HRESIZE | LAYOUT_VRESIZE))
            {
                CSize szHtmlSize;

                //szParentSizeForChild is calculated size of inner child (BODY or FRAMESET)
                //add HTML paddings and BODY margins
                szHtmlSize  =   szParentSizeForChild 
                            +   rcPaddings.TopLeft().AsSize() + rcPaddings.BottomRight().AsSize()
                            +   rcChildMargins.TopLeft().AsSize() + rcChildMargins.BottomRight().AsSize();
         
                //HTML border occupies some space - add it
                CBorderInfo    bi;
                DISPNODEBORDER dnbBorders = 
                    (DISPNODEBORDER)ElementOwner()->GetBorderInfo(
                                    pci, &bi, FALSE, FALSE FCCOMMA LC_TO_FC(LayoutContext()));

                if (dnbBorders != DISPNODEBORDER_NONE)
                {
                    szHtmlSize.cx   += bi.aiWidths[SIDE_LEFT] + bi.aiWidths[SIDE_RIGHT];
                    szHtmlSize.cy   += bi.aiWidths[SIDE_TOP] + bi.aiWidths[SIDE_BOTTOM];
                }

                SizeDispNode(pci, szHtmlSize);

                if(!pChildLayout->IsDisplayNone())
                {
                       //  Ensure & Size the internal HTML node
                    EnsureDispNodeCore(pci, (grfReturn & LAYOUT_FORCE), dni2, &_pInnerDispNode);
                    _pInnerDispNode->SetPosition(g_Zero.pt);        
                    _pInnerDispNode->SetSize(szHtmlSize, NULL, FALSE);

                    // Calculate the flow position of our child
                    _ptChildPosInFlow = rcPaddings.TopLeft() + rcChildMargins.TopLeft().AsSize();

                    //position child in flow here
                    pChildLayout->SetPosition(_ptChildPosInFlow);
                }
                *psize = szHtmlSize;
            }
        }
        else
        {
            CSize  szInnerNode;
            CPoint ptInnerNodePos(g_Zero.pt);
            
            if (   GetElementDispNode()
                && (grfReturn & (LAYOUT_FORCE | LAYOUT_HRESIZE | LAYOUT_VRESIZE)))
            {
                    SizeDispNode(pci, *psize);
            }

            if(!pChildLayout->IsDisplayNone())
            {
                // Handle Automargins if our child is in flow
                if (    !fChildIsAbsolute
                    &&  (fChildMarginLeftAuto || fChildMarginRightAuto)
                    &&  (cxParentWidth - szParentSizeForChild.cx) > 0   )
                {
                    long xWidthToDistribute = cxParentWidth - szParentSizeForChild.cx;

                    if (fChildMarginLeftAuto == fChildMarginRightAuto)
                    {
                        rcChildMargins.left  += xWidthToDistribute / 2;
                        rcChildMargins.right += xWidthToDistribute - xWidthToDistribute / 2;
                    }
                    else if (fChildMarginLeftAuto) 
                    {
                        rcChildMargins.left += xWidthToDistribute;
                    }
                    else 
                    {
                        rcChildMargins.right += xWidthToDistribute;
                    }
                }
                

                // Calculate the flow position of our inner display node.
                // Leave it zero if we're LTR, otherwise figure it out...
                if (fRTL)
                {
                    ptInnerNodePos.x = cxParentWidth - szParentSizeForChild.cx;

                    CDispNode * pCanvasDispNode = GetElementDispNode();
                    Assert(pCanvasDispNode->HasContentOrigin());

                    if(pCanvasDispNode->HasContentOrigin())
                        pCanvasDispNode->SetContentOrigin(CSize(0, 0), rcContent.Width());
                }                    

                // Calculate the flow position of our child
                _ptChildPosInFlow = rcPaddings.TopLeft();

                // Absolute elements account for margin in HandlePositionRequest
                // Do not add them on here.
                if (!fChildIsAbsolute)
                    _ptChildPosInFlow += rcChildMargins.TopLeft().AsSize();

                _ptChildPosInFlow += ptInnerNodePos.AsSize();

                if (fChildPositioned)   //positioned child, queue request
                {
                    pChildLayout->ElementOwner()->RepositionElement();
                }        
                else                    //static child, position it in flow here
                    pChildLayout->SetPosition(_ptChildPosInFlow);


                //
                //  Ensure & Size the internal HTML node
                //  This node serves as a 'placeholder' for BODY margins/HTML padding so that
                //  we could scroll to this space. If nothing was occupying this space, 
                //  outer scroller node would not reserve scrolling range to go there.
                //  szParentSizeForChild currently contains the size of the child (BODY) layout.
                //
                EnsureDispNodeCore(pci, (grfReturn & LAYOUT_FORCE), dni2, &_pInnerDispNode);
                GetInnerDispNode()->SetPosition(ptInnerNodePos);        

                //
                //  Size our "Inner" HTML node.
                //

                // If the child is in flow (takes up space), we need to be at least as big as it plus
                // the margins and padding we subtracted off earlier.
                if (!fChildIsAbsolute)
                {
                    szInnerNode =   szParentSizeForChild 
                                +   rcPaddings.TopLeft().AsSize() + rcPaddings.BottomRight().AsSize()
                                +   rcChildMargins.TopLeft().AsSize() + rcChildMargins.BottomRight().AsSize();
                }
                else 
                {
                    szInnerNode.cx =
                    szInnerNode.cy = 0;     // Node is irrelevant for ABS positioning.

                }
         
                GetInnerDispNode()->SetSize(szInnerNode, NULL, FALSE);
            }            

        }

        //
        //  Hook up the display nodes
        //

        CDispParentNode * pCanvasDispNode = (CDispParentNode *) GetElementDispNode();
        CDispParentNode * pHtmlDispNode =  (CDispParentNode *) GetInnerDispNode();
        CDispNode * pDispNode = pChildLayout->GetElementDispNode();

        if (    pCanvasDispNode
            &&  pHtmlDispNode
            &&  pDispNode        )
        {                        
            //  Hook up the HTML disp node under the canvas disp node
            if (pHtmlDispNode->GetParentNode() != pCanvasDispNode)
                pCanvasDispNode->InsertChildInFlow(pHtmlDispNode);
            
            //  Hook up the BODY/FRAMESET disp node
            if (pDispNode->GetParentNode() != pCanvasDispNode)
                pCanvasDispNode->InsertChildInFlow(pDispNode);

        }

    }
    else //no child layout. Strange but lets just size into psize...
    {
        if (GetElementDispNode())
            SizeDispNode(pci, *psize);
        *psize = g_Zero.size;
    }

    SetSizeThis(FALSE);
    return grfReturn;
}

//  Mousewheel scrolling defines.
void    ExecReaderMode(CElement * pScrollElement, CMessage * pMessage, BOOL fByMouse);
void    ReaderModeScroll(CLayout * pScrollLayout, int dx, int dy);
HRESULT HandleMouseWheel(CLayout * pScrollLayout, CMessage * pMessage);

HRESULT BUGCALL
CHtmlLayout::HandleMessage(
    CMessage * pMessage)
{
    HRESULT     hr            = S_FALSE;

    Assert(!GetOwnerMarkup() || GetOwnerMarkup()->IsHtmlLayout());

    switch(pMessage->message)
    {

        case WM_SETCURSOR:
            hr = ElementOwner()->SetCursorStyle(IDC_ARROW);
            break;
            
#ifndef WIN16
    case WM_MOUSEWHEEL:
        hr = THR(HandleMouseWheel(this, pMessage));
        break;

    case WM_MBUTTONDOWN:
        if (    GetElementDispNode()
            &&  !Doc()->_fDisableReaderMode
            &&  GetElementDispNode()->IsScroller())
        {
            //ExecReaderMode runs message pump, so element can be destroyed
            //during it. AddRef helps.
            CElement * pElement = ElementOwner();
            pElement->AddRef();
            ExecReaderMode(pElement, pMessage, TRUE);
            pElement->Release();

            hr = S_OK;
        }
        break;
            
#endif // ndef WIN16
    }

    // Remember to call super
    if (hr == S_FALSE)
    {
        hr = super::HandleMessage(pMessage);
    }

    RRETURN1(hr, S_FALSE);
}


BOOL
CHtmlLayout::GetBackgroundInfo(
    CFormDrawInfo *     pDI,
    CBackgroundInfo *   pbginfo,
    BOOL                fAll)
{
    Assert(pDI || !fAll);
    Assert(GetOwnerMarkup()->IsHtmlLayout());

    if (    DYNCAST(CHtmlElement, ElementOwner())->ShouldStealBackground()
        &&  GetOwnerMarkup()->GetElementClient() )
    {                
        // We need to try and steal a background from the BODY/FRAMESET.
        // NB: Call GetBackgroundInfoHelper, because
        //      1) CFramesetLayout/CBodyLayout::GetBackgroundInfo will return transparent (it's being stolen)
        //      2) We don't want to calc the image dimensions for the child layout.
        CLayout * pLayout = GetOwnerMarkup()->GetElementClient()->GetUpdatedLayout(GUL_USEFIRSTLAYOUT);
        pLayout->GetBackgroundInfoHelper(pbginfo);

        // We need to calc background image dimensions using *our* layout information, not the BODY/FRAMESETs
        if (    fAll
            &&  pbginfo->pImgCtx)
        {
            GetBackgroundImageInfoHelper(pDI, pbginfo);
        }

        // Do we need to ensure a background color?
        if (    GetOwnerMarkup() == Doc()->PrimaryMarkup()
            &&  pbginfo->crBack == COLORREF_NONE )
        {
            pbginfo->crBack = GetOwnerMarkup()->Root()->GetBackgroundColor();
            Assert(pbginfo->crBack != COLORREF_NONE);
        }
    }
    else
    {
        super::GetBackgroundInfo(pDI, pbginfo, fAll);
    }

    return TRUE;
}

void 
CHtmlLayout::GetPositionInFlow(CElement *pElement, CPoint *ppt)
{
    if (!ppt)
    {
        return;
    }

    *ppt = g_Zero.pt;

    if (    !pElement 
        ||  pElement != ElementOwner()->GetMarkup()->GetElementClient() )
    {
        return;
    }

    *ppt = _ptChildPosInFlow;
}

BOOL CHtmlLayout::IsRTL() const
{
    CElement           *pElement  = ElementOwner();
    Assert(pElement);

    CTreeNode          *pTreeNode = pElement->GetFirstBranch();
    const CFancyFormat *pFF       = pTreeNode->GetFancyFormat(LC_TO_FC(((CLayout *)this)->LayoutContext()));
    const CCharFormat  *pCF       = pTreeNode->GetCharFormat(LC_TO_FC(((CLayout *)this)->LayoutContext()));

    //if HTML has explicitly specified direction, use it..
    if(pFF->HasExplicitDir())
    {
        return pCF->_fRTL;
    }
    else //otherwise, steal direction on BODY if it has it secified..
    {
        CElement *pClientElement = GetOwnerMarkup()->GetElementClient();
        if(pClientElement && pClientElement->Tag() == ETAG_BODY)
        {
            CTreeNode          *pTreeNode = pClientElement->GetFirstBranch();
            const CFancyFormat *pFF = pTreeNode->GetFancyFormat(LC_TO_FC(((CLayout *)this)->LayoutContext()));
            const CCharFormat  *pCF = pTreeNode->GetCharFormat(LC_TO_FC(((CLayout *)this)->LayoutContext()));

            return pFF->HasExplicitDir() && pCF->_fRTL;
        }
    }

    //nobody has direction specified, return default (LTR)
    return FALSE;
}

// This is used by bookmark code to impatiently ask if we are already done..
// If BODY was not yet loaded, return FALSE - caller should wait (dmitryt)
BOOL CHtmlLayout::FRecalcDone()
{
    CLayout *pChildLayout = GetChildLayout();
    return pChildLayout ? pChildLayout->FRecalcDone() : FALSE; 
}


#if DBG == 1
//+------------------------------------------------------------------------
//
//  Member:     IsInPageTransition
//
//  Synopsis:   Returns TRUE if this element is involved in a page transition.
//              Only needed for an assert in CDispNode::GetDrawProgram.
//
//-------------------------------------------------------------------------

BOOL
CHtmlLayout::IsInPageTransitionApply() const
{
    CElement *pElement          = ElementOwner();
    CDocument *pDoc             = pElement  ? pElement->DocumentOrPendingDocument() : NULL;
    CPageTransitionInfo *pInfo  = pDoc      ? pDoc->GetPageTransitionInfo()         : NULL;
    CMarkup *pMarkup            = pInfo     ? pInfo->GetTransitionFromMarkup()      : NULL;

    return (pMarkup &&
            pInfo->GetPageTransitionState() == CPageTransitionInfo::PAGETRANS_REQUESTED
            && pMarkup->GetHtmlElement() == pElement);
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\layout\lrreg.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1999
//  All rights Reserved.
//  Information contained herein is Proprietary and Confidential.
//
//  Contents:   Layout Rect Registry implementation
//

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LRREG_HXX_
#define X_LRREG_HXX_
#include "lrreg.hxx"
#endif

MtDefine(CLayoutRectRegistry, Mem, "CLayoutRectRegistry");
MtDefine(CLayoutRectRegistry_aryLRRE_pv, CLayoutRectRegistry, "CLayoutRectRegistry::_aryLRRE::_pv");

/////////////////////////////////////////////////
// CLayoutRectRegistry

CLayoutRectRegistry::~CLayoutRectRegistry()
{
    int nEntries = _aryLRRE.Size();
    int i;
    CLRREntry *pLRRE;

    for (i = nEntries - 1; i >= 0 ; --i)
    {
        pLRRE = & _aryLRRE[i];
        Assert( pLRRE->_pSrcElem && pLRRE->_pcstrID );
        pLRRE->_pSrcElem->SubRelease();
        delete pLRRE->_pcstrID;

        _aryLRRE.Delete( i );
    }

    Assert( _aryLRRE.Size() == 0 );
}

HRESULT
CLayoutRectRegistry::AddEntry( CElement *pSrcElem, LPCTSTR pszID )
{
    Assert( pSrcElem && pszID );

    HRESULT     hr = S_OK;
    CLRREntry   lrre;
    int         nEntries, i;

    //
    // Make sure no other element is waiting for this ID.
    //
    for (i = 0, nEntries = _aryLRRE.Size(); i < nEntries ; ++i)
    {
        CLRREntry *pLRRE = &_aryLRRE[i];

        AssertSz( pSrcElem != pLRRE->_pSrcElem, "Shouldn't have an existing entry w/ same element" );
        if ( !StrCmpI( pszID, (LPTSTR)(*(pLRRE->_pcstrID))) )
        {
            // There's already an element looking for this ID; you lose.
            hr = E_FAIL;
            goto Cleanup;
        }
    }

    //
    // No element looking for this ID, we can create a new entry.
    //
    lrre._pcstrID = new CStr();
    if (    lrre._pcstrID == NULL 
        ||  FAILED(lrre._pcstrID->Set(pszID))   )
    {
        goto Error;
    }

    lrre._pSrcElem = pSrcElem;
    lrre._pSrcElem->SubAddRef();

    if (FAILED(_aryLRRE.AppendIndirect(&lrre)))
    {
        goto Error;
    }
    
Cleanup:
    return hr;

Error:
    if (lrre._pcstrID)
        delete lrre._pcstrID;

    if (lrre._pSrcElem)
        lrre._pSrcElem->SubRelease();

    hr = E_FAIL;
    goto Cleanup; 
}

// NOTE: Remember to SubRelease() the CElement you get back from this
// function when you're done with it.
CElement *
CLayoutRectRegistry::GetElementWaitingForTarget( LPCTSTR pszID )
{
    Assert( pszID );

    int nEntries = _aryLRRE.Size();
    int i;
    CLRREntry *pLRRE;
    CElement *pElem = NULL;

    for (i=0 ; i < nEntries ; ++i)
    {
        pLRRE = & _aryLRRE[i];
        if ( !StrCmpI( pszID, (LPTSTR)(*(pLRRE->_pcstrID))) )
        {
            // Found an entry that's looking for this ID.
            // Delete the entry, and return the element it was holding.

            // TODO (112509, olego): CLayoutRectRegistry needs conceptual 
            // and code cleanup
            // (original comment by ktam): Deliberately not releasing,
            // it here since we're going to be using the returned ptr! 
            // Think about ref-counting model.
            
            pElem = pLRRE->_pSrcElem;   // Save ptr we're going to return, but don't release it
            delete pLRRE->_pcstrID;     // CDataAry.Delete() won't clean this up, so we do it
            
            _aryLRRE.Delete( i );
            break;
        }
    }

    return pElem;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\layout\layout.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Trident
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       layout.cxx
//
//  Contents:   Implementation of CLayout and related classes.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_CSITE_HXX_
#define X_CSITE_HXX_
#include "csite.hxx"
#endif

#ifndef X_DRAWINFO_HXX_
#define X_DRAWINFO_HXX_
#include "drawinfo.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_CDUTIL_HXX_
#define X_CDUTIL_HXX_
#include "cdutil.hxx"
#endif

#ifndef X_ELABEL_HXX_
#define X_ELABEL_HXX_
#include "elabel.hxx"
#endif

#ifndef X_AVUNDO_HXX_
#define X_AVUNDO_HXX_
#include "avundo.hxx"
#endif

#ifndef X_EFORM_HXX_
#define X_EFORM_HXX_
#include "eform.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_SELECOBJ_HXX_
#define X_SELECOBJ_HXX_
#include "selecobj.hxx"
#endif

#ifndef X_INITGUID_H_
#define X_INITGUID_H_
#define INIT_GUID
#include <initguid.h>
#endif

#ifndef X_DEBUGPAINT_HXX_
#define X_DEBUGPAINT_HXX_
#include "debugpaint.hxx"
#endif

#ifndef X_XBAG_HXX_
#define X_XBAG_HXX_
#include "xbag.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_MSHTMDID_H_
#define X_MSHTMDID_H_
#include <mshtmdid.h>
#endif

#ifndef X_DISPLEAFNODE_HXX_
#define X_DISPLEAFNODE_HXX_
#include "displeafnode.hxx"
#endif

#ifndef X_DISPSCROLLER_HXX_
#define X_DISPSCROLLER_HXX_
#include "dispscroller.hxx"
#endif

#ifndef X_DISPSURFACE_HXX_
#define X_DISPSURFACE_HXX_
#include "dispsurface.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_ELEMENTP_HXX
#define X_ELEMENTP_HXX
#include "elementp.hxx"
#endif

#ifndef X_BODYLYT_HXX_
#define X_BODYLYT_HXX_
#include "bodylyt.hxx"
#endif

#ifndef X_COLOR3D_HXX_
#define X_COLOR3D_HXX_
#include "color3d.hxx"
#endif

#ifndef X_SCROLLBAR_HXX_
#define X_SCROLLBAR_HXX_
#include "scrollbar.hxx"
#endif

#ifndef X_SCROLLBARCONTROLLER_HXX_
#define X_SCROLLBARCONTROLLER_HXX_
#include "scrollbarcontroller.hxx"
#endif

#ifndef _X_SELDRAG_HXX_
#define _X_SELDRAG_HXX_
#include "seldrag.hxx"
#endif

#ifndef X_OPTSHOLD_HXX_
#define X_OPTSHOLD_HXX_
#include "optshold.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx" // needed for EVENTPARAM
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include "evntprm.hxx"
#endif

#ifndef X_LTCELL_HXX_
#define X_LTCELL_HXX_
#include "ltcell.hxx"
#endif

#ifndef X_TAREALYT_HXX_
#define X_TAREALYT_HXX_
#include "tarealyt.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_ADORNER_HXX_
#define X_ADORNER_HXX_
#include "adorner.hxx"
#endif

#ifndef X_IMGLYT_HXX_
#define X_IMGLYT_HXX_
#include "imglyt.hxx"
#endif

#ifndef X_CONTLYT_HXX_
#define X_CONTLYT_HXX_
#include "contlyt.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_HTIFRAME_H_
#define X_HTIFRAME_H_
#include <htiframe.h>
#endif

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"
#endif

#ifndef X_HTMLLYT_HXX_
#define X_HTMLLYT_HXX_
#include "htmllyt.hxx"
#endif


MtDefine(CLayout, Layout, "CLayout")
MtDefine(CRequest, Layout, "CRequest")
MtDefine(CBgRecalcInfo, Layout, "CBgRecalcInfo")
MtDefine(CLayout_aryRequests_pv, Layout, "CLayout RequestQueue")
MtDefine(CLayout_aryDispNodes_pv, Layout, "CLayout DispNode Array")
MtDefine(CLayoutDetach_aryChildLytElements_pv, Locals, "CLayout::Detach aryChildLytElements::_pv")
MtDefine(CLayoutScopeFlag, Locals, "CLayout::CScopeFlag")

MtDefine(LayoutMetrics, Metrics, "Layout Metrics")

DeclareTag(tagCalcSize,           "CalcSize:",       "Trace calls to CalcSize");
DeclareTag(tagCalcSizeDetail,     "CalcSize:",       "Additional CalcSize info");
DeclareTag(tagShowZeroGreyBorder,    "Edit",         "Show Zero Grey Border in Red");

DeclareTag(tagLayoutTasks,        "Layout: Reqs and Tasks",   "Trace layout requests and tasks");
DeclareTag(tagLayoutQueueDump,    "Layout: Dump Queue",       "Dumps layout request queue on QueueRequest() and ProcessRequests()");
DeclareTag(tagLayoutPositionReqs, "Layout: Pos Reqs",         "Traces handling of position requests");
DeclareTag(tagLayoutMeasureReqs,  "Layout: Meas Reqs",        "Traces handling of measure requests");
DeclareTag(tagLayoutAdornerReqs,  "Layout: Adorn Reqs",       "Traces handling of adorner requests");

DeclareTag(tagNoZOrderSignal,   "Layout",   "Don't notify view about ZOrder changes");
DeclareTag(tagZOrderChange,     "Layout",   "trace ZOrder changes");

// This tag allows us to log when GetUpdatedLayout is being called w/o
// context on an element that only has layouts w/ context (these are
// situations where we need to figure out how to supply context or
// make context unnecessary).
// NOTE: This tag should eventually be useless.
DeclareTag(tagLayoutAllowGULBugs, "Layout: Allow GUL bugs",   "Permits and traces buggy calls to GetUpdatedLayout");

// This allows tracking
DeclareTag(tagLayoutTrackMulti,   "Layout: Multi Layout",     "Track suspicious use of multiple layouts");

PerfDbgTag(tagLayoutCalcSize,     "Layout", "Trace CLayout::CalcSize")

ExternTag(tagLayout);
ExternTag(tagLayoutNoShort);
ExternTag(tagImgTrans);
ExternTag(tagDisplayInnerHTMLNode);


PerfDbgExtern(tagPaintWait);

const COLORREF ZERO_GREY_COLOR = RGB(0xC0,0xC0,0xC0);

//+----------------------------------------------------------------------------
//
//  Member:     GetDispNodeElement
//
//  Synopsis:   Return the element associated with a display node
//
//-----------------------------------------------------------------------------

CElement *
GetDispNodeElement(
    CDispNode const* pDispNode)
{
    CElement *  pElement;

    Assert(pDispNode);

    pDispNode->GetDispClient()->GetOwner(pDispNode, (void **)&pElement);

#ifdef ADORNERS
    if (!pElement)
    {
        pElement = DYNCAST(CAdorner, (CAdorner *)pDispNode->GetDispClient())->GetElement();
    }
#endif // ADORNERS

    Assert(pElement);
    Assert(DYNCAST(CElement, pElement));

    return pElement;
}


//+----------------------------------------------------------------------------
//
//  Member:     CRequest::CRequest/~CRequest
//
//  Synopsis:   Construct/destruct a CRequest object
//
//-----------------------------------------------------------------------------

inline
CRequest::CRequest(
    REQUESTFLAGS    rf,
    CElement *      pElement)
{
    Assert(pElement);

    pElement->AddRef();

    _cRefs    = 1;
    _pElement = pElement;
    _grfFlags = rf;
}

inline
CRequest::~CRequest()
{
    _pElement->DelRequestPtr();
    _pElement->Release();

#ifdef ADORNERS
    if (_pAdorner)
    {
        _pAdorner->Release();
    }
#endif // ADORNERS
}


//+----------------------------------------------------------------------------
//
//  Member:     CRequest::AddRef/Release
//
//  Synopsis:   Maintain CRequest reference count
//
//-----------------------------------------------------------------------------

inline DWORD
CRequest::AddRef()
{
    Assert(_cRefs > 0);
    return ++_cRefs;
}

inline DWORD
CRequest::Release()
{
    Assert(_cRefs > 0);
    --_cRefs;
    if (!_cRefs)
    {
        delete this;
        return 0;
    }
    return _cRefs;
}


//+----------------------------------------------------------------------------
//
//  Member:     CRequest::SetFlag/ClearFlag/IsFlagSet
//
//  Synopsis:   Manage CRequest flags
//
//-----------------------------------------------------------------------------

inline void
CRequest::SetFlag(REQUESTFLAGS rf)
{
    _grfFlags |= rf;
}

inline void
CRequest::ClearFlag(REQUESTFLAGS rf)
{
    _grfFlags &= ~rf;
}

inline BOOL
CRequest::IsFlagSet(REQUESTFLAGS rf) const
{
    return _grfFlags & rf;
}

//+----------------------------------------------------------------------------
//
//  Member:     CRequest::QueuedOnLayout/DequeueFromLayout/GetLayout/SetLayout
//
//  Synopsis:   Manage CRequest layout pointers
//
//-----------------------------------------------------------------------------

inline BOOL
CRequest::QueuedOnLayout(
    CLayout *   pLayout) const
{
    return  _pLayoutMeasure  == pLayout
        ||  _pLayoutPosition == pLayout
        ||  _pLayoutAdorner  == pLayout;
}

// See header for description of differences between DequeueFromLayout
// and RemoveFromLayouts.
void
CRequest::DequeueFromLayout(
    CLayout *   pLayout)
{
    if (_pLayoutMeasure == pLayout)
    {
        _pLayoutMeasure = NULL;
    }

    if (_pLayoutPosition == pLayout)
    {
        _pLayoutPosition = NULL;
    }

    if (_pLayoutAdorner == pLayout)
    {
        _pLayoutAdorner = NULL;
    }
}

void
CRequest::RemoveFromLayouts()
{
    int nReleases = 0;

    // Various layouts could have us queued.  Recall
    // that these ptrs may point to 3 different layouts,
    // or all to the same layout.  We need to figure out
    // how many distinct layouts were holding onto us; this
    // is equivalent to the # of refs that are held on us.
    // We do the releases all at the end, because we'll
    // self-destruct when the last release happens!
    if (_pLayoutMeasure)
    {
        nReleases += _pLayoutMeasure->FlushRequest( this );
    }

    if (_pLayoutPosition)
    {
        nReleases += _pLayoutPosition->FlushRequest( this );
    }

    if (_pLayoutAdorner)
    {
        nReleases += _pLayoutAdorner->FlushRequest( this );
    }

    // Can't touch "this" after this loop; we'll be deleted.
    while (nReleases)
    {
        Release();
        nReleases--;
    }
}

CLayout *
CRequest::GetLayout(
    REQUESTFLAGS    rf) const
{
    switch (rf)
    {
    default:
    case RF_MEASURE:    return _pLayoutMeasure;
    case RF_POSITION:   return _pLayoutPosition;
    case RF_ADDADORNER: return _pLayoutAdorner;
    }
}

inline void
CRequest::SetLayout(
    REQUESTFLAGS    rf,
    CLayout *       pLayout)
{
    switch (rf)
    {
    case RF_MEASURE:    _pLayoutMeasure  = pLayout; break;
    case RF_POSITION:   _pLayoutPosition = pLayout; break;
    case RF_ADDADORNER: _pLayoutAdorner  = pLayout; break;
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     CRequest::GetElement/GetAdorner/SetAdorner/GetAuto/SetAuto
//
//  Synopsis:   Various CRequest accessors
//
//-----------------------------------------------------------------------------

#ifdef ADORNERS
inline CAdorner *
CRequest::GetAdorner() const
{
    return _pAdorner;
}

inline void
CRequest::SetAdorner(CAdorner * pAdorner)
{
    Assert(pAdorner);

    if (pAdorner != _pAdorner)
    {
        if (_pAdorner)
        {
            _pAdorner->Release();
        }

        pAdorner->AddRef();
        _pAdorner = pAdorner;
    }
}

#endif // ADORNERS

inline CElement *
CRequest::GetElement() const
{
    return _pElement;
}

inline CPoint &
CRequest::GetAuto()
{
    return _ptAuto;
}

void
CRequest::SetAuto(const CPoint & ptAuto, BOOL fAutoValid)
{
    if (fAutoValid)
    {
        _ptAuto    = ptAuto;
        _grfFlags |= RF_AUTOVALID;
    }
    else
    {
        _grfFlags &= ~RF_AUTOVALID;
    }
}

#if DBG==1
inline void
CRequest::DumpRequest(void)
{
    TraceTagEx((tagLayoutQueueDump, TAG_NONAME,
                "\t Req=0x%x f=0x%x e=[0x%x,%S sn=%d] pt=%d,%d Mly=0x%x [e=0x%x,%S sn=%d] Ply=0x%x [e=0x%x,%S sn=%d] Aly=0x%x [e=0x%x,%S sn=%d] refs=%d",
                this,
                _grfFlags,
                _pElement, _pElement->TagName(), _pElement->_nSerialNumber,
                _ptAuto.x, _ptAuto.y,
                _pLayoutMeasure, (_pLayoutMeasure ? _pLayoutMeasure->_pElementOwner : 0), (_pLayoutMeasure ? _pLayoutMeasure->_pElementOwner->TagName() : _T("")), (_pLayoutMeasure ? _pLayoutMeasure->_pElementOwner->_nSerialNumber : 0),
                _pLayoutPosition, (_pLayoutPosition ? _pLayoutPosition->_pElementOwner : 0), (_pLayoutPosition ? _pLayoutPosition->_pElementOwner->TagName() : _T("")), (_pLayoutPosition ? _pLayoutPosition->_pElementOwner->_nSerialNumber : 0),
                _pLayoutAdorner, (_pLayoutAdorner ? _pLayoutAdorner->_pElementOwner : 0), (_pLayoutAdorner ? _pLayoutAdorner->_pElementOwner->TagName() : _T("")), (_pLayoutAdorner ? _pLayoutAdorner->_pElementOwner->_nSerialNumber : 0),
                _cRefs
              ));
}
#endif

//+----------------------------------------------------------------------------
//
//  Member:     CLayout::CLayout
//
//  Synopsis:   Normal constructor.
//
//  Arguments:  CElement * - element that owns the layout
//
//---------------------------------------------------------------

CLayout::CLayout(CElement * pElementLayout, CLayoutContext * pLayoutContext) :
    CLayoutInfo( pElementLayout )
{
    Assert(_pDocDbg && _pDocDbg->AreLookasidesClear( this, LOOKASIDE_LAYOUT_NUMBER ) );

    _ulRefs = 1;

    SetSizeThis( TRUE );
    _fContentsAffectSize = TRUE;
    _fAutoBelow          = FALSE;
    _fPositionSet        = FALSE;
    _fPositionedOnce     = FALSE;
    _fContainsRelative   = FALSE;
    _fEditableDirty      = TRUE;
    _fHasMarkupPtr       = FALSE;

    _fAllowSelectionInDialog = FALSE;

    _yDescent = -1;

    if (pLayoutContext)
        SetLayoutContext(pLayoutContext);
}

CLayout::~CLayout()
{
    Assert(!_pDispNode);
}

CDoc *
CLayout::Doc() const
{
    Assert( _pDocDbg == ( _fHasMarkupPtr ? _pMarkup->Doc() : _pDoc ) );
    return _fHasMarkupPtr ? _pMarkup->Doc() : _pDoc;
}

CFlowLayout *
CElement::HasFlowLayout( CLayoutContext * pLayoutContext )
{
    CLayout     * pLayout = GetUpdatedLayout( pLayoutContext );

    return (pLayout ? pLayout->IsFlowLayout() : NULL);
}

//+----------------------------------------------------------------------------
//
//  Member:     Init, virtual
//
//  NOTE:       every derived class overriding it should call super::Init
//
//-----------------------------------------------------------------------------

HRESULT
CLayout::Init()
{
    HRESULT         hr = S_OK;

    RRETURN (hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     OnExitTree
//
//  Synopsis:   Dequeue the pending layout request (if any)
//
//-----------------------------------------------------------------------------
HRESULT
CLayout::OnExitTree()
{
    Reset(TRUE);

    DestroyDispNode();

    //
    // Make sure we do a full recalc if we get added back into a tree somewhere.
    //
    SetSizeThis( TRUE );

    return S_OK;
}


//+----------------------------------------------------------------------------
//
//  Member:     Reset
//
//  Synopsis:   Dequeue the pending layout request (if any)
//
//  Arguments:  fForce - TRUE to always reset, FALSE only reset if there are no pending requests
//
//-----------------------------------------------------------------------------
void
CLayout::Reset(
    BOOL    fForce)
{
    if (fForce)
    {
        RemoveLayoutRequest();
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     Detach
//
//  Synopsis:   Prepares the layout for destruction.  After detaching, there
//              should be no one pointing to us, and we should no longer be
//              holding any resources.
//
//-----------------------------------------------------------------------------
void
CLayout::Detach()
{
    // Destroy the primary display node
    DestroyDispNode();

    // Flush requests HELD by this layout (it's now incapable of servicing them)
    FlushRequests();

    // Flush requests MADE by this layout on the view (it no longer needs them to be serviced)
    Reset( TRUE );

    if ( HasLayoutContext() )
    {
        // layout may have array of cloned disp node in print view.
        // NOTE: destrying should be done before layout context deletion !!!
        DestroyDispNodeArray();

        // We were in a layout context, which may or may not be invalid at this point.

        // Flush requests MADE ON this layout (for positioned elements) in
        // its viewchain.
        // Recall compatible contexts never have viewchains.
        // If this layout is in an invalid context, it will be unable to get a viewchain;
        //   however, it might have still have entries in the viewchain's queue.  This is safe
        //   because the viewchain will check for a layout's context's validity during queue
        //   processing.
        //
        // Note, this should only have significance if we are the position parent
        // for positioned elements.  It is safe (though unnecessary) to make this
        // call anyhow.  under dynamic view templates we may want to try to make
        // this more intelligent.
        CViewChain *pViewChain = LayoutContext()->ViewChain();
        if ( pViewChain )
        {
            pViewChain->FlushRequests( this );
        }
        // FUTURE : Figure out what asserts can go in an 'else' clause here.

        // Stop being in layout context
        DeleteLayoutContext();
    }

    if ( HasDefinedLayoutContext() )
    {
        // Stop defining a layout context
        DeleteDefinedLayoutContext();
    }

    // we are detached, no longer maintain a pointer to our element
    _pElementOwner = NULL;
}


//+------------------------------------------------------------------------
//
//  Member:     CLayout::QueryInterface, IUnknown
//
//-------------------------------------------------------------------------
HRESULT
CLayout::QueryInterface(REFIID riid, LPVOID * ppv)
{
    HRESULT hr = S_OK;

    *ppv = NULL;

    if(riid == IID_IUnknown)
    {
        *ppv = this;
    }

    if(*ppv == NULL)
    {
        hr = E_NOINTERFACE;
    }
    else
    {
        ((LPUNKNOWN)* ppv)->AddRef();
    }

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     UpdateScrollbarInfo, protected
//
//  Synopsis:   Update CDispNodeInfo to reflect the correct scroll-related settings
//
//-------------------------------------------------------------------------
void
UpdateScrollInfo(CDispNodeInfo * pdni, const CLayout * pLayout )
{
    Assert(pLayout);
    Assert(     pLayout->ElementOwner()->Tag() == ETAG_HTML
            ||  pLayout->ElementOwner()->Tag() == ETAG_BODY );
    BOOL      fBody         = (pLayout->ElementOwner()->Tag() == ETAG_BODY);
    CMarkup * pMarkup       = pLayout->GetOwnerMarkup();
    CElement* pBody         = NULL;

    Assert(pMarkup);
    Assert(pMarkup->GetElementClient());
    Assert(!pLayout->ElementOwner()->IsInViewLinkBehavior( TRUE ));

    // Find a BODY.
    // While we may want to do some of this for an HTML node containing a BODY, this is more of a departure from existing behavior.
    pBody = fBody ?  pLayout->ElementOwner() : pMarkup->GetElementClient();
    Assert(pBody && pBody->Tag() == ETAG_BODY);     // Only BODY's, right now.  SHould have been checked by caller.

    DWORD     dwFrameOptions;
    CDoc    * pDoc = pMarkup->Doc();
    Assert(pDoc);

    //
    //  Treat the top-level print document as having clipping
    //
    if (pMarkup->IsPrintMedia())
    {
        CElement * pRoot = pMarkup->Root();
        CElement * pMaster = pRoot ? pRoot->GetMasterPtr() : NULL;

        // check that this is not document inside frame 
        if (pMaster == NULL || (pMaster->Tag() != ETAG_FRAME && pMaster->Tag() != ETAG_IFRAME))
        {
            pdni->_overflowX =
            pdni->_overflowY = styleOverflowHidden;
        }
    }


    dwFrameOptions =    pMarkup->GetFrameOptions()
                            &  (    FRAMEOPTIONS_SCROLL_NO                                                           
                                |   FRAMEOPTIONS_SCROLL_YES
                                |   FRAMEOPTIONS_SCROLL_AUTO );

    //
    //  If overflow was not set or there are related frame options
    //
    if (    pdni->_overflowX == styleOverflowNotSet
        ||  pdni->_overflowY == styleOverflowNotSet
        ||  dwFrameOptions )
    {
        
        if (    pMarkup->IsPrimaryMarkup()
            &&  pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_SCROLL_NO)
        {
            dwFrameOptions = FRAMEOPTIONS_SCROLL_NO;
        }
        else
        {
            switch (((CBodyElement *)pBody)->GetAAscroll())
            {
            case bodyScrollno:
                dwFrameOptions = FRAMEOPTIONS_SCROLL_NO;
                break;

            case bodyScrollyes:
                dwFrameOptions = FRAMEOPTIONS_SCROLL_YES;
                break;

            case bodyScrollauto:
                dwFrameOptions = FRAMEOPTIONS_SCROLL_AUTO;
                break;

            case bodyScrolldefault:
                if (!dwFrameOptions && !pDoc->_fViewLinkedInWebOC)
                {
                    dwFrameOptions = FRAMEOPTIONS_SCROLL_YES;
                }
                break;
            }
        }

        switch (dwFrameOptions)
        {
        // scrollAuto case cares about the current overflow values whereas scrollNo case
        // does not. If scrollNo is set, then we are overriding any other setting.
        case FRAMEOPTIONS_SCROLL_NO:
            pdni->_overflowX = styleOverflowHidden;
            pdni->_overflowY = styleOverflowHidden;
            if (fBody)
                ((CBodyLayout *)pLayout)->SetForceVScrollBar(FALSE);
            break;

        case FRAMEOPTIONS_SCROLL_AUTO:      
            if (pdni->_overflowX == styleOverflowNotSet)
                pdni->_overflowX = styleOverflowAuto;
            if (pdni->_overflowY == styleOverflowNotSet)
            {
                if (fBody)
                    ((CBodyLayout *)pLayout)->SetForceVScrollBar(TRUE);
                pdni->_overflowY = styleOverflowAuto;
            }
            break;

        case FRAMEOPTIONS_SCROLL_YES:
        default:
            pdni->_sp._fHSBAllowed = TRUE;
            pdni->_sp._fHSBForced  = FALSE;
            pdni->_sp._fVSBAllowed = TRUE;
            pdni->_sp._fVSBForced  = (dwFrameOptions == FRAMEOPTIONS_SCROLL_YES) || !pDoc->_fViewLinkedInWebOC;
            break;
        }
    }

    //
    //  If an overflow value was set or generated, set the scrollbar properties using it
    //

    if (    pdni->_overflowX != styleOverflowNotSet
        ||  pdni->_overflowY != styleOverflowNotSet)
    {
        pLayout->GetDispNodeScrollbarProperties(pdni);
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CLayout::SubtractClientRectEdges
//
//  Synopsis:   Takes a rectangle of indeterminate size and subtracts off 
//              room for borders and/or scrollbar.
//
//              This used to be:  GetClientRect(prc, cs, CLIENTRECT_USERECT, pdci)
//              However, since one isn't actually getting a rect (just subtracting off
//              allocated space), this is now a separate function.
//
//
//  Arguments:  prc  - Input rectangle; border/scrollbar space will be subtracted from each side
//              pdci - doc calc info
//
//-------------------------------------------------------------------------
void
CLayout::SubtractClientRectEdges(
    CRect *             prc,
    CDocInfo *          pdci)
{
    Assert(prc);
    Assert(pdci);

    //Theoretically we should call GetDispNodeInfo here but it's too expensive.
    //Some code from there was moved here as a result.

    //first, get border widths
    CElement *     pElement = ElementOwner();
    CBorderInfo    bi;
    DISPNODEBORDER dnbBorders = ( pElement->Tag() == ETAG_SELECT
                            ? DISPNODEBORDER_NONE
                            : (DISPNODEBORDER)pElement->GetBorderInfo(
                                    pdci, &bi, FALSE, FALSE FCCOMMA LC_TO_FC(LayoutContext())));

    Assert( dnbBorders == DISPNODEBORDER_NONE
        ||  dnbBorders == DISPNODEBORDER_SIMPLE
        ||  dnbBorders == DISPNODEBORDER_COMPLEX);

    //border occupies some space - subtract it
    if (dnbBorders != DISPNODEBORDER_NONE)
    {
        prc->left   += bi.aiWidths[SIDE_LEFT];
        prc->top    += bi.aiWidths[SIDE_TOP];
        prc->right  -= bi.aiWidths[SIDE_RIGHT];
        prc->bottom -= bi.aiWidths[SIDE_BOTTOM];
    }

    //now, let's see if we need to subtract scrollbars width
    //these two bits..
    BOOL fVScrollbarForced;
    BOOL fHScrollbarForced;

    //will be gotten from back-end store here... (simplified code from GetDispNodeInfo)
    {   
        //  Never allow scroll bars on an object.  The object is responsible for that.
        //  Bug #77073  (greglett)
        if (pElement->Tag() == ETAG_OBJECT)
        {
            fVScrollbarForced = FALSE;
            fHScrollbarForced = FALSE;
        }
        else 
        {
            CDispNodeInfo       dni;
            CTreeNode *         pTreeNode   = pElement->GetFirstBranch();
            const BOOL          fHTMLLayout = IsHtmlLayoutHelper(GetOwnerMarkup());
            const CFancyFormat *pFF         = pTreeNode->GetFancyFormat(LC_TO_FC(LayoutContext()));
            const CCharFormat  *pCF         = pTreeNode->GetCharFormat(LC_TO_FC(LayoutContext()));
            const BOOL  fVerticalLayoutFlow = pCF->HasVerticalLayoutFlow();
            const BOOL  fWritingModeUsed    = pCF->_fWritingModeUsed;

            dni._overflowX   = pFF->GetLogicalOverflowX(fVerticalLayoutFlow, fWritingModeUsed);
            dni._overflowY   = pFF->GetLogicalOverflowY(fVerticalLayoutFlow, fWritingModeUsed);

            // In design mode, we want to treat overflow:hidden containers as overflow:visible
            // so editors can get to all their content.  This fakes out the display tree
            // so it creates CDispContainer*'s instead of CDispScroller, and hence doesn't
            // clip as hidden normally does. (KTam: #59722)
            // The initial fix is too aggressive; text areas implicitly set overflowX hidden
            // if they're in wordwrap mode.  Fix is to not do this munging for text areas..
            // Need to Revisit this
            // (carled) other elements (like inputText & inputButton) aslo implicitly set this property. (82287)
            if (   pElement->IsDesignMode()
                && pElement->Tag() != ETAG_TEXTAREA
                && pElement->Tag() != ETAG_INPUT
                && pElement->Tag() != ETAG_BUTTON)
            {
                if ( dni._overflowX  == styleOverflowHidden )
                {
                    dni._overflowX = styleOverflowVisible;
                }
                if ( dni._overflowY == styleOverflowHidden )
                {
                    dni._overflowY = styleOverflowVisible;
                }
            }

            if (((   !fHTMLLayout
                     && pElement->Tag() == ETAG_BODY )
                 || (   fHTMLLayout
                     && pElement->Tag() == ETAG_HTML
                     && GetOwnerMarkup()->GetElementClient()
                     && GetOwnerMarkup()->GetElementClient()->Tag() == ETAG_BODY )
                   )
                 && !ElementOwner()->IsInViewLinkBehavior( TRUE ) )
            {
                UpdateScrollInfo(&dni, this);
            }
            else
            {   
                GetDispNodeScrollbarProperties(&dni);
            }

            fVScrollbarForced = dni.IsVScrollbarForced();
            fHScrollbarForced = dni.IsHScrollbarForced();    
        }
    }

    if (    fVScrollbarForced
        ||  ForceVScrollbarSpace()
        ||  _fNeedRoomForVScrollBar)
    {
        prc->right -= pdci->DeviceFromHimetricX(g_sizelScrollbar.cx);
    }

    if (fHScrollbarForced)
    {
        prc->bottom -= pdci->DeviceFromHimetricY(g_sizelScrollbar.cy);
    }

    prc->MoveToOrigin();

    if (prc->right < prc->left)
    {
        prc->right = prc->left;
    }
    if (prc->bottom < prc->top)
    {
        prc->bottom = prc->top;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CLayout::GetClientRect
//
//  Synopsis:   Return client rectangle
//
//              This routine, by default, returns the rectangle in which
//              content should be measured/rendered, the region inside
//              the borders (and scrollbars - if a vertical scrollbar is
//              allowed, space for it is always removed, even if it is not
//              visible).
//              The coordinates are relative to the top of the content -
//              meaning that, for scrolling layouts, the scroll offset is
//              included.
//
//              The following flags can be used to modify this behavior:
//
//                  COORDSYS_xxxx   - Target coordinate system
//                  CLIENTRECT_CONTENT     - Return standard client rectangle (default)
//                  CLIENTRECT_BACKGROUND  - Return the rectangle for the background
//                                    (This generally the same as the default rectangle
//                                     except no space is reserved for the vertical
//                                     scrollbar)
//
//  Arguments:  pDispNode - the dispNode to be examined
//              prc  - returns the client rect
//              cs   - COORDSYS_xxxx
//              crt  - CLIENTRECT_xxxx
//
//  Inline this?  Called frequently, but not in large/tight loops.
//
//-------------------------------------------------------------------------
void
CLayout::GetClientRect(
    const CDispNode *   pDispNode,                        
    CRect *             prc,
    COORDINATE_SYSTEM   cs,
    CLIENTRECT          crt) const
{
    Assert(prc);

    if (pDispNode)
    {
        pDispNode->GetClientRect(prc, crt);

        // NOTE(Donmarsh+Sujalp): This used to be COORDSYS_FLOWCONTENT, instead of the current
        // COORDSYS_CONTENT. FLOWCONTENT was incorrect, because the rect going in was a
        // CONTENT rect and not a FLOWCONTENT rect. That's because GetClientRect returns a
        // CONTENT rect and not a FLOWCONTENT rect. This bug was exposed in bug 83091.
        pDispNode->TransformRect(*prc, COORDSYS_CONTENT, prc, cs);
    }
    else
    {
        *prc = g_Zero.rc;
    }
}

//+---------------------------------------------------------------------------
//
//  Member: CLayout::RestrictPointToClientRect
//
//  Params: [ppt]: The point to be clipped to the client rect of the elements
//                 layout. The point coming in is assumed to be in global
//                 client window coordinates.
//
//  Descr:  This function converts a point in site relative coordinates
//          to global client window coordinates.
//
//----------------------------------------------------------------------------
void
CLayout::RestrictPointToClientRect(POINT *ppt)
{
    RECT rcClient;

    Assert(ppt);

    GetClientRect(&rcClient, COORDSYS_GLOBAL);

    ppt->x = max(ppt->x, rcClient.left);
    ppt->x = min(ppt->x, (long)(rcClient.right - 1));
    ppt->y = max(ppt->y, rcClient.top);
    ppt->y = min(ppt->y, (long)(rcClient.bottom - 1));
}

//+------------------------------------------------------------------------
//
//  Member:     CLayout::GetClippedClientRect
//
//  Synopsis:   Return the clipped client rectangle
//
//              This routine functions the same as GetClientRect
//
//  Arguments:  prc  - returns the client rect
//              cs   - COORDSYS_xxxx
//              crt  - CLIENTRECT_xxxx
//
//-------------------------------------------------------------------------

void
CLayout::GetClippedClientRect(
    CRect *             prc,
    COORDINATE_SYSTEM   cs,
    CLIENTRECT          crt) const
{
    Assert(prc);

    CDispNode * pDispNode = GetElementDispNode();

    if (pDispNode)
    {
        pDispNode->GetClippedClientRect(prc, crt);
        pDispNode->TransformRect(*prc, COORDSYS_FLOWCONTENT, prc, cs);
    }
    else
    {
        *prc = g_Zero.rc;
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CLayout::CalcSize
//
//  Synopsis:   Calculate the size of the object
//
//              Container elements call this on children whenever they need the size
//              of the child during measuring. (The child may or may not measure its
//              contents in response.)
//
//              NOTE: There is no standard helper for assisting containers with
//                    re-sizing immediate descendents. Each container must implement
//                    its own algorithms for sizing children.
//
//  Arguments:  pci       - Current device/transform plus
//                  _smMode     - Type of size to calculate/return
//                                  SIZEMODE_NATURAL  - Return object size using pDI._sizeParent,
//                                                      available size, user specified values,
//                                                      and object contents as input
//                                  SIZEMODE_MMWIDTH  - Return the min/maximum width of the object
//                                  SIZEMODE_SET      - Override/set the object's size
//                                                      (must be minwidth <= size.cx <= maxwidth)
//                                  SIZEMODE_PAGE     - Return object size on the current page
//                                  SIZEMODE_MINWIDTH - Return the minimum width of the object
//                  _grfLayout  - One or more LAYOUT_xxxx flags
//                  _hdc        - Measuring HDC (cannot be used for rendering)
//                  _sizeParent - Size of parent site
//                  _yBaseLine  - y offset of baseline (returned for SIZEMODE_NATURAL)
//              psize     - Varies with passed SIZEMODE
//                          NOTE: Available size is usually that space between the where
//                                the site will be positioned and the right-hand edge. Percentage
//                                sizes are based upon the parent size, all others use available
//                                size.
//                              SIZEMODE_NATURAL  - [in]  Size available to the object
//                                                  [out] Object size
//                              SIZEMODE_MMWIDTH  - [in]  Size available to the object
//                                                  [out] Maximum width in psize->cx
//                                                        Minimum width in psize->cy
//                                                        (If the minimum cannot be calculated,
//                                                         psize->cy will be less than zero)
//                              SIZEMODE_SET      - [in]  Size object should become
//                                                  [out] Object size
//                              SIZEMODE_PAGE     - [in]  Available space on the current page
//                                                  [out] Size of object on the current page
//                              SIZEMODE_MINWIDTH - [in]  Size available to the object
//                                                  [out] Minimum width in psize->cx
//              psizeDefault - Default size (optional)
//
//  Returns:    S_OK if the calcsize is successful
//
//--------------------------------------------------------------------------
//
// NOTE: CalcSize vs. CalcSizeVirtual
//
// CalcSize is a non-virtual method, defined on CLayout only. It should not ever be overridden.
// CalcSizeVirtual does most of actual work, it is virtual, and is defined on CLayout and most
// derivatives.
//
// Everybody interested in an element's size should call CalcSize.
// CalcSizeVirtual is only doing the work that is *different* in various layout classes, and
// is designed to only be called from CLayout and its derivatives (it is protected for that reason).
//
//--------------------------------------------------------

MtDefine( CalcSize, LayoutMetrics, "CalcSize called" );

DWORD
CLayout::CalcSize( CCalcInfo * pci,
                   SIZE * psize,
                   SIZE * psizeDefault)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CLayout::CalcSize L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    PerfDbgLog(tagLayoutCalcSize, this, "+CLayout::CalcSize");
    WHEN_DBG(SIZE psizeIn = *psize);
    WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0

    MtAdd( Mt(CalcSize), 1, 0 );

    // Check that we don't get called recursively on same layout. We'll hang if it happens
    AssertSz(_cNestedCalcSizeCalls == 0, "Nested call to CalcSize! Must be a misuse of CalcSize vs. CalcSizeVirtual.");
    WHEN_DBG(_cNestedCalcSizeCalls++);

    AssertSz(CHK_CALCINFO_PPV(pci), "PPV members of CCalcInfo should stay untouched in browse mode !");

    CCalcInfo calcinfoLocal;
    CCalcInfo *pciOrig = NULL;
    BOOL fResolutionChange = FALSE;
    CLayoutContext * pLayoutContext        = pci->GetLayoutContext();
    CLayoutContext * pDefinedLayoutContext = DefinedLayoutContext();
    BOOL             fViewChain = (pLayoutContext && pLayoutContext->ViewChain());

#if DBG==1
    int cyAvailableHeightDbg = pci->_cyAvail;
#endif

    // For resolution nodes, Initialize local calc info to a different resolution
    // Note: we don't need to do anything if a parent has defined resolution. It is passed in pci.
    if (pDefinedLayoutContext && pDefinedLayoutContext->GetMedia() != mediaTypeNotSet)
    {
        fResolutionChange = TRUE;
        // NOTE (olego) : in a case when pci is CTableCalcInfo all children layouts will never get 
        // this information so at least two pieces of functionality will be broken: 
        // 1) CTableCalcInfo->_fDontSaveHistory will never be set (potential history navigation bug); 
        // 2) counter of table nesting will be wrong;
        calcinfoLocal.Init(pci);

        CUnitInfo const* pUnitInfo = GetView()->GetMeasuringDevice(pDefinedLayoutContext->GetMedia())->GetUnitInfo();
        calcinfoLocal.SetUnitInfo(pUnitInfo);

        pci = &calcinfoLocal;

        // TODO LRECT 112511: this is being done in Container layout anyway, will not be needed when merged.
        pci->SetLayoutContext( pDefinedLayoutContext );

    }

    // save pre-transform sizes
    CSize sizeOrgTransformed = *psize;
    CSize sizeDefaultOrgTransformed = psizeDefault ? *psizeDefault : CSize(0,0);

    // transform input sizes to content coordinates
    CRect rc(*psize); // note: origin unimportant for size transformations
    CDispTransform transform;
    BOOL fTransform = GetElementTransform(&rc, &transform, NULL) && !transform.IsOffsetOnly();
    if (fTransform)
    {
        CSize sizeAvail(0, 0);

        if (fViewChain)
        {
            sizeAvail.cx = psize->cx;
            sizeAvail.cy = pci->_cyAvail;
        }

        if (pci != &calcinfoLocal)
        {
            calcinfoLocal.Init(pci);
            pciOrig = pci;
            pci = &calcinfoLocal;
        }

        transform.GetWorldTransform()->Untransform((CSize *)&pci->_sizeParentForVert);
        transform.GetWorldTransform()->Untransform((CSize *)&pci->_sizeParent);
        transform.GetWorldTransform()->Untransform((CSize *)psize);
        transform.GetWorldTransform()->Untransform((CSize *)&sizeAvail);
        pci->_cyAvail        = sizeAvail.cy;
        pci->_cxAvailForVert = sizeAvail.cx;
        if (psizeDefault)
            transform.GetWorldTransform()->Untransform((CSize *)psizeDefault);
    }

    // save untransformed sizes
    CSize sizeOrg = *psize;
    CSize sizeDefaultOrg = psizeDefault ? *psizeDefault : CSize(0,0);

    DWORD dwResult = CalcSizeVirtual(pci, psize, psizeDefault);



    // save calculated sizes before transformations
    CSize sizeNew = *psize;
    CSize sizeDefaultNew = psizeDefault ? *psizeDefault : CSize(0,0);

    // transform result to parent coordinates
    if (fTransform)
    {
        transform.GetWorldTransform()->Transform((CSize *)psize);

        // in min/max mode size is not a size, but an array of 2 widths.
        // rotation would do wrong thing there, hence special case
        if (pci->_smMode == SIZEMODE_MMWIDTH &&
            transform.GetWorldTransform()->GetAngle() % 1800)
        {
            // It is unlear what to do with min/max info on an arbitrary rotated cell.
            // For now, only handle 90 degrees
            Assert(transform.GetWorldTransform()->GetAngle() % 900 == 0);

            // restore proper order of min and max in psize
            ((CSize *)psize)->Flip();
        }


        if (psizeDefault)
            transform.GetWorldTransform()->Transform((CSize *)psizeDefault);

        // copy ppv information back to original pci
        if (pciOrig)
        {
            pciOrig->_fLayoutOverflow |= pci->_fLayoutOverflow;
            pciOrig->_fHasContent |= pci->_fHasContent;
        }
    }

    // Make sure we are not loosing precision in two-way transforms when sizes don't change
    if (sizeNew == sizeOrg)
        *psize = sizeOrgTransformed;

    if (psizeDefault && sizeDefaultNew == sizeDefaultOrg)
        *psizeDefault = sizeDefaultOrgTransformed;


    // update display node transform if needed
    // TODO 15040: node transform is also set from CalcSizeVirtual. 
    //                 100% of node sizing logic should be here.
    if (fTransform && _pDispNode && _pDispNode->HasUserTransform()
        && (pci->_smMode == SIZEMODE_NATURAL ||
            pci->_smMode == SIZEMODE_SET ||
            pci->_smMode == SIZEMODE_FULLSIZE))

    {
        // NOTE: we currently need this here because CalcSizeVirtual doesn't know if
        //       transformation has changed when pre-transform size is same
        CSize sizeDN;
        GetApparentSize(&sizeDN);
        if (sizeDN != *psize)
        {
            Assert(_pDispNode);
            SizeDispNodeUserTransform(pci, sizeNew, _pDispNode);
        }
    }

    Assert(pciOrig || cyAvailableHeightDbg == pci->_cyAvail);

    if (    pLayoutContext
        &&  pLayoutContext->ViewChain()
        &&  pci->_smMode != SIZEMODE_MMWIDTH
        &&  pci->_smMode != SIZEMODE_MINWIDTH
        &&  ElementCanBeBroken())
    {
        CLayoutBreak *pLayoutBreak;
        pLayoutContext->GetEndingLayoutBreak(ElementOwner(), &pLayoutBreak);

        if (pLayoutBreak)
        {
            pLayoutBreak->CacheAvailHeight(pci->_cyAvail);
        }
    }

    WHEN_DBG(_cNestedCalcSizeCalls--);
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CLayout::CalcSize L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    PerfDbgLog3(tagLayoutCalcSize, this, "-CLayout::CalcSize (%S, %S, m:%d)", ElementOwner()->TagName(), ElementOwner()->GetIdentifier() ? ElementOwner()->GetIdentifier() : L"", pci->_smMode);
    return dwResult;
}

DWORD
CLayout::CalcSizeVirtual( CCalcInfo * pci,
                          SIZE * psize,
                          SIZE * psizeDefault)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));

    Assert(pci);
    Assert(psize);
    Assert(ElementOwner());
    WHEN_DBG(SIZE psizeIn = *psize);
    WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0

    CScopeFlag      csfCalcing(this);
    CElement::CLock LockS(ElementOwner(), CElement::ELEMENTLOCK_SIZING);
    CSaveCalcInfo   sci(pci, this);
    CSize           size(0,0);
    SIZE            sizeOriginal;
    CTreeNode     * pTreeNode = GetFirstBranch();
    DWORD           grfReturn;
    CPeerHolder   * pPH = ElementOwner()->GetLayoutPeerHolder();
    CSize           sizeZero(0,0); // not static to favour data locality; not g_Zero because psizeDefault isn't const*


    GetSize(&sizeOriginal);

    if (_fForceLayout)
    {
        TraceTagEx(( tagCalcSizeDetail, TAG_NONAME, "_fForceLayout is on"));
        pci->_grfLayout |= LAYOUT_FORCE;
        _fForceLayout = FALSE;
    }

    grfReturn  = (pci->_grfLayout & LAYOUT_FORCE);

    if (pci->_grfLayout & LAYOUT_FORCE)
    {
        TraceTagEx(( tagCalcSizeDetail, TAG_NONAME, "LAYOUT_FORCE is on"));
        SetSizeThis( TRUE );
        _fAutoBelow        = FALSE;
        _fPositionSet      = FALSE;
        _fContainsRelative = FALSE;
    }

    //
    // Ensure the display nodes are correct
    // (If they change, then force measuring since borders etc. may need re-sizing)
    //

    if (    pci->IsNaturalMode()
        &&  (EnsureDispNode(pci, (grfReturn & LAYOUT_FORCE)) == S_FALSE))
    {
        grfReturn |= LAYOUT_HRESIZE | LAYOUT_VRESIZE;
        SetSizeThis( TRUE );
    }

    //
    // If this object needs sizing, then determine its size
    //-----------------------------------------------------
    if (   pPH
        && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_FULLDELEGATION))
    {
        // There is a peer layout that wants full_delegation of the sizing.
        POINT pt;

        pt.x = pt.y = 0;

        //NOTE: It doesn't make sense to honor the offsetPoint here
        DelegateCalcSize(BEHAVIORLAYOUTINFO_FULLDELEGATION,
                         pPH, pci, size, &pt, &size);
    }
    else
    {
        if (pci->_smMode != SIZEMODE_SET)
        {
            if ( IsSizeThis() )
            {
                const CFancyFormat * pFF     = pTreeNode->GetFancyFormat();
                const CCharFormat  * pCF     = pTreeNode->GetCharFormat();
                BOOL fVerticalLayoutFlow     = pCF->HasVerticalLayoutFlow();
                BOOL fWritingModeUsed        = pCF->_fWritingModeUsed;
                const CUnitValue & cuvWidth  = pFF->GetLogicalWidth(fVerticalLayoutFlow, fWritingModeUsed);
                const CUnitValue & cuvHeight = pFF->GetLogicalHeight(fVerticalLayoutFlow, fWritingModeUsed);

                // If no defaults are supplied, assume zero as the default
                if (!psizeDefault)
                {
                    psizeDefault = &sizeZero;
                }

                // Set size from user specified or default values
                // (Also, "pin" user specified values to nothing less than zero)
                size.cx = (cuvWidth.IsNullOrEnum() || (pci->_grfLayout & LAYOUT_USEDEFAULT)
                                ? psizeDefault->cx
                                : max(0L, cuvWidth.XGetPixelValue(pci, pci->_sizeParent.cx,
                                                            pTreeNode->GetFontHeightInTwips(&cuvWidth))));

                size.cy = (cuvHeight.IsNullOrEnum() || (pci->_grfLayout & LAYOUT_USEDEFAULT)
                                ? psizeDefault->cy
                                : max(0L, cuvHeight.YGetPixelValue(pci, pci->_sizeParent.cy,
                                                            pTreeNode->GetFontHeightInTwips(&cuvHeight))));

                if (ElementOwner()->Tag() == ETAG_ROOT)
                {
                    _fContentsAffectSize = FALSE;
                }
                else if (ElementOwner()->TestClassFlag(CElement::ELEMENTDESC_BODY))
                {
                    Assert(ElementOwner()->Tag() == ETAG_FRAMESET); // BODY should not get here.

                    if (!GetOwnerMarkup()->IsHtmlLayout())
                    {
                        size.cx = max(size.cx, pci->_sizeParent.cx);
                        size.cy = max(size.cy, pci->_sizeParent.cy);
                    }
                    else
                    {
                        //  We really should set this as psizeDefault...
                        if (cuvWidth.IsNullOrEnum())
                            size.cx = psize->cx;
                        if (cuvHeight.IsNullOrEnum())
                            size.cy = psize->cy;
                    }

                    _fContentsAffectSize = FALSE;
                }
                else
                {
                    _fContentsAffectSize = (    (   cuvWidth.IsNullOrEnum()
                                                ||  cuvHeight.IsNullOrEnum())
                                            &&  !(pci->_grfLayout & LAYOUT_USEDEFAULT));
                }
            }
            else
            {
                GetSize(&size);
            }
        }
        else
        {
            // If the object's size is being set, take the passed size
            size = *psize;
        }


        // at this point the size has been computed, but only delgate if we had to compute
        // the size, and they didn't also ask for full delegation
        if (   pPH
            && IsSizeThis()
            && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_MODIFYNATURAL))
        {
            // There is a peer layout that wants to modify the natural sizing
            POINT pt;

            pt.x = pt.y = 0;

            DelegateCalcSize(BEHAVIORLAYOUTINFO_MODIFYNATURAL,
                             pPH, pci, size, &pt, &size);
        }
    } // end else, not full delegation


    // Return the size of the object (as per the request type)
    switch (pci->_smMode)
    {
    case SIZEMODE_NATURAL:
    case SIZEMODE_NATURALMIN:
    case SIZEMODE_SET:
    case SIZEMODE_FULLSIZE:

        SetSizeThis( FALSE );

        grfReturn  |= LAYOUT_THIS |
                      (size.cx != sizeOriginal.cx
                            ? LAYOUT_HRESIZE
                            : 0)  |
                      (size.cy != sizeOriginal.cy
                            ? LAYOUT_VRESIZE
                            : 0);

        //
        // If size changed, resize display nodes
        //

        if (   _pDispNode
            && (grfReturn & (LAYOUT_FORCE | LAYOUT_HRESIZE | LAYOUT_VRESIZE)))
        {
            SizeDispNode(pci, size);

            if (ElementOwner()->IsAbsolute())
            {
                ElementOwner()->SendNotification(NTYPE_ELEMENT_SIZECHANGED);
            }
        }

        //if there is a map size peer (like glow filter) that silently modifies the size of
        //the disp node, ask what the size is..
        if(HasMapSizePeer())
            GetApparentSize(psize);
        else
            *psize = size;

        break;

    case SIZEMODE_MMWIDTH:
    case SIZEMODE_MINWIDTH:
        // Use the object's width, unless it is a percentage, then use zero
        {
            const CCharFormat *pCF = pTreeNode->GetCharFormat();
            const CUnitValue & cuvWidth = pTreeNode->GetFancyFormat()->GetLogicalWidth(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
            psize->cx = psize->cy = cuvWidth.IsPercent() ? 0 : size.cx;

            //  At this point we want to update psize with a new information accounting filter 
            //  for MIN MAX Pass inside table cell.
            if (HasMapSizePeer())
            {
                //  At this point we want to update psize with a new information accounting filter 
                CRect rectMapped(CRect::CRECT_EMPTY);
                // Get the possibly changed size from the peer
                if(DelegateMapSize(*psize, &rectMapped, pci))
                {
                    psize->cy = psize->cx = rectMapped.Width();
                }
            }

            if(pci->_smMode == SIZEMODE_MINWIDTH)
                psize->cy = 0;
        }
        break;

    case SIZEMODE_PAGE:
        // Use the object's size if it fits, otherwise use zero
        psize->cx = (size.cx < psize->cx
                            ? size.cx
                            : 0);
        psize->cy = (size.cy < psize->cy
                            ? size.cy
                            : 0);
        break;

    }

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    return grfReturn;
}

//+---------------------------------------------------------------------------
//
//  Member : DelegateCalcSize
//
//  synopsis : INternal helper to encapsulate the logic of delegating the
//      calcsize to the layoutBehavior
//
//----------------------------------------------------------------------------
void
CLayout::DelegateCalcSize( BEHAVIOR_LAYOUT_INFO eMode,
                           CPeerHolder        * pPH,
                           CCalcInfo          * pci,
                           SIZE                 sizeNatural,
                           POINT              * pptOffset ,
                           SIZE               * psizeRet )
{
    LONG  lMode;

    Assert(pPH && pci);
    Assert(   ElementOwner()->HasPeerHolder() 
           || ElementOwner()->Tag()==ETAG_BODY
           || ElementOwner()->Tag()==ETAG_FRAMESET 
           || ElementOwner()->Tag()==ETAG_HTML);

    Assert(pptOffset && psizeRet && " internal helper needs return parameters");

    // set the mode enum to pass to the behavior, note the value of MMWidth
    lMode = (pci->_smMode == SIZEMODE_NATURAL) ? BEHAVIORLAYOUTMODE_NATURAL
                : (pci->_smMode == SIZEMODE_MMWIDTH) ? BEHAVIORLAYOUTMODE_MINWIDTH
                : (pci->_smMode == SIZEMODE_MINWIDTH) ? BEHAVIORLAYOUTMODE_MINWIDTH
                : (pci->_smMode == SIZEMODE_SET) ? BEHAVIORLAYOUTMODE_NATURAL
                : (pci->_smMode == SIZEMODE_NATURALMIN) ? BEHAVIORLAYOUTMODE_NATURAL
                : 0;

    if (pci->_fPercentSecondPass)
    {
        lMode |= BEHAVIORLAYOUTMODE_FINAL_PERCENT;
    }

    if (   pci->GetLayoutContext()                  // are we paginateing?
        && pci->GetLayoutContext()->ViewChain()     // and we are not in tables compat-pass
        && pci->GetLayoutContext()->GetMedia() == mediaTypePrint)
                                                    // and we are in print media
    {
        lMode |= BEHAVIORLAYOUTMODE_MEDIA_RESOLUTION;
    }

    // for safety lets only make the call if it is a calcmode that we recognize
    if (lMode)
    {
        POINT                            ptTranslate = {0};
        CPeerHolder::CPeerHolderIterator iter;

        // OM protection code. IMPORTANT. also important: clear this.
        Doc()->GetView()->BlockViewForOM(TRUE);

        //
        // since multiple peers may be attached to this element, we need to provide
        // each of them with this call.  However, for fullDelegation, only the first wins.
        //  the other delgation modes all get multiple callouts.
        //
        if (eMode == BEHAVIORLAYOUTINFO_FULLDELEGATION)
        {
            pPH->GetSize(lMode, sizeNatural, &ptTranslate, pptOffset, psizeRet);
        }
        else
        {
            for (iter.Start(ElementOwner()->GetPeerHolder());
                 !iter.IsEnd();
                 iter.Step())
            {
                if (   iter.PH()->IsLayoutPeer()
                    && iter.PH()->TestLayoutFlags(eMode))
                {
                    iter.PH()->GetSize(lMode, sizeNatural, &ptTranslate, pptOffset, psizeRet);
                }
            }
        }

        if (pci->_smMode == SIZEMODE_MMWIDTH)
        {
            //
            // in this case only, we just made a minsize call above, and now need
            // to call a second time asking for max size. In order to keep this
            // interface function clean, we do not expose the MM pass as a single
            // call the way it is handled internally. Instead we make two calls,
            // and munge the results together into the (internal) return value.
            // as a result, the behavior may be setting a min and max HEIGHT which
            // (today) we ignore.
            //
            lMode = BEHAVIORLAYOUTMODE_MAXWIDTH;
            CSize sizeMax;

            sizeMax.cx = psizeRet->cx;
            sizeMax.cy = psizeRet->cy;

            if (eMode == BEHAVIORLAYOUTINFO_FULLDELEGATION)
            {
                // important, not the different last paramenter, compared to the above call
                pPH->GetSize(lMode, sizeNatural, &ptTranslate, pptOffset, &sizeMax);
            }
            else
            {
                for (iter.Start(ElementOwner()->GetPeerHolder());
                     !iter.IsEnd();
                     iter.Step())
                {
                    if (   iter.PH()->IsLayoutPeer()
                        && iter.PH()->TestLayoutFlags(eMode))
                    {
                        // important, not the different last paramenter, compared to the above call
                        iter.PH()->GetSize(lMode, sizeNatural, &ptTranslate, pptOffset, &sizeMax);
                    }
                }
            }

            // if the user did not change the sizeMax, then the psizeRet remains the same.
            // and everything works as expected
            if ( psizeRet->cx != sizeMax.cx )
            {
                // otherwise use the behavior supplied width as the new max
                psizeRet->cy = sizeMax.cx;
            }
        }

        // get text descent
        LONG lTextDescent = 0;
        if (S_OK == pPH->GetTextDescent(&lTextDescent))
        {
            _yDescent = lTextDescent;
        }

        // cache ptTranslate in the layoutbag
        Assert( pPH->_pLayoutBag);
        pPH->_pLayoutBag->_ptTranslate = ptTranslate;

        // Clear the View state
        Doc()->GetView()->BlockViewForOM( FALSE );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::CalcAbsoluteSize
//
//  Synopsis:   Computes width and height of absolutely positioned element
//
//----------------------------------------------------------------------------
void
CLayout::CalcAbsoluteSize(CCalcInfo * pci,
                          SIZE * psize,
                          CRect * rcSize)
{
    WHEN_DBG(SIZE psizeIn = *psize);
    WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0

    CTreeNode   *pContext      = GetFirstBranch();
    const CFancyFormat * pFF   = pContext->GetFancyFormat();
    const CCharFormat  * pCF   = pContext->GetCharFormat();
    BOOL fVerticalLayoutFlow   = pCF->HasVerticalLayoutFlow();
    BOOL fWritingModeUsed      = pCF->_fWritingModeUsed;
    styleDir bDirection        = pContext->GetCascadedBlockDirection();

    const CUnitValue & cuvWidth  = pFF->GetLogicalWidth(fVerticalLayoutFlow, fWritingModeUsed);
    const CUnitValue & cuvHeight = pFF->GetLogicalHeight(fVerticalLayoutFlow, fWritingModeUsed);
    const CUnitValue & cuvTop    = pFF->GetLogicalPosition(SIDE_TOP, fVerticalLayoutFlow, fWritingModeUsed);
    const CUnitValue & cuvBottom = pFF->GetLogicalPosition(SIDE_BOTTOM, fVerticalLayoutFlow, fWritingModeUsed);
    const CUnitValue & cuvLeft   = pFF->GetLogicalPosition(SIDE_LEFT, fVerticalLayoutFlow, fWritingModeUsed);
    const CUnitValue & cuvRight  = pFF->GetLogicalPosition(SIDE_RIGHT, fVerticalLayoutFlow, fWritingModeUsed);

    BOOL  fLeftAuto   = cuvLeft.IsNullOrEnum();
    BOOL  fRightAuto  = cuvRight.IsNullOrEnum();
    BOOL  fWidthAuto  = cuvWidth.IsNullOrEnum();
    BOOL  fTopAuto    = cuvTop.IsNullOrEnum();
    BOOL  fBottomAuto = cuvBottom.IsNullOrEnum();
    BOOL  fHeightAuto = cuvHeight.IsNullOrEnum();

    Assert(rcSize);
    if (!rcSize)
        return;

    rcSize->SetRect(*psize);

/*
    POINT        ptPos         = g_Zero.pt;
    if (    (   fHeightAuto
            &&  fBottomAuto)
        ||  (   fLeftAuto
            &&  bDirection == htmlDirLeftToRight)
        ||  (   fRightAuto
            &&  bDirection == htmlDirRightToLeft))
    {
        GetUpdatedParentLayout()->GetPositionInFlow(ElementOwner(), &ptPos);
    }
*/

    if(fWidthAuto)
    {
        rcSize->left = !fLeftAuto
                        ? cuvLeft.XGetPixelValue(
                                pci,
                                psize->cx,
                                pContext->GetFontHeightInTwips(&cuvLeft))
                        : 0;

        rcSize->right = !fRightAuto
                        ? psize->cx -
                          cuvRight.XGetPixelValue(
                                pci,
                                psize->cx,
                                pContext->GetFontHeightInTwips(&cuvRight))
                        : psize->cx;
    }
    else
    {
        long offsetX = 0;
        rcSize->SetWidth(cuvWidth.XGetPixelValue(
                                pci,
                                psize->cx,
                                pContext->GetFontHeightInTwips(&cuvWidth)));

        if (bDirection == htmlDirLeftToRight)
        {
            if (!fLeftAuto)
            {
                offsetX = cuvLeft.XGetPixelValue(
                                pci,
                                psize->cx,
                                pContext->GetFontHeightInTwips(&cuvLeft));
            }
            else if (!fRightAuto)
            {
                offsetX = psize->cx - rcSize->right
                          - cuvRight.XGetPixelValue(
                                pci,
                                psize->cx,
                                pContext->GetFontHeightInTwips(&cuvRight));
            }
        }
        else
        {
            if (!fRightAuto)
            {
                offsetX = psize->cx - rcSize->right
                          - cuvRight.XGetPixelValue(
                                pci,
                                psize->cx,
                                pContext->GetFontHeightInTwips(&cuvRight));
            }
            else if (!fLeftAuto)
            {
                offsetX = cuvLeft.XGetPixelValue(
                                pci,
                                psize->cx,
                                pContext->GetFontHeightInTwips(&cuvLeft));
            }
        }

        rcSize->OffsetX(offsetX);
    }


    if(fHeightAuto)
    {

        rcSize->top = !fTopAuto
                        ? cuvTop.YGetPixelValue(
                                pci,
                                psize->cy,
                                pContext->GetFontHeightInTwips(&cuvTop))
                        : 0;

        rcSize->bottom = !fBottomAuto
                        ? psize->cy -
                          cuvBottom.YGetPixelValue(
                                pci,
                                psize->cy,
                                pContext->GetFontHeightInTwips(&cuvBottom))
                        : psize->cy;
    }
    else
    {
        long offsetY = 0;
        rcSize->SetHeight(cuvHeight.YGetPixelValue(
                                pci,
                                psize->cy,
                                pContext->GetFontHeightInTwips(&cuvHeight)));

        if (!fTopAuto)
        {
            offsetY = cuvTop.YGetPixelValue(
                            pci,
                            psize->cy,
                            pContext->GetFontHeightInTwips(&cuvTop));
        }
        else if (!fBottomAuto)
        {
            offsetY = psize->cy - rcSize->bottom
                      - cuvBottom.YGetPixelValue(
                            pci,
                            psize->cy,
                            pContext->GetFontHeightInTwips(&cuvBottom));
        }

        rcSize->OffsetY(offsetY);
    }
}




//+----------------------------------------------------------------------------
//
//  Member:     CLayout::GetRect
//
//  Synopsis:   Return the current rectangle of the layout
//
//  Arguments:  psize - Pointer to CSize
//              cs    - Coordinate system for returned values
//              dwBlockID - Layout block ID
//
//-----------------------------------------------------------------------------

void
CLayout::GetRect(
    CRect *             prc,
    COORDINATE_SYSTEM   cs
    ) const
{
    Assert(prc);
    CDispNode *pdn = _pDispNode;
    if (pdn)
    {
        pdn->GetBounds(prc, cs);
    }
        else
    {
        *prc = g_Zero.rc;
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     CLayout::GetClippedRect
//
//  Synopsis:   Return the current clipped rectangle of the layout
//
//  Arguments:  prc   - Pointer to CRect
//              cs    - Coordinate system for returned values
//              dwBlockID - Layout block ID
//
//-----------------------------------------------------------------------------

void
CLayout::GetClippedRect(CRect *             prc,
                        COORDINATE_SYSTEM   cs    ) const
{
    Assert(prc);

    CDispNode *pdn =  _pDispNode;
    if (pdn)
    {
        pdn->GetClippedBounds(prc, cs);
    }
    else
    {
        *prc = g_Zero.rc;
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     CLayout::GetExpandedRect
//
//  Synopsis:   Return the current expanded rectangle of the layout
//
//  Arguments:  prc - Pointer to CRect
//              cs    - Coordinate system for returned values
//
//-----------------------------------------------------------------------------

void
CLayout::GetExpandedRect(
    CRect *             prc,
    COORDINATE_SYSTEM   cs
    ) const
{
    Assert(prc);
    CDispNode *pdn = _pDispNode;
    if (pdn)
    {
        pdn->GetExpandedBounds(prc, cs);
    }
    else
    {
        *prc = g_Zero.rc;
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     CLayout::GetSize
//
//  Synopsis:   Return the current width/height of the layout
//
//  Arguments:  psize - Pointer to CSize
//
//-----------------------------------------------------------------------------

void
CLayout::GetSize(CSize * psize) const
{
    Assert(psize);

// NOTE: The following would be a nice assert. Unfortunately, it's not easily wired in right now
//         we should do the work to make it possible (brendand)
//    Assert((((CLayout *)this)->TestLock(CElement::ELEMENTLOCK_SIZING)) || !IsSizeThis());

    CDispNode *pdn = _pDispNode;

    *psize = (pdn) ? pdn->GetSize() : g_Zero.size;
}


//+----------------------------------------------------------------------------
//
//  Member:     CLayout::GetApparentSize
//
//  Synopsis:   Return the current width/height of the layout, taking
//              transformations into account.
//
//  Arguments:  psize - Pointer to CSize
//
//-----------------------------------------------------------------------------

void
CLayout::GetApparentSize( CSize * psize ) const
{
    Assert(psize);

// NOTE: The following would be a nice assert. Unfortunately, it's not easily wired in right now
//         we should do the work to make it possible (brendand)
//    Assert((((CLayout *)this)->TestLock(CElement::ELEMENTLOCK_SIZING)) || !IsSizeThis());

    CDispNode *pdn =  _pDispNode;

    *psize = (pdn) ? pdn->GetApparentSize() : g_Zero.size;
}


//+----------------------------------------------------------------------------
//
//  Member:     CLayout::GetContentSize
//
//  Synopsis:   Return the width/height of the content
//
//  Arguments:  psize - Pointer to CSize
//
//-----------------------------------------------------------------------------

void
CLayout::GetContentSize(
    CSize * psize,
    BOOL    fActualSize)
{
    CDispNode * pDispNode = GetElementDispNode();

    Assert(psize);

    if (pDispNode)
    {
        if (pDispNode->IsScroller())
        {
            DYNCAST(CDispScroller, pDispNode)->GetContentSize(psize);
        }
        else
        {
            CRect   rc;

            GetClientRect(&rc);

            psize->cx = rc.Width();
            psize->cy = rc.Height();
        }
    }
    else
    {
        *psize = g_Zero.size;
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     CLayout::GetContainerSize
//
//  Synopsis:   Return the width/height of the container
//
//  Arguments:  psize - Pointer to CSize
//
//-----------------------------------------------------------------------------

void
CLayout::GetContainerSize(
    CSize * psize)
{
    // default implementation returns size of the content
    GetContentSize(psize);
}


//+----------------------------------------------------------------------------
//
//  Member:     CLayout::GetPosition
//
//  Synopsis:   Return the top/left of a layout relative to its container
//
//  Arguments:  ppt     - Pointer to CPoint
//              cs    - Coordinate system for returned values
//
//-----------------------------------------------------------------------------

void
CLayout::GetPosition(
    CPoint *            ppt,
    COORDINATE_SYSTEM   cs) const
{
    Assert(ppt);
    if (    _pDispNode
        &&  _pDispNode->HasParent())
    {
        _pDispNode->TransformPoint(_pDispNode->GetPosition(), COORDSYS_PARENT, ppt, cs);
    }

    else if (ElementOwner()->Tag() == ETAG_TR)
    {
        CElement *  pElement = ElementOwner();
        CLayout *   pLayout  = (CLayout *)this;

        if (cs != COORDSYS_PARENT)
        {
            *ppt = g_Zero.pt;

            Assert(cs == COORDSYS_GLOBAL);

            if (pElement)
            {
                CTreeNode * pNode = pElement->GetFirstBranch();

                if (pNode)
                {
                    CElement * pElementZParent = pNode->ZParent();

                    if (pElementZParent)
                    {
                        CLayout  *  pParentLayout = pElementZParent->GetUpdatedNearestLayout();
                        CDispNode * pDispNode     = pParentLayout->GetElementDispNode(pElementZParent);

                        if (pDispNode)
                        {
                            pDispNode->TransformPoint(*ppt, COORDSYS_FLOWCONTENT, ppt, COORDSYS_GLOBAL);
                        }
                    }
                }
            }
        }
        else
        {
            ppt->x = pLayout->GetXProposed();
            ppt->y = pLayout->GetYProposed();

            // TODO RTL 112514: it is unlear in what direction XProposed is stored, 
            //                  and what is its meaning for a table row.
            //                  We may need to do a coordinate converson sort of like this:
#ifdef NEEDED
            // Because of the ridiculuous way xProposed is used,
            // we need to determine if the layout's parent is RTL, just so we can have
            // a reasonable guess for its meaning.
            if (pElement)
            {
                CLayout *pParentLayout = pElement->GetUpdatedParentLayout();
                long xParentWidth = pParentLayout->GetContainerWidth();

                if (pParentLayout->IsRightToLeft())
                    ppt->x = xParentWidth - ppt->x - pLayout->GetApparentWidth();
            }
#endif
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     CLayout::SetPosition
//
//  Synopsis:   Set the top/left of a layout relative to its container
//
//  Arguments:  ppt     - Pointer to CPoint
//
//-----------------------------------------------------------------------------

void
CLayout::SetPosition(const CPoint &  pt,
                     BOOL            fNotifyAuto)
{
    CPoint      ptOriginal;
    CDispNode * pdn =  _pDispNode;
    if(!pdn)
        return;

    ptOriginal = pdn->GetPosition();

    pdn->SetPosition(pt);

    if (    fNotifyAuto
        &&  _fPositionSet
        &&  pt != ptOriginal
        &&  (_fAutoBelow || _fContainsRelative)
        &&  !ElementOwner()->IsZParent())
    {
        CSize size(pt.x - ptOriginal.x, pt.y - ptOriginal.y);

        if (_fAutoBelow)
        {
            long    cpStart, cpEnd;

            ElementOwner()->GetFirstAndLastCp(&cpStart, &cpEnd);
            NotifyTranslatedRange(size, cpStart, cpEnd);
        }

        if (_fContainsRelative)
        {
            TranslateRelDispNodes(size);
        }
    }

    // if this layout has a window, tell the view that it will have to
    // reorder windows according to Z order
    if (ElementOwner()->GetHwnd())
    {
        GetView()->SetFlag(CView::VF_DIRTYZORDER);
    }

    _fPositionSet = TRUE;
    
    if (ElementOwner()->ShouldFireEvents())
    {
// TODO (IE6 Bug 13574): Queue and fire these after the measuring pass is complete (brendand)
        if (pt.x != ptOriginal.x)
        {
            ElementOwner()->FireOnChanged(DISPID_IHTMLELEMENT_OFFSETLEFT);
            ElementOwner()->FireOnChanged(DISPID_IHTMLELEMENT2_CLIENTLEFT);
        }

        if (pt.y != ptOriginal.y)
        {
            ElementOwner()->FireOnChanged(DISPID_IHTMLELEMENT_OFFSETTOP);
            ElementOwner()->FireOnChanged(DISPID_IHTMLELEMENT2_CLIENTTOP);
        }

        if (   _fPositionedOnce
            && (   pt.y != ptOriginal.y
                || pt.x != ptOriginal.x))
        {
            GetView()->AddEventTask(ElementOwner(), DISPID_EVMETH_ONMOVE);
        }
    }

    _fPositionedOnce = TRUE;
}


//+--------------------------------------------------------------------------
//
// Member:      CLayout::HandleTranslatedRange
//
// Synopsis:    Update the position of the current layout if it is a zparent
//              or any relative children if the content before the current
//              layout changes.
//
// Arguments:   size - size by which the current layout/relative children
//              need to be offset by.
//
//---------------------------------------------------------------------------
void
CLayout::HandleTranslatedRange(
    const CSize &   size)
{
    CTreeNode * pNode = GetFirstBranch();
    const CFancyFormat * pFF = pNode->GetFancyFormat(LC_TO_FC(LayoutContext()));
    const CCharFormat  * pCF = pNode->GetCharFormat(LC_TO_FC(LayoutContext()));

    Assert(_fContainsRelative || ElementOwner()->IsZParent());

    if (   _fContainsRelative
        ||  pFF->_fAutoPositioned)
    {
        CRequest * pRequest = ElementOwner()->GetRequestPtr();

        if (!pRequest || !pRequest->IsFlagSet(CRequest::RF_POSITION))
        {
            if (_fPositionSet)
            {
                Assert(ElementOwner()->GetMarkup()->Root());

                // (Bug 93785) -- abs pos elements that have top/bottom set are auto x-positiond,
                // but NOT auto y-positioned.  And likewise for having right/left set and not top/bottom.
                // to handle this properly, we need to detect this situation and mask the size that we
                // are using to adjust the position.
                CSize sizeTemp(size);

                if (pFF->_bPositionType == stylePositionabsolute)
                {
                    BOOL  fVertical = pCF->HasVerticalLayoutFlow();
                    BOOL  fWritingMode = pCF->_fWritingModeUsed;

                    if (!(   pFF->GetLogicalPosition(SIDE_TOP,
                                                     fVertical,
                                                     fWritingMode).IsNullOrEnum()
                          && pFF->GetLogicalPosition(SIDE_BOTTOM,
                                                     fVertical,
                                                     fWritingMode).IsNullOrEnum()))
                    {
                        // if either top or bottom are set then
                        // we are not auto for this dimension and should not be translated
                        sizeTemp.cy = 0;
                    }

                    if (!(  pFF->GetLogicalPosition(SIDE_LEFT,
                                                    fVertical,
                                                    fWritingMode).IsNullOrEnum()
                        && pFF->GetLogicalPosition(SIDE_RIGHT,
                                                   fVertical,
                                                   fWritingMode).IsNullOrEnum()))
                    {
                        // if either right or left are set then
                        // we are not auto for this dimension and should not be translated
                        sizeTemp.cx = 0;
                    }
                }


                // Normally, if the ElementOwner is a zparent we want to reset the position.
                // However, bodyTags at the root of an IFRAME are carried along by the
                // dispnode of the element in the main tree and should not be adjusted
                // in addition to their parent being moved. bug 88498, et al.
                if(   ElementOwner()->IsZParent()
                        // if we are a body in an iframe, TranslateRelDispNodes
                   && !(   ElementOwner()->Tag() == ETAG_BODY
                        && ElementOwner()->GetMarkup()->Root()->HasMasterPtr()
                        && ElementOwner()->GetMarkup()->Root()->GetMasterPtr()->TagType() == ETAG_IFRAME )
                  )
                {
                    CPoint pt;

                    GetPosition(&pt);
                    SetPosition(pt + sizeTemp);
                }
                else if (_fContainsRelative)
                {
                    Assert(!pRequest);

                    TranslateRelDispNodes(sizeTemp);
                }
            }
        }
        else if (pRequest && pRequest->IsFlagSet(CRequest::RF_AUTOVALID))
        {
            pRequest->ClearFlag(CRequest::RF_AUTOVALID);
        }
    }
}


//+----------------------------------------------------------------------------
//
//  Method:     CLayout::QueueRequest
//
//  Synopsis:   Add a request to the request queue
//
//  Arguments:  rf       - Request type
//              pElement - Element to queue
//
//-----------------------------------------------------------------------------

CRequest *
CLayout::QueueRequest(
    CRequest::REQUESTFLAGS  rf,
    CElement *              pElement)
{
    Assert(pElement);

    //
    //  It is illegal to queue measuring requests while handling measuring requests,
    //  to queue measuring or positioning requests while handling positioning requests,
    //  to queue any requests while handling adorner requests
    //

    Assert(!TestLock(CElement::ELEMENTLOCK_PROCESSMEASURE)  || rf != CRequest::RF_MEASURE);
    Assert(!TestLock(CElement::ELEMENTLOCK_PROCESSPOSITION) || (    rf != CRequest::RF_MEASURE
                                                                &&  rf != CRequest::RF_POSITION));
    Assert(!TestLock(CElement::ELEMENTLOCK_PROCESSADORNERS));
    CRequests * pRequests     = RequestQueue();
    CRequest *  pRequest      = NULL;
    BOOL        fQueueRequest = TRUE;

    //
    //  If no request queue exists, create one
    //

    if (!pRequests)
    {
        pRequests = new CRequests();

        if (!pRequests ||
            !SUCCEEDED(AddRequestQueue(pRequests)))
        {
            delete pRequests;
            goto Error;
        }
    }

    //
    //  Add a request for the element
    //  If the element does not have a request, create one and add to the queue
    //  If the request is already in our queue, just update its state
    //

    pRequest = pElement->GetRequestPtr();

    if (!pRequest)
    {
        pRequest = new CRequest(rf, pElement);

        if (    !pRequest
            ||  !SUCCEEDED(pElement->SetRequestPtr(pRequest)))
        {
            goto Error;
        }
    }
    else
    {
        if (!pRequest->QueuedOnLayout(this))
        {
            pRequest->AddRef();
        }
        else
        {
            fQueueRequest = FALSE;
        }

        pRequest->SetFlag(rf);
    }

    if (    fQueueRequest
        &&  !SUCCEEDED(pRequests->Append(pRequest)))
        goto Error;

    //
    //  Save the layout responsible for the request type
    //

    pRequest->SetLayout(rf, this);

#if DBG==1
    // Support for dumping request queue in debug
    if ( IsTagEnabled( tagLayoutQueueDump ) )
    {
        int cRequests = pRequests->Size();
        CRequest **ppRequest;

        TraceTagEx((tagLayoutQueueDump, TAG_NONAME,
                    "Layout Queue Dump (in QueueRequest()): ly=0x%x, queue size=%d",
                    this,
                    cRequests));

        for (ppRequest = &pRequests->Item(0);
            cRequests;
            ppRequest++, cRequests--)
        {
            (*ppRequest)->DumpRequest();
        }
    }
#endif

    //
    //  Post an appropriate layout task
    //

    TraceTagEx((tagLayoutTasks, TAG_NONAME,
                "Layout Task: Posted on ly=0x%x [e=0x%x,%S sn=%d] by CLayout::QueueRequest() [should be preceded by QueueRequest tracemsg]",
                this,
                _pElementOwner,
                _pElementOwner->TagName(),
                _pElementOwner->_nSerialNumber));

    PostLayoutRequest(rf == CRequest::RF_MEASURE
                            ? LAYOUT_MEASURE
                            : rf == CRequest::RF_POSITION
                                    ? LAYOUT_POSITION
                                    : LAYOUT_ADORNERS);

Cleanup:
    return pRequest;

Error:
    if (pRequest)
    {
        pRequest->DequeueFromLayout(this);
        pRequest->Release();
        pRequest = NULL;
    }
    goto Cleanup;
}


//+----------------------------------------------------------------------------
//
//  Method:     CLayout::FlushRequests
//
//  Synopsis:   Empty the request queue
//
//-----------------------------------------------------------------------------
void
CLayout::FlushRequests()
{
    if (HasRequestQueue())
    {
        CRequests * pRequests = DeleteRequestQueue();
        CRequest ** ppRequest;
        int         cRequests;

        for (ppRequest = &pRequests->Item(0), cRequests = pRequests->Size();
             cRequests;
             ppRequest++, cRequests--)
        {
            AssertSz( (*ppRequest)->QueuedOnLayout(this), "If the request is in our queue, it better think it's queued on us!" );
            (*ppRequest)->DequeueFromLayout(this);
            (*ppRequest)->Release();
        }

        delete pRequests;
    }

    TraceTagEx((tagLayoutTasks, TAG_NONAME,
                "Layout Request Queue flushed for ly=0x%x", this));
}

//+----------------------------------------------------------------------------
//
//  Method:     CLayout::FlushRequest
//
//  Synopsis:   Searches the request queue for the specified request and removes it
//              Returns 1 if the request was actually in the layout's queue
//              (signifying this layout was holding a ref to the request),
//              otherwise returns 0.
//
//-----------------------------------------------------------------------------
int
CLayout::FlushRequest(CRequest *pRequest)
{
    if (HasRequestQueue())
    {
        CRequests * pRequests = RequestQueue();

        // DeleteByValue() returns true if the request is found & deleted from
        // the queue.
        if ( pRequests->DeleteByValue( pRequest ) )
        {
            // Return 1 signifying that this layout was holding a ref
            return 1;
        }
        // NOTE (KTam): maybe delete the queue here if it's empty?
    }
    // We weren't holding a ref (either because we didn't have a queue,
    // or the queue didn't have the request), so return 0.
    return 0;
}

//+----------------------------------------------------------------------------
//
//  Method:     CLayout::ProcessRequest
//
//  Synopsis:   Process a single request
//
//  Arguments:  pci      - Current CCalcInfo
//              pRequest - Request to process
//                  - or -
//              pElement - CElement whose outstanding request should be processed
//
//-----------------------------------------------------------------------------
#pragma warning(disable:4702)           // Unreachable code (invalidly occurs on the IsFlagSet/GetLayout inlines)

BOOL
CLayout::ProcessRequest(
    CCalcInfo * pci,
    CRequest  * pRequest)
{
    Assert(pci);
    Assert(pci->_grfLayout & (LAYOUT_MEASURE | LAYOUT_POSITION | LAYOUT_ADORNERS));
    Assert(pRequest);

    BOOL    fCompleted = TRUE;

    TraceTagEx((tagLayoutTasks, TAG_NONAME,
                "Layout Request Processing: Req=0x%x", pRequest));
    //
    // NOTE (EricVas)
    //
    // Sometimes the element has already left the tree, but the detach of its
    // layout has not been called to dequeue the requests...
    //
    // When Srini fixes this for real, replace this test with an assert that
    // the element in in the tree.
    //
    // Also, beware of elements jumping from tree to tree.
    //
    if (pRequest->GetElement()->IsInMarkup())
    {
        if (    pRequest->IsFlagSet(CRequest::RF_MEASURE)
            &&  pRequest->GetLayout(CRequest::RF_MEASURE) == this)
        {
            if (pci->_grfLayout & LAYOUT_MEASURE)
            {
                CElement::CLock LockRequests(ElementOwner(), CElement::ELEMENTLOCK_PROCESSMEASURE);
                HandleElementMeasureRequest(pci,
                                            pRequest->GetElement(),
                                            IsEditable(TRUE));
                pRequest->ClearFlag(CRequest::RF_MEASURE);
            }
            else
            {
                fCompleted = FALSE;
            }
        }

        if (    pRequest->IsFlagSet(CRequest::RF_POSITION)
            &&  pRequest->GetLayout(CRequest::RF_POSITION) == this)
        {
            if (pci->_grfLayout & LAYOUT_POSITION)
            {
                CElement::CLock LockRequests(ElementOwner(), CElement::ELEMENTLOCK_PROCESSPOSITION);
                HandlePositionRequest(pci,
                                      pRequest->GetElement(),
                                      pRequest->GetAuto(),
                                      pRequest->IsFlagSet(CRequest::RF_AUTOVALID));
                pRequest->ClearFlag(CRequest::RF_POSITION);
            }
            else
            {
                fCompleted = FALSE;
            }
        }

#ifdef ADORNERS
        if (    pRequest->IsFlagSet(CRequest::RF_ADDADORNER)
            &&  pRequest->GetLayout(CRequest::RF_ADDADORNER) == this)
        {
            if (pci->_grfLayout & LAYOUT_ADORNERS)
            {
                CElement::CLock LockRequests(ElementOwner(), CElement::ELEMENTLOCK_PROCESSADORNERS);
                HandleAddAdornerRequest(pRequest->GetAdorner());
                pRequest->ClearFlag(CRequest::RF_ADDADORNER);
            }
            else
            {
                fCompleted = FALSE;
            }
        }
#endif // ADORNERS
    }

    return fCompleted;
}

#pragma warning(default:4702)           // Unreachable code

void
CLayout::ProcessRequest(
    CElement *  pElement)
{
    if (    pElement
        &&  !pElement->IsPositionStatic())
    {
        CRequest * pRequest = pElement->GetRequestPtr();

        if (pRequest)
        {
            CCalcInfo   CI(this);

            CI._grfLayout |= LAYOUT_MEASURE | LAYOUT_POSITION;

            // NOTE (KTam): Every place we call any version of
            // ProcessRequest() we need to make sure we size the calcinfo
            // correctly; it's different for flow lyts than for others.
            // We ought to reorg this code so this is more transparent.
            SizeCalcInfoForChild( &CI );

            ProcessRequest(&CI, pRequest);

            if (!pRequest->IsFlagSet(CRequest::RF_ADDADORNER))
            {
                CRequests * pRequests = RequestQueue();

                if (    pRequests
                    &&  pRequests->DeleteByValue(pRequest))
                {
                    pRequest->DequeueFromLayout(this);
                    pRequest->Release();
                }

                if (    pRequests
                    &&  !pRequests->Size())
                {
                    DeleteRequestQueue();
                    delete pRequests;
                }
            }
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Method:     CLayout::ProcessRequests
//
//  Synopsis:   Process each pending request in the request queue
//
//  Arguments:  pci  - Current CCalcInfo
//              size - Size available to the child element
//
//-----------------------------------------------------------------------------

void
CLayout::ProcessRequests(
    CCalcInfo *     pci,
    const CSize &   size)
{
    Assert(pci);
    Assert(HasRequestQueue());
    Assert(GetView());

    CElement::CLock Lock(ElementOwner(), CElement::ELEMENTLOCK_PROCESSREQUESTS);
    CElement::CLock LockRequests(ElementOwner(), pci->_grfLayout & LAYOUT_MEASURE
                                                        ? CElement::ELEMENTLOCK_PROCESSMEASURE
                                                        : pci->_grfLayout & LAYOUT_POSITION
                                                                ? CElement::ELEMENTLOCK_PROCESSPOSITION
                                                                : CElement::ELEMENTLOCK_PROCESSADORNERS);

    CSaveCalcInfo   sci(pci);
    CRequests *     pRequests;
    CRequest **     ppRequest;
    int             cRequests;
    BOOL            fCompleted = TRUE;

    pci->SizeToParent((SIZE *)&size);

    pRequests = RequestQueue();

    TraceTagEx((tagLayoutTasks, TAG_NONAME,
                "Layout Request Processing: Entered CLayout::ProcessRequests() for ly=0x%x [e=0x%x,%S sn=%d]",
                this,
                _pElementOwner,
                _pElementOwner->TagName(),
                _pElementOwner->_nSerialNumber));

#if DBG==1
    if ( IsTagEnabled( tagLayoutQueueDump ) )
    {
        int cRequests = pRequests->Size();
        CRequest **ppRequest;

        TraceTagEx((tagLayoutQueueDump, TAG_NONAME,
                    "Layout Queue Dump (in ProcessRequests()): ly=0x%x, queue size=%d",
                    this,
                    cRequests));

        for (ppRequest = &pRequests->Item(0);
            cRequests;
            ppRequest++, cRequests--)
        {
            (*ppRequest)->DumpRequest();
        }
    }
#endif


    if (pRequests)
    {
        cRequests = pRequests->Size();

        if (cRequests)
        {
            for (ppRequest = &pRequests->Item(0);
                cRequests;
                ppRequest++, cRequests--)
            {
                if (ProcessRequest(pci, (*ppRequest)))
                {
                    (*ppRequest)->DequeueFromLayout(this);
                }
                else
                {
                    fCompleted = FALSE;
                }
            }
        }

        if (fCompleted)
        {
            pRequests = DeleteRequestQueue();

            cRequests = pRequests->Size();

            if (cRequests)
            {
                for (ppRequest = &pRequests->Item(0);
                    cRequests;
                    ppRequest++, cRequests--)
                {
                    (*ppRequest)->Release();
                }
            }

            delete pRequests;
        }
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CLayout::HitTestPoint
//
//  Synopsis:   Determines if the passed CPoint hits the layout and/or one of its
//              contained elements
//
//  Arguments:  ppNodeElement - Location at which to return CTreeNode of hit element
//              grfFlags      - HT_ flags
//
//  Returns:    HTC
//
//----------------------------------------------------------------------------

HTC
CLayout::HitTestPoint(
    const CPoint &  pt,
    CTreeNode **    ppNodeElement,
    DWORD           grfFlags)
{
    Assert(ppNodeElement);
    return HTC_NO;
}


HRESULT
CLayout::GetChildElementTopLeft(POINT & pt, CElement * pChild)
{
//Commenting out this assert because script operation 
// (like asking offsetTop of <BR> can get us here easily)
//  Assert(0&&"WE should never get here");
    pt.x = pt.y = -1;
    return S_OK;
}

void
CLayout::GetMarginInfo(CParentInfo *ppri,
                       LONG * plLeftMargin, LONG * plTopMargin,
                       LONG * plRightMargin, LONG *plBottomMargin)
{
    CTreeNode * pNodeLayout  = GetFirstBranch();
    const CFancyFormat * pFF = pNodeLayout->GetFancyFormat(LC_TO_FC(LayoutContext()));
    const CParaFormat *  pPF = pNodeLayout->GetParaFormat(LC_TO_FC(LayoutContext()));
    const CCharFormat *  pCF = pNodeLayout->GetCharFormat(LC_TO_FC(LayoutContext()));

    Assert(plLeftMargin || plRightMargin || plTopMargin || plBottomMargin);

    if (plTopMargin)
        *plTopMargin = 0;

    if (plBottomMargin)
        *plBottomMargin = 0;

    if (plLeftMargin)
        *plLeftMargin = 0;

    if (plRightMargin)
        *plRightMargin = 0;

    if (!pFF->_fHasMargins)
        return;

    //
    // For block elements, top & bottom margins are treated as
    // before & afterspace, left & right margins are accumulated into the
    // indent's. So, ignore margin's since they are already factored in.
    // For the BODY, margins are never factored in because there is no
    // "higher level" flow layout.
    //
    if (    !ElementOwner()->IsBlockElement(LC_TO_FC(LayoutContext()))
        ||  !ElementOwner()->IsInlinedElement()
        ||  (   (   Tag() == ETAG_BODY          // Primary element clients are not in a flow layout and do not have before/after space.
                 || Tag() == ETAG_FRAMESET )
            &&  GetOwnerMarkup()->IsHtmlLayout() ))
    {
        CLayout * pParentLayout = GetUpdatedParentLayout(LayoutContext());
        const CCharFormat *pCFParent = pParentLayout ? pParentLayout->GetFirstBranch()->GetCharFormat(LC_TO_FC(pParentLayout->LayoutContext())) : NULL;
        BOOL fParentVertical = pCFParent ? pCFParent->HasVerticalLayoutFlow() : FALSE;
        BOOL fWritingModeUsed = pCF->_fWritingModeUsed;

        const CUnitValue & cuvMarginLeft   = pFF->GetLogicalMargin(SIDE_LEFT, fParentVertical, fWritingModeUsed);
        const CUnitValue & cuvMarginRight  = pFF->GetLogicalMargin(SIDE_RIGHT, fParentVertical, fWritingModeUsed);
        const CUnitValue & cuvMarginTop    = pFF->GetLogicalMargin(SIDE_TOP, fParentVertical, fWritingModeUsed);
        const CUnitValue & cuvMarginBottom = pFF->GetLogicalMargin(SIDE_BOTTOM, fParentVertical, fWritingModeUsed);

        if (plLeftMargin && !cuvMarginLeft.IsNull())
        {
            *plLeftMargin =  cuvMarginLeft.XGetPixelValue(
                                            ppri,
                                            ppri->_sizeParent.cx,
                                            pPF->_lFontHeightTwips);
        }
        if (plRightMargin && !cuvMarginRight.IsNull())
        {
            *plRightMargin = cuvMarginRight.XGetPixelValue(
                                            ppri,
                                            ppri->_sizeParent.cx,
                                            pPF->_lFontHeightTwips);
        }

        if (plTopMargin && !cuvMarginTop.IsNull())
        {
            *plTopMargin = cuvMarginTop.YGetPixelValue(
                                            ppri,
                                            ppri->_sizeParent.cx,
                                            pPF->_lFontHeightTwips);

        }
        if(plBottomMargin && !cuvMarginBottom.IsNull())
        {
            *plBottomMargin = cuvMarginBottom.YGetPixelValue(
                                            ppri,
                                            ppri->_sizeParent.cx,
                                            pPF->_lFontHeightTwips);
        }
    }
}

#ifdef ADORNERS
//+------------------------------------------------------------------------
//
//  Method:     SetIsAdorned
//
//  Synopsis:   Mark or clear a layout as adorned
//
//  Arguments:  fAdorned - TRUE/FALSE value
//
//-------------------------------------------------------------------------

VOID
CLayout::SetIsAdorned(BOOL fAdorned)
{
    _fAdorned = fAdorned;
}
#endif // ADORNERS

//+------------------------------------------------------------------------
//
//  Member:     CLayout::PreDrag
//
//  Synopsis:   Prepares for an OLE drag/drop operation
//
//  Arguments:  dwKeyState  Starting key / button state
//              ppDO        Data object to return
//              ppDS        Drop source to return
//
//-------------------------------------------------------------------------

HRESULT
CLayout::PreDrag(DWORD dwKeyState,
                 IDataObject **ppDO,
                 IDropSource **ppDS)
{
    RRETURN(E_FAIL);
}


//+------------------------------------------------------------------------
//
//  Member:     CLayout::PostDrag
//
//  Synopsis:   Cleans up after an OLE drag/drop operation
//
//  Arguments:  hrDrop      The hr that DoDragDrop came back with
//              dwEffect    The effect of the drag/drop
//
//-------------------------------------------------------------------------

HRESULT
CLayout::PostDrag(HRESULT hrDrop, DWORD dwEffect)
{
    RRETURN(E_FAIL);
}

static HRESULT
CreateDataObject(CDoc * pDoc,
                 IUniformResourceLocator * pUrlToDrag,
                 IDataObject ** ppDataObj)
{
    HRESULT hr = S_OK ;
    IDataObject * pLinkDataObj = NULL;
    CGenDataObject * pDataObj;

    if ( pUrlToDrag )
    {
        hr = THR(pUrlToDrag->QueryInterface(IID_IDataObject, (void **) &pLinkDataObj));
        if (hr)
            goto Cleanup;
    }

    pDataObj = new CGenDataObject(pDoc);
    if (!pDataObj)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    if ( pLinkDataObj )
        pDataObj->_pLinkDataObj = pLinkDataObj;
    pLinkDataObj = NULL;

    *ppDataObj = pDataObj;

Cleanup:
    ReleaseInterface(pLinkDataObj);
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CLayout::DoDrag
//
//  Synopsis:   Start an OLE drag/drop operation
//
//  Arguments:  dwKeyState   Starting key / button state
//              pURLToDrag   Specifies the URL data object if we are
//                           dragging a URL (from <A> or <AREA>).
//
//-------------------------------------------------------------------------

HRESULT
CLayout::DoDrag(DWORD dwKeyState,
                IUniformResourceLocator * pURLToDrag /* = NULL */,
                BOOL fCreateDataObjOnly /* = FALSE */,
                BOOL *pfDragSucceeded /*=NULL*/ ,
                BOOL  fCheckSelection /*=FALSE*/)
{
    HRESULT         hr          = NOERROR;

    LPDATAOBJECT    pDataObj    = NULL;
    LPDROPSOURCE    pDropSource = NULL;
    DWORD           dwEffect, dwEffectAllowed ;
    CElement::CLock Lock(ElementOwner());
    HWND            hwndOverlay = NULL;
    CDoc *          pDoc        = Doc();
#ifndef NO_EDIT
    CParentUndoUnit * pPUU = NULL;
    CDragStartInfo * pDragStartInfo = pDoc->_pDragStartInfo;

    if (!fCreateDataObjOnly)
        pPUU = pDoc->OpenParentUnit( pDoc, IDS_UNDODRAGDROP );
#endif // NO_EDIT

    if ( pfDragSucceeded )
        *pfDragSucceeded = TRUE;

    Assert(ElementOwner()->IsInMarkup());


    if (fCreateDataObjOnly || !pDragStartInfo || !pDragStartInfo->_pDataObj )
    {
        Assert(!pDoc->_pDragDropSrcInfo);

        if ( pURLToDrag ||
            ( ( fCheckSelection || fCreateDataObjOnly ) && ( !pDoc->HasSelection() || pDoc->IsEmptySelection() ) )
           )
        {
            pDoc->_pDragDropSrcInfo = new CDragDropSrcInfo;
            if (!pDoc->_pDragDropSrcInfo)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            pDoc->_pDragDropSrcInfo->_srcType = pURLToDrag ? DRAGDROPSRCTYPE_URL : DRAGDROPSRCTYPE_MISC;

            hr = CreateDataObject(pDoc, pURLToDrag, &pDataObj);
            if (!hr)
                hr = THR(CDummyDropSource::Create(dwKeyState, pDoc, &pDropSource));
        }
        else
            hr = THR(PreDrag(dwKeyState, &pDataObj, &pDropSource));
        if (hr)
        {
            if (S_FALSE == hr)
                hr = S_OK;
            if ( pfDragSucceeded )
                *pfDragSucceeded = FALSE;
            goto Cleanup;
        }

        {
            CElement * pElement = ElementOwner();
            CWindow *  pWindow = pElement->GetCWindowPtr();

            Assert(pWindow);

            IGNORE_HR(pWindow->SetDataObjectSecurity(pDataObj));
        }

        if (pDragStartInfo)
        {
            pDragStartInfo->_pDataObj = pDataObj;
            pDragStartInfo->_pDropSource = pDropSource;
            pDataObj->AddRef();
            pDropSource->AddRef();
            if (fCreateDataObjOnly)
                goto Cleanup;
        }
    }
    else
    {
        pDataObj = pDragStartInfo->_pDataObj;
        pDropSource = pDragStartInfo->_pDropSource;
        pDataObj->AddRef();
        pDropSource->AddRef();
    }

    // Setting this makes checking for self-drag easier
    pDoc->_fIsDragDropSrc = TRUE;
    pDoc->_fIsDragDropSrc = TRUE;

    // Make sure that no object has capture because OLE will want it
    pDoc->SetMouseCapture(NULL, NULL);

    // Force a synchronous redraw; this is necessary, since
    // the drag-drop feedback is drawn with an XOR pen.
    pDoc->UpdateForm();

    // Throw an overlay window over the current site in order
    // to prevent a move of a control into the same control.

    if (IsEditable(TRUE) &&
        pDoc->_pElemCurrent &&
        pDoc->_pElemCurrent->GetHwnd())
    {
        hwndOverlay = pDoc->CreateOverlayWindow(pDoc->_pElemCurrent->GetHwnd());
    }

    if (pDragStartInfo && pDragStartInfo->_dwEffectAllowed != DROPEFFECT_UNINITIALIZED)
        dwEffectAllowed = pDragStartInfo->_dwEffectAllowed;
    else
    {
        if (pURLToDrag)
            dwEffectAllowed = DROPEFFECT_LINK;
        else if (ElementOwner()->IsEditable(/*fCheckContainerOnly*/FALSE))
            dwEffectAllowed = DROPEFFECT_COPY | DROPEFFECT_MOVE;
        else // do not allow move if the site cannot be edited
            dwEffectAllowed = DROPEFFECT_COPY;
    }

    hr = THR(DoDragDrop(
            pDataObj,
            pDropSource,
            dwEffectAllowed,
            &dwEffect));

    if (pDragStartInfo)
        pDragStartInfo->_pElementDrag->Fire_ondragend(0, dwEffect);

    // Guard against unexpected drop-effect (e.g. VC5 returns DROPEFFECT_MOVE
    // even when we specify that only DROPEFFECT_COPY is allowed - bug #39911)
    if (DRAGDROP_S_DROP == hr &&
        DROPEFFECT_NONE != dwEffect &&
        !(dwEffect & dwEffectAllowed))
    {
        CheckSz(FALSE, "Unexpected drop effect returned by the drop target");

        if (DROPEFFECT_LINK == dwEffectAllowed)
        {
            dwEffect = DROPEFFECT_LINK;
        }
        else
        {
            Check(DROPEFFECT_COPY == dwEffectAllowed && DROPEFFECT_MOVE == dwEffect);
            dwEffect = DROPEFFECT_COPY;
        }
    }
    else if (DRAGDROP_S_CANCEL == hr || (DRAGDROP_S_DROP == hr && DROPEFFECT_NONE == dwEffect))
    {
        //  Bug 103279: If the drop didn't succeed due to a cancel or drop with DROPEFFECT_NONE,
        //  then we want to mark this as not succeeded and exit.
        if (pfDragSucceeded)
            *pfDragSucceeded = FALSE;
        hr = S_OK;
        goto Cleanup;
    }

    if (hwndOverlay)
    {
        DestroyWindow(hwndOverlay);
    }

    // NOTE (a-rmead):  The layout can become detached durring the previous DoDragDrop.
    // Happens when the innerHTML is removed or changed by an ondrag binding.
    // <SPAN ondrag='document.body.innerHTML="xx"' STYLE=width:100>DragThisText</SPAN>
    if (    !pURLToDrag
        &&  ElementOwner() && ElementOwner()->IsInMarkup())
    {
        hr = THR(PostDrag(hr, dwEffect));
        if (hr)
            goto Cleanup;
    }
    else
    {
        // DoDragDrop returns either DRAGDROP_S_DROP (for successful drops)
        // or some code for failure/user-cancel. We don't care, so we just
        // set hr to S_OK
        hr = S_OK;

    }

Cleanup:

    if (!fCreateDataObjOnly)
    {
#ifndef NO_EDIT
        pDoc->CloseParentUnit(pPUU, S_OK);
#endif // NO_EDIT

        if (pDoc->_pDragDropSrcInfo)
        {
            //
            // TODO (IE6 bug 13568) marka - SelDragDropSrcInfo is now refcounted.
            // to do - make normal DragDropSrcInfo an object too
            //
            if(DRAGDROPSRCTYPE_SELECTION == pDoc->_pDragDropSrcInfo->_srcType)
            {
                CSelDragDropSrcInfo * pDragInfo = DYNCAST(CSelDragDropSrcInfo, pDoc->_pDragDropSrcInfo);
                pDragInfo->Release();
            }
            else
            {
                delete pDoc->_pDragDropSrcInfo;
            }

            pDoc->_pDragDropSrcInfo = NULL;
        }
    }
    ReleaseInterface(pDataObj);
    ReleaseInterface(pDropSource);

    pDoc->_fIsDragDropSrc = FALSE;
    Assert(fCreateDataObjOnly || !pDoc->_pDragDropSrcInfo);

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CLayout::DropHelper
//
//  Synopsis:   Start an OLE drag/drop operation
//
//  Arguments:  ptlScreen   Screen loc of obj.
//              dwAllowed   Allowed list of drop effects
//              pdwEffect   The effect of the drop
//
//  Notes:      For now, this just handles right button dragging, but any
//              other info can be added here later.
//
//-------------------------------------------------------------------------

HRESULT
CLayout::DropHelper(POINTL ptlScreen, DWORD dwAllowed, DWORD *pdwEffect, LPTSTR lptszFileType)
{
    HRESULT hr = S_OK;

    if (Doc()->_fRightBtnDrag)
    {
        int     iSelection;

        *pdwEffect = DROPEFFECT_NONE;

        if (!Doc()->_fSlowClick)
        {
            hr = THR(Doc()->ShowDragContextMenu(ptlScreen, dwAllowed, &iSelection, lptszFileType));
            if (S_OK == hr)
            {
                *pdwEffect = iSelection;
            }
            else if (S_FALSE == hr)
            {
                hr = S_OK; // no need to propagate S_FALSE
            }
        }
    }

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLayout::DragEnter
//
//  Synopsis:   Setup for possible drop
//
//----------------------------------------------------------------------------

HRESULT
CLayout::DragEnter(
        IDataObject *pDataObj,
        DWORD grfKeyState,
        POINTL ptlScreen,
        DWORD *pdwEffect)
{
    HRESULT hr;

    Doc()->_fDragFeedbackVis = FALSE;

    if (!IsEditable(FALSE /*fCheckContainerOnly*/, TRUE /*fUseSlavePtr*/))
    {
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }

    hr = THR(ParseDragData(pDataObj));
    if ( hr == S_FALSE )
    {
        //
        // S_FALSE is returned by ParseData - if the DragDrop cannot accept the HTML
        // you want to paste.
        //
        *pdwEffect = DROPEFFECT_NONE;
        return S_OK;
    }
    if (hr)
        goto Cleanup;

    hr = THR(InitDragInfo(pDataObj, ptlScreen));
    if (hr)
        goto Cleanup;

    hr = THR(DragOver(grfKeyState, ptlScreen, pdwEffect));

    if (hr)
    {
        hr = THR(DragLeave());
    }

Cleanup:

    RRETURN1 (hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLayout::ParseDragData
//
//  Synopsis:
//
//----------------------------------------------------------------------------

HRESULT
CLayout::ParseDragData(IDataObject *pDataObj)
{
    TCHAR   szText[MAX_PATH];
    HRESULT hr = S_FALSE;


    // Start with flags set to default values.

    Doc()->_fOKEmbed = FALSE;
    Doc()->_fOKLink = FALSE;
    Doc()->_fFromCtrlPalette = FALSE;


    // Now set flags based on content of data object.

    if (OK(GetcfCLSIDFmt(pDataObj, szText)))
    {
        //
        //  Special combination of flags means copy from control box
        //
        Doc()->_fFromCtrlPalette = 1;
        hr = S_OK;
    }
    else
    {
        OBJECTDESCRIPTOR objdesc;

        // The explicit check for S_OK is required here because
        // OleQueryXXXFromData() returns other success codes.
        Doc()->_fOKEmbed = OleQueryCreateFromData(pDataObj) == S_OK;
        Doc()->_fOKLink = OleQueryLinkFromData(pDataObj) == S_OK;

        // NOTE: (anandra) Try to get the object descriptor immediately
        // to see if we can create a site for this thing.  This will
        // eventually change when we want to support dragging of html
        // files into the form

        if (!OK(GetObjectDescriptor(pDataObj, &objdesc)))
        {
            Doc()->_fOKEmbed = FALSE;
            Doc()->_fOKLink = FALSE;
        }
        else
        {
            hr = S_OK;
        }
    }

    return hr;
}



//+---------------------------------------------------------------------------
//
//  Member:     CLayout::DragOver
//
//  Synopsis:   Determine whether this would be a move, copy, link
//              or null operation and manage UI feedback
//
//----------------------------------------------------------------------------

HRESULT
CLayout::DragOver(DWORD grfKeyState, POINTL ptlScreen, LPDWORD pdwEffect)
{
    HRESULT hr      = S_OK;

    CDoc* pDoc = Doc();
    Assert(pdwEffect != NULL);

    grfKeyState &= MK_CONTROL | MK_SHIFT;

    if (!IsEditable(FALSE /*fCheckContainerOnly*/, TRUE /*fUseSlavePtr*/))
    {
        *pdwEffect = DROPEFFECT_NONE;               // No Drop into design mode
    }
    else if (pDoc->_fFromCtrlPalette)
    {
        *pdwEffect &= DROPEFFECT_COPY;              // Drag from Control Palette
    }
    else if (grfKeyState == (MK_CONTROL | MK_SHIFT) &&
            pDoc->_fOKLink &&
            (*pdwEffect & DROPEFFECT_LINK))
    {
        *pdwEffect = DROPEFFECT_LINK;               // Control-Shift equals create link
    }
    else if (grfKeyState == MK_CONTROL &&
            (*pdwEffect & DROPEFFECT_COPY))
    {
        *pdwEffect = DROPEFFECT_COPY;               // Control key = copy.
    }
    else if (*pdwEffect & DROPEFFECT_MOVE)
    {
        *pdwEffect = DROPEFFECT_MOVE;               // Default to move
    }
    else if (*pdwEffect & DROPEFFECT_COPY)
    {
        *pdwEffect = DROPEFFECT_COPY;               // If can't move, default to copy
    }
    else if ((pDoc->_fOKLink) &&
            (*pdwEffect & DROPEFFECT_LINK))
    {
        *pdwEffect = DROPEFFECT_LINK;               // If can't copy, default to link
    }
    else
    {
        *pdwEffect = DROPEFFECT_NONE;
    }


    //
    // Drag & Drop with pointers in the same flow layout will do a copy not a move
    // ( as a delete across flow layouts is not allowed).
    //
    if ( *pdwEffect & DROPEFFECT_MOVE &&
         pDoc->_pDragDropSrcInfo &&
         DRAGDROPSRCTYPE_SELECTION == pDoc->_pDragDropSrcInfo->_srcType)
    {
        CSelDragDropSrcInfo * pDragInfo = DYNCAST(CSelDragDropSrcInfo, pDoc->_pDragDropSrcInfo);
        if ( ! pDragInfo->IsInSameFlow() )
        {
            *pdwEffect = DROPEFFECT_COPY;
        }
    }

    //
    // Draw or erase feedback as appropriate.
    //
    if (*pdwEffect == DROPEFFECT_NONE)
    {
        // Erase previous feedback.
        DragHide();
    }
    else
    {
        hr = THR(UpdateDragFeedback( ptlScreen ));
        if (pDoc->_fSlowClick)
        {
            *pdwEffect = DROPEFFECT_NONE ;
        }
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::DragLeave
//
//  Synopsis:   Remove any user feedback
//
//----------------------------------------------------------------------------

HRESULT
CLayout::DragLeave()
{
    DragHide();
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::DragHide
//
//  Synopsis:   Remove any user feedback
//
//----------------------------------------------------------------------------

void
CLayout::DragHide()
{
    if (Doc()->_fDragFeedbackVis)
    {
        DrawDragFeedback(FALSE);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::DrawZeroBorder
//
//  Synopsis:   Draw the "Zero Grey Border" around the input.
//
//----------------------------------------------------------------------------

void
CLayout::DrawZeroBorder(CFormDrawInfo *pDI)
{
    Assert(GetUpdatedParentLayout()->IsEditable() && IsShowZeroBorderAtDesignTime());

    CColorValue cv        = ElementOwner()->GetFirstBranch()->GetCascadedbackgroundColor();
    CDispNode * pDispNode = GetElementDispNode(ElementOwner());
    pDI->_hdc = NULL;       // Whack the DC so we force client clipping.
    XHDC        hdc       = pDI->GetDC(TRUE);
    COLORREF    cr;

    if ( cv._dwValue == 0 )
    {
        cr = 0x00ffffff & (~(cv.GetColorRef()));
    }
    else
    {
        cr = ZERO_GREY_COLOR ;
    }

#if DBG == 1
    if ( IsTagEnabled(tagShowZeroGreyBorder))
    {
        cr = RGB(0xFF,0x00,0x00);
    }
#endif

    if ( ! pDispNode->HasBorder() )
    {
        HBRUSH hbr, hbrOld;
        hbr = ::CreateSolidBrush(cr );
        hbrOld = (HBRUSH) ::SelectObject( hdc, hbr );


        RECT rcContent;
        // bug fix:100405(chandras) : GetClientRect changed to DispNode->GetClientRect as one
        //                    transformation was done extra in GetClientRect before
        //
        pDispNode->GetClientRect(& rcContent, CLIENTRECT_CONTENT);

        if (Tag() == ETAG_TABLE)
            rcContent.bottom -= GetCaptionHeight(ElementOwner());

        PatBltRect( hdc, (RECT*) &rcContent , 1, PATCOPY );
        SelectBrush( hdc, hbrOld );
        DeleteBrush( hbr );
    }
    else
    {
        HPEN hPen, hPenOld;
        CRect rcBorder;
        pDispNode->GetBorderWidths( &rcBorder );

        hPen = CreatePen( PS_SOLID, 1, cr );
        hPenOld = SelectPen( hdc, hPen );
        RECT rcContent;

        // bug fix : 72161(chandras) GetRect changed to GetClientRect as one
        //                           transformation was done extra in GetRect before
        //
        pDispNode->GetClientRect(& rcContent, CLIENTRECT_CONTENT);

        if (Tag() == ETAG_TABLE)
            rcContent.bottom -= GetCaptionHeight(ElementOwner());

        int left, top, bottom, right;
        left = rcContent.left;
        top = rcContent.top;
        right = rcContent.right;
        bottom = rcContent.bottom;

        if ( rcBorder.left == 0 )
        {
            MoveToEx(  hdc, left, top , NULL );
            LineTo( hdc, left , bottom );
        }
        if ( rcBorder.right == 0 )
        {
            MoveToEx(  hdc, (right-left), top , NULL );
            LineTo( hdc, (right-left), bottom );
        }
        if ( rcBorder.top == 0 )
        {
            MoveToEx(  hdc, left , top, NULL );
            LineTo( hdc, (right-left), top );
        }
        if ( rcBorder.bottom == 0 )
        {
            MoveToEx(  hdc, left , bottom, NULL );
            LineTo( hdc, (right-left) , bottom );
        }
        SelectPen( hdc, hPenOld );
        DeletePen( hPen );
    }
}

void
DrawTextSelectionForRect(XHDC hdc, CRect *prc, CRect *prcClip, BOOL fSwapColor)
{
    static short bBrushBits [8] = {0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55, 0xaa, 0x55} ;
    HBITMAP hbm;
    HBRUSH hBrush, hBrushOld;
    COLORREF crOldBk, crOldFg;
    CPoint ptOrg;

    // Text selection feedback for sites is painting every other pixel
    // with the color being used for painting the background for selections.

    // Select the color we want to paint evey other pixel with
    crOldBk = SetBkColor (hdc, GetSysColor (
                                            fSwapColor ? COLOR_HIGHLIGHTTEXT : COLOR_HIGHLIGHT));

    hbm = CreateBitmap (8, 8, 1, 1, (LPBYTE)bBrushBits);
    hBrush = CreatePatternBrush (hbm);

    ptOrg = prc->TopLeft();
    if (ptOrg.x != 0)
    {
        ptOrg.x -= ptOrg.x % 8;
    }
    if (ptOrg.y != 0)
    {
        ptOrg.y -= ptOrg.y % 8;
    }

    SetBrushOrgEx( hdc, ptOrg.x, ptOrg.y, NULL );

    hBrushOld = (HBRUSH)SelectObject (hdc, hBrush);

    // Now, for monochrome bitmap brushes, 0: foreground, 1:background.
    // We've set the background color to the selection color, set the fg
    // color to black, so that when we OR, every other screen pixel will
    // retain its color, and the remaining with have the selection color
    // OR'd into them.
    crOldFg = SetTextColor (hdc, RGB(0,0,0));

    PatBlt (hdc, prc->left, prc->top,
            prc->right - prc->left,
            prc->bottom - prc->top,
            DST_PAT_OR);

    // Now, set the fg color to white so that when we AND, every other screen
    // pixel still retains its color, while the remaining have just the
    // selection in them. This gives us the effect of transparency.
    SetTextColor (hdc, RGB(0xff,0xff,0xff));

    PatBlt (hdc, prc->left, prc->top,
            prc->right - prc->left,
            prc->bottom - prc->top,
            DST_PAT_AND);   
    SelectObject (hdc, hBrushOld);
    DeleteObject (hBrush);
    DeleteObject (hbm);

    SetTextColor (hdc, crOldFg);
    SetBkColor   (hdc, crOldBk);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLayout::DrawTextSelectionForSite
//
//  Synopsis:   Draw the text selection feed back for the site
//
//----------------------------------------------------------------------------
void
CLayout::DrawTextSelectionForSite(CFormDrawInfo *pDI, const RECT *prcfClip)
{
    if (_fTextSelected)
    {
        CRect rcContent;
        GetClippedRect( & rcContent, COORDSYS_FLOWCONTENT );

        DrawTextSelectionForRect(pDI->GetDC(), &rcContent, &pDI->_rcClip, _fSwapColor);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::Draw
//
//  Synopsis:   Draw the site and its children to the screen.
//
//----------------------------------------------------------------------------

void
CLayout::Draw(CFormDrawInfo *pDI, CDispNode *)
{
    return;
}


void
CLayout::DrawBackground(
    CFormDrawInfo *     pDI,
    CBackgroundInfo *   pbginfo,
    RECT *              prcDraw)
{
    CRect       rcBackground;
    SIZE        sizeImg;
    CDoc    *   pDoc      = Doc();
    BOOL        fPrintDoc = ElementOwner()->GetMarkupPtr()->IsPrintMedia();
    XHDC        hdc;
    COLORREF    crBack    = pbginfo->crBack;
    CImgCtx *   pImgCtx   = pbginfo->pImgCtx;
    ULONG       ulState;

    if (pImgCtx)
    {
        ulState = pImgCtx->GetState(FALSE, &sizeImg);
    }
    else
    {
        ulState = 0;
        sizeImg = g_Zero.size;
    }

    Assert(pDoc);

    if (!(ulState & IMGLOAD_COMPLETE))
    {
        pImgCtx = NULL;
    }

    Assert(prcDraw);

    rcBackground = *prcDraw;

    IntersectRect(&rcBackground, &pDI->_rcClip, &rcBackground);

    hdc = pDI->GetDC();

        {
                // N.B. (johnv) We only blt the background if we do not have an
                // image, or if the image rect is not identical to the clip rectangle.
                // We can also blt four times (around the image) if this turns out
                // to be faster.
                if (    crBack != COLORREF_NONE
                        &&  (   !pImgCtx
                                ||  !(ulState & IMGTRANS_OPAQUE)
                                ||  !EqualRect(&rcBackground, &pbginfo->rcImg)))
                {
                        PatBltBrush(hdc, &rcBackground, PATCOPY, crBack);
                }
        }

        if (pImgCtx )
        {
                sizeImg.cx = pDI->DeviceFromDocPixelsX(sizeImg.cx);
                sizeImg.cy = pDI->DeviceFromDocPixelsY(sizeImg.cy);

                if (sizeImg.cx == 0 || sizeImg.cy == 0)
                        return;

                if (crBack == COLORREF_NONE)
                        crBack = pbginfo->crTrans;

        CSize sizeLayout = pDI->_rc.Size();

        // We need to pass the physical (non-memory) DC to the finction because on
        // the multimonitor W2k computers CreateCompatibleBitmap produces strange
        //  resutls (unless the Hardware acceleration of the primary monitor card is lowered).
        pImgCtx->TileEx(hdc,
                    &pbginfo->ptBackOrg,
                    &pbginfo->rcImg,
                    (fPrintDoc || pDI->IsDeviceScaling())
                        ? &sizeImg
                        : NULL,
                    crBack,
                    pDoc->GetImgAnimState(pbginfo->lImgCtxCookie),
                    pDI->DrawImageFlags(),
                    GetFirstBranch()->GetCharFormat()->HasVerticalLayoutFlow(),
                    sizeLayout, sizeImg, &(pDI->_hic));
    }

    WHEN_DBG(CDebugPaint::PausePaint(tagPaintWait));
}

HRESULT
CLayout::GetDC(LPRECT prc, DWORD dwFlags, HDC *phDC)
{
    CDoc    * pDoc = Doc();

    Assert(pDoc);
    Assert((dwFlags & 0xFF00) == 0);

    dwFlags |=  (   (pDoc->_bufferDepth & OFFSCR_BPP) << 16)
                |   (pDoc->_cSurface   ? OFFSCR_SURFACE   : 0)
                |   (pDoc->_c3DSurface ? OFFSCR_3DSURFACE : 0);

    return pDoc->GetDC(prc, dwFlags, phDC);
}


HRESULT
CLayout::ReleaseDC(HDC hdc)
{
    return Doc()->ReleaseDC(hdc);
}


//+-----------------------------------------------------------------------
//
//  Function:   Invalidate
//
//  Synopsis:   Invalidate the passed rectangle or region
//
//------------------------------------------------------------------------
void
CLayout::Invalidate(
    const RECT&         rc,
    COORDINATE_SYSTEM   cs)
{
    if (    Doc()->_state >= OS_INPLACE
        &&  GetFirstBranch()
        && _pDispNode)
    {
        _pDispNode->Invalidate((const CRect&) rc, cs);
    }
}


void
CLayout::Invalidate(
    LPCRECT prc,
    int     cRects,
    LPCRECT prcClip)
{
    CDispNode * pdn = _pDispNode;
    if (    Doc()->_state >= OS_INPLACE
        &&  GetFirstBranch()
        &&  pdn)
    {
        if (!prc)
        {
            pdn->Invalidate();
        }
        else
        {
            Assert( !cRects
                ||  prc);
            for (int i=0; i < cRects; i++, prc++)
            {
                pdn->Invalidate((CRect &)*prc, COORDSYS_FLOWCONTENT);
            }
        }
    }
}

void
CLayout::Invalidate(
    HRGN    hrgn)
{
    if (    Doc()->_state >= OS_INPLACE
        &&  GetFirstBranch()
        &&  _pDispNode)
    {
        _pDispNode->Invalidate(hrgn, COORDSYS_FLOWCONTENT);
    }
}


extern void CalcBgImgRect(CTreeNode * pNode, CFormDrawInfo * pDI,
                          const SIZE * psizeObj, const SIZE * psizeImg,
                          CPoint *pptBackOrig, CBackgroundInfo *pbginfo);

//+------------------------------------------------------------------------
//
//  Member:     GetBackgroundInfo
//
//  Synopsis:   Fills out a background info for which has details on how
//              to display a background color &| background image.
//
//-------------------------------------------------------------------------

BOOL
CLayout::GetBackgroundImageInfoHelper(
    CFormDrawInfo *     pDI,
    CBackgroundInfo *   pbginfo )
{
    CPoint      ptBackOrig;
    CSize       sizeImg;
    CSize       sizeClient;

    Assert(pDI);
    Assert(pbginfo->pImgCtx);

    pbginfo->pImgCtx->GetState(FALSE, &sizeImg);

    if (    pDI->IsDeviceScaling() 
        ||  (   LayoutContext()
            &&  LayoutContext()->GetMedia() != mediaTypeNotSet) )
    {
        // transform sizeImage to physical coordinates
        sizeImg.cx = pDI->DeviceFromDocPixelsX(sizeImg.cx);
        sizeImg.cy = pDI->DeviceFromDocPixelsY(sizeImg.cy);
    }

    // client size, for the purposes of background image positioning,
    // is the greater of our content size or our client rect
    CRect rcClient;
    GetClientRect(&rcClient, CLIENTRECT_BACKGROUND );

    if (!pbginfo->fFixed)
    {
        GetContentSize(&sizeClient, FALSE);
        sizeClient.Max(rcClient.Size());
    }
    else
    {
        // note: background rectangle is different for fixed background, but here we only need its size
        sizeClient = rcClient.Size();
    }

    // figure out background image rectangle and origin
    CalcBgImgRect(GetFirstBranch(), pDI, &sizeClient, &sizeImg, &ptBackOrig, pbginfo);

    // Translate background rectangle
    if (pbginfo->fFixed)
    {
        // translate image rectangle and origin to scroll amount.
        // this ensures that background doesn't move relative to scroller
        TransformRect(&pbginfo->rcImg, COORDSYS_SCROLL, COORDSYS_CONTENT);
        TransformPoint(&ptBackOrig, COORDSYS_SCROLL, COORDSYS_CONTENT);
    }
    else
    {
        // translate background rectangle and origin point to the top left
        // of bounding rect (which is not zero in RTL)
        OffsetRect(&pbginfo->rcImg, pDI->_rc.left, pDI->_rc.top);
        ptBackOrig.x += pDI->_rc.left;
        ptBackOrig.y += pDI->_rc.top;
    }

    pbginfo->ptBackOrg.x = ptBackOrig.x;
    pbginfo->ptBackOrg.y = ptBackOrig.y;

    IntersectRect(&pbginfo->rcImg, pDI->ClipRect(), &pbginfo->rcImg);

    return TRUE;
}


BOOL
CLayout::GetBackgroundInfoHelper(
    CBackgroundInfo *    pbginfo)
{
    const CFancyFormat *    pFF   = GetFirstBranch()->GetFancyFormat(LC_TO_FC(LayoutContext()));
          CColorValue       cv    = (CColorValue)(pFF->_ccvBackColor);

    pbginfo->pImgCtx       = ElementOwner()->GetBgImgCtx(LC_TO_FC(LayoutContext()));
    pbginfo->lImgCtxCookie = pFF->_lImgCtxCookie;
    pbginfo->fFixed        = (  pbginfo->pImgCtx
                            &&  pFF->_fBgFixed);

    pbginfo->crBack  = cv.IsDefined()
                            ? cv.GetColorRef()
                            : COLORREF_NONE;
    pbginfo->crTrans = COLORREF_NONE;

    GetBgImgSettings(pFF, pbginfo);

    return TRUE;
}

BOOL
CLayout::GetBackgroundInfo(
    CFormDrawInfo *     pDI,
    CBackgroundInfo *   pbginfo,
    BOOL                fAll)
{   
    Assert(pDI || !fAll);

    // Assert that pDI->rc is zero-based, unless there is a content offset.
    // If that is not true, we need to understand why, and probably make other adjustments to rcImg
    AssertSz(pDI == NULL ||
             pDI->_rc.left == 0 && pDI->_rc.top == 0 ||
             _pDispNode && _pDispNode->HasContentOrigin() &&
             _pDispNode->GetContentOrigin().cx == -pDI->_rc.left &&
             _pDispNode->GetContentOrigin().cy == -pDI->_rc.top,
             "Non-zero based bounding rect in GetBackgroundInfo");
    
    GetBackgroundInfoHelper(pbginfo);

    if (    fAll
        &&  pbginfo->pImgCtx)
    {
        GetBackgroundImageInfoHelper(pDI, pbginfo);
    }

    return TRUE;
}


//
// Scrolling
//

//+------------------------------------------------------------------------
//
//  Member:     Attach/DetachScrollbarController
//
//  Synopsis:   Manage association between this CLayout and the CScrollbarController
//
//-------------------------------------------------------------------------

void
CLayout::AttachScrollbarController(
    CDispNode * pDispNode,
    CMessage *  pMessage)
{
    CScrollbarController::StartScrollbarController(
        this,
        DYNCAST(CDispScroller, pDispNode),
        Doc(),
        g_uiDisplay.DeviceFromHimetricX(g_sizelScrollbar.cx),
        pMessage);
}

void
CLayout::DetachScrollbarController(
    CDispNode * pDispNode)
{
    CScrollbarController *  pSBC = TLS(pSBC);

    if (    pSBC
        &&  pSBC->GetLayout() == this)
    {
        CScrollbarController::StopScrollbarController();
    }
}


//+------------------------------------------------------------------------
//
//  Member:     ScrollElementIntoView
//
//  Synopsis:   Scroll the element into view
//
//-------------------------------------------------------------------------

HRESULT
CLayout::ScrollElementIntoView( CElement *  pElement,
                                SCROLLPIN   spVert,
                                SCROLLPIN   spHorz)
{
    Assert(ElementOwner()->IsInMarkup());

    if (!pElement)
    {
        pElement = ElementOwner();
    }

    //
    //  NOTE:
    //  This code should NOT test for CFlowLayout, using CElement::GetBoundingRect should suffice. Unfortunately,
    //  deep underneath this funtion (specifically in CDisplay::RegionFromElement) that behaves differently when
    //  called from a "scroll into view" routine. CFlowLayout::ScrollRangeIntoView can and does pass the correct
    //  flags such that everything works right - but CElement::GetBoundingRect cannot and does not so the rectangle
    //  it gets differs slightly thus affecting scroll into view. Blah!
    //
    //  Eventually, CDisplay::RegionFromElement should not have such odd dependencies or they should be formalized.
    //  Until then, this dual branch needs to exist. (brendand)
    //

    if (IsFlowLayout())
    {
        long    cpMin;
        long    cpMost;

        if (pElement != ElementOwner())
        {
            if (!pElement->IsAbsolute() || pElement->Tag() == ETAG_UNKNOWN)
            {
                cpMin  = max(GetContentFirstCp(), pElement->GetFirstCp());
                cpMost = min(GetContentLastCp(),  pElement->GetLastCp());
            }
            else
            {
                // since this layout is absolutely positioned, we don't want
                // to use the CPs, since these position its location-in-source.
                // instead it is just as simple to get the rect, and scroll
                // that into view directly.
                CRect rc;

                Assert(pElement->GetUpdatedLayout() && " youre about to crash");
                pElement->GetUpdatedLayout()->GetExpandedRect(&rc, COORDSYS_PARENT);

                ScrollRectIntoView(rc, spVert, spHorz);
                return S_OK;
            }
        }
        else
        {
            cpMin  =
            cpMost = -1;
        }

        RRETURN1(ScrollRangeIntoView(cpMin, cpMost, spVert, spHorz), S_FALSE);
    }

    else
    {
        CRect   rc;

        if (S_OK != pElement->EnsureRecalcNotify())
            return E_FAIL;

        pElement->GetBoundingRect(&rc);
        ScrollRectIntoView(rc, spVert, spHorz);
        return S_OK;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::ScrollRangeIntoView
//
//  Synopsis:   Scroll the given range into view
//
//  Arguments:  cpStart     First cp of range
//              cpEnd       Last cp of range
//              spVert      vertical scroll pin option
//              spHorz      horizontal scroll pin option
//
//----------------------------------------------------------------------------

HRESULT
CLayout::ScrollRangeIntoView( long        cpMin,
                              long        cpMost,
                              SCROLLPIN   spVert,
                              SCROLLPIN   spHorz)
{
    CSize   size;

    ElementOwner()->SendNotification(NTYPE_ELEMENT_ENSURERECALC);

    GetSize(&size);

    ScrollRectIntoView(CRect(size), spVert, spHorz);

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::ScrollRectIntoView
//
//  Synopsis:   Scroll the given rectangle (in content coordinates) into view.
//
//  Arguments:  rc          rect in content coordinates
//              spVert      vertical scroll pin option
//              spHorz      horizontal scroll pin option
//
//----------------------------------------------------------------------------

void
CLayout::ScrollRectIntoView( const CRect & rc,
                             SCROLLPIN     spVert,
                             SCROLLPIN     spHorz)
{
    Assert(spVert != SP_MAX && spHorz != SP_MAX);
    CPaintCaret hc( ElementOwner()->Doc()->_pCaret ); // Hide the caret for scrolling
    if (_pDispNode)
    {
        if (OpenView(FALSE, TRUE))
        {
            _pDispNode->ScrollRectIntoView(
                rc,
                COORDSYS_FLOWCONTENT,
                spVert,
                spHorz);

            EndDeferred();
        }
    }
    else
    {
        CLayout *   pLayout = GetUpdatedParentLayout();

        if (pLayout)
        {
            pLayout->ScrollElementIntoView(ElementOwner(), spVert, spHorz);
        }
    }
}


HRESULT BUGCALL
CLayout::HandleMessage(CMessage  * pMessage)
{
    HRESULT     hr          = S_FALSE;
    CDispNode * pDispNode   = GetElementDispNode();
    BOOL        fIsScroller = (pDispNode && pDispNode->IsScroller());
    CDoc*       pDoc        = Doc();

    BOOL        fInBrowse   = !IsDesignMode();

    if (!ElementOwner()->CanHandleMessage())
    {
        // return into ElementOwner()'s HandleMessage
        goto Cleanup;
    }

    //
    //  Handle scrollbar messages
    //

    if (    fIsScroller
        &&  (   (pMessage->htc == HTC_HSCROLLBAR && pMessage->pNodeHit->Element() == ElementOwner())
            ||  (pMessage->htc == HTC_VSCROLLBAR && pMessage->pNodeHit->Element() == ElementOwner()))
        &&  (   (  pMessage->message >= WM_MOUSEFIRST
#ifndef WIN16
                &&  pMessage->message != WM_MOUSEWHEEL
#endif
                &&  pMessage->message <= WM_MOUSELAST)
            ||  pMessage->message == WM_SETCURSOR
            ||  pMessage->message == WM_CONTEXTMENU ))
    {
        hr = HandleScrollbarMessage(pMessage, ElementOwner());
        if (hr != S_FALSE)
            goto Cleanup;
    }

    switch (pMessage->message)
    {
    case WM_CONTEXTMENU:
        if (!pDoc->_pInPlace->_fBubbleInsideOut)
        {
            int iContextMenu = CONTEXT_MENU_DEFAULT;

            // If the element is editable, we want to
            // display the same context menu we show
            // for editable intinsics (bug 84886)
            if ( IsEditable(/*fCheckContainerOnly*/FALSE) && fInBrowse)
            {
                iContextMenu = CONTEXT_MENU_CONTROL;
            }

            hr = THR(ElementOwner()->OnContextMenu(
                    (short) LOWORD(pMessage->lParam),
                    (short) HIWORD(pMessage->lParam),
                    iContextMenu));
        }
        else
            hr = S_OK;
        break;

#ifndef NO_MENU
    case WM_MENUSELECT:
        hr = THR(ElementOwner()->OnMenuSelect(
                GET_WM_MENUSELECT_CMD(pMessage->wParam, pMessage->lParam),
                GET_WM_MENUSELECT_FLAGS(pMessage->wParam, pMessage->lParam),
                GET_WM_MENUSELECT_HMENU(pMessage->wParam, pMessage->lParam)));
        break;

    case WM_INITMENUPOPUP:
        hr = THR(ElementOwner()->OnInitMenuPopup(
                (HMENU) pMessage->wParam,
                (int) LOWORD(pMessage->lParam),
                (BOOL) HIWORD(pMessage->lParam)));
        break;
#endif // NO_MENU

    case WM_KEYDOWN:
        hr = THR(HandleKeyDown(pMessage, ElementOwner()));
        break;

    case WM_HSCROLL:
        if (fIsScroller)
        {
            hr = THR(OnScroll(
                    0,
                    LOWORD(pMessage->wParam),
                    HIWORD(pMessage->wParam),
                    FALSE));
        }
        break;

    case WM_VSCROLL:
        if (fIsScroller)
        {
            hr = THR(OnScroll(
                    1,
                    LOWORD(pMessage->wParam),
                    HIWORD(pMessage->wParam),
                    FALSE));
        }
        break;

    case WM_CHAR:
        if (pMessage->wParam == VK_RETURN && fInBrowse)
        {
            hr = THR(pDoc->ActivateDefaultButton(pMessage));
            if (S_OK != hr && ElementOwner()->GetParentForm())
            {
                MessageBeep(0);
            }
            break;
        }

        if (    fInBrowse
            &&  pMessage->wParam == VK_SPACE
            &&  fIsScroller)
        {
            CDispNodeInfo   dni;
            GetDispNodeInfo(&dni);

            if (dni.IsVScrollbarAllowed())
            {
                OnScroll(
                    1,
                    pMessage->dwKeyState & MK_SHIFT
                            ? SB_PAGEUP
                            : SB_PAGEDOWN,
                    0,
                    FALSE,
                    (pMessage->wParam&0x4000000)
                            ? 50  // TODO (IE6 bug 13575): For now we are using the mouse delay - should use Api to find system key repeat rate set in control panel.
                            : MAX_SCROLLTIME);
            }
            hr = S_OK;
            break;
        }
        break;
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     PrepareMessage
//
//  Synopsis:   Prepare the CMessage for the layout (e.g., ensure the
//              content point exists)
//
//  Arguments:  pMessage  - CMessage to prepare
//              pDispNode - CDispNode to use (defaults to layout display node)
//
//--------------------------------------------------------------------------

void
CLayout::PrepareMessage(
    CMessage *  pMessage,
    CDispNode * pDispNode)
{
    if (!pMessage->IsContentPointValid())
    {
        if (!pDispNode)
            pDispNode = GetElementDispNode();

        if (pDispNode)
        {
            pMessage->pDispNode = pDispNode;
            pDispNode->TransformPoint(pMessage->pt,
                                      COORDSYS_GLOBAL,
                                      &pMessage->ptContent,
                                      COORDSYS_FLOWCONTENT);
            pMessage->coordinateSystem = COORDSYS_FLOWCONTENT;
        }
    }
}


ExternTag(tagMsoCommandTarget);

void
CLayout::AdjustSizeForBorder(SIZE * pSize, CDocInfo * pdci, BOOL fInflate)
{
    CBorderInfo bInfo;

    if (ElementOwner()->GetBorderInfo(pdci, &bInfo, FALSE, FALSE))
    {
        int iXWidths = bInfo.aiWidths[SIDE_RIGHT] + bInfo.aiWidths[SIDE_LEFT];
        int iYWidths = bInfo.aiWidths[SIDE_TOP] + bInfo.aiWidths[SIDE_BOTTOM];

        pSize->cx += fInflate ? iXWidths : -iXWidths;
        pSize->cy += fInflate ? iYWidths : -iYWidths;
    }
}


//+---------------------------------------------------------------------------
//
//  Function:   PercentSize
//              PercentWidth
//              PercentHeight
//
//  Synopsis:   Handy helpers to check for percentage dimensions
//
//----------------------------------------------------------------------------

BOOL
CLayout::PercentSize()
{
    CTreeNode * pNode = GetFirstBranch();
    const CFancyFormat *pFF = pNode->GetFancyFormat(LC_TO_FC(LayoutContext())); 
    return (pFF->IsWidthPercent() || pFF->IsHeightPercent());
}

BOOL
CLayout::PercentWidth()
{
    CTreeNode * pNode = GetFirstBranch();
    const CCharFormat *pCF = pNode->GetCharFormat(LC_TO_FC(LayoutContext()));
    return pNode->GetFancyFormat(LC_TO_FC(LayoutContext()))->IsLogicalWidthPercent(
        pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
}

BOOL
CLayout::PercentHeight()
{
    CTreeNode * pNode        = GetFirstBranch();
    const CCharFormat *pCF   = pNode->GetCharFormat(LC_TO_FC(LayoutContext()));
    return pNode->GetFancyFormat(LC_TO_FC(LayoutContext()))->IsLogicalHeightPercent(
        pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
}


//+---------------------------------------------------------------------------
//
//  Member:     CSite::Move
//
//  Synopsis:   Move and/or resize the control
//
//  Arguments:  [rc]      -- New position
//              [dwFlags] -- Specifies flags
//
//  Notes:      prcpixels is in parent content relative coords of the site.
//              Move will take into account to offset it appropriately
//              with it's region parent.
//
//----------------------------------------------------------------------------

HRESULT
CLayout::Move(RECT *prcpixels, DWORD dwFlags)
{
    HRESULT         hr = S_OK;
    RECT            rcWindow;
    CDocInfo        DCI(ElementOwner());
    CBorderInfo     borderinfo;
    int             xWidth2, yWidth2;
    BOOL            fChanged = FALSE;
    DWORD           dwNotificationFlags;
    CRect           rcContainer;


    // Only call RequestLayout if we're just moving the object, to minimize
    // repainting.

    dwNotificationFlags = (dwFlags & SITEMOVE_NORESIZE)
                          ? ELEMCHNG_SITEPOSITION | ELEMCHNG_CLEARCACHES
                          : ELEMCHNG_SIZECHANGED  | ELEMCHNG_CLEARCACHES;

#ifndef NO_EDIT
    {
        CUndoPropChangeNotificationPlaceHolder
                notfholder( !(dwFlags & SITEMOVE_NOFIREEVENT) &&
                            Doc()->LoadStatus() == LOADSTATUS_DONE,
                            ElementOwner(), DISPID_UNKNOWN, dwNotificationFlags );
#endif // NO_EDIT

    Assert(prcpixels);

    // we need to see if we are in a right to left situation
    // if we are we will need to set our left at a correct distance from our
    // parent's left
    CTreeNode * pParentNode = GetFirstBranch()->GetUpdatedParentLayoutNode();

    CLayout* pParentLayout = GetFirstBranch()->GetUpdatedParentLayout();

    // We might not get a pParentLayout at this point: e.g. an OBJECT tag in
    // the HEAD (recall <HTML> has no layout) (bug #70791), in which
    // case we play it safe and init rcContainer to a 0 pixel rect
    // (it shouldn't be used in any meaningful way anyways).

    // if we have scroll bars, we need to take of the size of the scrolls.
    if ( pParentLayout )
    {
        if(pParentLayout->GetElementDispNode() &&
           pParentLayout->GetElementDispNode()->IsScroller())
        {
            pParentLayout->GetClientRect(&rcContainer);
        }
        else
        {
            Assert(pParentNode);

            hr = THR(pParentNode->Element()->EnsureRecalcNotify());
            if (hr)
                goto Cleanup;

            pParentNode->Element()->GetBoundingRect(&rcContainer);
        }
    }
    else
    {
        rcContainer.top = rcContainer.left = 0;
        rcContainer.bottom = rcContainer.right = 0;
    }

    //
    // Account for any zooming.
    //
    rcWindow.left   = DCI.DocPixelsFromDeviceX(prcpixels->left);
    rcWindow.right  = DCI.DocPixelsFromDeviceX(prcpixels->right);
    rcWindow.top    = DCI.DocPixelsFromDeviceY(prcpixels->top);
    rcWindow.bottom = DCI.DocPixelsFromDeviceY(prcpixels->bottom);

    //
    // Finally rcWindow is in parent site relative document coords.
    //

    if (ElementOwner()->TestClassFlag(CElement::ELEMENTDESC_EXBORDRINMOV))
    {
        // We want untransformed border sizes (right?), so we pass in a NULL docinfo.
        ElementOwner()->GetBorderInfo(NULL, &borderinfo, FALSE, FALSE );

        xWidth2 = borderinfo.aiWidths[SIDE_RIGHT] + borderinfo.aiWidths[SIDE_LEFT];
        yWidth2 = borderinfo.aiWidths[SIDE_TOP] + borderinfo.aiWidths[SIDE_BOTTOM];
    }
    else
    {
        xWidth2 = 0;
        yWidth2 = 0;
    }


    if (!(dwFlags & SITEMOVE_NORESIZE))
    {
        // If the ELEMENTDESC flag is set

        // (ferhane)
        //  Pass in 1 when the size is not defined as a percent. If the size is defined as a
        //  percentage of the container, then the CUnitValue::SetFloatValueKeepUnits needs the
        //  container size to be passed for the proper percentage calculation.
        //
        if (!PercentWidth())
        {
            rcContainer.right = 1;
            rcContainer.left = 0;
        }

        if (!PercentHeight())
        {
            rcContainer.bottom = 1;
            rcContainer.top = 0;
        }

        // Set Attributes
        hr = THR ( ElementOwner()->SetDim ( STDPROPID_XOBJ_HEIGHT,
                            (float)(rcWindow.bottom - rcWindow.top - yWidth2),
                            CUnitValue::UNIT_PIXELS,
                            rcContainer.bottom - rcContainer.top,
                            NULL,
                            FALSE,
                            &fChanged ) );
        if ( hr )
            goto Cleanup;

        hr = THR ( ElementOwner()->SetDim ( STDPROPID_XOBJ_WIDTH,
                            (float)(rcWindow.right - rcWindow.left - xWidth2),
                            CUnitValue::UNIT_PIXELS,
                            rcContainer.right - rcContainer.left,
                            NULL,
                            FALSE,
                            &fChanged ) );
        if ( hr )
            goto Cleanup;

        // Set In-line style
        hr = THR ( ElementOwner()->SetDim ( STDPROPID_XOBJ_HEIGHT,
                            (float)(rcWindow.bottom - rcWindow.top - yWidth2),
                            CUnitValue::UNIT_PIXELS,
                            rcContainer.bottom - rcContainer.top,
                            NULL,
                            TRUE,
                            &fChanged ) );
        if ( hr )
            goto Cleanup;

        hr = THR ( ElementOwner()->SetDim ( STDPROPID_XOBJ_WIDTH,
                            (float)(rcWindow.right - rcWindow.left - xWidth2),
                            CUnitValue::UNIT_PIXELS,
                            rcContainer.right - rcContainer.left,
                            NULL,
                            TRUE,
                            &fChanged ) );
        if ( hr )
            goto Cleanup;
    }

//TODO (IE6 bug 13576): (FerhanE)
//          We will make the TOP and LEFT behavior for percentages the same with the
//          behavior for width and height above in the 5.x tree. 5.0 is not changed for
//          these attributes.
//
    if (!(dwFlags & SITEMOVE_RESIZEONLY))
    {
        hr = THR ( ElementOwner()->SetDim ( STDPROPID_XOBJ_TOP,
                            (float)rcWindow.top,
                            CUnitValue::UNIT_PIXELS,
                            1,
                            NULL,
                            TRUE,
                            &fChanged ) );
        if ( hr )
            goto Cleanup;

        hr = THR ( ElementOwner()->SetDim ( STDPROPID_XOBJ_LEFT,
                            (float)rcWindow.left,
                            CUnitValue::UNIT_PIXELS,
                            1,
                            NULL,
                            TRUE,
                            &fChanged ) );
        if ( hr )
            goto Cleanup;
    }

    // Only fire off a change notification if something changed
    if (fChanged && !(dwFlags & SITEMOVE_NOFIREEVENT))
    {
        ElementOwner()->OnPropertyChange( DISPID_UNKNOWN, dwNotificationFlags );
    }

Cleanup:

#ifndef NO_EDIT
        notfholder.SetHR( fChanged ? hr : S_FALSE );
    }
#endif // NO_EDIT

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::TransformPoint
//
//  Synopsis:   Transform a point from the source coordinate system to the
//              destination coordinate system
//
//  Arguments:  ppt             point to transform
//              source          source coordinate system
//              destination     destination coordinate system
//
//----------------------------------------------------------------------------

void
CLayout::TransformPoint(
    CPoint *            ppt,
    COORDINATE_SYSTEM   source,
    COORDINATE_SYSTEM   destination,
    CDispNode *         pDispNode) const
{
    if(!pDispNode)
        pDispNode = GetElementDispNode();

    if(pDispNode)
    {
        pDispNode->TransformPoint(*ppt, source, ppt, destination);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::TransformRect
//
//  Synopsis:   Transform a rect from the source coordinate system to the
//              destination coordinate system with optional clipping.
//
//  Arguments:  prc             rect to transform
//              source          source coordinate system
//              destination     destination coordinate system
//              fClip           TRUE to clip the rectangle
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CLayout::TransformRect(
    RECT *              prc,
    COORDINATE_SYSTEM   source,
    COORDINATE_SYSTEM   destination,
    CDispNode *         pDispNode) const
{
    if (!pDispNode)
        pDispNode = _pDispNode;

    if (pDispNode)
    {
        pDispNode->TransformRect((CRect&)*prc, source, (CRect *)prc, destination);
    }
}

//+-------------------------------------------------------------------------
//
//  Method:     SetSiteTextSelection
//
//  Synopsis:   Set's a sites text selection status
//
//  Arguments:  none
//
//  Returns:    nothing
//
//--------------------------------------------------------------------------
void
CLayout::SetSiteTextSelection (BOOL fSelected, BOOL fSwap)
{
    _fTextSelected = fSelected ;
    _fSwapColor = fSwap;
}


//+---------------------------------------------------------------------------
//
//  Member:     HandleKeyDown
//
//  Synopsis:   Helper for keydown handling
//
//  Arguments:  [pMessage]  -- message
//              [pChild]    -- pointer to child when bubbling allowed
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CLayout::HandleKeyDown(CMessage * pMessage, CElement * pElemChild)
{
    BOOL    fRunMode = !IsEditable(TRUE);
    BOOL    fAlt     = pMessage->dwKeyState & FALT;
    BOOL    fCtrl    = pMessage->dwKeyState & FCONTROL;
    HRESULT hr       = S_FALSE;

    if (    fRunMode
        &&  !fAlt)
    {
        CDispNode * pDispNode   = GetElementDispNode();
        BOOL        fIsScroller = pDispNode && pDispNode->IsScroller();
        BOOL        fDirect     = pElemChild == NULL;

        if (fIsScroller)
        {
            if (    !fDirect
                ||  SUCCEEDED(hr))
            {
                hr = HandleScrollbarMessage(pMessage, pElemChild);
            }
        }
    }

    if (    hr == S_FALSE
        &&  !fAlt
        &&  !fCtrl)
    {
        switch (pMessage->wParam)
        {
        case VK_RETURN:
            break;

        case VK_ESCAPE:
            if (fRunMode)
            {
                hr = THR(Doc()->ActivateCancelButton(pMessage));
            }
            break;
        }
    }
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::GetTheme
//
//  Synopsis:   Return the theme to use for painting or NULL is theme 
//              not present or not active
//
//----------------------------------------------------------------------------

HTHEME 
CLayout::GetTheme(THEMECLASSID themeId)
{
    HTHEME     hTheme = NULL;
    CElement * pElementOwner = ElementOwner();

    if(pElementOwner)
    {
        CMarkup *pMarkup = pElementOwner->GetMarkupPtr();
        if(pMarkup)
            hTheme = pMarkup->GetTheme(themeId);
    }
    return hTheme;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::GetOwner
//
//  Synopsis:   Return the logical owner of the CDispClient interface - This
//              is always either a CElement or NULL
//
//  Arguments:  ppv - Location at which to return the owner
//
//----------------------------------------------------------------------------

void
CLayout::GetOwner(
    CDispNode const* pDispNode,
    void **     ppv)
{
    Assert(pDispNode);
    Assert(pDispNode == GetElementDispNode());
    Assert(ppv);
    *ppv = ElementOwner();
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::DrawClient
//
//  Synopsis:   Draw display leaf nodes
//
//  Arguments:  prcBounds       bounding rect of display leaf node
//              prcRedraw       rect to be redrawn
//              pSurface        surface to render into
//              pDispNode       pointer to display node
//              pClientData     client-dependent data for drawing pass
//              dwFlags         flags for optimization
//
//----------------------------------------------------------------------------

void
CLayout::DrawClient(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          cookie,
    void *          pClientData,
    DWORD           dwFlags)
{
    Assert(pClientData);

    BOOL            fRestoreDIContext = FALSE;
    CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
    CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);

    // if we are asked to draw w/o a layoutcontext, and this layout has one,
    // then use our context for the callstack below us.
    if (   !pDI->GetLayoutContext()
        && LayoutContext())
    {
        pDI->SetLayoutContext(LayoutContext());
        fRestoreDIContext = TRUE;
    }

    Draw(pDI, pDispNode);
    DrawTextSelectionForSite(pDI, prcRedraw);
    if (fRestoreDIContext)
        pDI->SetLayoutContext(NULL);
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::DrawClientBackground
//
//  Synopsis:   Draw the background
//
//  Arguments:  prcBounds       bounding rect of display leaf
//              prcRedraw       rect to be redrawn
//              pSurface        surface to render into
//              pDispNode       pointer to display node
//              pClientData     client-dependent data for drawing pass
//              dwFlags         flags for optimization
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CLayout::DrawClientBackground(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          pClientData,
    DWORD           dwFlags)
{
    Assert(pClientData);

    CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
    CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);
    CBackgroundInfo bi;

    GetBackgroundInfo(pDI, &bi, TRUE);

#if DBG==1
    if (    IsTagEnabled(tagDisplayInnerHTMLNode)
        &&  ElementOwner()->Tag() == ETAG_HTML
        &&  _pDispNode != pDispNode )
    {
        bi.crBack     = RGB(0x80,0xff,0xff);
        bi.crTrans    = RGB(0,0,0);
    }
#endif

    if (bi.crBack != COLORREF_NONE || bi.pImgCtx)
        DrawBackground(pDI, &bi, (RECT *)&pDI->_rc);

    if ( IsShowZeroBorderAtDesignTime() &&
         Tag() != ETAG_CAPTION )
    {
        CLayout* pParentLayout = GetUpdatedParentLayout();
        if ( pParentLayout && pParentLayout->IsEditable() )
        {
            DrawZeroBorder(pDI);
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::DrawClientBorder
//
//  Synopsis:   Draw the border
//
//  Arguments:  prcBounds       bounding rect of display leaf
//              prcRedraw       rect to be redrawn
//              pSurface        surface to render into
//              pDispNode       pointer to display node
//              pClientData     client-dependent data for drawing pass
//              dwFlags         flags for optimization
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CLayout::DrawClientBorder(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          pClientData,
    DWORD           dwFlags)
{
    Assert(pClientData);

    CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
    CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);

    CBorderInfo     bi;
    CLayoutContext *pOldLC  = pDI->GetLayoutContext();
    CLayoutContext *pThisLC = LayoutContext();

    AssertSz( ((pOldLC) ? (pThisLC != NULL) : (TRUE)), "If we came in with a context, we must have one ourselves" );

    pDI->SetLayoutContext( pThisLC );

    ElementOwner()->GetBorderInfo(pDI, &bi, TRUE, FALSE FCCOMMA LC_TO_FC(LayoutContext()));

    // If we're a broken layout, we may only be displaying part of
    // pElement, so we might not want to draw the top or bottom border.
    if ( pThisLC )
    {
        AdjustBordersForBreaking( &bi );
    }

    ::DrawBorder(pDI, &(pDI->_rc), &bi);

    pDI->SetLayoutContext( pOldLC );
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::DrawClientScrollbar
//
//  Synopsis:   Draw horizontal/vertical scrollbar
//
//  Arguments:  iDirection      0 for horizontal scrollbar, 1 for vertical
//              prcBounds       bounding rect of the scrollbar
//              prcRedraw       rect to be redrawn
//              contentSize     size of content
//              containerSize   size of container that displays the content
//              scrollAmount    current scroll position
//              pSurface        surface to render into
//              pDispNode       pointer to display node
//              pClientData     client-dependent data for drawing pass
//              dwFlags         flags for optimization
//
//----------------------------------------------------------------------------

void
CLayout::DrawClientScrollbar(
    int            iDirection,
    const RECT *   prcBounds,
    const RECT *   prcRedraw,
    long           contentSize,
    long           containerSize,
    long           scrollAmount,
    CDispSurface * pDispSurface,
    CDispNode *    pDispNode,
    void *         pClientData,
    DWORD          dwFlags)
{
    CFormDrawInfo * pDI;
    CFormDrawInfo   DI;

    if (!pClientData)
    {
        DI.Init(this);
        DI._hdc = NULL;
        pDI = &DI;
    }
    else
    {
        pDI = (CFormDrawInfo *)pClientData;
    }

    CSetDrawSurface         sds(pDI, prcBounds, prcRedraw, pDispSurface);

    XHDC                    hdc  = pDI->GetDC(TRUE);
    CScrollbarController *  pSBC = TLS(pSBC);
    CScrollbarParams        params;
    CRect                   rcHimetricBounds;
    CTreeNode            *  pTreeNode   = ElementOwner()->GetFirstBranch();
    // When passing a xhdc pointer to this class make sure you do not delete ot before
    // this object is gone. It might try to use it.
    CScrollbarThreeDColors  colors(pTreeNode, &hdc);

    Assert(pSBC != NULL);

    const CCharFormat  *pCF  = pTreeNode->GetCharFormat(LC_TO_FC(LayoutContext()));

    if(pCF != NULL &&  pCF->HasVerticalLayoutFlow())
    {
        // Set a special flag so that the themed buttons will appear right
        dwFlags |= DISPSCROLLBARHINT_VERTICALLAYOUT;
    }

    params._pColors = &colors;
    params._buttonWidth = ((const CRect*)prcBounds)->Size(1-iDirection);
    params._fFlat       = Doc()->_dwFlagsHostInfo & DOCHOSTUIFLAG_FLAT_SCROLLBAR;
    params._fForceDisabled = ! ElementOwner()->IsEnabled();
    params._hTheme = GetTheme(THEME_SCROLLBAR);
#ifdef UNIX // Used for Motif scrollbar
    params._bDirection = iDirection;
#endif

    CScrollbar::Draw(
        iDirection,
        pDI->_rc,
        pDI->_rcClip,
        contentSize,
        containerSize,
        scrollAmount,
        ((iDirection==pSBC->GetDirection() && pSBC->GetLayout() == this)
            ? pSBC->GetPartPressed()
            : CScrollbar::SB_NONE),
        hdc,
        params,
        pDI,
        dwFlags);
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::DrawClientScrollbarFiller
//
//  Synopsis:   Draw dead region between scrollbars, that is also called corner
//
//  Arguments:  prcBounds       bounding rect of the dead region
//              prcRedraw       rect to be redrawn
//              pSurface        surface to render into
//              pDispNode       pointer to display node
//              pClientData     client-dependent data for drawing pass
//              dwFlags         flags for optimization
//
//----------------------------------------------------------------------------

void
CLayout::DrawClientScrollbarFiller(
    const RECT *   prcBounds,
    const RECT *   prcRedraw,
    CDispSurface * pDispSurface,
    CDispNode *    pDispNode,
    void *         pClientData,
    DWORD          dwFlags)
{
    HDC            hdc;

    if (SUCCEEDED(pDispSurface->GetDC(&hdc)))
    {
        XHDC        xhdc(hdc, pDispSurface);
        HBRUSH      hbr = NULL;

        // Ideally there should have been a part definition for the scrollbar code in the
        // theme APIs and we should have called GetTheme and used DrawThemeBackground if theming is on.
        // Even if they did the same thing as we do here it would provide a necessary level
        // of abstraction.

        CScrollbarThreeDColors  colors(ElementOwner()->GetFirstBranch(), &xhdc);

        pDispSurface->SetClip(*prcRedraw);
        
        hbr = colors.BrushBtnFace();
        FillRect(xhdc, prcRedraw, hbr);
        ReleaseCachedBrush(hbr);
    }
}


  


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::HitTestScrollbar
//
//  Synopsis:   Process a "hit" on a scrollbar
//
//  Arguments:  iDirection      0 for horizontal scrollbar, 1 for vertical
//              pptHit          hit test point
//              pDispNode       pointer to display node
//              pClientData     client-specified data value for hit testing pass
//
//----------------------------------------------------------------------------

BOOL
CLayout::HitTestScrollbar(
    int            iDirection,
    const POINT *  pptHit,
    CDispNode *    pDispNode,
    void *         pClientData)
{
    CHitTestInfo *  phti;

    Assert(pClientData);

    phti = (CHitTestInfo *)pClientData;

    if (phti->_grfFlags & HT_IGNORESCROLL)
        return FALSE;

    phti->_htc          = (iDirection == 0) ? HTC_HSCROLLBAR : HTC_VSCROLLBAR;
    phti->_pNodeElement = GetFirstBranch();
    phti->_ptContent    = *pptHit;
    phti->_pDispNode    = pDispNode;

    SetHTILayoutContext( phti );

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::HitTestScrollbarFiller
//
//  Synopsis:   Process a "hit" on a scrollbar filler
//
//  Arguments:  pptHit          hit test point
//              pDispNode       pointer to display node
//              pClientData     client-specified data value for hit testing pass
//
//----------------------------------------------------------------------------

BOOL
CLayout::HitTestScrollbarFiller(
    const POINT *  pptHit,
    CDispNode *    pDispNode,
    void *         pClientData)
{
    CHitTestInfo *  phti;

    Assert(pClientData);

    phti = (CHitTestInfo *)pClientData;

    phti->_htc          = HTC_NO;
    phti->_pNodeElement = ElementContent() ? ElementContent()->GetFirstBranch() : NULL;
    phti->_ptContent    = *pptHit;
    phti->_pDispNode    = pDispNode;

    SetHTILayoutContext( phti );

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::HitTestContentWithOverride
//
//  Synopsis:   Determine if the given display leaf node contains the hit point.
//
//  Arguments:  pptHit          hit test point
//              pDispNode       pointer to display node
//              pClientData     client-specified data value for hit testing pass
//              fOverrideHitInfo This is TRUE by default. Direct calls to CLayout::HTC
//                  will count as hard hits (e.g. image, hr..) but calls coming from
//                  super (e.g. w/in bounding rect but NOT on content) will only count
//                  as hits if nothing else has already said hit.  We rely on the display
//                  tree to call in the proper z-order so that the first thing that hits
//                  sets up the CHitTestInfo Structure.
//
//  Returns:    TRUE if the display leaf node contains the point
//
//----------------------------------------------------------------------------

BOOL
CLayout::HitTestContentWithOverride(
                const POINT * pptHit,
                CDispNode *   pDispNode,
                void *        pClientData,
                BOOL          fOverrideHitInfo,
                BOOL          fDeclinedByPeer)
{
    //
    // NOTE (michaelw)
    //
    // For compat reasons hit testing always succeeds when an element
    // has layout, even if the content is 100% transparent.  Yum.
    //
    // The only time that ElementOwner and ElementContent are not the
    // same is when we have a view slave.  The only time the view slave's
    // layout (and its dispnode) doesn't completely cover the master
    // layout is (according to ktam) in the rect peer (CContainerLayout).
    // In that case, we should fire the event on the rect instead of the
    // slave.  For this reason we use ElementOwner and not ElementContent.
    //
    // We should consider changing this behavior for platform use
    //
    // NOTE (CARLED) we have changed this a bit. a hit on CLayout directly is
    // considered a "hard" hit and hit testing should return TRUE. However, if we
    // get here from a derived class, that means that we are really only doing a
    // boundingBox check and we then need to deal with the distinction of "soft"
    // hits - hits that are w/in our bounds but not over content.  The way this works
    // is that soft-hits do NOT fill in the HitTestInfo if there is already a
    // _pNodeElement (since someone higher up inthe Z-order has already registered a soft
    // hit.  (had there been a "hard" hit the hit testing would have stopped with a return true).
    // if the _pNodeElement is empty then this is the first element to find a soft hit
    // and it will register itself.
    //
    // fOverride is TRUE by default (so calls to this Fx directly (e.g. Image or HR) will be
    // hard-hits if w/in the bounds.
    //
    // NOTE (carled) but (bug 104782) - if a renderingBehavior has declined the hit
    // (phti->_htc == HTC_BEHAVIOR && !phti->_pNodeElement) but the
    // dispnode HasBackground, we are going to return TRUE and stop hittesting
    // however, with the peer declinig we have no element to return at this time.
    // so we *have* to return this
    //

    Assert(pClientData);

    CHitTestInfo *phti = (CHitTestInfo *)pClientData;

    if (   fDeclinedByPeer
        && !fOverrideHitInfo
        && !pDispNode->HasBackground())
    {
        //
        // if we get here with no override, then we are being called from a
        // derieved layout class and in a non-content hittest pass.  If the
        // _htc is HTC_BEAHVIOR then this is a peer'd elementOwner() and if
        // _pNodeElement is NULL, then the peer has declined the hit,which
        // requires that we ignore it here to.
        //
        phti->_htc = HTC_NO;
    }
    else
    {
        phti->_htc          = HTC_YES;

        if (   fOverrideHitInfo
            || !phti->_pNodeElement)
            return HitTestContentCleanup(pptHit, pDispNode, phti, ElementOwner());
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLayout::HitTestContentCleanup
//
//  Synopsis:   Determine if the given display leaf node contains the hit point.
//
//  Arguments:  pptHit          hit test point
//              pDispNode       pointer to display node
//              pClientData     client-specified data value for hit testing pass
//
//  Returns:    TRUE if the display leaf node contains the point
//
//----------------------------------------------------------------------------

BOOL
CLayout::HitTestContentCleanup(
    const POINT *   pptHit,
    CDispNode *     pDispNode,
    CHitTestInfo *  phti,
    CElement *      pElement)
{
    Assert(pptHit);
    Assert(pDispNode);
    POINT ptNodeHit = *pptHit;


    Assert(phti->_htc != HTC_NO);
    phti->_pNodeElement = pElement->GetFirstBranch();
    phti->_ptContent    = ptNodeHit;
    phti->_pDispNode    = pDispNode;

    phti->_phtr->_fWantArrow = TRUE;

    SetHTILayoutContext( phti );

    Assert( ElementOwner()->HasLayoutAry() ? phti->_pLayoutContext != NULL : TRUE );

#if DBG
    // At this point if we hit an element w/ layout, it better
    // be the the owner of this layout; otherwise the display
    // tree should have called us on the HitTestContent of that
    // layout!!
    Assert( phti->_pNodeElement->Element()->ShouldHaveLayout() ?
            phti->_pNodeElement->Element() == ElementOwner() :
            TRUE );
#endif

    return (phti->_htc != HTC_NO);
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::HitTestPeer
//
//  Synopsis:   Determine if the given display leaf node contains the hit point.
//
//  Arguments:  pptHit          hit test point
//              pDispNode       pointer to display node
//              cookie          which peer to test
//              pClientData     client-specified data value for hit testing pass
//
//  Returns:    TRUE if the display leaf node contains the point
//
//----------------------------------------------------------------------------

BOOL
CLayout::HitTestPeer(
    const POINT *   pptHit,
    COORDINATE_SYSTEM cs,
    CDispNode *     pDispNode,
    void *          cookie,
    void *          pClientData,
    BOOL            fHitContent,
    CDispHitContext *pContext,
    BOOL *pfDeclinedHit)
{
    Assert(pptHit);
    Assert(pClientData);

    POINT          ptNodeHit   = *pptHit;
    CPeerHolder  * pPeerHolder = NULL;
    CHitTestInfo * phti        = (CHitTestInfo *)pClientData;

    if (pfDeclinedHit)
        *pfDeclinedHit = FALSE;

    if (cookie == NULL)
    {
        pPeerHolder = ElementOwner()->GetRenderPeerHolder();
    }
    else
    {
        // make sure the cookie points to a PH that still exists
        CPeerHolder * pPH = (CPeerHolder*) cookie;
        CPeerHolder::CPeerHolderIterator iter;

        for (iter.Start(ElementOwner()->GetPeerHolder());
             !iter.IsEnd();
             iter.Step())
        {
            if (pPH == iter.PH())
            {
                pPeerHolder = pPH;
                break;
            }
        }

        if(!pPeerHolder && 
            (ElementOwner()->Tag() == ETAG_BODY 
                || ElementOwner()->Tag() == ETAG_FRAMESET 
                || ElementOwner()->Tag() == ETAG_HTML))
        {
            Assert(ElementOwner()->Tag() != ETAG_HTML || GetOwnerMarkup()->IsHtmlLayout());
            // If this peer holder was not found it could be because we were in the middle
            // of a page transition, and we need to delegate to page transitionthe peer on
            // the root element
            CMarkup * pMarkup = ElementOwner()->GetMarkupPtr();
            if(pMarkup)
            {
                CDocument * pDocument = pMarkup->Document();
                if(pDocument && pDocument->HasPageTransitions())
                {
                    for (iter.Start(pMarkup->Root()->GetPeerHolder());
                         !iter.IsEnd();
                         iter.Step())
                    {
                        if (pPH == iter.PH())
                        {
                            pPeerHolder = pPH;
                            break;
                        }
                    }
                }
            }
        }
    }

    if (pPeerHolder &&
        pPeerHolder->TestPainterFlags(HTMLPAINTER_HITTEST))
    {
        //
        // delegate hit testing to peer
        //

        HRESULT hr;
        BOOL    fHit;

        // (treat hr error as no hit)
        CLayoutContext * pLayoutContext = LayoutContext();
        if(pLayoutContext)
            pContext->PushLayoutContext(pLayoutContext);

        hr = THR(pPeerHolder->HitTestPoint(pContext, fHitContent, &ptNodeHit, &fHit));
        if(pLayoutContext)
            pContext->PopLayoutContext();

        if (hr)
            goto Cleanup;

        // regardless of the hit or no, we want to honor the peers setting.
        if(fHit)
        {
            // First we need to determine if this hit actually happened on this peer
            // or if it was the result of a nested hit test via the filter
            // CPeerHolder::HitTestPoint doesn't set _htc so if the hit test succeeded
            // and _htc is empty, this hit really does belong to this behavior
            // if a previous behavior declined the hit, then we are free to override
            // at this point.

            if (    phti->_htc == HTC_NO
                || (   phti->_htc == HTC_BEHAVIOR
                    && phti->_pNodeElement ==NULL))
            {
                phti->_htc = HTC_BEHAVIOR;
                // hit on the peer itself, set return info for this element
                pContext->SetHitTestCoordinateSystem(cs);
                return HitTestContentCleanup(pptHit, pDispNode, phti, ElementOwner());
            }
            else
            {
                // if the hit is handled by some child of (filter) peer, return info
                // is already set
                //
                // otherwise, It must be a psuedo hit on a postioned object (109680)
                // and it is safe to override.
                if (   ElementOwner()->IsEditable(/*fCheckContainerOnly*/FALSE)
                   || ElementOwner()->IsDesignMode() )
                {
                    // we are editing and the info in the phti is for a descendant,
                    // then use it
                    if (   phti->_htc != HTC_NO
                        && phti->_pNodeElement
                        && (   phti->_pNodeElement->Element() == ElementOwner()
                            || GetFirstBranch()->AmIAncestorOrMasterOf(phti->_pNodeElement)
                           )
                        )
                    {
                        return TRUE;
                    }
                    else
                    {
                        // The hit is on a non-relative, or ancestor, so our claim to the hit
                        // is stronger, so use us.
                        phti->_htc = HTC_BEHAVIOR;
                        // hit on the peer itself, set return info for this element
                        pContext->SetHitTestCoordinateSystem(cs);
                        return HitTestContentCleanup(pptHit, pDispNode, phti, ElementOwner());
                    }
                }
                else
                {
                    return TRUE;
                }
            }
        }
        else if (   ElementOwner()->Doc()->_fPeerHitTestSameInEdit
                 || (   !ElementOwner()->IsEditable(/*fCheckContainerOnly*/FALSE)
                     && !ElementOwner()->IsDesignMode() 
                    )
                )
        {
            // if Editable or design mode, don't do this clearing.
            //
            //this is NOT a hit on the peer, so return FALSE (to continue the
            //  hit test search) but also clear the HitTestInfo.
            //
            // BUT WAIT, only clear the HTI if the _pNodeElement is ours! why?
            // because someone higher in the z-order may have already registered for the
            // hit.  if so, we don't necessarily want to blow them away.
            if (   phti->_pNodeElement
                && phti->_pNodeElement == GetFirstBranch())
            {
                phti->_htc = HTC_BEHAVIOR;
                phti->_pNodeElement = NULL;
                phti->_pDispNode    = NULL;
            }

        if (pfDeclinedHit)
            *pfDeclinedHit = TRUE;
        }
    }

Cleanup:
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::HitTestFuzzy
//
//  Synopsis:   Determine if the given display leaf node contains the hit point.
//
//  Arguments:  pptHitInBoxCoords       hit test point in box coordinates
//              pDispNode               pointer to display node
//              pClientData             client-specified data for hit testing
//
//  Returns:    TRUE if the display leaf node contains the point
//
//----------------------------------------------------------------------------

BOOL
CLayout::HitTestFuzzy(
    const POINT *   pptHitInBoxCoords,
    CDispNode *     pDispNode,
    void *          pClientData)
{
    Assert(pptHitInBoxCoords);
    Assert(pDispNode);
    Assert(pClientData);

    // HitTestFuzzy shouldn't be called unless we're in design mode
    Assert(DoFuzzyHitTest());

    CHitTestInfo *  phti = (CHitTestInfo *)pClientData;

    phti->_htc          = HTC_YES;
    phti->_pNodeElement = ElementContent()->GetFirstBranch();
    phti->_phtr->_fWantArrow = TRUE;

    SetHTILayoutContext( phti );

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLayout::HitTestBorder
//
//  Synopsis:   Hit test the border for this layout.
//
//  Arguments:  pptHit          point to hit test
//              pDispNode       display node
//              pClientData     client data
//
//  Returns:    TRUE if the given point hits this node's border.
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CLayout::HitTestBorder(
        const POINT *pptHit,
        CDispNode *pDispNode,
        void *pClientData)
{
    Assert(pptHit);
    Assert(pDispNode);
    Assert(pClientData);

    CHitTestInfo *  phti = (CHitTestInfo *)pClientData;

    phti->_htc          = HTC_YES;
    phti->_pNodeElement = GetFirstBranch();
    phti->_phtr->_fWantArrow = TRUE;
    phti->_ptContent    = *pptHit;
    phti->_pDispNode    = pDispNode;

    SetHTILayoutContext( phti );

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::HitTestBoxOnly, CDispClient
//
//  Synopsis:   Hook to do hit testing against the box only (as opposed to the content)
//
//  Arguments:  none
//
//  Returns:    TRUE if hit
//
//  Notes:      this is a hack to support VID's "frozen" attribute
//
//----------------------------------------------------------------------------

BOOL
CLayout::HitTestBoxOnly(
    const POINT *   pptHit,
    CDispNode *     pDispNode,
    void *          pClientData)
{
    if (ElementOwner()->IsFrozen())
    {
        CHitTestInfo *phti = (CHitTestInfo *)pClientData;

        phti->_htc          = HTC_YES;
        return HitTestContentCleanup(pptHit, pDispNode, phti, ElementOwner());
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::ProcessDisplayTreeTraversal
//
//  Synopsis:   Process results of display tree traversal.
//
//  Arguments:  pClientData     pointer to data defined by client
//
//  Returns:    TRUE to continue traversal
//
//  Notes:
//
//----------------------------------------------------------------------------

BOOL
CLayout::ProcessDisplayTreeTraversal(void *pClientData)
{
    return TRUE;
}

CTreeNode *
GetTopmostAbsoluteZParent(CTreeNode *pBaseNode)
{
    CTreeNode * pHeadNode;
    CTreeNode * pRearNode = pBaseNode;
    CTreeNode * pCanvasNode = pBaseNode->GetMarkup()->GetCanvasElement()->GetFirstBranch();

    Assert(pRearNode);

    pHeadNode = pRearNode->ZParentBranch();

    while (     pHeadNode
            &&  !pHeadNode->IsPositionStatic()
            &&  pHeadNode != pCanvasNode )
    {
        pRearNode = pHeadNode;
        pHeadNode = pHeadNode->ZParentBranch();
    }

    return pRearNode;
}

void
PopulateAbsoluteZParentAry(CPtrAry<CTreeNode *> *pary, CTreeNode *pBaseNode)
{
    CTreeNode *pNode = pBaseNode;
    CTreeNode *pCanvasNode = pBaseNode->GetMarkup()->GetCanvasElement()->GetFirstBranch();
    Assert(pary);
    Assert(pNode);

   while (     pNode
            &&  !pNode->IsPositionStatic()
            &&  pNode != pCanvasNode )
    {
        pary->Append(pNode);
        pNode = pNode->ZParentBranch();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CLayout::GetZOrderForSelf
//
//  Synopsis:   Return Z order for this container.
//
//  Returns:    Z order for this container.
//
//----------------------------------------------------------------------------
LONG
CLayout::GetZOrderForSelf(CDispNode const* pDispNode)
{
    Assert(!GetFirstBranch()->IsPositionStatic());

    return ReparentedZOrder()
                ?   GetTopmostAbsoluteZParent(GetFirstBranch())->GetCascadedzIndex()
                :   GetFirstBranch()->GetCascadedzIndex();
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::CompareZOrder
//
//  Synopsis:   Compare the z-order of two display nodes
//
//  Arguments:  pDispNode1 - Display node owned by this display client
//              pDispNode2 - Display node to compare against
//
//  Returns:    Greater than zero if pDispNode1 is greater
//              Less than zero if pDispNode1 is less
//              Zero if they are equal
//
//----------------------------------------------------------------------------
MtDefine(CompareZOrder_ary1_pv, Locals, "CLayout::CompareZOrder::aryNode1::CTreeNode*")
MtDefine(CompareZOrder_ary2_pv, Locals, "CLayout::CompareZOrder::aryNode2::CTreeNode*")

LONG
CLayout::CompareZOrder(
    CDispNode const* pDispNode1,
    CDispNode const* pDispNode2)
{
    Assert(pDispNode1);
    Assert(pDispNode2);

    CElement *  pElement1 = ElementOwner();
    CElement *  pElement2 = ::GetDispNodeElement(pDispNode2);


    // If we've reparented the display nodes involved,
    if (    ReparentedZOrder()
        &&  pDispNode2->GetDispClient()->ReparentedZOrder() )
    {
        // TODO (IE6 bug 13584) (greglett) PERF
        // We can collapse the IsParent tests into the ZParentAry checking easily.
        // We should actually get rid off all the reparentd zindex code, and somehow
        // frontload the work.

        // A child automatically beats a parent.  Z-Index is heirarchical.
        if (pElement1->IsParent(pElement2))
            return 1;

        if (pElement2->IsParent(pElement1))
            return -1;

        //  Otherwise, the topmost positioned zparent of each child should
        //  be compared.  Find it, and set pElement accordingly.
        //  Unfortunately, this top-down approach would require us to repeatedly
        //  walk the tree, so we store the results in arrays to ward off O(n^2) for O(2n).
        CPtrAry<CTreeNode *> aryNode1(Mt(CompareZOrder_ary1_pv));
        CPtrAry<CTreeNode *> aryNode2(Mt(CompareZOrder_ary2_pv));
        int n1, n2;
        PopulateAbsoluteZParentAry(&aryNode1, pElement1->GetFirstBranch());
        PopulateAbsoluteZParentAry(&aryNode2, pElement2->GetFirstBranch());

        n1 = aryNode1.Size() - 1;
        n2 = aryNode2.Size() - 1;
        while (     n1 >= 0
                &&  n2 >= 0
                &&  aryNode1[n1] == aryNode2[n2])
        {
            n1--;
            n2--;
        }

        if (n1 >= 0 && n2 >= 0)
        {
            pElement1 = aryNode1[n1]->SafeElement();
            pElement2 = aryNode2[n2]->SafeElement();
        }

        Assert(pElement1);
        Assert(pElement2);
    }
    // TODO (IE6 bug 13584) (greglett) This code really should be in the other CompareZOrder
    // implementations, also.
    else if (ReparentedZOrder())
    {
        // Our parent should be the one who compares.
        pElement1 = GetTopmostAbsoluteZParent(GetFirstBranch())->SafeElement();
    }
    else if (pDispNode2->GetDispClient()->ReparentedZOrder())
    {
        // Out parent should be the one who compares.
        pElement2 = GetTopmostAbsoluteZParent(pElement2->GetFirstBranch())->SafeElement();
    }

    //
    //  Compare element z-order
    //  If the same element is associated with both display nodes,
    //  then the second display node is for an adorner (which always come
    //  on top of the element)
    //

    return pElement1 != pElement2
                ? pElement1->CompareZOrder(pElement2)
                : -1;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::HandleViewChange
//
//  Synopsis:   Respond to changes of this layout's in-view status.
//
//  Arguments:  flags           flags containing state transition info
//              prcClient       client rect in global coordinates
//              prcClip         clip rect in global coordinates
//              pDispNode       node which moved
//
//----------------------------------------------------------------------------

void
CLayout::HandleViewChange(
     DWORD          flags,
     const RECT *   prcClient,
     const RECT *   prcClip,
     CDispNode *    pDispNode)
{
    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CLayout::NotifyScrollEvent
//
//  Synopsis:   A scroll has occured in the display and now we can do
//              something with this information, like fire the script
//              event
//
//  Arugments:  prcScroll        - Rectangle scrolled
//              psizeScrollDelta - Amount scrolled
//
//----------------------------------------------------------------------------

void
CLayout::NotifyScrollEvent(
    RECT *  prcScroll,
    SIZE *  psizeScrollDelta)
{
    CDoc * pDoc = Doc();

    pDoc->GetView()->AddEventTask(ElementOwner(), DISPID_EVMETH_ONSCROLL, 0);

    pDoc->DeferSetCursor();

    if (pDoc->_pCaret)
    {
        // Update caret only if it is in this markup (#67170)
        Assert(ElementOwner()->IsInMarkup());
        Assert(pDoc->_pElemCurrent && pDoc->_pElemCurrent->IsInMarkup());
        if (pDoc->_pElemCurrent->GetFirstBranch()->GetNodeInMarkup(ElementOwner()->GetMarkup()))
        {
            pDoc->_pCaret->UpdateCaret(FALSE, FALSE);
        }
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     CLayout::GetPeerPainterInfo
//
//  Synopsis:   Return peer rendering layers
//
//-----------------------------------------------------------------------------

DWORD
CLayout::GetPeerPainterInfo(CAryDispClientInfo *pAryClientInfo)
{
    CElement     * pElem;
    CPeerHolder  * pPeerHolder = NULL;

    Assert(pAryClientInfo && pAryClientInfo->Size() == 0);

    pElem = ElementOwner();
    if(pElem->HasPeerHolder())
    {
        pPeerHolder = pElem->GetPeerHolder();
    }

    // Append the info that is delegated to the Root if needed
    // The peer is on the root when we are in the middle of a page transition
    if((pElem->Tag() == ETAG_BODY || pElem->Tag() == ETAG_FRAMESET || pElem->Tag() == ETAG_HTML))
    {
        CMarkup * pMarkup = pElem->GetMarkupPtr();
        if(pMarkup)
        {
            CDocument *pDocument = pMarkup->Document();
            if(pDocument && pDocument->HasPageTransitions() &&  pMarkup->Root()->HasPeerHolder())
            {
                // Peers for the page transition are attached to the root element
                CPeerHolder * pRootPeerHolder = pElem->GetMarkupPtr()->Root()->GetPeerHolder();
                CPeerHolder::CPeerHolderIterator iter;

                for (iter.Start(pRootPeerHolder);
                     !iter.IsEnd();
                     iter.Step())
                {
                    // All the peers that delegate to the root are filters
                    if (!iter.PH()->_pRenderBag->_fInFilterCallback)
                    {
                        CDispClientInfo *pInfo = pAryClientInfo->Append();
                        if (pInfo)
                        {
                            pInfo->_sInfo = iter.PH()->_pRenderBag->_sPainterInfo;
                            pInfo->_pvClientData = (void*) iter.PH();
                        }
                    }
                }
            }
        }
    }

    if (pPeerHolder)
    {
        CPeerHolder::CPeerHolderIterator iter;

        for (iter.Start(pPeerHolder);
             !iter.IsEnd();
             iter.Step())
        {
            if (iter.PH()->IsRenderPeer() && !iter.PH()->_pRenderBag->_fInFilterCallback)
            {
                CDispClientInfo *pInfo = pAryClientInfo->Append();
                if (pInfo)
                {
                    pInfo->_sInfo = iter.PH()->_pRenderBag->_sPainterInfo;
                    pInfo->_pvClientData = (void*) iter.PH();
                }
            }
        }
    }


    return pAryClientInfo->Size() ? pAryClientInfo->Item(0)._sInfo.lZOrder
                                   : HTMLPAINT_ZORDER_NONE;
}

//+----------------------------------------------------------------------------
//
//  Member:     CLayout::GetClientPainterInfo
//
//  Synopsis:   Return client rendering layers
//
//-----------------------------------------------------------------------------

DWORD
CLayout::GetClientPainterInfo(  CDispNode *pDispNodeFor,
                                CAryDispClientInfo *pAryClientInfo)
{
    if ( _pDispNode    != pDispNodeFor)     // if draw request is for nodes other then primary
        return 0;                       // no layers

    return GetPeerPainterInfo(pAryClientInfo);
}


//+----------------------------------------------------------------------------
//
//  Member:     CLayout::DrawClientLayers
//
//  Synopsis:   Give a peer a chance to render
//
//-----------------------------------------------------------------------------

void
CLayout::DrawClientLayers(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          cookie,
    void *          pClientData,
    DWORD           dwFlags)
{
    CDispDrawContext * pContext = (CDispDrawContext *)pClientData;
    CFormDrawInfo * pDI         = (CFormDrawInfo *)pContext->GetClientData();
    CPeerHolder * pPeerHolder = NULL;
    CPeerHolder * pPeerHolderPageTransition = NULL;
    CElement    * pElemOwner = ElementOwner();

    BOOL    fNeedPageTransitionRedirect =
            (     pElemOwner->Tag() == ETAG_BODY 
               || pElemOwner->Tag() == ETAG_FRAMESET
               || pElemOwner->Tag() == ETAG_HTML
            ) &&
            pElemOwner->HasMarkupPtr() &&
            pElemOwner->GetMarkupPtr()->Root()->HasPeerHolder();

    Assert(!fNeedPageTransitionRedirect || pElemOwner->GetMarkupPtr()->Document());
    // If root has a peerholder, we must have page transitions
    Assert(!fNeedPageTransitionRedirect || pElemOwner->GetMarkupPtr()->Document()->HasPageTransitions());

    Assert(pDI);
    Assert(pElemOwner->HasPeerHolder() || fNeedPageTransitionRedirect);

    if (cookie == NULL)
    {
        if(fNeedPageTransitionRedirect)
        {
            pPeerHolderPageTransition = pElemOwner->GetMarkupPtr()->Root()->GetRenderPeerHolder();
        }
        pPeerHolder = pElemOwner->GetRenderPeerHolder();
    }
    else
    {
        // make sure the cookie points to a PH that still exists
        CPeerHolder * pPH = (CPeerHolder*) cookie;
        CPeerHolder::CPeerHolderIterator iter;

        for (iter.Start(pElemOwner->GetPeerHolder());
             !iter.IsEnd();
             iter.Step())
        {
            if (pPH == iter.PH())
            {
                pPeerHolder = pPH;
                break;
            }
        }

        if(fNeedPageTransitionRedirect)
        {
            // Peers for the page transition are attached to the root element
            for (iter.Start(pElemOwner->GetMarkup()->Root()->GetPeerHolder());
                 !iter.IsEnd();
                 iter.Step())
            {
                if (pPH == iter.PH())
                {
                    pPeerHolderPageTransition = pPH;
                    break;
                }
            }
        }
    }

    Assert(pPeerHolder || pPeerHolderPageTransition);

    if (pPeerHolder)
    {
        Assert(pPeerHolder->_pRenderBag);
        CRect rcBounds = *prcBounds;
        CRect rcClip = *prcRedraw;

        pContext->IntersectRedrawRegion(&rcClip);
        CSetDrawSurface sds(pDI, &rcBounds, &rcClip, pDispSurface);

        // Save the layout draw context into the pContext
        // It will be needed when the filter calls back, so we can decide
        // which one fo the multiple layoutes the call goes to
        CLayoutContext * pLayoutContext = LayoutContext();
        if(pLayoutContext)
            pContext->PushLayoutContext(pLayoutContext);

        pPeerHolder->Draw(pContext, dwFlags);

        if(pLayoutContext)
            pContext->PopLayoutContext();
    }

    if (pPeerHolderPageTransition)
    {
        Assert(pPeerHolderPageTransition->_pRenderBag);
        CRect rcBounds = *prcBounds;
        CRect rcClip = *prcRedraw;

        pContext->IntersectRedrawRegion(&rcClip);
        CSetDrawSurface sds(pDI, &rcBounds, &rcClip, pDispSurface);

        pPeerHolderPageTransition->Draw(pContext, dwFlags);
    }


}


//+----------------------------------------------------------------------------
//
//  Member:     CLayout::HasFilterPeer, per CDispClient
//
//  Synopsis:   Return true if there's a filter peer for the given dispnode
//
//-----------------------------------------------------------------------------

BOOL
CLayout::HasFilterPeer(CDispNode *pDispNode)
{
    BOOL    fPageTransitonRedirect = FALSE;
    if (pDispNode == _pDispNode)
    {
        CPeerHolder * pPeerHolder = ElementOwner()->GetFilterPeerHolder(TRUE, &fPageTransitonRedirect);
        if(fPageTransitonRedirect && !pPeerHolder)
        {
            pPeerHolder = ElementOwner()->GetFilterPeerHolder(FALSE);
        }

        return (pPeerHolder != NULL);
    }
    else
    {
        return FALSE;
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     CLayout::HasOverlayPeer, per CDispClient
//
//  Synopsis:   Return true if there's an overlay peer for the given dispnode
//
//-----------------------------------------------------------------------------

BOOL
CLayout::HasOverlayPeer(CDispNode *pDispNode)
{
    if (pDispNode == _pDispNode)
    {
        CPeerHolder::CPeerHolderIterator iter;

        for (iter.Start(ElementOwner()->GetPeerHolder());
             !iter.IsEnd();
             iter.Step())
        {
            if (iter.PH()->IsOverlayPeer())
                return TRUE;
        }
    }

    return FALSE;
}


//+----------------------------------------------------------------------------
//
//  Member:     CLayout::MoveOverlayPeers, per CDispClient
//
//  Synopsis:   Notify overlay peers that they have moved
//
//-----------------------------------------------------------------------------

void
CLayout::MoveOverlayPeers(CDispNode *pDispNode, CRect *prcgBounds, CRect *prcScreen)
{
    if (pDispNode == _pDispNode)
    {
        CInPlace *pInPlace = Doc()->_pInPlace;

        if (pInPlace)
        {
            // translate to screen coordinates
            CPoint ptTopLeft = prcgBounds->TopLeft();
            CPoint ptBottomRight = prcgBounds->BottomRight();

            ClientToScreen(pInPlace->_hwnd, &ptTopLeft);
            ClientToScreen(pInPlace->_hwnd, &ptBottomRight);

            CRect rcScreen(ptTopLeft, ptBottomRight);

            // if it moved, notify the peers
            if (rcScreen != *prcScreen)
            {
                CPeerHolder::CPeerHolderIterator iter;

                for (iter.Start(ElementOwner()->GetPeerHolder());
                     !iter.IsEnd();
                     iter.Step())
                {
                    if (iter.PH()->IsOverlayPeer())
                    {
                        iter.PH()->OnMove(&rcScreen);
                    }
                }
            }

            // update last known position
            *prcScreen = rcScreen;
        }
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     CLayout::InvalidateFilterPeer
//
//  Synopsis:   Send invalidation into the filter behavior
//
//-----------------------------------------------------------------------------

HRESULT
CLayout::InvalidateFilterPeer(
                const RECT* prc,
                HRGN hrgn,
                BOOL fSynchronousRedraw)
{
    BOOL            fPageTransitonRedirect;
    HRESULT         hr = S_FALSE;

    CPeerHolder   * pPeerHolder = ElementOwner()->GetFilterPeerHolder(TRUE, &fPageTransitonRedirect);

    if (pPeerHolder)
    {
        pPeerHolder->InvalidateFilter(prc, hrgn, fSynchronousRedraw);
        hr = S_OK;
    }

    if(fPageTransitonRedirect)
    {
        pPeerHolder = ElementOwner()->GetFilterPeerHolder(FALSE);
        if (pPeerHolder)
        {
            pPeerHolder->InvalidateFilter(prc, hrgn, fSynchronousRedraw);
            hr = S_OK;
        }
    }

    RRETURN1(hr, S_FALSE);
}


#if DBG==1
//+---------------------------------------------------------------------------
//
//  Member:     CLayout::DumpDebugInfo
//
//  Synopsis:   Dump debugging information for the given display node.
//
//  Arguments:  hFile           file handle to dump into
//              level           recursive tree level
//              childNumber     number of this child within its parent
//              pDispNode       pointer to display node
//              cookie          cookie value (only if present)
//
//  Notes:
//
//----------------------------------------------------------------------------

void
CLayout::DumpDebugInfo(
        HANDLE hFile,
        long level,
        long childNumber,
        CDispNode const* pDispNode,
        void *cookie)
{
    if (pDispNode->IsOwned())
    {
        WriteHelp(hFile, _T("<<tag><0s><</tag>\r\n"), ElementOwner()->TagName());
    }
}
#endif


//+----------------------------------------------------------------------------
//
//  Member:     GetElementDispNode
//
//  Synopsis:   Return the display node for the pElement
//
//              There are up to two display nodes associated with a layout:
//              The display node that directly represents the layout to its
//              parent and the display node that establishes the container
//              coordinate system for the layout (the primary display node).
//
//              The first of these is always kept in _pDispNode while the second
//              will be different when a filter is active. Parents that need
//              the display node to anchor into the display tree should never
//              request the primary display node (that is, fPrimary should be
//              FALSE for these uses). However, the layout itself should always
//              request the primary display node when accessing its own display
//              node.
//
//  Arguments:  pElement   - CElement whose display node is to obtained
//              fForParent - If TRUE (the default), return the display node a parent
//                           inserts into the tree. Otherwise, return the primary
//                           display node.
//                           NOTE: This only makes a difference with layouts that
//                                 have a filter.
//
//  Returns:    Pointer to the layout CDispNode if one exists, NULL otherwise
//
//-----------------------------------------------------------------------------
CDispNode *
CLayout::GetElementDispNode( CElement *  pElement ) const
{
    Assert(   !pElement
           || pElement == ElementOwner());

    return _pDispNode;
}


//+----------------------------------------------------------------------------
//
//  Member:     SetElementDispNode
//
//  Synopsis:   Set the display node for an element
//              NOTE: This is only supported for elements with layouts or
//                    those that are relatively positioned
//
//-----------------------------------------------------------------------------
void
CLayout::SetElementDispNode( CElement *  pElement, CDispNode * pDispNode )
{
    Assert( !pElement
        ||  pElement == ElementOwner());

    _pDispNode = pDispNode;
}


//+----------------------------------------------------------------------------
//
//  Member:     GetFirstContentDispNode
//
//  Synopsis:   Return the first content node
//
//              Only container-type display nodes have child content nodes.
//              This routine will return the first, unowned content node in the
//              flow layer under a container display or NULL.
//
//  Arguments:  pDispNode - Parent CDispNode (defaults to layout display node)
//              dwBlockID - Layout block ID.
//
//  Returns:    Pointer to flow CDispNode if one exists, NULL otherwise
//
//-----------------------------------------------------------------------------
CDispLeafNode *
CLayout::GetFirstContentDispNode( CDispNode * pDispNode ) const
{
    if (!pDispNode)
        pDispNode = GetElementDispNode();

    if (!pDispNode)
        return NULL;

    if (!pDispNode->IsContainer())
        return NULL;

    pDispNode = pDispNode->GetFirstFlowChildNode();

    if (!pDispNode)
        return NULL;

    while (pDispNode->IsOwned())
    {
        pDispNode = pDispNode->GetNextFlowNode();
        if (!pDispNode)
            return NULL;
    }

    Assert(pDispNode && pDispNode->IsLeafNode() && !pDispNode->IsOwned());

    return CDispLeafNode::Cast(pDispNode);
}


//+----------------------------------------------------------------------------
//
//  Member:     GetElementTransform
//
//  Synopsis:   Determine if custorm transformations are required, and fill
//              CWorldTransform if yes.
//
//  Arguments:  CDispTransform * ptransform - transformation descriptor to fill
//
//  Returns:    TRUE if transformations are required (ptransform filled)
//              FALSE if no transformations are required (ptransform ignored)
//
//-----------------------------------------------------------------------------
BOOL
CLayout::GetElementTransform(
    const CRect    * prcSrc,              // Can be NULL
    CDispTransform * ptransform,          // Can be NULL
    BOOL           * pfResolutionChange  // Can be NULL
    ) const
{
    BOOL   fHasUserTransform = FALSE;

    if (pfResolutionChange)
        *pfResolutionChange = FALSE;

    CTreeNode *pNode = ElementOwner()->GetFirstBranch();
    const CFancyFormat *pFF = pNode->GetFancyFormat(LC_TO_FC(((CLayout *)this)->LayoutContext()));

    // Note (azmyh) we assume the rotation angle to be in degrees
    // if we need more resolution we should make the changes here
    ANG ang = AngFromDeg(pNode->GetRotationAngle(pFF FCCOMMA LC_TO_FC(this->LayoutContext())));

    FLOAT flZoomFactor = 1.0;

    if (pFF->_flZoomFactor != 0)
    {
        flZoomFactor = pFF->_flZoomFactor;
    }

    // Add scaling for resolution change. The idea is to scale 1 printer inch to 1 screen inch
    CLayoutContext * pDefinedLayoutContext = DefinedLayoutContext();
    if (   pDefinedLayoutContext)
    {
        // We need to scale when parent context resolution is different from ours
        CLayoutContext * pLayoutContext = LayoutContext();
        CSize sizeInchParent = pLayoutContext 
                             ? pLayoutContext->GetMeasureInfo()->GetResolution()
                             : GetView()->GetMeasuringDevice(mediaTypeNotSet)->GetResolution();
                             
        CSize sizeInch = (pDefinedLayoutContext->IsValid())
                            ? pDefinedLayoutContext->GetMeasureInfo()->GetResolution()
                            : sizeInchParent;

        if (sizeInchParent != sizeInch)
        {
            flZoomFactor *= sizeInchParent.cx;
            flZoomFactor /= sizeInch.cx;

            if (pfResolutionChange)
                *pfResolutionChange = TRUE;
        }
    }

    if (flZoomFactor != 1.0 || ang != 0)
    {
        fHasUserTransform = TRUE;

        if (ptransform)
        {

            // define custom transformation *relative to parent*
            ptransform->SetToIdentity();

            CWorldTransform *pWorldTransform = ptransform->GetWorldTransform();

            if (ang)
            {

                Assert(prcSrc);

                 //rotate stuff

                pWorldTransform->AddRotation(ang);

                //add offset to move content back into bounds after rotation

                CRect rectBound;
                pWorldTransform->GetBoundingRectAfterTransform(prcSrc, &rectBound, FALSE /*changed from TRUE for bug 93619*/);

#if 0
                // our rects include the pixels underneath the top and
                // left edges, but not under the bottom and right edges.
                // Adjust for that here.  We decide which adjustments are
                // necessary by transforming the point (1,1) and seeing which
                // quadrant it ends up in.  This has the effect of adjusting x
                // for angles between 135 and 315 degrees, and y for angles
                // between 45 and 225 degrees (mod 360, of course).
                // We do this in a clever way just for the fun of avoiding
                // multiplications.
                if (!pWorldTransform->IsOffsetOnly())
                {
                    const XFORM *pXform = pWorldTransform->GetXform();
                    if (pXform->eM11 + pXForm->eM21 < 0.0)
                        rectBound.top += 1;
                    if (pXForm->eM12 + pXForm->eM22 < 0.0)
                        rectBound.left += 1;
                }
#endif

                pWorldTransform->AddPostTranslation( prcSrc->TopLeft() - rectBound.TopLeft());


#if DBG ==1
// this is the original code, we'll run it as well to see if the new code gives
// the right answer.  The new code is slightly more efficient, and avoids some
// obvious roundoff problems, so we expect it to give slightly different
// answers from the old code. (SamBent)
            {
                CWorldTransform worldTransform, *pWorldTransform1=&worldTransform;

                 //rotate stuff around the center (prcSrc has an untransformed(unzoomed) rect in container coords)

                pWorldTransform1->AddRotation(prcSrc, ang);

                //add offset to move content back into bounds after rotation

                CSize sizeBound, size(prcSrc->Size());
                pWorldTransform1->GetBoundingSizeAfterTransform(prcSrc, &sizeBound);

                if (sizeBound != size)
                    pWorldTransform1->AddPostTranslation((sizeBound - size) / 2);

                CPoint pt(0,0), pt1(0,0);
                pWorldTransform->Transform(&pt);
                pWorldTransform1->Transform(&pt1);
                pt -= pt1.AsSize();

                Assert(pWorldTransform->GetAngle() == pWorldTransform1->GetAngle() &&
                    Abs(pt.x) <= 2 && Abs(pt.y) <= 2);
            }
#endif
            }

            if (flZoomFactor != 1.0)
            {
                pWorldTransform->AddScaling(flZoomFactor, flZoomFactor);
            }
        }

    }

    if (   ElementOwner()->GetLayoutPeerHolder()
        && ElementOwner()->GetLayoutPeerHolder()->IsLayoutPeer())
    {

        if (ptransform)
        {
            CPoint ptOffset = ElementOwner()->GetLayoutPeerHolder()->_pLayoutBag->_ptTranslate;

            if ( ptOffset != g_Zero.pt)
            {
                // define custom transformation *relative to parent*
                ptransform->SetToIdentity();

                CWorldTransform *pWorldTransform = ptransform->GetWorldTransform();

                pWorldTransform->AddPostTranslation( ptOffset.AsSize() );
            }
        }

        fHasUserTransform  = TRUE;
    }


    return  fHasUserTransform;
}

//+----------------------------------------------------------------------------
//
//  Member:     GetDispNodeInfo
//
//  Synopsis:   Retrieve values useful for determining what type of display
//              node to create
//
//  Arguments:  pdni     - Pointer to CDispNodeInfo to fill
//              pdci     - Current CDocInfo (only required when fBorders == TRUE)
//              fBorders - If TRUE, retrieve border information
//              dwBlockID - Layout block ID.
//
//-----------------------------------------------------------------------------

void
CLayout::GetDispNodeInfo(
    CDispNodeInfo * pdni,
    CDocInfo *      pdci,
    BOOL            fBorders ) const
{
    CElement *              pElement    = ElementOwner();
    CTreeNode *             pTreeNode   = pElement->GetFirstBranch();
    const CFancyFormat *    pFF         = pTreeNode->GetFancyFormat(LC_TO_FC(((CLayout *)this)->LayoutContext()));
    const CCharFormat  *    pCF         = pTreeNode->GetCharFormat(LC_TO_FC(((CLayout *)this)->LayoutContext()));
    const CParaFormat  *    pPF       = pTreeNode->GetParaFormat(LC_TO_FC(((CLayout *)this)->LayoutContext()));
    const BOOL  fVerticalLayoutFlow     = pCF->HasVerticalLayoutFlow();
    const BOOL  fWritingModeUsed        = pCF->_fWritingModeUsed;
    BOOL                    fThemed     =    GetThemeClassId() != THEME_NO       
                                          && pElement->GetTheme(GetThemeClassId());
    BOOL                    fHTMLLayout = GetOwnerMarkup()->IsHtmlLayout();
    CBackgroundInfo         bi;

    //
    //  Get general information
    //

    pdni->_etag  = pElement->Tag();

    pdni->_layer =  (   !fHTMLLayout
                     && (   pdni->_etag == ETAG_BODY
                         || pdni->_etag == ETAG_FRAMESET
                         || pdni->_etag == ETAG_FRAME ))
                ||  (   fHTMLLayout
                     && pdni->_etag == ETAG_HTML )
                ||  (stylePosition)pFF->_bPositionType == stylePositionstatic
                ||  (stylePosition)pFF->_bPositionType == stylePositionNotSet
                            ? DISPNODELAYER_FLOW
                            : pFF->_lZIndex >= 0
                                    ? DISPNODELAYER_POSITIVEZ
                                    : DISPNODELAYER_NEGATIVEZ;

    //
    //  Determine if custom transformations are required
    //
    pdni->_fHasUserTransform = GetElementTransform(NULL, NULL, NULL);

    //
    //  Determine if insets are required
    //

    if (TestLayoutDescFlag(LAYOUTDESC_TABLECELL))
    {
        htmlCellVAlign  fVAlign;

        fVAlign = (htmlCellVAlign)pPF->_bTableVAlignment;

        pdni->_fHasInset = (    fVAlign != htmlCellVAlignNotSet
                            &&  fVAlign != htmlCellVAlignTop);
    }
    else
    {
        pdni->_fHasInset = TestLayoutDescFlag(LAYOUTDESC_HASINSETS);
    }

    //
    //  Determine background information
    //

    const_cast<CLayout *>(this)->GetBackgroundInfo(NULL, &bi, FALSE);

    pdni->_fHasBackground      = (bi.crBack != COLORREF_NONE || bi.pImgCtx) ||
                                  const_cast<CLayout *>(this)->IsShowZeroBorderAtDesignTime() ; // we always call DrawClientBackground when ZEROBORDER is on

    pdni->_fHasFixedBackground =        (bi.fFixed && !!bi.pImgCtx)
                                   ||   fThemed && pdni->_etag != ETAG_FIELDSET;


    pdni->_fIsOpaque = FALSE;

    if (   (pdni->_etag == ETAG_IMAGE)
        || (pdni->_etag == ETAG_IMG)
        || (   (pdni->_etag == ETAG_INPUT)
            && (DYNCAST(CInput, pElement)->GetType() == htmlInputImage)))
    {
        WHEN_DBG( const void *pvImgCtx = NULL; )
        WHEN_DBG( const void *pvInfo = NULL; )

        // These elements can have a flow layout if they have a slave. Check for this
        // before trying to cast to CImageLayout
        if (!((CLayout*)this)->IsFlowLayout())
        {
            CImageLayout *pImgLayout = const_cast<CImageLayout *>(DYNCAST(const CImageLayout, this));
            pdni->_fIsOpaque = pImgLayout->IsOpaque();

            WHEN_DBG( pvImgCtx = pImgLayout->GetImgHelper()->_pImgCtx; )
            WHEN_DBG( if (pvImgCtx) pvInfo = pImgLayout->GetImgHelper()->_pImgCtx->GetDwnInfoDbg(); )
        }

        TraceTag((tagImgTrans, "img layout %x ctx %x info %x  dni is %s",
                    this, pvImgCtx, pvInfo,
                    (!!(pdni->_fIsOpaque) ? "opaque" : "trans")));
    }

    // if there is a background image that doesn't cover the whole site, then we cannont be
    // opaque
    //
    // todo (IE5x BUG 66092) (carled) we are too close to RC0 to do the full fix.  Bug #66092 is opened for the ie6
    // timeframe to clean this up.  the imagehelper fx (above) should be REMOVED!! gone. bad
    // instead we need a virtual function on CLayout called BOOL CanBeOpaque(). The def imple
    // should contain the if stmt below. CImageLayout should override and use the contents
    // of CImgHelper::IsOpaque, (and call super). Framesets could possibly override and set
    // to false.  Input type=Image should override and do the same things as CImageLayout
    //
    pdni->_fIsOpaque  =    !TestLayoutDescFlag(LAYOUTDESC_NEVEROPAQUE)
                       &&  (   pdni->_fIsOpaque
                            || bi.crBack != COLORREF_NONE && !fThemed
                            ||  (   !!bi.pImgCtx
                                 &&  !!(bi.pImgCtx->GetState() & (IMGTRANS_OPAQUE))
                                 &&  pFF->GetBgPosX().GetRawValue() == 0 // Logical/physical does not matter
                                 &&  pFF->GetBgPosY().GetRawValue() == 0 // since we check both X and Y here.
                                 &&  pFF->GetBgRepeatX()                 // Logical/physica does not matter
                                 &&  pFF->GetBgRepeatY())                // since we check both X and Y here.
                            );

    if ( Tag() == ETAG_FRAME || Tag() == ETAG_IFRAME )
    {
        pdni->_fIsOpaque = DYNCAST(CFrameSite, pElement)->IsOpaque();
    }

    // NOTE (donmarsh) - treat elements with HWND as transparent.
    // This is pessimistic, but it's only a
    // small perf hit if the window is opaque and the display node is
    // transparent.  On the other hand, it is a rendering
    // bug if the window is transparent and the display node is opaque.
    if (pdni->_fIsOpaque && pElement->GetHwnd() != NULL)
        pdni->_fIsOpaque = FALSE;

#if DBG == 1
    if (bi.pImgCtx)
    {
        TraceTag((tagImgTrans, "layout %x  imgctx %x is %s  dni is %s",
                    this, bi.pImgCtx,
                    (!!(bi.pImgCtx->GetState() & (IMGTRANS_OPAQUE)) ? "opaque" : "trans"),
                    (!!(pdni->_fIsOpaque) ? "opaque" : "trans")));
    }
#endif

    //
    //  Determine overflow, scroll and scrollbar direction properties
    //

    pdni->_overflowX   = pFF->GetLogicalOverflowX(fVerticalLayoutFlow, fWritingModeUsed);
    pdni->_overflowY   = pFF->GetLogicalOverflowY(fVerticalLayoutFlow, fWritingModeUsed);
    pdni->_fIsScroller = pTreeNode->IsScrollingParent(LC_TO_FC(LayoutContext()));
    pdni->_fRTL = pTreeNode->GetCascadedBlockDirection(LC_TO_FC(LayoutContext())) == styleDirRightToLeft;

    // PERF note: not all nodes in RTL need this, only flow, and in fact, only if it is too wide.
    //            However, it is impossible to predict if an RTL node will eventually have
    //            an overflow, and display tree doesn't allow adding extras on the fly.
    //            Therefore, we have to make RTL disp nodes more expensive by an integer.
    pdni->_fHasContentOrigin = pdni->_fRTL
                                && ((CLayout*)this)->IsFlowLayout(); // only flow layout knows how to use it

    // In design mode, we want to treat overflow:hidden containers as overflow:visible
    // so editors can get to all their content.  This fakes out the display tree
    // so it creates CDispContainer*'s instead of CDispScroller, and hence doesn't
    // clip as hidden normally does. (KTam: #59722)
    // The initial fix is too aggressive; text areas implicitly set overflowX hidden
    // if they're in wordwrap mode.  Fix is to not do this munging for text areas..
    // Need to Revisit this
    // (carled) other elements (like inputText & inputButton) aslo implicitly set this property. (82287)
    if ( ((CLayout*)this)->IsDesignMode()
        && pdni->_etag != ETAG_TEXTAREA
        && pdni->_etag != ETAG_INPUT
        && pdni->_etag != ETAG_BUTTON)
    {
        if ( pdni->_overflowX  == styleOverflowHidden )
        {
            pdni->_overflowX = styleOverflowVisible;
            pdni->_fIsScroller = FALSE;
        }
        if ( pdni->_overflowY == styleOverflowHidden )
        {
            pdni->_overflowY = styleOverflowVisible;
            pdni->_fIsScroller = FALSE;
        }
    }

    if (pdni->_etag == ETAG_OBJECT)
    {
        //  Never allow scroll bars on an object.  The object is responsible for that.
        //  Bug #77073  (greglett)
        pdni->_sp._fHSBAllowed =
        pdni->_sp._fHSBForced  =
        pdni->_sp._fVSBAllowed =
        pdni->_sp._fVSBForced  = FALSE;
    }
    else if (((   !fHTMLLayout
                 && pdni->_etag == ETAG_BODY )
             || (   fHTMLLayout
                 && pdni->_etag == ETAG_HTML
                 && GetOwnerMarkup()->GetElementClient()
                 && GetOwnerMarkup()->GetElementClient()->Tag() == ETAG_BODY )
               )
             && !ElementOwner()->IsInViewLinkBehavior( TRUE ) )
    {
        UpdateScrollInfo(pdni, this);
    }
    else
    {
        GetDispNodeScrollbarProperties(pdni);
    }

    //
    //  Determine appearance properties
    //

    pdni->_fHasUserClip = ( pdni->_etag != ETAG_BODY
                        &&  (stylePosition)pFF->_bPositionType == stylePositionabsolute

                            // Do not care about physical/logical here since all TBLR are checked.
                        &&  (   !pFF->GetClip(SIDE_TOP).IsNullOrEnum()
                            ||  !pFF->GetClip(SIDE_BOTTOM).IsNullOrEnum()
                            ||  !pFF->GetClip(SIDE_LEFT).IsNullOrEnum()
                            ||  !pFF->GetClip(SIDE_RIGHT).IsNullOrEnum()));

    pdni->_fHasExpandedClip = pElement->IsBodySizingForStrictCSS1Needed();

    pdni->_visibility   = VisibilityModeFromStyle(pTreeNode->GetCascadedvisibility(LC_TO_FC(((CLayout *)this)->LayoutContext())));

    //
    //  Get border information (if requested)
    //

    if (fBorders)
    {
        Assert(pdci);

        pdni->_dnbBorders = pdni->_etag == ETAG_SELECT
                                ? DISPNODEBORDER_NONE
                                : (DISPNODEBORDER)pElement->GetBorderInfo(pdci, &(pdni->_bi), FALSE, FALSE FCCOMMA LC_TO_FC(((CLayout *)this)->LayoutContext()));

        Assert( pdni->_dnbBorders == DISPNODEBORDER_NONE
            ||  pdni->_dnbBorders == DISPNODEBORDER_SIMPLE
            ||  pdni->_dnbBorders == DISPNODEBORDER_COMPLEX);

        pdni->_fIsOpaque = pdni->_fIsOpaque
                            && (pdni->_dnbBorders == DISPNODEBORDER_NONE
                                || (    pdni->_bi.IsOpaqueEdge(SIDE_TOP)
                                    &&  pdni->_bi.IsOpaqueEdge(SIDE_LEFT)
                                    &&  pdni->_bi.IsOpaqueEdge(SIDE_BOTTOM)
                                    &&  pdni->_bi.IsOpaqueEdge(SIDE_RIGHT)) );
    }

    // Check if need to disable 'scroll bits' mode
    pdni->_fDisableScrollBits =   pdni->_fHasFixedBackground 
                               || (pFF->GetTextOverflow() != styleTextOverflowClip);

    // external painters may override some of the information we've computed
    if (pElement->HasPeerHolder())
    {
        CPeerHolder::CPeerHolderIterator iter;

        for (iter.Start(ElementOwner()->GetPeerHolder());
             !iter.IsEnd();
             iter.Step())
        {
            if (iter.PH()->IsRenderPeer())
            {
                HTML_PAINTER_INFO *pInfo = &iter.PH()->_pRenderBag->_sPainterInfo;

                // if painter is in charge of background, we're only opaque if
                // he says so
                if (!(pInfo->lFlags & HTMLPAINTER_OPAQUE) &&
                        (pInfo->lZOrder == HTMLPAINT_ZORDER_REPLACE_BACKGROUND ||
                         pInfo->lZOrder == HTMLPAINT_ZORDER_REPLACE_ALL))
                {
                    pdni->_fIsOpaque = FALSE;
                }

                // if painter doesn't allow scrollbits, neither should we
                if ((pInfo->lFlags & HTMLPAINTER_NOSCROLLBITS) &&
                    pInfo->lZOrder != HTMLPAINT_ZORDER_NONE)
                {
                    pdni->_fDisableScrollBits = TRUE;
                }
            }
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     GetDispNodeScrollbarProperties
//
//  Synopsis:   Set the scrollbar related properties of a CDispNodeInfo
//
//  Arguments:  pdni - Pointer to CDispNodeInfo
//
//-----------------------------------------------------------------------------

void
 CLayout::GetDispNodeScrollbarProperties(
    CDispNodeInfo * pdni) const
{
    switch (pdni->_overflowX)
    {
    case styleOverflowNotSet:
    case styleOverflowVisible:
    case styleOverflowHidden:
        pdni->_sp._fHSBAllowed =
        pdni->_sp._fHSBForced  = FALSE;
        break;

    case styleOverflowAuto:
        pdni->_sp._fHSBAllowed = TRUE;
        pdni->_sp._fHSBForced  = FALSE;
        break;

    case styleOverflowScroll:
        pdni->_sp._fHSBAllowed =
        pdni->_sp._fHSBForced  = TRUE;
        break;

#if DBG==1
    default:
        AssertSz(FALSE, "Illegal value for overflow style attribute!");
        break;
#endif
    }

    switch (pdni->_overflowY)
    {
    case styleOverflowNotSet:
    case styleOverflowVisible:
    case styleOverflowHidden:
        pdni->_sp._fVSBAllowed =
        pdni->_sp._fVSBForced  = FALSE;
        break;

    case styleOverflowAuto:
        pdni->_sp._fVSBAllowed = TRUE;
        pdni->_sp._fVSBForced  = FALSE;
        break;

    case styleOverflowScroll:
        pdni->_sp._fVSBAllowed =
        pdni->_sp._fVSBForced  = TRUE;
        break;

#if DBG==1
    default:
        AssertSz(FALSE, "Illegal value for overflow style attribute!");
        break;
#endif
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     EnsureDispNode
//
//  Synopsis:   Ensure an appropriate display node exists
//
//              For all but FRAMESET, if a container node is created, a single
//              CDispLeafNode will also be created and inserted as the first
//              child in the flow layer.
//
//  Arugments:  pdci   - Current CDocInfo
//              fForce - Forcibly update the display node(s)
//
//  Returns:    S_OK    if successful
//              S_FALSE if nodes were created/destroyed/changed in a significant way
//              E_FAIL  otherwise
//
//-----------------------------------------------------------------------------
HRESULT
CLayout::EnsureDispNodeCore(
    CCalcInfo *             pci,
    BOOL                    fForce,
    const CDispNodeInfo &   dni,
    CDispNode **            ppDispNodeElement
    )
{
    Assert(pci);
    Assert(ppDispNodeElement);
    
    CDispNode *     pDispNodeElement    = *ppDispNodeElement;
    CDispNode *     pDispNodeContent    = NULL;
    BOOL            fWasRTLScroller     = FALSE;
    BOOL            fHTMLLayout         = GetOwnerMarkup()->IsHtmlLayout();
    BOOL            fCloneDispNode      = pci->_fCloneDispNode && (!pci->_fTableCalcInfo || !((CTableCalcInfo *)pci)->_fSetCellPosition);
    HRESULT         hr                  = S_OK;

    //
    //  If the wrong type of display node exists, replace it
    //
    //  A new display is needed when:
    //      a) No display node exists
    //      b) If being forced to create a display node
    //      c) A different type of border is needed (none vs. simple vs. complex)
    //      d) The type of display node does not match current inset/scrolling/user-clip settings
    //
    //  Assert for print view positioned elements pagination support
    Assert(!fCloneDispNode || pDispNodeElement);

    


    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CLayout::EnsureDispNode L(0x%x, %S) Force=%d Clone=%d CurrentDN:0x%x", this, ElementOwner()->TagName(), fForce, fCloneDispNode, pDispNodeElement ));

    if (    !pDispNodeElement
        ||  fForce
        ||  fCloneDispNode
        ||  dni.GetBorderType() != pDispNodeElement->GetBorderType()
        ||  dni.HasInset()      != pDispNodeElement->HasInset()
        ||  dni.IsScroller()    != pDispNodeElement->IsScroller()
        ||  dni.HasUserClip()   != pDispNodeElement->HasUserClip()
        ||  dni.HasExpandedClip() != pDispNodeElement->HasExpandedClipRect()
        ||  dni.HasUserTransform()!= pDispNodeElement->HasUserTransform()
        ||  dni.HasContentOrigin()!= pDispNodeElement->HasContentOrigin()

        // note: IsRTLScroller() is always equal to (IsScroller() && HasContentOrigin()),
        //       unless there is a different reason for content origin
        ||  dni.IsRTLScroller()!= (pDispNodeElement->IsScroller() &&
                                     DYNCAST(CDispScroller, pDispNodeElement)->IsRTLScroller()))
    {
        CDispNode * pDispNode;
        BOOL        fRequireContainer;
        CDispClient * pDispClient = this;

        DWORD extras = 0;

        if (dni.GetBorderType() == DISPNODEBORDER_SIMPLE)
            extras |= DISPEX_SIMPLEBORDER;
        else if (dni.GetBorderType() == DISPNODEBORDER_COMPLEX)
            extras |= DISPEX_COMPLEXBORDER;
        
        if (dni.HasInset())
            extras |= DISPEX_INSET;
            
        if (dni.HasUserClip() || dni.HasExpandedClip())
            extras |= DISPEX_USERCLIP;
        if (dni.HasUserTransform())
            extras |= DISPEX_USERTRANSFORM;
        if (dni.HasContentOrigin())
            extras |= DISPEX_CONTENTORIGIN;
        else if (pDispNodeElement && pDispNodeElement->HasContentOrigin() && pDispNodeElement->IsScroller())
            fWasRTLScroller = TRUE;

        //
        //  Create the appropriate type of display node
        //
        fRequireContainer = ((      pDispNodeElement
                                &&  pDispNodeElement->IsContainer()
                                &&  DYNCAST(CDispContainer, pDispNodeElement)->CountChildren() > 1)
                            ||  ElementOwner()->IsLinkedContentElement()
                            ||  (   fHTMLLayout
                                 && dni.IsTag(ETAG_HTML) )
                            ||  dni.IsTag(ETAG_BODY)
// TODO (lmollico): what about the ETAG_FRAME?
                            ||  dni.IsTag(ETAG_IFRAME)
                            ||  dni.IsTag(ETAG_TABLE)
                            ||  dni.IsTag(ETAG_FRAMESET)
                            ||  dni.IsTag(ETAG_TR) );

        pDispNode = (dni.IsScroller()
                        ? (CDispNode *)CDispScroller::New(pDispClient, extras)
                        :   fRequireContainer
                            ? (CDispNode *)CDispContainer::New(pDispClient,
                                                                        dni.IsTag(ETAG_TR)
                                                                          ? (extras & ~DISPEX_ANYBORDER)
                                                                          : extras)
                            : (CDispNode *)CDispLeafNode::New(pDispClient, extras));

        if (!pDispNode)
            goto Error;

        TraceTagEx((tagCalcSizeDetail, TAG_NONAME, " Created DN: 0x%x", pDispNode ));

        // If RTL, and it is a scroller, scroll bar should be on the left
        if (dni.IsScroller() && dni.IsRTLScroller())
        {
            DYNCAST(CDispScroller, pDispNode)->SetRTLScroller(TRUE);
        }
        else
            Assert(!dni.IsRTLScroller()); // we won't want left scrollbar if it ain't scroller

        // We will later set the correct values, now just lets set empty so that the flags get setup correctly
        // in the display tree.
        if (dni.HasUserClip())
            pDispNode->SetUserClip(g_Zero.rc);
        else if (dni.HasExpandedClip())
        {
            CRect erc(CRect::CRECT_EMPTY);
            pDispNode->SetExpandedClipRect(erc);
        }
        
        // since this is a new node, mark the layout as not having not been SetPosition'ed
        _fPositionSet = FALSE;

        //
        //  Mark the node as owned and possibly filtered
        //

        pDispNode->SetOwned();

        //
        //  Anchor the display node
        //  (If a display node previously existed, the new node must take its place in the tree.
        //   Otherwise, just save the pointer.)
        //

        if (pDispNodeElement)
        {
            if (fCloneDispNode)
            {
                Assert(pci->GetLayoutContext());
                AddDispNodeToArray(pDispNode);
            }
            else
            {
                TraceTagEx((tagCalcSizeDetail, TAG_NONAME, " Replacing old DN: 0x%x", pDispNodeElement ));

                CDispNode *pdn =  *ppDispNodeElement;
                Assert(pdn);
                Assert(pdn == pDispNodeElement);

                // if we're replacing a scroller with another scroller, copy the
                // scroll offset
                if (dni.IsScroller() && pDispNodeElement->IsScroller())
                {
                    CDispScroller* pOldScroller = DYNCAST(CDispScroller, pDispNodeElement);
                    CDispScroller* pNewScroller = DYNCAST(CDispScroller, pDispNode);
                    pNewScroller->CopyScrollOffset(pOldScroller);
                }

                DetachScrollbarController(pDispNodeElement);

                pDispNode->SetLayerTypeSame(pDispNodeElement);
                pDispNode->ReplaceNode(pDispNodeElement);

                if (pdn == pDispNodeElement)
                {
                    *ppDispNodeElement = pDispNode;
                }
            }
        }
        else
        {
            Assert(!*ppDispNodeElement);
            *ppDispNodeElement = pDispNode;
        }

        pDispNodeElement = pDispNode;

        hr = S_FALSE;
    }

    //
    //  The display node is the right type, but its borders may have changed
    //

    else if (pDispNodeElement->HasBorder())
    {
        CRect   rcBordersOld;
        CRect   rcBordersNew;

        pDispNodeElement->GetBorderWidths(&rcBordersOld);
        dni.GetBorderWidths(&rcBordersNew);

        if (rcBordersOld != rcBordersNew)
        {
            hr = S_FALSE;
        }
    }

    //
    //  Ensure a single content node if necessary
    //  NOTE: This routine never removes content nodes
    //

    if (    pDispNodeElement->IsContainer()
        &&  !dni.IsTag(ETAG_FRAMESET)
        &&  !dni.IsTag(ETAG_HTML)
        &&  !dni.IsTag(ETAG_TR))
    {
        CDispNode * pDispNodeCurrent;
        CDispClient * pDispClient = this;

        pDispNodeCurrent =
        pDispNodeContent = GetFirstContentDispNode();

        if (    !pDispNodeContent
            ||  fForce
            ||  fCloneDispNode
            ||  dni.HasContentOrigin() != pDispNodeContent->HasContentOrigin()
            ||  dni.HasExpandedClip()  != pDispNodeContent->HasExpandedClipRect()
           )
        {
            DWORD dwExtras = 0;
            CSize sizeMove(0,0);
            if (dni.HasContentOrigin())
                dwExtras |= DISPEX_CONTENTORIGIN;
            if (dni.HasExpandedClip())
                dwExtras |= DISPEX_USERCLIP;

            else if (pDispNodeCurrent && pDispNodeCurrent->HasContentOrigin())
            {
                // When replacing RTL node with LTR node, we want to
                // adjust it position according to RTL overflow
                // (usually that means up moving it to 0,0)
                // Note that the LTR->RTL case is handled by SizeRTLDispNode()
                sizeMove = pDispNodeCurrent->GetContentOrigin();
            }

            pDispNodeContent = CDispLeafNode::New(pDispClient, dwExtras);

            if (!pDispNodeContent)
                goto Error;

            TraceTagEx((tagCalcSizeDetail, TAG_NONAME, " Created content DN: 0x%x for container", pDispNodeContent ));

            pDispNodeContent->SetOwned(FALSE);
            pDispNodeContent->SetLayerFlow();

            if (dni.HasExpandedClip())
            {
                CRect erc(CRect::CRECT_EMPTY);
                pDispNodeContent->SetExpandedClipRect(erc);
            }
            
            Assert((CPoint &)pDispNodeContent->GetPosition() == (CPoint &)g_Zero.pt);

            if (    !pDispNodeCurrent
                ||  fCloneDispNode )
            {
                DYNCAST(CDispParentNode, pDispNodeElement)->InsertChildInFlow(pDispNodeContent);
            }
            else
            {
                Assert(!pDispNodeCurrent->IsDrawnExternally());
                pDispNodeContent->ReplaceNode(pDispNodeCurrent);
            }

            if (!sizeMove.IsZero())
            {
                pDispNodeContent->SetPosition(pDispNodeContent->GetPosition() + sizeMove);
            }

            Assert(pDispNodeElement->GetFirstFlowChildNode() == pDispNodeContent);

            hr = S_FALSE;
        }
    }

    //
    //  Set the display node properties
    //  NOTE: These changes do not require notifying the caller since they do not affect
    //        the size or position of the display node
    //

    EnsureDispNodeLayer(dni, pDispNodeElement);
    EnsureDispNodeBackground(dni, pDispNodeElement);
    EnsureDispNodeVisibility(dni.GetVisibility(), ElementOwner(), pDispNodeElement);

    EnsureDispNodeAffectsScrollBounds( (!ElementOwner()->IsRelative(LC_TO_FC(LayoutContext()))
                                                &&  !ElementOwner()->IsInheritingRelativeness(LC_TO_FC(LayoutContext())))
                                           ||  IsEditable(TRUE),
                                       pDispNodeElement);

    if (dni.IsScroller())
    {
        EnsureDispNodeScrollbars(pci, dni, pDispNodeElement);

        BOOL fClipX = dni._overflowX != styleOverflowVisible && dni._overflowX != styleOverflowNotSet;
        BOOL fClipY = dni._overflowY != styleOverflowVisible && dni._overflowY != styleOverflowNotSet;

        // FRAME, IFRAME, and BODY must clip
        if (dni._etag == ETAG_BODY
            ||  dni._etag == ETAG_FRAMESET
            ||  dni._etag == ETAG_FRAME
            ||  dni._etag == ETAG_IFRAME)
        {
            // NOTE: This code is trying to honor styleOverflowVisible on BODY, FRAME, etc.
            // It may be that we want these elements to clip *no matter what*.  If so,
            // just set fClipX/fClipY to TRUE unconditionally.
            if (dni._overflowX == styleOverflowNotSet)
                fClipX = TRUE;
            if (dni._overflowY == styleOverflowNotSet)
                fClipY = TRUE;
        }

        CDispScroller* pDispScroller = CDispScroller::Cast(pDispNodeElement);
        pDispScroller->SetClipX(fClipX);
        pDispScroller->SetClipY(fClipY);

        if (fWasRTLScroller && !dni.IsRTLScroller())
        {
            // direction change RTL->LTR: reset scrollbars
            // LTR->RTL is handled elsewhere (it is already a special case for everyone).
            pDispScroller->SetScrollOffset(CSize(0,0), FALSE);
        }

        pDispNodeElement->SetDisableScrollBits(dni._fDisableScrollBits);
    }

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CLayout::EnsureDispNode L(0x%x, %S) Force=%d", this, ElementOwner()->TagName(), fForce ));
    return hr;

Error:
    if (pDispNodeContent)
    {
        pDispNodeContent->Destroy();
    }

    if (pDispNodeElement)
    {
        pDispNodeElement->Destroy();
    }

    *ppDispNodeElement = NULL;

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CLayout::EnsureDispNode L(0x%x, %S) ERROR - FAILURE", this, ElementOwner()->TagName() ));
    return E_FAIL;
}


//+----------------------------------------------------------------------------
//
//  Member:     EnsureDispNodeLayer
//
//  Synopsis:   Set the layer type of the container display node
//
//              NOTE: If a filter node exists, it is given the same layer type
//
//  Arguments:  dni       - CDispNodeInfo with display node properties
//              pDispNode - Display node to set (defaults to layout display node)
//
//-----------------------------------------------------------------------------
void
CLayout::EnsureDispNodeLayer(
    DISPNODELAYER           layer,
    CDispNode *             pDispNode)
{
    if (!pDispNode)
        pDispNode = GetElementDispNode();

    if (    pDispNode
        &&  pDispNode->GetLayerType() != layer)
    {
        GetView()->ExtractDispNode(pDispNode);
        pDispNode->SetLayerType(layer);
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     EnsureDispNodeBackground
//
//  Synopsis:   Set the background characteristics of the container display node
//
//  Arguments:  dni       - CDispNodeInfo with display node properties
//              pDispNode - Display node to set (defaults to layout display node)
//
//-----------------------------------------------------------------------------
void
CLayout::EnsureDispNodeBackground(
    const CDispNodeInfo &   dni,
    CDispNode *             pDispNode)
{
    if (!pDispNode)
    {
        if (Tag() == ETAG_TABLE)
        {   // NOTE: table might have a caption, and we don't want to set background image on the main
            // display node of the table that contains the caption display node. (bug #65617)
            // therefore we ensure backround only on the table's GRID node.
            CTableLayoutBlock *pTableLayout = DYNCAST(CTableLayoutBlock, this);
            pDispNode = pTableLayout->GetTableOuterDispNode();
        }
        else
        {
            pDispNode = GetElementDispNode();
        }
    }

    if (pDispNode)
    {
        // Suppress backgrounds when printing unless explicitly asked for.
        BOOL fPaintBackground = dni.HasBackground()
                                && (ElementOwner()->GetMarkupPtr()->PaintBackground()
                                    || Tag() == ETAG_BUTTON
                                    ||  (    Tag() == ETAG_INPUT
                                         &&  (   DYNCAST(CInput, ElementOwner())->IsButton()
                                              || ElementOwner()->GetTheme( DYNCAST(CInput, ElementOwner())->GetInputThemeClsId() ))));

        // Fixed backgrounds imply backgrounds.
        Assert(!dni.HasFixedBackground() || dni.HasBackground());

        pDispNode->SetBackground(fPaintBackground);

        if (pDispNode->IsScroller())
        {
            pDispNode->SetFixedBackground(dni.HasFixedBackground() && fPaintBackground);
        }
        pDispNode->SetOpaque(dni.IsOpaque());
    }
}

//+----------------------------------------------------------------------------
//
// Synposis:    Given a dispnode container, create a child flow node if one
//              does not exist.
//
//-----------------------------------------------------------------------------
CDispNode *
EnsureContentNode(CDispNode * pDispNode)
{
    Assert(pDispNode->IsContainer());

    CDispContainer * pDispContainer = DYNCAST(CDispContainer, pDispNode);
    CDispNode      * pDispContent = pDispContainer->GetFirstFlowChildNode();

// NOTE: srinib (what if the first child node is not a flow node
// but a layout node in flow layer).
    if(!pDispContent)
    {
        CSize size = pDispContainer->GetSize();

        DWORD dwContentExtras = 0;
        if (pDispContainer->HasContentOrigin())
        {
            dwContentExtras |= DISPEX_CONTENTORIGIN;
        }

        pDispContent = CDispLeafNode::New(pDispContainer->GetDispClient(), dwContentExtras);

        if (!pDispContent)
            goto Error;

        pDispContent->SetOwned(FALSE);
        pDispContent->SetLayerFlow();
        pDispContent->SetSize(size, NULL, FALSE);
        if (!pDispNode->IsScroller())
        {
            pDispContent->SetAffectsScrollBounds(pDispNode->AffectsScrollBounds());
        }
        pDispContent->SetVisible(pDispContainer->IsVisible());

        // transfer content origin from the container
        if (pDispContainer->HasContentOrigin())
        {
            pDispContent->SetContentOrigin(pDispContainer->GetContentOrigin(),
                                           pDispContainer->GetContentOffsetRTL());

            // note that SetContentOrigin calculates origin based on size and right offset,
            // so we should us the content's oringin for position rather than cash container's
            // (even though they will probably be always same at this point).
            pDispContent->SetPosition(pDispContent->GetPosition() - pDispContent->GetContentOrigin());
        }

        pDispContainer->InsertChildInFlow(pDispContent);

        Assert(pDispContainer->GetFirstFlowChildNode() == pDispContent);
    }

Error:
    return pDispContent;
}

//+----------------------------------------------------------------------------
//
//  Member:     EnsureDispNodeIsContainer
//
//  Synopsis:   Ensure that the display node is a container display node
//              NOTE: This routine is not a replacement for EnsureDispNode and
//                    only works after calling EnsureDispNode.
//
//              For all layouts but FRAMESETs, if a container node is created, a
//              single CDispLeafNode will also be created and inserted as the
//              first child in the flow layer.
//
//  Returns:    Pointer to CDispContainer if successful, NULL otherwise
//
//-----------------------------------------------------------------------------
CDispContainer *
CLayout::EnsureDispNodeIsContainer( CElement *  pElement)
{
    Assert(   !pElement
           || pElement->GetUpdatedNearestLayout(LayoutContext()) == this);
    Assert( !pElement
        ||  pElement == ElementOwner()
        ||  !pElement->ShouldHaveLayout());

    CDispNode *         pDispNodeOld = GetElementDispNode(pElement);
    CDispContainer *    pDispNodeNew = NULL;
    CRect               rc;

    if (!pDispNodeOld)
        goto Cleanup;

    if (pDispNodeOld->IsContainer())
    {
        pDispNodeNew = CDispContainer::Cast(pDispNodeOld);
        goto Cleanup;
    }

    //
    //  Create a basic container using the properties of the current node as a guide
    //

    Assert(pDispNodeOld->IsLeafNode());
    Assert( (   pElement
            &&  pElement != ElementOwner())
        ||  !GetFirstContentDispNode());

    pDispNodeNew = CDispContainer::New(CDispLeafNode::Cast(pDispNodeOld));

    if (!pDispNodeNew)
        goto Cleanup;

    //
    //  Set the background flag on display nodes for relatively positioned text
    //  (Since text that has a background is difficult to detect, the code always
    //   assumes a background exists and lets the subsequent calls to draw the
    //   background handle it)
    //

    if (    pElement
        &&  pElement != ElementOwner())
    {
        Assert( !pElement->ShouldHaveLayout()
            &&  pElement->IsRelative());
        pDispNodeNew->SetBackground(TRUE);
    }

    //
    //  Replace the existing node
    //

    pDispNodeNew->ReplaceNode(pDispNodeOld);
    SetElementDispNode(pElement, pDispNodeNew );

    //
    //  Ensure a single flow node if necessary
    //

    if (ElementOwner()->Tag() != ETAG_FRAMESET)
    {
        if(!EnsureContentNode(pDispNodeNew))
            goto Cleanup;
    }

Cleanup:
    return pDispNodeNew;
}


//+----------------------------------------------------------------------------
//
//  Member:     EnsureDispNodeScrollbars
//
//  Synopsis:   Set the scroller properties of a display node
//              NOTE: The call is ignored if CDispNode is not a CDispScroller
//
//  Arguments:  sp        - CScrollbarProperties object
//              pDispNode - CDispNode to set (default to the layout display node)
//
//-----------------------------------------------------------------------------

void
CLayout::EnsureDispNodeScrollbars(
    CDocInfo *                      pdci,
    const CScrollbarProperties &    sp,
    CDispNode *                     pDispNode)
{
    if (!pDispNode)
        pDispNode = GetElementDispNode();

    if (    pDispNode
        &&  pDispNode->IsScroller())
    {
        Assert(!sp._fHSBForced || sp._fHSBAllowed);
        Assert(!sp._fVSBForced || sp._fVSBAllowed);

        long cySB = pdci->DeviceFromHimetricY(sp._fHSBAllowed ? g_sizelScrollbar.cy : 0);
        long cxSB = pdci->DeviceFromHimetricX(sp._fVSBAllowed ? g_sizelScrollbar.cx : 0);

        DYNCAST(CDispScroller, pDispNode)->SetHorizontalScrollbarHeight(cySB, sp._fHSBForced);
        DYNCAST(CDispScroller, pDispNode)->SetVerticalScrollbarWidth(cxSB, sp._fVSBForced);
    }

#if DBG==1
    else if (pDispNode)
    {
        Assert(!sp._fHSBAllowed);
        Assert(!sp._fVSBAllowed);
        Assert(!sp._fHSBForced);
        Assert(!sp._fVSBForced);
    }
#endif
}


//+----------------------------------------------------------------------------
//
//  Member:     EnsureDispNodeVisibility
//
//  Synopsis:   Set the visibility mode on display node corresponding to
//              this layout
//
//              NOTE: If a filter node exists, it is given the same visibility mode
//
//  Arguments:  dni       - CDispNodeInfo with display node properties
//              pDispNode - Display node to set (defaults to layout display node)
//
//-----------------------------------------------------------------------------
void
CLayout::EnsureDispNodeVisibility(CElement *pElement, CDispNode * pDispNode)
{
    if (!pElement)
        pElement = ElementOwner();

    if (pElement && pElement->GetFirstBranch())
    {
        VISIBILITYMODE vm;

        vm = VisibilityModeFromStyle(pElement->GetFirstBranch()->GetCascadedvisibility(LC_TO_FC(LayoutContext())));

        EnsureDispNodeVisibility( vm, pElement, pDispNode);
    }
}



void
CLayout::EnsureDispNodeVisibility(
    VISIBILITYMODE  visibilityMode,
    CElement *      pElement,
    CDispNode *     pDispNode)
{
    Assert(pElement);

    if (!pDispNode)
        pDispNode = GetElementDispNode(pElement);

    if (pDispNode)
    {
        CTreeNode*  pNode = pElement->GetFirstBranch();

        Verify(OpenView());

        if (visibilityMode == VISIBILITYMODE_INHERIT)
        {
            visibilityMode = pNode->GetCharFormat(LC_TO_FC(LayoutContext()))->_fVisibilityHidden
                                    ? VISIBILITYMODE_INVISIBLE
                                    : VISIBILITYMODE_VISIBLE;
        }

        if ( (visibilityMode == VISIBILITYMODE_INVISIBLE) &&
             (pNode->IsParentEditable() && !pElement->GetMarkup()->IsRespectVisibilityInDesign() ) )
        {
            visibilityMode = VISIBILITYMODE_VISIBLE;
        }

        Assert(visibilityMode != VISIBILITYMODE_INHERIT);
        pDispNode->SetVisible(visibilityMode == VISIBILITYMODE_VISIBLE);

        EnsureContentVisibility(pDispNode, visibilityMode == VISIBILITYMODE_VISIBLE);
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     EnsureContentVisibility
//
//  Synopsis:   Ensure the visibility of the content node is correct
//
//  Arguments:  pDispNode - Parent CDispNode of the content node
//              fVisible  - TRUE to make visible, FALSE otherwise
//
//-----------------------------------------------------------------------------

void
CLayout::EnsureContentVisibility(
    CDispNode * pDispNode,
    BOOL        fVisible)
{
    CDispNode * pContentNode = GetFirstContentDispNode(pDispNode);

    if (pContentNode)
    {
        pContentNode->SetVisible(fVisible);
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     EnsureDispNodeAffectsScrollBounds
//
//  Synopsis:   Ensure the "affects scroll bounds" flag of the disp node is correct
//
//  Arguments:  pDispNode - Parent CDispNode of the content node
//              fVisible  - TRUE to make visible, FALSE otherwise
//
//-----------------------------------------------------------------------------

void
CLayout::EnsureDispNodeAffectsScrollBounds(
    BOOL        fAffectsScrollBounds,
    CDispNode * pDispNode)
{
    CDispNode * pContentNode = GetFirstContentDispNode(pDispNode);

    pDispNode->SetAffectsScrollBounds(fAffectsScrollBounds);

    if (pContentNode)
    {
        pContentNode->SetAffectsScrollBounds(
                            pDispNode->IsScroller() ? TRUE : fAffectsScrollBounds);
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     ExtractDispNodes
//
//  Synopsis:   Remove all children in the range from the tree
//
//  Arguments:  pDispNodeStart   - First node to adjust, NULL starts with first child
//              pDispNodeEnd     - Last node to adjust, NULL ends with last child
//              fRestrictToLayer - Restrict search to starting layer (ignore if pDispNodeStart is NULL)
//
//-----------------------------------------------------------------------------

void
CLayout::ExtractDispNodes(
    CDispNode * pDispNodeStart,
    CDispNode * pDispNodeEnd,
    BOOL        fRestrictToLayer)
{
    CDispNode * pDispNode = GetElementDispNode();

    //
    //  If there is nothing to do, exit
    //

    if (!pDispNode)
        goto Cleanup;

    if (!pDispNode->IsContainer())
        goto Cleanup;

    //
    //  Determine the start node (if none was supplied)
    //

    if (!pDispNodeStart)
    {
        pDispNodeStart   = pDispNode->GetFirstChildNode();
        fRestrictToLayer = FALSE;
    }

    if (!pDispNodeStart)
        goto Cleanup;

    //
    //  Find the end node (if none was supplied)
    //

    if (!pDispNodeEnd)
    {
        if (!fRestrictToLayer)
        {
            pDispNodeEnd = pDispNode->GetLastChildNode();
        }
        else
        {
            pDispNodeEnd = pDispNodeStart->GetLastInSameLayer();
        }
    }
    Assert(pDispNodeEnd);

    //
    //  Extract the nodes
    //

    GetView()->ExtractDispNodes(pDispNodeStart, pDispNodeEnd);

Cleanup:
    return;
}


//+----------------------------------------------------------------------------
//
//  Member:     SetPositionAware
//
//  Synopsis:   Set/clear the position aware flag on the display node
//
//              NOTE: If a filter node exists, it is given the same position awareness
//
//  Arguments:  fPositionAware - Value to set
//              pDispNode      - Display node to set (defaults to layout display node)
//
//-----------------------------------------------------------------------------
void
CLayout::SetPositionAware(
    BOOL        fPositionAware,
    CDispNode * pDispNode)
{
    if (!pDispNode)
        pDispNode = GetElementDispNode();

    pDispNode->SetPositionAware(fPositionAware);
}


//+----------------------------------------------------------------------------
//
//  Member:     SetInsertionAware
//
//  Synopsis:   Set/clear the insertion aware flag on the display node
//
//              NOTE: If a filter node exists, it is given the same position awareness
//
//  Arguments:  fInsertionAware - Value to set
//              pDispNode       - Display node to set (defaults to layout display node)
//
//-----------------------------------------------------------------------------
void
CLayout::SetInsertionAware(
    BOOL        fInsertionAware,
    CDispNode * pDispNode)
{
    if (!pDispNode)
        pDispNode = GetElementDispNode();

    pDispNode->SetInsertionAware(fInsertionAware);
}


//+----------------------------------------------------------------------------
//
//  Member:     SizeDispNode
//
//  Synopsis:   Adjust the size of the container display node
//
//  Arugments:  pci            - Current CCalcInfo
//              size           - The width/height of the entire layout
//              fInvalidateAll - If TRUE, force a full invalidation
//
//-----------------------------------------------------------------------------
void
CLayout::SizeDispNode(
    CCalcInfo *     pci,
    const SIZE &    size,
    BOOL            fInvalidateAll)
{
    CDoc *          pDoc                = NULL;
    CElement *      pElement            = NULL;
    CDispNode *     pDispNodeElement    = NULL;
    CRect *         prcpMapped          = NULL;
    CRect           rcpMapped;
    CSize           sizeOriginal;
    ELEMENT_TAG     etag;
    DISPNODEBORDER  dnb;
    CBorderInfo     bi;

    Assert(pci);

    if (!_pDispNode)
        goto Cleanup;

    pDispNodeElement = GetElementDispNode();

    //
    //  Set the border size (if any)
    //  NOTE: These are set before the size because a change in border widths
    //        forces a full invalidation of the display node. If a full
    //        invalidation is necessary, less code is executed when the
    //        display node's size is set.
    //

    pDoc           = Doc();
    pElement       = ElementOwner();
    etag           = pElement->Tag();
    dnb            = pDispNodeElement->GetBorderType();
    fInvalidateAll = !pDispNodeElement->IsContainer();

    sizeOriginal = pDispNodeElement->GetSize();

    if (dnb != DISPNODEBORDER_NONE)
    {
        CRect       rcBorderWidths;
        CRect       rc;

        pDispNodeElement->GetBorderWidths(&rcBorderWidths);

        pElement->GetBorderInfo(pci, &bi, FALSE, FALSE FCCOMMA LC_TO_FC(LayoutContext()));

        rc.left   = bi.aiWidths[SIDE_LEFT];
        rc.top    = bi.aiWidths[SIDE_TOP];
        rc.right  = bi.aiWidths[SIDE_RIGHT];
        rc.bottom = bi.aiWidths[SIDE_BOTTOM];

        if (rc != rcBorderWidths)
        {
            if (dnb == DISPNODEBORDER_SIMPLE)
            {
                pDispNodeElement->SetBorderWidths(rc.top);
            }
            else
            {
                pDispNodeElement->SetBorderWidths(rc);
            }

            fInvalidateAll = TRUE;
        }
    }

    //
    //  If there are any behaviors that want to map the size, find out the details
    //  now so we can tell the disp node.
    //

    if (DelegateMapSize(size, &rcpMapped, pci))
    {
        prcpMapped = &rcpMapped;
    }

    //
    //  Determine if a full invalidation is necessary
    //  (A full invalidation is necessary only when there is a fixed
    //   background located at a percentage of the width/height)
    //

    if (    !fInvalidateAll
        &&  pDispNodeElement->HasBackground())
    {
        const CFancyFormat *    pFF = pElement->GetFirstBranch()->GetFancyFormat(LC_TO_FC(LayoutContext()));

        // Logical/physical does not matter since we check both X and Y here.
        fInvalidateAll =    pFF->_lImgCtxCookie
                    &&  (   pFF->GetBgPosX().GetUnitType() == CUnitValue::UNIT_PERCENT
                        ||  pFF->GetBgPosY().GetUnitType() == CUnitValue::UNIT_PERCENT);
    }

    //
    //  Size the display node
    //  NOTE: Set only the width/height since top/left are managed
    //        by the layout engine which inserts this node into the
    //        display tree.
    //

    pDispNodeElement->SetSize(size, prcpMapped, fInvalidateAll);

    // Note: we are not dealing with HasContentOrigin here because it is handled
    // in CFlowLayout/CHtmlLayout, the only layouts using a content origin.

    Assert(     IsFlowLayout()
            ||  ElementOwner()->Tag() == ETAG_HTML
            ||  !pDispNodeElement->HasContentOrigin() );

    //
    //  If the display node has an explicit user transformation, set details
    //

    if (pDispNodeElement->HasUserTransform())
    {
        // _rctBounds is updated as part of user transform calculations
        SizeDispNodeUserTransform(pci, size, pDispNodeElement);
    }

    //
    //  If the display node has an explicit user clip, size it
    //

    if (pDispNodeElement->HasUserClip())
    {
        SizeDispNodeUserClip(pci, size, pDispNodeElement);
    }


    //  Any borders that have spacing dependant on their length need to be invalidated here.
    //  Currently, only marker edges (dotted/dashed) are dependant on their length (for spacing).
    //  e.g.  If the element increases in width, the top and bottom borders need to be invalidated.
    //  Use COORDSYS_BOX because it includes borders & scrollbars.

    if (    !fInvalidateAll
        &&  dnb != DISPNODEBORDER_NONE )
    {
        if (sizeOriginal.cx != size.cx)
        {
            if  ( bi.IsMarkerEdge(SIDE_TOP) )
                Invalidate(CRect(0, 0, size.cx, bi.aiWidths[SIDE_TOP]), COORDSYS_BOX);
            if  ( bi.IsMarkerEdge(SIDE_BOTTOM) )
                Invalidate(CRect(0, size.cy - bi.aiWidths[SIDE_BOTTOM], size.cx, size.cy), COORDSYS_BOX);
        }

        if (sizeOriginal.cy != size.cy)
        {
            if  ( bi.IsMarkerEdge(SIDE_LEFT) )
                Invalidate(CRect(0, 0, bi.aiWidths[SIDE_LEFT], size.cy), COORDSYS_BOX);
            if  ( bi.IsMarkerEdge(SIDE_RIGHT) )
                Invalidate(CRect(size.cx - bi.aiWidths[SIDE_RIGHT], 0, size.cx, size.cy), COORDSYS_BOX);
        }
    }

    //
    //  Fire related events
    //

    if (    (CSize &)size != sizeOriginal
        &&  !IsDisplayNone()
        &&  pDoc->_state >= OS_INPLACE
        &&  pElement->GetWindowedMarkupContext()->HasWindow()
        &&  pElement->GetWindowedMarkupContext()->Window()->_fFiredOnLoad)
    {
        bool skipAddEvent =
            pElement->HasLayoutAry() &&
            HasLayoutContext() &&
            LayoutContext()->GetMedia() == mediaTypePrint;
        if (!skipAddEvent)
            GetView()->AddEventTask(pElement, DISPID_EVMETH_ONRESIZE);
    }

    // TODO (IE6 Bug 13574) (michaelw) should the code below be moved to happen at the
    //                   same time as the above onresize?

    if (pElement->ShouldFireEvents())
    {
        if (size.cx != sizeOriginal.cx)
        {
            pElement->FireOnChanged(DISPID_IHTMLELEMENT_OFFSETWIDTH);
            pElement->FireOnChanged(DISPID_IHTMLELEMENT2_CLIENTWIDTH);
        }

        if (size.cy != sizeOriginal.cy)
        {
            pElement->FireOnChanged(DISPID_IHTMLELEMENT_OFFSETHEIGHT);
            pElement->FireOnChanged(DISPID_IHTMLELEMENT2_CLIENTHEIGHT);
        }
    }

Cleanup:

    return;
}


//+----------------------------------------------------------------------------
//
//  Member:     DelegateMapSize (helper)
//
//  Synopsis:   Collect information from peers that want to map the size
//
//  Arguments:  sizeBasic       [in] original size
//              prcpMapped      [out] accumulated mapped size
//
//  Returns:    TRUE            if one or more peers request a non-trivial mapping
//              FALSE           otherwise
//
//-----------------------------------------------------------------------------
BOOL
CLayout::DelegateMapSize(CSize                      sizeBasic, 
                         CRect *                    prcpMapped, 
                         const CCalcInfo * const    pci)
{
    CPeerHolder::CPeerHolderIterator    iter;
    BOOL                                fMappingRequested   = FALSE;
    bool                                fFilterPrint        = false;
    bool                                fFilterHighRes      = false;
    CElement *                          pElemOwner          = ElementOwner();
    CRect                               rcpMappedThis       = g_Zero.rc; // keep compiler happy
    CRect                               rcOriginal(sizeBasic);

    Assert(prcpMapped != NULL);
    Assert(pci != NULL);

    // 2001/03/28 mcalkins:
    // Instead of HasFilterPeer, we really want to know if this element has a 
    // peer that has request to draw onto a DirectDraw surface.

    if (HasFilterPeer(GetElementDispNode()))
    {
        // If we're a filter and we're printing, set the fFilterPrint flag.
        // If we're a filter and we're rendering to a high resolution display,
        // set the fFilterHighRes flag.
        
        // Checking to see if the mediaTypePrint flag is set is the definitive way
        // to see if we're measuring in high resolution.  IsPrintMedia() is not.

        if (   const_cast<CCalcInfo *>(pci)->GetLayoutContext()
            && (const_cast<CCalcInfo *>(pci)->GetLayoutContext() != GUL_USEFIRSTLAYOUT)
            && (const_cast<CCalcInfo *>(pci)->GetLayoutContext()->GetMedia() & mediaTypePrint))
        {
            fFilterPrint = true;
        }
        else if (g_uiDisplay.IsDeviceScaling())
        {
            fFilterHighRes = true;
        }
    }

    // If we're printing or print previewing and this element is filtered we
    // need to convert the size to display coordinates, ask the filter if it
    // wants to change the size, and if it does then convert the size back to
    // virtual coordinates and save them.  

    if (fFilterPrint)
    {
        pci->TargetFromDevice(sizeBasic, g_uiDisplay);

        rcOriginal.SetSize(sizeBasic);
    }
    else if (fFilterHighRes)
    {
        g_uiDisplay.DocPixelsFromDevice(sizeBasic, sizeBasic);

        rcOriginal.SetSize(sizeBasic);
    }

    // Loop through peers holders to map size.

    for (iter.Start(pElemOwner->GetPeerHolder());
         !iter.IsEnd();
         iter.Step())
    {
        if (   iter.PH()->IsLayoutPeer()
            && iter.PH()->TestLayoutFlags(BEHAVIORLAYOUTINFO_MAPSIZE))
        {
            // If the call to MapSize succeeds and the mapped rect is different
            // than the original rect then save the new mapped rect.

            if (   (S_OK == iter.PH()->MapSize(&sizeBasic, &rcpMappedThis)) 
                     && (rcpMappedThis != rcOriginal))
            {
                // If we did a coordinate system change for a filter, we need to
                // undo it to save the mapped size in virtual coordinates.

                if (fFilterPrint || fFilterHighRes)
                {
                    Assert((0 == rcpMappedThis.top) && (0 == rcpMappedThis.left));

                    CSize sizeTemp = rcpMappedThis.Size();

                    if (fFilterPrint)
                    {
                        g_uiDisplay.TargetFromDevice(sizeTemp, *(pci->GetUnitInfo()));
                    }
                    else
                    {
                        g_uiDisplay.DeviceFromDocPixels(sizeTemp, sizeTemp);
                    }

                    rcpMappedThis.SetSize(sizeTemp);
                }

                // Save the mapped size.

                if (!fMappingRequested)
                {
                    fMappingRequested   = TRUE;
                    *prcpMapped         = rcpMappedThis;
                }
                else
                {
                    prcpMapped->Union(rcpMappedThis);
                }
            }
        }
    }

    // for top-level layouts, don't use the information.  [We still have to
    // call MapSize, so that filters get initialized properly.]

    if (   (pElemOwner->Tag() == ETAG_BODY)
        || (pElemOwner->Tag() == ETAG_FRAMESET)
        || (pElemOwner->Tag() == ETAG_HTML && GetOwnerMarkup()->IsHtmlLayout()))
    {
        fMappingRequested = FALSE;
    }

    return fMappingRequested;
}


//+----------------------------------------------------------------------------
//
//  Member:     HasMapSizePeer (helper)
//
//  Synopsis:   Do I have a peer that asks for MapSize calls?
//
//  Arguments:  none
//
//  Returns:    TRUE            if yes
//              FALSE           otherwise
//
//-----------------------------------------------------------------------------
BOOL
CLayout::HasMapSizePeer() const
{
    CPeerHolder::CPeerHolderIterator iter;

    for (iter.Start(ElementOwner()->GetPeerHolder());
         !iter.IsEnd();
         iter.Step())
    {
        if (   iter.PH()->IsLayoutPeer()
            && iter.PH()->TestLayoutFlags(BEHAVIORLAYOUTINFO_MAPSIZE))
        {
            return TRUE;
        }
    }

    return FALSE;
}


//+----------------------------------------------------------------------------
//
//  Member:     OnResize
//
//  Synopsis:   Informs behaviors of size changes
//
//-----------------------------------------------------------------------------
void CLayout::OnResize(SIZE size, CDispNode *pDispNode)
{
    // If the notification doesn't come from my principal disp node, fuhgeddaboudit.
    // (This is probably what Artak was talking about in the next comment.
    if (GetElementDispNode() != pDispNode)
        return;

    // If the layout is on a frame inside a frameset I am seeing
    // two calls to this function, one with the right size and the
    // with he size of the whole window, still on the same layout
    // It does not matter for page transition, because the filter
    // behaviors ignores the onResize, but could be a problem for other things
    CElement * pElem = ElementOwner();
    if (pElem->HasPeerHolder())
    {
        CPeerHolder::CPeerHolderIterator iter;

        for (iter.Start(pElem->GetPeerHolder()) ; !iter.IsEnd(); iter.Step())
        {
            CPeerHolder *pPH = iter.PH();
            if (pPH && pPH->IsRenderPeer())
            {
                pPH->OnResize(size);
            }
        }
    }

    if (pElem->Tag() != ETAG_BODY && pElem->Tag() != ETAG_FRAMESET && pElem->Tag() != ETAG_HTML)
        return;

    // block to grab the document
    {
        CDocument *pDocument = pElem->GetMarkupPtr()->Document();
        if(!pDocument || !pDocument->HasPageTransitions())
            return;

        // Page transition peers have to be redirected
        CPageTransitionInfo * pPgTransInfo = pDocument->GetPageTransitionInfo();
        pElem = pPgTransInfo->GetTransitionToMarkup()->Root();
    }

    Assert(pElem->HasPeerHolder());
    CPeerHolder::CPeerHolderIterator iter;

    for (iter.Start(pElem->GetPeerHolder()) ; !iter.IsEnd(); iter.Step())
    {
        CPeerHolder *pPH = iter.PH();

        if (pPH  && pPH->IsRenderPeer() )
        {
            pPH->OnResize(size);
        }
    }

}


//+----------------------------------------------------------------------------
//
//  Member:     SizeDispNodeInsets
//
//  Synopsis:   Size the insets of the display node
//
//  Arguments:  va        - CSS verticalAlign value
//              cy        - Content height or baseline delta
//              pDispNode - CDispNode to set (defaults to the layout display node)
//
//-----------------------------------------------------------------------------
void
CLayout::SizeDispNodeInsets(
    styleVerticalAlign  va,
    long                cy,
    CDispNode *         pDispNode)
{
    if (!pDispNode)
        pDispNode = GetElementDispNode();

    if (    pDispNode
        &&  pDispNode->HasInset())
    {
        CSize sizeInset;
        long  cyHeight  = pDispNode->GetSize().cy;

        Assert(  (va == styleVerticalAlignBaseline || cy >= 0)
               || (va ==styleVerticalAlignMiddle && cy != 0));
        
        // NOTE: Assert removed for NT5 B3 (bug #75434)
        // IE6: Reenable for IE6+
        // AND DISABLE FOR NETDOCS!
        // Assert(cy <= cyHeight);

        switch (va)
        {
        case styleVerticalAlignTop:
            sizeInset = g_Zero.size;
            break;

        case styleVerticalAlignMiddle:
            sizeInset.cx = 0;
            sizeInset.cy = (cyHeight - cy) / 2;
            break;

        case styleVerticalAlignBottom:
            sizeInset.cx = 0;
            sizeInset.cy = cyHeight - cy;
            break;

        case styleVerticalAlignBaseline:
            sizeInset.cx = 0;
            sizeInset.cy = cy;
            break;
        }

        pDispNode->SetInset(sizeInset);
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     SizeDispNodeUserClip
//
//  Synopsis:   Calculate and set the user clip based on user settings
//              The default is infinite (represented by LONG_MIN/MAX) and all values
//              are relative to the origin (0,0)
//
//  Arguments:  pdci      - Current CDocInfo
//              size      - Current width/height
//              pDispNode - Display node on which to set the user clip (defaults to the layout display node)
//
//-----------------------------------------------------------------------------
void
CLayout::SizeDispNodeUserClip(
    const CDocInfo *pdci,
    const CSize &   size,
    CDispNode *     pDispNode)
{
    CElement *  pElement  = ElementOwner();
    BOOL        fVerticalLayoutFlow = pElement->HasVerticalLayoutFlow();
    CTreeNode * pTreeNode = pElement->GetFirstBranch();
    const CFancyFormat *pFF = pTreeNode->GetFancyFormat();
    BOOL        fWritingModeUsed = pTreeNode->GetCharFormat()->_fWritingModeUsed;
    CRect       rc;
    CUnitValue  uv;

    if (!pDispNode)
        pDispNode = GetElementDispNode();

    if (!pDispNode)
        goto Cleanup;

    Assert(pdci);
    Assert(pTreeNode);
    Assert(pDispNode->HasUserClip());

    rc.SetRect(LONG_MIN, LONG_MIN, LONG_MAX, LONG_MAX);

    uv = pFF->GetLogicalClip(SIDE_LEFT, fVerticalLayoutFlow, fWritingModeUsed);
    if (    !uv.IsNull()
        &&  (   CUnitValue::IsScalerUnit(uv.GetUnitType())
            ||  uv.GetUnitType() == CUnitValue::UNIT_PERCENT))
    {
        rc.left = uv.XGetPixelValue(pdci, size.cx, pTreeNode->GetFontHeightInTwips(&uv));
    }

    uv = pFF->GetLogicalClip(SIDE_RIGHT, fVerticalLayoutFlow, fWritingModeUsed);
    if (    !uv.IsNull()
        &&  (   CUnitValue::IsScalerUnit(uv.GetUnitType())
            ||  uv.GetUnitType() == CUnitValue::UNIT_PERCENT))
    {
        rc.right = uv.XGetPixelValue(pdci, size.cx, pTreeNode->GetFontHeightInTwips(&uv));
    }

    uv = pFF->GetLogicalClip(SIDE_TOP, fVerticalLayoutFlow, fWritingModeUsed);
    if (    !uv.IsNull()
        &&  (   CUnitValue::IsScalerUnit(uv.GetUnitType())
            ||  uv.GetUnitType() == CUnitValue::UNIT_PERCENT))
    {
        rc.top = uv.XGetPixelValue(pdci, size.cy, pTreeNode->GetFontHeightInTwips(&uv));
        if (fVerticalLayoutFlow)
        {
            CSize sz = pDispNode->GetSize();
            rc.top = sz.cy - rc.top;
        }
    }

    uv = pFF->GetLogicalClip(SIDE_BOTTOM, fVerticalLayoutFlow, fWritingModeUsed);
    if (    !uv.IsNull()
        &&  (   CUnitValue::IsScalerUnit(uv.GetUnitType())
            ||  uv.GetUnitType() == CUnitValue::UNIT_PERCENT))
    {
        rc.bottom = uv.XGetPixelValue(pdci, size.cy, pTreeNode->GetFontHeightInTwips(&uv));
        if (fVerticalLayoutFlow)
        {
            CSize sz = pDispNode->GetSize();
            rc.bottom = sz.cy - rc.bottom;
        }
    }

    pDispNode->SetUserClip(rc);

Cleanup:
    return;
}


//+----------------------------------------------------------------------------
//
//  Member:     SizeDispNodeUserTransform
//
//  Synopsis:   Calculate and set custom transformation if anything other than
//              offset needs to be applied to this node
//
//  Arguments:  pci       - Current CCalcInfo
//              sizep     - Current width/height (pre-transform)
//              pDispNode - Display node on which to set the stuff
//
//  Returns:    size of transformed bounds
//
//-----------------------------------------------------------------------------
void
CLayout::SizeDispNodeUserTransform(
    CCalcInfo *     pci,
    const CSize &   sizep,
    CDispNode *     pDispNode) const
{
    // Check that we don't do unnecessary work
    Assert(pDispNode->HasUserTransform());

    CDispTransform  transform;
    BOOL            fResolutionChange;
    CSize           sizetBound;
    CRect           rcp(sizep);

    // Get transform info, rotation center, if any, will be the center of rc.
    GetElementTransform(&rcp, &transform, &fResolutionChange);

    transform.GetWorldTransform()->GetBoundingSizeAfterTransform(&rcp, &sizetBound);

    // Update element size.
    pDispNode->SetUserTransform(&transform);

    // Set resolution if changing
    if (fResolutionChange)
    {
        CExtraTransform *pExtraTransform = pDispNode->GetExtraTransform();
        pExtraTransform->_fResolutionChange = TRUE;
        pExtraTransform->_pUnitInfo = pci->GetUnitInfo();
        
        // verify that the resolution in pci matches the defined resolution of this element
        Assert(DefinedLayoutContext());
        Assert(ElementOwner()->GetFirstBranch()->GetFancyFormat()->GetMediaReference() != mediaTypeNotSet);
        Assert(ElementOwner()->GetFirstBranch()->GetFancyFormat()->GetMediaReference() == DefinedLayoutContext()->GetMedia());
        Assert((CSize) pci->GetResolution() == GetView()->GetMeasuringDevice(DefinedLayoutContext()->GetMedia())->GetResolution());
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     SizeContentDispNode
//
//  Synopsis:   Adjust the size of the content node (if it exists)
//              NOTE: Unlike SizeDispNode above, this routine assumes that
//                    the passed size is correct and uses it unmodified
//
//  Arugments:  size           - The width/height of the content node
//              fInvalidateAll - If TRUE, force a full invalidation
//
//-----------------------------------------------------------------------------
void
CLayout::SizeContentDispNode(
    const SIZE &    size,
    BOOL            fInvalidateAll )
{
    CDispLeafNode * pDispContent;
    CSize           sizeContent;

    pDispContent = GetFirstContentDispNode();
    sizeContent  = size;

    if (pDispContent)
    {
        CDispNode * pDispElement;
        CSize       sizeOriginal;
        CRect       rc;

        Assert(GetView());
        
        pDispElement = GetElementDispNode();
        pDispElement->GetClientRect(&rc, CLIENTRECT_CONTENT);
        sizeOriginal = pDispContent->GetSize();

        //
        //  Ensure the passed size is correct
        //
        //    1) Scrolling containers always use the passed size
        //    2) Non-scrolling containers limit the size their client rectangle
        //    3) When editing psuedo-borders are enabled, ensure the size no less than the client rectangle
        //

        if (!pDispElement->IsScroller()
            // TODO RTL 112514: if we arbitrary resize an RTL node, its content gets totally messed up.
            //                 It is possible to do a combination of resize and positioning, 
            //                 but it looks like we manage to get away with just not doing this.
            //                 Somehow, this is called inconsistently on nodes with same exact properties
            //                 (e.g. table cells with overflow:hidden), so it looks like it is not really
            //                 required (or not needed for flow layout, which is fine, since only flow layout
            //                 can have a content origin (so far...).
            //                 If this code is really optional, why don't we nuke it?
            && !pDispContent->HasContentOrigin())
        {
            sizeContent = rc.Size();
        }

        if ( IsShowZeroBorderAtDesignTime() && IsEditable())
        {
            sizeContent.Max(rc.Size());
        }

        //
        //  If the size differs, set the new size
        //  (Invalidate the entire area for all changes to non-CFlowLayouts
        //   or anytime the width changes)
        //

        if (sizeOriginal != sizeContent)
        {
            fInvalidateAll =    fInvalidateAll
                            ||  !TestLayoutDescFlag(LAYOUTDESC_FLOWLAYOUT)
                            ||  sizeOriginal.cx != sizeContent.cx;

            pDispContent->SetSize(sizeContent, NULL, fInvalidateAll);
        }
        else if (fInvalidateAll)
        {
            pDispContent->Invalidate();
        }
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     TranslateDispNodes
//
//  Synopsis:   Adjust the position of a range of display nodes by the passed amount
//
//  Arguments:  size             - Amount by which to adjust
//              pDispNodeStart   - First node to adjust, NULL starts with first child
//              pDispNodeEnd     - Last node to adjust, NULL ends with last child
//              fRestrictToLayer - Restrict search to starting layer (ignore if pDispNodeStart is NULL)
//
//-----------------------------------------------------------------------------
void
CLayout::TranslateDispNodes(
    const SIZE &    size,
    CDispNode *     pDispNodeStart,
    CDispNode *     pDispNodeEnd,
    BOOL            fRestrictToLayer,
    BOOL            fExtractHidden)
{
    CDispNode * pDispNode = GetElementDispNode();

    //
    //  If there is nothing to do, exit
    //

    if (!pDispNode)
        goto Cleanup;

    if (    !pDispNode->IsContainer()
        ||  !DYNCAST(CDispContainer, pDispNode)->CountChildren())
        goto Cleanup;

    if (    !size.cx
        &&  !size.cy
        &&  !fExtractHidden)
        goto Cleanup;

    //
    //  Check for reasonable values
    //

    Assert(size.cx > (LONG_MIN / 2));
    Assert(size.cx < (LONG_MAX / 2));
    Assert(size.cy > (LONG_MIN / 2));
    Assert(size.cy < (LONG_MAX / 2));

    //
    //  Determine the start node (if none was supplied)
    //

    if (!pDispNodeStart)
    {
        pDispNodeStart   = pDispNode->GetFirstChildNode();
        if (!pDispNodeStart)
            goto Cleanup;
        fRestrictToLayer = FALSE;
    }

    //
    //  Translate the nodes
    //

    {
        pDispNode = pDispNodeStart;

        while (pDispNode)
        {
            CDispNode * pDispNodeCur = pDispNode;

            void *      pvOwner;
            CDispClient * pDispClient = this;

            pDispNode = fRestrictToLayer ? pDispNode->GetNextInSameLayer()
                                         : pDispNode->GetNextSiblingNode();

            //
            // if the current disp node is a text flow node or if the disp node
            // owner is not hidden then translate it or extract the disp node
            //
            if(pDispNodeCur->GetDispClient() == pDispClient)
            {
                pDispNodeCur->SetPosition(pDispNodeCur->GetPosition() + size);
            }
            else
            {
                pDispNodeCur->GetDispClient()->GetOwner(pDispNodeCur, &pvOwner);

                if (pvOwner)
                {
                    CElement *  pElement = DYNCAST(CElement, (CElement *)pvOwner);

                    if(fExtractHidden && pElement->IsDisplayNone())
                    {
                        GetView()->ExtractDispNode(pDispNodeCur);
                    }
                    else if (size.cx || size.cy)
                    {
                        if(pElement->ShouldHaveLayout())
                        {
                            pElement->GetUpdatedLayout()->SetPosition(pDispNodeCur->GetPosition() + size);
                        }
                        else
                        {
                            pDispNodeCur->SetPosition(pDispNodeCur->GetPosition() + size );
                        }
                   }
                }
            }

            if (pDispNodeCur == pDispNodeEnd)
                break;
        }
    }

Cleanup:
    return;
}


//+----------------------------------------------------------------------------
//
//  Member:     DestroyDispNode
//
//  Synopsis:   Disconnect/destroy all display nodes
//              NOTE: This only needs to destroy the container node since
//                    all other created nodes will be destroyed as a by-product.
//
//-----------------------------------------------------------------------------
void
CLayout::DestroyDispNode()
{
    if (_pDispNode)
    {
        DetachScrollbarController(_pDispNode);
        Verify(OpenView());
        _pDispNode->Destroy();
        _pDispNode = NULL;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     HandleScrollbarMessage
//
//  Synopsis:   Process a possible message for the scrollbar
//
//  Arguments:  pMessage - Message
//              pElement - Target element
//
//----------------------------------------------------------------------------
HRESULT
CLayout::HandleScrollbarMessage(
    CMessage *  pMessage,
    CElement *  pElement)
{
extern SIZE g_sizeScrollButton;

    CDispNode * pDispNode = GetElementDispNode();
    CDoc *      pDoc      = Doc();
    HRESULT     hr        = S_FALSE;

    if (    !pDispNode
        ||  !ElementOwner()->IsEnabled())
        return hr;

    Assert(pDispNode->IsScroller());

    switch (pMessage->message)
    {
    case WM_SETCURSOR:
        SetCursorIDC(IDC_ARROW);
        hr = S_OK;
        break;

    //
    //  Ignore up messages to simple fall-through
    //  ("Real" up messages are sent to the scrollbar directly
    //   since it captures the mouse on the cooresponding down message)
    //
    case WM_LBUTTONUP:
    case WM_MBUTTONUP:
    case WM_RBUTTONUP:
        break;

#ifndef UNIX
    case WM_MBUTTONDOWN:
#endif
    case WM_MBUTTONDBLCLK:
    case WM_RBUTTONDOWN:
    case WM_RBUTTONDBLCLK:
        break;

    case WM_LBUTTONDBLCLK:
        pDoc->_fGotDblClk = FALSE;

#ifdef UNIX
    case WM_MBUTTONDOWN:
#endif
    case WM_LBUTTONDOWN:
    case WM_CONTEXTMENU:
        AttachScrollbarController(pDispNode, pMessage);
        hr = S_OK;
        break;

    case WM_KEYDOWN:
        Assert(VK_PRIOR < VK_DOWN);
        Assert(VK_NEXT  > VK_PRIOR);
        Assert(VK_END   > VK_PRIOR);
        Assert(VK_HOME  > VK_PRIOR);
        Assert(VK_LEFT  > VK_PRIOR);
        Assert(VK_UP    > VK_PRIOR);
        Assert(VK_RIGHT > VK_PRIOR);

        if (    !(pMessage->dwKeyState & FALT)
            &&  pMessage->wParam >= VK_PRIOR
            &&  pMessage->wParam <= VK_DOWN)
        {
            UINT            uCode;
            long            cAmount;
            int             iDirection;
            CDispNodeInfo   dni;

            GetDispNodeInfo(&dni);

            uCode      = SB_THUMBPOSITION;
            cAmount    = 0;
            iDirection = 1;

            switch (pMessage->wParam)
            {
            case VK_END:
                cAmount = LONG_MAX;

            case VK_HOME:
                uCode = SB_THUMBPOSITION;
                break;

            case VK_NEXT:
                uCode = SB_PAGEDOWN;
                break;

            case VK_PRIOR:
                uCode = SB_PAGEUP;
                break;

            case VK_LEFT:
                iDirection = 0;
                // falling through

            case VK_UP:
                uCode = SB_LINEUP;
                break;

            case VK_RIGHT:
                iDirection = 0;
                // falling through

            case VK_DOWN:
                uCode = SB_LINEDOWN;
                break;
            }

            // Scroll only if scolling is allowed (IE5 #67686)
            if (    iDirection == 1 && dni.IsVScrollbarAllowed()
                ||  iDirection == 0 && dni.IsHScrollbarAllowed()
               )
            {
                hr = OnScroll(iDirection, uCode, cAmount, FALSE, (pMessage->wParam&0x4000000)
                                                                    ? 50  // TODO (IE6 bug 13575): For now we are using the mouse delay - should use Api to find system key repeat rate set in control panel.
                                                                    : MAX_SCROLLTIME);
            }
        }
        break;
    }

    return hr;
}


//+------------------------------------------------------------------------
//
//  Member:     OnScroll
//
//  Synopsis:   Compute scrolling info.
//
//  Arguments:  iDirection  0 - Horizontal scrolling, 1 - Vertical scrolling
//              uCode       scrollbar event code (SB_xxxx)
//              lPosition   new scroll position
//              fRepeat     TRUE if the previous scroll action is repeated
//              lScrollTime time in millisecs to scroll (smoothly)
//
//  Return:     HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CLayout::OnScroll(
    int     iDirection,
    UINT    uCode,
    long    lPosition,
    BOOL    fRepeat,
    LONG    lScrollTime)
{
extern WORD wConvScroll(WORD wparam);
extern SIZE g_sizeSystemChar;

    HRESULT hr = S_OK;

    //
    //  Ignore requests that arrive while the document is not in-place active
    //

    if (    Doc()->_state < OS_INPLACE
        &&  !Doc()->IsPrintDialogNoUI())
    {
        hr = OLE_E_INVALIDRECT;
    }

    //
    //  Scroll the appropriate direction
    //

    else
    {
        //
        //  Scroll the appropriate amount
        //

        switch (uCode)
        {
        case SB_LINEUP:
        case SB_LINEDOWN:
            if (iDirection)
            {
                ScrollByLine(CSize(0, (uCode == SB_LINEUP ? -1 : 1)), lScrollTime);
            }
            else
            {
                ScrollBy(CSize(uCode == SB_LINEUP ? -g_sizeSystemChar.cx : g_sizeSystemChar.cx, 0), lScrollTime);
            }
            break;

        case SB_PAGEUP:
        case SB_PAGEDOWN:
            {
                if (iDirection)
                {
                    ScrollByPage(CSize(0, (uCode == SB_PAGEUP ? -1 : 1)), lScrollTime);
                }
                else
                {
                    CRect   rc;
                    CSize   size;

                    GetClientRect(&rc);

                    size             = g_Zero.size;
                    size[iDirection] = (uCode == SB_PAGEUP ? -1 : 1) *
                                            max(1L,
                                            rc.Size(iDirection) - (((CSize &)g_sizeSystemChar)[iDirection] * 2L));

                    ScrollBy(size, lScrollTime);
                }
            }
            break;

        case SB_TOP:
            if (iDirection)
            {
                ScrollToY(-LONG_MAX);
            }
            else
            {
                ScrollToX(-LONG_MAX);
            }
            break;

        case SB_BOTTOM:
            if (iDirection)
            {
                ScrollToY(LONG_MAX);
            }
            else
            {
                ScrollToX(LONG_MAX);
            }
            break;

        case SB_THUMBPOSITION:
        case SB_THUMBTRACK:
            if (iDirection)
            {
                ScrollToY(lPosition);
            }
            else
            {
                ScrollToX(lPosition);
            }
            break;

        case SB_ENDSCROLL:
            break;
        }
    }

    return hr;
}

//+----------------------------------------------------------------------------
//
//  Member:     ScrollByLine
//
//  Synopsis:   Various scroll helpers
//
//  Arguments:  various size values (either percent or fixed amounts)
//
//-----------------------------------------------------------------------------
BOOL
CLayout::ScrollByLine(
    const CSize &   sizeDelta,
    LONG            lScrollTime)
{
    CDispNode * pDispNode   = GetElementDispNode();
    BOOL        fRet        = FALSE;
    CSize       sizeOffset;
    long        incY = -1;
    long        lUnitHeight;
    CDefaults * pDefaults   = ElementOwner()->GetDefaults();

    if (    !pDispNode
        ||  !pDispNode->IsScroller()
        ||  sizeDelta == g_Zero.size
        )
    {
        return fRet;
    }

    if (pDefaults)
    {
        incY = pDefaults->GetAAscrollSegmentY();
    }

    if (incY < 0)
    {
        Assert(abs(sizeDelta.cy) * 125 <= 1000);
        return ScrollByPercent(CSize(sizeDelta.cx, sizeDelta.cy * 125), lScrollTime);
    }
    else if (incY == 0 || incY == 1)
    {
        return fRet;
    }

    DYNCAST(CDispScroller, pDispNode)->GetScrollOffset(&sizeOffset);

    Assert(incY > 1);

    lUnitHeight    = GetContentHeight() / incY;

    sizeOffset.cy = sizeOffset.cy + sizeDelta.cy * lUnitHeight;
    sizeOffset.cx += sizeDelta.cx;

    return ScrollTo(sizeOffset, lScrollTime);
}

//+----------------------------------------------------------------------------
//
//  Member:     ScrollByPage
//
//  Synopsis:   Various scroll helpers
//
//  Arguments:  various size values (either percent or fixed amounts)
//
//-----------------------------------------------------------------------------
BOOL
CLayout::ScrollByPage(
    const CSize &   sizeDelta,
    LONG            lScrollTime)
{
    CDispNode * pDispNode   = GetElementDispNode();
    BOOL        fRet        = FALSE;
    CSize       sizeOffset;
    long        incY = -1;
    long        lUnitHeight;
    CRect       rc;
    CDefaults * pDefaults    = ElementOwner()->GetDefaults();

    Assert(abs(sizeDelta.cy) == 1);

    if (    !pDispNode
        ||  !pDispNode->IsScroller()
        ||  sizeDelta == g_Zero.size
        )
    {
        return fRet;
    }

    if (pDefaults)
    {
        incY = pDefaults->GetAAscrollSegmentY();
    }

    if (incY < 0)
    {
        return ScrollByPercent(CSize(sizeDelta.cx, sizeDelta.cy * 875), lScrollTime);
    }
    else if (incY == 0 || incY == 1)
    {
        return fRet;
    }

    DYNCAST(CDispScroller, pDispNode)->GetScrollOffset(&sizeOffset);

    Assert(incY > 1);

    lUnitHeight    = GetContentHeight() / incY;
    pDispNode->GetClientRect(&rc, CLIENTRECT_CONTENT);

    if (lUnitHeight == 0)
        return fRet;

    sizeOffset.cy = sizeOffset.cy + sizeDelta.cy * (rc.Height() - lUnitHeight);
    sizeOffset.cx += sizeDelta.cx;

    return ScrollTo(sizeOffset, lScrollTime);
}

//+----------------------------------------------------------------------------
//
//  Member:     ScrollBy
//              ScrollByPercent
//              ScrollTo
//              ScrollToX
//              ScrollToY
//
//  Synopsis:   Various scroll helpers
//
//  Arguments:  various size values (either percent or fixed amounts)
//
//-----------------------------------------------------------------------------
BOOL
CLayout::ScrollBy(
    const CSize &   sizeDelta,
    LONG            lScrollTime)
{
    CDispNode * pDispNode   = GetElementDispNode();
    BOOL        fRet        = FALSE;


    if (    pDispNode
        &&  pDispNode->IsScroller()
        &&  sizeDelta != g_Zero.size)
    {
        CSize   sizeOffset;
        long    incY = -1;

        if (sizeDelta.cy)
        {
            CDefaults *pDefaults = ElementOwner()->GetDefaults();
            if (pDefaults)
            {
                incY = pDefaults->GetAAscrollSegmentY();
            }

            if (incY == 0 || incY == 1)
            {
                return fRet;
            }
        }

        DYNCAST(CDispScroller, pDispNode)->GetScrollOffset(&sizeOffset);

        if (incY > 1)
        {
            long lDeltaY = sizeDelta.cy;
            long lUnitHeight = GetContentHeight() / incY;

            if (lUnitHeight == 0)
                return fRet;

            if (lDeltaY != 0)
            {
                lDeltaY = lDeltaY > 0 ? max(lDeltaY, lUnitHeight) + lUnitHeight/2 : min(lDeltaY, -lUnitHeight) - lUnitHeight/2;
                lDeltaY = (lDeltaY / lUnitHeight) * lUnitHeight;
            }
            sizeOffset.cx += sizeDelta.cx;
            sizeOffset.cy += lDeltaY;
        }
        else
        {
            sizeOffset += sizeDelta;
        }

        fRet = ScrollTo(sizeOffset, lScrollTime);
    }
    return fRet;
}


BOOL
CLayout::ScrollByPercent(
    const CSize &   sizePercent,
    LONG            lScrollTime)
{
    CDispNode * pDispNode   = GetElementDispNode();
    BOOL        fRet        = FALSE;

    if ( pDispNode &&
         pDispNode->IsScroller() &&
         sizePercent != g_Zero.size)
    {
        CRect   rc;
        CSize   sizeOffset;
        CSize   sizeDelta;
        long    incY = -1;

        pDispNode->GetClientRect(&rc, CLIENTRECT_CONTENT);

        sizeDelta.cy = (sizePercent.cy
                            ? (rc.Height() * sizePercent.cy) / 1000L
                            : 0);

        if (sizeDelta.cy)
        {
            CDefaults * pDefaults = ElementOwner()->GetDefaults();
            if (pDefaults)
            {
                incY = pDefaults->GetAAscrollSegmentY();
            }

            if (incY == 0 || incY == 1)
            {
                return fRet;
            }
        }

        DYNCAST(CDispScroller, pDispNode)->GetScrollOffset(&sizeOffset);

        sizeDelta.cx = (sizePercent.cx
                            ? (rc.Width() * sizePercent.cx) / 1000L
                            : 0);

        if (incY > 1)
        {
            long lUnitHeight    = GetContentHeight() / incY;

            if (lUnitHeight == 0)
                return fRet;

            if (sizeDelta.cy != 0)
            {
                sizeDelta.cy = sizeDelta.cy > 0
                                    ?   (max(sizeDelta.cy, lUnitHeight) + lUnitHeight/2)
                                    :   (min(sizeDelta.cy, -lUnitHeight) - lUnitHeight/2);
                sizeDelta.cy = (sizeDelta.cy / lUnitHeight) * lUnitHeight;
            }
        }
        else
        {
            sizeDelta.cy = (sizePercent.cy
                            ? (rc.Height() * sizePercent.cy) / 1000L
                            : 0);
        }

        sizeOffset += sizeDelta;

        fRet = ScrollTo(sizeOffset, lScrollTime);
    }
    return fRet;
}


BOOL
CLayout::ScrollTo(
    const CSize &   sizeOffset,
    LONG            lScrollTime)
{
    CDispNode * pDispNode   = GetElementDispNode();
    BOOL        fRet        = FALSE;

    if (pDispNode && pDispNode->IsScroller() && OpenView(FALSE, TRUE))
    {
        CView *     pView        = GetView();
        CElement *  pElement     = ElementOwner();
        BOOL        fLayoutDirty = pView->HasLayoutTask(this);
        BOOL        fScrollBits  = !fLayoutDirty && lScrollTime >= 0;
        CSize       sizeOffsetCurrent;
        CPaintCaret hc( pElement->Doc()->_pCaret ); // Hide the caret for scrolling

        //
        //  If layout is needed, perform it prior to the scroll
        //  (This ensures that container and content sizes are correct before
        //   adjusting the scroll offset)
        //

        if (fLayoutDirty)
        {
            DoLayout(pView->GetLayoutFlags() | LAYOUT_MEASURE);

            // Recompute pDispNode since it may have changed!
            pDispNode = GetElementDispNode();
            if (!pDispNode || !pDispNode->IsScroller())
                return fRet;
        }

        //
        // If the incoming offset has is different, scroll and fire the event
        //

        DYNCAST(CDispScroller, pDispNode)->GetScrollOffset(&sizeOffsetCurrent);

        if (sizeOffset != sizeOffsetCurrent)
        {
            AddRef();
            //
            //  Set the new scroll offset
            //  (If no layout work was pending, do an immediate scroll)
            //  NOTE: Setting the scroll offset will force a synchronous invalidate/render
            //

            fRet = pView->SmoothScroll(
                sizeOffset,
                this,
                fScrollBits,
                lScrollTime);

        //
            //  Ensure all deferred calls are executed
            //

            EndDeferred();

            Release();
        }
    }
    return fRet;
}


void
CLayout::ScrollToX(
    long    x,
    LONG    lScrollTime)
{
    CDispNode * pDispNode = GetElementDispNode();

    if (pDispNode && pDispNode->IsScroller())
    {
        CSize   sizeOffset;

        DYNCAST(CDispScroller, pDispNode)->GetScrollOffset(&sizeOffset);

        sizeOffset.cx = x;

        ScrollTo(sizeOffset, lScrollTime);
    }
}


void
CLayout::ScrollToY(
    long    y,
    LONG    lScrollTime)
{
    CDispNode * pDispNode = GetElementDispNode();

    if (pDispNode && pDispNode->IsScroller())
    {
        CSize   sizeOffset;
        long    incY = -1;
        CDefaults * pDefaults = ElementOwner()->GetDefaults();

        if (pDefaults)
        {
            incY = pDefaults->GetAAscrollSegmentY();
        }

        if (incY == 0 || incY == 1)
        {
            return;
        }

        DYNCAST(CDispScroller, pDispNode)->GetScrollOffset(&sizeOffset);

        if (incY > 1)
        {
            long lUnitHeight    = GetContentHeight() / incY;

            if (lUnitHeight == 0)
                return;

            y = y > 0   ?   (max(y,  lUnitHeight) + lUnitHeight/2)
                        :   (min(y, -lUnitHeight) - lUnitHeight/2);
            y = (y / lUnitHeight) * lUnitHeight;
        }

        sizeOffset.cy = y;

        ScrollTo(sizeOffset, lScrollTime);
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     GetXScroll
//              GetYScroll
//
//  Synopsis:   Helpers to retrieve scroll offsets
//
//-----------------------------------------------------------------------------
long
CLayout::GetXScroll() const
{
    CDispNode * pDispNode = GetElementDispNode();

    if (    pDispNode
        &&  pDispNode->IsScroller())
    {
        CSize   sizeOffset;

        DYNCAST(CDispScroller, pDispNode)->GetScrollOffset(&sizeOffset);
        return sizeOffset.cx;
    }
    else
        return 0;
}

long
CLayout::GetYScroll() const
{
    CDispNode * pDispNode = GetElementDispNode();

    if (    pDispNode
        &&  pDispNode->IsScroller())
    {
        CSize   sizeOffset;

        DYNCAST(CDispScroller, pDispNode)->GetScrollOffset(&sizeOffset);
        return sizeOffset.cy;
    }
    else
        return 0;
}


//+----------------------------------------------------------------------------
//
//  Member:     DoLayout
//
//  Synopsis:   Perform layout
//
//  Arguments:  grfLayout - Collection of LAYOUT_xxxx flags
//
//-----------------------------------------------------------------------------
void
CLayout::DoLayout(DWORD grfLayout)
{
    Assert(grfLayout & (LAYOUT_MEASURE | LAYOUT_POSITION | LAYOUT_ADORNERS));

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CLayout::DoLayout L(0x%x, %S) grfLayout(0x%x)", this, ElementOwner()->TagName(), grfLayout ));

    //
    //  If the element is not hidden, layout its content
    //

    if (!IsDisplayNone())
    {
        CCalcInfo   CI(this);
        CSize       size;

        GetSize(&size);

        CI._grfLayout |= grfLayout;

        //
        //  If requested, measure
        //

        if (grfLayout & LAYOUT_MEASURE)
        {
            if (_fForceLayout)
            {
                CI._grfLayout |= LAYOUT_FORCE;
            }

            CalcSize(&CI, &size);

            Reset(FALSE);
        }
        _fForceLayout = FALSE;

        //
        //  Process outstanding layout requests (e.g., sizing positioned elements, adding adorners)
        //

        if (HasRequestQueue())
        {
            ProcessRequests(&CI, size);
        }
    }

    //
    //  Otherwise, clear dirty state and dequeue the layout request
    //

    else
    {
        FlushRequests();
        Reset(TRUE);
    }

    Assert(!HasRequestQueue() || GetView()->HasLayoutTask(this));

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CLayout::DoLayout L(0x%x, %S) grfLayout(0x%x)", this, ElementOwner()->TagName(), grfLayout ));
}


//+----------------------------------------------------------------------------
//
//  Member:     Notify
//
//  Synopsis:   Respond to a notification
//
//  Arguments:  pnf - Notification sent
//
//-----------------------------------------------------------------------------
void
CLayout::Notify(
    CNotification * pnf)
{
    Assert(!pnf->IsReceived(_snLast));

    if (!TestLock(CElement::ELEMENTLOCK_SIZING))
    {
        // If the the current layout is hidden, then forward the current notification
        // to the parent as a resize notfication so that parents keep track of the dirty
        // range.
        if(    !pnf->IsFlagSet(NFLAGS_DESCENDENTS)
           &&  (   pnf->IsType(NTYPE_ELEMENT_REMEASURE)
                || pnf->IsType(NTYPE_ELEMENT_RESIZE)
                || pnf->IsType(NTYPE_ELEMENT_RESIZEANDREMEASURE)
                || pnf->IsType(NTYPE_CHARS_RESIZE))
           &&  IsDisplayNone())
        {
            pnf->ChangeTo(NTYPE_ELEMENT_RESIZE, ElementOwner());
        }
        else switch (pnf->Type())
        {
            case NTYPE_ELEMENT_RESIZE:
                if (!pnf->IsHandled())
                {
                    Assert(pnf->Element() != ElementOwner());

                    //  Always "dirty" the layout associated with the element
                    pnf->Element()->DirtyLayout(pnf->LayoutFlags());

                    //  Handle absolute elements by noting that one is dirty
                    if (pnf->Element()->IsAbsolute())
                    {
                        TraceTagEx((tagLayoutTasks, TAG_NONAME,
                                    "Layout Request: Queueing RF_MEASURE on ly=0x%x [e=0x%x,%S sn=%d] by CLayout::Notify() [n=%S srcelem=0x%x,%S]",
                                    this,
                                    _pElementOwner,
                                    _pElementOwner->TagName(),
                                    _pElementOwner->_nSerialNumber,
                                    pnf->Name(),
                                    pnf->Element(),
                                    pnf->Element() ? pnf->Element()->TagName() : _T("")));
                        QueueRequest(CRequest::RF_MEASURE, pnf->Element());

                        if (pnf->IsFlagSet(NFLAGS_ANCESTORS))
                        {
                            pnf->SetHandler(ElementOwner());
                        }
                    }
                }
                break;

            case NTYPE_ELEMENT_REMEASURE:
                pnf->ChangeTo(NTYPE_ELEMENT_RESIZE, ElementOwner());
                break;

            case NTYPE_CLEAR_DIRTY:
                SetSizeThis( FALSE );
                break;

            case NTYPE_TRANSLATED_RANGE:
                Assert(pnf->IsDataValid());
                HandleTranslatedRange(pnf->DataAsSize());
                break;

            case NTYPE_ZPARENT_CHANGE:
                if (!ElementOwner()->IsPositionStatic())
                {
                    ElementOwner()->ZChangeElement();
                }
                else if (_fContainsRelative)
                {
                    ZChangeRelDispNodes();
                }
                break;

            case NTYPE_DISPLAY_CHANGE :
            case NTYPE_VISIBILITY_CHANGE:
                HandleVisibleChange(pnf->IsType(NTYPE_VISIBILITY_CHANGE));
                break;

            case NTYPE_ZERO_GRAY_CHANGE:
                HandleZeroGrayChange( pnf );
                break;

            default:
                if (IsInvalidationNotification(pnf))
                {
                    Invalidate();

                    // We've now handled the notification, so set the handler
                    // (so we can know not to keep sending it if SENDUNTILHANDLED
                    // is true.
                    pnf->SetHandler(ElementOwner());
                }
                break;
        }
    }

#if DBG==1
    // Update _snLast unless this is a self-only notification. Self-only
    // notification are an anachronism and delivered immediately, thus
    // breaking the usual order of notifications.
    if (!pnf->SendToSelfOnly() && pnf->SerialNumber() != (DWORD)-1)
    {
        _snLast = pnf->SerialNumber();
    }
#endif
}


//+----------------------------------------------------------------------------
//
//  Member:     GetAutoPosition
//
//  Synopsis:   Get the auto position of a given layout for which, this is the
//              z-parent
//
//  Arguments:  pLayout - Layout to position
//              ppt     - Returned top/left (in parent content relative coordinates)
//
//-----------------------------------------------------------------------------
void
CLayout::GetAutoPosition(
    CElement  *  pElement,
    CElement  *  pElementZParent,
    CDispNode ** ppDNZParent,
    CLayout   *  pLayoutParent,
    CPoint    *  ppt,
    BOOL         fAutoValid)
{
    CElement  * pElementLParent = pLayoutParent->ElementOwner();
    CDispNode * pDispNodeParent;

    Assert(pLayoutParent);

    //
    // get the inflow position relative to the layout parent, if the pt
    // passed in is not valid.
    //
    if(!fAutoValid)
    {
        pLayoutParent->GetPositionInFlow(pElement, ppt);

        //
        // GetPositionInFlow may have caused a recalc, which may have
        // replaced the dispnode. So, we need to grab the new dispnode ptr.
        //
        *ppDNZParent = pElementZParent->GetUpdatedNearestLayout(LayoutContext())->GetElementDispNode(pElementZParent);
    }

    //
    // if the ZParent is ancestor of the LParent, then translate the point
    // to ZParent's coordinate system.
    // TODO (IE6 bug 13585) (srinib) - We are determining if ZParent is an ancesstor of
    // LParent here by comparing the source order. Searching the branch
    // could be cheaper
    //
    if(     pElementZParent == pElementLParent
        ||  (       pElementZParent->GetMarkup() == pElementLParent->GetMarkup()
                &&  pElementZParent->GetFirstCp() < pElementLParent->GetFirstCp())
        ||  (       pElementZParent->HasSlavePtr()
                &&  pElementZParent->GetSlavePtr() == pElementLParent->GetMarkup()->Root()
                &&  pElementZParent->GetSlavePtr()->GetFirstCp() < pElementLParent->GetFirstCp())
       )
    {
// TODO (IE6 bug 13585) - donmarsh when you have a routine to translate from one
// dispnode to another, please replace this code.(srinib)
        if(pElementZParent != pElementLParent)
        {
            pDispNodeParent = pLayoutParent->GetElementDispNode();

            while(  pDispNodeParent
                &&  pDispNodeParent != *ppDNZParent)
            {
                pDispNodeParent->TransformPoint(*ppt, COORDSYS_FLOWCONTENT, ppt, COORDSYS_PARENT);
                pDispNodeParent = pDispNodeParent->GetParentNode();
            }
        }
    }
    else
    {
        CPoint pt = g_Zero.pt;

        Assert(pElementZParent->IsRelative() && !pElementZParent->ShouldHaveLayout());

        pElementZParent->GetUpdatedParentLayout(pLayoutParent->LayoutContext())->GetFlowPosition(*ppDNZParent, &pt);

        ppt->x -= pt.x;
        ppt->y -= pt.y;
    }

}


//+----------------------------------------------------------------------------
//
//  Member:     HandleVisibleChange
//
//  Synopsis:   Respond to a change in the display or visibility property
//
//-----------------------------------------------------------------------------

void
CLayout::HandleVisibleChange(BOOL fVisibility)
{
    CView *     pView        = Doc()->GetView();
    CElement *  pElement     = ElementOwner();
    CTreeNode * pTreeNode    = pElement->GetFirstBranch();
    HWND        hwnd         = pElement->GetHwnd();
    BOOL        fDisplayNone = pTreeNode->IsDisplayNone();
    BOOL        fHidden      = pTreeNode->IsVisibilityHidden();

    pView->OpenView();

    if(fVisibility)
    {
        EnsureDispNodeVisibility(VisibilityModeFromStyle(pTreeNode->GetCascadedvisibility()), pElement);
    }

    if (hwnd && Doc()->_pInPlace)
    {
        CDispNode * pDispNode = GetElementDispNode(pElement);
        CRect       rc;
        UINT        uFlags = (  !fDisplayNone
                            &&  !fHidden
                            &&  (   !pDispNode
                                ||  pDispNode->IsInView())
                                        ? SWP_SHOWWINDOW
                                        : SWP_HIDEWINDOW);

        ::GetWindowRect(hwnd, &rc);
        ::MapWindowPoints(HWND_DESKTOP, Doc()->_pInPlace->_hwnd, (POINT *)&rc, 2);
        pView->DeferSetWindowPos(hwnd, &rc, uFlags, NULL);
    }

    // Special stuff for OLE sites
    if (pElement->TestClassFlag(CElement::ELEMENTDESC_OLESITE))
    {
        COleSite *  pSiteOle    = DYNCAST(COleSite, pElement);

        if (fHidden || fDisplayNone)
        {
            // When an OCX without a hwnd goes invisible, we need to call
            // SetObjectsRects with -ve rect. This lets the control hide
            // any internal windows (IE5 #66118)
            if (!hwnd)
            {
                RECT rcNeg = { -1, -1, -1, -1 };

                DeferSetObjectRects(
                    pSiteOle->_pInPlaceObject,
                    &rcNeg,
                    &g_Zero.rc,
                    NULL,
                    FALSE);
            }
        }
        else
        {
            //
            // transition up to at least baseline state if going visible.
            // Only do this if going visible cuz otherwise it causes
            // problems with the deskmovr. MikeSch has details. (anandra)
            //

            OLE_SERVER_STATE    stateBaseline   = pSiteOle->BaselineState(Doc()->State());
            if (pSiteOle->State() < stateBaseline)
            {
                pView->DeferTransition(pSiteOle);
            }
        }
    }

    if(!fVisibility)
    {
        if (ElementOwner()->IsPositioned() && !fDisplayNone)
        {
            pElement->ZChangeElement(0, NULL, LayoutContext());
        }
        else if (fDisplayNone)
        {
            CDispNode * pDispNode = GetElementDispNode();

            if (pDispNode)
            {
                // bug IE6 2282 (dmitryt) Only unlink nodes that are still
                // connected to the root. 
                // We are trying to unlink only first nodes on the way
                // down the tree, keeping all chldren of them intact so we
                // can avoid costly deep recalculation later.
                // If the "root" node returned by GetRootNode() 
                // (the one with _pParent==NULL) 
                // is not the real DispRoot, it means we belong to already
                // unlinked subtree.
                CDispNode *pRootNode = pDispNode->GetRootNode();
                if(pRootNode->IsDispRoot())
                {
                    pView->ExtractDispNode(pDispNode);
                }
            }
        }

        if (    !fDisplayNone
            &&  IsDirty()
            &&  !IsSizeThis())
        {
            TraceTagEx((tagLayoutTasks, TAG_NONAME,
                        "Layout Task: Posted on ly=0x%x [e=0x%x,%S sn=%d] by CLayout::HandleVisibleChange()",
                        this,
                        _pElementOwner,
                        _pElementOwner->TagName(),
                        _pElementOwner->_nSerialNumber));
            PostLayoutRequest(LAYOUT_MEASURE);
        }
    }
}

//+====================================================================================
//
// Method: HandleZeroGrayChange
//
// Synopsis: The ZeroGrayBorder bit on the view has been toggled. We either flip on that
//           we have a background or not on our dispnode accordingly.
//
//------------------------------------------------------------------------------------

VOID
CLayout::HandleZeroGrayChange( CNotification* pnf )
{
    CBackgroundInfo  bi;
    CDispNode      * pdn = _pDispNode;

    if ( IsShowZeroBorderAtDesignTime() )
    {
        if ( pdn &&
             ElementOwner()->_etag != ETAG_OBJECT &&
             ElementOwner()->_etag != ETAG_BODY ) // don't draw for Object tags - it may interfere with them
        {
            pdn->SetBackground( TRUE );
        }
    }
    else
    {
        //
        // Only if we don't have a background will we clear the bit.
        //
        if ( pdn )
        {
            GetBackgroundInfo(NULL, &bi, FALSE);

            BOOL fHasBack = (bi.crBack != COLORREF_NONE || bi.pImgCtx);
            if ( ! fHasBack )
                pdn->SetBackground( FALSE );
        }
    }
}

//+----------------------------------------------------------------------------
//
//  Member:     HandleElementMeasureRequest
//
//  Synopsis:   Respond to a request to measure an absolutely positioned element
//              NOTE: Due to property changes, it is possible for the element
//                    to no longer be absolutely positioned by the time the
//                    request is handled
//
//  Arguments:  pci        - CCalcInfo to use
//              pElement   - Element to position
//              fEditable  - TRUE the element associated with this layout is editable,
//                           FALSE otherwise
//
//-----------------------------------------------------------------------------
MtDefine(CLayout_HandleElementMeasureRequest, LFCCalcSize, "Calls to HandleElementMeasureRequest" )

void
CLayout::HandleElementMeasureRequest(
    CCalcInfo * pci,
    CElement *  pElement,
    BOOL        fEditable)
{
    Assert(pci);
    Assert(pElement);

    MtAdd( Mt(CLayout_HandleElementMeasureRequest), +1, 0 );

    TraceTagEx((tagLayoutPositionReqs, TAG_NONAME|TAG_INDENT, "(Layout Position Reqs: HandleElementMeasureRequest() ly=0x%x pci(%d,%d) e=0x%x,%s editable=%s",
                this, pci ? pci->_sizeParent.cx : 0, pci ? pci->_sizeParent.cy : 0, pElement, pElement->TagName(), fEditable ? "Y" : "N" ));

    CTreeNode *     pTreeNode = pElement->GetFirstBranch();
    CLayout *       pLayout   = pElement->GetUpdatedLayout(pci->GetLayoutContext());
    CNotification   nf;

    if (    pLayout
        &&  pTreeNode->IsAbsolute(LC_TO_FC(pci->GetLayoutContext()) ) )
    {
        if (   !pTreeNode->IsDisplayNone(LC_TO_FC(pci->GetLayoutContext()))
            || fEditable)
        {
            CalcAbsolutePosChild(pci, pLayout);

            nf.ElementSizechanged(pElement);
            GetView()->Notify(&nf);

            pElement->ZChangeElement(0,
                                     NULL,
                                     pci->GetLayoutContext()
                                     FCCOMMA LC_TO_FC(pci->GetLayoutContext()));
        }

        else
        {
            // NOTE (KTam): This notification is odd -- why not just clear our _fSizeThis directly?
            nf.ClearDirty(ElementOwner());
            ElementOwner()->Notify(&nf);

            if (    pLayout
                &&  pLayout->GetElementDispNode())
            {
                pLayout->GetView()->ExtractDispNode(pLayout->GetElementDispNode());
            }
        }

        // if this absolute element, has a height specified in
        // percentages, we need a flag to be set the parent flowlayout
        // in order for this resized during a vertical-only resize
        if (IsFlowLayout())
        {
            // Set flags relative to this layout's coordinate system

            const CFancyFormat *pFFChild  = pTreeNode->GetFancyFormat(LC_TO_FC(pLayout->LayoutContext()));
            BOOL  fChildWritingModeUsed   = pTreeNode->GetCharFormat(LC_TO_FC(pLayout->LayoutContext()))->_fWritingModeUsed;
            BOOL  fThisVerticalLayoutFlow = GetFirstBranch()->GetCharFormat(LC_TO_FC(LayoutContext()))->HasVerticalLayoutFlow();

            if (pFFChild->IsLogicalHeightPercent(fThisVerticalLayoutFlow, fChildWritingModeUsed))
            {
                DYNCAST(CFlowLayout, this)->SetVertPercentAttrInfo(TRUE);
            }

            if (pFFChild->IsLogicalWidthPercent(fThisVerticalLayoutFlow, fChildWritingModeUsed))
            {
                DYNCAST(CFlowLayout, this)->SetHorzPercentAttrInfo(TRUE);
            }
        }
    }
}


void
CLayout::CalcAbsolutePosChild(CCalcInfo *pci, CLayout *pChildLayout)
{
    CElement::CLock Lock(ElementOwner(), CElement::ELEMENTLOCK_SIZING);
    SIZE    sizeLayout = pci->_sizeParent;

    pChildLayout->CalcSize(pci, &sizeLayout);

    return;
}


//+----------------------------------------------------------------------------
//
//  Member:     HandlePositionNotification/Request
//
//  Synopsis:   Respond to a z-order or position change notification
//
//  Arguments:  pElement   - Element to position
//              ptAuto     - Top/Left values for "auto"
//              fAutoValid - TRUE if ptAuto is valid, FALSE otherwise
//
//  Returns:    TRUE if handled, FALSE otherwise
//
//-----------------------------------------------------------------------------
MtDefine(CLayout_HandlePositionNotification, LFCCalcSize, "Calls to HandlePositionNotification" )

BOOL
CLayout::HandlePositionNotification(CNotification * pnf)
{
    MtAdd( Mt(CLayout_HandlePositionNotification), +1, 0 );

// TODO (IE6 bug 13586): Handle if z-parent or _fContainsRelative (brendand)
    BOOL    fHandle = ElementOwner()->IsZParent();

    if (fHandle)
    {
        // Let the display tree know about z-index changes
        if (pnf->IsType(NTYPE_ELEMENT_ZCHANGE) &&
            pnf->Element()->GetUpdatedLayout(pnf->LayoutContext()))
        {
            CDispNode *pDispNode = pnf->Element()->GetUpdatedLayout(pnf->LayoutContext())->GetElementDispNode();

            if (pDispNode)
            {
                // Adjust pDispNode's layer type
                LONG zOrder = 0;
                if (!pDispNode->IsFlowNode())
                {
                    zOrder = pDispNode->GetZOrder();
                    pDispNode->SetLayerPositioned(zOrder);
                }

                WHEN_DBG(BOOL fZOrderChanged = )
                        pDispNode->RestoreZOrder(zOrder);
#if DBG == 1
                CLayout * pLayout = pnf->Element()->GetUpdatedLayout(pnf->LayoutContext());
                LONG lZOrder = pLayout->GetFirstBranch()->IsPositionStatic() ? 0 :
                                pLayout->GetZOrderForSelf(pDispNode);

                TraceTag((tagZOrderChange, "%ls %ld zorder changed to %ld   dispnode %x dispChange = %d",
                        pnf->Element()->TagName(), pnf->Element()->SN(),
                        lZOrder, pDispNode, fZOrderChanged));
#endif
            }
        }

        if (    !TestLock(CElement::ELEMENTLOCK_PROCESSREQUESTS)
            ||  TestLock(CElement::ELEMENTLOCK_PROCESSMEASURE))
        {
            TraceTagEx((tagLayoutTasks, TAG_NONAME,
                "Layout Request: Queueing RF_POSITION on ly=0x%x [e=0x%x,%S sn=%d] by CLayout::HandlePositionNotification() [n=%S srcelem=0x%x,%S]",
                this,
                _pElementOwner,
                _pElementOwner->TagName(),
                _pElementOwner->_nSerialNumber,
                pnf->Name(),
                pnf->Element(),
                pnf->Element() ? pnf->Element()->TagName() : _T("")));

            CViewChain *pViewChain = HasLayoutContext() ? LayoutContext()->ViewChain() : NULL;
            CElement *  pRoot;
            CElement *  pMaster;

            if (    pViewChain
                &&  pViewChain->ElementContent()->GetMarkupPtr() == GetOwnerMarkup()
                &&  pnf->Element()
                && (pnf->Element()->IsAbsolute() || pnf->Element()->IsRelative())
                && (pRoot = ElementOwner()->GetMarkupPtr()->Root(),
                    pMaster = pRoot ? pRoot->GetMasterPtr() : NULL,
                    pMaster == NULL || (pMaster->Tag() != ETAG_FRAME && pMaster->Tag() != ETAG_IFRAME)) )
            {
                pViewChain->QueuePositionRequest(this, pnf->Element(), pnf->DataAsPoint(), pnf->IsDataValid());
            }
            else
            {
                CRequest *  pRequest = QueueRequest(CRequest::RF_POSITION, pnf->Element());

                if (pRequest)
                {
                    pRequest->SetAuto(pnf->DataAsPoint(), pnf->IsDataValid());
                }
            }
        }
        else
        {
            CRequest * pRequest = pnf->Element()->GetRequestPtr();

            if(!pRequest || !pRequest->IsFlagSet(CRequest::RF_POSITION))
            {
                // This initializes CCalcInfo with resolution taken from this layout's context
                CCalcInfo CI(this);
                HandlePositionRequest(&CI, pnf->Element(), pnf->DataAsPoint(), pnf->IsDataValid());
            }
            else if (pRequest && pRequest->IsFlagSet(CRequest::RF_AUTOVALID))
            {
                pRequest->ClearFlag(CRequest::RF_AUTOVALID);
            }
        }
    }

    return fHandle;
}

MtDefine(CLayout_HandlePositionRequest, LFCCalcSize, "Calls to HandlePositionRequest" )

BOOL
CLayout::HandlePositionRequest(
    CCalcInfo *     pci,
    CElement *      pElement,
    const CPoint &  ptAuto,
    BOOL            fAutoValid)
{

    // TODO (IE6 bug 13586): Handle if z-parent or _fContainsRelative (brendand)
    Assert(ElementOwner()->IsZParent());
    Assert(!TestLock(CElement::ELEMENTLOCK_SIZING));
    Assert(GetElementDispNode());
    Assert(pElement->GetFirstBranch());

    MtAdd( Mt(CLayout_HandlePositionRequest), +1, 0 );

#if DBG==1
    {
        long    cp  = pElement->GetFirstCp() - GetContentFirstCp();
        long    cch = pElement->GetElementCch();

        Assert( !IsDirty()
            ||  (   IsFlowLayout()
                &&  DYNCAST(CFlowLayout, this)->IsRangeBeforeDirty(cp, cch)));
    }
#endif
          CLayoutContext * pLayoutContext = pci->GetLayoutContext();
          
          CTreeNode    * pTreeNode = pElement->GetFirstBranch();
    const CFancyFormat * pFF = pTreeNode->GetFancyFormat();
    const CCharFormat  * pCF = pTreeNode->GetCharFormat();
          BOOL           fRelative = pFF->IsRelative();
          BOOL           fAbsolute = pFF->IsAbsolute();


    TraceTagEx((tagLayoutPositionReqs, TAG_NONAME|TAG_INDENT, "(Layout Position Reqs: HandlePositionRequest() ly=0x%x pci(%d,%d) e=0x%x,%s pt(%d,%d) ptValid=%s",
                this, pci ? pci->_sizeParent.cx : 0, pci ? pci->_sizeParent.cy : 0, pElement, pElement->TagName(), ptAuto.x, ptAuto.y, fAutoValid ? "T" : "F" ));

    //
    // Layouts inside relative positioned elements do not know their
    // relative position untill the parent is measured. So, they fire
    // a z-change notification to get positioned into the tree.
    // fRelative is different from pCF->_fRelative, fRelative means
    // is the current element relative. pCF->_fRelative is true if
    // an element is inheriting relativeness from an ancestor the
    // does not have layoutness (an image inside a relative span,
    // if the span has layoutness then the image does not inherit
    // relativeness).
    //
    if (    !IsDisplayNone()
        &&  !pCF->IsDisplayNone()
        &&  (fAbsolute || pCF->_fRelative || fRelative))
    {
        // TODO (IE6 bug 13586): Re-write this: If _fContainsRelative, then get the element z-parent and its
        //         display node. Then use that node as the parent for all other processing.
        //         (brendand)
        CLayout   * pLayout         = pElement->GetUpdatedNearestLayout(pLayoutContext);
        CElement  * pElementZParent = pTreeNode->ZParent();
        CLayout   * pLayoutZParent  = pElementZParent->GetUpdatedNearestLayout(pLayoutContext);
        CDispNode * pDNElement;
        CDispNode * pDNZParent;

        pDNZParent = pLayoutZParent->EnsureDispNodeIsContainer(pElementZParent);

        if (pDNZParent)
        {
            Assert(pLayout);

            pDNElement = pLayout->GetElementDispNode(pElement);

            Assert(pDNZParent->IsContainer());

            if(pDNElement)
            {
                BOOL            fThisVertical = GetFirstBranch()->GetCharFormat(LC_TO_FC(pLayoutContext))->HasVerticalLayoutFlow();
                BOOL            fChildWM = pCF->_fWritingModeUsed;
                const CUnitValue & cuvTop     = pFF->GetLogicalPosition(SIDE_TOP, fThisVertical, fChildWM);
                const CUnitValue & cuvBottom  = pFF->GetLogicalPosition(SIDE_BOTTOM, fThisVertical, fChildWM);
                const CUnitValue & cuvLeft    = pFF->GetLogicalPosition(SIDE_LEFT, fThisVertical, fChildWM);
                const CUnitValue & cuvRight   = pFF->GetLogicalPosition(SIDE_RIGHT, fThisVertical, fChildWM);
                BOOL            fTopAuto      = cuvTop.IsNullOrEnum();
                BOOL            fBottomAuto   = cuvBottom.IsNullOrEnum();
                BOOL            fLeftAuto     = cuvLeft.IsNullOrEnum();
                BOOL            fRightAuto    = cuvRight.IsNullOrEnum();
                BOOL            fLeftPercent  = cuvLeft.IsPercent();
                BOOL            fTopPercent   = cuvTop.IsPercent();
                CLayout       * pLayoutParent = pElement->GetUpdatedParentLayout(pLayoutContext);
                long            lFontHeight   = pTreeNode->GetCharFormat()->GetHeightInTwips(Doc());
                long            xLeftMargin   = 0;
                long            yTopMargin    = 0;
                long            xRightMargin  = 0;
                long            yBottomMargin = 0;
                CPoint          pt(g_Zero.pt);
                CRect           rc(g_Zero.rc);
                CDocInfo      * pdciMeasure   = pci;
                CSize size;

                CElement  * pParent         = pLayoutParent->ElementOwner();

                if ( pParent->Tag() == ETAG_TR )
                {
                    if (pElement->Tag() == ETAG_TD || pElement->Tag() == ETAG_TH)
                    {
                        if (pParent->IsPositionStatic())  // if row itself is not postioned
                        {
                            // the parent layout should be the table
                            pLayoutParent = pParent->GetUpdatedParentLayout(pLayoutContext);
                        }
                    }
                }

                // We need to know if the parent is RTL to decide if we need to honor
                // right:XXX or left:XXX first
                BOOL fRTLParent = FALSE;
                {
                    CFlowLayout *pFL = pLayoutParent->IsFlowLayout();
                    if (pFL)
                    {
                        fRTLParent = pFL->IsRTLFlowLayout();
                    }
                    else
                    {
                        // This is a more expensive way to determine if a layout is
                        // RTL, but we only need this if a non-flow layout is a
                        // parent of something positoned, and that's exotic.
                        // (greglett)  Not so exotic anymore.  Under the CSS DTS most
                        //             elements will be positioned wrt the HTML layout.
                        fRTLParent = pLayoutParent->IsRightToLeft();
                    }

                    // In RTL, if Right is set, it has priority
                    if (fRTLParent)
                    {
                        if (!fRightAuto)
                            fLeftAuto = TRUE;
                    }
                }


                if (    !fAbsolute
                    ||  fLeftAuto
                    ||  fTopAuto)
                {
                    CFlowLayout * pFL = pLayoutParent->IsFlowLayout();

                    // GetAutoPosition returns bogus (0, 0) pt in situation when pLayoutParent 
                    // is calculated in background and pElement is not in calculated part yet... 
                    if (    pFL && pFL->HasBgRecalcInfo()
                        &&  pFL->GetMaxCpCalced() <= pElement->GetFirstCp())
                    {
                        goto Cleanup;
                    }

                    pt = ptAuto;

                    GetAutoPosition(pElement, pElementZParent, &pDNZParent, pLayoutParent, &pt, fAutoValid);

                    //
                    // Get auto position may have caused a calc which might result in
                    // morphing the display node for the current element.
                    //
                    pDNElement = pLayout->GetElementDispNode(pElement);
                }

                size = pDNElement->GetApparentSize();

                //
                // if the we are positioning an absolute element with top/left specified
                // then clear the auto values.
                //
                if (fAbsolute)
                {
                    if (!fLeftAuto || !fRightAuto)
                    {
                        pt.x = 0;
                        if (pLayoutZParent->IsFlowLayout())
                        {
                            CDispClient* pDispClient = pDNZParent->GetDispClient();
                            if (pDispClient)
                            {
                                CPoint anchor;
                                BOOL ok = pDispClient->GetAnchorPoint(pDNZParent, &anchor);
                                if (ok)
                                    pt.x = anchor.x;
                            }

                        }
                    }

                    if (!fTopAuto)
                        pt.y = 0;
                //}
                // Used to be: fAbsolute || Tag() == ETAG_BODY || Tag() == ETAG_FRAMESET
                //if (fAbsolute)
                //{
                    // Account for margins on absolute elements.
                    // Margins is already added onto relatively positioned elements.
                    // Due to the algorithm we need to have
                    // margin info available for absolute in opposite flows.
                    // Margins are also not added into BODY/FRAMESET, because HTML is not a flow layout.
                    // (greglett) However: BackCompat BODY/FRAMESET should not care about margins!
                    if (pLayout->ElementOwner() == pElement)
                    {
                        CCalcInfo CI(pdciMeasure, pLayoutParent);

                        pLayout->GetMarginInfo(&CI,
                                               &xLeftMargin,
                                               &yTopMargin,
                                               &xRightMargin,
                                               &yBottomMargin);

                        // Depending on flow direction, margins contribute differently
                        // TODO RTL 112514: this will not do the right thing in a run of opposite flow
                        //                  that is not explicitly marked as "dir=???". We should be 
                        //                  calling CalculateXPositionOfCp() or an equivalent, or cache
                        //                  the result of a previous call (since we have ptAuto, we have 
                        //                  called it before). But that is more change than I want to do 
                        //                  now, and this is not a regression from IE5.0
                        if(!fRTLParent)
                            pt.x += xLeftMargin;
                        else
                            pt.x -= xRightMargin;
                        pt.y += yTopMargin;
                    }
                }

                // (dmitryt) Perf optimization for the case when we have lots of positioned objects 
                // in a line. In this case, we get position request for each of them (N) and InsertChildInZLayer
                // is NlogN operation, so we have N*N*logN behavior.
                // Because of this, lets store the old position of dispnode and:
                // 1. if new position is the same - don't move dispnode.
                // 2. if _pParent is not NULL - don't try to insert the node into the tree.

                CPoint ptOldPos = pDNElement->GetPosition();
 
                //
                // if the element is positioned, compute the top/left based
                // on the top/left/right/bottom styles specified for the element
                //
                if (pFF->IsPositioned())
                {
                    //
                    //  Get the client rectangle used for percent and auto positioning
                    //  NOTE: Sanitize the rectangle so that each direction is even
                    //        (The extra pixel is given to the size of the object over the location)
                    //
                    if (    fLeftPercent
                        ||  fTopPercent
                        || !fRightAuto
                        || !fBottomAuto)
                    {
                        CLayout *pPositioningParent = fRelative ? pLayoutParent : pLayoutZParent;

                        pPositioningParent->GetClientRect(&rc);

                        // In RTL layout, positioning rectangle shouldn't be adjusted for scrolling.
                        // Absolute positioning from left and right behaves somewhat differently in RTL
                        // (and that's what it did in IE5): 'right:N' positions from right edge of layout, not
                        // from right edge of window; 'left:N' positions from left edge of original window.
                        // 'Left:N' behavior is probably bogus, but we need to investigate if it is a
                        // compatibility before changing it.
                        // (see bug 102699)
                        if (   fRTLParent 
                            && pPositioningParent->_pDispNode 
                            && pPositioningParent->_pDispNode->IsScroller())
                        {
                            // NOTE: this is only correct for scroller.
                            // leaf nodes and containers may have negative left of
                            // client area because of RTL overflow.
                            rc.MoveTo(0,0);
                        }

                        rc.right  &= ~0x00000001;
                        rc.bottom &= ~0x00000001;
                    }

                    // in RTL, do right offset first, otherwise, start with leftthere is no left offsetting the right offset
                    if(!fLeftAuto)
                    {
                        // adjust left position
                        pt.x += cuvLeft.XGetPixelValue(pdciMeasure, rc.Width(), lFontHeight);
                    }
                    else if(!fRightAuto)
                    {
                        if(fRelative)
                        {
                            // adjust the relative position in the flow
                            // kind of redundant to get the right x and then get
                            // the left again so just adjust the left
                            pt.x -= cuvRight.XGetPixelValue(pdciMeasure, rc.Width(), lFontHeight);
                        }
                        else
                        {
                            pt.x = rc.right;
                            pt.x -= cuvRight.XGetPixelValue(pdciMeasure, rc.Width(), lFontHeight);
                            pt.x -= xRightMargin;
                            //place the top/left now
                            pt.x -= size.cx;
                        }
                    }

                    // adjust top position
                    pt.y += cuvTop.YGetPixelValue(pdciMeasure, rc.Height(), lFontHeight);

                    if(!fBottomAuto)
                    {

                        // It is possible that we are overconstrained. Give top priority and
                        // don't go in here
                        if(fTopAuto)
                        {
                            if(fRelative)
                            {
                                // adjust the relative position in the flow
                                pt.y -= cuvBottom.YGetPixelValue(pdciMeasure, rc.Height(), lFontHeight);
                            }
                            else
                            {
                                pt.y = rc.bottom;
                                pt.y -= cuvBottom.YGetPixelValue(pdciMeasure, rc.Height(), lFontHeight);
                                pt.y -= yBottomMargin;
                                pt.y -= size.cy;
                            }
                        }
                    }

                    if (   (fAbsolute || fRelative)
                        && pLayoutContext
                        && pLayoutContext->ViewChain()
                        && pLayoutContext->ViewChain()->ElementContent()->GetMarkupPtr() == GetOwnerMarkup())
                    {
                        //  Reparenting absolute positioned element's disp node.

                        CLayoutContext * pLayoutContextDst;
                        CElement *       pElementContent;
                        CLayout *        pLayoutContent;
                        CViewChain *     pViewChain;
                        const CFancyFormat * pFFParent;
                        styleOverflow    overflowX;
                        styleOverflow    overflowY;
                        LONG             lZIndex;

                        pFFParent = ElementOwner()->GetFirstBranch()->GetFancyFormat();
                        overflowX = pFFParent->GetLogicalOverflowX(fThisVertical, fChildWM);
                        overflowY = pFFParent->GetLogicalOverflowY(fThisVertical, fChildWM);
                        lZIndex = GetTopmostAbsoluteZParent(pLayout->GetFirstBranch())->GetCascadedzIndex();

                        pViewChain = pLayoutContext->ViewChain();

                        pElementContent = pViewChain->ElementContent();
                        Assert(pElementContent);

                        if (   (pElementZParent == pElementContent
                                || (   pDNZParent->GetParentNode()
                                    && ((CLayout *)pDNZParent->GetParentNode()->GetDispClient())->ElementOwner() == pElementContent))
                            && (    overflowX == styleOverflowVisible
                                 || overflowX == styleOverflowNotSet
                                 || overflowY == styleOverflowVisible
                                 || overflowY == styleOverflowNotSet)   
                            &&  !HasFilterPeer(_pDispNode)  )
                        {
                            //  find the stitched pt
                            if (pElementZParent != pElementContent)
                            {
                                pt += pDNZParent->GetPosition().AsSize();

                                pDNZParent = pDNZParent->GetParentNode();
                                Assert(pDNZParent);
                                if (pDNZParent)
                                {
                                    pLayoutContent = (CLayout *)pDNZParent->GetDispClient();
                                    Assert(pLayoutContent
                                        &&  pLayoutContent->ElementOwner() == pElementContent
                                        &&  pLayoutContent->LayoutContext());

                                    pt.y += pLayoutContent->LayoutContext()->YOffset();
                                }
                            }
                            else if (   fRelative
                                    //  (bug # 99215; # 105475)
                                    ||  (fAutoValid && fTopAuto && fBottomAuto)  )
                            {
                                //  if this is a relative element add global y offset to get stitched coords
                                pt.y += pLayoutContext->YOffset();
                            }

                            CPoint ptStitched(pt);  //  at this point we have stitched pt

                            for (;;)
                            {
                                pt = ptStitched;

                                pLayoutContextDst = pViewChain->LayoutContextFromPoint(pLayout, &pt,
                                    //  If (pLayout->ElementOwner() != pElement) current disp node is
                                    //  rel disp node. And it should appear on the first page always (bug #106079)
                                    pLayout->ElementOwner() != pElement);

                                if (pLayoutContextDst == NULL)
                                {
                                    //  there is no page yet
                                    TraceTagEx((tagLayoutPositionReqs, TAG_NONAME|TAG_OUTDENT, ")Layout Position Reqs: HandlePositionRequest()"));
                                    return FALSE;
                                }

                                pLayoutContent = pElementContent->GetUpdatedLayout(pLayoutContextDst);

                                // We don't print HTML layout right now...
                                Assert(!GetOwnerMarkup()->IsHtmlLayout());

                                pDNZParent = pLayoutContent->EnsureDispNodeIsContainer(pElementContent);
                                
                                if (pDNZParent == NULL)
                                {
                                    //  this may happen if we have static template (not real print preview tempalte),
                                    //  in this case layout context exists but is not calaulted yet
                                    //  and doesn't have a disp node.
                                    TraceTagEx((tagLayoutPositionReqs, TAG_NONAME|TAG_OUTDENT, ")Layout Position Reqs: HandlePositionRequest()"));
                                    return FALSE;
                                }

                                // if view chain adjust to offset of the page
                                pt.y -= pLayoutContextDst->YOffset();

                                pLayout->_fDispNodeReparented = TRUE;

                                // NOTE : this is a code duplication should keep it in sync with what 
                                // we have below in this function.
                                pDNElement->SetLayerPositioned(lZIndex);
                                DYNCAST(CDispContainer, pDNZParent)->InsertChildInZLayer(pDNElement, lZIndex);

                                if (pElement->ShouldHaveLayout())
                                {
                                    pLayout->SetPosition(pt);

                                    //  pt.y less than zero if this is not the first block.
                                    //  Notification should be sent only for the first block.
                                    if (pt.y >= 0)
                                    {
                                        CNotification   nf;

                                        nf.ElementPositionchanged(pElement);
                                        GetView()->Notify(&nf);
                                    }
                                }
                                else
                                    pDNElement->SetPosition(pt);

                                ELEMENT_TAG etag = pLayout->Tag();

                                // Check if disp node doesn't fit into layout rect
                                if (    (ptStitched.y + size.cy) > (pLayoutContextDst->YOffset() + pLayoutContextDst->Height())
                                    //  Check that the element has its own layout. Otherwise this is a inline relative element.
                                    && pLayout->ElementOwner() == pElement
                                    &&  etag != ETAG_TR
                                    &&  etag != ETAG_THEAD
                                    &&  etag != ETAG_TFOOT  )
                                {
                                    // Set display break ...
                                    pViewChain->SetDisplayBreak(pLayoutContextDst, pLayout, (new CBreakBase()));

                                    // Clone disp nodes ... 

                                    // TODO (112506, olego): 
                                    // We do not have robust way to clone the display sub-tree. 
                                    // Now the full calcsize pass is ussed for that purpose. 
                                    // DisplayTree should have the functionality to clone its 
                                    // sub-tree starting from given display node.

                                    CCalcInfo   CI(pLayout);
                                    CSize       sizeLayout(size);

                                    Assert( CI.GetLayoutContext()
                                        &&  CI.GetLayoutContext()->ViewChain() );

                                    CI._fCloneDispNode = TRUE;
                                    CI._grfLayout = LAYOUT_MEASURE | LAYOUT_FORCE;
                                    CI._sizeParentForVert = CI._sizeParent;

                                    Assert(!pElement->IsAbsolute() || !pLayout->ElementCanBeBroken());

                                    //  Init available height for PPV
                                    if (pLayout->ElementCanBeBroken())
                                    {
                                        CLayoutBreak *pLayoutBreak;
                                        CI.GetLayoutContext()->GetEndingLayoutBreak(pElement, &pLayoutBreak);
                                        Assert(pLayoutBreak);

                                        if (pLayoutBreak)
                                        {
                                            CI._cyAvail = pLayoutBreak->AvailHeight();
                                        }
                                    }
                                    else
                                    {
                                        CI._cyAvail = pViewChain->HeightForContext( CI.GetLayoutContext() );
                                    }

                                    if (etag == ETAG_TD ||  etag == ETAG_TH)
                                    {
                                        CI._smMode = SIZEMODE_SET;
                                    }

                                    pLayout->SetSizeThis(TRUE);

                                    pLayout->CalcSize(&CI, (SIZE *)&sizeLayout);


                                    Assert(sizeLayout == size);

                                    pDNElement = pLayout->GetElementDispNode(pElement);
                                }
                                else
                                {
                                    return TRUE;
                                }
                            }
                        }
                    }


                    //if it's a newly created dispnode or ExtractFromTree was called during CalcSize,
                    //the parent will be NULL. This is the only case when we should Insert the dispnode
                    //into the tree (dmitryt)
                    CDispNode *pDisplayParent = pLayoutZParent->EnsureDispNodeIsContainer(pElementZParent);
                    if(pDNElement->GetParentNode() != pDisplayParent)
                    {
                        pDNElement->SetLayerPositioned(pFF->_lZIndex);
                        DYNCAST(CDispContainer, pDisplayParent)->InsertChildInZLayer(pDNElement, pFF->_lZIndex);
                    }
                }
                else
                {
                    DYNCAST(CDispContainer, pDNZParent)->InsertChildInFlow(pDNElement);
                }

                //if position actually changed, reposition dispnode
                if(ptOldPos != pt)
                {
                    if (pElement->ShouldHaveLayout())
                    {
                        pLayout->SetPosition(pt);

                        if (pFF->IsPositioned())
                        {
                            CNotification   nf;

                            nf.ElementPositionchanged(pElement);
                            GetView()->Notify(&nf);
                        }
                    }
                    else
                        pDNElement->SetPosition(pt);
                }
                else if (pElement->ShouldHaveLayout())
                    pLayout->_fPositionSet = TRUE;
            }
        }

        // The positioned element might have a caret inside that needs to move.
        CCaret *pCaret = Doc()->_pCaret;
        BOOL     fCaretVisible = FALSE;
        long     cpFirst, cpLast, cpCaret;

        if ( pCaret )
        {
            pCaret->IsVisible( &fCaretVisible );
            if ( fCaretVisible )
            {
                // If the markups are different, then we can't easily tell whether
                // the caret is affected by the element's position change, so just update.
                // If the markups are the same, we only need to update if the caret lies
                // within the cp range of the positioned element.
                if (    pCaret->GetMarkup() != pElement->GetMarkup()
                   || (  pElement->GetFirstAndLastCp( &cpFirst, &cpLast )
                      && ((cpCaret = pCaret->GetCp(NULL)) != 0)
                      && ( cpCaret >= cpFirst && cpCaret <= cpLast ) )
                   )
                {
                    pCaret->UpdateCaret();
                }
            }
        }
    }

Cleanup:
    TraceTagEx((tagLayoutPositionReqs, TAG_NONAME|TAG_OUTDENT, ")Layout Position Reqs: HandlePositionRequest()"));
    return TRUE;
}

#ifdef ADORNERS
//+----------------------------------------------------------------------------
//
//  Member:     HandleAddAdornerNotification/Request
//
//  Synopsis:   Insert the display node for a adorner
//
//  Arguments:  pAdorner - CAdorner whose display node is to be inserted
//
//-----------------------------------------------------------------------------

BOOL
CLayout::HandleAddAdornerNotification(
    CNotification * pnf)
{
    CElement *  pElement  = ElementOwner();
    CTreeNode * pTreeNode = pElement->GetFirstBranch();
    BOOL        fHandle   = FALSE;

    //
    //  Adorners for BODYs or FRAMESETs are always anchored at the absolute top of that element
    //  (since there is no parent element in the current design under which to anchor them)
    //
    if (pnf->Element() == pElement)
    {
        Assert(GetOwnerMarkup());
        if(    pElement->Tag() == ETAG_BODY         //check for tags because there could be both 
            || pElement->Tag() == ETAG_FRAMESET     //BODY and FRAMESET in html file...
            || pElement == GetOwnerMarkup()->GetCanvasElement()) //this is for CSS1 case to check for ETAG_HTML
        {
            Assert(pnf->DataAsPtr());
            DYNCAST(CAdorner, (CAdorner *)pnf->DataAsPtr())->GetDispNode()->SetExtraCookie((void *)ADL_ALWAYSONTOP);
            fHandle = TRUE;
        }
    }

    //
    //  Adorners are handled by the layout that owns the display node under which they are to be anchored
    //  This divides into several cases:
    //
    //      1) Adorners anchored at the "absolute" top are anchored under the first scrolling or
    //         filtered parent (since they mark a logical top within the display tree)
    //
    //      2) Adorners anchored on the element itself are anchored under the positioned parent
    //         (since that is the same parent under which the associated element is anchored)
    //         NOTE: Adorners anchored on an element are currently reserved for positioned elements -
    //               If that changes, then these rules will need appropriate modification
    //
    //      3) Adorners for the flow layer are anchored under either the first scrolling
    //         parent, first filtered parent, or first positioned parent found
    //         (since they establish the nearest flow layer)
    //
    //  These rules are modified slightly when the positioned parent does not have its own layout (such
    //  as with a relatively positioned element). In that case, while the adorner is still anchored under
    //  the positioned parent, it is the nearest layout of that positioned parent which handles the
    //  request
    //
    else
    {
        //
        //  Determine if this layout is at a logical top or is a z-parent
        //
        //      1) All clipping  elements mark a logical top
        //      2) The layout is (logically) a z-parent if it is a logical top,
        //         is itself a z-parent, or is the nearest layout to the actual
        //         z-parent
        //

        CDispNode * pElementDispNode = GetElementDispNode();

        BOOL        fAtTop    = pElementDispNode->IsClipNode();
        BOOL        fZParent  = fAtTop
                        ||  pTreeNode->IsZParent()
                        ||  (   (   !pnf->Element()->IsPositionStatic()
                                ||  pnf->Element()->IsInheritingRelativeness())
                            &&  pnf->Element()->GetFirstBranch()->ZParent()->GetUpdatedNearestLayout() == this);

        if (    fAtTop
            ||  fZParent)
        {
            CAdorner *      pAdorner  = DYNCAST(CAdorner, (CAdorner *)pnf->DataAsPtr());
            CDispNode *     pDispNode = pAdorner->GetDispNode();
            ADORNERLAYER    adl       = (ADORNERLAYER)(DWORD)(DWORD_PTR)pDispNode->GetExtraCookie();

            fHandle =   (   adl == ADL_ALWAYSONTOP
                        &&  fAtTop)
                    ||  (   adl == ADL_ONELEMENT
                        &&  fZParent)
                    ||  adl == ADL_TOPOFFLOW;
        }
    }

    if (fHandle)
    {
        if (!TestLock(CElement::ELEMENTLOCK_PROCESSREQUESTS))
        {
            TraceTagEx((tagLayoutTasks, TAG_NONAME,
                        "Layout Request: Queuing RF_ADDADORNERS on ly=0x%x [e=0x%x,%S sn=%d] by CLayout::HandleAddAdornerNotification() [n=%S srcelem=0x%x,%S]",
                        this,
                        _pElementOwner,
                        _pElementOwner->TagName(),
                        _pElementOwner->_nSerialNumber,
                        pnf->Name(),
                        pnf->Element(),
                        pnf->Element() ? pnf->Element()->TagName() : _T("")));
            CRequest *  pRequest = QueueRequest(CRequest::RF_ADDADORNER, pnf->Element());

            if (pRequest)
            {
                pRequest->SetAdorner(DYNCAST(CAdorner, (CAdorner *)pnf->DataAsPtr()));
            }
        }
        else
        {
            HandleAddAdornerRequest(DYNCAST(CAdorner, (CAdorner *)pnf->DataAsPtr()));
        }
    }

    return fHandle;
}

void
CLayout::HandleAddAdornerRequest(
    CAdorner *  pAdorner)
{
    Assert(pAdorner);
    Assert(pAdorner->GetElement());
    Assert(!TestLock(CElement::ELEMENTLOCK_SIZING));
    Assert(GetElementDispNode());
    Assert(TestLock(CElement::ELEMENTLOCK_PROCESSREQUESTS));
#if DBG==1
    {
        long    cp  = pAdorner->GetElement()->GetFirstCp() - GetContentFirstCp();
        long    cch = pAdorner->GetElement()->GetElementCch();

        Assert( !IsDirty()
            ||  (   IsFlowLayout()
                &&  DYNCAST(CFlowLayout, this)->IsRangeBeforeDirty(cp, cch)));
    }
#endif

    TraceTagEx((tagLayoutAdornerReqs, TAG_NONAME, "Layout Adorner Reqs: HandleAddAdornerRequest() called"));

    CDispNode * pDispAdorner = pAdorner->GetDispNode();
    CElement *  pElement     = pAdorner->GetElement();

    if (pDispAdorner)
    {
        switch ((ADORNERLAYER)(DWORD)(DWORD_PTR)pDispAdorner->GetExtraCookie())
        {

        //
        //  Anchor "always on top" adorners as the last node(s) of the current postive-z layer
        //

        default:
        case ADL_ALWAYSONTOP:
            {
                CDispParentNode *   pDispParent = EnsureDispNodeIsContainer();
                Assert (pDispParent);
                pDispParent->InsertChildInZLayer(pDispAdorner, pAdorner->GetZOrderForSelf(pDispAdorner));
            }
            break;

        //
        //  Anchor adorners that sit on the element as the element's next sibling
        //

        case ADL_ONELEMENT:
            {
                Assert(pElement->GetUpdatedNearestLayout());
                Assert(pElement->GetUpdatedNearestLayout()->GetElementDispNode(pElement));

                CLayout *   pLayout   = pElement->GetUpdatedNearestLayout();
                CDispNode * pDispNode = pLayout->GetElementDispNode(pElement);

                if (pDispNode && pDispNode->HasParent())
                {
                    pDispNode->InsertSiblingNode(pDispAdorner, CDispNode::after);
                }
            }
            break;

        //
        //  Anchor "top of flow" adorners in the flow layer of this layout or
        //  the element's positioned z-parent, whichever is closer
        //  (In either case, this layout "owns" the display node under which the
        //   adorner is added)
        //

        case ADL_TOPOFFLOW:
            {
                CElement *          pElementParent = pElement->GetFirstBranch()->ZParent();
                CDispParentNode * pDispParent;

                Assert( pElementParent == ElementOwner()
                    ||  pElementParent->IsPositionStatic()
                    ||  (   pElementParent->GetFirstBranch()->GetCascadedposition() == stylePositionrelative
                        &&  !pElementParent->GetUpdatedLayout()
                        &&  pElementParent->GetUpdatedNearestLayout() == this));

                if (pElementParent->IsPositionStatic())
                {
                    pElementParent = ElementOwner();
                }

                pDispParent = pElementParent->GetUpdatedNearestLayout()->EnsureDispNodeIsContainer(pElementParent);

                if (pDispParent)
                {
                    pDispParent->InsertChildInFlow(pDispAdorner);
                }
            }
            break;
        }

        pAdorner->PositionChanged();
    }
}
#endif // ADORNERS

HRESULT
CLayout::OnPropertyChange(DISPID dispid, DWORD dwFlags)
{
    HRESULT hr = S_OK;;

    switch(dispid)
    {
    case DISPID_A_OVERFLOW:
    case DISPID_A_OVERFLOWY:
    case DISPID_A_SCROLL   :
        // Reset this flag. Will get set if necessary in
        // the next calc pass.
        _fNeedRoomForVScrollBar = FALSE;
        break;

    case DISPID_UNKNOWN:
    case DISPID_CElement_className:
    case DISPID_A_BACKGROUNDIMAGE:
    case DISPID_BACKCOLOR:
        EnsureDispNodeBackground();
        break;
    }

    RRETURN(hr);
}

CMarkup *
CLayout::GetOwnerMarkup() const
{
    // get the owner's Markup
    Assert( _pMarkupDbg == (_fHasMarkupPtr ? _pMarkup : NULL ) );
    return _fHasMarkupPtr ? _pMarkup : NULL;
}

void
CLayout::DelMarkupPtr()
{
    Assert(_fHasMarkupPtr);
    Assert( _pMarkup == _pMarkupDbg);
    WHEN_DBG(_pMarkupDbg = NULL );

    // Delete out CMarkup *
    _pDoc = _pMarkup->Doc();
    _fHasMarkupPtr = FALSE;
}

void
CLayout::SetMarkupPtr(CMarkup *pMarkup)
{
    Assert( !_fHasMarkupPtr );
    Assert( pMarkup );
    Assert( pMarkup->Doc() == _pDocDbg );

     _pMarkup = pMarkup;
     WHEN_DBG( _pMarkupDbg = pMarkup );
     _fHasMarkupPtr = TRUE;
}

CMarkup *
CLayout::GetContentMarkup() const
{
    if (ElementOwner()->HasSlavePtr())
    {
        return ElementOwner()->GetSlavePtr()->GetMarkup();
    }
    // get the owner's Markup
    Assert( _pMarkupDbg == (_fHasMarkupPtr ? _pMarkup : NULL ) );
    return _fHasMarkupPtr ? _pMarkup : NULL;
}

//+----------------------------------------------------------------------------
//
//  Member:     RegionFromElement
//
//  Synopsis:   Return the bounding rectangle for an element, if the element is
//              this instance's owner. The RECT returned is in client coordinates.
//
//  Arguments:  pElement - pointer to the element
//              CDataAry<RECT> *  - rectangle array to contain
//              dwflags - flags define the type of changes required
//              (CLEARFORMATS) etc.
//
//-----------------------------------------------------------------------------
void
CLayout::RegionFromElement( CElement * pElement,
                            CDataAry<RECT> * paryRects,
                            RECT * prcBound,
                            DWORD  dwFlags)
{
    Assert( pElement && paryRects);

    if (!pElement || !paryRects)
        return;

    // if the element passed is the element that owns this instance,
    if ( _pElementOwner == pElement )
    {
        CRect rect;

        if (!prcBound)
        {
            prcBound = &rect;
        }

        // If the element is not shown, bounding rectangle is all zeros.
        if ( pElement->IsDisplayNone() )
        {
            // return (0,0,0,0) if the display is set to 'none'
            *prcBound = g_Zero.rc;
        }
        else
        {
            // return the rectangle that this CLayout covers
            GetRect( prcBound, dwFlags & RFE_SCREENCOORD
                                ? COORDSYS_GLOBAL
                                : COORDSYS_PARENT);
        }

        paryRects->AppendIndirect(prcBound);
    }
    else
    {
        // we should not reach here, since anything that can have children
        // is actually a flow layout (or a table thingy) since the CLayout does not know how
        // to wrap text.
        //(dmitryt) commenting this out - script can easily ask for offsetWidth of <BR>,
        // no need to assert here.
        //AssertSz( FALSE, "CLayout::RegionFromElement should not be called");
        if(prcBound)
            *prcBound = g_Zero.rc;
   }
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::NotifyMeasuredRange
//
//  Synopsis:   Send a measured range notification
//
//  Arguments:  cpStart - Starting cp of range
//              cpEnd   - Ending cp of range
//
//----------------------------------------------------------------------------

void
CLayout::NotifyMeasuredRange(
    long    cpStart,
    long    cpEnd)
{
    CNotification   nf;

    Assert( cpStart >= 0
        &&  cpEnd   >= 0);

    nf.MeasuredRange(cpStart, cpEnd - cpStart);

    GetView()->Notify(&nf);
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::NotifyTranslatedRange
//
//  Synopsis:   Send a translated range notification
//
//  Arguments:  size    - Size of translation
//              cpStart - Starting cp of range
//              cpEnd   - Ending cp of range
//
//----------------------------------------------------------------------------

void
CLayout::NotifyTranslatedRange(
    const CSize &   size,
    long            cpStart,
    long            cpEnd)
{
    CNotification   nf;
    BOOL fIsMaster = ElementOwner()->HasSlavePtr();

    if (fIsMaster)
    {
        cpStart = GetContentFirstCp();
        cpEnd = GetContentLastCp();
    }

    Assert( cpStart >= 0
        &&  cpEnd   >= 0);
    Assert(cpEnd >= cpStart);

    nf.TranslatedRange(cpStart, cpEnd - cpStart);
    nf.SetData(size);

    if (_fAutoBelow && !fIsMaster)
    {
        Assert(GetContentMarkup());
        GetContentMarkup()->Notify(&nf);
    }

    GetView()->Notify(&nf);
}


//+---------------------------------------------------------------------------
//
//  Member:     CLayout::ComponentFromPoint
//
//  Synopsis:   Return the component hit by this point.
//
//  Arguments:  x,y     coordinates of point
//
//  Returns:    the component that was hit
//
//  Notes:
//
//----------------------------------------------------------------------------

_htmlComponent
CLayout::ComponentFromPoint(long x, long y)
{
    CDispNode *pdn = _pDispNode;

    if (pdn)
    {
        CPoint pt;
        pdn->TransformPoint(
            CPoint(x,y),
            COORDSYS_GLOBAL,
            &pt,
            COORDSYS_BOX);

        CRect rcContainer(pdn->GetSize());
        if (rcContainer.Contains(pt))
        {
            if (pdn->IsScroller())
            {
                CRect rcScrollbar;
                CScrollbar::SCROLLBARPART part;
                CDispScroller* pScroller = DYNCAST(CDispScroller, pdn);
                const CSize& sizeContent = pScroller->GetContentSize();
                CSize sizeOffset;
                pScroller->GetScrollOffset(&sizeOffset);

                CFormDrawInfo DI;
                DI.Init(this);

                // check vertical scrollbar
                pScroller->GetClientRect(&rcScrollbar, CLIENTRECT_VSCROLLBAR);
                part = CScrollbar::GetPart(
                    1,
                    rcScrollbar,
                    pt,
                    sizeContent.cy,
                    rcScrollbar.Height(),
                    sizeOffset.cy,
                    rcScrollbar.Width(),
                    &DI);

                switch (part)
                {
                case CScrollbar::SB_PREVBUTTON: return htmlComponentSbUp;
                case CScrollbar::SB_NEXTBUTTON: return htmlComponentSbDown;
                case CScrollbar::SB_PREVTRACK:  return htmlComponentSbPageUp;
                case CScrollbar::SB_NEXTTRACK:  return htmlComponentSbPageDown;
                case CScrollbar::SB_THUMB:      return htmlComponentSbVThumb;
                }

                // check horizontal scrollbar
                pScroller->GetClientRect(&rcScrollbar, CLIENTRECT_HSCROLLBAR);
                part = CScrollbar::GetPart(
                    0,
                    rcScrollbar,
                    pt,
                    sizeContent.cx,
                    rcScrollbar.Width(),
                    sizeOffset.cx,
                    rcScrollbar.Height(),
                    &DI);

                switch (part)
                {
                case CScrollbar::SB_PREVBUTTON: return htmlComponentSbLeft;
                case CScrollbar::SB_NEXTBUTTON: return htmlComponentSbRight;
                case CScrollbar::SB_PREVTRACK:  return htmlComponentSbPageLeft;
                case CScrollbar::SB_NEXTTRACK:  return htmlComponentSbPageRight;
                case CScrollbar::SB_THUMB:      return htmlComponentSbHThumb;
                }
            }

            return htmlComponentClient;
        }
    }

    return htmlComponentOutside;
}

//+====================================================================================
//
// Method: ShowSelected
//
// Synopsis: The "selected-ness" of this layout has changed. We need to set it's
//           properties, and invalidate it.
//
//------------------------------------------------------------------------------------

VOID
CLayout::ShowSelected(
                        CTreePos* ptpStart,
                        CTreePos* ptpEnd,
                        BOOL fSelected,
                        BOOL fLayoutCompletelyEnclosed )
{
    SetSelected( fSelected, TRUE );
}

//+====================================================================================
//
// Method:  SetSelected
//
// Synopsis:Set the Text Selected ness of the layout
//
//------------------------------------------------------------------------------------


VOID
CLayout::SetSelected( BOOL fSelected , BOOL fInvalidate )
{
    // select the element
    const CCharFormat *pCF = GetFirstBranch()->GetCharFormat();

    // Set the site text selected bits appropriately
    SetSiteTextSelection (
        fSelected,
        pCF->SwapSelectionColors());

    if ( fInvalidate )
        Invalidate();
}

//+====================================================================================
//
// Method:  GetContentRect
//
// Synopsis:Get the content rect in the specified coordinate system
//
//------------------------------------------------------------------------------------
void
CLayout::GetContentRect(CRect *prc, COORDINATE_SYSTEM cs)
{
    CPoint ptTopLeft(0,0);
    CSize  sizeLayout;
    RECT   rcClient;
    CDispNode * pDispNode;

    TransformPoint(&ptTopLeft, COORDSYS_FLOWCONTENT, cs);
    GetContentSize(&sizeLayout);
    pDispNode = GetElementDispNode();



    prc->left   = ptTopLeft.x;
    prc->right  = prc->left + sizeLayout.cx;
    prc->top    = ptTopLeft.y;
    prc->bottom = prc->top + sizeLayout.cy;

    GetClientRect(&rcClient, cs);
    prc->Union(rcClient);
}

#if DBG==1
BOOL CLayout::ContainsNonHiddenChildLayout()
{
    BOOL fHasNonHiddenLayout = FALSE;
    DWORD_PTR dw=0;
    BOOL fRaw = FALSE;

    CLayout * pLayout = GetFirstLayout(&dw, FALSE, fRaw);
    while (pLayout)
    {
        if (!pLayout->IsDisplayNone())
        {
            fHasNonHiddenLayout = TRUE;
            break;
        }
        pLayout = GetNextLayout(&dw, FALSE, fRaw);
    }
    ClearLayoutIterator(dw, fRaw);
    return fHasNonHiddenLayout;
}
#endif

void
CLayout::PhysicalGlobalToPhysicalLocal(const CPoint &ptGlobalPhysical, CPoint *pptLocalPhysical)
{
    CElement  *pElement  = ElementOwner();
    CDispNode *pDispNode = GetElementDispNode();
    CPoint ptLocalLogical;
    CPoint ptClient;
    CPoint ptGlobalPhysicalHacked(ptGlobalPhysical);

    //
    // The point coming in is relative to the top/left of the frame. We need it relative to
    // the top/left of the root document.
    //
    pElement->GetClientOrigin(&ptClient);
    ptGlobalPhysicalHacked += ptClient.AsSize();


    //---------------------------------------------------------------------------------
    //
    // HACK BEGIN
    //
    // This hack is to mirror the hack in GetPosition. The problem is that the disp nodes for TR's are, for some
    // wierd reason (a this is where the real problem is), not positioned appropriately. I believe, that is to
    // have the cells position off of the table rather than the TR. But that nonsense causes us problems
    // every where we make transformations like these.
    //
    if (ETAG_TR == pElement->Tag())
    {
        CTreeNode *pNode = pElement->GetFirstBranch();
        CElement  *pElementZParent = pNode->ZParent();

        if (pElementZParent)
        {
            CLayout   *pParentLayout = pElementZParent->GetUpdatedNearestLayout();
            CDispNode *pDispNodeNew = pParentLayout->GetElementDispNode(pElementZParent);

            if (pDispNodeNew)
            {
                pElement = pElementZParent;
                pDispNode = pDispNodeNew;
            }
        }
    }
    //
    // This hack is there to support borders on selects. The problem is that for selects,
    // the display tree is unaware of the border. The old code used to manually remove the
    // border widths, now we depend on the display tree to do so. However, in this case
    // the display tree does not know about the borders and hence they need to be removed
    // manually, just like the old code. However, this causes a bug when we have border
    // set to something other than 2 on the style sheet -- the select control completely
    // ignores it, while the code which computes the offset* values pays attention to it.
    // To see what I am talking about here, load this page, and hover over the select
    // border and look at the offset* values you get back ...
    //
    // <select style="border:1000px solid red"><option>helloworld</option></select>
    //
    // Vertical layout does not matter since select is always horizontal.
    //
    else if (ETAG_SELECT == pElement->Tag())
    {
        CBorderInfo bi;
        pElement->GetBorderInfo(NULL, &bi, FALSE, FALSE);
        ptGlobalPhysicalHacked.x -= bi.aiWidths[SIDE_LEFT];
        ptGlobalPhysicalHacked.y -= bi.aiWidths[SIDE_TOP];
    }

    //
    // Yet another hack caused because of the possibility of 2 display nodes for tables.
    // The outer display node does not exhibit the borders which causes our current scheme
    // to fail. The correct thing would be to use the appropriate table display node
    // based on the y value coming in. But IE5 did not do it ...
    //
    if (ETAG_TABLE == pElement->Tag())
    {
        CBorderInfo bi;
        pDispNode->TransformPoint(ptGlobalPhysicalHacked, COORDSYS_GLOBAL,
                                  &ptLocalLogical,        COORDSYS_BOX);
        pElement->GetBorderInfo(NULL, &bi, FALSE, FALSE);
        ptLocalLogical.x -= bi.aiWidths[SIDE_LEFT];
        ptLocalLogical.y -= bi.aiWidths[SIDE_TOP];
    }
    //
    // END HACK
    //
    //---------------------------------------------------------------------------------
    else
    {
        pDispNode->TransformPoint(ptGlobalPhysicalHacked, COORDSYS_GLOBAL,
                                  &ptLocalLogical,        COORDSYS_CONTENT);
    }

    if (!pElement->HasVerticalLayoutFlow())
    {
        *pptLocalPhysical = ptLocalLogical;
    }
    else
    {
        CSize sz;

        GetContentSize(&sz, FALSE);
        pptLocalPhysical->y = ptLocalLogical.x;
        pptLocalPhysical->x = sz.cy - ptLocalLogical.y;
    }
}

void
CLayout::PhysicalLocalToPhysicalGlobal(const CPoint &ptLocalPhysical, CPoint *pptGlobalPhysical)
{
    CElement  *pElement  = ElementOwner();
    CDispNode *pDispNode = GetElementDispNode();
    CPoint ptLocalLogical;
    CPoint ptLocalPhysicalHacked(ptLocalPhysical);
    CPoint ptClient;

    //---------------------------------------------------------------------------------
    //
    // HACK BEGIN
    //
    // This hack is to mirror the hack in GetPosition. The problem is that the disp nodes for TR's are, for some
    // wierd reason (a this is where the real problem is), not positioned appropriately. I believe, that is to
    // have the cells position off of the table rather than the TR. But that nonsense causes us problems
    // every where we make transformations like these.
    //
    if (ETAG_TR == pElement->Tag())
    {
        CTreeNode *pNode = pElement->GetFirstBranch();
        CElement  *pElementZParent = pNode->ZParent();

        if (pElementZParent)
        {
            CLayout   *pParentLayout = pElementZParent->GetUpdatedNearestLayout();
            CDispNode *pDispNodeNew = pParentLayout->GetElementDispNode(pElementZParent);

            if (pDispNodeNew)
            {
                pElement = pElementZParent;
                pDispNode = pDispNodeNew;
            }
        }
    }
    //
    // This hack is there to support borders on selects. The problem is that for selects,
    // the display tree is unaware of the border. The old code used to manually remove the
    // border widths, now we depend on the display tree to do so. However, in this case
    // the display tree does not know about the borders and hence they need to be removed
    // manually, just like the old code. However, this causes a bug when we have border
    // set to something other than 2 on the style sheet -- the select control completely
    // ignores it, while the code which computes the offset* values pays attention to it.
    // To see what I am talking about here, load this page, and hover over the select
    // border and look at the offset* values you get back ...
    //
    // <select style="border:1000px solid red"><option>helloworld</option></select>
    //
    // Vertical layout does not matter since select is always horizontal.
    //
    else if (ETAG_SELECT == pElement->Tag())
    {
        CBorderInfo bi;
        pElement->GetBorderInfo(NULL, &bi, FALSE, FALSE);
        ptLocalPhysicalHacked.x += bi.aiWidths[SIDE_LEFT];
        ptLocalPhysicalHacked.y += bi.aiWidths[SIDE_TOP];
    }
    //
    // END HACK
    //
    //---------------------------------------------------------------------------------


    if (!pElement->HasVerticalLayoutFlow())
    {
        ptLocalLogical = ptLocalPhysicalHacked;
    }
    else
    {
        CSize sz;

        GetContentSize(&sz, FALSE);
        ptLocalLogical.x = ptLocalPhysicalHacked.y;
        ptLocalLogical.y = sz.cy - ptLocalPhysicalHacked.x;
    }

    //
    // Yet another hack caused because of the possibility of 2 display nodes for tables.
    // The outer display node does not exhibit the borders which causes our current scheme
    // to fail. The correct thing would be to use the appropriate table display node
    // based on the y value coming in. But IE5 did not do it ...
    //
    if (ETAG_TABLE == pElement->Tag())
    {
        CBorderInfo bi;
        pElement->GetBorderInfo(NULL, &bi, FALSE, FALSE);
        ptLocalLogical.x += bi.aiWidths[SIDE_LEFT];
        ptLocalLogical.y += bi.aiWidths[SIDE_TOP];
        pDispNode->TransformPoint(ptLocalLogical,    COORDSYS_BOX,
                                  pptGlobalPhysical, COORDSYS_GLOBAL);
    }
    else
    {
        pDispNode->TransformPoint(ptLocalLogical,    COORDSYS_CONTENT,
                                  pptGlobalPhysical, COORDSYS_GLOBAL);
    }

    //
    // We need to return the point relative to the frame top/left. Converting to coordsys_global
    // takes us relative to the top/left of the root document. We need to transform it by the
    // frame's origin to get it relative to the frame.
    //
    pElement->GetClientOrigin(&ptClient);
    *pptGlobalPhysical -= ptClient.AsSize();
}

BOOL
CLayout::IsEditable(BOOL fCheckContainerOnly, BOOL fUseSlavePtr)
{
    HRESULT                 hr = S_OK;
    BOOL                    fIsEditable = FALSE;
    CElement                *pElement = ElementOwner();
    IHTMLEditingServices    *pEdServices = NULL;
    IHTMLElement            *pSlaveElement = NULL;
    IHTMLElement            *pTestElement = NULL;
    IMarkupPointer          *pStartPointer = NULL;
    IMarkupPointer          *pEndPointer = NULL;

    if (fUseSlavePtr && pElement->HasSlavePtr() &&
        (pElement->Tag() == ETAG_GENERIC || pElement->Tag() == ETAG_IFRAME))
    {
        CDoc            *pDoc  = Doc();
        CElement        *pSlave = ElementOwner()->GetSlavePtr();
        CElement        *pTest = NULL;

        hr = THR( pSlave->QueryInterface(IID_IHTMLElement, (void **)&pSlaveElement) );
        if (hr)
            goto Cleanup;

        hr = THR( pDoc->CreateMarkupPointer(&pStartPointer) );
        if (hr)
            goto Cleanup;
        hr = THR( pDoc->CreateMarkupPointer(&pEndPointer) );
        if (hr)
            goto Cleanup;

        Assert(pSlaveElement);

        hr = THR( pDoc->GetEditingServices(& pEdServices ));
        if (hr)
            goto Cleanup;
        pEdServices->PositionPointersInMaster(pSlaveElement, pStartPointer, pEndPointer);

        hr = THR( pStartPointer->CurrentScope(&pTestElement) );
        if (hr || pTestElement == NULL)
            goto Cleanup;
        hr = THR( pTestElement->QueryInterface(CLSID_CElement, (void**)&pTest) );
        if (hr)
            goto Cleanup;

        Assert(pTest);
        fIsEditable = pTest->IsEditable(fCheckContainerOnly FCCOMMA LC_TO_FC(LayoutContext()));
    }
    else
    {
        fIsEditable = ElementOwner()->IsEditable(fCheckContainerOnly FCCOMMA LC_TO_FC(LayoutContext()));
    }

Cleanup:
    ReleaseInterface(pTestElement);
    ReleaseInterface(pSlaveElement);
    ReleaseInterface(pEdServices);
    ReleaseInterface(pStartPointer);
    ReleaseInterface(pEndPointer);

    return fIsEditable;
}

//+====================================================================================
//
// CLayoutContext methods
//
//------------------------------------------------------------------------------------
BOOL
CLayoutContext::IsEqual( CLayoutContext *pOtherLayoutContext ) const
{
    return ( this == pOtherLayoutContext );
}

CLayoutContext::CLayoutContext( CLayout *pLayoutOwner )
{
    Assert(pLayoutOwner);
    Assert( pLayoutOwner->ElementOwner()->IsLinkedContentElement()
            || !FormsStringICmp(pLayoutOwner->ElementOwner()->TagName(), _T("DEVICERECT")) );

    _cRefs = 0;
    _pLayoutOwner = pLayoutOwner;

    // inherit resolution from parent layout context.
    // If the owner layout defines its own media, it will override this setting
    CLayoutContext *pContainingLayoutContext = pLayoutOwner->LayoutContext();
    Assert( pContainingLayoutContext ? pContainingLayoutContext->IsValid() : TRUE );

    _media = pContainingLayoutContext
           ? pContainingLayoutContext->GetMedia()
           : mediaTypeNotSet;

#ifdef MULTI_FORMAT
    _pFormatContext = new CFormatContext(this);
#endif
}

CLayoutContext::~CLayoutContext()
{
    Assert( !_pLayoutOwner );    // Owner should have been NULLed out by now

#ifdef MULTI_FORMAT
    delete _pFormatContext;
#endif

}

//+====================================================================================
//
// Method:  GetLayoutBreak
//
// Synopsis:
//
//------------------------------------------------------------------------------------
HRESULT
CLayoutContext::GetLayoutBreak(CElement *pElement, CLayoutBreak **ppLayoutBreak)
{
    Assert(ppLayoutBreak);

    CViewChain *pViewChain = ViewChain();
    if (pViewChain)
    {
        return pViewChain->GetLayoutBreak(this, pElement, ppLayoutBreak, FALSE);
    }

    *ppLayoutBreak = NULL;
    return S_OK;
}

//+====================================================================================
//
// Method:  GetEndingLayoutBreak
//
// Synopsis:
//
//------------------------------------------------------------------------------------
HRESULT
CLayoutContext::GetEndingLayoutBreak(CElement *pElement, CLayoutBreak **ppLayoutBreak)
{
    Assert(ppLayoutBreak);

    CViewChain *pViewChain = ViewChain();
    if (pViewChain)
    {
        return pViewChain->GetLayoutBreak(this, pElement, ppLayoutBreak, TRUE);
    }

    *ppLayoutBreak = NULL;
    return S_OK;
}

//+====================================================================================
//
// Method:  SetLayoutBreak
//
// Synopsis:
//
//------------------------------------------------------------------------------------
HRESULT
CLayoutContext::SetLayoutBreak(CElement *pElement, CLayoutBreak *pLayoutBreak)
{
    HRESULT         hr = S_OK;

    Assert(pElement && pLayoutBreak);

    CViewChain *pViewChain = ViewChain();
    if (!pViewChain)
    {
        AssertSz(0, "SetLayoutBreak is called on a context with no chain");
        delete pLayoutBreak;
        return S_FALSE;
    }

    hr = pViewChain->SetLayoutBreak(this, pElement, pLayoutBreak);
    if (hr)
    {
        goto Cleanup;
    }

Cleanup:
    return hr;
}

//+====================================================================================
//
// Method:  RemoveLayoutBreak
//
// Synopsis:
//
//------------------------------------------------------------------------------------
HRESULT
CLayoutContext::RemoveLayoutBreak(CElement *pElement)
{
    HRESULT hr = S_OK;

    Assert(pElement);

    CViewChain *pViewChain = ViewChain();
    if (!pViewChain)
    {
        AssertSz(0, "RemoveLayoutBreak is called on a context with no chain");
        return S_FALSE;
    }

    hr = pViewChain->RemoveLayoutBreak(this, pElement);
    if (hr)
    {
        goto Cleanup;
    }

Cleanup:
    return hr;
}

//+====================================================================================
//
// Method:  ViewChain
//
// Synopsis: If this layout context is part of a view chain, this will return it.
//           If a context is invalid, that means it's not part of a view chain.
//           Note that compatible contexts override this fn to always return NULL.
//
//------------------------------------------------------------------------------------
CViewChain *
CLayoutContext::ViewChain()
{
    if ( IsValid() )
    {
        CLayout *pLayout = GetLayoutOwner();
        return pLayout->ViewChain();
    }

    return NULL;
}

//+====================================================================================
//
// Miscelaneous
//
//------------------------------------------------------------------------------------

HRESULT
CLayout::EnsureBgRecalcInfo()
{
    if (HasBgRecalcInfo())
        return S_OK;

    // Table cells don't get a CBgRecalcInfo and that's ok (S_FALSE).
    if (!CanHaveBgRecalcInfo())
        return S_FALSE;

    CBgRecalcInfo * pBgRecalcInfo = new CBgRecalcInfo;
    Assert(pBgRecalcInfo && "Failure to allocate CLayout::CBgRecalcInfo");

    if (pBgRecalcInfo)
    {
        IGNORE_HR( SetLookasidePtr(LOOKASIDE_BGRECALCINFO, pBgRecalcInfo) );
    }

    return pBgRecalcInfo ? S_OK : E_OUTOFMEMORY;
}

void
CLayout::DeleteBgRecalcInfo()
{
    Assert(HasBgRecalcInfo());

    CBgRecalcInfo * pBgRecalcInfo = (CBgRecalcInfo *)DelLookasidePtr(LOOKASIDE_BGRECALCINFO);

    Assert(pBgRecalcInfo);
    if (pBgRecalcInfo)
    {
        delete pBgRecalcInfo;
    }
}

HRESULT
CLayout::SetLayoutContext( CLayoutContext *pLayoutContext )
{
    Assert( !HasLayoutContext() && "A layout shouldn't ever change containing contexts" );
    Assert( pLayoutContext && " bad bad thing, E_INVALIDARG" );
    Assert( pLayoutContext->GetLayoutOwner() != this && "You can't possibly own the layout context you're contained within" );
    Assert( ( HasDefinedLayoutContext() ? DefinedLayoutContext() != pLayoutContext : TRUE ) && "You can't be contained within the same layout context you define" );

    // Main body is not supposed to be contained. Try asserting that:
    AssertSz(_pElementOwner->Tag() != ETAG_BODY ||
             pLayoutContext->GetLayoutOwner()->GetContentMarkup() != GetContentMarkup(),
             "Main body is not supposed to use a layout context");

    pLayoutContext->AddRef();
    return SetLookasidePtr(LOOKASIDE_CONTAININGCONTEXT, pLayoutContext);
}

void
CLayout::DeleteLayoutContext()
{
    Assert(HasLayoutContext());

    CLayoutContext * pLayoutContext = (CLayoutContext *)DelLookasidePtr(LOOKASIDE_CONTAININGCONTEXT);

    Assert(pLayoutContext);
    pLayoutContext->Release();
}

HRESULT
CLayout::SetDefinedLayoutContext( CLayoutContext *pLayoutContext )
{
    Assert( !HasDefinedLayoutContext() && "A layout shouldn't ever change the context it defines" );
    Assert( pLayoutContext && " bad bad thing, E_INVALIDARG" );
    Assert( pLayoutContext->GetLayoutOwner() == this && "You must own the layout context you define, or it's a working context" );
    Assert( ( HasLayoutContext() ? LayoutContext() != pLayoutContext : TRUE ) && "You can't be contained within the same layout context you define" );

    pLayoutContext->AddRef();
    return SetLookasidePtr(LOOKASIDE_DEFINEDCONTEXT, pLayoutContext);
}

void
CLayout::DeleteDefinedLayoutContext()
{
    Assert(HasDefinedLayoutContext());

    // Make us stop pointing to the context
    CLayoutContext * pLayoutContext = (CLayoutContext *)DelLookasidePtr(LOOKASIDE_DEFINEDCONTEXT);
    AssertSz(pLayoutContext, "Better have a context if we said we had one");
    AssertSz(pLayoutContext->RefCount() > 0, "Context better still be alive");
    AssertSz(pLayoutContext->IsValid(), "Context better still be valid");
    AssertSz(pLayoutContext->GetLayoutOwner() == this, "You must own the layout context you define" );

    // Make the context stop pointing to us
    pLayoutContext->ClearLayoutOwner();

    // This release corresponds to the addref in SetDefinedLayoutContext()
    pLayoutContext->Release();

    // At this point the context may still be alive, since it might have had layouts created in it,
    // which would continue to hold refs, but it's now invalid since the we the definer have gone away.

    // TODO (112486, olego): We should re-think layout context concept 
    // and according to that new understanding correct the code. 

    // We'd like to post a task that will run through the tree looking for such invalid layouts and
    // clean them up, but unfortunately we may be unable to access any elements
    // at this point since everything may be torn down.

    // One soln to this is to implement misc tasks in CView that don't require
    // any objects to execute.  Event tasks are probably out of the question
    // since they need an element.  All the task needs to do is fire an
    // NTYPE_MULTILAYOUT_CLEANUP notification (already ready to go).

    // GetView()->AddEventTask( NULL, DISPID_EVMETH_ONMULTILAYOUTCLEANUP );
}

// TODO (112486, olego): We should re-think layout context concept 
// and according to that new understanding correct the code. 

// (original comment by ktam): Eventually make this a CContainerLayout member instead
// of CLayout; unfortunately for now we need to be able to create context for other
// kinds of layouts (E1D) due to IFRAME hack.
// At that point, also make SetDefinedLayoutContext() a CContainerLayout
// member (same reason).
HRESULT CreateLayoutContext(CLayout * pLayout)
{
    Assert( !pLayout->HasDefinedLayoutContext() && "Can't create a context for a layout that already defines context" );

    // this comes back with a 0 refcount, this is ok because it is addref'd in the
    // SetlayoutContext
    CLayoutContext * pLayoutContext = new CLayoutContext( pLayout );

    Assert(pLayoutContext && "Failure to allocate CLayoutContext");

    if (pLayoutContext)
    {
        return pLayout->SetDefinedLayoutContext( pLayoutContext );
    }

    return E_OUTOFMEMORY;
}

void
CLayout::SetHTILayoutContext( CHitTestInfo *phti )
{
    if ( !HasLayoutContext() )
    {
        Assert( phti->_pLayoutContext == NULL );
        return;
    }

    CLayoutContext *pLayoutContext = LayoutContext();
    Assert( pLayoutContext->GetLayoutOwner() != this );

    // Only set the layout context if it hasn't been done already.
    if ( !phti->_pLayoutContext )
    {
        phti->_pLayoutContext = pLayoutContext;
    }
    // Check that if we've already set context, that we're not
    // trying to change it.
    Assert( phti->_pLayoutContext == pLayoutContext );
}

void
CLayout::SetElementAsBreakable()
{
    CMarkup *  pMarkup;
    CElement * pRoot;
    CElement * pMaster;

    Assert(!ElementCanBeBroken());

    pMarkup = ElementOwner()->GetMarkupPtr();
    if (pMarkup != NULL)
    {
        pRoot = (CElement *)pMarkup->Root();
        Assert(pRoot);
        pMaster = pRoot->HasMasterPtr() ? (CElement *)pRoot->GetMasterPtr() : NULL;

        // Allow to break only content inside layout rect
        SetElementCanBeBroken(pMaster != NULL && pMaster->IsLinkedContentElement());
    }
}


LONG
CLayout::GetCaptionHeight(CElement* pElement)
{
    LONG               lHeightCaption = 0;
    IHTMLTableCaption *pICaption = NULL;
    IHTMLElement      *pICaptionElement = NULL;
    IHTMLTable        *pITable = NULL  ;
    IHTMLElement      *pIElement = NULL;

    if (SUCCEEDED(pElement->QueryInterface(IID_IHTMLElement, (void**)&pIElement)))
    {
        if (SUCCEEDED(ElementOwner()->QueryInterface(IID_IHTMLTable , (void**)&pITable)))
        {
            if (SUCCEEDED(pITable->get_caption(&pICaption)))
            {
                if (pICaption != NULL)
                {
                    if (SUCCEEDED(pICaption->QueryInterface(IID_IHTMLElement , (void**)&pICaptionElement)))
                    {
                        pICaptionElement->get_offsetHeight(&lHeightCaption);
                    }
                    ReleaseInterface(pICaptionElement);
                }
            }
            ReleaseInterface(pICaption);
        }
        ReleaseInterface(pITable);
    }
    ReleaseInterface(pIElement);

    return (lHeightCaption);
}

BOOL
CLayout::IsShowZeroBorderAtDesignTime()
{
    CMarkup *pMarkup = GetContentMarkup();
    if (pMarkup != NULL)
    {
        return pMarkup->IsShowZeroBorderAtDesignTime();
    }
    else
    {
        return FALSE;
    }
}

void
CLayout::AdjustBordersForBreaking( CBorderInfo *pBI )
{
    CLayoutContext *pLayoutContext = LayoutContext();
    CElement       *pElementOwner;
    BOOL            fLayoutFlowVertical;

    if (   !pLayoutContext
        || !pLayoutContext->ViewChain()
        || !ElementCanBeBroken() )
    {
        return;
    }

    pElementOwner = ElementOwner();
    fLayoutFlowVertical = pElementOwner->HasVerticalLayoutFlow();

    Assert(pElementOwner);
    if (!pLayoutContext->IsElementFirstBlock(pElementOwner))
    {
        if (fLayoutFlowVertical)
        {
            pBI->wEdges &= ~BF_LEFT;
        }
        else
        {
            pBI->wEdges &= ~BF_TOP;
        }
    }

    if (!pLayoutContext->IsElementLastBlock(pElementOwner))
    {
        if (fLayoutFlowVertical)
        {
            pBI->wEdges &= ~BF_RIGHT;
        }
        else
        {
            pBI->wEdges &= ~BF_BOTTOM;
        }
    }
}

void
CLayout::AddDispNodeToArray(CDispNode *pNewDispNode)
{
    AssertSz(HasLayoutContext(), "Illegal to call CLayout::AddDispNodeToArray in non PPV.");
    Assert(_pDispNode && pNewDispNode && _pDispNode != pNewDispNode);

    CAryDispNode *pDispNodeArray = DispNodeArray();

    if (!pDispNodeArray)
    {
        pDispNodeArray = new CAryDispNode();

        if (    !pDispNodeArray
            ||  !SUCCEEDED(SetDispNodeArray(pDispNodeArray )))
        {
            delete pDispNodeArray;
            goto Error;
        }
    }

    AssertSz(pDispNodeArray, "No disp node array was created." );
    AssertSz(HasDispNodeArray(), "No disp node array was added to lookaside ptr.");
    AssertSz(pDispNodeArray == DispNodeArray(), "Pointers do NOT match.");

    if (!SUCCEEDED(pDispNodeArray->Append(_pDispNode)))
    {
        goto Error;
    }

    _pDispNode = pNewDispNode;

Error:
    return;
}

void
CLayout::DestroyDispNodeArray()
{
    if (HasDispNodeArray())
    {
        Assert(HasLayoutContext());

        CAryDispNode * pDispNodeArray = DeleteDispNodeArray();
        CDispNode **   ppDispNode;
        int            cDispNodes;

        for (ppDispNode = &pDispNodeArray->Item(0), cDispNodes = pDispNodeArray->Size();
             cDispNodes;
             ppDispNode++, cDispNodes--)
        {
            DetachScrollbarController(*ppDispNode);
            Verify(OpenView());
            (*ppDispNode)->Destroy();
        }

        delete pDispNodeArray;
    }
}

// ComputeMBPWidthHelper walks up document tree and accumulates MBP for all 
// block elements between this layout and pFlowLayoutParent. 
long 
CLayout::ComputeMBPWidthHelper(CCalcInfo *pci, CFlowLayout *pFlowLayoutParent)
{
    Assert(pci && pFlowLayoutParent);

    long        cxWidthDelta = 0;
    CTreeNode * pNodeCur;
    CTreeNode * pNodeParent;
    long        cxParentWidth = pci->_sizeParent.cx;

    if (    !ElementOwner()->HasMarkupPtr() 
        ||  !ElementOwner()->GetMarkupPtr()->IsStrictCSS1Document() )
    {
        // This function is called in CSS compliant mode from CFlowLayout::MeasureSite for embedded layouts to walk up the tree 
        // and sum up mbp (In IE compatible mode we only considered the (m)bp of the outer layout. I.e. we don't collapse mbp for
        // nested blocks.
        // When we come in this situation our layout belongs to an viewlink which has a differnt markup which is not under CSS
        // compliant dts. In this case we want to behave like before and we simply return 0. Going to Cleanup does it.
        goto Cleanup;
    }

    pNodeParent = pFlowLayoutParent->GetFirstBranch();
    pNodeCur    = GetFirstBranch();
    
    if (!pNodeParent || !pNodeCur)
    {
        goto Cleanup;
    }

    // 
    // The loop to iterate parent branch up the tree
    // 
    for (pNodeCur = pNodeCur->Parent(); pNodeCur && pNodeCur != pNodeParent; pNodeCur = pNodeCur->Parent())
    {
        CElement * pElement = pNodeCur->Element();

        Check(pElement && !pElement->ShouldHaveLayout());

        if (pElement && pElement->IsBlockElement())
        {
            CBorderInfo bi;

            if (pElement->GetBorderInfo(pci, &bi, FALSE, TRUE))
            {
                cxWidthDelta += bi.aiWidths[SIDE_LEFT] + bi.aiWidths[SIDE_RIGHT];
            }

            if (pElement->Tag() != ETAG_TC)
            {
                // we are interested in physical MBP, thus there is no need to call logical 
                // versions of methods...
                const CFancyFormat * pFF = pNodeCur->GetFancyFormat(LC_TO_FC(LayoutContext()));
                const CCharFormat  * pCF = pNodeCur->GetCharFormat(LC_TO_FC(LayoutContext()));
                long lFontHeight         = pCF->GetHeightInTwips(pNodeCur->Doc());
                const CUnitValue & cuvPaddingLeft   = pFF->GetPadding(SIDE_LEFT);
                const CUnitValue & cuvPaddingRight  = pFF->GetPadding(SIDE_RIGHT);
                const CUnitValue & cuvMarginLeft    = pFF->GetMargin(SIDE_LEFT);
                const CUnitValue & cuvMarginRight   = pFF->GetMargin(SIDE_RIGHT);

                cxWidthDelta +=   cuvPaddingLeft.XGetPixelValue(pci, cxParentWidth, lFontHeight) 
                                + cuvPaddingRight.XGetPixelValue(pci, cxParentWidth, lFontHeight)
                                + cuvMarginLeft.XGetPixelValue(pci, cxParentWidth, lFontHeight) 
                                + cuvMarginRight.XGetPixelValue(pci, cxParentWidth, lFontHeight);
            }
        }
    }

Cleanup:

    return (cxWidthDelta);
}

#if DBG
void
CLayout::DumpLayoutInfo( BOOL fDumpLines )
{
    WriteHelp(g_f, _T(" Layout (T=<0d>): 0x<1x> DC=0x<2x> CC=0x<3x>\r\n"),
              (long)_layoutType, this, DefinedLayoutContext(),
              LayoutContext() );
}

void
CLayout::SetSizeThis( unsigned u )
{
    _fSizeThis = u;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\layout\scrollbar.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       scrollbar.cxx
//
//  Contents:   Class to render default horizontal and vertical scrollbars.
//
//  Classes:    CScrollbar
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FLOAT2INT_HXX_
#define X_FLOAT2INT_HXX_
#include "float2int.hxx"
#endif

#ifndef X_SCROLLBAR_HXX_
#define X_SCROLLBAR_HXX_
#include "scrollbar.hxx"
#endif

#ifndef X_BUTTUTIL_HXX_
#define X_BUTTUTIL_HXX_
#include "buttutil.hxx"
#endif

#ifndef X_CDUTIL_HXX_
#define X_CDUTIL_HXX_
#include "cdutil.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_DISPSCROLLER_HXX_
#define X_DISPSCROLLER_HXX_
#include "dispscroller.hxx"
#endif

#ifdef UNIX
#ifndef X_UNIXCTLS_HXX_
#define X_UNIXCTLS_HXX_
#include "unixctls.hxx"
#endif
#endif // UNIX

#ifdef _MAC
#ifndef X_MACCONTROLS_HXX_
#define X_MACCONTROLS_HXX_
#include "maccontrols.h"
#endif
#endif


//+---------------------------------------------------------------------------
//
//  Member:     GetThemedScrollbarButtonCode
//              
//  Synopsis:   return the button part constant for themed scrollbars
//              
//  Arguments:  fButtonDisabled        TRUE if button is to be painted in disabled state
//              fButtonPressed         TRUE if button is to be painted in pressed state
//              nDirScrollbar          0 for horizontal, 1 for vertical
//              fVertLayout            TRUE if we are painting scroll bars in writing-mode:TB-RL
//              nWhichButton           0 is LEFT or UP and 1 is RIGHT or DOWN
//----------------------------------------------------------------------------

static int 
GetThemedScrollbarButtonCode(BOOL fButtonDisabled, BOOL fButtonPressed, int nDirScrollbar, BOOL fVertLayout, int nWhichButton)
{
    int nPartState;

    if(fVertLayout)
    {
        if(fVertLayout && nDirScrollbar == 1)
        {
            Assert(nWhichButton == 0 || nWhichButton == 1);
            // For vertical layout mode left and right buttons should be swapped
            //  on the vertical scrollbar (that becomes horizontal in that mode)
            nWhichButton = !nWhichButton;
        }
        Assert(nDirScrollbar == 0 || nDirScrollbar == 1);
        nDirScrollbar = !nDirScrollbar;
    }

    if(fButtonDisabled)
    {
        if(nDirScrollbar == 0)
            nPartState = (nWhichButton == 0) ? ABS_LEFTDISABLED : ABS_RIGHTDISABLED; 
        else
            nPartState = (nWhichButton == 0) ? ABS_UPDISABLED : ABS_DOWNDISABLED;
    }
    else if(fButtonPressed)
    {
        if(nDirScrollbar == 0)
            nPartState = (nWhichButton == 0) ? ABS_LEFTPRESSED : ABS_RIGHTPRESSED; 
        else
            nPartState = (nWhichButton == 0) ? ABS_UPPRESSED : ABS_DOWNPRESSED;
    }
    else
    {
        if(nDirScrollbar == 0)
            nPartState = (nWhichButton == 0) ? ABS_LEFTNORMAL : ABS_RIGHTNORMAL; 
        else
            nPartState = (nWhichButton == 0) ? ABS_UPNORMAL : ABS_DOWNNORMAL;
    }
    return nPartState;
}


//+---------------------------------------------------------------------------
//
//  Member:     GetThemedScrollbarPartState
//              
//  Synopsis:   return the disabled/pressed/normal code for given themed scrollbar part
//                to be used by the theme functions
//              
//  Arguments:  fDisabled              TRUE if the part is to be painted in disabled state
//              nPartPressed           The part that is pressed
//              nPart                  The part who's state we want to get
//----------------------------------------------------------------------------

static int
GetThemedScrollbarPartState(BOOL fDisabled, int nPartPressed, int nPart)
{
    int nPartState;

    if(fDisabled)
        nPartState = SCRBS_DISABLED;
    else if(nPartPressed == nPart)
        nPartState = SCRBS_PRESSED;
    else
        nPartState = SCRBS_NORMAL;

    return nPartState;
}



//+---------------------------------------------------------------------------
//
//  Member:     CScrollbar::Draw
//              
//  Synopsis:   Draw the scroll bar in the given direction.
//              
//  Arguments:  direction           0 for horizontal, 1 for vertical
//              rcScrollbar         bounds of entire scroll bar
//              rcRedraw            bounds to be redrawn
//              contentSize         size of content controlled by scroll bar
//              containerSize       size of area to scroll within
//              scrollAmount        amount that the content is scrolled
//              partPressed         which part, if any, is pressed
//              hdc                 DC to draw into
//              params              customizable scroll bar parameters
//              pDI                 draw info
//              dwFlags             rendering flags
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CScrollbar::Draw(
        int direction,
        const CRect& rcScrollbar,
        const CRect& rcRedraw,
        long contentSize,
        long containerSize,
        long scrollAmount,
        CScrollbar::SCROLLBARPART partPressed,
        XHDC hdc,
        const CScrollbarParams& params,
        CDrawInfo *pDI,
        DWORD dwFlags)
{
    BOOL    fDisabled;
    int     nVerticalLayoutDirThemed;
    long    scaledButtonWidth;
    BOOL    fUseThemes;
    int     nPartState;

    Assert(hdc != NULL);
    // for now, we're using CDrawInfo, which should have the same hdc
    Assert(pDI->_hdc == hdc);

    // trivial rejection if nothing to draw
    if (!rcScrollbar.Intersects(rcRedraw))
        return;
    
#ifdef _MAC
    DrawMacScrollbar(pDI, direction, (RECT*) &rcScrollbar,
                    contentSize, containerSize, scrollAmount);
    return;
#endif

    fDisabled = (params._fForceDisabled) || (containerSize >= contentSize);
    scaledButtonWidth = GetScaledButtonWidth(direction, rcScrollbar, params._buttonWidth);
    
    // compute rects for buttons and track
    CRect rcTrack(rcScrollbar);
    rcTrack[direction] += scaledButtonWidth;
    rcTrack[direction+2] -= scaledButtonWidth;

    CScrollbarThreeDColors& colors = *params._pColors;

    // If even one color is set through CSS we disable the theming
    fUseThemes = (params._hTheme != NULL) && (!colors.IsAnyColorSet());

    if(fUseThemes && dwFlags & DISPSCROLLBARHINT_VERTICALLAYOUT)
    {
        nVerticalLayoutDirThemed = !direction;
    }
    else
    {
        nVerticalLayoutDirThemed = direction;
    }

    // draw buttons unless requested not to (it's expensive to draw these!)
    if ((dwFlags & DISPSCROLLBARHINT_NOBUTTONDRAW) == 0)
    {
        CRect rcButton[2];
        rcButton[0] = rcScrollbar;
        rcButton[0][direction+2] = rcTrack[direction];
        rcButton[1] = rcScrollbar;
        rcButton[1][direction] = rcTrack[direction+2];
        
        // draw the buttons
        //=======================================================================================
        CSize sizeButton;
        pDI->HimetricFromDevice(
            sizeButton, rcButton[0].Width(), rcButton[0].Height());

        for (int i = 0; i < 2; i++)
        {
            if (rcRedraw.Intersects(rcButton[i]))
            {
                BOOL fButtonPressed =
                    (i == 0 && partPressed == SB_PREVBUTTON) ||
                    (i == 1 && partPressed == SB_NEXTBUTTON);
                
                if(fUseThemes)
                {
                    nPartState = GetThemedScrollbarButtonCode(fDisabled, fButtonPressed, 
                                        direction, !!(dwFlags & DISPSCROLLBARHINT_VERTICALLAYOUT), i);
 
                    Verify(SUCCEEDED(hdc.DrawThemeBackground(params._hTheme, SBP_ARROWBTN,
                                                nPartState, &rcButton[i], NULL)));
                }
                else
                {
                    CUtilityButton scrollButton(params._pColors, params._fFlat);
                    scrollButton.DrawButton(
                        pDI,
                        NULL,   // no hwnd, we don't want to invalidate
                        (direction == 0
                            ? (i == 0 ? BG_LEFT : BG_RIGHT)
                            : (i == 0 ? BG_UP : BG_DOWN)),
                        fButtonPressed,
                        !fDisabled,
                        FALSE,  // never focused
                        rcButton[i],
                        sizeButton,
                        0);     // assume both button glyphs are the same size
                }
            }
        }
    }
    
    // draw track
    if (rcRedraw.Intersects(rcTrack))
    {
        if (fDisabled)
        {
        // draw the disabled scrollbar
        //=======================================================================================
           if(fUseThemes)
           {
                Verify(SUCCEEDED(hdc.DrawThemeBackground(params._hTheme, 
                                        (nVerticalLayoutDirThemed == 0) ? SBP_LOWERTRACKHORZ : SBP_LOWERTRACKVERT,
                                         SCRBS_DISABLED, &rcTrack, NULL)));
           }
           else
           {
               DrawTrack(rcTrack, rcTrack.TopLeft(), FALSE, fDisabled, hdc, params);
           }
        }        
        else
        {
            // calculate thumb rect
            CRect rcThumb;
            GetPartRect(&rcThumb, SB_THUMB, direction, rcScrollbar, contentSize, containerSize,
                scrollAmount, params._buttonWidth, pDI);
                
            // can track contain the thumb?
            if (!rcTrack.Contains(rcThumb))
            {
               if(fUseThemes)
               {
                   // Draw the track
                    Verify(SUCCEEDED(hdc.DrawThemeBackground(params._hTheme, 
                                    (nVerticalLayoutDirThemed == 0) ? SBP_LOWERTRACKHORZ : SBP_LOWERTRACKVERT,
                                    (fDisabled) ? SCRBS_DISABLED : SCRBS_NORMAL, &rcTrack, NULL)));

               }
               else
               {
                    DrawTrack(rcTrack, rcTrack.TopLeft(), FALSE, fDisabled, hdc, params);
               }
            }
            
            else
            {
                //=======================================================================================
                // draw previous track, normal case
                CRect rcTrackPart(rcTrack);
                rcTrackPart[direction+2] = rcThumb[direction];
                if (rcRedraw.Intersects(rcTrackPart))
                {
                   if(fUseThemes)
                   {
                       int nTrackState = GetThemedScrollbarPartState(fDisabled, partPressed, SB_PREVTRACK);
                       Verify(SUCCEEDED(hdc.DrawThemeBackground(params._hTheme, 
                                        (nVerticalLayoutDirThemed == 0) ? SBP_UPPERTRACKHORZ : SBP_UPPERTRACKVERT,
                                        nTrackState, &rcTrackPart, NULL)));
                   }
                   else
                   {
                        DrawTrack(rcTrackPart, rcTrack.TopLeft(), partPressed == SB_PREVTRACK,
                              fDisabled, hdc, params);
                   }
                }
                
                //=======================================================================================
                // draw thumb
                if (rcRedraw.Intersects(rcThumb))
                {
                   if(fUseThemes)
                   {
                       int nThumbState;
                       int nPartId;

                       // DRAW the thumb
                        nThumbState = GetThemedScrollbarPartState(fDisabled, partPressed, SB_THUMB);
                        nPartId = (nVerticalLayoutDirThemed == 0) ? SBP_THUMBBTNHORZ : SBP_THUMBBTNVERT;
                        Verify(SUCCEEDED(hdc.DrawThemeBackground(params._hTheme, nPartId,
                                         nThumbState, &rcThumb, NULL)));

                        // Draw the little thingy on the thumb (gripper)
                        nPartId = (nVerticalLayoutDirThemed == 0) ? SBP_GRIPPERHORZ : SBP_GRIPPERVERT;
                        Verify(SUCCEEDED(hdc.DrawThemeBackground(params._hTheme, nPartId, 
                                         nThumbState, &rcThumb, NULL)));
                   }
                   else
                   {
                       DrawThumb(rcThumb, partPressed == SB_THUMB, hdc, params, pDI );
                   }
                }
                
                //=======================================================================================
                // draw next track
                rcTrackPart = rcTrack;
                rcTrackPart[direction] = rcThumb[direction+2];
                if (rcRedraw.Intersects(rcTrackPart))
                {
                    if(fUseThemes)
                    {
                        int nTrackState = GetThemedScrollbarPartState(fDisabled, partPressed, SB_NEXTTRACK);
                        Verify(SUCCEEDED(hdc.DrawThemeBackground(params._hTheme, 
                                        (nVerticalLayoutDirThemed == 0) ? SBP_LOWERTRACKHORZ : SBP_LOWERTRACKVERT,
                                        nTrackState, &rcTrackPart, NULL)));
                    }
                    else
                    {
                        DrawTrack(rcTrackPart, rcTrack.TopLeft(), partPressed == SB_NEXTTRACK,
                              fDisabled, hdc, params);
                    }
                }
            }
        }
    }
#ifdef UNIX
    //
    // Kind of a copout, but it works
    // We draw the 3D border around the whole scroll bar anytime
    // any part of the scroll bar is updated
    //
    
    IGNORE_HR(BRDrawBorder (
        pDI, (RECT *) &rcScrollbar, fmBorderStyleSunken,
        0, params._pColors, BRFLAGS_MONO ));
#endif
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollbar::DrawTrack
//              
//  Synopsis:   Draw the scroll bar track.
//              
//  Arguments:  rcTrack     bounds of track
//              ptOffset    point used to anchor dither pattern
//              fPressed    TRUE if this portion of track is pressed
//              fDisabled   TRUE if scroll bar is disabled
//              hdc         HDC to draw into
//              params      customizable scroll bar parameters
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CScrollbar::DrawTrack(
        const CRect& rcTrack,
        const CPoint& ptOffset,
        BOOL fPressed,
        BOOL fDisabled,
        XHDC hdc,
        const CScrollbarParams& params)
{
#ifdef _MAC
    return;
#endif
#ifdef UNIX
    {
        ScrollBarInfo info;
        info.lStyle = params._bDirection ? SB_VERT : SB_HORZ;
        info.bDisabled = FALSE;
        MwPaintMotifScrollRect(hdc,
                                LeftTopThumbRect, // It draws both sides.
                                (LPRECT)&rcTrack,
                                FALSE,
                                &info);
        return;
    }
#endif
    
    CScrollbarThreeDColors& colors = *params._pColors;
    HBRUSH       hbr;
    BOOL        fDither = TRUE;
    COLORREF    color1, color2 = 0;
    BOOL        fUseBmpBrush = FALSE;

    fDither = GetDeviceCaps(hdc, BITSPIXEL) < 8 ||            
                colors.BtnHighLight() != GetSysColorQuick(COLOR_SCROLLBAR);
    if(colors.IsTrackColorSet())
    {
        //Use the track color, it has been explicitly set
        color1 = colors.GetTrackColor();
    }
    else if(params._fFlat)
    {
        color1 = colors.BtnFace();
        color2 = (fPressed) ? colors.BtnShadow() : colors.BtnHighLight();
        fUseBmpBrush = TRUE;
    }
    else if(fDither)
    {
        color1 = colors.BtnFace();
        color2 = colors.BtnHighLight();
        if (fPressed)
        {
            color1 ^= 0x00ffffff;
            color2 ^= 0x00ffffff;
        }
        fUseBmpBrush = TRUE;
    }
    else
    {
        color1 = colors.BtnHighLight();
    }

    if(fUseBmpBrush)
    {
        hbr = GetCachedBmpBrush(IDB_DITHER);
        SetTextColor(hdc, color1);
        SetBkColor(hdc, color2);

        // For bitmap brushes need to set the right Brush Origin
        CPoint pt;
        ::GetViewportOrgEx(hdc, &pt);
        pt += ptOffset.AsSize();
#ifndef WINCE
        // not supported on WINCE
        ::UnrealizeObject(hbr);
#endif
        ::SetBrushOrgEx(hdc, POSITIVE_MOD(pt.x,8), POSITIVE_MOD(pt.y,8), NULL);
    }
    else
    {
        if (fPressed)
            color1 ^= 0x00ffffff;
        hbr = ::GetCachedBrush(color1);
    }
    
    HBRUSH hbrOld = (HBRUSH)::SelectObject(hdc, hbr);
    
    ::PatBlt(
           hdc,
           rcTrack.left, rcTrack.top,
           rcTrack.Width(), rcTrack.Height(),
           PATCOPY);
    
    ::SelectObject(hdc, hbrOld);

    // Release only the non-bitmap brushes
    if (!fUseBmpBrush)
        ::ReleaseCachedBrush(hbr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollbar::DrawThumb
//              
//  Synopsis:   Draw scroll bar thumb.
//              
//  Arguments:  rcThumb         bounds of thumb
//              fThumbPressed   TRUE if thumb is pressed
//              hdc             HDC to draw into
//              params          customizable scroll bar parameters
//              pDI             draw info
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CScrollbar::DrawThumb(
        const CRect& rcThumb,
        BOOL fThumbPressed,
        XHDC hdc,
        const CScrollbarParams& params,
        CDrawInfo* pDI)
{
#ifdef _MAC
    return;
#endif

#ifdef UNIX
    {
        ScrollBarInfo info;
        info.lStyle = params._bDirection ? SB_VERT : SB_HORZ;
        info.bDisabled = FALSE;
        MwPaintMotifScrollRect( hdc,
                                ThumbButton,
                                (LPRECT)&rcThumb,
                                FALSE,
                                &info);
        return;
    }
#endif
    
    CRect rcInterior(rcThumb);

    //
    // Draw the border of the thumb
    //

    IGNORE_HR(BRDrawBorder (
        pDI, (RECT *) &rcThumb, fmBorderStyleRaised,
        0, params._pColors,
        (params._fFlat ? BRFLAGS_MONO : 0 )));

    //
    // Calculate the interior of the thumb
    //

    IGNORE_HR(BRAdjustRectForBorder(
        pDI, &rcInterior,
        (params._fFlat ? fmBorderStyleSingle : fmBorderStyleRaised )));

    //
    // Here we draw the interior border of the scrollbar thumb.
    // We assume that the edge is two pixels wide.
    //

    HBRUSH hbr = params._pColors->BrushBtnFace();
    HBRUSH hbrOld = (HBRUSH)::SelectObject(hdc, hbr);
    ::PatBlt(hdc, rcInterior.left, rcInterior.top,
             rcInterior.Width(), rcInterior.Height(), PATCOPY );
    ::SelectObject(hdc, hbrOld);
    ::ReleaseCachedBrush(hbr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollbar::GetPart
//              
//  Synopsis:   Return the scroll bar part hit by the given test point.
//              
//  Arguments:  direction       0 for horizontal scroll bar, 1 for vertical
//              rcScrollbar     scroll bar bounds
//              ptHit           test point
//              contentSize     size of content controlled by scroll bar
//              containerSize   size of container
//              scrollAmount    current scroll amount
//              buttonWidth     width of scroll bar buttons
//              
//  Returns:    The scroll bar part hit, or SB_NONE if nothing was hit.
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

CScrollbar::SCROLLBARPART
CScrollbar::GetPart(
        int direction,
        const CRect& rcScrollbar,
        const CPoint& ptHit,
        long contentSize,
        long containerSize,
        long scrollAmount,
        long buttonWidth,
        CDrawInfo* pDI)
{
    if (!rcScrollbar.Contains(ptHit))
        return SB_NONE;
    
#ifdef _MAC
    return GetMacScrollPart(pDI, direction, ptHit);
#endif
   
    // adjust button width if there isn't room for both buttons at full size
    long scaledButtonWidth =
        GetScaledButtonWidth(direction, rcScrollbar, buttonWidth);
    
    // now test just the axis that matters
    long x = ptHit[direction];
    
    if (x < rcScrollbar.TopLeft()[direction] + scaledButtonWidth)
        return SB_PREVBUTTON;
    
    if (x >= rcScrollbar.BottomRight()[direction] - scaledButtonWidth)
        return SB_NEXTBUTTON;
    
    // NOTE: if there is no thumb, return SB_TRACK
    CRect rcThumb;
    GetPartRect(
        &rcThumb,
        SB_THUMB,
        direction,
        rcScrollbar,
        contentSize,
        containerSize,
        scrollAmount,
        buttonWidth,
        pDI);
    if (rcThumb.IsEmpty())
        return SB_TRACK;
     
    if (x < rcThumb.TopLeft()[direction])
        return SB_PREVTRACK;
    if (x >= rcThumb.BottomRight()[direction])
        return SB_NEXTTRACK;
    
    return SB_THUMB;
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollbar::GetPartRect
//              
//  Synopsis:   Return the rect bounding the given scroll bar part.
//              
//  Arguments:  prcPart         returns part rect
//              part            which scroll bar part
//              direction       0 for horizontal scroll bar, 1 for vertical
//              rcScrollbar     scroll bar bounds
//              contentSize     size of content controlled by scroll bar
//              containerSize   size of container
//              scrollAmount    current scroll amount
//              buttonWidth     width of scroll bar buttons
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CScrollbar::GetPartRect(
        CRect* prcPart,
        CScrollbar::SCROLLBARPART part,
        int direction,
        const CRect& rcScrollbar,
        long contentSize,
        long containerSize,
        long scrollAmount,
        long buttonWidth,
        CDrawInfo* pDI)
{
    // adjust button width if there isn't room for both buttons at full size
    long scaledButtonWidth =
        GetScaledButtonWidth(direction, rcScrollbar, buttonWidth);
    
    switch (part)
    {
    case SB_NONE:
        AssertSz(FALSE, "CScrollbar::GetPartRect called with no part");
        prcPart->SetRectEmpty();
        break;
        
    case SB_PREVBUTTON:
        *prcPart = rcScrollbar;
        (*prcPart)[direction+2] = rcScrollbar[direction] + scaledButtonWidth;
        break;
        
    case SB_NEXTBUTTON:
        *prcPart = rcScrollbar;
        (*prcPart)[direction] = rcScrollbar[direction+2] - scaledButtonWidth;
        break;
        
    case SB_TRACK:
    case SB_PREVTRACK:
    case SB_NEXTTRACK:
    case SB_THUMB:
        {
            if (contentSize <= containerSize && part != SB_TRACK)
            {
                prcPart->SetRectEmpty();
                break;
            }
            
            *prcPart = rcScrollbar;
            (*prcPart)[direction] += scaledButtonWidth;
            (*prcPart)[direction+2] -= scaledButtonWidth;
            if (part == SB_TRACK)
                break;
            
            // calculate thumb size
            long trackSize = prcPart->Size(direction);
            long thumbSize = GetThumbSize(
                direction, rcScrollbar, contentSize, containerSize, buttonWidth, pDI);
            long thumbOffset = GetThumbOffset(
                contentSize, containerSize, scrollAmount, trackSize, thumbSize);
            
            if (part == SB_THUMB)
            {
                (*prcPart)[direction] += thumbOffset;
                (*prcPart)[direction+2] = (*prcPart)[direction] + thumbSize;
            }
            else if (part == SB_PREVTRACK)
            {
                    (*prcPart)[direction+2] = (*prcPart)[direction] + thumbOffset;
            }
            else
            {
                    (*prcPart)[direction] += thumbOffset + thumbSize;
            }
        }
        break;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollbar::InvalidatePart
//              
//  Synopsis:   Invalidate and immediately redraw the indicated scrollbar part.
//              
//  Arguments:  part                part to redraw
//              direction           0 for horizontal scroll bar, 1 for vertical
//              rcScrollbar         scroll bar bounds
//              contentSize         size of content controlled by scroll bar
//              containerSize       size of container
//              scrollAmount        current scroll amount
//              buttonWidth         width of scroll bar buttons
//              pDispNodeToInval    display node to invalidate
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CScrollbar::InvalidatePart(
        CScrollbar::SCROLLBARPART part,
        int direction,
        const CRect& rcScrollbar,
        long contentSize,
        long containerSize,
        long scrollAmount,
        long buttonWidth,
        CDispScroller* pDispNodeToInval,
        CDrawInfo* pDI)
{
    // find bounds of part
    CRect rcPart;
    GetPartRect(
        &rcPart,
        part,
        direction,
        rcScrollbar,
        contentSize,
        containerSize,
        scrollAmount,
        buttonWidth,
        pDI);

    pDispNodeToInval->Invalidate(rcPart, COORDSYS_BOX, TRUE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollbar::GetThumbSize
//              
//  Synopsis:   Calculate the thumb size given the adjusted button width.
//              
//  Arguments:  direction           0 for horizontal scroll bar, 1 for vertical
//              rcScrollbar         scroll bar bounds
//              contentSize         size of content controlled by scroll bar
//              containerSize       size of container
//              buttonWidth         width of scroll bar buttons
//              
//  Returns:    width of thumb in pixels
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

long
CScrollbar::GetThumbSize(
        int direction,
        const CRect& rcScrollbar,
        long contentSize,
        long containerSize,
        long buttonWidth,
        CDrawInfo* pDI)
{
#ifdef _MAC
    return 16; // fixed size thumb
#endif
    long thumbSize = direction == 0
             ? pDI->DeviceFromHimetricX(HIMETRIC_PER_INCH*8/72)
             : pDI->DeviceFromHimetricY(HIMETRIC_PER_INCH*8/72);

    long trackSize = GetTrackSize(direction, rcScrollbar, buttonWidth);
    // minimum thumb size is 8 points for
    // compatibility with IE4.
    
    // [alanau] For some reason, I can't put two ternery expressions in a "max()", so it's coded this clumsy way:
    //
    if (contentSize) // Avoid divide-by-zero fault.
    {
        int t = IntFloor(double(trackSize) * containerSize / contentSize);
                // NOTE: (mikhaill) -- IntNear() is more natural but Robovision machines do not agree
        if (thumbSize < t)
            thumbSize = t;
    }
    return (thumbSize <= trackSize ? thumbSize : 0);
}



// This class holds colors used for scrollbar painting
CScrollbarThreeDColors::CScrollbarThreeDColors(CTreeNode *pNode, XHDC *pxhdc, OLE_COLOR coInitialBaseColor) 
    :   ThreeDColors(pxhdc, coInitialBaseColor)
{
    _fBaseColorSet = _fFaceColorSet = _fLightColorSet = _fArrowColorSet =
            _fShadowColorSet = _fHighLightColorSet = _fDkShadowColorSet = 
            _fTrackColorSet = 0;
    Assert(pNode != NULL);
    if(!g_fHighContrastMode && pNode && pNode->GetCascadedhasScrollbarColors())
    {
        CColorValue cv;
        
        cv = pNode->GetScrollbarBaseColor();
        if(cv.IsDefined())
        {
            SetBaseColor(cv.GetOleColor());
        }
        cv = pNode->GetScrollbarArrowColor();
        if(cv.IsDefined())
        {
            _fArrowColorSet = TRUE;
            _coArrowColor = cv.GetColorRef();
        }
        cv = pNode->GetScrollbarTrackColor();
        if(cv.IsDefined())
        {
            _fTrackColorSet = TRUE;
            _coTrackColor = cv.GetColorRef();
        }
        cv = pNode->GetScrollbarFaceColor();
        if(cv.IsDefined())
        {
            _fFaceColorSet = TRUE;
            _coBtnFace = cv.GetColorRef();
        }
        cv = pNode->GetScrollbar3dLightColor();
        if(cv.IsDefined())
        {
            _fLightColorSet = TRUE;
            _coBtnLight = cv.GetColorRef();
        }
        cv = pNode->GetScrollbarShadowColor();
        if(cv.IsDefined())
        {
            _fShadowColorSet = TRUE;
            _coBtnShadow = cv.GetColorRef();
        }
        cv = pNode->GetScrollbarDarkShadowColor();
        if(cv.IsDefined())
        {
            _fDkShadowColorSet = TRUE;
            _coBtnDkShadow = cv.GetColorRef();
        }
        cv = pNode->GetScrollbarHighlightColor();
        if(cv.IsDefined())
        {
            _fHighLightColorSet = TRUE;
            _coBtnHighLight = cv.GetColorRef();
        }
    }
    
}


COLORREF 
CScrollbarThreeDColors::BtnFace(void)
{
    if(_fFaceColorSet)
        return _coBtnFace;

    return ThreeDColors::BtnFace();
}

COLORREF 
CScrollbarThreeDColors::BtnLight(void)
{
    if(_fLightColorSet )
        return _coBtnLight;

    return ThreeDColors::BtnLight();
}

COLORREF
CScrollbarThreeDColors::BtnShadow(void)
{
    if(_fShadowColorSet)
        return _coBtnShadow;

    return ThreeDColors::BtnShadow();
}

COLORREF
CScrollbarThreeDColors::BtnHighLight(void)
{
    if(_fHighLightColorSet)
        return _coBtnHighLight;

    return ThreeDColors::BtnHighLight();
}

COLORREF
CScrollbarThreeDColors::BtnDkShadow(void)
{
    if(_fDkShadowColorSet)
        return _coBtnDkShadow;

    return ThreeDColors::BtnDkShadow();
}


// This is used as the Arrow color for the scroll bar
COLORREF 
CScrollbarThreeDColors::BtnText ( void )
{ 
    if(_fArrowColorSet)
        return _coArrowColor;
    // Use the system value
     return ThreeDColors::BtnText();
}


// This override just saves the color so that the currentStyle can get it
// and then calls the parent
void 
CScrollbarThreeDColors::SetBaseColor(OLE_COLOR clr)
{
    _fBaseColorSet = TRUE;
    _coBaseColor = clr;
    ThreeDColors::SetBaseColor(clr);
}
    

CColorValue
CTreeNode::GetScrollBarComponentColorHelper(DISPID dispid)
{
    HRESULT     hr;
    CVariant    var;
    CColorValue cv;
    
    if(!GetCascadedhasScrollbarColors())
       // No scroll bar colors are set
        goto Cleanup;
    
    // Climb up the element tree applying the style to find a match for diven dispid
    hr = THR(Element()->ComputeExtraFormat(dispid, 
            ComputeFormatsType_GetInheritedIntoTableValue, this, &var));
    if(hr)
        goto Cleanup;

    if(!var.IsEmpty())
    {
       cv = (CColorValue&) V_I4(&var);
    }

Cleanup:
    return cv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\layout\marqlyt.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       marqlyt.cxx
//
//  Contents:   Implementation of CMarqueeLayout
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_MARQLYT_HXX_
#define X_MARQLYT_HXX_
#include "marqlyt.hxx"
#endif

#ifndef X_TASKMAN_HXX_
#define X_TASKMAN_HXX_
#include "taskman.hxx"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_MARQUEE_HXX_
#define X_MARQUEE_HXX_
#include "marquee.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif


MtDefine(CMarqueeLayout, Layout, "CMarqueeLayout")

const CLayout::LAYOUTDESC CMarqueeLayout::s_layoutdesc =
{
    LAYOUTDESC_NOSCROLLBARS |
    LAYOUTDESC_FLOWLAYOUT,          // _dwFlags
};

HRESULT
CMarqueeLayout::Init()
{
    HRESULT hr = super::Init();

    if(hr)
        goto Cleanup;

    // Marquee can NOT be broken
    SetElementCanBeBroken(FALSE);

Cleanup:
    RRETURN(hr);
}

void
CMarqueeLayout::GetMarginInfo(CParentInfo * ppri,
                              LONG        * plLMargin,
                              LONG        * plTMargin,
                              LONG        * plRMargin,
                              LONG        * plBMargin)
{
    super::GetMarginInfo(ppri, plLMargin, plTMargin, plRMargin, plBMargin);

    CMarquee * pMarquee  = DYNCAST(CMarquee, ElementOwner());
    BOOL fParentVertical = pMarquee->GetFirstBranch()->IsParentVertical();
    LONG lhMargin = fParentVertical ? pMarquee->GetAAvspace() : pMarquee->GetAAhspace();
    LONG lvMargin = fParentVertical ? pMarquee->GetAAhspace() : pMarquee->GetAAvspace();

    if (lhMargin < 0)
        lhMargin = 0;
    if (lvMargin < 0)
        lvMargin = 0;

    lhMargin = ppri->DeviceFromDocPixelsX(lhMargin);
    lvMargin = ppri->DeviceFromDocPixelsY(lvMargin);

    if (plLMargin)
        *plLMargin += lhMargin;
    if (plRMargin)
        *plRMargin += lhMargin;
    if (plTMargin)
        *plTMargin += lvMargin;
    if (plBMargin)
        *plBMargin += lvMargin;
}

void CMarqueeLayout::GetDefaultSize(CCalcInfo *pci, SIZE &szMarquee, BOOL *fHasDefaultWidth, BOOL *fHasDefaultHeight)
{
    CMarquee   * pMarquee = DYNCAST(CMarquee, ElementOwner());
    if ( pMarquee->_direction == htmlMarqueeDirectionup
            ||  pMarquee->_direction == htmlMarqueeDirectiondown)
    {
       szMarquee.cy = pci->DeviceFromDocPixelsY(200);
       *fHasDefaultHeight = TRUE;
    }
    else
    {
       szMarquee.cy = 0;
    }
}

void CMarqueeLayout::GetScrollPadding(SIZE &szMarquee)
{
    CMarquee   * pMarquee = DYNCAST(CMarquee, ElementOwner());
    if ( pMarquee->_direction == htmlMarqueeDirectionup
            ||  pMarquee->_direction == htmlMarqueeDirectiondown)
    {
        szMarquee.cx = 0;
        pMarquee->_lXMargin = 0;
        pMarquee->_lYMargin = szMarquee.cy;
            
        GetDisplay()->SetWordWrap(TRUE);

    }
    else
    {
        szMarquee.cy = 0;
        pMarquee->_lYMargin = 0;
        pMarquee->_lXMargin = szMarquee.cx;

        GetDisplay()->SetWordWrap(FALSE);
    }
}

void CMarqueeLayout::SetScrollPadding(SIZE &szMarquee, SIZE &sizeText, SIZE &sizeBorder)
{
    CMarquee   * pMarquee = DYNCAST(CMarquee, ElementOwner());
    pMarquee->_sizeScroll.cx    = sizeText.cx - sizeBorder.cx;
    pMarquee->_sizeScroll.cy    = sizeText.cy - sizeBorder.cy;
    pMarquee->_fToBigForSwitch  = (sizeText.cx-szMarquee.cx*2) >= szMarquee.cx;

    pMarquee->InitScrollParams();
}

void CMarqueeLayout::CalcTextSize(CCalcInfo *pci, SIZE *psize, SIZE *psizeDefault)
{
    if (   pci->_smMode == SIZEMODE_MMWIDTH
        || pci->_smMode == SIZEMODE_MINWIDTH)
    {
        const CFancyFormat * pFF     = GetFirstBranch()->GetFancyFormat(LC_TO_FC(LayoutContext()));
        const CCharFormat  * pCF     = GetFirstBranch()->GetCharFormat(LC_TO_FC(LayoutContext()));
        BOOL fVerticalLayoutFlow     = pCF->HasVerticalLayoutFlow();
        BOOL fWritingModeUsed        = pCF->_fWritingModeUsed;
        const CUnitValue & cuvWidth  = pFF->GetLogicalWidth(fVerticalLayoutFlow, fWritingModeUsed);

        if  ( cuvWidth.IsNullOrEnum())
        {
            psize->cx = 0;
            psize->cy = 0;
        }
    }
    else
    {
        super::CalcTextSize(pci, psize, psizeDefault);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\layout\scrollbarcontroller.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Internet Explorer
//  Copyright (C) Microsoft Corporation, 1997-1998
//
//  File:       scrollbarcontroller.cxx
//
//  Contents:   Transient object to control scroll bar during user interaction.
//
//  Classes:    CScrollbarController
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_SCROLLBARCONTROLLER_HXX_
#define X_SCROLLBARCONTROLLER_HXX_
#include "scrollbarcontroller.hxx"
#endif

#ifndef X_DISPSCROLLER_HXX_
#define X_DISPSCROLLER_HXX_
#include "dispscroller.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_CDBASE_HXX_
#define X_CDBASE_HXX_
#include "cdbase.hxx"
#endif

#ifdef _MAC
#ifndef X_MACCONTROLS_HXX_
#define X_MACCONTROLS_HXX_
#include "maccontrols.h"
#endif
#endif

//
// This is the "timer ID" which will be used when the user has pressed
// either one of the scrollbar buttons, or the paging areas, to time
// the repeat rate for scrolling.
//

#define SB_REPEAT_TIMER 1


MtDefine(THREADSTATE_pSBC, THREADSTATE, "THREADSTATE::_pSBC")


//+----------------------------------------------------------------------------
//
//  Function:   InitScrollbar
//
//  Synopsis:   Allocate scrollbar helper
//
//  Arguments:  pts - THREADSTATE for current thread
//
//  Returns:    S_OK, E_OUTOFMEMORY
//
//-----------------------------------------------------------------------------
HRESULT
InitScrollbar(
    THREADSTATE *   pts)
{
    Assert(pts);

    pts->pSBC = new (Mt(THREADSTATE_pSBC)) CScrollbarController();
    if (!pts->pSBC)
        RRETURN(E_OUTOFMEMORY);
    RRETURN(S_OK);
}


//+----------------------------------------------------------------------------
//
//  Function:   DeinitScrollbar
//
//  Synopsis:   Delete scrollbar helper
//
//  Arguments:  pts - THREADSTATE for current thread
//
//-----------------------------------------------------------------------------
void
DeinitScrollbar(
    THREADSTATE *   pts)
{
    Assert(pts);
    delete pts->pSBC;
}


//+---------------------------------------------------------------------------
//
//  Function:   InitScrollbarTiming
//
//  Synopsis:   Get scrollbar's timing info into a thread local storage
//              scrollTimeInfo structure
//
//----------------------------------------------------------------------------

void
InitScrollbarTiming()
{
    THREADSTATE * pts = GetThreadState();

    Assert (pts);
    Assert (pts->pSBC);

    pts->scrollTimeInfo.lRepeatDelay = pts->pSBC->GetRepeatDelay ();
    pts->scrollTimeInfo.lRepeatRate  = pts->pSBC->GetRepeatRate ();
    pts->scrollTimeInfo.lFocusRate   = pts->pSBC->GetFocusRate ();
}


static UINT
TranslateSBAction(CScrollbar::SCROLLBARPART part)
{
    switch (part)
    {
    case CScrollbar::SB_PREVBUTTON: return SB_LINEUP;
    case CScrollbar::SB_NEXTBUTTON: return SB_LINEDOWN;
    case CScrollbar::SB_PREVTRACK:  return SB_PAGEUP;
    case CScrollbar::SB_NEXTTRACK:  return SB_PAGEDOWN;
    case CScrollbar::SB_THUMB:      return SB_THUMBPOSITION;
    default:                        Assert(FALSE); break;
    }
    
    // here only on error
    return SB_LINEUP;
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollbarController::StartScrollbarController
//              
//  Synopsis:   Start a scroll bar controller if necessary.
//              
//  Arguments:  pLayout         layout object to be called on scroll changes
//              pDispScroller   display scroller node
//              pServerHost     server host
//              buttonWidth     custom scroll bar button width
//              pMessage        message that caused creation of controller
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CScrollbarController::StartScrollbarController(
        CLayout* pLayout,
        CDispScroller* pDispScroller,
        CServer* pServerHost,
        long buttonWidth,
        CMessage* pMessage)
{
    Assert(pLayout != NULL);
    Assert(pDispScroller != NULL);
    Assert(pServerHost != NULL);
    Assert(pMessage != NULL);
    BOOL fScrollToHere = FALSE;
    BOOL fContextMenu;

    CScrollbarController* pSBC = TLS(pSBC);
    Assert(pSBC != NULL);
   
    // just to make sure previous controller is stopped
    if (pSBC->_pLayout != NULL)
    {
        StopScrollbarController();
    }
   
#ifdef UNIX
    if (pMessage->dwKeyState & (MK_CONTROL | MK_SHIFT | MK_ALT))
    {
        if (pMessage->message == WM_MBUTTONDOWN ||
            (pMessage->dwKeyState & MK_CONTROL) != MK_CONTROL)
            return;
    }
#endif
 
    pSBC->_direction = (pMessage->htc == HTC_HSCROLLBAR ? 0 : 1);
    pSBC->_pDispScroller = pDispScroller;
    pSBC->_drawInfo.Init(pLayout->ElementOwner());
    
    // calculate scroll bar rect
    pDispScroller->GetClientRect(
        &pSBC->_rcScrollbar,
        (pSBC->_direction == 0
            ? CLIENTRECT_HSCROLLBAR
            : CLIENTRECT_VSCROLLBAR));
    Assert(pSBC->_rcScrollbar.Contains(pMessage->ptContent));
    
    LONG contentSize, containerSize, scrollAmount;
    pSBC->GetScrollInfo(&contentSize, &containerSize, &scrollAmount);
    
    // if the scrollbar is inactive, it doesn't matter what was pressed
    if (contentSize <= containerSize)
        return;

    // what was pressed?
    pSBC->_partPressed = GetPart(
        pSBC->_direction,
        pSBC->_rcScrollbar,
        pMessage->ptContent,
        contentSize,
        containerSize,
        scrollAmount,
        buttonWidth,
        pSBC->GetDrawInfo());
    Assert(pSBC->_partPressed != SB_NONE);

    // treat ContextMenu like a thumb, in case user selects ScrollToHere
    fContextMenu = (pMessage->message == WM_CONTEXTMENU);
    if (fContextMenu)
    {
        pSBC->_partPressed = SB_THUMB;
    }
    
    // if inactive track was pressed, no more work to do
    if (pSBC->_partPressed == SB_TRACK)
        return;
    
    // make scroll bar controller active
    pSBC->_partPressedStart = pSBC->_partPressed;
    pSBC->_pLayout = pLayout;
    pSBC->_pDispScroller = pDispScroller;
    pSBC->_pServerHost = pServerHost;
    pSBC->_buttonWidth = buttonWidth;
    pSBC->_ptMouse = pMessage->ptContent;
   
    LONG lScrollTime = MAX_SCROLLTIME;

    // Handle special actions
#ifndef UNIX
    if (pMessage->dwKeyState & MK_SHIFT)
    {
        switch (pSBC->_partPressed)
        {
        case CScrollbar::SB_PREVTRACK:
        case CScrollbar::SB_THUMB:
        case CScrollbar::SB_NEXTTRACK:
            // shift-click is treated just like thumb: "scroll to here"
            pSBC->_partPressedStart = pSBC->_partPressed = SB_THUMB;
            fScrollToHere = TRUE;
            break;
        default:
            break;
        }
    }
#else // Handle UNIX motif scrollbar's special actions. 
    // Is MK_CONTROL pressed?
    if (pMessage->dwKeyState & MK_CONTROL)
    {
        switch (pSBC->_partPressed)
        {
        case CScrollbar::SB_PREVBUTTON:
        case CScrollbar::SB_PREVTRACK:
            pLayout->OnScroll(pSBC->_direction, SB_TOP, 0);
            break;
        case CScrollbar::SB_NEXTBUTTON:
        case CScrollbar::SB_NEXTTRACK:
            pLayout->OnScroll(pSBC->_direction, SB_BOTTOM, 0);
            break;
        }
        return;
    }
    if (pMessage->message == WM_MBUTTONDOWN)
    {
        pSBC->MoveThumb(pMessage->pt);
        pSBC->GetScrollInfo(&contentSize, &containerSize, &scrollAmount);
        pSBC->_partPressedStart = pSBC->_partPressed = SB_THUMB;
    }
#endif // UNIX

    // if thumbing, compute hit point offset from top of thumb
    if (pSBC->_partPressed == SB_THUMB)
    {
        long trackSize = GetTrackSize(
            pSBC->_direction, pSBC->_rcScrollbar, pSBC->_buttonWidth);
        long thumbSize = GetThumbSize(
            pSBC->_direction, pSBC->_rcScrollbar, contentSize, containerSize,
            pSBC->_buttonWidth, pSBC->GetDrawInfo());
        // _mouseInThumb is the xPos of the mouse in from the left edge of the thumb in LTR cases
        // and xPos of the mouse in from the right edge of the thumb in RTL HSCROLL cases
        if (fScrollToHere || fContextMenu)
        {
            pSBC->_mouseInThumb = thumbSize / 2;
        }
        else
        {
            pSBC->_mouseInThumb = 
                pSBC->_ptMouse[pSBC->_direction] -
                pSBC->_rcScrollbar[pSBC->_direction] -
                GetScaledButtonWidth(pSBC->_direction, pSBC->_rcScrollbar, pSBC->_buttonWidth) -
                GetThumbOffset(contentSize, containerSize, scrollAmount, trackSize, thumbSize);
        }
        Assert(pSBC->_mouseInThumb >= 0);

        // ScrollToHere works as if the thumb started in the current mouse position
        if (fScrollToHere)
        {
            pSBC->MouseMove(pMessage->pt);
        }
        
        // remember starting offset, in case mouse gets too far from scrollbar
        CSize sizeOffsetCurrent;
        pDispScroller->GetScrollOffset(&sizeOffsetCurrent);
        pSBC->_scrollOffsetStart = sizeOffsetCurrent[pSBC->_direction];
        
        // no smooth scrolling
        lScrollTime = 0;
    }

    // for ContextMenu, just popup the menu.  The callbacks take care of the rest
    if (fContextMenu)
    {
        pSBC->_partPressed = SB_CONTEXTMENU;
        IGNORE_HR(pLayout->ElementOwner()->OnContextMenu(
                (short) LOWORD(pMessage->lParam),
                (short) HIWORD(pMessage->lParam),
                pSBC->_direction ? CONTEXT_MENU_VSCROLL : CONTEXT_MENU_HSCROLL));
        StopScrollbarController();
        return;
    }
    
    // capture the mouse
    Assert(pServerHost->State() >= OS_INPLACE);
    HWND hwnd = pServerHost->_pInPlace->_hwnd;
    if (!hwnd)
    {
        IGNORE_HR(pServerHost->_pInPlace->_pInPlaceSite->GetWindow(&hwnd));
    }
#ifdef _MAC
    TrackMacScroll(pSBC, pServerHost, pMessage->ptContent, pSBC->_direction, pSBC->_partPressed);
#else
    if (FAILED(GWSetCapture(
            pSBC,
            ONMESSAGE_METHOD(CScrollbarController, OnMessage, onmessage),
            hwnd)))
    {
        pSBC->_pLayout = NULL;
        return;
    }
 
    // set timer for repeating actions
    if (pSBC->_partPressed != SB_THUMB)
    {
        // set timer for subsequent action
        // This must happen before OnScroll, in case the onscroll handler does
        // something to pump the message loop, call back to our OnMessage,
        // and try to kill the timer.
        FormsSetTimer(
            pSBC,
            ONTICK_METHOD(CScrollbarController, OnTick, ontick),
            SB_REPEAT_TIMER,
            GetRepeatDelay() );

        // perform first action
        pLayout->OnScroll(
            pSBC->_direction, TranslateSBAction(pSBC->_partPressed), 0, FALSE, lScrollTime);

        // CAUTION: the OnScroll method may cause StopScrollbarController
        // to be called, in which case we need to get outta here.
        if (pSBC->_pLayout != pLayout)
            return;
        Assert(pSBC->_pLayout->GetElementDispNode() == pSBC->_pDispScroller);

        CSize scrollOffset;
        pSBC->_pDispScroller->GetScrollOffset(&scrollOffset);
        scrollAmount = scrollOffset[pSBC->_direction];
    }
    
    // invalidate the part we hit, if necessary
    pLayout->OpenView();
    InvalidatePart(
        pSBC->_partPressed,
        pSBC->_direction,
        pSBC->_rcScrollbar,
        contentSize,
        containerSize,
        scrollAmount,
        buttonWidth,
        pDispScroller,
        pSBC->GetDrawInfo());
#endif // _MAC
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollbarController::StopScrollbarController
//              
//  Synopsis:   Stop an existing scroll bar controller.
//              
//  Arguments:  none
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CScrollbarController::StopScrollbarController()
{
    CScrollbarController* pSBC = TLS(pSBC);
    Assert(pSBC != NULL);
    
    if (pSBC->_pLayout != NULL)
    {
        // report scroll change to layout, which will take care of
        // invalidation

        pSBC->_pLayout->OnScroll(pSBC->_direction, SB_ENDSCROLL, 0);

        // do this before GWReleaseCapture, or StopScrollbarController
        // will be called recursively
        pSBC->_pLayout = NULL;

        // if we started from a context menu, there's no timer or capture
        if (pSBC->_partPressed == SB_CONTEXTMENU)
            return;

        if (pSBC->_partPressed != SB_THUMB)
        {
            FormsKillTimer(pSBC, SB_REPEAT_TIMER);
        }
#ifndef _MAC
        GWReleaseCapture(pSBC);
#endif
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollbarController::OnMessage
//              
//  Synopsis:   Handle messages sent to this scroll bar controller.
//              
//  Arguments:  
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

LRESULT
CScrollbarController::OnMessage(UINT msg, WPARAM wParam, LPARAM lParam)
{
    //
    // If the serverhost somehow went into the running state
    // just terminate capture and bail out.  This could happen
    // because of asynchronous activation/deactivation (as in IE)
    //
    if (_pServerHost->State() < OS_INPLACE)
        goto Terminate;
    
    switch (msg)
    {
    case WM_MOUSEMOVE:
        MouseMove( CPoint( MAKEPOINTS(lParam).x, MAKEPOINTS(lParam).y ) );
        break;

    case WM_LBUTTONDBLCLK:
    case WM_LBUTTONDOWN:
        AssertSz(FALSE, "CScrollbarController got unexpected message");
        break;

#ifdef UNIX
    case WM_MBUTTONUP:
#endif
    case WM_LBUTTONUP:
        if (_partPressed != SB_NONE)
        {
            // invalidate just the part that was pressed
            _partPressed = SB_NONE;
            CSize scrollOffset;
            _pDispScroller->GetScrollOffset(&scrollOffset);
            LONG containerSize = _rcScrollbar.Size(_direction);
            Verify(_pLayout->OpenView());
            InvalidatePart(
                _partPressedStart,
                _direction,
                _rcScrollbar,
                _pDispScroller->GetContentSize()[_direction],
                containerSize,
                scrollOffset[_direction],
                _buttonWidth,
                _pDispScroller,
                &_drawInfo);
        }
        
        // fall thru to Terminate...

    case WM_CAPTURECHANGED:
        goto Terminate;
    }
    
    return 0;
    
Terminate:
    StopScrollbarController();
    return 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollbarController::MouseMove
//              
//  Synopsis:   Handle mouse move events.
//              
//  Arguments:  pt      new mouse location
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CScrollbarController::MouseMove(const CPoint& pt)
{
    _pDispScroller->TransformPoint(
        pt,
        COORDSYS_GLOBAL,
        &_ptMouse,
        COORDSYS_BOX);
    
    switch (_partPressedStart)
    {
    case SB_NONE:
    case SB_TRACK:
        AssertSz(FALSE, "unexpected call to CScrollbarController::MouseMoved");
        break;
        
    case SB_THUMB:
        {
            LONG contentSize = _pDispScroller->GetContentSize()[_direction];
            Assert(contentSize >= 0);
            LONG trackSize =
                GetTrackSize(_direction, _rcScrollbar, _buttonWidth) -
                GetThumbSize(_direction, _rcScrollbar, contentSize,
                             _rcScrollbar.Size(_direction), _buttonWidth,
                             &_drawInfo);
            if (trackSize <= 0)
                break;  // can't move thumb

            // check to see if the mouse point
            // is out of range perpendicular to the scroll bar axis
            if (_ptMouse[!_direction] < _rcScrollbar[!_direction] - g_lScrollGutterRatio * _buttonWidth ||
                _ptMouse[!_direction] > _rcScrollbar[2 + !_direction] + g_lScrollGutterRatio * _buttonWidth)
            {
                // if it is, scroll back to where we started
                _pLayout->OnScroll(_direction, SB_THUMBPOSITION, _scrollOffsetStart);
                break;
            }

            LONG trackPos = _ptMouse[_direction] -
                            _rcScrollbar[_direction] -
                            GetScaledButtonWidth(_direction, _rcScrollbar, _buttonWidth) -
                            _mouseInThumb;
            
            LONG scrollOffset;
            if (trackPos <= 0)
            {
                scrollOffset = 0;
            }
            else
            {
                contentSize -= _rcScrollbar.Size(_direction);
                scrollOffset = MulDivQuick(trackPos, contentSize, trackSize);
            }
            
            _pLayout->OnScroll(_direction, SB_THUMBPOSITION, scrollOffset);
        }
        break;
        
    default:
        {
            // find out what the mouse would be pressing in its new location.
            // If it's not the same as it used to be, invalidate the part.
            SCROLLBARPART partPressedOld = _partPressed;
            LONG contentSize, containerSize, scrollAmount;
            GetScrollInfo(&contentSize, &containerSize, &scrollAmount);
            _partPressed = GetPart(
                _direction,
                _rcScrollbar,
                _ptMouse,
                contentSize,
                containerSize,
                scrollAmount,
                _buttonWidth,
                &_drawInfo);
            if (_partPressed != _partPressedStart)
            {
                _partPressed = SB_NONE;
            }
            if (_partPressed != partPressedOld)
            {
                SCROLLBARPART invalidPart = _partPressed;
                if (_partPressed != SB_NONE)
                {
                    // perform scroll action and set timer
                    OnTick(SB_REPEAT_TIMER);
                }
                else
                {
                    invalidPart = partPressedOld;
                }
                Verify(_pLayout->OpenView());
                InvalidatePart(
                    invalidPart,
                    _direction,
                    _rcScrollbar,
                    contentSize,
                    containerSize,
                    scrollAmount,
                    _buttonWidth,
                    _pDispScroller,
                    &_drawInfo);
            }
        }
        break;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollbarController::DoContextMenuScroll
//              
//  Synopsis:   Handle scroll commands from the context menu
//              
//  Arguments:  idm     menu command
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CScrollbarController::DoContextMenuScroll(UINT idm)
{
    Assert(_partPressed == SB_CONTEXTMENU);
    UINT uiCode = SB_TOP;

    switch (idm)
    {
    case IDM_SCROLL_HERE:
    {
        CPoint ptgMouse;
        _pDispScroller->TransformPoint(
            _ptMouse,
            COORDSYS_BOX,
            &ptgMouse,
            COORDSYS_GLOBAL);
        MouseMove(ptgMouse);
        return;
    }
    case IDM_SCROLL_TOP:
    case IDM_SCROLL_LEFTEDGE:
        uiCode = SB_TOP;
        break;
    case IDM_SCROLL_BOTTOM:
    case IDM_SCROLL_RIGHTEDGE:
        uiCode = SB_BOTTOM;
        break;
    case IDM_SCROLL_PAGEUP:
    case IDM_SCROLL_PAGELEFT:
        uiCode = SB_PAGEUP;
        break;
    case IDM_SCROLL_PAGEDOWN:
    case IDM_SCROLL_PAGERIGHT:
        uiCode = SB_PAGEDOWN;
        break;
    case IDM_SCROLL_UP:
    case IDM_SCROLL_LEFT:
        uiCode = SB_LINEUP;
        break;
    case IDM_SCROLL_DOWN:
    case IDM_SCROLL_RIGHT:
        uiCode = SB_LINEDOWN;
        break;
    }
    
    _pLayout->OnScroll(_direction, uiCode, 0);
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollbarController::OnTick
//              
//  Synopsis:   Handle mouse timer ticks to implement repeated scroll actions
//              and focus blinking.
//              
//  Arguments:  id      timer event type
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

HRESULT
CScrollbarController::OnTick(UINT id)
{
    // for now, SB_REPEAT_TIMER is the only id we use
    Assert(id == SB_REPEAT_TIMER);
    
    // timer tick snuck through right before we disabled it
    if (_pLayout == NULL)
        return S_OK;

    if (id == SB_REPEAT_TIMER)
    {
        if (_partPressed != SB_NONE)
        {
            // while paging, thumb may have moved underneath the mouse
            if (_partPressed == SB_PREVTRACK || _partPressed == SB_NEXTTRACK)
            {
                LONG contentSize, containerSize, scrollAmount;

                GetScrollInfo(&contentSize, &containerSize, &scrollAmount);
#if !defined(UNIX) && !defined(_MAC) //Under Unix where the thumb goes during a repetition
             // of page down makes no difference.

                _partPressed = GetPart(
                    _direction,
                    _rcScrollbar,
                    _ptMouse,
                    contentSize,
                    containerSize,
                    scrollAmount,
                    _buttonWidth,
                    &_drawInfo);
                if (_partPressed != _partPressedStart)
                {
                    _partPressed = SB_NONE;
                    Verify(_pLayout->OpenView());
                    InvalidatePart(
                        _partPressedStart,
                        _direction,
                        _rcScrollbar,
                        contentSize,
                        containerSize,
                        scrollAmount,
                        _buttonWidth,
                        _pDispScroller,
                        &_drawInfo);
                    return S_OK;
                }
#endif
            }
            
#ifndef _MAC            
            //
            // Now that at least one click has come in (to be processed right afterwards)
            // we set the timer to be the repeat rate.
            //

            FormsSetTimer(
                    this,
                    ONTICK_METHOD(CScrollbarController, OnTick, ontick),
                    SB_REPEAT_TIMER,
                    GetRepeatRate() );
#endif

            // repeat this scroll action
            _pLayout->OnScroll(_direction, TranslateSBAction(_partPressed), 0, FALSE, GetRepeatRate());
        }
    }
    
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CScrollbarController::GetScrollInfo
//              
//  Synopsis:   Get basic size information needed to perform scrolling calcs.
//              
//  Arguments:  pContentSize        size of content to be scrolled
//              pContainerSize      size of container
//              pScrollAmount       current scroll amount
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

void
CScrollbarController::GetScrollInfo(
        LONG* pContentSize,
        LONG* pContainerSize,
        LONG* pScrollAmount) const
{
    Assert(_pDispScroller != NULL);
    
    // get content size
    *pContentSize = _pDispScroller->GetContentSize()[_direction];
    
    // get container size
    *pContainerSize = _rcScrollbar.Size(_direction);
    
    // get current scroll offset
    CSize scrollOffset;
    _pDispScroller->GetScrollOffset(&scrollOffset);
    *pScrollAmount = scrollOffset[_direction];
}

#ifdef UNIX // Grap codes from MouseMove
void 
CScrollbarController::MoveThumb(const CPoint& pt)
{
    LONG contentSize = _pDispScroller->GetContentSize()[_direction];
    Assert(contentSize >= 0);
    LONG thumbSize =
        GetThumbSize(_direction, _rcScrollbar, contentSize,
                     _rcScrollbar.Size(_direction), _buttonWidth,
                     &_drawInfo);
    LONG trackSize =
        GetTrackSize(_direction, _rcScrollbar, _buttonWidth) - thumbSize;
    if (trackSize <= 0)
        return;  // can't move thumb

    // NOTE: we're not currently checking to see if the mouse point
    // is out of range perpendicular to the scroll bar axis
    LONG trackPos =
        pt[_direction] - _rcScrollbar[_direction] -
        GetScaledButtonWidth(_direction, _rcScrollbar, _buttonWidth) -
        thumbSize/2; //_mouseInThumb;
    LONG scrollOffset;
    if (trackPos <= 0)
    {
        scrollOffset = 0;
    }
    else
    {
        contentSize -= _rcScrollbar.Size(_direction);
        scrollOffset = trackPos * contentSize;
        if (scrollOffset < trackPos || scrollOffset < contentSize)
        {
            // oops, it overflowed.  Do a less accurate calculation in
            // a safer order.
            scrollOffset = contentSize / trackSize * trackPos;
        }
        else
        {
            scrollOffset /= trackSize;
        }
    }
            
    // report scroll change to layout, which will take care of
    // invalidation
    _pLayout->OnScroll(_direction, SB_THUMBPOSITION, scrollOffset);
}
#endif // UNIX
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\layout\sellyt.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       sellyt.cxx
//
//  Contents:   Implementation of CSelectLayout
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_SELLYT_HXX_
#define X_SELLYT_HXX_
#include "sellyt.hxx"
#endif

#ifndef X_EOPTION_HXX_
#define X_EOPTION_HXX_
#include "eoption.hxx"
#endif

#ifndef X_ESELECT_HXX_
#define X_ESELECT_HXX_
#include "eselect.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_RECT_HXX_
#define X_RECT_HXX_
#include "rect.hxx"
#endif

#ifndef X_BUTTUTIL_HXX_
#define X_BUTTUTIL_HXX_
#include "buttutil.hxx"
#endif

#ifndef X_COLOR3D_HXX_
#define X_COLOR3D_HXX_
#include "color3d.hxx"
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_SCROLLBAR_HXX_
#define X_SCROLLBAR_HXX_
#include "scrollbar.hxx"
#endif

MtDefine(CSelectLayout, Layout, "CSelectLayout")

const CLayout::LAYOUTDESC CSelectLayout::s_layoutdesc =
{
    LAYOUTDESC_NEVEROPAQUE, // _dwFlags
};

ExternTag(tagLayoutTasks);
ExternTag(tagCalcSize);
ExternTag(tagViewHwndChange);

DeclareTag(tagSelectSetPos, "SelectPos", "Trace SELECT SetPositions");
DeclareTag(tagSelectNotify, "SelectNotify", "Trace the flat SELECT notifications");


//+------------------------------------------------------------------------
//
//  Member:     CSelectLayout::Notify
//
//  Synopsis:   Hook into the layout notification. listen for any changed in the tree
//              under the SELECT
//
//
//-------------------------------------------------------------------------

void
CSelectLayout::InternalNotify(void)
{
    CSelectElement *    pSelect = DYNCAST(CSelectElement, ElementOwner());

    if ( !TestLock(CElement::ELEMENTLOCK_SIZING) &&
         pSelect->_fEnableLayoutRequests )
    {

        //
        //  Otherwise, accumulate the information
        //
        BOOL    fWasDirty = IsDirty();

        //
        //  If transitioning to dirty, post a layout request
        //

        _fDirty = TRUE;

        TraceTag((tagSelectNotify, "SELECT 0x%lx was dirtied", this));

        if ( !fWasDirty && IsDirty() )
        {
            TraceTag((tagSelectNotify, "SELECT 0x%lx enqueueing layout request", this));
            TraceTagEx((tagLayoutTasks, TAG_NONAME,
                        "Layout Task: Posted on ly=0x%x [e=0x%x,%S sn=%d] by CSelectLayout::InternalNotify()",
                        this,
                        _pElementOwner,
                        _pElementOwner->TagName(),
                        _pElementOwner->_nSerialNumber));
            PostLayoutRequest(LAYOUT_MEASURE);
        }
    }
}


//+------------------------------------------------------------------------
//
//  Member:     CSelectLayout::Notify
//
//  Synopsis:   Hook into the layout notification. listen for any changed in the tree
//              under the SELECT
//
//
//-------------------------------------------------------------------------
void
CSelectLayout::Notify(CNotification * pnf)
{
    Assert(!pnf->IsReceived(_snLast));

    BOOL    fWasDirty = IsDirty() || IsSizeThis();
    CSelectElement *    pSelect = DYNCAST(CSelectElement, ElementOwner());

    super::Notify(pnf);

    if (    TestLock(CElement::ELEMENTLOCK_SIZING)
        ||  pnf->IsType(NTYPE_ELEMENT_RESIZE)
        ||  pnf->IsType(NTYPE_ELEMENT_ENSURERECALC)
        ||  pnf->IsType(NTYPE_ELEMENT_RESIZEANDREMEASURE))
        goto Cleanup;

    pSelect = DYNCAST(CSelectElement, ElementOwner());

    if ( ! pSelect->_fEnableLayoutRequests )
        goto Cleanup;

    if (IsInvalidationNotification(pnf))
    {
        if (pSelect->_hwnd)
        {
            ::InvalidateRect(pSelect->_hwnd, NULL, FALSE);
        }
    }

    // NOTE (KTam): CSelectLayout::Notify is being pretty aggressive about setting the
    // handler for notifications; right now practically all notifications are being set
    // to handled.  This seems wrong; the adorners work clearly wanted to avoid this,
    // and bug #98969 is fixed by not calling SetHandler for NTYPE_VISIBILITY_CHANGE.  See that bug
    // for more details.
    if ( pnf->IsType(NTYPE_VISIBILITY_CHANGE ) )
        goto Cleanup;
#ifdef ADORNERS
    if (pnf->IsType(NTYPE_ELEMENT_ADD_ADORNER))
        goto Cleanup;
#endif // ADORNERS

    if ( pnf->IsHandled() )
        goto Cleanup;

    if ( !pnf->IsTextChange())
        goto Handled;

    _fDirty = TRUE;
    pSelect->_fOptionsDirty = TRUE;

    TraceTag((tagSelectNotify, "SELECT 0x%lx was dirtied", this));

    if ( !fWasDirty && IsDirty() )
    {
        TraceTag((tagSelectNotify, "SELECT 0x%lx enqueueing layout request", this));
        TraceTagEx((tagLayoutTasks, TAG_NONAME,
                    "Layout Task: Posted on ly=0x%x [e=0x%x,%S sn=%d] by CSelectLayout::Notify() [n=%S srcelem=0x%x,%S]",
                    this,
                    _pElementOwner,
                    _pElementOwner->TagName(),
                    _pElementOwner->_nSerialNumber,
                    pnf->Name(),
                    pnf->Element(),
                    pnf->Element() ? pnf->Element()->TagName() : _T("")));
        PostLayoutRequest(pnf->LayoutFlags() | LAYOUT_MEASURE);
    }


Handled:
    pnf->SetHandler(pSelect);

Cleanup:
    return;
}





//+-------------------------------------------------------------------------
//
//  Method:     DoLayout
//
//  Synopsis:   Layout contents
//
//  Arguments:  grfLayout   - One or more LAYOUT_xxxx flags
//
//--------------------------------------------------------------------------

void
CSelectLayout::DoLayout(DWORD grfLayout)
{
    Assert(grfLayout & (LAYOUT_MEASURE | LAYOUT_POSITION | LAYOUT_ADORNERS));

    CSelectElement *    pSelect = DYNCAST(CSelectElement, ElementOwner());
    BOOL fTreeChanged = IsDirty();

    TraceTag((tagSelectNotify, "SELECT 0x%lx DoLayout called, flags: 0x%lx", this, grfLayout));
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CSelectLayout::DoLayout L(0x%x, %S) grfLayout(0x%x)", this, ElementOwner()->TagName(), grfLayout ));

    Assert(grfLayout & LAYOUT_MEASURE);
    Assert(!(grfLayout & LAYOUT_ADORNERS));

    if ( _fDirty )
    {
        if (pSelect->_hwnd)
            pSelect->PushStateToControl();

        _fDirty = FALSE;
        pSelect->ResizeElement();

    }

        //  Remove the request from the layout queue
    TraceTag((tagSelectNotify, "SELECT 0x%lx DEqueueing layout request", this));
    RemoveLayoutRequest();

    if ( IsSizeThis() )
    {
        CCalcInfo   CI(this);

        TraceTag((tagSelectNotify, "SELECT 0x%lx DoLayout caused EnsureDefaultSize", this));
        CI._grfLayout |= grfLayout;

        if (_fForceLayout)
        {
            CI._grfLayout |= LAYOUT_FORCE;
            _fForceLayout = FALSE;

            EnsureDispNode(&CI, TRUE);
            SetPositionAware();
        }

        if ( fTreeChanged || (grfLayout & LAYOUT_FORCE) )
        {
            pSelect->_sizeDefault.cx = pSelect->_sizeDefault.cy = 0;
        }

        if (HasRequestQueue())
        {
            ProcessRequests(&CI, pSelect->_sizeDefault);
        }
        
         EnsureDefaultSize(&CI);
    }

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CSelectLayout::DoLayout L(0x%x, %S) grfLayout(0x%x)", this, ElementOwner()->TagName(), grfLayout ));
}

//+------------------------------------------------------------------------
//
//  Member:     CSelectLayout::EnsureDefaultSize, protected
//
//  Synopsis:   Compute the default size of the control
//              if it hasn't been done yet.
//
//  Note:       Jiggles the window to handle integralheight listboxes correctly.
//
//-------------------------------------------------------------------------
#define CX_SELECT_DEFAULT_HIMETRIC  634L  // 1/4 logical inch

HRESULT
CSelectLayout::EnsureDefaultSize(CCalcInfo * pci)
{
    Assert(ElementOwner());

    HRESULT             hr = S_OK;
    long                lSIZE;
    CRect               rcSave;
    int                 i;
    long                lWidth, lMaxWidth;
    COptionElement *    pOption;
    CSelectElement *    pSelect = DYNCAST(CSelectElement, ElementOwner());
    SIZE &              sizeDefault = pSelect->_sizeDefault;

    if ( sizeDefault.cx && sizeDefault.cy )
        goto Cleanup;

#if DBG == 1
    _cEnsureDefaultSize++;
#endif

    lMaxWidth = 0;

    lSIZE = pSelect->GetAAsize();

    if ( lSIZE == 0 )
    {
        lSIZE = pSelect->_fMultiple ? 4 : 1;
    }

    sizeDefault.cy = pSelect->_lFontHeight * lSIZE +
                      pci->DeviceFromDocPixelsX(6);

    if (pSelect->_fWindowDirty || pSelect->_fOptionsDirty)
        pSelect->PushStateToControl();

    //  Measure the listbox lines
    for ( i = pSelect->_aryOptions.Size() - 1; i >= 0; i-- )
    {
        pOption = pSelect->_aryOptions[i];
        lWidth = pOption->MeasureLine(pci);

        if ( lWidth > lMaxWidth )
        {
            lMaxWidth = lWidth;
            pSelect->_poptLongestText = pOption;
        }
    }

    sizeDefault.cx = pci->DeviceFromHimetricX(g_sizelScrollbar.cx) +
                      lMaxWidth +
                      pci->DeviceFromDocPixelsX(6 + 4);   //  6 is magic number for borders

    if ( sizeDefault.cx < pci->DeviceFromHimetricX(CX_SELECT_DEFAULT_HIMETRIC) )
    {
        sizeDefault.cx = pci->DeviceFromHimetricX(CX_SELECT_DEFAULT_HIMETRIC);
    }

    pSelect->_lComboHeight = pSelect->_lFontHeight * DEFAULT_COMBO_ITEMS;

    pSelect->_lMaxWidth = lMaxWidth;
    _fDirty = FALSE;

Cleanup:
    RRETURN(hr);
}




//+-------------------------------------------------------------------------
//
//  Method:     CSelectLayout::CalcSizeVirtual
//
//  Synopsis:   Calculate the size of the object
//
//--------------------------------------------------------------------------

DWORD
CSelectLayout::CalcSizeVirtual( CCalcInfo * pci,
                                SIZE *      psize,
                                SIZE *      psizeDefault)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(CSelectLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));

    Assert(ElementOwner());
    CScopeFlag          csfCalcing(this);
    CSaveCalcInfo       sci(pci);
    HRESULT             hr;
    DWORD               grfLayout = 0;
    CSelectElement *    pSelect = DYNCAST(CSelectElement, ElementOwner());
    SIZE &              sizeDefault = pSelect->_sizeDefault;

#if DBG == 1
    _cCalcSize++;
#endif

    if (_fForceLayout)
    {
        pci->_grfLayout |= LAYOUT_FORCE;
        _fForceLayout = FALSE;
    }

    SetSizeThis( IsSizeThis() || (pci->_grfLayout & LAYOUT_FORCE) );

    if(  pSelect->_fNeedMorph && pSelect->_hwnd)
    {
        // We may have changed our flow direction. Recreate the control.
        pSelect->Morph();

        if(_pDispNode)
            GetElementDispNode()->RequestViewChange();
    }

    if ( ! pSelect->_hwnd )
    {
        hr = THR(AcquireFont(pci));
        if ( FAILED(hr) )
            goto Cleanup;

        if ( Doc() && Doc()->_pInPlace && Doc()->_pInPlace->_hwnd && IsInplacePaintAllowed())
        {
            hr = THR(pSelect->EnsureControlWindow());

            if ( hr )
                goto Cleanup;
        }
    }
    else if ( pSelect->_fRefreshFont ) 
    {
        hr = THR(AcquireFont(pci));
        if ( FAILED(hr)) 
            goto Cleanup;

        Assert(pSelect->_hFont);

        // AcquireFont returns S_FALSE if the new font is the same as the old one.
        if (hr != S_FALSE)
        {
            ::SendMessage(pSelect->_hwnd, WM_SETFONT, (WPARAM)pSelect->_hFont, MAKELPARAM(FALSE,0));
            if (! pSelect->_fListbox )
            {
                pSelect->SendSelectMessage(CSelectElement::Select_SetItemHeight, (WPARAM)-1, pSelect->_lFontHeight);
            }
            pSelect->SendSelectMessage(CSelectElement::Select_SetItemHeight, 0, pSelect->_lFontHeight);
        }
        hr = S_OK;
    }

    if ( pci->_grfLayout & LAYOUT_FORCE || _fDirty)
    {
        sizeDefault.cx = sizeDefault.cy = 0;
    }

    IGNORE_HR(EnsureDefaultSize(pci));

Cleanup:

    TraceTag((tagSelectSetPos, "SELECT 0x%lx CalcSize, cx=%d, cy=%d", this, psize->cx, psize->cy));

    // if we're a combo box, ignore height set by CSS and use
    // the default height. BUT, we do use the CSS width if it 
    // has been set.
    if (! pSelect->_fListbox)
    {
        CTreeNode * pTreeNode = GetFirstBranch();
        if (pTreeNode)
        {
            const CCharFormat *pCF = pTreeNode->GetCharFormat();
            const CUnitValue & cuvWidth = pTreeNode->GetFancyFormat()->GetLogicalWidth(
                pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);

            sizeDefault.cx = (cuvWidth.IsNullOrEnum() || (pci->_grfLayout & LAYOUT_USEDEFAULT)
                                    ? sizeDefault.cx
                                    : max(0L, cuvWidth.XGetPixelValue(pci, pci->_sizeParent.cx,
                                                        pTreeNode->GetFontHeightInTwips(&cuvWidth))));

            pci->_grfLayout |= LAYOUT_USEDEFAULT;
        }
    }

    grfLayout |= super::CalcSizeVirtual(pci, psize, &sizeDefault);

    //
    // If anything changed, ensure the display node is position aware
    //
    if(_pDispNode
        &&  (grfLayout & (LAYOUT_THIS | LAYOUT_HRESIZE | LAYOUT_VRESIZE)))
    {
        SetPositionAware();
    }

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")CSelectLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    return grfLayout;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::AcquireFont, protected
//
//  Synopsis:   Beg, borrow or steal a font and set it to the control window
//
//  returns:    S_FALSE if the current font and old font are the same
//
//----------------------------------------------------------------------------

HRESULT
CSelectLayout::AcquireFont(CCalcInfo * pci)
{
    Assert(ElementOwner());

    HRESULT             hr = S_OK;
    LOGFONT             lfOld;
    LOGFONT             lf;
    CCcs                ccs;
    CSelectElement *    pSelect = DYNCAST(CSelectElement, ElementOwner());

    const CCharFormat * pcf = GetFirstBranch()->GetCharFormat();

    memset(&lfOld, 0, sizeof(lfOld));
    memset(&lf, 0, sizeof(lf));

    if ( ! pcf )
        goto Error;

    if (!fc().GetCcs(&ccs, pci->_hdc, pci, pcf))
        goto Error;

    lf = ccs.GetBaseCcs()->_lf;    //  Copy it out
    lf.lfUnderline = pcf->_fUnderline;
    lf.lfStrikeOut = pcf->_fStrikeOut;

    if (pSelect->_hFont)
    {
        ::GetObject(pSelect->_hFont, sizeof(lfOld), &lfOld);
        if (!memcmp(&lf, &lfOld, sizeof(lfOld)))
        {
            hr = S_FALSE;
            goto Cleanup;
        }
        else
        {
            Verify(DeleteObject(pSelect->_hFont));
            pSelect->_hFont = NULL;
        }
    }
    
    pSelect->_hFont = CreateFontIndirect(&lf);
    pSelect->_lFontHeight = ccs.GetBaseCcs()->_yHeight;

    pSelect->_fRefreshFont = FALSE;

Cleanup:
    ccs.Release();
    RRETURN1(hr, S_FALSE);

Error:
    hr = E_FAIL;
    goto Cleanup;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::DrawControl, protected
//
//  Synopsis:   Renders the SELECT into a DC which is different
//              from the inplace-active DC.
//
//  Note:       Used mainly to print.
//
//----------------------------------------------------------------------------

void
CSelectLayout::DrawControl(CFormDrawInfo * pDI, BOOL fPrinting)
{
    XHDC                hdc             = pDI->GetDC(TRUE);
    CRect               rc              = pDI->_rc;
    CRect               rcLine;
    CRect               rcScrollbar;
    CSize               sizeInner;
    long                xOffset;
    FONTIDX             hFontOld        = HFONT_INVALID;
    int                 cColors;
    COLORREF            crText, crBack;
    COLORREF            crSelectedText  = 0x00FFFFFF, crSelectedBack=0;
    CCcs                ccs;
    COptionElement *    pOption;
    long                lSelectedIndex  = 0;
    long                cVisibleLines;
    long                lTopIndex;
    long                lItemHeight;
    long                i;
    BOOL                fPrintBW;
    CColorValue         ccv;
    CStr                cstrTransformed;
    CStr *              pcstrDisplayText;
    long                cOptions;
    BOOL                fRTL;
    CSelectElement *    pSelect         = DYNCAST(CSelectElement, ElementOwner());
    UINT                taOld = 0;
    CBorderInfo         bi;
    CTreeNode * pNode = GetFirstBranch();
    const CCharFormat * pCF             = pNode->GetCharFormat();
    const CParaFormat * pPF             = pNode->GetParaFormat();
 
    HTHEME              hThemeBorder    = GetOwnerMarkup()->GetTheme(THEME_EDIT);

    if  (   !hThemeBorder
        ||  !hdc.DrawThemeBackground(    hThemeBorder,
                                         EP_EDITTEXT,
                                         pSelect->IsEnabled() ? ETS_NORMAL : ETS_DISABLED,
                                         &rc,
                                         NULL))
    {
        if (ElementOwner()->GetBorderInfo(pDI, &bi, TRUE))
        {
            ::DrawBorder(pDI, &rc, &bi);
        }
    }

    //  Deflate the rect
    sizeInner = rc.Size();
    AdjustSizeForBorder(&sizeInner, pDI, FALSE);    //  FALSE means deflate

    rc.top += (rc.Height() - sizeInner.cy) / 2;
    rc.bottom = rc.top + sizeInner.cy;
    rc.left += (rc.Width() - sizeInner.cx) / 2;
    rc.right = rc.left + sizeInner.cx;

    xOffset = pDI->DeviceFromDocPixelsX(2);

    //  set up font, text and background colors

    cColors = GetDeviceCaps(hdc, NUMCOLORS);
    if ( !GetContentMarkup()->PaintBackground() && cColors <= 2)
    {
        fPrintBW = TRUE;
        crBack = 0x00FFFFFF;
        crText = pSelect->GetAAdisabled() ? GetSysColorQuick(COLOR_GRAYTEXT) : 0x0;
        crSelectedBack = crText;
        crSelectedText = crBack;
    }
    else
    {
        fPrintBW = FALSE;
        crText = 0x0;
        if (pNode->GetCascadedbackgroundColor().IsDefined())
        {
            crBack = pNode->GetCascadedbackgroundColor().GetColorRef();
        }
        else
        {
            crBack = GetSysColorQuick(COLOR_WINDOW);
        }
    }

    //  Fill the background with crBack

    PatBltBrush(hdc, &rc, PATCOPY, crBack);

    // find out what our reading order is.
    fRTL = pPF->HasRTL(TRUE);

    // ComplexText
    if(fRTL)
    {
        taOld = GetTextAlign(hdc);
        SetTextAlign(hdc, TA_RTLREADING | TA_RIGHT);
    }

    if ( pCF )
    {
        if (!fc().GetCcs(&ccs, hdc, pDI, pCF))
            return;

        hFontOld = ccs.PushFont(hdc);

        //  NOTE(laszlog): Underline!
    }

    if ( ! pSelect->_fMultiple )
    {
        lSelectedIndex = pSelect->GetCurSel();
    }

    if ( pSelect->_fListbox )
    {
#ifndef WIN16
                // BUGWIN16: Win16 doesn't support Select_GetTopIndex,
                // so am turning this off. is this right ?? vreddy - 7/16/97
        if ( pSelect->_hwnd )
        {
            lTopIndex = pSelect->SendSelectMessage(CSelectElement::Select_GetTopIndex, 0, 0);
        }
        else
#endif
        {
            lTopIndex = pSelect->_lTopIndex;
        }

        cVisibleLines = pSelect->GetAAsize();
        cOptions = pSelect->_aryOptions.Size();

        //  Handle the default height fudge
        if ( cVisibleLines == 0 )
        {
            cVisibleLines = 4;
        }

        if (pNode->GetFancyFormat()->GetLogicalHeight(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed).IsNull())
        {
            lItemHeight = rc.Height() / cVisibleLines;
        }
        else
        {
            lItemHeight = pSelect->_lFontHeight;
            cVisibleLines = (rc.Height() / lItemHeight) + 1;
        }


        if ( ! pSelect->_fMultiple )
        {
            lSelectedIndex = pSelect->GetCurSel();
        }


        if ( cVisibleLines < cOptions )
        {
            rcScrollbar = rc;
            // put the scrollbar rect on the appropriate side of the control based on
            // the direction
            if(!fRTL)
            {
                rcScrollbar.left = rcScrollbar.right - pDI->DeviceFromHimetricX(g_sizelScrollbar.cx);
                rc.right = rcScrollbar.left;
            }
            else
            {
                rcScrollbar.right = rcScrollbar.left + pDI->DeviceFromHimetricX(g_sizelScrollbar.cx);
                rc.left = rcScrollbar.right;
            }

            // Draw scrollbar for listbox
            {          
                CScrollbar sb;
                CScrollbarParams        params;
                CScrollbarThreeDColors  colors(ElementOwner()->GetFirstBranch(), &hdc);
    
                params._pColors     = &colors;
                params._buttonWidth = rcScrollbar.Width();
                params._fFlat       = Doc()->_dwFlagsHostInfo & DOCHOSTUIFLAG_FLAT_SCROLLBAR;
                params._fForceDisabled = FALSE;
                params._hTheme = GetTheme(THEME_SCROLLBAR);
                sb.Draw(1,
                        rcScrollbar,
                        rcScrollbar,
                        cOptions * lItemHeight,
                        rcScrollbar.Height(),
                        0,
                        CScrollbar::SB_NONE,
                        hdc,
                        params,
                        pDI,
                        0);
            }        
        }

        cVisibleLines += lTopIndex;
        cVisibleLines = min(cOptions, cVisibleLines);
    }
    else
    {
        ThreeDColors  colors(&hdc);
        CUtilityButton cub(&colors, FALSE);
        SIZEL sizel;

        rcScrollbar = rc;
        // put the scrollbar rect on the appropriate side of the control based on
        // the direction
        if(!fRTL)
        {
            rcScrollbar.left = rcScrollbar.right - pDI->DeviceFromHimetricX(g_sizelScrollbar.cx);
            rc.right = rcScrollbar.left;
        }
        else
        {
            rcScrollbar.right = rcScrollbar.left + pDI->DeviceFromHimetricX(g_sizelScrollbar.cx);
            rc.left = rcScrollbar.right;
        }

        pDI->HimetricFromDevice(sizel, rcScrollbar.Size());

        //  Draw the drop button here
        {
            HTHEME  hTheme  = GetTheme(THEME_COMBO);
            BOOL    fRetVal = FALSE;

            if (hTheme)
            {
                fRetVal = hdc.DrawThemeBackground(  hTheme,
                                                    CP_DROPDOWNBUTTON,
                                                    CBXS_NORMAL,
                                                    &rcScrollbar,
                                                    NULL);
            }

            if (!fRetVal)
            {
                cub.DrawButton(pDI, NULL,
                               BG_COMBO,
                               FALSE,
                               !pSelect->GetAAdisabled(),
                               FALSE,
                               rcScrollbar,
                               sizel,//extent
                               0);
            }
        }

        if ( lSelectedIndex == -1 )
            goto Cleanup;   //  Combobox is empty

        lTopIndex = lSelectedIndex;
        cVisibleLines = lTopIndex + 1;
        lItemHeight = rc.Height();
    }

    // Check to see if select control is empty.  No more to draw!
    if (pSelect->_aryOptions.Size() <= 0)
        goto Cleanup;

    rcLine = rc;

    for ( i = lTopIndex, rcLine.bottom = rc.top + lItemHeight;
          i < cVisibleLines;
          i++, rcLine.OffsetRect(0, lItemHeight), rcLine.bottom = min(rc.bottom, rcLine.bottom) )
    {
        int iRet = -1;

        Assert(i < pSelect->_aryOptions.Size());

        pOption = pSelect->_aryOptions[i];

        pcstrDisplayText = pOption->GetDisplayText(&cstrTransformed);


        if ( fPrintBW )
        {
            SetBkColor  (hdc, pSelect->_fListbox && pOption->_fSELECTED ? crSelectedBack : crBack);
            SetTextColor(hdc, pSelect->_fListbox && pOption->_fSELECTED ? crSelectedText : crText);
            PatBltBrush(hdc, &rcLine, PATCOPY, pSelect->_fListbox && pOption->_fSELECTED ? crSelectedBack : crBack);
        }
        else
        {
            pOption->GetDisplayColors(&crText, &crBack, pSelect->_fListbox);

            SetBkColor(hdc, crBack);
            SetTextColor(hdc, crText);
            PatBltBrush(hdc, &rcLine, PATCOPY, crBack);
        }

        //  Set up clipping
#ifdef WIN16
        GDIRECT gr, *prc;
        CopyRect(&gr, &rc);
        prc = &gr;
#else
        RECT *prc = &rc;
#endif

        if ( pCF )
        {
            if ( pOption->CheckFontLinking(hdc, &ccs) )
            {
                // this option requires font linking

                iRet = FontLinkTextOut(hdc,
                                       !fRTL ? rcLine.left + xOffset : rcLine.right - xOffset,
                                       rcLine.top,
                                       ETO_CLIPPED,
                                       prc,
                                       *pcstrDisplayText,
                                       pcstrDisplayText->Length(),
                                       pDI,
                                       pCF,
                                       FLTO_TEXTOUTONLY);
            }
        }
        if (iRet < 0)
        {
            // no font linking

            VanillaTextOut(&ccs,
                           hdc,
                           !fRTL ? rcLine.left + xOffset : rcLine.right - xOffset,
                           rcLine.top,
                           ETO_CLIPPED,
                           prc,
                           *pcstrDisplayText,
                           pcstrDisplayText->Length(),
                           ElementOwner()->GetMarkup()->GetCodePage(),
                           NULL);

            if (pSelect->_hFont && g_dwPlatformID == VER_PLATFORM_WIN32_WINDOWS)
            {
                // Workaround for win95 gdi ExtTextOutW underline bugs.
                DrawUnderlineStrikeOut(rcLine.left + xOffset,
                                       rcLine.top,
                                       pOption->MeasureLine(NULL),
                                       hdc,
                                       pSelect->_hFont,
                                       prc);
            }
        }
    }

Cleanup:
    if (hFontOld != HFONT_INVALID)
        ccs.PopFont(hdc, hFontOld);
    if(fRTL)
        SetTextAlign(hdc, taOld);

    ccs.Release();

    return;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSelectElement::Draw
//
//  Synopsis:   Draw the site and its children to the screen.
//
//----------------------------------------------------------------------------

void
CSelectLayout::Draw(CFormDrawInfo *pDI, CDispNode *)
{
    if (pDI->_fInplacePaint && IsInplacePaintAllowed())
    {
        Assert(pDI->_dwDrawAspect == DVASPECT_CONTENT);
        //DrawBorder(pDI);

        goto Cleanup;
    }

    //  Use ExtTextOut to draw the listbox line by line

    if ( pDI->_dwDrawAspect == DVASPECT_CONTENT ||
         pDI->_dwDrawAspect == DVASPECT_DOCPRINT )
    {
        DrawControl(pDI, pDI->_dwDrawAspect == DVASPECT_DOCPRINT);
    }

Cleanup:
    return;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSelectLayout::OnFormatsChange
//
//  Synopsis:   Handle formats change notification
//
//----------------------------------------------------------------------------
HRESULT
CSelectLayout::OnFormatsChange(DWORD dwFlags)
{
    CSelectElement * pElementSelect = DYNCAST(CSelectElement, ElementOwner());

    if ( dwFlags & ELEMCHNG_CLEARCACHES )
    {
        pElementSelect->_fRefreshFont = TRUE;
    }

    HRESULT hr = THR(super::OnFormatsChange(dwFlags));

    // Invalidate the brush - when needed it will be re-computed
    pElementSelect->InvalidateBackgroundBrush();

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     HandleViewChange
//
//  Synopsis:   Respond to change of in view status
//
//  Arguments:  flags           flags containing state transition info
//              prcClient       client rect in global coordinates
//              prcClip         clip rect in global coordinates
//              pDispNode       node which moved
//
//----------------------------------------------------------------------------
void
CSelectLayout::HandleViewChange(
    DWORD           flags,
    const RECT*     prcClient,
    const RECT*     prcClip,
    CDispNode*      pDispNode)
{
    CSelectElement * pSelect = DYNCAST(CSelectElement, ElementOwner());
    
    BOOL fInView = !!(flags & VCF_INVIEW);
    BOOL fInViewChanged = !!(flags & VCF_INVIEWCHANGED);
    BOOL fMoved = !!(flags & VCF_POSITIONCHANGED);
    BOOL fNoRedraw = !!(flags & VCF_NOREDRAW);

    pSelect->_fWindowVisible = fInView && IsInplacePaintAllowed();
    
    // NOTE (donmarsh) - For now, CSelectElement creates its HWND
    // during CalcSize.  However, it would be a significant perf win
    // to create it here when it first becomes visible.  KrisMa will fix.
    if (_fWindowHidden && pSelect->_fWindowVisible)
    {
        pSelect->EnsureControlWindow();
        _fWindowHidden = FALSE;
    }
    Assert((pSelect->Doc() && pSelect->Doc()->State() < OS_INPLACE) ||
        pSelect->_hwnd || 
        (pSelect->Doc() && pSelect->GetMarkupPtr()->IsPrintMedia()) ||
        !IsInplacePaintAllowed());
    
    if (fInView)
    {
        if (pSelect->_fSetComboVert)
        {
            pSelect->_fSetComboVert = FALSE;

            UINT uFlags = SWP_NOACTIVATE|SWP_NOZORDER|SWP_NOREDRAW;
      
            // this call just sets the window size
            SetWindowPos(pSelect->_hwnd,
                NULL,
                prcClient->left,
                prcClient->top,
                prcClient->right - prcClient->left,
                pSelect->_fListbox ? prcClient->bottom - prcClient->top :
                    pSelect->_lComboHeight,
                uFlags);

            // make sure we show the window
            fInViewChanged = TRUE;
        }
    }
       
    if (fMoved || fInViewChanged)
    {
        DWORD positionChangeFlags = SWP_NOACTIVATE | SWP_NOZORDER;
        if (fInViewChanged)
            positionChangeFlags |= (fInView) ? SWP_SHOWWINDOW : SWP_HIDEWINDOW;
        if (fNoRedraw)
            positionChangeFlags |= SWP_NOREDRAW;
    
        CRect rcClip(*prcClip);

        rcClip.OffsetRect(-((const CRect*)prcClient)->TopLeft().AsSize());

        pSelect->SetVisibleRect(rcClip);

        CSelectElement * pSelect = DYNCAST(CSelectElement, ElementOwner());

        if (g_uiDisplay.IsDeviceScaling() && pSelect && !pSelect->_fListbox)
        {
            // Bug 27787: There is a bug in the combobox control where resizing the height of the
            // control may cause the combobox to resize itself incorrectly.  For some reason with
            // hidpi support our layout rects don't correspond correctly with what the combobox
            // expects and we see this bug.  So to workaround this issue we'll keep the current
            // control height and just update the width and top left positions.
            CRect rcSelectWnd;
            ::GetWindowRect(pSelect->_hwnd, &rcSelectWnd);
            rcSelectWnd.bottom = prcClient->top + (rcSelectWnd.bottom - rcSelectWnd.top);
            rcSelectWnd.left = prcClient->left;
            rcSelectWnd.top = prcClient->top;
            rcSelectWnd.right = prcClient->right;

            DeferSetWindowPos(pSelect->_hwnd, &rcSelectWnd, positionChangeFlags, NULL);
        }
        else
        {
            DeferSetWindowPos(pSelect->_hwnd, prcClient, positionChangeFlags, NULL);
        }
    }

}


//+---------------------------------------------------------------------------
//
//  Member:     CSelectLayout::Obscure
//              
//  Synopsis:   Obscure the control, by clipping it to the given region
//              
//----------------------------------------------------------------------------

void
CSelectLayout::Obscure(CRect *prcgClient, CRect *prcgClip, CRegion2 *prgngVisible)
{
    CSelectElement * pSelect = DYNCAST(CSelectElement, ElementOwner());
    CRegion2 rgng = *prgngVisible;

    rgng.Offset(- prcgClient->TopLeft().AsSize() );
    pSelect->SetVisibleRegion(rgng);
}


//+---------------------------------------------------------------------------
//
//  Member:     CSelectLayout::ProcessDisplayTreeTraversal
//              
//  Synopsis:   Add our window to the z order list.
//              
//  Arguments:  pClientData     window order information
//              
//  Returns:    TRUE to continue display tree traversal
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
CSelectLayout::ProcessDisplayTreeTraversal(void *pClientData)
{
    CSelectElement * pSelect = DYNCAST(CSelectElement, ElementOwner());
    if (pSelect->_hwnd)
    {
        CView::CWindowOrderInfo* pWindowOrderInfo =
            (CView::CWindowOrderInfo*) pClientData;
        pWindowOrderInfo->AddWindow(pSelect->_hwnd);
    }
    
    return TRUE;
}


//+--------------------------------------------------------------------------
//
//  Member : GetChildElementTopLeft
//
//  Synopsis : CLayout virtual override, the job of this function is to
//      translate Queries for the top left of an option (the only element
//      that would be a child of the select) into the top left, of the select
//      itself.
//
//----------------------------------------------------------------------------

HRESULT
CSelectLayout::GetChildElementTopLeft(POINT & pt, CElement * pChild)
{
    // Only OPTIONs can be children of SELECT
    Assert( pChild && pChild->Tag() == ETAG_OPTION );
    
    // an option's top left is reported as 0,0 (Bug #41111).
    pt.x = pt.y = 0;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\layout\olelyt.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       olelyt.cxx
//
//  Contents:   Implementation of COleayout and related classes.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_OLELYT_HXX_
#define X_OLELYT_HXX_
#include "olelyt.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_EOBJECT_HXX
#define X_EOBJECT_HXX
#include "eobject.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif  

#ifndef X_LTABLE_HXX_
#define X_LTABLE_HXX_
#include "ltable.hxx"
#endif

#ifndef X_FLOAT2INT_HXX_
#define X_FLOAT2INT_HXX_
#include "float2int.hxx"
#endif

#define ALWAYS_DEFER_SET_WINDOW_RGN

DeclareTag(tagOleRgn, "OleLayout", "Fill window region");
#if defined(ALWAYS_DEFER_SET_WINDOW_RGN)
DeclareTag(tagDeferSetWindowRgn, "OleLayout", "Don't defer SetWindowRgn");
#else
DeclareTag(tagDeferSetWindowRgn, "OleLayout", "Always defer SetWindowRgn");
#endif

MtDefine(COleLayout, Layout, "COleLayout");

ExternTag(tagOleSiteRect);
ExternTag(tagViewHwndChange);
ExternTag(tagCalcSize);

extern BOOL IntersectRectE (RECT * prRes, const RECT * pr1, const RECT * pr2);


const CLayout::LAYOUTDESC COleLayout::s_layoutdesc =
{
    0, // _dwFlags
};


//+---------------------------------------------------------------------------
//
//  Member:     COleLayout::Reset
//
//  Synopsis:   Remove the object's HWND from the view's caches.
//
//----------------------------------------------------------------------------

void
COleLayout::Reset(BOOL fForce)
{
    COleSite *  pSiteOle = DYNCAST(COleSite, ElementOwner());
    HWND hwnd = pSiteOle->GetHwnd();
    
    if (hwnd != NULL)
    {
        GetView()->CleanupWindow(hwnd);
    }
    
    super::Reset(fForce);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleLayout::Draw
//
//  Synopsis:   Draw the object.
//
//----------------------------------------------------------------------------

void
COleLayout::Draw(CFormDrawInfo * pDI, CDispNode *)
{
    CDoc     *  pDoc     = Doc();
    COleSite *  pSiteOle = DYNCAST(COleSite, ElementOwner());
    INSTANTCLASSINFO * pici;
    BOOL fInplacePaint = pDI->_fInplacePaint && IsInplacePaintAllowed();

    
    Assert(pSiteOle);

    // inplace paint should be disabled if we have print delegate here.
    if (pSiteOle->_hemfSnapshot)
        fInplacePaint= FALSE;
    
    ////
    //
    // IN_PLACE PAINT
    //
    ////
    if (fInplacePaint)
    {
        Assert(pDI->_dwDrawAspect == DVASPECT_CONTENT);

        if (pSiteOle->_state == OS_OPEN)
        {
#ifndef WINCE
            XHDC    hdc = pDI->GetGlobalDC(TRUE);
            HBRUSH  hbr;

            hbr = CreateHatchBrush(
                            HS_DIAGCROSS,
                            GetSysColorQuick(COLOR_WINDOWFRAME));
            if (hbr)
            {
                FillRect(hdc, &pDI->_rc, hbr);
                DeleteObject(hbr);
            }
#endif // WINCE
            goto Cleanup;
        }
        else if (pSiteOle->_state >= OS_INPLACE &&
                 !pSiteOle->_fWindowlessInplace)
        {
            TraceTagEx((tagOLEWatch,
                TAG_NONAME,
                "TRIDENT Draw with _state >= OS_INPLACE && !_fWindowlessInplace, site %x",
                pSiteOle));

#if DBG==1
            if (IsTagEnabled(tagOleRgn))
            {
                HWND    hwnd = pSiteOle->GetHwnd();
                HDC     hdc  = ::GetDC(hwnd);
                HBRUSH  hbr  = ::CreateSolidBrush((COLORREF)0x000000FF);
                HRGN    hrgn = ::CreateRectRgnIndirect(&g_Zero.rc);

                ::GetWindowRgn(hwnd, hrgn);
                ::FillRgn(hdc, hrgn, hbr);

                ::DeleteObject(hrgn);
                ::DeleteObject(hbr);
                ::ReleaseDC(hwnd, hdc);
            }
#endif

            goto Cleanup;
        }
    }

    ////
    //
    // not in-place
    //
    ////

    Assert((pDI->_rc.right - pDI->_rc.left)
        && (pDI->_rc.bottom - pDI->_rc.top));
    
    // Don't draw unless:
    //
    //  1)  Object is windowless inplace...  or...
    //  2)  Baseline state is less than OS_INPLACE... or...
    //  3)  We're not drawing into the inplace dc (someone else called
    //      IVO::Draw on trident itself)... or...
    //  4)  The control is oc96 or greater.  This is because atl has
    //      a bug where it totally ignores the pfNoRedraw argument of
    //      IOleInPlaceSiteEx::OnInPlaceActivateEx.  If we didn't do
    //      the IVO::Draw here, the control would never paint.
    //      ie4 bug 54603.  (anandra)
    //  5)  There is a metafile snapshot to be used in printing or print preview
    //
    // Otherwise calling IVO::Draw would likely leave a "ghost" image
    // that would soon be replaced when activation occurs - leading to
    // flicker...  (philco)
    //
    pici = pSiteOle->GetInstantClassInfo();

    //
    // If we have a metafile snapshot, just play it!
    //
    if (pSiteOle->_hemfSnapshot)
    {
        XHDC    hdc = pDI->GetGlobalDC(!ElementOwner()->GetMarkupPtr()->IsPrintMedia());
        
        // CAUTION: getting raw DC. We must be careful with what we do to it.
        HDC rawHDC = hdc.GetOleDC();
        // who knows what the control will do to the DC?  The Windows Media
        // Player changes the palette, for example (bug 76819)
        int nSavedDC = ::SaveDC(rawHDC);
        Assert(nSavedDC);
        
        // XHDC::PlayEnhMetafile() takes care of transformations.
        Assert(!fInplacePaint);

        // Let's assert that rect is zero-based. 
        // It would be easy to handle an offset, but it doesn't look like we ever have it.
        Assert(pDI->_rc.TopLeft() == g_Zero.pt);

        CDocInfo const *pdciDefault  = &Doc()->_dciRender;
        CRect           rcBoundsPlay;
        ENHMETAHEADER   emfh = {EMR_HEADER, sizeof(emfh)};

        if (GetEnhMetaFileHeader(pSiteOle->_hemfSnapshot, sizeof(emfh), &emfh))
        {
            extern CRect ComputeEnhMetaFileBounds(ENHMETAHEADER *pemh);

            RECTL rcFrameHM = emfh.rclFrame;
            long  lFrameWidth = rcFrameHM.right - rcFrameHM.left;
            long  lFrameHeight = rcFrameHM.bottom - rcFrameHM.top;

            rcBoundsPlay = ComputeEnhMetaFileBounds(&emfh);

            // convert to layout resolution
            CSize const& defRes = pdciDefault->GetResolution();
            rcBoundsPlay.left   = IntNear(double(rcBoundsPlay.left  ) * HIMETRIC_PER_INCH / defRes.cx * pDI->_rc.Width()  / lFrameWidth );
            rcBoundsPlay.top    = IntNear(double(rcBoundsPlay.top   ) * HIMETRIC_PER_INCH / defRes.cy * pDI->_rc.Height() / lFrameHeight);
            rcBoundsPlay.right  = IntNear(double(rcBoundsPlay.right ) * HIMETRIC_PER_INCH / defRes.cx * pDI->_rc.Width()  / lFrameWidth );
            rcBoundsPlay.bottom = IntNear(double(rcBoundsPlay.bottom) * HIMETRIC_PER_INCH / defRes.cy * pDI->_rc.Height() / lFrameHeight);
        }

        //
        // Play metafile
        //
        WHEN_DBG(BOOL f = )
                PlayEnhMetaFile(hdc, pSiteOle->_hemfSnapshot, &rcBoundsPlay);
        AssertSz(f, "PlayEnhMetaFile");
        WHEN_DBG(GetLastError();)
        
        // restore DC
        Verify(::RestoreDC(rawHDC, nSavedDC));
    }
    //
    // Do the work to Call IViewObject::Draw
    //
    else if (   pSiteOle->_pVO
             && (   pSiteOle->_fWindowlessInplace
                 || (pSiteOle->BaselineState(pDoc->State()) < OS_INPLACE)
                 || !fInplacePaint
                 || (pici && pici->IsOC96()
                )))
    {
        XHDC    hdc = pDI->GetGlobalDC(!ElementOwner()->GetMarkupPtr()->IsPrintMedia());
        POINT   ptBrushOriginSave, ptViewportOrigin, ptNewBrushOrigin;
        BOOL    fBrushOrgChanged;

        ptBrushOriginSave = g_Zero.pt;  // this is just to appease the LINT (alexa)
        Assert( !_pElementOwner->_fSurface ||  pDI->IsMemory() ||  ElementOwner()->GetMarkupPtr()->IsPrintMedia() 
               || pDI->_fIsMetafile);
        Assert(!(pSiteOle->OlesiteTag() == COleSite::OSTAG_APPLET && ElementOwner()->GetMarkupPtr()->IsPrintMedia()));

        
        // NOTE: The marshalling code for IViewObject::Draw was
        //   not updated to the oc96 spec and thus does not know
        //   about the pvAspect usage.  It returns E_INVALIDARG if
        //   a non-NULL pvAspect is passed in.  So we check to see
        //   if we're talking to an OLE proxy and pass in NULL then.
        //   Otherwise we pass in the default value.
        //   (anandra) Apr-16-97.
        //
        // The MultiMedia Structured Graphics control mmsgrfxe.ocx
        // expects us to manage their brush origin.  Although the
        // contract does not state we have to, and MSDN in fact states
        // they should not count on the brush origin, it is fairly
        // easy for us to do it here so we extend this nice gesture.
        //
        // The issue is that whenever they move about on the screen
        // the brush origin must move with them so that any patterns
        // which are brushed onto their images remain aligned.  Also,
        // our off-screen rendering into a memory DC complicates things
        // by moving the viewport origin.
        //
        fBrushOrgChanged = GetViewportOrgEx(hdc, &ptViewportOrigin);
        if (fBrushOrgChanged)
        {
            ptNewBrushOrigin.x = (ptViewportOrigin.x + pDI->_rc.left) % 8;
            if( ptNewBrushOrigin.x < 0 )
                ptNewBrushOrigin.x += 8;
            ptNewBrushOrigin.y = (ptViewportOrigin.y + pDI->_rc.top) % 8;
            if( ptNewBrushOrigin.x < 0 )
                ptNewBrushOrigin.y += 8;

            fBrushOrgChanged = SetBrushOrgEx(
                            hdc,
                            ptNewBrushOrigin.x,
                            ptNewBrushOrigin.y,
                            &ptBrushOriginSave );
        }

        //
        // Save DC
        //
        
        // CAUTION: getting raw DC. We must be careful with what we do to it.
        HDC rawHDC = hdc.GetOleDC();
        
        // who knows what the control will do to the DC?  The Windows Media
        // Player changes the palette, for example (bug 76819)
        int nSavedDC = ::SaveDC(rawHDC);
        Assert(nSavedDC);

        // a windowless in-place control expects to render at the coordinates
        // it was given in SetObjectRects.  We oblige by manipulating the
        // viewport origin so it will render in the correct place.  This is
        // especially important for filtered controls, since the offscreen
        // buffer kept by the filter has a different coordinate system than
        // the one that was used when SetObjectRects was called.
        BOOL fCompatNeetsZeroBasedDrawRect = pici && (pici->dwCompatFlags & COMPAT_NEEDSZEROBASEDDRAWRECT);
        BOOL fSetViewportOrg = (fInplacePaint || pDI->_fIsMetafile) 
                             && (pSiteOle->_fWindowlessInplace || fCompatNeetsZeroBasedDrawRect);
        RECTL* prc;
        if (fSetViewportOrg)
        {
            prc = NULL;
            CPoint ptOrg = 
                pDI->_rc.TopLeft() + (CSize&)ptViewportOrigin
                - _rcWnd.TopLeft().AsSize();
            ::SetViewportOrgEx(hdc, ptOrg.x, ptOrg.y, NULL);
        }
        else
        {
            prc = (RECTL*) &pDI->_rc;
        }

        // Transform rectangles.
        // Unfortunately, we have to do it here, since there is no way to 
        // automatically apply transformations IViewObject::Draw
        CRect rcBounds, *prcBounds = (CRect *) prc;
        CRect rcWBounds, *prcWBounds = (CRect *) pDI->_prcWBounds;
        CPoint ptOrg(0,0);

        if (hdc.HasTransform())
        {
            // Note: for rotation, we'll rotate the rectangle, but not the image.
            // In case of non-90 degree rotation, it won't do any good, so this needs more work
            AssertSz(hdc.transform().GetAngle() % 900 == 0, "Non-trivial rotation in COleLayout::Draw");
        
            if (prcBounds)
            {
                rcBounds = *prcBounds;
                hdc.transform().Transform(&rcBounds);
                prcBounds = &rcBounds;
            }
            else
            {
                // If there is no prc, need to apply viewport origin 
                // (see the call to SetViewportOrgEx above, and bugs 90270, 90276). 
                HDC hdcTranslate = NULL; // keep compiler happy
                CSize sizeTranslate = g_Zero.size; // keep compiler happy
                if (hdc.GetTranslatedDC(&hdcTranslate, &sizeTranslate))
                {
                    // offset by translation amount
                    // TODO (donmarsh) -- adding to the viewport org is dangerous under Win9x,
                    // because we might silently exceed GDI's 16-bit limitation.  We just ignore
                    // that possibility for now.
                    Assert(rawHDC == hdcTranslate);
                    ::OffsetViewportOrgEx(rawHDC, sizeTranslate.cx, sizeTranslate.cy, &ptOrg);
                }
                else
                    AssertSz(FALSE, "Can't draw windowless OLE control with complex transformation");
            }

            if (prcWBounds)
            {
                rcWBounds = *prcWBounds;
                hdc.transform().Transform(&rcWBounds);
                prcWBounds = &rcWBounds;
            }
        }

        // some controls don't work if the rcBounds.topleft isn't (0,0).  To
        // accommodate them, we offset the rectangles and the viewport origin.
        if (!prcBounds 
            && fCompatNeetsZeroBasedDrawRect    // app compat hack for home publisher... (bug 99738)
            && !pSiteOle->_fWindowlessInplace)  // ...but not for in-place media player (bug 104531)
        {
            rcBounds.SetRect(CPoint(0,0), pDI->_rc.Size());
            prcBounds = &rcBounds;
        }

        //
        // IViewObject::Draw()
        //        
        THR_OLE( pSiteOle->_pVO->Draw(
            pDI->_dwDrawAspect,
            pDI->_lindex,
            pSiteOle->IsOleProxy()
                ? NULL
                : pDI->_pvAspect,
            pDI->_ptd,
            pDI->_hic.GetOleDC(),
            rawHDC,
            (const RECTL *)prcBounds,
            (const RECTL *)prcWBounds,
            pDI->_pfnContinue,
            pDI->_dwContinue));


        //
        // Restore DC (this restores viewport and brush origins too)
        //
        Verify(::RestoreDC(rawHDC, nSavedDC));

        if (fBrushOrgChanged)
        {
            SetBrushOrgEx(
                    hdc,
                    ptBrushOriginSave.x,
                    ptBrushOriginSave.y,
                    NULL);
        }
    }
    else
    {
        // no _pVO
        //
        if (!(pSiteOle->_pUnkCtrl))
        {
            // object hasn't been created, so we show placeholder for it
            //
            XHDC hdc = pDI->GetGlobalDC(TRUE);
            SIZE sizePrint;
            SIZE sizeGrab = {GRABSIZE, GRABSIZE};
            BOOL fPrint = ElementOwner()->GetMarkupPtr()->IsPrintMedia();
            if (fPrint)
            {
                GetPlaceHolderBitmapSize(
                        pSiteOle->_fFailedToCreate,
                        &sizePrint);
                sizePrint.cx = pDI->DeviceFromDocPixelsX(sizePrint.cx);
                sizePrint.cy = pDI->DeviceFromDocPixelsY(sizePrint.cy);
                sizeGrab.cx = pDI->DeviceFromDocPixelsX(GRABSIZE);
                sizeGrab.cy = pDI->DeviceFromDocPixelsY(GRABSIZE);
            }
            
            DrawPlaceHolder(
                    pDI,
                    hdc,
                    pDI->_rc,
                    NULL, CP_UNDEFINED, 0, 0,  // no alt text
                    &sizeGrab,
                    pSiteOle->_fFailedToCreate,
                    0,
                    pSiteOle->GetBackgroundColor(),
                    fPrint ? &sizePrint : NULL,
                    FALSE,
                    pDI->DrawImageFlags());
        }
        else
        {
            // this is created object does not support _pVO
            if (IsEditable())
            {
                // Draw a rectangle so that we don't see garbage in the site
                //
                XHDC hdc = pDI->GetGlobalDC(TRUE);
                HBRUSH hbrOld;

                hbrOld = (HBRUSH) SelectObject(
                                hdc,
                                GetStockObject(LTGRAY_BRUSH));
                Rectangle(
                        hdc,
                        pDI->_rc.left,
                        pDI->_rc.top,
                        pDI->_rc.right,
                        pDI->_rc.bottom);
                SelectObject(hdc, hbrOld);
            }
            else
            {
                TraceTagEx((tagOLEWatch,
                    TAG_NONAME,
                    "TRIDENT Attempt to draw when ViewObject is NULL, site %x",
                    pSiteOle));
            }
        }
    }

Cleanup:

    return;
}


//+-------------------------------------------------------------------------
//
//  Method:     COleLayout::CalcSizeVirtual
//
//  Synopsis:   Calculate the size of the object
//
//--------------------------------------------------------------------------
DWORD
COleLayout::CalcSizeVirtual( CCalcInfo * pci,
                             SIZE *      psize,
                             SIZE *      psizeDefault)
{
    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_INDENT, "(COleLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));

    Assert(pci);
    Assert(psize);
    Assert(ElementOwner());
    WHEN_DBG(SIZE psizeIn = *psize);
    WHEN_DBG(psizeIn = psizeIn); // so we build with vc6.0

    //  TODO (112503, olego) : Do we ever get here with SIZEMODE_SET ???
    Assert(pci->_smMode != SIZEMODE_SET);

    CScopeFlag      csfCalcing(this);
    CDoc          * pDoc         = Doc();
    CSize           sizeOriginal;
    COleSite *      pSiteOle     = DYNCAST(COleSite, ElementOwner());
    RECT            tmpRect      = { 0, 0, 2048, 2048 };
    int             cxBorder;
    int             cyBorder;
    DWORD           grfReturn;
    INSTANTCLASSINFO * pici;

    CSaveCalcInfo   sci(pci, this);

    GetSize(&sizeOriginal);

    if (_fForceLayout)
    {
        pci->_grfLayout |= LAYOUT_FORCE;
        _fForceLayout = FALSE;
    }

    SubtractClientRectEdges(&tmpRect, pci);
    cxBorder = (2048 - tmpRect.right)  + (tmpRect.left - 0);
    cyBorder = (2048 - tmpRect.bottom) + (tmpRect.top  - 0);

    grfReturn  = (pci->_grfLayout & LAYOUT_FORCE);
    SetSizeThis( IsSizeThis() || (pci->_grfLayout & LAYOUT_FORCE) );

    //
    // If sizing or retrieving min/max, handle it here
    //  otherwise, let super handle it.
    //
    if (!(   IsSizeThis()
          || pci->_smMode == SIZEMODE_MMWIDTH
          || pci->_smMode == SIZEMODE_MINWIDTH
          || pci->_smMode == SIZEMODE_SET)
       )
    {
        DWORD dwRet = super::CalcSizeVirtual(pci, psize, psizeDefault);

        TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")COleLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
        return dwRet;
    }


    {
        IOleObject *    pObject       = NULL;
        BOOL            fHaveWidth    = FALSE;
        BOOL            fHaveHeight   = FALSE;
        BOOL            fDelaySetForPercentInTable = FALSE;
        SIZEL           sizel;
        HRESULT         hr;
        
        CTreeNode * pNode            = GetFirstBranch();
        const CFancyFormat * pFF     = pNode->GetFancyFormat();
        const CCharFormat  * pCF     = pNode->GetCharFormat();
        BOOL fVerticalLayoutFlow     = pCF->HasVerticalLayoutFlow();
        BOOL fWritingModeUsed        = pCF->_fWritingModeUsed;
        const CUnitValue & cuvWidth  = pFF->GetLogicalWidth(fVerticalLayoutFlow, fWritingModeUsed);
        const CUnitValue & cuvHeight = pFF->GetLogicalHeight(fVerticalLayoutFlow, fWritingModeUsed);
        CPeerHolder      * pPH       = ElementOwner()->GetLayoutPeerHolder();
        POINT              ptDelegateOffset;

        ptDelegateOffset.x = ptDelegateOffset.y = 0;
        sizel = g_Zero.size;

        _fContentsAffectSize = (cuvWidth.IsNullOrEnum() || cuvHeight.IsNullOrEnum());

        //
        // If There is a peer that wants full_delegation of the sizing...        
        //-------------------------------------------------------------------
        if (   pPH 
            && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_FULLDELEGATION))
        {
            DelegateCalcSize(BEHAVIORLAYOUTINFO_FULLDELEGATION,
                             pPH, pci, *psize, &ptDelegateOffset, psize);

            // now that we have the size, worry about setting the dispnode
            goto SetTheControlSize;
        }

        switch (pci->_smMode)
        {
        case SIZEMODE_MMWIDTH:
        case SIZEMODE_MINWIDTH:
            // If the user didn't specify a size in the html,
            // ask the control for it's preferred size.
            //
            if(PercentWidth())
            {
                psize->cx = 0;
                fHaveWidth = TRUE;
            }

            if(PercentHeight())
            {
                psize->cy = 0;
                fHaveHeight = TRUE;
            }

            // Fall min/max requests through
            // (This is done to allow user specified settings to override
            //  the object's preferred size. Additionally, if the object
            //  does not have a preferred or user set size, the min/max are
            //  the object's current size.)

        case SIZEMODE_NATURAL:
        case SIZEMODE_NATURALMIN:
            // If this control is marked invisible at run time, and we're in
            // browse mode, give it zero size.
            //           
            if ((pSiteOle->_fInvisibleAtRuntime && !IsEditable()) || pSiteOle->_fHidden)
            {
                fHaveWidth = fHaveHeight = TRUE;
                psize->cx = psize->cy = 0;
            }

            // Now see if we can get something directly from the html
            //
            if (!cuvWidth.IsNullOrEnum() && !fHaveWidth)
            {
                psize->cx  = max(0L,
                                 cuvWidth.XGetPixelValue(
                                         pci,
                                         psize->cx,  // Use available space.
                                         pNode->GetFontHeightInTwips(&cuvWidth)));
                psize->cx += cxBorder;
                fHaveWidth = TRUE;
            }
            if (!cuvHeight.IsNullOrEnum() && !fHaveHeight)
            {
                psize->cy   = max(0L,
                                  cuvHeight.YGetPixelValue(
                                         pci,
                                         pci->_sizeParent.cy,
                                         pNode->GetFontHeightInTwips(&cuvHeight)));
                psize->cy += cyBorder;
                fHaveHeight = TRUE;
            }

            // If either the width or height value is missing,
            // fill it in with the object's current size
            //
            if (!fHaveWidth || !fHaveHeight)
            {
                SIZE    size;

                if (!pSiteOle->_hemfSnapshot)
                {
                    hr = THR_OLE(pSiteOle->QueryControlInterface(
                            IID_IOleObject,
                             (void **)&pObject));
                    if (    !hr 
                        &&  pObject )   // (olego) S_OK does not guarantee that pObject is correct. 
                    {
                        hr = THR_OLE(pObject->GetExtent(DVASPECT_CONTENT, &sizel));
                        if (hr && pSiteOle->_state < OS_RUNNING)
                        {
                            hr = THR(pSiteOle->TransitionTo(OS_RUNNING));
                            if (OK(hr))
                            {
                                hr = THR_OLE(pObject->GetExtent(
                                                DVASPECT_CONTENT,
                                                &sizel));
                            }
                        }
                    }
                }
                else
                {
                    ENHMETAHEADER emfh = {EMR_HEADER, sizeof(emfh)};

                    if (GetEnhMetaFileHeader(pSiteOle->_hemfSnapshot, sizeof(emfh), &emfh))
                    {
                        CRect rc(*(RECT *)&emfh.rclFrame);
                        sizel = rc.Size();
                    }

                    hr = S_OK;
                }

                // Use a default size if the request failed
                //
                if (hr)
                {
                    sizel.cx = HimetricFromHPix(16);
                    sizel.cy = HimetricFromVPix(16);
                    hr = S_OK; // so the error does not get propagated
                }

                pci->DeviceFromHimetric(size, sizel);
                size.cx += cxBorder;
                size.cy += cyBorder;

                if (!fHaveWidth)
                {
                    psize->cx = size.cx;
                }
                if (!fHaveHeight)
                {
                    psize->cy = size.cy;
                }
            }

            //
            //  FALL THROUGH
            //

        case SIZEMODE_SET:

            // now that we have a size proposed for the control, we need to 
            // determine if we need to delegate to a layoutBehavior
            if (   pPH 
                && pPH->TestLayoutFlags(BEHAVIORLAYOUTINFO_MODIFYNATURAL))
            {
                DelegateCalcSize(BEHAVIORLAYOUTINFO_MODIFYNATURAL,
                                 pPH, pci, *psize, &ptDelegateOffset, psize);
            }

            // This is here because we likely fell through from the above two cases
            // SIZEMODE_NATURAL requests shoudl continue through to set the object's size
            // SIZEMODE_MM/MINWIDTH requests, however, stop here.
            // all four modes (mm, NATURAL, SET) needed to be delegated to the layoutBehavior
            //
            if (   pci->_smMode == SIZEMODE_MMWIDTH
                || pci->_smMode == SIZEMODE_MINWIDTH)
            {
                psize->cy = psize->cx;

                //  At this point we want to update psize with a new information accounting filter 
                //  for MIN MAX Pass inside table cell.
                if (HasMapSizePeer())
                {
                    //  At this point we want to update psize with a new information accounting filter 
                    CRect rectMapped(CRect::CRECT_EMPTY);
                    // Get the possibly changed size from the peer
                    if(DelegateMapSize(*psize, &rectMapped, pci))
                    {
                        psize->cy = psize->cx = rectMapped.Width();
                    }
                }

                if(pci->_smMode == SIZEMODE_MINWIDTH)
                    psize->cy = 0;

                break;
            }

            // If we are asking for something different than last time,
            // then we negotiate with the control.
            //
SetTheControlSize: 
            // for delegation calls, we come here with the size given by the
            // layoutBehavior, and we treat it in just the same manner as if it
            // was a height=? or width=? specification.
            pci->HimetricFromDevice(sizel,
                                    max(0L,(LONG)(psize->cx - cxBorder)),
                                    max(0L,(LONG)(psize->cy - cyBorder)));

            // Spare the effort of size negotiations if the current size 
            // matches the size we have set to the control last time 
            if (sizel.cx != _sizelLast.cx ||
                sizel.cy != _sizelLast.cy)
            {
                Assert(sizel.cx >= 0);
                Assert(sizel.cy >= 0);


                // if we came from a metafile, then there is no need to negotiate for the size.
                // since it will scale into whatever we give it.
                if (!pSiteOle->_hemfSnapshot)
                {
                    // Need to be running to set the size.
                    //
                    if (!pObject)
                    {
                        pSiteOle->QueryControlInterface(
                                IID_IOleObject,
                                (void **)&pObject);
                    }

                    if (pObject)
                    {

                        // Control must be at least running to set the extent.
                        if (pSiteOle->State() < OS_RUNNING)
                        {
                            IGNORE_HR(pSiteOle->TransitionTo(OS_RUNNING));
                        }

                        // The CDK implementation of IOleObject::SetExtent calls
                        // IOleInplaceSite::OnPosRectChange with the old position
                        // of the control.  We note that we are setting the extent
                        // in order to give OnPosRectChange a reasonable answer.
                        //
                        _sizelLast = sizel;

                        //
                        // percent sized objects in tables often come through on the 
                        // first calc pass with a 0 size.  then on the set pass they get
                        // their real size.  Doing 2 setextents on a windowed control
                        // causes really ugly flashing. This hack is here to not do the 
                        // setextent to a 0 size, and is dependent on the second calc
                        // coming through and giving us a size.  we ONLY bail if this is 
                        // not the setPosition pass.  that way we are gaurenteed to ensure
                        // the dispnode and transition the control
                        //
                        fDelaySetForPercentInTable =    fHaveHeight
                                                     && cuvHeight.IsPercent()
                                                     && pci->_fTableCalcInfo
                                                     && ((CTableCalcInfo*)pci)->_pRowLayout //  this means that we are inside TD or TH 
                                                                                            //  but not a caption or TC.
                                                     && !((CTableCalcInfo*)pci)->_fSetCellPosition;

                        if (!fDelaySetForPercentInTable)
                        {

                            pici = pSiteOle->GetInstantClassInfo();

                            // If pici is NULL, we don't know if COMPAT_NO_SETEXTENT
                            // is set. If this is the case, do not set the extent.
                            //
                            if (pici && !(pici->dwCompatFlags & COMPAT_NO_SETEXTENT))
                            {
                                SIZEL   sizelTemp;

                                {
                                    CElement::CLock lock1(pSiteOle, CElement::ELEMENTLOCK_RECALC);
                                    COleSite::CLock lock2(pSiteOle, COleSite::OLESITELOCK_SETEXTENT);

                                    hr = THR_OLE(pObject->SetExtent(
                                            DVASPECT_CONTENT,
                                            &sizel));
                                }

                                // Some controls don't listen to what we tell them,
                                // so ask the control again about how large it wants
                                // to be.  Basically the control has veto power
                                // over what the html says
                                //
                                if (OK(THR_OLE(pObject->GetExtent(
                                            DVASPECT_CONTENT,
                                            &sizelTemp))))
                                {
                                    _sizelLast = sizel = sizelTemp;
                                }

                                // Reset sizel to zero if we're invisibleatruntime
                                // The ms music control responds with non-zero extent
                                // even after SetExtent(0).  IE4 bug 36598. (anandra)
                                //
                                if ((pSiteOle->_fInvisibleAtRuntime && !IsEditable()) || pSiteOle->_fHidden)
                                {
                                    sizel.cx = sizel.cy = 0;
                                }
                            }
                        }
                    }
                }
            }

            // Take whatever we have at this point as the size.
            //
            pci->DeviceFromHimetric(*psize, sizel);

            // Add in any hspace/vspace and borders.
            //
            psize->cx += cxBorder;
            psize->cy += cyBorder;

            //
            // If dirty, ensure display tree nodes exist
            //

            if (    IsSizeThis()
                &&  (EnsureDispNode(pci, (grfReturn & LAYOUT_FORCE)) == S_FALSE))
            {
                SetPositionAware();
                SetInsertionAware();

                grfReturn |= LAYOUT_HRESIZE | LAYOUT_VRESIZE;
            }

            SetSizeThis( FALSE );
            grfReturn    |= LAYOUT_THIS  |
                            (psize->cx != sizeOriginal.cx
                                    ? LAYOUT_HRESIZE
                                    : 0) |
                            (psize->cy != sizeOriginal.cy
                                    ? LAYOUT_VRESIZE
                                    : 0);

            //
            // Size display nodes if size changes occurred
            //

            if (grfReturn & (LAYOUT_FORCE | LAYOUT_HRESIZE | LAYOUT_VRESIZE))
            {
                SizeDispNode(pci, *psize);
            }

            //if there is a map size peer (like glow filter) that silently modifies the size of
            //the disp node, ask what the size is..
            if(HasMapSizePeer())
                GetApparentSize(psize);

            //
            //  Ensure baseline state
            //
            
            if (pSiteOle->_pUnkCtrl && !fDelaySetForPercentInTable) 
            {
                OLE_SERVER_STATE os = pSiteOle->BaselineState(pDoc->State());

                if (os > pSiteOle->State())
                    pDoc->GetView()->DeferTransition(pSiteOle);
            }

            break;

        default:
            Assert(0);
            break;
        }

        ReleaseInterface(pObject);
    }

    //(dmitryt) call and ignore result - it will use "window detection" code in GetHwnd
    //some tricky (ie smart) controls postpone creation of their window after Activate() 
    //call until container tells them their extent. So they get a window at this point, 
    //after we told then their size. GetHwnd() has a code that catches newborn window
    //and sets some internal vars.
    pSiteOle->GetHwnd();

    TraceTagEx((tagCalcSize, TAG_NONAME|TAG_OUTDENT, ")COleLayout::CalcSizeVirtual L(0x%x, %S) P(%d,%d) S(%d,%d) D(%d,%d) M=%S fL=0x%x f=0x%x dwF=0x%x", CALCSIZETRACEPARAMS ));
    return grfReturn;
}


//+------------------------------------------------------------------------
//
//  Member:     GetMarginInfo
//
//  Synopsis:   add hspace/vspace into the CSS margin
//
//-------------------------------------------------------------------------

void
COleLayout::GetMarginInfo(CParentInfo * ppri,
                          LONG        * plLMargin,
                          LONG        * plTMargin,
                          LONG        * plRMargin,
                          LONG        * plBMargin)
{
    super::GetMarginInfo(ppri, plLMargin, plTMargin, plRMargin, plBMargin);

    if (Tag() == ETAG_OBJECT || Tag() == ETAG_APPLET)
    {
        CObjectElement * pObject = DYNCAST(CObjectElement, ElementOwner());
        BOOL fParentVertical = pObject->GetFirstBranch()->IsParentVertical();
        LONG lhMargin = fParentVertical ? pObject->GetAAvspace() : pObject->GetAAhspace();
        LONG lvMargin = fParentVertical ? pObject->GetAAhspace() : pObject->GetAAvspace();

        if (lhMargin < 0)
            lhMargin = 0;
        if (lvMargin < 0)
            lvMargin = 0;

        lhMargin = ppri->DeviceFromDocPixelsX(lhMargin);
        lvMargin = ppri->DeviceFromDocPixelsY(lvMargin);

        if (plLMargin)
            *plLMargin += lhMargin;
        if (plRMargin)
            *plRMargin += lhMargin;
        if (plTMargin)
            *plTMargin += lvMargin;
        if (plBMargin)
            *plBMargin += lvMargin;
    }
}

#if 1
// TODO (donmarsh) - IE 4 used the following routine to handle extra
// invalidation, which is necessary if we have an asynchronously-drawn OLE
// control.  This actually causes performance degradation for scrolling of
// all OLE controls (not just asynchronous ones), and visible flashing.
// To fix, we need to grab a lock that prevents anything from drawing to the
// screen before our deferred set object rects call is complete.  There isn't
// enough time to make such a drastic change before our beta 2 release, we
// should review this for RTM version.

//+-----------------------------------------------------------------------------
//
// Synopsis:   in assumption that rcOld rectangle was shifted along one axis to
//             rectangle rcNew, this function finds the rectangle of difference
//             between rcOld and rcNew. [if the shift was along 2 axes then the
//             difference will be non-rectangular area]
//
//------------------------------------------------------------------------------
static BOOL
FindRectAreaDifference (CRect * prcRes, const CRect& rcOld, const CRect& rcNew)
{
    Assert (prcRes);

    // if size of prOld is different from size of prNew
    //
    if (rcOld.Width() != rcNew.Width() || rcOld.Height() != rcNew.Height())
    {
        return FALSE;
    }

    if (rcNew.top < rcOld.top)
    {
        // rect was shifted up
        // if also shifted along the other axis
        //
        if (rcNew.left != rcOld.left)
            return FALSE;

        prcRes->SetRect(rcNew.left, rcNew.bottom, rcNew.right, rcOld.bottom);
    }
    else if (rcOld.top < rcNew.top)
    {
        // rect was shifted down
        // if also shifted along the other axis
        //
        if (rcNew.left != rcOld.left)
            return FALSE;

        prcRes->SetRect(rcNew.left, rcOld.top, rcNew.right, rcNew.top);
    }
    else if (rcNew.left < rcOld.left)
    {
        // rect was shifted to the left
        // if also shifted along the other axis
        //
        if (rcNew.top != rcOld.top)
            return FALSE;

        prcRes->SetRect(rcNew.right, rcNew.top, rcOld.right, rcNew.bottom);
    }
    else if (rcOld.left < rcNew.left)
    {
        // rect was shifted to the right
        // if also shifted along the other axis
        //
        if (rcNew.top != rcOld.top)
            return FALSE;

        prcRes->SetRect(rcOld.left, rcNew.top, rcNew.left, rcNew.bottom);
    }
    else
    {
        // position was not changed - set rect to empty
        //
        prcRes->SetRectEmpty();
    }

    return TRUE;
}
#endif


#if DBG==1
extern CLSID CLSID_MPIT_MenuDBG;
#endif 

//+---------------------------------------------------------------------------
//
//  Member:     HandleViewChange
//
//  Synopsis:   Respond to change of in view status
//
//  Arguments:  flags           flags containing state transition info
//              prcClient       client rect in global coordinates
//              prcClip         clip rect in global coordinates
//              pDispNode       node which moved
//
//----------------------------------------------------------------------------
void
COleLayout::HandleViewChange(
    DWORD           flags,
    const RECT*     prcClient,
    const RECT*     prcClip,
    CDispNode*      pDispNode)
{
    COleSite *  pSiteOle = DYNCAST(COleSite, ElementOwner());
    HWND        hwnd;
    BOOL fInvalidate = FALSE;
    
    if (pSiteOle->_state < OS_INPLACE)
    {
        _rcWnd = *prcClient;
        return;
    }
    
    hwnd = pSiteOle->GetHwnd();
    if (hwnd == NULL)
    {
        _rcWnd = *prcClient;
    }
    else
    {
        CTreeNode * pTreeNode = pSiteOle->GetFirstBranch();
        CRect* prcInvalid = NULL;
        CRect rcInvalid;

        if (    pTreeNode->IsVisibilityHidden()
            ||  pTreeNode->IsDisplayNone())
        {
            flags |= VCF_INVIEWCHANGED;
            flags &= ~VCF_INVIEW;
        }
        
        // When positioning objects, we move the object
        // hwnd from under it.  This is for two reasons: it
        // reduces flicker when scrolling because we don't invalidate,
        // and we can then draw the bits on the screen directly as
        // well.  That way when the object calls MoveWindow in response
        // to SetObjectRects, nothing happens.
        
        DWORD positionChangeFlags = SWP_NOACTIVATE | SWP_NOZORDER;
        CRect rcTarget = *prcClient;
        CRect rcWndBefore;
        BOOL fIsClippingOuterWindow = GetView()->IsClippingOuterWindow(hwnd);

        // if it's an MFC-like control, move directly to the clipping rect
        if (fIsClippingOuterWindow)
        {
            rcTarget = *prcClip;
        }
        
        GetView()->GetHWNDRect(hwnd, &rcWndBefore);
        if (!fIsClippingOuterWindow || rcWndBefore.Size() == rcTarget.Size())
        {
            positionChangeFlags |= SWP_NOSIZE;
        }

        if (flags & VCF_INVIEWCHANGED)
        {
            positionChangeFlags |=
                (flags & VCF_INVIEW) ? SWP_SHOWWINDOW : SWP_HIDEWINDOW;
            DeferSetWindowPos(hwnd, &rcTarget, positionChangeFlags, NULL);
        }
        else
        {
            BOOL fClipMoved = ! (rcWndBefore.Size() == CRect(*prcClip).Size() &&
                     (rcWndBefore.TopLeft() - _rcWnd.TopLeft()) ==
                     (CRect(*prcClip).TopLeft() - CRect(*prcClient).TopLeft()));
            if (flags & VCF_NOREDRAW)
            {
                if (!fIsClippingOuterWindow || !fClipMoved)
                {
                    positionChangeFlags |= SWP_NOREDRAW;
                }
                else
                {
                    fInvalidate = TRUE;
                }
#if 1
// TODO (donmarsh) - IE 4 did the following extra invalidation, which
// is necessary to clean up something that gets drawn asynchronously in the
// wrong position before our set object rects call completes.  See comment
// above FindRectAreaDifference.
                if (FindRectAreaDifference(&rcInvalid, _rcWnd, (const CRect&) *prcClient))
                    prcInvalid = &rcInvalid;
#endif
            }
      
            DeferSetWindowPos(hwnd, &rcTarget, positionChangeFlags, prcInvalid);
        }
        
        // remember our new "theoretical" rect to allow subsequent
        // DeferSetWindowPos call above
        _rcWnd = *prcClient;
        
        // (alexz) (anandra)
        // set window region to clip rectangle. This eliminates
        // flickering for several controls - e.g. several of ncompass
        // controls or proto view treeview. These controls flicker
        // if rcClip is different from rc in SetObjectRects,
        // which, however, gets fixed by proper call to SetWindowRgn.
        // rc can be different from rcClip very often - during
        // scrolling when object is only partially visible.
        // NOTE: This used to be done only for a known set of controls (via a compatibility flag).
        //       However, it turns out that more controls need it so now it is done all the
        //       time. (brendand)
        // Bugs: # 37662, 43877, 43885.

        //
        //  NOTE: The call to SetWindowRgn has been changed from asynch to synch since the asynch form
        //        results in the 3rd party application, FirstAid, faulting! (brendand/kensy)
        //

        {
            CRect rcClip(*prcClip);
            rcClip.OffsetRect(-rcTarget.TopLeft().AsSize());
            // prevent reentry of Display Tree if the following calls cause
            // a WM_ERASEBKGND message to be sent
            CServer::CLock Lock(Doc(), SERVERLOCK_IGNOREERASEBKGND);

#if defined(ALWAYS_DEFER_SET_WINDOW_RGN)
            BOOL fDeferSWR = TRUE;
            
#  if DBG == 1
            if (IsTagEnabled(tagDeferSetWindowRgn))
            {
                INSTANTCLASSINFO * pici = pSiteOle->GetInstantClassInfo();
                fDeferSWR = (pici && (pici->dwCompatFlags & COMPAT_ALWAYSDEFERSETWINDOWRGN));
            }
#  endif
            if (fDeferSWR)
#else
            INSTANTCLASSINFO * pici = pSiteOle->GetInstantClassInfo();

            if ((pici && (pici->dwCompatFlags & COMPAT_ALWAYSDEFERSETWINDOWRGN))
#  if DBG == 1
                    ||  IsTagEnabled(tagDeferSetWindowRgn)
#  endif
                )
#endif
            {
                DeferSetWindowRgn(hwnd, &rcClip, !prcInvalid);
            }
            else
            {
                SetWindowRgn(hwnd, &rcClip, !prcInvalid);
            }
        }
    }

    // 
    // (olego) apphack fix for IE6 bug 25970. Due to incorrect implementation 
    // of MPIT.Menu control, call to IOleInPlaceObject::SetObjectRects would 
    // reposition its window to (0, 0)...
    // 
    if (pSiteOle->_fAppHack_MPIT_Menu)
    {
        Assert(pSiteOle->_clsid == CLSID_MPIT_MenuDBG);
        return;
    }
    
    CRect rcClient(*prcClient);
    CRect rcClip(*prcClip);

    if (pSiteOle->IsDisplayNone() || pSiteOle->IsVisibilityHidden())
        rcClient.SetRect(-1, -1, -1, -1);

    if (pSiteOle->ClipViaHwndOnly())
        rcClip = rcClient;

    DeferSetObjectRects(
        pSiteOle->_pInPlaceObject,
        (RECT*) &rcClient,
        (RECT*) &rcClip,
        hwnd,
        fInvalidate);

}


//+---------------------------------------------------------------------------
//
//  Member:     COleLayout::WantsToBeObscured
//              
//  Synopsis:   Should this control be obscured by content higher up in
//              the z-order (which requires clipping its window)
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
COleLayout::WantsToBeObscured(CDispNode *pDispNode) const
{
    COleSite *  pSiteOle = DYNCAST(COleSite, ElementOwner());
    
    if (pSiteOle && pSiteOle->_state >= OS_INPLACE)
    {
        HWND hwnd = pSiteOle->GetHwnd();
        if (hwnd && pDispNode == GetElementDispNode())
        {
            return TRUE;
        }
    }

    // don't need special clipping if there's no HWND
    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Member:     COleLayout::Obscure
//              
//  Synopsis:   Obscure the control, by clipping it to the given region
//              
//----------------------------------------------------------------------------

void
COleLayout::Obscure(CRect *prcgClient, CRect *prcgClip, CRegion2 *prgngVisible)
{
    HWND hwnd = NULL;
    COleSite *  pSiteOle = DYNCAST(COleSite, ElementOwner());
    
    if (pSiteOle && pSiteOle->_state >= OS_INPLACE)
    {
        hwnd = pSiteOle->GetHwnd();
    }
    
    AssertSz(hwnd, "No window for obscured control");
    if (!hwnd)
        return;

    HRGN hrgn = prgngVisible->ConvertToWindows();
    CRect rcgTarget = GetView()->IsClippingOuterWindow(hwnd) ? *prcgClip : *prcgClient;
    CRect *prcClip = NULL;
    CRect rcClip;

    // We're about to clip the control's window via SetWindowRgn.
    // Update the pending SetObjectRects clipping rect as best we
    // can (if we're using SOR to clip at all).  This eliminates some
    // flashing (bug 108347).
    if (!pSiteOle->ClipViaHwndOnly())
    {
        if (prgngVisible->GetBoundingRect(rcClip))
        {
            rcClip.OffsetRect(-rcgTarget.left, -rcgTarget.top);
        }
        else
        {
            rcClip.SetRectEmpty();
        }
        prcClip = &rcClip;
    }

    if (::OffsetRgn(hrgn, -rcgTarget.left, -rcgTarget.top) != ERROR)
    {
        DeferSetWindowRgn(hwnd, hrgn, prcClip, TRUE);
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     COleLayout::ProcessDisplayTreeTraversal
//              
//  Synopsis:   Add our window to the z order list.
//              
//  Arguments:  pClientData     window order information
//              
//  Returns:    TRUE to continue display tree traversal
//              
//  Notes:      
//              
//----------------------------------------------------------------------------

BOOL
COleLayout::ProcessDisplayTreeTraversal(void *pClientData)
{
    COleSite *  pSiteOle = DYNCAST(COleSite, ElementOwner());
    
    if (pSiteOle && pSiteOle->_state >= OS_INPLACE)
    {
        HWND hwnd = pSiteOle->GetHwnd();
        if (hwnd)
        {
            CView::CWindowOrderInfo* pWindowOrderInfo =
                (CView::CWindowOrderInfo*) pClientData;
            pWindowOrderInfo->AddWindow(hwnd);
        }
    }
    
    return TRUE;
}



//+---------------------------------------------------------------------------
//
//  Member:     COleLayout::HitTestContent
//
//  Synopsis:   Determine if the given display leaf node contains the hit point.
//
//  Arguments:  pptHit          hit test point
//              pDispNode       pointer to display node
//              pClientData     client-specified data value for hit testing pass
//
//  Returns:    TRUE if the display leaf node contains the point
//
//----------------------------------------------------------------------------

BOOL
COleLayout::HitTestContent(
    const POINT *   pptHit,
    CDispNode *     pDispNode,
    void *          pClientData,
    BOOL            fDeclinedByPeer)
{
    Assert(pptHit);
    Assert(pDispNode);
    Assert(pClientData);

    COleSite *  pSiteOle = DYNCAST(COleSite, ElementOwner());
    CHitTestInfo *  phti = (CHitTestInfo *) pClientData;
    HTC htc = HTC_YES;
    BOOL fRet = TRUE;

    Assert(pSiteOle);

    if (pSiteOle->_fUseViewObjectEx)
    {
        DWORD dwHitResult = HITRESULT_OUTSIDE;

        if (pSiteOle->_pVO)
        {
            RECT rcClient;

            GetClientRect(&rcClient);

            if (FAILED(((IViewObjectEx *) (pSiteOle->_pVO))->QueryHitPoint(
                                                    DVASPECT_CONTENT,
                                                    &rcClient,
                                                    *pptHit,
                                                    0,
                                                    &dwHitResult)))
                dwHitResult = HITRESULT_OUTSIDE;
        }

        if (dwHitResult == HITRESULT_OUTSIDE)
        {
            htc = HTC_NO;
            fRet = FALSE;
        }
        else if (dwHitResult != HITRESULT_HIT)   // HITRESULT_TRANSPARENT or HITRESULT_CLOSE
        {
            fRet = FALSE;
        }
    }

    if ((phti->_htc == HTC_NO) || fRet)
    {
        phti->_htc = htc;

        if (htc == HTC_YES)
        {
            phti->_pNodeElement = ElementContent()->GetFirstBranch();
            phti->_ptContent    = *pptHit;
            phti->_pDispNode    = pDispNode;
            phti->_phtr->_fWantArrow = TRUE;
        }
    }

    return(fRet);
}

//+---------------------------------------------------------------------------
//  Member:     COleLayout::DragEnter
//
//  Synopsis:   This is called when an object is started to be dragged over this 
//              layout area. If the inplace object is a windowless control, then 
//              the call is delegated to the control. Otherwise, the call is 
//              delegated to the super.
//----------------------------------------------------------------------------
HRESULT 
COleLayout::DragEnter(
                    IDataObject *pDataObj,
                    DWORD grfKeyState,
                    POINTL pt,
                    DWORD *pdwEffect)
{
    HRESULT             hr;
    IDropTarget *       pDT = NULL;
    COleSite    *       pSiteOle = DYNCAST(COleSite, ElementOwner());
    IPointerInactive *  pPI = NULL;
    DWORD               dwPolicy = 0;

    // check if the control needs to be activated because of the drag drop operation
    if (pSiteOle->_state < OS_INPLACE)
    {
        // the control is not inplace active, inplace activation is needed.

        if (!THR_NOTRACE(pSiteOle->QueryControlInterface(IID_IPointerInactive, (void **) &pPI)))
        {
            hr = THR(pPI->GetActivationPolicy(&dwPolicy));
            if (hr)
                goto Cleanup;

            // should we activate the control if not active?
            if (dwPolicy & POINTERINACTIVE_ACTIVATEONDRAG)
            {
                hr = THR(pSiteOle->TransitionTo(OS_INPLACE, NULL));
                if (hr)
                    goto Cleanup;
            }
        }
    }
    
    // if the ole site is a windowless control, we must delegate the call to the control.
    if (pSiteOle->_fWindowlessInplace)
    {
        // check if the control has a drop target.
        hr = THR_OLE(((IOleInPlaceObjectWindowless *)pSiteOle->_pInPlaceObject)->GetDropTarget(&pDT));

#if DBG == 1
        if ( SUCCEEDED( hr) )
        {
            AssertSz( pDT , "You're returning S_OK - but no DropTarget. This is incorrect ( and not an MSHTML bug)");
        }            
#endif
        if (!hr && pDT)
        {

            
// CONSIDERATION: (ferhane)
// In the call below, if the DragEnter is returning S_FALSE then it means that 
// the control is trying to delegate the call to us. We could immediately drop step and 
// call the super for the hr==S_FALSE case, instead of returning S_FALSE to the caller.
// However, that would require us to keep track of which data types was refused by this
// control, so that we could not call it but process the call ourselves for the following 
// DragOver and Drop calls that we would receive.
// According to spec, there is no guarantee that any of the IDropTarget methods other than
// the DragEnter would return S_FALSE. So, we are the ones ending up tracking this ... 

            //delegate the call
            hr = THR_OLE(pDT->DragEnter(pDataObj, grfKeyState, pt, pdwEffect));
                goto Cleanup;            
        }
    }

    // Handle the call as if there was not a windowless control..
    hr = THR_OLE(super::DragEnter(pDataObj, grfKeyState, pt, pdwEffect));

Cleanup:
    ReleaseInterface(pDT);
    ReleaseInterface(pPI);

    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//  Member:     COleLayout::DragOver
//
//  Synopsis:   This is called when an object is being dragged over this layout 
//              area. If the inplace object is a windowless control, then the 
//              call is delegated to the control. Otherwise, the call is delegated 
//              to the super.
//----------------------------------------------------------------------------
HRESULT 
COleLayout::DragOver(DWORD grfKeyState, POINTL pt, DWORD * pdwEffect)
{
    HRESULT         hr;
    IDropTarget *   pDT = NULL;
    COleSite    *   pSiteOle = DYNCAST(COleSite, ElementOwner());

    // if the ole site is a windowless control, we must delegate the call to the control.
    if (pSiteOle->_fWindowlessInplace)
    {
        // check if the control has a drop target.
        hr = THR_OLE(((IOleInPlaceObjectWindowless *)pSiteOle->_pInPlaceObject)->GetDropTarget(&pDT));

#if DBG == 1
        if ( SUCCEEDED( hr) )
        {
            AssertSz( pDT , "You're returning S_OK - but no DropTarget. This is incorrect ( and not an MSHTML bug)");
        }            
#endif
        if (!hr && pDT)        
        {
            //delegate the call
            hr = THR_OLE(pDT->DragOver( grfKeyState, pt, pdwEffect));
            goto Cleanup;
        }
    }

    // Handle the call as if there was not a windowless control..
    hr = THR_OLE(super::DragOver( grfKeyState, pt, pdwEffect));

Cleanup:
    ReleaseInterface(pDT);

    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//  Member:     COleLayout::Drop
//
//  Synopsis:   This is called when an object is dropped on this layout area.
//              If the inplace object is a windowless control, then the call is 
//              delegated to the control. Otherwise, the call is delegated to the 
//              super.
//----------------------------------------------------------------------------
HRESULT 
COleLayout::Drop(   IDataObject *pDataObj,
                    DWORD grfKeyState,
                    POINTL pt,
                    DWORD *pdwEffect)
{
    HRESULT         hr;
    IDropTarget *   pDT = NULL;
    COleSite    *   pSiteOle = DYNCAST(COleSite, ElementOwner());

    // if the ole site is a windowless control, we must delegate the call to the control.
    if (pSiteOle->_fWindowlessInplace)
    {
        // check if the control has a drop target.
        hr = THR_OLE(((IOleInPlaceObjectWindowless *)pSiteOle->_pInPlaceObject)->GetDropTarget(&pDT));

#if DBG == 1
        if ( SUCCEEDED( hr) )
        {
            AssertSz( pDT , "You're returning S_OK - but no DropTarget. This is incorrect ( and not an MSHTML bug)");
        }            
#endif
        if (!hr && pDT)        
        {
            //delegate the call
            hr = THR_OLE(pDT->Drop( pDataObj, grfKeyState, pt, pdwEffect));
            goto Cleanup;
        }
    }

    // Handle the call as if there was not a windowless control..
    hr = THR_OLE(super::Drop( pDataObj, grfKeyState, pt, pdwEffect));

Cleanup:
    ReleaseInterface(pDT);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//  Member:     COleLayout::DragLeave
//
//  Synopsis:   This is called when an object that was being dragged over this area 
//              leaves the area. If the inplace object is a windowless control, then the 
//              call is delegated to the control. Otherwise, the call is delegated 
//              to the super.
//----------------------------------------------------------------------------
HRESULT 
COleLayout::DragLeave()
{
    HRESULT         hr;
    IDropTarget *   pDT = NULL;
    COleSite    *   pSiteOle = DYNCAST(COleSite, ElementOwner());

    // if the ole site is a windowless control, we must delegate the call to the control.
    if (pSiteOle->_fWindowlessInplace)
    {
        // check if the control has a drop target.
        hr = THR_OLE(((IOleInPlaceObjectWindowless *)pSiteOle->_pInPlaceObject)->GetDropTarget(&pDT));

#if DBG == 1
        if ( SUCCEEDED( hr) )
        {
            AssertSz( pDT , "You're returning S_OK - but no DropTarget. This is incorrect ( and not an MSHTML bug)");
        }            
#endif
        if (!hr && pDT)        
        {
            //delegate the call
            hr = THR_OLE(pDT->DragLeave());
            goto Cleanup;
        }
    }

    // Handle the call as if there was not a windowless control..
    hr = THR_OLE(super::DragLeave());

Cleanup:
    ReleaseInterface(pDT);

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\layout\tarealyt.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1998
//
//  File:       tarealyt.cxx
//
//  Contents:   Implementation of layout class for <RICHTEXT> <TEXTAREA> controls.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_RECT_HXX_
#define X_RECT_HXX_
#include "rect.hxx"
#endif

#ifndef X_SIZE_HXX_
#define X_SIZE_HXX_
#include "size.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_TAREALYT_HXX_
#define X_TAREALYT_HXX_
#include "tarealyt.hxx"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif

#ifndef X__FONTLNK_H_
#define X__FONTLNK_H_
#include "_fontlnk.h"
#endif

#ifndef X_TEXTAREA_HXX_
#define X_TEXTAREA_HXX_
#include "textarea.hxx"
#endif

#ifndef X__FONT_H_
#define X__FONT_H_
#include "_font.h"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_THEMEHLP_HXX_
#define X_THEMEHLP_HXX_
#include "themehlp.hxx"
#endif

#ifndef X__TEXT_H_
#define X__TEXt_H_
#include "_text.h"
#endif

MtDefine(CTextAreaLayout, Layout, "CTextAreaLayout")
MtDefine(CRichtextLayout, Layout, "CRichtextLayout")

extern void DrawTextSelectionForRect(XHDC hdc, CRect *prc, CRect *prcClip, BOOL fSwapColor);

const CLayout::LAYOUTDESC CRichtextLayout::s_layoutdesc =
{
    LAYOUTDESC_FLOWLAYOUT,          // _dwFlags
};

HRESULT
CRichtextLayout::Init()
{
    HRESULT hr = S_OK;

    hr = super::Init();

    if(hr)
        goto Cleanup;

    _fAllowSelectionInDialog = TRUE;

    // Can NOT be broken
    SetElementCanBeBroken(FALSE);

Cleanup:
    RRETURN(hr);
}

void
CRichtextLayout::SetWrap()
{
    BOOL    fWrap = IsWrapSet();

    GetDisplay()->SetWordWrap(fWrap);
    GetDisplay()->SetWrapLongLines(fWrap);
}

BOOL
CRichtextLayout::IsWrapSet()
{
    return (DYNCAST(CRichtext, ElementOwner())->GetAAwrap() != htmlWrapOff);
}

HRESULT
CRichtextLayout::OnTextChange(void)
{
    CRichtext *     pInput  = DYNCAST(CRichtext, ElementOwner());

    if (!pInput->IsEditable(TRUE))
        pInput->_fTextChanged = TRUE;

    if (pInput->_fFiredValuePropChange)
    {
        pInput->_fFiredValuePropChange = FALSE;
    }
    else
    {
        pInput->OnPropertyChange(DISPID_CRichtext_value, 
                                 0,
                                 (PROPERTYDESC *)&s_propdescCRichtextvalue); // value change
    }
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CRichtextLayout::DrawClient
//
//  Synopsis:   Draw client rect part of the controls
//
//  Arguments:  prcBounds       bounding rect of display leaf node
//              prcRedraw       rect to be redrawn
//              pSurface        surface to render into
//              pDispNode       pointer to display node
//              pClientData     client-dependent data for drawing pass
//              dwFlags         flags for optimization
//
//----------------------------------------------------------------------------

void
CRichtextLayout::DrawClient(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          cookie,
    void *          pClientData,
    DWORD           dwFlags)
{
    Assert(pClientData);

    CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;

    {
        // we set draw surface information separately for Draw() and
        // the stuff below, because the Draw method of some subclasses
        // (like CFlowLayout) puts pDI into a special device coordinate
        // mode
        CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);
        Draw(pDI);
    }

    {
        // see comment above
        CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);

        // We only want to paint selection on the client rect in this part
        // In RTL the scrollbar is on the left and will leave extra highlighting
        // on the right side of the control if we do not adjust it here
        if (_fTextSelected)
        {
            DrawTextSelectionForRect(pDI->GetDC(), (CRect *)prcRedraw ,& pDI->_rcClip , _fSwapColor);
        }

        // just check whether we can draw zero border at design time
        if (IsShowZeroBorderAtDesignTime())
        {
            CLayout* pParentLayout = GetUpdatedParentLayout();
            if ( pParentLayout && pParentLayout->IsEditable() )
            {
                 DrawZeroBorder(pDI);
            }
        }
    }
}


void
CRichtextLayout::DrawClientBorder(
    const RECT *    prcBounds,
    const RECT *    prcRedraw,
    CDispSurface *  pDispSurface,
    CDispNode *     pDispNode,
    void *          pClientData,
    DWORD           dwFlags)
{
    CRichtext *     pElem = DYNCAST(CRichtext, ElementOwner());
    HTHEME          hTheme = pElem->GetTheme(THEME_EDIT);

    Assert(pClientData);

    if (hTheme)
    {
        CFormDrawInfo * pDI = (CFormDrawInfo *)pClientData;
        CSetDrawSurface sds(pDI, prcBounds, prcRedraw, pDispSurface);
        XHDC            hdc    = pDI->GetDC(TRUE);
        CRect           rc;        

        if (hdc.DrawThemeBackground(    hTheme,
                                        EP_EDITTEXT,
                                        pElem->GetThemeState(),
                                        &pDI->_rc,
                                        NULL))
            return;
        else
            super::DrawClientBorder(prcBounds,
                                prcRedraw,
                                pDispSurface,
                                pDispNode,
                                pClientData,
                                dwFlags);

    }
    super::DrawClientBorder(prcBounds,
                                prcRedraw,
                                pDispSurface,
                                pDispNode,
                                pClientData,
                                dwFlags);
}

void
CTextAreaLayout::GetPlainTextWithBreaks(TCHAR * pchBuff)
{
    CDisplay *  pdp = GetDisplay();
    CTxtPtr     tp(pdp->GetMarkup(), GetContentFirstCp());
    long        i;
    long        c = pdp->Count();
    CLineCore  *pLine;

    for(i = 0; i < c; i++)
    {
        pLine = pdp->Elem(i);

        if (pLine->_cch)
        {
            tp.GetRawText(pLine->_cch, pchBuff);
            tp.AdvanceCp(pLine->_cch);
            pchBuff += pLine->_cch;

            // If the line ends in a '\r', we need to append a '\r'.
            // Otherwise, it must be having a soft break (unless it is
            // the last line), so we need to append a '\r\n'
            if (pLine->_fHasBreak)
            {
                Assert(*(pchBuff - 1) == _T('\r'));
                *pchBuff++ = _T('\n');
            }
            else if ( i < c - 1)
            {
                *pchBuff++ = _T('\r');
                *pchBuff++ = _T('\n');
            }
        }
    }
    // Null-terminate
    *pchBuff = 0;
}

long
CTextAreaLayout::GetPlainTextLengthWithBreaks()
{
    long        len     = 1; // for trailing '\0'
    long        i;
    CDisplay *  pdp = GetDisplay();
    long        c = pdp->Count();
    CLineCore  *pLine;

    for(i = 0; i < c; i++)
    {
        // Every line except the last must be non-empty.
        Assert(i == c - 1 || pdp->Elem(i)->_cch > 0);

        pLine = pdp->Elem(i);
        Assert(pLine);
        len += pLine->_cch;

        // If the line ends in a '\r', we need to append a '\r'.
        // Otherwise, it must be having a soft break (unless it is
        // the last line), so we need to append a '\r\n'
        if (pLine->_fHasBreak)
        {
            len++;
        }
        else if (i < c - 1)
        {
            len += 2;
        }
    }

    return len;
}

void CRichtextLayout::GetDefaultSize(CCalcInfo *pci, SIZE &psize, BOOL *fHasDefaultWidth, BOOL *fHasDefaultHeight)
{
    SIZE            sizeFontForShortStr;
    SIZE            sizeFontForLongStr;
    CRichtext     * pTextarea = DYNCAST(CRichtext, ElementOwner());
    CTreeNode *     pTreeNode = pTextarea->GetFirstBranch();
    int             charX = 1;
    int             charY = 1;
    BOOL            fIsPrinting = ElementOwner()->GetMarkupPtr()->IsPrintMedia();
    styleOverflow   overflow;
    extern SIZE     g_sizelScrollbar;
    const CCharFormat * pCF = pTreeNode->GetCharFormat();
    SIZE            sizeInset;

    sizeInset.cx = TEXT_INSET_DEFAULT_RIGHT + TEXT_INSET_DEFAULT_LEFT;
    sizeInset.cy = TEXT_INSET_DEFAULT_TOP   + TEXT_INSET_DEFAULT_BOTTOM;

    charX = pTextarea->GetAAcols();
    Assert(charX > 0);
    charY = pTextarea->GetAArows();
    Assert(charY > 0);

    GetFontSize(pci, &sizeFontForShortStr, &sizeFontForLongStr);
        
    psize.cx = charX * sizeFontForLongStr.cx
                + pci->DeviceFromDocPixelsX(sizeInset.cx
                                        + (fIsPrinting ? 0 : GetDisplay()->GetCaret()));
    psize.cy = charY * sizeFontForLongStr.cy
                + pci->DeviceFromDocPixelsY(sizeInset.cy);

    overflow = pTreeNode->GetFancyFormat()->GetLogicalOverflowY(pCF->HasVerticalLayoutFlow(), pCF->_fWritingModeUsed);
    if (overflow != styleOverflowHidden)
    {
        psize.cx += pci->DeviceFromHimetricX(g_sizelScrollbar.cx);
        if (!IsWrapSet())
        {
            psize.cy += pci->DeviceFromHimetricY(g_sizelScrollbar.cy);
        }
    }

    AdjustSizeForBorder(&psize, pci, TRUE);
    SetWrap();

    *fHasDefaultWidth = TRUE;
    *fHasDefaultHeight = TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\misc\siteid.c ===
/*
   siteid.c

   Please do not use any single line comments before the inclusion of w4warn.h!
*/

#define INITGUID
#include <w4warn.h>
#ifdef WIN16
#include <windows.h>
#else
#include <windef.h>
#endif
#include <basetyps.h>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#define PRIVATE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8)

#include <siteguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\layout\viewchain.cxx ===
//+---------------------------------------------------------------------------
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1999
//
//  File:       VIEWCHAIN.CXX
//
//  Contents:   Implementation of CViewChain and related classes.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_VIEWCHAIN_HXX_
#define X_VIEWCHAIN_HXX_
#include "viewchain.hxx"
#endif

MtDefine(CViewChain_pv, ViewChain, "CViewChain_pv");
MtDefine(CViewChain_aryRequest_pv, ViewChain, "CViewChain_aryRequest_pv");

DeclareTag(tagVCContext, "Layout: ViewChain", "Trace Add/Remove context to ViewChain");

//============================================================================
//
//  CViewChain methods
//
//============================================================================

//----------------------------------------------------------------------------
//
//  Member: AddContext
//
//  Note:   Allocates new break table object for context document and inserts 
//          it after pLContextPrev.
//----------------------------------------------------------------------------
HRESULT 
CViewChain::AddContext(CLayoutContext *pLContext, CLayoutContext *pLContextPrev)
{
    HRESULT     hr;
    CBreakBase *pBreakTable;

    TraceTagEx((tagVCContext, TAG_NONAME,
                "VC AddContext: this=0x%x, add=0x%x, prev=0x%x",
                this,
                pLContext, pLContextPrev ));

    Assert(pLContext != NULL);

    pBreakTable = new CBreakTable();
    if (pBreakTable == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = _bt.SetBreakAfter((void *)pLContext, (void *)pLContextPrev, pBreakTable);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

Cleanup:
    return (hr);
}

//----------------------------------------------------------------------------
//
//  Member: ReleaseContext
//
//  Note:   Removes array entry (and all data) for pLContext 
//----------------------------------------------------------------------------
HRESULT 
CViewChain::ReleaseContext(CLayoutContext *pLContext)
{
    HRESULT hr;

    TraceTagEx((tagVCContext, TAG_NONAME,
                "VC ReleaseContext: this=0x%x, rel=0x%x",
                this,
                pLContext ));

    Assert(pLContext != NULL);
    
    hr = _bt.RemoveBreak((void *)pLContext);
    Assert(SUCCEEDED(hr));

    return (hr);
}

//----------------------------------------------------------------------------
//
//  Member: RemoveLayoutBreak
//
//  Note:   Removes break data for certain element in certain layout context.
//----------------------------------------------------------------------------
HRESULT 
CViewChain::RemoveLayoutBreak(CLayoutContext *pLContext, CElement *pElement)
{
    HRESULT         hr = S_OK;
    CBreakBase      *pBreakTable;

    Assert( HasLayoutOwner() );

    hr = _bt.GetBreak((void *)pLContext, &pBreakTable);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    if (pBreakTable)
    {
        hr = DYNCAST(CBreakTable, pBreakTable)->GetLayoutBreakTable()->RemoveBreak((void *)pElement);
    }

Cleanup:
    return (hr);
}

//----------------------------------------------------------------------------
//
//  Member: SetLayoutBreak
//
//  Note:   Sets break data for certain element in certain layout context.
//----------------------------------------------------------------------------
HRESULT 
CViewChain::SetLayoutBreak(CLayoutContext *pLContext, 
                     CElement *pElement, CLayoutBreak *pLayoutBreak)
{
    HRESULT         hr = S_OK;
    CBreakBase      *pBreakTable;

    Assert( HasLayoutOwner() );

    hr = _bt.GetBreak((void *)pLContext, &pBreakTable);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    if (pBreakTable)
    {
        hr = DYNCAST(CBreakTable, pBreakTable)->GetLayoutBreakTable()->SetBreak((void *)pElement, pLayoutBreak);
    }

Cleanup:
    return (hr);
}

//----------------------------------------------------------------------------
//
//  Member: GetLayoutBreak
//
//  Note:   Retrieves break data for certain element in certain layout context.
//          Actually break data for previous layout context is returned 
//          (beginning of the rectangle is the ending of previous one). 
//----------------------------------------------------------------------------
HRESULT 
CViewChain::GetLayoutBreak(CLayoutContext *pLContext, 
                     CElement *pElement, CLayoutBreak **ppLayoutBreak, BOOL fEnding)
{
    HRESULT         hr = S_OK;
    CBreakBase      *pBreakTable;
    CBreakBase      *pLayoutBreak;

    Assert( HasLayoutOwner() );
    Assert(ppLayoutBreak);

    *ppLayoutBreak = NULL;

    hr = _bt.GetBreakByIndex(_bt.GetIndex((void *)pLContext) - (fEnding ? 0 : 1), &pBreakTable);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    if (pBreakTable)
    {
        hr = DYNCAST(CBreakTable, pBreakTable)->GetLayoutBreakTable()->GetBreak((void *)pElement, &pLayoutBreak);
        *ppLayoutBreak = DYNCAST(CLayoutBreak, pLayoutBreak);
    }

Cleanup:
    return (hr);
}

//----------------------------------------------------------------------------
//
//  Member: EnsureCleanToContext
//
//  Note:   Sends appropriate notifications to ensure that all dirty contexts in the
//          view chain prior to the one passed in will be measured.  If they
//          are all currently clean (not including the one passed in), return TRUE,
//          else return FALSE.
//----------------------------------------------------------------------------
BOOL
CViewChain::EnsureCleanToContext( CLayoutContext *pLContext )
{
    int              i               = 0;
    CBreakBase      *pBreakTable     = NULL;
    CLayoutContext  *pLC             = NULL;
    void            *pV              = NULL;
    BOOL             fCleanToContext = TRUE;

    Assert( HasLayoutOwner() );

    for (;;)
    {
        _bt.GetKeyByIndex( i, &pV );
        // TODO (112510, olego): Can't do a dynamic_cast from void *; 
        // think about changing the type of _pKey in CBreakTable
        pLC = (CLayoutContext *)pV;
        // GetKeyByIndex will return NULL when we reach the end of the array.
        // Stop processing once we've reached the context passed in.
        if ( !pLC || pLC->IsEqual( pLContext ))
            break;

        _bt.GetBreakByIndex( i, &pBreakTable );
        AssertSz( pBreakTable, "Must have a valid break if we found a key" );

        if ( pBreakTable->IsDirty() )
        {
            // If we found a dirty break, we must return false and
            // queue a request to get the break measured.
            fCleanToContext = FALSE;

            // remesuring layout rect that does not have content element yet 
            // has no sense...
            if (ElementContent())
            {
                pLC->GetLayoutOwner()->ElementOwner()->RemeasureElement();
            }
        }

        ++i;
    }

    return fCleanToContext;
}

//----------------------------------------------------------------------------
//
//  Member: MarkContextClean
//
//  Note:   Marks the breaktable for this context as clean
//----------------------------------------------------------------------------
HRESULT
CViewChain::MarkContextClean( CLayoutContext *pLContext )
{
    CBreakBase     *pBreakTable;
    HRESULT         hr = E_FAIL;

    hr = _bt.GetBreak((void *)pLContext, &pBreakTable);
    if ( SUCCEEDED(hr) )
    {
        Assert( pBreakTable );
        pBreakTable->SetDirty( FALSE );
    }

    return hr;
}

//----------------------------------------------------------------------------
//
//  Member: SetLayoutOwner
//
//----------------------------------------------------------------------------
void
CViewChain::SetLayoutOwner(CLayout *pLayoutOwner)
{ 
    if (!pLayoutOwner)
    {
        CLayoutContext  *pLayoutContext = NULL;
        CLayout         *pLayout        = NULL;
        void            *pV             = NULL;
        int              i;

        Assert(HasLayoutOwner());  // Someone needs to have a ref to us that we won't release in the loop below

        // NB: (greglett)
        // Other people may be removing the break we're looking at as we're looking at it.
        // If we iterate from 0 to size, then our indecies get messed up.
        // So, we iterate from size to 0.
        for (i=_bt.Size() - 1;i >= 0;i--)
        {            
            _bt.GetKeyByIndex( i, &pV );    

            if (!pV)
                break;

            // TODO (112510, olego): Can't do a dynamic_cast from void *; 
            // think about changing the type of _pKey in CBreakTable
            pLayoutContext = (CLayoutContext *)pV;
            pLayout  = pLayoutContext->GetLayoutOwner();
            Assert(pLayout);

            // Don't set the view chain on our owner - our owner is likely fiddling with us right now.
            if (pLayout != GetLayoutOwner())
            {
                // 
                // (bug # 104682) At this point container layout MUST be destroyed to ensure:
                // 1. Layout Context defined by container layout will be destroyed;
                // 2. Display node of this container layout will be deleted from the display tree. 
                // 
                CElement *pElement = pLayout->ElementOwner();

                //  Container Layout MUST be allowed to destroyed
                Assert(!pElement->_fLayoutAlwaysValid);

                if (pElement->HasLayoutPtr())
                {
                    WHEN_DBG(CLayout *pLayoutDbg =)
                    pElement->DelLayoutPtr();
                    Assert(pLayoutDbg == pLayout);

                    pLayout->Detach();
                    pLayout->Release();
                }
                else if (pElement->HasLayoutAry())
                {
                    pElement->DelLayoutAry(); // will take care of detaching/releasing its layouts
                }
            }
        }
    }

     _pLayoutOwner = pLayoutOwner;
}


//----------------------------------------------------------------------------
//
//  Member: ElementContent()
//
//  Note:   Returns the content element that this chain is measuring.
//          Obtained from the layout owner's slave ptr.
//----------------------------------------------------------------------------
CElement *
CViewChain::ElementContent()
{
    return ( HasLayoutOwner() ? _pLayoutOwner->ElementContent() : NULL );
}

//----------------------------------------------------------------------------
//
//  Member: YOffsetForContext()
//
//  Note:   Returns the starting Y for LayoutContext in stitched coordinate 
//          system
//----------------------------------------------------------------------------
long 
CViewChain::YOffsetForContext(CLayoutContext *pLayoutContext)
{
    Assert(pLayoutContext);

    CElement * pElementContent = ElementContent();
    long       yHeight = 0;
    int        i;
    
    Assert(pElementContent);

    for (i = 0; ; ++i)
    {
        CLayout * pL;
        void *    pV;

        _bt.GetKeyByIndex(i, &pV);
        if (pV == NULL)
        {
            //  the end of view chain is reached 
            //  given LayoutContext was not found so return 0
            yHeight = 0;
            break;
        }
        else if (pV == (void *)pLayoutContext)
        {
            // given LayoutContext is here - break
            break;
        }

        pL = pElementContent->GetUpdatedLayout((CLayoutContext *)pV);
        Assert(pL);

        yHeight += pL->GetHeight();
    }

    return (yHeight);
}

//----------------------------------------------------------------------------
//
//  Member: HeightForContext()
//
//  Note:   Returns height for LayoutContext 
//----------------------------------------------------------------------------
long 
CViewChain::HeightForContext(CLayoutContext *pLayoutContext)
{
    Assert(pLayoutContext);

    CElement * pElementContent;
    CLayout * pLayout;
    
    pElementContent = ElementContent();
    Assert(pElementContent);

    pLayout = pElementContent->GetUpdatedLayout(pLayoutContext);
    Assert(pLayout);

    return (pLayout->GetHeight());
}

//----------------------------------------------------------------------------
//
//  Member: LayoutContextFromPoint()
//
//  Note:   Returns the LayoutContext containing the point. If there is a break entry 
//          in display layer of break table returns the first empty context (if exist) 
//          Though fIgnoreChain (when is TRUE) force searching for chain. This is done 
//          to make rel disp nodes (that shares the same layout with parent) appear 
//          on the first page always. 
//----------------------------------------------------------------------------
CLayoutContext * 
CViewChain::LayoutContextFromPoint(CLayout *pLayout, CPoint *ppt, BOOL fIgnoreChain)
{
    Assert(pLayout && ppt);
    Assert(HasLayoutOwner());

    CElement *       pElementContent = ElementContent();
    CLayoutContext * pLayoutContext = NULL;
    long             yHeight = 0;
    void *           pV;
    int              i;
    
    Assert(pElementContent);

    //  find the layout context containing the point 
    for (i = 0; ; ++i)
    {
        CLayout * pL;

        _bt.GetKeyByIndex(i, &pV);
        if (pV == NULL)
        {
            //  the end of view chain is reached
            break;
        }

        pL = pElementContent->GetUpdatedLayout((CLayoutContext *)pV);
        Assert(pL);

        yHeight += pL->GetHeight();

        if (ppt->y < yHeight)
        {
            pLayoutContext = (CLayoutContext *)pV;
            break;
        }
    }

    if (    !fIgnoreChain 
        &&  pLayoutContext  )
    {
        //  check display layout of break table to find first empty context 
        CBreakBase *pBreakTable;
        CBreakBase *pLayoutBreak;

        for (i = _bt.GetIndex((void *)pLayoutContext), pLayoutContext = NULL; i < _bt.Size(); ++i)
        {
            if (FAILED(_bt.GetBreakByIndex(i, &pBreakTable)))
            {
                goto Cleanup;
            }

            if (pBreakTable)
            {
                DYNCAST(CBreakTable, pBreakTable)->GetDisplayBreakTable()->GetBreak((void *)pLayout, &pLayoutBreak);
                if (!pLayoutBreak) 
                {
                    //  there is no display break, so context is empty 
                    _bt.GetKeyByIndex(i, &pV);
                    pLayoutContext = (CLayoutContext *)pV;
                    break;
                }
            }
        }
    }

Cleanup:
    return (pLayoutContext);
}

//----------------------------------------------------------------------------
//
//  Member: SetDisplayBreak()
//----------------------------------------------------------------------------
HRESULT 
CViewChain::SetDisplayBreak(CLayoutContext *pLContext, 
                     CLayout *pLayout, CBreakBase *pBreak)
{
    HRESULT         hr = S_OK;
    CBreakBase      *pBreakTable;

    Assert( HasLayoutOwner() );
    Assert( pLayout );

    hr = _bt.GetBreak((void *)pLContext, &pBreakTable);
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    if (pBreakTable)
    {
        hr = DYNCAST(CBreakTable, pBreakTable)->GetDisplayBreakTable()->SetBreak((void *)pLayout, pBreak);
    }

Cleanup:
    return (hr);
}

//----------------------------------------------------------------------------
//
//  Member: IsElementFirstBlock()
//
//  Note:   Returns TRUE if the element is starting in given layout context. 
//          SHOULD BE CALLED ONLY FOR ELEMENTS THAT CAN BE BROKEN !!!
//----------------------------------------------------------------------------
BOOL 
CViewChain::IsElementFirstBlock(CLayoutContext *pLayoutContext, CElement *pElement)
{
    AssertSz(pLayoutContext && pElement, "Illegal parameters !!!");
    Assert( HasLayoutOwner() );

    HRESULT       hr;
    CLayoutBreak *pLayoutBreak;

#if DBG==1
    {
        CLayoutBreak *pEndLayoutBreak;

        hr = GetLayoutBreak(pLayoutContext, pElement, &pEndLayoutBreak, 1);
        if (!FAILED(hr))
        {
            AssertSz(pEndLayoutBreak, "Function is called for NON broken element ?");
        }
    }
#endif

    hr = GetLayoutBreak(pLayoutContext, pElement, &pLayoutBreak, 0);
    if (FAILED(hr))
    {
        goto Error;
    }

    //  No break entry for this layout context means element is starting from here:
    return (!pLayoutBreak);

Error:
    //  By default return TRUE. (We won't skip drawing top border in this case.)
    return (TRUE);
}

//----------------------------------------------------------------------------
//
//  Member: IsElementLastBlock()
//
//  Note:   Returns TRUE if the element is ending in given layout context. 
//          SHOULD BE CALLED ONLY FOR ELEMENTS THAT CAN BE BROKEN !!!
//----------------------------------------------------------------------------
BOOL 
CViewChain::IsElementLastBlock(CLayoutContext *pLayoutContext, CElement *pElement)
{
    AssertSz(pLayoutContext && pElement, "Illegal parameters !!!");
    Assert( HasLayoutOwner() );

    HRESULT     hr;
    CBreakBase *pBreakTable;
    CBreakBase *pLayoutBreak = NULL;
    int         idx;

    idx = _bt.GetIndex((void *)pLayoutContext);

    //
    //  First check ending break...
    //
    hr = _bt.GetBreakByIndex(idx, &pBreakTable);
    if (FAILED(hr))
    {
        goto Error;
    }

    if (pBreakTable)
    {
        hr = DYNCAST(CBreakTable, pBreakTable)->GetLayoutBreakTable()->GetBreak((void *)pElement, &pLayoutBreak);
        AssertSz(FAILED(hr) || pLayoutBreak, "Function is called for NON broken element ?");
        if (FAILED(hr) || !pLayoutBreak)
        {
            goto Error;
        }

        if (DYNCAST(CLayoutBreak, pLayoutBreak)->LayoutBreakType() == LAYOUT_BREAKTYPE_LINKEDOVERFLOW)
        {
            //  Ending break is of overflow type so this is not the ending block
            return (FALSE);
        }
    }

    Assert(pLayoutBreak 
        && DYNCAST(CLayoutBreak, pLayoutBreak)->LayoutBreakType() == LAYOUT_BREAKTYPE_LAYOUTCOMPLETE);

    //
    //  Check if we have anything after... (We may if this is a table cell for example)
    //
    if ((idx + 1) >= _bt.Size())
    {
        //  The block is ending with layout complete and appeared inside last rect. This is the end...
        return (TRUE);
    }

    hr = _bt.GetBreakByIndex(idx + 1, &pBreakTable);
    if (FAILED(hr))
    {
        goto Error;
    }

    if (pBreakTable)
    {
        hr = DYNCAST(CBreakTable, pBreakTable)->GetLayoutBreakTable()->GetBreak((void *)pElement, &pLayoutBreak);
        if (FAILED(hr))
        {
            goto Error;
        }

        //  If we have something here the element doesn't finish yet.
        return (!pLayoutBreak);
    }

Error:
    //  By default return TRUE. (We won't skip drawing bottom border in this case.)
    return (TRUE);
}

//+-------------------------------------------------------------------------
//   A B S O L U T E   E L E M E N T S   H A N D L I N G 
//+-------------------------------------------------------------------------

//+-------------------------------------------------------------------------
//
//  Member   : QueuePositionRequest()
//
//  Synopsis : Places request for position of absolute position object.
//
//  Arguments:  CLayout *  - layout owner of the request 
//              CElement * - element to be positioned
//              CPoint &   - point used for auto positioning 
//              BOOL       - if auto point is valid
//
//  Returns  :  S_OK          - success code
//              E_OUTOFMEMORY - not enough memory to allocate new element 
//                              in the queue.
//+-------------------------------------------------------------------------

HRESULT 
CViewChain::QueuePositionRequest(CLayout *pLayout, CElement *pElement, const CPoint &ptAuto, BOOL fAutoValid)
{
    // At the time a request is queued, the layout better be in a valid context.
    Assert(pLayout && pLayout->LayoutContext() && pLayout->LayoutContext()->IsValid());
    Assert(pElement && (pElement->IsAbsolute() || pElement->IsRelative()));

    HRESULT hr = S_OK;

    CRequest *pRequest = _aryRequest.Append();
    if (pRequest == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // FUTURE: Should addref or subaddref the element (and possibly the layout,
    // when we decide on a layout mem-management strategy).  Watch out for circular
    // references!  Shouldn't be an issue as long as the document is static, so we 
    // can probably get away with it for now.
    pRequest->_pLayoutOwner = pLayout;
    pRequest->_pElement     = pElement;
    pRequest->_ptAuto       = ptAuto;
    pRequest->_fAutoValid   = !!fAutoValid;

Cleanup:
    return (hr);
}

//+-------------------------------------------------------------------------
//
//  Member   : FlushRequests()
//
//  Synopsis : Flushes the queue of requests on a particular layout.
//
//  Arguments:  CLayout *  - layout owner of the request 
//
//  Returns  :  S_OK       - found and deleted requests for this layout
//              S_FALSE    - the layout didn't have any requests in the queue
//+-------------------------------------------------------------------------

HRESULT 
CViewChain::FlushRequests(CLayout *pLayout)
{
    Assert(pLayout && pLayout->LayoutContext());

    HRESULT hr = S_FALSE;

    // Deletion from the end simplifies index management
    int i = _aryRequest.Size() - 1;
    while ( i >= 0 )
    {
        if ( _aryRequest[i]._pLayoutOwner == pLayout )
        {
            _aryRequest.Delete( i );
            hr = S_OK;
        }
        --i;
    }

    return (hr);
}

//+-------------------------------------------------------------------------
//
//  Member   : HandlePositionRequests()
//
//  Synopsis : Processes the queue. Requests are pulled out in source order, 
//             which guarantees that parents will be processed before children 
//             in a case of nesting.
//
//+-------------------------------------------------------------------------
HRESULT 
CViewChain::HandlePositionRequests()
{
    int     idx;

    while ((idx = NextPositionRequestInSourceOrder()) >= 0)
    {
        Assert(idx < _aryRequest.Size());

        if (!HandlePositionRequest(&_aryRequest[idx]))
        {
            // cannot process yet (no page exists).

            // WARNING: This could probably be a "continue", because subsequent requests may
            // be handleable at this point.
            break;
        }

        //  delete this entry
        _aryRequest.Delete(idx);
    }

    return (S_OK);
}

//+-------------------------------------------------------------------------
//
//  Member : HandlePositionRequest()
//
//  Synopsis : Processes a single request
//
//+-------------------------------------------------------------------------
BOOL 
CViewChain::HandlePositionRequest(CRequest *pRequest)
{
    Assert(pRequest);
    Assert(pRequest->_pLayoutOwner);
    AssertSz(pRequest->_pLayoutOwner->HasLayoutContext(), "If we asked the viewchain to position us, we must have a context" );

    CLayout *pLayout = pRequest->_pLayoutOwner;

    if ( !pLayout->LayoutContext()->IsValid() )
    {
        // This request is pointless because the context it was made in is no longer valid.
        // Do nothing and return TRUE so the request will be deleted.
        return TRUE;
    }

    CCalcInfo CI(pLayout);

    // WARNING (KTam, OlegO): We should ensure that pRequest->_pElement
    // has a layout in this context; it's possible that it had a layout
    // but it was destroyed in UndoMeasure, in which case we will recreate
    // it here (bad) and end up with 2 positioned layouts for that element.

    return (pLayout->HandlePositionRequest(&CI, 
                                           pRequest->_pElement, 
                                           pRequest->_ptAuto, 
                                           pRequest->_fAutoValid));
}

//+-------------------------------------------------------------------------
//
//  Member : NextPositionRequestInSourceOrder()
//
//  Synopsis : Returns the first request in the queue (in source order) 
//
//+-------------------------------------------------------------------------
int 
CViewChain::NextPositionRequestInSourceOrder()
{
    int i, iRequest, cRequests;
    int si, siRequest;

    iRequest  = -1;
    cRequests = _aryRequest.Size();
    siRequest = INT_MAX;

    for (i = 0; cRequests; --cRequests, ++i)
    {
        CRequest *pRequest = &(_aryRequest[i]);

        Assert(pRequest && pRequest->_pElement);

        si = pRequest->_pElement->GetSourceIndex();
        if (si < siRequest)
        {
            siRequest = si;
            iRequest  = i;
        }
    }

    return iRequest;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\misc\siteidpr.c ===
/*
   siteidpr.c

   Please do not use any single line comments before the inclusion of w4warn.h!
*/

#define INITGUID
#include <w4warn.h>
#ifdef WIN16
#include <windows.h>
#else
#include <windef.h>
#endif
#include <basetyps.h>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#define PUBLIC_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8)

#include <siteguid.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\div.cxx ===
//+---------------------------------------------------------------------
//
//   File:      eblock.cxx
//
//  Contents:   Div element class
//
//  Classes:    CDivElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DIV_HXX_
#define X_DIV_HXX_
#include "div.hxx"
#endif

#ifndef X_E1D_HXX_
#define X_E1D_HXX_
#include "e1d.hxx"
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

class CHtmTag;

#define _cxx_
#include "div.hdl"

interface IHTMLControlElement;

extern "C" const IID IID_IControl;

const CElement::CLASSDESC CDivElement::s_classdesc =
{
    {
        &CLSID_HTMLDivElement,               // _pclsid
        0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                      // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                              // _pcpi
        0,                                   // _dwFlags
        &IID_IHTMLDivElement,                // _piidDispinterface
        &s_apHdlDescs,                       // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLDivElement,         // _pfnTearOff
    NULL                                     // _pAccelsRun
};

HRESULT
CDivElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_DIV));
    Assert(ppElement);
    *ppElement = new CDivElement(pDoc);
    return *ppElement ? S_OK : E_OUTOFMEMORY;
}



#ifndef NO_DATABINDING

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

const CDBindMethods *
CDivElement::GetDBindMethods()
{
    return &DBindMethodsTextRichRO;
}

//+----------------------------------------------------------------------------
//
//  Member:     CDivElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-----------------------------------------------------------------------------

HRESULT
CDivElement::PrivateQueryInterface ( REFIID iid, void ** ppv )
{
    HRESULT hr;

    *ppv = NULL;

    // IE4 shipped the interface IHTMLControlElement with the same GUID as
    // IControl.  Unfortunately, IControl is a forms^3 interface, which is bad.
    // To resolve this problem Trident's GUID for IHTMLControlElement has
    // changed however, the old GUID remembered in the QI for CSite to return
    // IHTMLControlElement.  The only side affect is that using the old GUID
    // will not marshall the interface correctly only the new GUID has the
    // correct marshalling code.  So, the solution is that QI'ing for
    // IID_IControl or IID_IHTMLControlElement will return IHTMLControlElement.

    // For VB page designer we need to emulate IE4 behavior (fail the QI if not a site)
    if(iid == IID_IControl && Doc()->_fVB && !ShouldHaveLayout())
        RRETURN(E_NOINTERFACE);

        if (iid == IID_IHTMLControlElement || iid == IID_IControl)
    {

        hr = CreateTearOffThunk(this,
                                s_apfnpdIHTMLControlElement,
                                NULL,
                                ppv,
                                (void *)s_ppropdescsInVtblOrderIHTMLControlElement);
        if (hr)
            RRETURN(hr);
    }
    else if (iid == IID_IHTMLTextContainer)
    {
        hr = CreateTearOffThunk(this,
                                (void *)this->s_apfnIHTMLTextContainer,
                                NULL,
                                ppv);
        if (hr)
            RRETURN(hr);
    }
/*
    else if (iid == IID_IHTMLDivPosition)
    {
        hr = CreateTearOffThunk(this, 
                                s_apfnpdIHTMLDivPosition, 
                                NULL, 
                                ppv,
                                (void*)s_ppropdescsInVtblOrderIHTMLDivPosition);
        if (hr)
            RRETURN(hr);
    }
*/
    else
    {
        RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}
#endif // ndef NO_DATABINDING
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\eanchor.cxx ===
//+---------------------------------------------------------------------
//
//   File:      eanchor.cxx
//
//  Contents:   Anchor element class
//
//  Classes:    CAnchorElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_TXTELEMS_HXX_
#define X_TXTELEMS_HXX_
#include "txtelems.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_TPOINTER_HXX_
#define X_TPOINTER_HXX_
#include "tpointer.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EANCHOR_HXX_
#define X_EANCHOR_HXX_
#include "eanchor.hxx"
#endif

#ifndef X_EBODY_HXX_
#define X_EBODY_HXX_
#include "ebody.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include <treepos.hxx>
#endif

#ifndef X_HLINK_H_
#define X_HLINK_H_
#include "hlink.h"
#endif

#ifndef X_URLMON_H_
#define X_URLMON_H_
#include "urlmon.h"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif


#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_ROOTELEM_HXX_
#define X_ROOTELEM_HXX_
#include "rootelem.hxx"
#endif

#ifndef X_UNDO_HXX_
#define X_UNDO_HXX_
#include "undo.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "anchor.hdl"

MtDefine(CAnchorElement, Elements, "CAnchorElement")

ExternTag(tagMsoCommandTarget);

#ifdef WIN16
#define SetCursorStyle(x) ::SetCursor((HICON)x)
#endif

#ifndef NO_PROPERTY_PAGE
const CLSID * const CAnchorElement::s_apclsidPages[] =
{
    // Browse-time pages
    &CLSID_CAnchorBrowsePropertyPage,
    NULL,
    // Edit-time pages
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,
#endif // DBG==1    
    NULL
};
#endif // NO_PROPERTY_PAGE


const CElement::CLASSDESC CAnchorElement::s_classdesc =
{
    {
        &CLSID_HTMLAnchorElement,            // _pclsid
        0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                      // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                              // _pcpi
        0,                                   // _dwFlags
        &IID_IHTMLAnchorElement,             // _piidDispinterface
        &s_apHdlDescs,                       // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLAnchorElement,      // _pfnTearOff
    NULL                                     // _pAccelsRun
};


HRESULT
CAnchorElement::CreateElement(CHtmTag *pht, CDoc *pDoc, CElement **ppElement)
{
    HRESULT   hr = S_OK;

    Assert(pht->Is(ETAG_A));
    Assert(ppElement);
    *ppElement = new CAnchorElement(pDoc);

    if (!*ppElement)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CAnchorElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CAnchorElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_HTML_TEAROFF(this, IHTMLAnchorElement2, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

HRESULT
CAnchorElement::EnterTree()
{
    HRESULT hr = S_OK;
    TCHAR   cBuf[pdlUrlLen];
    TCHAR * pchNewUrl = cBuf;
    CDoc *  pDoc = Doc();

    Assert (IsInMarkup());

    if (GetMarkup()->_fMarkupServicesParsing && pDoc->_fPasteIE40Absolutify && !pDoc->_fNoFixupURLsOnPaste)
    {
        LPCTSTR szUrl = GetAAhref();

        if (szUrl && *szUrl)
        {
            Assert( !IsInPrimaryMarkup() );

            hr = THR(
                CMarkup::ExpandUrl(GetMarkup()->GetFrameOrPrimaryMarkup(), 
                    szUrl, ARRAY_SIZE(cBuf), pchNewUrl, this,
                    URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE,
                    LPTSTR( Doc()->_cstrPasteUrl)));

            if (hr)
                goto Cleanup;

            hr = THR(SetAAhref(pchNewUrl));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:

    RRETURN( hr );

}

void
CAnchorElement::Notify(CNotification *pNF)
{
    super::Notify(pNF);
    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_QUERYFOCUSSABLE:
        if (!IsEditable(TRUE))
        {
            CQueryFocus *   pQueryFocus     = (CQueryFocus *)pNF->DataAsPtr();
            CTreePos    *   ptp, *ptpEnd;

            if (!GetAAhref())
            {
                pQueryFocus->_fRetVal = FALSE;
                break;
            }
            // Check for server-side image map
            // If all that this contains is an IMG with isMap, don't take focus.
            // The image would take focus instead
            GetTreeExtent(&ptp, &ptpEnd);
            ptp = ptp->NextTreePos();
            if (    ptp != ptpEnd
                &&  ptp->IsBeginElementScope()
                &&  ptp->Branch()->Tag() == ETAG_IMG
                &&  DYNCAST(CImgElement, ptp->Branch()->Element())->GetAAisMap()
                &&  ptp->NextTreePos() == ptpEnd->PreviousTreePos())
            {
                pQueryFocus->_fRetVal = FALSE;
                break;
            }
        }
        // If the anchor is in edit mode and we don't have a layout,
        // then we don't want focus.
        else if (!GetUpdatedLayout())
        {
            CQueryFocus *   pQueryFocus     = (CQueryFocus *)pNF->DataAsPtr();
            pQueryFocus->_fRetVal = FALSE;
        }
        break;

    case NTYPE_ELEMENT_SETFOCUS:
        if (GetFirstBranch())
        {
            IGNORE_HR(SetStatusText());

            if (IsInMarkup())
            {
                SetActive(TRUE);
            }
        }
        break;

    case NTYPE_ELEMENT_ENTERTREE:
        EnterTree();
        break;

    case NTYPE_BASE_URL_CHANGE: 
        _fBaseUrlChanged = TRUE;
        OnPropertyChange( DISPID_CAnchorElement_href, 
                            ((PROPERTYDESC *)&s_propdescCAnchorElementhref)->GetdwFlags(),
                            (PROPERTYDESC *)&s_propdescCAnchorElementhref);
        break;
    }
}

BOOL 
CAnchorElement::CanStealFormats(CTreeNode *pNodeVictim)
{
    BOOL fSteal;
    CAnchorElement *pAnchorOther = DYNCAST(CAnchorElement, pNodeVictim->Element());
    CAttrArray **ppAA1 = GetAttrArray();
    CAttrArray **ppAA2 = pAnchorOther->GetAttrArray();

    if (*ppAA1 != NULL && *ppAA2 != NULL)
    {
        DISPID dispid;
        if (!(*ppAA1)->Compare(*ppAA2, &dispid))
        {
            // If the 2 <A>'s are different only in their HREF and if both
            // have the same visited status, then we can steal formats.
            fSteal = dispid == s_propdescCAnchorElementhref.a.GetDispid()
                 && ( (GetAAhref()==NULL) == (pAnchorOther->GetAAhref()==NULL) );
        }
        else
        {
            // If they are the same hrefs (or no hrefs are present), then we can
            // steal the formats.
            fSteal = TRUE;
        }
    }
    else
    {
        fSteal = (*ppAA1 == NULL && *ppAA2 == NULL);
    }
    if (fSteal)
    {
        EnsureVisited();
        fSteal =    _fVisited == pAnchorOther->_fVisited
                 && _fHovered == pAnchorOther->_fHovered
                 && _fActive  == pAnchorOther->_fActive;
    }
    return fSteal;
}

HRESULT
CAnchorElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT hr;

    Assert(Tag() == ETAG_A);

    pCFI->PrepareCharFormat();

    if (GetAAhref())
    {
        pCFI->PrepareFancyFormat();

        switch (Doc()->_pOptionSettings->nAnchorUnderline)
        {
            case ANCHORUNDERLINE_NO:
                pCFI->_cf()._fUnderline = FALSE;
                pCFI->_ff()._fHasExplicitUnderline = FALSE;
                break;

            case ANCHORUNDERLINE_YES:
                pCFI->_cf()._fUnderline = TRUE;
                pCFI->_ff()._fHasExplicitUnderline = TRUE;
                break;

            case ANCHORUNDERLINE_HOVER:
                if (_fHovered)
                {
                    pCFI->_cf()._fUnderline = TRUE;
                    pCFI->_ff()._fHasExplicitUnderline = TRUE;
                }
                break;
        }

        pCFI->_cf()._ccvTextColor.SetValue(GetLinkColor(), FALSE);

        // (gschneid) If we have a link with a href attribute we always want to show
        // the hand for links. The following line prevents in this case (with attribute href)
        // that the cursor property is inherited from an enclosing element.
        pCFI->_cf()._bCursorIdx = styleCursorAuto;
    }

    pCFI->UnprepareForDebug();

    hr = THR(super::ApplyDefaultFormat(pCFI));

    RRETURN(hr);
}

void CAnchorElement::EnsureVisited()
{
    if (!_fVisitedValid)
    {
        _fVisited = Doc()->IsVisitedHyperlink(GetAAhref(), this);
        _fVisitedValid = TRUE;
    }
}


COLORREF CAnchorElement::GetLinkColor()
{
    CDoc *pDoc = Doc();

    CColorValue  color;

    EnsureVisited();
    if (!pDoc->_pOptionSettings->fAlwaysUseMyColors)
    {
        CBodyElement * pBody = NULL;

        if (GetFirstBranch())
        {
            CTreeNode * pNode;

            pNode = GetFirstBranch()->SearchBranchToRootForTag( ETAG_BODY );

            if (pNode)
                pBody = DYNCAST( CBodyElement, pNode->Element() );
        }

        if (pBody)
        {
            if (_fHovered && pDoc->_pOptionSettings->fUseHoverColor)
                ;//pBody->GetAAhLink();// When ScottI agrees with HLINK attribute on BODY ! :-)
            else if (_fActive)
                color = pBody->GetAAaLink();
            else if (_fVisited)
                color = pBody->GetAAvLink();
            else
                color = pBody->GetAAlink();
        }
    }

    if (_fHovered && pDoc->_pOptionSettings->fUseHoverColor)
    {
        return (color.IsDefined())
                ? color.GetColorRef()
                : pDoc->_pOptionSettings->crAnchorHovered();
    }
    else if (_fVisited)
    {
        return (color.IsDefined())
                ? color.GetColorRef()
                : pDoc->_pOptionSettings->crAnchorVisited();
    }
    else
    {
        return (color.IsDefined())
                ? color.GetColorRef()
                : pDoc->_pOptionSettings->crAnchor();
    }
}


HRESULT
CAnchorElement::UpdateAnchorFromHref()
{
    IHTMLEditingServices * pEd = NULL;

    IHTMLEditor *   phtmed;
    BOOL            fUpdateText;
    BSTR            bstrAnchorText = NULL;
    CMarkup *       pMarkup;
    OLECHAR *       pstrHref;
    HRESULT         hr = S_OK;
    MARKUP_CONTEXT_TYPE context;
    CDoc *          pDoc = Doc();    
    
    Assert( pDoc );

    CMarkupPointer  mpStart( pDoc );
    CMarkupPointer  mpEnd( pDoc );

    //
    // Get the text and href values
    //
    hr = THR( get_innerText( &bstrAnchorText ) );
    if (hr)
        goto Cleanup;

    pstrHref = (OLECHAR *)GetAAhref();
    if (! pstrHref)
        goto Cleanup;

    //
    // If anchor has text, and it's equal to the href already, we can bail
    //
    if ( bstrAnchorText && StrCmpIC( pstrHref, bstrAnchorText ) == 0 )
        goto Cleanup;

    pMarkup = GetMarkup();        
    
    if (! pMarkup )
        goto Cleanup;

    //
    // See what's inside the anchor
    //

    hr = THR( mpStart.MoveAdjacentToElement( this, ELEM_ADJ_AfterBegin ) );
    if (hr)
        goto Cleanup;

    hr = THR( mpEnd.MoveAdjacentToElement( this, ELEM_ADJ_BeforeEnd ) );
    if (hr)
        goto Cleanup;

    //
    // If there anything other than text in the anchor, it is best
    // not to update the anchor's text
    //
    fUpdateText = TRUE;
    while(! mpStart.IsEqualTo( &mpEnd ) )
    {           
        mpStart.Right( TRUE, &context, NULL, NULL, NULL, NULL );
        if ( context != CONTEXT_TYPE_Text )
        {
            fUpdateText = FALSE;
            break;
        }
    }

    if (! fUpdateText)
        goto Cleanup;

    //
    // Get a hold of yourself, now we have to call the autodetector to see
    // if the text and href are autodetectable and match the same pattern
    //
    hr = THR( mpStart.MoveAdjacentToElement( this, ELEM_ADJ_AfterBegin ) );
    if (hr)
        goto Cleanup;

    phtmed = pDoc->GetHTMLEditor();

    if (!phtmed)
        goto Cleanup;

    hr = THR(
        phtmed->QueryInterface(
            IID_IHTMLEditingServices, (void **) & pEd ) );

    if (hr)
        goto Cleanup;

    hr = THR( pEd->ShouldUpdateAnchorText( pstrHref, bstrAnchorText, &fUpdateText ) );
    if (hr)
        goto Cleanup;

    if ( fUpdateText )
    {
        hr = THR( pDoc->Remove( &mpStart, &mpEnd ) );
        if (hr)
            goto Cleanup;

        hr = THR( pDoc->InsertText( & mpStart, pstrHref, -1 ) );
        if (hr)
            goto Cleanup;
    }

Cleanup:
    if (bstrAnchorText)
        SysFreeString(bstrAnchorText);
    ReleaseInterface( pEd );
    return hr;
}


HRESULT
CAnchorElement::OnPropertyChange ( DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc )
{
    HRESULT hr = S_OK;
    //
    // If we are changing the HREF for the anchor, we may want to update the
    // text the anchor influences.
    //

    // Undoing of the modification of the tree will be handled by other objects in
    // the undo stack.  Mucking with the tree here will royally whack stuff.
    if (dispid == DISPID_CAnchorElement_href && TLS(nUndoState) == UNDO_BASESTATE)
    {
        // we must set this flag for NS compatibility (Carled)
        // if the change occured because of a base tag change, we don't treat
        // it as a direct OM modification
        _fOMSetHasOccurred = !_fBaseUrlChanged;
        _fBaseUrlChanged = FALSE;

        IGNORE_HR( UpdateAnchorFromHref() );
    }

    hr = THR( super::OnPropertyChange( dispid, dwFlags, ppropdesc ) );

    RRETURN( hr );
}

//+-------------------------------------------------------------------------
//
//  member OnCaptureMessage
//
// Synopsis : This fn will be called whenever the Anchor has captured the mouse
//      it is also resposible for intiating the dragdrop behavior of anchors,
//      including the firing of ondragstart
//
//----------------------------------------------------------------------------

HRESULT BUGCALL
CAnchorElement::OnCaptureMessage(CMessage *pMessage)
{
    HRESULT                     hr = S_FALSE;
    CLayout                  *  pLayout = GetFirstBranch()->GetUpdatedNearestLayout();
    TCHAR   cBuf[pdlUrlLen];
    TCHAR *                     pchExpandedUrl = cBuf;
    CStr                        strText;
    IUniformResourceLocator *   pURLToDrag = NULL;

    switch (pMessage->message)
    {
    case WM_LBUTTONUP:
        Assert(GetFirstBranch());
        pMessage->SetNodeClk(GetFirstBranch());
        // fall-through

    case WM_MBUTTONUP:
        hr = S_OK;
        // fall-through

    case WM_RBUTTONUP:
        // Release mouse capture
        TakeCapture(FALSE);
        //Doc()->SetMouseCapture(NULL, NULL);
        break;

    case WM_MOUSEMOVE:
    {
        // If the user moves the mouse outside the wobble zone,
        // show the no-entry , plus disallow a subsequent OnClick
        POINT ptCursor = { LOWORD(pMessage->lParam), HIWORD(pMessage->lParam) };
        CDoc *  pDoc = Doc();

        if ( _fCanClick && !PtInRect(&_rcWobbleZone, ptCursor))
        {
            _fCanClick = FALSE;
        }

        // initiate drag-drop
        if (!_fCanClick && !pDoc->_fIsDragDropSrc) // && !pDoc->_pElementOMCapture)
        {
            // fully resolve URL
            if (S_OK == THR(CMarkup::ExpandUrl(NULL, GetAAhref(), ARRAY_SIZE(cBuf), pchExpandedUrl, this)))
            {
                if (pMessage->pNodeHit &&
                        pMessage->pNodeHit->TagType() == ETAG_IMG &&
                        S_OK == THR(strText.Set(
                            DYNCAST(CImgElement,pMessage->pNodeHit->Element())
                                ->GetAAalt())) ||
                    S_OK == THR(GetPlainTextInScope(&strText)))
                {
                    if (S_OK == THR(CreateLinkDataObject(pchExpandedUrl,
                                            strText,
                                            &pURLToDrag)))
                    {
                        if (!DragElement(pLayout, pMessage->dwKeyState, pURLToDrag, -1))
                        {
                            // release the capture and let someone else handle the
                            // WM_MOUSEMOVE by leaving hr=S_FALSE
                            //pDoc->SetMouseCapture(NULL,NULL);
                            TakeCapture(FALSE);
                            break;
                        }
                    }
                }
            }
        }
        // Intentional drop through to WM_SETCURSOR - WM_SETCURSOR is NOT sent
        // while the Capture is set
    }

    case WM_SETCURSOR:
    {
        LPCTSTR idc;
        if(_fCanClick)
        {
            Assert(pLayout);
            idc = GetHyperlinkCursor();
        }
        else
        {
            idc = IDC_NO;
        }

        SetCursorStyle(idc);
        hr = S_OK;
    }
    break;
    }

    ReleaseInterface(pURLToDrag);

    RRETURN1 ( hr, S_FALSE );
}

//+------------------------------------------------------------------------
//
//  Member:     CAnchorElement::HandleMessage
//
//  Synopsis:   Perform any element specific mesage handling
//
//  Arguments:  pmsg    Ptr to incoming message
//
//-------------------------------------------------------------------------

HRESULT
CAnchorElement::HandleMessage(CMessage *pMessage)
{
    // Only the marquee is allowed to cheat and pass the wrong
    // context in.  This is only done so that message bubbling will
    // skip above the marquee.  However, for operations on the anchor itself,
    // we need to use a correct context and therefore use GetFirstBranch()

    CDoc *      pDoc = Doc();
    HRESULT     hr = S_FALSE;
    HRESULT     hr2;
    CLock       Lock(this);
    BOOL        fDesignMode = IsEditable(/*fCheckContainerOnly*/FALSE);
    CTreeNode * pNodeContextReal = GetFirstBranch();

    Assert(pNodeContextReal);

    CTreeNode::CLock NodeLock;
    hr2 = THR( NodeLock.Init(pNodeContextReal) );
    if( hr2 )
    {
        hr = hr2;
        goto Cleanup;
    }

    if (    fDesignMode

            // If htc is set to something other than HTC_NO or HTC_YES,
            // it tells me that the message is a mouse messaage and that
            // the mouse is over a scrollbar or some such uninteresting
            // region. I will let the base class take care of such a
            // message. Note that htc is left as HTC_NO for non-mouse
            // messages.
        ||  (pMessage->htc != HTC_YES && pMessage->htc != HTC_NO)

        || !GetAAhref())
    {
        goto Ignored;
    }

    // now deal with the rest of the messages
    switch ( pMessage -> message )
    {
    case WM_SETCURSOR:
        {
            TCHAR * pchUrl;

            hr = GetUrlComponent(NULL, URLCOMP_WHOLE, &pchUrl);
            if (hr == S_OK && pchUrl)
            {
                SetCursorStyle(GetHyperlinkCursor());
                MemFreeString(pchUrl);
                goto Cleanup;
            }
        }
        break;
    case WM_LBUTTONDOWN:
    case WM_RBUTTONDOWN:
        // Capture the mouse to CAnchorElement::::OnCaptureMessage
        pDoc->SetMouseCapture(
                   MOUSECAPTURE_METHOD(CAnchorElement, OnCaptureMessage, oncapturemessage),
                   this,
                   TRUE,
                   TRUE);

        // Set the limits for a mouse move before showing
        // the no entry cursor
        _rcWobbleZone.left   = LOWORD(pMessage->lParam) - g_sizeDragMin.cx;
        _rcWobbleZone.right  = LOWORD(pMessage->lParam) + g_sizeDragMin.cx + 1;
        _rcWobbleZone.top    = HIWORD(pMessage->lParam) - g_sizeDragMin.cy;
        _rcWobbleZone.bottom = HIWORD(pMessage->lParam) + g_sizeDragMin.cy + 1;
        // Can click while mouse is inside wobble zone
        _fCanClick = GetAAhref() ? TRUE : FALSE;

        // Give immediate feedback
        if(_fCanClick)
        {
            SetCursorStyle(GetHyperlinkCursor());
        }

        // The message has been handled. Kill it.
        hr = S_OK;
        break;

    case WM_CONTEXTMENU:

        hr = THR(OnContextMenu(
                    (short) LOWORD(pMessage->lParam),
                    (short) HIWORD(pMessage->lParam),
                    (IsEditable(TRUE)) ? (CONTEXT_MENU_DEFAULT)
                                   : (CONTEXT_MENU_ANCHOR)));
        break;

    case WM_CHAR:
    case WM_SYSCHAR:
        switch (pMessage->wParam)
        {
        case VK_RETURN:

            // This is being called only if anchor element has a HREF.
            // i.e. because we donot support tabbing to (and hence the RETURN on)
            // anchor elements which do not have HREFs.
            Assert (GetAAhref() != NULL) ;

            pMessage->SetNodeClk(pNodeContextReal);
            hr = S_OK;
            break ;
        }
        break ;

    case WM_MOUSEWHEEL:
        if ((pMessage->dwKeyState & FSHIFT) && (((short) HIWORD(pMessage->wParam)) > 0))
        {
            // This is being called only if anchor element has a HREF, because
            // we donot navigate to anchor elements which do not have HREFs.
            //
            Assert(GetAAhref() != NULL);
            pMessage->SetNodeClk(pNodeContextReal);
            hr = S_OK;
        }
        break;

    case WM_MOUSEOVER:
        if (!_fHasMouseOverCancelled)
        {
            SetStatusText();
        }
        // fall through
    case WM_MOUSELEAVE:
        _fHovered = pMessage->message == WM_MOUSEOVER ? TRUE : FALSE;
        UpdateFormats(pNodeContextReal);
        break;
    }

Ignored:
    if (S_FALSE == hr)
    {
        hr = THR(super::HandleMessage(pMessage));
    }
Cleanup:
    RRETURN1(hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     CAnchorElement::UpdateFormats
//
//  Synopsis:   Clear format caches, recompute them and then do any
//              necessary invalidate or recalc.
//
//-------------------------------------------------------------------------

HRESULT
CAnchorElement::UpdateFormats(CTreeNode * pNodeContext)
{
    HRESULT hr = S_OK;
    LONG iCF = pNodeContext->_iCF;
    LONG iPF = pNodeContext->_iPF;
    LONG iFF = pNodeContext->_iFF;
    THREADSTATE * pts = GetThreadState();

    // Ensure that current formats are not going anywhere
    if (iCF >= 0) pts->_pCharFormatCache->AddRefData(iCF);
    if (iPF >= 0) pts->_pParaFormatCache->AddRefData(iPF);
    if (iFF >= 0) pts->_pFancyFormatCache->AddRefData(iFF);

    // Clear the format caches
    hr = THR(EnsureFormatCacheChange(ELEMCHNG_CLEARCACHES));
    if (hr)
        goto Cleanup;

    // Cause the formats to get recomputed
    pNodeContext->GetFancyFormat();

    // if format have not changed, no invalidation necessary
    if (    pNodeContext->_iCF >= 0
        &&  pNodeContext->_iCF == iCF
        &&  pNodeContext->_iPF == iPF
        &&  pNodeContext->_iFF == iFF)
        goto Cleanup;

    // And invalidate or recalc based on differences between the old and new formats
    if (    pNodeContext->_iCF == -1
        ||  pNodeContext->_iFF == -1
        ||  iCF == -1
        ||  iFF == -1
        ||  iPF != pNodeContext->_iPF
        ||  !GetCharFormatEx(pNodeContext->_iCF)->CompareForLayout(GetCharFormatEx(iCF))
        ||  !GetFancyFormatEx(pNodeContext->_iFF)->CompareForLayout(GetFancyFormatEx(iFF)))
    {
        // invalidate, because if the element gets/loses positioning, we need two different
        // rects redrawn (before & after)
        Invalidate();
        ResizeElement(NFLAGS_FORCE);
    }
    else
    {
        SmartInvalidate();
    }
    
Cleanup:
    // Release the old format caches
    if (iCF >= 0) pts->_pCharFormatCache->ReleaseData(iCF);
    if (iPF >= 0) pts->_pParaFormatCache->ReleaseData(iPF);
    if (iFF >= 0) pts->_pFancyFormatCache->ReleaseData(iFF);
    RRETURN(hr);
}

void
CAnchorElement::TSSmartInvalidate()
{
    Assert(g_fTerminalServer);
    CTreePos *ptp;
    CTreePos *ptpStop;
    CElement *pElement;
    BOOL fContainsOnlyImages = FALSE;
    
    GetTreeExtent(&ptp, &ptpStop);
    if (!ptp || !ptpStop)
        goto Cleanup;
    ptp = ptp->NextTreePos();

    while (   ptp != NULL
           && ptp != ptpStop
          )
    {
        // Text node with text: so contains something other than only images
        if (ptp->IsText() && ptp->Cch())
            goto Cleanup;

        if (ptp->IsBeginNode())
        {
            pElement = ptp->GetBranch()->Element();

            // Begining of a nested layout: so contains something other than only images
            if (   pElement->CurrentlyHasAnyLayout()
                && ptp->GetBranch()->Tag() != ETAG_IMG
               )
            {
                goto Cleanup;
            }
        }
        ptp = ptp->NextTreePos();
    }

    // OK, contains only images.
    fContainsOnlyImages = TRUE;

Cleanup:
    if (!fContainsOnlyImages)
    {
        Invalidate();
    }
}

HRESULT
CAnchorElement::DoClick(CMessage * pMessage, CTreeNode *pNodeContext,
                        BOOL fFromLabel,
                        EVENTINFO* pEvtInfo /*= NULL*/ ,
                        BOOL fFromClick /*= FALSE */)
{
    HRESULT         hr = S_OK;
    CFlowLayout   * pLayout;

    if(!pNodeContext)
        pNodeContext = GetFirstBranch();

    if(!pNodeContext)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    Assert(pNodeContext && pNodeContext->Element() == this);

    pLayout = pNodeContext->GetFlowLayout();
    if (pLayout )
    {
        hr = super::DoClick(pMessage, pNodeContext, fFromLabel, pEvtInfo, fFromClick );
    }

Cleanup:
    RRETURN1(hr, S_FALSE);
}

HRESULT
CAnchorElement::ClickAction (CMessage *pmsg)
{
    HRESULT hr = super::ClickAction(pmsg);

    if (hr == S_OK && !_fVisited)
    {
        hr = THR(SetVisited());
        if (hr)
            goto Cleanup;
    }

Cleanup:
    // Do not want this to bubble, so..
    if (S_FALSE == hr)
        hr = S_OK;

    RRETURN(hr);
}

HRESULT
CAnchorElement::SetActive( BOOL fActive )
{
    HRESULT hr = S_OK;
    BOOL    fCurrentState = _fActive;

    // UpdateFormats needs this set inorder to properly pick up the new 
    // formats.
    _fActive = fActive;

    if ( fActive != fCurrentState)
    {
        hr = ExecPseudoClassEffect(_fVisited, fActive, _fVisited, fCurrentState);
    }

    return hr;
}

HRESULT
CAnchorElement::ExecPseudoClassEffect(BOOL fVisited, BOOL fActive,
                                      BOOL fOldVisited, BOOL fOldActive)
{
    HRESULT hr = S_OK;
   
    CStyleSheetArray * pSS = GetMarkup()->GetStyleSheetArray();
    BYTE                    ab[sizeof(CFormatInfo)];
    CFormatInfo *           pInfo = (CFormatInfo*)&ab;

    // First check the anchor itself for any styles that effect
    if(pSS)
    {
       pInfo->_pNodeContext = GetFirstBranch();
       if (pSS->TestForPseudoclassEffect(pInfo,
                                         fVisited, fActive,
                                         fOldVisited, fOldActive))
       {
           hr = UpdateFormats(pInfo->_pNodeContext);
       }
       else
       {
           CChildIterator  ci( this, NULL, CHILDITERATOR_DEEP );
           CTreeNode *     pNodeCurr;

           for( pNodeCurr = ci.NextChild();
                pNodeCurr;
                pNodeCurr = ci.NextChild() )
           {
               pInfo->_pNodeContext = pNodeCurr;
               if( pSS->TestForPseudoclassEffect(pInfo,
                                                 fVisited, fActive,
                                                 fOldVisited, fOldActive))
               {
                   // make sure we skip over the curr node's
                   // subtree
                   ci.ClearDeep();
               
                   // Resize/Invalidate the current element
                   hr = UpdateFormats(pInfo->_pNodeContext);
               }
               else
               {
                   ci.SetDeep();
               }
           }

           Invalidate();
       }
    }
    else
    {
        // Resize/Invalidate the current element
        hr = UpdateFormats(GetFirstBranch());
    }
    RRETURN(hr);
}

HRESULT
CAnchorElement::SetVisited()
{
    HRESULT hr = S_OK;

    if (!Doc()->IsOffline())
    {
        _fVisited = TRUE;
        _fVisitedValid = TRUE;

        // if we are not in the tree just leave.
        if (!GetFirstBranch())
            goto Cleanup;

        hr = ExecPseudoClassEffect(_fVisited, _fActive, FALSE, _fActive);
    }

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
// Member: get_mimeType
//
//-----------------------------------------------------------------------------
extern TCHAR * GetFileTypeInfo(TCHAR * pszFileName);

STDMETHODIMP
CAnchorElement::get_mimeType(BSTR * pMimeType)
{
    HRESULT   hr   = S_OK;
    TCHAR   * pUrl = NULL;

    * pMimeType = NULL;

    hr = get_href(&pUrl);
    if (hr)
        goto Cleanup;

    if (pUrl && !UrlIsOpaque(pUrl))
    {
        TCHAR * pCh = _tcschr(pUrl, _T('?'));
        if (pCh)
            pCh = _T('\0');

        * pMimeType = GetFileTypeInfo(pUrl);
        SysFreeString(pUrl);
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
// Member: get_protocolLong
//
//-----------------------------------------------------------------------------
extern TCHAR * ProtocolFriendlyName(TCHAR * szUrl);

STDMETHODIMP
CAnchorElement::get_protocolLong(BSTR * pProtocol)
{
    HRESULT   hr      = S_OK;
    TCHAR   * pUrl    = NULL;
    TCHAR   * pResult = NULL;

    * pProtocol = NULL;

    hr = get_href(&pUrl);
    if (hr)
        goto Cleanup;

    if (pUrl)
    {
        pResult = ProtocolFriendlyName(pUrl);
        if (pResult)
        {
            int z = (_tcsncmp(pResult, 4, _T("URL:"), -1) == 0) ? (4) : (0);
            * pProtocol = SysAllocString(pResult + z);
            SysFreeString(pResult);
        }
        SysFreeString(pUrl);
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
// Member: get_nameProp
//
//-----------------------------------------------------------------------------
STDMETHODIMP
CAnchorElement::get_nameProp(BSTR * pName)
{
    *pName = NULL;

    TCHAR   * pUrl  = NULL;
    TCHAR   * pszName = NULL;
    HRESULT hr;

    hr = get_href(&pUrl);
    if (hr)
        goto Cleanup;

    if (pUrl)
    {
        pszName = _tcsrchr(pUrl, _T('/'));
        if (!pszName)
            pszName = pUrl;
        else if (*(pszName + 1) == _T('\0'))
        {
            *(pszName) = _T('\0');
            pszName = _tcsrchr(pUrl, _T('/'));
            if (!pszName)
                pszName = pUrl;
            else
                pszName ++;
        }
        else
            pszName ++;

        * pName = SysAllocString(pszName);
        SysFreeString(pUrl);
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------------------
//
//  Member:     CDoc::EnumContainedURLs
//
//  Synopsis:   returns 2 arrays (containing the URLs and the associated anchor
//              strings) for a given document
//
//  Arguments:  paryURLs     - array containing URL strings
//              paryStrings  - array containing anchor strings
//
//-----------------------------------------------------------------------------

HRESULT
CDoc::EnumContainedURLs(CURLAry * paryURLs, CURLAry * paryStrings)
{
    HRESULT         hr = S_OK;
    CElement        *pAnchorOrAreaElement;
    CAnchorElement  *pAnchorElem=NULL;
    CAreaElement    *pAreaElem=NULL;
    LPCTSTR         lpctstrAnchorOrAreaAAhref;
    BOOL            fAnchorElem;
    CStr            *pStrURL;
    CStr            *pStrText;
    LONG            i, c;
    CCollectionCache *pCollectionCache;

    if (!paryURLs || !paryStrings)
    {
       hr = E_POINTER;
       goto Cleanup;
    }

    hr = THR (PrimaryMarkup()->EnsureCollectionCache(CMarkup::LINKS_COLLECTION));
    if (hr)
    {
        goto Cleanup;
    }

    pCollectionCache = PrimaryMarkup()->CollectionCache();

    c = pCollectionCache->SizeAry(CMarkup::LINKS_COLLECTION);
    for (i = 0; i < c; i++)
    {
        hr = THR (pCollectionCache->GetIntoAry(CMarkup::LINKS_COLLECTION,
                        i,
                        &pAnchorOrAreaElement));
        if (hr != S_OK)
        {
            goto Cleanup;
        }

        fAnchorElem = pAnchorOrAreaElement->_etag == ETAG_A;
        Assert(fAnchorElem || pAnchorOrAreaElement->_etag == ETAG_AREA);

        pAnchorElem = fAnchorElem ? DYNCAST (CAnchorElement, pAnchorOrAreaElement) : NULL;
        pAreaElem  = !fAnchorElem ? DYNCAST (CAreaElement, pAnchorOrAreaElement) : NULL;

        lpctstrAnchorOrAreaAAhref = fAnchorElem ? pAnchorElem->GetAAhref() : pAreaElem->GetAAhref();
        if (lpctstrAnchorOrAreaAAhref)
        {
            CStr strTmp;
            TCHAR   cBuf[pdlUrlLen];
            TCHAR *pachAbsoluteUrl = cBuf;

            hr = paryURLs->AppendIndirect(NULL, &pStrURL);
            if (hr)
                goto Cleanup;

            hr = paryStrings->AppendIndirect(NULL, &pStrText);
            if (hr)
                goto Cleanup;

            hr = THR(CMarkup::ExpandUrl(NULL, 
                lpctstrAnchorOrAreaAAhref, ARRAY_SIZE(cBuf), pachAbsoluteUrl, pAnchorOrAreaElement));
            if (hr != S_OK || !pachAbsoluteUrl)
            {
                goto Cleanup;
            }

            hr = THR(pStrURL->Set(pachAbsoluteUrl));

            if (hr != S_OK)
            {
                goto Cleanup;
            }

            hr = pAnchorOrAreaElement->GetPlainTextInScope(&strTmp);
            if (hr != S_OK)
            {
                goto Cleanup;
            }

            hr = THR (pStrText->Set(strTmp));
            if (hr != S_OK)
            {
                goto Cleanup;
            }
        }
    }

Cleanup:
    RRETURN1 (hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CAnchorElement::ShowTooltip
//
//  Synopsis:   Displays the tooltip for the site.
//
//  Arguments:  [pt]    Mouse position in container window coordinates
//              msg     Message passed to tooltip for Processing
//
//--------------------------------------------------------------------------

ExternTag(tagFormatTooltips);

HRESULT
CAnchorElement::ShowTooltip(CMessage *pmsg, POINT pt)
{
    HRESULT     hr = S_FALSE;
    CDoc *      pDoc = Doc();
    TCHAR *     pchString;
    BOOL        fRTL = FALSE;

#if DBG == 1
    if (IsTagEnabled(tagFormatTooltips))
    {
        return super::ShowTooltip(pmsg, pt);
    }
#endif

    if (pDoc->State() < OS_INPLACE)
        goto Cleanup;

    pchString = (LPTSTR) GetAAtitle();

    if ( pchString)
    {
        RECT    rc;

        // Ignore spurious WM_ERASEBACKGROUNDs generated by tooltips
        CServer::CLock Lock(pDoc, SERVERLOCK_IGNOREERASEBKGND);

        hr = THR(GetElementRc(&rc,
                              GERC_ONALINE | GERC_CLIPPED,
                              &pt));
        if (hr)
            goto Cleanup;

        // COMPLEXSCRIPT - determine if element is right to left for tooltip style setting
        if(GetFirstBranch())
        {
            fRTL = GetFirstBranch()->GetCharFormat()->_fRTL;
        }          
        if (!pDoc->_pDocPopup)
        {
            FormsShowTooltip(
                    pchString,
                    pDoc->_pInPlace->_hwnd,
                    *pmsg,
                    &rc,
                    (DWORD_PTR) GetMarkup(),
                    (DWORD_PTR) this,
                    fRTL);
        }
        hr = S_OK;
    }

Cleanup:
    return hr;
}

#ifndef NO_DATABINDING
#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

class CDBindMethodsAnchor : public CDBindMethodsSimple
{
    typedef CDBindMethodsSimple super;

public:
    CDBindMethodsAnchor() : super(VT_BSTR, DBIND_ONEWAY) {}
    ~CDBindMethodsAnchor()  {}

    virtual HRESULT BoundValueToElement(CElement *pElem, LONG id,
                                        BOOL fHTML, LPVOID pvData) const;

};

static const CDBindMethodsAnchor DBindMethodsAnchor;

const CDBindMethods *
CAnchorElement::GetDBindMethods()
{

    return &DBindMethodsAnchor;
}

//+----------------------------------------------------------------------------
//
//  Function: BoundValueToElement, CDBindMethods
//
//  Synopsis: Transfer data into bound image.  Only called if DBindKind
//            allows databinding.
//
//  Arguments:
//            [id]      - ID of binding point.  For anchor, is always
//                        DISPID_CAnchorElement_href.
//            [pvData]  - pointer to data to transfer, in this case a bstr.
//
//-----------------------------------------------------------------------------
HRESULT
CDBindMethodsAnchor::BoundValueToElement(CElement *pElem,
                                         LONG,
                                         BOOL,
                                         LPVOID pvData) const
{
    RRETURN1(DYNCAST(CAnchorElement, pElem)->put_href(*(BSTR *)pvData), S_FALSE);
}
#endif // ndef NO_DATABINDING


// URL accessors - CHyperlink overrides

HRESULT
CAnchorElement::SetUrl(BSTR bstrUrl)
{
    return (s_propdescCAnchorElementhref.b.SetUrlProperty(bstrUrl,
                                this,
                                (CVoid *)(void *)GetAttrArray()));
}


LPCTSTR
CAnchorElement::GetUrl() const
{
    return GetAAhref();
}


LPCTSTR
CAnchorElement::GetTarget() const
{
    return GetAAtarget();
}


HRESULT
CAnchorElement::GetUrlTitle(CStr * pstr)
{
    HRESULT hr;
    LPCTSTR pchTitle = GetAAtitle();

    if (pchTitle && *pchTitle)
    {
        hr = THR(pstr->Set(pchTitle));
    }
    else
    {
        hr = THR(GetPlainTextInScope(pstr));
    }

    if (OK(hr) && GetMarkup()->_fVisualOrder) 
    {
        LPTSTR pStart = *pstr;
        LPTSTR pEnd = pStart + pstr->Length() - 1;

        while (pStart < pEnd)
        {
            const TCHAR ch = *pStart;
            *pStart++ = *pEnd;
            *pEnd-- = ch;
        }
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CAnchorElement::QueryStatus, public
//
//  Synopsis:   Implements QueryStatus for CAnchorElement
//
//  Notes:      Delegates to base class
//
//----------------------------------------------------------------------------

HRESULT
CAnchorElement::QueryStatus(
        GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    TraceTag((tagMsoCommandTarget, "CAnchorElement::QueryStatus"));

    Assert(cCmds == 1);
    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));

    HRESULT  hr   = S_OK;
    MSOCMD * pCmd = &rgCmds[0];

    Assert(!pCmd->cmdf);

    if (!hr && !pCmd->cmdf)
    {
        hr = THR_NOTRACE(super::QueryStatusHelper(pguidCmdGroup, cCmds, rgCmds, pcmdtext));
    }

    if (!hr && !pCmd->cmdf)
    {
        hr = THR_NOTRACE(CElement::QueryStatus(pguidCmdGroup, cCmds, rgCmds, pcmdtext));
    }

    RRETURN_NOTRACE(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CAnchorElement::Exec, public
//
//  Synopsis:   Executes a command on the CAnchorElement
//
//  Notes:      Delegates to base class
//
//----------------------------------------------------------------------------

HRESULT
CAnchorElement::Exec(
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    TraceTag((tagMsoCommandTarget, "CAnchorElement::Exec"));

    HRESULT hr = MSOCMDERR_E_NOTSUPPORTED;

    if (hr == MSOCMDERR_E_NOTSUPPORTED)
    {
        hr = THR_NOTRACE(super::ExecHelper(
                    pguidCmdGroup,
                    nCmdID,
                    nCmdexecopt,
                    pvarargIn,
                    pvarargOut));
    }

    if (hr == MSOCMDERR_E_NOTSUPPORTED)
    {
        hr = THR_NOTRACE(CElement::Exec(
                pguidCmdGroup,
                nCmdID,
                nCmdexecopt,
                pvarargIn,
                pvarargOut));
    }
    RRETURN_NOTRACE(hr);
}

HRESULT CAnchorElement::focus() { return super::focus(); };
HRESULT CAnchorElement::blur() { return super::blur(); };
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\comment.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       comment.cxx
//
//  Contents:   CCommentElement
//
//  History:    
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_COMMENT_HXX_
#define X_COMMENT_HXX_
#include "comment.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "comment.hdl"

MtDefine(CCommentElement, Elements, "CCommentElement")
ExternTag(tagDontRewriteDocType);

static
HRESULT
SetTextHelper(CStr *cstrText, LPTSTR lptnewstr, long length, ELEMENT_TAG Tag )
{
    HRESULT hr;
    if(Tag == ETAG_RAW_COMMENT)
    {
        hr = THR(cstrText->Set(_T("<!--"), 4));
        if(hr)
            goto Cleanup;
        
        hr = THR(cstrText->Append(lptnewstr, length));
        if(hr)
            goto Cleanup;
        
        hr = THR(cstrText->Append(_T("-->"), 3));
        if(hr)
            goto Cleanup;
    }
    else
    {
        hr = THR(cstrText->Set(lptnewstr, length));
        if(hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+-----------------------------------------------------------
//
//  Class: CCommentElement
//
//------------------------------------------------------------

const CElement::CLASSDESC CCommentElement::s_classdesc =
{
    {
        &CLSID_HTMLCommentElement,          // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLCommentElement,           // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLCommentElement,    // _apfnTearOff
    NULL                                    // _pAccelsRun
};



HRESULT CCommentElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    HRESULT hr = S_OK;

    CCommentElement *pElementComment;

    Assert(ppElement);

    pElementComment = new CCommentElement(pht->GetTag(), pDoc);
    if (!pElementComment)
        return E_OUTOFMEMORY;

    pElementComment->_fAtomic = pht->Is(ETAG_RAW_COMMENT);
    
    *ppElement = (CElement *)pElementComment;
    if (pElementComment->_fAtomic)
    {
        hr = pElementComment->_cstrText.Set(pht->GetPch(), pht->GetCch());
    }
    RRETURN(hr);
}

HRESULT
CCommentElement::Save( CStreamWriteBuff * pStreamWriteBuff, BOOL fEnd )
{
    HRESULT hr = S_OK;

    // Don't write out comments for end tags, plain text, RTF, or if
    // it's the DOCTYPE comment.
    if (    fEnd 
        ||  pStreamWriteBuff->TestFlag(WBF_SAVE_PLAINTEXT) 
        ||  pStreamWriteBuff->TestFlag(WBF_FOR_RTF_CONV)
        || (    _cstrText.Length() >= 9 && StrCmpNIC(_T("<!DOCTYPE"), _cstrText, 9) == 0 
            &&  !Doc()->_fDontWhackGeneratorOrCharset WHEN_DBG( && !IsTagEnabled( tagDontRewriteDocType ) ) ) )
        return(hr);

    DWORD dwOldFlags = pStreamWriteBuff->ClearFlags(WBF_ENTITYREF);

    pStreamWriteBuff->SetFlags(WBF_SAVE_VERBATIM | WBF_NO_WRAP);

    // TODO: hack to preserve line breaks
    pStreamWriteBuff->BeginPre();

    if (!_fAtomic)
    {
        // Save <tagname>
        hr = THR(super::Save(pStreamWriteBuff, FALSE));
        if (hr)
            goto Cleanup;
    }
    hr = THR(pStreamWriteBuff->Write((LPTSTR)_cstrText));

    if (hr)
        goto Cleanup;
    if (!_fAtomic)
    {
        // Save </tagname>
        hr = THR(super::Save(pStreamWriteBuff, TRUE));
        if (hr)
            goto Cleanup;
    }

    //TODO see above
    pStreamWriteBuff->EndPre();

    if (!hr)
    {
        pStreamWriteBuff->RestoreFlags(dwOldFlags);
    }
Cleanup:
    RRETURN(hr);
}

HRESULT
CCommentElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_TEAROFF(this, IHTMLCommentElement2, NULL);
    }

    if (*ppv)
    {
        ((IUnknown *) *ppv)->AddRef();
        RRETURN(S_OK);
    }

    RRETURN(super::PrivateQueryInterface(iid, ppv));
}

HRESULT
CCommentElement::get_data(BSTR *pbstrData)
{
    HRESULT hr = S_OK;

    if(!pbstrData)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    if(Tag() == ETAG_RAW_COMMENT)
        hr = FormsAllocStringLen ( _cstrText+4, _cstrText.Length()-7, pbstrData );
    else
        hr = FormsAllocStringLen ( _cstrText, _cstrText.Length(), pbstrData );

    if ( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CCommentElement::put_data(BSTR bstrData)
{
    HRESULT hr = S_OK;

    hr = THR(SetTextHelper(&_cstrText, bstrData, SysStringLen(bstrData), Tag()));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CCommentElement::get_length(long *pLength)
{
    HRESULT hr = S_OK;

    *pLength = _cstrText.Length();
    
    if(Tag() == ETAG_RAW_COMMENT)
        *pLength -= 7;

    goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CCommentElement::substringData (long loffset, long lCount, BSTR* pbstrsubString)
{
    HRESULT hr = S_OK;
    long length = _cstrText.Length();
    if(Tag() == ETAG_RAW_COMMENT) length -= 7;
    long numChars = length - loffset;

    if(loffset > length || loffset < 0 || lCount < 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if(numChars > lCount)
        numChars = lCount;

    if(Tag() == ETAG_RAW_COMMENT)
        loffset+=4; //Account for Raw_Comment

    hr = THR(FormsAllocStringLen(_cstrText+loffset, numChars, pbstrsubString));
    if( hr )
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CCommentElement::appendData (BSTR bstrstring)
{
    HRESULT hr = S_OK;
    LPTSTR lptnewstr = NULL;

    if(Tag() == ETAG_RAW_COMMENT)
    {
        LPTSTR lpstr = LPTSTR(_cstrText);
        long length = _cstrText.Length();
        lptnewstr = new TCHAR[length-3];
        if(!lptnewstr)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        CopyMemory(lptnewstr, lpstr, (length-3)*sizeof(TCHAR));
        hr = THR(_cstrText.Set(lptnewstr, length-3));
        if(hr)
            goto Cleanup;

    }
    
    hr = THR(_cstrText.Append(bstrstring));
    if( hr )
        goto Cleanup;

    if(Tag() == ETAG_RAW_COMMENT)
    {
        hr = THR(_cstrText.Append(_T("-->")));
        if(hr)
            goto Cleanup;
    }

Cleanup:
    if(lptnewstr)
        delete lptnewstr;

    RRETURN(SetErrorInfo(hr));
}

HRESULT
CCommentElement::insertData (long loffset, BSTR bstrstring)
{
    HRESULT hr = S_OK;
    long length = _cstrText.Length();
    long rawoffset = 0;
    if(Tag() == ETAG_RAW_COMMENT)
    {
        length -= 7;
        rawoffset = 4;
    }
    LPTSTR lptnewstr = NULL;
    long linslength = SysStringLen(bstrstring);
    long lcomvar = linslength + loffset;

    if(loffset > length || loffset < 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    length += linslength;

    lptnewstr = new TCHAR[length];
    if (!lptnewstr)
    {
         hr = E_OUTOFMEMORY;
         goto Cleanup;
    }

    CopyMemory(lptnewstr, _cstrText+rawoffset, loffset*sizeof(TCHAR));
    CopyMemory(lptnewstr+loffset, bstrstring, linslength*sizeof(TCHAR));
    CopyMemory(lptnewstr+lcomvar, _cstrText+rawoffset+loffset, (length-lcomvar)*sizeof(TCHAR));
    
    hr = THR(SetTextHelper(&_cstrText, lptnewstr, length, Tag()));
    if(hr)
        goto Cleanup;

Cleanup:
    if(lptnewstr)
        delete lptnewstr;
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CCommentElement::deleteData (long loffset, long lCount)
{
    HRESULT hr = S_OK;
    long length = _cstrText.Length();
    long rawoffset = 0;
    if(Tag() == ETAG_RAW_COMMENT) 
    {
        length -= 7;
        rawoffset = 4;
    }
    LPTSTR lptnewstr = NULL;
    long numChars = length - loffset;

    if(loffset > length || loffset < 0 || lCount < 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    if(!lCount)
        goto Cleanup;
        
    if(numChars > lCount)
        numChars = lCount;

    length -= numChars;

    lptnewstr = new TCHAR[length];
    if (!lptnewstr)
    {
         hr = E_OUTOFMEMORY;
         goto Cleanup;
    }

    CopyMemory(lptnewstr, _cstrText+rawoffset, loffset*sizeof(TCHAR));
    CopyMemory(lptnewstr+loffset, _cstrText + rawoffset + loffset + numChars, (length - loffset)*sizeof(TCHAR));

    hr = THR(SetTextHelper(&_cstrText, lptnewstr, length, Tag()));
    if(hr)
        goto Cleanup;

Cleanup:
    if(lptnewstr)
        delete lptnewstr;
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CCommentElement::replaceData (long loffset, long lCount, BSTR bstrstring)
{
    HRESULT hr = S_OK;
    long length = _cstrText.Length();
    long rawoffset = 0;
    if(Tag() == ETAG_RAW_COMMENT) 
    {
        length -= 7;
        rawoffset = 4;
    }

    LPTSTR lptnewstr = NULL;
    long linslength = SysStringLen(bstrstring);
    long lcomvar = linslength + loffset;
    long numChars = length - loffset;

    if(loffset > length || loffset < 0 || lCount < 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if(numChars > lCount)
        numChars = lCount;

    length += (linslength-numChars);

    lptnewstr = new TCHAR[length];
    if (!lptnewstr)
    {
         hr = E_OUTOFMEMORY;
         goto Cleanup;
    }

    CopyMemory(lptnewstr, _cstrText+rawoffset, loffset*sizeof(TCHAR));
    CopyMemory(lptnewstr+loffset, bstrstring, linslength*sizeof(TCHAR));

    CopyMemory(lptnewstr+lcomvar, _cstrText+loffset+numChars+rawoffset, (length-lcomvar)*sizeof(TCHAR));

    hr = THR(SetTextHelper(&_cstrText, lptnewstr, length, Tag()));
    if(hr)
        goto Cleanup;

Cleanup:
    if(lptnewstr)
        delete lptnewstr;
    RRETURN(SetErrorInfo(hr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\earea.cxx ===
//=-----------------------------------------------------------=
//
// File:        earea.cxx
//
// Contents:    Area element class
//
// Classes:     CAreaElement
//
//=-----------------------------------------------------------=


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MATH_H_
#define X_MATH_H_
#include "math.h"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"   // For AnchorPropertyPage
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X_EMAP_HXX_
#define X_EMAP_HXX_
#include "emap.hxx"
#endif

#ifndef X_JSPROT_HXX_
#define X_JSPROT_HXX_
#include "jsprot.hxx"
#endif

#ifndef X_WCHDEFS_H_
#define X_WCHDEFS_H_
#include "wchdefs.h"
#endif

#ifndef X_RECT_HXX_
#define X_RECT_HXX_
#include "rect.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#define _cxx_
#include "area.hdl"

MtDefine(CAreaElement, Elements, "CAreaElement")
MtDefine(CImgAreaStub, Elements, "CImgAreaStub")

ExternTag(tagMsoCommandTarget);

#ifndef NO_PROPERTY_PAGE
const CLSID * const CAreaElement::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
#endif // DBG==1    
    NULL
};
#endif // NO_PROPERTY_PAGE


const CElement::CLASSDESC CAreaElement::s_classdesc =
{
    {
    &CLSID_HTMLAreaElement,             // _pclsid
    0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
    s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
    s_acpi,                             // _pcpi
    ELEMENTDESC_NOLAYOUT,               // _dwFlags
    &IID_IHTMLAreaElement,              // _piidDispinterface
    &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLAreaElement,   // _pfnTearOff
    NULL                                // _pAccelsRun
};


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//      Creation and Initialization
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

//=-----------------------------------------------------------------------=
//
// Function:    CreateElement
//
// Synopsis:    Creates an instance of the given element's class
//
// Arguments:   CHtmTag *pht - struct for tag creation info.
//              CElement *pElementParent - The parent of the element
//              CElement **ppElement - Return ptr to element in *ppElement.
//
//=-----------------------------------------------------------------------=
HRESULT
CAreaElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    HRESULT hr = S_OK;

    Assert(pht->Is(ETAG_AREA));
    Assert(ppElement);

    *ppElement = new CAreaElement(pDoc);

    if (!*ppElement)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
Cleanup:
    RRETURN(hr);
}

//=-----------------------------------------------------------------------=
//
// Function:    Init2()
//
// Synopsis:    Overridden to set netscape events (copied from
//              CAnchorElement::Init2()).
//
//=-----------------------------------------------------------------------=

HRESULT
CAreaElement::Init2(CInit2Context * pContext)
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = Doc();

    Assert(pDoc);
    if (pDoc)
    {
        // Set default shape and parse the coords string if needed
        if (!_fShapeSet)
        {
            // No shape attribute is specified in the HTML
            _nShapeType = SHAPE_TYPE_RECT;
            _fShapeSet = TRUE;
            if (!_strCoords.IsNull())
            {
                hr = ParseCoords();
            }
        }

    }

    RRETURN(super::Init2(pContext));
}

//=-----------------------------------------------------------------------=
//
// Function:    GetcoordsHelper
//
// Synopsis:    Gets the coordinates attribute
//
// Arguments:   BSTR *bstrCOORDS - Pointer to BSTR for COORDS
//
//=-----------------------------------------------------------------------=
HRESULT
CAreaElement::GetcoordsHelper(CStr *pstrCOORDS)
{
    HRESULT hr = S_OK;
    TCHAR   achTemp[1024];
    int     c;
    int     nOffset;
    POINT  *ppt;
    BOOL    fFirst;

    Assert(pstrCOORDS);

    *achTemp = 0;
    switch(_nShapeType)
    {
    case SHAPE_TYPE_RECT:
        hr = THR(Format(0,
                &achTemp,
                ARRAY_SIZE(achTemp),
                _T("<0d>,<1d>,<2d>,<3d>"),
                (long)_coords.Rect.left,
                (long)_coords.Rect.top,
                (long)_coords.Rect.right,
                (long)_coords.Rect.bottom));
        if (hr)
            goto Cleanup;
        hr = THR(pstrCOORDS->Set(achTemp));
        break;

    case SHAPE_TYPE_CIRCLE:
        hr = THR(Format(0,
                &achTemp,
                ARRAY_SIZE(achTemp),
                _T("<0d>,<1d>,<2d>"),
                (long)_coords.Circle.lx,
                (long)_coords.Circle.ly,
                (long)_coords.Circle.lradius));
        if (hr)
            goto Cleanup;
        hr = THR(pstrCOORDS->Set(achTemp));
        break;

    case SHAPE_TYPE_POLY:
        hr = THR(pstrCOORDS->Set(_T("")));
        if (hr)
            goto Cleanup;
        fFirst = TRUE;
        for(c = _ptList.Size(), ppt = _ptList; c > 0; c--, ppt++)
        {
            if (fFirst)
            {
                fFirst = FALSE;
                nOffset = 0;
            }
            else
            {
                achTemp[0] = _T(',');
                nOffset = 1;
            }
            hr = THR(Format(0,
                    &(achTemp[nOffset]),
                    ARRAY_SIZE(achTemp)-nOffset,
                    _T("<0d>,<1d>"),
                    ppt->x,
                    ppt->y));
            if (hr)
                goto Cleanup;
            hr = THR(pstrCOORDS->Append(achTemp));
            if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN ( hr );
}

//=-----------------------------------------------------------------------=
//
// Function:    SetcoordsHelper
//
// Synopsis:    Sets the coordinates attribute
//
// Arguments:   CStr pstrCOORDS - String containing COORDS
//
//=-----------------------------------------------------------------------=
HRESULT
CAreaElement::SetcoordsHelper(CStr *pstrCOORDS)
{
    if (!pstrCOORDS->Length())
        RRETURN(S_OK);

    // Copy the buffer for tokenizing
    _strCoords.Set(*pstrCOORDS);

    // Don;t parse this yet if we don't know the shape
    if (!_fShapeSet)
    {
        RRETURN(S_OK);
    }
    RRETURN(ParseCoords());
}

//=-----------------------------------------------------------------------=
//
// Function:    NextNumInDevicePixelsY
//
// Synopsis:    Return the next num in doc pixels instead of device
//
//=-----------------------------------------------------------------------=

HRESULT 
CAreaElement::NextNumInDevicePixelsY(LONG *plNum, TCHAR **ppch)
{
    HRESULT hr;

    hr = THR(NextNum(plNum, ppch));
    if (FAILED(hr)) 
        goto Cleanup;

    *plNum = g_uiDisplay.DeviceFromDocPixelsY(*plNum);

Cleanup:
    RRETURN(hr);
}

//=-----------------------------------------------------------------------=
//
// Function:    NextNumInDevicePixelsX
//
// Synopsis:    Return the next num in doc pixels instead of device
//
//=-----------------------------------------------------------------------=

HRESULT 
CAreaElement::NextNumInDevicePixelsX(LONG *plNum, TCHAR **ppch)
{
    HRESULT hr;

    hr = THR(NextNum(plNum, ppch));
    if (FAILED(hr)) 
        goto Cleanup;

    *plNum = g_uiDisplay.DeviceFromDocPixelsX(*plNum);

Cleanup:
    RRETURN(hr);
}

//=-----------------------------------------------------------------------=
//
// Function:    ParseCoords
//
// Synopsis:    Parses the input string and sets the coordinates attribute.
//
//=-----------------------------------------------------------------------=
HRESULT
CAreaElement::ParseCoords()
{
    POINT pt;
    TCHAR *pch;

    Assert(_fShapeSet);
    Assert(_strCoords.Length());

    //
    // Grab the first token.  If _tcstok returns NULL,
    // we want to keep processing, because this means they
    // gave us an empty coordinate string.  Right now,
    // missing values are set to 0.
    //

    pch = _tcstok(_strCoords, DELIMS);

    switch(_nShapeType)
    {
    case SHAPE_TYPE_RECT:
        NextNumInDevicePixelsX(&_coords.Rect.left, &pch);
        NextNumInDevicePixelsY(&_coords.Rect.top, &pch);
        NextNumInDevicePixelsX(&_coords.Rect.right, &pch);
        NextNumInDevicePixelsY(&_coords.Rect.bottom, &pch);

        UpdateRectangle();
        break;

    case SHAPE_TYPE_CIRCLE:
        NextNumInDevicePixelsX(&_coords.Circle.lx, &pch);
        NextNumInDevicePixelsY(&_coords.Circle.ly, &pch);
        NextNumInDevicePixelsX(&_coords.Circle.lradius, &pch);

        break;

    case SHAPE_TYPE_POLY:
        if(_ptList.Size())
        {
            _ptList.DeleteMultiple(0, _ptList.Size() - 1);
        }
        while(pch)
        {
            NextNumInDevicePixelsX(&pt.x, &pch);
            NextNumInDevicePixelsY(&pt.y, &pch);
           _ptList.AppendIndirect(&pt);
        }
        if (_ptList.Size())
        {
            // We don't store the same point as first and last
            if((_ptList[0].x == _ptList[_ptList.Size() - 1].x) &&
               (_ptList[0].y == _ptList[_ptList.Size() - 1].y))
            {
                _ptList.Delete(_ptList.Size() - 1);
            }
        }
        UpdatePolygon();
        break;
    }

    _strCoords.Free();
    RRETURN(S_OK);
}


//=-----------------------------------------------------------------------=
//
// Function:    GetshapeHelper
//
// Synopsis:    Gets the Shape attribute
//
// Arguments:   BSTR *bstrSHAPE - Pointer to BSTR for SHAPE
//
//=-----------------------------------------------------------------------=
HRESULT
CAreaElement::GetshapeHelper(CStr *pstrSHAPE)
{
    HRESULT hr = S_OK;
    Assert(pstrSHAPE);

    switch(_nShapeType)
    {
    case SHAPE_TYPE_RECT:
        hr = THR ( pstrSHAPE -> Set (_T("RECT")) );
        break;

    case SHAPE_TYPE_CIRCLE:
        hr = THR ( pstrSHAPE -> Set (_T("CIRCLE")) );
        break;

    case SHAPE_TYPE_POLY:
        hr = THR ( pstrSHAPE -> Set (_T("POLY")) );
        break;
    }


    RRETURN ( hr );
}


//=-----------------------------------------------------------------------=
//
// Function:    SetshapeHelper
//
// Synopsis:    Sets the shape attribute
//
// Arguments:   BSTR bstrSHAPE - BSTR containing SHAPE
//
//=-----------------------------------------------------------------------=
HRESULT
CAreaElement::SetshapeHelper(CStr *pstrSHAPE)
{
    HRESULT hr = S_OK;

    if (!*pstrSHAPE)
    {
        _nShapeType = SHAPE_TYPE_RECT;
    }
    else if (!StrCmpIC(*pstrSHAPE, _T("CIRC")) ||
         !StrCmpIC(*pstrSHAPE, _T("CIRCLE")))
    {
        _nShapeType = SHAPE_TYPE_CIRCLE;
    }
    else if (!StrCmpIC(*pstrSHAPE, _T("POLY")) ||
         !StrCmpIC(*pstrSHAPE, _T("POLYGON")))
    {
        _nShapeType = SHAPE_TYPE_POLY;
    }
    else
    {
        _nShapeType = SHAPE_TYPE_RECT;
    }

    // Parse the coords string if needed
    if (!_fShapeSet)
    {
        _fShapeSet = TRUE;
        if (!_strCoords.IsNull())
        {
            hr = ParseCoords();
        }
    }


    RRETURN(hr);
}



///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//      End Creation and Initialization
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////



///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//      Destructor
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

void CAreaElement::Passivate()
{
    if(_nShapeType == SHAPE_TYPE_POLY && _coords.Polygon.hPoly)
    {
        DeleteObject(_coords.Polygon.hPoly);
        _coords.Polygon.hPoly = NULL;
    }

    super::Passivate();
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//      End Destructor
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//      Drawing related Code
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////



//=-----------------------------------------------------------------------=
//
// Function:    Draw
//
// Synopsis:    Performs the drawing of the Area, given a DC
//
// Arguments:   CFormDrawInfo * pDI - draw info
//              CElement *      pImg- Associated image
//
//=-----------------------------------------------------------------------=

HRESULT
CAreaElement::Draw(CFormDrawInfo * pDI, CElement * pImg)
{
    CRect   rcFocus, rcImg;
    LONG    xOff, yOff;
    XHDC    hdc  = pDI->GetDC(TRUE);

    Assert(pImg);
    Assert(pImg->Doc());
    Assert(pImg->Doc()->_pInPlace);

    DYNCAST(CImgElement, pImg)->_pImage->GetRectImg(&rcImg);
    xOff = rcImg.left;
    yOff = rcImg.top;

    // Should not come here in browse mode
    Assert(pImg->IsEditable(TRUE));

    switch(_nShapeType)
    {
    case SHAPE_TYPE_RECT:
        rcFocus.left    = _coords.Rect.left     + xOff;
        rcFocus.top     = _coords.Rect.top      + yOff;
        rcFocus.right   = _coords.Rect.right    + xOff;
        rcFocus.bottom  = _coords.Rect.bottom   + yOff;
        Rectangle(hdc, rcFocus.left, rcFocus.top,
            rcFocus.right, rcFocus.bottom);
        break;

    case SHAPE_TYPE_CIRCLE:
        Ellipse(hdc,
            _coords.Circle.lx - _coords.Circle.lradius + xOff,
            _coords.Circle.ly - _coords.Circle.lradius + yOff,
            _coords.Circle.lx + _coords.Circle.lradius + xOff,
            _coords.Circle.ly + _coords.Circle.lradius + yOff);

        break;

    case SHAPE_TYPE_POLY:
        POINT *ppt;
        UINT c;

        // Do we have enough points to draw a polygon ?
        if (_ptList.Size() < 2)
            break;

        MoveToEx(hdc, _ptList[0].x + xOff, _ptList[0].y + yOff, (POINT *)NULL);
        for(c = _ptList.Size(), ppt = &(_ptList[1]);
            c > 1;                  // c > 1, because we MoveTo'd the first pt
            ppt++, c--)
        {
            LineTo(hdc, ppt->x + xOff, ppt->y + yOff);
        }
        //
        // If there are only 2 points in the polygon, we don't want to draw
        // the same line twice and end up with nothing!
        //

        if(_ptList.Size() != 2)
        {
            LineTo(hdc, _ptList[0].x + xOff, _ptList[0].y + yOff);

        }
        break;

    default:
        Assert(FALSE && "Invalid Shape");

        break;
    }

    return S_OK;
}

//=-----------------------------------------------------------------------=
//
// Function:    GetBoundingRect
//
// Synopsis:    Returns the bounding rectangle for the area.
//
//=-----------------------------------------------------------------------=
void
CAreaElement::GetBoundingRect(RECT *prc)
{
    int i;

    switch(_nShapeType)
    {
    case SHAPE_TYPE_RECT:
        *prc = _coords.Rect;
        break;
    case SHAPE_TYPE_CIRCLE:
        prc->left = _coords.Circle.lx - _coords.Circle.lradius;
        prc->top = _coords.Circle.ly - _coords.Circle.lradius;
        prc->right = _coords.Circle.lx + _coords.Circle.lradius;
        prc->bottom = _coords.Circle.ly + _coords.Circle.lradius;
        break;
    case SHAPE_TYPE_POLY:
        if (_ptList.Size() == 0)
            break;
        prc->left = prc->right = _ptList[0].x;
        prc->top = prc->bottom = _ptList[0].y;
        for (i = _ptList.Size() - 1; i > 0; i--)
        {
            if (_ptList[i].x < prc->left)
            {
                prc->left = _ptList[i].x;
            }
            else if (_ptList[i].x > prc->right)
            {
                prc->right = _ptList[i].x;
            }
            if (_ptList[i].y < prc->top)
            {
                prc->top = _ptList[i].y;
            }
            else if (_ptList[i].y > prc->bottom)
            {
                prc->bottom = _ptList[i].y;
            }
        }
        break;
    }
}


//=-----------------------------------------------------------------------=
//
// Function:    UpdatePolygon
//
// Synopsis:    Updates the internal polygon region.
//
// Notes:       Should only be called if the region is actually a
//              SHAPE_TYPE_POLY.
//
//=-----------------------------------------------------------------------=
HRESULT
CAreaElement::UpdatePolygon()
{
    HRGN hNew;

    Assert(_nShapeType == SHAPE_TYPE_POLY);

    hNew = CreatePolygonRgn(_ptList, _ptList.Size(), ALTERNATE);

    if(hNew == NULL)
    {
        return E_OUTOFMEMORY;
    }
    else
    {
        if (_coords.Polygon.hPoly)
            DeleteObject(_coords.Polygon.hPoly);
        _coords.Polygon.hPoly = hNew;

        return S_OK;
    }
}


//=-----------------------------------------------------------------------=
//
// Function:    UpdateRectangle
//
// Synopsis:    Updates the rectangle coordinates.
//
// Notes:       Should only be called if the region is actually a
//              SHAPE_TYPE_RECT.
//
//=-----------------------------------------------------------------------=
HRESULT
CAreaElement::UpdateRectangle()
{
    LONG ltemp;

    Assert(_nShapeType == SHAPE_TYPE_RECT);

    if(_coords.Rect.left > _coords.Rect.right)
    {
        ltemp = _coords.Rect.left;
        _coords.Rect.left = _coords.Rect.right;
        _coords.Rect.right = ltemp;
    }

    if(_coords.Rect.top > _coords.Rect.bottom)
    {
        ltemp = _coords.Rect.top;
        _coords.Rect.top = _coords.Rect.bottom;
        _coords.Rect.bottom = ltemp;
    }

    return S_OK;
}

///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//      End Modification/Update Code
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


///////////////////////////////////////////////////////////////////////////////
// Helpers

HRESULT
CAreaElement::InsertIntoElemTree ( CMapElement * pMap, long lItemIndex )
{
    HRESULT    hr = S_OK;
    CTreeNode *pNodeAdjacentTo;
    Where      adjacencyHow;

    if (lItemIndex <= 0)
    {
        pNodeAdjacentTo = pMap->GetFirstBranch();
        adjacencyHow = AfterBegin;
    }
    else
    {
        CChildIterator ci(pMap);
        CTreeNode * pNode;
        LONG lIndex = 0;

        pNodeAdjacentTo = NULL;
        adjacencyHow = AfterEnd;

        while ((pNode = ci.NextChild()) != NULL)
        {
            if (pNode->Tag() == ETAG_AREA)
            {
                if (lItemIndex-1 == lIndex)
                {
                    if (ci.NextChild())
                    {
                        pNodeAdjacentTo = pNode;
                    }
                    break;
                }

                lIndex += 1;
            }
        }

        if (pNodeAdjacentTo == NULL)
        {
            pNodeAdjacentTo = pMap->GetFirstBranch();
            adjacencyHow = BeforeEnd;
        }
    }

    Assert(pNodeAdjacentTo);

    hr = THR( pNodeAdjacentTo->Element()->InsertAdjacent( adjacencyHow, this ) );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}

HRESULT
CAreaElement::RemoveFromElemTree()
{
    HRESULT hr;

    hr = THR( RemoveOuter() );

    if (hr)
        goto Cleanup;

Cleanup:

    RRETURN( hr );
}


HRESULT
CAreaElement::focus()
{
    HRESULT hr = S_OK;
    CNotification   nf;
    CMarkup *       pMarkup = GetMarkup();

    // we could have been created and not added to the tree yet
    if (!pMarkup || !pMarkup->GetElementClient())
        goto Cleanup;

    nf.AreaFocus(pMarkup->GetElementClient(), this);
    pMarkup->Notify(&nf);

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CAreaElement::blur()
{
    HRESULT         hr = S_OK;
    CImgElement *   pImg;
    long            lIndex;
    CDoc *          pDoc = Doc();
    
    Assert(pDoc);

    // don't blur if the img is not current, this area is not the _pArea
    // or the frame in which this object is, does not currently have the focus
    if (!pDoc->_pInPlace ||
        ::GetFocus() != pDoc->_pInPlace->_hwnd ||
        pDoc->_pElemCurrent->Tag() != ETAG_IMG)
        goto Cleanup;

    //
    // Search for this area in the current element's map.
    //

    pImg = DYNCAST(CImgElement, pDoc->_pElemCurrent);
    pImg->EnsureMap();
    if (!pImg->GetMap())
        goto Cleanup;

    if (!OK(pImg->GetMap()->SearchArea(this, &lIndex)))
        goto Cleanup;
    
    // make the body the current site. Become current handles all the event firing
    hr = THR(pImg->blur());

Cleanup:
    RRETURN(hr);
}

void
CAreaElement::Notify(CNotification *pNF)
{
    super::Notify(pNF);
    switch (pNF->Type())
    {
    case NTYPE_BASE_URL_CHANGE: 
        _fBaseUrlChanged = TRUE;
        OnPropertyChange( DISPID_CAreaElement_href, 
                          ((PROPERTYDESC *)&s_propdescCAreaElementhref)->GetdwFlags(),
                          (PROPERTYDESC *)&s_propdescCAreaElementhref);
        break;
    case NTYPE_ELEMENT_QUERYMNEMONICTARGET:
        *(FOCUS_ITEM *)pNF->DataAsPtr() = GetFocusItem();
        break;
    }
}


FOCUS_ITEM
CAreaElement::GetFocusItem()
{
    FOCUS_ITEM          fi;
    CElement *          pElem       = NULL;
    CImgElement *       pImg        = NULL;
    int                 i, c;
    CCollectionCache*   pCollectionCache;

    fi.pElement = NULL;
    fi.lSubDivision = 0;

    if (!IsInMarkup())
        goto Cleanup;

    // Search the document's collection for the first image that has this AREA as
    // a subdivision.
    if (S_OK != THR(GetMarkup()->EnsureCollectionCache(CMarkup::IMAGES_COLLECTION)))
        goto Cleanup;

    pCollectionCache = GetMarkup()->CollectionCache();

    // get size of collection
    c = pCollectionCache->SizeAry(CMarkup::IMAGES_COLLECTION);

    for (i = 0; i < c; i++)
    {
        if (S_OK != THR(pCollectionCache->GetIntoAry(CMarkup::IMAGES_COLLECTION, i, &pElem)))
            goto Cleanup;

        if (pElem->Tag() != ETAG_IMG)
            continue;

        pImg = DYNCAST(CImgElement, pElem);
        if (!pImg->EnsureAndGetMap())
            continue;

        if (OK(pImg->GetMap()->SearchArea(this, &fi.lSubDivision)))
        {
            fi.pElement = pImg;
            break;
        }
    }
Cleanup:
    return fi;
}


HRESULT
CAreaElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{

    switch (dispid)
    {
    case DISPID_CAreaElement_href:
        _fOMSetHasOccurred = !_fBaseUrlChanged;
        _fBaseUrlChanged = FALSE;
        break;

    case DISPID_CElement_tabIndex:
        {
            CNotification   nf;
            CMarkup *       pMarkup = GetMarkup();

            // we could have been created and not added to the tree yet
            if (!pMarkup || !pMarkup->GetElementClient())
                break;

            nf.AreaTabindexChange(pMarkup->GetElementClient(), this);
            pMarkup->Notify(&nf);
        }
        break;
    }
    
    return super::OnPropertyChange( dispid, dwFlags, ppropdesc );
}


// URL accessors - CHyperlink overrides

HRESULT
CAreaElement::SetUrl(BSTR bstrUrl)
{
    return (s_propdescCAreaElementhref.b.SetUrlProperty(bstrUrl,
                this,
                (CVoid *)(void *)GetAttrArray()));
}


LPCTSTR
CAreaElement::GetUrl() const
{
    return GetAAhref();
}


LPCTSTR
CAreaElement::GetTarget() const
{
    return GetAAtarget();
}


HRESULT
CAreaElement::GetUrlTitle(CStr *pstr)
{
    pstr->Set(GetAAalt());
    if (pstr->Length() == 0)
        pstr->Set(GetAAtitle());
    return S_OK;
}


HRESULT
CAreaElement::ClickAction (CMessage *pmsg)
{
    HRESULT hr = super::ClickAction(pmsg);

    // Do not want this to bubble, so..
    if (S_FALSE == hr)
        hr = S_OK;

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\ebgsound.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       ebgsound.cxx
//
//  Contents:   CBGsound & related
//
//
//----------------------------------------------------------------------------

#include "headers.hxx"      // for the world

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"     // for cbitsctx
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"     // for celement
#endif

#ifndef X_EBGSOUND_HXX_
#define X_EBGSOUND_HXX_
#include "ebgsound.hxx"     // for cbgsound
#endif

#ifndef X_MMPLAY_HXX_
#define X_MMPLAY_HXX_
#include "mmplay.hxx"       // for ciemmplayer
#endif

#define _cxx_
#include "bgsound.hdl"      

MtDefine(CBGsound, Elements, "CBGsound")
extern BOOL IsScriptUrl(LPCTSTR pszURL);

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
const CBGsound::CLASSDESC CBGsound::s_classdesc =
{
    {
        &CLSID_HTMLBGsound,                 // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                               // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLBGsound,                  // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLBGsound
};

//----------------------------------------------------------------------------
//----------------------------------------------------------------------------
HRESULT CBGsound::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(ppElement);

    *ppElement = new CBGsound(pDoc);

    return *ppElement ? S_OK : E_OUTOFMEMORY;
}


HRESULT
CBGsound::EnterTree()
{
    GWPostMethodCall(this, ONCALL_METHOD(CBGsound, OnSrcAvailable, onsrcavailable), 0, TRUE, "CBGsound::OnSrcAvailable");

    return S_OK;
}

void
CBGsound::OnSrcAvailable(DWORD_PTR dwContext)
{
    CDoc *pDoc = Doc();

    if (pDoc && (pDoc->State() >= OS_INPLACE))
        _fIsInPlace = TRUE;

    AddRef();
    THR(OnPropertyChange(DISPID_CBGsound_src, 
                         0, 
                         (PROPERTYDESC *)&s_propdescCBGsoundsrc));
    Release();
}


//+---------------------------------------------------------------------------
//
//  Member:     CBGSound::Init2
//
//  Synopsis:   Init override
//
//----------------------------------------------------------------------------

HRESULT 
CBGsound::Init2(CInit2Context * pContext)
{
    CDoc * pDoc = Doc();

    pDoc->_fBroadcastInteraction = TRUE;
    pDoc->_fBroadcastStop = TRUE;

    RRETURN(super::Init2(pContext));
}

//+---------------------------------------------------------------------------
//
//  Member:     CBGSound::Notify
//
//  Synopsis:   Handle notifications
//
//----------------------------------------------------------------------------

void
CBGsound::Notify(CNotification *pNF)
{
    super::Notify(pNF);
    switch (pNF->Type())
    {
    case NTYPE_DOC_STATE_CHANGE_1:
        if (!!_fIsInPlace != (Doc()->State() >= OS_INPLACE))
        {
            pNF->SetSecondChanceRequested();
        }
        break;

    case NTYPE_DOC_STATE_CHANGE_2:
        {
            CDoc * pDoc = Doc();

            Assert( !!_fIsInPlace != (pDoc->State() >= OS_INPLACE) );

            _fIsInPlace = pDoc->State() >= OS_INPLACE;

            SetAudio();

            if (_pBitsCtx && _fIsInPlace)
            {
                DWNLOADINFO dli;
                if( SUCCEEDED ( GetMarkup()->InitDownloadInfo(&dli) ) )
                {
                    _pBitsCtx->SetLoad(TRUE, &dli, FALSE);
                }
            }
        }
        break;

    case NTYPE_STOP_1:
    case NTYPE_MARKUP_UNLOAD_1:
        if (_pBitsCtx)
            _pBitsCtx->SetLoad(FALSE, NULL, FALSE);

        if (_pSoundObj)
            pNF->SetSecondChanceRequested();
        break;

    case NTYPE_STOP_2:
    case NTYPE_MARKUP_UNLOAD_2:
        if (_pSoundObj)
        {
            _pSoundObj->Stop();    // stop whatever we were playing
            _fStopped = TRUE;
        }
        break;

    case NTYPE_ENABLE_INTERACTION_1:
        pNF->SetSecondChanceRequested();
        break;

    case NTYPE_ENABLE_INTERACTION_2:
        SetAudio();
        break;

    case NTYPE_ACTIVE_MOVIE:
        {
            void * pv;

            pNF->Data(&pv);

            if (_pSoundObj && (pv == this))
                _pSoundObj->NotifyEvent();              
                // Let the sound object know something happened
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        if (_pSoundObj)
        {
            pNF->SetSecondChanceRequested();
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_2:
        {
            if(!_pSoundObj->Release())
                _pSoundObj = NULL;
        }

        break;

    case NTYPE_ELEMENT_ENTERTREE:
        EnterTree();
        break;
        
    case NTYPE_BASE_URL_CHANGE:
        OnPropertyChange( DISPID_CBGsound_src, 
                          ((PROPERTYDESC *)&s_propdescCBGsoundsrc)->GetdwFlags(),
                          (PROPERTYDESC *)&s_propdescCBGsoundsrc);
        break;
    }
}


void
CBGsound::SetBitsCtx(CBitsCtx * pBitsCtx)
{
    if (_pBitsCtx)
    {
        if (_pSoundObj)
        {
            _pSoundObj->Stop();    // stop whatever we were playing
            ClearInterface(&_pSoundObj);
        }
        
        _pBitsCtx->SetProgSink(NULL); // detach download from document's load progress
        _pBitsCtx->Disconnect();
        _pBitsCtx->Release();
    }

    _pBitsCtx = pBitsCtx;

    if (pBitsCtx)
    {
        pBitsCtx->AddRef();

        _fStopped = FALSE;

        if (pBitsCtx->GetState() & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED))
            OnDwnChan(pBitsCtx);
        else
        {
            pBitsCtx->SetProgSink(CMarkup::GetProgSinkHelper(GetMarkup()));
            pBitsCtx->SetCallback(OnDwnChanCallback, this);
            pBitsCtx->SelectChanges(DWNCHG_COMPLETE, 0, TRUE);
        }
    }
}

//+------------------------------------------------------------------------
//
//  Method:     CBgsound::SetAudio
//
//-------------------------------------------------------------------------

void CBGsound::SetAudio()
{
    CDoc *  pDoc = Doc();

    if (!_pSoundObj)
        return;

    if (_fIsInPlace && pDoc->_fEnableInteraction && !_fStopped && !IsPrintMedia())
    {
        _pSoundObj->SetNotifyWindow(pDoc->GetHWND(), WM_ACTIVEMOVIE, (LONG_PTR)this);
        _pSoundObj->Play();
    }
    else
    {
        _pSoundObj->SetNotifyWindow(NULL, WM_ACTIVEMOVIE, (LONG_PTR)this);
        _pSoundObj->Stop();
    }
}

//+------------------------------------------------------------------------
//
//  Method:     CBGsound::OnDwnChan
//
//-------------------------------------------------------------------------

void CBGsound::OnDwnChan(CDwnChan * pDwnChan)
{
    ULONG ulState = _pBitsCtx->GetState();
    BOOL fDone = FALSE;
    TCHAR * pchFile = NULL;
   
    if (ulState & DWNLOAD_COMPLETE)
    {
        fDone = TRUE;

        BOOL fPendingRoot = FALSE;

        if (IsInMarkup())
            fPendingRoot = GetMarkup()->IsPendingRoot();

        // If security redirect occurred, we may need to blow away doc's lock icon
        Doc()->OnSubDownloadSecFlags(fPendingRoot, _pBitsCtx->GetUrl(), _pBitsCtx->GetSecFlags());

        // Ensure a sound object
        if(!_pSoundObj)
        {
            _pSoundObj = (CIEMediaPlayer *)new (CIEMediaPlayer);

            if(!_pSoundObj)
                goto Nosound;
        }

        _pSoundObj->AddRef();
        if((S_OK == _pBitsCtx->GetFile(&pchFile)) &&
           (S_OK == _pSoundObj->SetURL(pchFile)))       // Initialize & RenderFile
        {
            // Set the volume & balance values
            //

            // if the colume property is not initialized to something within range 
            // get the value from the soundobject and set it to that
            //
            if(GetAAvolume() > 0)   // range is -10000 to 0
            {
                VARIANT vtLong;

                vtLong.vt = VT_I4;
                vtLong.lVal = _pSoundObj->GetVolume();

                put_VariantHelper(vtLong, (PROPERTYDESC *)&s_propdescCBGsoundvolume);
            }
            else
                _pSoundObj->SetVolume(GetAAvolume());

            if(GetAAbalance() > 10000)   // range is -10000 to 10000
            {
                VARIANT vtLong;

                vtLong.vt = VT_I4;
                vtLong.lVal = _pSoundObj->GetBalance();

                put_VariantHelper(vtLong, (PROPERTYDESC *)&s_propdescCBGsoundbalance);
            }
            else
                _pSoundObj->SetBalance(GetAAbalance());

            _pSoundObj->SetLoopCount(GetAAloop());

            SetAudio();

        }
        _pSoundObj->Release();
    }
    else if (ulState & (DWNLOAD_STOPPED | DWNLOAD_ERROR))
    {
        fDone = TRUE;
    }

Nosound:
    if (fDone)
    {
        _pBitsCtx->SetProgSink(NULL); // detach download from document's load progress
    }

    MemFreeString(pchFile);
    
}

//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange
//
//  Note:       Called after a property has changed to notify derived classes
//              of the change.  All properties (except those managed by the
//              derived class) are consistent before this call.
//
//              Also, fires a property change notification to the site.
//
//-------------------------------------------------------------------------

HRESULT CBGsound::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr = S_OK;
    CDoc *pDoc = Doc();

    switch (dispid)
    {
        case DISPID_CBGsound_src:
        {
            // Should we even play the sound?
            if (pDoc->_dwLoadf & DLCTL_BGSOUNDS)
            {
                CBitsCtx *pBitsCtx = NULL;
                LPCTSTR szUrl = GetAAsrc();

                BOOL fPendingRoot = FALSE;

                if (IsInMarkup())
                    fPendingRoot = GetMarkup()->IsPendingRoot();

                if ( ! IsScriptUrl( szUrl ))
                {
                    hr = THR(pDoc->NewDwnCtx(DWNCTX_FILE, szUrl, this,
                                (CDwnCtx **)&pBitsCtx, fPendingRoot));

                    if (hr == S_OK)
                    {
                        SetBitsCtx(pBitsCtx);

                        if (pBitsCtx)
                            pBitsCtx->Release();
                    }
                }
            }
            break;
        }

        case DISPID_CBGsound_loop:
            if(_pSoundObj)
                _pSoundObj->SetLoopCount(GetAAloop());
            break;

        case DISPID_CBGsound_balance:
            if(_pSoundObj)
                _pSoundObj->SetBalance(GetAAbalance());
            break;
        
        case DISPID_CBGsound_volume:
            if(_pSoundObj)
                _pSoundObj->SetVolume(GetAAvolume());
            break;
    }

    if (OK(hr))
        hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));

    RRETURN(hr);
}

//--------------------------------------------------------------------------
//
//  Method:     CBGsound::Passivate
//
//  Synopsis:   Shutdown main object by releasing references to
//              other objects and generally cleaning up.  This
//              function is called when the main reference count
//              goes to zero.  The destructor is called when
//              the reference count for the main object and all
//              embedded sub-objects goes to zero.
//
//              Release any event connections held by the form.
//
//--------------------------------------------------------------------------

void CBGsound::Passivate(void)
{
    ClearInterface(&_pSoundObj);
    SetBitsCtx(NULL);
    super::Passivate();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\eblock.cxx ===
//+---------------------------------------------------------------------
//
//   File:      eblock.cxx
//
//  Contents:   Block element class
//
//  Classes:    CBlockElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X__DOC_H_
#define X__DOC_H_
#include "_doc.h"
#endif

#ifndef X_EBLOCK_HXX_
#define X_EBLOCK_HXX_
#include "eblock.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "block.hdl"

MtDefine(CBlockElement, Elements, "CBlockElement")

const CElement::CLASSDESC CBlockElement::s_classdesc =
{
    {
        &CLSID_HTMLBlockElement,            // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLBlockElement,             // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLBlockElement,      // _apfnTearOff
    NULL                                    // _pAccelsRun
};

HRESULT
CBlockElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert( pht->Is(ETAG_ADDRESS)  || pht->Is(ETAG_BLOCKQUOTE) ||
            pht->Is(ETAG_CENTER)   || pht->Is(ETAG_LISTING) ||
            pht->Is(ETAG_XMP)      || pht->Is(ETAG_PRE) ||
            pht->Is(ETAG_PLAINTEXT));

    Assert(ppElement);
    *ppElement = new CBlockElement(pht->GetTag(), pDoc);
    return *ppElement ? S_OK: E_OUTOFMEMORY;
}


//+------------------------------------------------------------------------
//
//  Member:     CBlockElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CBlockElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_HTML_TEAROFF(this, IHTMLBlockElement, NULL)
        QI_HTML_TEAROFF(this, IHTMLBlockElement2, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


HRESULT
CBlockElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT hr  = S_OK;
    CDoc *  pDoc = Doc();
    LONG lFontHeightTwips;

    if (pCFI->_ppf->_fTabStops)
    {
        pCFI->PrepareParaFormat();
        pCFI->_pf()._fTabStops = FALSE;
        pCFI->UnprepareForDebug();
    }

    //
    // Apply default indents and before/after space.
    // NOTE: Indents and before/after space are outside our box (== margins), 
    //       so they are relative to the parent's text flow.
    //
    BOOL fParentVertical = pCFI->_pNodeContext->IsParentVertical();

    switch(Tag())
    {
    case ETAG_ADDRESS:
        pCFI->PrepareCharFormat();
        pCFI->_cf()._fItalic = TRUE;
        pCFI->UnprepareForDebug();
        break;

    case ETAG_BLOCKQUOTE:
        {
            pCFI->PrepareParaFormat();
            pCFI->PrepareFancyFormat();

            pCFI->_pf()._cuvOffsetPoints.SetPoints( LIST_FIRST_REDUCTION_POINTS );
            pCFI->_pf()._cuvNonBulletIndentPoints.SetPoints(
                    pCFI->_pf()._cuvNonBulletIndentPoints.GetPoints() +
                    BLOCKQUOTE_INDENT_POINTS );

            ApplyDefaultVerticalSpace(fParentVertical, &pCFI->_ff());

            // Set the default indent values
            CUnitValue uv;
            uv.SetPoints(BLOCKQUOTE_INDENT_POINTS);
            if (fParentVertical)
            {
                if (pCFI->_ff().GetMargin(SIDE_TOP).IsNullOrEnum())
                    pCFI->_ff().SetMargin(SIDE_TOP, uv);
                if (pCFI->_ff().GetMargin(SIDE_BOTTOM).IsNullOrEnum())
                    pCFI->_ff().SetMargin(SIDE_BOTTOM, uv);
            }
            else
            {
                if (pCFI->_ff().GetMargin(SIDE_LEFT).IsNullOrEnum())
                    pCFI->_ff().SetMargin(SIDE_LEFT, uv);
                if (pCFI->_ff().GetMargin(SIDE_RIGHT).IsNullOrEnum())
                    pCFI->_ff().SetMargin(SIDE_RIGHT, uv);
            }
            pCFI->_ff()._fHasMargins = TRUE;

            pCFI->UnprepareForDebug();
        }
        break;

    case ETAG_CENTER:
        pCFI->_bBlockAlign     = (BYTE) htmlBlockAlignCenter;
        pCFI->_bCtrlBlockAlign = (BYTE) htmlBlockAlignCenter;
        break;

    case ETAG_LISTING:
        // NB (cthrash) Inside a listing, we drop the font size by 2.
        // We drop it by one here, and then set BUMPSIZEDOWN on
        // to drop another.
        pCFI->PrepareCharFormat();
        pCFI->_cf().ChangeHeightRelative( -1 );
        pCFI->UnprepareForDebug();
    case ETAG_XMP:
    case ETAG_PRE:
    case ETAG_PLAINTEXT:
        pCFI->PrepareParaFormat();
        pCFI->_pf()._fTabStops = TRUE;
        pCFI->_pf()._fHasPreLikeParent = TRUE;
        pCFI->UnprepareForDebug();

        pCFI->_fPre = TRUE;
        pCFI->_fInclEOLWhite = TRUE;
        pCFI->_fNoBreak = TRUE;

        pCFI->PrepareCharFormat();
        pCFI->_cf()._fBumpSizeDown = TRUE;
        pCFI->UnprepareForDebug();

        if (Tag() != ETAG_PLAINTEXT)
        {
            pCFI->PrepareFancyFormat();
            ApplyDefaultVerticalSpace(fParentVertical, &pCFI->_ff());
        }
        else
        {
            // Netscape puts a lot of space between PLAINTEXT and the preceeding lines.
            pCFI->PrepareFancyFormat();
            ApplyDefaultVerticalSpace(fParentVertical, &pCFI->_ff(), 26);
        }

        {
            pCFI->PrepareCharFormat();

            CMarkup * pMarkup = GetMarkup();
            CODEPAGESETTINGS * pCS = pMarkup->GetCodepageSettings();

            if (!pCS)
                pCS = pDoc->PrimaryMarkup()->GetCodepageSettings();

            // Thai does not have a fixed pitch font. Leave it as proportional
            if (pMarkup->GetCodePage() != CP_THAI)
            {
                pCFI->_cf()._bPitchAndFamily = FIXED_PITCH;
                pCFI->_cf().SetFaceNameAtom(pCS->latmFixedFontFace);
                if (pCFI->_cf().NeedAtFont())
                {
                    ApplyAtFontFace(&pCFI->_cf(), Doc(), GetMarkup());
                }
            }
            pCFI->_cf()._bCharSet = pCS->bCharSet;
            pCFI->_cf()._fNarrow = IsNarrowCharSet(pCFI->_cf()._bCharSet);

        }
        pCFI->UnprepareForDebug();
        break;

    case ETAG_P:
        pCFI->PrepareFancyFormat();
        ApplyDefaultBeforeSpace(fParentVertical, &pCFI->_ff());
        if (_fExplicitEndTag)
        {
            ApplyDefaultAfterSpace(fParentVertical, &pCFI->_ff());
        }
        pCFI->UnprepareForDebug();
        // Note that we inherit the after space from the parent.
        break;
    }

    // we need to call super AFTER the above code, because this is where in-linestyles get
    //  applied. by calling super first we overwrote explicitly set values (e.g. margin-top)
    hr = THR(super::ApplyDefaultFormat(pCFI));
    if(hr)
        goto Cleanup;

    // set up for potential EM, EN, ES converstions

    lFontHeightTwips = pCFI->_pcf->GetHeightInTwips(pDoc);
    if (lFontHeightTwips <= 0)
        lFontHeightTwips = 1;

    if (pCFI->_ppf->_lFontHeightTwips != lFontHeightTwips)
    {
        pCFI->PrepareParaFormat();
        pCFI->_pf()._lFontHeightTwips = lFontHeightTwips;
        pCFI->UnprepareForDebug();
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CBlockElement::Save
//
//  Synopsis:   Save the tag to the specified stream.
//
//-------------------------------------------------------------------------

HRESULT
CBlockElement::Save(CStreamWriteBuff * pStmWrBuff, BOOL fEnd)
{
    HRESULT hr;
    BOOL    fPreLikeElement = (   Tag() == ETAG_LISTING
                               || Tag() == ETAG_PLAINTEXT
                               || Tag() == ETAG_XMP
                               || Tag() == ETAG_PRE);

    if (!fEnd)
    {
        if (fPreLikeElement)
        {
            pStmWrBuff->BeginPre();

            if (Tag() != ETAG_PRE)
            {
                pStmWrBuff->ClearFlags(WBF_ENTITYREF);
            }
        }
    }

    hr = THR( super::Save(pStmWrBuff, fEnd) );
    if (hr)
        goto Cleanup;

    if (fPreLikeElement)
    {
        if (    fEnd 
            &&  (   !pStmWrBuff->GetElementContext() 
                 || GetFirstCp() >= pStmWrBuff->GetElementContext()->GetFirstCp() ) )
        {
            pStmWrBuff->EndPre();
            
            if (Tag() != ETAG_PRE)
            {
                pStmWrBuff->SetFlags(WBF_ENTITYREF);
            }

            if (pStmWrBuff->TestFlag(WBF_SAVE_PLAINTEXT) && !(pStmWrBuff->TestFlag(WBF_FORMATTED)))
            {
                pStmWrBuff->NewLine();
            }
        }
    }


Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\ebr.cxx ===
//+---------------------------------------------------------------------
//
//   File:      ebr.cxx
//
//  Contents:   BR element class
//
//  Classes:    CBRElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EBR_HXX_
#define X_EBR_HXX_
#include "ebr.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include <strbuf.hxx>
#endif

#define _cxx_
#include "br.hdl"

MtDefine(CBRElement, Elements, "CBRElement")

const CElement::CLASSDESC CBRElement::s_classdesc =
{
    {
        &CLSID_HTMLBRElement,               // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLBRElement,                // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLBRElement,         // _pfnTearOff
    NULL                                    // _pAccelsRun
};

HRESULT
CBRElement::CreateElement(
    CHtmTag *pht,
    CDoc *pDoc,
    CElement **ppElement)
{
    Assert(pht->Is(ETAG_BR));

    Assert(ppElement);
    *ppElement = new CBRElement(pDoc);
    return *ppElement ? S_OK: E_OUTOFMEMORY;
}


HRESULT
CBRElement::Save(
    CStreamWriteBuff * pStreamWrBuff,
    BOOL fEnd )
{
    HRESULT hr;

    hr = THR( super::Save(pStreamWrBuff, fEnd) );
    if (hr)
        goto Cleanup;

    if (fEnd && pStreamWrBuff->TestFlag(WBF_SAVE_PLAINTEXT))
    {
        hr = THR( pStreamWrBuff->NewLine() );
    }

Cleanup:

    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\edd.cxx ===
//+---------------------------------------------------------------------
//
//   File:      edd.cxx
//
//  Contents:   DD element class
//
//  Classes:    CDDElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EDD_HXX_
#define X_EDD_HXX_
#include "edd.hxx"
#endif

#ifndef X_ELIST_HXX_
#define X_ELIST_HXX_
#include "elist.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#define _cxx_
#include "dd.hdl"

MtDefine(CDDElement, Elements, "CDDElement")

const CElement::CLASSDESC CDDElement::s_classdesc =
{
    {
        &CLSID_HTMLDDElement,               // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLDDElement,                // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLDDElement,         // apfnTearOff
    NULL                                    // _pAccelsRun
};

HRESULT
CDDElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_DD));
    Assert(ppElement);
    *ppElement = new CDDElement(pDoc);
    return *ppElement ? S_OK: E_OUTOFMEMORY;
}

HRESULT
CDDElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT hr = S_OK;

    // Restart leveling. This means that nested DLs under this DD will
    // not indent anymore. This is all for Netscape compatibility.
    pCFI->PrepareParaFormat();
    pCFI->_pf()._cListing.SetLevel(0);
    pCFI->_pf()._cListing.SetType(CListing::DEFINITION);
    pCFI->UnprepareForDebug();

    pCFI->PrepareFancyFormat();
    pCFI->_ff()._cuvSpaceBefore.SetPoints(0);
    pCFI->_ff()._cuvSpaceAfter.SetPoints(0);
        pCFI->UnprepareForDebug();

    hr = THR(super::ApplyDefaultFormat(pCFI));
    if(hr)
        goto Cleanup;

    // If we're under a DL, we indent the whole paragraph, otherwise,
    // just the first line.
    if (pCFI->_pNodeContext->Ancestor(ETAG_DL))
    {
        pCFI->PrepareFancyFormat();

        BYTE    side;
        side = !pCFI->_ppf->HasRTL(TRUE) ? SIDE_LEFT : SIDE_RIGHT;
        side = !pCFI->_pff->FlipSides(pCFI->_pNodeContext->IsParentVertical(), pCFI->_pcf->_fWritingModeUsed) 
                ? side : (++side % SIDE_MAX);

        const CUnitValue &uvSideMargin = pCFI->_ff().GetMargin(side);

        if (    uvSideMargin.IsNullOrEnum()
            &&  (   !HasMarkupPtr() 
                ||  !GetMarkupPtr()->IsStrictCSS1Document() 
                ||  !pCFI->_ff().HasExplicitMargin(side) 
                ||  uvSideMargin.GetUnitType() != CUnitValue::UNIT_ENUM 
                ||  uvSideMargin.GetUnitValue() != styleAutoAuto    ) 
            )
        {
            CUnitValue uv;
            uv.SetPoints(LIST_INDENT_POINTS);
            pCFI->_ff().SetMargin(side, uv);
        }

        pCFI->_ff()._fHasMargins = TRUE;

        pCFI->UnprepareForDebug();
    }
    else
    {
        pCFI->PrepareParaFormat();
        pCFI->_pf()._fFirstLineIndentForDD = TRUE;
        pCFI->UnprepareForDebug();
    }

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\edt.cxx ===
//+---------------------------------------------------------------------
//
//   File:      edd.cxx
//
//  Contents:   DT element class
//
//  Classes:    CDTElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EDT_HXX_
#define X_EDT_HXX_
#include "edt.hxx"
#endif

#ifndef X_ELIST_HXX_
#define X_ELIST_HXX_
#include "elist.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#define _cxx_
#include "dt.hdl"

MtDefine(CDTElement, Elements, "CDTElement")

const CElement::CLASSDESC CDTElement::s_classdesc =
{
    {
        &CLSID_HTMLDTElement,               // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLDTElement,                // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLDTElement,         // _apfnTearOff
    NULL                                    // _pAccelsRun
};

HRESULT
CDTElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_DT));

    Assert(ppElement);
    *ppElement = new CDTElement(pDoc);
    return *ppElement ? S_OK: E_OUTOFMEMORY;
}

HRESULT 
CDTElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT hr = S_OK;

    pCFI->PrepareParaFormat();
    pCFI->_pf()._cListing.SetType( CListing::DEFINITION );
    pCFI->UnprepareForDebug();

    pCFI->PrepareFancyFormat();
    pCFI->_ff()._cuvSpaceBefore.SetValue(0, CUnitValue::UNIT_POINT);
    pCFI->UnprepareForDebug();

    pCFI->PrepareFancyFormat();
    pCFI->_ff()._cuvSpaceAfter.SetValue(0, CUnitValue::UNIT_POINT);
    pCFI->UnprepareForDebug();

    hr = THR(super::ApplyDefaultFormat(pCFI));
    if(hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\edlist.cxx ===
//+---------------------------------------------------------------------
//
//   File:      edlist.cxx
//
//  Contents:   Ordered List Element class
//
//  Classes:    CDListElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EDLIST_HXX_
#define X_EDLIST_HXX_
#include "edlist.hxx"
#endif

#define _cxx_
#include "dlist.hdl"

const CElement::CLASSDESC CDListElement::s_classdesc =
{
    {
        &CLSID_HTMLDListElement,            // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLDListElement,             // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLDListElement,      // _pfnTearOff
    NULL                                    // _pAccelsRun
};


//+------------------------------------------------------------------------
//
//  Member:     CDListElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CDListElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr;

    *ppv = NULL;

    if IID_HTML_TEAROFF(this, IHTMLDListElement, NULL)
    else
    {
        RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    (*(IUnknown **)ppv)->AddRef();
    return S_OK;
}


HRESULT CDListElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(pht->Is(ETAG_DL));
    Assert(ppElementResult);
    *ppElementResult = new CDListElement(pDoc);
    return *ppElementResult ? S_OK : E_OUTOFMEMORY;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\efont.cxx ===
//+---------------------------------------------------------------------
//
//   File:      efont.cxx
//
//  Contents:   Font element class
//
//  Classes:    CFontElement, CBaseFontElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EFONT_HXX_
#define X_EFONT_HXX_
#include "efont.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"
#endif

#define _cxx_
#include "font.hdl"

#define _cxx_
#include "basefont.hdl"

MtDefine(CFontElement, Elements, "CFontElement")
MtDefine(CBaseFontElement, Elements, "CBaseFontElement")

const CElement::CLASSDESC CFontElement::s_classdesc =
{
    {
        &CLSID_HTMLFontElement,             // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLFontElement,              // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLFontElement,       //_apfnTearOff
    NULL                                    // _pAccelsRun
};

HRESULT
CFontElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_FONT));
    Assert(ppElement);
    *ppElement = new CFontElement(pDoc);
    return *ppElement ? S_OK: E_OUTOFMEMORY;
}



//+-------------------------------------------------------------------
//
//  Member:     Add Attributes
//
//  Synopsis:   For all unspecified attributes in 'this', the attributes
//              of pElement are merged in.  The caller is expected to
//              to delete the pElement after this operation.
//
//--------------------------------------------------------------------

HRESULT
CFontElement::CombineAttributes( CFontElement * pFont )
{
    HRESULT hr = S_OK;
    LPCTSTR pchFace;

    Assert( ETAG_FONT == pFont->Tag() );

    if (GetFontSize().IsNull())
    {
        hr = THR( SetAAsize(pFont->GetFontSize()) );
        if (hr)
            goto Cleanup;
    }

    if (!GetAAcolor().IsDefined())
    {
        hr = THR( SetAAcolor(pFont->GetAAcolor()) );
        if (hr)
            goto Cleanup;
    }

    pchFace = GetAAface();
    if ( !(pchFace && pchFace[0]) )
    {
        hr = THR( SetAAface(pFont->GetAAface()) );
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}

//+-------------------------------------------------------------------
//
//  Member:     RemoveAttributes
//
//  Synopsis:   Remove attributes specified in pFont for 'this.'
//              If all attributes were stripped, pfAttrBagEmpty
//              return true and the caller should free this object.
//
//--------------------------------------------------------------------

HRESULT
CFontElement::RemoveAttributes(
    CFontElement *pFont,
    BOOL * pfAttrBagEmpty )
{
    HRESULT hr=S_OK;
    BOOL fKeepThis = FALSE;
    
    Assert( ETAG_FONT == pFont->Tag() );

    if (!GetFontSize().IsNull())
    {
        if (!pFont->GetFontSize().IsNull())
        {
            CUnitValue cuv;
            cuv.SetNull();
            IGNORE_HR( SetAAsize(cuv) );
        }
        else
        {
            fKeepThis = TRUE;
        }
    }        

    if (GetAAcolor().IsDefined())
    {
        if (pFont->GetAAcolor().IsDefined())
        {
            IGNORE_HR( SetAAcolor(VALUE_UNDEF) );
        }
        else
        {
            fKeepThis = TRUE;
        }
    }

    LPCTSTR pchFace = GetAAface();
    if ( pchFace && pchFace[0] )
    {
        pchFace = pFont->GetAAface();
        if (pchFace && pchFace[0])
        {
            hr = THR( SetAAface(NULL) );
            if (hr)
                goto Cleanup;
        }
        else
        {
            fKeepThis = TRUE;
        }
    }

Cleanup:
    *pfAttrBagEmpty = !fKeepThis;

    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//  Member:     CFontElement::ApplyDefaultFormat()
//
//  Synopsis:   Apply the default formats of the font element.
//-----------------------------------------------------------------------------
HRESULT
CFontElement::ApplyDefaultFormat(CFormatInfo * pCFI)
{
    HRESULT hr;

    // If this is an empty font tag, it should reset the font size
    if(!_pAA)
    {
        CUnitValue cuv;

        cuv.SetValue(0, CUnitValue::UNIT_RELATIVE);

        hr = THR(SetAAsize(cuv));
        if (hr)
            goto Cleanup;
    }

    hr = THR(super::ApplyDefaultFormat(pCFI));
Cleanup:
    RRETURN(hr);
}


//+-----------------------------------------------------
//
//  Member : CBaseFontElement::GetFontSize()
//
//  Synopsis : a wrapper function for the AttrArray access
//      method.
//
//+------------------------------------------------------
CUnitValue
CFontElement::GetFontSize( void )
{
    CUnitValue uvSize= GetAAsize();
    long lAASize = uvSize.GetUnitValue(); 

    //if it is valid
    lAASize = (lAASize<MIN_FONT_SIZE) ? MIN_FONT_SIZE : lAASize;
    lAASize = (lAASize>MAX_FONT_SIZE) ? MAX_FONT_SIZE : lAASize;

    uvSize.SetValue(lAASize, uvSize.GetUnitType());

    return uvSize;
}
//============================================================
//
//  CBaseFontElement Methods
//
//============================================================

const CElement::CLASSDESC CBaseFontElement::s_classdesc =
{
    {
        &CLSID_HTMLBaseFontElement,         // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLBaseFontElement,          // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLBaseFontElement,   // _ApfnTearOff
    NULL                                    // _pAccelsRun
};

HRESULT
CBaseFontElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_BASEFONT));
    Assert(ppElement);
    *ppElement = new CBaseFontElement(pDoc);
    return *ppElement ? S_OK: E_OUTOFMEMORY;
}

//+-----------------------------------------------------
//
//  Member : CBaseFontElement::GetFontSize()
//
//  Synopsis : a wrapper function for the AttrArray access
//      method.
//
//+------------------------------------------------------
long
CBaseFontElement::GetFontSize( void )
{
    long lAASize = GetAAsize(); 

    //if it is valid
    lAASize = (lAASize<MIN_BASEFONT) ? MIN_BASEFONT : lAASize;
    lAASize = (lAASize>MAX_BASEFONT) ? MAX_BASEFONT : lAASize;


    return lAASize;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\elabel.cxx ===
//+---------------------------------------------------------------------
//
//   File:      elabel.cxx
//
//  Contents:   Label element class
//
//  Classes:    CLabelElement
//
//------------------------------------------------------------------------


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CGUID_H_
#define X_CGUID_H_
#include <cguid.h>
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_INPUTTXT_H_
#define X_INPUTTXT_H_
#include "inputtxt.h"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_INPUTBTN_H_
#define X_INPUTBTN_H_
#include "inputbtn.h"
#endif

#ifndef X_INPUTBTN_HXX_
#define X_INPUTBTN_HXX_
#include "inputbtn.hxx"
#endif

#ifndef X_ELABEL_HXX_
#define X_ELABEL_HXX_
#include "elabel.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include <treepos.hxx>
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_BTNHLPER_H_
#define X_BTNHLPER_H_
#include "btnhlper.hxx"
#endif

#define _cxx_
#include "label.hdl"

MtDefine(CLabelElement, Elements, "CLabelElement")

#ifndef NO_PROPERTY_PAGE
const CLSID * const CLabelElement::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
    // &CLSID_CCDLabelPropertyPage,
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,
#endif // DBG==1    
    NULL
};
#endif // NO_PROPERTY_PAGE


const CElement::CLASSDESC CLabelElement::s_classdesc =
{
    {
        &CLSID_HTMLLabelElement,            // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLLabelElement,             // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLLabelElement,      // _pfnTearOff
    NULL                                    // _pAccelsRun
};


HRESULT
CLabelElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_LABEL));
    Assert(ppElement);
    *ppElement = new CLabelElement(pDoc);
    return *ppElement ? S_OK : E_OUTOFMEMORY;
}

//+------------------------------------------------------------------------
//
//  Member:     CLabelElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CLabelElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_TEAROFF(this, IHTMLLabelElement2, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

#ifndef NO_DATABINDING
const CDBindMethods *
CLabelElement::GetDBindMethods()
{
    return &DBindMethodsTextRichRO;
}
#endif

HRESULT
CLabelElement::ClickAction(CMessage *pMessage)
{
    HRESULT     hr      = S_OK;
    FOCUS_ITEM  fi;
    
    fi = GetMnemonicTarget(pMessage ? pMessage->lSubDivision : 0);

    if (fi.pElement)
    {

        // Activate and click pElem. Use NULL instead of
        // pMessage, because the original message was intended for
        // the label and would not be appropriate for pElem.

        hr = THR(fi.pElement->BecomeCurrentAndActive(fi.lSubDivision, NULL, NULL, TRUE));
        if (hr)
            goto Cleanup;

        hr = THR(fi.pElement->ScrollIntoView());
        if (FAILED(hr))
            goto Cleanup;

        // TODO (MohanB) Click would not fire on the subdivision!
        hr = THR(fi.pElement->DoClick(NULL, fi.pElement->GetFirstBranch(), TRUE));
    }
Cleanup:
    // Do not want this to bubble, so..
    if (S_FALSE == hr)
        hr = S_OK;

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CLabelElement::HandleMessage
//
//  Synopsis:   Perform any element specific mesage handling
//
//  Arguments:  pmsg    Ptr to incoming message
//
//-------------------------------------------------------------------------

HRESULT
CLabelElement::HandleMessage(CMessage *pMessage)
{
    HRESULT     hr = S_FALSE;
    FOCUS_ITEM  fi;
    CInput     *pInput;
    CButton    *pButton;
    
    // If not in browse mode, then ignore message.
    if (IsEditable(TRUE))
        goto Ignored;

    switch (pMessage->message)
    {
    case WM_SETCURSOR:
#ifdef WIN16
        ::SetCursor(LoadCursor(NULL, IDC_ARROW));
#else
        SetCursorStyle(IDC_ARROW);
#endif
        hr = S_OK;
        break;
    case WM_MOUSEOVER:
    case WM_MOUSELEAVE:
        fi = GetMnemonicTarget(pMessage ? pMessage->lSubDivision : 0);
        if (fi.pElement && fi.pElement->Tag() == ETAG_INPUT)
        {
            pInput = DYNCAST(CInput, fi.pElement);
            if (pInput->IsOptionButton())
            {
                if (pMessage->message == WM_MOUSEOVER)
                {
                    pInput->_wBtnStatus = BTN_SETSTATUS(pInput->_wBtnStatus, FLAG_MOUSEOVER);
                }
                else // pMessage->message == WM_MOUSELEAVE
                {                 
                    pInput->_wBtnStatus = BTN_RESSTATUS(pInput->_wBtnStatus, FLAG_MOUSEOVER);                
                }
                
                pInput->CBtnHelper::Invalidate();
            }
        }
        else if (fi.pElement && fi.pElement->Tag() == ETAG_BUTTON)
        {
            pButton = DYNCAST(CButton, fi.pElement);
            if (pMessage->message == WM_MOUSEOVER)
            {
                pButton->_wBtnStatus = BTN_SETSTATUS(pButton->_wBtnStatus, FLAG_MOUSEOVER);
            }
            else // pMessage->message == WM_MOUSELEAVE
            {                 
                pButton->_wBtnStatus = BTN_RESSTATUS(pButton->_wBtnStatus, FLAG_MOUSEOVER);                
            }
            
            pButton->CBtnHelper::Invalidate();
            
        }
        hr = S_OK;
        break;
    }

Ignored:
    if (S_FALSE == hr)
    {
        hr = THR(super::HandleMessage(pMessage));
    }
    RRETURN1(hr, S_FALSE);
}

void
CLabelElement::Notify(CNotification *pNF)
{
    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_QUERYMNEMONICTARGET:
        {
            FOCUS_ITEM          fi;
            CElement *          pElem       = NULL;
            LPCTSTR             pszIdFor,
                                pszId;
            int                 c;
            CCollectionCache*   pCollectionCache;

            fi.pElement = NULL;
            fi.lSubDivision = 0;

            pszIdFor = GetAAhtmlFor();
            if (!pszIdFor || !pszIdFor[0])
                goto CleanupGetTarget;

            if (!IsInMarkup())
                goto CleanupGetTarget;

            // Search the document's collection for a site which has the same id
            // that is associated with this label.
            if (S_OK != THR(GetMarkup()->EnsureCollectionCache(CMarkup::ELEMENT_COLLECTION)))
                goto CleanupGetTarget;

            pCollectionCache = GetMarkup()->CollectionCache();

            // get size of collection
            c = pCollectionCache->SizeAry(CMarkup::ELEMENT_COLLECTION);

            while (c--)
            {
                if (S_OK != THR(pCollectionCache->GetIntoAry(CMarkup::ELEMENT_COLLECTION, c, &pElem)))
                    goto CleanupGetTarget;

                pszId = pElem->GetAAid();

                // is this item in the target group?
                if (pszId && !FormsStringICmp(pszIdFor, pszId))
                {
                    break;
                }
            }
        CleanupGetTarget:
            if (pElem)
            {
                if (pElem->Tag() == ETAG_AREA)
                {
                    // Get the <IMG, lSubDivision> pair
                    fi = pElem->GetMnemonicTarget(0);
                }
                else
                {
                    fi.pElement = pElem;
                }
            }
            *(FOCUS_ITEM *)pNF->DataAsPtr() = fi;
        }
        break;
    default:
        super::Notify(pNF);
        break;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\eheader.cxx ===
//+---------------------------------------------------------------------
//
//   File:      eheader.cxx
//
//  Contents:   Header Element class
//
//  Classes:    CHeaderElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EHEADER_HXX_
#define X_EHEADER_HXX_
#include "eheader.hxx"
#endif

#ifndef X_EFONT_HXX_
#define X_EFONT_HXX_
#include "efont.hxx"
#endif

#ifndef X__DOC_H_
#define X__DOC_H_
#include "_doc.h"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#define _cxx_
#include "header.hdl"


const CElement::CLASSDESC CHeaderElement::s_classdesc =
{
    {
        &CLSID_HTMLHeaderElement,           // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLHeaderElement,            // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLHeaderElement,     // _apfnTearOff
    NULL                                    // _pAccelsRun
};


HRESULT CHeaderElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert( pht->Is(ETAG_H1) || pht->Is(ETAG_H2) ||
            pht->Is(ETAG_H3) || pht->Is(ETAG_H4) ||
            pht->Is(ETAG_H5) || pht->Is(ETAG_H6));

    Assert(ppElementResult);
    *ppElementResult = new CHeaderElement(pht->GetTag(), pDoc);
    return *ppElementResult ? S_OK : E_OUTOFMEMORY;
}

//+------------------------------------------------------------------------
//
//  Member:     CHeaderElement::ApplyDefaultFormat
//
//  Synopsis:   Applies default formatting properties for that element to 
//              the char and para formats passed in
//
//  Arguments:  pCFI - Format Info needed for cascading
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
                                 
HRESULT                           
CHeaderElement::ApplyDefaultFormat (CFormatInfo *pCFI)
{
    if ( _nLevel >= 1 && _nLevel <= 6 )
    {
        //
        // Apply default before/after space.
        // NOTE: Before/after space are outside our box (== margins), 
        //       so they are relative to the parent's text flow.
        //
        BOOL fParentVertical = pCFI->_pNodeContext->IsParentVertical();

        pCFI->PrepareFancyFormat();
        ApplyDefaultVerticalSpace(fParentVertical, &pCFI->_ff());
        pCFI->UnprepareForDebug();

        pCFI->PrepareCharFormat();
        pCFI->_cf().SetHeightInTwips( ConvertHtmlSizeToTwips( 7-_nLevel ) );
        pCFI->_cf()._fBold = TRUE;
        pCFI->_cf()._wWeight = 700;
        pCFI->_cf()._fBumpSizeDown = FALSE; // Nav compat
        pCFI->UnprepareForDebug();
    }

    RRETURN(super::ApplyDefaultFormat(pCFI));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\eform.cxx ===
//+---------------------------------------------------------------------
//
//   File:      eform.cxx
//
//  Contents:   Form element class, etc..
//
//  Classes:    CFormElement, etc..
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CGUID_H_
#define X_CGUID_H_
#include <cguid.h>
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_EFORM_HXX_
#define X_EFORM_HXX_
#include "eform.hxx"
#endif

#ifndef X_BTNHLPER_HXX_
#define X_BTNHLPER_HXX_
#include "btnhlper.hxx"
#endif

#ifndef X_INPUTTXT_HXX_
#define X_INPUTTXT_HXX_
#include "inputtxt.hxx"
#endif

#ifndef X_TEXTAREA_HXX_
#define X_TEXTAREA_HXX_
#include "textarea.hxx"
#endif

#ifndef X_INPUTBTN_HXX_
#define X_INPUTBTN_HXX_
#include "inputbtn.hxx"
#endif

#ifndef X_IMGELEM_HXX_
#define X_IMGELEM_HXX_
#include "imgelem.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_POSTDATA_HXX_
#define X_POSTDATA_HXX_
#include "postdata.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_INPUTLYT_HXX_
#define X_INPUTLYT_HXX_
#include "inputlyt.hxx"
#endif

#ifndef X_TAREALYT_HXX_
#define X_TAREALYT_HXX_
#include "tarealyt.hxx"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include "intl.hxx"
#endif


#if defined(_M_ALPHA)
#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif
#endif

#define _cxx_
#include "eform.hdl"

// Needs this for the IHTMLElementCollection interface
#define _hxx_
#include "collect.hdl"

DeclareTag(tagFormElement, "Form Element", "Form Element methods")
ExternTag(tagFormEncoding);

MtDefine(CFormElement, Elements, "CFormElement")
MtDefine(BldFormElementCol, PerfPigs, "Build CFormElement::FORM_ELEMENT_COLLECTION")
MtDefine(BldFormNamedImgCol, PerfPigs, "Build CFormElement::FORM_NAMED_IMG_COLLECTION")
MtDefine(BldFormSubmitCol, PerfPigs, "Build CFormElement::FORM_SUBMIT_COLLECTION")

#ifndef NO_PROPERTY_PAGE
const CLSID * const CFormElement::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,
#endif // DBG==1    
    NULL
};
#endif // NO_PROPERTY_PAGE


BEGIN_TEAROFF_TABLE(CFormElement, IProvideMultipleClassInfo)
    TEAROFF_METHOD(CFormElement, GetClassInfo, getclassinfo, (ITypeInfo ** ppTI))
    TEAROFF_METHOD(CFormElement, GetGUID, getguid, (DWORD dwGuidKind, GUID * pGUID))
    TEAROFF_METHOD(CFormElement, GetMultiTypeInfoCount, getmultitypeinfocount, (ULONG *pcti))
    TEAROFF_METHOD(CFormElement, GetInfoOfIndex, getinfoofindex, (
            ULONG iti,
            DWORD dwFlags,
            ITypeInfo** pptiCoClass,
            DWORD* pdwTIFlags,
            ULONG* pcdispidReserved,
            IID* piidPrimary,
            IID* piidSource))
END_TEAROFF_TABLE()


const CElement::CLASSDESC CFormElement::s_classdesc =
{
    {
        &CLSID_HTMLFormElement,             // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLFormElement,              // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLFormElement,       // _pfnTearOff
    NULL                                    // _pAccelsRun
};

HRESULT
CFormElement::CreateElement(CHtmTag *pht, CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_FORM));
    Assert(ppElement);
    *ppElement = new CFormElement(pDoc);
    return *ppElement ? S_OK: E_OUTOFMEMORY;
}


#if 0 // (JHarding): We need to be in a tree before adding ourselves to the
      // script collection, so this logic has moved to after we get our
      // enter tree notification
//+---------------------------------------------------------------------------
//
//  Member :    CFormElement::Init2
//
//  Synopsis:   Last chance to init.
//
//+---------------------------------------------------------------------------

HRESULT
CFormElement::Init2(CInit2Context * pContext)
{
    HRESULT hr = S_OK;
    CDoc *  pDoc = Doc();
    CScriptCollection * pScriptCollection;

    Assert (!_pTypeInfoElements);
    Assert (!_pTypeInfoCoClassElements);
    Assert (!_pTypeInfoImgs);
    Assert (!_pTypeInfoCoClassImgs);

    if (!pDoc || pContext->_pTargetMarkup->_fDesignMode)
        goto Cleanup;

    //
    // Add this form as a named item to the script engine.
    // This is to enable scriptlets for children of the form.  Also
    // to keep compatibility with IE.
    //
    pScriptCollection = pContext->_pTargetMarkup->GetScriptCollection();

    if (pScriptCollection)
    {
        hr = THR(pScriptCollection->AddNamedItem(this));
        if (hr)
            goto Cleanup;
    }

    hr = THR(super::Init2(pContext));

Cleanup:
    RRETURN(hr);
}
#endif // 0

//+---------------------------------------------------------------------------
//
//  Member :    CFormElement::Passivate
//
//  Synopsis:   1st stage destructor.
//
//+---------------------------------------------------------------------------

void
CFormElement::Passivate()
{
    ClearInterface(&_pTypeInfoElements);
    ClearInterface(&_pTypeInfoCoClassElements);
    ClearInterface(&_pTypeInfoImgs);
    ClearInterface(&_pTypeInfoCoClassImgs);

    // Free Radio groups
    while (_pRadioGrpName)
    {
        RADIOGRPNAME  *pRadioGroup = _pRadioGrpName->_pNext;

        SysFreeString((BSTR)_pRadioGrpName->lpstrName);
        delete _pRadioGrpName;
        _pRadioGrpName = pRadioGroup;
    }

    super::Passivate();
}


//+---------------------------------------------------------------------------
//
//  Member :    CFormElement::PrivateQueryInterface
//
//  Synopsis:   per IPrivateUnknown.
//
//+---------------------------------------------------------------------------

HRESULT
CFormElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_TEAROFF_DISPEX(this, NULL)
        QI_TEAROFF(this, IProvideMultipleClassInfo, NULL)
        QI_TEAROFF2(this, IProvideClassInfo, IProvideMultipleClassInfo, NULL)
        QI_TEAROFF2(this, IProvideClassInfo2, IProvideMultipleClassInfo, NULL)
        QI_TEAROFF(this, IHTMLSubmitData, NULL);
        QI_HTML_TEAROFF(this, IHTMLFormElement2, NULL);
        QI_TEAROFF(this, IHTMLFormElement3, NULL)

        default:
            RRETURN(super::PrivateQueryInterface(iid, ppv));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    (*(IUnknown **)ppv)->AddRef();

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     Getelements
//
//  Synopsis:   Return the form elements collection dispatch.  This is just
//              the "controls" in the form, not all elements.
//
//-------------------------------------------------------------------------

HRESULT
CFormElement::get_elements(IDispatch ** ppElemCol)
{
    TraceTag((tagFormElement, "Getelements"));

    HRESULT hr;

    if (!ppElemCol)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppElemCol = NULL;

    hr = THR_NOTRACE(QueryInterface(IID_IDispatch, (void**)
                ppElemCol));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+------------------------------------------------------------------------
//
//  Member:     EnsureCollectionCache
//
//  Synopsis:   Create the form's collection cache if needed.
//
//-------------------------------------------------------------------------

HRESULT
CFormElement::EnsureCollectionCache()
{
    TraceTag((tagFormElement, "EnsureCollectionCache"));

    HRESULT         hr = S_OK;

    if (!_pCollectionCache)
    {
        _pCollectionCache = new CCollectionCache(
                this,
                GetWindowedMarkupContext(),
                ENSURE_METHOD(CFormElement, EnsureCollections, ensurecollections));
        if (!_pCollectionCache)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        hr = THR(_pCollectionCache->InitReservedCacheItems(FORM_NUM_COLLECTIONS,
            FORM_ELEMENT_COLLECTION /* Identitiy Collection Form == Form.elements */ ));
        if (hr)
            goto Error;

        //
        // To incorporate the VBScript engine dynamic type library, the form calls
        // BuildObjectTypeInfo to create a dynamic type info based on the FORM_ELEMENT_COLLECTION
        // starting at DISPID_COLLECTION_MIN
        //
        // We create two collections on the FORM element:-
        //
        // FORM_ELEMENT_COLLECTION is the "elements" collection used to resolve most names,
        // and serves as the identity collection
        //
        // FORM_NAMED_IMG_COLLECTION contains named IMGs scoped to the FORM. This mimics a Nav feature where named IMG's
        // appear in the name space of the FORM, but not as ordinals in the collection.
        //

        _pCollectionCache->SetDISPIDRange (
            FORM_ELEMENT_COLLECTION,
            DISPID_FORM_ELEMENT_GN_MIN,
            DISPID_FORM_ELEMENT_GN_MAX );

        // Turn off ordinal promotion on the named IMG collection, this stops us
        // resolving ordinals when we call GetIDsOfNamesEx in it.
        _pCollectionCache->DontPromoteOrdinals ( FORM_NAMED_IMG_COLLECTION );

        // Set the DISPID range for the second collection, so we can distinguish between the two
        // in Invoke

        _pCollectionCache->SetDISPIDRange (
            FORM_NAMED_IMG_COLLECTION,
            DISPID_FORM_NAMED_IMG_GN_MIN,
            DISPID_FORM_NAMED_IMG_GN_MAX );
    }

Cleanup:
    RRETURN(hr);

Error:
    delete _pCollectionCache;
    _pCollectionCache = NULL;
    goto Cleanup;
}


void
CFormElement::Notify(CNotification * pnf)
{
    // Do this before super::Notify
    switch( pnf->Type() )
    {
    case NTYPE_ELEMENT_ENTERTREE:
        FormEnterTree();
        break;
    }

    super::Notify(pnf);

    // Do these after super::Notify
    switch (pnf->Type())
    {
    case NTYPE_ELEMENT_EXITTREE_1:
        if (_pSubmitData)
            pnf->SetSecondChanceRequested();
        break;

    case NTYPE_ELEMENT_EXITTREE_2:
        delete _pSubmitData;
        _pSubmitData = NULL;
        break;
    }
}

//+------------------------------------------------------------------------
//
//  Member:     EnsureCollections
//
//  Synopsis:   Refresh the form elements collection, if needed.
//
//-------------------------------------------------------------------------

HRESULT
CFormElement::EnsureCollections(long lIndex, long * plCollectionVersion)
{
    TraceTag((tagFormElement, "EnsureCollections Version:%d", *plCollectionVersion));

    CMarkup *   pMarkupPtr;
    long        lSize;
    long        l;
    HRESULT     hr;
    LPCTSTR     szFormName;
    BOOL fAddToNamedImages = FALSE, fAddToSubmit = FALSE,fAddToElements = FALSE ;
    CCollectionCache *pCollectionCache;

#ifdef PERFMETER
    static PERFMETERTAG s_mpColMtr[] = { Mt(BldFormElementCol), Mt(BldFormNamedImgCol), Mt(BldFormSubmitCol) };
#endif

    hr = THR(EnsureInMarkup());
    if (hr)
        goto Cleanup;

    pMarkupPtr = GetMarkupPtr();
    Assert(pMarkupPtr);

    // For
    // Makes sure the doc's collections are up-to-date.
    l = *plCollectionVersion;
    hr = THR(pMarkupPtr->EnsureCollectionCache(CMarkup::ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    // Nothing to do so get out.
    if (*plCollectionVersion == pMarkupPtr->GetMarkupTreeVersion())
        return S_OK;

    MtAdd(s_mpColMtr[lIndex], +1, 0);

    if ( lIndex == FORM_NAMED_IMG_COLLECTION )
        fAddToNamedImages = TRUE;
    else if ( lIndex == FORM_SUBMIT_COLLECTION )
        fAddToSubmit = TRUE;
    else if ( lIndex == FORM_ELEMENT_COLLECTION )
        fAddToElements = TRUE;

    pCollectionCache = pMarkupPtr->CollectionCache();

    hr = THR(pCollectionCache->GetIntoAry(CMarkup::ELEMENT_COLLECTION, this, &l));
    if (hr)
        goto Cleanup;

    // Get the size of the doc's elements collection (0).
    lSize = pCollectionCache->SizeAry(CMarkup::ELEMENT_COLLECTION);

    // Reset the arrays before loading them.  This is the Member cache, not the Markup cache!
    _pCollectionCache->ResetAry(lIndex);

    szFormName = GetAAname();

    // Reload this collection.
    for (++l; l < lSize; ++l)
    {
        CElement * pElemCandidate;
        CTreeNode * pNodeCandidate;

        WHEN_DBG( pElemCandidate = NULL; )

        hr = THR(
            pCollectionCache->GetIntoAry( CMarkup::ELEMENT_COLLECTION, l, & pElemCandidate ) );

        if (hr)
            goto Error;

        Assert( pElemCandidate );
        pNodeCandidate = pElemCandidate->GetFirstBranch();
        Assert ( pNodeCandidate );

        //
        // Search for the element to ensure that it is within the form.  If not
        // then break out.
        //

        if (!pNodeCandidate->SearchBranchToRootForScope(this))
            break;              // Yes, so we're done.

        switch (pNodeCandidate->TagType())
        {
            //
            // If this ever changes, please change the
            // CDoc::AddToCollections list also
            //
        case ETAG_IMG:
            // Add named IMGs scoped by this
            if ( fAddToNamedImages )
            {
                hr = THR(_pCollectionCache->SetIntoAry( FORM_NAMED_IMG_COLLECTION,
                            pElemCandidate ));
                if (hr)
                    goto Error;
            }
            break;

        case ETAG_INPUT:
            // Ignore INPUT TYPE=IMAGE
            if (DYNCAST(CInput, pNodeCandidate->Element())->GetAAtype() == htmlInputImage)
            {
                if ( fAddToSubmit )
                {
                    hr = THR(_pCollectionCache->SetIntoAry( FORM_SUBMIT_COLLECTION,
                                pElemCandidate ));
                }
                break;
            }
            hr = S_OK;
            // otherwise intentional fall through

        case ETAG_FIELDSET :
        case ETAG_BUTTON:
        case ETAG_SELECT:
        case ETAG_TEXTAREA:
#ifdef  NEVER
        case ETAG_HTMLAREA:
#endif
        case ETAG_OBJECT:
        case ETAG_EMBED:
            if ( fAddToElements )
            {
                hr = THR(_pCollectionCache->SetIntoAry( FORM_ELEMENT_COLLECTION,
                            pElemCandidate ));
                if (hr)
                    goto Error;
            }
            if ( fAddToSubmit )
            {
                hr = THR(_pCollectionCache->SetIntoAry( FORM_SUBMIT_COLLECTION,
                            pElemCandidate ));
                if (hr)
                    goto Error;
            }
            break;
        default:
            if ( fAddToSubmit && pElemCandidate->HasPeerHolder())
            {
                HRESULT hrSubmit = S_OK;
                IElementBehaviorSubmit * pSubmit = NULL;

                hrSubmit = pElemCandidate->GetPeerHolder()->QueryPeerInterfaceMulti( 
                    IID_IElementBehaviorSubmit,
                    (void**)&pSubmit, 
                    FALSE );

                if (hrSubmit == S_OK)
                {
                    hr = THR(_pCollectionCache->SetIntoAry( FORM_SUBMIT_COLLECTION,
                            pElemCandidate ));
                }

                if (pSubmit)
                    pSubmit->Release();
            }
        }
    }

    *plCollectionVersion = pMarkupPtr->GetMarkupTreeVersion();

Cleanup:
    RRETURN(hr);

Error:
    _pCollectionCache->ResetAry(lIndex);
    goto Cleanup;
}


//+--------------------------------------------------------------
//
//  Member:     CFormElement::CallGetSubmitInfo
//
//  Synopsis:   Iterate thru elements, and call GetSubmitinfo on them.
//              this should construct the get/post data string in the
//              format: n=v[&n=v[...]]\0
//
//---------------------------------------------------------------
HRESULT
CFormElement::CallGetSubmitInfo( 
        CElement * pSubmitSite,
        CElement** ppInputImg,
        int      * pnMultiLines,
        int      * pnFieldsChanged,
        BOOL       fUseUtf8, /*= FALSE*/
        CODEPAGE   cp /*= NULL*/)
{
    HRESULT                     hr;
    ULONG                       i;
    BOOL                        fCanUseUTF8         = Utf8InAcceptCharset();
    ULONG                       cElements           = 0;
    BOOL                        fUseSubmitInterface = FALSE;
    IHTMLSubmitData *           pSubmitData         = NULL;

    TraceTag((tagFormEncoding, "CFormElement::CallGetSubmitInfo called. fUseUtf8: %d, cp %d", fUseUtf8, cp));

    // get size of collection
    cElements = _pCollectionCache->SizeAry(FORM_SUBMIT_COLLECTION);

    if (fUseUtf8)
    {
        Assert(!cp);
        _pSubmitData->_fUseUtf8 = TRUE;
        TraceTag((tagFormEncoding, "CPostData::_fUseUtf8 set to TRUE"));
    }

    if (cp)
    {
        Assert(!fUseUtf8);
        _pSubmitData->_fUseCustomCodePage = TRUE;
        TraceTag((tagFormEncoding, "CPostData::_fUseCustomCodePage set to TRUE"));
        _pSubmitData->_cpInit = cp;
        TraceTag((tagFormEncoding, "CPostData::_cpInit set to %d", cp));
    }   

    hr = THR( this->QueryInterface(IID_IHTMLSubmitData, (void **) &pSubmitData) );
    if (hr) 
        goto Cleanup;

    for (i = 0; i < cElements; i++)
    {
        CElement * pElement;
        const TCHAR *   pchName;
        IElementBehaviorSubmit *    pSubmit             = NULL;

        hr = THR(_pCollectionCache->GetIntoAry(FORM_SUBMIT_COLLECTION,
                        i,
                        &pElement ) );

        if (hr)
            goto Cleanup;

        // Per W3C, don't submit anything for diabled controls. This
        // is incompatible with Nav3/4, which do not support disabled
        // controls at all.
        if (!pElement->IsEnabled())
            continue;

        switch(pElement->Tag())
        {
        // Always skip non-input images
        // submit
        case    ETAG_IMG:
            continue;

        case ETAG_INPUT:
            switch (DYNCAST(CInput, pElement)->GetType())
            {
            case    htmlInputSubmit:
                    // (NS compatibility) If this is a 'submit' button and has
                    // no name (value=NULL), then don't send any submit info
                    // for this control. BUT if the control has a blank name
                    // (value=""), then do send. (ie. "...&=Submit")
                    pchName = pElement->GetAAsubmitname();
                    if ( ! pchName )
                        continue;
            case    htmlInputReset:
            case    htmlInputButton:
                if (!pSubmitSite || pSubmitSite != pElement)
                {
                    continue;
                }
                break;

            // For input images,
            // 1) do not send data if they did not initiate the submit
            // 2) send data in the end, if they did initiate the submit
            case    htmlInputImage:
                if (!pSubmitSite || pSubmitSite != pElement)
                    continue;
                if (i == cElements - 1)
                    break;
                Assert(!*ppInputImg);
                *ppInputImg = pElement;
                continue;
            }

            break;
        default:
            {
                if (pElement->HasPeerHolder())
                {
                    HRESULT hrSubmit = S_OK;
                    hrSubmit = pElement->GetPeerHolder()->QueryPeerInterfaceMulti(
                        IID_IElementBehaviorSubmit, 
                        (void **)&pSubmit, 
                        FALSE);

                    if (hrSubmit == S_OK)
                    {
                        fUseSubmitInterface = TRUE;
                    }
                }
            }
        }


        hr = THR(_pSubmitData->AppendItemSeparator());
        if ( hr )
        {
            if (pSubmit)
                pSubmit->Release();
            goto Cleanup;
        }

        if (!fUseSubmitInterface)
            hr = THR_NOTRACE(pElement->GetSubmitInfo(_pSubmitData));
        else
        {
            hr = pSubmit->GetSubmitInfo(pSubmitData);
            fUseSubmitInterface = FALSE;
        }
        hr = (hr == S_FALSE) ? S_OK : hr;
        if (hr)
        {
            if (pSubmit)
                pSubmit->Release();
            goto Cleanup;  // not OK, not E_NOTIMPL
        }

        //
        //  If the form can use utf-8 and we've found an element
        //  that does not use the default charset, break out of the
        //  loop and use utf-8 instead.
        //  NOTE (krisma) if these conditions are all true, 
        //  CallGetSubmitInfo will be called again by DoSubmit.
        //  See the note in that function.
        //
        if (_pSubmitData->_fCharsetNotDefault && fCanUseUTF8 && !fUseUtf8)
        {
            TraceTag((tagFormEncoding, "Bailing out of CallGetSubmitInfo. _pSubmitData->_fCharsetNotDefault: %d, fCanUseUTF8: %d, !fUseUtf8: %d", 
                _pSubmitData->_fCharsetNotDefault, fCanUseUTF8, !fUseUtf8));
            if (pSubmit)
                pSubmit->Release();
            goto Cleanup;
        }

        // Count the number of text fields, etc. This info is used to throw
        // the appropriate security alert
        switch(pElement->Tag())
        {
        case ETAG_INPUT:
            if (DYNCAST(CInput, pElement)->_fTextChanged)
            {
                (*pnFieldsChanged)++;
            }
            break;
#ifdef  NEVER
        case ETAG_HTMLAREA:
#endif
        case ETAG_TEXTAREA:
            if (DYNCAST(CRichtext, pElement)->_fTextChanged)
            {
                (*pnFieldsChanged)++;
                *pnMultiLines += DYNCAST(CRichtext,
                            pElement)->Layout()->LineCount() - 1;
            }
            break;
        }
        if (pSubmit)
            pSubmit->Release();
    }

Cleanup:
    if (pSubmitData)
        pSubmitData->Release();
    RRETURN(SetErrorInfo(hr));
}


//+--------------------------------------------------------------
//
//  Member:     CFormElement::submit
//
//  Synopsis:   Executes the submit method on the form
//              enumerates all contained sites
//              and calls the appropriated apis on the site
//              to get the submit infos
//              Then constructs the submit string and uses the
//              hyperlink apis to submit
//              This function is exclusively for use in scripts.
//              It does not fire onSubmit event. DoSubmit() must
//              be directly called for internal use.
//
//---------------------------------------------------------------
HRESULT
CFormElement::submit()
{
    RRETURN(DoSubmit(NULL, FALSE));
}

//+--------------------------------------------------------------
//
//  Member:     CFormElement::DoSubmit
//
//  Synopsis:   Executes the submit method on the form
//              enumerates all contained sites
//              and calls the appropriated apis on the site
//              to get the submit infos
//              Then constructs the submit string and uses the
//              hyperlink apis to submit
//
//---------------------------------------------------------------
HRESULT
CFormElement::DoSubmit(CElement *pSubmitSite, BOOL fFireEvent)
{
    HRESULT     hr              = S_OK;
    CDwnPost *  pDwnPost        = NULL;
    CDoc *      pDoc            = Doc();
    int         nMultiLines     = 0;
    int         nFieldsChanged  = 0;
    CElement *  pInputImg       = NULL;
    BOOL        fCanUseUTF8     = Utf8InAcceptCharset();
    BOOL        fUseUtf8        = FALSE;
    LPCTSTR     pchAction;
    CODEPAGE    cp              = NULL;
    CElement::CLock Lock(this);
    
    TraceTag((tagFormElement, "submit"));

    if (fFireEvent && !Fire_onsubmit())
        goto Cleanup;

    // got nuked in event handler?
    if (!IsConnectedToPrimaryMarkup())
        goto Cleanup;

    // We're starting a new submission, so we want to make sure the
    // CPostData is empty;
    if (_pSubmitData)
    {
        TraceTag((tagFormEncoding, "deleting _pSubmitData"));
        delete _pSubmitData;
        _pSubmitData = NULL;
    }
    EnsureSubmitData();
    
    pchAction = GetAAaction();

    // default action should navigate to top level page
    if (!(pchAction && pchAction[0]))
        pchAction = CMarkup::GetUrl(GetFrameOrPrimaryMarkup());

    // Collect and send submit data
    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->EnsureAry(FORM_SUBMIT_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR(CallGetSubmitInfo(
        pSubmitSite,
        &pInputImg,
        &nMultiLines,
        &nFieldsChanged));

    if (hr)
        goto Cleanup;

    // Should convert the submit data to UTF-8?
    // NOTE (krisma) If the following conditions are true,
    // we ended the previous CallGetSubitInfo early.
    // see the note in that function.
    if (_pSubmitData->_fCharsetNotDefault)
    {
        if (fCanUseUTF8)
        {
            fUseUtf8 = TRUE;
        }
        else if (!_pSubmitData->_fCodePageError && !GetMarkup()->HaveCodePageMetaTag())
        {
            hr = THR(mlang().CodePagesToCodePage(_pSubmitData->_dwCodePages, 0, &cp));
            if (S_OK != hr)
                goto Cleanup;
        }

        _pSubmitData->DeleteAllData();

        hr = THR(CallGetSubmitInfo(
            pSubmitSite,
            &pInputImg,
            &nMultiLines,
            &nFieldsChanged,
            fUseUtf8,
            cp));

        if (hr)
            goto Cleanup;
    }

    if (pInputImg)
    {
        _pSubmitData->AppendItemSeparator();
        hr = THR_NOTRACE(pInputImg->GetSubmitInfo(_pSubmitData));

        hr = (hr == S_FALSE) ? S_OK : hr;
        if (hr)
            goto Cleanup;  // not OK, not E_NOTIMPL
    }

    //  Finish up the SubmitData

    hr = THR(_pSubmitData->Finish());
    if ( hr )
        goto Cleanup;

    hr = THR(CDwnPost::Create(_pSubmitData, &pDwnPost));
    if (hr)
        goto Cleanup;

    TraceTag((tagFormEncoding, "Calling FollowHyperlink"));
    hr = THR(pDoc->FollowHyperlink(pchAction,       // Action
                                   GetAAtarget(),   // Target
                                   this,            // pElementContext
                                   pDwnPost,        // data to submit
                                   _fSendAsPost,    // POST or GET
                                   NULL,            // pchExtraHeaders
                                   FALSE,           // OpenInNewWindow
                                   NULL,            // pUnkFrame
                                   NULL,            // ppWindowOut
                                   0,               // dwBindOptions
                                   ERROR_INTERNET_POST_IS_NON_SECURE,  // dwSecurityCode
                                   FALSE,
                                   NULL,
                                   FALSE,
                                   CDoc::FHL_HYPERLINKCLICK | CDoc::FHL_SETDOCREFERER));

    if ( E_ABORT == hr )
    {
        hr = S_OK;
    }

Cleanup:
    if (_pSubmitData)
    {
        delete _pSubmitData;
        _pSubmitData = NULL;
    }
    ReleaseInterface(pDwnPost);
    RRETURN(SetErrorInfo(hr));
}


//+--------------------------------------------------------------
//
//  Member:     CFormElement::Utf8InAcceptCharset
//
//  Synopsis:   Searches through the accept-charset attribute
//              for the string "utf-8" (case insensitive)
//
//---------------------------------------------------------------
BOOL
CFormElement::Utf8InAcceptCharset()
{
    BOOL    fRetVal = FALSE;
    LPCTSTR pch = GetAAacceptCharset();

    TraceTag((tagFormEncoding, "GetAAacceptCharset returned %S", pch));

    while (pch && *pch)
    {
        if (_7csnipre(TEXT("utf-8"), 5, pch, -1))
        {
            fRetVal = TRUE;
            break;
        }
        pch++;
    }

    //
    // Let's make sure the next character is either a 
    // space, commma, or the end of the string
    //
    pch += 5;   //"utf-8" is 5 characters long
    if (fRetVal && *pch)
    {
        if (!_7csnipre(TEXT(" "), 1, pch, 1)
            && !_7csnipre(TEXT(","), 1, pch, 1))
            fRetVal=FALSE;
    }

    TraceTag((tagFormEncoding, "CFormElement::Utf8InAcceptCharset returning %d", fRetVal));
    return fRetVal;
}

//+--------------------------------------------------------------
//
//  Member:     CFormElement::reset
//
//  Synopsis:   Executes the reset method on the form
//              enumerates all contained sites
//              and calls the reset API on the site
//              This function is exclusively for use in scripts.
//              DoReset() must be directly called for internal
//              use.
//
//---------------------------------------------------------------
HRESULT
CFormElement::reset()
{
    RRETURN(DoReset(TRUE));
}

//+--------------------------------------------------------------
//
//  Member:     CFormElement::DoReset
//
//  Synopsis:   Executes the reset method on the form
//              enumerates all contained sites
//              and calls the reset API on the site
//
//---------------------------------------------------------------
HRESULT
CFormElement::DoReset(BOOL fFireEvent)
{
    TraceTag((tagFormElement, "reset"));

    HRESULT     hr = S_OK;
    long        c =0;

    if (fFireEvent && !Fire_onreset())
        goto Cleanup;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->EnsureAry(FORM_SUBMIT_COLLECTION));
    if (hr)
        goto Cleanup;

    // get size of collection
    c = _pCollectionCache->SizeAry(FORM_SUBMIT_COLLECTION);

    //
    // Iterate thru elements, and call DoReset on them.
    //
    while (c--)
    {
        CElement * pElem;

        hr = THR(_pCollectionCache->GetIntoAry(FORM_SUBMIT_COLLECTION,
                        c,
                        &pElem ) );

        if (!hr)
        {
            if (pElem->HasPeerHolder())
            {
                HRESULT                  hrReset = S_OK;
                IElementBehaviorSubmit * pSubmit = NULL;

                hrReset = pElem->GetPeerHolder()->QueryPeerInterfaceMulti(
                    IID_IElementBehaviorSubmit,
                    (void **)&pSubmit,
                    FALSE);
                
                if (!hrReset)
                    pSubmit->Reset();

                if (pSubmit)
                    pSubmit->Release();
            }
            else
                IGNORE_HR(pElem->DoReset());
        }
    }

    hr = S_OK;

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CFormElement::InvokeEx
//
//  Synopsis:   Per IDispatch
//
//--------------------------------------------------------------------------

#ifdef USE_STACK_SPEW
#pragma check_stack(off)
#endif

HRESULT
CFormElement::ContextThunk_InvokeEx (
    DISPID          dispidMember,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS *    pdispparams,
    VARIANT *       pvarResult,
    EXCEPINFO *     pexcepinfo,
    IServiceProvider *pSrvProvider)
{
    IUnknown * pUnkContext;

    // Magic macro which pulls context out of nowhere (actually eax)
    CONTEXTTHUNK_SETCONTEXT

    TraceTag((tagFormElement, "Invoke dispid=0x%x", dispidMember));

    HRESULT hr;
    RETCOLLECT_KIND collectionCreation;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = DISP_E_MEMBERNOTFOUND;

    // If the DISPID came from the typeinfo, adjust the DISPID into GetIdsOfNames range,
    // and record that the Invoke should only return a single item, not a collection

    if ( dispidMember >= DISPID_COLLECTION_TI_MIN &&
         dispidMember <= DISPID_COLLECTION_TI_MAX )
    {
        dispidMember = DISPID_COLLECTION_TI_TO_GN(dispidMember);

        collectionCreation = RETCOLLECT_FIRSTITEM;
    }
    else
    {
        collectionCreation = RETCOLLECT_ALL;
    }


    // Ensuring the 
    if ( _pCollectionCache->IsDISPIDInCollection ( FORM_ELEMENT_COLLECTION , dispidMember ) )
    {
        hr = THR(_pCollectionCache->EnsureAry(FORM_ELEMENT_COLLECTION));
        if (hr)
            goto Cleanup;
        hr = _pCollectionCache->Invoke(FORM_ELEMENT_COLLECTION,
                                      dispidMember,
                                      IID_NULL,
                                      lcid,
                                      wFlags,
                                      pdispparams,
                                      pvarResult,
                                      pexcepinfo,
                                      NULL,
                                      collectionCreation);
    }
    else 
    {

        if ( _pCollectionCache->IsDISPIDInCollection ( FORM_NAMED_IMG_COLLECTION , dispidMember ) )
        {
            hr = THR(_pCollectionCache->EnsureAry(FORM_NAMED_IMG_COLLECTION));
            if (hr)
                goto Cleanup;
            hr = _pCollectionCache->Invoke(FORM_NAMED_IMG_COLLECTION,
                                          dispidMember,
                                          IID_NULL,
                                          lcid,
                                          wFlags,
                                          pdispparams,
                                          pvarResult,
                                          pexcepinfo,
                                          NULL);
        }
    }

    // If above didn't work then try to get the property/expando.
    if (hr)
    {
        hr = THR_NOTRACE(super::ContextInvokeEx (dispidMember,
                                   lcid,
                                   wFlags,
                                   pdispparams,
                                   pvarResult,
                                   pexcepinfo,
                                   pSrvProvider,
                                   pUnkContext ? pUnkContext : (IUnknown*)this));
    }

Cleanup:
    RRETURN(hr);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(on)
#endif

HRESULT
CFormElement::GetDispID(BSTR bstrName, DWORD grfdex, DISPID *pid)
{
    HRESULT     hr = DISP_E_UNKNOWNNAME;
    
    if(IsInMarkup())
    {
        // make sure the form element is inside the tree
        hr = THR(EnsureCollectionCache());
        if (hr)
            goto Cleanup;

        Assert (_pCollectionCache);


        hr = THR(_pCollectionCache->EnsureAry(FORM_ELEMENT_COLLECTION));
        if ( hr )
            goto Cleanup;

        // Try the FORM_ELEMENT_COLLECTION first
        hr = THR_NOTRACE(_pCollectionCache->GetDispID(FORM_ELEMENT_COLLECTION,
                                                      bstrName,
                                                      grfdex,
                                                      pid));

        // If not there try the FORM_NAMED_IMG_COLLECTION. Note that we've turned off
        // ordinal promotion on this collection.
        if ( hr == DISP_E_UNKNOWNNAME )
        {
            hr = THR(_pCollectionCache->EnsureAry(FORM_NAMED_IMG_COLLECTION));
            if ( hr )
                goto Cleanup;
            hr = THR_NOTRACE(_pCollectionCache->GetDispID(FORM_NAMED_IMG_COLLECTION,
                                                          bstrName,
                                                          grfdex,
                                                          pid));
        }
    }

    // The collectionCache GetDispID will return S_OK w/ DISPID_UNKNOWN
    // if the name isn't found, catastrophic errors are of course returned.
    if (hr || (!hr && *pid == DISPID_UNKNOWN))
    {
        // Don't allow vbscript fast event sinks to be hooked up.
        if (hr && (grfdex & fdexNameNoDynamicProperties))
        {
            *pid = DISPID_UNKNOWN;
            goto Cleanup;
        }

        hr = THR_NOTRACE(super::GetDispID(bstrName, grfdex, pid));

        // Add the hack for the Jeremie test.  If the property we're looking
        // for is  enctype, return the dispid for encoding.
        if (hr == DISP_E_UNKNOWNNAME && !_tcscmp(bstrName, _T("enctype")))
        {
            BSTR    bstrTmp;

            hr = FormsAllocString(_T("encoding"), &bstrTmp);
            if (FAILED(hr))
                goto Cleanup;
            hr = THR_NOTRACE(super::GetDispID(bstrTmp, grfdex, pid));
            FormsFreeString(bstrTmp);
        }
    }

Cleanup:
    RRETURN(hr);
}


HRESULT
CFormElement::GetNextDispID(
                DWORD grfdex,
                DISPID id,
                DISPID *prgid)
{
    HRESULT     hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    if(IsInMarkup())
    {
        hr = THR(_pCollectionCache->EnsureAry(FORM_ELEMENT_COLLECTION));
        if (hr)
            goto Cleanup;
    }

    hr = DispatchGetNextDispIDCollection(this,
#ifndef WIN16
                                         (GetNextDispIDPROC)&super::GetNextDispID,
#else
                                         CBase::GetNextDispID,
#endif
                                         _pCollectionCache,
                                         FORM_ELEMENT_COLLECTION,
                                         grfdex,
                                         id,
                                         prgid);

Cleanup:
    RRETURN1(hr, S_FALSE);
}

HRESULT
CFormElement::GetMemberName(
                DISPID id,
                BSTR *pbstrName)
{
    HRESULT     hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = DispatchGetMemberNameCollection(this,
#ifndef WIN16
                                         (GetGetMemberNamePROC)super::GetMemberName,
#else
                                         CBase::GetMemberName,
#endif
                                         _pCollectionCache,
                                         FORM_ELEMENT_COLLECTION,
                                         id,
                                         pbstrName);

Cleanup:
    RRETURN(hr);
}

//---------------------------------------------------------------------------
//
//  Member:     CFormElement::GetMultiTypeInfoCount
//
//  Synopsis:   per IProvideMultipleClassInfo
//
//---------------------------------------------------------------------------

HRESULT
CFormElement::GetMultiTypeInfoCount(ULONG *pc)
{
    TraceTag((tagFormElement, "GetMultiTypeInfoCount"));

    *pc = 3;
    return S_OK;
}


//---------------------------------------------------------------------------
//
//  Member:     CFormElement::GetInfoOfIndex
//
//  Synopsis:   per IProvideMultipleClassInfo
//
//---------------------------------------------------------------------------

HRESULT
CFormElement::GetInfoOfIndex(
    ULONG       iTI,
    DWORD       dwFlags,
    ITypeInfo** ppTICoClass,
    DWORD*      pdwTIFlags,
    ULONG*      pcdispidReserved,
    IID*        piidPrimary,
    IID*        piidSource)
{
    TraceTag((tagFormElement, "GetInfoOfIndex"));

    HRESULT         hr = S_OK;
    long            lIndex;
    DISPID          dispidMin;
    DISPID          dispidMax;
    ITypeInfo **    ppTypeInfo = NULL;
    ITypeInfo **    ppTypeInfoCoClass = NULL;

    //
    // First try the main typeinfo
    //

    if (dwFlags & MULTICLASSINFO_GETTYPEINFO)
    {
        //
        // If the type-info to be created on the fly has not yet
        // happened then create them
        //

        if (1 == iTI)
        {
            lIndex = FORM_ELEMENT_COLLECTION;
            dispidMin = DISPID_FORM_ELEMENT_TI_MIN;
            dispidMax = DISPID_FORM_ELEMENT_TI_MAX;
            ppTypeInfo        = &_pTypeInfoElements;
            ppTypeInfoCoClass = &_pTypeInfoCoClassElements;
        }
        else if (2 == iTI)
        {
            lIndex = FORM_NAMED_IMG_COLLECTION;
            dispidMin = DISPID_FORM_NAMED_IMG_TI_MIN;
            dispidMax = DISPID_FORM_NAMED_IMG_TI_MAX;
            ppTypeInfo        = &_pTypeInfoImgs;
            ppTypeInfoCoClass = &_pTypeInfoCoClassImgs;
        }
        else
        {
            goto Dosuper;
        }

        hr = THR(EnsureCollectionCache());
        if (hr)
            goto Cleanup;

        hr = THR(_pCollectionCache->EnsureAry(lIndex));
        if (hr)
            goto Cleanup;

        Assert (ppTypeInfo && ppTypeInfoCoClass);

        if (!(*ppTypeInfo) || !(*ppTypeInfoCoClass))
        {
            hr = THR(Doc()->BuildObjectTypeInfo(
                _pCollectionCache,
                lIndex,
                dispidMin,
                dispidMax,
                ppTypeInfo,
                ppTypeInfoCoClass));
            if (hr)
                goto Cleanup;
        }

        *ppTICoClass = *ppTypeInfoCoClass;
        (*ppTICoClass)->AddRef();

        //
        // Clear out these values so that we can use the base impl.
        //

        dwFlags &= ~MULTICLASSINFO_GETTYPEINFO;
        iTI = 0;
        ppTICoClass = NULL;
    }

Dosuper:
    hr = THR(super::GetInfoOfIndex(
            iTI,
            dwFlags,
            ppTICoClass,
            pdwTIFlags,
            pcdispidReserved,
            piidPrimary,
            piidSource));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

//+--------------------------------------------------------------
//
//  Member:     CFormElement::FOnlyTextbox
//
//  Synopsis:   Called by an input textbox to determine whether
//              it should cause the form to be submitted upon
//              receiving a VK_ENTER.
//
//---------------------------------------------------------------

HRESULT
CFormElement::FOnlyTextbox(CInput * pTextbox, BOOL * pfOnly)
{
    HRESULT     hr = S_OK;
    long        i;
    CElement *  pElem;

    Assert(pTextbox);
    Assert(pTextbox->Tag() == ETAG_INPUT);
    Assert(pTextbox->GetType() != htmlInputButton);
    Assert(pTextbox->GetType() != htmlInputReset);
    Assert(pTextbox->GetType() != htmlInputSubmit);

    Assert(pfOnly);
    *pfOnly = TRUE;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->EnsureAry(FORM_ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    for (i = _pCollectionCache->SizeAry(FORM_ELEMENT_COLLECTION) - 1;
            i >= 0 && *pfOnly; i--)
    {
        hr = THR(_pCollectionCache->GetIntoAry(FORM_ELEMENT_COLLECTION,
                        i,
                        &pElem));
        if (hr)
            goto Cleanup;

        if (pElem != pTextbox && pElem->Tag() == ETAG_INPUT)
        {
            CInput * pInput = DYNCAST(CInput, pElem);

            switch (pInput->GetType())
            {
            case htmlInputText:
            case htmlInputPassword:
                *pfOnly = FALSE;  // found another textbox in this form
            }
        }
    }
Cleanup:
    RRETURN(hr);
}

//+--------------------------------------------------------------
//
//  Member:     CFormElement::FormTraverseGroup
//
//  Synopsis:   Called by (e.g.)a radioButton to its form, this function
//      takes the groupname and queries the Form's collection for the rest
//      of the group and calls the provided CLEARGROUP function on that
//      element. in this way ANY Form GRoup can be cleared (or have some
//      opetation done on all its members)
//
//---------------------------------------------------------------

HRESULT
CFormElement::FormTraverseGroup(
    LPCTSTR strGroupName,
    PFN_VISIT pfn,
    DWORD_PTR dw,
    BOOL fForward)
{
    HRESULT     hr;
    long        i, c;
    CElement *  pElem;
    LPCTSTR     lpName;

    _fInTraverseGroup = TRUE;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->EnsureAry(FORM_ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    // get size of collection
    c = _pCollectionCache->SizeAry(FORM_ELEMENT_COLLECTION);

    if (fForward)
        i = 0;
    else
        i = c - 1;

    // if nothing is in the collection, default answer is S_FALSE.
    hr = S_FALSE;

    while (c--)
    {
        hr = THR(_pCollectionCache->GetIntoAry(FORM_ELEMENT_COLLECTION,
                        i,
                        &pElem));
        if (fForward)
            i++;
        else
            i--;

        if (hr)
            goto Cleanup;

        lpName = pElem->GetAAname();

        hr = S_FALSE;                   // default answer again.

        // is this item in the target group?
        if ( lpName && FormsStringICmp(strGroupName, lpName) == 0 )
        {
            // Call the function and stop if it doesn't return S_FALSE.
#ifdef WIN16
            hr = THR( (*pfn)(pElem, dw) );
#else
            hr = THR( CALL_METHOD( pElem, pfn, (dw)) );
#endif
            if (hr != S_FALSE)
                break;
        }
    }

Cleanup:
    _fInTraverseGroup = FALSE;
    RRETURN1(hr, S_FALSE);
}

//+--------------------------------------------------------------
//
//  Member:     CFormElement::FindDefaultElem
//
//  Synopsis:   find the default/Cancel button
//
//---------------------------------------------------------------

CElement *
CFormElement::FindDefaultElem(BOOL fDefault, BOOL fCurrent /* FALSE */)
{
    HRESULT     hr      = S_FALSE;
    long        i       = 0;
    long        c       = 0;
    CElement  * pElem   = NULL;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->EnsureAry(FORM_ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    // get size of collection
    c = _pCollectionCache->SizeAry(FORM_ELEMENT_COLLECTION);

    while (c--)
    {
        hr = THR(_pCollectionCache->GetIntoAry(FORM_ELEMENT_COLLECTION,
                        i++,
                        &pElem));

        if (hr)
        {
            pElem = NULL;
            goto Cleanup;
        }

        Assert(pElem);
        if (pElem->_fExittreePending)
            continue;

        if (fCurrent)
        {
            if (pElem->_fDefault)
                goto Cleanup;
            continue;
        }

        if ( pElem->TestClassFlag(fDefault?
                ELEMENTDESC_DEFAULT : ELEMENTDESC_CANCEL)
            && pElem->IsVisible(TRUE)
            && pElem->IsEnabled()
            )
        {
                goto Cleanup;
        }
    }
    pElem = NULL;

Cleanup:
    return pElem;
}

//+--------------------------------------------------------------
//
//  Member:     CFormElement::ApplyDefaultFormat
//
//  Synopsis: Provide for special formatting for the form. So far
//            the only interesting thing here is that <FORM>s generate
//            extra vertical white space in Netscape, but not in IE.
//            We imitate Netscape.
//
//---------------------------------------------------------------

HRESULT
CFormElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT         hr = S_OK;

    hr = THR(super::ApplyDefaultFormat(pCFI));
    if(hr)
        goto Cleanup;

    //
    // Apply default before/after space.
    // NOTE: Before/after space are outside our box (== margins), 
    //       so they are relative to the parent's text flow.
    //
    {
        BOOL fParentVertical = pCFI->_pNodeContext->IsParentVertical();

        pCFI->PrepareFancyFormat();
        ApplyDefaultVerticalSpace(fParentVertical, &pCFI->_ff());
        pCFI->UnprepareForDebug();
    }

Cleanup:
    return (hr);
}

//+--------------------------------------------------------------
//
//  Member:     CFormElement::put_method
//
//  Synopsis: needed because of special get_method handling
//
//+--------------------------------------------------------------
STDMETHODIMP CFormElement::put_method(BSTR bstr)
{
    VARIANT v;
    v.vt = VT_BSTR;
    V_BSTR(&v) = bstr;
    RRETURN(SetErrorInfo(s_propdescCFormElementmethod.a.HandleEnumProperty(HANDLEPROP_SET |
                                                                 HANDLEPROP_AUTOMATION |
                                                                 (PROPTYPE_VARIANT << 16),
                                                                 &v,
                                                                 this,
                                                                 (CVoid *)(void *)(&_pAA))));
}
//+--------------------------------------------------------------
//
//  Member:     CFormElement::get_method
//
//  Synopsis: Through the OM when the value is notSet we return Get
//
//  N.B. this function assumes intimate knowledge of the htmlMethod enum.
//       and the possible values. if the number of enums changes, or the
//       indicies into the enum then this function will need attention
//+--------------------------------------------------------------
STDMETHODIMP CFormElement::get_method(BSTR * pbstr)
{
    HRESULT hr;

    if (!pbstr)
    {
        hr = E_POINTER;
        goto Cleanup;
    }



    if(GetAAmethod()!=htmlMethodPost)
    {
        // then return the "get" string
        hr = THR(FormsAllocString( s_enumdeschtmlMethod.aenumpairs[ htmlMethodGet ].pszName,
                                   pbstr));
    }
    else
    {
        // then return the "Post" string
        hr = THR(FormsAllocString( s_enumdeschtmlMethod.aenumpairs[ htmlMethodPost ].pszName,
                                   pbstr));
    }
    if (hr )
        goto Cleanup;


Cleanup:
    RRETURN(SetErrorInfo( hr));
}



//+------------------------------------------------------------------------
//
//  Member:     get_length
//
//  Synopsis:   collection object model, defers to Cache Helper
//
//-------------------------------------------------------------------------

HRESULT
CFormElement::get_length(long * plSize)
{
    HRESULT hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;


    hr = THR(_pCollectionCache->EnsureAry(FORM_ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->GetLength(FORM_ELEMENT_COLLECTION, plSize));

Cleanup:
    RRETURN(SetErrorInfo( hr));

}


//+------------------------------------------------------------------------
//
//  Member:     put_length
//
//  Synopsis:   collection object model, defers to Cache Helper
//
//-------------------------------------------------------------------------

HRESULT
CFormElement::put_length(long lSize)
{
    // supported only in area collection
    RRETURN(SetErrorInfo(E_NOTIMPL));
}


//+------------------------------------------------------------------------
//
//  Member:     item
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CFormElement::item(VARIANTARG var1, VARIANTARG var2, IDispatch** ppResult)
{
    HRESULT hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->EnsureAry(FORM_ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->Item(FORM_ELEMENT_COLLECTION,
                        var1,
                        var2,
                        ppResult));

Cleanup:
    RRETURN(SetErrorInfo( hr));
}

//+------------------------------------------------------------------------
//
//  Member:     namedItem
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CFormElement::namedItem(BSTR bstrName, IDispatch** ppResult)
{
    HRESULT hr;

    if (!bstrName || !*bstrName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->EnsureAry(FORM_ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    VARIANT var1, var2;

    var1.vt = VT_BSTR;
    var1.bstrVal = bstrName;
    var2.vt = VT_EMPTY;

    hr = THR(_pCollectionCache->Item(FORM_ELEMENT_COLLECTION,
                        var1,
                        var2,
                        ppResult));

Cleanup:
    RRETURN(SetErrorInfo( hr));
}

//+------------------------------------------------------------------------
//
//  Member:     tags
//
//  Synopsis:   collection object model, this always returns a collection
//              and is named based on the tag, and searched based on tagname
//
//-------------------------------------------------------------------------

HRESULT
CFormElement::tags(VARIANT var1, IDispatch ** ppdisp)
{
    HRESULT hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;


    hr = THR(_pCollectionCache->EnsureAry(FORM_ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->Tags(FORM_ELEMENT_COLLECTION, var1, ppdisp));

Cleanup:
    RRETURN(SetErrorInfo( hr));
}


//+------------------------------------------------------------------------
//
//  Member:     urns
//
//  Synopsis:   collection object model, this always returns a collection
//              and is named based on the urn, and searched based on urn
//
//-------------------------------------------------------------------------

HRESULT
CFormElement::urns(VARIANT var1, IDispatch ** ppdisp)
{
    HRESULT hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;


    hr = THR(_pCollectionCache->EnsureAry(FORM_ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->Urns(FORM_ELEMENT_COLLECTION, var1, ppdisp));

Cleanup:
    RRETURN(SetErrorInfo( hr));
}

//+------------------------------------------------------------------------
//
//  Member:     Get_newEnum
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CFormElement::get__newEnum(IUnknown ** ppEnum)
{
    HRESULT hr;

    hr = THR(EnsureCollectionCache());
    if (hr)
        goto Cleanup;

    
    hr = THR(_pCollectionCache->EnsureAry(FORM_ELEMENT_COLLECTION));
    if (hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->GetNewEnum(FORM_ELEMENT_COLLECTION, ppEnum));

Cleanup:
    RRETURN(SetErrorInfo( hr));
}

//+------------------------------------------------------------------------
//
//  Member:     appendNameValuePair
//
//  Synopsis:   IHTMLSubmitData support
//
//-------------------------------------------------------------------------
HRESULT
CFormElement::appendNameValuePair(BSTR name, BSTR value)
{
    HRESULT hr = S_OK;

    hr = THR(EnsureSubmitData());
    if (hr)
        goto Cleanup;

    hr = THR(_pSubmitData->AppendNameValuePair(name, value, GetMarkup()));

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     appendNameFilePair
//
//  Synopsis:   IHTMLSubmitData support
//
//-------------------------------------------------------------------------
HRESULT
CFormElement::appendNameFilePair(BSTR name, BSTR filename)
{
    HRESULT hr = S_OK;

    hr = THR(EnsureSubmitData());
    if (hr)
        goto Cleanup;

    hr = THR(_pSubmitData->AppendNameFilePair(name, filename, GetMarkup()));

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     appendItemSeparator
//
//  Synopsis:   IHTMLSubmitData support
//
//-------------------------------------------------------------------------
HRESULT
CFormElement::appendItemSeparator()
{
    HRESULT hr = S_OK;

    hr = THR(EnsureSubmitData());
    if (hr)
        goto Cleanup;

    hr = THR(_pSubmitData->AppendItemSeparator());

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     EnsureSubmitData
//
//  Synopsis:   If _pSubmitData is null; create a new CPostData and 
//              initialize it.
//
//-------------------------------------------------------------------------
HRESULT
CFormElement::EnsureSubmitData()
{
    HRESULT     hr          = S_OK;
    BOOL        fSendAsPost;
    LPCTSTR     pchAction;
    CDoc *      pDoc        = Doc();

    if (_pSubmitData)
        goto Cleanup;

    _pSubmitData = new CPostData();
    if (!_pSubmitData)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    fSendAsPost = (GetAAmethod() == htmlMethodPost);

    pchAction = GetAAaction();
    if (!(pchAction && pchAction[0]))
        pchAction = pDoc->GetPrimaryUrl();

    //  Get the ENCTYPE attrib of the form. Set it into the SubmitData object
    _pSubmitData->_encType = GetAAencoding();

    // Netscape compatibility: if encType==text/plain then make it a POST
    if (_pSubmitData->_encType == htmlEncodingText && !fSendAsPost)
    {
        UINT    uProt = GetUrlScheme(pchAction);

        if (URL_SCHEME_HTTP == uProt ||
            URL_SCHEME_HTTPS == uProt)
        {
            fSendAsPost = TRUE;
        }
    }

    if (!fSendAsPost)
    {
        // GET only allows one possible encoding
        _pSubmitData->_encType = htmlEncodingURL;
    }

    hr = _pSubmitData->CreateHeader();
    if (hr)
        goto Error;

    _fSendAsPost = fSendAsPost;

Cleanup:
    RRETURN(hr);

Error:
    delete _pSubmitData;
    _pSubmitData = NULL;
    goto Cleanup;
}


//+----------------------------------------------------------------------------
//  
//  Method:     CFormElement::FormEnterTree
//  
//  Synopsis:   Does some work that's needed when the element enters the
//              tree, such as adding itself to the script collection.
//  
//  Returns:    HRESULT
//  
//  Arguments:
//  
//+----------------------------------------------------------------------------

HRESULT
CFormElement::FormEnterTree()
{
    HRESULT hr = S_OK;
    CMarkup * pMarkup = GetMarkupPtr();
    CScriptCollection * pScriptCollection;

    Assert (!_pTypeInfoElements);
    Assert (!_pTypeInfoCoClassElements);
    Assert (!_pTypeInfoImgs);
    Assert (!_pTypeInfoCoClassImgs);

    if (!pMarkup || pMarkup->_fDesignMode || pMarkup->_fMarkupServicesParsing)
        goto Cleanup;

    //
    // Add this form as a named item to the script engine.
    // This is to enable scriptlets for children of the form.  Also
    // to keep compatibility with IE.
    //
    pScriptCollection = pMarkup->GetScriptCollection();

    if (pScriptCollection)
    {
        hr = THR(pScriptCollection->AddNamedItem(this));
        if (hr)
            goto Cleanup;
    }
Cleanup:
    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\eli.cxx ===
//+---------------------------------------------------------------------
//
//   File:      eli.cxx
//
//  Contents:   LI element class
//
//  Classes:    CLIElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ELI_HXX_
#define X_ELI_HXX_
#include "eli.hxx"
#endif

#ifndef X_ELIST_HXX_
#define X_ELIST_HXX_
#include "elist.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X__DOC_H_
#define X__DOC_H_
#include "_doc.h"
#endif

#ifndef X_NUMCONV_HXX_
#define X_NUMCONV_HXX_
#include "numconv.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#define _cxx_
#include "li.hdl"

MtDefine(CLIElement, Elements, "CLIElement")

EXTERN_C const ENUMDESC s_enumdescTYPE;

const CElement::CLASSDESC CLIElement::s_classdesc =
{
    {
        &CLSID_HTMLLIElement,               // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLLIElement,                // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLLIElement,         //_apfnTearOff
    NULL                                    // _pAccelsRun
};

HRESULT
CLIElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_LI));

    Assert(ppElement);
    *ppElement = new CLIElement(pDoc);
    return *ppElement ? S_OK: E_OUTOFMEMORY;
}

HRESULT
CLIElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT     hr = S_OK;
    CTreeNode * pNodeList = NULL;
    CTreeNode * pNodeContext = pCFI->_pNodeContext;
    CFlowLayout *pFL;
    
    Assert(pNodeContext && SameScope(this, pNodeContext));

    // Find the List element
    pFL = pNodeContext->Parent()->GetFlowLayout();
    if (pFL && pFL->GetContentMarkup())
    {
        pNodeList = pFL->GetContentMarkup()->SearchBranchForCriteria(
            pCFI->_pNodeContext->Parent(), IsBlockListElement, NULL);
    }

    // Setup default LI formats
    // Default bullet position is inside for naked LI's.
    pCFI->PrepareParaFormat();
    pCFI->_pf()._cListing.SetType((pNodeList && ETAG_OL == pNodeList->Tag())
                                  ? CListing::NUMBERING : CListing::BULLET);
    if (pNodeList)
    {
        CListElement * pListElem = DYNCAST(CListElement, pNodeList->Element());
        pCFI->_pf()._cListing.SetStyle(pListElem->FilterHtmlListType(pCFI->_ppf->GetListStyleType(), 
            ETAG_OL == pNodeList->Tag() ? 0 : (WORD)pCFI->_ppf->_cListing.GetLevel()));
    }
    if (!pCFI->_pf()._fExplicitListPosition)
    {
        // If list position hasn't been explicitly set, naked LIs and 
        // LIs inside DLs by default have bullet position inside.
        pCFI->_pf()._bListPosition = (pNodeList && pNodeList->Tag() != ETAG_DL)
                                   ? styleListStylePositionOutSide 
                                   : styleListStylePositionInside;
    }
    pCFI->UnprepareForDebug();

    // Apply formats
    hr = THR(super::ApplyDefaultFormat(pCFI));
    if(hr)
        goto Cleanup;

    // check for the VALUE attribute.
    if (GetAAvalue() > 0)
    {
        pCFI->PrepareParaFormat();
        pCFI->_pf()._cListing.SetValueValid();
        pCFI->_pf()._lNumberingStart = GetAAvalue();
        pCFI->UnprepareForDebug();
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CLIElement::Save
//
//  Synopsis:   Save the element to the stream
//
//-------------------------------------------------------------------------

HRESULT
CLIElement::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    HRESULT hr;
    CElement *pElementParent = IsInMarkup() ? GetFirstBranch()->Parent()->Element() : NULL;
    CFlowLayout *pFL = GetFlowLayout();
    CElement *pElementFL = pFL ? pFL->ElementContent() : NULL;

    AssertSz( !( pStreamWrBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC) ||
                 pStreamWrBuff->TestFlag(WBF_NUMBER_LISTS) )
              || pElementParent, 
              "Parentless LIs can not be saved with these flags on!" );

    if (    pStreamWrBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC) 
        &&  pStreamWrBuff->TestFlag(WBF_SAVE_SELECTION)
        &&  pElementParent->Tag() == ETAG_OL
        &&  !fEnd
        &&  !IsDisplayNone() )
    {
        CListValue LV;
        GetValidValue(&LV, GetMarkupPtr(), GetFirstBranch(), 
            GetMarkupPtr()->FindMyListContainer(GetFirstBranch()), pElementFL);

        CAttrArray * pNewAA;
        CAttrArray * pOldAA = *GetAttrArray();
        if (pOldAA)
        {
            hr = pOldAA->Clone(&pNewAA);
            if (hr)
                goto Cleanup;
        }
        else
            pNewAA = new CAttrArray;

        if(!pNewAA)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        VARIANT value;
        value.vt = VT_I4;
        value.lVal = LV._lValue;
        CAttrArray::Set(&pNewAA, DISPID_CLIElement_value, &value);
        SetAttrArray(pNewAA);

        hr = super::Save(pStreamWrBuff, fEnd);

        SetAttrArray(pOldAA);
        delete pNewAA;
    }
    else
    {
        TCHAR ach[17];

        hr = super::Save(pStreamWrBuff, fEnd);
        if (hr)
            goto Cleanup;

        if (pStreamWrBuff->TestFlag(WBF_NUMBER_LISTS) && !fEnd)
        {
            CListValue LI;
            GetValidValue(&LI, GetMarkupPtr(), GetFirstBranch(), 
                GetMarkupPtr()->FindMyListContainer(GetFirstBranch()), pElementFL);

            if(pElementParent->Tag() == ETAG_OL)
            {
                NumberToNumeral(LI._lValue, ach);
            }
            else
            {
                NumberToAlphaLower(LI._lValue, ach);
            }

            hr = pStreamWrBuff->Write(ach);
            if (hr)
                goto Cleanup;

            hr = pStreamWrBuff->Write(_T(". "), 2);
           if (hr)
                goto Cleanup;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CLIElement::Notify
//
//  Synopsis:   Catches enter and exit tree notifications to update the
//              index caches.
//
//-------------------------------------------------------------------------
void
CLIElement::Notify(CNotification *pNF)
{
    super::Notify(pNF);
    switch (pNF->Type())
    {
        case NTYPE_ELEMENT_EXITTREE_1:
            if (pNF->DataAsDWORD() & EXITTREE_DESTROY)
                break;
            // Else, fall thru and do exactly the same stuff we would do on enter tree
        case NTYPE_ELEMENT_ENTERTREE:
        {
            CMarkup *pMarkup = GetMarkup();
            Assert(pMarkup);
            if (!pMarkup)
                goto Cleanup;

            CTreeNode *pListNode = pMarkup->FindMyListContainer(GetFirstBranch());
            if (pListNode)
            {
                DYNCAST(CListElement, pListNode->Element())->UpdateVersion();

                // For an LI coming in, we want to be sure that its version and
                // value are invalid. They may not be if this LI is being cut and
                // pasted from another part of the document. It may so happen that
                // the LI has the exact same version as the one we updated just
                // above,  then the LI will in most cases have a bad value.
                _ivIndex._dwVersion = 0;
                _ivIndex._lValue = 0;
            }
            break;
        }
    }
Cleanup:
    return;
}


//+------------------------------------------------------------------------
//
//  Member:     CLIElement::GetValidValue
//
//  Synopsis:   This is the main function which returns the list index value
//              for an LI. Its only called by the renderer.
//
//-------------------------------------------------------------------------
VOID
CLIElement::GetValidValue(CListValue   *pLV,                // [o]
                          CMarkup      *pMarkup,            // [i]
                          CTreeNode    *pLINode,            // [i]
                          CTreeNode    *pNodeListElement,   // [i]
                          CElement     *pElementFL)         // [i]
{
    CListing  Listing;
    BOOL      fInner;
    const     CParaFormat *pPF;
    CListElement *pListElement;
    
    Assert(pLV);
    Assert(pMarkup == GetMarkup());
    Assert(pLINode && pLINode->Element() == this);
    Assert(SameScope(pNodeListElement, pMarkup->FindMyListContainer(pLINode)));
    Assert(pElementFL);
    Assert(!IsDisplayNone());
    
    pListElement = pNodeListElement ? DYNCAST(CListElement, pNodeListElement->Element()) : NULL;

    fInner = SameScope(pLINode, pElementFL);
    pPF = pLINode->GetParaFormat();
    Listing = pPF->GetListing();
    Assert(Listing.HasAdornment());

    // Note(SujalP): LI's are naked if they are under anything but
    // OL and UL. (So an LI under a BODY, P, DL is considered naked)
    if (   !pListElement
        || pListElement->Tag() == ETAG_DL
       )
    {
        pLV->_lValue = Listing.IsValueValid()
                       ? pPF->GetNumberingStart()
                       : 1;
        pLV->_style = Listing.GetStyle();
    }

    // Valid index
    else if (IsIndexValid(pListElement))
    {
        pLV->_lValue = _ivIndex._lValue;
        pLV->_style  = Listing.GetStyle();
    }

    // Invalid index
    else
    {
        CTreeNode  *pNodeLastValid;
        CTreeNode  *pNode;

        // Find the previous valid LI with a valid index. If there was not valid LI
        // then the list container is by default valid so find that.
        LONG lValue = FindPreviousValidIndexedElement(pNodeListElement,
            pLINode,
            pElementFL,
            &pNodeLastValid);
        
        // We have to have a node, and it is either the container itself
        // or its a LI with a valid index.
        Assert(   pNodeLastValid
               && (   SameScope(pNodeLastValid, pListElement)
                   || DYNCAST(CLIElement, pNodeLastValid->Element())->IsIndexValid(pListElement)
                  )
              );

        CListItemIterator ci(pListElement,
                             SameScope(pNodeLastValid, pListElement) ? NULL : pNodeLastValid->Element());

        // Use the iterator to walk forward from the last li with a valid index to the
        // present LI, validating all the LI's along the way.
        while((pNode = ci.NextChild()) != NULL)
        {
            // Ignore an LI if it not displayed. Remember a display none LI will
            // never have a valid index
            if (pNode->IsDisplayNone())
            {
                Assert(!DYNCAST(CLIElement, pNode->Element())->IsIndexValid(pListElement));
                continue;
            }
            
            CLIElement *pLIElement = DYNCAST(CLIElement, pNode->Element());

            pPF         = pNode->GetParaFormat();
            fInner      = SameScope(pNode, pElementFL);
            Listing     = pPF->GetListing();

            if (Listing.IsValueValid())
            {
                lValue = pPF->GetNumberingStart();
            }
            
            // Validate all the list elements as we are walking forward
            pLIElement->_ivIndex._lValue    = lValue;
            pLIElement->_ivIndex._dwVersion = pListElement->_dwVersion;

            // If we have reached our LI then we stop any further validations.
            if (pLIElement == this)
            {
                pLV->_style  = Listing.GetStyle();
                pLV->_lValue = lValue;
                break;
            }

            // Increment the index to go to the next LI
            lValue++;
        }
    }
    
    if (pLV->_style == styleListStyleTypeNotSet)
        pLV->_style  = styleListStyleTypeDisc;
    return;
}


//+-----------------------------------------------------------------------
//
//  Member:     FindPreviousValidIndexedElement
//
//  Returns:    Finds the previous valid LI and returns the index to be
//              given to the current LI
//
//------------------------------------------------------------------------
LONG
CLIElement::FindPreviousValidIndexedElement(CTreeNode *pNodeListIndex,
                                            CTreeNode *pLINode,
                                            CElement  *pElementFL,
                                            CTreeNode **ppNodeLIPrevValid)
{
    Assert(pNodeListIndex);
    Assert(pLINode);
    Assert(ppNodeLIPrevValid);
    Assert(pElementFL);
    
    CTreeNode    *pNode;
    CLIElement   *pLIElement = NULL;
    LONG          lValue;
    CListElement *pListElement = DYNCAST(CListElement, pNodeListIndex->Element());

    CListItemIterator ci(pListElement, pLINode->Element());

    // Walk back till we find a LI with a valid index.
    while((pNode = ci.PreviousChild()) != NULL)
    {
        pLIElement = DYNCAST(CLIElement, pNode->Element());
        if (pLIElement->IsIndexValid(pListElement))
            break;
        pLIElement = NULL;
    }

    // If we came here with a NULL pLIElement, it means that we could not find
    // a LI with valid index and we have to return the OL.
    if (pLIElement)
    {
        lValue = pLIElement->_ivIndex._lValue + 1;
    }
    else
    {
        if (pNodeListIndex->Tag() == ETAG_OL)
        {
            const CParaFormat *pPF = pNodeListIndex->GetParaFormat();
            lValue = pPF->GetNumberingStart();
        }
        else
        {
            lValue = 1;
        }

        // If we have reached our container and its version is 0, then we have
        // have to validate the container's version number.
        if (pListElement->_dwVersion == 0)
            pListElement->_dwVersion = 1;
        
        pNode = pNodeListIndex;
    }

    *ppNodeLIPrevValid = pNode;
    return lValue;
}

//+-----------------------------------------------------------------------
//
//  Member:    IsIndexValid()
//
//  Note  :    Verifies if the index is a valid index.
//
//------------------------------------------------------------------------
BOOL
CLIElement::IsIndexValid(CListElement *pListElement)
{
    // NOTE: The following also tests for pListElement->_dwVersion==0 by default
    // and returns false in that case too.
    return    _ivIndex._dwVersion != 0
           && _ivIndex._dwVersion == pListElement->_dwVersion;
}

//+-----------------------------------------------------------------------
//
//  Member:     OnPropertyChange()
//
//  Note  :    Trap the change to start attribute to inval the index caches
//
//------------------------------------------------------------------------
HRESULT
CLIElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr;

    if (dispid == DISPID_CLIElement_value)
    {
        CTreeNode *pNode = GetMarkup()->FindMyListContainer(GetFirstBranch());
        if (pNode)
        {
            DYNCAST(CListElement, pNode->Element())->UpdateVersion();
        }
    }
    hr = THR( super::OnPropertyChange( dispid, dwFlags, ppropdesc ) );

    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\elink.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       elink.cxx
//
//  Contents:   CLinkElement & related
//
//
//----------------------------------------------------------------------------

#include "headers.hxx"      // for the world

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"     // for CCssCtx
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"     // for CElement
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_ELINK_HXX_
#define X_ELINK_HXX_
#include "elink.hxx"        // for CLinkElement
#endif

#ifndef X_ESTYLE_HXX_
#define X_ESTYLE_HXX_
#include "estyle.hxx"       // for CStyleElement
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"      // for CTxtSite
#endif

#ifndef X_TYPES_H_
#define X_TYPES_H_
#include "types.h"          // for s_enumdeschtmlReadyState
#endif

#ifndef X_SCRPTLET_H_
#define X_SCRPTLET_H_
#include "scrptlet.h"       // for the scriptoid stuff
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_LAYOUT_HXX_
#define X_LAYOUT_HXX_
#include "layout.hxx"
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_PRIVACY_HXX_
#define X_PRIVACY_HXX_
#include "privacy.hxx"
#endif

#if defined(_M_ALPHA)
#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif
#endif


#define _cxx_
#include "link.hdl"

MtDefine(CLinkElement, Elements, "CLinkElement")
MtDefine(CLinkElementOnDwnChan_pbBuffer, Locals, "CLinkElement::OnDwnChan pbBuffer")
MtDefine(CLinkElementOnDwnChan_pchSrc, Locals, "CLinkElement::OnDwnChan pchSrc")
MtDefine(CLinkElementHandleLinkedObjects, Elements, "CLinkElement::HandleLinkedObjects");

EXTERN_C const GUID CLSID_ScriptletConstructor;

ExternTag(tagStyleSheet)
ExternTag(tagSharedStyleSheet)
//+------------------------------------------------------------------------
//
//  Class: CLinkElement
//
//-------------------------------------------------------------------------

const CElement::CLASSDESC CLinkElement::s_classdesc =
{
    {
        &CLSID_HTMLLinkElement,             // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLLinkElement,              // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLLinkElement,       // _apfnTearOff
    NULL                                    // _pAccelsRun
};


CLinkElement::CLinkElement(CDoc *pDoc)
      : CElement(ETAG_LINK, pDoc)
{
    _pStyleSheet = NULL;
    _fIsInitialized = FALSE;
    _readyStateLink = READYSTATE_UNINITIALIZED;
}

HRESULT
CLinkElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);
    *ppElementResult = new CLinkElement(pDoc);
    return *ppElementResult ? S_OK : E_OUTOFMEMORY;
}


//+----------------------------------------------------------------------------
//
//  Member:     CLinkElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-----------------------------------------------------------------------------

HRESULT
CLinkElement::PrivateQueryInterface ( REFIID iid, void ** ppv )
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_INHERITS2(this, IUnknown, IHTMLLinkElement)
        QI_HTML_TEAROFF(this, IHTMLElement2, NULL)
        QI_HTML_TEAROFF(this, IHTMLLinkElement, NULL)
        QI_HTML_TEAROFF(this, IHTMLLinkElement2, NULL)
        QI_HTML_TEAROFF(this, IHTMLLinkElement3, NULL)
        QI_TEAROFF_DISPEX(this, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     InvokeExReady
//
//  Synopsis  :this is only here to handle readyState queries, everything
//      else is passed on to the super
//
//+------------------------------------------------------------------------

#ifdef USE_STACK_SPEW
#pragma check_stack(off)
#endif

STDMETHODIMP
CLinkElement::ContextThunk_InvokeExReady(DISPID dispid,
                            LCID lcid,
                            WORD wFlags,
                            DISPPARAMS *pdispparams,
                            VARIANT *pvarResult,
                            EXCEPINFO *pexcepinfo,
                            IServiceProvider *pSrvProvider)
{
    IUnknown * pUnkContext;

    // Magic macro which pulls context out of nowhere (actually eax)
    CONTEXTTHUNK_SETCONTEXT

    HRESULT  hr = S_OK;

    hr = THR(ValidateInvoke(pdispparams, pvarResult, pexcepinfo, NULL));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(ReadyStateInvoke(dispid, wFlags, _readyStateFired, pvarResult));
    if (hr == S_FALSE)
    {
        hr = THR_NOTRACE(super::ContextInvokeEx(dispid,
                                         lcid,
                                         wFlags,
                                         pdispparams,
                                         pvarResult,
                                         pexcepinfo,
                                         pSrvProvider,
                                         pUnkContext ? pUnkContext : (IUnknown*)this));
    }

Cleanup:
    RRETURN(hr);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(on)
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CLinkElement::Notify
//
//  Synopsis:   Receive notifications
//
//----------------------------------------------------------------------------

void
CLinkElement::Notify(CNotification *pNF)
{
    super::Notify(pNF);
    switch (pNF->Type())
    {
    case NTYPE_STOP_1:
    case NTYPE_MARKUP_UNLOAD_1:
        if ( _pCssCtx )
            _pCssCtx->SetLoad( FALSE, NULL, FALSE );  // stop the directly linked stylesheet
        if ( _pStyleSheet )
            _pStyleSheet->StopDownloads( FALSE );  // if the directly linked sheet already came down,
        break;

    case NTYPE_BASE_URL_CHANGE:
        OnPropertyChange( DISPID_CLinkElement_href, 
                          ((PROPERTYDESC *)&s_propdescCLinkElementhref)->GetdwFlags(),
                          (PROPERTYDESC *)&s_propdescCLinkElementhref);
        break;
        
    case NTYPE_ELEMENT_ENTERTREE:
        if(!_fIsInitialized)
        {
            HRESULT hr;
            // (Jharding): I'm changing this to a HandleLinkedObjects, which is 
            // all the OnPropertyChange was doing, less firing the notification
            hr = HandleLinkedObjects();
            if (!hr)
                _fIsInitialized = TRUE;
        }
        else
        {
            // Insert the existing SS into this Markup
            CMarkup * pMarkup = GetMarkup();
            CStyleSheetArray * pStyleSheets = NULL;

            if (pMarkup && _pStyleSheet)
            {
                // Check for the temporary holding SSA
                if (_pSSATemp && (_pSSATemp == _pStyleSheet->GetSSAContainer()))
                {
                    _pSSATemp->ReleaseStyleSheet( _pStyleSheet, FALSE );

                    // The Temp SSA's work is now done.
                    _pSSATemp->CBase::PrivateRelease();
                    _pSSATemp = NULL;
                }

                THR(pMarkup->EnsureStyleSheets());

                pStyleSheets = pMarkup->GetStyleSheetArray();

                THR(pStyleSheets->AddStyleSheet(_pStyleSheet));
                THR(EnsureStyleDownload());

                // When exiting the tree the style rules are disable. Reenable them if they were
                //     not also disabled on the element.
                if(!GetAAdisabled())
                    IGNORE_HR(_pStyleSheet->ChangeStatus(CS_ENABLERULES, FALSE, NULL) );

            }
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        {
            CMarkup * pMarkup = GetMarkup();

            if (_pStyleSheet)
            {
                CStyleSheetArray * pStyleSheets = NULL;

                if (pMarkup && !(pNF->DataAsDWORD() & EXITTREE_DESTROY))
                    pStyleSheets = pMarkup->GetStyleSheetArray();

                // Tell the top-level stylesheet collection to let go of it's reference
                // Do NOT force a re-render (might be fatal if everyone's passivating around us)
                if (pStyleSheets)
                    pStyleSheets->ReleaseStyleSheet( _pStyleSheet, FALSE );
            }

            // unblock script execution
            if (_dwScriptDownloadCookie && pMarkup)
            {
                _markupCookie = pMarkup;
                _markupCookie->AddRef();
                pNF->SetSecondChanceRequested();
            }
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_2:

        if (_dwScriptDownloadCookie)
        {
            Assert(_markupCookie);
            _markupCookie->UnblockScriptExecution(&_dwScriptDownloadCookie);
            _dwScriptDownloadCookie = NULL;
            _markupCookie->Release();
        }
        break;

    }
}


//+---------------------------------------------------------------------------
//
//  Method:     CLinkElement::SetCssCtx
//
//+---------------------------------------------------------------------------
void
CLinkElement::SetCssCtx(CCssCtx * pCssCtx)
{
    if (_pCssCtx)
    {        
        _pCssCtx->SetProgSink(NULL); // detach download from document's load progress
        _pCssCtx->Disconnect();
        _pCssCtx->Release();

        if (!pCssCtx && _dwStyleCookie)
        {
            Doc()->LeaveStylesheetDownload(&_dwStyleCookie);
        }
    }

    _pCssCtx = pCssCtx;

    if (pCssCtx)
    {
        pCssCtx->AddRef();

        TraceTag( (tagStyleSheet, "Link - SetCssCtx [%p]--  in state [%x]", _pCssCtx, _pCssCtx->GetState()) );
        if (pCssCtx->GetState() & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED))
        {
            OnDwnChan(pCssCtx);
        }
        else
        {
            pCssCtx->SetProgSink(CMarkup::GetProgSinkHelper(GetMarkup()));
            pCssCtx->SetCallback(OnDwnChanCallback, this);
            pCssCtx->SelectChanges(DWNCHG_HEADERS|DWNCHG_COMPLETE, 0, TRUE);
        }
    }
}

//+------------------------------------------------------------------------
//
//  Method:     CLinkElement::OnDwnChan
//
//-------------------------------------------------------------------------
void
CLinkElement::OnDwnChan(CDwnChan * pDwnChan)
{
    Assert( !_pStyleSheet || GetThreadState() == _pStyleSheet->_pts );

    ULONG       ulState;
    CDoc *      pDoc = Doc();
    CMarkup *   pMarkup = GetMarkup();
    char *      pbBuffer = NULL;
    TCHAR *     pchSrc = NULL;
    HRESULT     hrParsing = S_OK;
    BOOL        fDoHeaders;

    Assert(pDoc);

    Assert( _pCssCtx && "Link - OnDwnChan called while _pCssCtx == NULL, possibely legacy callbacks" );      
    ulState  = _pCssCtx->GetState();
    fDoHeaders = (BOOL)(ulState & DWNLOAD_HEADERS);
    if (!fDoHeaders)
    {
        fDoHeaders = (ulState & DWNLOAD_COMPLETE) && !(ulState & DWNLOAD_HEADERS);
    }
    
    if (fDoHeaders && _pStyleSheet)
    {
        BOOL fGotLastMod = FALSE;
        FILETIME ft = {0};
        
        ft = _pCssCtx->GetLastMod();
        if (ft.dwHighDateTime == 0 && ft.dwLowDateTime == 0)
        {
            extern BOOL GetUrlTime(FILETIME *pt, const TCHAR *pszAbsUrl, CElement *pElem);
            fGotLastMod = GetUrlTime(&ft, _pStyleSheet->GetAbsoluteHref(), _pStyleSheet->_pParentElement);
        }
        else
            fGotLastMod = TRUE;
        
        if (fGotLastMod)
        {
            _pStyleSheet->GetSSS()->_ft = ft;
        }
#if DBG==1            
        else
        {   
            TraceTag( (tagSharedStyleSheet, "Link - OnDwnChan cannot get FILETIME from CssCtx") );
        }
#endif             
        
        _pStyleSheet->GetSSS()->_dwBindf = _pCssCtx->GetBindf();
        _pStyleSheet->GetSSS()->_dwRefresh = _pCssCtx->GetRefresh();
    }

    // try attach late
    if ((ulState & (DWNLOAD_COMPLETE | DWNLOAD_HEADERS)) && _pStyleSheet)
    {
        CSharedStyleSheetsManager *pSSSM = _pStyleSheet->GetSSS()->_pManager;
        CSharedStyleSheet *pSSS = NULL;
        if (pSSSM && !_pStyleSheet->GetSSS()->_fComplete)     
        {
            // try find a completed one            
            if (!(_pStyleSheet->GetSSS()->_ft.dwHighDateTime == 0 && _pStyleSheet->GetSSS()->_ft.dwLowDateTime == 0)
                && (S_OK == THR(_pStyleSheet->AttachByLastMod(pSSSM, NULL, &pSSS, FALSE)) )
               )
            {
                //
                // Stop downloading
                //
                TraceTag( (tagSharedStyleSheet, "link - attached - stop downloading") );
                if (!(ulState & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED)))
                {
                    _pCssCtx->SetLoad( FALSE, NULL, FALSE );
                    ulState |= DWNLOAD_COMPLETE;
                }
                Assert( pSSS );
                IGNORE_HR(_pStyleSheet->AttachByLastMod(pSSSM, pSSS, NULL, TRUE));
                _pStyleSheet->_eParsingStatus = CSSPARSESTATUS_DONE;
            }
        }
        //
        // else simply fall through...
        // 
    }

    // do parsing if necessary
    if (ulState & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED))
    {
        // TODO: remove all the if (_pStyleSheet) statement below
        Assert( _pStyleSheet );
        if (_pStyleSheet)
        {
            if (_pStyleSheet->_fComplete)
            {
                TraceTag( (tagSharedStyleSheet, "link - OnDwnChan called while _pStyleSheet->_fComplete is TRUE - skipover" ) );
                Assert( FALSE && "reenter - link ondwnchan");
                goto Cleanup;
            }
            _pStyleSheet->_fComplete = TRUE;
        }
        
        SetReadyStateLink(READYSTATE_COMPLETE);
        pDoc->LeaveStylesheetDownload(&_dwStyleCookie);

        if (ulState & DWNLOAD_COMPLETE)
        {
            BOOL fPendingRoot = FALSE;

            if (IsInMarkup())
                fPendingRoot = GetMarkup()->IsPendingRoot();

            // If unsecure download, may need to remove lock icon on Doc
            Doc()->OnSubDownloadSecFlags(fPendingRoot, _pCssCtx->GetUrl(), _pCssCtx->GetSecFlags());
            
            if (_pStyleSheet)
            {
                if (_pStyleSheet->_eParsingStatus != CSSPARSESTATUS_DONE)
                {
                    hrParsing = THR(_pStyleSheet->DoParsing(_pCssCtx));
                }
                Assert( SUCCEEDED(hrParsing) );
                if (S_OK == hrParsing)
                {
                    // (this is not always stable moment)
                    IGNORE_HR( OnCssChange(/*fStable = */ FALSE, /* fRecomputePeers = */TRUE) );
                }
            }
            else
                TraceTag((tagError, "CLinkElement::OnChan bitsctx failed to get file!"));
        }
        else
        {
            _pStyleSheet->EnsureCopyOnWrite(/*fDetachOnly*/TRUE, /*fWaitForCompletion*/FALSE);
            TraceTag((tagError, "CLinkElement::OnChan bitsctx failed to complete! ulState [%x]", ulState));
        }

        if (S_FALSE != hrParsing)
        {
            TraceTag( (tagSharedStyleSheet, "Link - parsing status == DONE Notify markup and parent, unblock script execution") );
            if (_pStyleSheet)
            {
                _pStyleSheet->CheckImportStatus();
                if (_dwScriptDownloadCookie)
                {
                    Assert (pMarkup);
                    pMarkup->UnblockScriptExecution(&_dwScriptDownloadCookie);
                    _dwScriptDownloadCookie = NULL;
                }
            }

            _pCssCtx->SetProgSink(NULL); // detach download from document's load progress
            SetCssCtx( NULL );           // No reason to hold on to the data anymore
        }
        //
        // else we should wait for callback...
        //
    }
    else 
       WHEN_DBG( if (!(ulState & DWNLOAD_HEADERS)) Assert( "Unknown result returned from CStyleSheet's bitsCtx!" && FALSE ) );

Cleanup:
    delete pbBuffer;
    delete pchSrc;
    return;
}


//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange
//
//  Note:       Called after a property has changed to notify derived classes
//              of the change.  All properties (except those managed by the
//              derived class) are consistent before this call.
//
//              Also, fires a property change notification to the site.
//
//-------------------------------------------------------------------------

HRESULT
CLinkElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr = S_OK;

    switch (dispid)
    {
    case DISPID_CLinkElement_href:
    case DISPID_CLinkElement_rel:
    case DISPID_CLinkElement_type:
        hr = HandleLinkedObjects();
        break;

    case DISPID_CElement_disabled:
        // Passing ChangeStatus() 0 means disable rules
        if(_pStyleSheet)
        {
            hr = THR( _pStyleSheet->ChangeStatus( GetAAdisabled() ? 0 : CS_ENABLERULES, FALSE, NULL ) );
            {
                hr = THR( OnCssChange(/*fStable = */ TRUE, /* fRecomputePeers = */TRUE) );
                if (hr)
                    goto Cleanup;
            }
        }
        break;

    case DISPID_CLinkElement_media:
        {
            if(_pStyleSheet)
            {
                LPCTSTR pcszMedia;

                if ( NULL == ( pcszMedia = GetAAmedia() ) )
                    pcszMedia = _T("all");

                hr = THR( _pStyleSheet->SetMediaType( TranslateMediaTypeString( pcszMedia ), FALSE ) );
                if ( !( OK( hr ) ) )
                    goto Cleanup;

                hr = THR( OnCssChange(/*fStable = */ TRUE, /* fRecomputePeers = */TRUE) );
                if (hr)
                    goto Cleanup;
            }
        }
        break;
    }

    if (OK(hr))
        hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLinkElement::SetActivity
//
//  Synopsis:   Turns activity on or off depending on visibility and
//              in-place activation.
//
//----------------------------------------------------------------------------

void
CLinkElement::SetActivity()
{
}

//--------------------------------------------------------------------------
//
//  Method:     CLinkElement::Passivate
//
//  Synopsis:   Shutdown main object by releasing references to
//              other objects and generally cleaning up.  This
//              function is called when the main reference count
//              goes to zero.  The destructor is called when
//              the reference count for the main object and all
//              embedded sub-objects goes to zero.
//
//              Release any event connections held by the form.
//
//--------------------------------------------------------------------------

void
CLinkElement::Passivate(void)
{
    SetCssCtx(NULL);

    if (_pStyleSheet)
    {
        // Removed from StyleSheetArray in the ExitTree notification

        // Halt all stylesheet downloading.
        _pStyleSheet->StopDownloads( TRUE );

        // Let go of our reference
        _pStyleSheet->Release();
        _pStyleSheet = NULL;
    }

    if (_pSSATemp)
    {
        _pSSATemp->Release();
        _pSSATemp = NULL;
    }
  
    super::Passivate();
}

//--------------------------------------------------------------------------
//
//  Method:     CLinkElement::HandleLinkedObjects()
//
//  Helper called by OnPropertyChange.  Checks whether the attribute
//  values on the link tag require us to link to a stylesheet, and
//  does the appropriate stylesheet creation/release.
//
//--------------------------------------------------------------------------

HRESULT
CLinkElement::HandleLinkedObjects(void)
{
    HRESULT     hr = S_OK;
    CDoc *      pDoc = Doc();
    CMarkup *   pMarkup;
    LPCTSTR     szUrl = GetAAhref();
    LPCTSTR     pcszRel;
    LINKTYPE    linktype;
    CStyleSheetArray *pStyleSheets;
    CStyleSheetCtx  ctxSS;

    pMarkup = GetMarkup();

    Assert (pDoc);

    if (pMarkup)
    {
        pStyleSheets = pMarkup->GetStyleSheetArray();
    }
    else
    {
        pStyleSheets = _pSSATemp;
    }

    linktype = GetLinkType();

    if (LINKTYPE_STYLESHEET != linktype || !szUrl || !(*szUrl))
    {
        // If we get here, it means the attributes on the LINK do not qualify it as
        // a linked stylesheet.  We check if we have a current linked stylesheet, and
        // let it go, forcing a re-render.

        if (_pStyleSheet)
        {
            Assert(pStyleSheets);
            hr = THR(pStyleSheets->ReleaseStyleSheet(
                    _pStyleSheet,
                    TRUE));
            if (hr)
                goto Cleanup;

            _pStyleSheet->Release();
            _pStyleSheet = NULL;

            if (_pSSATemp)
            {
                Assert(!pMarkup);
                _pSSATemp->Release();
                _pSSATemp = NULL;
            }
        }

        if (LINKTYPE_P3PV1POLICYREF == linktype)
        {
            if (pMarkup && pDoc && szUrl && *szUrl)
            {
                TCHAR   cBuf[pdlUrlLen];
                hr = THR(CMarkup::ExpandUrl(pMarkup, szUrl, ARRAY_SIZE(cBuf), cBuf, this));
                THR(pDoc->AddToPrivacyList(CMarkup::GetUrl(pMarkup), cBuf, (DWORD)PRIVACY_URLHASPOLICYREFLINK));
            }
            goto Cleanup;
        }

        if(LINKTYPE_STYLESHEET != linktype)
            goto Cleanup; // done
        // Fall through for the empty href case, some pages need to have an empty stylesheet 
    }

    // If we get here, it means the attributes on the LINK qualify it as a linked stylesheet.
    SetReadyStateLink( READYSTATE_LOADING );

    ctxSS._pParentElement    = this;
    ctxSS._dwCtxFlag         = STYLESHEETCTX_SHAREABLE | STYLESHEETCTX_REUSE;
    ctxSS._szUrl             = szUrl;

    // If we're already ref'ing a stylesheet, then it means that the HREF changed (most likely)
    // or there was no TYPE property and now there is (unlikely, in which case the following work
    // is wasted).  We reload our current stylesheet object with the href.
    if ( _pStyleSheet )
    {
        // If we're in designMode and the don't downloadCSS flag is set on the doc
        // then don't initiate download.  Probably thicket saving.
        if (!(IsDesignMode() && pDoc->_fDontDownloadCSS))
        {
            hr = _pStyleSheet->LoadFromURL( &ctxSS, TRUE );
        }
    }
    // We aren't already ref'ing a stylesheet, so we need a new stylesheet object.
    else
    {
        long nSSInHead = -1;        // default to append

        if (pMarkup)
        {
            hr = pMarkup->EnsureStyleSheets();
            if ( hr )
                goto Cleanup;

            // Figure out where this <link> stylesheet lives (i.e. what should its index in the
            // stylesheet collection be?).  We only need to do this if we are turning an existing
            // link into a stylesheet link -- if this link is in the process of being constructed
            // then we're guaranteed the stylesheet belongs at the end.

            if ( _fIsInitialized )
            {
                Assert( pMarkup );
                CTreeNode *pNode;
                CLinkElement *pLink;
                CStyleElement *pStyle;

                Assert( pMarkup->GetHeadElement() );

                nSSInHead = 0;
            
                CChildIterator ci ( pMarkup->GetHeadElement() );

                while ( (pNode = ci.NextChild() ) != NULL )
                {
                    if ( pNode->Tag() == ETAG_LINK )
                    {
                        pLink = DYNCAST( CLinkElement, pNode->Element() );
                        if ( pLink == this )
                            break;
                        else if ( pLink->_pStyleSheet ) // faster than IsLinkedStyleSheet() and adequate here
                            ++nSSInHead;
                    }
                    else if ( pNode->Tag() == ETAG_STYLE )
                    {
                        pStyle = DYNCAST( CStyleElement, pNode->Element() );
                        if ( pStyle->_pStyleSheet ) // Not all STYLE elements create a SS.
                            ++nSSInHead;
                    }
                }
            }

            pStyleSheets = pMarkup->GetStyleSheetArray();
        }
        else
        {
            if (!_pSSATemp)
            {
                pStyleSheets = new CStyleSheetArray( NULL, NULL, 0 );
                if (!pStyleSheets || pStyleSheets->_fInvalid )
                {
                    hr = E_OUTOFMEMORY;
                    goto Cleanup;
                }
                _pSSATemp = pStyleSheets;
            }
            else
                pStyleSheets = _pSSATemp;

            nSSInHead = pStyleSheets->Size();
        }

        hr = pStyleSheets->CreateNewStyleSheet(&ctxSS, &_pStyleSheet, nSSInHead);
        if (!SUCCEEDED(hr))
            goto Cleanup;

        _pStyleSheet->AddRef(); // since the link elem is hanging onto the stylesheet ptr
                                // Note this results in a subref on us.
        if (hr == S_FALSE)
        {
            hr = S_OK;
            if ( szUrl && szUrl[0] )
            {
                hr = EnsureStyleDownload();
            }
            else
            {
                _pStyleSheet->GetSSS()->_fComplete = TRUE;
            }
        }
        else if (hr == S_OK)
        {
            Assert(_pStyleSheet);
            // (this is not always stable moment)
            IGNORE_HR( OnCssChange(/*fStable = */ FALSE, /* fRecomputePeers = */TRUE) );
            // _pStyleSheet might be freed by OnCssChange
            if(_pStyleSheet)
                _pStyleSheet->CheckImportStatus();
        }
    }

    pcszRel = GetAArel();
    if ( GetAAdisabled() || ( pcszRel && !StrCmpIC(_T("alternate stylesheet"), pcszRel ) ) )
    {
        hr = THR( _pStyleSheet->ChangeStatus( 0, FALSE, NULL ) );   // 0 means disable rules
    }

Cleanup:
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CLinkElement::EnsureStyleDownload
//
//----------------------------------------------------------------------------

HRESULT
CLinkElement::EnsureStyleDownload()
{
    HRESULT     hr = S_OK;
    CDoc *      pDoc = Doc();
    CCssCtx *  pCssCtx = NULL;
    BOOL fPendingRoot = FALSE;

    if (IsInMarkup())
        fPendingRoot = GetMarkup()->IsPendingRoot();

    Assert( _pStyleSheet->GetSSS() );

    if (_pStyleSheet->_fComplete)
    {
        TraceTag( (tagStyleSheet, "Link [%p] - EnsureStyelDownload [%p]-- stylesheet is already completed", this, _pStyleSheet) );
        IGNORE_HR( OnCssChange(/*fStable = */ FALSE, /* fRecomputePeers = */TRUE) );
        goto Cleanup;
    }

    hr = THR(pDoc->NewDwnCtx(DWNCTX_CSS, _pStyleSheet->GetAbsoluteHref(),
                this, (CDwnCtx **)&pCssCtx, fPendingRoot));
    if(hr)
        goto Cleanup;

    pDoc->EnterStylesheetDownload(&_dwStyleCookie);

    if (IsInMarkup())
    {
        GetMarkup()->BlockScriptExecution(&_dwScriptDownloadCookie);
        Assert (_dwScriptDownloadCookie);
    }

    SetCssCtx(pCssCtx);                                   // Save the bits context

    if (pCssCtx)
        pCssCtx->Release();
    
Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CLinkElement::OnReadyStateChange
//
//----------------------------------------------------------------------------

void
CLinkElement::OnReadyStateChange()
{   // do not call super::OnReadyStateChange here - we handle firing the event ourselves
    SetReadyStateLink(_readyStateLink);
}

//+------------------------------------------------------------------------
//
//  Member:     CLinkElement::SetReadyStateLink
//
//  Synopsis:   Use this to set the ready state;
//              it fires OnReadyStateChange if needed.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CLinkElement::SetReadyStateLink(long readyStateLink)
{
    TraceTag( (tagStyleSheet, "[%p] set readystate [%x] - complete is %x", this, readyStateLink, READYSTATE_COMPLETE) );
    
    long readyState;
    
    _readyStateLink = readyStateLink;

    readyState = min ((long)_readyStateLink, super::GetReadyState());

    if ((long)_readyStateFired != readyState)
    {
        _readyStateFired = readyState;

        GWPostMethodCall(this,
            ONCALL_METHOD (CLinkElement, DeferredFireEvent, deferredfireevent),
            (DWORD_PTR) &s_propdescCElementonreadystatechange, FALSE, "CLinkElement::DeferredFireEvent");

        if (_readyStateLink == READYSTATE_COMPLETE)
        {
            GWPostMethodCall(this,
                ONCALL_METHOD (CLinkElement, DeferredFireEvent, deferredfireevent),
                (DWORD_PTR) &s_propdescCLinkElementonload, FALSE, "CLinkElement::DeferredFireEvent");
        }
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CLinkElement:get_readyState
//
//+------------------------------------------------------------------------------

HRESULT
CLinkElement::get_readyState(BSTR * p)
{
    HRESULT hr = S_OK;

    if ( !p )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR( s_enumdeschtmlReadyState.StringFromEnum(_readyStateFired, p) );

Cleanup:
    RRETURN( SetErrorInfo(hr) );
}

HRESULT
CLinkElement::get_readyState(VARIANT * pVarRes)
{
    HRESULT hr = S_OK;

    if (!pVarRes)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = get_readyState(&V_BSTR(pVarRes));
    if (!hr)
        V_VT(pVarRes) = VT_BSTR;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


HRESULT
CLinkElement::get_readyStateValue(long *plRetValue)
{
    HRESULT     hr = S_OK;

    if (!plRetValue)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    *plRetValue = _readyStateFired;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+----------------------------------------------------------------------------
//
//  Member:     CLinkElement:get_styleSheet
//
//+------------------------------------------------------------------------------

HRESULT
CLinkElement::get_styleSheet(IHTMLStyleSheet** ppHTMLStyleSheet)
{
    HRESULT hr = S_OK;

    if (!ppHTMLStyleSheet)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppHTMLStyleSheet = NULL;

    if ( _pStyleSheet )
    {
        hr = _pStyleSheet->QueryInterface(IID_IHTMLStyleSheet,
                                              (void**)ppHTMLStyleSheet);
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}



//+----------------------------------------------------------------------------
//
//  Member:     CLinkElement::GetLinkType
//
//  Tests the attributes of the LINK element to determine what type link this is
//
//+------------------------------------------------------------------------------

CLinkElement::LINKTYPE
CLinkElement::GetLinkType()
{
    LPCTSTR     pchHref = GetAAhref();
    LPCTSTR     pchRel = GetAArel();
    LPCTSTR     pchType = GetAAtype();
    CTreeNode * pNodeContext = GetFirstBranch();

    if (!pNodeContext || (!IsInMarkup() &&
        pNodeContext->Parent()->Tag() == ETAG_HEAD))
        return LINKTYPE_UNKNOWN;

    if (pchHref && pchRel)
    {
        if (0 == StrCmpIC(_T("stylesheet"), pchRel) ||          // if rel = "stylesheet"
            0 == StrCmpIC(_T("alternate stylesheet"), pchRel))  // or rel = "alternate stylesheet"
        {
            if (!pchType || 0 == StrCmpIC(_T("text/css"), pchType)) // if type = "text/css"
            {
                return LINKTYPE_STYLESHEET;                     // this is a stylesheet link
            }
        }

        if (0 == StrCmpIC(_T("P3Pv1"), pchRel))                 // if rel = "P3Pv1"
        {
            return LINKTYPE_P3PV1POLICYREF;
        }
    }

    return LINKTYPE_UNKNOWN;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\enoshow.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       eshow.cxx
//
//  Contents:   CNoShowElement
//
//  History:    15-Jul-1996     AnandRa     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ENOSHOW_HXX_
#define X_ENOSHOW_HXX_
#include "enoshow.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#define _cxx_
#include "noshow.hdl"

MtDefine(CNoShowElement, Elements, "CNoShowElement")
MtDefine(CShowElement, Elements, "CShowElement")

//+------------------------------------------------------------------------
//
//  Class:      CNoShowElement
//
//  Synopsis:   
//
//-------------------------------------------------------------------------

const CElement::CLASSDESC CNoShowElement::s_classdesc =
{
    {
        &CLSID_HTMLNoShowElement,           // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLNoShowElement,            // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnIHTMLNoShowElement,

    NULL                                    // _pAccelsRun
};


HRESULT
CNoShowElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);
    *ppElementResult = new CNoShowElement(pht->GetTag(), pDoc);

    return (*ppElementResult ? S_OK : E_OUTOFMEMORY);
}

//+---------------------------------------------------------------------------
//
//  Member:     CNoShowElement::Save
//
//  Synopsis:   called twice: for opening <NOFRAMES> and for </NOFRAMES>.
//
//----------------------------------------------------------------------------

HRESULT
CNoShowElement::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    HRESULT hr;

    hr = THR(super::Save(pStreamWrBuff, fEnd));
    if (hr)
        goto Cleanup;

    if (!fEnd && !pStreamWrBuff->TestFlag(WBF_SAVE_PLAINTEXT))
    {
        DWORD dwOldFlags = pStreamWrBuff->ClearFlags(WBF_ENTITYREF);

        pStreamWrBuff->SetFlags(WBF_KEEP_BREAKS | WBF_NO_WRAP);

        if (_cstrContents.Length())
        {
            hr = THR(pStreamWrBuff->Write(_cstrContents));
            if (hr)
                goto Cleanup;
        }

        pStreamWrBuff->RestoreFlags(dwOldFlags);
    }

Cleanup:

    RRETURN1(hr, S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\elist.cxx ===
//+---------------------------------------------------------------------
//
//   File:      eolist.cxx
//
//  Contents:   List Element class (OL, DL, UL, MENU, DIR
//
//  Classes:    CListElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ELIST_HXX_
#define X_ELIST_HXX_
#include "elist.hxx"
#endif

#ifndef X_EDLIST_HXX_
#define X_EDLIST_HXX_
#include "edlist.hxx"
#endif

#ifndef X_ELI_HXX_
#define X_ELI_HXX_
#include "eli.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X__DOC_H_
#define X__DOC_H_
#include "_doc.h"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "list.hdl"

MtDefine(CListElement, Elements, "CListElement")

const CElement::CLASSDESC CListElement::s_classdesc =
{
    {
        &CLSID_HTMLListElement,             // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLListElement,              // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnIHTMLListElement,         // apfnTearOff

    NULL                                    // _pAccelsRun
};

//+------------------------------------------------------------------------
//
//  Member:     CListElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CListElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_HTML_TEAROFF(this, IHTMLListElement2, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Member:     CListElement::ApplyDefaultFormat
//
//  Synopsis:   Applies default formatting properties for that element to
//              the char and para formats passed in
//
//  Arguments:  pCFI - Format Info needed for cascading
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CListElement::ApplyDefaultFormat (CFormatInfo *pCFI)
{
    HRESULT hr;
    BOOL fInList;
    WORD wLevel;

    // Don't inherit list-style-type property for list elements.
    // They have their own type defined.
    pCFI->PrepareParaFormat();
    pCFI->_pf().SetListStyleType(styleListStyleTypeNotSet);
    pCFI->UnprepareForDebug();

    // We need to do this first for list elements in order to determine if
    // this is an inside or outside bullet style.  We carefully check before
    // overriding margins or anything else, to see if the properties have already
    // been set by stylesheets, et al.
    hr = THR(super::ApplyDefaultFormat(pCFI));
    if(hr)
        goto Cleanup;

    fInList = pCFI->_ppf->_cListing.IsInList();
    wLevel  = (WORD)pCFI->_ppf->_cListing.GetLevel();

    pCFI->PrepareParaFormat();

    // NOTE (paulnel): we need direction added here because ApplyInnerOuterFormat
    // is not applied until later.
    pCFI->_pf()._fRTLInner = pCFI->_pcf->_fRTL;

    // Other tags interfere with level for DLs. This is necessary for Netscape
    // compatibility because <UL><LI><DL> only causes one level of indentation
    // instead of two. Basically, we reset the level for DLs whenever they're
    // the first nested tag under another type of nested list.
    if (ETAG_DL == Tag() && pCFI->_pf()._fResetDLLevel)
        wLevel = 0;

    // Note that we DO need to indent for DLs after the first one.
    if (ETAG_DL != Tag() || wLevel > 0)
    {
        // Don't inherit any numbering attributes.
        pCFI->_pf()._cListing.Reset();

        pCFI->PrepareFancyFormat();

        BYTE    side;
        side = !pCFI->_ppf->HasRTL(TRUE) ? SIDE_LEFT : SIDE_RIGHT;
        side = !pCFI->_pcf->HasVerticalLayoutFlow() ? side : (++side % SIDE_MAX);

        const CUnitValue &uvSideMargin = pCFI->_ff().GetMargin(side);

        if (    uvSideMargin.IsNullOrEnum()
            &&  (   !HasMarkupPtr() 
                ||  !GetMarkupPtr()->IsStrictCSS1Document() 
                ||  !pCFI->_ff().HasExplicitMargin(side) 
                ||  uvSideMargin.GetUnitType() != CUnitValue::UNIT_ENUM 
                ||  uvSideMargin.GetUnitValue() != styleAutoAuto    ) 
            )
        {
            CUnitValue uv;
            uv.SetPoints(LIST_INDENT_POINTS);
            pCFI->_ff().SetMargin(side, uv);
        }

        pCFI->_ff()._fHasMargins = TRUE;

        if (++wLevel < CListing::MAXLEVELS)
        {
            pCFI->_pf()._cListing.SetLevel(wLevel);
        }

        // Default index style.
        pCFI->_pf()._cListing.SetStyle(FilterHtmlListType(styleListStyleTypeNotSet, wLevel));
    }

    if (ETAG_DL == Tag())
    {
        // DLs have a level, but our normal mechanism above is short
        // circuited because we've combined it with indentation. This is 
        // done for Netscape compatibility.
        if (!wLevel)
        {
            // Paranoid assumption that the maximum allowable levels
            // might actually be zero.
            if (++wLevel < CListing::MAXLEVELS)
            {
                pCFI->_pf()._cListing.SetLevel(wLevel);
            }

            pCFI->_pf()._fResetDLLevel = FALSE;
        }

        // Check to see if the compact flag is set.  If so, set a bit in the para format.
        VARIANT_BOOL fCompact = FALSE;
        IGNORE_HR(this->get_PropertyHelper( &fCompact, (PROPERTYDESC *)&s_propdescCListElementcompact ) );
        pCFI->_pf()._fCompactDL = fCompact;
    }
    else
    {
        // all lists other than DL cause some indent by default. So, if there is
        // an li in the the list, then the bullet is drawn in the indent. For DL
        // there is no indent so do not set offset. This case is handled in
        // MeasureListIndent.
        if (pCFI->_pf()._bListPosition != styleListStylePositionInside)
            pCFI->_pf()._cuvOffsetPoints.SetPoints(LIST_FIRST_REDUCTION_POINTS);

        pCFI->_pf()._fResetDLLevel = TRUE;
    }

    pCFI->UnprepareForDebug();

    // Spacing is different within lists than without.
    ApplyListFormats(pCFI, fInList ? 0 : -1);

    pCFI->PrepareParaFormat();

    pCFI->_pf()._cListing.SetInList();

    // set up for potential EMs, ENs, and ES Conversions
    pCFI->_pf()._lFontHeightTwips = pCFI->_pcf->GetHeightInTwips(Doc());
    if (pCFI->_pf()._lFontHeightTwips <=0)
        pCFI->_pf()._lFontHeightTwips = 1;

    pCFI->UnprepareForDebug();

Cleanup:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Member:     FilterHtmlListType()
//
//  Returns:    Return the perferred htmlListType
//
//------------------------------------------------------------------------

styleListStyleType
CListElement::FilterHtmlListType(styleListStyleType type, WORD wLevel)
{
    return type;
}

//+-----------------------------------------------------------------------
//
//  Member:     Notify()
//
//  Returns:    Trap exit and enter tree's to invalidate the index caches
//
//------------------------------------------------------------------------
void
CListElement::Notify(CNotification *pNF)
{
    super::Notify(pNF);
    NOTIFYTYPE  ntype = pNF->Type();

    if (ntype == NTYPE_ELEMENT_EXITTREE_1)
    {
        if (!(pNF->DataAsDWORD() & EXITTREE_DESTROY))
        {
            CMarkup *pMarkup = GetMarkup();
            Assert (pMarkup);
            if (!pMarkup)
                goto Cleanup;
            
            CTreeNode *pListNode = pMarkup->FindMyListContainer(GetFirstBranch());
            if (pListNode)
            {
                CListElement *pListElement = DYNCAST(CListElement, pListNode->Element());

                // Invalidate my container so that it has 1 + max of my version and its
                // version. This way we are sure that all my containing LI's will
                // surely be invalid in my container.
                pListElement->_dwVersion = max(_dwVersion, pListElement->_dwVersion) + 1;
            }
        }
    }
    else if (ntype == NTYPE_ELEMENT_ENTERTREE)
    {
        CMarkup *pMarkup = GetMarkup();
        Assert (pMarkup);
        if (!pMarkup)
            goto Cleanup;
        
        CTreeNode *pListNode = pMarkup->FindMyListContainer(GetFirstBranch());
        if (pListNode)
        {
            CListElement *pListElement = DYNCAST(CListElement, pListNode->Element());

            // Update my version number to be the version number of the parent OL + 1
            // so that both, LI's inside me and inside my containing OL are invalidated.
            pListElement->UpdateVersion();
            _dwVersion = pListElement->_dwVersion;
        }
        else
        {
            // If we have _thrown_ an OL around existing LI's then we have to nuke
            // the version numbers of all such LI's since they are invalid now.
            CListItemIterator ci(this, NULL);
            CTreeNode *pNode;
            
            while ((pNode = ci.NextChild()) != NULL)
            {
                CLIElement *pLIElement = DYNCAST(CLIElement, pNode->Element());
                pLIElement->_ivIndex._dwVersion = 0;
            }

            // Finally nuke the OL's version number too!
            _dwVersion = 0;
        }
    }

Cleanup:
    return;
}


static ELEMENT_TAG g_etagChildrenNoRecurse[] = {ETAG_OL, ETAG_UL, ETAG_DL, ETAG_DIR, ETAG_MENU, ETAG_LI};
static ELEMENT_TAG g_etagInterestingChildren[] = {ETAG_LI};
    // Removed CHILDITERATOR_DEEP since USETAGS implies deep and giving both _USETAGS+_DEEP confuses
    // the iterator.
static const DWORD LI_ITERATE_FLAGS=(CHILDITERATOR_USETAGS); // Use the lists to stop recursion
CListItemIterator::CListItemIterator(CListElement *pElementContainer, CElement *pElementStart)
            :CChildIterator(pElementContainer,
                            pElementStart,
                            LI_ITERATE_FLAGS,
                            &g_etagChildrenNoRecurse[0],     // Do NOT recurse into these children
                            sizeof(g_etagChildrenNoRecurse) / sizeof(g_etagChildrenNoRecurse[0]),
                            &g_etagInterestingChildren[0],   // Return all of these kinds of children to me
                            sizeof(g_etagInterestingChildren) / sizeof(g_etagInterestingChildren[0])
                           )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\emap.cxx ===
//=-----------------------------------------------------------=
//
// File:        emap.cxx
//
// Contents:    Map element class
//
// Classes:     CMapElement
//              CAreasCollection
//
//=-----------------------------------------------------------=

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_EAREA_HXX_
#define X_EAREA_HXX_
#include "earea.hxx"
#endif

#ifndef X_EMAP_HXX_
#define X_EMAP_HXX_
#include "emap.hxx"
#endif

#ifndef X_CSIMUTIL_HXX_
#define X_CSIMUTIL_HXX_
#include "csimutil.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#define _cxx_
#include "map.hdl"

MtDefine(CMapElement, Elements, "CMapElement")
MtDefine(CAreasCollection, Tree, "CAreasCollection")
MtDefine(BldMapAreasCol, PerfPigs, "Build CMapElement::AREAS_COLLECTION")

const CElement::CLASSDESC CMapElement::s_classdesc =
{
    {
        &CLSID_HTMLMapElement,              // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLMapElement,               // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnIHTMLMapElement,          // _pfnTearOff

    NULL                                    // _pAccelsRun
};

CMapElement::CMapElement(CDoc *pDoc)
    : CElement(ETAG_MAP, pDoc)
{
#ifdef WIN16
    m_baseOffset = ((BYTE *) (void *) (CBase *)this) - ((BYTE *) this);
    m_ElementOffset = ((BYTE *) (void *) (CElement *)this) - ((BYTE *) this);
#endif
}

//=-----------------------------------------------------------------------=
//
// Function:    CreateElement
//
// Synopsis:    Creates an instance of the given element's class
//
// Arguments:   CHtmTag *pst - struct for creation info
//              CElement *pElementParent - Parent of new element
//              CElement **ppElement - Return ptr to element in *ppElement.
//
//=-----------------------------------------------------------------------=
HRESULT
CMapElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_MAP));
    Assert(ppElement);

    *ppElement = new CMapElement(pDoc);

    return *ppElement ? S_OK : E_OUTOFMEMORY;
}


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//      Destructor, and pasivate
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

CMapElement::~CMapElement()
{
    delete _pCollectionCache;
}


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//      Notification
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

void
CMapElement::Notify(CNotification *pNF)
{
    CMarkup * pMarkup;

    super::Notify(pNF);

    switch (pNF->Type())
    {
        case NTYPE_ELEMENT_ENTERTREE:
        {
            pMarkup = GetMarkup();
            Assert(pMarkup);
            _pMapNext = pMarkup->GetMapHead();
            pMarkup->SetMapHead(this);
            break;
        }

        case NTYPE_ELEMENT_EXITTREE_1:
        {
            CMapElement ** ppMap, *pMap;

            pMarkup = GetMarkup(); Assert(pMarkup);
            Assert( pMarkup->HasEditContext() && pMarkup->GetMapHead() );
            for ( ppMap = &( pMarkup->GetEditContext()->_pMapHead ); (pMap = *ppMap) != NULL; ppMap = &pMap->_pMapNext)
            {
                if (pMap == this)
                {
                    *ppMap = _pMapNext;
                    break;
                }
            }
            AssertSz(pMap == this, "Can't find CMapElement in CMarkupEditContext::_pMapHead list");
            break;
        }
    }
}


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//      Containment Checking
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

//=-----------------------------------------------------------------------=
//
// Function:    GetAreaContaining
//
// Synopsis:    Gives the area in the map that contains the given point,
//                  if there is an area that contains it.  If the point
//                  is not contained within an area, it sets it to NULL.
//                  If an area is found, returns S_OK, if not, E_FAIL.
//
// Arguments:   POINT pt - The point for which to check containment.
//              CAreaElement **parea - Area (if any) containing the point
//                  is stored in *parea.
//
//=-----------------------------------------------------------------------=

HRESULT
CMapElement::GetAreaContaining(POINT pt, long *plIndex)
{
    CChildIterator ci(this, NULL, CHILDITERATOR_DEEP);
    CTreeNode * pNode;
    CAreaElement * pArea;
    LONG lIndex = 0;

    while ((pNode = ci.NextChild()) != NULL)
    {
        if (pNode->Tag() == ETAG_AREA)
        {
            pArea = DYNCAST(CAreaElement, pNode->Element());

            if (Contains(pt, pArea->_coords, pArea->_nShapeType))
            {
                *plIndex = lIndex;
                return S_OK;
            }

            lIndex += 1;
        }
    }

    *plIndex = -1;
    return S_OK;
}


//=-----------------------------------------------------------------------=
//
// Function:    GetAreaContaining
//
// Synopsis:    Gives the area in the map that contains the given point,
//                  if there is an area that contains it.  If the point
//                  is not contained within an area, it sets it to NULL.
//                  If an area is found, returns S_OK, if not, E_FAIL.
//
//=-----------------------------------------------------------------------=

HRESULT
CMapElement::GetAreaContaining(long lIndex, CAreaElement **ppArea)
{
    CChildIterator ci(this, NULL, CHILDITERATOR_DEEP);
    CTreeNode * pNode;

    *ppArea = NULL;
    while (lIndex >= 0 && (pNode = ci.NextChild()) != NULL)
    {
        if (pNode->Tag() == ETAG_AREA)
        {
            if (lIndex == 0)
            {
                *ppArea = DYNCAST(CAreaElement, pNode->Element());
                return S_OK;
            }

            lIndex -= 1;
        }
    }

    return E_FAIL;
}

LONG
CMapElement::GetAreaCount()
{
    CChildIterator ci(this, NULL, CHILDITERATOR_DEEP);
    CTreeNode * pNode;
    LONG lCount = 0;

    while ((pNode = ci.NextChild()) != NULL)
    {
        if (pNode->Tag() == ETAG_AREA)
        {
            lCount += 1;
        }
    }

    return lCount;
}

HRESULT
CMapElement::GetAreaTabs(long *pTabs, long c)
{
    CChildIterator ci(this, NULL, CHILDITERATOR_DEEP);
    CTreeNode * pNode;

    while ((pNode = ci.NextChild()) != NULL)
    {
        if (pNode->Tag() == ETAG_AREA)
        {
            if (c == 0)
            {
                AssertSz(0, "Requesting more tabs than there are AREA elements");
                return E_FAIL;
            }

            *pTabs++ = DYNCAST(CAreaElement, pNode->Element())->GetAAtabIndex();
            c -= 1;
        }
    }

    return S_OK;
}

//=-----------------------------------------------------------------------=
//
// Function:    CMapElement::SearchArea
//
// Synopsis:    Search for the given area, returning it's index
//
//=-----------------------------------------------------------------------=

HRESULT
CMapElement::SearchArea(CAreaElement *pAreaFind, long *plIndex)
{
    CChildIterator ci(this, NULL, CHILDITERATOR_DEEP);
    CTreeNode * pNode;
    CAreaElement * pArea;
    LONG lIndex = 0;

    while ((pNode = ci.NextChild()) != NULL)
    {
        if (pNode->Tag() == ETAG_AREA)
        {
            pArea = DYNCAST(CAreaElement, pNode->Element());

            if (pArea == pAreaFind)
            {
                *plIndex = lIndex;
                return S_OK;
            }
        }

        lIndex += 1;
    }

    *plIndex = 0;
    return E_FAIL;
}


//=-----------------------------------------------------------------------=
//
// Function:    GetBoundingRect
//
// Synopsis:    Returns the bounding rectangle for the map, computed as
//              union of the bounding rectangles of the <AREA>s in it.
//
//=-----------------------------------------------------------------------=
void
CMapElement::GetBoundingRect(RECT *prc)
{
    CChildIterator ci(this, NULL, CHILDITERATOR_DEEP);
    CTreeNode * pNode;
    RECT rcArea, rcTemp;

    SetRectEmpty(prc);

    while ((pNode = ci.NextChild()) != NULL)
    {
        if (pNode->Tag() == ETAG_AREA)
        {
            DYNCAST(CAreaElement, pNode->Element())->GetBoundingRect(&rcArea);
            CopyRect(&rcTemp, prc);
            UnionRect(prc, &rcTemp, &rcArea);
        }
    }
}


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//      Drawing Related Code
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////

//=------------------------------------------------------------------------=
//
// Function:    Draw
//
// Synopsis:    Refreshes all the areas on the map
//
// Arguments:   HDC hDC - The DC to draw into
//              RECT rc - The rectangle of the image site calling me
//
//=------------------------------------------------------------------------=
HRESULT
CMapElement::Draw(CFormDrawInfo * pDI, CElement * pImg)
{
    CChildIterator  ci(this, NULL, CHILDITERATOR_DEEP);
    CTreeNode *     pNode;
    HPEN            hpenOld;
    HBRUSH          hbrOld;
    int             nROPOld;
    XHDC            hdc = pDI->GetDC(TRUE);
    
    // Should come here only in edit mode
    Assert(pImg && pImg->IsEditable(TRUE));

    nROPOld = SetROP2(hdc, R2_XORPEN);
    hpenOld = (HPEN)SelectObject(hdc, GetStockObject(WHITE_PEN));
    hbrOld  = (HBRUSH)SelectObject(hdc, GetStockObject(HOLLOW_BRUSH));
    
    while ((pNode = ci.NextChild()) != NULL)
    {
        if (pNode->Tag() == ETAG_AREA)
        {
            DYNCAST(CAreaElement, pNode->Element())->Draw(pDI, pImg);
        }
    }

    SelectObject(hdc, hpenOld);
    SelectObject(hdc, hbrOld);
    SetROP2(hdc, nROPOld);

    return S_OK;
}


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//      Area Collection Code
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
HRESULT
CMapElement::EnsureCollectionCache()
{
    HRESULT hr = S_OK;

    if ( ! _pCollectionCache )
    {
        _pCollectionCache =
            new CCollectionCache(
                this,
                GetWindowedMarkupContext(),
                ENSURE_METHOD(CMapElement, EnsureAreaCollection, ensureareacollection),
                CREATECOL_METHOD(CMapElement, CreateAreaCollection, createareacollection),
                NULL,
                ADDNEWOBJECT_METHOD(CMapElement, AddNewArea, addnewarea));

        if (!_pCollectionCache)
            goto MemoryError;

        hr = THR(_pCollectionCache->InitReservedCacheItems(1));
        if (hr)
            goto Cleanup;

    }

    hr = THR(_pCollectionCache->EnsureAry(AREA_ELEMENT_COLLECTION));

Cleanup:
    if (hr && _pCollectionCache)
    {
        delete _pCollectionCache;
        _pCollectionCache = NULL;
    }    
    RRETURN(SetErrorInfo(hr));

MemoryError:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

HRESULT BUGCALL
CMapElement::CreateAreaCollection(IDispatch ** ppIEC, long lIndex)
{
    HRESULT             hr = S_OK;
    CAreasCollection *  pobj;

    pobj = new CAreasCollection(_pCollectionCache, lIndex);
    if (!pobj)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pobj->QueryInterface(IID_IDispatch, (void **) ppIEC));
    pobj->Release();
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN(hr);
}

HRESULT BUGCALL
CMapElement::EnsureAreaCollection(long lIndex, long * plCollectionVersion)
{
    CTreeNode *     pNode;
    HRESULT         hr = S_OK;
    CMarkup *       pMarkup = GetMarkup();

    *plCollectionVersion = NULL;

    // Nothing to do so get out.
    if (pMarkup && *plCollectionVersion == pMarkup->GetMarkupTreeVersion())
        return S_OK;

    MtAdd(Mt(BldMapAreasCol), +1, 0);

    // Reset this collection.
    _pCollectionCache->ResetAry(AREA_ELEMENT_COLLECTION);

    if(IsInMarkup())
    {
        CChildIterator  ci(this, NULL, CHILDITERATOR_DEEP);
        while ((pNode = ci.NextChild()) != NULL)
        {
            if (pNode->Tag() == ETAG_AREA)
            {
                hr = THR(_pCollectionCache->SetIntoAry(AREA_ELEMENT_COLLECTION, pNode->Element()));
                if (hr)
                    goto Error;
            }
        }
    }

    if (pMarkup)
        *plCollectionVersion = pMarkup->GetMarkupTreeVersion();

Cleanup:
    RRETURN(hr);

Error:
    _pCollectionCache->ResetAry(AREA_ELEMENT_COLLECTION);
    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Member:     AddAreaHelper
//
//  Synopsis:   Add area to collection
//
//-------------------------------------------------------------------------
HRESULT
CMapElement::AddAreaHelper(CAreaElement * pArea, long lItemIndex)
{
    HRESULT         hr;

    if (lItemIndex == -1)
        lItemIndex = GetAreaCount(); // append

    // insert the area into the element tree, with pMap as parent at the
    // position lItemIndex
    hr = THR(pArea->InsertIntoElemTree(this, lItemIndex));
    if (hr)
        goto Cleanup;
        
Cleanup:
    RRETURN (SetErrorInfo(hr));
}


//+------------------------------------------------------------------------
//
//  Member:     RemoveAreaHelper
//
//  Synopsis:   remove the area at the given index 
//
//-------------------------------------------------------------------------

HRESULT
CMapElement::RemoveAreaHelper(long lItemIndex)
{
    HRESULT         hr;
    CAreaElement *  pArea;
    
    Assert (lItemIndex >= 0);
    
    hr = THR(GetAreaContaining(lItemIndex, &pArea));
    if (hr)
    {
        // Silently ignore out-of-bounds condition
        hr = S_OK;
        goto Cleanup;
    }

    // remove the area from the element tree
    hr = THR(pArea->RemoveFromElemTree());
    if (hr)
        goto Cleanup;
        
Cleanup:
    RRETURN (SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  Member:     CMapElement::AddNewArea
//
// Supports adding area element to the areas collection via
// JScript array access e.g.
// areas [ 7 ] = new Area();
//----------------------------------------------------------------------------

HRESULT BUGCALL
CMapElement::AddNewArea(long lIndex, IDispatch *pObject, long index)
{
    HRESULT             hr = S_OK;
    CAreaElement *      pArea;
    IUnknown *          pUnk;
    long                lDummy;
    CElement *          pElement = NULL;
    long                lAreaCount;

    if (index < -1)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Make sure that pObject is an <AREA> element
    hr = THR(pObject->QueryInterface(IID_IHTMLAreaElement, (void**)&pUnk));
    ReleaseInterface(pUnk);
    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    lAreaCount = GetAreaCount();

    if (index == -1)
        index = lAreaCount; // append

    // index is the ordinal position to add/replace
    // If it exists, replace the existing element.
    // If not extend the options array with default elements
    // up to index-1, then add the new element
    // Verify that pObject is an IOptionElement

    if (index < lAreaCount)
    {
        // remove the current element at 'index'
        hr = THR(RemoveAreaHelper(index));
        if (hr)
            goto Cleanup;

        lAreaCount -= 1;
    }
    else
    {
        CDoc *  pDoc = Doc();

        // pad with dummy elements till index - 1

        for (lDummy = index - lAreaCount; lDummy > 0; --lDummy)
        {
            hr = THR(pDoc->CreateElement(ETAG_AREA, &pElement));
            if (hr)
                goto Cleanup;

            pArea = DYNCAST(CAreaElement, pElement);
            // insert the dummy element
            hr = THR(AddAreaHelper(pArea, lDummy));
            if (hr)
                goto Cleanup;
                
            CElement::ClearPtr(&pElement);
           
            lAreaCount += 1;
        }
    }

    // insert the new element at 'index'
    Verify(S_OK == THR(pObject->QueryInterface(CLSID_CElement, (void **)&pArea)));

    // Bail out if the element is already in the tree - #25130
    if (pArea->IsInMarkup())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }


    hr = THR(AddAreaHelper(pArea, index));
    if (hr)
        goto Cleanup;

Cleanup:

    CElement::ClearPtr(&pElement);
        
    RRETURN(hr);
}


HRESULT
CMapElement::get_areas(IHTMLAreasCollection ** ppElemCol)
{
    HRESULT hr;

    if (!ppElemCol)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }
    
    hr = EnsureCollectionCache(); // Ensures AREAS
    if(hr)
        goto Cleanup;

    hr = THR(_pCollectionCache->GetDisp(0, (IDispatch**)ppElemCol));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}



///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
//          Class CAreasCollection method implementations
///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////


//+------------------------------------------------------------------------
//
//  Member:     s_classdesc
//
//  Synopsis:   class descriptor
//
//-------------------------------------------------------------------------

const CBase::CLASSDESC CAreasCollection::s_classdesc =
{
    NULL,                           // _pclsid
    0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
    NULL,                           // _apClsidPages
#endif // NO_PROPERTY_PAGE
    NULL,                           // _pcpi
    0,                              // _dwFlags
    &IID_IHTMLAreasCollection,      // _piidDispinterface
    &s_apHdlDescs,                  // _apHdlDesc
};

//+------------------------------------------------------------------------
//
//  Member:     ~CAreasCollection
//
//  Synopsis:   destructor
//
//-------------------------------------------------------------------------

CAreasCollection::~CAreasCollection()
{
    _pCollectionCache->ClearDisp(_lIndex);
}

//+------------------------------------------------------------------------
//
//  Member:     PrivateQueryInterface
//
//  Synopsis:   vanilla implementation
//
//-------------------------------------------------------------------------

HRESULT
CAreasCollection::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IHTMLAreasCollection *)this, IUnknown)
        QI_INHERITS((IHTMLAreasCollection *)this, IDispatch)
        QI_INHERITS(this, IDispatchEx)
        QI_TEAROFF(this, IHTMLAreasCollection2, NULL)
        QI_TEAROFF(this, IHTMLAreasCollection3, NULL)

        default:
            if (iid == IID_IHTMLAreasCollection)
                *ppv = (IHTMLAreasCollection *)this;
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *) *ppv)->AddRef();

    return S_OK;
}



//+------------------------------------------------------------------------
//
//  Member:     get_length
//
//  Synopsis:   collection object model, defers to Cache Helper
//
//-------------------------------------------------------------------------

HRESULT
CAreasCollection::get_length(long * plSize)
{
    RRETURN(SetErrorInfo(_pCollectionCache->GetLength(_lIndex, plSize)));
}


//+-------------------------------------------------------------------------
//
//  Method:     CAreasCollection::putt_length
//
//  Synopsis:   Sets length (i.e. the number of entries). Truncates or
//              expands (by padding with dummy elements) the array as needed.
//
//--------------------------------------------------------------------------

HRESULT
CAreasCollection::put_length(long lLengthNew)
{
    HRESULT         hr = S_OK;
    long            l, lLengthOld;
    CAreaElement *  pArea;
    CMapElement *   pMap;
    CElement *      pElement = NULL;

    if (lLengthNew < 0)
    {
        hr =E_INVALIDARG;
        goto Cleanup;
    }

#ifdef WIN16
    // we store it as the original ptr and a DYNCAST just messes
    // things up so cast to void * and then back to what we want.
    pMap = (CMapElement *)(void *)_pCollectionCache->GetBase();
#else
    pMap = DYNCAST(CMapElement, _pCollectionCache->GetBase());
#endif
    if (!pMap)
    {
        hr = E_UNEXPECTED; 
        goto Cleanup;
    }

    lLengthOld = pMap->GetAreaCount();
    
    if (lLengthNew == lLengthOld)
        goto Cleanup;

    if (lLengthNew < lLengthOld)
    {
        // truncate the array
        for (l = lLengthOld-1; l >= lLengthNew; l--)
        {
            hr = THR(pMap->RemoveAreaHelper(l));
            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        CDoc *  pDoc = pMap->Doc();

        // pad the array
        for (l = lLengthOld; l < lLengthNew; l++)
        {
            hr = THR(pDoc->CreateElement(ETAG_AREA, &pElement));
            if (hr)
                goto Cleanup;

            pArea = DYNCAST(CAreaElement, pElement);
            // insert the dummy element
            hr = THR(pMap->AddAreaHelper(pArea, l));
            if (hr)
                goto Cleanup;

            CElement::ClearPtr(&pElement);
        }
    }
Cleanup:
    CElement::ClearPtr(&pElement);
    
    RRETURN(SetErrorInfo(hr));
}


//+------------------------------------------------------------------------
//
//  Member:     item
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CAreasCollection::item(VARIANTARG var1, VARIANTARG var2, IDispatch** ppResult)
{
    RRETURN(SetErrorInfo(_pCollectionCache->Item(_lIndex, var1, var2, ppResult)));
}

//+------------------------------------------------------------------------
//
//  Member:     namedItem
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CAreasCollection::namedItem(BSTR bstrName, IDispatch** ppResult)
{
    HRESULT hr;

    if (!bstrName || !*bstrName)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    VARIANT var1, var2;

    var1.vt = VT_BSTR;
    var1.bstrVal = bstrName;

    var2.vt = VT_EMPTY;

    hr = THR(_pCollectionCache->Item(_lIndex, var1, var2, ppResult));

Cleanup:
    RRETURN(SetErrorInfo( hr));
}

//+------------------------------------------------------------------------
//
//  Member:     tags
//
//  Synopsis:   collection object model, this always returns a collection
//              and is named based on the tag, and searched based on tagname
//
//-------------------------------------------------------------------------

HRESULT
CAreasCollection::tags(VARIANT var1, IDispatch ** ppdisp)
{
    RRETURN(SetErrorInfo(_pCollectionCache->Tags(_lIndex, var1, ppdisp)));
}


//+------------------------------------------------------------------------
//
//  Member:     urns
//
//  Synopsis:   collection object model, this always returns a collection
//              and is named based on the urn, and searched based on urn
//
//-------------------------------------------------------------------------

HRESULT
CAreasCollection::urns(VARIANT var1, IDispatch ** ppdisp)
{
    RRETURN(SetErrorInfo(_pCollectionCache->Urns(_lIndex, var1, ppdisp)));
}

//+------------------------------------------------------------------------
//
//  Member:     Get_newEnum
//
//  Synopsis:   collection object model
//
//-------------------------------------------------------------------------

HRESULT
CAreasCollection::get__newEnum(IUnknown ** ppEnum)
{
    RRETURN(SetErrorInfo(_pCollectionCache->GetNewEnum(_lIndex, ppEnum)));
}


//+------------------------------------------------------------------------
//
//  Member:     Add
//
//  Synopsis:   Add item to collection...
//
//-------------------------------------------------------------------------
HRESULT
CAreasCollection::add(IHTMLElement * pIElement, VARIANT varIndex)
{
    HRESULT         hr;
    CMapElement *   pMap;
    CAreaElement *  pArea;
    long            lItemIndex;
    IUnknown *      pUnk = NULL;

    if (!pIElement)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Make sure this is an AREA element
    hr = THR(pIElement->QueryInterface(IID_IHTMLAreaElement, (void**)&pUnk));
    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(pUnk->QueryInterface(CLSID_CElement, (void**)&pArea));
    if (hr)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    // Bail out if the element is already in the tree - #25130
    if (pArea->IsInMarkup())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

#ifdef WIN16
    // we store it as the original ptr and a DYNCAST just messes
    // things up so cast to void * and then back to what we want.
    pMap = (CMapElement *)(void *)_pCollectionCache->GetBase();
#else
    pMap = DYNCAST(CMapElement, _pCollectionCache->GetBase());
#endif
    if (!pMap)
    {
        hr = E_UNEXPECTED; 
        goto Cleanup;
    }

    hr = THR(VARIANTARGToIndex(&varIndex, &lItemIndex));
    if (hr)
        goto Cleanup;
    
    if (lItemIndex < -1 || lItemIndex > pMap->GetAreaCount())
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(pMap->AddAreaHelper(pArea, lItemIndex));
    if (hr)
        goto Cleanup;
        
Cleanup:
    ReleaseInterface(pUnk);
    RRETURN (SetErrorInfo(hr));
}

//+------------------------------------------------------------------------
//
//  Member:     remove
//
//  Synopsis:   remove the item in the collection at the given index 
//
//-------------------------------------------------------------------------

HRESULT
CAreasCollection::remove(long lItemIndex)
{
    HRESULT         hr;
    CMapElement *   pMap; 

#ifdef WIN16
    // we store it as the original ptr and a DYNCAST just messes
    // things up so cast to void * and then back to what we want.
    pMap = (CMapElement *)(void *)_pCollectionCache->GetBase();
#else
    pMap = DYNCAST(CMapElement, _pCollectionCache->GetBase());
#endif
    if (!pMap)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    if (lItemIndex < 0)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    hr = THR(pMap->RemoveAreaHelper(lItemIndex));
        
Cleanup:
    RRETURN (SetErrorInfo(hr));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\epara.cxx ===
//+---------------------------------------------------------------------
//
//   File:      epara.cxx
//
//  Contents:   Para element class
//
//  Classes:    CParaElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EPARA_HXX_
#define X_EPARA_HXX_
#include "epara.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#define _cxx_
#include "para.hdl"

const CElement::CLASSDESC CParaElement::s_classdesc =
{
    {
        &CLSID_HTMLParaElement,             // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLParaElement,              // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLParaElement,       // _apfnTearOff
    NULL                                    // _pAccelsRun
};

HRESULT
CParaElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_P));

    Assert(ppElement);
    *ppElement = new CParaElement(pDoc);
    return *ppElement ? S_OK: E_OUTOFMEMORY;
}

HRESULT
CParaElement::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    HRESULT hr;

    hr = super::Save(pStreamWrBuff, fEnd);
    if (hr)
        goto Cleanup;
    
    if (fEnd && pStreamWrBuff->TestFlag(WBF_FORMATTED_PLAINTEXT))
    {
        // Double space in plaintext mode after <P> elements
        hr = pStreamWrBuff->NewLine();
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\eolist.cxx ===
//+---------------------------------------------------------------------
//
//   File:      eolist.cxx
//
//  Contents:   Ordered List Element class
//
//  Classes:    COListElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EOLIST_HXX_
#define X_EOLIST_HXX_
#include "eolist.hxx"
#endif

#define _cxx_
#include "olist.hdl"

EXTERN_C const ENUMDESC s_enumdescTYPE;

const CElement::CLASSDESC COListElement::s_classdesc =
{
    {
        &CLSID_HTMLOListElement,            // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLOListElement,             // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLOListElement,      // _apfnTearOff
    NULL                                    // _pAccelsRun
};


//+------------------------------------------------------------------------
//
//  Member:     COListElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
COListElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr;

    *ppv = NULL;

    if IID_HTML_TEAROFF(this, IHTMLOListElement, NULL)
    else
    {
        RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    (*(IUnknown **)ppv)->AddRef();
    return S_OK;
}


HRESULT COListElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(pht->Is(ETAG_OL));
    Assert(ppElementResult);
    *ppElementResult = new COListElement(pDoc);
    return *ppElementResult ? S_OK : E_OUTOFMEMORY;
}

HRESULT
COListElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT hr;

    hr = super::ApplyDefaultFormat(pCFI);
    if (hr)
        goto Cleanup;

    pCFI->PrepareParaFormat();
    pCFI->_pf()._lNumberingStart = GetAAstart();
    pCFI->_pf()._cListing.SetStyle(FilterHtmlListType(pCFI->_ppf->GetListStyleType(), 0));
    pCFI->UnprepareForDebug();

Cleanup:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Member:     FilterHtmlListType()
//
//  Returns:    Return the perferred htmlListType for ordered lists.
//
//------------------------------------------------------------------------

styleListStyleType
COListElement::FilterHtmlListType(  styleListStyleType type, WORD wLevel )
{
    return ( styleListStyleTypeNotSet != type) ? type : styleListStyleTypeDecimal;
}


//+-----------------------------------------------------------------------
//
//  Member:     OnPropertyChange()
//
//  Note  :    Trap the change to start attribute to inval the index caches
//
//------------------------------------------------------------------------
HRESULT
COListElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr;

    if (dispid == DISPID_COListElement_start)
    {
        UpdateVersion();
    }
    hr = THR( super::OnPropertyChange( dispid, dwFlags, ppropdesc ) );

    RRETURN( hr );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\ephrase.cxx ===
//+---------------------------------------------------------------------
//
//   File:      ephrase.cxx
//
//  Contents:   Phrase element class
//
//  Classes:    CPhraseElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EPHRASE_HXX_
#define X_EPHRASE_HXX_
#include "ephrase.hxx"
#endif

#ifndef X_EFONT_HXX_
#define X_EFONT_HXX_
#include "efont.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_TXTSITE_HXX_
#define X_TXTSITE_HXX_
#include "txtsite.hxx"
#endif

#ifndef X_E1D_HXX_
#define X_E1D_HXX_
#include "e1d.hxx"
#endif

#ifndef X_DISPDEFS_HXX_
#define X_DISPDEFS_HXX_
#include "dispdefs.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "phrase.hdl"

interface IHTMLControlElement;

extern "C" const IID IID_IControl;

MtDefine(CPhraseElement, Elements, "CPhraseElement")
MtDefine(CSpanElement, Elements, "CSpanElement")

const CElement::CLASSDESC CPhraseElement::s_classdesc =
{
    {
        &CLSID_HTMLPhraseElement,           // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLPhraseElement,            // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnIHTMLPhraseElement,       //  _apfnTearOff

    NULL                                    // _pAccelsRun
};

HRESULT
CPhraseElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    HRESULT    hr = S_OK;
    CElement * pElement;

    Assert(pht->Is(ETAG_B)        || pht->Is(ETAG_U)      ||
           pht->Is(ETAG_I)        || pht->Is(ETAG_STRONG) ||
           pht->Is(ETAG_BIG)      || pht->Is(ETAG_SMALL)  ||
           pht->Is(ETAG_BLINK)    || pht->Is(ETAG_TT)     ||
           pht->Is(ETAG_STRIKE)   || pht->Is(ETAG_VAR)    ||
           pht->Is(ETAG_SUP)      || pht->Is(ETAG_SUB)    ||
           pht->Is(ETAG_CITE)     || pht->Is(ETAG_CODE)   ||
           pht->Is(ETAG_KBD)      || pht->Is(ETAG_SAMP)   ||
           pht->Is(ETAG_DFN)      || pht->Is(ETAG_S)      ||
           pht->Is(ETAG_EM)       || pht->Is(ETAG_NOBR)   ||
           pht->Is(ETAG_ACRONYM)  || pht->Is(ETAG_Q)      ||
           pht->Is(ETAG_INS)      || pht->Is(ETAG_DEL)    ||
           pht->Is(ETAG_BDO)	  || pht->Is(ETAG_RUBY)   ||
           pht->Is(ETAG_RT)       || pht->Is(ETAG_RP));

    Assert(ppElement);
    pElement = new CPhraseElement(pht->GetTag(), pDoc);
    if (!pElement)
        goto MemoryError;

    *ppElement = pElement;

Cleanup:
    RRETURN(hr);

MemoryError:
    hr = E_OUTOFMEMORY;
    goto Cleanup;
}

//+------------------------------------------------------------------------
//
//  Member:     CPhraseElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CPhraseElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{   
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_TEAROFF(this, IHTMLPhraseElement, NULL)
        QI_HTML_TEAROFF(this, IHTMLPhraseElement2, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


HRESULT
CPhraseElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    pCFI->PrepareCharFormat();

    CCharFormat *pCF = &pCFI->_cf();
    LONG twips;

    switch(Tag())
    {
    case ETAG_I:
    case ETAG_CITE:
    case ETAG_DFN:
    case ETAG_EM:
    case ETAG_VAR:
        pCF->_fItalic = TRUE;
        break;

    case ETAG_U:
    case ETAG_INS:
        pCFI->PrepareFancyFormat();
        pCF->_fUnderline = TRUE;
        pCFI->_ff()._fHasExplicitUnderline = TRUE;
        break;

    case ETAG_SMALL:
    case ETAG_BIG:
        pCF->ChangeHeightRelative( (Tag() == ETAG_BIG) ? 1 : -1 );
        break;

    case ETAG_B:
    case ETAG_STRONG:
        pCF->_fBold = TRUE;
        pCF->_wWeight = 700;
        break;

    case ETAG_S:
    case ETAG_STRIKE:
    case ETAG_DEL:
        pCFI->PrepareFancyFormat();
        pCF->_fStrikeOut = TRUE;
        pCFI->_ff()._fHasExplicitLineThrough = TRUE;
        break;
        

    case ETAG_KBD:
    case ETAG_CODE:
    case ETAG_SAMP:
    case ETAG_TT:
        pCF->_fBumpSizeDown = TRUE;
        {
            CDoc *  pDoc = Doc();
            CMarkup * pMarkup = GetMarkup();
            CODEPAGESETTINGS * pCS = pMarkup->GetCodepageSettings();
            CODEPAGE cp = pMarkup->GetCodePage();

            if (!pCS)
                pCS = pDoc->PrimaryMarkup()->GetCodepageSettings();

            // Thai does not have a fixed pitch font. Leave it as proportional
            if(cp != CP_THAI)
            {
                pCF->_bPitchAndFamily = FIXED_PITCH;
                pCF->SetFaceNameAtom(pCS->latmFixedFontFace);
                if (pCF->NeedAtFont())
                {
                    ApplyAtFontFace(pCF, Doc(), GetMarkup());
                }
            }
            pCF->_bCharSet = pCS->bCharSet;
            pCF->_fNarrow = IsNarrowCharSet(pCS->bCharSet);
        }
        break;

    case ETAG_SUB:
        {
            pCF->_fSubscript = TRUE;
            pCF->_fSubSuperSized = TRUE;

            pCFI->PrepareFancyFormat();
            pCFI->_ff().SetVerticalAlign(styleVerticalAlignSub);
            pCFI->_ff().SetCSSVerticalAlign(TRUE);
            pCFI->_cf()._fNeedsVerticalAlign = TRUE;
        }
        break;

    case ETAG_SUP:
        {
            pCF->_fSuperscript = TRUE;
            pCF->_fSubSuperSized = TRUE;

            pCFI->PrepareFancyFormat();
            pCFI->_ff().SetVerticalAlign(styleVerticalAlignSuper);
            pCFI->_ff().SetCSSVerticalAlign(TRUE);
            pCFI->_cf()._fNeedsVerticalAlign = TRUE;
        }
        break;

    case ETAG_NOBR:
        pCFI->_fNoBreak = TRUE;
        break;

    case ETAG_RUBY:
        pCF->_fIsRuby = TRUE;
        break;

    case ETAG_RT:
        if(pCF->_fIsRuby) 
        {
            pCF->_fIsRubyText = TRUE;
            twips = pCF->GetHeightInTwips( Doc() );
            pCF->SetHeightInTwips( twips / 2 );
        }
        break;

    case ETAG_BDO:
        pCFI->_fBidiEmbed = TRUE;
        pCFI->_fBidiOverride = TRUE;
        break;

    case ETAG_RP:
        if(pCF->_fIsRuby) 
        {
            pCF->_fDisplayNone = TRUE;
            if( !pCF->_fIsRubyText )
            {
                pCF->_fIsRubyText = TRUE;
                twips = pCF->GetHeightInTwips( Doc() );
                pCF->SetHeightInTwips( twips / 2 );
            }
        }
        break;
    }
    
    pCFI->UnprepareForDebug();

    RRETURN(super::ApplyDefaultFormat(pCFI));
}

const CElement::CLASSDESC CSpanElement::s_classdesc =
{
    {
        &CLSID_HTMLSpanElement,             // _pclsid
        0,                                  // _idrBase
        s_apclsidPages,                     // _apClsidPages
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLSpanElement,              // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnIHTMLSpanElement,         // _apfnTearOff

    NULL                                    // _pAccelsRun
};

HRESULT
CSpanElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_SPAN));
    Assert(ppElement);
    *ppElement = new CSpanElement(ETAG_SPAN, pDoc);
    return *ppElement ? S_OK : E_OUTOFMEMORY;
}

#ifndef NO_DATABINDING
#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

const CDBindMethods *
CSpanElement::GetDBindMethods()
{
    return &DBindMethodsTextRichRO;
}


//+----------------------------------------------------------------------------
//
//  Member:     CSpanElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-----------------------------------------------------------------------------

HRESULT
CSpanElement::PrivateQueryInterface ( REFIID iid, void ** ppv )
{
    HRESULT hr;

    *ppv = NULL;

    // IE4 shipped the interface IHTMLControlElement with the same GUID as
    // IControl.  Unfortunately, IControl is a forms^3 interface, which is bad.
    // To resolve this problem Trident's GUID for IHTMLControlElement has
    // changed however, the old GUID remembered in the QI for CSite to return
    // IHTMLControlElement.  The only side affect is that using the old GUID
    // will not marshall the interface correctly only the new GUID has the
    // correct marshalling code.  So, the solution is that QI'ing for
    // IID_IControl or IID_IHTMLControlElement will return IHTMLControlElement.

    // For VB page designer we need to emulate IE4 behavior (fail the QI if not a site)
    if(iid == IID_IControl && Doc()->_fVB && !ShouldHaveLayout())
        RRETURN(E_NOINTERFACE);

    if (iid == IID_IHTMLControlElement || iid == IID_IControl)
    {

        hr = CreateTearOffThunk(this,
                                s_apfnpdIHTMLControlElement,
                                NULL,
                                ppv,
                                (void *)s_ppropdescsInVtblOrderIHTMLControlElement);
        if (hr)
            RRETURN(hr);
    }
    else
    {
        RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\eulist.cxx ===
//+---------------------------------------------------------------------
//
//   File:      eulist.cxx
//
//  Contents:   Ordered List Element class
//
//  Classes:    CUListElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EULIST_HXX_
#define X_EULIST_HXX_
#include "eulist.hxx"
#endif

#define _cxx_
#include "ulist.hdl"

const CElement::CLASSDESC CUListElement::s_classdesc =
{
    {
        &CLSID_HTMLUListElement,            // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        0,                                  // _dwFlags
        &IID_IHTMLUListElement,             // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLUListElement,      // _apfnTearOff
    NULL                                    // _pAccelsRun
};


//+------------------------------------------------------------------------
//
//  Member:     CUListElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CUListElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr;

    *ppv = NULL;

    if IID_HTML_TEAROFF(this, IHTMLUListElement, NULL)
    else
    {
        RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    (*(IUnknown **)ppv)->AddRef();
    return S_OK;
}


HRESULT CUListElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(pht->Is(ETAG_UL) || pht->Is(ETAG_MENU) || pht->Is(ETAG_DIR));
    Assert(ppElementResult);
    *ppElementResult = new CUListElement(pht->GetTag(), pDoc);
    return *ppElementResult ? S_OK : E_OUTOFMEMORY;
}

HRESULT
CUListElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT hr;

    hr = super::ApplyDefaultFormat(pCFI);
    if (hr)
        goto Cleanup;

    pCFI->PrepareParaFormat();
    pCFI->_pf()._cListing.SetStyle(FilterHtmlListType(pCFI->_ppf->GetListStyleType(), 
                                   (WORD)pCFI->_pf()._cListing.GetLevel()));
    pCFI->UnprepareForDebug();

Cleanup:
    RRETURN(hr);
}

//+-----------------------------------------------------------------------
//
//  Member:     FilterHtmlListType()
//
//  Returns:    Return the perferred htmlListType for unordered lists.
//
//------------------------------------------------------------------------

styleListStyleType
CUListElement::FilterHtmlListType(  styleListStyleType type, WORD wLevel )
{
    return ( styleListStyleTypeNotSet != type ? type :
            ((wLevel == 1) ? styleListStyleTypeDisc :
             (wLevel == 2) ? styleListStyleTypeCircle : styleListStyleTypeSquare) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\generic.cxx ===
//+---------------------------------------------------------------------
//
//  File:       generic.cxx
//
//  Contents:   Extensible tags classes
//
//  Classes:    CGenericElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_GENERIC_HXX_
#define X_GENERIC_HXX_
#include "generic.hxx"
#endif

#ifndef X_HTC_HXX_
#define X_HTC_HXX_
#include "htc.hxx"
#endif

#ifndef X_XMLNS_HXX_
#define X_XMLNS_HXX_
#include "xmlns.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx" // for CStreamWriteBuf
#endif

#ifndef X_DMEMBMGR_HXX_
#define X_DMEMBMGR_HXX_
#include "dmembmgr.hxx"       // for CDataMemberMgr
#endif

#ifndef X_DBTASK_HXX_
#define X_DBTASK_HXX_
#include "dbtask.hxx"       // for CDataBindTask
#endif

#ifndef X_LRREG_HXX_
#define X_LRREG_HXX_
#include "lrreg.hxx"       // for CLayoutRectRegistry
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif // X_PEER_HXX_

#ifndef X_PEERXTAG_HXX_
#define X_PEERXTAG_HXX_
#include "peerxtag.hxx"
#endif // X_PEERXTAG_HXX_

#ifndef X_ELEMENTP_HXX_
#define X_ELEMENTP_HXX_
#include "elementp.hxx"
#endif

#ifndef X_PEERMGR_HXX_
#define X_PEERMGR_HXX_
#include "peermgr.hxx"
#endif

#define _cxx_
#include "generic.hdl"


#include "complus.h"

MtDefine(CGenericElement, Elements, "CGenericElement")

///////////////////////////////////////////////////////////////////////////
//
// misc
//
///////////////////////////////////////////////////////////////////////////

const CElement::CLASSDESC CGenericElement::s_classdesc =
{
    {
        &CLSID_HTMLGenericElement,          // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_XTAG
#ifdef V4FRAMEWORK
        | ELEMENTDESC_NOTIFYENDPARSE
#endif
        ,                                   // _dwFlags
        &IID_IHTMLGenericElement,           // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnIHTMLGenericElement,      //_apfnTearOff

    NULL                                    // _pAccelsRun
};

///////////////////////////////////////////////////////////////////////////
//
// CGenericElement methods
//
///////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Method:     CGenericElement::CreateElement
//
//-------------------------------------------------------------------------

HRESULT CGenericElement::CreateElement(
    CHtmTag *  pht,
    CDoc *      pDoc,
    CElement ** ppElement)
{
    HRESULT hr = S_OK;

    Assert(ppElement);

    *ppElement = new CGenericElement(pht, pDoc);
    if (!*ppElement)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

#ifdef V4FRAMEWORK
    hr = ((CGenericElement*)*ppElement)->CreateComPlusObjectLink();
    if ( hr )
        goto Cleanup;
#endif

Cleanup:
    return hr;;
}

//+------------------------------------------------------------------------
//
//  Method:     CGenericElement constructor
//
//-------------------------------------------------------------------------

CGenericElement::CGenericElement (CHtmTag * pht, CDoc * pDoc)
  : CElement(pht->GetTag(), pDoc)
{
    LPTSTR  pchColon;
    LPTSTR  pchStart;

    Assert(IsGenericTag(pht->GetTag()));
    Assert(pht->GetPch());

    if (pht->GetPch())
    {
        pchColon = StrChr(pht->GetPch(), _T(':'));
        if (pchColon)
        {
            pchStart = pht->GetPch();

            IGNORE_HR(_cstrNamespace.Set(pchStart, PTR_DIFF(pchColon, pchStart)));
            IGNORE_HR(_cstrTagName.Set(pchColon + 1));
        }
        else
        {
            IGNORE_HR(_cstrTagName.Set(pht->GetPch()));
        }
    }

#ifdef ATOMICGENERIC
    _fAttemptAtomicSave = pht->IsEmpty();
#endif // ATOMICGENERIC
}

#ifdef V4FRAMEWORK
void CGenericElement::Passivate()
{
    COMPLUSREF lVal;
    IExternalDocument *pFactory;
    HRESULT hr;

    pFactory = GetFrameworkDocAndElem(&lVal);
    if (!pFactory)
    {
        AssertSz(false, "~GenericElement() External Factory gone");
        goto Cleanup;
    }

    hr = THR(pFactory->ReleaseProxy((long)lVal));

Cleanup:
    super::Passivate();
}
#endif V4FRAMEWORK


#ifdef V4FRAMEWORK
HRESULT CGenericElement::PutComPlusReference ( COMPLUSREF lVal )
{
    return AddSimple(DISPID_INTERNAL_GENERICCOMPLUSREF, (DWORD)lVal, CAttrValue::AA_Internal);

}

HRESULT CGenericElement::GetComPlusReference ( COMPLUSREF *plVal )
{
    return GetSimpleAt (FindAAIndex (DISPID_INTERNAL_GENERICCOMPLUSREF, CAttrValue::AA_Internal), (DWORD *)plVal );
}
#endif V4FRAMEWORK

//+------------------------------------------------------------------------
//
//  Method:     CGenericElement::Init2
//
//-------------------------------------------------------------------------

HRESULT
CGenericElement::Init2(CInit2Context * pContext)
{
    HRESULT     hr;
    LPTSTR      pchNamespace;

    hr = THR(super::Init2(pContext));
    if (hr)
        goto Cleanup;

    if (pContext)
    {
        pchNamespace = (LPTSTR) Namespace();

        if (pchNamespace && pContext->_pTargetMarkup)
        {
            CXmlNamespaceTable *    pNamespaceTable = pContext->_pTargetMarkup->GetXmlNamespaceTable();
            LONG                    urnAtom;

            if (pNamespaceTable) // (we might not have pNamespaceTable if the namespace if "PUBLIC:")
            {
                hr = THR(pNamespaceTable->GetUrnAtom(pchNamespace, &urnAtom));
                if (hr)
                    goto Cleanup;

                if (-1 != urnAtom)
                {
                    hr = THR(PutUrnAtom(urnAtom));
                }
            }
        }
    }


Cleanup:
    RRETURN (hr);
}

#ifdef V4FRAMEWORK

class CExternalCOMPlusPeerHolder : public CPeerHolder
{
public:
    CExternalCOMPlusPeerHolder ( CElement *pElem ) : CPeerHolder (pElem){}
    HRESULT GetSize(LONG    lFlags,
                       SIZE    sizeNatural,
                       POINT * pPtTranslate,
                       POINT * pPtTopLeft,
                       SIZE  * psizeProposed);
};


HRESULT CExternalCOMPlusPeerHolder::GetSize(LONG    lFlags,
                   SIZE    sizeNatural,
                   POINT * pPtTranslate,
                   POINT * pPtTopLeft,
                   SIZE  * psizeProposed)
{
    IExternalDocument *pFactory = NULL;
    CGenericElement::COMPLUSREF cpRef;
    HRESULT hr;

    hr = ((CGenericElement*)_pElement)->GetComPlusReference ( &cpRef );
    if ( hr )
        goto Cleanup;

    pFactory = _pElement->Doc()->EnsureExternalFrameWork();
    if (!pFactory)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(pFactory->GetSize ( (long)cpRef, lFlags,
        sizeNatural.cx, sizeNatural.cy,
        &pPtTranslate->x, &pPtTranslate->y,
        &pPtTopLeft->x, &pPtTopLeft->y,
        &psizeProposed->cx, &psizeProposed->cy ));
Cleanup:
    RRETURN(hr);
}

#endif V4FRAMEWORK


#ifdef V4FRAMEWORK
HRESULT CGenericElement::CreateComPlusObjectLink()
{
    HRESULT hr = S_OK;
    IExternalDocument *pFactory = NULL;
    COMPLUSREF lRef;
    BSTR bstrTagName;
    CPeerHolder *pH;

    // CoCreate the MSUI factory object
    pFactory = Doc()->EnsureExternalFrameWork();
    if (!pFactory)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = THR(FormsAllocString( (TCHAR*)_cstrTagName,
        &bstrTagName ) );
    if (hr)
        goto Cleanup;


    // Hand out pointer to Element Site
    hr = pFactory->CreateElement ( bstrTagName, (long)this, &lRef );
    if (hr)
        goto Cleanup;

    //Store away the reference
    hr = PutComPlusReference ( lRef );
    if (hr)
        goto Cleanup;

    // Increment the count on the framework site, decremented when the external element is destroyed
    Doc()->_extfrmwrkSite.lExternalElems++;

    // Create call implicetly creates a strong ref on the newly created object

    // Artificialy AddRef ourselves - COMPlus object behaves as a strong ref
    AddRef();

    pH = new CExternalCOMPlusPeerHolder(this);
    pH->_pLayoutBag = new CPeerHolder::CLayoutBag();
    pH->_pLayoutBag->_lLayoutInfo = 0; // Gets set by CExternalFrameworkSite::SetLongRenderProperty ()
    SetPeerHolder(pH);

Cleanup:
    FormsFreeString(bstrTagName);
    return hr;
}
#endif V4FRAMEWORK

#ifdef V4FRAMEWORK
HRESULT CGenericElement::ChangeRefComPlusObject( BOOL fStrongNotWeak )
{
    IExternalDocument *pFactory = NULL;
    HRESULT hr;
    COMPLUSREF cpRef;

    hr = GetComPlusReference ( &cpRef );
    if ( hr )
        goto Cleanup;

    pFactory = Doc()->EnsureExternalFrameWork();
    if (!pFactory)
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    if ( fStrongNotWeak )
    {
        hr = pFactory ->StrongRefElement ( (long)cpRef );
    }
    else
    {
        hr = pFactory ->WeakRefElement ( (long)cpRef );
    }

Cleanup:
    return hr;
}
#endif V4FRAMEWORK


#ifdef V4FRAMEWORK
ULONG
CGenericElement::PrivateAddRef()
{
    CMarkup * pMarkup = NULL;
    BOOL fStrongRef = FALSE;

    if( _ulRefs == 2 && IsInMarkup() )
    {
        Assert( GetMarkupPtr() );
        pMarkup = GetMarkupPtr();
    }

    if ( _ulRefs == 1 )
        fStrongRef = TRUE;

    // Skip CElement deliberately
    ULONG ulRet = CBase::PrivateAddRef();

    if ( fStrongRef )
    {
        StrongRefComPlusObject();
    }

    if ( pMarkup )
    {
        pMarkup ->AddRef();
    }

    return ulRet;
}
#endif V4FRAMEWORK

#ifdef V4FRAMEWORK
void
CGenericElement::PrivateExitTree( CMarkup * pMarkupOld)
{
    BOOL fReleaseMarkup = _ulRefs > 2; // 1 from tree, 1 from COMPlus element
    BOOL fWeakRef = FALSE;

    Assert( ! IsInMarkup() );
    Assert( pMarkupOld );


    if (_ulRefs == 2)
    {
        // Only COM+ artificial AddRef() keeping object alive
        fWeakRef = TRUE;
    }

    // If we sent the EXITTREE_PASSIVATEPENDING bit then we
    // must also passivate right here.
    //AssertSz( !_fPassivatePending || _ulRefs == 2,
    //    "EXITTREE_PASSIVATEPENDING set and element did not passivate.  Talk to JBeda." );

    CBase::PrivateRelease();

    if ( fReleaseMarkup )
    {
        pMarkupOld->Release();
    }

    if ( fWeakRef )
    {
        // Takes off the strong ref on the COM+ object, COMPlus object will go away eventually when it's
        // external refs drop to Zero, then Finalize() on COM+ object will call back to us
        // to remove the artificial AddRef() applied in CreateComPlusObjectLink*(
        WeakRefComPlusObject();
    }

}
#endif V4FRAMEWORK

#ifdef V4FRAMEWORK
ULONG
CGenericElement::PrivateRelease()
{
    CMarkup * pMarkup = NULL;
    BOOL fWeakRef = FALSE;

    if(_ulRefs == 3 && IsInMarkup())
    {
        // Last External COM Classic Reference is being removed on element
        pMarkup = GetMarkupPtr();
    }

    if (_ulRefs == 2)
    {
        // Only COM+ artificial AddRef() keeping object alive
        fWeakRef = TRUE;
    }

    // Skip CElement deliberately
    ULONG ret =  CBase::PrivateRelease();

    if( pMarkup )
    {
        pMarkup->Release();
    }

    if ( fWeakRef )
    {
        // Takes off the strong ref on the COM+ object, COMPlus object will go away eventually when it's
        // external refs drop to Zero, then Finalize() on COM+ object will call back to us
        // to remove the artificial AddRef() applied in CreateComPlusObjectLink*(
        WeakRefComPlusObject();
    }
    return ret;
}
#endif V4FRAMEWORK

#ifdef V4FRAMEWORK


HRESULT
CGenericElement::InitAttrBag(CHtmTag *pht, CMarkup * pMarkup)
{
    // Tag the Tag Stream & hand it off to the element
    BSTR bstrPackedAttributeArray;
    HRESULT hr;
    IExternalDocument *pFactory;
    COMPLUSREF cpr;

    pFactory = GetFrameworkDocAndElem(&cpr);
    if (!pFactory)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    hr = pht->ToBSTR ( &bstrPackedAttributeArray );
    if ( hr )
        goto Cleanup;

    hr = pFactory->InitAttributes ( (long)cpr, bstrPackedAttributeArray );
    if ( hr )
        goto Cleanup;

Cleanup:
    FormsFreeString(bstrPackedAttributeArray);
    RRETURN(hr);
}

void CGenericElement::OnEnterTree(DWORD_PTR dwAsynch)
{
    IExternalDocument *pFactory;
    COMPLUSREF cpr;

    pFactory = GetFrameworkDocAndElem(&cpr);
    if (!pFactory)
        return;

    if ((BOOL)dwAsynch)
        IGNORE_HR(pFactory->OnEnterTreeAsynch((long)cpr));
    else
        IGNORE_HR(pFactory->OnEnterTree((long)cpr));
}

void CGenericElement::OnExitTree(DWORD_PTR dwAsynch)
{
    IExternalDocument *pFactory;
    COMPLUSREF cpr;

    pFactory = GetFrameworkDocAndElem(&cpr);
    if (!pFactory)
        return;

    if ((BOOL)dwAsynch)
        IGNORE_HR(pFactory->OnExitTreeAsynch((long)cpr));
    else
        IGNORE_HR(pFactory->OnExitTree((long)cpr));
}

#endif V4FRAMEWORK

//+------------------------------------------------------------------------
//
//  Method:     CGenericElement::Notify
//
//-------------------------------------------------------------------------

void
CGenericElement::Notify(CNotification *pnf)
{
    CMarkup *pMarkup;
    Assert(pnf);

    super::Notify(pnf);

    switch (pnf->Type())
    {
    case NTYPE_ELEMENT_ENTERTREE:

        pMarkup = GetMarkup();
        if (pMarkup->HasBehaviorContext() && Tag() == ETAG_GENERIC_BUILTIN)
        {
            CHtmlComponent *pComponent = pMarkup->BehaviorContext()->_pHtmlComponent;
            if (pComponent && !pComponent->Dirty())
            {
                if ((pMarkup->_LoadStatus >= LOADSTATUS_QUICK_DONE || pMarkup->GetWindowedMarkupContext()->GetWindowPending()->Window()->IsInScript()) &&
                    (TagNameToHtcBehaviorType(TagName()) & HTC_BEHAVIOR_PROPERTYORMETHODOREVENT))
                {
                    if (pComponent->_fFirstInstance)
                        pComponent->_pConstructor->_pFactoryComponent->_fDirty = TRUE;
                    else
                        pComponent->_fDirty = TRUE;
                }
                else if (GetName() &&
                         !pComponent->_fFactoryComponent &&
                         pComponent->_fFirstInstance &&
                         (TagNameToHtcBehaviorType(TagName()) & HTC_BEHAVIOR_PROPERTYORMETHOD))
                {
                    Assert(pComponent->_pConstructor);
                    Assert(pComponent->_pConstructor->_pFactoryComponent);
                    CHtmlComponent *pFactory = pComponent->_pConstructor->_pFactoryComponent;
                    Assert(pFactory);
                    Assert(StrCmpC(GetName(), GetExpandoString(this, _T("name"))) == 0);
                    // CONSIDER: any way to get the source index passed in at Enter Tree time?
                    pFactory->AddAtom(GetName(), LongToPtr(GetSourceIndex() + HTC_PROPMETHODNAMEINDEX_BASE));
                }
            }
        }

        // the <XML> tag can act as a data source for databinding.  Whenever such
        // a tag is added to the document, we should tell the databinding task
        // to try again.  Something might work now that didn't before.
        if (0 == FormsStringCmp(TagName(), _T("xml")))
        {
            pMarkup->GetDataBindTask()->SetWaiting();
        }
        // MULTI_LAYOUT
        // Semi-hack: when layout rect elements enter the tree, they need to participate
        // in hooking up to view chains.  This participation has 2 aspects:
        // 1) A layout rect may have an ID that matches a desired target ID (as
        // stored in the layout rect registry).  We need to see whether such a match
        // exists, and do the necessary hookup.
        // 2) A layout rect may have a nextRect attribute that identifies a target element
        // for overflowing content.  That target element may or may not currently be
        // in the tree; if it is, we can do the hookup here, otherwise we need to store
        // ourselves and and the target's ID in the layout rect registry so that if/when
        // an appropriate target enters the tree, the hookup can be done.
        // Why semi-hack?  We may want a better mechanism for this kind of
        // notification (ie, notifying an element when some other element
        // enters the tree), but this isn't really so bad.
        // Known limitations: consider the case where an existing viewchain
        // loses its head (ie the element w/ the contentSrc attr is removed).
        // The viewchain will remain, but will be ownerless.
        // If we then add a new layout rect w/ a contentSrc, and a nextRect
        // that hooks it up to the existing layout rects, we will not
        // behave correctly; what we'd like is to have 1 viewchain, but
        // instead we'll have 2 -- 1 that has just the head, and 1 that's
        // headless.  This is not a compelling scenario to enable for print
        // preview, but will be required if we expose view templates more
        // generally.
        else if ( IsLinkedContentElement() )
        {
            HRESULT   hr;
            CVariant  cvarNextRect;
            LPCTSTR   pszID = GetAAid();
            CElement *pSrcElem = NULL;

            Assert(pMarkup);

            // Do we have an ID?
            if ( pszID )
            {
                // yes, so find the element (if any) that's waiting for us.
                pSrcElem = pMarkup->GetLayoutRectRegistry()->GetElementWaitingForTarget( pszID );
            }

            // Is there an element waiting for a nextRect of our ID?
            if ( pSrcElem )
            {
                // yes, so hook us up.
                ConnectLinkedContentElems( pSrcElem, this );
                // src elem was subref'ed when its entry in the registry was
                // created
                pSrcElem->SubRelease();
                RemeasureElement(NFLAGS_FORCE);
            }

            // Do we have nextRect attribute?  If so we need to do some work.
            hr = GetLinkedContentAttr( _T("nextRect"), &cvarNextRect );
            if ( hr == S_OK )
            {
                // Found a valid nextRect attr
                CElement *pNextElem = GetNextLinkedContentElem();
                if ( pNextElem )
                {
                    // the element pointed to by the nextRect attr
                    // is in the tree, so we can hook it up now.
                    ConnectLinkedContentElems( this, pNextElem );
                    pNextElem->RemeasureElement(NFLAGS_FORCE);
                }
                else
                {
                    // can't find an element in the tree matching
                    // the ID specified by nextRect.  Add an entry
                    // to the layout rect registry so we can be
                    // notified when such an element enters.
                    pMarkup->GetLayoutRectRegistry()->AddEntry( this, (LPTSTR)V_BSTR(&cvarNextRect) );
                }
            }
        }

        //  When printing, we may have persisted the current state of a viewlinked markup.
        if (pMarkup->IsPrintMedia())
        {
            CVariant            cvarURL;
            CPeerMgr *          pPeerMgr;
            CDefaults *         pDefaults;
            CDocument *         pDocument   = pMarkup->Document();
            IHTMLDocument2  *   pIDoc       = NULL;

            if (    pDocument
                &&  PrimitiveGetExpando(_T("__IE_ViewLinkSrc"), &cvarURL) == S_OK
                &&  V_VT(&cvarURL) == VT_BSTR )
            {
                // We have persisted a viewlink.  Load it in...
                if  (   pDocument->createDocumentFromUrlInternal(V_BSTR(&cvarURL), _T("print"), &pIDoc, CDFU_DONTVERIFYPRINT) == S_OK
                     && pIDoc )
                {
                    // ...and viewlink it.
                    if (    CPeerMgr::EnsurePeerMgr(this, &pPeerMgr) == S_OK
                        &&  pPeerMgr->EnsureDefaults(&pDefaults) == S_OK     )
                    {
                        PrimitiveRemoveExpando(_T("__IE_ViewLinkSrc"));
                        pDefaults->put_viewLink(pIDoc);
                    }
                }
            }

            ReleaseInterface(pIDoc);
        }


#ifdef V4FRAMEWORK
        {
            OnEnterTree(FALSE);
            IGNORE_HR(GWPostMethodCall(this, ONCALL_METHOD(CGenericElement, OnEnterTree, onentertree), TRUE, FALSE, "CGenericElement::OnEnterTreeAynch"));
        }
#endif V4FRAMEWORK

        break;

    case NTYPE_DELAY_LOAD_HISTORY:
        {
            if (HasSlavePtr())
            {
                CElement *  pElemSlave = GetSlavePtr();

                if (pElemSlave)
                {
                    Assert(pElemSlave->IsInMarkup());
                    IGNORE_HR(pElemSlave->GetMarkup()->LoadSlaveMarkupHistory());
                }
            }
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        {
            pMarkup = GetMarkup();
            Assert(pMarkup);
            if (pMarkup->HasBehaviorContext() &&
                Tag() == ETAG_GENERIC_BUILTIN &&
                (TagNameToHtcBehaviorType(TagName()) & HTC_BEHAVIOR_PROPERTYORMETHODOREVENT))
            {
                CHtmlComponent *pComponent = pMarkup->BehaviorContext()->_pHtmlComponent;
                if (pComponent)
                    pComponent->_fDirty = TRUE;
            }

#ifdef V4FRAMEWORK
            OnExitTree(FALSE);
            IGNORE_HR(GWPostMethodCall(this, ONCALL_METHOD(CGenericElement, OnExitTree, onexittree), TRUE, FALSE, "CGenericElement::OnExitTreeAynch"));
#endif V4FRAMEWORK
        }
        break;

#ifdef V4FRAMEWORK
    case NTYPE_END_PARSE:
        {
            HRESULT hr;
            IExternalDocument *pFactory;
            COMPLUSREF cpr;
            BSTR bstrContents;

            pFactory = GetFrameworkDocAndElem(&cpr);
            if (!pFactory)
                break;

            if (_cstrContents)
            {
                hr = THR(FormsAllocString((TCHAR*)_cstrContents, &bstrContents));
                if (hr)
                   break;

                // set the literal content.
                IGNORE_HR(pFactory->SetLiteralContent((long)cpr, bstrContents));
                FormsFreeString(bstrContents);
            }

            IGNORE_HR(pFactory->OnContentReady((long)cpr));
        }

        break;
#endif V4FRAMEWORK

    default:
        break;
    }
}

//+------------------------------------------------------------------------
//
//  Method:     CGenericElement::Save
//
//-------------------------------------------------------------------------

HRESULT
CGenericElement::Save (CStreamWriteBuff * pStreamWriteBuff, BOOL fEnd)
{
    HRESULT     hr;
    DWORD       dwOldFlags;
    CMarkup *   pMarkup = GetMarkup();
    CDoc *      pDoc = Doc();
    BOOL        fSavedViewlink  = FALSE;
    BOOL        fExpando        = FALSE;
#ifdef ATOMICGENERIC
    BOOL        fAtomicSave = FALSE;

    // Determine if we should do an atomic save
    if( _fAttemptAtomicSave         &&
        !_cstrContents.Length() )
    {
        CTreePos * ptpBegin;
        CTreePos * ptpEnd;

        //
        // See if there is anything inside us besides pointer pos's
        //
        GetTreeExtent( &ptpBegin, &ptpEnd );
        while( ptpBegin->NextTreePos() != ptpEnd )
        {
            // TODO (JHarding): This won't see text frags.
            if( !ptpBegin->NextTreePos()->IsPointer() )
                break;

            ptpBegin = ptpBegin->NextTreePos();
        }

        fAtomicSave = ( ptpBegin->NextTreePos() == ptpEnd );
    }
#endif // ATOMICGENERIC

    //
    // For printing, persist out the current state of any viewlinked markup
    //
    if (    pDoc
        &&  pMarkup
        &&  pDoc->_fSaveTempfileForPrinting
        &&  !fEnd
        &&  HasSlavePtr())
    {
        CMarkup * pSlaveMarkup = GetSlavePtr()->GetMarkup();
        if( pSlaveMarkup ) // && pSlaveMarkup->GetReadyState() >= READYSTATE_LOADED )
        {
            TCHAR   achTempLocation[pdlUrlLen];

            _tcscpy(achTempLocation, _T("file://"));

            Assert(pdlUrlLen >= MAX_PATH + 7);

            // Obtain a temporary file name
            if (pDoc->GetTempFilename( _T("\0"), _T("htm"), ((TCHAR *)achTempLocation)+7 ) )
            {
                VARIANT varProp;

                // Save the submarkup
                hr = THR( pSlaveMarkup->Save(((TCHAR *)achTempLocation)+7, FALSE) );

                fExpando = pMarkup->_fExpando;
                pMarkup->_fExpando = TRUE;

                // Set an attribute so that we can relink the markup on the print side...
                // NOTE: If this expando ever becomes accessible to script (across the WriteTag call below, or whatever)
                //       we have a security hole.  See IE6 bug 15775 for effects.
                V_VT(&varProp)     = VT_BSTR;
                V_BSTR(&varProp)   = SysAllocString(achTempLocation);

                PrimitiveSetExpando(_T("__IE_ViewLinkSrc"), varProp);
                VariantClear(&varProp);

                fSavedViewlink = TRUE;
            }
        }
    }

    if (ETAG_GENERIC_LITERAL != Tag())
    {
#ifdef ATOMICGENERIC
        hr = THR( WriteTag(pStreamWriteBuff, fEnd, FALSE, fAtomicSave) );
#else
        hr = THR( super::Save(pStreamWriteBuff, fEnd) );
#endif
        if(hr)
            goto Cleanup;
    }
    else // if (ETAG_GENERIC_LITERAL == Tag())
    {
        Assert (ETAG_GENERIC_LITERAL == Tag());

        dwOldFlags = pStreamWriteBuff->ClearFlags(WBF_ENTITYREF);
        pStreamWriteBuff->SetFlags(WBF_SAVE_VERBATIM | WBF_NO_WRAP);

        pStreamWriteBuff->BeginPre();

#ifdef ATOMICGENERIC
        hr = THR( WriteTag(pStreamWriteBuff, fEnd, FALSE, fAtomicSave) );
#else
        hr = THR( super::Save(pStreamWriteBuff, fEnd) );
#endif // ATOMICGENERIC
        if(hr)
            goto Cleanup;

        if ( !fEnd &&
             !pStreamWriteBuff->TestFlag( WBF_SAVE_PLAINTEXT ) &&
             !pStreamWriteBuff->TestFlag( WBF_FOR_TREESYNC ) )
        {
#ifdef ATOMICGENERIC
            Assert( !fAtomicSave );
#endif // ATOMICGENERIC
            hr = THR(pStreamWriteBuff->Write(_cstrContents));
            if (hr)
                goto Cleanup;
        }
        pStreamWriteBuff->EndPre();

        pStreamWriteBuff->RestoreFlags(dwOldFlags);
    }

    // If we set the attribute to persist out, remove it here.
    if (fSavedViewlink)
    {
        WHEN_DBG(HRESULT hrDbg =)  PrimitiveRemoveExpando(_T("__IE_ViewLinkSrc"));
        Assert(!hrDbg);

        pMarkup->_fExpando = fExpando;
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CGenericElement::namedRecordset
//
//  Synopsis:   returns an ADO Recordset for the named data member.  Tunnels
//              into the hierarchy using the path, if given.
//
//  Arguments:  bstrDataMember  name of data member (NULL for default)
//              pvarHierarchy   BSTR path through hierarchy (optional)
//              pRecordSet      where to return the recordset.
//
//
//----------------------------------------------------------------------------

HRESULT
CGenericElement::namedRecordset(BSTR bstrDatamember,
                               VARIANT *pvarHierarchy,
                               IDispatch **ppRecordSet)
{
    HRESULT hr;
    CDataMemberMgr *pdmm;

#ifndef NO_DATABINDING
    EnsureDataMemberManager();
    pdmm = GetDataMemberManager();
    if (pdmm)
    {
        hr = pdmm->namedRecordset(bstrDatamember, pvarHierarchy, ppRecordSet);
        if (hr == S_FALSE)
            hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }

#else
    *pRecordSet = NULL;
    hr = S_OK;
#endif NO_DATABINDING

    RRETURN (SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  Member:     CGenericElement::getRecordSet
//
//  Synopsis:   returns an ADO Recordset pointer if this site is a data
//              source control
//
//  Arguments:  IDispatch **    pointer to a pointer to a record set.
//
//
//----------------------------------------------------------------------------

HRESULT
CGenericElement::get_recordset(IDispatch **ppRecordSet)
{
    return namedRecordset(NULL, NULL, ppRecordSet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\hyplnk.cxx ===
//=-----------------------------------------------------------=
//
// File:        earea.cxx
//
// Contents:    Area element class
//
// Classes:     CHyperlink
//
//=-----------------------------------------------------------=


#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_HYPLNK_HXX_
#define X_HYPLNK_HXX_
#include "hyplnk.hxx"
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X_MSRATING_HXX_
#define X_MSRATING_HXX_
#include "msrating.hxx" // AreRatingsEnabled()
#endif

MtDefine(CHyperlink, Elements, "CHyperlink")
MtDefine(CHyperlinkGetUrlComponent, Utilities, "CHyperlink::GetUrlComponent")


//+---------------------------------------------------------------------------
//
// Member: CHyperlink::SetStausText
//
//----------------------------------------------------------------------------

HRESULT
CHyperlink::SetStatusText()
{
    HRESULT     hr;
    CDoc *      pDoc    = Doc();
    TCHAR *     pchUrl  = NULL;

    hr = GetUrlComponent(NULL, URLCOMP_WHOLE, &pchUrl);
    if (!hr && pchUrl)
    {
        TCHAR *pchFriendlyUrl = GetFriendlyUrl(
                pchUrl,
                pDoc->GetPrimaryUrl(),
                pDoc->_pOptionSettings->fShowFriendlyUrl, TRUE);

        pDoc->SetStatusText(pchFriendlyUrl, STL_ROLLSTATUS, GetMarkup());

        MemFreeString(pchFriendlyUrl);
        MemFreeString(pchUrl);
    }
    return hr;

}

//+------------------------------------------------------------------------
//
//  Member:     CHyperlink::CopyLinkToClipboard
//
//  Synopsis:   Copies the asssociated link to clipboard, which can then be
//              pasted onto dersktop as a URL shortcut, etc. 
//
//-------------------------------------------------------------------------
HRESULT CHyperlink::CopyLinkToClipboard(const TCHAR * pchDesc/*=NULL*/)
{
    HRESULT                     hr              = S_OK;
    IDataObject *               pDO             = NULL;
    IUniformResourceLocator *   pURLToDrag      = NULL;
    TCHAR                       cBuf[pdlUrlLen];
    TCHAR *                     pchExpandedUrl  = cBuf;
    CStr                        strUrlTitle;
    CWindow *                   pWindow;

    // fully resolve URL
    hr = THR(CMarkup::ExpandUrl(NULL, GetUrl(), ARRAY_SIZE(cBuf), pchExpandedUrl, this));
    if (hr)
        goto Cleanup;

    if (!pchDesc && S_OK == GetUrlTitle(&strUrlTitle))
    {
        pchDesc = strUrlTitle;
    }

    hr = THR(CreateLinkDataObject(pchExpandedUrl, pchDesc, &pURLToDrag));
    if (hr)
        goto Cleanup;

    hr = THR(pURLToDrag->QueryInterface(IID_IDataObject, (void **)&pDO));
    if (hr)
        goto Cleanup;

    pWindow = GetCWindowPtr();
    
    if (pWindow)
    {
        hr = THR(pWindow->SetClipboard(pDO));
    }
    
Cleanup:
    ReleaseInterface(pURLToDrag);
    ReleaseInterface(pDO);
    RRETURN(hr);
}


//+-------------------------------------------------------------------
//
// Members:     URL componenet access helpers
//
// sysnopsis:  [Get/Set]UrlComponentHelper wraps InternetCrackURL
//              the fucntions below all call the helper with diffent
//              component requests:
//              Hash
//              Host
//              search
//              Hostname
//              pathname
//              port
//              protocol
//--------------------------------------------------------------------
#define URL_COMPONENT_FLAGS  (ICU_DECODE | URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE)

HRESULT
CHyperlink::get_host(BSTR *pstr)
{
    RRETURN(SetErrorInfo(GetUrlComponent(pstr, URLCOMP_HOST, 
                NULL, URL_COMPONENT_FLAGS)));
}

HRESULT
CHyperlink::put_host(BSTR str)
{
    RRETURN(SetErrorInfo(SetUrlComponent(str, URLCOMP_HOST)));
}

HRESULT
CHyperlink::get_hostname(BSTR *pstr)
{
    RRETURN(SetErrorInfo(GetUrlComponent(pstr, URLCOMP_HOSTNAME, 
                NULL, URL_COMPONENT_FLAGS)));
}

HRESULT
CHyperlink::put_hostname(BSTR str)
{
    RRETURN(SetErrorInfo(SetUrlComponent(str, URLCOMP_HOSTNAME)));
}

HRESULT
CHyperlink::get_pathname(BSTR *pstr)
{
    RRETURN(SetErrorInfo(GetUrlComponent(pstr, URLCOMP_PATHNAME, 
                NULL, URL_COMPONENT_FLAGS)));
}

HRESULT
CHyperlink::put_pathname(BSTR str)
{
    RRETURN(SetErrorInfo(SetUrlComponent(str, URLCOMP_PATHNAME)));
}

HRESULT
CHyperlink::get_port(BSTR *pstr)
{
    RRETURN(SetErrorInfo(GetUrlComponent(pstr, URLCOMP_PORT, 
                NULL, URL_COMPONENT_FLAGS)));
}

HRESULT
CHyperlink::put_port(BSTR str)
{
    RRETURN(SetErrorInfo(SetUrlComponent(str, URLCOMP_PORT)));
}

HRESULT
CHyperlink::get_protocol(BSTR *pstr)
{
     RRETURN(SetErrorInfo(GetUrlComponent(pstr, URLCOMP_PROTOCOL, 
                NULL, URL_COMPONENT_FLAGS)));
}

HRESULT
CHyperlink::put_protocol(BSTR str)
{
    RRETURN(SetErrorInfo(SetUrlComponent(str, URLCOMP_PROTOCOL)));
}

HRESULT
CHyperlink::get_search(BSTR *pstr)
{
    RRETURN(SetErrorInfo(GetUrlComponent(pstr, URLCOMP_SEARCH, 
                NULL, URL_COMPONENT_FLAGS)));
}

HRESULT
CHyperlink::put_search(BSTR str)
{
    RRETURN(SetErrorInfo(SetUrlComponent(str, URLCOMP_SEARCH)));
}

HRESULT
CHyperlink::get_hash(BSTR *pstr)
{
    RRETURN(SetErrorInfo(GetUrlComponent(pstr, URLCOMP_HASH, 
                NULL, URL_COMPONENT_FLAGS)));
}

HRESULT
CHyperlink::put_hash(BSTR str)
{
    RRETURN(SetErrorInfo(SetUrlComponent(str, URLCOMP_HASH)));
}

STDMETHODIMP
CHyperlink::get_href(BSTR * p)
{
    RRETURN(SetErrorInfo(GetUrlComponent(p, URLCOMP_WHOLE, 
                NULL, URL_COMPONENT_FLAGS)));
}

STDMETHODIMP
CHyperlink::put_href(BSTR v)
{
    RRETURN(SetErrorInfo(SetUrlComponent(v, URLCOMP_WHOLE)));
}

//+-----------------------------------------------------------
//
//  Member  : GetUrlComponenet
//
//  Synopsis    : return a componenet of the href
//              the OM calls to this always fill in a BSTR and 
//                   a NULL ppchurl and require no processing, 
//                   merely the componenet spliting
//              internal calls to this are the opposite and 
//                   are processed (expamded, encoded and then split)
//              this functin is written so that it returns one
//                   or the other of these, but not both. I always
//                   test just one of the pair for consistency.
//              if you make changes to get/set/shortcut make sure to 
//                  make the changes to their clones in CAnchorElemnt
//-----------------------------------------------------------

HRESULT
CHyperlink::GetUrlComponent(BSTR     * pstrComp, 
                  URLCOMP_ID ucid, 
                  TCHAR   ** ppchUrl,
                  DWORD      dwFlags)
{
    HRESULT  hr = S_OK;
    TCHAR  * pchTheHref = (TCHAR*)GetUrl();
    TCHAR   cBuf[pdlUrlLen];
    TCHAR  * pchNewUrl  = cBuf;

    // make sure we have at least one place to return a value
    Assert(!(pstrComp && ppchUrl));
    if (!pstrComp && !ppchUrl)
    {
        hr = E_INVALIDARG;
        goto Cleanup;
    }

    if (ppchUrl)
        *ppchUrl = NULL;
    else
        *pstrComp = NULL;

    if (!pchTheHref)
        goto Cleanup;

    // get the expanded string 
    hr = THR(CMarkup::ExpandUrl(GetMarkup(), pchTheHref, ARRAY_SIZE(cBuf), pchNewUrl, this, dwFlags));

    // don't bail out if OM set has occured and OM is asking for the component.
    if (hr && (!_fOMSetHasOccurred || ppchUrl))
        goto Cleanup;

    // if asking for whole thing, just set return param
    if (ucid == URLCOMP_WHOLE)
    {
        if (ppchUrl)
        {
            MemAllocString(Mt(CHyperlinkGetUrlComponent), pchNewUrl, ppchUrl);
        }
        else
        {
            *pstrComp = (_fOMSetHasOccurred) ? SysAllocString(pchTheHref) :
                               SysAllocString(pchNewUrl);
            hr = (!*pstrComp) ? E_OUTOFMEMORY : S_OK;
        }
    }
    else
    {
        // we want a piece, so split it up.
        CStr cstrComponent; 
        // we need to use TheHref when a set has happened. but when hash/search
        //  is requested we NEED to crack the url properly, so we need to use
        //  pchNewUrl.
        BOOL fUseTheHref = _fOMSetHasOccurred && ((ucid != URLCOMP_HASH) && 
                              (ucid != URLCOMP_SEARCH));

        // bail out if we have to use expanded Url, but the Combine failes and we are
        // here because an OM set has already occured and an OM get is happening now.
        if (!fUseTheHref && hr)
            goto Cleanup;

        if (!pchNewUrl || pchNewUrl[0]==NULL || 
            (_fOMSetHasOccurred && (!pchTheHref || pchTheHref[0]==NULL)))
            goto Cleanup;

        hr = THR(GetUrlComponentHelper((fUseTheHref ? pchTheHref: pchNewUrl), 
                        &cstrComponent, 
                        dwFlags, 
                        ucid));
        if (hr == E_FAIL)
        {
            hr = S_OK;
            goto Cleanup;
        }


        if (ppchUrl)
        {
            if (cstrComponent)
            {
                hr = THR(MemAllocString(Mt(CHyperlinkGetUrlComponent),
                            cstrComponent, ppchUrl));
            }
            else
                *ppchUrl = NULL;
        }
        else
        {
            hr = THR(cstrComponent.AllocBSTR(pstrComp));
        }

    }

Cleanup:

    RRETURN (hr);
}

//+-----------------------------------------------------------
//
//  Member  : SetUrlComponenet
//
//  Synopsis    : field the various component setting requests
//
//-----------------------------------------------------------

HRESULT
CHyperlink::SetUrlComponent(const BSTR bstrComp, URLCOMP_ID ucid)
{
    HRESULT     hr=S_OK;
    TCHAR       achUrl[pdlUrlLen];
    TCHAR     * pchTheHref = NULL;

    // if set_href, just set it
    if (ucid == URLCOMP_WHOLE)
    {
        hr = THR(SetUrl(bstrComp));
    }
    else
    {
        // get the old url
        hr = THR(GetUrlComponent(NULL, URLCOMP_WHOLE, &pchTheHref, 
                     ICU_DECODE));
        if (hr || !pchTheHref)
            goto Cleanup;

        // expand it if necessary
        if ((ucid != URLCOMP_HASH) && (ucid != URLCOMP_SEARCH))
        {
            // and set the appropriate component
            hr = THR(SetUrlComponentHelper(pchTheHref,
                           achUrl,
                           ARRAY_SIZE(achUrl),
                           &bstrComp,
                           ucid));
        }
        else
        {
            hr = THR(ShortCutSetUrlHelper(pchTheHref,
                       achUrl,
                       ARRAY_SIZE(achUrl),
                       &bstrComp,
                       ucid));
        }
        if (hr)
            goto Cleanup;

        hr = THR(SetUrl((BSTR)achUrl));
    }
                        

Cleanup:
    if (pchTheHref)
        MemFreeString(pchTheHref);

    RRETURN(hr);
}

HRESULT CHyperlink::ClickAction(CMessage *pmsg)
{
    HRESULT         hr = S_OK;

    // Disable this feature, because this breaks compat. with IE$, where
    // Shift+Click causes the navigation to occur in a new browser window.
#ifdef NEVER
    // Shift+Click should do 'SaveAs'
    if (pmsg && pmsg->message == WM_LBUTTONUP && (pmsg->dwKeyState & FSHIFT))
    {
        MSOCMD cmd;

        cmd.cmdID = IDM_SAVETARGET;
        cmd.cmdf  = 0;

        hr = QueryStatusHelper((GUID *)&CGID_MSHTML, 1, &cmd, NULL, TRUE);
        if (hr == S_OK && cmd.cmdf != 0 && cmd.cmdf != MSOCMDSTATE_DISABLED)
        {
            hr = ExecHelper((GUID *)&CGID_MSHTML, cmd.cmdID, 0, NULL, NULL, FALSE);
        }

    }
    else
#endif
    {
        const TCHAR *   pchUrl = GetUrl();

        // This used to not hyperlink if the HREF was "".  For compatibility
        // with Navigator, we need to hyperlink even in that case.  The only
        // time we don't want to hyperlink is if the HREF is not supplied at all.

        if (pchUrl)
        {
            CDoc *  pDoc                = Doc();
            BOOL    fUseNewWindow       = (pmsg && pmsg->message != WM_MOUSEWHEEL)
                                            ? !!(pmsg->dwKeyState & MK_SHIFT)
                                            : FALSE;
            COmWindowProxy *pWindow = NULL;
            CWindow *pWindowParent;
            Assert(pDoc);

            while (pDoc->_fScriptletDoc)
            {
                Assert(pDoc->_pWindowPrimary);
                Assert(pDoc->_pWindowPrimary->Window());
                pWindowParent = pDoc->_pWindowPrimary->Window()->_pWindowParent;
                if (pWindowParent)
                {
                    pWindow = pWindowParent->Markup()->Window();
                    pDoc = pWindowParent->Doc();
                }
                else
                    break;
                    
                Assert(pDoc);
            }

            hr = THR(pDoc->FollowHyperlink(     /* formal arg name  */
                                pchUrl,         /* pchURL           */
                                GetTarget(),    /* pchTarget        */
                                this,           /* pElementContext  */
                                NULL,           /* pDwnPost         */
                                FALSE,          /* fSendAsPost      */
                                NULL,           /* pchExtraHeaders  */
                                FALSE        ,  /* fOpenInNewWindow */
                                pWindow,        /* pWindow          */
                                NULL,           /* ppWindowOut      */
                                0,              /* dwBindf          */
                                ERROR_SUCCESS,  /* dwSecurityCode   */
                                FALSE,          /* fReplace         */
                                NULL,           /* ppHTMLWindow2    */
                                fUseNewWindow,  /* fOpenInNewBrowser*/
                                CDoc::FHL_HYPERLINKCLICK | CDoc::FHL_SETDOCREFERER
                           ));
        }
    }
    RRETURN1(hr, S_FALSE);
}

//+--------------------------------------------------------------------------
//
//  Method :    CHyperlink::GetHyperlinkCursor
//
//  Synopsis :  Get cursor based on offline state and cache
//
//---------------------------------------------------------------------------

extern BOOL IsGlobalOffline();

LPTSTR
CHyperlink::GetHyperlinkCursor()
{
    if (!IsGlobalOffline())
        return MAKEINTRESOURCE(IDC_HYPERLINK);

    if (!_fAvailableOfflineValid)
    {
        _fAvailableOffline = Doc()->IsAvailableOffline(GetUrl(), this);
        _fAvailableOfflineValid = TRUE;
    }

    return _fAvailableOffline ? MAKEINTRESOURCE(IDC_HYPERLINK) : MAKEINTRESOURCE(IDC_HYPERLINK_OFFLINE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CHyperlink::QueryStatusHelper
//
//  Synopsis:   Implements QueryStatus for CHyperlink
//
//----------------------------------------------------------------------------

HRESULT
CHyperlink::QueryStatusHelper(
        GUID * pguidCmdGroup,
        ULONG cCmds,
        MSOCMD rgCmds[],
        MSOCMDTEXT * pcmdtext)
{
    int idm;

    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));
    Assert(cCmds == 1);

    MSOCMD *        pCmd    = &rgCmds[0];
    HRESULT         hr      = S_OK;
    const TCHAR *   pchUrl  = GetUrl();

    Assert(!pCmd->cmdf);

    idm = CBase::IDMFromCmdID(pguidCmdGroup, pCmd->cmdID);
    switch (idm)
    {
    case IDM_FOLLOWLINKC:
    case IDM_FOLLOWLINKN:
    case IDM_PRINTTARGET:
    case IDM_SAVETARGET:

        // Plug a ratings security hole.
        if ((idm == IDM_PRINTTARGET || idm == IDM_SAVETARGET) &&
            S_OK == AreRatingsEnabled())
        {
            pCmd->cmdf = MSOCMDSTATE_DISABLED;
            break;
        }

        // Enable "Open->In Current Window"; enable "Open->In New Window"
        //  if protocol is not "mailto:"
        // Note: We don't need to call ExpandUrl() here
        if (pchUrl && (idm == IDM_FOLLOWLINKC ||
                        !_tcsnipre(_T("mailto:"), 7, pchUrl, -1)))
        {
            pCmd->cmdf = MSOCMDSTATE_UP;
        }
        break;
    case IDM_ADDFAVORITES:
    case IDM_COPYSHORTCUT:
        if (pchUrl)
        {
            pCmd->cmdf = MSOCMDSTATE_UP;
        }
        break;
    case IDM_CUT:
        // Enable if script wants to handle it, otherwise leave it to default
        if (!Fire_onbeforecut())
        {
            pCmd->cmdf = MSOCMDSTATE_UP;
        }
        break;
    case IDM_COPY:
        // Enable if script wants to handle it, otherwise leave it to default
        if (!Fire_onbeforecopy())
        {
            pCmd->cmdf = MSOCMDSTATE_UP;
        }
        break;
    case IDM_PASTE:
        // Enable if script wants to handle it, otherwise leave it to default
        if (!Fire_onbeforepaste())
        {
            pCmd->cmdf = MSOCMDSTATE_UP;
        }
        break;
    }

    RRETURN_NOTRACE(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CHyperlink::ExecHelper
//
//  Synopsis:   Executes a command on the CHyperlink
//
//----------------------------------------------------------------------------

HRESULT
CHyperlink::ExecHelper(
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));

    int             idm             = CBase::IDMFromCmdID(pguidCmdGroup, nCmdID);
    HRESULT         hr              = MSOCMDERR_E_NOTSUPPORTED;
    const TCHAR *   pchUrl          = GetUrl();
    TCHAR   cBuf[pdlUrlLen];
    TCHAR *         pchExpandedUrl  = cBuf;

    switch (idm)
    {
    case IDM_FOLLOWLINKC:
    case IDM_FOLLOWLINKN:
    case IDM_SAVETARGET:
    case IDM_PRINTTARGET:
    {
        if (pchUrl && !_tcsnipre(_T("mailto:"), 7, pchUrl, -1))
        {
            CDoc *  pDoc = Doc();

            if ((idm == IDM_PRINTTARGET) || (idm == IDM_SAVETARGET))
            {
                // Plug a ratings security hole.
                if (S_OK == AreRatingsEnabled())
                {
                    Assert(hr == MSOCMDERR_E_NOTSUPPORTED);
                    break;
                }

                hr = THR(CMarkup::ExpandUrl(NULL, pchUrl, ARRAY_SIZE(cBuf), pchExpandedUrl, this));

                if (hr == S_OK)
                {
                    if (idm == IDM_PRINTTARGET)
                    {
                        hr = pDoc->PrintHandler(Document(), NULL, pchExpandedUrl);
                    }
                    else    // IDM_SAVETARGET
                        hr = DoFileDownLoad(pchExpandedUrl);
                    if (hr == S_OK)
                    {
                        IGNORE_HR(SetVisited());
                    }

                }
            }
            else
            {
                hr = THR(pDoc->FollowHyperlink(
                            pchUrl,                 // pchURL
                            GetTarget(),            // pchTarget
                            this,                   // pElementContext
                            NULL,                   // pDwnPost
                            FALSE,                  // fSendAsPost
                            NULL,                   // pchExtraHeaders
                            FALSE,                  // fOpenInNewWindow
                            NULL,                   // pWindow
                            NULL,                   // ppWindowOut
                            0,                      // dwBindOptions
                            ERROR_SUCCESS,          // dwSecurityCode
                            FALSE,                  // fReplace
                            NULL,                   // ppHTMLWindow2
                            idm == IDM_FOLLOWLINKN, // fOpenInNewBrowser
                            CDoc::FHL_HYPERLINKCLICK | CDoc::FHL_SETDOCREFERER
                            )
                        );
            }
        }
        break;
    }

    case IDM_COPYSHORTCUT:
        if (pchUrl)
            hr = THR(CopyLinkToClipboard());
        break;

    case IDM_ADDFAVORITES:
        if (pchUrl)
        {
            CStr strUrlTitle;
            CDoc *  pDoc = Doc();

            hr = THR(CMarkup::ExpandUrl(NULL, pchUrl, ARRAY_SIZE(cBuf), pchExpandedUrl, this));
            if (hr)
                goto Cleanup;
            IGNORE_HR(GetUrlTitle(&strUrlTitle));
            hr = pDoc->AddToFavorites(pchExpandedUrl, strUrlTitle);
        }
        break;
    case IDM_CUT:
        if (!Fire_oncut())
            hr = S_OK;
        break;
    case IDM_COPY:
        if (!Fire_oncopy())
            hr = S_OK;
        break;
    case IDM_PASTE:
        if (!Fire_onpaste())
            hr = S_OK;
        break;
    }

Cleanup:
    RRETURN_NOTRACE(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\mmplay.cxx ===
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_MMPLAY_HXX_
#define X_MMPLAY_HXX_
#include "mmplay.hxx"
#endif

#ifndef X_STRMIF_H_
#define X_STRMIF_H_
#include <strmif.h>
#endif

#ifndef X_CONTROL_H_
#define X_CONTROL_H_
#include <control.h>
#endif

#ifndef X_EVCODE_H_
#define X_EVCODE_H_
#include "evcode.h"
#endif

#ifndef X_UUIDS_H_
#define X_UUIDS_H_
#include <uuids.h>
#endif

#ifdef WIN16
#ifndef X_MMSYSTEM_H_
#define X_MMSYSTEM_H_
#include <mmsystem.h>
#endif

WORD MapFileToDeviceType(LPCTSTR);
#endif

#define DEFAULT_VIDEOWIDTH 32
#define DEFAULT_VIDEOHEIGHT 32

MtDefine(CIEMediaPlayer, Dwn, "CIEMediaPlayer")
MtDefine(CIEMediaPlayerUrl, CIEMediaPlayer, "CIEMediaPlayer::_pchUrl")

// ======================================================================
//
// ======================================================================
CIEMediaPlayer::CIEMediaPlayer()
{
    _ulRefs = 1;        // born with 1
    _fState = IEMM_Uninitialized;
#ifdef WIN16
    _wMCIDeviceID = -1;
#else
    _pGraph = NULL;
#endif
    _pchURL = NULL;
    _hwndOwner = NULL;
    _fHasAudio = FALSE;
    _fHasVideo = FALSE;

    _fDataDownloaded = FALSE;
    _fRestoreVolume = FALSE;
    _lLoopCount = 1;
    _lPlaysDone = 0;
    _lOriginalVol = 1000;       // init it out of range 
    _lOriginalBal = -100000;    // ditto

    _xWidth = DEFAULT_VIDEOWIDTH; 
    _yHeight = DEFAULT_VIDEOHEIGHT;
}


// ======================================================================
//
// ======================================================================
CIEMediaPlayer::~CIEMediaPlayer()
{
    if(_fRestoreVolume)
    {
        SetVolume(_lOriginalVol);
        SetBalance(_lOriginalBal);
        Stop();
    }

    DeleteContents();
}
#if !defined(WINCE) && !defined(NO_MEDIA_PLAYER)
// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::QueryInterface (REFIID riid, LPVOID * ppv)
{ 
    if (riid == IID_IUnknown)
    {
        *ppv = (IUnknown *) this;
        AddRef();
        return S_OK;
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


// ======================================================================
//
// ======================================================================
void CIEMediaPlayer::DeleteContents( void )
{
#ifdef WIN16
    mciSendCommand(_wMCIDeviceID, MCI_CLOSE, 0, 0);
#else
    if (_pGraph) 
    {
        if (_hwndOwner)
        {
            HRESULT hr;
            IVideoWindow * pVW = NULL;
            hr = _pGraph->QueryInterface(IID_IVideoWindow, (void **) &pVW);
            if (OK(hr))
            {
                pVW->put_MessageDrain((OAHWND) NULL);
                pVW->Release();
                _hwndOwner = NULL;
            }
        }
        _pGraph->Release();
        _pGraph = NULL;
    }
#endif // ndef WIN16

    if(_pchURL)
    {
        MemFreeString(_pchURL);
        _pchURL = NULL;
    }

    _fState = IEMM_Uninitialized;
}

    
// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::Initialize(void) 
{
    HRESULT hr; // return code

#ifndef WIN16
    if(_pGraph)         // already initialized
    {
        _pGraph->Release(); // go away
        _pGraph = NULL;
    }


    hr = CoCreateInstance(CLSID_FilterGraph,    // get this documents graph object
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IGraphBuilder,
                          (void **) &_pGraph);

    if (FAILED(hr)) 
    {
        DeleteContents();
        return hr;
    }
#endif // ndef WIN16

    _fState = IEMM_Initialized;
    return S_OK;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetURL(const TCHAR  *pchURL)
{
    HRESULT hr = S_OK, hr2 = S_OK;
    IVideoWindow * pVW;

    if(!pchURL)
        return ERROR_INVALID_PARAMETER;

    MemReplaceString(Mt(CIEMediaPlayerUrl), pchURL, &_pchURL);
    
#ifdef WIN16
    mciSendCommand(_wMCIDeviceID, MCI_CLOSE, 0, 0);
#else
    if(_pGraph)
        Stop();     // We already have a graph built so call stop in case it's running
#endif // ndef WIN16

#if 1   // TODO: Davidna:     Do this until AMovie implements ReleaseAllFilters()
    hr = Initialize();       // This will release the Graph and CoCreateInstance() a new one.
#else
    hr = _pGraph->ReleaseAllFilters();       // Someday...
#endif

    if (FAILED(hr))
        goto Failed;

    _fDataDownloaded = TRUE;    // we we're passed in a valid URL

#ifdef WIN16
    MCI_OPEN_PARMS mciOpenParms;

    /*
     * Open the device by specifying the
     * device name and device element.
     * MCI will attempt to choose the
     * MIDI Mapper as the output port.
     */
    //mciOpenParms.lpstrDeviceType = (LPSTR)(LONG)MapFileToDeviceType(pchURL);
    mciOpenParms.lpstrElementName = _pchURL;
    if (hr = (HRESULT) mciSendCommand(NULL, MCI_OPEN,
            /*MCI_OPEN_TYPE |  */ MCI_OPEN_ELEMENT,
            (DWORD)(LPVOID) &mciOpenParms)) {
        
         /*
         * Failed to open device;
         * don't close it, just return error.
         */
        _fState = IEMM_Aborted;
        goto Failed;
    }
    else
    {
        _fState = IEMM_Stopped;
    }

    _wMCIDeviceID = mciOpenParms.wDeviceID;
#else
    // Build the graph.
    //
    // This won't return until the the file type is sniffed and the appropriate
    // graph is built
    //
    hr = _pGraph->RenderFile(_pchURL, NULL);
    if(SUCCEEDED(hr))
    {
        _fState = IEMM_Stopped;
    }
    else
    {
        _fState = IEMM_Aborted;
        goto Failed;
    }

    // Need to check to see if there's a Video renderer interface and
    // shut it off if it's there. Our default state is to show no window until
    // someone sets our window position
    //
    // For BGSound this allows video files to be used without having a video window
    //  pop up on us.
    // For DYNSRC a video window size will be set at which point we'll 
    //  turn the thing on again.
    
    hr = _pGraph->QueryInterface(IID_IVideoWindow, (void **) &pVW);
    if(OK(hr)) 
    {
        long lVisible;

        // if this fails then we have an audio only stream
        hr2 = pVW->get_Visible(&lVisible);  
        if(hr2 == S_OK)
        {
            SIZE size;
            GetSize(&size);             // this will get the size of the video source
                                        // and cache the results for later

            hr2 = pVW->put_AutoShow(0);  // turn off the auto show of the video window
            _fHasVideo = TRUE;
        }
        else
        {
            _xWidth = 0;
            _yHeight = 0;
        }
        pVW->Release();
    }

    _fUseSegments = FALSE;

    IMediaSeeking *pIMediaSeeking;
    hr = _pGraph->QueryInterface(IID_IMediaSeeking, (void **) &pIMediaSeeking);
    if( SUCCEEDED(hr))
    {
        // See if Segment seeking is supported (for Seamless looping)
        if (pIMediaSeeking)
        {
            DWORD dwCaps = AM_SEEKING_CanDoSegments;
            _fUseSegments =
                (S_OK == pIMediaSeeking->CheckCapabilities(&dwCaps));
        } 
        pIMediaSeeking->Release();
    }

    IBasicAudio *pIBa;
    long lOriginalVolume, lOriginalBalance;

    lOriginalVolume = lOriginalBalance = 0;

    hr = _pGraph->QueryInterface(IID_IBasicAudio, (void **) &pIBa);
    if( SUCCEEDED(hr))
    {
        hr2 = pIBa->get_Volume(&lOriginalVolume);
        if(hr2 == S_OK)
        {
            _fHasAudio = TRUE;
            pIBa->get_Balance(&lOriginalBalance);
        }
        pIBa->Release();
    }

    // save away the original volume so that we can restore it on our way out
    if(_fHasAudio && _lOriginalVol > 0)
    {
        _lOriginalBal = lOriginalBalance;
        _lOriginalVol = lOriginalVolume;
    }

#endif // ndef WIN16

Failed:
    return hr;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetVideoWindow(HWND hwnd)
{
    IVideoWindow * pVW = NULL;
    HRESULT        hr  = S_OK;

    if(!_fHasVideo)
        return S_FALSE;

#ifndef WIN16
    if(!_pGraph)
        return E_FAIL;

    if (hwnd)
    {
        _hwndOwner = hwnd;

        hr = _pGraph->QueryInterface(IID_IVideoWindow, (void **) &pVW);
        if (FAILED(hr))
            goto Cleanup;

        hr = pVW->put_Owner((OAHWND) hwnd);
        if (FAILED(hr))
            goto Cleanup;

        hr = pVW->put_MessageDrain((OAHWND) hwnd);
        if (FAILED(hr))
            goto Cleanup;

        hr = pVW->put_WindowStyle(WS_CHILDWINDOW);
        if (FAILED(hr))
            goto Cleanup;

        hr = pVW->put_BackgroundPalette(-1); // OATRUE
        if (FAILED(hr))
            goto Cleanup;
    }
#endif // ndef WIN16

Cleanup:
    if (pVW)
        pVW->Release();

    RRETURN(hr);
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetWindowPosition(RECT *prc)
{
    HRESULT hr;
    IVideoWindow * pVW = NULL;

    Assert(prc);

    if (!_fHasVideo)
        return S_FALSE;

#ifndef WIN16
    if (!_pGraph)
        return E_FAIL;

    hr = _pGraph->QueryInterface(IID_IVideoWindow, (void **) &pVW);
    if (FAILED(hr))
        goto Cleanup;

    hr = pVW->SetWindowPosition(prc->left,
                                prc->top,
                                prc->right - prc->left,
                                prc->bottom - prc->top);
#endif // ndef WIN16

Cleanup:
    if (pVW)
        pVW->Release();

    RRETURN(hr);

}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetVisible(BOOL fVisible)
{
    HRESULT hr;
    IVideoWindow * pVW = NULL;

    if(!_fHasVideo)
        return S_FALSE;

#ifndef WIN16
    if(!_pGraph)
        return E_FAIL;

    hr = _pGraph->QueryInterface(IID_IVideoWindow, (void **) &pVW);
    if (OK(hr))
    {
        if(fVisible)
            hr = pVW->put_Visible(-1);  // OATRUE
        else 
            hr = pVW->put_Visible(0);   // OAFALSE
    }

    if (pVW)
        pVW->Release();
#endif // ndef WIN16

    return hr;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::GetSize(SIZE *psize)
{
#ifdef WIN16
    psize->cx = psize->cy = 0;
    return S_OK;
#else
    long    lWidth = 0;
    long    lHeight = 0;
    HRESULT hr = S_OK;
    IBasicVideo * pBV = NULL;

    if(!_pGraph)
        return E_FAIL;

    if(_xWidth == DEFAULT_VIDEOWIDTH && _yHeight == DEFAULT_VIDEOHEIGHT)
    {
        hr = _pGraph->QueryInterface(IID_IBasicVideo, (void **) &pBV);

        if (OK(hr))
            hr = pBV->get_SourceWidth(&lWidth);

        if (OK(hr))
            hr = pBV->get_SourceHeight(&lHeight);
        
        if (OK(hr))
        {
            _xWidth = lWidth;
            _yHeight = lHeight;
        }
    }

    psize->cx = _xWidth;
    psize->cy = _yHeight;

    if (pBV)
        pBV->Release();

    return hr;
#endif
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetNotifyWindow(HWND hwnd, long lmsg, long lParam)
{
#ifdef WIN16
    return E_FAIL;
#else
    HRESULT hr = S_OK;
    IMediaEventEx *pMvEx = NULL;

    if(!_pGraph)
        return E_FAIL;

    hr = _pGraph->QueryInterface(IID_IMediaEventEx, (void **) &pMvEx);
    if (FAILED(hr))
        goto Failed;

    hr = pMvEx->SetNotifyWindow((OAHWND) hwnd, lmsg, lParam);
    
    pMvEx->Release();

Failed:
    return hr;
#endif
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetLoopCount(long uLoopCount)
{
    _lLoopCount = uLoopCount;
    _lPlaysDone = 0;
    return S_OK;
}

// ======================================================================
//
// ======================================================================
long CIEMediaPlayer::GetVolume(void)
{
#ifdef WIN16
    return E_FAIL;
#else
    HRESULT hr;
    IBasicAudio *pIBa;
    long lTheVolume=E_FAIL;

    if(_pGraph)
    {
        hr = _pGraph->QueryInterface(IID_IBasicAudio, (void **) &pIBa);
        if( SUCCEEDED(hr) && pIBa)
        {
            hr = pIBa->get_Volume(&lTheVolume);
            pIBa->Release();
        }
    }
    return lTheVolume;
#endif
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetVolume(long lVol)
{
#ifdef WIN16
    return E_FAIL;
#else
    HRESULT hr = S_OK;

    IBasicAudio *pIBa;

    if(lVol < -10000 && lVol > 0)
        return ERROR_INVALID_PARAMETER;

    if(!_pGraph)
        return E_FAIL;

    hr = _pGraph->QueryInterface(IID_IBasicAudio, (void **) &pIBa);
    if( SUCCEEDED(hr) && pIBa)
    {
        hr = pIBa->put_Volume(lVol);
        pIBa->Release();
    }
    _fRestoreVolume = TRUE;

    return hr;
#endif // ndef WIN16
}

// ======================================================================
//
// ======================================================================
long CIEMediaPlayer::GetBalance(void)
{
#ifdef WIN16
    return E_FAIL;
#else
    HRESULT hr;

    IBasicAudio *pIBa;
    long lTheBal=E_FAIL;

    if(_pGraph)
    {
        hr = _pGraph->QueryInterface(IID_IBasicAudio, (void **) &pIBa);
        if( SUCCEEDED(hr) && pIBa)
        {
            hr = pIBa->get_Balance(&lTheBal);
            pIBa->Release();
        }
    }

    return lTheBal;
#endif // ndef WIN16
}   
// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetBalance(long lBal)
{
#ifdef WIN16
    return E_FAIL;
#else
    HRESULT hr = S_OK;

    IBasicAudio *pIBa;

    if(lBal < -10000 && lBal > 10000)
        return ERROR_INVALID_PARAMETER;

    if(!_pGraph)
        return E_FAIL;

    hr = _pGraph->QueryInterface(IID_IBasicAudio, (void **) &pIBa);
    if( SUCCEEDED(hr) && pIBa)
    {
        hr = pIBa->put_Balance(lBal);
        pIBa->Release();
    }

    _fRestoreVolume = TRUE;

    return hr;
#endif // ndef WIN16
}

// ======================================================================
//
// ======================================================================
int CIEMediaPlayer::GetStatus(void)
{
    return _fState;
}


// ======================================================================
//
// CIEMediaPlayer commands
// ======================================================================
//
HRESULT CIEMediaPlayer::Play()
{
    HRESULT hr = S_OK;

    if (CanPlay())
    {
#ifdef WIN16
        MCI_PLAY_PARMS mciPlayParms = { 0,0,0};
        /*
        * Begin playback. The window procedure function
        * for the parent window is notified with an
        * MM_MCINOTIFY message when playback is complete.
        * The window procedure then closes the device.
        */
        if (hr = mciSendCommand(_wMCIDeviceID, MCI_PLAY,
            0, (DWORD)(LPVOID) &mciPlayParms)) {
            mciSendCommand(_wMCIDeviceID, MCI_CLOSE, 0, 0);
            return hr;
        }
#else
        IMediaControl *pMC = NULL;

        // Obtain the interface to our filter graph
        //
        hr = _pGraph->QueryInterface(IID_IMediaControl, (void **) &pMC);
        if (SUCCEEDED(hr) && pMC)
        {
            if (_fUseSegments)
            {
                // If we're using seamless looping, we need to 1st set seeking flags
                Seek(0);
            }

            // Ask the filter graph to play 
            hr = pMC->Run();

            if (SUCCEEDED(hr))
            {
                _fState = IEMM_Playing;
                if (_lLoopCount > 0)
                    _lPlaysDone++;
            }
            else
            {
                pMC->Stop();    // some filters in the graph may have started
                                // so we better stop them
            }
            pMC->Release();
        }
        else
            hr = S_FALSE;
#endif
    }

    RRETURN1(hr, S_FALSE);
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::Pause()
{
    HRESULT hr = S_OK;

    if( CanPause() )
    {
#ifdef WIN16
		// we are not too sophisticated, we just stop & start it.
		mciSendCommand(_wMCIDeviceID, MCI_CLOSE, 0, 0);
#else
        IMediaControl *pMC;
        // Obtain the interface to our filter graph
        hr = _pGraph->QueryInterface(IID_IMediaControl, (void **) &pMC);

        // Ask the filter graph to pause
        if( SUCCEEDED(hr ) )
            pMC->Pause();
        
        pMC->Release();

        _fState = IEMM_Paused;
#endif
    }
    else
        hr = S_FALSE;

    RRETURN1(hr, S_FALSE);
}

// ======================================================================
// 
//  Stop playback if it's active
//
// ======================================================================
HRESULT CIEMediaPlayer::Abort()
{
    // Must stop play first.
    //
    Stop();

    _fState = IEMM_Aborted;

    return S_OK;   // must not fail
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::Seek(ULONG uPosition)
{
#ifdef WIN16
    Assert(0);
    return S_FALSE;
#else
    HRESULT hr = S_OK;

    IMediaSeeking *pIMediaSeeking=NULL;
    if(_pGraph)
        hr = _pGraph->QueryInterface(IID_IMediaSeeking, (void **) &pIMediaSeeking);

    if( SUCCEEDED(hr) && pIMediaSeeking)
    {
        LONGLONG llStop;

        hr = pIMediaSeeking->GetPositions(NULL, &llStop);
        if (SUCCEEDED(hr) && (llStop > uPosition))
        {
            long lSegmentSeek = 0L;
            LONGLONG llPosition = (LONGLONG) uPosition;

            SetSegmentSeekFlags(&lSegmentSeek); // in case we're seamless looping
            hr = pIMediaSeeking->SetPositions( &llPosition
                                              , AM_SEEKING_AbsolutePositioning | lSegmentSeek
                                              , &llStop
                                              , AM_SEEKING_NoPositioning );
        }
        pIMediaSeeking->Release();
    }

    RRETURN1(hr, S_FALSE);
#endif // ndef WIN16
}

// ======================================================================
//
// ======================================================================
void CIEMediaPlayer::SetSegmentSeekFlags(LONG *plSegmentSeek)
{
#ifdef WIN16
    Assert(0);
#else
    if (plSegmentSeek)
    {
        *plSegmentSeek = 
            _fUseSegments && _lLoopCount != 1 ?
    	        ((_lLoopCount == -1) ||
	             (_lLoopCount > _lPlaysDone + 1) ? AM_SEEKING_NoFlush |
		        	  AM_SEEKING_Segment 
	            	: AM_SEEKING_NoFlush
                ) :  0L;
    }
#endif // ndef WIN16
}


// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::Stop()
{
    HRESULT hr = S_OK;

    if( CanStop() )
    {
#ifdef WIN16
        mciSendCommand(_wMCIDeviceID, MCI_CLOSE, 0, 0);
        Assert(0);
#else
        IMediaControl *pMC;

        // Obtain the interface to our filter graph
        hr = _pGraph->QueryInterface(IID_IMediaControl, (void **) &pMC);
        if( SUCCEEDED(hr) )
        {
            // Stop the filter graph
            hr = pMC->Stop();
            // Release the interface
            pMC->Release();

            // set the flags
            _fState = IEMM_Stopped;
        }
#endif
    }
    else
        hr = S_FALSE;

    RRETURN1(hr, S_FALSE);
}

//
// ======================================================================
//
// If the event handle is valid, ask the graph
// if anything has happened. eg the graph has stopped...
// ======================================================================
HRESULT CIEMediaPlayer::NotifyEvent(void) 
{
#ifdef WIN16
	Assert(0);
    return E_FAIL;
#else
    HRESULT hr = S_OK;
    long lEventCode;
    LONG_PTR lParam1, lParam2;
    IMediaEvent *pME = NULL;

    if(!_pGraph)
        return E_FAIL;

    hr = _pGraph->QueryInterface(IID_IMediaEvent, (void **) &pME); 
    if( FAILED(hr) )
        goto GN_Failed;

    hr = pME->GetEvent(&lEventCode, &lParam1, &lParam2, 0);
    if( FAILED(hr) )
        goto GN_Failed;

    if (lEventCode == EC_COMPLETE || lEventCode == EC_END_OF_SEGMENT)
    {
        // Do we need to loop?
        //
        if(_lLoopCount == -1 || _lLoopCount > _lPlaysDone )
        {
            Seek(0);        // we're still playing so seek back to the begining
                            // and we'll keep going
            if(_lLoopCount >0)
                _lPlaysDone++;
        }
        else    
        {
            // we're done stop the graph
            Stop();
            _fState = IEMM_Completed;
        }

    } else if ((lEventCode == EC_ERRORABORT) || (lEventCode == EC_USERABORT)      ) 
    {
        Stop();
    }

GN_Failed:
    if(pME) pME->Release();

    RRETURN1(hr, S_FALSE);
#endif
}

#else // !WINCE && !NO_MEDIA_PLAYER

// Just stub these methods out for GALAHAD / UNIX

// ======================================================================
//
// ======================================================================
void CIEMediaPlayer::DeleteContents( void )
{
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::QueryInterface (REFIID riid, LPVOID * ppv)
{ 
    *ppv = NULL;
    return E_NOINTERFACE;
}
    
// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::Initialize(void) 
{
    return E_FAIL;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetURL(const TCHAR  *pchURL)
{
	return E_FAIL;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetVideoWindow(HWND hwnd)
{
	return E_FAIL;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetWindowPosition(RECT *prc)
{
	return E_FAIL;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetVisible(BOOL fVisible)
{
	return E_FAIL;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::GetSize(SIZE *psize)
{
	return E_FAIL;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetNotifyWindow(HWND hwnd, long lmsg, long lParam)
{
	return E_FAIL;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetLoopCount(long uLoopCount)
{
    return E_FAIL;
}

// ======================================================================
//
// ======================================================================
long CIEMediaPlayer::GetVolume(void)
{
	return E_FAIL;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetVolume(long lVol)
{
	return E_FAIL;
}

// ======================================================================
//
// ======================================================================
long CIEMediaPlayer::GetBalance(void)
{
	return E_FAIL;
}
// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::SetBalance(long lBal)
{
	return E_FAIL;
}

// ======================================================================
//
// ======================================================================
int CIEMediaPlayer::GetStatus(void)
{
    return _fState;
}


// ======================================================================
//
// CIEMediaPlayer commands
// ======================================================================
//
HRESULT CIEMediaPlayer::Play()
{
	return E_FAIL;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::Pause()
{
	return E_FAIL;
}

// ======================================================================
// 
//  Stop playback if it's active
//
// ======================================================================
HRESULT CIEMediaPlayer::Abort()
{
	return E_FAIL;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::Seek(ULONG uPosition)
{
	return E_FAIL;
}

// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::Stop()
{
	return E_FAIL;
}

//
// ======================================================================
//
// ======================================================================
HRESULT CIEMediaPlayer::NotifyEvent(void) 
{
	return E_FAIL;
}

#endif // WINCE && NO_MEDIA_PLAYER
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscsite\e1d.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       e1d.cxx
//
//  Contents:   CFlowSite, C1DElement, CSpanSite, and related classes.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CGUID_H_
#define X_CGUID_H_
#include <cguid.h>
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_DIV_HXX_
#define X_DIV_HXX_
#include "div.hxx"
#endif

#ifndef X_EPHRASE_HXX_
#define X_EPHRASE_HXX_
#include "ephrase.hxx"
#endif

#ifndef X_E1D_HXX_
#define X_E1D_HXX_
#include "e1d.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#ifndef X_FSlYT_HXX_
#define X_FSLYT_HXX_
#include "fslyt.hxx"
#endif

#ifndef X_DISPDEFS_HXX_
#define X_DISPDEFS_HXX_
#include "dispdefs.hxx"
#endif

#ifndef X_THEMEHLP_HXX_
#define X_THEMEHLP_HXX_
#include "themehlp.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#define _cxx_
#include "e1d.hdl"

#define _cxx_
#include "espan.hdl"

MtDefine(C1DElement, Elements, "C1DElement")
MtDefine(CSpanSite, Elements, "CSpanSite")
MtDefine(CLegendElement, Elements, "CLegendElement")
MtDefine(CFieldSetElement, Elements, "CFieldSetElement")

const CElement::CLASSDESC C1DElement::s_classdesc =
{
    {
        &CLSID_HTMLDivPosition,         // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_TEXTSITE,           // Allow 1D element to inherit parent styles
        &IID_IHTMLDivPosition,          // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLDivPosition,   // _apfnTearOff
    NULL                                // _pAccelsRun
};

#ifndef NO_PROPERTY_PAGE
const CLSID * const C1DElement::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,
#endif    
    NULL
};
#endif // NO_PROPERTY_PAGE

const CElement::CLASSDESC CSpanSite::s_classdesc =
{
    {
        &CLSID_HTMLSpanFlow,            // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_TEXTSITE,       // Allow SPAN element to inherit parent styles
        &IID_IHTMLSpanFlow,             // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLSpanFlow,      // _apfnTearOff
    NULL                                // _pAccelsRun
};

#ifndef NO_PROPERTY_PAGE
const CLSID * const CSpanSite::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
    &CLSID_CInlineStylePropertyPage,
#endif // DBG==1 
    NULL
};
#endif // NO_PROPERTY_PAGE


////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////////////////

CFlowSite::CFlowSite (ELEMENT_TAG etag, CDoc *pDoc)
  : CTxtSite(etag, pDoc)
{
}



#ifndef NO_DATABINDING
#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

//+----------------------------------------------------------------------------
//
//  Function: GetDBindMethods, IHTMLElement
//
//  Synopsis: Get pointer to implementation of databinding support.
//
//-----------------------------------------------------------------------------
const CDBindMethods *
CFlowSite::GetDBindMethods()
{
    Assert(Tag() == ETAG_SPAN || Tag() == ETAG_DIV);
    return &DBindMethodsTextRichRO;
}
#endif // ndef NO_DATABINDING

//+----------------------------------------------------------------------------
//
//  For:    CFieldSetElement
//
//
//
//+----------------------------------------------------------------------------

const CElement::CLASSDESC CFieldSetElement::s_classdesc =
{
    {
        &CLSID_HTMLFieldSetElement,     // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_TEXTSITE,       // Allow 1D element to inherit parent styles
        &IID_IHTMLFieldSetElement,      // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLFieldSetElement, // _apfnTearOff
    NULL                                // _pAccelsRun
};

//+---------------------------------------------------------------------------
//
//  Member:     CFieldSetElement::CreateElement
//
//  Synopsis:   Create a FieldSet
//
//+---------------------------------------------------------------------------

HRESULT
CFieldSetElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(ppElement);

    *ppElement = new CFieldSetElement(pht->GetTag(), pDoc);

    RRETURN ( (*ppElement) ? S_OK : E_OUTOFMEMORY);
}

//+----------------------------------------------------------------------------
//
//  Member:     CFieldSetElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-----------------------------------------------------------------------------

HRESULT
CFieldSetElement::PrivateQueryInterface ( REFIID iid, void ** ppv )
{
    *ppv = NULL; 
    switch(iid.Data1)
    {
        QI_TEAROFF(this, IHTMLTextContainer, NULL)
        QI_TEAROFF(this, IHTMLFieldSetElement2, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFieldSetElement::GetBorderInfo
//
//  Synopsis:   provide BorderInfo
//              return FALSE when drawing, otherwise return TRUE
//
//----------------------------------------------------------------------------

DWORD
CFieldSetElement::GetBorderInfo(CDocInfo * pdci, CBorderInfo *pborderinfo, BOOL fAll, BOOL fAllPhysical FCCOMMA FORMAT_CONTEXT FCPARAM)
{
    DWORD nBorders  = super::GetBorderInfo( pdci, pborderinfo, fAll, fAllPhysical FCCOMMA FCPARAM);
    long  iBdrLeft  = pborderinfo->aiWidths[SIDE_LEFT];
    long  iBdrTop   = pborderinfo->aiWidths[SIDE_TOP];
    long  iBdrOff   = FIELDSET_CAPTION_OFFSET;

    CLegendLayout *     pLegendLayout;

    POINT   posLegend;
    SIZE    sizeLegend;
    SIZE    sizeFieldset;

    if (nBorders == DISPNODEBORDER_NONE)
        goto Cleanup;

    pLegendLayout = GetLegendLayout();
    if (!pLegendLayout)
        goto Cleanup;

    pLegendLayout->GetLegendInfo(&sizeLegend, &posLegend);
    GetUpdatedLayout()->GetSize(&sizeFieldset);

    if (pdci)
    {
        iBdrOff = pdci->DeviceFromDocPixelsY(FIELDSET_CAPTION_OFFSET);
    }

    // calc caption size and pos

    if (sizeLegend.cx > 0)
    {
        pborderinfo->sizeCaption.cx = posLegend.x - iBdrOff + iBdrLeft;
        pborderinfo->sizeCaption.cy = posLegend.x + sizeLegend.cx + iBdrOff + iBdrLeft;

        if (pborderinfo->sizeCaption.cx < 0)
            pborderinfo->sizeCaption.cx = 0;
        if (pborderinfo->sizeCaption.cy < 0)
            pborderinfo->sizeCaption.cy = 0;

        sizeFieldset.cx = sizeFieldset.cx - iBdrLeft * 2;

        if (pborderinfo->sizeCaption.cx > sizeFieldset.cx)
        {
            pborderinfo->sizeCaption.cx = sizeFieldset.cx;
        }
        if (pborderinfo->sizeCaption.cy > sizeFieldset.cx)
        {
            pborderinfo->sizeCaption.cy = sizeFieldset.cx;
        }
    }
    else
    {
        pborderinfo->sizeCaption.cx = 0;
        pborderinfo->sizeCaption.cy = 0;
    }


    // set offset
    if (sizeLegend.cy > 0)
    {
        pborderinfo->offsetCaption = posLegend.y + ((sizeLegend.cy - iBdrTop) >> 1);
        if (    pborderinfo->offsetCaption < 0 
           ||   pborderinfo->offsetCaption > sizeFieldset.cy)
        {
            pborderinfo->offsetCaption = 0;
        }
    }
    else
    {
        pborderinfo->offsetCaption = 0;
    }

    if (!_fDrawing)
    {
        pborderinfo->wEdges &= ~BF_TOP;
        pborderinfo->aiWidths[SIDE_TOP] = 0;
    }
    nBorders = DISPNODEBORDER_COMPLEX;

Cleanup:
    return nBorders;
}

CLegendLayout *
CFieldSetElement::GetLegendLayout()
{
    DWORD_PTR dw;
    CLayout * pLayout;
    CLayout * pLayoutThis = GetUpdatedLayout();
    CLegendLayout * pLegendLayout = NULL;

    Assert(pLayoutThis);

    // We can also enforce the fieldset legend to be the first element
    // in this case, we just need to return the first element in the site
    // array only if it is a legend
    for (pLayout = pLayoutThis->GetFirstLayout(&dw);
         pLayout;
         pLayout = pLayoutThis->GetNextLayout(&dw))
    {
        if (pLayout->Tag() == ETAG_LEGEND)
        {
            pLegendLayout = (CLegendLayout *)pLayout;
            break;
        }
    }
    pLayoutThis->ClearLayoutIterator(dw, FALSE);
    return pLegendLayout;
}

HRESULT
CFieldSetElement::ApplyDefaultFormat( CFormatInfo *pCFI )
{
    BYTE i;
    HRESULT hr;
    HTHEME hTheme = GetMarkup()->GetTheme(THEME_BUTTON);
    RECT            rcBg;
    CUnitValue      auv[SIDE_MAX];

    if (pCFI->_pcf->_bCursorIdx != styleCursorAuto)
    {
        //our intrinsics shouldn't inherit the cursor property. they have a 'default'
        pCFI->PrepareCharFormat();
        pCFI->_cf()._bCursorIdx = styleCursorAuto;
        pCFI->UnprepareForDebug();
    }

    pCFI->PrepareFancyFormat();

    CUnitValue uvBorder;
    uvBorder.SetValue(2, CUnitValue::UNIT_PIXELS);
    for (i = 0; i < SIDE_MAX; i++)
    {
        pCFI->_ff()._bd.SetBorderWidth(i, uvBorder);
        pCFI->_ff()._bd.SetBorderStyle(i, fmBorderStyleEtched);
    }

    pCFI->_ff()._bd._ccvBorderColorLight.SetSysColor(COLOR_3DLIGHT);
    pCFI->_ff()._bd._ccvBorderColorDark.SetSysColor(COLOR_3DDKSHADOW);
    pCFI->_ff()._bd._ccvBorderColorHilight.SetSysColor(COLOR_BTNHIGHLIGHT);
    pCFI->_ff()._bd._ccvBorderColorShadow.SetSysColor(COLOR_BTNSHADOW);

    pCFI->UnprepareForDebug();

    hr = THR(super::ApplyDefaultFormat(pCFI));
    if (hr)
        goto Cleanup;

    // Default to percent width (element's coordinate system).
    pCFI->PrepareFancyFormat();

    if (hTheme && !pCFI->_ff().IsThemeDisabled()) // the control is themed
    {
        // set theme defaults for properties not already set

        if (!THR(GetThemeBackgroundExtent(hTheme, NULL, BP_GROUPBOX, PBS_NORMAL, &g_Zero.rc, &rcBg)))
        {
            CUnitValue uv;

            if (!pCFI->_fPaddingLeftSet)
            {
                uv.SetValue( -rcBg.left, CUnitValue::UNIT_PIXELS);            
                pCFI->_ff().SetPadding(SIDE_LEFT, uv);
            }
            if (!pCFI->_fPaddingRightSet)
            {
                uv.SetValue( rcBg.right, CUnitValue::UNIT_PIXELS);            
                pCFI->_ff().SetPadding(SIDE_RIGHT, uv);
            }
            if (!pCFI->_fPaddingBottomSet)
            {
                uv.SetValue( rcBg.bottom, CUnitValue::UNIT_PIXELS);            
                pCFI->_ff().SetPadding(SIDE_BOTTOM, uv);
            }
        }           
    }

    if (pCFI->_pcf->HasVerticalLayoutFlow())
    {
        pCFI->_ff().SetHeightPercent(pCFI->_ff().IsHeightPercent() | pCFI->_ff().GetHeight().IsNullOrEnum());
    }
    else
    {
        pCFI->_ff().SetWidthPercent(pCFI->_ff().IsWidthPercent() | pCFI->_ff().GetWidth().IsNullOrEnum());
    }
    pCFI->UnprepareForDebug();

Cleanup:
    RRETURN(hr);
}

#ifndef NO_DATABINDING
const CDBindMethods *
CFieldSetElement::GetDBindMethods()
{
    // TODO: we probably want to support databniding to FieldSet's, but
    //  need to special-case any embedded Legend.
    return NULL;    // our superclass would do otherwise; suppress here
}
#endif // ndef NO_DATABINDING

const CElement::CLASSDESC CLegendElement::s_classdesc =
{
    {
        &CLSID_HTMLLegendElement,       // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_TEXTSITE,           // _dwFlags
        &IID_IHTMLLegendElement,        // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLLegendElement, // _pfnTearOff
    NULL                                // _pAccelsRun
};

HRESULT
CLegendElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(ppElement);

    *ppElement = new CLegendElement(pht->GetTag(), pDoc);

    RRETURN ( (*ppElement) ? S_OK : E_OUTOFMEMORY);
}

//+------------------------------------------------------------------------
//
//  Member:     CLegendElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CLegendElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_TEAROFF(this, IHTMLLegendElement2, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

HRESULT CLegendElement::ApplyDefaultFormat ( CFormatInfo * pCFI )
{
    HTHEME hTheme = GetMarkup()->GetTheme(THEME_BUTTON);    
    HRESULT hr = S_OK;

    pCFI->_bBlockAlign     = htmlBlockAlignNotSet;
    pCFI->_bCtrlBlockAlign = htmlBlockAlignNotSet;

    hr = super::ApplyDefaultFormat ( pCFI );

    pCFI->PrepareCharFormat();
    pCFI->PrepareFancyFormat();

    if (hTheme && !pCFI->_ff().IsThemeDisabled()) // set theme defaults
    {
        LOGFONT lf;
        CUnitValue  uv;     
        COLORREF    cr;

        if (!pCFI->_fFontSet && !GetThemeFont(hTheme, NULL, BP_GROUPBOX, PBS_NORMAL, TMT_FONT, &lf))
        {
            long    twips;
                        
            if (!pCFI->_fFontWeightSet)
                pCFI->_cf()._wWeight = lf.lfWeight;

            if (!pCFI->_fFontHeightSet)
            {
                twips = MulDivQuick(lf.lfHeight,
                                    TWIPS_PER_INCH,
                                    g_sizePixelsPerInch.cy);

                if(twips < 0)
                    twips = - twips;

                pCFI->_cf().SetHeightInTwips( twips );
            }
        }        

        if (!pCFI->_fFontColorSet && !GetThemeColor(hTheme, BP_GROUPBOX, 0, TMT_TEXTCOLOR, &cr))
        {
            pCFI->_cf()._ccvTextColor.SetValue( cr, FALSE);
        }

        uv.SetValue( FIELDSET_CAPTION_OFFSET, CUnitValue::UNIT_PIXELS);

        if (!pCFI->_fPaddingLeftSet)
            pCFI->_ff().SetPadding(SIDE_LEFT, uv);
        
        if (!pCFI->_fPaddingRightSet)
            pCFI->_ff().SetPadding(SIDE_RIGHT, uv);        
    }

    pCFI->UnprepareForDebug();

    RRETURN(hr);
}


void
CLegendElement::Notify(CNotification *pNF)
{
    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_QUERYMNEMONICTARGET:
        {
            FOCUS_ITEM  fi;
            CElement *  pParent;

            fi.pElement = NULL;
            fi.lSubDivision = 0;
    
            // Legend itself is not focussable; activate the next element in the fieldset
            if (    NULL != (pParent = GetFirstBranch()->SearchBranchToRootForTag(ETAG_FIELDSET)->Element())
                &&  Doc()->FindNextTabOrder(DIRECTION_FORWARD, FALSE, NULL, this, 0, &fi.pElement, &fi.lSubDivision)
                &&  fi.pElement && fi.pElement->GetFirstBranch()->SearchBranchToRootForScope(pParent))
            {
                *(FOCUS_ITEM *)pNF->DataAsPtr() = fi;
            }
        }
        break;
    default:
        super::Notify(pNF);
        break;
    }
}

#ifndef NO_DATABINDING
#include "elemdb.hxx"

const CDBindMethods *
CLegendElement::GetDBindMethods()
{
    return &DBindMethodsTextRichRO;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\estyle.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       estyle.cxx
//
//  Contents:   CStyleElement & related
//
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx" // for CStreamWriteBuf
#endif

#ifndef X_TYPES_H_
#define X_TYPES_H_
#include "types.h" // for s_enumdeschtmlReadyState
#endif

#ifndef X_STYLE_HXX_
#define X_STYLE_HXX_
#include "style.hxx"
#endif

#ifndef X_SHEETS_HXX_
#define X_SHEETS_HXX_
#include "sheets.hxx"
#endif

#ifndef X_ESTYLE_HXX_
#define X_ESTYLE_HXX_
#include "estyle.hxx"
#endif

#ifndef X_ELINK_HXX_
#define X_ELINK_HXX_
#include "elink.hxx"
#endif

#ifndef X_TREEPOS_HXX_
#define X_TREEPOS_HXX_
#include "treepos.hxx"
#endif

#ifndef X_HEDELEMS_HXX_
#define X_HEDELEMS_HXX_
#include "hedelems.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#if defined(_M_ALPHA)
#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif
#endif

#define _cxx_
#include "estyle.hdl"

MtDefine(CStyleElement, Elements, "CStyleElement")

const CElement::CLASSDESC CStyleElement::s_classdesc =
{
    {
        &CLSID_HTMLStyleElement,            // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLStyleElement,             // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLStyleElement,      // _apfnTearOff
    NULL                                    // _pAccelsRun
};


HRESULT CStyleElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(ppElement);

    *ppElement = new CStyleElement(pDoc);
    return *ppElement ? S_OK : E_OUTOFMEMORY;
}

CStyleElement::CStyleElement(CDoc *pDoc)
    : CElement(ETAG_STYLE, pDoc)
{
    _pStyleSheet = NULL;
    _fDirty = FALSE;
    _fParseFinished = TRUE;
    _readyStateStyle = READYSTATE_UNINITIALIZED;
    _fExplicitEndTag = TRUE;
}

HRESULT
CStyleElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_HTML_TEAROFF(this, IHTMLElement2, NULL)
    }

    if (*ppv)
    {
        ((IUnknown *) *ppv)->AddRef();
        RRETURN(S_OK);
    }

    RRETURN(super::PrivateQueryInterface(iid, ppv));
}


void
CStyleElement::Notify(CNotification *pNF)
{
    // call super (important in all cases, including ENTERTREE)
    super::Notify(pNF);

    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_ENTERTREE:
        _fEnterTreeCalled = TRUE;
        if (_fParseFinished)
        {
            // setText can only be called when both this element is in the tree
            // and the parsectx::Finish() has been called.  The reason for this 
            // is that SetText needs to set up the absolute URL path, and any
            // base tags above it might not be in the tree yet either.

            // When a STYLE sheet moves between trees (as in paste or innerHTML etc)
            // I get an exit then an enter - in this case, I don't need to 
            // re-parse the text
            if ( !_pStyleSheet )
                IGNORE_HR(SetText(_cstrText));
            else
            {
                // Insert the existing SS into this Markup
                CMarkup * pMarkup = GetMarkup();
                CStyleSheetArray * pStyleSheets = NULL;

                if (pMarkup)
                {
                    CElement *pHeadElement;
                    int nSSInHead;

                    // Check for the temporary holding SSA
                    if (_pSSATemp && (_pSSATemp == _pStyleSheet->GetSSAContainer()))
                    {
                        _pSSATemp->ReleaseStyleSheet( _pStyleSheet, FALSE );

                        // The Temp SSA's work is now done.
                        _pSSATemp->Free();
                        _pSSATemp->CBase::PrivateRelease();
                        _pSSATemp = NULL;
                    }

                    THR(pMarkup->EnsureStyleSheets());

                    pStyleSheets = pMarkup->GetStyleSheetArray();
     
                    pHeadElement = pMarkup->GetHeadElement();
                    if (pHeadElement)
                    {
                        CChildIterator ci ( pHeadElement );
                        CTreeNode      * pNode;
                        CLinkElement   * pLink;
                        CStyleElement  * pStyle;

                        nSSInHead = 0;

                        while ( (pNode = ci.NextChild()) != NULL )
                        {
                            if ( pNode->Tag() == ETAG_LINK )
                            {
                                pLink = DYNCAST( CLinkElement, pNode->Element() );
                                if ( pLink->_pStyleSheet ) // faster than IsLinkedStyleSheet() and adequate here
                                    ++nSSInHead;
                            }
                            else if ( pNode->Tag() == ETAG_STYLE )
                            {
                                pStyle = DYNCAST( CStyleElement, pNode->Element() );
                                if ( pStyle == this)
                                {
                                    break;
                                }
                                if ( pStyle->_pStyleSheet ) // Not all STYLE elements create a SS.
                                    ++nSSInHead;
                            }
                        }
                    }
                    else
                    {
                        nSSInHead = -1;
                    }                    

                    THR(pStyleSheets->AddStyleSheet(_pStyleSheet, nSSInHead));
    
                    // When exiting the tree the style rules are disable. Reenable them if they were
                    //     not also disabled on the element.
                    if(!GetAAdisabled())
                        IGNORE_HR(_pStyleSheet->ChangeStatus(CS_ENABLERULES, FALSE, NULL) );

                    IGNORE_HR(OnCssChange(/*fStable = */ FALSE, /* fRecomputePeers = */FALSE));

                }
            }
        }
        break;
    case NTYPE_STOP_1:
    case NTYPE_MARKUP_UNLOAD_1:
        // if the directly linked sheet already came down,
        // this will stop any of its imports.
        if (_pStyleSheet)
            _pStyleSheet->StopDownloads(FALSE);  

        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        {
            if (_pStyleSheet)
            {
                CMarkup * pMarkup = GetMarkup();
                CStyleSheetArray * pStyleSheets = NULL;

                if (pMarkup && !(pNF->DataAsDWORD() & EXITTREE_DESTROY))
                    pStyleSheets = pMarkup->GetStyleSheetArray();

                // Tell the top-level stylesheet collection to let go of it's reference
                if (pStyleSheets)
                    pStyleSheets->ReleaseStyleSheet( _pStyleSheet, FALSE );

                _pStyleSheet->StopDownloads(TRUE);

                if ( !(pNF->DataAsDWORD() & EXITTREE_DESTROY) ) 
                    pMarkup->EnsureFormatCacheChange( ELEMCHNG_CLEARCACHES );
            }
            _fEnterTreeCalled = FALSE;
        }
    }
}


void
CStyleElement::Passivate (void)
{
    if (_pStyleSheet)
    {
        // Removed from StyleSheetArray in the ExitTree notification

        // Halt all stylesheet downloading.
        _pStyleSheet->StopDownloads( TRUE );

        // Let go of our reference
        _pStyleSheet->Release();    // this will subrel ourselves
        _pStyleSheet = NULL;
    }

    if (_pSSATemp)
    {
        _pSSATemp->Free();
        _pSSATemp->Release();
        _pSSATemp = NULL;
    }
   
    super::Passivate();
}


//+------------------------------------------------------------------------
//
//  Member:     InvokeExReady
//
//  Synopsis  :this is only here to handle readyState queries, everything
//      else is passed on to the super
//
//+------------------------------------------------------------------------

#ifdef USE_STACK_SPEW
#pragma check_stack(off)
#endif

STDMETHODIMP
CStyleElement::ContextThunk_InvokeExReady(DISPID dispid,
                             LCID lcid,
                             WORD wFlags,
                             DISPPARAMS *pdispparams,
                             VARIANT *pvarResult,
                             EXCEPINFO *pexcepinfo,
                             IServiceProvider *pSrvProvider)
{
    IUnknown * pUnkContext;

    // Magic macro which pulls context out of nowhere (actually eax)
    CONTEXTTHUNK_SETCONTEXT

    HRESULT  hr = S_OK;

    hr = THR(ValidateInvoke(pdispparams, pvarResult, pexcepinfo, NULL));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(ReadyStateInvoke(dispid, wFlags, _readyStateFired, pvarResult));
    if (hr == S_FALSE)
    {
        hr = THR_NOTRACE(super::ContextInvokeEx(dispid,
                                         lcid,
                                         wFlags,
                                         pdispparams,
                                         pvarResult,
                                         pexcepinfo,
                                         pSrvProvider,
                                         pUnkContext ? pUnkContext : (IUnknown*)this));
    }

Cleanup:
    RRETURN(hr);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(on)
#endif

//+---------------------------------------------------------------
//
//  Member : CStyleElement::Save
//
//  Synopsis    :   Standard Save routine
//
//+---------------------------------------------------------------
HRESULT
CStyleElement::Save(CStreamWriteBuff * pStreamWriteBuff, BOOL fEnd)
{
    HRESULT hr = S_OK;
    DWORD   dwOld;

    // No styles for plaintext mode
    if (pStreamWriteBuff->TestFlag(WBF_SAVE_PLAINTEXT))
        return S_OK;

    if (!fEnd)
    {
        hr = THR(pStreamWriteBuff->NewLine());
        if(hr)
            goto Cleanup;
    }

    //
    // Save tagname and attributes.
    //

    hr = THR(super::Save(pStreamWriteBuff, fEnd));
    if (hr)
        goto Cleanup;

    if (fEnd)
    {
        // New line after </STYLE>
        hr = THR(pStreamWriteBuff->NewLine());
        goto Cleanup;
    }

    //
    // Tell the write buffer to just write this string
    // literally, without checking for any entity references.
    //

    dwOld = pStreamWriteBuff->ClearFlags(WBF_ENTITYREF);

    //
    // Tell the stream to now not perform any fancy indenting
    // or such stuff.
    //

    pStreamWriteBuff->BeginPre();

    if ( _fDirty )
    {   // This stylesheet has been touched through the OM, we need to
        // use the internal data to get the contents to persist.
        _cstrText.Free();
        if ( _pStyleSheet )
        {
            hr = _pStyleSheet->GetString( &_cstrText );
            if (hr)
                goto Cleanup;
        }
    }
    hr = THR(pStreamWriteBuff->Write((LPTSTR)_cstrText));
    if (hr)
        goto Cleanup;

    if ( _fDirty )  // Don't leave our string around
        _cstrText.Free();

    pStreamWriteBuff->EndPre();
    pStreamWriteBuff->SetFlags(dwOld);

Cleanup:
    RRETURN(hr);
}

void CStyleElement::SetDirty( void )
{
    _cstrText.Free();
    _fDirty = TRUE;
}

//+---------------------------------------------------------------
//
//  Member:     CStyleElement::SetText
//
//  Synopsis:   Sets the text owned by the style
//
//  TODO: If this is called more than once per lifetime of a
//  style element, we need to fix the CreateNewStyleSheet call
//  so the old CStyleSheet is taken care of etc.  Right now the
//  assumption is that this is never called more than once
//  per lifetime of a style element.
//
//+---------------------------------------------------------------

HRESULT
CStyleElement::SetText(TCHAR *pch)
{
    CCSSParser *pcssp;
    HRESULT hr = S_OK;
    LPCTSTR szType;
    CDoc *  pDoc = Doc();
    CMarkup * pMarkup = GetMarkup();
    CStyleSheetArray *pSSA;
    CStyleSheetCtx  ctxSS;

    szType = GetAAtype();
    if ( szType && StrCmpIC( _T("text/css"), szType ) )
        goto Save_Contents;

    Assert( "Already have a stylesheet on this element!" && !_pStyleSheet );

    SetReadyStateStyle( READYSTATE_LOADING );

    if (pMarkup)
    {
        hr = pMarkup->EnsureStyleSheets();
        if (hr)
            goto Cleanup;

        pSSA = pMarkup->GetStyleSheetArray();
    }
    else
    {
        pSSA = new CStyleSheetArray( NULL, NULL, 0 );
        if (!pSSA || pSSA->_fInvalid )
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        _pSSATemp = pSSA;
    }

    ctxSS._pParentElement = this;
    hr = THR(pSSA->CreateNewStyleSheet(&ctxSS, &_pStyleSheet));
    if (!SUCCEEDED(hr))
        goto Cleanup;
    Assert(hr == S_FALSE);      // cannot be shared. has to download!
    hr = S_OK;
    
    _pStyleSheet->AddRef(); // since the style elem is hanging onto the stylesheet ptr
                            // Note this results in a subref on us.

    // Setting the disabled status BEFORE adding all the rules (Write()ing to the parser, below)
    // is more efficient, because we don't have to walk the rules list.
    if ( GetAAdisabled() )
    {
        hr = THR( _pStyleSheet->ChangeStatus( 0, FALSE, NULL ) );   // 0 means disable rules
        if (hr)
            goto Save_Contents;
    }

    if(pch && *pch)
    {
        pcssp = new CCSSParser(_pStyleSheet, NULL, IsInMarkup() && GetMarkupPtr()->IsXML(), 
                               IsInMarkup() && GetMarkup()->IsStrictCSS1Document());
        if (!pcssp)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        pcssp->Open();
        pcssp->Write(pch, _tcslen(pch));
        pcssp->Close();
        delete pcssp;
        _pStyleSheet->GetSSS()->_fComplete = TRUE;

        // ArtakKa - I think we can remove the IsInMarkup() check and call EnsureFormatCacheChange
        //              whenever we have a pMarkup
        if (IsInPrimaryMarkup())
        {
            // (alexz) we don't need to do OnCssChangeStable here, and it is also unsafe to do so
            // (this is not a stable moment when we can go out to scripts and other external components) 
            IGNORE_HR(pDoc->ForceRelayout());
        }
        else if(pMarkup)
        {
            pMarkup->EnsureFormatCacheChange(ELEMCHNG_CLEARCACHES);
        }

        // _pStyleSheet might be freed by OnCssChange
        if(_pStyleSheet)
            _pStyleSheet->CheckImportStatus();
    }
    else
    {
        _pStyleSheet->GetSSS()->_fComplete = TRUE;
    }

Save_Contents:
    _cstrText.Set(pch);

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CStyleElement::OnReadyStateChange
//
//----------------------------------------------------------------------------

void
CStyleElement::OnReadyStateChange()
{   // do not call super::OnReadyStateChange here - we handle firing the event ourselves
    SetReadyStateStyle(_readyStateStyle);
}

//+------------------------------------------------------------------------
//
//  Member:     CStyleElement::SetReadyStateStyle
//
//  Synopsis:   Use this to set the ready state;
//              it fires OnReadyStateChange if needed.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------
HRESULT
CStyleElement::SetReadyStateStyle(long readyStateStyle)
{
    long readyState;

    _readyStateStyle = readyStateStyle;

    readyState = min ((long)_readyStateStyle, super::GetReadyState());

    if ((long)_readyStateFired != readyState)
    {
        _readyStateFired = readyState;

        GWPostMethodCall(this,
            ONCALL_METHOD (CStyleElement, DeferredFireEvent, deferredfireevent),
            (DWORD_PTR) &s_propdescCElementonreadystatechange, FALSE, "CStyleElement::DeferredFireEvent");

        if (_readyStateStyle == READYSTATE_COMPLETE)
        {
            GWPostMethodCall(this,
                ONCALL_METHOD (CStyleElement, DeferredFireEvent, deferredfireevent),
                (DWORD_PTR) &s_propdescCStyleElementonload, FALSE, "CStyleElement::DeferredFireEvent");
        }            
    }

    return S_OK;
}

//+----------------------------------------------------------------------------
//
//  Member:     CStyleElement:get_readyState
//
//+------------------------------------------------------------------------------

HRESULT
CStyleElement::get_readyState(BSTR * p)
{
    HRESULT hr = S_OK;

    if ( !p )
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = THR( s_enumdeschtmlReadyState.StringFromEnum(_readyStateFired, p) );

Cleanup:
    RRETURN( SetErrorInfo(hr) );
}

HRESULT
CStyleElement::get_readyState(VARIANT * pVarRes)
{
    HRESULT hr = S_OK;

    if (!pVarRes)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = get_readyState(&V_BSTR(pVarRes));
    if (!hr)
        V_VT(pVarRes) = VT_BSTR;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

//+----------------------------------------------------------------------------
//
//  Member:     CStyleElement:get_styleSheet
//
//+------------------------------------------------------------------------------

HRESULT
CStyleElement::get_styleSheet(IHTMLStyleSheet** ppHTMLStyleSheet)
{
    HRESULT hr = S_OK;

    if (!ppHTMLStyleSheet)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppHTMLStyleSheet = NULL;

    // We may not have a stylesheet if we've been passivated
    if ( _pStyleSheet )
    {
        hr = _pStyleSheet->QueryInterface(IID_IHTMLStyleSheet,
                                              (void**)ppHTMLStyleSheet);
    }

Cleanup:
    RRETURN( SetErrorInfo( hr ));
}

//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange
//
//  Note:       Called after a property has changed to notify derived classes
//              of the change.  All properties (except those managed by the
//              derived class) are consistent before this call.
//
//              Also, fires a property change notification to the site.
//
//-------------------------------------------------------------------------

HRESULT
CStyleElement::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr = S_OK;

    switch (dispid)
    {
    case DISPID_CElement_disabled:
        // Passing ChangeStatus() 0 means disable rules
        if ( _pStyleSheet )
        {
            hr = THR( _pStyleSheet->ChangeStatus( GetAAdisabled() ? 0 : CS_ENABLERULES, FALSE, NULL ) );
            if ( !( OK( hr ) ) )
                goto Cleanup;

            hr = THR( OnCssChange(/*fStable = */ TRUE, /* fRecomputePeers = */TRUE) );
            if (hr)
                goto Cleanup;
        }
        break;

    case DISPID_CStyleElement_type:
        {
            LPCTSTR szType = GetAAtype();

            if ( szType && StrCmpIC( _T("text/css"), szType ) )
            {
                if ( _pStyleSheet )
                {
                    CMarkup * pMarkup = GetMarkup();
                    CStyleSheetArray * pStyleSheets = NULL;
                    
                    if (pMarkup)
                        pStyleSheets = pMarkup->GetStyleSheetArray();

                    // Halt all stylesheet downloading.
                    _pStyleSheet->StopDownloads( TRUE );

                    // Tell the top-level stylesheet collection to let go of it's reference
                    if (pStyleSheets)
                        pStyleSheets->ReleaseStyleSheet( _pStyleSheet, FALSE );

                    // Let go of our reference
                    _pStyleSheet->Release();    // this will subrel ourselves
                    _pStyleSheet = NULL;

                    // Rerender, since our SS is gone.
                    
                    hr = THR( OnCssChange(/*fStable = */ TRUE, /* fRecomputePeers = */TRUE) );
                    if (hr)
                        goto Cleanup;
                }

            }
            else
            {   // We're the right type - make sure we have a stylesheet attached.
                hr = EnsureStyleSheet();
            }
        }
        break;

    case DISPID_CStyleElement_media:
        if ( _pStyleSheet )
        {
            LPCTSTR pcszMedia;

            if ( NULL == ( pcszMedia = GetAAmedia() ) )
                pcszMedia = _T("all");

            hr = THR( _pStyleSheet->SetMediaType( TranslateMediaTypeString( pcszMedia ), FALSE ) );
            if ( !( OK( hr ) ) )
                goto Cleanup;

            hr = THR( OnCssChange(/*fStable = */ TRUE, /* fRecomputePeers = */TRUE) );
            if (hr)
                goto Cleanup;
        }
        break;
    }

    hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Member:     CStyleElement:EnsureStyleSheet
//      Makes sure that we have a stylesheet built for this element.  This is
//  only called if we build a style element through a createElement call from
//  the OM, as opposed to a regular parsing pass (which will call SetText, which
//  will create our stylesheet in order automatically).
//      This particular CStyleElement should be living in the HEAD, or this function
//  may not work properly.  Note that from where this function is currently
//  called (the OM's createElement method), this is always true, so we'll throw
//  an assert if it's not true.
//
//+------------------------------------------------------------------------------
HRESULT
CStyleElement::EnsureStyleSheet( void )
{
    HRESULT hr = S_OK;

    if ( !_pStyleSheet )    // We aren't already ref'ing a stylesheet, so we need a new stylesheet object.
    {
        CMarkup *pMarkup = GetMarkup();
        CStyleSheetArray * pStyleSheets;

        if (pMarkup)
        {
            hr = pMarkup->EnsureStyleSheets();
            if ( hr )
                goto Cleanup;

            pStyleSheets = pMarkup->GetStyleSheetArray();
        }
        else
        {
            pStyleSheets = new CStyleSheetArray( NULL, NULL, 0 );
            if (!pStyleSheets || pStyleSheets->_fInvalid )
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }

            // Track the StyleSheetArray in this element because we don't have a Markup
            _pSSATemp = pStyleSheets;
        }
        Assert(pStyleSheets);

        // Figure out where this <style> stylesheet lives (i.e. what should its index in the
        // stylesheet collection be?).

        long nSSInHead;
        CTreeNode *pNode;
        CLinkElement *pLink;
        CStyleElement *pStyle;
        CElement *pHeadElement = pMarkup ? pMarkup->GetHeadElement() : NULL;
        CStyleSheetCtx  ctxSS;

        nSSInHead = 0;
     
        if (pHeadElement)
        {
            CChildIterator ci ( pHeadElement );

            while ( (pNode = ci.NextChild()) != NULL )
            {
                if ( pNode->Tag() == ETAG_LINK )
                {
                    pLink = DYNCAST( CLinkElement, pNode->Element() );
                    if ( pLink->_pStyleSheet ) // faster than IsLinkedStyleSheet() and adequate here
                        ++nSSInHead;
                }
                else if ( pNode->Tag() == ETAG_STYLE )
                {
                    pStyle = DYNCAST( CStyleElement, pNode->Element() );
                    if ( pStyle == this )
                        break;
                    if ( pStyle->_pStyleSheet ) // Not all STYLE elements create a SS.
                        ++nSSInHead;
                }
            }
        }
        else
        {
            // Get the next available ID based on the size of the Style Sheet collection
            nSSInHead = pStyleSheets->Size();
        }

        ctxSS._pParentElement = this;
        hr = pStyleSheets->CreateNewStyleSheet( &ctxSS, &_pStyleSheet, nSSInHead );
        if ( !SUCCEEDED(hr) )
            goto Cleanup;
        Assert(hr = S_FALSE);   // need download...
        hr = S_OK;

        _pStyleSheet->AddRef(); // since the style elem is hanging onto the stylesheet ptr
                                // Note this results in a subref on us.
    }

Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CStyleElement::Clone
//
//  Synopsis:   Make a new one just like this one
//
//-------------------------------------------------------------------------

HRESULT
CStyleElement::Clone(CElement **ppElementClone, CDoc *pDoc)
{
    HRESULT hr;

    hr = THR(super::Clone(ppElementClone, pDoc));
    if (hr)
        goto Cleanup;

    if (_cstrText)
    {
        hr = THR(DYNCAST(CStyleElement, *ppElementClone)->SetText(_cstrText));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    RRETURN(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscelem\escript.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1996
//
//  File:       escript.cxx
//
//  Contents:   CScriptElement, CScriptParser
//
//  History:    15-Jul-1996     AnandRa     Created
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_ESCRIPT_HXX_
#define X_ESCRIPT_HXX_
#include "escript.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_COLLECT_HXX_
#define X_COLLECT_HXX_
#include "collect.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_PEER_HXX_
#define X_PEER_HXX_
#include "peer.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_ACTIVSCP_H_
#define X_ACTIVSCP_H_
#include <activscp.h>
#endif

#ifndef X_SHOLDER_HXX_
#define X_SHOLDER_HXX_
#include "sholder.hxx"
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_SCRIPT_HXX_
#define X_SCRIPT_HXX_
#include "script.hxx"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_HTC_HXX_
#define X_HTC_HXX_
#include "htc.hxx"
#endif

#ifndef X_MARKUPCTX_HXX_
#define X_MARKUPCTX_HXX_
#include "markupctx.hxx"
#endif

#ifndef X_DEBUGGER_HXX_
#define X_DEBUGGER_HXX_
#include "debugger.hxx"
#endif

#ifndef X_DMEMBMGR_HXX_
#define X_DMEMBMGR_HXX_
#include <dmembmgr.hxx>       // for CDataMemberMgr
#endif

#ifndef X_INTL_HXX_
#define X_INTL_HXX_
#include <intl.hxx>
#endif

#define _cxx_
#include "script.hdl"

extern BOOL IsSpecialUrl(LPCTSTR pszURL);
extern MIMEINFO *  GetMimeInfoFromData(void * pb, ULONG cb, const TCHAR *pchProposed, CStr * pcstrMimeType);

#ifndef NO_SCRIPT_DEBUGGER
extern interface IProcessDebugManager * g_pPDM;
extern interface IDebugApplication *g_pDebugApp;
#endif // ndef NO_SCRIPT_DEBUGGER

MtDefine(CScriptElement, Elements, "CScriptElement")
MtDefine(CScriptElement_pchSrcCode, CScriptElement, "CScriptElement::_pchSrcCode")
MtDefine(CScriptElementOnDwnChan_pbBuffer, Locals, "CScriptElement::OnDwnChan pbBuffer")
MtDefine(TokenizeEventDescription_ppchEventName, Utilities, "TokenizeEventDescription *ppchEventName")
MtDefine(TokenizeEventDescription_ppchFormalParams, Utilities, "TokenizeEventDescription *ppchFormalParams")

const CElement::CLASSDESC CScriptElement::s_classdesc =
{
    {
        &CLSID_HTMLScriptElement,       // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NOLAYOUT,           // _dwFlags
        &IID_IHTMLScriptElement,        // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLScriptElement, // _apfnTearOff
    NULL                                // _pAccelsRun
};

DeclareTag(tagHtmSrcTest, "Dwn", "! Test Unicode Source Access")

//+------------------------------------------------------------------------
//
//  Member:     CScriptElement::CreateElement
//
//  Synopsis:   standard element creator
//
//  Arguments:  pht             Info about the tag
//              pElementParent  The parent element of the script
//              ppElement       Ptr to returned element
//
//-------------------------------------------------------------------------

HRESULT 
CScriptElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    HRESULT         hr = S_OK;
    CScriptElement *pElement;

    Assert(ppElement);

    pElement = new CScriptElement(pht, pDoc);
    if (!pElement)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    *ppElement = pElement;
    pElement = NULL;
   
Cleanup:

    delete pElement;
    
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CScriptElement::CScriptElement
//
//-------------------------------------------------------------------------

CScriptElement::CScriptElement (CHtmTag *pht, CDoc *pDoc) 
     : CElement(pht->GetTag(), pDoc)
{
    _ulScriptOffset = pht->GetOffset();
    _ulScriptLine = pht->GetLine();

    _dwScriptCookie = NO_SOURCE_CONTEXT;

    Assert (!_fCodeConstructed);
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptElement::PrivateQueryInterface, per IPrivateUnknown
//
//-------------------------------------------------------------------------

HRESULT
CScriptElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;

    switch (iid.Data1)
    {
        QI_HTML_TEAROFF(this, IHTMLElement2, NULL)
        QI_HTML_TEAROFF(this, IHTMLScriptElement2, NULL)

    default:
        if (iid == CLSID_HTMLScriptElement)
        {
            *ppv = this;    // weak ref
            return S_OK;
        }
    }

    if (*ppv)
    {
        ((IUnknown *) *ppv)->AddRef();
        RRETURN(S_OK);
    }

    RRETURN(super::PrivateQueryInterface(iid, ppv));
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptElement::Save
//
//  Synopsis:   standard element saver
//
//  Arguments:  pStreamWriteBuff    The stream to write into
//              fEnd                If this is the end tag
//
//-------------------------------------------------------------------------

HRESULT
CScriptElement::Save(CStreamWriteBuff * pStreamWriteBuff, BOOL fEnd)
{
    HRESULT hr = S_OK;

    // Do not write out the script when saving in plaintext mode, or when
    // writing for the rtf converter.
    if (!pStreamWriteBuff->TestFlag(WBF_SAVE_PLAINTEXT) &&
        !pStreamWriteBuff->TestFlag(WBF_FOR_RTF_CONV))
    {
        DWORD   dwOld;

        if (!fEnd)
        {
            //
            // New line for the <SCRIPT> tag
            //

            hr = THR(pStreamWriteBuff->NewLine());
            if(hr)
                goto Cleanup;
        }

        //
        // Save tagname and attributes.
        //

        hr = THR(super::Save(pStreamWriteBuff, fEnd));
        if (hr)
            goto Cleanup;

        if (fEnd)
        {
            //
            // New line after </SCRIPT>
            //

            hr = THR(pStreamWriteBuff->NewLine());
            goto Cleanup;
        }

        // Turn of entitizing within the script
        dwOld = pStreamWriteBuff->ClearFlags(WBF_ENTITYREF);
    
        // Turn off fancy indenting/formatting
        pStreamWriteBuff->BeginPre();

        hr = THR(pStreamWriteBuff->Write((LPTSTR)_cstrText));
        if (hr)
            goto Cleanup;
        
        pStreamWriteBuff->EndPre();
        pStreamWriteBuff->SetFlags(dwOld);
    }
    
Cleanup:
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CScriptElement::CommitCode
//
//  Synopsis:   Commits the code that it has into a script engine
//              holder.  This could potentially cause code to execute.
//
//-------------------------------------------------------------------------

HRESULT
CScriptElement::CommitCode(BOOL fCommitOutOfMarkup, CHtmlComponent *pComponent, CElement * pElementContext)
{
    const static TCHAR      achDelimiter[] = _T("</SCRIPT>");
    HRESULT                 hr = S_OK;
    CExcepInfo              ExcepInfo;
    CVariant                Var;
    CDoc  *                 pDoc = Doc();
    BSTR                    bstrFuncName = NULL;
    TCHAR *                 pchCleanSource = NULL;
    TCHAR *                 pchSource = NULL;
    LPTSTR                  pchNamespace;
    LPCTSTR                 pchScope = NULL;
    LPCTSTR                 pchLang;
    LPCTSTR                 pchEvent;
    LPCTSTR                 pchFor;
    LPCTSTR                 pchType;
    CMarkup *               pMarkup = GetMarkup();
    CMarkup *               pScriptCollectionMarkup;
    CScriptCollection *     pScriptCollection;
    CMarkupScriptContext *  pScriptContext;

    CDoc::CLock Lock(pDoc);

    Assert(!_fDeferredExecution);

    if (!pMarkup && !fCommitOutOfMarkup)
        goto Cleanup;

    if (!CMarkup::CanCommitScripts(fCommitOutOfMarkup ? NULL : pMarkup, this))
        goto Cleanup;

    // assert correctness of params setup
#if DBG == 1
    if (!fCommitOutOfMarkup)
    {
        // most typical case
        Assert (!pComponent && !pElementContext);
        Assert (pMarkup);
    }
    else
    {
        // script in lightweight HTCs
        Assert (pComponent && pElementContext);
        Assert (pMarkup);
    }

#endif

    pchLang = GetAAlanguage();
    pchEvent = GetAAevent();
    pchFor = GetAAhtmlFor();
    pchType = GetAAtype();
    
    SetReadyStateScript(READYSTATE_INTERACTIVE);
        
    if (!pchFor)
    {
        pchFor = DEFAULT_OM_SCOPE;
    }

    if (pComponent)
    {
        // lightweight htc
        pchNamespace = pComponent->GetNamespace();
    }
    else
    {
        hr = THR(pMarkup->EnsureScriptContext(&pScriptContext));
        if (hr)
            goto Cleanup;

        pchNamespace = pScriptContext->GetNamespace();
    }

    Assert(pchNamespace);

    pchScope = NameOrIDOfParentForm();

    pchSource = _fSrc ? _pchSrcCode : _cstrText;

#if DBG==1
    if (IsTagEnabled(tagHtmSrcTest))
    {
        TCHAR achSrc[512];
        ULONG cch;

        HRESULT hrT;

        hrT = pDoc->GetHtmSourceText(_ulScriptOffset, ARRAY_SIZE(achSrc) - 1,
                achSrc, &cch);

        if (hrT == S_OK)
        {
            cch = min(cch, (ULONG)_tcslen(STRVAL(pchSource)));
            achSrc[cch] = 0;

            TraceTag((tagHtmSrcTest, "Expect \"%.64ls\", (ln=%ld pos=%ld) \"%.64ls\"",
                pchSource, _ulScriptLine, _ulScriptOffset, achSrc));
        }
    }
#endif

#define MAX_SCRIPT_INCLUDES 0 // feature disabled - see CLIENT_SIDE_INCLUDES

#if MAX_SCRIPT_INCLUDES
    if (!pchEvent && pchLang && !StrCmpIC(pchLang, _T("include")) && pDoc->_cIncludes < MAX_SCRIPT_INCLUDES)
    {
        if (pchSource && pDoc->HtmCtx() && pMarkup->IsInInline() && (!_fSrc || _pBitsCtx && pDoc->AccessAllowed(_pBitsCtx->GetUrl())))
        {
            hr = THR(pDoc->HtmCtx()->Write(pchSource, FALSE));
        }

        pDoc->_cIncludes += 1;

        goto Cleanup;
    }
#endif

    if (!fCommitOutOfMarkup)
    {
        // most typical case

        pScriptCollectionMarkup = GetNearestMarkupForScriptCollection();
    }
    else
    {
        // lightweight HTCs case

        pScriptCollectionMarkup = pElementContext->GetNearestMarkupForScriptCollection();
    }

    Assert (pScriptCollectionMarkup);

    pScriptCollection = pScriptCollectionMarkup->GetScriptCollection();

    if (pScriptCollection)
    {
        // hold on to the script collection until the end of the cycle,
        pScriptCollection->AddRef();

        //
        // If the event attribute is set, then treat this as
        // a scriptlet.  Otherwise, just parse it in as script text as
        // long as we're not an event tag.
        //

        if (pchEvent)
        {
            hr = THR(pScriptCollection->AddScriptlet(
                    (LPTSTR)pchLang,                                    // pchLanguage
                    pMarkup,                                            // pScriptMarkup
                    (LPTSTR)pchType,                                    // pchType
                    (LPTSTR)pchSource,                                  // pchCode
                    (LPTSTR)(pchScope ? pchScope : DEFAULT_OM_SCOPE),   // pchItemName
                    (LPTSTR)pchFor,                                     // pchSubItemName
                    (LPTSTR)pchEvent,                                   // pchEventName
                    (LPTSTR)achDelimiter,                               // pchDelimiter
                    _fSrc ? 0 : _ulScriptOffset,                        // ulOffset
                    _fSrc ? 0 : _ulScriptLine,                          // ulStartingLine
                    NULL,                                               // pSourceObject
                    0,                                                  // dwFlags
                    &bstrFuncName,                                      // pbstrName
                    pComponent));                                       // instance of lightweight htc
            
        }
        else
        {
//$ WIN64: CScriptElement::CommitCode is passing a pointer through the ulSourceContextCookie parameter
//$ WIN64:   of the CScriptCollection::ParseScriptText method.

#ifndef NO_SCRIPT_DEBUGGER
            CBase *pBase = (!g_pPDM || !g_pDebugApp) ? pMarkup : (CBase *)this;          // pSourceObject
#else
            CBase *pBase = pMarkup;
#endif

            hr = THR(pScriptCollection->ParseScriptText(
                        (LPTSTR)pchLang,            // pchLanguage
                        pMarkup,                    // pScriptMarkup
                        (LPTSTR)pchType,            // pchType
                        (LPTSTR)pchSource,          // pchCode
                        (LPTSTR)pchNamespace,       // pchItemName
                        (LPTSTR)achDelimiter,       // pchDelimiter
                        _ulScriptOffset,            // ulOffset
                        _ulScriptLine,              // ulStartingLine
                        pBase,                      // pSourceObject
                        SCRIPTTEXT_ISVISIBLE | SCRIPTTEXT_HOSTMANAGESSOURCE, // dwFlags
                        &Var,                       // pvarResult
                        &ExcepInfo,                 // pExcepInfo
                        fCommitOutOfMarkup,         // For shared htc's        
                        pComponent));               // instance of lightweight htc
        }
        if (hr)
            hr = S_OK;

        // release the reference we added at the top of this if' s scope.
        pScriptCollection->Release();
    }

    SetReadyStateScript(READYSTATE_COMPLETE);

Cleanup:
    FormsFreeString(bstrFuncName);
    delete [] pchCleanSource;
    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CScriptElement::EnsureScriptDownloadLeft
//
//-------------------------------------------------------------------------

HRESULT
CScriptElement::EnsureScriptDownloadLeft()
{
    HRESULT     hr = S_OK;

    if (_dwScriptDownloadCookie)
    {
        if (IsInMarkup())
            IGNORE_HR(GetMarkup()->UnblockScriptExecution(&_dwScriptDownloadCookie));
        _dwScriptDownloadCookie = NULL;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Function:   CScriptElement::EnsureSourceObjectRevoked
//
//-------------------------------------------------------------------------

HRESULT
CScriptElement::EnsureSourceObjectRevoked()
{
    HRESULT     hr = S_OK;
    CDoc *      pDoc = Doc();

    if (pDoc->_pScriptCookieTable && NO_SOURCE_CONTEXT != _dwScriptCookie)
    {
        IGNORE_HR(pDoc->_pScriptCookieTable->RevokeSourceObject(_dwScriptCookie, this));
        _dwScriptCookie = NO_SOURCE_CONTEXT;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:   CScriptElement::Passivate
//
//-------------------------------------------------------------------------

void
CScriptElement::Passivate()
{
    IGNORE_HR(EnsureSourceObjectRevoked());

    if (_pScriptDebugDocument)
    {
        _pScriptDebugDocument->Release();
    }

    if (_fSharedCode)
        _cstrText.SetPch(NULL);

    SetBitsCtx(NULL);
    if (!_fSharedCode)
        delete _pchSrcCode;
    delete _pchEventName;
    _pchEventName = NULL;
    ClearInterface (&_pDispCode);
    super::Passivate();
}

//+------------------------------------------------------------------------
//
//  Function:   helper for CScriptElement::CommitFunctionPointersCode
//
//-------------------------------------------------------------------------

HRESULT
TokenizeEventDescription (TCHAR * pchEvent, TCHAR ** ppchEventName, TCHAR ** ppchFormalParams)
{
    HRESULT     hr = S_OK;
    TCHAR *     pchStart;
    TCHAR *     pchEnd;
    long        l;

    Assert (ppchEventName);
    Assert (ppchFormalParams);
    
    delete [] *ppchEventName;
    *ppchEventName    = NULL;
    *ppchFormalParams = NULL;

    //
    // get event name
    //

    // skip leading spaces
    pchStart = pchEvent;
    while (_T(' ') == *pchStart)
        pchStart++;

    if (0 == *pchStart) // if no name specified
        goto Cleanup;

    // find the end of name
    pchEnd = pchStart;
    while (_T(' ') != *pchEnd && _T('(') != *pchEnd && *pchEnd)
        pchEnd++;

    // alloc and copy event name

    Assert (pchStart && pchEnd);

    l = PTR_DIFF(pchEnd, pchStart);

    *ppchEventName = new(Mt(TokenizeEventDescription_ppchEventName)) TCHAR [l + 1];
    if (!*ppchEventName)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    _tcsncpy (*ppchEventName, pchStart, l);
    (*ppchEventName)[l] = 0;

    //
    // get formal params
    //

    pchStart = _tcschr (pchEnd, _T('('));
    if (!pchStart)
        goto Cleanup; // no open bracket so no params

    pchEnd = _tcschr (pchStart, _T(')'));
    if (!pchEnd)
        goto Cleanup; // invalid syntax - there was open bracket and no closing bracket

    // alloc and copy formal params

    Assert (pchStart && pchEnd);

    l = PTR_DIFF(pchEnd, pchStart) - 1;

    if (l)
    {
        *ppchFormalParams = new(Mt(TokenizeEventDescription_ppchFormalParams)) TCHAR [l + 1];
        if (!*ppchFormalParams)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }

        _tcsncpy (*ppchFormalParams, pchStart + 1, l);
        (*ppchFormalParams)[l] = 0;
    }

Cleanup:
    if (hr)
    {
        delete *ppchEventName;
        delete *ppchFormalParams;
    }

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptElement::CommitFunctionPointersCode
//
//-------------------------------------------------------------------------

HRESULT
CScriptElement::CommitFunctionPointersCode(CBase *pelTarget, BOOL fHookup)
{
    HRESULT                 hr = S_OK;
    TCHAR *                 pchEvent;
    TCHAR *                 pchFor;
    TCHAR *                 pchLanguage;
    TCHAR *                 pchType;
    int                     iObject;
    int                     cObjects;
    CBase *                 pObject;
    CElementAryCacheItem    cacheItem;
    CElement *              pElem;
    TCHAR *                 pchFormalParams = NULL;
    CBase *                 pNonElementPropHost = NULL;
    CBase **                ppBase = NULL;
    CScriptHolder *         pHolder;
    ITypeInfo *             pTIEvent = NULL;
    DISPID                  dispid = DISPID_UNKNOWN;
    COleSite *              pOleSite = NULL;
    CMarkup *               pMarkup = GetMarkup();
    TCHAR *                 pchSource = _fSrc ? _pchSrcCode : _cstrText;
    BOOL                    fAnyDeleted;
    CScriptCollection *     pScriptCollection;

    pchEvent = (TCHAR*) GetAAevent();
    pchFor   = (TCHAR*) GetAAhtmlFor();
    pchType  = (TCHAR*) GetAAtype();

    Assert(pMarkup);

    // if the script element is for/event type
    if (pchEvent && *pchEvent && pchFor && *pchFor && pchSource && *pchSource)
    {
        //
        // get objects specified in pchFor
        //

        pchLanguage = (TCHAR*)GetAAlanguage();
        pScriptCollection = pMarkup->GetScriptCollection();

        if (!pScriptCollection)
            goto Cleanup;

        hr = THR(pScriptCollection->GetHolderForLanguage(pchLanguage, pMarkup, pchType, NULL, &pHolder));
        if (hr)
            goto Cleanup;

        if (pelTarget)
        {
            if ((0 == FormsStringCmpCase(DYNCAST(CElement, pelTarget)->GetAAname(), pchFor, pHolder->_fCaseSensitive)) ||
                (0 == FormsStringCmpCase(DYNCAST(CElement, pelTarget)->GetAAid(), pchFor, pHolder->_fCaseSensitive)))
            {
                cObjects = 1;
                ppBase = &pelTarget;
            }
            else
                goto Cleanup;
        }
        else if (0 == FormsStringCmpCase(_T("document"), pchFor, pHolder->_fCaseSensitive))
        {
            hr = pMarkup->EnsureDocument();
            if (hr)
                goto Cleanup;

            pNonElementPropHost = pMarkup->Document();
            cObjects = 1;
            ppBase = &pNonElementPropHost;
        }
        else if (0 == FormsStringCmpCase(_T("window"), pchFor, pHolder->_fCaseSensitive))
        {
            if (!pMarkup->HasWindow())
            {
                hr = S_OK;
                goto Cleanup;
            }

            pNonElementPropHost = pMarkup->Window();
            cObjects = 1;
            ppBase = &pNonElementPropHost;            
        }
        else
        {
            hr = THR(pMarkup->EnsureCollectionCache(CMarkup::ELEMENT_COLLECTION));
            if (hr)
                goto Cleanup;

            hr = THR_NOTRACE(pMarkup->CollectionCache()->BuildNamedArray(
                CMarkup::ELEMENT_COLLECTION,
                pchFor,
                FALSE,
                &cacheItem,
                0,  // iStartFrom
                pHolder->_fCaseSensitive));
            if (hr)
                goto Cleanup;

            cObjects = cacheItem.Length();
        }

        if (!cObjects)
            goto Cleanup;

        //
        // construct code
        //
        if (!_fCodeConstructed) 
        {
            //
            // get pchEventName and pchFormalParams from pchEvent
            //
            TCHAR *pchNamespace = NULL;

            hr = THR(TokenizeEventDescription((TCHAR*)pchEvent, &_pchEventName, &pchFormalParams));
            if (hr || !_pchEventName)
                goto Cleanup;

            if (!pMarkup->HasWindowPending())
            {
                CMarkupScriptContext *pScriptContext;
                hr = THR(pMarkup->EnsureScriptContext(&pScriptContext));
                if (!hr)
                    pchNamespace = pScriptContext->GetNamespace();
            }

            hr = THR_NOTRACE(pScriptCollection->ConstructCode(
                pchNamespace,       // pchScope
                pchSource,          // pchCode
                pchFormalParams,    // pchFormalParams
                pchLanguage,        // pchLanguage
                pMarkup,            // pMarkup
                pchType,            // pchType
                _ulScriptOffset,    // ulOffset
                _ulScriptLine,      // ulStartingLine
                pMarkup,            // pSourceObject
                0,                  // dwFlags
                &_pDispCode,        // ppDispCode result
                FALSE));            // fSingleLine

            if (hr)
            {                   // if the language does not support code construction
                                // or failed to construct because of syntax error
                hr = S_OK;
                goto Cleanup;
            }

            _fCodeConstructed = TRUE;
        }

        //
        // for each object set the property
        //
        for (iObject = 0; iObject < cObjects; iObject++)
        {
            if(ppBase)
            {
                pObject = ppBase[iObject];
                pElem = NULL;
            }
            else
            {
                pElem = cacheItem.GetAt(iObject);
                pObject = (CBase*)pElem;
            }

            hr = E_FAIL;

            //
            // Get the dispid to use for storing the function pointer.
            //

            //
            // If this object is an olesite, ask the control's event
            // typeinfo if it knows about the name.
            // We need to do this first in order to catch the event as
            // defined by the control rather than by us. (e.g. onclick)
            //
            if (pObject->BaseDesc()->_dwFlags & CElement::ELEMENTDESC_OLESITE)
            {
                pOleSite = DYNCAST(COleSite, pObject);

                pTIEvent = pOleSite->GetClassInfo()->_pTypeInfoEvents;
                if (pTIEvent)
                {
                    hr = THR_NOTRACE(pTIEvent->GetIDsOfNames(
                            &_pchEventName,
                            1,
                            &dispid));
                }
            }

            // if not an olesite or could not find dispid from object in olesite
            if (hr)
            {
                // Note: for special IE3 compatibility we allow case insensitive
                // matching for the EVENT OnLoad attribute.  This is because IE3
                // implemented it as onLoad, and we correctly implement it as
                // onload.  So that sites can use onLoad & work with IE3 until
                // it is gone for good this hack allows us to use onLoad with
                // any case whatsoever.  -TomSn
                hr = THR_NOTRACE(pObject->GetDispID(
                    _pchEventName,
                    (pHolder->_fCaseSensitive && _tcsicmp( _T("onload"), _pchEventName )) ?
                        fdexNameCaseSensitive : 0,
                    &dispid));

                // if could not get a standard event
                if (hr || IsExpandoDispid(dispid))
                {
                    if (!pNonElementPropHost)
                    {
                        CElement * pElement = DYNCAST(CElement, pObject);

                        if (pElement->HasPeerHolder())
                        {
                            hr = THR_NOTRACE(pElement->GetPeerHolder()->GetEventDispidMulti(
                                _pchEventName, &dispid));
                        }
                    }
                    else
                        hr = E_FAIL;

                    if (hr)
                    {
                        hr = S_OK;

                        if (pelTarget)      // this is important so that _fScriptCommitted does not get set
                            goto Cleanup;   // and we force the script element to be recommitted again later

                        continue;
                    }
                }
            }
            Assert(_pDispCode);
            hr = THR(pObject->SetCodeProperty(dispid, fHookup ? _pDispCode : NULL, &fAnyDeleted));
            if (hr)
                goto Cleanup;

            if (pElem && !fAnyDeleted && dispid == DISPID_EVPROP_ONLOAD)
            {
                IHTMLElement2  *pElem2 = NULL;
                long            lRetValue;

                hr = THR(pElem->QueryInterface(IID_IHTMLElement2, (void **)&pElem2));
                if (hr)
                    continue;

                IGNORE_HR(pElem2->get_readyStateValue(&lRetValue));

                ReleaseInterface(pElem2);
                
                if (lRetValue == READYSTATE_COMPLETE)
                {
                    // All onload propdesc's are same, so use any in the absence of one on CElement
                    pElem->FireEvent(&s_propdescCWindowonload);
                }
            }

            //
            // Ensure the private sink from oc's *after* setting the
            // code property so that if the oc immediately fires an
            // event, we can correctly refire into the script engine.
            //
            
            if (pOleSite && fHookup)
            {
                pOleSite->EnsurePrivateSink();
                pOleSite->SetEventsShouldFire();
            }

            // if we add a data event to an element, make sure the event can fire
            CDataMemberMgr::EnsureDataEventsFor(pObject, dispid);
        }
    }

    _fScriptCommitted = TRUE;

Cleanup:
    delete pchFormalParams;

    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CScriptElement::SetBitsCtx
//
//  Synopsis:   Attaches the script element to a bitsctx to download
//
//-------------------------------------------------------------------------

void CScriptElement::SetBitsCtx(CBitsCtx * pBitsCtx)
{
    CBitsCtx *  pBitsCtxOld = _pBitsCtx;
    
    if (pBitsCtxOld)
    {
        _pBitsCtx = NULL;
        pBitsCtxOld->SetProgSink(NULL); // detach download from document's load progress
        pBitsCtxOld->Disconnect();
        pBitsCtxOld->Release();
    }

    _pBitsCtx = pBitsCtx;

    if (pBitsCtx)
    {
        pBitsCtx->AddRef();

        if (pBitsCtx->GetState() & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED))
            OnDwnChan(pBitsCtx);
        else
        {
            pBitsCtx->SetProgSink(CMarkup::GetProgSinkHelper(GetMarkup()));
            pBitsCtx->SetCallback(OnDwnChanCallback, this);
            pBitsCtx->SelectChanges(DWNCHG_COMPLETE, 0, TRUE);
        }
    }
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptElement::OnDwnChan
//
//  Synopsis:   Called by the bitsctx to notify of download progress
//
//-------------------------------------------------------------------------

void
CScriptElement::OnDwnChan(CDwnChan * pDwnChan)
{
    HRESULT         hr;
    CDoc *          pDoc = Doc();
    ULONG           ulState;
    char *          pbBuffer = NULL;
    IStream *       pStream = NULL;
    STATSTG         statstg;
    ULONG           cbLen;
    int             cchLen;
    BOOL            fEndCR;
    ULONG           cbRead;
    TCHAR *         pchEnd;
    TCHAR *         pchUrl;
    CMarkup *       pMarkup = GetMarkup();

    Assert(_fSrc);

    // Stress bug fix for # 28132.  CScriptElement seems to be getting destructed
    // half-way through this call.
    Assert(!(IsPassivating() || IsPassivated() || IsDestructing()));
    PrivateAddRef();

    ulState = _pBitsCtx->GetState();
    
    if (ulState & DWNLOAD_COMPLETE)
    {
        pchUrl = (LPTSTR) _pBitsCtx->GetRedirectedUrl();
        if (pchUrl == NULL)
            pchUrl = (LPTSTR) _pBitsCtx->GetUrl();

        BOOL fPendingRoot = FALSE;

        if (IsInMarkup())
            fPendingRoot = pMarkup->IsPendingRoot();

        // If unsecure download, may need to remove lock icon on Doc
        pDoc->OnSubDownloadSecFlags(fPendingRoot, pchUrl, _pBitsCtx->GetSecFlags());
    
        // if load completed OK, load file and convert to unicode
        hr = THR(_pBitsCtx->GetStream(&pStream));

        if (hr)
            goto Cleanup;

        hr = THR(pStream->Stat(&statstg, STATFLAG_NONAME));
        if (hr)
            goto Cleanup;

        cbLen = statstg.cbSize.LowPart;
        if (statstg.cbSize.HighPart || cbLen == 0xFFFFFFFF)
            goto Cleanup;

        pbBuffer = new(Mt(CScriptElementOnDwnChan_pbBuffer)) char[cbLen];
        if (!pbBuffer)
            goto Cleanup;

        hr = THR(pStream->Read(pbBuffer, cbLen, &cbRead));

        if (hr == S_FALSE)
            hr = S_OK;
        else if (hr || cbRead != cbLen)
            goto Cleanup;

        delete [] _pchSrcCode;

        if (cbLen)
        {
            // TODO/NB (cthrash) In IE4, we loaded linked script files by converting the source
            // to Unicode using CP_ACP.  This implied that how the script file was interpreted
            // depended on the system codepage of the UA, i.e. the author had no control over
            // how it was read into the browser.  This was bad.  So for IE5.1, we will load the
            // script file in the document's codepage, usually set in the form of a META tag.
            // This change will surely cause some incompatibilities, but hopefully not in cases
            // we care about.
            //
            // The quirk to this change which may not be immediately obvious to authors is that
            // immediately following a document.write, the document's codepage switches to Unicode
            // (cp1200).  This implies that subsequent linked script files would be loaded in
            // Unicode.  That would be a significant departure from IE4 (in IE4 you could not load
            // a Unicode-encoded script file under any circumstance.)   So the hack here is to load
            // the script file in the 'navigatable' codepage which is the same as the codepage in
            // all cases except Unicode.  The navigateable codepage for Unicode is UTF-8.  This is
            // clearly a hack, but at least all ASCII content is guaranteed to be loaded reliably,
            // and after all, that's the only kind of content you could predictably load in IE4
            // anyway.

//TODO (lmollico): fix this (CScriptElement::put_src in script2.htm)
            LPCTSTR szCharset = GetAAcharset();
            CODEPAGE cp = szCharset ? CodePageFromAlias(szCharset) : CP_UNDEFINED;

            if (cp == CP_UNDEFINED)
            {
                pMarkup = IsInMarkup() ? pMarkup : pDoc->PrimaryMarkup();
                cp = NavigatableCodePage(pMarkup->GetCodePage());
            }

            CToUnicodeConverter tuc(cp);
            HRESULT hr;

#ifdef PERFMETER
            tuc.SetMt(Mt(CScriptElement_pchSrcCode));
#endif

            hr = THR( tuc.Convert( pbBuffer, cbLen, &_pchSrcCode, &cchLen ) );
            if (hr)
                goto Cleanup;
        }
        else
        {
            // Commit code can't deal with NULL _pchSrcCode, so allocate a single-char buffer with NUL.

            _pchSrcCode = new(Mt(CScriptElement_pchSrcCode)) TCHAR[1];

            if (!_pchSrcCode)
                goto Cleanup;

            cchLen = 0;
        }

        fEndCR = FALSE;
        pchEnd = _pchSrcCode + cchLen;
        cchLen -= NormalizerChar(_pchSrcCode, &pchEnd);
        _pchSrcCode[cchLen] = _T('\0');
        
        // these variable are not set correctly in case of <script src = >
        _ulScriptOffset = 0;
        _ulScriptLine = 1;

        if (_pScriptDebugDocument)
        {
            _pScriptDebugDocument->Release();
        }
        {
            CScriptDebugDocument::CCreateInfo   createInfo(IsInMarkup() ? GetMarkup() : pDoc->PrimaryMarkup(), pchUrl, _pchSrcCode);

            hr = THR(CScriptDebugDocument::Create(&createInfo, &_pScriptDebugDocument));
            if (hr)
                goto Cleanup;
        }

        if ((!ParserWillExecute() || _fPastedOrInjected) && IsInMarkup())
        {
            if (!_fPastedOrInjected)
                Execute();
            _fPastedOrInjected = FALSE;
            CommitFunctionPointersCode();
        }
    }
    
Cleanup:
    // even if download failed, tell the cdoc that it's done
    if (ulState & (DWNLOAD_COMPLETE | DWNLOAD_ERROR | DWNLOAD_STOPPED))
    {
        SetReadyStateScript(READYSTATE_LOADED);

        IGNORE_HR(EnsureScriptDownloadLeft());
        
        // stress fix check - bug # 556759
        if (_pBitsCtx != NULL)
        {
            _pBitsCtx->SetProgSink(NULL); // detach download from document's load progress
            SetBitsCtx( NULL );           // No reason to hold on to the data anymore
        }
    }
    
    delete pbBuffer;
    ReleaseInterface(pStream);

    // PrivateRelease() to match the PrivateAddRef() at the beginning of the function.
    PrivateRelease();
}


//+------------------------------------------------------------------------
//
//  Member:     CScriptElement::Notify
//
//  Synopsis:   Handle the STOP message - stop downloading inline script
//
//-------------------------------------------------------------------------

void
CScriptElement::Notify(CNotification *pNF)
{
    HRESULT     hr = S_OK;
    TCHAR      *pchEvent;
    TCHAR      *pchFor;
    CDoc       *pDoc;
    
    super::Notify(pNF);
    switch (pNF->Type())
    {
    case NTYPE_STOP_1:
    case NTYPE_MARKUP_UNLOAD_1:
        if (_pBitsCtx)
            _pBitsCtx->SetLoad(FALSE, NULL, FALSE);
        break;

    case NTYPE_ELEMENT_ENTERTREE:
        if(!_fFirstEnteredTree)
        {
            CMarkup *pMarkup = GetMarkup();
            pDoc = Doc();
            BOOL fRunScript;

            _fFirstEnteredTree = TRUE;

            // TODO (alexz) it is not safe to call SetReadyStateScript or ProcessUrlAction
            // from EnterTree. The first one may fire events, which will execute external code,
            // and the second one may push a message loop for a security message box. These
            // scenarios will lead to crashing bugs in the tree and parser code.
            // This code should be move to Execute phase

            SetReadyStateScript(READYSTATE_LOADING);

            if (IsSpecialUrl(CMarkup::GetUrl(pMarkup)))
            {
                DWORD dwPolicyTo;

                hr = THR(pMarkup->ProcessURLAction(URLACTION_SCRIPT_RUN, 
                                                    &fRunScript,
                                                    0, 
                                                    &dwPolicyTo, 
                                                    pMarkup->GetAAcreatorUrl()));
            }
            else
            {
                hr = THR(pMarkup->ProcessURLAction(URLACTION_SCRIPT_RUN, &fRunScript));
            }

            if (!hr && fRunScript)
            {
                // Do not download script if already done so in put_src
                if (!_fScriptDownloaded)
                {
                    hr = THR(DownLoadScript(TRUE));
                    if (hr)
                        break;
                }

                // commit script only when a newly created\removed script elem enters some tree
                // and it has no src or an already downloaded src as a result of a put_src
                if (!_fSrc || (_pchSrcCode && _fScriptDownloaded))
                {
                    // Commit only dynamically created script elems on behalf of parser.
                    if (!ParserWillExecute())
                    {
                        Execute();
                    }
                }

                pchEvent = (TCHAR *)GetAAevent();
                pchFor = (TCHAR *)GetAAhtmlFor();

                if (pchEvent && *pchEvent && pchFor && *pchFor)
                {
                    //
                    // Set bit on doc telling it to walk script collection.
                    //

                    if (!pMarkup->_fHasScriptForEvent) 
                        pMarkup->_fHasScriptForEvent = TRUE;

                    // commit script only when a newly created\removed script elem enters some tree
                    // and it has no src or an already downloaded src  as a result of a put_src
                    if ((!ParserWillExecute() || _fPastedOrInjected) && (!_fSrc || (_pchSrcCode && _fScriptDownloaded)))
                    {
                        Assert(!pMarkup->_fMarkupServicesParsing);
                        Assert(!_fPastedOrInjected || ParserWillExecute());
                        _fPastedOrInjected = FALSE;
                        CommitFunctionPointersCode();
                    }
        
                    if (pMarkup->_fMarkupServicesParsing)
                        _fPastedOrInjected = TRUE;
                }
            }
        }

        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        {
            // No longer under parser control, once removed from tree after being committed once.
            BOOL fMarkupDestroy = pNF->DataAsDWORD() & EXITTREE_DESTROY;

            // No longer under parser control, once removed from tree after being committed once
            if (_fScriptCommitted)
                SetParserWillExecute(FALSE);

            // unhook code on all objects associated with this (user created, not by parser)
            // script elem 
            if (!fMarkupDestroy)
            {
                if (!ParserWillExecute())
                {
                    pchEvent = (TCHAR *)GetAAevent();
                    // For now, don't allow inline script block to be reexecuted if it enters
                    // another markup later.
                    if (!pchEvent)
                        break;

                    CommitFunctionPointersCode(NULL, FALSE);
            
                    // Allow hook up when it enters some tree again.
                    _fScriptCommitted = FALSE;
                }

                // unblock script execution - stress fix check - bug # 556786
                CMarkup * pMarkup = GetMarkup();

                if (_dwScriptDownloadCookie && pMarkup)
                {
                    _markupCookie = pMarkup;
                    _markupCookie->AddRef();
                    pNF->SetSecondChanceRequested();
                }
            }
            else
            {
                SetBitsCtx(NULL);
                _fScriptCommitted = FALSE;
            }

            IGNORE_HR(EnsureSourceObjectRevoked());

            _fFirstEnteredTree = FALSE;
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_2:

        if (_dwScriptDownloadCookie)
        {
            Assert(_markupCookie);
            _markupCookie->UnblockScriptExecution(&_dwScriptDownloadCookie);
            _dwScriptDownloadCookie = NULL;
            _markupCookie->Release();
            _markupCookie = NULL;
        }
        break;
    }
}

HRESULT
CScriptElement::DownLoadScript(BOOL fShare)
{
    HRESULT         hr = S_OK;
    CDoc *          pDoc = Doc();
    const TCHAR *   pchUrl = GetAAsrc();
    CBitsCtx *      pBitsCtx = NULL;

    if (pchUrl && *pchUrl)
    {
        _fSrc = TRUE;

        CHtmlComponent *pComponent = NULL;
        CMarkup *pMarkup = GetMarkup();

        if (fShare && pMarkup && pMarkup->HasBehaviorContext())
        {
            pComponent = pMarkup->BehaviorContext()->_pHtmlComponent;
        }

        if (!pComponent || pComponent->_fFactoryComponent || !pComponent->_pConstructor->_pelFactoryScript)
        {
            BOOL fPendingRoot = FALSE;

            if (IsInMarkup())
                fPendingRoot = pMarkup->IsPendingRoot();

            hr = THR(pDoc->NewDwnCtx(DWNCTX_BITS, pchUrl, this,
                        (CDwnCtx **)&pBitsCtx, fPendingRoot, FALSE, PROGSINK_CLASS_CONTROL));
            if (hr)
                goto Cleanup;

            // IE5: don't block parser for script download if DEFER attribute is present
            // (we leave _dwScriptCookie NULL in this case)
        
            Assert(!_dwScriptDownloadCookie);
        
            if (VB_FALSE == GetAAdefer())
            {
                if (IsInMarkup())
                {
                    pMarkup->BlockScriptExecution(&_dwScriptDownloadCookie);
                    Assert(_dwScriptDownloadCookie);
                }
            }
        
            SetBitsCtx(pBitsCtx);
        }
        else
        {
            Assert(!pComponent->_fFactoryComponent);
            Assert(pComponent->_pConstructor->_pFactoryComponent->_fClonedScript);
            Assert(pComponent->_pConstructor->_pelFactoryScript);
            Assert(pComponent->_pConstructor->_pFactoryComponent->_pMarkup == pComponent->_pConstructor->_pelFactoryScript->GetMarkup());
            Assert(pComponent->_pConstructor->_pelFactoryScript->_pchSrcCode);
            _pchSrcCode = pComponent->_pConstructor->_pelFactoryScript->_pchSrcCode;
            _fSharedCode = TRUE;

            // these variable are not set correctly in case of <script src = >
            _ulScriptOffset = 0;
            _ulScriptLine = 1;

            if (_pScriptDebugDocument)
            {
                _pScriptDebugDocument->Release();
            }
            {
                CScriptDebugDocument::CCreateInfo   createInfo(IsInMarkup() ? pMarkup : pDoc->PrimaryMarkup(), (LPTSTR)pchUrl, _pchSrcCode);

                hr = THR(CScriptDebugDocument::Create(&createInfo, &_pScriptDebugDocument));
                if (hr)
                    goto Cleanup;
            }

            if ((!ParserWillExecute() || _fPastedOrInjected) && IsInMarkup())
            {
                if (!_fPastedOrInjected)
                    Execute();
                _fPastedOrInjected = FALSE;
                CommitFunctionPointersCode();
            }

            SetReadyStateScript(READYSTATE_LOADED);
        }
    }
    else
        _fSrc = FALSE;

Cleanup:
    if (pBitsCtx)
        pBitsCtx->Release();

    return hr;
}

HRESULT
CScriptElement::Execute()
{
    HRESULT         hr = S_OK;
    HRESULT         hr2;
    VARIANT_BOOL    vbDefer = GetAAdefer();
    CDoc *          pDoc = Doc();
    CMarkup *       pMarkup = GetMarkup();

    CDoc::CLock Lock(pDoc);

    if (!pMarkup)
        goto Cleanup;

    // if no defer attribute set, or we're not inside the parser, commit code now
    if (VB_FALSE == vbDefer || !ParserWillExecute())
    {
        //
        // Any script tags that don't have the defer attribute specified
        // are not sent to the script engine when pasting.  This is to
        // prevent document.write problems and more seriously exposing
        // the paste tree to object model before it's been spliced into
        // the main tree.
        //

        if (pMarkup->_fMarkupServicesParsing)
            return S_OK;

        if (_fSrc && pMarkup->IsInScriptExecution())
        {
            // commit after inline scripts are complete
            RRETURN(THR(pMarkup->EnqueueScriptToCommit(this)));
        }
        else
        {
            CWindow *pWindow = NULL;

            // execute should not be called on a script element that is not in a markup
            Assert (pMarkup);

            // Abort script execution in print mode
            // This scenario only appears to come up for HTCs
            if ( pMarkup->DontRunScripts() )
                goto Cleanup;

            // commit immediately
            hr = THR(pMarkup->EnterScriptExecution(&pWindow));
            if (hr)
                goto Cleanup;

            hr2 = THR(CommitCode());

            hr = THR(pMarkup->LeaveScriptExecution(pWindow));
            if (hr2)
                hr = hr2;

            if (hr)
                goto Cleanup;
        }
    }
    else
    {
        // when parsing a script tag with the defer attribute, we want to
        // commit after all downloads are complete
        RRETURN(THR(pDoc->DeferScript(this)));
    }

    Assert(VB_FALSE != vbDefer || !pMarkup->_fMarkupServicesParsing);

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     CScriptElement::OnReadyStateChange
//
//----------------------------------------------------------------------------

void
CScriptElement::OnReadyStateChange()
{   // do not call super::OnReadyStateChange here - we handle firing the event ourselves
    SetReadyStateScript(_readyStateScript);
}

void
CScriptElement::FireOnReadyStateChange(DWORD_PTR dwContext)
{
    Fire_onreadystatechange();
}

//+------------------------------------------------------------------------
//
//  Member:     CScriptElement::SetReadyStateScript
//
//  Synopsis:   Use this to set the ready state;
//              it fires OnReadyStateChange if needed.
//
//  Returns:    void
//
//-------------------------------------------------------------------------
void
CScriptElement::SetReadyStateScript(long readyStateScript)
{
    long readyState;

    _readyStateScript = readyStateScript;

    readyState = min ((long)_readyStateScript, super::GetReadyState());

    if ((long)_readyStateFired != readyState)
    {
        _readyStateFired = readyState;

        GWPostMethodCall(this, ONCALL_METHOD(CScriptElement, FireOnReadyStateChange, fireonreadystatechange), 0, FALSE, "CScriptElement::FireOnReadyStateChange");
    }
}


//+----------------------------------------------------------------------------
//
//  Member:     CScriptElement:get_readyState
//
//+------------------------------------------------------------------------------

HRESULT
CScriptElement::get_readyState(BSTR * p)
{
    HRESULT hr = S_OK;

    if (!p)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr=THR(s_enumdeschtmlReadyState.StringFromEnum(_readyStateFired, p));

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CScriptElement::get_readyState(VARIANT * pVarRes)
{
    HRESULT hr = S_OK;

    if (!pVarRes)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = get_readyState(&V_BSTR(pVarRes));
    if (!hr)
        V_VT(pVarRes) = VT_BSTR;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

STDMETHODIMP CScriptElement::put_src(BSTR v)
{
    HRESULT hr;
    BOOL fRunScript;
    CMarkup *pMU;

    hr = THR(put_StringHelper(v, (const PROPERTYDESC *)&s_propdescCScriptElementsrc));
    if (hr)
        goto Cleanup;

    pMU = GetMarkupPtr();
    if ( !pMU )
        pMU = Doc()->PrimaryMarkup();

    Assert( pMU );
    
    hr = THR(pMU->ProcessURLAction(URLACTION_SCRIPT_RUN, &fRunScript));
    if (hr)
        goto Cleanup;

    if (!fRunScript)
        goto Cleanup;
    
    _fCodeConstructed = FALSE;
    if (!_fSharedCode)
        delete [] _pchSrcCode;
    _pchSrcCode = NULL;


//    if (_fDownloadContent) // TODO(sramani)
    {
        // Make sure script will be committed\executed after download is finished.
        SetParserWillExecute(FALSE);

        hr = THR(DownLoadScript());
        if (hr)
            goto Cleanup;

        // flag that we have already downloaded script: in case script elem is
        // removed from some tree and inserted back in, or a newly created script
        // elem enters some tree, we don't want to download again on SN_ENTERTREE
        _fScriptDownloaded = _fSrc;
    }
//    else
//        _fScriptDownloaded = FALSE;

    // if the src is being removed, hook up again if the script elem
    // is in some tree and it has code.
    if (IsInMarkup() && !_fSrc && _cstrText)
    {
        hr = THR(Execute());
        if (hr)
            goto Cleanup;
        
        hr = THR(CommitFunctionPointersCode());
    }
    else
        _fSharedCode = FALSE;

Cleanup:
    return SetErrorInfo(hr);
}

STDMETHODIMP CScriptElement::put_htmlFor(BSTR v)
{
    // unhook current event sink for the old htmlFor
    if (IsInMarkup())
        CommitFunctionPointersCode(NULL, FALSE);

    // hook up this sink as the new one for <v>
    return SetPropertyHelper(v, (const PROPERTYDESC *)&s_propdescCScriptElementhtmlFor);
}

STDMETHODIMP CScriptElement::put_event(BSTR v)
{
    // TODO: don't allow inline script blocks to be converted to event handlers,
    // until namespace movement support is provided by script engine in IE6
    if (_fScriptCommitted && !GetAAevent())
        return SetErrorInfo(E_UNEXPECTED);

    // unhook event sink for all objects listening to current event.
    if (IsInMarkup())
        CommitFunctionPointersCode(NULL, FALSE);

    _fCodeConstructed = FALSE;
    return SetPropertyHelper(v, (const PROPERTYDESC *)&s_propdescCScriptElementevent);
}

STDMETHODIMP CScriptElement::put_text(BSTR v)
{
    _fCodeConstructed = FALSE;
    if (_fSharedCode)
    {
        _cstrText.SetPch(NULL);
        _fSharedCode = FALSE;
    }
    return SetPropertyHelper(v, (const PROPERTYDESC *)&s_propdescCScriptElementtext);
}

STDMETHODIMP CScriptElement::SetPropertyHelper(BSTR v, const PROPERTYDESC *pPropDesc)
{
    HRESULT hr;
    BOOL fRunScript;
    CMarkup *pMU;

    hr = THR(put_StringHelper(v, pPropDesc));
    if (hr)
        goto Cleanup;

    pMU = GetMarkupPtr();
    if ( !pMU )
        pMU = Doc()->PrimaryMarkup();

    Assert( pMU );
    
    hr = THR(pMU->ProcessURLAction(URLACTION_SCRIPT_RUN, &fRunScript));
    if (hr)
        goto Cleanup;

    if (!fRunScript)
        goto Cleanup;

    // Allow code to be committed\executed if not yet done, but script tag
    // is present on the page.
    SetParserWillExecute(FALSE);

    // if script elem in any tree, then commit its code now, else
    // do it when it enters some tree
    if (IsInMarkup())
    {
        hr = THR(Execute());
        if (hr)
            goto Cleanup;

        hr = THR(CommitFunctionPointersCode());
    }

Cleanup:
    return hr;
}

STDMETHODIMP CScriptElement::get_src(BSTR *p)
{
    HRESULT hr = get_PropertyHelper(p, (const PROPERTYDESC *)&s_propdescCScriptElementsrc);

    if (SUCCEEDED(hr) && (*p != NULL) && (_pBitsCtx != NULL) && (_pBitsCtx->GetRedirectedUrl() != NULL))
    {
        if (SysReAllocString(p, (OLECHAR*) _pBitsCtx->GetRedirectedUrl()))
            hr = S_OK;
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}

STDMETHODIMP CScriptElement::get_htmlFor(BSTR *p)
{
    return get_PropertyHelper(p, (const PROPERTYDESC *)&s_propdescCScriptElementhtmlFor);
}

STDMETHODIMP CScriptElement::get_event(BSTR *p)
{
    return get_PropertyHelper(p, (const PROPERTYDESC *)&s_propdescCScriptElementevent);
}

STDMETHODIMP CScriptElement::get_text(BSTR *p)
{
    return get_PropertyHelper(p, (const PROPERTYDESC *)&s_propdescCScriptElementtext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscsite\ehr.cxx ===
//+---------------------------------------------------------------------
//
//   File:      eli.cxx
//
//  Contents:   HR element class
//
//  Classes:    CHRElement
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_EHR_HXX_
#define X_EHR_HXX_
#include "ehr.hxx"
#endif

#ifndef X_HRLYT_HXX_
#define X_HRLYT_HXX_
#include "hrlyt.hxx"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#define _cxx_
#include "hr.hdl"

MtDefine(CHRElement, Elements, "CHRElement")



const CElement::CLASSDESC CHRElement::s_classdesc =
{
    {
        &CLSID_HTMLHRElement,                // _pclsid
        0,                                   // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                      // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                              // _pcpi
        ELEMENTDESC_NEVERSCROLL     |
        ELEMENTDESC_CARETINS_DL,             // _dwFlags
        &IID_IHTMLHRElement,                 // _piidDispinterface
        &s_apHdlDescs,                       // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLHRElement,          //_apfnTearOff
    NULL                                     // _pAccelsRun
};

HRESULT
CHRElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert(pht->Is(ETAG_HR));
    Assert(ppElement);

    *ppElement = new CHRElement(pDoc);

    RRETURN ( (*ppElement) ? S_OK : E_OUTOFMEMORY );
}

//+------------------------------------------------------------------------
//
//  Member:     CHRElement::Save
//
//  Synopsis:   Save the element to the stream
//
//-------------------------------------------------------------------------

HRESULT
CHRElement::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    DWORD   dwOldFlags;
    HRESULT hr = S_OK;

    dwOldFlags = pStreamWrBuff->ClearFlags(WBF_ENTITYREF);

    // Supress CRLF at start when saving (bug 66743) (jbeda)
    if (! pStreamWrBuff->TestFlag(WBF_NO_PRETTY_CRLF))
    {
        hr = pStreamWrBuff->NewLine();
        if (hr)
            goto Cleanup;
    }

    if(!fEnd)
    {
        if(pStreamWrBuff->TestFlag(WBF_SAVE_PLAINTEXT))
        {
            if (pStreamWrBuff->TestFlag(WBF_FORMATTED_PLAINTEXT))
            {
                hr = pStreamWrBuff->WriteRule();
                if(hr)
                    goto Cleanup;
            }
        }
        else
        {
            // do not write end tags for P, etc
            hr = WriteTag(pStreamWrBuff, fEnd);
            if(hr)
                goto Cleanup;
        }
    }

Cleanup:
    pStreamWrBuff->RestoreFlags(dwOldFlags);
    RRETURN(hr);
}

//
// NOTE marka - HandleMessage for HR has been removed. We used to bubble the message to it's
// parent in edit mode. We don't think we need this anymore ( or can't see why ).
//


HRESULT
CHRElement::ApplyDefaultFormat ( CFormatInfo * pCFI )
{
    HRESULT hr;

    // Override the inherited text color
    if (pCFI->_pcf->_ccvTextColor.IsDefined())
    {
        pCFI->PrepareCharFormat();
        pCFI->_cf()._ccvTextColor.Undefine();
        pCFI->UnprepareForDebug();
    }

    if (pCFI->_bBlockAlign == htmlBlockAlignNotSet)
    {
        pCFI->_bBlockAlign     = htmlBlockAlignCenter;
        pCFI->_bCtrlBlockAlign = htmlBlockAlignCenter;
    }

    hr = THR(super::ApplyDefaultFormat ( pCFI ));

    // Default to percent width (element's coordinate system).
    pCFI->PrepareFancyFormat();
    if (pCFI->_pcf->HasVerticalLayoutFlow())
    {
        pCFI->_ff().SetHeightPercent(pCFI->_ff().IsHeightPercent() | pCFI->_ff().GetHeight().IsNullOrEnum());
    }
    else
    {
        pCFI->_ff().SetWidthPercent(pCFI->_ff().IsWidthPercent() | pCFI->_ff().GetWidth().IsNullOrEnum());
    }
    pCFI->UnprepareForDebug();

    RRETURN(hr);
}



//+-------------------------------------------------------------------------
//
//  Method:     CHRElement::QueryStatus
//
//  Synopsis:   Called to discover if a given command is supported
//              and if it is, what's its state.  (disabled, up or down)
//
//--------------------------------------------------------------------------

HRESULT
CHRElement::QueryStatus(GUID * pguidCmdGroup,
                        ULONG cCmds,
                        MSOCMD rgCmds[],
                        MSOCMDTEXT * pcmdtext)
{
    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));
    Assert(cCmds == 1);

    MSOCMD   * pCmd = & rgCmds[0];
    ULONG      cmdID;
    HRESULT    hr;

    Assert(!pCmd->cmdf);

    cmdID = CBase::IDMFromCmdID( pguidCmdGroup, pCmd->cmdID );
    switch (cmdID)
    {
    case IDM_FORECOLOR:
        pCmd->cmdf = IsEditable(TRUE) ?
                (MSOCMDSTATE_UP) : (MSOCMDSTATE_DISABLED);
        hr = S_OK;
        break;

    default:
        hr = THR_NOTRACE(super::QueryStatus(pguidCmdGroup,
                                            1,
                                            pCmd,
                                            pcmdtext));
        break;
    }

    RRETURN_NOTRACE( hr );
}

//+-------------------------------------------------------------------------
//
//  Method:     CHRElement::Exec
//
//  Synopsis:   execute the commands from QueryStatus
//
//--------------------------------------------------------------------------

HRESULT
CHRElement::Exec(GUID * pguidCmdGroup,
                 DWORD nCmdID,
                 DWORD nCmdexecopt,
                 VARIANTARG * pvarargIn,
                 VARIANTARG * pvarargOut)
{
    Assert(CBase::IsCmdGroupSupported(pguidCmdGroup));

    int      idm = CBase::IDMFromCmdID(pguidCmdGroup, nCmdID);
    HRESULT  hr  = MSOCMDERR_E_NOTSUPPORTED;

    switch (idm)
    {
    case IDM_FORECOLOR:
        if (pvarargOut)
        {
            // its a property get
            hr = THR(get_PropertyHelper(pvarargOut, (PROPERTYDESC *)&s_propdescCHRElementcolor));
            if (hr)
                goto Cleanup;

            if (VT_BSTR == V_VT(pvarargOut))
            {
                // we need to convert to I4 to return consistent with what
                // comes in from a set
                CColorValue cvColor;

                hr = THR(cvColor.FromString(V_BSTR(pvarargOut)));
                if (hr)
                    goto Cleanup;

                VariantClear(pvarargOut);
                V_I4(pvarargOut) = cvColor.GetRawValue();
                V_VT(pvarargOut) = VT_I4;
            }
        }
        else if (!pvarargIn)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }
        else
        {
#ifndef NO_EDIT
            CParentUndoUnit *pCPUU = OpenParentUnit(this, IDS_UNDOPROPCHANGE);
#endif // NO_EDIT

            // property set. we need to flip the colors, for OLE
            // compatability
            CColorValue cvValue;
            CVariant varColor;

            hr = THR(varColor.CoerceVariantArg(pvarargIn, VT_I4));
            if (hr)
                goto Cleanup;

            cvValue.SetFromRGB(V_I4(&varColor));

            V_I4(pvarargIn) = (DWORD)cvValue.GetRawValue();
            V_VT(pvarargIn) = VT_I4;

            //its a property put
            hr = THR(put_VariantHelper(*pvarargIn, (PROPERTYDESC *)&s_propdescCHRElementcolor));

#ifndef NO_EDIT
            CloseParentUnit(pCPUU, hr);
#endif // NO_EDIT
        }
        break;
    }

    if (hr == MSOCMDERR_E_NOTSUPPORTED)
    {
        hr = super::Exec(
                pguidCmdGroup,
                nCmdID,
                nCmdexecopt,
                pvarargIn,
                pvarargOut);
    }

Cleanup:
    RRETURN_NOTRACE(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\ole\frmsite.cxx ===
//+---------------------------------------------------------------------
//
//   File:      frmsite.cxx
//
//  Contents:   frame site implementation
//
//  Classes:    CFrameSite, etc..
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_EXDISP_H_
#define X_EXDISP_H_
#include "exdisp.h"     // for IWebBrowser
#endif

#ifndef X_HTIFACE_H_
#define X_HTIFACE_H_
#include "htiface.h"    // for ITargetFrame, ITargetEmbedding
#endif

#ifndef X_DOWNLOAD_HXX_
#define X_DOWNLOAD_HXX_
#include "download.hxx"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"
#endif

#ifndef X_CUTIL_HXX_
#define X_CUTIL_HXX_
#include "cutil.hxx"
#endif

#ifndef X_WINDOW_HXX_
#define X_WINDOW_HXX_
#include "window.hxx"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include <shell.h>
#endif

#ifndef X_SHLOBJP_H_
#define X_SHLOBJP_H_
#include <shlobjp.h>
#endif

#ifndef X_SHLGUID_H_
#define X_SHLGUID_H_
#include <shlguid.h>
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_PERHIST_H_
#define X_PERHIST_H_
#include <perhist.h>
#endif

#ifndef X_EVENTOBJ_HXX_
#define X_EVENTOBJ_HXX_
#include "eventobj.hxx"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"
#endif

#ifndef X_SHAPE_HXX_
#define X_SHAPE_HXX_
#include "shape.hxx"
#endif

#ifndef X_OLELYT_HXX_
#define X_OLELYT_HXX_
#include "olelyt.hxx"
#endif

#ifndef _X_WEBOCUTIL_H_
#define _X_WEBOCUTIL_H_
#include "webocutil.h"
#endif

#ifndef X_FRAMEWEBOC_HXX_
#define X_FRAMEWEBOC_HXX_
#include "frameweboc.hxx"
#endif

#ifndef X_FRAMELYT_HXX_
#define X_FRAMELYT_HXX_
#include "framelyt.hxx"
#endif

#define _cxx_
#include "frmsite.hdl"


////////////////////////////////////////////////////////////////////////////////////////

BOOL IsSpecialUrl(LPCTSTR pszUrl);
extern HRESULT GetCallerIDispatch(IServiceProvider *pSP, IDispatch ** ppID);
extern BOOL g_fInMshtmpad;

////////////////////////////////////////////////////////////////////////////////////////

#if 0
BOOL
CFrameSite::DoWeHandleThisIIDInOC(REFIID iid)
{
    return    IsEqualIID(iid, IID_IWebBrowser2)
           || IsEqualIID(iid, IID_IWebBrowser)
           || IsEqualIID(iid, IID_IWebBrowserApp)
           || IsEqualIID(iid, IID_IHlinkFrame)
           || IsEqualIID(iid, IID_ITargetFrame)
           || IsEqualIID(iid, IID_IServiceProvider)
           || IsEqualIID(iid, IID_IPersistHistory)
           || IsEqualIID(iid, IID_IPersist)
           || IsEqualIID(iid, IID_IOleCommandTarget)
           || IsEqualIID(iid, IID_IConnectionPointContainer);
}
#endif

//+------------------------------------------------------------------------
//
//  Member:     CFrameSite::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CFrameSite::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr;

    *ppv = NULL;

    if IID_HTML_TEAROFF(this, IHTMLFrameBase, NULL)
    else
    if IID_HTML_TEAROFF(this, IHTMLFrameBase2, NULL)
    else
    if IID_HTML_TEAROFF(this, IHTMLFrameBase3, NULL)
    else
    if IID_HTML_TEAROFF(this, IHTMLElement2, NULL)
    else
    if IID_TEAROFF(this, IDispatchEx, NULL)
    else if (  _pWindow
            && _pWindow->Window()->_punkViewLinkedWebOC
            && IsEqualIID(iid, IID_ITargetFramePriv))
    {
        void * pvObject = NULL;

        hr = _pWindow->Window()->_punkViewLinkedWebOC->QueryInterface(iid, &pvObject);
        if (hr)
            RRETURN(hr);

        hr = THR(CreateTearOffThunk(
                 pvObject, 
                 *(void **)pvObject,
                 NULL,
                 ppv,
                 (IUnknown *)(IPrivateUnknown *)this,
                 *(void **)(IUnknown *)(IPrivateUnknown *)this,
                 QI_MASK,      // Call QI on object 2.
                 NULL));

         ((IUnknown *)pvObject)->Release();

         if (!*ppv)
         {
             return E_OUTOFMEMORY;
         }
    }
    else
    {
        hr = THR_NOTRACE(super::PrivateQueryInterface(iid, ppv));

        if (S_OK == hr)
        {
            RRETURN(hr);
        }
        else if (_pWindow)
        {
            void    * pvObject = NULL;
            CWindow * pWindow  = _pWindow->Window();

            //
            // For these cases, just delegate on down to the window
            // with our IUnknown.
            //
            if (!pWindow)
                return E_NOINTERFACE;

            hr = pWindow->EnsureFrameWebOC();
            if (hr)
                RRETURN(hr);

            hr = THR_NOTRACE(pWindow->_pFrameWebOC->QueryInterface(iid, &pvObject));
            if (hr)
                RRETURN(hr);

            hr = THR(CreateTearOffThunk(
                                        pvObject, 
                                        *(void **)pvObject,
                                        NULL,
                                        ppv,
                                        (IUnknown *)(IPrivateUnknown *)this,
                                        *(void **)(IUnknown *)(IPrivateUnknown *)this,
                                        QI_MASK,      // Call QI on object 2.
                                        NULL));

            ((IUnknown *)pvObject)->Release();
            if (!*ppv)
                RRETURN(E_OUTOFMEMORY);
        }
        else
            RRETURN(E_NOINTERFACE);
    }
    (*(IUnknown **)ppv)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------
//
//  Member:     CFrameSite::Passivate
//
//  Synopsis:   1st stage dtor.
//
//---------------------------------------------------------------

void
CFrameSite::Passivate()
{
    Assert(Doc());

    if (_pWindow && _pWindow->_fFiredOnLoad &&
        !(Doc()->IsPassivating() || Doc()->IsPassivated()))
    {
        _pWindow->_fFiredOnLoad = FALSE;

        // This used to be done when the nested WebOC went down.(see bug# 101175)
        _pWindow->Fire_onunload();
    }

    if (_pWindow)
    {
        // Have to explictly shut down the child world.
        _pWindow->Markup()->TearDownMarkup();
        if( _pWindow->Window()->_pMarkupPending )
            _pWindow->Window()->ReleaseMarkupPending(_pWindow->Window()->_pMarkupPending);

        //
        //  Clear defunked AccEvents -- jharding
        //  These could hold onto our child window and keep it alive.
        //
        Doc()->_aryAccEvents.Flush();

        // Normally, the call to _pWindow->Fire_onunload() above will cause the MyPics object to be released.
        // However, if the Doc is passivating or passivated, the above call will be bypassed.  This call to 
        // DestroyMyPics will ensure that we release the MyPics object which holds a ref on the CDocument.
        _pWindow->DestroyMyPics();

        _pWindow->Release();
        _pWindow = NULL;
    }

    super::Passivate();
}

//+------------------------------------------------------------------------
//
//  Member:     CFrameSite::CreateObject()
//
//  Synopsis:   Helper to instantiate the contained document
//
//-------------------------------------------------------------------------

HRESULT
CFrameSite::CreateObject()
    {
    HRESULT             hr;
    CVariant            varApplication(VT_EMPTY);
    CVariant            varSecurity(VT_EMPTY);
    CMarkup           * pMarkup          = GetMarkup();
    CDoc              * pDoc             = Doc();
    INamedPropertyBag * pINPB            = NULL;
    BOOL                bRestoreFavorite = FALSE;
    COmWindowProxy    * pWindowProxy     = NULL;

    if (!pMarkup)
    {
        AssertSz(FALSE, "Should always have a markup.");
        hr = S_FALSE;
        goto Cleanup;
    }

    // See if there is an "Application" attribute on this element, and if there is,
    // set a flag that is checked from CDocument::SetClientSite.
    hr = getAttribute(_T("Application"), 0, &varApplication);

    if (SUCCEEDED(hr) && (V_VT(&varApplication) == VT_BSTR))
    {
        if (pMarkup->IsMarkupTrusted() && !StrCmpIC(V_BSTR(&varApplication), _T("Yes")))
            _fTrustedFrame = TRUE;
    }

    // See if there is a "Security" attribute on this element, if there is and it is
    // set to "Restricted", set a flag to be copied into proxy objects created for this 
    // window's access to other windows.
    hr = getAttribute(_T("Security"), 0, &varSecurity);

    if ( SUCCEEDED(hr) && (V_VT(&varSecurity) == VT_BSTR) && (V_BSTR(&varSecurity)))
    {
        _fRestrictedFrame = !StrCmpIC(V_BSTR(&varSecurity), _T("Restricted"));
    }

    // If we have the restricted zone set on the frame element or we have a parent window with 
    // restricted zone we are a restricted zone frame.
    pWindowProxy = GetWindowedMarkupContext()->GetWindowPending();
    if (pWindowProxy)
    {
        _fRestrictedFrame |= pWindowProxy->Window()->_fRestricted;
    }

    if (IsOverflowFrame() ||
        (pDoc->_dwLoadf & DLCTL_NO_FRAMEDOWNLOAD))
    {
        hr = S_OK;
        goto Cleanup;
    }

    //
    // $$anandra This needs to wire into the speculative dl that was begun.  
    //

    // if we are in the process of restoring a shortcut, then try to get the src
    // for this element.  If it is not there, do the normal load thing.  if it is
    // there, then set the src to that.

    // QFE: The BASEURL could be there, but stale.  This will happen if the top-level page has changed
    // to point the subframe to a different URL.
    // Provide a mechanism to compare and invalidate the persisted URL if this is the case.

    if (pDoc->_pShortcutUserData &&
        !pMarkup->MetaPersistEnabled(htmlPersistStateFavorite) )
    {
        hr = THR_NOTRACE(pDoc->_pShortcutUserData->
                        QueryInterface(IID_INamedPropertyBag,
                                      (void**) &pINPB));
        if (!hr)
        {
            PROPVARIANT  varBASEURL = {0};
            PROPVARIANT  varORIGURL = {0};
            BSTR         strName = GetPersistID();
            bRestoreFavorite = TRUE;

            // Check the shortcut for a BASEURL

            V_VT(&varBASEURL) = VT_BSTR;
            hr = THR_NOTRACE(pINPB->ReadPropertyNPB(strName, _T("BASEURL"), &varBASEURL));

            if (!hr && V_VT(&varBASEURL) == VT_BSTR)
            {
                // The shortcut has a BASEURL.  Now see if it has an ORIGURL (original URL)

                V_VT(&varORIGURL) = VT_BSTR;
                hr = THR_NOTRACE(pINPB->ReadPropertyNPB(strName, _T("ORIGURL"), &varORIGURL));

                if (!hr && V_VT(&varORIGURL) == VT_BSTR)
                {
                    // The shortcut has an ORIGURL.  Get the URL from the markup, and compare.

                    const TCHAR * pchUrl = GetAAsrc();

                    if (pchUrl && UrlCompare(pchUrl, V_BSTR(&varORIGURL), TRUE) != 0)
                    {
                        // They're different.  Invalidate the BASEURL by not setting the attribute.

                        bRestoreFavorite = FALSE;
                    }

                    SysFreeString(V_BSTR(&varORIGURL));
                    V_BSTR(&varORIGURL) = NULL;
                }
                
                // Restore the saved URL if either (1) there is no ORIGURL, or (2) there is an ORIGURL and it matches
                // the URL currently in the markup.

                if (bRestoreFavorite)
                {
                    // (jbeda) this will cause us to save the wrong ORIGURL if we
                    // repersist this favorite. BUG #87465
                    hr = THR(SetAAsrc(V_BSTR(&varBASEURL)));
                }

                SysFreeString(V_BSTR(&varBASEURL));
            }
            SysFreeString(strName);
            ReleaseInterface(pINPB);
        }

        hr = S_OK;
    }   

    _fDeferredCreate = FALSE;

    // HACK ALERT (jbeda)
    // If we are loading with PICS turned on we need to have something going on until we
    // know that this URL is okay.  For that reason, if we don't already have a window, we
    // first load up with about:blank and then navigate to the real URL that we want.
    if (!_pWindow && pDoc->_pClientSite && !(pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_NOPICS))
    {
        VARIANT varPics = {0};
        IGNORE_HR(CTExec(pDoc->_pClientSite, &CGID_ShellDocView, SHDVID_ISPICSENABLED, 
                         0, NULL, &varPics));
        if (V_VT(&varPics) == VT_BOOL && V_BOOL(&varPics) == VARIANT_TRUE)
        {
            CStr strUrlOrig;

            hr = strUrlOrig.Set(GetAAsrc());
            if (hr)
                goto Cleanup;

            hr = THR(SetAAsrc(_T("about:blank")));
            if (hr)
                goto Cleanup;

            OnPropertyChange_Src();
            SetFrameData();

            hr = THR(SetAAsrc(strUrlOrig));
            if (hr)
                goto Cleanup;

            // This is not the nav that you are looking for 
            // (with hand gesture -- get the reference?)
            if (_pWindow && _pWindow->Window())
            {
                _pWindow->Window()->_fNavigated = FALSE;
            }
        }
    }

    // JHarding: We were ignoring errors from here, but errors are
    // legitimately bad now.
    hr = THR(OnPropertyChange_Src());
    if( hr )
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    SetFrameData();

    // Since we loaded from a favorite, we want to simulate
    // more than one load so that we will save out a favorite.
    if (bRestoreFavorite && _pWindow && _pWindow->Window())
        _pWindow->Window()->NoteNavEvent();

Cleanup:
    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CFrameSite::Init2
//
//  Synopsis:   2nd phase of initialization
//
//-------------------------------------------------------------------------

HRESULT
CFrameSite::Init2(CInit2Context * pContext)
{
    HRESULT hr = THR(super::Init2(pContext));
    if (hr)
        goto Cleanup;

    Doc()->_fBroadcastStop = TRUE;

    if (Tag() == ETAG_IFRAME)
    {
        // frameBorder form <iframe> should be calculated here.
        //
        LPCTSTR    pStrFrameBorder = GetAAframeBorder();

        _fFrameBorder = !pStrFrameBorder
                      || pStrFrameBorder[0] == _T('y')
                      || pStrFrameBorder[0] == _T('Y')
                      || pStrFrameBorder[0] == _T('1');
        Doc()->_fFrameBorderCacheValid = TRUE;
    }
    else
    {
        Doc()->_fFrameBorderCacheValid = FALSE;
    }

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CFrameSite::IsClean
//
//  Synopsis:   Return S_OK if contained document is clean.
//
//----------------------------------------------------------------------------

HRESULT
CFrameSite::IsClean(void)
{
    HRESULT hr = S_FALSE;

    // ask the document inside if its dirty to answer the question
    IPersistFile * pPF;

    if (OK(THR(_pWindow->Document()->QueryInterface(IID_IPersistFile, (void **)&pPF))))
    {
        hr = THR(pPF->IsDirty());
        pPF->Release();
    }

    hr = (hr == S_FALSE) ? S_OK : S_FALSE;

    RRETURN1(hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     CFrameSite::Notify
//
//  Synopsis:   Called to notify of a change
//
//-------------------------------------------------------------------------

void
CFrameSite::Notify(CNotification *pNF)
{
    
    switch (pNF->Type())
    {
    case NTYPE_BASE_URL_CHANGE:
        OnPropertyChange(DISPID_CFrameSite_src, 
                         ((PROPERTYDESC *) &s_propdescCFrameSitesrc)->GetdwFlags(),
                         (PROPERTYDESC *) &s_propdescCFrameSitesrc);
        break;

    case NTYPE_ELEMENT_ENTERTREE:
        {                                 
            CElement *  pParent = GetFirstBranch()->Parent()->Element();

            GetMarkup()->_fHasFrames = TRUE;
            COmWindowProxy *pOmWindowParent = GetMarkup()->GetWindowPending();

            if (_pWindow && _pWindow->Window() && pOmWindowParent)
            {
                Assert(!_pWindow->Window()->_pWindowParent);                
           
                _pWindow->Window()->_pWindowParent = pOmWindowParent->Window();
                _pWindow->Window()->_pWindowParent->SubAddRef();

                // Attach a window that is disable modeless, when it
                // gets reenabled we will be reenabled one extra time.
                // We will underflow and never navigate again.
                Assert( !_pWindow->Window()->_ulDisableModeless );
            }                  

            if (_fDeferredCreate || 
                  ( (!pNF->DataAsDWORD()) && !_fHaveCalledOnPropertyChange_Src ) )
            {
                CreateObject();
            }

            //  If we have entered a FRAMESET, dirty its frame positions so that it will calc
            //  our positions and attach our display node.
            if (    pParent
                &&  pParent->Tag() == ETAG_FRAMESET
                &&  pParent->CurrentlyHasAnyLayout())
            {
                DYNCAST(CFrameSetSite, pParent)->Layout()->SetDirtyFramePositions(TRUE);
                pParent->ResizeElement();        
            }
        }
        break;

    case NTYPE_ELEMENT_EXITTREE_1:
        pNF->SetSecondChanceRequested();
        break;

    case NTYPE_ELEMENT_EXITTREE_2:
        if (_pWindow && _pWindow->Window() && _pWindow->Window()->_pWindowParent)
        {
            _pWindow->Window()->_pWindowParent->SubRelease();
            _pWindow->Window()->_pWindowParent = NULL;

            // If we go away without reenable modeless on 
            // our parent markup, the parent will never
            // be able to navigate again.
            Assert( !_pWindow->Window()->_ulDisableModeless );
        }

        if(     !(pNF->DataAsDWORD() & EXITTREE_PASSIVATEPENDING) 
            &&  _pWindow 
            &&  _pWindow->Window() 
            &&  !_pWindow->Window()->_pMarkup->IsOrphanedMarkup() )
        {
            IGNORE_HR( _pWindow->Window()->_pMarkup->SetOrphanedMarkup( TRUE ) );
        }
        break;

        // CONSIDER: (jbeda) move this to CElement to handle general view-link case
    case NTYPE_FAVORITES_SAVE:
        // if persist is not turned on, do the 'default stuff' (if it is, the 
        //    special handling already happened in the call to super::
        if (!GetMarkup()->MetaPersistEnabled(htmlPersistStateFavorite))
        {
            BSTR                    bstrName;
            BSTR                    bstrTemp;
            FAVORITES_NOTIFY_INFO * psni;
            CMarkup*                pMarkupLink = NULL;
            
            pNF->Data((void **)&psni);

            if (_pWindow)
                pMarkupLink = _pWindow->Markup();

            if (!pMarkupLink)
                break;

            bstrName = GetPersistID(psni->bstrNameDomain);

            // fire on persist to give the event an oppurtunity to cancel
            // the default behavior.

            IGNORE_HR(PersistFavoritesData(psni->pINPB, bstrName));


            {
                CNotification   nf;
            
                // do the broadcast notify, but use the new name for nesting purposes
                bstrTemp = psni->bstrNameDomain;
                psni->bstrNameDomain = bstrName;

                nf.FavoritesSave(pMarkupLink->Root(), (void*)psni);
                pMarkupLink->Notify(&nf);

                psni->bstrNameDomain = bstrTemp;
            }

            SysFreeString(bstrName);
        }
        break;

    case NTYPE_GET_FRAME_ZONE:
        {
            VARIANT *   pvar;
            CMarkup*    pMarkupLink = NULL;
            HRESULT     hr;

            pNF->Data((void **)&pvar);

            if (_pWindow)
                pMarkupLink = _pWindow->Markup();

            if (!pMarkupLink)
                break;

            hr = THR(pMarkupLink->GetFrameZone(pvar));
            if (hr)
                break;
        }

        break;


    case NTYPE_BEFORE_UNLOAD:
        {
            BOOL *pfContinue;

            pNF->Data((void **)&pfContinue);
            if (*pfContinue && _pWindow)
            {
               *pfContinue = _pWindow->Fire_onbeforeunload();
            }
        }
        break;

    case NTYPE_ON_UNLOAD:
        {
            if (_pWindow && _pWindow->_fFiredOnLoad)
            {
                _pWindow->_fFiredOnLoad = FALSE;
                _pWindow->Fire_onunload();
            }
        }
        break;

    case NTYPE_ELEMENT_ENTERVIEW_1:
        {            
            if (_fDeferredCreate) 
            {               
                OnPropertyChange_Src();     
                SetFrameData();
            }
        }
        break;

    case NTYPE_UPDATE_DOC_DIRTY:
        if (S_FALSE == IsClean())
        {
            Doc()->_lDirtyVersion = MAXLONG;
            pNF->SetFlag(NFLAGS_SENDENDED);
        }
        break;
    }



    super::Notify(pNF);
}
//+--------------------------------------------------------------------------------
//
//  member : PersistFavoritesData   
//
//  Synopsis : this method is responsible for saveing the default frame information
//      into the shortcut file.  This include filtering for the meta tags/ xtag
//      specification of what values to store.
//
//      For the frame we want to save a number of different pieces of information
//      this includes:
//          frame name/id/unique identifier
//          frame URL
//          frame's body's scroll position
//          frame postition or size
//
//      TODO: add the filtering logic
//
//---------------------------------------------------------------------------------

HRESULT
CFrameSite::PersistFavoritesData(INamedPropertyBag * pINPB, BSTR bstrSection)
{
    HRESULT       hr = S_OK;
    PROPVARIANT   varValue;
    TCHAR         achTemp[pdlUrlLen];

    Assert (pINPB);

    // only do the save for this frame if it has actually navigated.
    if (_pWindow && _pWindow->Window() && _pWindow->Window()->_fNavigated)
    {
        hr = THR(GetCurrentFrameURL(achTemp, ARRAY_SIZE(achTemp) ));
        if (hr != S_OK)
        {
            hr = S_OK;
            goto Cleanup;
        }

        // First store off the url of the frame
        V_VT(&varValue) = VT_BSTR;
        V_BSTR(&varValue) = SysAllocString(achTemp);

        IGNORE_HR(pINPB->WritePropertyNPB(bstrSection,
                                          _T("BASEURL"),
                                          &varValue));
        SysFreeString(V_BSTR(&varValue));

        // Second, store off the original SRC URL
        const TCHAR * pchUrl = GetAAsrc();

        V_VT(&varValue) = VT_BSTR;
        V_BSTR(&varValue) = SysAllocString(pchUrl);

        IGNORE_HR(pINPB->WritePropertyNPB(bstrSection,
                                          _T("ORIGURL"),
                                          &varValue));
        SysFreeString(V_BSTR(&varValue));

    }

Cleanup:
    RRETURN( hr );
}

//+------------------------------------------------------------------------
//
//  Member:     CFrameSite::NoResize()
//
//  Note:       Called by CFrameSetSite to determine if the site is resizeable
//
//-------------------------------------------------------------------------

BOOL CFrameSite::NoResize()
{
    return GetAAnoResize() != 0 && !IsEditable(TRUE);
}

//+------------------------------------------------------------------------
//
//  Member:     CFrameSite::Opaque()
//
//  Note:       allowTransparency is a VARIANT_BOOL, default false
//              IsOpaque is designed to return the opposite of allowTransparency
//
//-------------------------------------------------------------------------

BOOL CFrameSite::IsOpaque()
{
    return GetAAallowTransparency() == VARIANT_FALSE;
}

//+------------------------------------------------------------------------
//
//  Member:     CFrameSite::ApplyDefaultFormat()
//
//-------------------------------------------------------------------------

HRESULT CFrameSite::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT hr;

    hr = super::ApplyDefaultFormat(pCFI);
    if (FAILED(hr))
    {
        goto done;
    }

    if (IsOpaque())
    {
        pCFI->PrepareFancyFormat();
        
        pCFI->_ff()._ccvBackColor.SetSysColor(COLOR_WINDOW);
          
        Assert(pCFI->_ff()._ccvBackColor.IsDefined());
        
        pCFI->UnprepareForDebug();        
    }
    
done:
    RRETURN( hr );
}

//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange
//
//  Note:       Called after a property has changed to notify derived classes
//              of the change.  All properties (except those managed by the
//              derived class) are consistent before this call.
//
//              Also, fires a property change notification to the site.
//
//-------------------------------------------------------------------------

HRESULT
CFrameSite::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT   hr   = S_OK;
    CDoc    * pDoc = Doc();

    if (!pDoc)
    {
        AssertSz(0,"Possible Async Problem Causing Watson Crashes");
        return E_FAIL;
    }

    switch (dispid)
    {
    case DISPID_CFrameSite_src:
    {
        BOOL fSaveTempfileForPrinting = pDoc && pDoc->_fSaveTempfileForPrinting;

        // While we are saving frames or iframes out to tempfiles, we are rewiring
        // the src property of the (i)frame temporarily, but we don't want any
        // property change notifications to occur because they would alter the
        // document inside the browser.
        if (!fSaveTempfileForPrinting)
        {
            hr = THR(OnPropertyChange_Src());
            SetFrameData();
        }
        break;
    }

    case DISPID_CFrameSite_scrolling:
        hr = THR(OnPropertyChange_Scrolling());
        break;

    case DISPID_CFrameSite_noResize:
        hr = THR(OnPropertyChange_NoResize());
        break;

    case DISPID_CFrameSite_frameBorder:
        if (Tag() == ETAG_IFRAME)
        {
            LPCTSTR pStrFrameBorder = GetAAframeBorder();
            _fFrameBorder = !pStrFrameBorder
                          || pStrFrameBorder[0] == _T('y')
                          || pStrFrameBorder[0] == _T('Y')
                          || pStrFrameBorder[0] == _T('1');
        }
        else
        {
            // don't assume this, DOM can make a mess of the tree.
            if (GetMarkup()->GetElementClient()->Tag() == ETAG_FRAMESET)
            {
                pDoc->_fFrameBorderCacheValid = FALSE;
            }
        }
        break;
    }

    if (!hr)
    {
        hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));
    }

    RRETURN(hr);
}

HRESULT
CFrameSite::Init()
{
    HRESULT hr;

    hr = THR(super::Init());
    if (hr)
        goto Cleanup;

    _fLayoutAlwaysValid = TRUE;

    CreateLayout();

Cleanup:

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange_Src
//
//  Note:       Called after src property has changed
//
//-------------------------------------------------------------------------

HRESULT
CFrameSite::OnPropertyChange_Src(DWORD dwBindf, DWORD dwFlags)
{
    HRESULT       hr = S_OK;
    const TCHAR * pchUrl = GetAAsrc();
    TCHAR         cBuf[pdlUrlLen];
    TCHAR   *     pchExpandedUrl = cBuf;
    CDoc    *     pDoc = Doc();
    CMarkup *     pMarkup;
    CDwnDoc *     pDwnDoc;
    BSTR          bstrMedia   = NULL;
    IStream *     pStmHistory = NULL;
    BOOL          fLocalNavigation   = FALSE;
    BOOL          fProtocolNavigates = TRUE;
    BOOL          bAllowSpecialAboutBlank = FALSE;
    const TCHAR * pchContainerurl = NULL;
    const TCHAR * pchCreatorurl = NULL;
    DWORD         dwContext = 0;
    DWORD         dwPolicy = URLPOLICY_DISALLOW;
    DWORD         dwPUAFFlags = PUAF_DEFAULT;
    DWORD         dwZone = URLZONE_UNTRUSTED;
    CMarkup *     pWindowedMarkupContext = NULL;
    IInternetSecurityManager *pSecMgr = NULL;
    extern BOOL   g_fInAutoCad;

    // defer until we are connected to the primary markup
    if (!IsConnectedToPrimaryWindow())
    {   
        _fDeferredCreate = TRUE;
        goto Cleanup;
    }
    _fDeferredCreate = FALSE;
    
    hr = EnsureInMarkup();
    if (hr)
        goto Cleanup;

    pMarkup = GetMarkup();          

    pDwnDoc = pMarkup->GetDwnDoc();

    if (pDwnDoc)
        dwBindf |= pDwnDoc->GetBindf();

    if (!pchUrl || !*pchUrl)
    {
        pchUrl = _T("about:blank");
    }

    if (!(dwFlags & CDoc::FHL_DONTEXPANDURL))
    {
        // Expand the URL and escape spaces.
        //
        CMarkup::ExpandUrl(pMarkup, pchUrl, ARRAY_SIZE(cBuf), pchExpandedUrl, this);
    }
    else
    {
        pchExpandedUrl = (TCHAR*)pchUrl;
    }

    // Block url recursion unless this came though window.location.href, etc (#106907)
    //
    if (   pMarkup
        && !(dwFlags & CDoc::FHL_SETURLCOMPONENT)
        && !(dwFlags & CDoc::FHL_FOLLOWHYPERLINKHELPER)
        && pMarkup->IsUrlRecursive(pchExpandedUrl))
    {
        TraceTag((tagWarning, "Found %ls recursively, not displaying", pchExpandedUrl));
        pchExpandedUrl = _T("about:blank");
    }

    // Do some security checks before allowing navigation to the frame.

    // Get the url of the markup.
    pWindowedMarkupContext = pMarkup->GetWindowedMarkupContext();
    pchContainerurl = pWindowedMarkupContext->Url();
    if (!pchContainerurl || IsSpecialUrl(pchContainerurl))
    {
        // If the markup is a special url, get the creator url.
        pchCreatorurl = pWindowedMarkupContext->GetAAcreatorUrl();
    }

    // Make a special case for about:blank, this allows for the design mode.
    if ((!pchCreatorurl || !_tcsicmp(pchCreatorurl, _T("about:blank"))) &&
        pchContainerurl && !_tcsicmp(pchContainerurl, _T("about:blank")))
    {
        bAllowSpecialAboutBlank = TRUE;
    }

    // If the container url is a special url, use the creator url.
    if (!pchContainerurl || IsSpecialUrl(pchContainerurl))
        pchContainerurl = pchCreatorurl;

    // Check if frames are allowed in the markup.
    if (!g_fInAutoCad && (Doc()->_dwLoadf & DLCTL_NOFRAMES))
    {
        hr = E_ACCESSDENIED;
        goto Cleanup;
    }
    else if (_fTrustedFrame || bAllowSpecialAboutBlank)
    {
        // Do nothing for trusted frames.
        // Do nothing for the special case about:blank with no creator url.
    }
    else
    {
        // Get the security manager.
        pWindowedMarkupContext->Doc()->EnsureSecurityManager();
        pSecMgr = pWindowedMarkupContext->GetSecurityManager();

        if (!pchContainerurl || IsSpecialUrl(pchContainerurl))
        {
            // If the creator url is a special url, treat zone as restricted.
            dwPUAFFlags = PUAF_ENFORCERESTRICTED;
        }
        else if (pWindowedMarkupContext->HasWindowPending() &&
                 pWindowedMarkupContext->GetWindowPending()->Window()->_fRestricted)
        {
            // Honor the restricted bit on the window.
            dwPUAFFlags = PUAF_ENFORCERESTRICTED;
        }
        else if (!SUCCEEDED(hr = pSecMgr->MapUrlToZone(pchContainerurl, &dwZone, 0)) ||
                dwZone == URLZONE_UNTRUSTED)
        {
            // If MapUrlToZone fails, treat the url as restricted.
            dwPUAFFlags = PUAF_ENFORCERESTRICTED;
        }

        // We're overloading the Urlaction for launching programs and files in
        // frames to mean dis-allow frame navigation in Restricted zone.  Treat
        // URLPOLICY_QUERY as disallow for this purpose. RAID #569126.
        if (dwPUAFFlags == PUAF_ENFORCERESTRICTED)
        {
            hr = pSecMgr->ProcessUrlAction(pchContainerurl, URLACTION_SHELL_VERB,
                                           (BYTE*)&dwPolicy, sizeof(dwPolicy),
                                           (BYTE*)&dwContext, sizeof(dwContext),
                                           dwPUAFFlags | PUAF_NOUI, 0);

            if (!SUCCEEDED(hr) || GetUrlPolicyPermissions(dwPolicy) == URLPOLICY_DISALLOW)
            {
                hr = E_ACCESSDENIED;
                goto Cleanup;
            }
        }
    }

    // Do a local machine access check to see if navigation is allowed to the
    // specified Url in this frame.  No checks for the special case about:blank with
    // special creator url.  This allows design mode.
    if (!bAllowSpecialAboutBlank &&
        !COmWindowProxy::CanNavigateToUrlWithLocalMachineCheck(pMarkup, NULL, pchExpandedUrl))
    {
        pchExpandedUrl = _T("about:blank");
    }

    // FollowHyperlink is called in this function further down the line.  No further
    // local machine check is needed in FollowHyperLink since it'll repeat the same thing
    // we did above.
    dwFlags |= CDoc::FHL_NOLOCALMACHINECHECK;

    // If url is not secure but is on a secure page, we should query now
    // Note that even if we don't want to load the page, we do the navgiation anyway;
    // When loading the nested instance, we call ValidateSecureUrl again and fail the load.
    // This is so that the nested shdocvw has the correct URL in case of "refresh". (dbau)
    {
        SSL_SECURITY_STATE  sslSecurity;           // unsecure/mixed/secure
        SSL_PROMPT_STATE    sslPrompt;             // allow/query/deny
        BOOL                fPendingRoot = pMarkup->IsPendingRoot();
        
        pDoc->GetRootSslState(fPendingRoot, &sslSecurity, &sslPrompt);

        if (sslPrompt == SSL_PROMPT_QUERY && !IsSpecialUrl(pchExpandedUrl))
        {
            pMarkup->ValidateSecureUrl(fPendingRoot, pchExpandedUrl, FALSE, FALSE);
        }
    }
    
    dwFlags |= CDoc::FHL_IGNOREBASETARGET | 
               CDoc::FHL_SETDOCREFERER    |
               CDoc::FHL_FRAMENAVIGATION;

    if (!_pWindow)
    {
        dwFlags |= CDoc::FHL_FRAMECREATION;

        hr = THR(pMarkup->GetLoadHistoryStream((0xF000000 | GetSourceIndex()), HistoryCode(), &pStmHistory));

        // GetLoadHistoryStream can succeed
        // and return a NULL stream.
        //
        if (!hr && pStmHistory)
        {
            THR(pStmHistory->Seek(LI_ZERO.li, STREAM_SEEK_SET, NULL));
        }
    }
    
    hr = THR(pDoc->FollowHyperlink(pchExpandedUrl, 
                                   NULL, 
                                   this, 
                                   NULL, 
                                   FALSE,
                                   NULL,
                                   !_pWindow,
                                   _pWindow, 
                                   _pWindow ? NULL : &_pWindow,
                                   dwBindf,
                                   ERROR_SUCCESS,
                                   FALSE,
                                   NULL,
                                   FALSE,
                                   dwFlags,
                                   GetAAname(),
                                   pStmHistory,
                                   this,
                                   NULL, // pchContainerurl,
                                   &fLocalNavigation,
                                   &fProtocolNavigates,
                                   NULL,
                                   pchContainerurl));

    //  If we don't have a _pWindow, the markup will not be trusted
    // (FerhanE)
    if (_pWindow)
    {
        if (!fProtocolNavigates)
        {
            // restore old src
            hr = S_FALSE;
        }
        else if (!fLocalNavigation)
        {
            hr = _pWindow->Window()->AttachOnloadEvent(pMarkup);
            if (hr)
                goto Cleanup;

            hr = THR(SetViewSlave(_pWindow->Markup()->Root()));
            if (hr)
                goto Cleanup;

            if( pMarkup->IsPrintMedia() )
            {
                bstrMedia = SysAllocString( _T("print") );

                Assert( _pWindow->Document() );

                IGNORE_HR( _pWindow->Document()->putMediaHelper( bstrMedia ) );
            }
            else if (pMarkup->IsPrintTemplate())
            {
                Assert( _pWindow->Document() && _pWindow->Document()->Markup() );

                CMarkup * pSlaveMarkup = _pWindow->Document()->Markup();
                if (!pSlaveMarkup->IsPrintTemplateExplicit())
                    pSlaveMarkup->SetPrintTemplate(TRUE);
            }

            // set the _fTrusted on the new window.
            if (pDoc->IsHostedInHTA() || pDoc->_fInTrustedHTMLDlg)
            {
                // the trust flag on the frame tag should be set &&
                // the trust flag on the containing markup should be set

                // BUBBUG(sramani) Don't need to check IsMarkupTrusted() anymore
                // as _fTrustedFrame implies it now. Infact there is no need to 
                // SetMarkupTrusted again here, as we already do so in DoNavigate
                // But I am leaving this here for now just to be on the safe side.
                BOOL fTrust = _fTrustedFrame && pMarkup->IsMarkupTrusted();

                _pWindow->Markup()->SetMarkupTrusted(fTrust);

                // For frames cases, the markup is created and the ensure window 
                // is called within the DoNavigate(). We have no knowledge of the 
                // _fTrustedFrame flag there, so we set the flag on the markup above.
                // Since the proxy flag _fTrustedDoc is also dependent on the markup's flag _fTrusted,
                // we have to make sure that we are updating that flag here.
                _pWindow->_fTrustedDoc = !!fTrust;
            }
                           
            pMarkup->_fHasFrames = TRUE;
        }
    }

    _fHaveCalledOnPropertyChange_Src = TRUE;
    
Cleanup:
    ReleaseInterface(pStmHistory);
    SysFreeString(bstrMedia);

    RRETURN1(hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange_Scrolling
//
//  Note:       Called after scrolling property has changed
//
//-------------------------------------------------------------------------

HRESULT
CFrameSite::OnPropertyChange_Scrolling()
{
    HRESULT hr = S_OK;

    RRETURN (hr);
}


//+------------------------------------------------------------------------
//
//  Member:     OnPropertyChange_NoResize
//
//  Note:       Called after NoResize property has changed
//
//-------------------------------------------------------------------------

HRESULT
CFrameSite::OnPropertyChange_NoResize()
{
    HRESULT hr = S_OK;

    RRETURN (hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CFrameSite::GetIPrintObject
//
//  Note:       drills into WebBrowser control to get
//              the IPrint-supporter living there
//
//-------------------------------------------------------------------------
HRESULT
CFrameSite::GetIPrintObject(IPrint ** ppPrint)
{
    HRESULT     hr       = E_FAIL;
    IDispatch * pDispDoc = NULL;

    if (!ppPrint)
        RRETURN(E_POINTER);

    *ppPrint = NULL;

    if (!_pWindow)
        RRETURN(E_FAIL);

    if (!_pWindow->Window()->_punkViewLinkedWebOC)
        goto Cleanup;
    
    hr = GetWebOCDocument(_pWindow->Window()->_punkViewLinkedWebOC, &pDispDoc);
    if (hr)
        goto Cleanup;

    hr = pDispDoc->QueryInterface(IID_IPrint, (void **) ppPrint);

Cleanup:
    ReleaseInterface(pDispDoc);

    // Don't RRETURN because in most cases, we won't find an IPrint interface.
    return hr;
}

//+------------------------------------------------------------------------
//
//  Member:     CFrameSite::GetCurrentFrameURL
//
//  Note:       drills into WebBrowser control to get
//              the URL of the current html or external doc living there
//
//-------------------------------------------------------------------------

HRESULT
CFrameSite::GetCurrentFrameURL(TCHAR *pchUrl, DWORD cchUrl)
{
    CMarkup * pMarkupMaster = GetMarkup();
    CMarkup * pMarkupSlave = NULL;
    HRESULT hr = S_FALSE;
    DWORD cchTemp;
    const TCHAR * pchUrlBase = NULL;

    if (cchUrl)
        *pchUrl = _T('\0');

    if (_pWindow && _pWindow->Window())
        pMarkupSlave = _pWindow->Window()->_pMarkup;

    if (!pMarkupSlave)
    {
        hr = S_FALSE;
        goto Cleanup;
    }

    // Get the base URL
    if (pMarkupMaster->HasUrl())
        pchUrlBase = pMarkupMaster->Url();
    if (!pchUrlBase)
        pchUrlBase = _T("");

    hr = THR(CoInternetCombineUrl( pchUrlBase,
                                   pMarkupSlave->GetUrl( pMarkupSlave ),
                                   URL_ESCAPE_SPACES_ONLY | URL_BROWSER_MODE,
                                   pchUrl, cchUrl, &cchTemp, 0));
    if (hr)
        goto Cleanup;

Cleanup:
    RRETURN1 (hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     CFrameSite::get_contentWindow
//
//-------------------------------------------------------------------------

HRESULT
CFrameSite::get_contentWindow(IHTMLWindow2 ** ppOut)
{
    HRESULT             hr;
    COmWindowProxy *    pWindow = NULL;
    CMarkup *           pMarkup = NULL;

    if (!ppOut)
    {
        hr = E_POINTER;
        goto Cleanup;
    }
    if (!_pWindow)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    *ppOut = NULL;

    // Secure the inner window of the framesite in the context of the 
    // window that contains the frame tag.

    pMarkup = GetMarkup();

    if (pMarkup)
    {
        // get the window that contains the page with the frame tag for this site.
        pWindow = pMarkup->Window();

        // In case framesite resides in an htc context, we need to get the window
        // that owns the page with the HTC.
        if (!pWindow)
        {
            pWindow = pMarkup->GetNearestMarkupForScriptCollection()->Window();
        }

        if (pWindow)
        {
            CVariant varIn(VT_DISPATCH);
            CVariant varOut(VT_DISPATCH);
            COmWindowProxy * pOmWindowProxy = NULL;

            if (_pWindow->Window()->_punkViewLinkedWebOC)
            {
                pOmWindowProxy = _pWindow->Window()->GetInnerWindow();
            }
            if (!pOmWindowProxy)
                pOmWindowProxy = _pWindow;

            V_DISPATCH(&varIn) = (IHTMLWindow2 *) pOmWindowProxy;
            pOmWindowProxy->AddRef();

            hr = pWindow->SecureObject(&varIn,
                                       &varOut,
                                       NULL,
                                       this);

            if (!hr && V_DISPATCH(&varOut))
            {
                *ppOut = ((IHTMLWindow2 *)V_DISPATCH(&varOut));
                (*ppOut)->AddRef();
            }

            goto Cleanup;
        }
    }
    
    hr = E_FAIL;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+------------------------------------------------------------------------
//
//  Member:     CFrameSite::GetCWindow
//
//  Note:       Returns the CWindow of the doc living inside the framesite
//              THIS IS NOT A SECURE OBJECT AT ALL ! ! !
//
//-------------------------------------------------------------------------

HRESULT
CFrameSite::GetCWindow(IHTMLWindow2 ** ppOmWindow)
{
    *ppOmWindow = NULL;

    if (_pWindow)
    {
        IHTMLWindow2 * pWindow = _pWindow->_pWindow;

        Assert(_pWindow->_pWindow);

        if (_pWindow->Window()->_punkViewLinkedWebOC)
        {
            COmWindowProxy * pOmWindowProxy = _pWindow->Window()->GetInnerWindow();

            if (pOmWindowProxy)
                pWindow = pOmWindowProxy->_pWindow;
        }

        RRETURN(pWindow->QueryInterface(IID_IHTMLWindow2, (void **)ppOmWindow));
    }

    return E_FAIL;
}


//+----------------------------------------------------------------------------
//
// Member:    CFrameSite::VerifyReadyState
//
//-----------------------------------------------------------------------------
#if DBG==1

ExternTag(tagReadystateAssert);

void
CFrameSite::VerifyReadyState(LONG lReadyState)
{
    Assert(0);
}
#endif

void
CFrameSite::SetFrameData()
{
    // deferred until we are in the primary markup
    if (_fDeferredCreate)
        return;

    if (HasSlavePtr())
    {
        CMarkup *   pMarkup         = GetSlavePtr()->GetMarkup();
        DWORD       dwFlags         = pMarkup->GetFrameOptions();
        DWORD       dwFlagScroll    = (DWORD) GetAAscrolling();
        CDoc  *     pDoc            = Doc();
        CUnitValue  puvHeight       = GetAAmarginHeight();
        CUnitValue  puvWidth        = GetAAmarginWidth();
        long        iExtra          = CFrameSetSite::iPixelFrameHighlightWidth;
   
        // If GetAAscrolling() does not contain FRAMEOPTIONS_SCROLL_NO
        // default option contains FRAMEOPTIONS_SCROLL_AUTO,
        // In both cases, always contains FRAMEOPTIONS_NORESIZE
        //
        if (!pDoc->_fFrameBorderCacheValid && IsInMarkup())
        {
            CElement * pElemClient = GetMarkup()->GetElementClient();

            // don't assume since this could be an IFRAME or a frame as well
            if (pElemClient && pElemClient->Tag() == ETAG_FRAMESET)
            {
                DYNCAST(CFrameSetSite, pElemClient)->FrameBorderAttribute(TRUE, FALSE);
                pDoc->_fFrameBorderCacheValid = TRUE;
            }
        }

        if (dwFlagScroll & FRAMEOPTIONS_SCROLL_NO)
        {
            dwFlags |= FRAMEOPTIONS_NORESIZE
                    |  (_fFrameBorder ? 0 : FRAMEOPTIONS_NO3DBORDER)
                    |  dwFlagScroll;
        }
        else
        {
            dwFlags |= FRAMEOPTIONS_SCROLL_AUTO
                    |  FRAMEOPTIONS_NORESIZE
                    |  (_fFrameBorder ? 0 : FRAMEOPTIONS_NO3DBORDER)
                    |  dwFlagScroll;
        }

        pMarkup->SetFrameOptions(dwFlags);

        // if we have only one of (marginWidth, marginHeight) defined,
        // use 0 for the other. This is for Netscape compability.
        //

        _dwWidth  = (!puvWidth.IsNull())
                  ? max(iExtra, puvWidth.GetPixelValue())
                  : ((!puvHeight.IsNull()) ? 0 : -1);
        _dwHeight = (!puvHeight.IsNull())
                  ? max(iExtra, puvHeight.GetPixelValue())
                  : ((!puvWidth.IsNull()) ? 0 : -1);

        IGNORE_HR(_pWindow->put_name(const_cast<BSTR>(GetAAname())));
    }
}

#ifndef NO_DATABINDING
class CDBindMethodsFrame : public CDBindMethodsSimple
{
    typedef CDBindMethodsSimple super;

public:
    CDBindMethodsFrame() : super(VT_BSTR, DBIND_ONEWAY) {}
    ~CDBindMethodsFrame()   {}

    virtual HRESULT BoundValueToElement(CElement *pElem, LONG id,
                                        BOOL fHTML, LPVOID pvData) const;

};

static const CDBindMethodsFrame DBindMethodsFrame;

const CDBindMethods *
CFrameSite::GetDBindMethods()
{
    Assert(Tag() == ETAG_FRAME || Tag() == ETAG_IFRAME);
    return &DBindMethodsFrame;
}

//+----------------------------------------------------------------------------
//
//  Function: BoundValueToElement, CDBindMethods
//
//  Synopsis: Transfer data into bound image.  Only called if DBindKind
//            allows databinding.
//
//  Arguments:
//            [pvData]  - pointer to data to transfer, in this case a bstr.
//
//-----------------------------------------------------------------------------
HRESULT
CDBindMethodsFrame::BoundValueToElement(CElement *pElem,
                                        LONG,
                                        BOOL,
                                        LPVOID pvData) const
{
    RRETURN(DYNCAST(CFrameSite, pElem)->put_UrlHelper(*(BSTR *)pvData, (PROPERTYDESC *)&s_propdescCFrameSitesrc));
}
#endif // ndef NO_DATABINDING




HRESULT
CFrameSite::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    BOOL    fSaveToTempFile = FALSE;
    CDoc *  pDoc = Doc();
    BOOL    fSaveTempfileForPrinting = pDoc && pDoc->_fSaveTempfileForPrinting;
    TCHAR   achTempBuffer[pdlUrlLen];
    TCHAR   achTempLocation[pdlUrlLen];
    LPCTSTR pstrSrc = NULL;
    HRESULT hr;
    
    if (fSaveTempfileForPrinting && !fEnd)
    {
        if (_pWindow && _pWindow->Window()->_punkViewLinkedWebOC)
        {
            IDispatch   * pDispDoc      = NULL;
            CMarkup     * pMarkupSlave  = NULL;

            // (104758) (greglett)
            // XML documnents are a webOC'd subinstance of Trident.
            // We need to drill into them to persist their current state. 
            // Should XML ever cease to be a nested WebOC, we can do away with this.
            if (    (GetWebOCDocument(_pWindow->Window()->_punkViewLinkedWebOC, &pDispDoc) == S_OK)
                &&  (pDispDoc->QueryInterface(CLSID_CMarkup, (void **) &pMarkupSlave) == S_OK)               )
            {                        
                Assert(pMarkupSlave);
                pMarkupSlave->Doc()->SaveToTempFile(pMarkupSlave->Document(), achTempLocation, NULL);                
            }
            
            // We use the IPrint interface for an unrecognized/default webOC.
            // To work around an UrlMon / Word97 bug (43440) where the Word document disappears from the browse doc whenever someone
            // else binds to it we don't persist webOC objects; instead we persist a "Cannot be previewed" document and come back for
            // to get the IPrint when we print. (greglett)

            // For IFRAMEs, pretend that they're blank (52158)
            else if (Tag() == ETAG_IFRAME)
                _tcscpy(achTempLocation, _T("about:blank"));
            
            // For FRAMES, persist a cannot be previewed resource.
            else
                _tcscpy(achTempLocation, _T("res://SHDOCLC.DLL/printnof.htm"));
            
            ReleaseInterface(pDispDoc);
            hr = S_OK;
        }
        else
        {        
            CMarkup * pMarkup = _pWindow ? _pWindow->Markup() : NULL;

            if( pMarkup && pMarkup->GetReadyState() >= READYSTATE_LOADED )
            {
                Assert(ARRAY_SIZE(achTempLocation) > MAX_PATH + 7);

                _tcscpy(achTempLocation, _T("file://"));

                // Obtain a temporary file name
                if (!pDoc->GetTempFilename(_T("\0"), _T("htm"), ((TCHAR *)achTempLocation)+7 ))
                    goto DontCreateTempfile;

                hr = THR( pMarkup->Save(((TCHAR *)achTempLocation)+7, FALSE) );

            }
            else
            {
                hr = THR( GetCurrentFrameURL(achTempLocation, ARRAY_SIZE(achTempLocation) ));
            }

        }

        if (!hr)
        {
            // remember original src.
            pstrSrc = GetAAsrc();

            if ( pstrSrc )
            {
                _tcscpy(achTempBuffer, GetAAsrc());
                pstrSrc = achTempBuffer;
            }

            hr = THR( SetAAsrc(achTempLocation) );

            fSaveToTempFile = TRUE;
        }
    }

DontCreateTempfile:

    hr = THR( super::Save(pStreamWrBuff, fEnd) );

    if (fSaveToTempFile)
    {
        IGNORE_HR( SetAAsrc(pstrSrc) );
    }

    RRETURN(hr);
}

//+-------------------------------------------------------------------------
//
//  Method:     CFrameSite::Exec
//
//  Synopsis:   Called to execute a given command.  If the command is not
//              consumed, it may be routed to other objects on the routing
//              chain.
//
//--------------------------------------------------------------------------

HRESULT
CFrameSite::Exec(
        GUID * pguidCmdGroup,
        DWORD nCmdID,
        DWORD nCmdexecopt,
        VARIANTARG * pvarargIn,
        VARIANTARG * pvarargOut)
{
    Assert(IsCmdGroupSupported(pguidCmdGroup));

    UINT    idm;
    CDoc *pDoc = Doc();
    HRESULT hr = OLECMDERR_E_NOTSUPPORTED;
    IServiceProvider *pSrvProvider = NULL;
    IDispatch *pCaller = NULL;
    IUnknown *  pUnk = NULL;

    //
    // default processing
    //

    idm = IDMFromCmdID(pguidCmdGroup, nCmdID);

    if (!pguidCmdGroup || IsEqualGUID(CGID_MSHTML, *pguidCmdGroup))
    {
        COmWindowProxy *pWindow;
        AAINDEX     aaindex;
        BOOL fClipboardAccessNotAllowed = FALSE;

        if (!_pWindow)
            goto Cleanup;

        Assert(GetMarkup());
        pWindow = GetMarkup()->Window();
        Assert(pWindow);
        Assert(pWindow->Window() == _pWindow->Window()->_pWindowParent);

        // Bug 27773: When we check to see if we're in script we can't just check IsInScript() on
        // the window.  Simple way is to walk up window parent chain to check IsInScript().  However
        // this does not work for TriEdit controls, so we need to get the caller from IServiceProvider,
        // which should be the calling window, and we can check IsInScript() on that.
        
        aaindex = FindAAIndex(DISPID_INTERNAL_INVOKECONTEXT, CAttrValue::AA_Internal);
        if (aaindex != AA_IDX_UNKNOWN)
        {
            hr = THR( GetUnknownObjectAt(aaindex, &pUnk) );
            if FAILED(hr)
                goto Cleanup;

            Assert(pUnk);
            if (pUnk)
            {
                hr = THR( pUnk->QueryInterface(IID_IServiceProvider, (void **)&pSrvProvider) );
                if (FAILED(hr))
                    goto Cleanup;
            }
            
            Assert(pSrvProvider);
            if (pSrvProvider)
            {
                hr = THR( GetCallerIDispatch(pSrvProvider, &pCaller) );
                if (FAILED(hr))
                {            
                    goto Cleanup;
                }
            }

            Assert(pCaller || g_fInMshtmpad);
            if (pCaller)
            {
                // We know from checks above that we are in script.  We'll call AccessAllowed
                // to do a final security check to see whether the pCaller (the script caller)
                // has access to the _pWindow.

                if (!_pWindow->AccessAllowed(pCaller))
                {
                    fClipboardAccessNotAllowed = TRUE;
                }
            }
        }

        if (fClipboardAccessNotAllowed)
        {
            OPTIONSETTINGS *pos = pDoc->_pOptionSettings;
        
            if ((idm == IDM_PASTE || idm == IDM_CUT || idm == IDM_COPY) && (pos && pos->fAllowCutCopyPaste)) 
                goto AllowExec;

            hr = E_ACCESSDENIED;
            goto Cleanup;
        }

AllowExec:
        // If we are a site selected, then don't delegate the command to the iframe.  The
        // editor will handle it at a higher level

        if (IsSiteSelected())
        {
            hr = OLECMDERR_E_NOTSUPPORTED;
            goto Cleanup;
        }

        // If this assertion fails, that means CFrameSite can represent elements other than
        // ETAG_FRAME and ETAG_IFRAME.  Look in CDoc::ExecHelper for the case IDM_SAVEAS, see
        // what tags we're checking to defer Exec.  Based on that either change the assertion
        // or add the condition to the if statement that follows this assert.
        Assert(Tag() == ETAG_FRAME || Tag() == ETAG_IFRAME);

        // Bug fix for 21114 - CDoc::ExecHelper() returns control to its current element.
        // This condition check below prevents the ensuing infinite recursion if this
        // happens to be the current element for the CDoc.
        if (!(this == pDoc->_pElemCurrent && nCmdID == OLECMDID_SAVEAS))
        // Call Exec on the content document of this frame's window
        // (but don't honor CDoc::_pMenuObject, or we'd get into an infinite loop -- 91870)
        {
            CElement * pMenuObjectOld = pDoc->_pMenuObject;
            CDocument *pContextDoc = _pWindow->Document();
            BOOL      fAddContextToAA = FALSE;

            pDoc->_pMenuObject = NULL;

            aaindex = pContextDoc->FindAAIndex(DISPID_INTERNAL_INVOKECONTEXT, CAttrValue::AA_Internal);
            fAddContextToAA = (aaindex == AA_IDX_UNKNOWN && pUnk);

            if (fAddContextToAA)
            {
                pContextDoc->AddUnknownObject(
                    DISPID_INTERNAL_INVOKECONTEXT, pUnk, CAttrValue::AA_Internal);
            }

            hr = THR(pDoc->ExecHelper(pContextDoc, pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));

            if (fAddContextToAA)
            {
                pContextDoc->FindAAIndexAndDelete(
                    DISPID_INTERNAL_INVOKECONTEXT, CAttrValue::AA_Internal);
            }

            pDoc->_pMenuObject = pMenuObjectOld;
        }
    }

    if (OLECMDERR_E_NOTSUPPORTED == hr)
        hr = THR(super::Exec(pguidCmdGroup, nCmdID, nCmdexecopt, pvarargIn, pvarargOut));

Cleanup:
    ReleaseInterface(pSrvProvider);
    ReleaseInterface(pCaller);
    ReleaseInterface(pUnk);
    RRETURN_NOTRACE(hr);
}

HRESULT
CFrameSite::get_readyState(BSTR * p)
{
    if (_pWindow && _pWindow->Document())
        RRETURN(_pWindow->Document()->get_readyState(p));
    else
        RRETURN(SetErrorInfo(E_FAIL));
}

HRESULT
CFrameSite::get_readyState(VARIANT * pVarRes)
{
    HRESULT hr = S_OK;

    if (!pVarRes)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = get_readyState(&V_BSTR(pVarRes));
    if (!hr)
        V_VT(pVarRes) = VT_BSTR;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

HRESULT
CFrameSite::GetDispID(BSTR bstrName, DWORD grfdex, DISPID * pid)
{
    HRESULT hr;

    hr = super::GetDispID(bstrName, grfdex, pid);

    Assert(hr || *pid < WEBOC_DISPIDBASE || *pid > WEBOC_DISPIDMAX);

    if (hr)
    {
        hr = GetWebOCDispID(bstrName, (grfdex & fdexNameCaseSensitive), pid);
    }

    RRETURN(hr);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(off)
#endif
HRESULT
CFrameSite::ContextThunk_InvokeEx (
    DISPID          dispidMember,
    LCID            lcid,
    WORD            wFlags,
    DISPPARAMS *    pdispparams,
    VARIANT *       pvarResult,
    EXCEPINFO *     pexcepinfo,
    IServiceProvider *pSrvProvider)
{
    HRESULT     hr;
    IUnknown *  pUnkContext;
    IDispatch *pCaller = NULL;

    // Magic macro which pulls context out of nowhere (actually eax)
    CONTEXTTHUNK_SETCONTEXT

    hr = THR_NOTRACE(super::ContextInvokeEx(dispidMember,
                                            lcid,
                                            wFlags,
                                            pdispparams,
                                            pvarResult,
                                            pexcepinfo,
                                            pSrvProvider,
                                            pUnkContext ? pUnkContext : (IUnknown*)this));

    if (    hr
        &&  _pWindow
//        &&  dispidMember >= WEBOC_DISPIDBASE
//        &&  dispidMember <= WEBOC_DISPIDMAX
       )
    {
        hr = E_ACCESSDENIED;
        if (pSrvProvider)
        {
            if (FAILED(GetCallerIDispatch(pSrvProvider, &pCaller)))
            {            
                goto Cleanup;
            }
        }
        else
        {
            pCaller = GetWindowedMarkupContext() ? (IDispatch *)(IHTMLWindow2 *)GetWindowedMarkupContext()->Window() : NULL;
            if (pCaller)
            {
                pCaller->AddRef();
            }
        }

        if (pCaller && _pWindow->AccessAllowed(pCaller))
        {
            hr = _pWindow->Window()->EnsureFrameWebOC();
            if (hr)
                goto Cleanup;

            hr = InvokeWebOC(_pWindow->Window()->_pFrameWebOC, dispidMember, lcid,
                             wFlags, pdispparams, pvarResult, pexcepinfo, pSrvProvider);
        }
    }

Cleanup:
    ReleaseInterface(pCaller);
    RRETURN(hr);
}
#ifdef USE_STACK_SPEW
#pragma check_stack(on)
#endif

BOOL
CFrameSite::IsSiteSelected()
{
    HRESULT         hr;
    BOOL            fIsSiteSelected = FALSE;
    ISegmentList    *pISegmentList = NULL;  
    IElementSegment *pIElementSegment = NULL;
    IHTMLElement    *pIElement = NULL;
    CElement        *pElement;
    ISegmentListIterator *pIter = NULL;
    ISegment        *pISegment = NULL;
    
    if (Doc()->GetSelectionType() != SELECTION_TYPE_Control)
        goto Cleanup;
    
    hr = THR(Doc()->GetCurrentSelectionSegmentList(&pISegmentList));
    if (hr)
        goto Cleanup;

    Assert(pISegmentList);


    hr = THR( pISegmentList->CreateIterator(&pIter) );
    if( hr )
        goto Cleanup;

    while( pIter->IsDone() == S_FALSE )
    {    
        hr = THR(pIter->Current(&pISegment) );
        if (hr)
            goto Cleanup;

        hr = THR(pISegment->QueryInterface(IID_IElementSegment, (void**)&pIElementSegment));
        if (hr)
            goto Cleanup;
            
        hr = THR(pIElementSegment->GetElement(&pIElement));
        if (hr)
            goto Cleanup;                

        if (!pIElement)
            goto Cleanup;
        
        hr = THR(pIElement->QueryInterface(CLSID_CElement, (void**)&pElement));
        if (hr)
            goto Cleanup;

        fIsSiteSelected = (pElement == this);
        if (fIsSiteSelected)
            goto Cleanup;

        ClearInterface(&pISegment);
        ClearInterface(&pIElementSegment);
        ClearInterface(&pIElement);

        hr = THR(pIter->Advance());
        if( hr )
            goto Cleanup;
    }


Cleanup:
    ReleaseInterface(pISegmentList);            
    ReleaseInterface(pIElementSegment);
    ReleaseInterface(pIElement);
    ReleaseInterface(pIter);
    ReleaseInterface(pISegment);

    return fIsSiteSelected;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\ole\frame.cxx ===
//+---------------------------------------------------------------------
//
//   File:      frame.cxx
//
//  Contents:   frame tag implementation
//
//  Classes:    CFrameSite, etc..
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"
#endif

#ifndef X_PUTIL_HXX_
#define X_PUTIL_HXX_
#include "putil.hxx"
#endif

#define _cxx_
#include "frame.hdl"

MtDefine(CFrameElement, Elements, "CFrameElement")
MtDefine(CIFrameElement, Elements, "CIFrameElement")

const CElement::CLASSDESC CFrameElement::s_classdesc =
{
    {
        &CLSID_HTMLFrameElement,        // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NEVERSCROLL    |
        ELEMENTDESC_FRAMESITE,          // _dwFlags
        &IID_IHTMLFrameElement,         // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLFrameElement,  // _pfnTearOff
    NULL                                // _pAccelsRun
};

//+---------------------------------------------------------------------------
//
//  element creator used by parser
//
//----------------------------------------------------------------------------

HRESULT
CFrameElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);

    *ppElementResult = new CFrameElement(pDoc);

    RRETURN ( (*ppElementResult) ? S_OK : E_OUTOFMEMORY);
}

//+---------------------------------------------------------------------------
//
//  Member: CFrameElement constructor
//
//----------------------------------------------------------------------------

CFrameElement::CFrameElement(CDoc *pDoc)
  : CFrameSite(ETAG_FRAME, pDoc)
{
}

//+----------------------------------------------------------------------------
//
// Member: CFrameElement::ApplyDefaultFormat
//
//-----------------------------------------------------------------------------
HRESULT
CFrameElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    pCFI->PrepareFancyFormat();
    pCFI->_ff()._fRectangular = TRUE;
    pCFI->UnprepareForDebug();
    RRETURN(super::ApplyDefaultFormat(pCFI));
}


//+----------------------------------------------------------------------------
//
// Member: CFrameElement:get_height
//
//-----------------------------------------------------------------------------
STDMETHODIMP CFrameElement::get_height(VARIANT * p)
{
    HRESULT hr = S_OK;

    if (p)
    {
        V_VT(p) = VT_I4;
        CLayout * pLayout = GetUpdatedLayout();

        //CFrameElement always has layout, but PREFIX doesn't believe it
        //and possibly some stress conditions could cause the problem indeed..
        V_I4(p) = ( pLayout ? g_uiDisplay.DocPixelsFromDeviceY(pLayout->GetHeight()) : 0 );
    }
    RRETURN(SetErrorInfo(hr));
}

STDMETHODIMP CFrameElement::put_height(VARIANT p)
{
    RRETURN(SetErrorInfo(CTL_E_METHODNOTAPPLICABLE));
}

//+----------------------------------------------------------------------------
//
// Member: CFrameElement:get_width
//
//-----------------------------------------------------------------------------
STDMETHODIMP CFrameElement::get_width(VARIANT * p)
{
    HRESULT hr = S_OK;

    if (p)
    {
        V_VT(p) = VT_I4;
        CLayout * pLayout = GetUpdatedLayout();

        //CFrameElement always has layout, but PREFIX doesn't believe it
        //and possibly some stress conditions could cause the problem indeed..
        V_I4(p) = ( pLayout ? g_uiDisplay.DocPixelsFromDeviceX(pLayout->GetWidth()) : 0 );
    }
    RRETURN(SetErrorInfo(hr));
}

STDMETHODIMP CFrameElement::put_width(VARIANT p)
{
    RRETURN(SetErrorInfo(CTL_E_METHODNOTAPPLICABLE));
}

//+----------------------------------------------------------------------------
//
// Member: CFrameElement:Notify
//
//-----------------------------------------------------------------------------
void
CFrameElement::Notify(CNotification *pNF)
{    
    switch (pNF->Type())
    {
    //  Notification creates collection of IPrints exclusively contained by frames.
    //  If this frame contains an IPrint instead of normal HTML, add the IPrint to the collection.
    //  NB: If we wanted to also collect IFrames (in addition to FRAMEs), we could just move this
    //      logic up to CFrameSite::Notify, and remove the FRAMESET check in CDoc::ExecHelper GETIPRINT.
    case NTYPE_COLLECT_IPRINT:
        CIPrintCollection *pIPC;

        pNF->Data((void**)&pIPC);
        if (pIPC)
        {        
            IPrint *pIPrint = NULL;
            if (!GetIPrintObject(&pIPrint))
            {
                pIPC->AddIPrint( pIPrint );
            }
            
            // Otherwise, rebroadcast in new markup if this is a submarkup with a nested frameset
            else
            {
                CMarkup  * pMarkup;
                CElement * pElement;

                pElement = GetSlavePtr();
                if (pElement)
                {
                    pMarkup = pElement->GetMarkup();
                    if (pMarkup)
                    {
                        pElement = pMarkup->GetElementClient();
                        Assert(pElement);
                        if (pElement)
                        {
                            // NB: (greglett) Since this notification only collects CFrameElements and not IFrames, we only need
                            // to fire the notification if we have a frameset.
                            if (pElement->Tag() == ETAG_FRAMESET)
                            {
                                CNotification nf;
                                Assert(pElement->GetFirstBranch());

                                // Collect all IPrint objects from frames that consist of only IPrint objects.
                                nf.Initialize(NTYPE_COLLECT_IPRINT, pElement, pElement->GetFirstBranch(), pIPC, 0);

                                pMarkup->Notify(&nf);
                            }
                        }
                    }
                }
            }

            ReleaseInterface(pIPrint);
        }
        break;
    }

    super::Notify(pNF);
}

//+----------------------------------------------------------------------------
//
//  Member:     CFrameElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-----------------------------------------------------------------------------

HRESULT
CFrameElement::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *) this, IUnknown)
        QI_HTML_TEAROFF(this, IHTMLFrameElement, NULL)
        QI_TEAROFF(this, IHTMLFrameElement2, NULL)
        QI_TEAROFF_DISPEX(this, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\ole\iframe.cxx ===
//+---------------------------------------------------------------------
//
//   File:      frame.cxx
//
//  Contents:   frame tag implementation
//
//  Classes:    CFrameSite, etc..
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifdef WIN16
#ifndef X_EXDISP_H_
#define X_EXDISP_H_
#include <exdisp.h>
#endif
#endif

#define _cxx_
#include "iframe.hdl"

const CElement::CLASSDESC CIFrameElement::s_classdesc =
{
    {
        &CLSID_HTMLIFrame,              // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NEVERSCROLL    |
        ELEMENTDESC_FRAMESITE,          // _dwFlags
        &IID_IHTMLIFrameElement,        // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLIFrameElement, // _pfnTearOff
    NULL                                // _pAccelsRun
};

//+---------------------------------------------------------------------------
//
//  element creator used by parser
//
//----------------------------------------------------------------------------

HRESULT
CIFrameElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);

    *ppElementResult = new CIFrameElement(pDoc);

    RRETURN ( (*ppElementResult) ? S_OK : E_OUTOFMEMORY);
}

//+---------------------------------------------------------------------------
//
//  Member: CIFrameElement constructor
//
//----------------------------------------------------------------------------

CIFrameElement::CIFrameElement(CDoc *pDoc)
  : CFrameSite(ETAG_IFRAME, pDoc)
{
}


//+----------------------------------------------------------------------------
//
//  Member:     CIFrameElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-----------------------------------------------------------------------------

HRESULT
CIFrameElement::PrivateQueryInterface ( REFIID iid, void ** ppv )
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *) this, IUnknown)
        QI_HTML_TEAROFF(this, IHTMLIFrameElement, NULL)
        QI_HTML_TEAROFF(this, IHTMLIFrameElement2, NULL)
        QI_TEAROFF_DISPEX(this, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}


//+----------------------------------------------------------------------------
//
// Member: CIFrameElement::ApplyDefaultFormat
//
//-----------------------------------------------------------------------------
HRESULT
CIFrameElement::ApplyDefaultFormat(CFormatInfo *pCFI)
{
    HRESULT hr = S_OK;

    //
    // in NF, IFrames now have a default size.
    //
    pCFI->PrepareFancyFormat();
    pCFI->_ff().SetWidth(CUnitValue(300, CUnitValue::UNIT_PIXELS));
    pCFI->_ff().SetHeight(CUnitValue(150, CUnitValue::UNIT_PIXELS));
    pCFI->_ff()._fRectangular = TRUE;
    pCFI->UnprepareForDebug();

    //
    // Add 'vspace' & 'hspace' to margins
    //
    long cxHSpace = GetAAhspace();
    long cyVSpace = GetAAvspace();

    if (cxHSpace)
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._fHasMargins = TRUE;

        CUnitValue uv(cxHSpace, CUnitValue::UNIT_PIXELS);
        if (pCFI->_ff().GetMargin(SIDE_LEFT).IsNullOrEnum())
            pCFI->_ff().SetMargin(SIDE_LEFT, uv);
        if (pCFI->_ff().GetMargin(SIDE_RIGHT).IsNullOrEnum())
            pCFI->_ff().SetMargin(SIDE_RIGHT, uv);

        pCFI->UnprepareForDebug();
    }
    if (cyVSpace)
    {
        pCFI->PrepareFancyFormat();
        pCFI->_ff()._fHasMargins = TRUE;

        CUnitValue uv(cyVSpace, CUnitValue::UNIT_PIXELS);
        if (pCFI->_ff().GetMargin(SIDE_TOP).IsNullOrEnum())
            pCFI->_ff().SetMargin(SIDE_TOP, uv);
        if (pCFI->_ff().GetMargin(SIDE_BOTTOM).IsNullOrEnum())
            pCFI->_ff().SetMargin(SIDE_BOTTOM, uv);

        pCFI->UnprepareForDebug();
    }

    hr = super::ApplyDefaultFormat(pCFI);

    // in NATIVE_FRAMES, IFrames need a default size but (bug 95406) it is 
    // possible that a user has set height:auto or width:auto.  In this 
    // case we want to use the default height (we do not size to content)
    // there are two ways to do this, 1> hack calcsizecore to detect an iframe with
    // auto settings, or 2> hack a reset for it here.  due to the possibility of 
    // regresions, I will hack here.

    pCFI->PrepareFancyFormat();
    if ( pCFI->_ff().GetWidth().GetRawValue() == CUnitValue::UNIT_ENUM) 
    {
        pCFI->_ff().SetWidth(CUnitValue(300, CUnitValue::UNIT_PIXELS));
    }
    if (pCFI->_ff().GetHeight().GetRawValue() == CUnitValue::UNIT_ENUM)
    {
        pCFI->_ff().SetHeight(CUnitValue(150, CUnitValue::UNIT_PIXELS));
    }

    pCFI->UnprepareForDebug();

    RRETURN( hr );
}

//+---------------------------------------------------------------------------
//
//  Member:     CIFrameElement::Save
//
//  Synopsis:   called twice: for opening <NOFRAMES> and for </NOFRAMES>.
//
//----------------------------------------------------------------------------

HRESULT
CIFrameElement::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    HRESULT hr;

    hr = THR(super::Save(pStreamWrBuff, fEnd));
    if (hr)
        goto Cleanup;

    if (!fEnd && !pStreamWrBuff->TestFlag(WBF_SAVE_PLAINTEXT))
    {
        DWORD dwOldFlags = pStreamWrBuff->ClearFlags(WBF_ENTITYREF);

        pStreamWrBuff->SetFlags(WBF_KEEP_BREAKS | WBF_NO_WRAP);

        if (_cstrContents.Length())
        {
            hr = THR(pStreamWrBuff->Write(_cstrContents));
            if (hr)
                goto Cleanup;
        }

        pStreamWrBuff->RestoreFlags(dwOldFlags);
    }

Cleanup:

    RRETURN1(hr, S_FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\ole\eobject.cxx ===
//+---------------------------------------------------------------------
//
//   File:      eobject.cxx
//
//  Contents:   Object element class, etc..
//
//  Classes:    CObjectElement, etc..
//
//------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#ifndef X_MIME64_HXX_
#define X_MIME64_HXX_
#include "mime64.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_PROPBAG_HXX_
#define X_PROPBAG_HXX_
#include "propbag.hxx"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include "binder.hxx"       // for CDataSourceProvider
#endif

#ifndef X_DBTASK_HXX_
#define X_DBTASK_HXX_
#include "dbtask.hxx"       // for CDatabindTask
#endif

#ifndef X_DMEMBMGR_HXX_
#define X_DMEMBMGR_HXX_
#include "dmembmgr.hxx"       // for CDataMemberMgr
#endif

#ifndef X_POSTDATA_HXX_
#define X_POSTDATA_HXX_
#include "postdata.hxx"     // for cpostdata
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_PROPS_HXX_
#define X_PROPS_HXX_
#include "props.hxx"
#endif

#ifndef X_SAFETY_HXX_
#define X_SAFETY_HXX_
#include "safety.hxx"
#endif

#if defined(_M_ALPHA)
#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include "tearoff.hxx"
#endif
#endif

#define _cxx_
#include "object.hdl"

MtDefine(CParamElement, Elements, "CParamElement")
MtDefine(CObjectElement, Elements, "CObjectElement")
MtDefine(CObjectElement_aryParamBinding_pv, CObjectElement, "CObjectElement::_aryParamBinding::_pv")
MtDefine(CObjectElement_aryParams_pv, CObjectElement, "CObjectElement::_aryParams::_pv")
MtDefine(CObjectElementStreamFromInlineData_pMimeType, Locals, "CObjectElement::StreamFromInlineData pMimeType")
MtDefine(CObjectElementGetIDForParamBinding_strTemp, Locals, "CObjectElement::GetIDForParamBinding strTemp")
MtDefine(CObjectElementSaveToDataStream_pchData, Locals, "CObjectElement::SaveToDataStream pchData")
MtDefine(CObjectElementCreateObject_pchUrl, CObjectElement, "CObjectElement::CreateObject pchUrl")
MtDefine(CObjectElementRetrieveClassidAndData_pchUrl, CObjectElement, "CObjectElement::RetrieveClassidAndData pchUrl")

#define CLSID_PREFIX                _T("clsid:")
#define CLSID_PREFIX_LEN            (ARRAY_SIZE(CLSID_PREFIX)-1)

#define DATA_PREFIX                 _T("data:")
#define DATA_PREFIX_LEN             (ARRAY_SIZE(DATA_PREFIX)-1)

#define DATA_COMPLETE_PREFIX        _T("data:application/x-oleobject;base64,")
#define DATA_COMPLETE_PREFIX_LEN    (ARRAY_SIZE(DATA_COMPLETE_PREFIX)-1)

#define DATA_ENCODING               _T("base64")
#define DATA_ENCODING_LEN           (ARRAY_SIZE(DATA_ENCODING)-1)

#define DATA_MIMETYPE               _T("application/x-oleobject")
#define DATA_MIMETYPE_LEN           (ARRAY_SIZE(DATA_MIMETYPE)-1)

#define CODEBASE_VERSION            _T("version=")

#define CODEBASE_KEY_LEN            4

/// Externs 
EXTERN_C CLSID CLSID_AppletOCX;
extern BOOL IsSpecialUrl(LPCTSTR pchUrl);   // TRUE for javascript, vbscript, about protocols

// Apphack CLSIDs to instantiate in print/preview (IE6 15562)
const CLSID CLSID_Taltech_Barcode   = { 0xC917E12F, 0x9757, 0x11D2, 0x85, 0xDB, 0xF0, 0x18, 0x51, 0xC1, 0x00, 0x00 };   // Taltech barcode (demo & retail)
const CLSID CLSID_AOL_Calendar      = { 0x3AEE3932, 0x59BB, 0x11D3, 0xA8, 0xCC, 0x00, 0x50, 0x04, 0xA0, 0xF3, 0x23 };   // AOL calendar
const CLSID CLSID_CS_Calendar       = { 0xA552A602, 0x0A49, 0x11D4, 0x92, 0xCD, 0x00, 0x60, 0xB0, 0xFA, 0x8D, 0xAC };   // CS caldendar

// Apphack CLSIDs that require special handling in browser mode
const CLSID CLSID_MPIT_Menu         = { 0x22AA22B2, 0x2439, 0x11D3, 0xB9, 0x9C, 0x00, 0xC0, 0x4F, 0x68, 0x8B, 0xE3 };   // Popup menu
WHEN_DBG(CLSID CLSID_MPIT_MenuDBG = CLSID_MPIT_Menu);

#ifdef WIN16
const CLSID CLSID_CMSApplet16 = { 0x0D30EC48L, 0xDD33, 0x11D0, {0xA0, 0xFD, 0x00, 0x00, 0xF8, 0x75, 0x1B, 0x8D}};
// const CLSID CLSID_CMSApplet16 = { 0xfc144cc0, 0x2136, 0x11d0, {0x95, 0x38, 0x0, 0xaa, 0x0, 0x4b, 0x9c, 0x68}};
#endif

const CElement::CLASSDESC CParamElement::s_classdesc =
{
    {
        &CLSID_HTMLParamElement,            // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        NULL,                               // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _pcpi
        ELEMENTDESC_NOLAYOUT,               // _dwFlags
        &IID_IHTMLParamElement,             // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLParamElement,      // _pfnTearOff
    NULL                                    // _pAccelsRun
};

const CONNECTION_POINT_INFO CObjectElement::s_acpi[] =
{
    CPI_ENTRY(IID_IPropertyNotifySink, DISPID_A_PROPNOTIFYSINK)
    CPI_ENTRY(DIID_HTMLObjectElementEvents, DISPID_A_EVENTSINK)
    CPI_ENTRY(DIID_HTMLObjectElementEvents2, DISPID_A_EVENTSINK)
    CPI_ENTRY(IID_IDispatch, DISPID_A_EVENTSINK)
    CPI_ENTRY(IID_ITridentEventSink, DISPID_A_EVENTSINK)
    CPI_ENTRY(IID_NULL, DISPID_A_EVENTSINK) // This will be filled up at
                                        //   with ocx's primary event iid.
    CPI_ENTRY_NULL
};

const CElement::CLASSDESC CObjectElement::s_classdesc =
{
    {
        &CLSID_HTMLObjectElement,       // _pclsid
        0,                              // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                 // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                         // _pcpi
        ELEMENTDESC_NEVERSCROLL    |
        ELEMENTDESC_OLESITE        |    // _dwFlags
        ELEMENTDESC_NOTIFYENDPARSE |
        ELEMENTDESC_NOANCESTORCLICK,
        &IID_IHTMLObjectElement,        // _piidDispinterface
        &s_apHdlDescs,                  // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLObjectElement, // _pfnTearOff
    NULL                                // _pAccelsRun
};

static void
GetVersionFromString(const TCHAR *pchBuf, DWORD *pdwMS, DWORD *pdwLS);

//+---------------------------------------------------------------------------
//
//  Function:   GetVersionFromString
//
//  Synopsis:   Converts version in text format (a,b,c,d) into two dwords
//              (a,b), (c,d).  The printed version number is of format a.b.d
//              (but, we don't care)
//
//  Notes:      Lifted from URLMON.DLL sources.
//
//----------------------------------------------------------------------------

void
GetVersionFromString(const TCHAR *pchBuf, DWORD *pdwMS, DWORD *pdwLS)
{
    const TCHAR *   pch = pchBuf;
    TCHAR           ch;
    USHORT          n = 0;
    USHORT          a = 0;
    USHORT          b = 0;
    USHORT          c = 0;
    USHORT          d = 0;
    enum HAVE { HAVE_NONE, HAVE_A, HAVE_B, HAVE_C, HAVE_D } have = HAVE_NONE;

    *pdwMS = 0;
    *pdwLS = 0;

    if (!pch)            // default to zero if none provided
        return;

    // TODO:  philco 5/6/96
    // Need to add code to handle trailing/leading/embedded spaces in the
    // version string.
    if (!StrCmpC(pch, _T("-1,-1,-1,-1")))
    {
        *pdwMS = 0xFFFFFFFF;
        *pdwLS = 0xFFFFFFFF;
        return;
    }

    for (ch = *pch++;;ch = *pch++)
    {
        if (ch == ',' || ch == '\0')
        {
            switch (have)
            {
            case HAVE_NONE:
                a = n;
                have = HAVE_A;
                break;

            case HAVE_A:
                b = n;
                have = HAVE_B;
                break;

            case HAVE_B:
                c = n;
                have = HAVE_C;
                break;

            case HAVE_C:
                d = n;
                have = HAVE_D;
                break;

            case HAVE_D:
                goto Error;
            }

            if (ch == '\0')
            {
                // all done convert a,b,c,d into two dwords of version

                *pdwMS = ((a << 16)|b);
                *pdwLS = ((c << 16)|d);
                return;
            }

            n = 0; // reset
        }
        else if (ch < '0' || ch > '9')
            goto Error;
        else
        {
            n = n*10 + (ch - '0');
        }
    } /* end forever */

Error:
    *pdwMS = *pdwLS = 0;
}

HRESULT CParamElement::CreateElement(CHtmTag *pht,
                                     CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);
    *ppElementResult = new CParamElement(pht->GetTag(), pDoc);
    return *ppElementResult ? S_OK : E_OUTOFMEMORY;
}

HRESULT 
CObjectElement::RemoveParam(CElement *pelOld)
{
    int idx;
    int c = _aryParams.Size();
    LPCTSTR pchName;
    HRESULT hr = S_OK;
    Assert(pelOld);
    Assert(pelOld->Tag() == ETAG_PARAM);
    CParamElement *pelParam = DYNCAST(CParamElement, pelOld);

    idx = pelParam->_idxParam;
    Assert(idx == _aryParams.Find(pelParam));
    Assert(idx != -1 && idx < c);
    Assert(_aryParams[idx] && _aryParams[idx] == pelParam);
    Assert(_aryParams[idx]->_pelObjParent == this);

    _aryParams.Delete(idx);

    for (int i = idx; i < c-1; i++)
    {
        Assert(_aryParams[i]->_idxParam == i+1);
        _aryParams[i]->_idxParam = i;
    }

    pelParam->_idxParam = -1;
    pelParam->Release();
    Assert(pelParam->GetObjectRefs());

    Assert(c-1 == _aryParams.Size());
    Assert(pelParam->_pelObjParent);

    pelParam->_pelObjParent = NULL;

    if (_pParamBag)
    {
        Assert(_pParamBag && c>0);
        Assert(c == _pParamBag->_aryProps.Size());

        pchName = pelParam->GetAAname();
        Assert(pchName && *pchName);

        for (idx = 0; idx < c; idx++)
        {
            if (0 == _tcsicmp(pchName, _pParamBag->_aryProps[idx]._cstrName))
            {
                _pParamBag->_aryProps[idx].Free();
                _pParamBag->_aryProps.Delete(idx);
                break;
            }
        }

        Assert(c-1 == _pParamBag->_aryProps.Size());
    }

    RRETURN(hr);
}

HRESULT 
CObjectElement::ReplaceParam(CElement *pelNew, CElement *pelOld)
{
    int idx;
    int c;
    LPCTSTR pchName;
    BOOL fAddParam = TRUE;
    HRESULT hr = E_INVALIDARG;
    CParamElement *pelParam;
    Assert(pelOld->Tag() == ETAG_PARAM);
    CParamElement *pelParamOld = DYNCAST(CParamElement, pelOld);

    if (pelNew->Tag() != ETAG_PARAM)
        goto Cleanup;

    // remove <PARAM> from exisiting <OBJECT> if present, first
    pelParam = DYNCAST(CParamElement, pelNew);
    if (pelParam->_pelObjParent)
    {
        Assert(!pelNew->IsInMarkup());
        Assert(pelParam->_idxParam != -1);
        hr = THR(pelParam->_pelObjParent->RemoveParam(pelParam));
        if (hr)
            goto Cleanup;
    }
    else if (pelNew->IsInMarkup())
    {
        Assert(Doc() == pelNew->Doc());
        hr = THR(Doc()->RemoveElement(pelNew, MUS_DOMOPERATION));
        if (hr)
            goto Cleanup;
    }

    c = _aryParams.Size();

    if (_pParamBag)
    {
        Assert(_pParamBag && c>0);
        Assert(c == _pParamBag->_aryProps.Size());

        pchName = pelParamOld->GetAAname();
        Assert(pchName && *pchName);

        for (idx = 0; idx < c; idx++)
        {
            if (0 == _tcsicmp(pchName, _pParamBag->_aryProps[idx]._cstrName))
            {
                _pParamBag->_aryProps[idx].Free();
                _pParamBag->_aryProps.Delete(idx);
                Assert(c-1 == _pParamBag->_aryProps.Size());
                break;
            }
        }

        Assert(idx < c);

        pchName = pelParam->GetAAname();
        if (pchName && *pchName)
        {
            LPCTSTR pchValue = pelParam->GetAAvalue();
            hr = THR(_pParamBag->AddProp((LPTSTR)pchName, _tcslen(pchName), (LPTSTR)pchValue, pchValue ? _tcslen(pchValue) : 0));
            if (hr)
                goto Cleanup;
        }

        fAddParam = (c == _pParamBag->_aryProps.Size());
    }

    Assert(pelParamOld);
    idx = pelParamOld->_idxParam;
    Assert(idx == _aryParams.Find(pelParamOld));
    Assert(idx != -1 && idx < c);
    Assert(_aryParams[idx] && _aryParams[idx] == pelOld);
    _aryParams[idx]->Release();
    Assert(pelParamOld->GetObjectRefs());
    Assert(_aryParams[idx]->_pelObjParent);
    Assert(_aryParams[idx]->_pelObjParent == this);
    Assert(_aryParams[idx]->_pelObjParent == pelParamOld->_pelObjParent);

    Assert(pelParam->_idxParam == -1);
    pelParamOld->_idxParam = -1;
    pelParamOld->_pelObjParent = NULL;

    if (fAddParam)
    {
        pelParam->AddRef();
        _aryParams[idx] = pelParam;
        pelParam->_idxParam = idx;
        Assert(c == _aryParams.Size());
        Assert(!pelParam->_pelObjParent);
        // the parent <OBJECT> will always outlive the child <PARAM>s, so no need to AddRef
        pelParam->_pelObjParent = this; 
    }
    else
    {
        Assert(!_pParamBag || (c-1 == _pParamBag->_aryProps.Size()));
        _aryParams.Delete(idx);
        Assert(c-1 == _aryParams.Size());

        for (int i = idx; i < c-1; i++)
        {
            Assert(_aryParams[i]->_idxParam == i+1);
            _aryParams[i]->_idxParam = i;
        }
    }

    hr= S_OK;

Cleanup:
    RRETURN(hr);
}

HRESULT 
CObjectElement::AddParam(CElement *pelNew, CElement *pelRef)
{
    LPCTSTR pchName;
    HRESULT hr = E_INVALIDARG;
    BOOL fAddParam = TRUE;
    int c;
    CParamElement *pelParam;

    if (pelNew->Tag() != ETAG_PARAM)
        goto Cleanup;

    // first, remove <PARAM> from exisiting <OBJECT> if present or other element if in markup
    pelParam = DYNCAST(CParamElement, pelNew);
    if (pelParam->_pelObjParent)
    {
        Assert(!pelNew->IsInMarkup());
        Assert(pelParam->_idxParam != -1);
        hr = THR(pelParam->_pelObjParent->RemoveParam(pelParam));
        if (hr)
            goto Cleanup;
    }
    else if (pelNew->IsInMarkup())
    {
        Assert(Doc() == pelNew->Doc());
        hr = THR(Doc()->RemoveElement(pelNew, MUS_DOMOPERATION));
        if (hr)
            goto Cleanup;
    }

    c = _aryParams.Size();
    Assert(c || !_pParamBag);

    if (!c && !_pParamBag)
    {
        hr = THR(EnsureParamBag());
        if (hr)
            goto Cleanup;
    }

    if (_pParamBag)
    {
        Assert(c == _pParamBag->_aryProps.Size());

        pchName = pelParam->GetAAname();
        if (pchName && *pchName)
        {
            LPCTSTR pchValue = pelParam->GetAAvalue();
            hr = THR(_pParamBag->AddProp((LPTSTR)pchName, _tcslen(pchName), (LPTSTR)pchValue, pchValue ? _tcslen(pchValue) : 0));
            if (hr)
                goto Cleanup;
        }

        fAddParam = (c+1 == _pParamBag->_aryProps.Size());
    }

    if (fAddParam)
    {
        pelParam->AddRef();
        Assert(pelParam->_idxParam == -1);
        if (pelRef)
        {
            CParamElement *pelParamRef = DYNCAST(CParamElement, pelRef);
            int idx = pelParamRef->_idxParam;
            Assert(idx == _aryParams.Find(pelParamRef));
            Assert(idx != -1 && idx < c);
            Assert(pelParamRef->_pelObjParent == this);
            Assert(_aryParams[idx] && _aryParams[idx] == pelParamRef);
            hr = THR(_aryParams.Insert(idx, pelParam));
            pelParam->_idxParam = idx;

            for (int i = idx+1; i <= c; i++)
            {
                Assert(_aryParams[i]->_idxParam == i-1);
                _aryParams[i]->_idxParam = i;
            }
        }
        else
        {
            hr = THR(_aryParams.Append(pelParam));
            pelParam->_idxParam = c;
        }

        if (hr)
            goto Cleanup;

        Assert(c+1 == _aryParams.Size());
        Assert(!pelParam->_pelObjParent);
        // the parent <OBJECT> will always outlive the child <PARAM>s, so no need to AddRef
        pelParam->_pelObjParent = this; 
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  element creator used by parser
//
//----------------------------------------------------------------------------

HRESULT
CObjectElement::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElementResult)
{
    Assert(ppElementResult);

    *ppElementResult = new CObjectElement(pht->GetTag(), pDoc);

    RRETURN ( (*ppElementResult) ? S_OK : E_OUTOFMEMORY);
}


//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement constructor
//
//----------------------------------------------------------------------------

CObjectElement::CObjectElement (ELEMENT_TAG etag, CDoc *pDoc)
  : super(etag, pDoc), _aryParamBinding(Mt(CObjectElement_aryParamBinding_pv)), 
                       _aryParams(Mt(CObjectElement_aryParams_pv))

{
}


//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement::Passivate, CBase
//
//----------------------------------------------------------------------------

void
CObjectElement::Passivate()
{
    long i;

#ifndef NO_DATABINDING
    //
    // There may be deferred calls pending to DeferredSaveData which
    // we need to clear
    //

    GWKillMethodCall(this, ONCALL_METHOD(CObjectElement, DeferredSaveData, deferredsavedata), 0);
#endif

    for ( i = _aryParamBinding.Size() ; i ; )
    {
        PARAMBINDING *pParamBinding = &_aryParamBinding[--i];

        MemFree(pParamBinding->_strParamName);
        MemFree(pParamBinding->_strDataSrc);
        MemFree(pParamBinding->_strDataFld);
        MemFree(pParamBinding->_strDataFormatAs);
    }
    _aryParamBinding.DeleteAll();

    for (i = _aryParams.Size() ; i ; )
    {
        CParamElement *pelParam = _aryParams[--i];
        Assert(pelParam && pelParam->Tag() == ETAG_PARAM);
        Assert(pelParam->_pelObjParent == this);
        pelParam->_pelObjParent = NULL;
        pelParam->Release();
    }
    _aryParams.DeleteAll();

    if (_pParamBag)
    {
        // This will only happen if the </OBJECT> end-tag is missing.
        TraceTag((tagError, "Missing </OBJECT> tag in HTML source!"));
        ReleaseParamBag();
    }

    super::Passivate();
}


//+----------------------------------------------------------------------------
//
//  Member:     CObjectElement::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-----------------------------------------------------------------------------

HRESULT
CObjectElement::PrivateQueryInterface ( REFIID iid, void ** ppv )
{
    *ppv = NULL;
    switch(iid.Data1)
    {
        QI_HTML_TEAROFF(this, IHTMLElement2, NULL)
        QI_HTML_TEAROFF(this, IHTMLObjectElement, NULL)
        QI_INHERITS2(this, IUnknown, IHTMLObjectElement)
        QI_HTML_TEAROFF(this, IHTMLObjectElement2, NULL)
        QI_HTML_TEAROFF(this, IHTMLObjectElement3, NULL)
        default:
            RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    if (!*ppv)
        RRETURN(E_NOINTERFACE);

    ((IUnknown *)*ppv)->AddRef();

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     InvokeExReady
//
//  Synopsis  :this is only here to handle readyState queries, everything
//      else is passed on to the super
//
//+------------------------------------------------------------------------

#ifdef USE_STACK_SPEW
#pragma check_stack(off)
#endif

STDMETHODIMP
CObjectElement::ContextThunk_InvokeExReady(DISPID dispid,
                              LCID lcid,
                              WORD wFlags,
                              DISPPARAMS *pdispparams,
                              VARIANT *pvarResult,
                              EXCEPINFO *pexcepinfo,
                              IServiceProvider *pSrvProvider)
{
    IUnknown * pUnkContext;

    // Magic macro which pulls context out of nowhere (actually eax)
    CONTEXTTHUNK_SETCONTEXT

    HRESULT  hr = S_OK;

    hr = THR(ValidateInvoke(pdispparams, pvarResult, pexcepinfo, NULL));
    if (hr)
        goto Cleanup;

    hr = THR_NOTRACE(ReadyStateInvoke(dispid, wFlags, _lReadyState, pvarResult));
    if (hr == S_FALSE)
    {
        hr = THR_NOTRACE(super::ContextInvokeEx(dispid,
                                         lcid,
                                         wFlags,
                                         pdispparams,
                                         pvarResult,
                                         pexcepinfo,
                                         pSrvProvider,
                                         pUnkContext ? pUnkContext : (IUnknown*)this));
    }

Cleanup:
    RRETURN(hr);
}

#ifdef USE_STACK_SPEW
#pragma check_stack(on)
#endif

//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement::StreamFromInlineData
//
//  Synopsis:   Retrieve DATA as a mime64 encoded string.
//
//  Notes:      Parses a data attribute of the form:
//
//              DATA="data:application/x-oleobject;base64,8dhfh8d4mvc983f"
//
//----------------------------------------------------------------------------

HRESULT
CObjectElement::StreamFromInlineData(TCHAR *pchData, IStream ** ppStm)
{
    if (!pchData || !ppStm)
        return E_INVALIDARG;

    HRESULT hr = E_FAIL;
    LPTSTR pData = pchData + DATA_PREFIX_LEN; // skip past data: URL specifier

    LPTSTR pComma = _tcsrchr(pData, _T(','));
    if (pComma == NULL)
        return E_INVALIDARG;    // Bad data attribute

    LPTSTR pSemiColon = _tcsrchr(pData, _T(';'));
    if (pSemiColon > pComma)
        pSemiColon = NULL;    // handles case where ';' appears in the encoded data.

    // Indicates the end of the mimetype designation.
    LPTSTR pMimeTerminator = pSemiColon ? pSemiColon : pComma;

    LPTSTR pMimeType = NULL;
    int mimelength = pMimeTerminator - pData + 1;  // leave room for the null terminator

    if (mimelength > 0)
    {
        pMimeType = (TCHAR *)MemAlloc(Mt(CObjectElementStreamFromInlineData_pMimeType),
            mimelength * sizeof(TCHAR));
        if (pMimeType)
        {
            // Since _tcsncpy doesn't terminate the string,
            // fill the memory with zeros.
            ::ZeroMemory(pMimeType, mimelength * sizeof(TCHAR));
            _tcsncpy(pMimeType, pData, (mimelength - 1));
        }
    }
    else
    {
        // Default to this mime type.
        MemAllocString(Mt(CObjectElementStreamFromInlineData_pMimeType),
            _T("text/plain;charset=US-ASCII"), &pMimeType);
    }

    if (pSemiColon)
    {
        pSemiColon = CharNext(pSemiColon);
        if ((_tcsnicmp( pSemiColon, DATA_ENCODING_LEN, DATA_ENCODING, DATA_ENCODING_LEN) == 0) && (_tcsncmp(pMimeType, DATA_MIMETYPE_LEN, DATA_MIMETYPE, DATA_MIMETYPE_LEN) == 0))
        {
            pComma = CharNext(pComma);
            hr = Mime64Decode(pComma, ppStm);
            goto Cleanup;
        }
    }

Cleanup:
    MemFree(pMimeType);
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement::SaveToDataStream
//
//  Synopsis:   Set the DATA attribute as a mime64 encoded string.
//
//----------------------------------------------------------------------------

HRESULT
CObjectElement::SaveToDataStream()
{
    HRESULT                 hr = S_OK;
    IPersistStreamInit *    pPSI = NULL;
    IStream *               pStm = NULL;
    STATSTG                 statstg;
    HGLOBAL                 hGlobal;
    LPVOID                  pv;
    TCHAR *                 pchData = NULL;

    hr = THR_NOTRACE(QueryControlInterface(IID_IPersistStreamInit, (void **)&pPSI));
    if (hr)
    {
        if (E_NOINTERFACE == hr) // eat up certain errors
            hr = S_OK;
        goto Cleanup;
    }

    hr = THR(CreateStreamOnHGlobal(NULL, TRUE, &pStm));
    if(hr)
        goto Cleanup;

    hr = THR(OleSaveToStream((IPersistStream*)pPSI, pStm));
    if (hr)
    {
        if (E_NOTIMPL == hr)
            hr = S_OK;  // bug 49053
        goto Cleanup;
    }

    hr = THR(pStm->Stat(&statstg, STATFLAG_NONAME));
    if (hr)
        goto Cleanup;

    if (statstg.cbSize.HighPart)
    {
        hr = E_FAIL; // way too long stream to save it
        goto Cleanup;
    }

    hr = THR(GetHGlobalFromStream(pStm, &hGlobal));
    if (hr)
        goto Cleanup;

    pv = GlobalLock(hGlobal);
    if (pv == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    // we allocate this size under assumption that
    // mime64 encoding increases size if input not more than 2 times
    pchData = new(Mt(CObjectElementSaveToDataStream_pchData)) TCHAR [DATA_COMPLETE_PREFIX_LEN + 2 * statstg.cbSize.LowPart + 1];
    if (!pchData)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    _tcscpy (pchData, DATA_COMPLETE_PREFIX);

    hr = THR(Mime64Encode((BYTE *)pv, statstg.cbSize.LowPart, pchData + DATA_COMPLETE_PREFIX_LEN));
    if (hr)
        goto Cleanup;

    GlobalUnlock(hGlobal);

    hr = THR(SetAAdata(pchData));
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pPSI);
    ReleaseInterface(pStm);
    delete [] pchData;
    RRETURN(hr);
}

// (alexz) (anandra) (oliverse) (hollyba)
// because of a bug in JavaVM (as of Sep 3, 97), applets can crash when printed on
// FE Win95 systems. For stability reasons, instead of making the fix in JavaVM
// (which is not safe) we disable printing them on FE Win95 systems. In case if
// Java VM team makes a private or other drop of java VM with the problem fixed,
// registry key Software\\Microsoft\\Internet Explorer\\PrintAppletsOnFEWin95 can
// be put into the registry which will allow printing of applets on FE Win95.
// All other systems should not be affected by this fix.
//

BOOL PrintAppletsOnFEWin95()
{
    static TCHAR szTableRootKey[] =
        _T("Software\\Microsoft\\Internet Explorer\\PrintAppletsOnFEWin95");

    LONG    lRet;
    HKEY    hkeyRoot = NULL;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTableRootKey, 0, KEY_READ, &hkeyRoot);

    if (hkeyRoot)
        RegCloseKey (hkeyRoot);

    return (ERROR_SUCCESS == lRet) ? TRUE : FALSE;
}


//+------------------------------------------------------------------------
//
//  Member:     CObjectElement::CreateObject()
//
//  Synopsis:   Helper to instantiate control
//
//-------------------------------------------------------------------------

HRESULT
CObjectElement::CreateObject()
{
    HRESULT             hr = S_OK;
    OLECREATEINFO       info;
    TCHAR *             pchCodeBase = NULL;
    TCHAR *             pchVersion = NULL;
    TCHAR   cBuf[pdlUrlLen];
    TCHAR *             pchBaseUrl = cBuf;

    GWKillMethodCall((COleSite *)this, ONCALL_METHOD(COleSite, DeferredCreateObject, deferredcreateobject), 0);

    // if already created, do nothing
    if (_pUnkCtrl)
        goto Cleanup;

    //
    // This is where we create the object based on the html attributes
    // First try and get a clsid if possible.
    //

    hr = RetrieveClassidAndData(
             &info.clsid,
             &info.pStream,
             &info.pchDataUrl,
             &info.pchClassid);

    // We found a applet tag with a non Applet clsid OR 
    // an object tag with a code attribute and non-applet clsid, so prevent creation
    if (FAILED(hr))
    {
        goto Cleanup;
    }

    //
    // Check if there is a snapshot. 
    // If there is, don't bother learning anything else about the object.
    //
    if (    _pParamBag
        &&  HasMarkupPtr()
        &&  GetMarkupPtr()->IsPrintMedia())
    {
        // AppHack (greglett)
        // Certain ActiveX controls want to draw during printing so that they can take
        // advantage of the higher resolution.
        if (    info.clsid == CLSID_Taltech_Barcode
            ||  info.clsid == CLSID_AOL_Calendar
            ||  info.clsid == CLSID_CS_Calendar         )       // Any more and we should iterate over a list!
            goto InstantiateHere;
        
        // See if there is a metafile provided
        VARIANT    var;
        var.vt = VT_BSTR;


        if (OK(_pParamBag->Read(L"_Snapshot_EMF", &var, NULL, 0)) &&
            var.vt == VT_BSTR && var.bstrVal)
        {
            // "_ZERO" means that the original didn't have layout, or had zero size.
            // We don't need it at all.
            if (0 !=_tcscmp(var.bstrVal, _T("_ZERO")))
            {
                // "_EB_FACTORY" means that this object doesn't have a metafile and 
                // MUST be instantiated. If not, then nothing will print/preview 
                // sicne we can't instantiate the element behavior
                if (0 ==_tcscmp(var.bstrVal, _T("_EB_FACTORY")))
                {
                    VariantClear(&var);
                    goto InstantiateHere;
                }

                // Open the metafile and hold on to it
                if (g_dwPlatformID == VER_PLATFORM_WIN32_NT)
                {
                    // Use Unicode file name
                    _hemfSnapshot = GetEnhMetaFile(var.bstrVal);
                }
                else
                {
                    // Use ANSI file name
                    char achFileNameA[MAX_PATH];
                    if (WideCharToMultiByte(CP_OEMCP, 0, var.bstrVal, -1, achFileNameA, MAX_PATH, NULL, NULL))
                    {
                        _hemfSnapshot = GetEnhMetaFileA(achFileNameA);
                    }
                }
            }
            // NOTE: whether we have succeeded with opening metafile or not, 
            //       DON'T proceed to loading the object. If there is metafile name in the stream,
            //       the object data is not usable.
            VariantClear(&var);

             // Supply a dummy object to pretend we've loaded it. It will fail all QIs and do nothing.
            _pUnkCtrl = (IUnknown *) new CDummyUnknown;
            _pUnkCtrl->AddRef();
            goto Cleanup;
        }
    } 
    
    // If we are in a print media markup, (getting here means we did NOT have a metafile)
    // and If we are a print template, don't instantiate the control.. 
    //    this is a major security issue, and a bigger UI problem.
    if (    !_fViewLinkedWebOC
        &&  IsPrintMedia()     )
    {
        // if we do not have a param bag, but are in a print media markup in a print template
        // still do not bring up the contrl
        // however, we do want to go to READYSTATE_COMPLETE so no one waits for us to download
        OnControlReadyStateChanged(TRUE);
        goto Cleanup;
    }


InstantiateHere:

    //
    // Bail out if not allowed to create control/applet/plugin
    //

    // [kusumav] - Moved this check from COleSite::CreateObjectNow
    // We may not have a clsid here but unless we pass in URLPOLICY_ACTIVEX_CHECK_LIST as a policy
    // to check when we call ProcessUrlAction, urlmon doesn't even look at this clsid. We only
    // check if controls are allowed to be created for the current zone.
    // A better fix may be to start the bind and wait for the clsid/mime notification but since 
    // urlmon posts progress notifications async-ly and due to the time gap to call Terminate
    // urlmon may already have created the server which we don't want. 
    if (!AllowCreate(info.clsid))
    {
        NotifyHaveProtectedUserFromUnsafeContent(GetMarkup(), IDS_OCXDISABLED);
        OnFailToCreate();
	OnControlReadyStateChanged();
        goto Cleanup;
    }

    // Check for zone elevation in case of the web browser object.
    CMarkup *pMarkup = HasMarkupPtr() ? GetMarkupPtr() : NULL;
    if (pMarkup && _pParamBag && (info.clsid == CLSID_WebBrowser || info.clsid == CLSID_WebBrowser_V1))
    {
        PROPNAMEVALUE *pprop = NULL;
        TCHAR cBuf[pdlUrlLen];
        BSTR bstrLoc = _T("location");

        pprop = _pParamBag->Find(bstrLoc);
        if (pprop)
        {
            hr = THR(CMarkup::ExpandUrl(NULL, V_BSTR(&pprop->_varValue), ARRAY_SIZE(cBuf), cBuf, this));
            if (!SUCCEEDED(hr) || !COmWindowProxy::CanNavigateToUrlWithLocalMachineCheck(pMarkup, NULL, cBuf))
            {
                OnFailToCreate();
                goto Cleanup;
            }
        }
    }

    //
    // Now initialize the mime type
    //

    if (info.clsid == CLSID_NULL && GetAAtype())
    {
        MemAllocString(Mt(OleCreateInfo),
            (TCHAR *)GetAAtype(), &info.pchMimeType);
    }

    //
    // Initialize the major and minor versions to a default of 0
    //

    info.dwMajorVer = info.dwMinorVer = (DWORD)0;

    //
    // Go about determining the source of the object/applet
    //

    info.pchSourceUrl = NULL;
    pchCodeBase = (TCHAR*) GetAAcodeBase();
    if (pchCodeBase)
    {
        // CODEBASE= values can take several forms:
        // 1. Full URL path:  CODEBASE=http://www.this.com/ctrls/foo.cab#version=...
        // 2. Relative URL:   CODEBASE=ctrls/foo.cab#version=...
        // 3. No URL:         CODEBASE=#version=...

        if (pchCodeBase[0] != _T('#') )
        {
            TCHAR   cBuf[pdlUrlLen];
            DWORD   dwZone;
            IInternetSecurityManager *pSecurityManager;

            // There is a part of a URL to expand & combine:
            hr = THR(CMarkup::ExpandUrl(NULL, pchCodeBase, ARRAY_SIZE(cBuf), cBuf, this));

            if (hr)
                goto Cleanup;

            // Reducing Attack Surface area, we will not allow special urls in the data attrib
            if (IsSpecialUrl(cBuf))
            {
                hr = E_ACCESSDENIED;
                goto Cleanup;
            }
           
            CMarkup *    pMarkup = HasMarkupPtr() ? GetMarkupPtr() : NULL;  //Moved from down a-thkesa. 
            if (pMarkup)
            {
                pSecurityManager = GetMarkup()->GetSecurityManager();
                if (!pSecurityManager)
                   hr = E_ACCESSDENIED;
                else
                {
                   pSecurityManager->MapUrlToZone(cBuf, &dwZone, 0);

                   if (dwZone == URLZONE_LOCAL_MACHINE)
                   {
                      DWORD dwPageUrlZone;
                      pSecurityManager->MapUrlToZone(CMarkup::GetUrl(GetMarkup()), &dwPageUrlZone, 0);
                      if (dwPageUrlZone != URLZONE_LOCAL_MACHINE)
                         hr = E_ACCESSDENIED;
                   }
                }

                if (hr)
                   goto Cleanup;

                if (pMarkup->ValidateSecureUrl(pMarkup->IsPendingRoot(), cBuf, FALSE, FALSE))
                {
                    MemAllocString(Mt(CObjectElementCreateObject_pchUrl), cBuf, &info.pchSourceUrl);
                    if (info.pchSourceUrl == NULL)
                        goto Cleanup;

                    pchCodeBase = info.pchSourceUrl;

                    //
                    // Search the codebase for '#'.  This is the delimiter for the
                    // version.
                    //

                    // (ferhane/alanshi) 
                    // For Fusion usage, URLMON now needs the complete URL as the codebase string, 
                    // including the version information. So, we stopped terminating the codebase
                    // string at the '#' sign. The version string is still copied and used separately.

                    pchVersion = _tcschr(info.pchSourceUrl, _T('#'));

                    if (pchVersion)
                        pchVersion++;
                }
            }
        }
        else
        {   // There was only a version number:
            pchVersion = pchCodeBase+1;
        }

        if (pchVersion)
        {
            //
            // Continue searching for the "version="
            //

            if (_tcsnipre(
                    CODEBASE_VERSION, ARRAY_SIZE(CODEBASE_VERSION) - 1,
                    pchVersion, -1))
            {
                // Advance past the "version="
                pchVersion += ARRAY_SIZE(CODEBASE_VERSION) - 1;
                GetVersionFromString(pchVersion, &info.dwMajorVer, &info.dwMinorVer);
            }
        }
    }

    //
    // Finally in the case of the applet oc, specifically save
    // all attributes into the param bag so the applet oc can retrieve
    // everything.
    //
    if (info.clsid == CLSID_AppletOCX)
    {
        if (g_fFarEastWin9X && GetMarkupPtr()->IsPrintMedia())
        {
            if (!PrintAppletsOnFEWin95())
            {
                hr = E_FAIL;
                goto Cleanup;
            }
        }

        hr = THR(EnsureParamBag());
        if (hr)
            goto Cleanup;

        Assert(_pParamBag);

        //
        // Save attributes into param bag.
        //

        hr = THR(super::SaveAttributes(_pParamBag));
        if (hr)
            goto Cleanup;

        //
        // Set the codebase attribute to point to the full base url
        // The VM ocx needs this.
        //

        if (!pchCodeBase)
        {
            hr = THR(CMarkup::ExpandUrl(NULL, _T("."), ARRAY_SIZE(cBuf), pchBaseUrl, this));
            if (hr)
                goto Cleanup;

            // Reducing Attack Surface area, we will not allow special urls in the data attrib
            if (IsSpecialUrl(cBuf))
            {
                hr = E_ACCESSDENIED;
                goto Cleanup;
            }

            CMarkup *    pMarkup = HasMarkupPtr() ? GetMarkupPtr() : NULL;
            if (pMarkup)
            {
                if (!pMarkup->ValidateSecureUrl(pMarkup->IsPendingRoot(), pchBaseUrl, FALSE, FALSE))
                {
                    hr = E_FAIL;
                    goto Cleanup;
                }
                hr = THR(_pParamBag->AddProp(_T("codeBase"), pchBaseUrl));
                if (hr)
                    goto Cleanup;
            }
        }
        else
        {
            // update the entry with the new string, 
            hr = THR(_pParamBag->FindAndSetProp(_T("codeBase"), pchCodeBase));
            if (hr)
                goto Cleanup;
        }
    }

    if (TLS(_pDataObjectForPaste))
    {
        info.pDataObject = TLS(_pDataObjectForPaste);
        (info.pDataObject)->AddRef();

        // Just to make the point that we have consumed this data obj.
        TLS(_pDataObjectForPaste) = NULL;
    }

    if (_pParamBag)
    {
        info.pPropBag = _pParamBag;
        _pParamBag->AddRef();
    }

    {
        //
        // (t-chrisr) hack so that webcheck can find out all the
        // information it needs to properly pull down java applets.
        //
        if (_pParamBag &&
            (OlesiteTag() == OSTAG_APPLET) &&
            (Doc()->_dwLoadf & DLCTL_NO_JAVA) &&
            Doc()->_pClientSite)
        {
            VARIANTARG  varargIn;
            VARIANTARG  varargOut;
            VariantInit(&varargIn);
            V_VT(&varargIn) = VT_UNKNOWN;
            varargIn.punkVal = (IPropertyBag2*)_pParamBag;

            //
            // if this fails, it should do no harm to us
            //
            IGNORE_HR(CTExec(Doc()->_pClientSite,
                            &CGID_JavaParambagCompatHack,
                            0,
                            MSOCMDEXECOPT_DONTPROMPTUSER,
                            &varargIn,
                            &varargOut));
        }
    }

    {
        // 
        // (olego) apphack fix for IE6 bug 25970. Set _fAppHack_MPIT_Menu flag 
        // so COleLayout can alter behaviour for this control...
        // 
        if (info.clsid == CLSID_MPIT_Menu)
        {
            _fAppHack_MPIT_Menu = TRUE;
        }
    }

    hr = THR(super::CreateObject(&info));


Cleanup:
    // If the control has been created, release the param bag.
    if (_pUnkCtrl)
        ReleaseParamBag();
        
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement::RetrieveClassidAndData
//
//  Synopsis:   Helper for retrieving a CLSID from html attributes
//  
//  [kusumav - 03/2002] This function did not return a HRESULT previously and
//              we ignored all errors here. Still keeping the same behavior 
//              except for the invalid applets case since we don't want to 
//              create the element in these cases(See where hRes is being set)
//----------------------------------------------------------------------------

HRESULT
CObjectElement::RetrieveClassidAndData(
    CLSID *pclsid,
    IStream **ppStream,
    TCHAR **ppchData,
    TCHAR **ppchClassid)
{
    HRESULT     hr, hRes = S_OK;
    IBindCtx *  pBC = NULL;
    TCHAR *     pchData = (TCHAR *)GetAAdata();
    TCHAR *     pchClsid = (TCHAR *)GetAAclassid();

    //
    //  Rules for retrieval:
    //      -   If we have a data:, get the clsid from it.
    //      -   If we had a real clsid present as an attribute, use it.
    //      -   If the code attribute is present, default to the applet ocx.
    //      -   Try to infer the clsid from the codeType attribute.
    //      -   Failing that try to infer the clsid from the type attribute.
    //

    if (pchData)
    {
        if (!_tcsnipre(DATA_PREFIX, DATA_PREFIX_LEN, pchData, -1))
        {
            TCHAR   cBuf[pdlUrlLen];
            MemFreeString(*ppchData);
            hr = THR(CMarkup::ExpandUrl(NULL, pchData, ARRAY_SIZE(cBuf), cBuf, this));
            if (hr)
                goto Error;

            // Reducing Attack Surface area, we will not allow special urls in the data attrib
            if (IsSpecialUrl(cBuf))
            {
                hr = E_ACCESSDENIED;
                goto Error;
            }

            CMarkup *    pMarkup = HasMarkupPtr() ? GetMarkupPtr() : NULL;
            if (pMarkup)
            {
                if (pMarkup->ValidateSecureUrl(pMarkup->IsPendingRoot(), cBuf, FALSE, FALSE))
                {
                    MemAllocString(Mt(CObjectElementRetrieveClassidAndData_pchUrl), cBuf, ppchData);
                    if (ppchData == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                        goto Error;
                    }
                }
            }
        }
        else
        {
            HKEY hKey;
            DWORD dwData = 0, dwSize = sizeof(dwData);
            RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\Internet Explorer\\ActiveX Compatibility"), 
                NULL, KEY_QUERY_VALUE, &hKey);
            RegQueryValueEx(hKey, TEXT("EnableInlineData"), NULL, NULL, (LPBYTE)&dwData, &dwSize);
            RegCloseKey(hKey);

            if (dwData)
            {
                LARGE_INTEGER   dlibMove = {0,0};

                // inline mime64-encoded data.  Parse and decode.
                hr = THR(StreamFromInlineData(pchData, ppStream));
                if (hr)
                    goto Error;

                // seek to the begining of the stream
                hr = THR((*ppStream)->Seek(dlibMove, STREAM_SEEK_SET, NULL));
                if (hr)
                    goto Error;

                //
                // read the clsid from the first 16 bytes
                //

    #ifdef BIG_ENDIAN
                Assert( 0 && "Fix big endian read of clsid" );
    #endif

                hr = THR((*ppStream)->Read(pclsid, 16, NULL));
                if (hr)
                    goto Error;

                goto Cleanup;
            }
        }
    }

    if (pchClsid && *pchClsid)
    {
        if (!OK(CLSIDFromHtmlString(pchClsid, pclsid)))
        {
            TCHAR   achBuf[pdlUrlLen];

            MemFreeString(*ppchClassid);
            hr = THR(CMarkup::ExpandUrl(NULL, pchClsid, ARRAY_SIZE(achBuf), achBuf, this));
            if (hr)
                goto Error;

            // Reducing Attack Surface area, we will not allow special urls in the data attrib
            if (IsSpecialUrl(achBuf))
            {
                hr = E_ACCESSDENIED;
                goto Error;
            }

            CMarkup *    pMarkup = HasMarkupPtr() ? GetMarkupPtr() : NULL;
            if (pMarkup)
            {
                if (pMarkup->ValidateSecureUrl(pMarkup->IsPendingRoot(), achBuf, FALSE, FALSE))
                {
                    MemAllocString(Mt(CObjectElementRetrieveClassidAndData_pchUrl), achBuf, ppchClassid);
                    if (ppchClassid == NULL)
                    {
                        hr = E_OUTOFMEMORY;
                        goto Error;
                    }
                }
            }
        }
        // Is this an object tag with code attrib and a non applet clsid, if yes then don't create it
        if (((Tag() == ETAG_OBJECT) && (GetAAcode() && *GetAAcode())) || (Tag() == ETAG_APPLET))
        {
            if (*pclsid != CLSID_AppletOCX)
            {
                hRes = E_ACCESSDENIED;
                goto Error;
            }
        }
        goto Cleanup;
    }

    if ((Tag() == ETAG_APPLET) || GetAAcode())
    {
#ifndef WIN16
        *pclsid = CLSID_AppletOCX;
#else
                *pclsid = CLSID_CMSApplet16;
#endif
        goto Cleanup;
    }

    hr = THR(CreateAsyncBindCtxEx(NULL, 0, NULL, NULL, &pBC, 0));
    if (hr)
        goto Error;

    if (GetAAcodeType())
    {
        hr = THR_NOTRACE(GetClassFileOrMime(
                pBC,
                NULL,
                NULL,
                0,
                GetAAcodeType(),
                0,
                pclsid));
    }
    else if (GetAAtype())
    {
        hr = THR_NOTRACE(GetClassFileOrMime(
                pBC,
                NULL,
                NULL,
                0,
                GetAAtype(),
                0,
                pclsid));
    }
    else if (pchData)       // try the data URL to find a mime type
    {
        hr = THR_NOTRACE(GetClassFileOrMime(
                pBC,
                pchData,
                NULL,
                0,
                NULL,
                0,
                pclsid));

        // URLMON special cases CLSID_HTMLDocument to return the following
        // failure.  We don't want to lose the contents of *pchData in this case.
        if (hr == REGDB_E_CLASSNOTREG)
        {
            Assert(*pclsid == GUID_NULL);
            hr = S_OK;
        }
    }

    pBC->Release();

    if (hr)
        goto Error;

Cleanup:
    // Check for zone elevation.
    CMarkup *pMarkup = HasMarkupPtr() ? GetMarkupPtr() : NULL;
    if (pMarkup && pclsid && *pclsid == GUID_NULL && ppchData && *ppchData &&
        !COmWindowProxy::CanNavigateToUrlWithLocalMachineCheck(pMarkup, NULL, *ppchData))
    {
        // Note that when you get back to Cleanup from Error, *ppchData is NULL.
        // So there is no infinite loop here.
        goto Error;
    }
    RRETURN1(hRes, E_ACCESSDENIED);

Error:
    ClearInterface(ppStream);
    MemFreeString(*ppchData);
    *ppchData = NULL;
    *pclsid = GUID_NULL;
    goto Cleanup;
}


//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement::Save
//
//  Synopsis:   called twice: for opening <OBJECT> and for closing </OBJECT>.
//              Adds to parent's implementation saving parambag if necessary
//
//----------------------------------------------------------------------------

HRESULT
CObjectElement::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    HRESULT hr = S_OK;
    TCHAR * pchData;
    BOOL    fSaveParams = FALSE;
    BOOL    fHadParamBag = !!(_pParamBag);

    if (pStreamWrBuff->TestFlag(WBF_NO_OBJECTS))
    {
        goto Cleanup;        
    }

    if (!fEnd && !pStreamWrBuff->TestFlag(WBF_SAVE_PLAINTEXT))
    {
        //
        // Saving open tag.
        //

        //
        // Many cases to consider here.
        // Case 1:  DATA attribute exists and it's not a data:
        //          Just save the attribute as is, and no saving params
        // Case 2:  DATA attribute exists and it is a data:
        //          Ask control to persist itself into stream and
        //          mime encode it.
        // Case 3:  Try IPersistPropertyBag::Save
        // Case 4:  Try IPersistStream::Save
        //

        pchData = (TCHAR *)GetAAdata();
        if (pchData)
        {
            if (_tcsnipre(DATA_PREFIX, DATA_PREFIX_LEN, pchData, -1))
            {
                // Case 2

                hr = THR(SaveToDataStream());
                // see commment 10 lines lower
                if (   hr 
                    && !Doc()->_fSaveTempfileForPrinting)
                    goto Cleanup;
            }
        }
        else
        {
            // Case 3

            if (_pParamBag)
            {
                fSaveParams = TRUE;
            }
            
            if (OK(ExchangeParamBag(FROMCONTROL)))
            {
                fSaveParams = TRUE;
            }
            else
            {
                // Case 4:

                hr = THR(SaveToDataStream());
                // if we are saving for printing we don't want to bail (104177)
                // because this will avoid saving the metafile, and nothing will
                // print.  
                if (   hr 
                    && !Doc()->_fSaveTempfileForPrinting)
                    goto Cleanup;
            }
        }
    }

    hr = THR(super::Save(pStreamWrBuff, fEnd));
    if (hr)
        goto Cleanup;

    if (!fEnd && !pStreamWrBuff->TestFlag(WBF_SAVE_PLAINTEXT))
    {
        // If we're saving for printing
        // TODO PRINT 112553: don't save anything other than snapshot 
        //                 if snapshot save is successful
        if (   Doc()->_fSaveTempfileForPrinting
            && _pUnkCtrl)
        {
            //
            // if we have a param bag then everything should save fine. However under
            // cases 1,2,4 above it is *possible* that we have no param bag at this point.
            // in this situation we simply want to create one and try to save the metafile.
            // Note, it is really important that we save the metafile. if this fails, then
            // the object will be instantiated in the print template and be UI activated, 
            // scrollable, poorly sized (due to high res measuring) and possibly have 
            // security warnings.  So pay attenting to the below Assert if you see it.
            //
            IGNORE_HR(EnsureParamBag());

            if (_pParamBag)
            {
                TCHAR   achTempFileName[MAX_PATH];
                
                if (S_OK == SaveMetaFileSnapshot(achTempFileName))
                {
                    THR(_pParamBag->AddProp(L"_Snapshot_EMF", achTempFileName));

                    fSaveParams = TRUE;
                }
                else
                {
                    // Well, we have failed to write out metafile snapshot, 
                    // but we are not going to do anything about it, except 
                    // we'll assert and investigate why that happens, just in case.
                    // The worst thing that can happen is we'll instantiate a new object 
                    // in print doc.
                    AssertSz(0, "Failed to save metafile shapshot");
                }
            }
        }

        // if open tag was just written
        hr = THR(SaveParamBindings(pStreamWrBuff));
        if (hr)
            goto Cleanup;

        if (fSaveParams && _pParamBag)
        {
            CPropertyBag *pParamBagFiltered = _pParamBag;

            if (!pStreamWrBuff->TestFlag(WBF_NO_DATABIND_ATTRS))
            {
                hr = THR(RemoveBoundParams(_pParamBag, fHadParamBag,
                                            &pParamBagFiltered));
            }
            
            hr = THR(pParamBagFiltered->Save(pStreamWrBuff));
            if (pParamBagFiltered != _pParamBag)
                pParamBagFiltered->Release();
            if (hr)
                goto Cleanup;
        }

        // save altHtml after PARAMs
        hr = THR(SaveAltHtml(pStreamWrBuff));
        if (hr)
            goto Cleanup;
    }

Cleanup:
    // we release the param bag, if we created it now. 
    // We should not release it if we already had it when we were called.
    if ( !fHadParamBag )
        ReleaseParamBag();

    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement::RemoveBoundParams
//
//  Synopsis:   Helper routine, called by CObjectElement::Save.  This walks
//              through the param bag removing any params that also appear
//              in the param binding list, so that we don't persist them
//              twice.
//
//              To avoid allocations, we return the original bag
//              whenever possible - either because there were no changes
//              to make or because the caller said it was OK to change
//              the original list in place (by passing fPreserve = FALSE).
//              It's the caller's responsibility to release the new bag
//              if we did have to allocate a new one.
//
//  Arguments:  pParamBag           param bag (input)
//              fPreserve           true if we shouldn't change input bag
//              ppParamBagReturn    filtered param bag (output)
//
//----------------------------------------------------------------------------

HRESULT
CObjectElement::RemoveBoundParams(CPropertyBag *pParamBag,
                                    BOOL fPreserve,
                                    CPropertyBag **ppParamBagReturn)
{
    Assert(pParamBag && ppParamBagReturn);
    HRESULT hr = S_OK;
    int k;
    PROPNAMEVALUE *pProp;
    CPropertyBag *pParamBagNew;
    BOOL fNeedCopy = FALSE;

    // assume we can reuse the original bag
    *ppParamBagReturn = pParamBag;

    // if there are no param bindings, there's nothing to do
    if (_aryParamBinding.Size() == 0)
        goto Cleanup;

    // march through the input bag backwards, looking for duplicates
    for (k=pParamBag->_aryProps.Size()-1, pProp=&(pParamBag->_aryProps[k]);
         !fNeedCopy && k >= 0;
         --k, --pProp)
    {
        int j;
        PARAMBINDING *pParamBinding;

        for (j=_aryParamBinding.Size(), pParamBinding=&_aryParamBinding[0];
             j > 0;
             --j, ++pParamBinding)
        {
            if (!_tcsicmp(pProp->_cstrName, pParamBinding->_strParamName))
            {
                // there's a change to make.  Make it in place, if that's
                // allowed;  otherwise go do a full copy/filter.
                if (fPreserve)
                {
                    fNeedCopy = TRUE;
                }
                else
                {
                    pProp->Free();
                    pParamBag->_aryProps.Delete(k);
                }
                break;      // we've seen the dupe, no sense looking at the rest
            }
        }
    }

    // if we didn't need to allocate a new bag, we're done
    if (!fNeedCopy)
        goto Cleanup;

    // allocate a new param bag
    pParamBagNew = new CPropertyBag;
    if (pParamBagNew == NULL)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }
    
    // copy the properties that don't appear as param bindings
    for (k=pParamBag->_aryProps.Size(), pProp=&(pParamBag->_aryProps[0]);
         k > 0;
         --k, ++pProp)
    {
        int j;
        PARAMBINDING *pParamBinding;
        BOOL fCopy = TRUE;

        for (j=_aryParamBinding.Size(), pParamBinding=&_aryParamBinding[0];
             j > 0;
             --j, ++pParamBinding)
        {
            if (!_tcsicmp(pProp->_cstrName, pParamBinding->_strParamName))
            {
                fCopy = FALSE;
                break;      // we've seen the dupe, no sense looking at the rest
            }
        }

        // if the property wasn't a param binding, copy it to the new bag
        if (fCopy)
        {
            HRESULT hr1;
            PROPNAMEVALUE *pPropNew = pParamBagNew->_aryProps.Append();

            if (pPropNew == NULL)
            {
                hr = E_OUTOFMEMORY;
                goto Cleanup;
            }
            
            hr = pPropNew->_cstrName.Set(pProp->_cstrName);
            VariantInit(&pPropNew->_varValue);
            hr1 = VariantCopy(&pPropNew->_varValue, &pProp->_varValue);
            if (hr || hr1)
            {
                hr = hr ? hr : hr1;
                goto Cleanup;
            }
        }
    }

    // return the new param bag
    *ppParamBagReturn = pParamBagNew;

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement::SaveParamBindings
//
//  Synopsis:   Helper routine, called by CObjectElement::Save, which persists
//              any bindings specified by attributes of PARAM tags.
//
//  Arguments:  pStreamWrBuff:  stream to write HTML to
//
//----------------------------------------------------------------------------

HRESULT
CObjectElement::SaveParamBindings(CStreamWriteBuff * pStreamWrBuff)
{
    HRESULT         hr = S_OK;
    int             cParamBindings = _aryParamBinding.Size();
    PARAMBINDING   *pParamBinding;
    DWORD           dwOldBuffFlags;

    if (pStreamWrBuff->TestFlag(WBF_NO_DATABIND_ATTRS))
        goto Cleanup;

    if (cParamBindings == 0)
        goto Cleanup;

    dwOldBuffFlags = pStreamWrBuff->ClearFlags(WBF_ENTITYREF);
    pStreamWrBuff->BeginIndent();

    for (pParamBinding = &_aryParamBinding[0]; cParamBindings--; pParamBinding++)
    {

        hr = pStreamWrBuff->NewLine();
        if (hr)
            break;

        hr = pStreamWrBuff->Write(
                pStreamWrBuff->TestFlag(WBF_SAVE_FOR_PRINTDOC) && pStreamWrBuff->TestFlag(WBF_SAVE_FOR_XML)
                    ? _T("<HTML:PARAM NAME=") : _T("<PARAM NAME=")
                );
        if (hr)
            break;

        hr = pStreamWrBuff->WriteQuotedText( pParamBinding->_strParamName, TRUE );
        if( hr )
            break;

        if (pParamBinding->_strDataSrc)
        {
            hr = pStreamWrBuff->Write(_T(" DATASRC="));
            if( hr )
                break;

            hr = pStreamWrBuff->WriteQuotedText( pParamBinding->_strDataSrc, TRUE );
            if( hr )
                break;
        }

        if (pParamBinding->_strDataFld)
        {
            hr = pStreamWrBuff->Write(_T(" DATAFLD="));
            if( hr )
                break;

            hr = pStreamWrBuff->WriteQuotedText( pParamBinding->_strDataFld, TRUE );
            if( hr )
                break;
        }

        if (pParamBinding->_strDataFormatAs)
        {
            hr = pStreamWrBuff->Write(_T(" DATAFORMATAS="));
            if( hr )
                break;

            hr = pStreamWrBuff->WriteQuotedText( pParamBinding->_strDataFormatAs, TRUE );
            if( hr )
                break;
        }

        hr = pStreamWrBuff->Write(_T(">"));
        if( hr )
            break;
    }

    pStreamWrBuff->EndIndent();
    pStreamWrBuff->RestoreFlags(dwOldBuffFlags);

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement::SaveAltHtml
//
//  Synopsis:   Helper routine, called by CObjectElement::Save, which saves
//              any "alternate" html originally inside the OBJECT tag
//
//  Arguments:  pStreamWrBuff:  stream to write HTML to
//
//----------------------------------------------------------------------------

HRESULT
CObjectElement::SaveAltHtml (CStreamWriteBuff *pStreamWrBuff)
{
    HRESULT         hr = S_OK;
    TCHAR         * pchAltHtml = (LPTSTR)GetAAaltHtml();
    DWORD           dwOldBuffFlags = pStreamWrBuff->ClearFlags(WBF_ENTITYREF);

    if (pchAltHtml)
    {
        hr = pStreamWrBuff->NewLine();
        if (hr)
            goto Cleanup;

        hr = pStreamWrBuff->Write(pchAltHtml);
    }

Cleanup:
    pStreamWrBuff->RestoreFlags(dwOldBuffFlags);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement::Getobject
//
//  Synopsis:   implementation of pdl-abstract attribute
//
//----------------------------------------------------------------------------

HRESULT
CObjectElement::get_object(IDispatch **ppDisp)
{
    HRESULT hr = S_OK;

    if (!ppDisp)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *ppDisp = NULL;

    if (!IsInMarkup())
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    CacheDispatch();
    if (!_pDisp)
        goto Cleanup;

    if (IsSafeToScript() && AccessAllowed(_pDisp))
    {
        CDoc *pDoc = NULL;
        if (SUCCEEDED(_pDisp->QueryInterface(CLSID_HTMLDocument, (void **)&pDoc)))
        {
            CDocument *pDocument = pDoc->_pWindowPrimary->Document();
            if (pDocument)
            {
                hr = pDocument->QueryInterface(IID_IDispatch, (void **)ppDisp);
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
        else
        {
            *ppDisp = _pDisp;
            _pDisp->AddRef();
        }
    }
    else
    {
        hr = E_ACCESSDENIED;
    }

Cleanup:
    RRETURN(SetErrorInfo(hr));
}


//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement::namedRecordset
//
//  Synopsis:   returns an ADO Recordset for the named data member.  Tunnels
//              into the hierarchy using the path, if given.
//
//  Arguments:  bstrDataMember  name of data member (NULL for default)
//              pvarHierarchy   BSTR path through hierarchy (optional)
//              pRecordSet      where to return the recordset.
//
//
//----------------------------------------------------------------------------

HRESULT
CObjectElement::namedRecordset(BSTR bstrDatamember,
                               VARIANT *pvarHierarchy,
                               IDispatch **pRecordSet)
{
    HRESULT hr;
    CDataMemberMgr *pdmm;

#ifndef NO_DATABINDING
    EnsureDataMemberManager();
    pdmm = GetDataMemberManager();
    if (pdmm)
    {
        hr = pdmm->namedRecordset(bstrDatamember, pvarHierarchy, pRecordSet);
        if (hr == S_FALSE)
            hr = S_OK;
    }
    else
    {
        hr = E_FAIL;
    }
    
#else
    *pRecordSet = NULL;
    hr = S_OK;
#endif NO_DATABINDING

    RRETURN (SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement::getRecordSet
//
//  Synopsis:   returns an ADO Recordset pointer if this site is a data
//              source control
//
//  Arguments:  IDispatch **    pointer to a pointer to a record set.
//
//
//----------------------------------------------------------------------------

HRESULT
CObjectElement::get_recordset(IDispatch **pRecordSet)
{
    HRESULT hr = S_OK;
    *pRecordSet = NULL;                 // Make sure to null on failure.
    CDataMemberMgr *pdmm;
    
#ifndef NO_DATABINDING
    EnsureDataMemberManager();
    pdmm = GetDataMemberManager();
    if (pdmm)
    {
        // normal case, return ADO recordset based on my provider
        hr = pdmm->namedRecordset(NULL, NULL, pRecordSet);
    }
    else
    {
        hr = S_FALSE;
    }
    
    // backward compatability with IE3 and ADC1.1.  If my control isn't a provider
    // (in the Trident sense), it may expose its own recordset property. Delegate.
    if (hr == S_FALSE)
    {
        DISPID dispid;
        VARIANT varRecordset;
        static OLECHAR * oszRecordset = _T("Recordset");

        hr = S_OK;
        if (!_pUnkCtrl)                 // Make sure site really has an object
            goto Cleanup;

        CacheDispatch();

        if ( !_pDisp )
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        // get dispid of control's recordset property
        hr = _pDisp->GetIDsOfNames(IID_NULL, &oszRecordset, 1,
                                    g_lcidUserDefault, &dispid);
        if (hr)
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        // get recordset property
        VariantInit(&varRecordset);
        hr = GetDispProp(_pDisp, dispid, g_lcidUserDefault, &varRecordset);
        if (hr)
            goto Cleanup;

        // return it to caller
        if (varRecordset.vt == VT_DISPATCH || varRecordset.vt == VT_UNKNOWN)
            *pRecordSet = varRecordset.pdispVal;
        else
        {
            hr = DISP_E_MEMBERNOTFOUND;
            VariantClear(&varRecordset);
            goto Cleanup;
        }
    }

Cleanup:
#endif // ndef NO_DATABINDING
    RRETURN (SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement::setRecordSet
//
//  Synopsis:   returns an ADO Recordset pointer if this site is a data
//              source control
//
//  Arguments:  IDispatch **    pointer to a pointer to a record set.
//
//
//----------------------------------------------------------------------------

HRESULT
CObjectElement::put_recordset(IDispatch *pRecordSet)
{
    HRESULT hr = DISP_E_MEMBERNOTFOUND; // Trident does not support put_recordset

#ifndef NO_DATABINDING
    // backward compatability with IE3 and ADC1.1.  If my control isn't a provider
    // (in the Trident sense), it may expose its own recordset property. Delegate.
    if (!IsDataProvider())
    {
        DISPID dispid;
        VARIANT varRecordset;
        static OLECHAR * oszRecordset = _T("Recordset");

        CacheDispatch();

        if ( !_pDisp )
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        // get dispid of control's recordset property
        hr = _pDisp->GetIDsOfNames(IID_NULL, &oszRecordset, 1,
                                    g_lcidUserDefault, &dispid);
        if (hr)
        {
            hr = DISP_E_MEMBERNOTFOUND;
            goto Cleanup;
        }

        // set recordset property
        VariantInit(&varRecordset);
        varRecordset.vt = VT_DISPATCH;
        varRecordset.pdispVal = pRecordSet;
        hr = SetDispProp(_pDisp, dispid, g_lcidUserDefault, &varRecordset);
    }

Cleanup:
#endif // ndef NO_DATABINDING
    RRETURN(SetErrorInfo(hr));
}

//+---------------------------------------------------------------------------
//
//  Member:     CObjectElement::get_BaseHref
//
//  Synopsis:   Returns the base href for this object tag.
//
//----------------------------------------------------------------------------

HRESULT
CObjectElement::get_BaseHref(BSTR *pbstr)
{
        RRETURN( SetErrorInfo(GetBaseHref( pbstr )) );
}

#ifndef NO_DATABINDING
class CDBindMethodsObject : public CDBindMethods
{
    typedef CDBindMethods super;

public:
    CDBindMethodsObject()   {}
    ~CDBindMethodsObject()  {}

    virtual HRESULT BoundValueToElement(CElement *pElem, LONG id,
                                        BOOL fHTML, LPVOID pvData) const;

    virtual HRESULT BoundValueFromElement(CElement *pElem, LONG id,
                                         BOOL fHTML, LPVOID pvData) const;


protected:
    virtual DBIND_KIND DBindKindImpl(CElement *pElem,
                                     LONG id,
                                     DBINFO *pdbi) const;

    virtual BOOL    FDataSrcValidImpl(CElement *pElem) const { return TRUE; }
    virtual BOOL    FDataFldValidImpl(CElement *pElem) const { return TRUE; }
    virtual BOOL    IsReadyImpl(CElement *pElem) const;

    virtual HRESULT GetNextDBSpecCustom(CElement *pElem,
                                        LONG *pid,
                                        DBSPEC *pdbs) const;

};

static const CDBindMethodsObject DBindMethodsObject;

const CDBindMethods *
CObjectElement::GetDBindMethods()
{

    return &DBindMethodsObject;
}


//+----------------------------------------------------------------------------
//
//  Function: DBindKindImpl, CDBindMethods
//
//  Synopsis: Indicate whether or not <element, id> can be databound, and
//            optionally return additional info about binding -- an ID used
//            for transfer, and the desired data type to be used for transfer.
//
//  Arguments:
//            [id]    - binding being asked about; 0 mean defaulbind attribute,
//                      other refers to a param binding
//            [pdbi]  - pointer to struct to get data type and ID;
//                      may be NULL
//
//  Returns:  Binding status: one of
//              DBIND_NONE
//              DBIND_SINGLEVALUE
//              DBIND_ICURSOR
//              DBIND_IROWSET
//              DBIND_DLCURSOR
//
//-----------------------------------------------------------------------------

DBIND_KIND
CDBindMethodsObject::DBindKindImpl(CElement *pElem,
                                   LONG id,
                                   DBINFO *pdbi) const
{
    DBIND_KIND dbk = DBIND_NONE;

    CObjectElement *pObj = DYNCAST(CObjectElement, pElem);
    BOOL fReady = (pObj->_lReadyState >= READYSTATE_LOADED);
    CLASSINFO *pci;     // don't call GetClassInfo unless we have to

    // We use a private dbi, distinct from *pdbi.  Note that pdbi may be NULL;
    // if non-NULL, it has already been initialized.  
    DBINFO dbi;

    dbi._vt = VT_EMPTY;
    // If an Object/Applet can be bound, it will be bound READ/WRITE.
    dbi._dwTransfer = 0;    // no HTML, R/W; different than default *pdbi

    Assert(pObj->Tag() == ETAG_OBJECT
            || pObj->Tag() == ETAG_APPLET
            || pObj->Tag() == ETAG_EMBED );

    // avoid asking for CLASSINFO unless we really have a need --

    if (id != ID_DBIND_DEFAULT)
    {
        CObjectElement::PARAMBINDING *pParamBinding;

        Assert(id - (ID_DBIND_DEFAULT + 1) >= 0);
        Assert(id  - (ID_DBIND_DEFAULT + 1) < pObj->_aryParamBinding.Size());

        pParamBinding = &pObj->_aryParamBinding[id - (ID_DBIND_DEFAULT + 1)];
        pObj->EnsureParamType(pParamBinding);
        if (pParamBinding->_vt == VT_EMPTY)
            goto Cleanup;

        if (!FormsIsEmptyString(pParamBinding->_strDataFld))
        {
            dbk = DBIND_SINGLEVALUE;
            dbi._vt = CVarType(pParamBinding->_vt, pParamBinding->_vt != VT_VARIANT);
        }
        else if (pParamBinding->_vt == VT_UNKNOWN || pParamBinding->_vt == VT_DISPATCH)
        {
            dbk = DBIND_IDATASOURCE;
        }

        goto Cleanup;
    }

    pci = pObj->GetClassInfo();

    //Assert(pObj->GetAAdataFld() || pObj->GetAAdataSrc());

    if (!pObj->GetAAdataFld())  // set-binding requested
    {
// TODO: check that it's not a read-only property
        if (pci->dispIDBind == pci->dispidIDataSource &&
            pci->dispidIDataSource != DISPID_UNKNOWN)
        {
            dbk = DBIND_IDATASOURCE;
        }
        else if (pci->dispidCursor != DISPID_UNKNOWN)
        {
            dbk = DBIND_ICURSOR;
        }
        goto Cleanup;
    }

    if (pci->dispIDBind != DISPID_UNKNOWN)
    {
        VARTYPE vtBind = pci->vtBindType & VT_TYPEMASK;
        dbk = DBIND_SINGLEVALUE;
        dbi._vt = CVarType(vtBind, vtBind != VT_VARIANT && !pObj->IsVTableValid());
    }

Cleanup:
    // Don't bind to objects that aren't safe for scripting
    if (dbk != DBIND_NONE && fReady && !pObj->IsSafeToScript())
    {
        dbk = DBIND_NONE;
    }

    if (pdbi && dbk != DBIND_NONE)
    {
        *pdbi = dbi;
    }
    return dbk;
}


//+----------------------------------------------------------------------------
//
//  Function: IsReadyImpl, CDBindMethods
//
//  Synopsis: Indicate whether the element is ready to be bound.
//
//  Arguments:  pElem       pointer to object element being queried
//
//-----------------------------------------------------------------------------

BOOL
CDBindMethodsObject::IsReadyImpl(CElement *pElem) const
{
    CObjectElement *pObj = DYNCAST(CObjectElement, pElem);

    return (pObj->_lReadyState >= READYSTATE_LOADED);
}

//+----------------------------------------------------------------------------
//
//  Function: GetNextDBSpecCustom, CDBindMethods
//
//  Synopsis: Inspect whatever attributes and styles necessary to determine
//            what bindings are specified in addition to the one on the
//            element's tag itself.
//  Arguments:
//            [pElem] - element being asked bout
//            [pid]   - pointer to ID before the first to be considered
//            [pdbs]  - pointer to struct to get spec; can't be NULL
//
//  Returns:  S_OK:     We have a spec, *pid and *pdbs filled in
//            S_FALSE:  No more specs
//
//  Notes:    ID_DBIND_DEFAULT refers to the elements itself.  Successive
//            values refer to param bindings.
//
//-----------------------------------------------------------------------------

HRESULT
CDBindMethodsObject::GetNextDBSpecCustom(CElement *pElem,
                                         LONG *pid,
                                         DBSPEC *pdbs) const
{
    HRESULT hr = S_FALSE;
    CObjectElement *pObj = DYNCAST(CObjectElement, pElem);
    LONG size = pObj->_aryParamBinding.Size();
    LONG id = *pid;

    CObjectElement::PARAMBINDING *pParamBinding;
    LONG iParamBinding;

    id ++;  // the next id we will try
    iParamBinding = id - (ID_DBIND_DEFAULT + 1);

    if (iParamBinding < 0 || iParamBinding >= size)
    {
        goto Cleanup;
    }

    pParamBinding = &pObj->_aryParamBinding[iParamBinding];
    pdbs->_pStrDataSrc = pParamBinding->_strDataSrc;
    pdbs->_pStrDataFld = pParamBinding->_strDataFld;
    pdbs->_pStrDataFormatAs = pParamBinding->_strDataFormatAs;

    *pid = id;
    hr = S_OK;

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+----------------------------------------------------------------------------
//
//  Function: GetIDForParamBinding, CObjectElement
//
//  Synopsis: For a given PARAMBINDING specification, make sure that we have
//            a dispid to be used to either put or get a property value.
//            Helper for BoundValueToElement and BoundValueFromElement.
//
//  Arguments:
//            [pParamBinding]  - PARAMBINDING structure with property name,
//                               and may or may not have filled in DISPIDs
//                               for getting and putting property values.
//            [fPut]           - Does caller want to a put a value (as opposed
//                               to fetching one?)
//
//  Returns:  S_OK             - Desired DISPID has been set filled in with
//                               somethint other than DISPID_UNKNOWN in the
//                               PARAMBINDING.
//            E_*              - some erorr
//
//-----------------------------------------------------------------------------

HRESULT
CObjectElement::GetIDForParamBinding(PARAMBINDING *pParamBinding, BOOL fPut)
{
    HRESULT hr = S_OK;
    DISPID *pdispid = fPut ? &pParamBinding->_dispidPut
                           : &pParamBinding->_dispidGet;
    DISPID dispid;
    LPTSTR strName;

    if (*pdispid != DISPID_UNKNOWN)
    {
        goto Cleanup;
    }

    strName = pParamBinding->_strParamName;

    CacheDispatch();
    if (!_pDisp)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    hr = THR(_pDisp->GetIDsOfNames(IID_NULL,
                                   &strName,
                                   1,
                                   g_lcidUserDefault,
                                   &dispid ) );
    if (!hr)
    {
        pParamBinding->_dispidPut = pParamBinding->_dispidGet = dispid;
    }
    else
    {
        static const TCHAR PUT_PREFIX[] = _T("set");
        static const TCHAR GET_PREFIX[] = _T("get");
        LPCTSTR strPrefix = fPut ? PUT_PREFIX : GET_PREFIX;
        LPTSTR strTemp =  new(Mt(CObjectElementGetIDForParamBinding_strTemp)) TCHAR[_tcslen(strPrefix) + _tcslen(strName) + 1];

        if (strTemp == NULL)
        {
            hr = E_OUTOFMEMORY;
            goto Cleanup;
        }
        _tcscpy(strTemp, strPrefix);
        _tcscat(strTemp, strName);

        hr = THR(_pDisp->GetIDsOfNames(IID_NULL,
                                       &strTemp,
                                       1,
                                       g_lcidUserDefault,
                                       &dispid ) );
        delete [] strTemp;
        if (!hr)
        {
            *pdispid = dispid;
            pParamBinding->_dwInvokeFlags = DISPATCH_METHOD;
        }
    }

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
//  Function: BoundValueToElement, CDBindMethods
//
//  Synopsis: Transfer data into bound OBJECT.  Only called if DBindKind
//            previous returned TRUE.
//
//  Arguments:
//            [id]      - ID of binding point.  id 0 is the object's
//                        defaultbind property.  Other IDs are PARAM bindings.
//            [pvData]  - pointer to data to transfer, datatype specified
//                        by object's typeinfo
//
//-----------------------------------------------------------------------------

HRESULT
CDBindMethodsObject::BoundValueToElement(CElement *pElem,
                                         LONG id,
                                         BOOL,
                                         LPVOID pvData) const
{
    HRESULT                     hr = S_OK;
    DISPID                      dispid;
    DWORD                       dwInvokeFlags = DISPATCH_PROPERTYPUT;
    CObjectElement             *pObj = DYNCAST(CObjectElement, pElem);
    EXCEPINFO                   except;

    // if the object isn't ready yet, don't do anything and return S_OK.
    // This happens, for example, for applets in a repeated table.
    if (pObj->_lReadyState < READYSTATE_COMPLETE)
        goto Cleanup;

    pObj->CacheDispatch();
    if (!pObj->_pDisp)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (id == ID_DBIND_DEFAULT)
    {
        CLASSINFO      *pci = pObj->GetClassInfo();

        if (pObj->IsVTableValid())
        {
            hr = pObj->VTableDispatch(pObj->_pDisp,
                            pci->vtBindType,
                            COleSite::VTBL_PROPSET,
                            pvData,
                            pci->uPutBindIndex);
            goto Cleanup;
        }

        dispid = pci->dispIDBind;
        dwInvokeFlags = pci->dwFlagsBind;
    }
    else
    {
        CObjectElement::PARAMBINDING *pParamBinding;

        pParamBinding = &pObj->_aryParamBinding[id - (ID_DBIND_DEFAULT + 1)];
        hr = pObj->GetIDForParamBinding(pParamBinding, TRUE);
        if (hr)
            goto Cleanup;
        dispid = pParamBinding->_dispidPut;
        dwInvokeFlags = pParamBinding->_dwInvokeFlags;
    }

    InitEXCEPINFO(&except);
    hr = THR(SetDispProp(pObj->_pDisp,
                         dispid,
                         g_lcidUserDefault,
                         (VARIANT *) pvData,
                         &except,
                         dwInvokeFlags));
    FreeEXCEPINFO(&except);

Cleanup:
    return(hr);
}

//+----------------------------------------------------------------------------
//
//  Function: BoundValueFromElement, CDBindMethods
//
//  Synopsis: Transfer data from bound OBJECT.  Only called if DBindKind
//            previous returned TRUE.
//
//  Arguments:
//            [id]      - ID of binding point.  id 0 is the object's
//                        defaultbind property.  Other IDs are PARAM bindings.
//            [pvData]  - pointer to buffer for transfer, datatype specified
//                        by object's typeinfo
//
//-----------------------------------------------------------------------------

HRESULT
CDBindMethodsObject::BoundValueFromElement(CElement *pElem,
                                           LONG id,
                                           BOOL,
                                           LPVOID pvData) const
{
    HRESULT                     hr;
    DISPID                      dispid;
    DWORD                       dwInvokeFlags = DISPATCH_PROPERTYGET;
    CObjectElement             *pObj = DYNCAST(CObjectElement, pElem);
    EXCEPINFO                   except;

    pObj->CacheDispatch();
    if (!pObj->_pDisp)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    if (id == ID_DBIND_DEFAULT)
    {
        CLASSINFO      *pci = pObj->GetClassInfo();

        if (pObj->IsVTableValid())
        {
            hr = pObj->VTableDispatch(pObj->_pDisp,
                            pci->vtBindType,
                            COleSite::VTBL_PROPGET,
                            pvData,
                            pci->uGetBindIndex);
            goto Cleanup;
        }

        dispid = pci->dispIDBind;
        dwInvokeFlags = pci->dwFlagsBind;
    }
    else
    {
        CObjectElement::PARAMBINDING *pParamBinding;

        pParamBinding = &pObj->_aryParamBinding[id - (ID_DBIND_DEFAULT + 1)];
        hr = pObj->GetIDForParamBinding(pParamBinding, TRUE);
        if (hr)
            goto Cleanup;
        dispid = pParamBinding->_dispidGet;
        dwInvokeFlags = pParamBinding->_dwInvokeFlags;
    }

    InitEXCEPINFO(&except);
    hr = THR(GetDispProp(pObj->_pDisp,
                         dispid,
                         g_lcidUserDefault,
                         (VARIANT *) pvData,
                         &except,
                         dwInvokeFlags));
    FreeEXCEPINFO(&except);
    if (hr)
        goto Cleanup;

Cleanup:
    return(hr);
}


//+----------------------------------------------------------------------------
//
//  Function: EnsureParamType (private helper)
//
//  Synopsis: Determine the preferred type of a param binding
//
//  Arguments:
//            pParamBinding     binding whose type we want
//
//-----------------------------------------------------------------------------

void
CObjectElement::EnsureParamType(PARAMBINDING *pParamBinding)
{
    HRESULT     hr;
    DISPID      dispid;
    EXCEPINFO   except;
    VARIANT     var;
    CLASSINFO   *pci;

    if (pParamBinding->_vt != VT_EMPTY)     // we've already found the type
        goto Cleanup;

    if (_lReadyState < READYSTATE_LOADED)   // we're not ready to answer
        goto Cleanup;

    CacheDispatch();                        // need _pDisp to do anything
    if (!_pDisp)
        goto Cleanup;

    // get the dispid for the property
    hr = GetIDForParamBinding(pParamBinding, FALSE);
    if (hr)
        goto Cleanup;
    dispid = pParamBinding->_dispidGet;

    // Read the property from the control
    VariantInit(&var);
    InitEXCEPINFO(&except);
    hr = THR(GetDispProp(_pDisp,
                         dispid,
                         g_lcidUserDefault,
                         &var,
                         &except,
                         pParamBinding->_dwInvokeFlags));
    FreeEXCEPINFO(&except);
    if (hr)
        goto Cleanup;

    // remember its type
    switch (var.vt)
    {
    case VT_EMPTY:
    case VT_NULL:
        pParamBinding->_vt = VT_VARIANT;
        break;
    case VT_UNKNOWN:
    case VT_DISPATCH:
        // in this case, we need to get the typeinfo to see if the DataSource
        // property is put or putref
        pParamBinding->_vt = var.vt;
        pci = GetClassInfo();
        if (dispid == pci->dispidIDataSource)
        {
            pParamBinding->_dwInvokeFlags = pci->dwFlagsDataSource;
        }
        else if (dispid == pci->dispidRowset)
        {
            pParamBinding->_dwInvokeFlags = pci->dwFlagsRowset;
        }
        break;
    default:
        pParamBinding->_vt = var.vt;
        break;
    }
    VariantClear(&var);

Cleanup:
    return;
}

//+-------------------------------------------------------------------------
//
//  Method:     CObjectElement::DeferredSaveData
//
//  Synopsis:   If the Site was considered dirty, then save the data in a bound
//              element to what is it bound to (often, a database).
//              It is no longer dirty after flush.  Works on the default
//              binding only, not parameter bindings.
//
//  Arguments:  DWORD trickily encodes the bound id.  Because GWKillMethodCall
//              treats dw == 0 as a request to kill all calls no matter what
//              dw, we have to make sure that dw == 0 represents ID_DBIND_ALL.
//
//  Returns:    HRESULT
//
//--------------------------------------------------------------------------

void
CObjectElement::DeferredSaveData(DWORD_PTR dw)
{
    // note use of super:: -- we don't need to call GWKillMethodCall, which
    //  CObjectElement::SaveDataIfChanged would do.

    // ID_DBIND_ALL adjusment is so that dw == 0 maps to id == ID_DBIND_ALL
    IGNORE_HR(super::SaveDataIfChanged((DWORD)dw + ID_DBIND_ALL, /* fLoud */ FALSE));
}


//+-------------------------------------------------------------------------
//
//  Method:     CObjectElement::SaveDataIfChanged, CSite
//
//  Synopsis:   Determine whether or not is appropate to save the value
//              in  a control to a datasource, and do so.  Fire any appropriate
//              events.
//
//  Returns:    S_OK: no work to do, or transfer successful
//
//--------------------------------------------------------------------------
HRESULT
CObjectElement::SaveDataIfChanged(LONG id, BOOL fLoud, BOOL fForceIsCurrent)
{
    // We kill any pending defered calls to ourselves, just in case we got here
    // other than from a defered call.
    // ID_DBIND_ALL adjustment is so that dw == 0 maps to id == ID_DBIND_ALL
    GWKillMethodCall(this, ONCALL_METHOD(CObjectElement, DeferredSaveData, deferredsavedata), (DWORD_PTR)(id - ID_DBIND_ALL));

    RRETURN1(super::SaveDataIfChanged(id, fLoud, fForceIsCurrent), S_FALSE);
}
#endif // ndef NO_DATABINDING

//+-------------------------------------------------------------------------
//
//  Method:     CObjectElement::OnControlRequestEdit, COleSite
//
//  Synopsis:   Give Site (or its derived class) a chance to act on a
//              control's OnRequestEdit notification,  and cancel any forwarding
//              which might normally take place through our XObject.
//
//  Arguments:  dispid of property who's value has changed
//
//  Returns:    HRESULT.  Any non-zero HRESULT, including S_FALSE, will
//              cancel OnRequestEdit forwarding.
//
//--------------------------------------------------------------------------

HRESULT
CObjectElement::OnControlRequestEdit(DISPID dispid)
{
    HRESULT             hr;
    DBMEMBERS          *pdbm;
    CLASSINFO          *pci;
    PARAMBINDING       *pParamBinding;
    int                 cParamBindings;

    hr = super::OnControlRequestEdit(dispid);
    if (hr)
    {
        goto Cleanup;
    }

    if (dispid == DISPID_UNKNOWN)
    {
        goto Cleanup;
    }

    if (_state < OS_LOADED)
    {
        // don't know if this check is necessary here, but it was necessary in
        // OnControlChanged.
        goto Cleanup;
    }

#ifndef NO_DATABINDING
    pdbm = GetDBMembers();
    if (!pdbm)
    {
        goto Cleanup;
    }

    cParamBindings = _aryParamBinding.Size();
    pParamBinding = &_aryParamBinding[cParamBindings];

    while (pParamBinding--, cParamBindings--)
    {
        if (pParamBinding->_dispidGet == dispid)
        {
            if (FAILED(pdbm->CheckSrcWritable(this,
                                 cParamBindings + (ID_DBIND_DEFAULT+1) ) ) )
            {
                hr = S_FALSE;
                goto Cleanup;
            }
        }
    }

    // we've considered the PARAM bindings; now consider the default
    //  binding.

    // Avoid accessing the ClassInfo unless we know that ID_DBIND_DEFAULT
    //  is bound.
    if (!pdbm->FBoundID(this, ID_DBIND_DEFAULT))
    {
        goto Cleanup;
    }

    // Now that we're sure we need it, get the ClassInfo
    pci = GetClassInfo();
    if (dispid != pci->dispIDBind)
    {
        goto Cleanup;
    }

    if (FAILED(pdbm->CheckSrcWritable(this, ID_DBIND_DEFAULT)))
    {
        hr = S_FALSE;
    }
#endif // ndef NO_DATABINDING

Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+-------------------------------------------------------------------------
//
//  Method:     CObjectElement::OnControlChanged, COleSite
//
//  Synopsis:   Give Site (or its derived class) a chance to act on a
//              control's OnChanged notification,  and cancel any forwarding
//              which might normally take place through our XObject.
//
//  Arguments:  dispid of property who's value has changed
//
//  Returns:    HRESULT.  Any non-zero HRESULT, including S_FALSE, will
//              cancel OnChanged forwarding.
//
//              We don't have code here to restore the dispid back to
//              the bound value, if the bound source isn't writable.
//              Probably should have a DeferedRestoreData.
//
//--------------------------------------------------------------------------

HRESULT
CObjectElement::OnControlChanged(DISPID dispid)
{
    HRESULT             hr          = S_OK;
    DBMEMBERS           *pdbm;
    CLASSINFO           *pci;
    CDoc *              pDoc = Doc();
    CDataMemberMgr *    pdmm = GetDataMemberManager();

    // handle changes in readystate
    Verify(!super::OnControlChanged(dispid));

    if (_state < OS_LOADED)
    {
        // (alexz) (anandra)
        // this is done specifically for Marquee control of IE 3.0,
        // which has DISPID_ScrollStyleX == DISPID_VALUE == 0 (which is a bug).
        // When loading from param bag, it fires OnPropertyChange (DISPID_ScrollStyleX),
        // which leads our code here as we think that was an OnValuePropertyChange; then it
        // causes save, which crashes that control because it's code happened to be
        // not robust for the case when somebody operates with it's properties while it is in
        // process of loading.
        goto Cleanup;
    }

#ifndef NO_DATABINDING
    // if the databinding interface changed, let the provider know
    if (pdmm)
    {
        if (dispid == pdmm->GetDatabindingDispid() || dispid == DISPID_UNKNOWN)
        {
            IGNORE_HR(pdmm->ChangeDataBindingInterface(NULL, TRUE));
        }
    }

    pdbm = GetDBMembers();
    if (!pdbm)
    {
        goto Cleanup;
    }

    if (this != pDoc->_pElemCurrent)
    {
        int           cParamBindings = _aryParamBinding.Size();
        PARAMBINDING *pParamBinding  = &_aryParamBinding[cParamBindings];

        while (pParamBinding--, cParamBindings--)
        {
            if ((dispid == DISPID_UNKNOWN || pParamBinding->_dispidGet == dispid)
                && pdbm->CompareWithSrc(this, cParamBindings + (ID_DBIND_DEFAULT+1)) )
            {
                // note two adjustments here
                //  ID_DBIND_DEFAULT+1 adjust array offset to binding id.
                //  -ID_DBIND_ALL adjusts binding id to required DWORD value
                //      (see DeferSaveData for details)
                GWPostMethodCall(this,
                                 ONCALL_METHOD(CObjectElement, DeferredSaveData, deferredsavedata),
                                 (DWORD_PTR) cParamBindings + (ID_DBIND_DEFAULT+1) - ID_DBIND_ALL,
                                 FALSE, "CObjectElement::DeferredSaveData");
            }
        }
    }

    // we only have to consider ClassInfo information if we have a binding
    //  on the tag itself
    if (!pdbm->FBoundID(this, ID_DBIND_DEFAULT))
    {
        goto Cleanup;
    }

    // Now that we're sure we need it, get the ClassInfo
    pci = GetClassInfo();

    if (dispid != DISPID_UNKNOWN && dispid != pci->dispIDBind)
    {
        goto Cleanup;
    }

    // for current control, we only transfer value now if IMMEDIATEBIND.
    if (this == pDoc->_pElemCurrent && !pci->FImmediateBind())
    {
        goto Cleanup;
    }


    // fetch that value
    if (!pdbm->CompareWithSrc(this, ID_DBIND_DEFAULT))
    {
        goto Cleanup;
    }

    // See DeferredSaveData for explanation of  "- ID_DBIND_ALL"
    GWPostMethodCall(this,
                     ONCALL_METHOD(CObjectElement, DeferredSaveData, deferredsavedata),
                     (DWORD_PTR) (ID_DBIND_DEFAULT - ID_DBIND_ALL), FALSE, "CObjectElement::DeferredSaveData");

#endif // ndef NO_DATABINDING
Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+------------------------------------------------------------------------
//
//  Member:     OnFailToCreate
//
//  Synopsis:   Called when an OBJECT fails to instantiate correctly
//
//-------------------------------------------------------------------------

HRESULT
CObjectElement::OnFailToCreate()
{
    super::OnFailToCreate();

    if ( !IsEditable(/*fCheckContainerOnly*/FALSE) && !Doc()->IsShut() )
    {
        //
        // fire the onerror event to see if anyone wants to handle this case for us.
        // unless we get back FALSE, do the default processing which is to 
        // replace element with the altHTML.  
        //

        BOOL fRet = Fire_onerror();
        if (fRet)
        {
            TCHAR * pchAltHtml = (LPTSTR)GetAAaltHtml();
            if (pchAltHtml)
            {
                IGNORE_HR(Inject(
                        CElement::Outside, TRUE, pchAltHtml, _tcslen(pchAltHtml)));
            }
        }
    }

    return S_OK;
}


//+------------------------------------------------------------------------
//
//  Member:     GetSumbitInfo
//
//  Synopsis:   Retrieve info for form sumbission and give it to the
//              CPostData.
//
//-------------------------------------------------------------------------

HRESULT
CObjectElement::GetSubmitInfo(CPostData *pSubmitData)
{
    HRESULT            hr = S_FALSE;
    const CCharFormat *pCF;
    CVariant           vt;
    LPCTSTR            lpstrName;


    // Make sure we've actually got a control.
    if(!_pDisp)
        goto Cleanup;

    // If it doesn't have a name, then it doesn't go in the string!
    lpstrName = GetAAname();
    if(!lpstrName)
        goto Cleanup;

    // Get the CharFormat for the LCID.
    pCF = GetFirstBranch()->GetCharFormat();
    if(!pCF)
        goto Cleanup;

    // Finally, get the default value.
    hr = THR(GetDispProp(_pDisp, DISPID_VALUE, pCF->_lcid, &vt));
    if(hr)
        goto Cleanup;

    hr = THR(vt.CoerceVariantArg(VT_BSTR));
    if(hr)
        goto Cleanup;

    hr = THR(pSubmitData->AppendNameValuePair(lpstrName, V_BSTR(&vt), GetMarkup()));

Cleanup:
    // If we got any kind of error, return S_FALSE
    // so that we're just skipped in the submit info.
    if(hr)
    {
        hr = S_FALSE;
    }
    RRETURN1(hr, S_FALSE);
}

STDMETHODIMP
CObjectElement::get_readyState(VARIANT *pVarResult)
{
    HRESULT     hr;

    if (!pVarResult)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    hr = get_readyState(&V_I4(pVarResult));
    if (!hr)
        V_VT(pVarResult) = VT_I4;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

STDMETHODIMP
CObjectElement::get_readyState(long *pReadyState)
{
    HRESULT     hr = S_OK;

    if (!pReadyState)
    {
        hr = E_POINTER;
        goto Cleanup;
    }

    *pReadyState = _lReadyState;

Cleanup:
    RRETURN(SetErrorInfo(hr));
}

STDMETHODIMP CObjectElement::put_classid(BSTR v)
{
    HRESULT hr = CTL_E_SETNOTSUPPORTEDATRUNTIME;
    CVoid *pSubObj;
    if (_pUnkCtrl || GetAAclassid() || GetAAcodeType() || GetAAtype())
        goto Cleanup;

    RECALC_PUT_HELPER(s_propdescCObjectElementclassid.b.dispid)
    pSubObj = CVOID_CAST(GetAttrArray());
    hr = THR(s_propdescCObjectElementclassid.b.SetStringProperty(v, this, pSubObj));
    if (hr)
        goto Cleanup;

    hr = THR(CreateObject());

Cleanup:
    return SetErrorInfo(hr);
}

STDMETHODIMP CObjectElement::get_classid(BSTR *p)
{
    RECALC_GET_HELPER(s_propdescCObjectElementclassid.b.dispid)
    CVoid *pSubObj = CVOID_CAST(GetAttrArray());
    return SetErrorInfo(s_propdescCObjectElementclassid.b.GetStringProperty(p, this, pSubObj));
}

STDMETHODIMP CObjectElement::put_codeType(BSTR v)
{
    HRESULT hr = CTL_E_SETNOTSUPPORTEDATRUNTIME;
    CVoid *pSubObj;
    if (_pUnkCtrl || GetAAcodeType() || GetAAclassid() || GetAAtype())
        goto Cleanup;

    RECALC_PUT_HELPER(s_propdescCObjectElementcodeType.b.dispid)
    pSubObj = CVOID_CAST(GetAttrArray());
    hr = THR(s_propdescCObjectElementcodeType.b.SetStringProperty(v, this, pSubObj));
    if (hr)
        goto Cleanup;

    hr = THR(CreateObject());

Cleanup:
    return SetErrorInfo(hr);
}

STDMETHODIMP CObjectElement::get_codeType(BSTR *p)
{
    RECALC_GET_HELPER(s_propdescCObjectElementcodeType.b.dispid)
    CVoid *pSubObj = CVOID_CAST(GetAttrArray());
    return SetErrorInfo(s_propdescCObjectElementcodeType.b.GetStringProperty(p, this, pSubObj));
}

STDMETHODIMP CObjectElement::put_type(BSTR v)
{
    HRESULT hr = CTL_E_SETNOTSUPPORTEDATRUNTIME;
    CVoid *pSubObj;
    if (_pUnkCtrl || GetAAtype() || GetAAclassid() || GetAAcodeType())
        goto Cleanup;

    RECALC_PUT_HELPER(s_propdescCObjectElementtype.b.dispid)
    pSubObj = CVOID_CAST(GetAttrArray());
    hr = THR(s_propdescCObjectElementtype.b.SetStringProperty(v, this, pSubObj));
    if (hr)
        goto Cleanup;

    hr = THR(CreateObject());

Cleanup:
    return SetErrorInfo(hr);
}

STDMETHODIMP CObjectElement::get_type(BSTR *p)
{
    RECALC_GET_HELPER(s_propdescCObjectElementtype.b.dispid)
    CVoid *pSubObj = CVOID_CAST(GetAttrArray());
    return SetErrorInfo(s_propdescCObjectElementtype.b.GetStringProperty(p, this, pSubObj));
}

STDMETHODIMP CParamElement::get_name(BSTR *p)
{
    CVoid *pSubObj = CVOID_CAST(GetAttrArray());
    return SetErrorInfo(s_propdescCParamElementname.b.GetStringProperty(p, this, pSubObj));
}

STDMETHODIMP CParamElement::put_name(BSTR v)
{
    HRESULT hr = S_OK;
    CVoid *pSubObj = CVOID_CAST(GetAttrArray());

    if (_pelObjParent && _pelObjParent->_pParamBag)
    {
        if (v && *v)
        {
            LPCTSTR pchName;
            PROPNAMEVALUE *pprop = _pelObjParent->_pParamBag->Find(v);
            if (pprop)
                goto Cleanup;

            // Didn't find name, so change it in propbag too
            pchName = GetAAname();
            Assert(pchName && *pchName);
            pprop = _pelObjParent->_pParamBag->Find((LPTSTR)pchName);
            Assert(pprop);
            hr = THR(pprop->_cstrName.Set(v));
            if (hr)
                goto Cleanup;
        }
        else
            goto Cleanup;
    }

    hr = THR(s_propdescCParamElementname.b.SetStringProperty(v, this, pSubObj));
    if (hr)
        goto Cleanup;

Cleanup:
    return SetErrorInfo(hr);
}

STDMETHODIMP CParamElement::get_value(BSTR *p)
{
    CVoid *pSubObj = CVOID_CAST(GetAttrArray());
    return SetErrorInfo(s_propdescCParamElementvalue.b.GetStringProperty(p, this, pSubObj));
}

STDMETHODIMP CParamElement::put_value(BSTR v)
{
    HRESULT hr;
    CVoid *pSubObj = CVOID_CAST(GetAttrArray());
    
    if (_pelObjParent && _pelObjParent->_pParamBag)
    {
        VARIANT Var;
        if (v && *v)
        {
            V_VT(&Var) = VT_BSTR;
            V_BSTR(&Var) = v;
        }

        LPCTSTR pchName = GetAAname();
        Assert(pchName && *pchName);
        PROPNAMEVALUE *pprop = _pelObjParent->_pParamBag->Find((LPTSTR)pchName);
        Assert(pprop);
        VariantClear(&pprop->_varValue);
        hr = THR(VariantCopy(&pprop->_varValue, &Var));

        if (hr)
            goto Cleanup;
    }

    hr = THR(s_propdescCParamElementvalue.b.SetStringProperty(v, this, pSubObj));
    if (hr)
        goto Cleanup;

Cleanup:
    return SetErrorInfo(hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\ole\clstab.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       clstab.cxx
//
//  Contents:   Class table for CDoc.
//
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_CLSTAB_HXX_
#define X_CLSTAB_HXX_
#include "clstab.hxx"
#endif

#ifndef X_TYPENAV_HXX_
#define X_TYPENAV_HXX_
#include <typenav.hxx>
#endif

#ifndef X_OBJEXT_H_
#define X_OBJEXT_H_
#include <objext.h>
#endif

MtDefine(CClassTable, CDoc, "CClassTable")
MtDefine(CClassTable_aryci_pv, CClassTable, "CClassTable::_aryci::_pv")

EXTERN_C const CLSID CLSID_IE4ShellFolderIcon = { 0xE5DF9D10, 0x3B52, 0x11D1, 0x83, 0xE8, 0x00, 0xA0, 0xC9, 0x0D, 0xC8, 0x49 };
EXTERN_C const CLSID CLSID_IE4ShellPieChart =   { 0x1D2B4F40, 0x1F10, 0x11D1, 0x9E, 0x88, 0x00, 0xC0, 0x4F, 0xDC, 0xAB, 0x92 };
EXTERN_C const CLSID CLSID_AppletOCX =          { 0x08B0e5c0, 0x4FCB, 0x11CF, 0xAA, 0xA5, 0x00, 0x40, 0x1C, 0x60, 0x85, 0x01 };
#if DBG == 1
EXTERN_C const CLSID CLSID_WebBrowser;
         const CLSID CLSID_IISForm =            { 0x812AE312, 0x8B8E, 0x11CF, 0x93, 0xC8, 0x00, 0xAA, 0x00, 0xC0, 0x8F, 0xDF };
         const CLSID CLSID_Forms3Optionbutton = { 0x8BD21D50, 0xEC42, 0x11CE, 0x9E, 0x0D, 0x00, 0xAA, 0x00, 0x60, 0x02, 0xF3 };
         const CLSID CLSID_Acrobat =            { 0xCA8A9780, 0x280D, 0x11CF, 0xA2, 0x4D, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00 };
         const CLSID CLSID_SurroundVideo =      { 0x928626A3, 0x6B98, 0x11CF, 0x90, 0xB4, 0x00, 0xAA, 0x00, 0xA4, 0x01, 0x1F };
         const CLSID CLSID_MSInvestor =         { 0xD2F97240, 0xC9F4, 0x11CF, 0xBF, 0xC4, 0x00, 0xA0, 0xC9, 0x0C, 0x2B, 0xDB };
         const CLSID CLSID_PowerPointAnimator = { 0xEFBD14F0, 0x6BFB, 0x11CF, 0x91, 0x77, 0x00, 0x80, 0x5F, 0x88, 0x13, 0xFF };
         const CLSID CLSID_MSInvestorNews =     { 0x025B1052, 0xCB0B, 0x11CF, 0xA0, 0x71, 0x00, 0xA0, 0xC9, 0xA0, 0x6E, 0x05 };
         const CLSID CLSID_MSTreeView =         { 0xB9D029D3, 0xCDE3, 0x11CF, 0x85, 0x5E, 0x00, 0xA0, 0xC9, 0x08, 0xFA, 0xF9 };
         const CLSID CLSID_ActiveMovie =        { 0x05589fa1, 0xc356, 0x11ce, 0xbf, 0x01, 0x00, 0xaa, 0x00, 0x55, 0x59, 0x5a };
         const CLSID CLSID_MediaPlayer =        { 0x22D6F312, 0xB0F6, 0x11D0, 0x94, 0xAB, 0x00, 0x80, 0xC7, 0x4C, 0x7E, 0x95 };
         const CLSID CLSID_MCSITree =           { 0xB3F8F451, 0x788A, 0x11D0, 0x89, 0xD9, 0x00, 0xA0, 0xC9, 0x0C, 0x9B, 0x67 };
         const CLSID CLSID_IEMenu =             { 0x7823A620, 0x9DD9, 0x11CF, 0xA6, 0x62, 0x00, 0xaa, 0x00, 0xC0, 0x66, 0xD2 };
         const CLSID CLSID_CitrixWinframe =     { 0x238f6f83, 0xb8b4, 0x11cf, 0x87, 0x71, 0x00, 0xa0, 0x24, 0x54, 0x1e, 0xe3 };
         const CLSID CLSID_VivoViewer =         { 0x02466323, 0x75ed, 0x11cf, 0xa2, 0x67, 0x00, 0x20, 0xaf, 0x25, 0x46, 0xea };
         const CLSID CLSID_SheridanCommand =    { 0xAAD093B2, 0xF9CA, 0x11CF, 0x9C, 0x85, 0x00, 0x00, 0xC0, 0x93, 0x00, 0xC4 };
         const CLSID CLSID_VActive =            { 0x5A20858B, 0x000D, 0x11D0, 0x8C, 0x01, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00 };
         const CLSID CLSID_SaxCanvas =          { 0x1DF67C43, 0xAEAA, 0x11CF, 0xBA, 0x92, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00 };
         const CLSID CLSID_GregConsDieRoll =    { 0x46646B43, 0xEA16, 0x11CF, 0x87, 0x0C, 0x00, 0x20, 0x18, 0x01, 0xDD, 0xD6 };
         const CLSID CLSID_NCompassBillboard =  { 0x6059B947, 0xEC52, 0x11CF, 0xB5, 0x09, 0x00, 0xA0, 0x24, 0x48, 0x8F, 0x73 };
         const CLSID CLSID_NCompassLightboard = { 0xB2F87B84, 0x26A6, 0x11D0, 0xB5, 0x0A, 0x00, 0xA0, 0x24, 0x48, 0x8F, 0x73 };
         const CLSID CLSID_ProtoviewTreeView =  { 0xB283E214, 0x2CB3, 0x11D0, 0xAD, 0xA6, 0x00, 0x40, 0x05, 0x20, 0x79, 0x9C };
         const CLSID CLSID_ActiveEarthTime =    { 0x9590092D, 0x8811, 0x11CF, 0x80, 0x75, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00 };
         const CLSID CLSID_LeadControl =        { 0x00080000, 0xB1BA, 0x11CE, 0xAB, 0xC6, 0xF5, 0xB2, 0xE7, 0x9D, 0x9E, 0x3F };
         const CLSID CLSID_TextX =              { 0x5B84FC03, 0xE639, 0x11CF, 0xB8, 0xA0, 0x00, 0xA0, 0x24, 0x18, 0x6B, 0xF1 };
         const CLSID CLSID_Plugin =             { 0x06DD38D3, 0xD187, 0x11CF, 0xA8, 0x0D, 0x00, 0xC0, 0x4F, 0xD7, 0x4A, 0xD8 };
         const CLSID CLSID_GreetingsUpload =    { 0x03405265, 0xb4e2, 0x11d0, 0x8a, 0x77, 0x00, 0xaa, 0x00, 0xa4, 0xfb, 0xc5 };
         const CLSID CLSID_GreetingsDownload =  { 0x03405269, 0xb4e2, 0x11d0, 0x8a, 0x77, 0x00, 0xaa, 0x00, 0xa4, 0xfb, 0xc5 };
         const CLSID CLSID_COMCTLTree =         { 0x0713E8A2, 0x850A, 0x101B, 0xAF, 0xC0, 0x42, 0x10, 0x10, 0x2A, 0x8D, 0xA7 };
         const CLSID CLSID_COMCTLProg =         { 0x0713E8D2, 0x850A, 0x101B, 0xAF, 0xC0, 0x42, 0x10, 0x10, 0x2A, 0x8D, 0xA7 };
         const CLSID CLSID_COMCTLImageList =    { 0x58DA8D8F, 0x9D6A, 0x101B, 0xAF, 0xC0, 0x42, 0x10, 0x10, 0x2A, 0x8D, 0xA7 };
         const CLSID CLSID_COMCTLListview =     { 0x58DA8D8A, 0x9D6A, 0x101B, 0xAF, 0xC0, 0x42, 0x10, 0x10, 0x2A, 0x8D, 0xA7 };
         const CLSID CLSID_COMCTLSbar =         { 0x6B7E638F, 0x850A, 0x101B, 0xAF, 0xC0, 0x42, 0x10, 0x10, 0x2A, 0x8D, 0xA7 };
         const CLSID CLSID_MCSIMenu =           { 0x275E2FE0, 0x7486, 0x11D0, 0x89, 0xD6, 0x00, 0xA0, 0xC9, 0x0C, 0x9B, 0x67 };
         const CLSID CLSID_MSNVer =             { 0xA123D693, 0x256A, 0x11d0, 0x9D, 0xFE, 0x00, 0xC0, 0x4F, 0xD7, 0xBF, 0x41 };
         const CLSID CLSID_RichTextCtrl =       { 0x3B7C8860, 0xD78F, 0x101B, 0xB9, 0xB5, 0x04, 0x02, 0x1C, 0x00, 0x94, 0x02 };
         const CLSID CLSID_IETimer =            { 0x59CCB4A0, 0x727D, 0x11CF, 0xAC, 0x36, 0x00, 0xAA, 0x00, 0xA4, 0x7D, 0xD2 };
         const CLSID CLSID_SubScr =             { 0x78A9B22E, 0xE0F4, 0x11D0, 0xB5, 0xDA, 0x00, 0xC0, 0xF0, 0x0A, 0xD7, 0xF8 };
EXTERN_C const CLSID CLSID_Scriptlet;  //AE24FDAE-03C6-11D1-8B76-0080C744F389
         const CLSID CLSID_OldXsl =             { 0x2BD0D2F2, 0x52EC, 0x11D1, 0x8C, 0x69, 0x0E, 0x16, 0xBC, 0x00, 0x00, 0x00 };
         const CLSID CLSID_MMC =                { 0xD306C3B7, 0x2AD5, 0x11D1, 0x9E, 0x9A, 0x00, 0x80, 0x5F, 0x20, 0x00, 0x05 };
         const CLSID CLSID_RealAudio =          { 0xCFCDAA03, 0x8BE4, 0x11CF, 0xB8, 0x4B, 0x00, 0x20, 0xAF, 0xBB, 0xCC, 0xFA };
         const CLSID CLSID_WebCalc =            { 0x0002E510, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46 };
         const CLSID CLSID_AnswerList =         { 0x8F2C1D40, 0xC3CD, 0x11D1, 0xA0, 0x8F, 0x00, 0x60, 0x97, 0xBD, 0x99, 0x70 };
         const CLSID CLSID_PreLoader =          { 0x16E349E0, 0x702C, 0x11CF, 0xA3, 0xA0, 0x00, 0xA0, 0xC9, 0x03, 0x49, 0x20 };
         const CLSID CLSID_EyeDog =             { 0x06A7EC63, 0x4E21, 0x11D0, 0xA1, 0x12, 0x00, 0xA0, 0xC9, 0x05, 0x43, 0xAA };
         const CLSID CLSID_ImgAdmin =           { 0x009541A0, 0x3B81, 0x101C, 0x92, 0xF3, 0x04, 0x02, 0x24, 0x00, 0x9C, 0x02 };
         const CLSID CLSID_ImgThumb =           { 0xE1A6B8A0, 0x3603, 0x101C, 0xAC, 0x6E, 0x04, 0x02, 0x24, 0x00, 0x9C, 0x02 };
         const CLSID CLSID_HHOpen =             { 0x130D7743, 0x5F5A, 0x11D1, 0xB6, 0x76, 0x00, 0xA0, 0xC9, 0x69, 0x72, 0x33 };
         const CLSID CLSID_RegWiz =             { 0x50E5E3D1, 0xC07E, 0x11D0, 0xB9, 0xFD, 0x00, 0xA0, 0x24, 0x9F, 0x6B, 0x00 };
         const CLSID CLSID_SetupCtl =           { 0xF72A7B0E, 0x0DD8, 0x11D1, 0xBD, 0x6E, 0x00, 0xAA, 0x00, 0xB9, 0x2A, 0xF1 };
         const CLSID CLSID_ImgEdit =            { 0x6D940280, 0x9F11, 0x11CE, 0x83, 0xFD, 0x02, 0x60, 0x8C, 0x3E, 0xC0, 0x8A };
         const CLSID CLSID_ImgEdit2 =           { 0x6D940285, 0x9F11, 0x11CE, 0x83, 0xFD, 0x02, 0x60, 0x8C, 0x3E, 0xC0, 0x8A };
         const CLSID CLSID_ImgScan =            { 0x84926CA0, 0x2941, 0x101C, 0x81, 0x6F, 0x0E, 0x60, 0x13, 0x11, 0x4B, 0x7F };
         const CLSID CLSID_IELabel =            { 0x99B42120, 0x6EC7, 0x11CF, 0xA6, 0xC7, 0x00, 0xAA, 0x00, 0xA4, 0x7D, 0xD2 };
         const CLSID CLSID_HomePubRender =      { 0x96B9602E, 0xBD20, 0x11D2, 0xAC, 0x89, 0x00, 0xC0, 0x4F, 0x79, 0x89, 0xD6 };
         const CLSID CLSID_MGIPhotoSuiteBtn =   { 0x4FA211A0, 0xFD53, 0x11D2, 0xAC, 0xB6, 0x00, 0x80, 0xC8, 0x77, 0xD9, 0xB9 };
         const CLSID CLSID_MGIPhotoSuiteSlider ={ 0x105C7D20, 0xFE19, 0x11D2, 0xAC, 0xB6, 0x00, 0x80, 0xC8, 0x77, 0xD9, 0xB9 };
         const CLSID CLSID_MGIPrintShopSlider  ={ 0x7B9379D2, 0xE1E4, 0x11D0, 0x84, 0x44, 0x00, 0x40, 0x1C, 0x60, 0x75, 0xAA };
         const CLSID CLSID_RunLocExe =          { 0x73822330, 0xB759, 0x11D0, 0x9E, 0x3D, 0x00, 0xA0, 0xC9, 0x11, 0xC8, 0x19 };
         const CLSID CLSID_Launchit2 =          { 0xB75FEF72, 0x0C54, 0x11D2, 0xB1, 0x4E, 0x00, 0xC0, 0x4F, 0xB9, 0x35, 0x8B };
         const GUID CLSID_MS_MSHTA =            {0x3050f4d8, 0x98b5, 0x11cf, {0xbb, 0x82, 0x00, 0xaa, 0x00, 0xbd, 0xce, 0x0b}};
         const CLSID CLSID_ShavlikSec =         { 0x913C89C0, 0x492C, 0x11D4, 0x91, 0x1A, 0x00, 0x90, 0x27, 0x37, 0x06, 0x74 };		 

    //
    // This table exists to double check the table in the registry.
    // It is incredibly easy for a typo to corrupt the copy of this table
    // that is stored in f3\rsrc\selfreg.inx and gets propagated to the registry.
    //
struct CompatibilityTableElementAssert
{
    const CLSID *pclsid;
    DWORD        dwCompatFlags;
    DWORD        dwMiscStatusFlags;
} s_aCompatibility[] = 
{
    // 
    // W A R N I N G - Review this list on a regular basis.
    //                 We might find that some of these controls
    //                 fix their problems.
    //
    // **  I M P O R T A N T  **
    //
    // To add to this compatibility table do the following steps:
    //
    // 1. Create a new COMPAT_* flag in clstab.hxx if needed.
    // 2. Implement the COMPAT_* flag check and associated special behavior in
    //    olesite.cxx or whereever.
    // 3. Add the clsid of the particular ActiveX control to the declarations
    //    above if not already there.
    // 4. Add a new entry to the table below for that clsid if not already there.
    //    ** VERY IMPORTANT:  Keep the table sorted in ascending clsid order.
    //    ** EVEN MORE IMPORTANT: Keeping the table sorted is no longer necessary.
    // 5. Add a corresponding clsid string and table entry to the [CompatTable.Reg]
    //    section of msthml\src\f3\rsrc\selfreg.inx.
    // 6. Increment the szOurVersion version number declaration below.
    // 7. Increment the "Version" reg entry value in the [CompatTable.Reg] section
    //    of selfreg.inx.
    //    ** if you fail to do this, your additions will not be installed
    //       into the registry, since ShouldWeRegisterCompatibilityTable()
    //       will think the table is unchanged.
    // 8. Build and do mshtmpad /local to put the new entry in the registry on your
    //    machine.
    // 9. When you check in warn everyone that they must do mshtmpad /local or they
    //    will get asserts.
    //

    { &CLSID_VivoViewer, COMPAT_SEND_SHOW, 0}, 
    { &CLSID_MSInvestorNews, COMPAT_NO_UIACTIVATE | COMPAT_NO_QUICKACTIVATE, 0 },
    { &CLSID_ActiveMovie, COMPAT_INPLACEACTIVATEEVENWHENINVISIBLE, 0 },
    { &CLSID_Plugin,    COMPAT_ALWAYS_INPLACEACTIVATE, 0 },
    { &CLSID_AppletOCX, COMPAT_INPLACEACTIVATEEVENWHENINVISIBLE, 0 },
    { &CLSID_SaxCanvas, COMPAT_ALWAYS_INPLACEACTIVATE | COMPAT_PROGSINK_UNTIL_ACTIVATED, 0 },
    { &CLSID_MediaPlayer, COMPAT_INPLACEACTIVATEEVENWHENINVISIBLE | COMPAT_NEEDSZEROBASEDDRAWRECT, 0 },
    { &CLSID_CitrixWinframe, COMPAT_USE_PROPBAG_AND_STREAM, 0 },
    { &CLSID_GregConsDieRoll, COMPAT_ALWAYS_INPLACEACTIVATE | COMPAT_DISABLEWINDOWLESS, 0 },
    { &CLSID_VActive, COMPAT_SEND_SHOW, 0 },
    { &CLSID_IEMenu, COMPAT_ALWAYS_INPLACEACTIVATE, 0 },
    { &CLSID_WebBrowser, COMPAT_AGGREGATE | COMPAT_ALWAYS_INPLACEACTIVATE, 0 },
    { &CLSID_Forms3Optionbutton, COMPAT_AGGREGATE, 0 },
    { &CLSID_SurroundVideo, COMPAT_NO_SETEXTENT, 0 },
    { &CLSID_MSTreeView, COMPAT_ALWAYS_INPLACEACTIVATE },
    { &CLSID_Acrobat, COMPAT_SEND_SHOW | COMPAT_PRINTPLUGINSITE, 0 },
    { &CLSID_MSInvestor, COMPAT_SEND_HIDE, 0 },
    { &CLSID_PowerPointAnimator, COMPAT_NO_SETEXTENT | COMPAT_NO_BINDF_OFFLINEOPERATION, 
        OLEMISC_INSIDEOUT | OLEMISC_ACTIVATEWHENVISIBLE },
    { &CLSID_SheridanCommand, COMPAT_DISABLEWINDOWLESS },
    { &CLSID_MCSITree, COMPAT_ALWAYS_INPLACEACTIVATE | COMPAT_PROGSINK_UNTIL_ACTIVATED, 0 },
    { &CLSID_NCompassBillboard,   COMPAT_SETWINDOWRGN, 0 },
    { &CLSID_NCompassLightboard,  COMPAT_SETWINDOWRGN, 0 },
    { &CLSID_ProtoviewTreeView,   COMPAT_SETWINDOWRGN, 0 },
    { &CLSID_ActiveEarthTime,     COMPAT_SETWINDOWRGN, 0 },
    { &CLSID_LeadControl,         COMPAT_SETWINDOWRGN, 0 },
    { &CLSID_TextX, COMPAT_DISABLEWINDOWLESS, 0 },
    { &CLSID_IISForm, COMPAT_NO_OBJECTSAFETY, 0 },
    { &CLSID_GreetingsUpload, COMPAT_ALWAYS_INPLACEACTIVATE, 0 },
    { &CLSID_GreetingsDownload, COMPAT_ALWAYS_INPLACEACTIVATE, 0 },
    { &CLSID_COMCTLTree, COMPAT_ALWAYS_INPLACEACTIVATE | COMPAT_PROGSINK_UNTIL_ACTIVATED, 0 },
    { &CLSID_COMCTLProg, COMPAT_ALWAYS_INPLACEACTIVATE | COMPAT_PROGSINK_UNTIL_ACTIVATED, 0 },
    { &CLSID_COMCTLImageList, COMPAT_ALWAYS_INPLACEACTIVATE | COMPAT_PROGSINK_UNTIL_ACTIVATED, 0 },
    { &CLSID_COMCTLListview, COMPAT_ALWAYS_INPLACEACTIVATE | COMPAT_PROGSINK_UNTIL_ACTIVATED, 0 },
    { &CLSID_COMCTLSbar, COMPAT_ALWAYS_INPLACEACTIVATE | COMPAT_PROGSINK_UNTIL_ACTIVATED, 0 },
    { &CLSID_MCSIMenu, COMPAT_ALWAYS_INPLACEACTIVATE, 0 },
    { &CLSID_MSNVer, COMPAT_ALWAYS_INPLACEACTIVATE, 0 },
    { &CLSID_RichTextCtrl, COMPAT_EVIL_DONT_LOAD, 0 },
    { &CLSID_IETimer, COMPAT_ALWAYS_INPLACEACTIVATE, 0 },
    { &CLSID_SubScr, COMPAT_EVIL_DONT_LOAD, 0 },
    { &CLSID_Scriptlet, COMPAT_ALWAYS_INPLACEACTIVATE, 0 },
    { &CLSID_OldXsl, COMPAT_EVIL_DONT_LOAD, 0 },
    { &CLSID_MMC, COMPAT_EVIL_DONT_LOAD, 0 },
    { &CLSID_RealAudio, COMPAT_INPLACEACTIVATEEVENWHENINVISIBLE, 0 },
    { &CLSID_WebCalc, COMPAT_ALWAYSDEFERSETWINDOWRGN, 0},
    { &CLSID_AnswerList, COMPAT_INPLACEACTIVATESYNCHRONOUSLY, 0 },
    { &CLSID_PreLoader, COMPAT_EVIL_DONT_LOAD, 0 },

    // Hack for IE5 #68793. These controls, used in IE4 shell webview, mess up tabbing once
    // they get focus. Make them unfocussable. The controls will be fixed in NT5 and given
    // new clsids.
    { &CLSID_IE4ShellFolderIcon, COMPAT_NEVERFOCUSSABLE, 0 },
    { &CLSID_IE4ShellPieChart, COMPAT_NEVERFOCUSSABLE, 0 },
    // End hack

    { &CLSID_EyeDog, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_ImgAdmin, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_ImgThumb, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_HHOpen, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_RegWiz, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_SetupCtl, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_ImgEdit, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_ImgEdit2, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_ImgScan, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_IELabel, COMPAT_ALWAYSDEFERSETWINDOWRGN, 0},
    { &CLSID_HomePubRender, COMPAT_NEEDSZEROBASEDDRAWRECT, 0},
    { &CLSID_MGIPhotoSuiteBtn, COMPAT_HWNDPRIVATE, 0},
    { &CLSID_MGIPhotoSuiteSlider, COMPAT_HWNDPRIVATE, 0},
    { &CLSID_MGIPrintShopSlider, COMPAT_HWNDPRIVATE, 0},
    { &CLSID_RunLocExe, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_Launchit2, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_MS_MSHTA, COMPAT_EVIL_DONT_LOAD, 0},
    { &CLSID_ShavlikSec, COMPAT_EVIL_DONT_LOAD, 0},

};
#endif

//
// This needs to stay in sync with the Version value in selfreg.inx!
// Note: this version number is also used for urlcomp.cxx
//

extern const TCHAR szOurVersion[];
const TCHAR szOurVersion[] = _T("5.17");

/*
Format of the registry entries
ROOT_LOCATION 
 =HKEY_LOCAL_MACHINE\Software\Microsoft\Internet Explorer\ActiveX Compatibility

That root location key will have one value, "Version" = REG_SZ "5.00". 
This gives the version number of the compatability table. Initially the version 
numberwill be "0.0" allowing increments during development. At RTM it will be "5.00".

Under that will be keys with CLSID names with the same format as HKCR\CLSID.
Each of those CLSID subkeys may have two values.  Either or both values may be absent.
  {SOME-CLSID-VALUE-0000001}\ value name "Compatibility Flags" REG_DWORD 12345
  {SOME-CLSID-VALUE-0000001}\ value name "MiscStatus Flags"    REG_DWORD 12345

The Compat Flags value holds the COMPAT_* type flags.
The OleMiscFlags value holds our OLEMISC_* flags but uses a different name & structure
than in HKCR\CLSID. In that location they have MiscStatus\<version number>.
We don't track the version number of the control we instantiate, so we have
no <version number> subkey.

Self Registration
The compat table will be stored in f3\rsrc\selfreg.inx and written during normal
DLLInstall() operation.  It will be written
if the ROOT_LOCATION key does notexist or if the mshtml.dll 
compatibility table version number is > than thatin the registry. 
Such "reluctant" writing of the compatibility table will
allow users or others to add, modify, or delete entries in the compatibility
table and those changes will not be overwritten easily.
If mshtml.dll is writing the compatibility table to the registry due to a
compat table version number increase it will add entries but not remove
entries that may have been put there by someone else.
*/

static TCHAR szTableRootKey[] = 
   _T("Software\\Microsoft\\Internet Explorer\\ActiveX Compatibility");

static TCHAR szCompatFlags[] =      _T("Compatibility Flags");
static TCHAR szMiscStatusFlags[] =  _T("MiscStatus Flags");

CLASSINFO g_ciNull;

//+---------------------------------------------------------------------------
//
//  Function:   ShouldWeRegisterCompatibilityTable
//
//  Synopsis:   Determine whether would should write our compatibility table,
//              as recorded in selfreg.inx, to the registry.
//  
//              We do if the table is not in the registry at all, or if
//              our version of the table is more recent than that in the
//              registry.
//
//  Returns:    TRUE - yes, write the table please.
//
//----------------------------------------------------------------------------

BOOL 
ShouldWeRegisterCompatibilityTable()
{
    BOOL fOurRet = TRUE;
    LONG lRet;
    HKEY hkeyRoot = NULL;
    DWORD dwSize, dwType;
    TCHAR szVersion[10];

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTableRootKey, 0, KEY_READ, &hkeyRoot);
    if( lRet != ERROR_SUCCESS )
        return( TRUE );

    dwSize = sizeof( szVersion );
    lRet = RegQueryValueEx( hkeyRoot, _T("Version"), NULL, &dwType, 
      (LPBYTE)szVersion, &dwSize );
    if( lRet == ERROR_SUCCESS )
        fOurRet = (_tcscmp( szVersion, szOurVersion ) < 0);

    RegCloseKey( hkeyRoot );

    return( fOurRet );
}

#if DBG == 1
//+---------------------------------------------------------------------------
//
//  Function:   AssertCompatibilityTable
//
//  Synopsis:   Reads the compatibility table from the registry.
//              Confirms that it is identical to our internal compatibility
//              table.
//
//----------------------------------------------------------------------------

HRESULT
CompatFlagsFromClsid(REFCLSID clsid, LPDWORD pdwCompatFlags, LPDWORD pdwMiscStatusFlags);

void
AssertCompatibilityTable()
{
#ifndef WIN16           // we'll deal with ActiveX issue later
    LONG    lRet;       // Dual error code types and variables.
    HRESULT hr = S_OK;  // Notice the two exit paths below.

    HKEY  hkeyRoot = NULL;
    DWORD cKeys = 0, iKey = 0, cbClsid;
    DWORD dwOleMisc, dwSize, dwType;
    DWORD dwCompatFlags;
    CLSID clsid;
    TCHAR szClsid[40];
    TCHAR szVersion[10];
    int   iVersionNumberComparison;

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTableRootKey, 0, KEY_READ, &hkeyRoot);
    if( lRet != ERROR_SUCCESS )
        goto Win32ErrorExit;

    // Check the version number:
    dwSize = sizeof( szVersion );
    lRet = RegQueryValueEx( hkeyRoot, _T("Version"), NULL, &dwType, 
      (LPBYTE)szVersion, &dwSize );
    if( lRet != ERROR_SUCCESS )
        goto Win32ErrorExit;

    iVersionNumberComparison = _tcscmp( szVersion, szOurVersion );

    // The version number should not be less than our internal one:
    Assert( szVersion >= 0 );

    // First count how many entries there are:
    lRet = RegQueryInfoKey( hkeyRoot, NULL, NULL, NULL, &cKeys,
        NULL, NULL, NULL, NULL, NULL, NULL, NULL );
    if( lRet != ERROR_SUCCESS )
        goto Win32ErrorExit;

    // If the version number is the same the count should be the
    // same:
    if( iVersionNumberComparison == 0 )
        Assert( cKeys == ARRAY_SIZE( s_aCompatibility ) );

    // Read each table entry:
    for( ; iKey < cKeys; iKey++ )
    {
        cbClsid = sizeof( szClsid );
        lRet = RegEnumKeyEx( hkeyRoot, iKey, szClsid, &cbClsid, NULL, NULL, NULL, NULL );
        if( lRet != ERROR_SUCCESS )
            goto Win32ErrorExit;

        // Get the clsid value from the string:
        szClsid[cbClsid] = _T('\0');
        hr = CLSIDFromString( szClsid, &clsid );
        if( FAILED(hr) )
            goto Exit;

        Assert( *s_aCompatibility[iKey].pclsid == clsid );

        hr = CompatFlagsFromClsid( clsid, &dwCompatFlags, &dwOleMisc );
        Assert( SUCCEEDED( hr ) );

        Assert( s_aCompatibility[iKey].dwCompatFlags == dwCompatFlags );
        Assert( s_aCompatibility[iKey].dwMiscStatusFlags == dwOleMisc );
    }

  Exit:
    if( hkeyRoot )
        RegCloseKey( hkeyRoot );

    Assert( SUCCEEDED( hr ) );
    return;

  Win32ErrorExit:  // convert WIN32 error code to HRESULT:
    hr = HRESULT_FROM_WIN32( lRet );
    goto Exit;
#endif    
}
#endif

EXTERN_C const IID IID_IRowset;
EXTERN_C const IID IID_OLEDBSimpleProvider;
EXTERN_C const IID IID_IRowCursor;
EXTERN_C const IID IID_DataSource;

DeclareTag(tagShowHideVerb, "OleSite", "DoVerb(SHOW/HIDE) before Inplace (de)activate.");


//+------------------------------------------------------------------------
//
//  Member:     CompatFlagsFromClsid
//
//  Synopsis:   Get compatibility flags for given clsid.
//
//-------------------------------------------------------------------------

HRESULT
CompatFlagsFromClsid(REFCLSID clsid, LPDWORD pdwCompatFlags, LPDWORD pdwMiscStatusFlags)
{
    LONG lRet;      // Dual error code types and variables.
    HRESULT hr;     // Notice the two exit paths below.

    HKEY hkeyRoot = NULL, hkeyClsid = NULL;
    DWORD dwSize, dwType;
    LPOLESTR pszClsid = NULL;
    union Yuck { 
        DWORD dw;
        TCHAR tch[10];
    } yuckValue;

    Assert( pdwCompatFlags != NULL );
    Assert( pdwMiscStatusFlags != NULL );

    lRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTableRootKey, 0, KEY_READ, &hkeyRoot);
    if( lRet != ERROR_SUCCESS )
        goto Win32ErrorExit;

    hr = StringFromCLSID( clsid, &pszClsid );
    if( FAILED( hr ) )
        goto Exit;

    // Open the {####-####-####...} Clsid subkey:
    lRet = RegOpenKeyEx(hkeyRoot, pszClsid, 0, KEY_READ, &hkeyClsid);
    if( lRet != ERROR_SUCCESS )
    {
        hr = S_FALSE;  // if there is no entry in the table that is OK.
        goto Exit;
    }

    // Get the flags from the subkeys named values. Either value may
    // be missing from the registry, we'll just use 0 then.
    // The yuckValue mechanism is due to the fact that the .inf tools
    // sometimes put STRINGS rather than DWORDS in the registry on win95.
    *pdwCompatFlags = 0;    // default initial value in case we fail anywhere.
    dwSize = sizeof( yuckValue );
    lRet = RegQueryValueEx( hkeyClsid, szCompatFlags, NULL, &dwType, 
      (LPBYTE)&yuckValue, &dwSize );
    if( lRet == ERROR_SUCCESS )
    {
        if( dwType == REG_DWORD )
            *pdwCompatFlags = yuckValue.dw;
        else if( dwType == REG_SZ && dwSize > 2 )
            *pdwCompatFlags = _tcstol( yuckValue.tch+2, NULL, 16 );
    }
    
    *pdwMiscStatusFlags = 0; // default initial value in case we fail anywhere.
    dwSize = sizeof( yuckValue );
    lRet = RegQueryValueEx( hkeyClsid, szMiscStatusFlags, NULL, &dwType, 
      (LPBYTE)&yuckValue, &dwSize );
    if( lRet == ERROR_SUCCESS )
    {
        if( dwType == REG_DWORD )
            *pdwMiscStatusFlags = yuckValue.dw;   
        else if( dwType == REG_SZ && dwSize > 2)
            *pdwMiscStatusFlags = _tcstol( yuckValue.tch+2, NULL, 16 );
    }

  Exit:
    if( hkeyClsid )
        RegCloseKey( hkeyClsid );

    if( hkeyRoot )
        RegCloseKey( hkeyRoot );

    if( pszClsid )
        CoTaskMemFree( pszClsid );

    return( hr );

  Win32ErrorExit:  // convert WIN32 error code to HRESULT:
    hr = HRESULT_FROM_WIN32( lRet );
    goto Exit;
}


//+------------------------------------------------------------------------
//
//  Member:     CClassTable::Reset
//
//  Synopsis:   Releases the ITypeInfo interface pointes we have stored in the
//              _aryci array.
//
//-------------------------------------------------------------------------

void
CClassTable::Reset()
{
    int i = _aryci.Size();

    for( ; i > 0; --i )
    {
        ClearInterface( &_aryci[i-1]._pTypeInfoEvents );
    }

    _aryci.DeleteAll();

#if DBG == 1
    // Take out temporarily due to table order issues on WIN95.  -Tom
    //AssertCompatibilityTable();
#endif
}

//+------------------------------------------------------------------------
//
//  Member:     InitializeClassInfo
//
//  Synopsis:   Initializes a CLASSINFO structure
//
//  Arguments:  pci         CLASSINFO structure
//              clsid       The GUID identifier.
//
//  Returns:    void
//
//-------------------------------------------------------------------------

HRESULT
CLASSINFO::Init(REFCLSID rclsid, BOOL fInitCompatFlags)
{
    HRESULT hr = S_OK;

    // Initialize CLASSINFO members to defaul state

    // 0-fill for speed
    memset(this, 0, sizeof(CLASSINFO));
    
    clsid = rclsid;

    // Assume IDispatch for these two IIDs.  Note that if the object doesn't
    //  actually have a default interface or default event interface, subsequent
    //  code will simply fail when we try to QI or FindConnectionPoint for these
    //  IIDs, so we're no worse off than if we started with IID_NULL here.
    iidDefault = IID_IDispatch;
    iidDispEvent = IID_IDispatch;

    Assert(vtValueType == VT_EMPTY);
    Assert(vtBindType == VT_EMPTY);
    dispIDBind = DISPID_UNKNOWN;
    dispidIDataSource = DISPID_UNKNOWN;
    dispidRowset = DISPID_UNKNOWN;
    dispidCursor = DISPID_UNKNOWN;
    dispidSTD = DISPID_UNKNOWN;

    if (fInitCompatFlags)
    {
        hr = CompatFlagsFromClsid(rclsid, &dwCompatFlags, &dwMiscStatusFlags);
    }

    if (S_FALSE == hr)
        hr = S_OK;

    RRETURN(hr);
}

//+------------------------------------------------------------------------
//
//  Member:     CClassTable::AssignWclsid
//
//  Synopsis:   Assign an integer id given a guid id.
//
//  Arguments:  pDoc       The hosting form.
//              clsid       The GUID identifier.
//              pwclsid     The integer identifier.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CClassTable::AssignWclsid(CDoc *pDoc, REFCLSID clsid, WORD *pwclsid)
{
    int                     wclsid = 0;
    CLASSINFO *             pci;
    HRESULT                 hr = S_OK;
    ILicensedClassManager * pLCM = NULL;
    IRequireClasses *       pRC = NULL;

    if (clsid == GUID_NULL)
        goto Cleanup;

    for (wclsid = 1, pci = _aryci; wclsid <= _aryci.Size(); wclsid++, pci++)
    {
        if (pci->clsid == clsid)
            goto Cleanup;
    }

    hr = THR(_aryci.EnsureSize(_aryci.Size() + 1));
    if (hr)
        goto Cleanup;

    pci = &_aryci[_aryci.Size()];

    hr = pci->Init(clsid, TRUE);
    if (hr)
        goto Cleanup;

    wclsid = _aryci.Size() + 1;

    _aryci.SetSize(_aryci.Size() + 1);

    // Notify the world that we have added a class.

    if (OK(THR_NOTRACE(pDoc->QueryService(
            SID_SLicensedClassManager,
            IID_ILicensedClassManager,
            (void **)&pLCM))))
    {
        if (OK(THR(pDoc->QueryInterface(IID_IRequireClasses, (void **)&pRC))))
        {
            IGNORE_HR(pLCM->OnChangeInRequiredClasses(pRC));
            pRC->Release();
        }
        pLCM->Release();
    }

 Cleanup:
    if (hr)
        wclsid = 0;

    *pwclsid = (WORD)wclsid;
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CClassTable::IsInterfaceProperty, static
//
//  Synopsis:   Determine if the given TypeDesc is for an interface-valued
//              property, and return the IID of that interface if it is.
//
//  Arguments:  pTI             TypeInfo which we found the given TypeDesc
//              pTypeDesc       type descriptor of a property
//              piid            Where to return the discovered IID
//              
//
//  Returns:    TRUE            if the TypeDesc is for an interface-valued
//                              property; fills in *piid.
//              FALSE           if the property is not interface-valued;
//                              leaves *piid unaffected.
//
//-------------------------------------------------------------------------

BOOL
CClassTable::IsInterfaceProperty (ITypeInfo *pTI, TYPEDESC *pTypeDesc, IID *piid)
{
    BOOL        fResult = FALSE;

    Assert(pTI);
    Assert(pTypeDesc);
    Assert(piid);

    // We are looking for a pointer to GUID'd user-defined type

    // first, make sure it's a pointer
    if (!pTypeDesc || pTypeDesc->vt != VT_PTR)
    {
        goto Cleanup;
    }

    // now examine the type of the object pointed to, make sure
    //  it's a user-defined type
    pTypeDesc = pTypeDesc->lptdesc;
    if (pTypeDesc && pTypeDesc->vt == VT_USERDEFINED)
    {
        // Yes, so it could be the interface-valued object.
        HREFTYPE    hreftype;
        ITypeInfo * pUserTI;

        // We have a property which has a undefined type.
        hreftype = pTypeDesc->hreftype;

        if (!pTI->GetRefTypeInfo(hreftype, &pUserTI))
        {
            TYPEATTR *pTypeAttr;

            if (!pUserTI->GetTypeAttr(&pTypeAttr))
            {
                *piid = pTypeAttr->guid;
                fResult = TRUE;

                pUserTI->ReleaseTypeAttr(pTypeAttr);
            }

            ReleaseInterface(pUserTI);
        }
    }

Cleanup:
    return fResult;
}


//+------------------------------------------------------------------------
//
//  Member:     GetDefaultBindInfoForGet, static helper
//
//  Synopsis:   save the info we need about the default bind property's
//              "get" method
//
//  Arguments:  pci             the class info structure
//              pfDesc          function description (from typelib)
//              pClassTable     the class table entry
//              cTINav          typeinfo navigator (for checking interface properties)
//
//  Returns:    none
//
//-------------------------------------------------------------------------
void
CClassTable::GetDefaultBindInfoForGet(CLASSINFO *pci, FUNCDESC *pfDesc,
                                        CTypeInfoNav& cTINav)
{
    IID iid;
    VARTYPE vtParamType;
    
    pci->uGetBindIndex = pfDesc->oVft;
    vtParamType = pfDesc->elemdescFunc.tdesc.vt;
    pci->dispIDBind = pfDesc->memid;

    // the type should agree with the put method (if we've seen it)
    Assert(pci->vtBindType == VT_EMPTY || (pci->vtBindType & VT_TYPEMASK) == vtParamType);
    pci->vtBindType = vtParamType | (pci->vtBindType & ~VT_TYPEMASK);

    // special check for complex data consumers
    if (IsInterfaceProperty(cTINav.getITypeInfo(),
                                &pfDesc->elemdescFunc.tdesc,
                                &iid))
    {
        if (IsEqualIID(iid, IID_DataSource) ||
            IsEqualIID(iid, IID_OLEDBSimpleProvider) ||
            IsEqualIID(iid, IID_IRowset))
        {
            pci->vtBindType = VT_UNKNOWN;
        }
    }
}


//+------------------------------------------------------------------------
//
//  Member:     GetDefaultBindInfoForPut, static helper
//
//  Synopsis:   save the info we need about the default bind property's
//              "put" method
//
//  Arguments:  pci             the class info structure
//              pfDesc          function description (from typelib)
//
//  Returns:    none
//
//-------------------------------------------------------------------------
void
CClassTable::GetDefaultBindInfoForPut(CLASSINFO *pci, FUNCDESC *pfDesc)
{
    VARTYPE vtParamType;
    BOOL fParamIsPointer;
    
    pci->uPutBindIndex = pfDesc->oVft;
    pci->fImmediateBind = !!(pfDesc->wFuncFlags & FUNCFLAG_FIMMEDIATEBIND);
    pci->dwFlagsBind = pfDesc->invkind;

    // get the type of the put method's parameter
    Assert(pfDesc->cParams == 1);
    vtParamType = pfDesc->lprgelemdescParam->tdesc.vt;
    fParamIsPointer = (vtParamType == VT_PTR);
    if (fParamIsPointer)
    {
        vtParamType = pfDesc->lprgelemdescParam->tdesc.lptdesc->vt | VT_BYREF;
    }

    // it should agree with the type of the get method (if we've seen it)
    Assert(pci->vtBindType == VT_EMPTY || 
            (pci->vtBindType & VT_TYPEMASK) == (vtParamType & VT_TYPEMASK));
    pci->vtBindType = vtParamType;
}


//+------------------------------------------------------------------------
//
//  Member:     CClassTable::GetDualInfo, static
//
//  Synopsis:   Save the
//
//  Arguments:  pTI             the class typeinfo.
//              pci             the class info structure, may change:
//                                  fDualInterface
//                                  fImmediateBind
//                                  dispIDBind
//                                  uGetBindIndex
//                                  uPutBindIndex
//                                  vtBindType
//
//  Returns:    none
//
//-------------------------------------------------------------------------
void
CClassTable::GetDualInfo(
        CTypeInfoNav & cTINav,
        FUNCDESC *pfDesc,
        CLASSINFO *pci)
{
    BOOL fValueProp = (pfDesc->memid == DISPID_VALUE);
    BOOL fDefaultBind = ( (pfDesc->wFuncFlags & 
                                (FUNCFLAG_FBINDABLE|FUNCFLAG_FDEFAULTBIND)) ==
                            (FUNCFLAG_FBINDABLE | FUNCFLAG_FDEFAULTBIND));
    
    switch (pfDesc->invkind)
    {
    case INVOKE_PROPERTYGET:
        // Save information about the defaultbind property
        if (fDefaultBind)
        {
            GetDefaultBindInfoForGet(pci, pfDesc, cTINav);
        }
        
        // Save information about the value property information (DISPID_VALUE)
        if (fValueProp)
        {
            pci->uGetValueIndex = pfDesc->oVft;
            pci->vtValueType = pfDesc->elemdescFunc.tdesc.vt;

            // if we haven't seen the defaultbind property, use the value property;
            // this will be overwritten if the defaultbind property shows up later.
            // The effect is to bind to the value property (if any) if no defaultbind
            // property is present.
            if (pci->dispIDBind == DISPID_UNKNOWN || pci->dispIDBind == DISPID_VALUE)
            {
                GetDefaultBindInfoForGet(pci, pfDesc, cTINav);
            }
        }
        break;

    case INVOKE_PROPERTYPUT:
    case INVOKE_PROPERTYPUTREF:
        // Save information about the defaultbind property
        if (fDefaultBind)
        {
            GetDefaultBindInfoForPut(pci, pfDesc);
        }
        
        // Save information about the value property information (DISPID_VALUE)
        if (fValueProp)
        {
            pci->uPutValueIndex = pfDesc->oVft;
            pci->dwFlagsValue = pfDesc->invkind;

            // if we haven't seen the defaultbind property, use the value property;
            // this will be overwritten if the defaultbind property shows up later.
            // The effect is to bind to the value property (if any) if no defaultbind
            // property is present.
            if (pci->dispIDBind == DISPID_UNKNOWN || pci->dispIDBind == DISPID_VALUE)
            {
                GetDefaultBindInfoForPut(pci, pfDesc);
            }
        }
        break;
    }
}



//+------------------------------------------------------------------------
//
//  Member:     CClassTable::FindTypelibInfo, static
//
//  Synopsis:   Look for the IRowset property and value property FuncFlags or
//              ValueFlags for this class, if they are found.
//
//  Arguments:  pTI             the class typeinfo.
//              pci             the class info structure, may change:
//                                  fImmediateBind
//                                  dispidRowset
//                                  dispIDBind
//                                  uGetBindIndex
//                                  uPutBindIndex
//                                  vtBindType
//                                  uSetRowset
//                                  dispidCursor
//                                  dispidSTD
//                                  uSetCursor
//                                  uGetSTD
//
//  Returns:    none
//
//-------------------------------------------------------------------------
void
CClassTable::FindTypelibInfo(ITypeInfo *pTI, CLASSINFO *pci)
{
    HRESULT         hr;
    CTypeInfoNav    cTINav;
    WORD            wVFFlags = 0;

    Assert(pTI);
    Assert(pci);

    // Look for the displaybind and bindable properties.
    hr = THR(cTINav.InitITypeInfo(pTI, 0));
    if (hr)
        goto Cleanup;

    // Keep looping through typeinfo until we find a property match.
    while (!cTINav.Next())
    {
        FUNCDESC    *pfDesc;

        pfDesc = cTINav.getFuncD();

        // Do we have a user defined type?
        if (pfDesc)
        {
            // Check for interesting interface-valued Get properties
            // with no paramter types.
            if (pfDesc->invkind == INVOKE_PROPERTYGET &&
                pfDesc->cParams == 0)
            {
                IID iid;

                // Check out the return type for a known interface.
                if (IsInterfaceProperty(pTI,
                                        &pfDesc->elemdescFunc.tdesc,
                                        &iid))
                {
                    if (IsEqualIID(iid, IID_DataSource))
                    {
                        pci->dispidIDataSource = pfDesc->memid;
                        pci->uGetIDataSource = pfDesc->oVft;
                    }
                    if (IsEqualIID(iid, IID_OLEDBSimpleProvider))
                    {
                        pci->dispidSTD = pfDesc->memid;
                        pci->uGetSTD = pfDesc->oVft;
                    }
                    if (IsEqualIID(iid, IID_IRowset))
                    {
                        pci->dispidRowset = pfDesc->memid;
                        pci->uGetRowset = pfDesc->oVft;
                    }
                }
            }

            // Check for interesting interface-valued put property.
            if (pfDesc->lprgelemdescParam &&
                (pfDesc->invkind == INVOKE_PROPERTYPUT ||
                 pfDesc->invkind == INVOKE_PROPERTYPUTREF))
            {
                IID iid;
                
                if (IsInterfaceProperty(pTI,
                                        &pfDesc->lprgelemdescParam->tdesc,
                                        &iid ) )
                {
                    if (IsEqualIID(iid, IID_DataSource))
                    {
                        pci->dispidIDataSource = pfDesc->memid;
                        pci->uSetIDataSource = pfDesc->oVft;
                        pci->dwFlagsDataSource = pfDesc->invkind;
                    }
                    if (IsEqualIID(iid, IID_IRowset))
                    {
                        pci->dispidRowset = pfDesc->memid;
                        pci->uSetRowset = pfDesc->oVft;
                        pci->dwFlagsRowset = pfDesc->invkind;
                    }
                    else if (IsEqualIID(iid, IID_IRowCursor))
                    {
                        pci->dispidCursor = pfDesc->memid;
                        pci->uSetCursor = pfDesc->oVft;
                    }
                }
            }

            if (cTINav.IsDualInterface())
            {
                GetDualInfo(cTINav, pfDesc, pci);
            }
        }
        else
        {
            VARDESC *pvDesc;

            pvDesc = cTINav.getVarD();
            if (pvDesc)
            {
                IID iid;
                
                wVFFlags = pvDesc->wVarFlags;

                // Check for the interface-valued properties
                if (IsInterfaceProperty(pTI, &pvDesc->elemdescVar.tdesc,
                                        &iid ) )
                {
                    if (IsEqualIID(iid, IID_DataSource))
                    {
                        pci->dispidIDataSource = pvDesc->memid;
                    }
                    else if (IsEqualIID(iid, IID_IRowset))
                    {
                        pci->dispidRowset = pvDesc->memid;
                    }
                    else if(IsEqualIID(iid, IID_OLEDBSimpleProvider))
                    {
                        pci->dispidSTD = pvDesc->memid;
                    }
                    else if(IsEqualIID(iid, IID_IRowCursor))
                    {
                        pci->dispidCursor = pvDesc->memid;
                    }
                }

                // Default bindable property?
                if (((wVFFlags&(FUNCFLAG_FBINDABLE|FUNCFLAG_FDEFAULTBIND)) ==
                     (FUNCFLAG_FBINDABLE | FUNCFLAG_FDEFAULTBIND)) ||
                    (pvDesc->memid == 0 && pci->dispIDBind == DISPID_UNKNOWN))
                {
                    pci->dispIDBind = pvDesc->memid;
                    pci->vtBindType = pvDesc->elemdescVar.tdesc.vt;
                    if (pvDesc->wVarFlags & VARFLAG_FIMMEDIATEBIND)
                    {
                        pci->fImmediateBind = TRUE;
                    }
                }
            }
        }
    }
    
    pci->fDualInterface = cTINav.IsDualInterface() &&
                            pci->uGetBindIndex!=0 && pci->uPutBindIndex!=0;

Cleanup:
    return;
}


//+------------------------------------------------------------------------
//
//  Member:     CClassTable::InitializeIIDsFromTIDefault, static
//
//  Synopsis:   Given the TypeInfo for the default interface of a class,
//              fill in whatever CLASSINFO members can be computed from it.
//              Helper function used no matter what mechanism is used to
//              obtain the TypeInfo.
//
//  Arguments:  pci         Fill in this CLASSINFO ..
//              pTIDefault  ... using this type info
//              ptaDefault  and the caller-fetched type attribute for
//                          this TypeInfo
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CClassTable::InitializeIIDsFromTIDefault(CLASSINFO *pci,
                                         ITypeInfo *pTIDefault,
                                         TYPEATTR *ptaDefault)
{
    HRESULT hr = S_OK;
    ITypeInfo * pTIDual= NULL;
    TYPEATTR *  ptaDual = NULL;
    HREFTYPE    hrt;

    
    //
    // Only handle dual interfaces.

    // Does the control class have an IRowset,Value and/or default
    // bindable property?
    FindTypelibInfo(pTIDefault, pci);

    pci->iidDefault = ptaDefault->guid;

    if (ptaDefault->wTypeFlags & TYPEFLAG_FDUAL)
    {
        hr = THR(pTIDefault->GetRefTypeOfImplType((UINT) -1, &hrt));
        if (hr)
            goto Cleanup;

        hr = THR(pTIDefault->GetRefTypeInfo(hrt, &pTIDual));
        if (hr)
            goto Cleanup;

        hr = THR(pTIDefault->GetTypeAttr(&ptaDual));
        if (hr)
            goto Cleanup;

        pci->cMethodsDefault = (int) (ptaDual->cbSizeVft / sizeof(void (*)()));
// TODO: (garybu) Should assert that tearoff table is large enough to thunk to this itf.
    }

Cleanup:
    if (ptaDual)
        pTIDual->ReleaseTypeAttr(ptaDual);
    ReleaseInterface(pTIDual);

    RRETURN1(hr, S_FALSE);
}

//+------------------------------------------------------------------------
//
//  Member:     CClassTable::InitializeIIDs, static
//
//  Synopsis:   Fetch the IIDs for a given CLASSINFO
//
//  Arguments:  pci     Fill in this CLASSINFO ..
//              pUnk    ... using type info from this object.
//
//  Returns:    HRESULT
//
//-------------------------------------------------------------------------

HRESULT
CClassTable::InitializeIIDs(CLASSINFO *pci, IUnknown *pUnk)
{
    HRESULT     hr = S_OK;
    int         i;
    ITypeInfo * pTIClass = NULL;
    TYPEATTR *  ptaClass = NULL;
    IProvideClassInfo *pPCI = NULL;
    IDispatch * pDispatch = NULL;

    Assert(!pci->fAllInitialized);
    
    // Should have been set when instantiated the control
    if (!pUnk)
    {
        hr = E_FAIL;
        goto Cleanup;
    }

    // Get the ITypeInfo, either via IProvideClassInfo, or IDispatch

    // TODO:
    // The IDispatch mechanism below won't discover any eventset. A solution\
    // would be to go to registry if we don't have IProvideClassInfo.
    //
    if (OK(THR_NOTRACE(pUnk->
               QueryInterface(IID_IProvideClassInfo,
                              (void **) &pPCI))))
    {
        hr = THR(pPCI->GetClassInfo(&pTIClass));
        if (hr)
            goto Cleanup;

        hr = THR(pTIClass->GetTypeAttr(&ptaClass));
        if (hr)
            goto Cleanup;

        if (ptaClass->typekind != TKIND_COCLASS)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        for (i = 0; i < ptaClass->cImplTypes; i++)
        {
            int         implTypeFlags;
            HREFTYPE    hrt;
            ITypeInfo * pTIDefault = NULL;
            TYPEATTR *  ptaDefault = NULL;

            hr = THR(pTIClass->GetImplTypeFlags(i, &implTypeFlags));
            if (hr)
                goto Cleanup;

            if (!(implTypeFlags & IMPLTYPEFLAG_FDEFAULT))
                continue;

            hr = THR(pTIClass->GetRefTypeOfImplType(i, &hrt));
            if (hr)
                goto Cleanup;

            hr = THR(pTIClass->GetRefTypeInfo(hrt, &pTIDefault));
            if (hr)
                goto Cleanup;

            hr = THR(pTIDefault->GetTypeAttr(&ptaDefault));
            if (hr)
                goto LoopCleanup;

            if (!(ptaDefault->typekind & TKIND_DISPATCH))
                goto LoopCleanup;

            if (implTypeFlags & IMPLTYPEFLAG_FSOURCE)
            {
                pci->_pTypeInfoEvents = pTIDefault;
                pTIDefault->AddRef();

                pci->iidDispEvent = ptaDefault->guid;

            }
            else
            {
                hr = THR(InitializeIIDsFromTIDefault(pci, pTIDefault, ptaDefault));
            }
LoopCleanup:
            if (ptaDefault)
                pTIDefault->ReleaseTypeAttr(ptaDefault);

            ReleaseInterface(pTIDefault);
            if (hr)
                goto Cleanup;
        }

    }
    else if (OK(THR_NOTRACE(pUnk->
               QueryInterface(IID_IDispatch,
                              (void **) &pDispatch))))
    {
        // we cheat a little on variable names here; we are using pTIClass
        //  and ptaClass, even though we have the TypeInfo for the Dispatch
        //  itself.  This lets us leverage the cleanup logic below
        hr = THR(pDispatch->GetTypeInfo(0, 0, &pTIClass));
        if (hr)
            goto Cleanup;
        hr = THR(pTIClass->GetTypeAttr(&ptaClass));
        if (hr)
            goto Cleanup;

        if (!(ptaClass->typekind & TKIND_DISPATCH))
        {
            goto Cleanup;
        }

        hr = THR(InitializeIIDsFromTIDefault(pci, pTIClass, ptaClass));
    }

Cleanup:
    if (ptaClass)
        pTIClass->ReleaseTypeAttr(ptaClass);

    ReleaseInterface(pTIClass);
    ReleaseInterface(pPCI);
    ReleaseInterface(pDispatch);

    if (hr != E_OUTOFMEMORY)
    {
        // we only try to initialize once, unless the problem was E_OUTOFMEMORY, which
        //  might get alleviated for subsequent attempts.
        pci->fAllInitialized = TRUE;
    }

    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CClassTable::GetClassInfo
//
//  Synopsis:   Find pointer to class info given word class identifier.
//              Forces load of TypeInfo for class, if not already done.
//
//-------------------------------------------------------------------------

CLASSINFO *
CClassTable::GetClassInfo(int wclsid, IUnknown *pUnk, COleSite *pSite)
{
    CLASSINFO * pci;

    Assert(0 <= wclsid && wclsid <= _aryci.Size());

    if (wclsid == 0)
    {
        return(&g_ciNull);
    }

    pci = &_aryci[wclsid - 1];
    
    if (!pci->fAllInitialized) // Is it actually initialized?
    {
        // (sramani) java applets have same clsid but dufferent per instance typeinfo.
        // So we fetch the per instance classinfo and store it in that instance's olesite
        // instead of in the common class table entry. We make sure that it is only fetched
        // once per instance.
        Assert(pSite);
        if (pci->clsid == CLSID_AppletOCX)
        {
            if (!pSite->_pci)
            {
                pSite->_pci = new CLASSINFO;
                if (!pSite->_pci)
                    return(&g_ciNull);

                memcpy(pSite->_pci, pci, sizeof(CLASSINFO));
            }
 
            pci = pSite->_pci;
        }
        // No, so initialize it.  We trust InitializeIIDS to leave us
        //  us something sane on failure.
        if (!pci->fAllInitialized) // Is it actually initialized?
            IGNORE_HR(InitializeIIDs(pci, pUnk));
    }

    Assert(pci->clsid != CLSID_AppletOCX || (pSite->_pci && pSite->_pci->fAllInitialized));
    Assert(pci->clsid == CLSID_AppletOCX || !pSite->_pci);

#if DBG == 1
    if (IsTagEnabled(tagShowHideVerb))
        pci->dwCompatFlags |= (COMPAT_SEND_SHOW | COMPAT_SEND_HIDE);
#endif

    return pci;
}



//+------------------------------------------------------------------------
//
//  Member:     CClassTable::GetQuickClassInfo
//
//  Synopsis:   Find pointer to "quick" class info given word class
//              identifier.  Tries to avoid loading the TypInfo for
//              the class, but may need to, if the class doesn't
//              support IProvideClassInfo2.
//
//-------------------------------------------------------------------------

QUICKCLASSINFO *
CClassTable::GetQuickClassInfo(int wclsid, IUnknown *pUnk)
{
    Assert(0 <= wclsid && wclsid <= _aryci.Size());

    HRESULT             hr;
    CLASSINFO *         pci;
    IProvideClassInfo2 *pPCI2 = 0;

    if (wclsid == 0)
    {
        pci = &g_ciNull;
        goto Cleanup;
    }

    pci = &_aryci[wclsid - 1];

    // IE5 Bug 66813: Some controls, namely the TAPI control
    // QI us after we have already started shutting down. When
    // they QI us, we have already deleted everything in _aryci
    // in the Reset() method. This method is called with wclsid
    // set to 1. In that case, _aryci returns NULL for position 0,
    // since everything is already deleted. This check is to 
    // save ourselves from controls not doing what they are supposed to do.
    //
    if (!pci)
        goto Cleanup;

    //
    // If the Default Event has not yet been initialized and the entire
    // class info has also not been initialized, QI the pUnk for 
    // IProvideClassInfo2 and cache the info.
    //
    // HACKHACKHACK: All applets have the same clsid but will have 
    // different event iids.  To have event sinking on multiple applets
    // work, never depend on the cached event iid if we're the applet ocx.
    // ASSUMPTION: The VM implements IProvideClassInfo2.
    //
    
    if ((!pci->fAllInitialized && !pci->fiidDEInitialized) ||
        (pci->clsid == CLSID_AppletOCX))
    {
        if (OK(THR(pUnk->
                   QueryInterface(IID_IProvideClassInfo2,
                                  (void **) &pPCI2))))
        {
            hr = pPCI2->GetGUID(GUIDKIND_DEFAULT_SOURCE_DISP_IID,
                                &pci->iidDispEvent);
            
            if (SUCCEEDED(hr))
            {
                pci->fiidDEInitialized = TRUE;
                goto Done;
            }
        }
        
        // If IProvideClassInfo2 is not supported, or the GetGUID
        // method failed, then we must try querying the TypeLibInfo..
        // except for applet OCs.

        if (!pci->fAllInitialized && !pci->fiidDEInitialized && pci->clsid != CLSID_AppletOCX)
        {
            hr = InitializeIIDs(pci, pUnk);
        }
    }

Done:
#if DBG == 1
    if (IsTagEnabled(tagShowHideVerb))
        pci->dwCompatFlags |= (COMPAT_SEND_SHOW | COMPAT_SEND_HIDE);
#endif
    ReleaseInterface(pPCI2);

Cleanup:
    return (QUICKCLASSINFO *) pci;
}



//+------------------------------------------------------------------------
//
//  Member:     CLASSINFO::ClearFDualInterface
//
//  Synopsis:   Change CLASSINFO marked as dual to a consistent state
//              reflecting that the class is IDispatch-only.  Meant
//              to be called if QI for the primary interface fails because
//              the primary interface isn't remoted across thread boundaries,
//              but a QI for IDispatch succeeds, because the system does
//              know how to remote IDispatch.
//
//-------------------------------------------------------------------------

void
CLASSINFO::ClearFDualInterface()
{
    // Mark control as NOT dual interface.
    fDualInterface = FALSE;

    // Set it so in later instances, we know to QI for IDispatch right
    // away, instead of trying the iidDefault marked in the Object's
    // typelib.
    iidDefault = IID_IDispatch;

    // This should really not be necessary, since people should check
    // dwFlags for CLSTABLE_DUALINTERFACE before jumping through the
    // VTable, but for now..
    uGetBindIndex = 0;
    uPutBindIndex = 0;
    uGetValueIndex = 0;
    uPutValueIndex = 0;
    uSetIDataSource = 0;
    uGetIDataSource = 0;
    uSetRowset = 0;
    uGetRowset = 0;
    uSetCursor = 0;
    uGetSTD = 0;
}

HRESULT
InitClassTable()
{
    RRETURN(g_ciNull.Init(GUID_NULL, FALSE));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\ole\bag16.cxx ===
//bag16.cxx
#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_EOBJECT_HXX_
#define X_EOBJECT_HXX_
#include "eobject.hxx"
#endif

#ifndef X_MIME64_HXX_
#define X_MIME64_HXX_
#include "mime64.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_PROPBAG_HXX_
#define X_PROPBAG_HXX_
#include "propbag.hxx"
#endif

#ifndef X_PERHIST_HXX_
#define X_PERHIST_HXX_
#include "perhist.hxx"
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include <binder.hxx>       // for cdatasourceprovider
#endif

#ifndef X_ADO_ADOID_H_
#define X_ADO_ADOID_H_
#include <ado/adoid.h>
#endif

#ifndef X_UWININET_H_
#define X_UWININET_H_
#include "uwininet.h"
#endif

#include "object.hdl"

#pragma warning (disable: 4702)

#define      MAX_PROXY     1024  


static const char aJavaKey[] = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\JavaVM";
static const char aProxyKey[] = "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings";


static const char* aProxyPropName[] = {"proxyhttp" , 
                                       "proxyssl", 
                                       "proxygopher",
                                       "proxyftp",
                                        NULL };

static const char* aProtocol[] = {"http", "https" , "gopher" , "ftp" , NULL};
static const char* aProtocolEq[] = {"http=", "https=" , "gopher=" , "ftp=" , "socks=", NULL};


char aClassPath[MAX_PATH];
char aDefaultOptions[MAX_PATH];
char aBaseUrl[MAX_PATH];
char aProxyString[MAX_PROXY];
char aProxyBuffer[MAX_PATH];


/*-----------------------------------------------------
** IsProxyEnabled
** 
** determine whether ProxyEnabled key in registry exists and if its value is nonzero
**-----------------------------------------------------
*/
BOOL IsProxyEnabled()
{
    DWORD dwData = 0;
    DWORD dwResult = 0;
    HKEY hKey = 0;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, &aProxyKey[0], 0 , NULL , &hKey))
    {   
        dwData = 4L;
        RegQueryValueEx(hKey,"ProxyEnable" ,NULL, NULL , (LPBYTE)&dwResult, &dwData); 
        RegCloseKey(hKey);
    } 
    
    return (dwResult != 0);
} 


/*------------------------------------------------------
** UseSameProxies
** 
** determine whether proxy settings string begins with a protocol name.  If not
** by convention the proxy string is assumed to be the proxy setting used for all protocols
**------------------------------------------------------
*/

BOOL UseSameProxies(LPSTR lpProxyString)
{   
    //if string begins with "socks" from the point of view of JavaVM, no proxies are enabled  
    if (strlen(lpProxyString) >= 5 && strnicmp(lpProxyString , "socks" , 5) == 0)
    {
        return FALSE;
    }
    
    char* lpProtocol;  
    int i;
    for (i = 0 , lpProtocol = (char*)aProtocolEq[0]; lpProtocol; i++ , lpProtocol = (char*)aProtocol[i])

    {
        if (strlen(lpProxyString) >= strlen(lpProtocol) &&  
            strnicmp(lpProxyString , lpProtocol, strlen(lpProtocol)) == 0) 
            return FALSE;
    }
    
    return TRUE;
}
            


   

/*
**----------------------------------------------
** GetProxyString   
**
** static helper to parse value of given proxy property from string in registry
**----------------------------------------------
*/

BOOL GetProxyString(LPSTR lpKey , LPSTR lpString, LPSTR lpRet, int iMaxChars)
{   
    if (!IsProxyEnabled()) 
    { 
        return FALSE;
    }
    
    if (!lpString || !lpString[0])
    {
        return FALSE;
    }
    
    if (UseSameProxies(lpString))
    {   
        //enough room in output buffer?
        if (iMaxChars < strlen(lpString) + strlen(lpKey) + 5)
        {
            return FALSE;
        }
        
        //change setting string of form "itgproxy:80" to one of form "http://itgproxy:80/"
        if (strstr(lpString, "://") == 0)
        {
            strcpy(lpRet,lpKey);
            strcat(lpRet,"://");
            strcat(lpRet,lpString);
        }
        else
        {
            strcpy(lpRet, lpString);
        }
        if (*(lpRet + strlen(lpRet) - 1) != '/')
        {
            strcat(lpRet,"/");
        }
        
        return TRUE;
    }    

    //copy data since strtok is destructive
    char* lpTemp = new char[strlen(lpString) + 1];
    strcpy(lpTemp , lpString);
    LPSTR lpNext = strtok(lpTemp , "=;" );
    while (lpNext)
    {
        if (strcmp(lpNext, lpKey) == 0)
        {
            LPSTR lpSetting = strtok(NULL , "=;");
            if (!lpSetting) 
            {    
                delete [] lpTemp;
                return FALSE;
            }

            if (iMaxChars < strlen(lpSetting) + strlen(lpKey) + 5) 
            {
                delete lpTemp;
                return FALSE;
            }
            
            //change setting string of form "itgproxy:80" to one of form "http://itgproxy:80/"
            if (strstr(lpSetting, "://") == 0)
            {
                strcpy(lpRet,lpKey);
                strcat(lpRet,"://");
                strcat(lpRet,lpSetting);
            }
            else
            {
                strcpy(lpRet, lpSetting);
            }
            if (*(lpRet + strlen(lpRet) - 1) != '/')
            {
                strcat(lpRet,"/");
            }

            delete [] lpTemp;
            return TRUE;
        }

        lpNext = strtok( NULL  , "=;");
    }

    //not found
    delete [] lpTemp;
    return FALSE;
    
}


HRESULT CObjectElement::SaveWin16AppletProps(IPropertyBag* pBag)
{
    HKEY hKey;
    HRESULT hr = S_OK;

    DWORD dwData;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, &aJavaKey[0], 0 , NULL , &hKey))
    {

        dwData = sizeof(aClassPath);
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, 
                                             "ClassPath" , 
                                             NULL, 
                                             NULL , 
                                             (LPBYTE)&aClassPath[0], &dwData))
        {
            goto FAILED;
        }

        dwData = sizeof(aDefaultOptions);
        if (ERROR_SUCCESS != RegQueryValueEx(hKey, 
                        "DefaultOptions",
                        NULL,
                        NULL, 
                        (LPBYTE)&aDefaultOptions[0], 
                        &dwData))

    
        {
            strcpy(aDefaultOptions , "-mx600k -ss8k msjava16");
        }
        
        RegCloseKey(hKey);
        hKey = 0;
    }
    else
    {
        goto FAILED;
    }

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, &aProxyKey[0], 0 , NULL , &hKey))
    {
        dwData = sizeof(aProxyString);
        aProxyString[0] = '\0';
        RegQueryValueEx(hKey, "ProxyServer", NULL, NULL , (LPBYTE)&aProxyString[0], &dwData);
        RegCloseKey(hKey);
    }

    //drop data in propertybag
    VARIANT var;
    VariantInit(&var);
    if (pBag->Read("documentbase", &var, NULL) == E_INVALIDARG)
    {
        char* pBaseURL;  
        char pDocBaseURL[pdlUrlLen];
        char *pDocBaseSlash;
        DWORD dwDocBase;
        
        hr = _pDoc->GetBaseUrl(&pBaseURL, this); 
        if (hr)
            goto FAILED;
        
        dwDocBase = pdlUrlLen;
        if (!InternetCombineUrl(pBaseURL, "java", pDocBaseURL, &dwDocBase, 0))
            goto FAILED;
        char chSlash = strnicmp(pDocBaseURL, "file://", 7) ? '/' : '\\';
        if (!(pDocBaseSlash = strrchr(pDocBaseURL, chSlash)))
                goto FAILED;   

        if (_stricmp(pDocBaseSlash + 1, "java"))
            goto FAILED;
        *(pDocBaseSlash + 1) = '\0';  

        var.vt = VT_BSTR;
        var.bstrVal = SysAllocString(pDocBaseURL);  
        hr = pBag->Write("documentbase", &var);  
        VariantClear(&var);
        if (hr) goto FAILED;
    }
    
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString(&aClassPath[0]);
    hr = pBag->Write("classpath", &var);
    VariantClear(&var);
    if (hr) goto FAILED;
   
    var.vt = VT_BSTR;
    var.bstrVal = SysAllocString(&aDefaultOptions[0]);
    hr = pBag->Write("defaultoptions", &var); 
    VariantClear(&var);
    if (hr) goto FAILED;

    if (aProxyString[0])
    {
        for (int i = 0; aProtocol[i]; i++)
        {
            if (GetProxyString((LPSTR)aProtocol[i] , 
                               aProxyString, 
                               aProxyBuffer, 
                               sizeof(aProxyBuffer)))
            {
                var.vt = VT_BSTR; 
            
                var.bstrVal = SysAllocString(&aProxyBuffer[0]);
                hr = pBag->Write(aProxyPropName[i], &var);
                VariantClear(&var);
                if (hr) goto FAILED;
            
            }
        }

    }

    return S_OK;

FAILED:
    return S_FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\miscsite\frameset.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995
//
//  File:       frameset.cxx
//
//  Contents:   Implementation of CFrameSetSite
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_CGUID_H_
#define X_CGUID_H_
#include "cguid.h"
#endif

#ifndef X_FRAMESET_HXX_
#define X_FRAMESET_HXX_
#include "frameset.hxx"
#endif

#ifndef X_ELEMENT_HXX_
#define X_ELEMENT_HXX_
#include "element.hxx"
#endif

#ifndef X_FRAME_HXX_
#define X_FRAME_HXX_
#include "frame.hxx"
#endif

#ifndef X_FRAMELYT_HXX_
#define X_FRAMELYT_HXX_
#include "framelyt.hxx"
#endif

#ifndef X_STRBUF_HXX_
#define X_STRBUF_HXX_
#include "strbuf.hxx"
#endif

#ifndef X_HTIFRAME_H_
#define X_HTIFRAME_H_
#include <htiframe.h>
#endif

#ifndef X_MSHTMHST_H_
#define X_MSHTMHST_H_
#include <mshtmhst.h>
#endif

#ifndef X_FLOWLYT_HXX_
#define X_FLOWLYT_HXX_
#include "flowlyt.hxx"
#endif

#define _cxx_
#include <frameset.hdl>

MtDefine(CFrameSetSite, Elements, "CFrameSetSite")
MtDefine(CFrameSetSite_aryFrames_pv, CFrameSetSite, "CFrameSetSite::_aryFrames::_pv")
MtDefine(CFrameSetSite_aryFormVisit_pv, CFrameSetSite, "CFrameSetSite::_aryFormVisit::_pv")
MtDefine(CNoFramesElement, Elements, "CNoFramesElement")
MtDefine(CFramesetChildIterator, Layout, "CFramesetChildIterator")

MtDefine(CFrameSetSite_aryRows_pv, CFrameSetSite, "CFrameSetSite::_aryRows::_pv")
MtDefine(CFrameSetSite_aryCols_pv, CFrameSetSite, "CFrameSetSite::_aryCols::_pv")

enum XorYLoop { XDirection = 0, YDirection = 1, Terminate = 2 };

#ifndef NO_PROPERTY_PAGE
const CLSID * const CFrameSetSite::s_apclsidPages[] =
{
    // Browse-time pages
    NULL,
    // Edit-time pages
#if DBG==1    
    &CLSID_CCDGenericPropertyPage,
#endif // DBG==1    
    NULL
};
#endif // NO_PROPERTY_PAGE

CElement::ACCELS CFrameSetSite::s_AccelsFrameSetSiteRun = CElement::ACCELS (&CElement::s_AccelsElementRun, IDR_ACCELS_FRAMESET_RUN);

const CElement::CLASSDESC CFrameSetSite::s_classdesc =
{
    {
        &CLSID_HTMLFrameSetSite,            // _pclsid
        0,                                  // _idrBase
#ifndef NO_PROPERTY_PAGE
        s_apclsidPages,                     // _apClsidPages
#endif // NO_PROPERTY_PAGE
        s_acpi,                             // _apiidConect
        ELEMENTDESC_BODY |                  // _dwFlags
        ELEMENTDESC_NOTIFYENDPARSE,
        &IID_IHTMLFrameSetElement,          // _piidDispinterface
        &s_apHdlDescs,                      // _apHdlDesc
    },
    (void *)s_apfnpdIHTMLFrameSetElement,
    &s_AccelsFrameSetSiteRun                // _pAccelsRun
};

const CElement::CLASSDESC CNoFramesElement::s_classdesc = { 0 };

struct MYPROP
{
    PROPERTYDESC  pdesc;
    NUMPROPPARAMS numprop;
};

// Value the unitvalue is given if the string is empty
#define NOT_SET_DEFAULT  0

LPTSTR
FindRowColSeparator(LPTSTR pchStart, const TCHAR * pchSep)
{
    // IE50 Raid 3475
    // re-implement _tcstok to not skipping over leading separators
    //
    LPTSTR  pchNext;
    TCHAR * pchControl;

    for (pchNext = pchStart; * pchNext; pchNext ++)
    {
        for (pchControl = (TCHAR * ) pchSep;
             * pchControl && * pchNext != * pchControl;
             pchControl ++);
        if (* pchControl)
            break;
    }

    if (* pchNext)
    {
        * pchNext = _T('\0');
        return pchNext + 1;
    }
    else
        return NULL;
}


//+------------------------------------------------------------------------
//
//  Member:     CFrameSetSite::PrivateQueryInterface, IUnknown
//
//  Synopsis:   Private unknown QI.
//
//-------------------------------------------------------------------------

HRESULT
CFrameSetSite::PrivateQueryInterface(REFIID iid, void ** ppv)
{
    HRESULT hr;

    *ppv = NULL;

    if IID_TEAROFF(this, IHTMLFrameSetElement2, NULL)
    else
    {
        RRETURN(THR_NOTRACE(super::PrivateQueryInterface(iid, ppv)));
    }

    (*(IUnknown **)ppv)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CFrameSetSite::CreateElement, public
//
//  Synopsis:   Creates a CFrameSetSite
//
//----------------------------------------------------------------------------

HRESULT
CFrameSetSite::CreateElement(CHtmTag *pht,
                              CDoc *pDoc, CElement **ppElement)
{
    Assert (ppElement);

    if (pht->Is(ETAG_FRAMESET))
    {
        *ppElement = new CFrameSetSite(pDoc);
    }
    else // ETAG_NOFRAMES
    {
        Assert(pht->Is(ETAG_NOFRAMES));

        *ppElement = new CNoFramesElement(pDoc);
    }

    RRETURN ((*ppElement) ? S_OK : E_OUTOFMEMORY);
}

//+---------------------------------------------------------------------------
//
//  Member:     CFrameSetSite::CFrameSetSite, public
//
//  Synopsis:   CFrameSetSite ctor
//
//----------------------------------------------------------------------------

CFrameSetSite::CFrameSetSite ( CDoc * pDoc )
  : super(ETAG_FRAMESET, pDoc),
    _aryRows(Mt(CFrameSetSite_aryRows_pv)),
    _aryCols(Mt(CFrameSetSite_aryCols_pv)),
    _aryRowsResize(Mt(CFrameSetSite_aryRows_pv)),
    _aryColsResize(Mt(CFrameSetSite_aryCols_pv))
{
#ifdef WIN16
    m_baseOffset = ((BYTE *) (void *) (CBase *)this) - ((BYTE *) this);
    m_ElementOffset = ((BYTE *) (void *) (CElement *)this) - ((BYTE *) this);
#endif
    _pNFE = NULL;
};


//+---------------------------------------------------------------------------
//
//  Member:     CFrameSetSite::Init2, public
//
//  Synopsis:   Parse the ROWS and/or COLS attributes
//
//  Arguments:  (none)
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------
HRESULT
CFrameSetSite::Init2(CInit2Context * pContext)
{
    HRESULT   hr;
    CDoc *    pDoc = Doc();
    
    hr = THR(super::Init2(pContext));
    if (hr)
        goto Cleanup;
   
    pDoc->_fFrameBorderCacheValid = FALSE;

Cleanup:
    RRETURN(hr);
}


//+-------------------------------------------------------------------------
//
//  Method:     CFrameSetSite::Notify
//
//--------------------------------------------------------------------------

void
CFrameSetSite::Notify(CNotification *pNF)
{
    super::Notify(pNF);

    switch (pNF->Type())
    {
    case NTYPE_ELEMENT_ENTERTREE:
    {
        CMarkup * pMarkup = GetMarkup();

        pMarkup->_fFrameSet = TRUE;

        LPCTSTR    pStrFrameBorder = NULL;
        CElement * pParent         = GetFirstBranch()->Parent()->Element();

        //
        // Alert the view that the top client element may have changed
        //

        Doc()->OpenView();

        DoNetscapeMappings();

        pStrFrameBorder = GetAAframeBorder();

        if (pStrFrameBorder)
        {
            _fFrameBorder =  pStrFrameBorder[0] == _T('y')
                          || pStrFrameBorder[0] == _T('Y')
                          || pStrFrameBorder[0] == _T('1');
        }
        else if (pParent->Tag() == ETAG_FRAMESET)
        {
            _fFrameBorder = DYNCAST(CFrameSetSite, pParent)->_fFrameBorder;
        }
        else // top-level <frameset>, default is TRUE.
        {
            _fFrameBorder = TRUE;

            // If the HTML element has had it's formats calc'd, it has made scrolling decisions without us.
            // We want it to be aware of its client before making scrolling decisions.  Let it redecide.
            if (pMarkup->IsHtmlLayout())
            {
                CElement * pHTML = pMarkup->GetHtmlElement();
                if (pHTML)
                    pHTML->GetFirstBranch()->VoidFancyFormat();
            }
        }
        
        SetRowsCols();

        //
        // Notify the view of a new possible top element
        //

        SendNotification(NTYPE_VIEW_ATTACHELEMENT);

        if (pMarkup->HasWindowPending())
        {               
            pMarkup->OnLoadStatus(LOADSTATUS_INTERACTIVE);
        }

        break;
    }

    case NTYPE_ELEMENT_EXITTREE_1:
        //
        // Notify the view that the top element may have left
        //

        SendNotification(NTYPE_VIEW_DETACHELEMENT);
        break;
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CFrameSetSite::ExpectedFrames
//
//  Synopsis:   Returns the number of frames expected (used during parsing)
//
//--------------------------------------------------------------------------

int
CFrameSetSite::ExpectedFrames()
{
    int iRows = _aryRows.Size();
    int iCols = _aryCols.Size();

    if (!iRows)
        iRows = 1;

    if (!iCols)
        iCols = 1;

    return (iRows * iCols);
}


//+-------------------------------------------------------------------------
//
// Member: CFrameSetSite::FrameSpacingAttribute
//
//  Synopsis:   walk up the tree looking for a framespacing attribute
//
//--------------------------------------------------------------------------
CUnitValue
CFrameSetSite::FrameSpacingAttribute()
{
    CUnitValue uv = GetAAframeSpacing();
    CTreeNode *pNode = GetFirstBranch();

    Assert( pNode );

    while ( uv.IsNull() )
    {
        pNode = pNode->Parent();
        if ( !pNode )
            break;

        if ( pNode->Tag() == ETAG_FRAMESET )
        {
            Assert( pNode->Element()->Tag() == ETAG_FRAMESET );
            uv = DYNCAST(CFrameSetSite, pNode->Element())->GetAAframeSpacing();
        }
    }

    return uv;
}

//+-------------------------------------------------------------------------
//
//  Method:     CFrameSetSite::IsSeamlessEdit()
//
//  Synopsis:   tells us that Primary markup is in design mode
//              and we show no borders between frames (seamless join mode 
//              in VS terminology) - we want to show some resize handles 
//              in this mode anyway. (nothing shown in browse mode)
//--------------------------------------------------------------------------
BOOL 
CFrameSetSite::IsSeamlessEdit()
{
    CMarkup *pPrimaryMarkup = Doc()->PrimaryMarkup();
    CUnitValue uvFrameSpacing = FrameSpacingAttribute();

    //design_mode && border=0 && framespacing=0

    return (   pPrimaryMarkup
            && pPrimaryMarkup->IsEditable()
            && !_fFrameBorder
            && !uvFrameSpacing.IsNullOrEnum()
            && uvFrameSpacing.GetPixelValue() == 0
           );
}

//+-------------------------------------------------------------------------
//
//  Method:     CFrameSetSite::GetFrameSpacing()
//
//  Synopsis:   compute the amount of space between frames
//
//--------------------------------------------------------------------------

int
CFrameSetSite::GetFrameSpacing()
{
    CUnitValue uvFrameSpacing = FrameSpacingAttribute();

    if(!uvFrameSpacing.IsNullOrEnum())
    {
        int iRet = uvFrameSpacing.GetPixelValue();

        if(iRet == 0 && IsSeamlessEdit())
            return 2;
        else
            return iRet;
    }
    else
        return 2;

}

//+-------------------------------------------------------------------------
//
//  Method:     CFrameSetSite::DoNetscapeMappings()
//
//  Synopsis:   map netscapes frame attributes to ours
//
//--------------------------------------------------------------------------

void
CFrameSetSite::DoNetscapeMappings()
{
    BOOL fOldEventListener = FALSE;

    CUnitValue uv = FrameSpacingAttribute();
    if (uv.IsNull())
    {
        uv = BorderAttribute();
        if (!uv.IsNull())
        {
            // OK, so we have a border attribute and no
            // framespacing attribute.  Now we need to
            // map the values appropriately.

            int iPixelValueFrameSpacing = uv.GetPixelValue();
            VARIANT iFrameSpacing;
            iFrameSpacing.vt = VT_I2;
            iFrameSpacing.iVal = (SHORT)iPixelValueFrameSpacing;

            // Inhibit OnPropertyChange event firing because
            // this is an internal change for Netscape Compat
            fOldEventListener      = _fEventListenerPresent;
            _fEventListenerPresent = FALSE;

            switch(iPixelValueFrameSpacing)
            {
            case 0:
                iFrameSpacing.iVal = 0;
                put_StringHelper(_T("0"), (PROPERTYDESC *)&s_propdescCFrameSetSiteframeBorder);
                break;
            case 1:
            case 2:
                iFrameSpacing.iVal = _fFrameBorder ? 2 : 4;
                put_StringHelper(_T("0"), (PROPERTYDESC *)&s_propdescCFrameSetSiteframeBorder);
                break;
            case 3:
            case 4:
                iFrameSpacing.iVal = _fFrameBorder ? 1 : 4;
                put_StringHelper(_fFrameBorder ? _T("1") : _T("0"), (PROPERTYDESC *)&s_propdescCFrameSetSiteframeBorder);
                break;
            default:
                iFrameSpacing.iVal = (_fFrameBorder ? iPixelValueFrameSpacing-4
                                                   : iPixelValueFrameSpacing);
                break;
            }
            put_VariantHelper(iFrameSpacing, (PROPERTYDESC *)&s_propdescCFrameSetSiteframeSpacing);

            // Re-enable previous event firing settings
            _fEventListenerPresent = fOldEventListener;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CFrameSetSite::IsOverflowFrame
//
//  Synopsis : first we need to verify that our frameset is not an overflow of
//    a frameset above us.
//----------------------------------------------------------------------------

#ifdef _M_IA64
//$ WIN64: Why is there unreachable code in the retail build of this next function for IA64?
#pragma warning(disable:4702) /* unreachable code */
#endif

BOOL
CFrameSetSite::IsOverflowFrame(CElement *pel)
{

    if (CElement::IsOverflowFrame())
        return TRUE;
    else
    {
        int                 cexp = 0;
        int                 i = 0;
        CTreeNode *         pNode = NULL;
        static ELEMENT_TAG  atagStop = ETAG_FRAMESET;
        static ELEMENT_TAG  atagChild[2] = { ETAG_FRAMESET, ETAG_FRAME };
        CChildIterator  iter(
            this,
            NULL,
            CHILDITERATOR_USETAGS,
            &atagStop, 1,
            atagChild, ARRAY_SIZE(atagChild));

        cexp = ExpectedFrames();
    
        for (i = 0, pNode = iter.NextChild(); 
             (pNode && i < cexp); 
             pNode = iter.NextChild(), i++)
        {
            // seen request frame as expected
            if (pNode->Element() == pel)
                return FALSE;
        }

        // seen all expected frames already
        if (i >= cexp)
            return TRUE;

        // no more frames
        if (!pNode)
        {
            Assert(0);
        }
    }

    return FALSE;
}

#ifdef _M_IA64
#pragma warning(default:4702) /* unreachable code */
#endif

//+------------------------------------------------------------------
//
//  Member:     CFrameSetSite::GetFrameFlat
//
//  Synopsis:   gets frame # nIndex, where indexing goes flat through
//              nested framesets.
//              Returns:
//
//              nIndex          index of frame to get
//              pcFrames        number of frames passed by (including all frames
//                              in nested framesets)
//              ppFrame         frame with index nIndex if found
//
//              return value    TRUE            if frame with index nIndex found
//                              FALSE           otherwise
//
//-------------------------------------------------------------------

BOOL
CFrameSetSite::GetFrameFlat (LONG nIndex, LONG * pcFrames, CFrameElement ** ppFrame)
{
    CLayout         * pLayout;
    CFrameSetLayout * pLayoutThis = Layout();
    LONG              cFrames, cFramesSub;
    DWORD_PTR         dw;
    BOOL              fFound = FALSE;

    if (ppFrame)
        *ppFrame = NULL;

    cFrames = 0;

    for(pLayout = pLayoutThis->GetFirstLayout(&dw, FALSE);
        pLayout;
        pLayout = pLayoutThis->GetNextLayout(&dw, FALSE))
    {
        if (ETAG_FRAME == pLayout->Tag())
        {
            cFrames++;
            if (cFrames == nIndex+1)
            {
                fFound = TRUE;
                if (ppFrame)
                    *ppFrame = DYNCAST(CFrameElement, pLayout->ElementOwner());
                break;
            }
        }
        else if (ETAG_FRAMESET == pLayout->Tag())
        {
            fFound = DYNCAST(CFrameSetSite, pLayout->ElementOwner())->GetFrameFlat(nIndex - cFrames, &cFramesSub, ppFrame);
            cFrames += cFramesSub;
            if (fFound)
                break;
        }
    }

    pLayoutThis->ClearLayoutIterator(dw, FALSE);
    if (pcFrames)
        *pcFrames = cFrames;

    return fFound;
}

//+--------------------------------------------------------------
//
//  Member:     CFrameSetSite::GetFramesCount
//
//  Synopsis:   returns number of frames in this frameset,
//              including all nested frames
//
//---------------------------------------------------------------

HRESULT
CFrameSetSite::GetFramesCount (LONG * pcFrames)
{
    if (!pcFrames)
        RRETURN (E_POINTER);

    GetFrameFlat(-1, pcFrames, NULL);

    return S_OK;
}

//+------------------------------------------------------------------------
//
//  Function:   CFrameSetSite::BorderColorAttribute
//
//  Synopsis:   walk up the tree looking for a bordercolor attribute
//              if one isn't found, return NULL
//
//-------------------------------------------------------------------------
CColorValue
CFrameSetSite::BorderColorAttribute()
{
    CColorValue ccvBorderColor = GetAAborderColor();
    CTreeNode *pNode = GetFirstBranch();

    Assert( pNode );

    while ( ccvBorderColor.IsNull() )
    {
        pNode = pNode->Parent();
        if ( !pNode )
            break;

        if ( pNode->Tag() == ETAG_FRAMESET )
        {
            Assert( pNode->Element()->Tag() == ETAG_FRAMESET );
            ccvBorderColor = DYNCAST(CFrameSetSite, pNode->Element())->GetAAborderColor();
        }
    }

    return ccvBorderColor;
}


//+------------------------------------------------------------------------
//
//  Function:   CFrameSetSite::FrameBorderAttribute
//
//  Synopsis:   walk up the tree looking for a frameborder attribute
//              if one isn't found, return NULL
//
//-------------------------------------------------------------------------
void
CFrameSetSite::FrameBorderAttribute(BOOL fFrameBorder, BOOL fDefined)
{
    LPCTSTR pStrFrameBorder     = GetAAframeBorder();
    BOOL    fFrameBorderDefined = (pStrFrameBorder) ? (TRUE) : (fDefined);

    _fFrameBorder = (pStrFrameBorder)
                  ? (   pStrFrameBorder[0] == _T('y')
                     || pStrFrameBorder[0] == _T('Y')
                     || pStrFrameBorder[0] == _T('1'))
                  : (fFrameBorder);

    CFrameSetLayout * pLayoutThis = Layout( GUL_USEFIRSTLAYOUT );
    DWORD_PTR  dw;
    CLayout  * pLayout = pLayoutThis->GetFirstLayout(&dw, FALSE);
    BOOL       fFirst  = TRUE;
    BOOL       fFrameBorderThis = _fFrameBorder;
    BOOL       fFrameBorderChild;

    while (pLayout)
    {
        ELEMENT_TAG eTag = (ELEMENT_TAG) pLayout->ElementOwner()->_etag;

        switch (eTag)
        {
        case ETAG_FRAME:
            {
                CFrameSite * pFrame = DYNCAST(CFrameSite, pLayout->ElementOwner());
                pStrFrameBorder = pFrame->GetAAframeBorder();
                pFrame->_fFrameBorder = (pStrFrameBorder)
                                      ? (   pStrFrameBorder[0] == _T('y')
                                         || pStrFrameBorder[0] == _T('Y')
                                         || pStrFrameBorder[0] == _T('1'))
                                      : (_fFrameBorder);
                fFrameBorderChild = pFrame->_fFrameBorder;
            }
            break;

        case ETAG_FRAMESET:
            {
                CFrameSetSite * pFrameSet = DYNCAST(CFrameSetSite,
                                                    pLayout->ElementOwner());
                pFrameSet->FrameBorderAttribute(_fFrameBorder,
                                                fFrameBorderDefined);
                fFrameBorderChild = pFrameSet->_fFrameBorder;
            }
            break;

        default:
            fFrameBorderChild = fFrameBorderThis;
            break;
        }

        if (fFirst)
        {
            fFrameBorderThis = fFrameBorderChild;
            fFirst           = FALSE;
        }
        else if (fFrameBorderThis != fFrameBorderChild)
        {
            fFrameBorderThis = TRUE;
        }

        pLayout = pLayoutThis->GetNextLayout(&dw, FALSE);
    }

    pLayoutThis->ClearLayoutIterator(dw, FALSE);

    if (!fFrameBorderDefined)
    {
        _fFrameBorder = fFrameBorderThis;
    }
}

//+------------------------------------------------------------------------
//
//  Function:   CFrameSetSite::BorderAttribute
//
//  Synopsis:   walk up the tree looking for a border attribute
//              if one isn't found, return NULL
//
//-------------------------------------------------------------------------

CUnitValue
CFrameSetSite::BorderAttribute()
{
    CUnitValue uv = GetAAborder();
    CTreeNode *pNode = GetFirstBranch();

    Assert( pNode );

    while ( uv.IsNull() )
    {
        pNode = pNode->Parent();
        if ( !pNode )
            break;

        if ( pNode->Tag() == ETAG_FRAMESET )
        {
            Assert( pNode->Element()->Tag() == ETAG_FRAMESET );
            uv = DYNCAST(CFrameSetSite, pNode->Element())->GetAAborder();
        }
    }

    return uv;
}

//+------------------------------------------------------------------------
//
// Member:      CFrameSetSite::ApplyDefaultFormat, CSite
//
//-------------------------------------------------------------------------
HRESULT
CFrameSetSite::ApplyDefaultFormat(CFormatInfo * pCFI)
{
    CDoc *  pDoc = Doc();
    CMarkup * pMarkup = GetMarkup();

    if (!pMarkup->IsHtmlLayout())
    {
        pCFI->PrepareFancyFormat();

        pCFI->_ff().SetHeightPercent(TRUE);
        pCFI->_ff().SetWidthPercent(TRUE);
        if (    pMarkup->GetElementClient() == this
            &&  pMarkup->HasWindow()
            &&  (pMarkup->GetFrameOptions() & FRAMEOPTIONS_NO3DBORDER) == 0
            &&  (pDoc->_dwFlagsHostInfo & DOCHOSTUIFLAG_NO3DBORDER) == 0 )
        {
            // set 3D border color attributes for top-level frameset
            //
            pCFI->_ff()._bd._ccvBorderColorLight.SetValue(
                    GetSysColorQuick(COLOR_3DLIGHT), FALSE);
            pCFI->_ff()._bd._ccvBorderColorShadow.SetValue(
                    GetSysColorQuick(COLOR_BTNSHADOW), FALSE);
            pCFI->_ff()._bd._ccvBorderColorHilight.SetValue(
                    GetSysColorQuick(COLOR_BTNHIGHLIGHT), FALSE);
            pCFI->_ff()._bd._ccvBorderColorDark.SetValue(
                    GetSysColorQuick(COLOR_3DDKSHADOW), FALSE);

        }
        pCFI->UnprepareForDebug();
    }

    return super::ApplyDefaultFormat(pCFI);
}

//+------------------------------------------------------------------------
//
//  Member:     CFrameSetSite::GetBorderInfo
//
//  Synopsis:   Generate the border information for a framesite
//
//-------------------------------------------------------------------------

DWORD
CFrameSetSite::GetBorderInfo(
    CDocInfo *      pdci,
    CBorderInfo *   pborderinfo,
    BOOL            fAll,
    BOOL            fAllPhysical
    FCCOMMA           FORMAT_CONTEXT FCPARAM)
{
    CDoc *  pDoc = Doc();
    if  (   !GetMarkup()->IsHtmlLayout()
         && (   GetMarkup() == Doc()->PrimaryMarkup()
             || (   IsInViewLinkBehavior(TRUE)
                 && !IsInViewLinkBehavior(FALSE) ))
         && (GetMarkup()->GetElementClient() == this)
         && ((GetMarkup()->GetFrameOptions() & FRAMEOPTIONS_NO3DBORDER) == 0)
         && ((pDoc->_dwFlagsHostInfo & (DOCHOSTUIFLAG_NO3DBORDER | DOCHOSTUIFLAG_NO3DOUTERBORDER)) == 0))
    {
        // set border style and border space for top-level frameset
        //
        pborderinfo->abStyles[SIDE_TOP]
                = pborderinfo->abStyles[SIDE_RIGHT]
                = pborderinfo->abStyles[SIDE_BOTTOM]
                = pborderinfo->abStyles[SIDE_LEFT]
                = fmBorderStyleSunken;
        pborderinfo->aiWidths[SIDE_TOP]
                = pborderinfo->aiWidths[SIDE_RIGHT]
                = pborderinfo->aiWidths[SIDE_BOTTOM]
                = pborderinfo->aiWidths[SIDE_LEFT]
                = 2;
        pborderinfo->wEdges = BF_RECT;
    }

    return super::GetBorderInfo(pdci, pborderinfo, fAll, fAllPhysical FCCOMMA FCPARAM);
}

int CFrameSetSite::iPixelFrameHighlightWidth = 0;

int CFrameSetSite::iPixelFrameHighlightBuffer = 0;

//+---------------------------------------------------------------------------
//
//  Member:     CNoFramesElement::Save, public
//
//  Synopsis:   Saves all our embedded sites.
//
//  Arguments:  [pStreamWrBuff] -- Stream to write to
//              [fEnd]          -- TRUE if we're saving the end tag
//
//  Returns:    HRESULT
//
//----------------------------------------------------------------------------

HRESULT
CNoFramesElement::Save(CStreamWriteBuff * pStreamWrBuff, BOOL fEnd)
{
    HRESULT hr;

    // No frameset for plaintext mode
    if (pStreamWrBuff->TestFlag(WBF_SAVE_PLAINTEXT))
        return S_OK;

    hr = super::Save(pStreamWrBuff, fEnd);
    if (hr)
        goto Cleanup;

    if (!fEnd)
    {
        DWORD dwOldFlags;

        hr = THR(pStreamWrBuff->NewLine());
        if (hr)
            goto Cleanup;
        hr = THR(pStreamWrBuff->NewLine());
        if (hr)
            goto Cleanup;

        dwOldFlags = pStreamWrBuff->ClearFlags(WBF_ENTITYREF);
        pStreamWrBuff->BeginPre();

        hr = THR(pStreamWrBuff->Write(_cstrNoFrames));
        if (hr)
            goto Cleanup;

        pStreamWrBuff->EndPre();
        pStreamWrBuff->RestoreFlags(dwOldFlags);

        hr = THR(pStreamWrBuff->NewLine());
    }

Cleanup:
    RRETURN(hr);
}

//+----------------------------------------------------------------------------
//
// Member: OnPropertyChange
//
//-----------------------------------------------------------------------------
HRESULT
CFrameSetSite::OnPropertyChange(DISPID dispid, DWORD dwFlags, const PROPERTYDESC *ppropdesc)
{
    HRESULT hr;

    hr = THR(super::OnPropertyChange(dispid, dwFlags, ppropdesc));
    if (hr)
        goto Cleanup;

    if (dispid == DISPID_CFrameSetSite_rows || dispid == DISPID_CFrameSetSite_cols)
    {
        SetRowsCols();
        Layout()->CancelManualResize(FALSE);
        Layout()->CancelManualResize(TRUE);
        ResizeElement();
    }

    if (dispid == DISPID_CFrameSetSite_frameBorder)
    {
        Doc()->_fFrameBorderCacheValid = FALSE;
    }

Cleanup:
    RRETURN(hr);
}

CBase *
CFrameSetSite::GetBaseObjectFor(DISPID dispID, CMarkup * pMarkup)
{
    // Messy.  We want to supply the window/markup if:
    // 1. We are backwards compatible and a BODY/FRAMESET (really should be *primary* BODY/FRAMESET).
    // 2. We are CSS1 strict, a BODY/FRAMESET (should be primary), and is not DISPID_EVPROP_ONSCROLL.
    // 3. We are CSS1 strict, an HTML element, and are DISPID_EVPROP_ONSCROLL
    // If we have to add other events to the list, we should make another static CMarkup fn.  (greglett)
    if (    !pMarkup
        &&  IsInMarkup() )
        pMarkup = GetMarkup();

    if (    CMarkup::IsTemporaryDISPID (dispID)
        &&  (   dispID != DISPID_EVPROP_ONSCROLL
            ||  !pMarkup                    
            ||  !pMarkup->IsHtmlLayout() ))
    {        
        if (!pMarkup)
            return NULL;
        else if (pMarkup->HasWindow())
            return pMarkup->Window();       // if we have a window use it 

        // if we have a pending window, we temporarily store these 
        // DISPIDs on the markup and move them onto the window when we switch
        else if (pMarkup->_fWindowPending)
            return pMarkup;
    }

    return this;
}


//+----------------------------------------------------------------------------
//
// Member: WaitForRecalc
//
//-----------------------------------------------------------------------------

void
CFrameSetSite::WaitForRecalc()
{
    CFrameSetLayout * pLayoutThis = Layout();
    CLayout *         pLayout;
    CFrameElement *   pFrameElement;
    DWORD_PTR         dw;

    for (pLayout = pLayoutThis->GetFirstLayout(&dw, FALSE);
         pLayout;
         pLayout = pLayoutThis->GetNextLayout(&dw, FALSE))
    {
        if (ETAG_FRAME == pLayout->Tag())
        {
            pFrameElement = DYNCAST(CFrameElement, pLayout->ElementOwner());

            if (pFrameElement->HasSlavePtr())
            {
                Doc()->WaitForRecalc(pFrameElement->GetSlavePtr()->GetMarkup());
            }
        }
        else if (ETAG_FRAMESET == pLayout->Tag())
        {
            DYNCAST(CFrameSetSite, pLayout->ElementOwner())->WaitForRecalc();
        }
    }

    pLayoutThis->ClearLayoutIterator(dw, FALSE);
}

void
CFrameSetSite::SetRowsCols()
{
    HRESULT                hr;
    CDataAry<CUnitValue> * paryValues;
    CDataAry<CUnitValue> * paryValuesResize;
    CUnitValue             uvValue;
    XorYLoop               dir;
    CStr                   cstr;
    LPCTSTR                pch;
    LPTSTR                 pchThis, pchNext;

    static const TCHAR * s_pszSep = _T(",;"); // Be liberal and allow semicolons
    static MYPROP  s_pdesc = {
                                      { NULL, NULL, 0, NOT_SET_DEFAULT },
                                      {
                                        {
                                           PP_UV_LENGTH_OR_PERCENT |
                                           PROPPARAM_TIMESRELATIVE, 0, 0
                                        },
                                        VT_EMPTY, 0, 0, 0
                                      }
                                    };

    // Clear rows/cols if they exist (IE6 15112)
    _aryCols.DeleteAll();
    _aryRows.DeleteAll();
    _aryColsResize.DeleteAll();
    _aryRowsResize.DeleteAll();
    if (CurrentlyHasAnyLayout())
        Layout()->SetDirtyFramePositions(TRUE);

    for (dir  = XDirection;
         dir != Terminate;
         dir  = ((dir==XDirection) ? YDirection : Terminate))
    {
        if (dir == XDirection)
        {
            pch = GetAAcols();
            paryValues = &_aryCols;
            paryValuesResize = &_aryColsResize;
        }
        else
        {
            pch = GetAArows();
            paryValues = &_aryRows;
            paryValuesResize = &_aryRowsResize;
        }

        if (!pch)
            continue;

        cstr.Set(pch); // Copy the string because _tcstok modifies it

        pchThis = cstr;

        while (pchThis && * pchThis)
        {
            pchNext = FindRowColSeparator(pchThis, s_pszSep);

            if (!(*pchThis))
            {
                // IE50 Raid 3475 - Treat empty string as "*"
                //
                hr = THR(uvValue.SetValue(100, CUnitValue::UNIT_TIMESRELATIVE));
            }
            else
            {
                // We are setting HTML-property and not CSS1 property.
                hr = THR(uvValue.FromString(pchThis, &s_pdesc.pdesc, 0)); 

                if (hr)
                {
                    uvValue.SetValue(0, CUnitValue::UNIT_PIXELS);
                }
                else if (uvValue.GetUnitValue() < 0)
                {
                    if (uvValue.GetUnitType() == CUnitValue::UNIT_PERCENT)
                    {
                        // treat negative percentage rows/cols values as "*"
                        //
                        hr = THR(uvValue.SetValue(100,
                                CUnitValue::UNIT_TIMESRELATIVE));
                    }
                    else
                    {
                        uvValue.SetValue(0, CUnitValue::UNIT_PIXELS);
                    }
                }
            }

            paryValues->AppendIndirect(&uvValue);
            paryValuesResize->AppendIndirect(&uvValue);
            pchThis = pchNext;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\ole\codeload.cxx ===
//+------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       codeload.cxx
//
//  Contents:   Implementation of CCodeLoad class
//
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_CODELOAD_HXX_
#define X_CODELOAD_HXX_
#include "codeload.hxx"
#endif

#ifndef X_SAFETY_HXX_
#define X_SAFETY_HXX_
#include "safety.hxx"
#endif

#ifndef X_PROGSINK_HXX_
#define X_PROGSINK_HXX_
#include "progsink.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_SAFEOCX_H_
#define X_SAFEOCX_H_
#include <safeocx.h>
#endif

ExternTag(tagSecurityContext);

HRESULT CreateStreamOnFile(LPCTSTR lpstrFile, DWORD dwSTGM, LPSTREAM * ppstrm);

EXTERN_C CLSID CLSID_AppletOCX;

MtDefine(CCodeLoad, Dwn, "CCodeLoad")
MtDefine(OleCreateInfo, Dwn, "OLECREATEINFO")
MtDefine(CBindContextParam, Dwn, "CBindContextParam")

#define BINDCONTEXT_CMDID_BASEURL               0
#define BINDCONTEXT_CMDID_PROPBAG               1

///////////////////////////////////////////////////////////////////////////////////////////

//+------------------------------------------------------------------------
//
//  Member:     CCodeLoad::CCodeLoad
//
//  Synopsis:   ctor
//
//-------------------------------------------------------------------------

CCodeLoad::CCodeLoad()
{
    _info.clsid = GUID_NULL;
}


//+------------------------------------------------------------------------
//
//  Member:     CCodeLoad::Init
//
//  Synopsis:   Simple initializer for code download context
//
//-------------------------------------------------------------------------

HRESULT
CCodeLoad::Init(
    COleSite *pSiteOle,
    COleSite::OLECREATEINFO *pinfo)
{
    CLock   Lock(this);
    HRESULT hr = S_OK;
    CDoc *  pDoc = pSiteOle->Doc();

    Assert( pSiteOle );

    CMarkup * pMarkup = pSiteOle->GetMarkup();

    //
    // Initialize member data
    //

    _pSiteOle = pSiteOle;
    _pSiteOle->SubAddRef();

    if (pMarkup)
    {
        _pMarkupScriptBlock = pMarkup;
        _pMarkupScriptBlock->SubAddRef();

        pMarkup->BlockScriptExecution(&_dwScriptCookie);
    }

    _fGotData = TRUE;

    Assert(!pinfo->pDataObject);

    // Make a copy of pinfo locally.
    _info.clsid = pinfo->clsid;
    if (pinfo->pStream)
    {
        _info.pStream = pinfo->pStream;
        pinfo->pStream->AddRef();
    }
    if (pinfo->pStorage)
    {
        _info.pStorage = pinfo->pStorage;
        pinfo->pStorage->AddRef();
    }
    if (pinfo->pPropBag)
    {
        _info.pPropBag = pinfo->pPropBag;
        pinfo->pPropBag->AddRef();
    }
    if (pinfo->pStreamHistory)
    {
        _info.pStreamHistory = pinfo->pStreamHistory;
        pinfo->pStreamHistory->AddRef();
    }
    if (pinfo->pBindCtxHistory)
    {
        _info.pBindCtxHistory = pinfo->pBindCtxHistory;
        pinfo->pBindCtxHistory->AddRef();
    }
    if (pinfo->pShortCutInfo)
    {
        _info.pShortCutInfo = pinfo->pShortCutInfo;
        _info.pShortCutInfo->AddRef();
    }
    _info.dwMajorVer = pinfo->dwMajorVer;
    _info.dwMinorVer = pinfo->dwMinorVer;

    MemReplaceString(Mt(OleCreateInfo), pinfo->pchSourceUrl, &_info.pchSourceUrl);
    MemReplaceString(Mt(OleCreateInfo), pinfo->pchDataUrl, &_info.pchDataUrl);
    MemReplaceString(Mt(OleCreateInfo), pinfo->pchMimeType, &_info.pchMimeType);
    MemReplaceString(Mt(OleCreateInfo), pinfo->pchClassid, &_info.pchClassid);
    MemReplaceString(Mt(OleCreateInfo), pinfo->pchFileName, &_info.pchFileName);

    _pProgSink = CMarkup::GetProgSinkHelper(pMarkup);
    if (_pProgSink)
    {
        _pProgSink->AddRef();
        IGNORE_HR(_pProgSink->AddProgress( PROGSINK_CLASS_CONTROL, &_dwProgCookie ));
    }

    //
    // If we need to download data, create a bits context and get data
    //

    if (pinfo->pchDataUrl)
    {

        // We still download the data, even if from another domain.  But set
        // the flag so we can inject policy when we init the control.
        if (pMarkup)
            pSiteOle->_fDataSameDomain = pMarkup->AccessAllowed(pinfo->pchDataUrl);

        BOOL fPendingRoot = FALSE;

        if (pSiteOle->IsInMarkup())
            fPendingRoot = pSiteOle->GetMarkup()->IsPendingRoot();

        hr = THR(pDoc->NewDwnCtx(DWNCTX_FILE, pinfo->pchDataUrl,
                    pSiteOle, (CDwnCtx **)&_pBitsCtx, fPendingRoot));
        if (hr)
            goto Cleanup;

        if (_pBitsCtx->GetState() & (DWNLOAD_COMPLETE | DWNLOAD_ERROR))
        {
            OnDwnChan(_pBitsCtx);
        }
        else
        {
            _fGotData = FALSE;
            _pBitsCtx->SetProgSink(CMarkup::GetProgSinkHelper(pMarkup));
            _pBitsCtx->SetCallback(OnDwnChanCallback, this);
            _pBitsCtx->SelectChanges(DWNCHG_COMPLETE, 0, TRUE);
        }
    }

    if (pSiteOle->HasMarkupPtr())
        SetDwnDoc(pMarkup->GetDwnDoc());

    //
    // Start BTO.
    //

    hr = THR(BindToObject());
    if (!OK(hr))
        goto Cleanup;

Cleanup:
    RRETURN1(hr, MK_S_ASYNCHRONOUS);
}

//+------------------------------------------------------------------------
//
//  Method:     CCodeLoad::OnDwnChan
//
//-------------------------------------------------------------------------

void
CCodeLoad::OnDwnChan(CDwnChan * pDwnChan)
{
    CLock       Lock(this);
    ULONG       ulState = _pBitsCtx->GetState();
    HRESULT     hr;
    BOOL        fDone = FALSE;
    TCHAR *     pchExt;

    //
    // We better not have terminated yet
    //

    Assert(_pSiteOle);

    if (ulState & DWNLOAD_COMPLETE)
    {
        fDone = TRUE;

        BOOL fPendingRoot = FALSE;

        if (_pSiteOle->IsInMarkup())
            fPendingRoot = _pSiteOle->GetMarkup()->IsPendingRoot();

        // If unsecure download, may need to remove lock icon on Doc
        _pSiteOle->Doc()->OnSubDownloadSecFlags(fPendingRoot, _pBitsCtx->GetUrl(), _pBitsCtx->GetSecFlags());
        
        // Find last occurance of '.' in URL

        //
        // Due to a data sniffing bug, binary .stm files
        // are downloaded and given an extension of .htm.  We then
        // need to examine the URL to get the correct file extension
        //

        pchExt = _tcsrchr(_pBitsCtx->GetUrl(), _T('.'));
        if (pchExt &&
            (!StrCmpIC(pchExt, _T(".stm")) ||
             !StrCmpIC(pchExt, _T(".ods")) ||   // NCompass data files
             !StrCmpIC(pchExt, _T(".ica"))))    // Citrix Winframe data files
        {
            hr = THR(CreateStreamFromData());
            if (hr)
                goto Cleanup;

            goto Done;
        }

        _pBitsCtx->GetFile(&_info.pchFileName);
    }
    else if (ulState & (DWNLOAD_ERROR | DWNLOAD_STOPPED))
    {
        //
        // In error case, try to initNew
        //

        fDone = TRUE;
    }

Done:
    if (fDone)
    {
        _fGotData = TRUE;

        if (_punkObject)
        {
            //
            // Code download is already done, go ahead and create object.
            //

            hr = THR(_pSiteOle->CreateObjectNow(
                _iidObject,
                _punkObject,
                &_info));
        }

        if (_pBitsCtx)
        {
            _pBitsCtx->SetProgSink(NULL); // detach download from document's load progress
            _pBitsCtx->Disconnect();
            _pBitsCtx->Release();
            _pBitsCtx = NULL;
        }
    }

Cleanup:
    ;
}


//+------------------------------------------------------------------------
//
//  Member:     CCodeLoad::CreateStreamFromData
//
//  Synopsis:   Creates an OLE stream from a .stm data file.
//
//-------------------------------------------------------------------------

HRESULT
CCodeLoad::CreateStreamFromData()
{
    LARGE_INTEGER   dlibMove = {0,0};
    HRESULT         hr = E_FAIL;
    TCHAR *         pchFileName = NULL;
    CLSID           clsid;

    //
    // Retrieve clsid from stream and get control
    //

    hr = THR(_pBitsCtx->GetFile(&pchFileName));
    if (hr)
        goto Cleanup;

    hr = THR(CreateStreamOnFile(
            pchFileName,
            STGM_READ | STGM_SHARE_DENY_WRITE,
            &_info.pStream));
    if (hr)
        goto Cleanup;

    //
    // In this mode, we only know how to initialize the
    // object via a stream.
    //

    // seek to the begining of the stream
    hr = THR(_info.pStream->Seek(dlibMove, STREAM_SEEK_SET, NULL));
    if (hr)
        goto Cleanup;

    //
    // read the clsid from the first 16 bytes
    //

#ifdef BIG_ENDIAN
    Assert( 0 && "Fix big endian read of clsid" );
#endif

    hr = THR(_info.pStream->Read(&clsid, 16, NULL));
    if (hr)
        goto Cleanup;

    //
    // If we don't have a clsid yet, go ahead and set the clsid.
    //

    if (_info.clsid == g_Zero.guid)
    {
        _info.clsid = clsid;
    }

Cleanup:
    MemFreeString(pchFileName);
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CCodeLoad::Terminate
//
//  Synopsis:   1st stage destruction.
//
//-------------------------------------------------------------------------

void
CCodeLoad::Terminate()
{
    CLock Lock(this);

    Assert(_pSiteOle);

    if (_pMarkupScriptBlock)
    {
        IGNORE_HR(_pMarkupScriptBlock->UnblockScriptExecution(&_dwScriptCookie));

        _pMarkupScriptBlock->SubRelease();
        _pMarkupScriptBlock = NULL;
    }

    if (_pBitsCtx)
    {
        _pBitsCtx->Disconnect();
        _pBitsCtx->Release();
        _pBitsCtx = NULL;
    }

    _pSiteOle->AddRef();

    if (!_fGotObject)
    {
        // $$ktam: Another reason why Invalidate should be a CLayoutInfo virtual.
        // We can get away with it here because we aren't breaking ole sites.
        
        _pSiteOle->OnFailToCreate();

        // bug 102547
        Assert(!_pSiteOle->IsPassivated());

        CLayout * pLayout = _pSiteOle->GetUpdatedLayout(GUL_USEFIRSTLAYOUT);
        if (pLayout)
            pLayout->Invalidate(); // so olesite will redraw another placeholder

        if (_pbinding)
        {
            IGNORE_HR(_pbinding->Abort());
        }
    }

    if (_pbctx)
    {
        IGNORE_HR(RevokeBindStatusCallback(_pbctx, this));
        ClearInterface(&_pbctx);
    }

    _pSiteOle->OnControlReadyStateChanged(/* fForceComplete = */FALSE);

    _pSiteOle->SubRelease();
    _pSiteOle->Release();
    _pSiteOle = NULL;

    ClearInterface(&_punkObject);

    if( _dwProgCookie )
    {
        Assert( _pProgSink );
        _pProgSink->DelProgress( _dwProgCookie );
    }
    ClearInterface(&_pProgSink);
}


//+---------------------------------------------------------------------------
//
//  Member:     CCodeLoad::QueryInterface, IUnknown
//
//  Synopsis:   Per IUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP
CCodeLoad::QueryInterface(REFIID iid, void ** ppv)
{
    if (iid == IID_IWindowForBindingUI)
    {
        *ppv = (IWindowForBindingUI *)this;
        AddRef();
        return(S_OK);
    }

    return(super::QueryInterface(iid, ppv));
}


//+---------------------------------------------------------------------------
//
//  Member:     CCodeLoad::QueryService, IServiceProvider
//
//  Synopsis:   Per IServiceProvider
//
//----------------------------------------------------------------------------

STDMETHODIMP
CCodeLoad::QueryService(REFGUID rguidService, REFIID riid, void ** ppvObj)
{
    if (rguidService == IID_IWindowForBindingUI)
    {
        return QueryInterface(riid, ppvObj);
    }

    return super::QueryService(rguidService, riid, ppvObj);
}


//+---------------------------------------------------------------------------
//
//  Member:     CCodeLoad::GetWindow, IWindowForBindingUI
//
//  Synopsis:   Per IWindowForBindingUI
//
//----------------------------------------------------------------------------

STDMETHODIMP
CCodeLoad::GetWindow(REFGUID rguidReason, HWND *phwnd)
{
    HRESULT hr;

    if (!_pSiteOle)
    {
        *phwnd = 0;
        hr = E_FAIL;
    }
    else if (_pSiteOle->Doc() && _pSiteOle->Doc()->IsPrintDialogNoUI())
    {
        *phwnd = HWND_DESKTOP;
        hr = S_OK;
    }
    else if (_pSiteOle->Doc()->_dwLoadf & DLCTL_SILENT)
    {
        *phwnd = (HWND)INVALID_HANDLE_VALUE;
        hr = S_FALSE;
    }
    else
    {
        _pSiteOle->Doc()->GetWindowForBinding(phwnd);
        hr = S_OK;
    }

    RRETURN1(hr, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCodeLoad::OnObjectAvailable, IBindStatusCallback
//
//  Synopsis:   Internet Component Download will call back
//              when object is ready.  Typically a class factory.
//
//----------------------------------------------------------------------------

HRESULT
CCodeLoad::OnObjectAvailable(REFIID riid, IUnknown *punk)
{
    HRESULT        hr = E_FAIL;
    IClassFactory *pCF = NULL;

    if (!_pSiteOle)
        goto Cleanup;

    _fGotObject = TRUE;

    if (!_fGotData)
    {
        //
        // Data download is occuring.  Wait until OnChan to create object.
        //

        ReplaceInterface (&_punkObject, punk);
        _iidObject = riid;
        hr = S_OK;
    }
    else
    {
        if (_fGetClassObject && OK(punk->QueryInterface(IID_IClassFactory, (void **)&pCF)))
        {
            hr = THR(_pSiteOle->CreateObjectNow(IID_IClassFactory, pCF, &_info));
        }
        else
        {
            hr = THR(_pSiteOle->CreateObjectNow(riid, punk, &_info));
        }
    }

Cleanup:
    ReleaseInterface(pCF);
    RRETURN(hr);
}


//+------------------------------------------------------------------------
//
//  Member:     CPeerFactoryUrl::GetBindInfo, per IBindStatusCallback
//
//-------------------------------------------------------------------------

HRESULT
CCodeLoad::GetBindInfo(DWORD * pdwBindf, BINDINFO * pbindinfo)
{
    HRESULT hr;

    hr = THR(super::GetBindInfo(pdwBindf, pbindinfo));
    if (S_OK == hr && _fGetClassObject)
    {
        *pdwBindf |= BINDF_GETCLASSOBJECT;
    }

    RRETURN (hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CCodeLoad::OnProgress, IBindStatusCallback
//
//  Synopsis:   Feedback on code download.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CCodeLoad::OnProgress(ULONG ulPos, ULONG ulMax, ULONG ulCode,
    LPCWSTR pchText)
{
    LPCWSTR pszComponent = NULL;
    ULONG   ulSetProgressFlags;

    if (_pProgSink)
    {
        switch( ulCode )
        {
            case BINDSTATUS_DOWNLOADINGDATA:
            case BINDSTATUS_BEGINDOWNLOADCOMPONENTS:
            case BINDSTATUS_INSTALLINGCOMPONENTS:       
            ulSetProgressFlags = PROGSINK_SET_STATE | PROGSINK_SET_POS | PROGSINK_SET_IDS | PROGSINK_SET_MAX;
            if( pchText )
            {   // Find the component name in the passed in string:
                pszComponent = pchText + wcslen( pchText );
                while( pszComponent > pchText )
                {
                    if( pszComponent[-1] == _T('/') || pszComponent[-1] == _T('\\'))
                    {
                        break;
                    }
                    --pszComponent;
                }
                ulSetProgressFlags |= PROGSINK_SET_TEXT;
            }

            IGNORE_HR(_pProgSink->SetProgress(
              _dwProgCookie,
              ulSetProgressFlags,
              PROGSINK_STATE_LOADING,
              pszComponent,
              IDS_BINDSTATUS_INSTALLINGCOMPONENTS,
              ulPos,
              ulMax ));
            break;
        }
    }

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCodeLoad::OnStartBinding, IBindStatusCallback
//
//  Synopsis:   Feedback on code download.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CCodeLoad::OnStartBinding(DWORD grfBSCOption, IBinding *pbinding)
{
    if (_pSiteOle)
    {
        ReplaceInterface(&_pbinding, pbinding);
    }
    else
    {
        IGNORE_HR(pbinding->Abort());
    }

    return(S_OK);
}

//+---------------------------------------------------------------------------
//
//  Member:     CCodeLoad::OnStopBinding, IBindStatusCallback
//
//  Synopsis:   Feedback on code download.
//
//----------------------------------------------------------------------------

STDMETHODIMP
CCodeLoad::OnStopBinding(HRESULT hrBinding, LPCWSTR szErr)
{
    CLock   Lock(this);

    ClearInterface(&_pbinding);

        if (_pbctx)
        {
        IGNORE_HR(RevokeBindStatusCallback(_pbctx, this));
            ClearInterface(&_pbctx);
        }

    // if error (e.g., download was aborted or failed to find the object)
    if (hrBinding && _pSiteOle)
    {
        // If download failed due to trust violation, inform user.
        if (hrBinding == TRUST_E_FAIL)
        {
            //
            // Don't show dlg for TRUST_E_SUBJECT_NOT_TRUSTED because that
            // is only returned if user chooses no on authenticode dialog.
            // ie4 bug 38366.
            //
            NotifyHaveProtectedUserFromUnsafeContent(_pSiteOle->GetMarkup(), IDS_OCXDISABLED);
        }

        // in stress, _pSiteOle turns up NULL at this point (not sure why - dbau)
        if (_pSiteOle)
        {
            _pSiteOle->ReleaseCodeLoad();
        }
    }

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function    :   AddBindContextParam
//
//  Description :   Adds a CBindContextParam pointer to the bind context as a 
//                  parameter with the key name of BINDCONTEXT_PARAM if none is specified. 
//                  The class contains the base URL of the document and can
//                  contain additional parameters in the future.
//
//----------------------------------------------------------------------------
HRESULT
AddBindContextParam(IBindCtx *pbctx, CStr * pcstr, IPropertyBag * pPropBag, LPTSTR pstrKey /* NULL */)
{
    HRESULT             hr;
    CBindContextParam * pBindContextParam = NULL;

    pBindContextParam = new CBindContextParam();
    if (!pBindContextParam)
    {
        hr = E_OUTOFMEMORY;
        goto Cleanup;
    }

    TraceTag((tagSecurityContext, "AddBindContextParam - URL: %ws", (LPTSTR)(*pcstr)));

    hr = THR(pBindContextParam->Init(pcstr, pPropBag));
    if (hr)
        goto Cleanup;

    if (pstrKey)
        hr = THR(pbctx->RegisterObjectParam(pstrKey, pBindContextParam));
    else
        hr = THR(pbctx->RegisterObjectParam(KEY_BINDCONTEXTPARAM, pBindContextParam));

    if (hr)
        goto Cleanup;

Cleanup:
    if (pBindContextParam)
        pBindContextParam->Release();

    RRETURN (hr);
}

//+---------------------------------------------------------------------------
//  Function    :   GetBindContextParamHelper
//
//----------------------------------------------------------------------------
HRESULT
GetBindContextParam(IBindCtx * pBindCtx, CStr * pcstrSourceUrl)
{
    HRESULT             hr;
    IUnknown *          pUnk = NULL;
    IOleCommandTarget * pCommandTarget = NULL;
    CVariant            varUrl;
    DWORD               dwCmdId = BINDCONTEXT_CMDID_BASEURL;

    Assert(pBindCtx);
    Assert(pcstrSourceUrl);

    //
    // get the CBindContextParam object.
    //
    hr = THR(pBindCtx->GetObjectParam(KEY_BINDCONTEXTPARAM, &pUnk));
    if (hr)
        goto Cleanup;

    pBindCtx->RevokeObjectParam(KEY_BINDCONTEXTPARAM);

    hr = THR(pUnk->QueryInterface(IID_IOleCommandTarget, (void**) &pCommandTarget));
    if (hr)
        goto Cleanup;

//  We are hardcoding the cmdid now, however, if we have other commands in the future 
//      this function should be used with a switch statement and an additional param for the function. 
//  (FerhanE)

    hr = THR(pCommandTarget->Exec(
            &CGID_DownloadObjectBindContext,
            dwCmdId,
            0,
            NULL,
            &varUrl));
    if (hr)
        goto Cleanup;

    // Initialize the CStr with the BSTR 
    hr = THR(pcstrSourceUrl->SetBSTR(V_BSTR(&varUrl)));
    if (hr)
        goto Cleanup;

    TraceTag((tagSecurityContext, "GetBindContextParam - Bind context param URL: %ws", (LPTSTR)*pcstrSourceUrl));

Cleanup:
    ReleaseInterface(pUnk); 
    ReleaseInterface(pCommandTarget);
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Function    :   GetBindInfoParam
//  
//  Description :   
//
//----------------------------------------------------------------------------

#ifdef _WIN64
LWSTDAPI_(BOOL)     StrToInt64ExW(LPCWSTR pszString, DWORD dwFlags, LONGLONG * pllRet);
#endif

HRESULT
GetBindInfoParam( IInternetBindInfo * pIBindInfo, CStr * pcstrSourceUrl)
{
    HRESULT             hr;
    IBindCtx *          pBindCtx = NULL;
    TCHAR *             pchBindCtx = NULL;  // needed for delete 
    DWORD               dwElFetched = 0;
        
    Assert(pIBindInfo);
    Assert(pcstrSourceUrl);

    // get the bind context pointer as a string.
    hr = pIBindInfo->GetBindString(BINDSTRING_PTR_BIND_CONTEXT,
                                    &pchBindCtx, 
                                    0,
                                    &dwElFetched);
    if (hr)
        goto Cleanup;

    // convert the string to an actual pointer
#ifdef _WIN64
    StrToInt64ExW(pchBindCtx, 0, (LONGLONG *)&pBindCtx);
#else
    pBindCtx = (IBindCtx *) StrToInt(pchBindCtx);
#endif
    Assert(pBindCtx);

    hr = THR(GetBindContextParam( pBindCtx, pcstrSourceUrl)); 
    if (hr)
        goto Cleanup;

Cleanup:
    ReleaseInterface(pBindCtx);

// The CoTaskMemFree can crash on WinCE with a NULL pointer(MSDN)(FerhanE)
#ifdef WINCE        
    if (pchBindCtx)                     
#endif
    CoTaskMemFree(pchBindCtx);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     CCodeLoad::BindToObject
//
//  Synopsis:   Start binding to code.
//
//----------------------------------------------------------------------------

HRESULT
CCodeLoad::BindToObject()
{
    HRESULT                     hr;
    CLock                       Lock(this);
    BOOL                        fClearTask = TRUE;
    IClassFactory *             pCF = NULL;
    IMoniker *                  pMk = NULL;
    IUnknown *                  pUnkObject = NULL;
    TCHAR *                     pchUrl;
    COleSite::OLECREATEINFO *   pinfo = &_info;
    IBindStatusCallback *       pBSC;
    CDoc *                      pDoc = _pSiteOle->Doc();

    hr = THR(CreateAsyncBindCtxEx(NULL, 0, NULL, NULL, &_pbctx, 0));
    if (hr)
        goto Cleanup;

    pBSC = this;

#if DBG==1
    pBSC->AddRef();
    DbgTrackItf(IID_IBindStatusCallback, "codlod", TRUE, (void **)&pBSC);
#endif

    hr = THR(RegisterBindStatusCallback(_pbctx, pBSC, NULL, NULL));

#if DBG==1
    pBSC->Release();
#endif

    if (hr && hr != S_FALSE) // S_FALSE returned normally
        goto Cleanup;

    if (!IsEqualGUID(g_Zero.guid, pinfo->clsid) ||    // if clsid is not zero, or
        pinfo->pchMimeType)                           // there is MimeType
    {
        IActiveXSafetyProvider *    pSafetyProvider;

        hr = THR(_pSiteOle->Doc()->GetActiveXSafetyProvider(&pSafetyProvider));
        if (hr)
            goto Cleanup;

        if (pSafetyProvider) {
            //
            // An ActiveXSafetyProvider is installed.  Use it to
            // instantiate controls.
            //
            BOOL    fTreatAsUntrusted;

            hr = THR(_pSiteOle->GetMarkupPtr()->ProcessURLAction(URLACTION_ACTIVEX_TREATASUNTRUSTED,
                &fTreatAsUntrusted));
            if (hr)
                goto Cleanup;

            hr = pSafetyProvider->TreatControlAsUntrusted(fTreatAsUntrusted);
            if (hr)
                goto Cleanup;

            if (_pSiteOle->GetMarkupPtr()->IsPrintMedia() && pDoc->_pPrintSecurityMgr )
            {
                AssertSz(pDoc->IsPrintDialog(), "should never have a print security manager except in a printing dialog!");
                hr = pSafetyProvider->SetSecurityManager(pDoc->_pPrintSecurityMgr);
            }
            else
            {
                hr = pSafetyProvider->SetSecurityManager(pDoc->_pSecurityMgr);
            }
            if (hr)
                goto Cleanup;
            hr = pSafetyProvider->SetDocumentURLW(pDoc->GetPrimaryUrl());
            if (hr)
                goto Cleanup;
        }


        // CONSIDER: (alexz) (anandra) it would be good to have monikers support
        // urls like "clsid:......." - so that MkParseDisplayName would return
        // a moniker on clsid, and BindToObject on that moniker would instantiate
        // the object with the clsid. If that is implemented, then here we would
        // not call CoGetClassObjectFromURL but go instead to pchUrl codepath.

        if (!(pDoc->_dwLoadf & DLCTL_NO_DLACTIVEXCTLS))
        {
            //
            // main case - download of activex controls is allowed
            //

            // Need to ensure that the latest version of the Java VM is installed
            if (pinfo->clsid == CLSID_AppletOCX)
            {
                HWND            hwnd     = NULL;
                CDwnDoc       * pDwnDoc  = GetDwnDoc();
                CDoc          * pDoc     = NULL;
                uCLSSPEC        classpec;

                if (pDwnDoc)
                {
                    pDoc = pDwnDoc->GetCDoc();
                    if (pDoc)
                        hwnd = pDoc->GetHWND();
                }

                classpec.tyspec             = TYSPEC_CLSID;
                classpec.tagged_union.clsid = pinfo->clsid;

                hr = THR(FaultInIEFeatureHelper(hwnd, &classpec, NULL, 0));

                // We don't want to use an older version of the VM
                if (FAILED(hr))
                    goto Cleanup;
            }

            hr =  THR(CoGetClassObjectFromURL(
                        pinfo->clsid,
                        pinfo->pchSourceUrl,
                        pinfo->dwMajorVer,
                        pinfo->dwMinorVer,
                        pinfo->pchMimeType,
                        _pbctx,
                        CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER | CLSCTX_LOCAL_SERVER,
                        NULL,
                        IID_IClassFactory,
                        (void **)&pCF));
        }
        else
        {
            //
            // we are not allowed to download activex control so try to
            // instantiate from local machine (common scenario - in WebCheck)
            //

            if (pSafetyProvider) {
                hr = THR(pSafetyProvider->SafeGetClassObject(
                    pinfo->clsid,
                    CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER | CLSCTX_LOCAL_SERVER,
                    NULL,
                    IID_IClassFactory,
                    (IUnknown **)&pCF));
            } else {
                hr = THR(CoGetClassObject(
                    pinfo->clsid,
                    CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER | CLSCTX_LOCAL_SERVER,
                    NULL,
                    IID_IClassFactory,
                    (void **)&pCF));
            }
        }
    }
    else
    {
        ULONG   cchEaten;
        CStr cstrSpecialURL;
        TCHAR * pchCID;

        if (pinfo->pchClassid)
        {
            pchUrl = pinfo->pchClassid;
            _fGetClassObject = TRUE;
        }
        else
        {
            pchUrl = pinfo->pchDataUrl;
        }

        // since the UrlCompare also calls this, it is not a problem to call it here.
        // we need it to protect against cases where .HTA can be written as .ht%61
        hr = THR(UrlUnescape( pchUrl, NULL, NULL, URL_UNESCAPE_INPLACE));
        if (hr)
            goto Cleanup;

        // Binding to an HTA in this manner is a security hole.
        if (!pchUrl || !StrCmpI(PathFindExtension(pchUrl), _T(".HTA")))
            goto Cleanup;

        // we don't want to continue if the URL we have is the same
        // with the Urls of any of the parent documents.
        if (_pSiteOle->IsInMarkup())
        {                         
            if (_pSiteOle->GetMarkup()->IsUrlRecursive(pchUrl))
                goto Cleanup;
        }

        hr = E_FAIL;

        // do not allow code objects in OE mail
        if (_tcsnipre( _T("mhtml:"), 6, pchUrl,  -1))
        {
            pchCID = _tcschr(pchUrl, _T('!'));
            if (pchCID)
            {
                pchCID++;
                if (_tcsnipre( _T("cid:"), 4, pchCID,  -1))
                    goto Cleanup;
            }
        }

        //
        // First try MkParseDisplayName because MkParseDisplayNameEx
        // seems to have a bug in it where it doesn't forward to
        // MkParseDisplayName.  This is needed for TracySh's java:
        // moniker.  Look at ie4 bug 45662.  (anandra)
        //
        if (!_tcsnipre( _T("file:"), 5, pchUrl,  -1))
            hr = THR_NOTRACE(MkParseDisplayName(_pbctx, pchUrl, &cchEaten, &pMk));
        if (hr)
        {
            hr = THR(MkParseDisplayNameEx(_pbctx, pchUrl, &cchEaten, &pMk));
            if (hr)
                goto Cleanup;
        }

        TCHAR * pchBaseUrl;
        CStr    cstrBindCtxUrl;
            
        hr = THR(CMarkup::GetBaseUrl(NULL, &pchBaseUrl, _pSiteOle));
        hr = THR(cstrBindCtxUrl.Set(pchBaseUrl));
        if (hr) 
            goto Cleanup;

        hr = THR(AddBindContextParam(_pbctx, &cstrBindCtxUrl, _info.pPropBag));
        if (hr)
            goto Cleanup;


        hr = THR(pMk->BindToObject(
                _pbctx,
                NULL,
                IID_IUnknown,
                (void **)&pUnkObject));
        if (!OK(hr))
            goto Cleanup;
    }

    if (S_OK == hr)
    {
        //
        // the object is immediately available, signal OnObjectAvailable
        //

        if (pCF)
        {
            hr = THR(OnObjectAvailable(IID_IClassFactory, pCF));
        }
        else
        {
            Assert(pUnkObject);
            hr = THR(OnObjectAvailable(IID_IUnknown, pUnkObject));
        }
    }
    else if (MK_S_ASYNCHRONOUS == hr)
    {
        //
        // Block this task until OnObjectAvailable
        //

        fClearTask = FALSE;
    }
    else if (TRUST_E_FAIL == hr)
    {
            NotifyHaveProtectedUserFromUnsafeContent(_pSiteOle->GetMarkup(), IDS_OCXDISABLED);
    }


Cleanup:
    ReleaseInterface (pCF);
    ReleaseInterface (pMk);
    ReleaseInterface (pUnkObject);

    //
    // Clear up internal state in the case where the class
    // factory is already available.
    //

    if (fClearTask && _pbctx)
    {
        IGNORE_HR(RevokeBindStatusCallback(_pbctx, this));
    }

    RRETURN1(hr, MK_S_ASYNCHRONOUS);
}

///////////////////////////////////////////////////////////////////////////////////////////
//
// CBindContextParam methods
//
//

CBindContextParam::CBindContextParam()
{
    _ulRefs = 1;
    _pPropBag = NULL;
}

CBindContextParam::~CBindContextParam()
{
    if(_pPropBag)
        _pPropBag->Release();
}

HRESULT
CBindContextParam::QueryInterface(REFIID iid, void ** ppv)
{
    switch (iid.Data1)
    {
        QI_INHERITS(this, IUnknown)
        QI_INHERITS(this, IOleCommandTarget)

    default:
        *ppv = NULL;
        RRETURN (E_NOINTERFACE);
    }

    AddRef();
    return S_OK;
}

HRESULT
CBindContextParam::Init(CStr * pcstrData, IPropertyBag * pPropBag)
{
    Assert(pcstrData);
    
    ReplaceInterface(&_pPropBag, pPropBag);

    RRETURN(THR(_cstrBaseUrl.Set((LPTSTR)(*pcstrData))));
}

HRESULT
CBindContextParam::Exec(
    const GUID *    pguidCmdGroup,
    DWORD           nCmdID,
    DWORD           nCmdexecopt,
    VARIANT *       pvarIn,
    VARIANT *       pvarOut)
{
    HRESULT hr = S_OK;

    if (IsEqualGUID(*pguidCmdGroup, CGID_DownloadObjectBindContext))
    {
        if (!pvarOut)
        {
            hr = E_POINTER;
            goto Cleanup;
        }

        switch (nCmdID)
        {
        case BINDCONTEXT_CMDID_BASEURL:
            // *** external dependency: also called from shdocvw ***
            V_VT(pvarOut) = VT_BSTR;
            hr = THR(FormsAllocString(_cstrBaseUrl, &V_BSTR(pvarOut)));
            break;

        case BINDCONTEXT_CMDID_PROPBAG:
            if (_pPropBag)
            {
                V_VT(pvarOut) = VT_UNKNOWN;
                V_UNKNOWN(pvarOut) = _pPropBag;
                _pPropBag->AddRef();
                break;
            }

            // Fall thru

        default:
            hr = OLECMDERR_E_NOTSUPPORTED;
            break;
        }
    }
    else
    {
        hr = OLECMDERR_E_UNKNOWNGROUP;
    }

Cleanup:
    RRETURN (hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\ole\oleobj.cxx ===
//+------------------------------------------------------------------------
//
//  File:       oleobj.cxx
//
//  Contents:   COleSite::CObject implementation.
//
//
//	History:	
//				5-22-95		kfl		converted WCHAR to TCHAR
//-------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

IMPLEMENT_FORMS_SUBOBJECT_IUNKNOWN(COleSite::CObject, COleSite, _Object)

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CObject::GetDispatch
//
//  Synopsis:   Fetch the IDispatch pointer of the embedded control.
//
//  Returns:    NULL if not available.
//
//----------------------------------------------------------------------------

IDispatch *
COleSite::CObject::GetDispatch()
{
    if (IsMyParentAlive())
    {
        return MyCOleSite()->_pDisp;
    }
    else
    {
        return NULL;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CObject::QueryInterface, IUnknown
//
//  Synopsis:   As per IUnknown
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CObject::QueryInterface(REFIID iid, void **ppv)
{
    if (iid == IID_IDispatch || iid == IID_IUnknown)
    {
        *ppv = (IDispatch *)this;
    }
    else
    {
        *ppv = 0;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CObject::GetTypeInfoCount, IDispatch
//
//  Synopsis:   As per IDispatch
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CObject::GetTypeInfoCount(UINT * pctinfo)
{
    IDispatch *pDisp = GetDispatch();

    RRETURN(!pDisp ? E_FAIL : pDisp->GetTypeInfoCount(pctinfo));
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CObject::GetIDsOfNames, IDispatch
//
//  Synopsis:   As per IDispatch
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CObject::GetIDsOfNames(
        REFIID          iid,
        LPTSTR *        rgszNames,
        UINT            cNames,
        LCID            lcid,
        DISPID FAR*     rgdispid)
{
    IDispatch *pDisp = GetDispatch();
    RRETURN(!pDisp ? E_FAIL : pDisp->GetIDsOfNames(
            iid,
            rgszNames,
            cNames,
            lcid,
            rgdispid));
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CObject::Invoke, IDispatch
//
//  Synopsis:   As per IDispatch
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CObject::Invoke(
        DISPID          dispidMember,
        REFIID          iid,
        LCID            lcid,
        WORD            wFlags,
        DISPPARAMS *    pdispparams,
        VARIANT *       pvarResult,
        EXCEPINFO *     pexcepinfo,
        UINT *          puArgErr)
{
    IDispatch *pDisp = GetDispatch();
    RRETURN(!pDisp ? E_FAIL : pDisp->Invoke(
            dispidMember,
            iid,
            lcid,
            wFlags,
            pdispparams,
            pvarResult,
            pexcepinfo,
            puArgErr));
}

STDMETHODIMP
COleSite::CObject::GetTypeInfo(
        UINT         itinfo,
        LCID         lcid,
        ITypeInfo ** pptinfo)
{
    IDispatch *pDisp = GetDispatch();
    RRETURN(!pDisp ? E_FAIL : pDisp->GetTypeInfo(
            itinfo,
            lcid,
            pptinfo));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\ole\oleclnt.cxx ===
//+---------------------------------------------------------------------------
//
//   File:      oleclnt.cxx
//
//  Contents:   True client site to embeddings.
//
//----------------------------------------------------------------------------

#include "headers.hxx"

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_DOCGLBS_HXX_
#define X_DOCGLBS_HXX_
#include "docglbs.hxx"
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include "formkrnl.hxx"
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include "elemdb.hxx"
#endif

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include "binder.hxx"
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_VBCURSOR_OCDB_H_
#define X_VBCURSOR_OCDB_H_
#include <vbcursor/ocdb.h>
#endif

#ifndef X_VBCURSOR_VBDSC_H_
#define X_VBCURSOR_VBDSC_H_
#include <vbcursor/vbdsc.h>
#endif

#ifndef X_VBCURSOR_OLEBIND_H_
#define X_VBCURSOR_OLEBIND_H_
#include <vbcursor/olebind.h>
#endif

#ifndef X_SHELL_H_
#define X_SHELL_H_
#include <shell.h>
#endif

#ifndef X_QI_IMPL_H_
#define X_QI_IMPL_H_
#include "qi_impl.h"
#endif

#ifndef X_ROOTELEM_HXX
#define X_ROOTELEM_HXX
#include "rootelem.hxx"
#endif

#ifndef X_OLELYT_HXX_
#define X_OLELYT_HXX_
#include "olelyt.hxx"
#endif

#ifndef X_MSDATSRC_H_
#define X_MSDATSRC_H_
#include <msdatsrc.h>
#endif

#ifndef X_DISPNODE_HXX_
#define X_DISPNODE_HXX_
#include "dispnode.hxx"
#endif

#ifndef X_OTHRGUID_H_
#define X_OTHRGUID_H_
#include "othrguid.h"
#endif

PerfDbgExtern(tagDocPaint)
DeclareTagOther(tagOleSiteClientNoWindowless, "OleSite", "Disable windowless inplace activation")
DeclareTag(tagOleSiteClient, "OleSite", "OleSiteClient methods");
ExternTag(tagOleSiteRect);

// to make all QI_TEAROFFs directed to global function CreateTearOffThunk instead of attempt
// to use COleSite::CreateTearOffThunk inherited from CElement
#define CreateTearOffThunk ::CreateTearOffThunk

BEGIN_TEAROFF_TABLE_SUB_(COleSite, CClient, IOleInPlaceSiteWindowless)
    // IOleWindow
    TEAROFF_METHOD_SUB(COleSite, CClient, GetWindow, getwindow, (HWND *phwnd))
    TEAROFF_METHOD_SUB(COleSite, CClient, ContextSensitiveHelp, contextsensitivehelp, (BOOL fEnterMode))
    // IOleInPlaceSite
    TEAROFF_METHOD_SUB(COleSite, CClient, CanInPlaceActivate, caninplaceactivate, ())
    TEAROFF_METHOD_SUB(COleSite, CClient, OnInPlaceActivate, oninplaceactivate, ())
    TEAROFF_METHOD_SUB(COleSite, CClient, OnUIActivate, onuiactivate, ())
    TEAROFF_METHOD_SUB(COleSite, CClient, GetWindowContext, getwindowcontext, (IOleInPlaceFrame **ppFrame, IOleInPlaceUIWindow **ppDoc, LPOLERECT lprcPosRect, LPOLERECT lprcClipRect, LPOLEINPLACEFRAMEINFO lpFrameInfo))
    TEAROFF_METHOD_SUB(COleSite, CClient, Scroll, scroll, (OLESIZE scrollExtant))
    TEAROFF_METHOD_SUB(COleSite, CClient, OnUIDeactivate, onuideactivate, (BOOL fUndoable))
    TEAROFF_METHOD_SUB(COleSite, CClient, OnInPlaceDeactivate, oninplacedeactivate, ())
    TEAROFF_METHOD_SUB(COleSite, CClient, DiscardUndoState, discardundostate, ())
    TEAROFF_METHOD_SUB(COleSite, CClient, DeactivateAndUndo, deactivateandundo, ())
    TEAROFF_METHOD_SUB(COleSite, CClient, OnPosRectChange, onposrectchange, (LPCOLERECT lprcPosRect))
    // IOleInPlaceSiteEx
    TEAROFF_METHOD_SUB(COleSite, CClient, OnInPlaceActivateEx, oninplaceactivateex, (BOOL *, DWORD))
    TEAROFF_METHOD_SUB(COleSite, CClient, OnInPlaceDeactivateEx, oninplacedeactivateex, (BOOL))
    TEAROFF_METHOD_SUB(COleSite, CClient, RequestUIActivate, requestuiactivate, ())
    // IOleInPlaceSiteWindowless
    TEAROFF_METHOD_SUB(COleSite, CClient, CanWindowlessActivate, canwindowlessactivate, ())
    TEAROFF_METHOD_SUB(COleSite, CClient, GetCapture, getcapture, ())
    TEAROFF_METHOD_SUB(COleSite, CClient, SetCapture, setcapture, (BOOL fCapture))
    TEAROFF_METHOD_SUB(COleSite, CClient, GetFocus, getfocus, ())
    TEAROFF_METHOD_SUB(COleSite, CClient, SetFocus, setfocus, (BOOL fFocus))
    TEAROFF_METHOD_SUB(COleSite, CClient, GetDC, getdc, (LPCRECT prc, DWORD grfFlags, HDC *phDC))
    TEAROFF_METHOD_SUB(COleSite, CClient, ReleaseDC, releasedc, (HDC hdc))
    TEAROFF_METHOD_SUB(COleSite, CClient, InvalidateRect, invalidaterect, (LPCRECT prc, BOOL fErase))
    TEAROFF_METHOD_SUB(COleSite, CClient, InvalidateRgn, invalidatergn, (HRGN hrgn, BOOL fErase))
    TEAROFF_METHOD_SUB(COleSite, CClient, ScrollRect, scrollrect, (int dx, int dy, LPCRECT prcScroll, LPCRECT prcClip))
    TEAROFF_METHOD_SUB(COleSite, CClient, AdjustRect, adjustrect, (LPRECT prc))
    TEAROFF_METHOD_SUB(COleSite, CClient, OnDefWindowMessage, ondefwindowmessage, (UINT msg, WPARAM wParam, LPARAM lParam, LRESULT* plResult))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(COleSite, CClient, IOleControlSite)
    TEAROFF_METHOD_SUB(COleSite, CClient, OnControlInfoChanged, oncontrolinfochanged, ())
    TEAROFF_METHOD_SUB(COleSite, CClient, LockInPlaceActive, lockinplaceactive, (BOOL fLock))
    TEAROFF_METHOD_SUB(COleSite, CClient, GetExtendedControl, getextendedcontrol, (IDispatch ** ppDisp))
    TEAROFF_METHOD_SUB(COleSite, CClient, TransformCoords, transformcoords, (POINTL * lpptlHimetric, POINTF * lpptfContainer, DWORD flags))
    TEAROFF_METHOD_SUB(COleSite, CClient, TranslateAccelerator, translateaccelerator, (LPMSG lpMsg, DWORD grfModifiers))
    TEAROFF_METHOD_SUB(COleSite, CClient, OnFocus, onfocus, (BOOL fGotFocus))
    TEAROFF_METHOD_SUB(COleSite, CClient, ShowPropertyFrame, showpropertyframe, ())
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(COleSite, CClient, IDispatch)
    TEAROFF_METHOD_SUB(COleSite, CClient, GetTypeInfoCount, gettypeinfocount, (UINT * pctinfo))
    TEAROFF_METHOD_SUB(COleSite, CClient, GetTypeInfo, gettypeinfo, (UINT, ULONG, ITypeInfo**))
    TEAROFF_METHOD_SUB(COleSite, CClient, GetIDsOfNames, getidsofnames, (REFIID riid, LPTSTR * rgszNames, UINT cNames, LCID lcid, DISPID * rgdispid))
    TEAROFF_METHOD_SUB(COleSite, CClient, Invoke, invoke, (DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS * pdispparams, VARIANT * pvarResult, EXCEPINFO * pexcepinfo, UINT * puArgErr))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(COleSite, CClient, IOleCommandTarget)
    TEAROFF_METHOD_SUB(COleSite, CClient, QueryStatus, querystatus, (GUID *pguidCmdGroup, ULONG cCmds, MSOCMD rgCmds[], MSOCMDTEXT *pcmdText))
    TEAROFF_METHOD_SUB(COleSite, CClient, Exec, exec, (GUID *pguidCmdGroup, DWORD nCmdID, DWORD nCmdexecopt, VARIANTARG *pvarargIn, VARIANTARG *pvarargOut))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(COleSite, CClient, IServiceProvider)
    TEAROFF_METHOD_SUB(COleSite, CClient, QueryService, queryservice, (REFGUID guidService, REFIID iid, void ** ppv))
END_TEAROFF_TABLE()

#ifndef NO_DATABINDING
BEGIN_TEAROFF_TABLE_SUB_(COleSite, CClient, IBoundObjectSite)
    TEAROFF_METHOD_SUB(COleSite, CClient, GetCursor, getcursor, (DISPID dispid, ICursor **ppCursor, LPVOID FAR* ppcidOut))
END_TEAROFF_TABLE()
#endif // ndef NO_DATABINDING

BEGIN_TEAROFF_TABLE_SUB_(COleSite, CClient, IBindHost)
    TEAROFF_METHOD_SUB(COleSite, CClient, CreateMoniker, createmoniker,
        (LPOLESTR szName, IBindCtx * pbc, IMoniker ** ppmk, DWORD dwReserved))
    TEAROFF_METHOD_SUB(COleSite, CClient, MonikerBindToStorage, monikerbindtostorage,
        (IMoniker * pmk, IBindCtx * pbc, IBindStatusCallback * pbsc, REFIID riid, void ** ppvObj))
    TEAROFF_METHOD_SUB(COleSite, CClient, MonikerBindToObject, monikerbindtoobject,
        (IMoniker * pmk, IBindCtx * pbc, IBindStatusCallback * pbsc, REFIID riid, void ** ppvObj))
END_TEAROFF_TABLE()

BEGIN_TEAROFF_TABLE_SUB_(COleSite, CClient, ISecureUrlHost)
    TEAROFF_METHOD_SUB(COleSite, CClient, ValidateSecureUrl, validatesecureurl,
        (BOOL* fAllow, OLECHAR* pchUrlInQuestion, DWORD dwFlags))
END_TEAROFF_TABLE()

EXTERN_C const IID IID_IHTMLDialog;

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::AddRef, IUnknown
//
//  Synopsis:   Private IUnknown implementation.
//
//----------------------------------------------------------------------------

ULONG
COleSite::CClient::AddRef()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::AddRef SSN=0x%x ulRefs=%ld", MyOleSite()->_ulSSN, ++_ulRefsLocal));

    return MyOleSite()->SubAddRef();
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::Release, IUnknown
//
//  Synopsis:   Private IUnknown implementation.
//
//----------------------------------------------------------------------------

ULONG
COleSite::CClient::Release()
{
    Assert(_ulRefsLocal > 0);
    TraceTag((tagOleSiteClient, "COleSite::CClient::Release SSN=0x%x ulRefs=%ld", MyOleSite()->_ulSSN, --_ulRefsLocal));

    return MyOleSite()->SubRelease();
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::QueryInterface, IUnknown
//
//  Synopsis:   Private IUnknown implementation.
//
//----------------------------------------------------------------------------

HRESULT
COleSite::CClient::QueryInterface(REFIID iid, void **ppv)
{
    if (ppv)
        *ppv = NULL;

    if (MyOleSite()->IllegalSiteCall(0))
        RRETURN(E_UNEXPECTED);

#if DBG==1
    char * pszTearoff = NULL, * pszInherit = NULL;
    if (iid == IID_IUnknown)                        pszInherit = "IUnknown";
    else if (iid == IID_IAdviseSinkEx)              pszInherit = "IAdviseSinkEx";
    else if (iid == IID_IAdviseSink)                pszInherit = "IAdviseSink";
    else if (iid == IID_IOleClientSite)             pszInherit = "IOleClientSite)";
    else if (iid == IID_IPropertyNotifySink)        pszInherit = "IPropertyNotifySink";
    else if (iid == IID_IDispatch)                  pszTearoff = "IDispatch";
    else if (iid == IID_IOleControlSite)            pszTearoff = "IOleControlSite";
    else if (iid == IID_IOleWindow)                 pszTearoff = "IOleWindow";
    else if (iid == IID_IOleInPlaceSite)            pszTearoff = "IOleInPlaceSite";
    else if (iid == IID_IOleInPlaceSiteWindowless)  pszTearoff = "IOleInPlaceSiteWindowless";
    else if (iid == IID_IOleInPlaceSiteEx)          pszTearoff = "IOleInPlaceSiteEx";
    else if (iid == IID_IOleCommandTarget)          pszTearoff = "IOleCommandTarget";
    else if (iid == IID_IServiceProvider)           pszTearoff = "IServiceProvider";
    else if (iid == IID_IBindHost)                  pszTearoff = "IBindHost";
    else if (iid == IID_IBoundObjectSite)           pszTearoff = "IBoundObjectSite";
    else if (iid == IID_ISecureUrlHost)             pszTearoff = "ISecureUrlHost";
    else                                            pszInherit = "(Unknown IID)";
    TraceTag((tagOleSiteClient, "COleSite::CClient::QueryInterface %s %s%s",
              pszTearoff ? "(Tearoff)" : "(Inherit)", pszTearoff ? pszTearoff : "",
              pszInherit ? pszInherit : ""));
#endif

    *ppv = NULL;
    switch (iid.Data1)
    {
        QI_INHERITS((IPrivateUnknown *) this, IUnknown)
#if 0 // IEUNIX
        QI_INHERITS2(this, IUnknown, IOleClientSite) // IEUNIX don't cast to IPrivateUnknown, because we don't implement that
#endif
        QI_INHERITS(this, IAdviseSinkEx)
        QI_INHERITS2(this, IAdviseSink, IAdviseSinkEx)
        QI_INHERITS2(this, IAdviseSink2, IAdviseSinkEx)
        QI_INHERITS(this, IOleClientSite)
#ifndef NO_DATABINDING
        QI_INHERITS(this, IPropertyNotifySink)
#endif // ndef NO_DATABINDING
        QI_TEAROFF(this, IDispatch, (IOleClientSite *)this)
        QI_TEAROFF(this, IOleControlSite, (IOleClientSite *)this)
        QI_TEAROFF2(this, IOleWindow, IOleInPlaceSiteWindowless, (IOleClientSite *)this)
        QI_TEAROFF2(this, IOleInPlaceSite, IOleInPlaceSiteWindowless, (IOleClientSite *)this)
        QI_TEAROFF(this, IOleInPlaceSiteWindowless, (IOleClientSite *)this)
        QI_TEAROFF2(this, IOleInPlaceSiteEx, IOleInPlaceSiteWindowless, (IOleClientSite *)this)
        QI_TEAROFF(this, IOleCommandTarget, (IOleClientSite *)this)
        QI_TEAROFF(this, IServiceProvider, (IOleClientSite *)this)
        QI_TEAROFF(this, IBindHost, (IOleClientSite*)this)
#ifndef NO_DATABINDING
        QI_TEAROFF(this, IBoundObjectSite, (IOleClientSite *)this)
#endif // ndef NO_DATABINDING
        QI_TEAROFF(this, ISecureUrlHost, (IOleClientSite *)this)
    }

    if (!*ppv)
    {
        // HACK for getting pWindowParent hooked up for scriptlets in native frames!
        if (IsEqualIID(iid, CLSID_HTMLWindow2))
        {
            if (MyOleSite()->HasMarkupPtr())
            {
                CMarkup * pMarkup = MyOleSite()->GetMarkup()->GetWindowedMarkupContext();

                Assert(pMarkup);

                COmWindowProxy *pOmWndProxy = pMarkup->Window();

                if (pOmWndProxy)
                {
                    *ppv = pOmWndProxy->Window();
                    return S_OK;
                }
            }
        }

        TraceTag((tagOleSiteClient, "COleSite::CClient::QueryInterface --> E_NOINTERFACE"));
        RRETURN_NOTRACE(E_NOINTERFACE);
    }

    (*(IUnknown **)ppv)->AddRef();

    TraceTag((tagOleSiteClient, "COleSite::CClient::QueryInterface --> %08lX", *ppv));

#if DBG==1
    if (pszTearoff)
    {
        MemSetName((*ppv, "COleSite::CClient::QI %s", pszTearoff));
    }
#endif

    DbgTrackItf(iid, "CClient", FALSE, ppv);
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::SaveObject, IOleClientSite
//
//  Synopsis:   Object is asking us to save it
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::SaveObject()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::SaveObject SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED))
        RRETURN(E_UNEXPECTED);

    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::GetMoniker, IOleClientSite
//
//  Synopsis:   Answer the specified moniker
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, LPMONIKER FAR* ppmk)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::GetMoniker SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_ATTACHED))
        RRETURN(E_UNEXPECTED);

    HRESULT hr;

    switch (dwWhichMoniker)
    {
    case OLEWHICHMK_CONTAINER:
        {
            CMarkup * pMarkup = MyOleSite()->GetMarkup();

            if (    pMarkup
                &&  !pMarkup->IsPrimaryMarkup())
            {
                hr = THR(CreateURLMoniker(NULL, CMarkup::GetUrl(pMarkup), ppmk));
            }
            else
            {
                hr = THR_NOTRACE(Doc()->GetMoniker(dwAssign, OLEWHICHMK_OBJFULL, ppmk));
            }
        }

        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    RRETURN_NOTRACE(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::GetContainer, IOleClientSite
//
//  Synopsis:   Answer pointer to IOleContainer (if supported)
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::GetContainer(LPOLECONTAINER FAR* ppContainer)
{
    HRESULT hr;

    TraceTag((tagOleSiteClient, "COleSite::CClient::GetContainer SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_ATTACHED | VALIDATE_DOC_ALIVE))
        RRETURN(E_UNEXPECTED);

    if (MyOleSite()->IsInMarkup())
    {
        CMarkup * pMarkup = MyOleSite()->GetMarkup();

        if (pMarkup->HasWindow())
        {
            hr = THR(pMarkup->Document()->QueryInterface(IID_IOleContainer, (void **)ppContainer));
            goto Cleanup;
        }
    }
    hr = THR(Doc()->QueryInterface(IID_IOleContainer, (void **)ppContainer));
    DbgTrackItf(IID_IOleContainer, "GetContainer", TRUE, (void **)ppContainer);

Cleanup:
    RRETURN(hr);

}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::ShowObject, IOleClientSite
//
//  Synopsis:   Asks container to show itself (and object at this site)
//
//  Notes:  This method is called during the binding process to
//          a link source. The code was launched either:
//              a) with /Embedding, in which case it will
//                 be waiting to show itself and this or DoVerb(SHOW)
//                 will be the ocassion for doing so
//              b) without /Embedding, in which case it will have registered
//                 via CoRegisterClassObject and will already be
//                 visible: this method now means "bring the link
//                 source into view".
//
//          If this object is in turn embedded in another container,
//          it should (recursively) call this same method on it's
//          client site...
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::ShowObject()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::ShowObject SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED))
        RRETURN(E_UNEXPECTED);

#ifdef WISH_THAT_ACTIVEX_CTLS_WERENT_SO_STUPID
    //
    // The webbrowser oc as well as the marcwan (basectl) framework
    // call ShowObject while inplace-activating.  This makes no sense
    // for ocx's to do this at this juncture so bail out immediately.
    //
    // Also, bail out right now if the ocx is not inplace yet.  The ppt
    // viewer ocx extraordinaire calls ShowObject in the middle of
    // SetClientSite!  We don't have any code anyway for inside-out
    // inplace activation.
    //
    // IE3 didn't implement this method anyway, so there should be
    // no ill effects here. (anandra)
    //

    if (MyOleSite()->TestLock(COleSite::OLESITELOCK_INPLACEACTIVATE) ||
        MyOleSite()->State() < OS_INPLACE)
    {
        return S_OK;
    }

    //
    // If we're scrolling then we better not be in the middle of sizing
    // or positioning.  I.e. before we can scroll we need to know how big
    // and where we are!!
    //

    Assert(!MyOleSite()->TestLock(ELEMENTLOCK_SIZING) &&
           !MyOleSite()->TestLock(ELEMENTLOCK_POSITIONING));

    RRETURN(MyOleSite()->ScrollIntoView());
#else
    return S_OK;
#endif
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnShowWindow, IOleClientSite
//
//  Synopsis:   Informs container (us) about object Show/Hide events
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::OnShowWindow(BOOL fShow)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnShowWindow SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED))
        RRETURN(E_UNEXPECTED);

    OLE_SERVER_STATE stateNew = MyOleSite()->State();

    if (fShow)
    {
        stateNew = OS_OPEN;
    }
    else if (MyOleSite()->_state > OS_RUNNING)
    {
        stateNew = OS_RUNNING;
    }

    if (MyOleSite()->State() != stateNew)
    {
        MyOleSite()->_state = stateNew;
        MyOleSite()->GetUpdatedLayout()->Invalidate();
    }
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::RequestNewObjectLayout, IOleClientSite
//
//  Synopsis:
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::RequestNewObjectLayout( )
{
    HRESULT     hr;
    IOleObject *pOleObject = NULL;
    SIZEL       sizel;
    SIZE        size;
    CRect       rcBounds;
    CRect       rcClient;

// If we are in the midst of recalculating the size, ignore this call.
    if (MyOleSite()->CElement::TestLock(ELEMENTLOCK_RECALC))
        return S_OK;

    COleLayout * pLayout = DYNCAST(COleLayout, MyOleSite()->GetUpdatedLayout());
    Assert(pLayout);

    TraceTag((tagOleSiteClient, "COleSite::CClient::RequestNewObjectLayout SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED))
    {
        hr = E_UNEXPECTED;
        goto Cleanup;
    }

    //
    // Ask the object how big it wants to be and stuff the info into
    // the width/height attributes.
    //

    hr = THR_NOTRACE(MyOleSite()->QueryControlInterface(IID_IOleObject, (void **)&pOleObject));
    if (hr)
        goto Cleanup;

    //
    // Transition to the running state because GetExtent can fail
    // if not OS_RUNNING.
    //

    hr = THR(MyOleSite()->TransitionTo(OS_RUNNING));
    if (hr)
        goto Cleanup;

    hr = THR_OLE(pOleObject->GetExtent(DVASPECT_CONTENT, &sizel));
    if (hr)
        goto Cleanup;

    Doc()->GetView()->GetMeasuringDevice(mediaTypeNotSet)->DeviceFromHimetric(size, sizel);

    pLayout->GetRect(&rcBounds);
    pLayout->GetClientRect(&rcClient, COORDSYS_PARENT);

    rcBounds.right  = rcBounds.left + (rcBounds.Width()  - rcClient.Width())  + size.cx;
    rcBounds.bottom = rcBounds.top  + (rcBounds.Height() - rcClient.Height()) + size.cy;

    hr = THR(pLayout->Move(&rcBounds, SITEMOVE_RESIZEONLY));
    if (hr)
        goto Cleanup;

    MyOleSite()->ResizeElement();

Cleanup:
    ReleaseInterface(pOleObject);
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::GetWindow, IOleWindow
//
//  Synopsis:   Answer containing window handle
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::GetWindow(HWND * phwnd)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::GetWindow SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_ATTACHED | VALIDATE_DOC_ALIVE))
        RRETURN(E_UNEXPECTED);

    RRETURN(Doc()->GetWindow(phwnd));
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::ContextSensitiveHelp, IOleWindow
//
//  Synopsis:   Notifies enter/exit CSH mode
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::ContextSensitiveHelp(BOOL fEnterMode)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::ContextSensitiveHelp SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED | VALIDATE_DOC_INPLACE))
        RRETURN(E_UNEXPECTED);

    RRETURN(Doc()->_pInPlace->_pInPlaceSite->ContextSensitiveHelp(fEnterMode));
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::CanInPlaceActivate, IOleInPlaceSite
//
//  Synopsis:   Answer wether or not object can IPActivate
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::CanInPlaceActivate()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::CanInPlaceActivate SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(0))
        RRETURN(E_UNEXPECTED);

    return S_OK;     // we always allow in-place activation
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnInPlaceActivate, IOleInPlaceSite
//
//  Synopsis:   Notifies container (us) of object activation
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::OnInPlaceActivate()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnInPlaceActivate SSN=0x%x", MyOleSite()->_ulSSN));

    RRETURN(THR_OLEO(OnInPlaceActivateEx(NULL, 0),MyOleSite()));
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnInPlaceActivateEx, IOleInPlaceSiteEx
//
//  Synopsis:   Notifies container (us) of object activation
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::OnInPlaceActivateEx(BOOL *pfNoRedraw, DWORD dwFlags)
{
    HRESULT hr;
    RECT    rcUpdate;
    RECT    rcSite;
    CDoc *  pDoc = Doc();

    TraceTag((tagOleSiteClient, "COleSite::CClient::OnInPlaceActivateEx SSN=0x%x", MyOleSite()->_ulSSN));

    //
    // Don't allow inplace activation if the site is not loaded yet
    // or if the doc is not at least inplace active.
    //

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED | VALIDATE_DOC_INPLACE ))
        RRETURN(E_UNEXPECTED);

    TraceTag((tagCDoc, "COleSite::CClient::OnInPlaceActivate %x", this));

    Assert(MyOleSite()->_pInPlaceObject == 0);

    // handle the above assert failing. If this site is already inplace, return S_OK.
    // This situation should never happen, but Adobe's Acrobat control does this.
    if (MyOleSite()->_pInPlaceObject != 0)
    {
        Assert(MyOleSite()->State() >= OS_INPLACE);
        return S_OK;
    }
        
    if (dwFlags & ACTIVATE_WINDOWLESS)
    {
        hr = THR_OLEO(MyOleSite()->QueryControlInterface(
                IID_IOleInPlaceObjectWindowless,
                (void **) &MyOleSite()->_pInPlaceObject),MyOleSite());
        if (hr)
            goto Cleanup;

        MyOleSite()->_fWindowlessInplace = TRUE;
        MyOleSite()->_fUseInPlaceObjectWindowless = TRUE;
    }
    else
    {
        hr = THR_OLEO(MyOleSite()->QueryControlInterface(
                IID_IOleInPlaceObject,
                (void **) &MyOleSite()->_pInPlaceObject),MyOleSite());
        if (hr)
            goto Cleanup;
    }

    MyOleSite()->_state = OS_INPLACE;

    // Adjust z-order of all HWNDs within the document and transparency of the associated display node (if any)

    if (!pDoc->_fInPlaceActivating && !MyOleSite()->_fWindowlessInplace)
    {
        HWND hwndPar = pDoc->_pInPlace->_hwnd;
        HWND hwndCtl = MyOleSite()->GetHwnd();
        CLayout *   pLayout   = MyOleSite()->GetUpdatedLayout(GUL_USEFIRSTLAYOUT);
        CDispNode * pDispNode = pLayout
                                    ? pLayout->GetElementDispNode()
                                    : NULL;

        if (hwndCtl)
        {
            if (GetParent(hwndCtl) == hwndPar)
            {
                pDoc->FixZOrder();
            }

            if (    pDispNode
                &&  pDispNode->IsOpaque()
                &&  ::GetWindowLong(hwndCtl, GWL_EXSTYLE) & WS_EX_TRANSPARENT)
            {
                MyOleSite()->ResizeElement();
            }
        }
    }

    if (pfNoRedraw)
    {
        // If the baseline state is OS_INPLACE then IVO::Draw() won't, so we
        // have to have them draw themselves during this activation process.
        *pfNoRedraw = (MyOleSite()->BaselineState(OS_INPLACE) != OS_INPLACE);

        // If the control is windowless, then the normal window invalidation
        // mechanism will take care of getting the bits on the screen correct.
        // If the control has a window, then we need to tell the object if
        // it needs to invalidate or not.

        if (!MyOleSite()->_fWindowlessInplace)
        {
            // If the form's update rect intersects the site, then
            // redraw is required.

            if (GetUpdateRect(pDoc->_pInPlace->_hwnd, &rcUpdate, FALSE))
            {
                CLayout * pLayout   = MyOleSite()->GetUpdatedLayout();

                if (pLayout)
                {
                    pLayout->GetRect(&rcSite, COORDSYS_GLOBAL);
                    if (IntersectRect(&rcSite, &rcSite, &rcUpdate))
                    {
                        *pfNoRedraw = FALSE;
                    }
                }
            }

            if (*pfNoRedraw)
            {
                *pfNoRedraw = !MyOleSite()->ActivationChangeRequiresRedraw();
            }
        }
    }

Cleanup:
    RRETURN(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnInPlaceDeactivateEx, IOleInPlaceSiteEx
//
//  Synopsis:   Notifies container (us) of object activation
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::OnInPlaceDeactivateEx(BOOL fNoRedraw)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnInPlaceDeactivateEx SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(0))
        RRETURN(E_UNEXPECTED);

    if (!fNoRedraw ||
        (!MyOleSite()->_fWindowlessInplace &&
            MyOleSite()->ActivationChangeRequiresRedraw()))
    {
        MyOleSite()->GetUpdatedLayout()->Invalidate();
    }

    RRETURN(THR(OnInPlaceDeactivate()));
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnInPlaceDeactivate, IOleInPlaceSite
//
//  Synopsis:   Notifies container (us) of object deactivation
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::OnInPlaceDeactivate()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnInPlaceDeactivate SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(0))
        RRETURN(E_UNEXPECTED);

    TraceTag((tagCDoc, "COleSite::CClient::OnInPlaceDeactivate %x", this));

    //
    // If this site is still UIACTIVE fire the OnUIDeactivate event for it.
    // This is protection against ill-behaved objects like WordArt 2.0 which
    // fire OnUIActivate but fail to send OnUIDeactivate if it encounters
    // trouble.  It does send OnInPlaceDeactivate, hence the catch here.
    //

    if (MyOleSite()->_state == OS_UIACTIVE)
    {
        OnUIDeactivate(FALSE);
    }
    
//    Assert(MyOleSite()->_pInPlaceObject); // (IE5 bug 65988) this is not a valid assert - the control can call OnInPlaceDeactivate any time it wants to, even in the middle of inplace activation)

    ClearInterface(&MyOleSite()->_pInPlaceObject);
    MyOleSite()->_fWindowlessInplace = FALSE;
    MyOleSite()->_fUseInPlaceObjectWindowless = FALSE;
    MyOleSite()->_state = OS_RUNNING;

    // Destroy private hwnd. Hack for PhotoSUite 3 (#94834)
    if (MyOleSite()->_hwndPrivate)
    {
#if DBG == 1
        INSTANTCLASSINFO * pici = MyOleSite()->GetInstantClassInfo();
        Assert(pici && (pici->dwCompatFlags & COMPAT_HWNDPRIVATE));
#endif
        Assert(IsWindow(MyOleSite()->_hwndPrivate));
        DestroyWindow(MyOleSite()->_hwndPrivate);
        MyOleSite()->_hwndPrivate = NULL;
    }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnUIActivate, IOleInPlaceSite
//
//  Synopsis:   Notifies container (us) of object UIactivation
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::OnUIActivate()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnUIActivate SSN=0x%x", MyOleSite()->_ulSSN));
    HRESULT     hr = S_OK;
    INSTANTCLASSINFO * pici = MyOleSite()->GetInstantClassInfo();

    //
    // Do not allow ui-activation if we're positioning the control.
    // The wonderful msn company news ocx does this when we
    // first inplace activate it.
    //

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED | VALIDATE_DOC_INPLACE) ||
        MyOleSite()->State() < OS_RUNNING ||
        (pici && (pici->dwCompatFlags & COMPAT_NO_UIACTIVATE)))
    {
        TraceTag((tagError, "Unexpected call to OnUIActivate!"));
        RRETURN(E_UNEXPECTED);
    }

    {
        CLock       Lock(MyOleSite(), OLESITELOCK_TRANSITION);

        hr = Doc()->SetUIActiveElement(MyOleSite());
        if (hr)
            RRETURN(hr);
    }

    MyOleSite()->_state = OS_UIACTIVE;

    if (!MyOleSite()->_fInBecomeCurrent)
    {
        // if, on the other hand, MyOleSite()->!_fInBecomeCurrent were TRUE,
        // we pretend that this is ui-active.  We will complete
        // the activation process in NTYPE_ELEMENT_SETFOCUS notification
        // once SetCurrentElem() succeeds. If, oin the other hand,
        // SetCurrentElem fails, we will reset the state in
        // NTYPE_ELEMENT_SETFOCUSFAILED notification.

        hr = MyOleSite()->BecomeCurrent(0);
        if (hr)
            hr = E_UNEXPECTED;
    }

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnUIDeactivate, IOleInPlaceSite
//
//  Synopsis:   Notifies container (us) of object UIdeactivation
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::OnUIDeactivate(BOOL fUndoable)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnUIDeactivate SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_INPLACE))
        RRETURN(E_UNEXPECTED);

    HRESULT     hr;
    CDoc *      pDoc = Doc();

    Assert (pDoc); // should be checked by IllegalSiteCall

    if (!pDoc->_pInPlace)  // if the doc has deactived already,
        return S_OK;       // nothing more to do

    Assert (pDoc->_pInPlace);

    // Mark ourselves as no longer UIActive:
    pDoc->_pInPlace->_fChildActive = FALSE;
    MyOleSite()->_state = OS_INPLACE;
    MyOleSite()->TakeCapture(FALSE);

    //
    // If we are the ui-active or current site, make sure
    // we clean up the doc's internal state variables.
    //

    if (pDoc->_pElemUIActive == MyOleSite() &&
        !pDoc->_pInPlace->_fChildActivating)
    {
        //
        // If the doc is not deactivating, just make this
        // site's parent current and active.
        //

        if (!pDoc->_pInPlace->_fDeactivating)
        {
            CElement * pElementPL = MyOleSite()->GetFirstBranch()
                                        ? MyOleSite()->GetUpdatedParentLayoutElement()
                                        : NULL;

            // The callee's expect this to no longer be so...
            pDoc->_pElemUIActive = NULL;

            if(pElementPL)
            {
                pElementPL->BecomeCurrentAndActive(0, NULL, NULL, TRUE);
            }
            else
            {
                IGNORE_HR(pDoc->PrimaryRoot()->BecomeCurrentAndActive());
            }
        }
        else
        {
            //
            // Otherwise the doc is deactivating, so just force
            // the rootsite to become current and active.
            // Don't use the BecomeUIActive method on the rootsite
            // because that could cause certain unpleasant side-effects
            //

            pDoc->_pElemUIActive = pDoc->_pElementDefault;

            IGNORE_HR(pDoc->PrimaryRoot()->BecomeCurrent(0));
        }
    }

    hr = S_OK;

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::GetWindowContext, IOleInplaceSite
//
//  Synopsis:   Answer a description of the IP window context
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::GetWindowContext(
    IOleInPlaceFrame ** ppFrame,
    IOleInPlaceUIWindow ** ppDoc,
    LPOLERECT prcPosRect,
    LPOLERECT prcClipRect,
    OLEINPLACEFRAMEINFO * pFI)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::GetWindowContext SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_DOC_INPLACE))
        RRETURN(E_UNEXPECTED);

    HRESULT      hr;
    OLERECT      rcT;
    CDoc *       pDoc = Doc();
    COleLayout * pLayout;

    pLayout = DYNCAST(COleLayout, MyOleSite()->GetUpdatedLayout(GUL_USEFIRSTLAYOUT));

    if (MyOleSite()->_state < OS_LOADED)
    {
        Assert(0 && "Unexpected call to client site.");
        *ppFrame = NULL;
        *ppDoc = NULL;
        SetRectEmpty(prcPosRect);
        SetRectEmpty(prcClipRect);
        memset(pFI, 0, sizeof(OLEINPLACEFRAMEINFO));
        RRETURN(E_UNEXPECTED);
    }

    *ppFrame = NULL;
    *ppDoc = NULL;

    pFI->cb = sizeof(OLEINPLACEFRAMEINFO);
    hr = THR(pDoc->_pInPlace->_pInPlaceSite->GetWindowContext(
            ppFrame,
            ppDoc,
            &rcT,
            &rcT,
            pFI));
    if (hr)
        goto Cleanup;

    if (*ppFrame)
    {
        ReleaseInterface(*ppFrame);
        *ppFrame = &pDoc->_FakeInPlaceFrame;
        (*ppFrame)->AddRef();
        DbgTrackItf(IID_IOleInPlaceFrame, "FrmWnd", TRUE, (void **)ppFrame);
    }

    if (*ppDoc)
    {
        ReleaseInterface(*ppDoc);
        *ppDoc = &pDoc->_FakeDocUIWindow;
        (*ppDoc)->AddRef();
        DbgTrackItf(IID_IOleInPlaceUIWindow, "DocWnd", TRUE, (void **)ppDoc);
    }

    if (pLayout)
        pLayout->GetClientRect(prcPosRect, COORDSYS_GLOBAL);

#ifdef WIN16
    RECTL rcClipRectl;
    MyOleSite()->GetParentLayout()->GetVisibleClientRect(&rcClipRectl);
    CopyRect(prcClipRect, &rcClipRectl);
#else
    if (pLayout)
        pLayout->GetClippedClientRect((CRect*)prcClipRect, COORDSYS_GLOBAL);
#endif

Cleanup:
    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::Scroll, IOleInPlaceSite
//
//  Synopsis:   Object wants us to scroll by sizeScroll, which is in
//              pixels.
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::Scroll(OLESIZE sizeScroll)
{
#if 0
// TODO: Fix this! (brendand)
    int             i;
    POINT           ptBefore;
    POINT           ptAfter;
    SIZEL           sizelScroll;
    CTreeNode *     pNodeParent;
    int             cx;
    HRESULT         hr = S_OK;

    TraceTag((tagOleSiteClient, "COleSite::CClient::Scroll SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_INPLACE  | VALIDATE_DOC_INPLACE))
        RRETURN(E_UNEXPECTED);

    for (pNodeParent = MyOleSite()->GetParentLayoutNode();
            pNodeParent && (sizeScroll.cx || sizeScroll.cy);
            pNodeParent = pNodeParent->GetParentLayoutNode())
    {
        ptBefore.x = MyOleSite()->GetCurLayout()->_rc.left;
        ptBefore.y = MyOleSite()->GetCurLayout()->_rc.top;
        pNodeParent->Doc()->HimetricFromDevice(sizelScroll, sizeScroll);
        hr = THR(pNodeParent->GetCurLayout()->ScrollBy(
                                sizelScroll.cx,
                                sizelScroll.cy,
                                fmScrollActionControlRequest,
                                fmScrollActionControlRequest));
        if (hr)
            goto Cleanup;

        ptAfter.x = MyOleSite()->GetCurLayout()->_rc.left;
        ptAfter.y = MyOleSite()->GetCurLayout()->_rc.top;

        // Calculate the remaining amount to scroll using the positions
        // before and after scrolling. This calculation is tricky because we
        // want to handle the case where the parent site overshoots the scroll
        // amount. This might happen because a datadoc is aligning a row.

        for (i = 0; i < 2; i++)
        {
            cx = (&sizeScroll.cx)[i] + (&ptAfter.x)[i] - (&ptBefore.x)[i];
            if ((&sizeScroll.cx)[i] < 0)
            {
                if (cx > 0)
                    cx = 0;
            }
            else if ((&sizeScroll.cx)[i] > 0)
            {
                if (cx < 0)
                    cx = 0;
            }
            else
            {
                cx = 0;
            }
            (&sizeScroll.cx)[i] = cx;
        }
    }

    if (sizeScroll.cx || sizeScroll.cy)
        hr = THR(Doc()->_pInPlace->_pInPlaceSite->Scroll(sizeScroll));

Cleanup:
    RRETURN(hr);
#else
    RRETURN(S_OK);
#endif
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::DiscardUndoState, IOleInPlaceSite
//
//  Synopsis:   dump any saved undo state for this object
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::DiscardUndoState()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::DiscardUndoState SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_INPLACE))
        RRETURN(E_UNEXPECTED);

    // SITEBUG -- Undo
    // Doc()->SetUndoState(NULL);

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::DeactivateAndUndo, IOleInPlaceSite
//
//  Synopsis:   Object wants us to deactivate it and undo a prior action
//
//  Notes:      The object is asking us to back up, deactivating it
//              and undo (local to our state). We must call UIDeactivate
//              on the object.
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::DeactivateAndUndo()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::DeactivateAndUndo SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_INPLACE))
        RRETURN(E_UNEXPECTED);

    HRESULT     hr;
    CDoc *      pDoc = Doc();
    CDoc::CLock Lock(pDoc);

    // TODO:  Need to handle error result if error from SaveData call in
    //        TransitionToBaselineState.
    MyOleSite()->TransitionToBaselineState(OS_UIACTIVE);

    //
    // This will call Undo on the form's site if the first thing the user did
    // after the form was activated was activate something inside it.  This is
    // because the current undo object will be a CUndoActivate in that
    // situation.
    //

#ifdef NO_EDIT
    hr = S_OK;
#else
    hr = THR(pDoc->EditUndo());
#endif // NO_EDIT
    pDoc->ShowLastErrorInfo(hr);

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnPosRectChange, IOleInPlaceSite
//
//  Synopsis:   object self-move/resize
//
//  Arguments:  prcPos  New Physical Rect
//
//  Notes:      We are being informed that the object wants a new position/size
//              in the document. We should try to be accomodating by laying
//              ourself out differently. This may of course be a recursive
//              process (if we are embedded). When we are done, the InPlace
//              object is notified of the result via SetObjectRects(). The
//              result may be that we have clipped some or all of the new
//              PosRect, or that the new PosRect is zoomed with respect
//              to the request -- in either case the object may choose
//              to deactivate and proceed with an open edit. Notice that
//              this means we may be deactivated if we choose to
//              recursively renegotiate with our InPlaceSite.
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::OnPosRectChange(LPCOLERECT prcPos)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnPosRectChange SSN=0x%x", MyOleSite()->_ulSSN));

    // If we are in the midst of recalculating the size, ignore this call.
    if (MyOleSite()->CElement::TestLock(CElement::ELEMENTLOCK_RECALC))
        return S_OK;

    if (MyOleSite()->IllegalSiteCall(VALIDATE_INPLACE))
        RRETURN(E_UNEXPECTED);

    // if we are in the midst of SetWindowPos or SetObjectRects, ignore this call
    if (Doc()->GetView()->IsChangingRectsFor(MyOleSite()->GetHwnd(), MyOleSite()->_pInPlaceObject))
        RRETURN(E_UNEXPECTED);

    // If we are currently rendering, we would like to still process this call, but at a later
    // time. So, we post a method call to ourselves.
    // The return value is an error since we can not process the call now. Since we will call
    // the SetObjectRects later when we process the posted message, the control is happy.
    if (MyOleSite()->IllegalSiteCall(VALIDATE_NOTRENDERING))
    {
        if (!_prcPending)
        {
            _prcPending = new CRect(*prcPos);

            if ( ! _prcPending )
            {
                RRETURN( E_OUTOFMEMORY );
            }
            
            TraceTag((
                tagOleSiteRect,
                "COleSite::Client::OnPosRectChange: SSN=%x rcPosIn=l=%ld t=%ld r=%ld b=%ld DSOR",
                MyOleSite()->_ulSSN,
                prcPos->left, prcPos->top, prcPos->right, prcPos->bottom));

            IGNORE_HR(GWPostMethodCall(this, 
                ONCALL_METHOD(COleSite::CClient, DeferredOnPosRectChange, deferredonposrectchange), 
                0, 
                TRUE, 
                "COleSite::CClient::DeferredOnPosRectChange"));
        }

        // we have to return here instead of going to the cleanup,
        // since cleanup frees the _prcPending and resets it.
        RRETURN(E_UNEXPECTED);
    }

    HRESULT hr  = S_OK;
    OLERECT rcPos;
    RECT    rcClip;

// TODO: Fix this (brendand)
    rcClip = g_Zero.rc;

    COleLayout * pLayout = DYNCAST(COleLayout, MyOleSite()->GetUpdatedLayout());
    
    //
    // If we are in the middle of COleSite::Move (_fSettingExtent == TRUE),
    // then we ignore the argument (prcPos) and tell the control to move
    // where COleSite::Move was told to move the control.  This protects
    // against calls to OnPosRectChange from the CDK's implementation of
    // IOleObject::SetExtent.
    //

    if (   pLayout 
        && MyOleSite()->TestLock(COleSite::OLESITELOCK_SETEXTENT))
    {
        SIZE    size;

        Doc()->DeviceFromHimetric(size, pLayout->_sizelLast);
        pLayout->GetClientRect(&rcPos, COORDSYS_GLOBAL);
        rcPos.right  = rcPos.left + size.cx;
        rcPos.bottom = rcPos.top + size.cy;

        TraceTag((
            tagOleSiteRect,
            "COleSite::Client::OnPosRectChange: SSN=%x rcPosIn=l=%ld t=%ld r=%ld b=%ld SOR=l=%ld t=%ld r=%ld b=%ld ",
            MyOleSite()->_ulSSN,
            prcPos->left, prcPos->top, prcPos->right, prcPos->bottom,
            rcPos.left, rcPos.top, rcPos.right, rcPos.bottom));

        {
            CView::CLockWndRects lock(Doc()->GetView(), NULL, MyOleSite()->_pInPlaceObject);
            hr = THR_OLEO(MyOleSite()->_pInPlaceObject->SetObjectRects(&rcPos, ENSUREOLERECT(&rcClip)),MyOleSite());
        }
        if (hr)
            goto Cleanup;
    }
    else
    {
        BOOL            fLayoutOnly = FALSE;
        BOOL            fStatic = TRUE;
        CRect           rcPosClient(0,0,0,0);

        if (pLayout)
            pLayout->GetClientRect(&rcPosClient, COORDSYS_GLOBAL);

        //
        // If the site is position is absolute or relative we will allow
        // changes to the location as well as size.  Otherwise only changes
        // to the size are allowed.
        //

        if (!MyOleSite()->IsPositionStatic())
        {
            fStatic = FALSE;
            rcPos = *prcPos;
        }
        else
        {
            rcPos = rcPosClient;
            rcPos.right = rcPos.left + prcPos->right - prcPos->left;
            rcPos.bottom = rcPos.top + prcPos->bottom - prcPos->top;
        }

        //
        // OPTIMIZATION:  If the new size is the same as the old size, only
        //   a relayout needs to be done.  Otherwise a full resizing
        //   a relayout is necessary.
        //
        if (    (rcPos.right - rcPos.left == rcPosClient.Width())
            &&  (rcPos.bottom - rcPos.top == rcPosClient.Height()))
        {
            fLayoutOnly = TRUE;
        }

        TraceTag((
            tagOleSiteRect,
            "COleSite::Client::OnPosRectChange: SSN=%x rcPosIn=l=%ld t=%ld r=%ld b=%ld SOR=l=%ld t=%ld r=%ld b=%ld ",
            MyOleSite()->_ulSSN,
            prcPos->left, prcPos->top, prcPos->right, prcPos->bottom,
            rcPos.left, rcPos.top, rcPos.right, rcPos.bottom));

        {
            CView::CLockWndRects lock(Doc()->GetView(), NULL, MyOleSite()->_pInPlaceObject);
            hr = THR_OLEO(MyOleSite()->_pInPlaceObject->SetObjectRects(
                &rcPos,
                ENSUREOLERECT(&rcClip)),
                MyOleSite());
        }
        if (hr)
            goto Cleanup;

        // convert the rc to parent content relative coordinates
        if (pLayout)
        {
            pLayout->TransformRect(&rcPos, COORDSYS_GLOBAL, COORDSYS_PARENT);

            hr = THR(pLayout->Move(&rcPos, SITEMOVE_NOFIREEVENT));
            if (hr)
                goto Cleanup;
        }

        TraceTag((
            tagOleSiteRect,
            "COleSite::Client::OnPosRectChange: SSN=%x \n\t rcPosIn=l=%ld t=%ld r=%ld b=%ld SOR=l=%ld t=%ld r=%ld b=%ld",
            MyOleSite()->_ulSSN,
            prcPos->left, prcPos->top, prcPos->right, prcPos->bottom,
            rcPos.left, rcPos.top, rcPos.right, rcPos.bottom));

        hr = THR(MyOleSite()->OnPropertyChange(
                DISPID_UNKNOWN,
                ELEMCHNG_CLEARCACHES));
        if (hr)
            goto Cleanup;

        MyOleSite()->ResizeElement();
    }

Cleanup:
    RRETURN(hr);
}


//+----------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnDataChange, IAdviseSink
//
//  Synopsis:   Data-changed event
//
//  Notes:      the memory pointed to by pStgmed is owned by the caller,
//              it must not be free's here (but can of course be copied).
//
//+---------------------------------------------------------------------------

void
COleSite::CClient::OnDataChange(FORMATETC FAR* pFormatetc, STGMEDIUM FAR* pStgmed)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnDataChange SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED))
        return;

    // Ignore calls from DataDoc instances.  Because they are
    // never saved, they can't be dirty.

    MyOleSite()->_fDirty = TRUE;
    Doc()->OnDataChange(FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnViewChange, IAdviseSink
//
//  Synopsis:   View-changed event
//
//+---------------------------------------------------------------------------

void
COleSite::CClient::OnViewChange(DWORD dwAspects, LONG lindex)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnViewChange SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED) || 
        MyOleSite()->IllegalSiteCall(VALIDATE_NOTRENDERING))
        return;

    if ((dwAspects & DVASPECT_CONTENT) && Doc()->_state >= OS_INPLACE)
    {
        if (MyOleSite()->_state < OS_INPLACE)
        {
            COleLayout * pLayout = DYNCAST(COleLayout, MyOleSite()->GetUpdatedLayout());
            if (pLayout)
            pLayout->Invalidate();
        }
    }

    // We only InvalidateColors is the object
    // doesn't know how to use SHDVID_ONCOLORSCHANGE
    //
    if (!MyOleSite()->_fCanDoShColorsChange)
            MyOleSite()->Doc()->InvalidateColors();

    Doc()->OnViewChange(dwAspects);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnRename, IAdviseSink
//
//  Synopsis:   Linking clients need to update source monikers.
//
//+---------------------------------------------------------------------------

void
COleSite::CClient::OnRename(LPMONIKER pmk)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnRenameSSN=0x%x", MyOleSite()->_ulSSN));
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnSave, IAdviseSink
//
//  Synopsis:   Object-saved event
//
//+---------------------------------------------------------------------------

void
COleSite::CClient::OnSave()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnSave SSN=0x%x", MyOleSite()->_ulSSN));
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnClose, IAdviseSink
//
//  Synopsis:   Object-closed event
//
//+---------------------------------------------------------------------------

void
COleSite::CClient::OnClose()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnClose SSN=0x%x", MyOleSite()->_ulSSN));
}


//+---------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnLinkSrcChange, IAdviseSink2
//
//  Synopsis:   Object-closed event
//
//---------------------------------------------------------------
void
COleSite::CClient::OnLinkSrcChange(IMoniker * pmk)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnLinkSrcChange SSN=0x%x", MyOleSite()->_ulSSN));
}


//+---------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnViewStatusChange, IAdviseSinkEx
//
//  Synopsis:   View Status flags has changed
//
//---------------------------------------------------------------
void
COleSite::CClient::OnViewStatusChange(DWORD dwViewStatus)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnViewStatusChange SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED))
        return;

    MyOleSite()->SetViewStatusFlags(dwViewStatus);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::CanWindowlessActivate, IOleInPlaceSiteWindowless
//
//  Synopsis:   object is asking if it can in-place activate without a window
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::CanWindowlessActivate()
{
    INSTANTCLASSINFO * pici;
    
    TraceTag((tagOleSiteClient, "COleSite::CClient::CanWindowlessActivate SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(0))
        RRETURN(E_UNEXPECTED);

#if DBG==1
    if (IsTagEnabled(tagOleSiteClientNoWindowless))
        return S_FALSE;
#endif
    pici = MyOleSite()->GetInstantClassInfo();

    if (!pici)
        return S_FALSE;
        
    return (pici->dwCompatFlags & COMPAT_DISABLEWINDOWLESS) ?
                    S_FALSE :
                    S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::GetCapture, IOleInPlaceSiteWindowless
//
//  Synopsis:   object wants to know if it still has mouse capture
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::GetCapture()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::GetCapture SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE | VALIDATE_DOC_INPLACE))
        RRETURN(E_UNEXPECTED);

    CDoc *  pDoc = Doc();

    return (pDoc->HasCapture(MyOleSite()) ? S_OK : S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::SetCapture, IOleInPlaceSiteWindowless
//
//  Synopsis:   object wants to capture the mouse, or release capture
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::SetCapture(BOOL fCapture)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::SetCapture SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        RRETURN(E_UNEXPECTED);

    MyOleSite()->TakeCapture(fCapture);
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::GetFocus, IOleInPlaceSiteWindowless
//
//  Synopsis:   object wants to know if it still has focus
//
//+---------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::GetFocus()
{
    CDoc * pDoc = Doc();

    TraceTag((tagOleSiteClient, "COleSite::CClient::GetFocus SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE | VALIDATE_DOC_INPLACE))
        RRETURN(E_UNEXPECTED);

    return (pDoc->_pElemCurrent == MyOleSite() &&
            ::GetFocus() == pDoc->_pInPlace->_hwnd) ? S_OK : S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::SetFocus, IOleInPlaceSiteWindowless
//
//  Synopsis:   Windowless control wants to grab the focus.
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::SetFocus(BOOL fFocus)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::SetFocus SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE | VALIDATE_DOC_INPLACE))
        RRETURN(E_UNEXPECTED);

    HRESULT hr = S_OK;
    CDoc *  pDoc = Doc();

    if (fFocus)
    {
        if (S_OK != MyOleSite()->BecomeCurrent(0))
        {
            RRETURN(E_FAIL);
        }

        if (::GetFocus() != pDoc->_pInPlace->_hwnd)
        {
            // This will cause WM_SETFOCUS to be sent to this site.
            ::SetFocus(pDoc->_pInPlace->_hwnd);
        }
        else
        {
            // Focus already on the form. Need to force message to control.

            LRESULT lResult;

            hr = THR_OLEO(((IOleInPlaceObjectWindowless *)MyOleSite()->_pInPlaceObject)->
                OnWindowMessage(
                    WM_SETFOCUS,
                    0,
                    0,
                    &lResult),MyOleSite());
        }
    }
    else if (pDoc->_pElemCurrent == MyOleSite() &&
             ::GetFocus() == pDoc->_pInPlace->_hwnd)
    {
        ::SetFocus(NULL);
    }

    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnDefWindowMessage, IOleInPlaceSiteWindowless
//
//  Synopsis:   Implement default behavior for messages. Can be called by
//              object as an alternative to returning S_FALSE from
//              IOleInPlaceObjectWindowless::OnWindowMessage.
//
//  Arguments:  see OnWindowMessage
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::OnDefWindowMessage(UINT msg, WPARAM wParam, LPARAM lParam, LRESULT *plResult)
{
    TraceTag((tagOleSiteClient,
        "COleSite::CClient::OnDefWindowMessage SSN=0x%x msg=0x%x wParam=0x%x lParam=0x%x",
        MyOleSite()->_ulSSN,
        msg, wParam, lParam));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE | VALIDATE_DOC_INPLACE))
        RRETURN(E_UNEXPECTED);

    CMessage Message(NULL, msg, wParam, lParam);
    HRESULT hr;
    CDoc *  pDoc = Doc();

    hr = THR( Message.SetNodeHit( MyOleSite()->GetFirstBranch() ) );
    if( hr )
        goto Cleanup;

    // Tell the form that this message came from a control inside it.
    pDoc->_pInPlace->_fBubbleInsideOut = TRUE;
    hr = THR( MyOleSite()->CElement::HandleMessage( &Message ) );
    pDoc->_pInPlace->_fBubbleInsideOut = FALSE;
    // TODO (carled) plResult is not set by this routine. eventually we will want to
    // put in   *plResult = Message.lResult;
    // but for now...
    *plResult = hr;
Cleanup:
    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Function:   COleSite::CClient::GetDC, IOleInPlaceSiteWindowless
//
//  Synopsis:   Provides hDC for windowless object to paint itself.
//
//  Arguments:  [prc]     -- rect which object wants to draw in pixels
//              [dwFlags] -- flags to determine hDC returned by container
//              [phDC]    -- pointer to returned hDC
//
//  Returns:    HRESULT (S_OK if valid HDC, OLE_E_NESTEDPAINT if already painting)
//
//  Notes:      if [prc] is NULL, assume object wants to draw entire rect.
//
//              Following is the description of how we process depending on
//              various flags.
//
//                              no OFFSCREEN              OFFSCREEN
//
//              no PAINTBKGND   pre: exclude opaque       pre: nothing
//              (opaque)        areas in front
//
//                              post: paint transparent   post: paint all in
//                              areas in front            front
//
//
//              PAINTBKGND      pre: exclude opaque       pre: paint all
//              (transparent)   areas in front. paint     behind, also
//                              all sites behind, also    paint form.
//                              paint form.
//
//                              post: paint transparent   post: paint all
//                              areas in front            in front
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::GetDC(LPCRECT prc, DWORD dwFlags, HDC * phDC)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::GetDC SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        RRETURN(E_UNEXPECTED);

    CRect   rcClip;

    //  restrict paint area to the control's rectangle
    //
    COleLayout * pLayout = DYNCAST(COleLayout, MyOleSite()->GetUpdatedLayout());

    Assert(pLayout);

    pLayout->GetClippedRect(&rcClip, COORDSYS_GLOBAL);
    
    if (prc)
    {
        rcClip.IntersectRect(*prc);
    }
    
    if (!rcClip.IsEmpty())
    {
        // if the caller isn't going to use this DC for drawing, we can safely
        // return a DC
        if (dwFlags & OLEDC_NODRAW)
        {
            return pLayout->GetDC(&rcClip, dwFlags, phDC);
        }
        
        // just invalidate and fail, and we will draw the control later
        pLayout->Invalidate(rcClip, COORDSYS_GLOBAL);
    }
    
    return E_FAIL;
}


//+---------------------------------------------------------------------------
//
//  Function:   COleSite::CClient::ReleaseDC, IOleInPlaceSiteWindowless
//
//  Synopsis:   Signals end of paint for object
//
//  Arguments:  [hDC] -- hDC returned by object
//
//  Returns:    HRESULT (S_OK)
//
//  Notes:      See notes for GetDC
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::ReleaseDC(HDC hDC)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::ReleaseDC SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        RRETURN(E_UNEXPECTED);

    COleLayout * pLayout = DYNCAST(COleLayout, MyOleSite()->GetUpdatedLayout());
    Assert(pLayout);

    RRETURN(pLayout->ReleaseDC(hDC));
}


//+---------------------------------------------------------------------------
//
//  Function:   COleSite::CClient::InvalidateRect, IOleInPlaceSiteWindowless
//
//  Synopsis:   Invalidates a given rectangular area within object's rectangle
//
//  Arguments:  [prc]    -- rectangle to invalidate
//              [fErase] -- repaint the background?
//
//  Returns:    HRESULT (S_OK)
//
//  Notes:      [prc] is assumed to be in Window Pixel coordinates.
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::InvalidateRect(LPCRECT prc, BOOL fErase)
{
    COleSite *  pOleSite = MyOleSite();
    CLayout *   pLayout  = pOleSite->GetUpdatedLayout();

    if (!pLayout)
        return S_OK;

    TraceTag((tagOleSiteClient, "COleSite::CClient::InvalidateRect SSN=0x%x", MyOleSite()->_ulSSN));

    if (pOleSite->IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        RRETURN(E_UNEXPECTED);


    // make sure the doc flag for disabling tiled paint is set
    if (pOleSite->_fSurface)
    {
        pOleSite->Doc()->_fDisableTiledPaint = TRUE;
    }

    // prc is in global coordinates, so invalidate appropriately
    if (prc)
    {
        CRect   rc = *prc;

        pLayout->TransformRect(&rc, COORDSYS_GLOBAL, COORDSYS_FLOWCONTENT);
        pLayout->Invalidate(&rc);
    }
    else
        pLayout->Invalidate(prc);

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   COleSite::CClient::InvalidateRgn, IOleInPlaceSiteWindowless
//
//  Synopsis:   Invalidates a given region within object's rectangle
//
//  Arguments:  [hrgn]    -- region to invalidate
//              [fErase]  -- repaint the background?
//
//  Returns:    HRESULT (S_OK)
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::InvalidateRgn(HRGN hrgn, BOOL fErase)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::InvalidateRgn SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        RRETURN(E_UNEXPECTED);

    // make sure the doc flag for disabling tiled paint is set
    if (MyOleSite()->_fSurface)
    {
        MyOleSite()->Doc()->_fDisableTiledPaint = TRUE;
    }

// TODO: This region is in global coordinates and must be transformed to local before calling CLayout (brendand)
    MyOleSite()->GetUpdatedLayout()->Invalidate(hrgn);

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   COleSite::CClient::ScrollRect, IOleInPlaceSiteWindowless
//
//  Synopsis:   Scrolls the site window as requested
//
//  Arguments:  [dx]        --
//              [dy]        --
//              [prcScroll] --
//              [prcClip]   --
//
//  Returns:    HRESULT (S_OK)
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::ScrollRect(
    int dx, int dy, LPCRECT prcScroll, LPCRECT prcClip )
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::ScrollRect SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE | VALIDATE_DOC_INPLACE))
        RRETURN(E_UNEXPECTED);

    HRESULT         hr = S_OK;
#if 0
// TODO: Fix this! (brendand)
    RECT            rcParent;
    RECT            rcScroll;
    RECT            rcClip;
    RECT            rcSite;
    BOOL            fAboveMe;
    CDoc *          pDoc = Doc();

    Assert(pDoc->_pInPlace);

    // Get the visible site rect in device units

    rcSite = MyOleSite()->GetCurLayout()->_rc;
    MyOleSite()->GetParentLayout()->GetVisibleClientRect(&rcParent);
    IntersectRect(&rcSite, &rcSite, &rcParent);

    // If not scroll rect was passed in, then scroll the entire site

    rcScroll = prcScroll ? * prcScroll : rcSite;

    // If no clip rect was passed in, then set  it to the scroll rect

    rcClip = prcClip ? * prcClip : rcScroll;

    // Make sure rects are contained within the client site.  If either
    // does not intersect the site, then do nothing.

    if (!IntersectRect(&rcScroll, &rcScroll, &rcSite) ||
        !IntersectRect(&rcClip,   &rcClip,   &rcSite))
    {
        goto Cleanup;
    }

    // If this site has a transparent control, then just invalidate.

    if (!MyOleSite()->GetCurLayout()->_fOpaque)
        goto InvalidateClip;

    // Check to see if another site above us in the zorder intersects.
    // If so, then invalidate.

    fAboveMe = FALSE;
    if (pDoc->_pSiteRoot->GetCurLayout()->CheckLayoutIntersect(
                                     MyOleSite()->GetCurLayout(),
                                     &fAboveMe,
                                     SI_ABOVE))
        goto InvalidateClip;

    Assert(pDoc->_pInPlace->_hwnd);

    ::ScrollWindowEx(
        pDoc->_pInPlace->_hwnd,
        dx, dy, &rcScroll, &rcClip, 0, 0, SW_INVALIDATE);

Cleanup:
#endif

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   COleSite::CClient::AdjustRect, IOleInPlaceSiteWindowless
//
//  Synopsis:   Invalidates object's rectangle
//
//  Arguments:  [prc] -- return clipped rectangle here.
//
//  Returns:    HRESULT (S_OK)
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::AdjustRect(LPRECT prc)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::AdjustRect SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_WINDOWLESSINPLACE))
        RRETURN(E_UNEXPECTED);

#if 0
//    TODO : fix later, what is this doing ?
    CSite *         pSiteLoop;
    RECT            rcSiteOpaque;
    POINT           pt;

    if (!MyOleSite()->_fWindowlessInplace)
    {
        Assert(0 && "Unexpected call to client site.");
        RRETURN(E_UNEXPECTED);
    }

    Assert(prc);

    pt.x = prc->left;
    pt.y = prc->top;

    while ((pSiteLoop = iterBackToFront.Next()) != MyOleSite()) {};

    while ((pSiteLoop = iterBackToFront.Next()) != NULL)
    {
        if (pSiteLoop->HitTestRect(&(MyOleSite()->_rc)) == HTC_YES)
        {
            if (pSiteLoop->GetOpaqueRect(&rcSiteOpaque))
            {
                if (!IntersectRect(prc, prc, &rcSiteOpaque))
                {
                    prc->left = prc->right = pt.x;
                    prc->top = prc->bottom = pt.y;
                    return S_FALSE;
                }
            }
        }
        else
        {
            iterBackToFront.SkipChildren(pSiteLoop);
        }
    }
#endif
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnControlInfoChanged, IOleControlSite
//
//  Synopsis:   notification from the control of change
//
//  Returns:    S_OK iff sucessful, else error
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::OnControlInfoChanged()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnControlInfoChanged SSN=0x%x", MyOleSite()->_ulSSN));

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::LockInPlaceActive, IOleControlSite
//
//  Synopsis:   Increments or decrements an in-place active lock
//              count.  If non-zero, then the form will ensure that
//              this site is not deactivated.
//
//  Arguments:  [fLock] -- Increment if TRUE
//
//  Returns:    S_OK iff sucessful, else error
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::LockInPlaceActive(BOOL fLock)
{
    TraceTag((tagOleSiteClient,
        "COleSite::CClient::LockInPlaceActive SSN=0x%x fLock=%s",
        MyOleSite()->_ulSSN,
        fLock ? "TRUE" : "FALSE"));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_INPLACE))
        RRETURN(E_UNEXPECTED);

    HRESULT             hr;
    IOleControlSite *   pOCS;

    //  Part of the contract of locking the control in the in-place
    //    active state is that the form itself needs to remain
    //    in-place active.  We can't do this unless the form's
    //    site supports the LockInPlaceActive method

    hr = THR(Doc()->_pClientSite->QueryInterface(
            IID_IOleControlSite,
            (void **) &pOCS));
    if (hr)
        RRETURN(E_FAIL);

    hr = THR(pOCS->LockInPlaceActive(fLock));
    if (hr)
        goto Cleanup;

    if (fLock)
    {
        if (MyOleSite()->_cLockInPlaceActive == MAX_LOCK_INPLACEACTIVE)
        {
            hr = E_FAIL;
            goto Cleanup;
        }

        MyOleSite()->_cLockInPlaceActive++;
    }
    else
    {
        if (MyOleSite()->_cLockInPlaceActive == 0)
        {
            hr = E_INVALIDARG;
            goto Cleanup;
        }

        MyOleSite()->_cLockInPlaceActive--;
    }

    //  Changing the lock count may change the proper state for
    //    this control; this call moves the control to the
    //    proper state.  Note that errors are ignored.

    IGNORE_HR(MyOleSite()->TransitionToCorrectState());

Cleanup:
    pOCS->Release();

    RRETURN(hr);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::GetExtendedControl, IOleControlSite
//
//  Synopsis:   Answer pointer to the XObject for this control
//
//  Arguments:  [ppUnk] -- where to return pointer
//
//  Returns:    S_OK iff sucessful, else error
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::GetExtendedControl(IDispatch **ppDisp)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::GetExtendedControl SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_ATTACHED))
        RRETURN(E_UNEXPECTED);

    RRETURN(THR_OLEO(MyOleSite()->QueryInterface(IID_IDispatch,(void **)ppDisp),MyOleSite()));
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::TransformCoords, IOleControlSite
//
//  Synopsis:   Answer pointer to the XObject for this control
//
//  Arguments:  [ppUnk] -- where to return pointer
//
//  Returns:    S_OK iff sucessful, else error
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::TransformCoords(POINTL *pptl, POINTF *pptf, DWORD dwFlags)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::TransformCoords SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_ATTACHED))
        RRETURN(E_UNEXPECTED);

     if (dwFlags & XFORMCOORDS_HIMETRICTOCONTAINER)
     {
         pptf->x = HPixFromHimetric(pptl->x);
         pptf->y = VPixFromHimetric(pptl->y);
     }
     else
     {
         pptl->x = HimetricFromHPix(pptf->x + 0.5);
         pptl->y = HimetricFromVPix(pptf->y + 0.5);
     }

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::TranslateAccelerator, IOleControlSite
//
//  Synopsis:   Called by our embedded control if it doesn't process an
//              accelerator message.
//
//  Arguments:  [pmsg] -- Message to translate
//
//  Returns:    S_OK if handled, S_FALSE if not, error HRESULT on error.
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::TranslateAccelerator(LPMSG pmsg, DWORD grfModifiers)
{
    TraceTag((tagOleSiteClient,
        "COleSite::CClient::TranslateAccelerator SSN=0x%x message=0x%x",
        MyOleSite()->_ulSSN,
        pmsg->message));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED))
        RRETURN(E_UNEXPECTED);

    CMessage Message(pmsg);

    // Give host a chance to handle it first
    if (Doc()->HostTranslateAccelerator(pmsg) == S_OK)
        return S_OK;

    // We get many messages besides the keystroke messages here.  This is
    // expected and used by the other site types, but for ole sites we
    // need to ensure only keystroke messages are handled and propagated
    // here.  -Tom

    switch (pmsg->message)
    {
    case WM_KEYDOWN:
    case WM_KEYUP:
    case WM_SYSKEYDOWN:
    case WM_SYSKEYUP:
        break;
    default:
        return S_FALSE;
    }

    //
    // Backspace is a navigation keystroke for us.  Block this out
    // for any ocx, as long as alt & ctrl aren't depressed either.
    //

    if (Message.wParam == VK_BACK &&
        !(Message.dwKeyState & (MK_CONTROL | MK_ALT)))
        return S_FALSE;

    CTreeNode * pNodeParentSite = MyOleSite()->GetUpdatedParentLayoutNode();

    if (!pNodeParentSite)
        return S_FALSE;

    RRETURN1(THR(pNodeParentSite->Doc()->PumpMessage(&Message, pNodeParentSite, TRUE)), S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::RequestUIActivate, IOleInPlaceSiteEx
//
//  Synopsis:   Notifies the container that the control intends to transition
//              to the UIActivate state
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::RequestUIActivate()
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::RequestUIActivate SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED))
        RRETURN(E_UNEXPECTED);

    RRETURN1(MyOleSite()->IsFocussable(0) ? S_OK : S_FALSE, S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnFocus, IOleControlSite
//
//  Synopsis:   Notifies the container that the control grabbed the focus.
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::OnFocus(BOOL)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnFocus SSN=0x%x", MyOleSite()->_ulSSN));

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::ShowPropertyFrame, IOleControlSite
//
//  Synopsis:   allows a container to hook the control's display of a
//              property frame.  Whenever the control wants to display
//              a property frame, it calls this method.  If this method
//              returns S_OK, then this site has displayed the property
//              frame, and the control should take no further action.
//              Otherwise, the control should proceed with displaying
//              its own property frame.
//
//  Returns:    S_OK or propagates error code.
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::ShowPropertyFrame()
{
#ifdef NO_PROPERTY_PAGE
    return S_OK;
#else
    TraceTag((tagOleSiteClient, "COleSite::CClient::ShowPropertyFrame SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED | VALIDATE_DOC_ALIVE))
        RRETURN(E_UNEXPECTED);


    HRESULT hr = E_FAIL;
    IOleControlSite * pCtrlSite = NULL;
    CDoc *  pDoc = Doc();

    //
    // Allow Trident host to handle this call
    //

    // First, give inplace object a chance to provide control site.
    if (pDoc->_pInPlace && pDoc->_pInPlace->_pInPlaceSite)
    {
        pDoc->_pInPlace->_pInPlaceSite->QueryInterface(IID_IOleControlSite, (void **) &pCtrlSite);
    }

    // if this fails, try the client site.
    if (!pCtrlSite && pDoc->_pClientSite)
    {
        pDoc->_pClientSite->QueryInterface(IID_IOleControlSite, (void **) &pCtrlSite);
    }

    if (pCtrlSite)
    {
        hr = pCtrlSite->ShowPropertyFrame();
        ReleaseInterface(pCtrlSite);
    }

    RRETURN(hr);
#endif // NO_PROPERTY_PAGE
}

//+------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::QueryStatus, IOleCommandTarget
//
//  Synopsis:   Delegates QS of commands upward
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

HRESULT
COleSite::CClient::QueryStatus(
                GUID * pguidCmdGroup,
                ULONG cCmds,
                MSOCMD rgCmds[],
                MSOCMDTEXT * pcmdtext)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::QueryStatus SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED | VALIDATE_DOC_SITE))
        RRETURN(OLECMDERR_E_UNKNOWNGROUP);

    HRESULT hr;

    hr = THR_NOTRACE(CTQueryStatus(
        Doc()->_pClientSite,
        pguidCmdGroup,
        cCmds,
        rgCmds,
        pcmdtext));

    if (hr == E_NOINTERFACE)
        hr = OLECMDERR_E_UNKNOWNGROUP;

    // Disable Office documents in frameset from showing/hiding toolbars.

    if (pguidCmdGroup == NULL)
    {
        for (UINT i = 0; i < cCmds; i++)
        {
            if (rgCmds[i].cmdID == OLECMDID_HIDETOOLBARS)
            {
                rgCmds[i].cmdf = 0;
            }
        }
    }

    RRETURN(hr);
}






//+------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::Exec, IOleCommandTarget
//
//  Synopsis:   Delegates Exec of commands upward
//
//  Returns:    HRESULT (STDMETHOD)
//
//-------------------------------------------------------------------------

HRESULT
COleSite::CClient::Exec(
                GUID * pguidCmdGroup,
                DWORD nCmdID,
                DWORD nCmdexecopt,
                VARIANTARG * pvarargIn,
                VARIANTARG * pvarargOut)
{
    HRESULT hr;

    TraceTag((tagOleSiteClient, "COleSite::CClient::Exec SSN=0x%x", MyOleSite()->_ulSSN));

// New code to implement refresh for HTML OSP
    
    if ((pguidCmdGroup == NULL) && (nCmdID == OLECMDID_HTTPEQUIV))
    {
        extern BOOL ParseRefreshContent(LPCTSTR pchContent,
                                        UINT * puiDelay,
                                        LPTSTR pchUrlBuf,
                                        UINT cchUrlBuf);
        COleSite *pOleSite = MyOleSite();
        if (pOleSite->_iRefreshTime == 0)
        {
            LPCTSTR psz = pvarargIn->bstrVal;
            if (_tcsnipre(_T("refresh:"), 8, psz, -1))
            {
                UINT uiRefresh = 0;
                TCHAR ach[pdlUrlLen];
                psz += 8;

                if (ParseRefreshContent(psz, &uiRefresh, ach, ARRAY_SIZE(ach)))
                {
                    pOleSite->ClearRefresh();
                    pOleSite->_iRefreshTime = uiRefresh * 1000;
                    if (ach[0])
                        pOleSite->_pstrRefreshURL = SysAllocString(ach);
                }
            }
        }

        return S_OK;
    }

    if ((pguidCmdGroup == NULL) && (nCmdID == OLECMDID_HTTPEQUIV_DONE))
        return S_OK;

    if (IDMFromCmdID(pguidCmdGroup, nCmdID) == IDM_SHDV_ONCOLORSCHANGE)
    {
        MyOleSite()->Doc()->InvalidateColors();
        return S_OK;
    }

// End Refresh code

    if (MyOleSite()->IllegalSiteCall(VALIDATE_LOADED | VALIDATE_DOC_SITE))
        RRETURN(OLECMDERR_E_UNKNOWNGROUP);

    //  Doc aggregates the Enter/Leaving scripts of embeddings with its own
    //  and fires these execs on aggregate entry/leaving
    if (pguidCmdGroup && *pguidCmdGroup == CGID_ShellDocView)
    {
        Assert(MyOleSite()->GetWindowedMarkupContext());
        Assert(MyOleSite()->GetWindowedMarkupContext()->GetWindowPending());
        if (nCmdID == SHDVID_NODEACTIVATENOW)
        {
            RRETURN(THR(MyOleSite()->GetWindowedMarkupContext()->GetWindowPending()->Window()->EnterScript()));
        }
        else if (nCmdID == SHDVID_DEACTIVATEMENOW)
        {
            RRETURN(THR(MyOleSite()->GetWindowedMarkupContext()->GetWindowPending()->Window()->LeaveScript()));
        }
    }
    else if (pguidCmdGroup == NULL && nCmdID == OLECMDID_HIDETOOLBARS)
    {
        // Disable Office documents in frameset from showing/hiding toolbars.

        RRETURN(OLECMDERR_E_DISABLED);
    }

    if (pguidCmdGroup && IsEqualGUID(CGID_DocHostCmdPriv, *pguidCmdGroup))
    {
        return OLECMDERR_E_NOTSUPPORTED;
    }

    if (MyOleSite()->_fViewLinkedWebOC && pguidCmdGroup &&
        IsEqualGUID(CGID_Explorer, *pguidCmdGroup) &&
        nCmdID == SBCMDID_MIXEDZONE )
    {
        pvarargIn = NULL;
    }
   

    hr = THR_NOTRACE(CTExec(Doc()->_pClientSite,
                            pguidCmdGroup,
                            nCmdID,
                            nCmdexecopt,
                            pvarargIn,
                            pvarargOut));

    if (hr == E_NOINTERFACE)
    {
        hr = OLECMDERR_E_UNKNOWNGROUP;
    }

    RRETURN1(hr, S_FALSE);
}





//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::QueryService, IServiceProvider
//
//  Synopsis:   Return any requested services that the site supports,
//              otherwise delegate to the form.  The form will delegate to
//              its site.
//
//  Arguments:  [guidService] -- GUID of requested service
//              [iid]         -- Interface to return on requested service
//              [ppv]         -- Place to put requested service
//
//  Returns:    HRESULT (STDMETHOD)
//
//----------------------------------------------------------------------------

EXTERN_C const GUID CLSID_HTMLFrameBase;
EXTERN_C const GUID CLSID_HTMLIFrame;
EXTERN_C const GUID CLSID_HTMLObjectElement;

STDMETHODIMP
COleSite::CClient::QueryService(REFGUID guidService,
                                REFIID iid,
                                void ** ppv)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::QueryService SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_ATTACHED))
        RRETURN(E_NOINTERFACE);

    *ppv = NULL;

    OLESITE_TAG osTag = MyOleSite()->OlesiteTag();

    if (IsEqualGUID(guidService, CLSID_HTMLFrameBase))
    {
        if (MyOleSite()->_fViewLinkedWebOC)
        {
            // NOTE that we're not AddRef()'ing the return
            // value.  Callers beware!
            *ppv = MyOleSite();
            return S_OK;
        }
        else
            return E_NOINTERFACE;
    }
    else if (IsEqualGUID(guidService, CLSID_HTMLObjectElement))
    {
        // NOTE that we're not AddRef()'ing the return
        // value.  Callers beware!
        *ppv = MyOleSite();
        return S_OK;
    }
    else if (IsEqualGUID(guidService, SID_SBindHost))
    {
        RRETURN (THR(QueryInterface(iid, ppv)));
    }
    else if (osTag != OSTAG_FRAME &&
             osTag != OSTAG_IFRAME &&
             IsEqualGUID(guidService, CLSID_HTMLDocument))
    {
        //
        // (anandra) No bubbling of private QS's if not in a frame.
        //

        RRETURN(E_NOINTERFACE);
    }
    else if (IsEqualGUID(guidService, IID_IHTMLDialog))
    {
        // (alexz) (anandra) IID_IHTMLDialog is our private interface and it is used by document /
        // script window to find out if they are hosted in / aggregated by CHtmlDlg. No objects
        // hosted inside olesite can make QueryService for IID_IHTMLDialog except WebBrowser OC. WebBrowser OC
        // makes the QS in case if it contains Trident doc / window inside. In that case, however, we should
        // block the propagation of QS so that the doc / window will not get confused thinking that
        // they are hosted in / aggregated by html dlg.
        //
        // the way to get to this codepath: bring up an html dialog with <iframe> inside.

        RRETURN(E_NOINTERFACE);
    }
    else if (MyOleSite()->IsInMarkup())
    {
        // delegate the queryservice call to the document object.

        CDocument * pDocument = MyOleSite()->GetMarkup()->Document();
        
        if (pDocument)
        {
            RRETURN(pDocument->QueryService(guidService, iid, ppv));
        }
    }

    RRETURN(Doc()->QueryService(guidService, iid, ppv));
}

//+---------------------------------------------------------------------------
//
// Member:      COleSite::CClient::GetTypeInfoCount
//
// Synopsis:    Returns the number of typeinfos available on this object
//
// Arguments:   [pctinfo] - The number of typeinfos
//
//----------------------------------------------------------------------------

HRESULT
COleSite::CClient::GetTypeInfoCount(UINT FAR *pcTinfo)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::GetTypeInfoCount SSN=0x%x", MyOleSite()->_ulSSN));

    *pcTinfo = 0;
    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::GetIDsOfNames
//
// Synopsis:    Returns the ID of the given name
//
// Arguments:   [riid]      - Interface id to interpret names for
//              [rgszNames] - Array of names
//              [cNames]    - Number of names in [rgszNames]
//              [lcid]      - Locale ID to interpret names in
//              [rgdispid]  - Returned array of IDs
//
//----------------------------------------------------------------------------

HRESULT
COleSite::CClient::GetIDsOfNames(
        REFIID      riid,
        TCHAR **    rgszNames,
        UINT        cNames,
        LCID        lcid,
        DISPID *    rgdispid)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::GetIDsOfNames SSN=0x%x", MyOleSite()->_ulSSN));

    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::GetTypeInfo, IDispatch
//
//  Synopsis:   As per IDispatch
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo ** ppTI)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::GetTypeInfo SSN=0x%x", MyOleSite()->_ulSSN));

    RRETURN(E_NOTIMPL);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::Invoke, IDispatch
//
// Synopsis:    Provides access to properties and members of the control
//
// Arguments:   [dispidMember] - Member id to invoke
//              [riid]         - Interface ID being accessed
//              [wFlags]       - Flags describing context of call
//              [pdispparams]  - Structure containing arguments
//              [pvarResult]   - Place to put result
//              [pexcepinfo]   - Pointer to exception information struct
//              [puArgErr]     - Indicates which argument is incorrect
//
//----------------------------------------------------------------------------

HRESULT
COleSite::CClient::Invoke(DISPID dispidMember,
        REFIID riid,
        LCID lcid,
        WORD wFlags,
        DISPPARAMS FAR *pdispparams,
        VARIANT FAR *pvarResult,
        EXCEPINFO FAR *pexcepinfo,
        UINT FAR *puArgErr)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::Invoke SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_ATTACHED))
        RRETURN(E_UNEXPECTED);

    HRESULT hr = S_OK;

    if (puArgErr)
        *puArgErr = 0;

    if (pexcepinfo)
        memset(pexcepinfo, 0, sizeof(*pexcepinfo));

    if (!pdispparams)
        RRETURN(E_INVALIDARG);

    if (pvarResult != NULL)
        VariantInit(pvarResult);

    if (wFlags & DISPATCH_PROPERTYGET)
    {
        if (pvarResult == NULL)
            return E_INVALIDARG;

        hr = MyOleSite()->GetAmbientProp(dispidMember, pvarResult);
    }
    else if (wFlags & DISPATCH_PROPERTYPUT)
    {
        hr = DISP_E_MEMBERNOTFOUND;

        if (pdispparams->cArgs < 1)
            return E_INVALIDARG;
    }
    else
        hr = DISP_E_MEMBERNOTFOUND;

    return hr;
}

#ifndef NO_DATABINDING
//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::GetCursor (IBoundObjectSite)
//
//  Synopsis:   Called by Data consuming control to get its ICursor
//
//  Arguments:  dispid      dispid of data-bound property
//              ppCursor    where to put the cursor pointer
//                          may not be NULL
//              ppcidOut    If a simple-valued binding (not Cursor-valued,
//                          where to a return an ICursor DBCOLUMNID for
//                          which column boun to.
//
//  Returns:    S_OK        success
//              E_INVALIDARG
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::GetCursor(DISPID dispid,
        ICursor **ppCursor,
        LPVOID FAR* ppcidOut)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::GetCursor SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_ATTACHED))
        RRETURN(E_UNEXPECTED);

    HRESULT     hr = E_INVALIDARG;
    DISPID      dispidCursor = MyOleSite()->GetClassInfo()->dispidCursor;

    if (ppCursor == NULL)
        goto Cleanup;

    *ppCursor = NULL;

    // ppcidOut should only be NULL, otherwise error.
    if (ppcidOut != NULL)
    {
        *ppcidOut = NULL;
        goto Cleanup;
    }

    if (dispid == dispidCursor)
    {
        // we only support ICursor binding on the tag itself;
        //  any binding set on PARAMs uses IDataSource.
        DBMEMBERS *pdbm = MyOleSite()->GetDBMembers();
        CDataSourceBinder *pdsbBinder;

        if (!pdbm)
            goto Error;

        pdsbBinder = pdbm->GetBinder(ID_DBIND_DEFAULT);
        if (!pdsbBinder)
            goto Error;

        hr = pdsbBinder->GetICursor(ppCursor);
    }

Cleanup:
    RRETURN(hr);

Error:
    hr = E_FAIL;
    goto Cleanup;
}
#endif

//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::::OnChanged
//
//  Synopsis:   Forwards to the connection point.
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::OnChanged(DISPID dispid)
{
    TraceTag((tagOleSiteClient,
        "COleSite::CClient::OnChanged SSN=0x%x dispid=0x%x",
        MyOleSite()->_ulSSN,
        dispid));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_ATTACHED))
        RRETURN(E_UNEXPECTED);

    HRESULT hr;

    hr = THR(MyOleSite()->OnControlChanged(dispid));
    if (hr == S_FALSE)
        hr = S_OK;
    else if (!hr)
        hr = THR(MyOleSite()->FireOnChanged(dispid));

    RRETURN(hr);
}



//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::OnRequestEdit
//
//  Synopsis:   Forwards to the connection point.
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::OnRequestEdit(DISPID dispid)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::OnRequestEdit SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_ATTACHED))
        RRETURN(E_UNEXPECTED);

    HRESULT hr;

    hr = THR(MyOleSite()->OnControlRequestEdit(dispid));
    if (!hr)
    {
        hr = THR(MyOleSite()->FireRequestEdit(dispid));
    }

    RRETURN1(hr, S_FALSE);
}


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::CClient::ValidateSecureUrl
//
//  Synopsis:   Forwards to the connection point.
//
//----------------------------------------------------------------------------

STDMETHODIMP
COleSite::CClient::ValidateSecureUrl(BOOL* pfAllow, OLECHAR* pchUrlInQuestion, DWORD dwFlags)
{
    TraceTag((tagOleSiteClient, "COleSite::CClient::ValidateSecureUrl SSN=0x%x", MyOleSite()->_ulSSN));

    if (MyOleSite()->IllegalSiteCall(VALIDATE_ATTACHED))
        RRETURN(E_UNEXPECTED);

    HRESULT   hr;
    TCHAR     cBuf[pdlUrlLen];
    TCHAR   * pchNewUrl = cBuf;
    CDoc    * pDoc = MyOleSite()->Doc();
    BOOL      fPendingRoot = FALSE;
    CMarkup * pMarkup = NULL;

    hr = THR(CMarkup::ExpandUrl(
            NULL, pchUrlInQuestion, ARRAY_SIZE(cBuf), pchNewUrl, MyOleSite()));
    if (hr)
        goto Cleanup;

    if (MyOleSite()->IsInMarkup())
    {
        pMarkup = MyOleSite()->GetMarkup();
        fPendingRoot = pMarkup->IsPendingRoot();
    }
    else
    {
        pMarkup = pDoc->PrimaryMarkup();
    }

    Assert(pMarkup);

    *pfAllow = (pMarkup->ValidateSecureUrl(fPendingRoot, pchNewUrl,
        !!(SUHV_PROMPTBEFORENO & dwFlags),
        !!(SUHV_SILENTYES & dwFlags),
        !!(SUHV_UNSECURESOURCE & dwFlags)));

Cleanup:
    RRETURN(hr);
}

//----------------------------------------------------------------------------
//  Member:     COleSite::CClient::DeferredOnPosRectChange
//
//  Synopsis:   OnPostRectChange posts a call to itself through this method,
//              if we are in the rendering /view updating phase when OnPosRectChange
//              is called by the control site.
//              This member recalls the OnPosRectChange.
//----------------------------------------------------------------------------
void
COleSite::CClient::DeferredOnPosRectChange( DWORD_PTR dwContext )
{
    if (!_prcPending)
        return;

    THR(OnPosRectChange( _prcPending ));

    delete _prcPending;
    _prcPending = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetcore\mshtml\src\site\ole\olesitdb.cxx ===
//---------------------------------------------------------------------------
//
//  Microsoft Forms
//  Copyright (C) Microsoft Corporation, 1994-1995
//
//  File:       olesitdb.cxx
//
//  Contents:   databinding functions for COleSite class
//
//  Classes:    COleSite
//
//----------------------------------------------------------------------------

#include <headers.hxx>

#pragma MARK_DATA(__FILE__)
#pragma MARK_CODE(__FILE__)
#pragma MARK_CONST(__FILE__)

#ifndef X_BINDER_HXX_
#define X_BINDER_HXX_
#include <binder.hxx>       // for cdatasourceprovider
#endif

#ifndef X_FORMKRNL_HXX_
#define X_FORMKRNL_HXX_
#include <formkrnl.hxx>     // for safetylevel in safety.hxx (via olesite.hxx)
#endif

#ifndef X_OLESITE_HXX_
#define X_OLESITE_HXX_
#include "olesite.hxx"
#endif

#ifndef X_EVNTPRM_HXX_
#define X_EVNTPRM_HXX_
#include <evntprm.hxx>      // for eventparam (needed by fire_ondata*)
#endif

#ifndef X_ELEMDB_HXX_
#define X_ELEMDB_HXX_
#include <elemdb.hxx>       // for DBSPEC
#endif

#ifndef NO_DATABINDING
#ifndef X_VBCURSOR_VBDSC_H_
#define X_VBCURSOR_VBDSC_H_
#include <vbcursor/vbdsc.h> // for iid_ivbdsc
#endif

#ifndef X_SIMPDATA_H_
#define X_SIMPDATA_H_
#include <simpdata.h>
#endif

#ifndef X_MSDATSRC_H_
#define X_MSDATSRC_H_
#include <msdatsrc.h>
#endif

#ifndef X_TEAROFF_HXX_
#define X_TEAROFF_HXX_
#include <tearoff.hxx>
#endif

#endif // ndef NO_DATABINDING


//+---------------------------------------------------------------------------
//
//  Member:     COleSite::GetInterfaceProperty (protected member)
//
//  Synopsis:   Get an interface-valued property of the control.
//
//----------------------------------------------------------------------------

HRESULT
COleSite::GetInterfaceProperty(UINT uGetOffset, DISPID dispid, REFIID riid,
                                IUnknown** ppunk)
{
    HR